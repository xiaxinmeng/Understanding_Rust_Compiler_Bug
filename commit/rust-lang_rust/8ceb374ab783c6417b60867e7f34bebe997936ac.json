{"sha": "8ceb374ab783c6417b60867e7f34bebe997936ac", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhjZWIzNzRhYjc4M2M2NDE3YjYwODY3ZTdmMzRiZWJlOTk3OTM2YWM=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-11-21T23:42:55Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-11-26T16:25:00Z"}, "message": "librustc: Remove non-procedure uses of `do` from librustc, librustdoc,\nand librustpkg.", "tree": {"sha": "5045a1aab7ec9c4cd362cb6ec331bd0d972a317d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5045a1aab7ec9c4cd362cb6ec331bd0d972a317d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8ceb374ab783c6417b60867e7f34bebe997936ac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8ceb374ab783c6417b60867e7f34bebe997936ac", "html_url": "https://github.com/rust-lang/rust/commit/8ceb374ab783c6417b60867e7f34bebe997936ac", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8ceb374ab783c6417b60867e7f34bebe997936ac/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "efc512362b0f2ae200ef079e3566c6b158a857cc", "url": "https://api.github.com/repos/rust-lang/rust/commits/efc512362b0f2ae200ef079e3566c6b158a857cc", "html_url": "https://github.com/rust-lang/rust/commit/efc512362b0f2ae200ef079e3566c6b158a857cc"}], "stats": {"total": 2658, "additions": 1311, "deletions": 1347}, "files": [{"sha": "adc3712bf0f97b157e8c22aaf0c06b9f93355fc8", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=8ceb374ab783c6417b60867e7f34bebe997936ac", "patch": "@@ -72,13 +72,13 @@ pub fn WriteOutputFile(\n         Output: &Path,\n         FileType: lib::llvm::FileType) {\n     unsafe {\n-        do Output.with_c_str |Output| {\n+        Output.with_c_str(|Output| {\n             let result = llvm::LLVMRustWriteOutputFile(\n                     Target, PM, M, Output, FileType);\n             if !result {\n                 llvm_err(sess, ~\"Could not write output\");\n             }\n-        }\n+        })\n     }\n }\n \n@@ -130,12 +130,12 @@ pub mod jit {\n             for cratepath in r.iter() {\n                 debug!(\"linking: {}\", cratepath.display());\n \n-                do cratepath.with_c_str |buf_t| {\n+                cratepath.with_c_str(|buf_t| {\n                     if !llvm::LLVMRustLoadCrate(manager, buf_t) {\n                         llvm_err(sess, ~\"Could not link\");\n                     }\n                     debug!(\"linked: {}\", cratepath.display());\n-                }\n+                })\n             }\n \n             // We custom-build a JIT execution engine via some rust wrappers\n@@ -149,9 +149,9 @@ pub mod jit {\n             // Next, we need to get a handle on the _rust_main function by\n             // looking up it's corresponding ValueRef and then requesting that\n             // the execution engine compiles the function.\n-            let fun = do \"_rust_main\".with_c_str |entry| {\n+            let fun = \"_rust_main\".with_c_str(|entry| {\n                 llvm::LLVMGetNamedFunction(m, entry)\n-            };\n+            });\n             if fun.is_null() {\n                 llvm::LLVMDisposeExecutionEngine(ee);\n                 llvm::LLVMContextDispose(c);\n@@ -248,9 +248,9 @@ pub mod write {\n             llvm::LLVMInitializeMipsAsmParser();\n \n             if sess.opts.save_temps {\n-                do output.with_extension(\"no-opt.bc\").with_c_str |buf| {\n+                output.with_extension(\"no-opt.bc\").with_c_str(|buf| {\n                     llvm::LLVMWriteBitcodeToFile(llmod, buf);\n-                }\n+                })\n             }\n \n             configure_llvm(sess);\n@@ -263,9 +263,9 @@ pub mod write {\n             };\n             let use_softfp = sess.opts.debugging_opts & session::use_softfp != 0;\n \n-            let tm = do sess.targ_cfg.target_strs.target_triple.with_c_str |T| {\n-                do sess.opts.target_cpu.with_c_str |CPU| {\n-                    do sess.opts.target_feature.with_c_str |Features| {\n+            let tm = sess.targ_cfg.target_strs.target_triple.with_c_str(|T| {\n+                sess.opts.target_cpu.with_c_str(|CPU| {\n+                    sess.opts.target_feature.with_c_str(|Features| {\n                         llvm::LLVMRustCreateTargetMachine(\n                             T, CPU, Features,\n                             lib::llvm::CodeModelDefault,\n@@ -274,9 +274,9 @@ pub mod write {\n                             true,\n                             use_softfp\n                         )\n-                    }\n-                }\n-            };\n+                    })\n+                })\n+            });\n \n             // Create the two optimizing pass managers. These mirror what clang\n             // does, and are by populated by LLVM's default PassManagerBuilder.\n@@ -288,7 +288,7 @@ pub mod write {\n             // If we're verifying or linting, add them to the function pass\n             // manager.\n             let addpass = |pass: &str| {\n-                do pass.with_c_str |s| { llvm::LLVMRustAddPass(fpm, s) }\n+                pass.with_c_str(|s| llvm::LLVMRustAddPass(fpm, s))\n             };\n             if !sess.no_verify() { assert!(addpass(\"verify\")); }\n             if sess.lint_llvm()  { assert!(addpass(\"lint\"));   }\n@@ -300,11 +300,11 @@ pub mod write {\n             }\n \n             for pass in sess.opts.custom_passes.iter() {\n-                do pass.with_c_str |s| {\n+                pass.with_c_str(|s| {\n                     if !llvm::LLVMRustAddPass(mpm, s) {\n                         sess.warn(format!(\"Unknown pass {}, ignoring\", *pass));\n                     }\n-                }\n+                })\n             }\n \n             // Finally, run the actual optimization passes\n@@ -316,9 +316,9 @@ pub mod write {\n             llvm::LLVMDisposePassManager(mpm);\n \n             if sess.opts.save_temps {\n-                do output.with_extension(\"bc\").with_c_str |buf| {\n+                output.with_extension(\"bc\").with_c_str(|buf| {\n                     llvm::LLVMWriteBitcodeToFile(llmod, buf);\n-                }\n+                })\n             }\n \n             if sess.opts.jit {\n@@ -337,14 +337,14 @@ pub mod write {\n                 match output_type {\n                     output_type_none => {}\n                     output_type_bitcode => {\n-                        do output.with_c_str |buf| {\n+                        output.with_c_str(|buf| {\n                             llvm::LLVMWriteBitcodeToFile(llmod, buf);\n-                        }\n+                        })\n                     }\n                     output_type_llvm_assembly => {\n-                        do output.with_c_str |output| {\n+                        output.with_c_str(|output| {\n                             llvm::LLVMRustPrintModule(cpm, llmod, output)\n-                        }\n+                        })\n                     }\n                     output_type_assembly => {\n                         WriteOutputFile(sess, tm, cpm, llmod, output, lib::llvm::AssemblyFile);\n@@ -415,9 +415,9 @@ pub mod write {\n             add(*arg);\n         }\n \n-        do llvm_args.as_imm_buf |p, len| {\n+        llvm_args.as_imm_buf(|p, len| {\n             llvm::LLVMRustSetLLVMOptions(len as c_int, p);\n-        }\n+        })\n     }\n \n     unsafe fn populate_llvm_passes(fpm: lib::llvm::PassManagerRef,\n@@ -736,7 +736,7 @@ pub fn sanitize(s: &str) -> ~str {\n \n             _ => {\n                 let mut tstr = ~\"\";\n-                do char::escape_unicode(c) |c| { tstr.push_char(c); }\n+                char::escape_unicode(c, |c| tstr.push_char(c));\n                 result.push_char('$');\n                 result.push_str(tstr.slice_from(1));\n             }"}, {"sha": "d8d868d847325aa4bc83bb0ae8e20c64c95e213c", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=8ceb374ab783c6417b60867e7f34bebe997936ac", "patch": "@@ -123,10 +123,10 @@ pub fn build_configuration(sess: Session) ->\n // Convert strings provided as --cfg [cfgspec] into a crate_cfg\n fn parse_cfgspecs(cfgspecs: ~[~str], demitter: @diagnostic::Emitter)\n                   -> ast::CrateConfig {\n-    do cfgspecs.move_iter().map |s| {\n+    cfgspecs.move_iter().map(|s| {\n         let sess = parse::new_parse_sess(Some(demitter));\n         parse::parse_meta_from_source_str(@\"cfgspec\", s.to_managed(), ~[], sess)\n-    }.collect::<ast::CrateConfig>()\n+    }).collect::<ast::CrateConfig>()\n }\n \n pub enum input {"}, {"sha": "1602cbb6a9bafb2f7e466e6f94eaff56073b997c", "filename": "src/librustc/front/config.rs", "status": "modified", "additions": 13, "deletions": 19, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fconfig.rs?ref=8ceb374ab783c6417b60867e7f34bebe997936ac", "patch": "@@ -20,9 +20,7 @@ struct Context<'self> {\n // any items that do not belong in the current configuration\n pub fn strip_unconfigured_items(crate: ast::Crate) -> ast::Crate {\n     let config = crate.config.clone();\n-    do strip_items(crate) |attrs| {\n-        in_cfg(config, attrs)\n-    }\n+    strip_items(crate, |attrs| in_cfg(config, attrs))\n }\n \n impl<'self> fold::ast_fold for Context<'self> {\n@@ -68,14 +66,12 @@ fn filter_view_item<'r>(cx: &Context, view_item: &'r ast::view_item)\n }\n \n fn fold_mod(cx: &Context, m: &ast::_mod) -> ast::_mod {\n-    let filtered_items = do m.items.iter().filter_map |a| {\n+    let filtered_items = m.items.iter().filter_map(|a| {\n         filter_item(cx, *a).and_then(|x| cx.fold_item(x))\n-    }.collect();\n-    let filtered_view_items = do m.view_items.iter().filter_map |a| {\n-        do filter_view_item(cx, a).map |x| {\n-            cx.fold_view_item(x)\n-        }\n-    }.collect();\n+    }).collect();\n+    let filtered_view_items = m.view_items.iter().filter_map(|a| {\n+        filter_view_item(cx, a).map(|x| cx.fold_view_item(x))\n+    }).collect();\n     ast::_mod {\n         view_items: filtered_view_items,\n         items: filtered_items\n@@ -96,11 +92,9 @@ fn fold_foreign_mod(cx: &Context, nm: &ast::foreign_mod) -> ast::foreign_mod {\n                            .iter()\n                            .filter_map(|a| filter_foreign_item(cx, *a))\n                            .collect();\n-    let filtered_view_items = do nm.view_items.iter().filter_map |a| {\n-        do filter_view_item(cx, a).map |x| {\n-            cx.fold_view_item(x)\n-        }\n-    }.collect();\n+    let filtered_view_items = nm.view_items.iter().filter_map(|a| {\n+        filter_view_item(cx, a).map(|x| cx.fold_view_item(x))\n+    }).collect();\n     ast::foreign_mod {\n         abis: nm.abis,\n         view_items: filtered_view_items,\n@@ -147,12 +141,12 @@ fn filter_stmt(cx: &Context, stmt: @ast::Stmt) -> Option<@ast::Stmt> {\n }\n \n fn fold_block(cx: &Context, b: &ast::Block) -> ast::Block {\n-    let resulting_stmts = do b.stmts.iter().filter_map |a| {\n+    let resulting_stmts = b.stmts.iter().filter_map(|a| {\n         filter_stmt(cx, *a).and_then(|stmt| cx.fold_stmt(stmt))\n-    }.collect();\n-    let filtered_view_items = do b.view_items.iter().filter_map |a| {\n+    }).collect();\n+    let filtered_view_items = b.view_items.iter().filter_map(|a| {\n         filter_view_item(cx, a).map(|x| cx.fold_view_item(x))\n-    }.collect();\n+    }).collect();\n     ast::Block {\n         view_items: filtered_view_items,\n         stmts: resulting_stmts,"}, {"sha": "4d1998c8fd722f4f9e3c778b2d1a1a571777fea1", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=8ceb374ab783c6417b60867e7f34bebe997936ac", "patch": "@@ -118,13 +118,13 @@ impl fold::ast_fold for TestHarnessGenerator {\n         fn nomain(cx: @mut TestCtxt, item: @ast::item) -> @ast::item {\n             if !*cx.sess.building_library {\n                 @ast::item {\n-                    attrs: do item.attrs.iter().filter_map |attr| {\n+                    attrs: item.attrs.iter().filter_map(|attr| {\n                         if \"main\" != attr.name() {\n                             Some(*attr)\n                         } else {\n                             None\n                         }\n-                    }.collect(),\n+                    }).collect(),\n                     .. (*item).clone()\n                 }\n             } else {\n@@ -172,10 +172,10 @@ fn generate_test_harness(sess: session::Session, crate: ast::Crate)\n fn strip_test_functions(crate: ast::Crate) -> ast::Crate {\n     // When not compiling with --test we should not compile the\n     // #[test] functions\n-    do config::strip_items(crate) |attrs| {\n+    config::strip_items(crate, |attrs| {\n         !attr::contains_name(attrs, \"test\") &&\n         !attr::contains_name(attrs, \"bench\")\n-    }\n+    })\n }\n \n fn is_test_fn(cx: @mut TestCtxt, i: @ast::item) -> bool {\n@@ -232,13 +232,13 @@ fn is_bench_fn(i: @ast::item) -> bool {\n }\n \n fn is_ignored(cx: @mut TestCtxt, i: @ast::item) -> bool {\n-    do i.attrs.iter().any |attr| {\n+    i.attrs.iter().any(|attr| {\n         // check ignore(cfg(foo, bar))\n         \"ignore\" == attr.name() && match attr.meta_item_list() {\n             Some(ref cfgs) => attr::test_cfg(cx.config, cfgs.iter().map(|x| *x)),\n             None => true\n         }\n-    }\n+    })\n }\n \n fn should_fail(i: @ast::item) -> bool {"}, {"sha": "b82bc38fbd9645284d79c020130c1f03d875a526", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=8ceb374ab783c6417b60867e7f34bebe997936ac", "patch": "@@ -261,9 +261,9 @@ pub fn run_compiler(args: &[~str], demitter: @diagnostic::Emitter) {\n     let odir = matches.opt_str(\"out-dir\").map(|o| Path::new(o));\n     let ofile = matches.opt_str(\"o\").map(|o| Path::new(o));\n     let cfg = build_configuration(sess);\n-    let pretty = do matches.opt_default(\"pretty\", \"normal\").map |a| {\n+    let pretty = matches.opt_default(\"pretty\", \"normal\").map(|a| {\n         parse_pretty(sess, a)\n-    };\n+    });\n     match pretty {\n       Some::<PpMode>(ppm) => {\n         pretty_print_input(sess, cfg, &input, ppm);\n@@ -345,7 +345,7 @@ pub fn monitor(f: proc(@diagnostic::Emitter)) {\n         task_builder.opts.stack_size = Some(STACK_SIZE);\n     }\n \n-    match do task_builder.try {\n+    match task_builder.try(|| {\n         let ch = ch_capture.clone();\n         // The 'diagnostics emitter'. Every error, warning, etc. should\n         // go through this function.\n@@ -368,7 +368,7 @@ pub fn monitor(f: proc(@diagnostic::Emitter)) {\n         // Due reasons explain in #7732, if there was a jit execution context it\n         // must be consumed and passed along to our parent task.\n         back::link::jit::consume_engine()\n-    } {\n+    }) {\n         result::Ok(_) => { /* fallthrough */ }\n         result::Err(_) => {\n             // Task failed without emitting a fatal diagnostic\n@@ -403,9 +403,6 @@ pub fn main() {\n \n pub fn main_args(args: &[~str]) -> int {\n     let owned_args = args.to_owned();\n-    do monitor |demitter| {\n-        run_compiler(owned_args, demitter);\n-    }\n-\n-    return 0;\n+    monitor(|demitter| run_compiler(owned_args, demitter));\n+    0\n }"}, {"sha": "5de9a3894215c836ec9f5551ce7ed214cd41cacb", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=8ceb374ab783c6417b60867e7f34bebe997936ac", "patch": "@@ -1844,9 +1844,9 @@ pub struct TargetData {\n }\n \n pub fn mk_target_data(string_rep: &str) -> TargetData {\n-    let lltd = do string_rep.with_c_str |buf| {\n+    let lltd = string_rep.with_c_str(|buf| {\n         unsafe { llvm::LLVMCreateTargetData(buf) }\n-    };\n+    });\n \n     TargetData {\n         lltd: lltd,"}, {"sha": "bc15312d98e18cdfbe076ed568580fdcaca02981", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=8ceb374ab783c6417b60867e7f34bebe997936ac", "patch": "@@ -159,9 +159,9 @@ pub fn get_dep_hashes(cstore: &CStore) -> ~[@str] {\n         });\n     }\n \n-    let sorted = do extra::sort::merge_sort(result) |a, b| {\n+    let sorted = extra::sort::merge_sort(result, |a, b| {\n         (a.name, a.vers, a.hash) <= (b.name, b.vers, b.hash)\n-    };\n+    });\n \n     debug!(\"sorted:\");\n     for x in sorted.iter() {"}, {"sha": "cd4afdff91ef55bf8ee32cce13b98e28733e890e", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 95, "deletions": 96, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=8ceb374ab783c6417b60867e7f34bebe997936ac", "patch": "@@ -62,15 +62,15 @@ fn lookup_hash(d: ebml::Doc, eq_fn: |&[u8]| -> bool, hash: u64) ->\n     let belt = tag_index_buckets_bucket_elt;\n \n     let mut ret = None;\n-    do reader::tagged_docs(tagged_doc.doc, belt) |elt| {\n+    reader::tagged_docs(tagged_doc.doc, belt, |elt| {\n         let pos = u64_from_be_bytes(*elt.data, elt.start, 4) as uint;\n         if eq_fn(elt.data.slice(elt.start + 4, elt.end)) {\n             ret = Some(reader::doc_at(d.data, pos).doc);\n             false\n         } else {\n             true\n         }\n-    };\n+    });\n     ret\n }\n \n@@ -168,10 +168,10 @@ fn item_visibility(item: ebml::Doc) -> ast::visibility {\n \n fn item_method_sort(item: ebml::Doc) -> char {\n     let mut ret = 'r';\n-    do reader::tagged_docs(item, tag_item_trait_method_sort) |doc| {\n+    reader::tagged_docs(item, tag_item_trait_method_sort, |doc| {\n         ret = doc.as_str_slice()[0] as char;\n         false\n-    };\n+    });\n     ret\n }\n \n@@ -181,10 +181,10 @@ fn item_symbol(item: ebml::Doc) -> ~str {\n \n fn item_parent_item(d: ebml::Doc) -> Option<ast::DefId> {\n     let mut ret = None;\n-    do reader::tagged_docs(d, tag_items_data_parent_item) |did| {\n+    reader::tagged_docs(d, tag_items_data_parent_item, |did| {\n         ret = Some(reader::with_doc_data(did, parse_def_id));\n         false\n-    };\n+    });\n     ret\n }\n \n@@ -200,19 +200,19 @@ fn item_def_id(d: ebml::Doc, cdata: Cmd) -> ast::DefId {\n }\n \n fn get_provided_source(d: ebml::Doc, cdata: Cmd) -> Option<ast::DefId> {\n-    do reader::maybe_get_doc(d, tag_item_method_provided_source).map |doc| {\n+    reader::maybe_get_doc(d, tag_item_method_provided_source).map(|doc| {\n         translate_def_id(cdata, reader::with_doc_data(doc, parse_def_id))\n-    }\n+    })\n }\n \n fn each_reexport(d: ebml::Doc, f: |ebml::Doc| -> bool) -> bool {\n     reader::tagged_docs(d, tag_items_data_item_reexport, f)\n }\n \n fn variant_disr_val(d: ebml::Doc) -> Option<ty::Disr> {\n-    do reader::maybe_get_doc(d, tag_disr_val).and_then |val_doc| {\n-        do reader::with_doc_data(val_doc) |data| { u64::parse_bytes(data, 10u) }\n-    }\n+    reader::maybe_get_doc(d, tag_disr_val).and_then(|val_doc| {\n+        reader::with_doc_data(val_doc, |data| u64::parse_bytes(data, 10u))\n+    })\n }\n \n fn doc_type(doc: ebml::Doc, tcx: ty::ctxt, cdata: Cmd) -> ty::t {\n@@ -231,10 +231,10 @@ fn doc_transformed_self_ty(doc: ebml::Doc,\n                            tcx: ty::ctxt,\n                            cdata: Cmd) -> Option<ty::t>\n {\n-    do reader::maybe_get_doc(doc, tag_item_method_transformed_self_ty).map |tp| {\n+    reader::maybe_get_doc(doc, tag_item_method_transformed_self_ty).map(|tp| {\n         parse_ty_data(*tp.data, cdata.cnum, tp.start, tcx,\n                       |_, did| translate_def_id(cdata, did))\n-    }\n+    })\n }\n \n pub fn item_type(_item_id: ast::DefId, item: ebml::Doc,\n@@ -258,22 +258,22 @@ fn item_ty_param_defs(item: ebml::Doc,\n                       tag: uint)\n                       -> @~[ty::TypeParameterDef] {\n     let mut bounds = ~[];\n-    do reader::tagged_docs(item, tag) |p| {\n+    reader::tagged_docs(item, tag, |p| {\n         let bd = parse_type_param_def_data(\n             *p.data, p.start, cdata.cnum, tcx,\n             |_, did| translate_def_id(cdata, did));\n         bounds.push(bd);\n         true\n-    };\n+    });\n     @bounds\n }\n \n fn item_region_param_defs(item_doc: ebml::Doc,\n                           tcx: ty::ctxt,\n                           cdata: Cmd)\n                           -> @[ty::RegionParameterDef] {\n-    do at_vec::build(None) |push| {\n-        do reader::tagged_docs(item_doc, tag_region_param_def) |rp_doc| {\n+    at_vec::build(None, |push| {\n+        reader::tagged_docs(item_doc, tag_region_param_def, |rp_doc| {\n             let ident_str_doc = reader::get_doc(rp_doc,\n                                                 tag_region_param_def_ident);\n             let ident = item_name(tcx.sess.intr(), ident_str_doc);\n@@ -284,8 +284,8 @@ fn item_region_param_defs(item_doc: ebml::Doc,\n             push(ty::RegionParameterDef { ident: ident,\n                                           def_id: def_id });\n             true\n-        };\n-    }\n+        });\n+    })\n }\n \n fn item_ty_param_count(item: ebml::Doc) -> uint {\n@@ -298,11 +298,11 @@ fn item_ty_param_count(item: ebml::Doc) -> uint {\n fn enum_variant_ids(item: ebml::Doc, cdata: Cmd) -> ~[ast::DefId] {\n     let mut ids: ~[ast::DefId] = ~[];\n     let v = tag_items_data_item_variant;\n-    do reader::tagged_docs(item, v) |p| {\n+    reader::tagged_docs(item, v, |p| {\n         let ext = reader::with_doc_data(p, parse_def_id);\n         ids.push(ast::DefId { crate: cdata.cnum, node: ext.node });\n         true\n-    };\n+    });\n     return ids;\n }\n \n@@ -313,7 +313,7 @@ pub fn item_path(item_doc: ebml::Doc) -> ast_map::path {\n     let len = reader::doc_as_u32(len_doc) as uint;\n \n     let mut result = vec::with_capacity(len);\n-    do reader::docs(path_doc) |tag, elt_doc| {\n+    reader::docs(path_doc, |tag, elt_doc| {\n         if tag == tag_path_elt_mod {\n             let str = elt_doc.as_str_slice();\n             result.push(ast_map::path_mod(token::str_to_ident(str)));\n@@ -333,7 +333,7 @@ pub fn item_path(item_doc: ebml::Doc) -> ast_map::path {\n             // ignore tag_path_len element\n         }\n         true\n-    };\n+    });\n \n     return result;\n }\n@@ -412,14 +412,14 @@ pub fn get_trait_def(cdata: Cmd,\n     let mut bounds = ty::EmptyBuiltinBounds();\n     // Collect the builtin bounds from the encoded supertraits.\n     // FIXME(#8559): They should be encoded directly.\n-    do reader::tagged_docs(item_doc, tag_item_super_trait_ref) |trait_doc| {\n+    reader::tagged_docs(item_doc, tag_item_super_trait_ref, |trait_doc| {\n         // NB. Bypasses real supertraits. See get_supertraits() if you wanted them.\n         let trait_ref = doc_trait_ref(trait_doc, tcx, cdata);\n-        do tcx.lang_items.to_builtin_kind(trait_ref.def_id).map |bound| {\n+        tcx.lang_items.to_builtin_kind(trait_ref.def_id).map(|bound| {\n             bounds.add(bound);\n-        };\n+        });\n         true\n-    };\n+    });\n     ty::TraitDef {\n         generics: ty::Generics {type_param_defs: tp_defs,\n                                 region_param_defs: rp_defs},\n@@ -455,9 +455,9 @@ pub fn get_impl_trait(cdata: Cmd,\n                       tcx: ty::ctxt) -> Option<@ty::TraitRef>\n {\n     let item_doc = lookup_item(id, cdata.data);\n-    do reader::maybe_get_doc(item_doc, tag_item_trait_ref).map |tp| {\n+    reader::maybe_get_doc(item_doc, tag_item_trait_ref).map(|tp| {\n         @doc_trait_ref(tp, tcx, cdata)\n-    }\n+    })\n }\n \n pub fn get_impl_vtables(cdata: Cmd,\n@@ -479,13 +479,13 @@ pub fn get_impl_method(intr: @ident_interner, cdata: Cmd, id: ast::NodeId,\n                        name: ast::Ident) -> Option<ast::DefId> {\n     let items = reader::get_doc(reader::Doc(cdata.data), tag_items);\n     let mut found = None;\n-    do reader::tagged_docs(find_item(id, items), tag_item_impl_method) |mid| {\n+    reader::tagged_docs(find_item(id, items), tag_item_impl_method, |mid| {\n         let m_did = reader::with_doc_data(mid, parse_def_id);\n         if item_name(intr, find_item(m_did.node, items)) == name {\n             found = Some(translate_def_id(cdata, m_did));\n         }\n         true\n-    };\n+    });\n     found\n }\n \n@@ -512,15 +512,15 @@ pub fn def_like_to_def(def_like: DefLike) -> ast::Def {\n pub fn each_lang_item(cdata: Cmd, f: |ast::NodeId, uint| -> bool) -> bool {\n     let root = reader::Doc(cdata.data);\n     let lang_items = reader::get_doc(root, tag_lang_items);\n-    do reader::tagged_docs(lang_items, tag_lang_items_item) |item_doc| {\n+    reader::tagged_docs(lang_items, tag_lang_items_item, |item_doc| {\n         let id_doc = reader::get_doc(item_doc, tag_lang_items_item_id);\n         let id = reader::doc_as_u32(id_doc) as uint;\n         let node_id_doc = reader::get_doc(item_doc,\n                                           tag_lang_items_item_node_id);\n         let node_id = reader::doc_as_u32(node_id_doc) as ast::NodeId;\n \n         f(node_id, id)\n-    }\n+    })\n }\n \n struct EachItemContext<'self> {\n@@ -624,7 +624,7 @@ impl<'self> EachItemContext<'self> {\n         let mut continue_ = true;\n \n         // Iterate over all children.\n-        do reader::tagged_docs(item_doc, tag_mod_child) |child_info_doc| {\n+        reader::tagged_docs(item_doc, tag_mod_child, |child_info_doc| {\n             let child_def_id = reader::with_doc_data(child_info_doc,\n                                                      parse_def_id);\n             let child_def_id = translate_def_id(self.cdata, child_def_id);\n@@ -670,14 +670,14 @@ impl<'self> EachItemContext<'self> {\n                 }\n             }\n             continue_\n-        };\n+        });\n \n         if !continue_ {\n             return false\n         }\n \n         // Iterate over reexports.\n-        do each_reexport(item_doc) |reexport_doc| {\n+        each_reexport(item_doc, |reexport_doc| {\n             let def_id_doc = reader::get_doc(\n                 reexport_doc,\n                 tag_items_data_item_reexport_def_id);\n@@ -723,7 +723,7 @@ impl<'self> EachItemContext<'self> {\n             }\n \n             continue_\n-        };\n+        });\n \n         continue_\n     }\n@@ -737,7 +737,7 @@ fn each_child_of_item_or_crate(intr: @ident_interner,\n                                           ast::Ident,\n                                           ast::visibility|) {\n     // Iterate over all children.\n-    let _ = do reader::tagged_docs(item_doc, tag_mod_child) |child_info_doc| {\n+    let _ = reader::tagged_docs(item_doc, tag_mod_child, |child_info_doc| {\n         let child_def_id = reader::with_doc_data(child_info_doc,\n                                                  parse_def_id);\n         let child_def_id = translate_def_id(cdata, child_def_id);\n@@ -767,23 +767,23 @@ fn each_child_of_item_or_crate(intr: @ident_interner,\n         }\n \n         true\n-    };\n+    });\n \n     // As a special case, iterate over all static methods of\n     // associated implementations too. This is a bit of a botch.\n     // --pcwalton\n-    let _ = do reader::tagged_docs(item_doc,\n-                                   tag_items_data_item_inherent_impl)\n-            |inherent_impl_def_id_doc| {\n+    let _ = reader::tagged_docs(item_doc,\n+                                tag_items_data_item_inherent_impl,\n+                                |inherent_impl_def_id_doc| {\n         let inherent_impl_def_id = item_def_id(inherent_impl_def_id_doc,\n                                                cdata);\n         let items = reader::get_doc(reader::Doc(cdata.data), tag_items);\n         match maybe_find_item(inherent_impl_def_id.node, items) {\n             None => {}\n             Some(inherent_impl_doc) => {\n-                let _ = do reader::tagged_docs(inherent_impl_doc,\n-                                               tag_item_impl_method)\n-                        |impl_method_def_id_doc| {\n+                let _ = reader::tagged_docs(inherent_impl_doc,\n+                                            tag_item_impl_method,\n+                                            |impl_method_def_id_doc| {\n                     let impl_method_def_id =\n                         reader::with_doc_data(impl_method_def_id_doc,\n                                               parse_def_id);\n@@ -812,15 +812,15 @@ fn each_child_of_item_or_crate(intr: @ident_interner,\n                     }\n \n                     true\n-                };\n+                });\n             }\n         }\n \n         true\n-    };\n+    });\n \n     // Iterate over all reexports.\n-    let _ = do each_reexport(item_doc) |reexport_doc| {\n+    let _ = each_reexport(item_doc, |reexport_doc| {\n         let def_id_doc = reader::get_doc(reexport_doc,\n                                          tag_items_data_item_reexport_def_id);\n         let child_def_id = reader::with_doc_data(def_id_doc,\n@@ -854,7 +854,7 @@ fn each_child_of_item_or_crate(intr: @ident_interner,\n         }\n \n         true\n-    };\n+    });\n }\n \n /// Iterates over each child of the given item.\n@@ -1002,11 +1002,11 @@ fn get_explicit_self(item: ebml::Doc) -> ast::explicit_self_ {\n fn item_impl_methods(intr: @ident_interner, cdata: Cmd, item: ebml::Doc,\n                      tcx: ty::ctxt) -> ~[@ty::Method] {\n     let mut rslt = ~[];\n-    do reader::tagged_docs(item, tag_item_impl_method) |doc| {\n+    reader::tagged_docs(item, tag_item_impl_method, |doc| {\n         let m_did = reader::with_doc_data(doc, parse_def_id);\n         rslt.push(@get_method(intr, cdata, m_did.node, tcx));\n         true\n-    };\n+    });\n \n     rslt\n }\n@@ -1083,10 +1083,10 @@ pub fn get_trait_method_def_ids(cdata: Cmd,\n     let data = cdata.data;\n     let item = lookup_item(id, data);\n     let mut result = ~[];\n-    do reader::tagged_docs(item, tag_item_trait_method) |mth| {\n+    reader::tagged_docs(item, tag_item_trait_method, |mth| {\n         result.push(item_def_id(mth, cdata));\n         true\n-    };\n+    });\n     result\n }\n \n@@ -1105,15 +1105,15 @@ pub fn get_provided_trait_methods(intr: @ident_interner, cdata: Cmd,\n     let item = lookup_item(id, data);\n     let mut result = ~[];\n \n-    do reader::tagged_docs(item, tag_item_trait_method) |mth_id| {\n+    reader::tagged_docs(item, tag_item_trait_method, |mth_id| {\n         let did = item_def_id(mth_id, cdata);\n         let mth = lookup_item(did.node, data);\n \n         if item_method_sort(mth) == 'p' {\n             result.push(@get_method(intr, cdata, did.node, tcx));\n         }\n         true\n-    };\n+    });\n \n     return result;\n }\n@@ -1123,7 +1123,7 @@ pub fn get_supertraits(cdata: Cmd, id: ast::NodeId, tcx: ty::ctxt)\n                     -> ~[@ty::TraitRef] {\n     let mut results = ~[];\n     let item_doc = lookup_item(id, cdata.data);\n-    do reader::tagged_docs(item_doc, tag_item_super_trait_ref) |trait_doc| {\n+    reader::tagged_docs(item_doc, tag_item_super_trait_ref, |trait_doc| {\n         // NB. Only reads the ones that *aren't* builtin-bounds. See also\n         // get_trait_def() for collecting the builtin bounds.\n         // FIXME(#8559): The builtin bounds shouldn't be encoded in the first place.\n@@ -1132,7 +1132,7 @@ pub fn get_supertraits(cdata: Cmd, id: ast::NodeId, tcx: ty::ctxt)\n             results.push(@trait_ref);\n         }\n         true\n-    };\n+    });\n     return results;\n }\n \n@@ -1144,10 +1144,10 @@ pub fn get_type_name_if_impl(cdata: Cmd,\n     }\n \n     let mut ret = None;\n-    do reader::tagged_docs(item, tag_item_impl_type_basename) |doc| {\n+    reader::tagged_docs(item, tag_item_impl_type_basename, |doc| {\n         ret = Some(token::str_to_ident(doc.as_str_slice()));\n         false\n-    };\n+    });\n \n     ret\n }\n@@ -1162,17 +1162,17 @@ pub fn get_static_methods_if_impl(intr: @ident_interner,\n     }\n \n     // If this impl implements a trait, don't consider it.\n-    let ret = do reader::tagged_docs(item, tag_item_trait_ref) |_doc| {\n+    let ret = reader::tagged_docs(item, tag_item_trait_ref, |_doc| {\n         false\n-    };\n+    });\n \n     if !ret { return None }\n \n     let mut impl_method_ids = ~[];\n-    do reader::tagged_docs(item, tag_item_impl_method) |impl_method_doc| {\n+    reader::tagged_docs(item, tag_item_impl_method, |impl_method_doc| {\n         impl_method_ids.push(reader::with_doc_data(impl_method_doc, parse_def_id));\n         true\n-    };\n+    });\n \n     let mut static_impl_methods = ~[];\n     for impl_method_id in impl_method_ids.iter() {\n@@ -1205,13 +1205,13 @@ pub fn get_item_attrs(cdata: Cmd,\n                       node_id: ast::NodeId,\n                       f: |~[@ast::MetaItem]|) {\n     let item = lookup_item(node_id, cdata.data);\n-    do reader::tagged_docs(item, tag_attributes) |attributes| {\n-        do reader::tagged_docs(attributes, tag_attribute) |attribute| {\n+    reader::tagged_docs(item, tag_attributes, |attributes| {\n+        reader::tagged_docs(attributes, tag_attribute, |attribute| {\n             f(get_meta_items(attribute));\n             true\n-        };\n+        });\n         true\n-    };\n+    });\n }\n \n fn struct_field_family_to_visibility(family: Family) -> ast::visibility {\n@@ -1228,7 +1228,7 @@ pub fn get_struct_fields(intr: @ident_interner, cdata: Cmd, id: ast::NodeId)\n     let data = cdata.data;\n     let item = lookup_item(id, data);\n     let mut result = ~[];\n-    do reader::tagged_docs(item, tag_item_field) |an_item| {\n+    reader::tagged_docs(item, tag_item_field, |an_item| {\n         let f = item_family(an_item);\n         if f == PublicField || f == PrivateField || f == InheritedField {\n             // FIXME #6993: name should be of type Name, not Ident\n@@ -1241,16 +1241,16 @@ pub fn get_struct_fields(intr: @ident_interner, cdata: Cmd, id: ast::NodeId)\n             });\n         }\n         true\n-    };\n-    do reader::tagged_docs(item, tag_item_unnamed_field) |an_item| {\n+    });\n+    reader::tagged_docs(item, tag_item_unnamed_field, |an_item| {\n         let did = item_def_id(an_item, cdata);\n         result.push(ty::field_ty {\n             name: special_idents::unnamed_field.name,\n             id: did,\n             vis: ast::inherited,\n         });\n         true\n-    };\n+    });\n     result\n }\n \n@@ -1272,13 +1272,13 @@ fn family_names_type(fam: Family) -> bool {\n }\n \n fn read_path(d: ebml::Doc) -> (~str, uint) {\n-    do reader::with_doc_data(d) |desc| {\n+    reader::with_doc_data(d, |desc| {\n         let pos = u64_from_be_bytes(desc, 0u, 4u) as uint;\n         let pathbytes = desc.slice(4u, desc.len());\n         let path = str::from_utf8(pathbytes);\n \n         (path, pos)\n-    }\n+    })\n }\n \n fn describe_def(items: ebml::Doc, id: ast::DefId) -> ~str {\n@@ -1317,13 +1317,13 @@ fn item_family_to_str(fam: Family) -> ~str {\n \n fn get_meta_items(md: ebml::Doc) -> ~[@ast::MetaItem] {\n     let mut items: ~[@ast::MetaItem] = ~[];\n-    do reader::tagged_docs(md, tag_meta_item_word) |meta_item_doc| {\n+    reader::tagged_docs(md, tag_meta_item_word, |meta_item_doc| {\n         let nd = reader::get_doc(meta_item_doc, tag_meta_item_name);\n         let n = nd.as_str_slice().to_managed();\n         items.push(attr::mk_word_item(n));\n         true\n-    };\n-    do reader::tagged_docs(md, tag_meta_item_name_value) |meta_item_doc| {\n+    });\n+    reader::tagged_docs(md, tag_meta_item_name_value, |meta_item_doc| {\n         let nd = reader::get_doc(meta_item_doc, tag_meta_item_name);\n         let vd = reader::get_doc(meta_item_doc, tag_meta_item_value);\n         let n = nd.as_str_slice().to_managed();\n@@ -1332,22 +1332,22 @@ fn get_meta_items(md: ebml::Doc) -> ~[@ast::MetaItem] {\n         // but currently the encoder just drops them\n         items.push(attr::mk_name_value_item_str(n, v));\n         true\n-    };\n-    do reader::tagged_docs(md, tag_meta_item_list) |meta_item_doc| {\n+    });\n+    reader::tagged_docs(md, tag_meta_item_list, |meta_item_doc| {\n         let nd = reader::get_doc(meta_item_doc, tag_meta_item_name);\n         let n = nd.as_str_slice().to_managed();\n         let subitems = get_meta_items(meta_item_doc);\n         items.push(attr::mk_list_item(n, subitems));\n         true\n-    };\n+    });\n     return items;\n }\n \n fn get_attributes(md: ebml::Doc) -> ~[ast::Attribute] {\n     let mut attrs: ~[ast::Attribute] = ~[];\n     match reader::maybe_get_doc(md, tag_attributes) {\n       option::Some(attrs_d) => {\n-        do reader::tagged_docs(attrs_d, tag_attribute) |attr_doc| {\n+        reader::tagged_docs(attrs_d, tag_attribute, |attr_doc| {\n             let meta_items = get_meta_items(attr_doc);\n             // Currently it's only possible to have a single meta item on\n             // an attribute\n@@ -1363,7 +1363,7 @@ fn get_attributes(md: ebml::Doc) -> ~[ast::Attribute] {\n                     span: codemap::dummy_sp()\n                 });\n             true\n-        };\n+        });\n       }\n       option::None => ()\n     }\n@@ -1412,14 +1412,14 @@ pub fn get_crate_deps(data: @~[u8]) -> ~[CrateDep] {\n         let d = reader::get_doc(doc, tag_);\n         d.as_str_slice().to_managed()\n     }\n-    do reader::tagged_docs(depsdoc, tag_crate_dep) |depdoc| {\n+    reader::tagged_docs(depsdoc, tag_crate_dep, |depdoc| {\n         deps.push(CrateDep {cnum: crate_num,\n                   name: token::str_to_ident(docstr(depdoc, tag_crate_dep_name)),\n                   vers: docstr(depdoc, tag_crate_dep_vers),\n                   hash: docstr(depdoc, tag_crate_dep_hash)});\n         crate_num += 1;\n         true\n-    };\n+    });\n     return deps;\n }\n \n@@ -1477,36 +1477,37 @@ pub fn translate_def_id(cdata: Cmd, did: ast::DefId) -> ast::DefId {\n \n pub fn each_impl(cdata: Cmd, callback: |ast::DefId|) {\n     let impls_doc = reader::get_doc(reader::Doc(cdata.data), tag_impls);\n-    let _ = do reader::tagged_docs(impls_doc, tag_impls_impl) |impl_doc| {\n+    let _ = reader::tagged_docs(impls_doc, tag_impls_impl, |impl_doc| {\n         callback(item_def_id(impl_doc, cdata));\n         true\n-    };\n+    });\n }\n \n pub fn each_implementation_for_type(cdata: Cmd,\n                                     id: ast::NodeId,\n                                     callback: |ast::DefId|) {\n     let item_doc = lookup_item(id, cdata.data);\n-    do reader::tagged_docs(item_doc, tag_items_data_item_inherent_impl)\n-            |impl_doc| {\n+    reader::tagged_docs(item_doc,\n+                        tag_items_data_item_inherent_impl,\n+                        |impl_doc| {\n         let implementation_def_id = item_def_id(impl_doc, cdata);\n         callback(implementation_def_id);\n         true\n-    };\n+    });\n }\n \n pub fn each_implementation_for_trait(cdata: Cmd,\n                                      id: ast::NodeId,\n                                      callback: |ast::DefId|) {\n     let item_doc = lookup_item(id, cdata.data);\n \n-    let _ = do reader::tagged_docs(item_doc,\n-                                   tag_items_data_item_extension_impl)\n-            |impl_doc| {\n+    let _ = reader::tagged_docs(item_doc,\n+                                tag_items_data_item_extension_impl,\n+                                |impl_doc| {\n         let implementation_def_id = item_def_id(impl_doc, cdata);\n         callback(implementation_def_id);\n         true\n-    };\n+    });\n }\n \n pub fn get_trait_of_method(cdata: Cmd, id: ast::NodeId, tcx: ty::ctxt)\n@@ -1521,10 +1522,8 @@ pub fn get_trait_of_method(cdata: Cmd, id: ast::NodeId, tcx: ty::ctxt)\n     match item_family(parent_item_doc) {\n         Trait => Some(item_def_id(parent_item_doc, cdata)),\n         Impl => {\n-            do reader::maybe_get_doc(parent_item_doc, tag_item_trait_ref).map\n-                    |_| {\n-                item_trait_ref(parent_item_doc, tcx, cdata).def_id\n-            }\n+            reader::maybe_get_doc(parent_item_doc, tag_item_trait_ref)\n+                .map(|_| item_trait_ref(parent_item_doc, tcx, cdata).def_id)\n         }\n         _ => None\n     }"}, {"sha": "8f09353796b7e121b9ab6d6680be8d98d7d40c41", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=8ceb374ab783c6417b60867e7f34bebe997936ac", "patch": "@@ -615,12 +615,12 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n         ebml_w.wr_str(def_to_str(local_def(item.id)));\n         ebml_w.end_tag();\n \n-        do each_auxiliary_node_id(*item) |auxiliary_node_id| {\n+        each_auxiliary_node_id(*item, |auxiliary_node_id| {\n             ebml_w.start_tag(tag_mod_child);\n             ebml_w.wr_str(def_to_str(local_def(auxiliary_node_id)));\n             ebml_w.end_tag();\n             true\n-        };\n+        });\n \n         match item.node {\n             item_impl(*) => {\n@@ -1570,13 +1570,13 @@ fn encode_crate_deps(ecx: &EncodeContext,\n \n         // Pull the cnums and name,vers,hash out of cstore\n         let mut deps = ~[];\n-        do cstore::iter_crate_data(cstore) |key, val| {\n+        cstore::iter_crate_data(cstore, |key, val| {\n             let dep = decoder::CrateDep {cnum: key,\n                        name: ecx.tcx.sess.ident_of(val.name),\n                        vers: decoder::get_crate_vers(val.data),\n                        hash: decoder::get_crate_hash(val.data)};\n             deps.push(dep);\n-        };\n+        });\n \n         // Sort by cnum\n         extra::sort::quick_sort(deps, |kv1, kv2| kv1.cnum <= kv2.cnum);\n@@ -1697,12 +1697,12 @@ fn encode_misc_info(ecx: &EncodeContext,\n         ebml_w.wr_str(def_to_str(local_def(item.id)));\n         ebml_w.end_tag();\n \n-        do each_auxiliary_node_id(item) |auxiliary_node_id| {\n+        each_auxiliary_node_id(item, |auxiliary_node_id| {\n             ebml_w.start_tag(tag_mod_child);\n             ebml_w.wr_str(def_to_str(local_def(auxiliary_node_id)));\n             ebml_w.end_tag();\n             true\n-        };\n+        });\n     }\n \n     // Encode reexports for the root module."}, {"sha": "b2e5888eee1a50d70076b3a02bb9978e4618beb2", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=8ceb374ab783c6417b60867e7f34bebe997936ac", "patch": "@@ -118,7 +118,7 @@ pub fn mk_filesearch(maybe_sysroot: &Option<@Path>,\n }\n \n pub fn search(filesearch: @FileSearch, pick: pick) {\n-    do filesearch.for_each_lib_search_path() |lib_search_path| {\n+    filesearch.for_each_lib_search_path(|lib_search_path| {\n         debug!(\"searching {}\", lib_search_path.display());\n         match io::result(|| fs::readdir(lib_search_path)) {\n             Ok(files) => {\n@@ -140,7 +140,7 @@ pub fn search(filesearch: @FileSearch, pick: pick) {\n             }\n             Err(*) => FileDoesntMatch,\n         }\n-    };\n+    });\n }\n \n pub fn relative_target_lib_path(target_triple: &str) -> Path {"}, {"sha": "ecd1c8985bd00dc52404f3aa9e4eb71bfd67737f", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=8ceb374ab783c6417b60867e7f34bebe997936ac", "patch": "@@ -193,17 +193,15 @@ pub fn metadata_matches(extern_metas: &[@ast::MetaItem],\n     debug!(\"matching {} metadata requirements against {} items\",\n            local_metas.len(), extern_metas.len());\n \n-    do local_metas.iter().all |needed| {\n-        attr::contains(extern_metas, *needed)\n-    }\n+    local_metas.iter().all(|needed| attr::contains(extern_metas, *needed))\n }\n \n fn get_metadata_section(os: Os,\n                         filename: &Path) -> Option<@~[u8]> {\n     unsafe {\n-        let mb = do filename.with_c_str |buf| {\n+        let mb = filename.with_c_str(|buf| {\n             llvm::LLVMRustCreateMemoryBufferWithContentsOfFile(buf)\n-        };\n+        });\n         if mb as int == 0 { return option::None::<@~[u8]>; }\n         let of = match mk_object_file(mb) {\n             option::Some(of) => of,\n@@ -224,19 +222,19 @@ fn get_metadata_section(os: Os,\n                        vlen);\n                 let minsz = num::min(vlen, csz);\n                 let mut version_ok = false;\n-                do vec::raw::buf_as_slice(cvbuf, minsz) |buf0| {\n+                vec::raw::buf_as_slice(cvbuf, minsz, |buf0| {\n                     version_ok = (buf0 ==\n                                   encoder::metadata_encoding_version);\n-                }\n+                });\n                 if !version_ok { return None; }\n \n                 let cvbuf1 = ptr::offset(cvbuf, vlen as int);\n                 debug!(\"inflating {} bytes of compressed metadata\",\n                        csz - vlen);\n-                do vec::raw::buf_as_slice(cvbuf1, csz-vlen) |bytes| {\n+                vec::raw::buf_as_slice(cvbuf1, csz-vlen, |bytes| {\n                     let inflated = flate::inflate_bytes(bytes);\n                     found = Some(@(inflated));\n-                }\n+                });\n                 if found != None {\n                     return found;\n                 }"}, {"sha": "19a9a7efc578ae609038a6f8be044e93d72b5140", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=8ceb374ab783c6417b60867e7f34bebe997936ac", "patch": "@@ -132,7 +132,7 @@ fn enc_opt<T>(w: @mut MemWriter, t: Option<T>, enc_f: |T|) {\n \n fn enc_substs(w: @mut MemWriter, cx: @ctxt, substs: &ty::substs) {\n     enc_region_substs(w, cx, &substs.regions);\n-    do enc_opt(w, substs.self_ty) |t| { enc_ty(w, cx, t) }\n+    enc_opt(w, substs.self_ty, |t| enc_ty(w, cx, t));\n     mywrite!(w, \"[\");\n     for t in substs.tps.iter() { enc_ty(w, cx, *t); }\n     mywrite!(w, \"]\");\n@@ -350,10 +350,10 @@ fn enc_purity(w: @mut MemWriter, p: purity) {\n \n fn enc_abi_set(w: @mut MemWriter, abis: AbiSet) {\n     mywrite!(w, \"[\");\n-    do abis.each |abi| {\n+    abis.each(|abi| {\n         mywrite!(w, \"{},\", abi.name());\n         true\n-    };\n+    });\n     mywrite!(w, \"]\")\n }\n "}, {"sha": "c0dc904b9a376e10f246cbdaccd870cbe78bf224", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 128, "deletions": 136, "changes": 264, "blob_url": "https://github.com/rust-lang/rust/blob/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=8ceb374ab783c6417b60867e7f34bebe997936ac", "patch": "@@ -303,7 +303,7 @@ struct NestedItemsDropper {\n \n impl fold::ast_fold for NestedItemsDropper {\n     fn fold_block(&self, blk: &ast::Block) -> ast::Block {\n-        let stmts_sans_items = do blk.stmts.iter().filter_map |stmt| {\n+        let stmts_sans_items = blk.stmts.iter().filter_map(|stmt| {\n             match stmt.node {\n                 ast::StmtExpr(_, _) | ast::StmtSemi(_, _) |\n                 ast::StmtDecl(@codemap::Spanned {\n@@ -316,7 +316,7 @@ impl fold::ast_fold for NestedItemsDropper {\n                 }, _) => None,\n                 ast::StmtMac(*) => fail!(\"unexpanded macro in astencode\")\n             }\n-        }.collect();\n+        }).collect();\n         let blk_sans_items = ast::Block {\n             view_items: ~[], // I don't know if we need the view_items here,\n                              // but it doesn't break tests!\n@@ -568,26 +568,26 @@ trait read_method_map_entry_helper {\n fn encode_method_map_entry(ecx: &e::EncodeContext,\n                            ebml_w: &mut writer::Encoder,\n                            mme: method_map_entry) {\n-    do ebml_w.emit_struct(\"method_map_entry\", 3) |ebml_w| {\n-        do ebml_w.emit_struct_field(\"self_ty\", 0u) |ebml_w| {\n+    ebml_w.emit_struct(\"method_map_entry\", 3, |ebml_w| {\n+        ebml_w.emit_struct_field(\"self_ty\", 0u, |ebml_w| {\n             ebml_w.emit_ty(ecx, mme.self_ty);\n-        }\n-        do ebml_w.emit_struct_field(\"explicit_self\", 2u) |ebml_w| {\n+        });\n+        ebml_w.emit_struct_field(\"explicit_self\", 2u, |ebml_w| {\n             mme.explicit_self.encode(ebml_w);\n-        }\n-        do ebml_w.emit_struct_field(\"origin\", 1u) |ebml_w| {\n+        });\n+        ebml_w.emit_struct_field(\"origin\", 1u, |ebml_w| {\n             mme.origin.encode(ebml_w);\n-        }\n-        do ebml_w.emit_struct_field(\"self_mode\", 3) |ebml_w| {\n+        });\n+        ebml_w.emit_struct_field(\"self_mode\", 3, |ebml_w| {\n             mme.self_mode.encode(ebml_w);\n-        }\n-    }\n+        });\n+    })\n }\n \n impl read_method_map_entry_helper for reader::Decoder {\n     fn read_method_map_entry(&mut self, xcx: @ExtendedDecodeContext)\n                              -> method_map_entry {\n-        do self.read_struct(\"method_map_entry\", 3) |this| {\n+        self.read_struct(\"method_map_entry\", 3, |this| {\n             method_map_entry {\n                 self_ty: this.read_struct_field(\"self_ty\", 0u, |this| {\n                     this.read_ty(xcx)\n@@ -608,7 +608,7 @@ impl read_method_map_entry_helper for reader::Decoder {\n                     self_mode\n                 }),\n             }\n-        }\n+        })\n     }\n }\n \n@@ -648,50 +648,50 @@ pub fn encode_vtable_res(ecx: &e::EncodeContext,\n     // ty::t doesn't work, and there is no way (atm) to have\n     // hand-written encoding routines combine with auto-generated\n     // ones.  perhaps we should fix this.\n-    do ebml_w.emit_from_vec(*dr) |ebml_w, param_tables| {\n+    ebml_w.emit_from_vec(*dr, |ebml_w, param_tables| {\n         encode_vtable_param_res(ecx, ebml_w, *param_tables);\n-    }\n+    })\n }\n \n pub fn encode_vtable_param_res(ecx: &e::EncodeContext,\n                      ebml_w: &mut writer::Encoder,\n                      param_tables: typeck::vtable_param_res) {\n-    do ebml_w.emit_from_vec(*param_tables) |ebml_w, vtable_origin| {\n+    ebml_w.emit_from_vec(*param_tables, |ebml_w, vtable_origin| {\n         encode_vtable_origin(ecx, ebml_w, vtable_origin)\n-    }\n+    })\n }\n \n \n pub fn encode_vtable_origin(ecx: &e::EncodeContext,\n                         ebml_w: &mut writer::Encoder,\n                         vtable_origin: &typeck::vtable_origin) {\n-    do ebml_w.emit_enum(\"vtable_origin\") |ebml_w| {\n+    ebml_w.emit_enum(\"vtable_origin\", |ebml_w| {\n         match *vtable_origin {\n           typeck::vtable_static(def_id, ref tys, vtable_res) => {\n-            do ebml_w.emit_enum_variant(\"vtable_static\", 0u, 3u) |ebml_w| {\n-                do ebml_w.emit_enum_variant_arg(0u) |ebml_w| {\n+            ebml_w.emit_enum_variant(\"vtable_static\", 0u, 3u, |ebml_w| {\n+                ebml_w.emit_enum_variant_arg(0u, |ebml_w| {\n                     ebml_w.emit_def_id(def_id)\n-                }\n-                do ebml_w.emit_enum_variant_arg(1u) |ebml_w| {\n+                });\n+                ebml_w.emit_enum_variant_arg(1u, |ebml_w| {\n                     ebml_w.emit_tys(ecx, *tys);\n-                }\n-                do ebml_w.emit_enum_variant_arg(2u) |ebml_w| {\n+                });\n+                ebml_w.emit_enum_variant_arg(2u, |ebml_w| {\n                     encode_vtable_res(ecx, ebml_w, vtable_res);\n-                }\n-            }\n+                })\n+            })\n           }\n           typeck::vtable_param(pn, bn) => {\n-            do ebml_w.emit_enum_variant(\"vtable_param\", 1u, 2u) |ebml_w| {\n-                do ebml_w.emit_enum_variant_arg(0u) |ebml_w| {\n+            ebml_w.emit_enum_variant(\"vtable_param\", 1u, 2u, |ebml_w| {\n+                ebml_w.emit_enum_variant_arg(0u, |ebml_w| {\n                     pn.encode(ebml_w);\n-                }\n-                do ebml_w.emit_enum_variant_arg(1u) |ebml_w| {\n+                });\n+                ebml_w.emit_enum_variant_arg(1u, |ebml_w| {\n                     ebml_w.emit_uint(bn);\n-                }\n-            }\n+                })\n+            })\n           }\n         }\n-    }\n+    })\n }\n \n pub trait vtable_decoder_helpers {\n@@ -724,40 +724,40 @@ impl vtable_decoder_helpers for reader::Decoder {\n     fn read_vtable_origin(&mut self,\n                           tcx: ty::ctxt, cdata: @cstore::crate_metadata)\n         -> typeck::vtable_origin {\n-        do self.read_enum(\"vtable_origin\") |this| {\n-            do this.read_enum_variant([\"vtable_static\",\n-                                       \"vtable_param\",\n-                                       \"vtable_self\"])\n-                    |this, i| {\n+        self.read_enum(\"vtable_origin\", |this| {\n+            this.read_enum_variant([\"vtable_static\",\n+                                    \"vtable_param\",\n+                                    \"vtable_self\"],\n+                                   |this, i| {\n                 match i {\n                   0 => {\n                     typeck::vtable_static(\n-                        do this.read_enum_variant_arg(0u) |this| {\n+                        this.read_enum_variant_arg(0u, |this| {\n                             this.read_def_id_noxcx(cdata)\n-                        },\n-                        do this.read_enum_variant_arg(1u) |this| {\n+                        }),\n+                        this.read_enum_variant_arg(1u, |this| {\n                             this.read_tys_noxcx(tcx, cdata)\n-                        },\n-                        do this.read_enum_variant_arg(2u) |this| {\n+                        }),\n+                        this.read_enum_variant_arg(2u, |this| {\n                             this.read_vtable_res(tcx, cdata)\n-                        }\n+                        })\n                     )\n                   }\n                   1 => {\n                     typeck::vtable_param(\n-                        do this.read_enum_variant_arg(0u) |this| {\n+                        this.read_enum_variant_arg(0u, |this| {\n                             Decodable::decode(this)\n-                        },\n-                        do this.read_enum_variant_arg(1u) |this| {\n+                        }),\n+                        this.read_enum_variant_arg(1u, |this| {\n                             this.read_uint()\n-                        }\n+                        })\n                     )\n                   }\n                   // hard to avoid - user input\n                   _ => fail!(\"bad enum variant\")\n                 }\n-            }\n-        }\n+            })\n+        })\n     }\n }\n \n@@ -793,54 +793,48 @@ trait ebml_writer_helpers {\n \n impl ebml_writer_helpers for writer::Encoder {\n     fn emit_ty(&mut self, ecx: &e::EncodeContext, ty: ty::t) {\n-        do self.emit_opaque |this| {\n-            e::write_type(ecx, this, ty)\n-        }\n+        self.emit_opaque(|this| e::write_type(ecx, this, ty))\n     }\n \n     fn emit_vstore(&mut self, ecx: &e::EncodeContext, vstore: ty::vstore) {\n-        do self.emit_opaque |this| {\n-            e::write_vstore(ecx, this, vstore)\n-        }\n+        self.emit_opaque(|this| e::write_vstore(ecx, this, vstore))\n     }\n \n     fn emit_tys(&mut self, ecx: &e::EncodeContext, tys: &[ty::t]) {\n-        do self.emit_from_vec(tys) |this, ty| {\n-            this.emit_ty(ecx, *ty)\n-        }\n+        self.emit_from_vec(tys, |this, ty| this.emit_ty(ecx, *ty))\n     }\n \n     fn emit_type_param_def(&mut self,\n                            ecx: &e::EncodeContext,\n                            type_param_def: &ty::TypeParameterDef) {\n-        do self.emit_opaque |this| {\n+        self.emit_opaque(|this| {\n             tyencode::enc_type_param_def(this.writer,\n                                          ecx.ty_str_ctxt(),\n                                          type_param_def)\n-        }\n+        })\n     }\n \n     fn emit_tpbt(&mut self,\n                  ecx: &e::EncodeContext,\n                  tpbt: ty::ty_param_bounds_and_ty) {\n-        do self.emit_struct(\"ty_param_bounds_and_ty\", 2) |this| {\n-            do this.emit_struct_field(\"generics\", 0) |this| {\n-                do this.emit_struct(\"Generics\", 2) |this| {\n-                    do this.emit_struct_field(\"type_param_defs\", 0) |this| {\n-                        do this.emit_from_vec(*tpbt.generics.type_param_defs)\n-                                |this, type_param_def| {\n+        self.emit_struct(\"ty_param_bounds_and_ty\", 2, |this| {\n+            this.emit_struct_field(\"generics\", 0, |this| {\n+                this.emit_struct(\"Generics\", 2, |this| {\n+                    this.emit_struct_field(\"type_param_defs\", 0, |this| {\n+                        this.emit_from_vec(*tpbt.generics.type_param_defs,\n+                                           |this, type_param_def| {\n                             this.emit_type_param_def(ecx, type_param_def);\n-                        }\n-                    }\n-                    do this.emit_struct_field(\"region_param_defs\", 1) |this| {\n+                        })\n+                    });\n+                    this.emit_struct_field(\"region_param_defs\", 1, |this| {\n                         tpbt.generics.region_param_defs.encode(this);\n-                    }\n-                }\n-            }\n-            do this.emit_struct_field(\"ty\", 1) |this| {\n+                    })\n+                })\n+            });\n+            this.emit_struct_field(\"ty\", 1, |this| {\n                 this.emit_ty(ecx, tpbt.ty);\n-            }\n-        }\n+            })\n+        })\n     }\n }\n \n@@ -912,125 +906,123 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n     {\n         let r = tcx.def_map.find(&id);\n         for def in r.iter() {\n-            do ebml_w.tag(c::tag_table_def) |ebml_w| {\n+            ebml_w.tag(c::tag_table_def, |ebml_w| {\n                 ebml_w.id(id);\n-                do ebml_w.tag(c::tag_table_val) |ebml_w| {\n-                    (*def).encode(ebml_w)\n-                }\n-            }\n+                ebml_w.tag(c::tag_table_val, |ebml_w| (*def).encode(ebml_w));\n+            })\n         }\n     }\n \n     {\n         let r = tcx.node_types.find(&(id as uint));\n         for &ty in r.iter() {\n-            do ebml_w.tag(c::tag_table_node_type) |ebml_w| {\n+            ebml_w.tag(c::tag_table_node_type, |ebml_w| {\n                 ebml_w.id(id);\n-                do ebml_w.tag(c::tag_table_val) |ebml_w| {\n+                ebml_w.tag(c::tag_table_val, |ebml_w| {\n                     ebml_w.emit_ty(ecx, *ty);\n-                }\n-            }\n+                })\n+            })\n         }\n     }\n \n     {\n         let r = tcx.node_type_substs.find(&id);\n         for tys in r.iter() {\n-            do ebml_w.tag(c::tag_table_node_type_subst) |ebml_w| {\n+            ebml_w.tag(c::tag_table_node_type_subst, |ebml_w| {\n                 ebml_w.id(id);\n-                do ebml_w.tag(c::tag_table_val) |ebml_w| {\n+                ebml_w.tag(c::tag_table_val, |ebml_w| {\n                     ebml_w.emit_tys(ecx, **tys)\n-                }\n-            }\n+                })\n+            })\n         }\n     }\n \n     {\n         let r = tcx.freevars.find(&id);\n         for &fv in r.iter() {\n-            do ebml_w.tag(c::tag_table_freevars) |ebml_w| {\n+            ebml_w.tag(c::tag_table_freevars, |ebml_w| {\n                 ebml_w.id(id);\n-                do ebml_w.tag(c::tag_table_val) |ebml_w| {\n-                    do ebml_w.emit_from_vec(**fv) |ebml_w, fv_entry| {\n+                ebml_w.tag(c::tag_table_val, |ebml_w| {\n+                    ebml_w.emit_from_vec(**fv, |ebml_w, fv_entry| {\n                         encode_freevar_entry(ebml_w, *fv_entry)\n-                    }\n-                }\n-            }\n+                    })\n+                })\n+            })\n         }\n     }\n \n     let lid = ast::DefId { crate: ast::LOCAL_CRATE, node: id };\n     {\n         let r = tcx.tcache.find(&lid);\n         for &tpbt in r.iter() {\n-            do ebml_w.tag(c::tag_table_tcache) |ebml_w| {\n+            ebml_w.tag(c::tag_table_tcache, |ebml_w| {\n                 ebml_w.id(id);\n-                do ebml_w.tag(c::tag_table_val) |ebml_w| {\n+                ebml_w.tag(c::tag_table_val, |ebml_w| {\n                     ebml_w.emit_tpbt(ecx, *tpbt);\n-                }\n-            }\n+                })\n+            })\n         }\n     }\n \n     {\n         let r = tcx.ty_param_defs.find(&id);\n         for &type_param_def in r.iter() {\n-            do ebml_w.tag(c::tag_table_param_defs) |ebml_w| {\n+            ebml_w.tag(c::tag_table_param_defs, |ebml_w| {\n                 ebml_w.id(id);\n-                do ebml_w.tag(c::tag_table_val) |ebml_w| {\n+                ebml_w.tag(c::tag_table_val, |ebml_w| {\n                     ebml_w.emit_type_param_def(ecx, type_param_def)\n-                }\n-            }\n+                })\n+            })\n         }\n     }\n \n     {\n         let r = maps.method_map.find(&id);\n         for &mme in r.iter() {\n-            do ebml_w.tag(c::tag_table_method_map) |ebml_w| {\n+            ebml_w.tag(c::tag_table_method_map, |ebml_w| {\n                 ebml_w.id(id);\n-                do ebml_w.tag(c::tag_table_val) |ebml_w| {\n+                ebml_w.tag(c::tag_table_val, |ebml_w| {\n                     encode_method_map_entry(ecx, ebml_w, *mme)\n-                }\n-            }\n+                })\n+            })\n         }\n     }\n \n     {\n         let r = maps.vtable_map.find(&id);\n         for &dr in r.iter() {\n-            do ebml_w.tag(c::tag_table_vtable_map) |ebml_w| {\n+            ebml_w.tag(c::tag_table_vtable_map, |ebml_w| {\n                 ebml_w.id(id);\n-                do ebml_w.tag(c::tag_table_val) |ebml_w| {\n+                ebml_w.tag(c::tag_table_val, |ebml_w| {\n                     encode_vtable_res(ecx, ebml_w, *dr);\n-                }\n-            }\n+                })\n+            })\n         }\n     }\n \n     {\n         let r = tcx.adjustments.find(&id);\n         for adj in r.iter() {\n-            do ebml_w.tag(c::tag_table_adjustments) |ebml_w| {\n+            ebml_w.tag(c::tag_table_adjustments, |ebml_w| {\n                 ebml_w.id(id);\n-                do ebml_w.tag(c::tag_table_val) |ebml_w| {\n+                ebml_w.tag(c::tag_table_val, |ebml_w| {\n                     (**adj).encode(ebml_w)\n-                }\n-            }\n+                })\n+            })\n         }\n     }\n \n     {\n         let r = maps.capture_map.find(&id);\n         for &cap_vars in r.iter() {\n-            do ebml_w.tag(c::tag_table_capture_map) |ebml_w| {\n+            ebml_w.tag(c::tag_table_capture_map, |ebml_w| {\n                 ebml_w.id(id);\n-                do ebml_w.tag(c::tag_table_val) |ebml_w| {\n-                    do ebml_w.emit_from_vec(*cap_vars) |ebml_w, cap_var| {\n+                ebml_w.tag(c::tag_table_val, |ebml_w| {\n+                    ebml_w.emit_from_vec(*cap_vars, |ebml_w, cap_var| {\n                         cap_var.encode(ebml_w);\n-                    }\n-                }\n-            }\n+                    })\n+                })\n+            })\n         }\n     }\n }\n@@ -1072,14 +1064,14 @@ trait ebml_decoder_decoder_helpers {\n impl ebml_decoder_decoder_helpers for reader::Decoder {\n     fn read_ty_noxcx(&mut self,\n                      tcx: ty::ctxt, cdata: @cstore::crate_metadata) -> ty::t {\n-        do self.read_opaque |_, doc| {\n+        self.read_opaque(|_, doc| {\n             tydecode::parse_ty_data(\n                 *doc.data,\n                 cdata.cnum,\n                 doc.start,\n                 tcx,\n                 |_, id| decoder::translate_def_id(cdata, id))\n-        }\n+        })\n     }\n \n     fn read_tys_noxcx(&mut self,\n@@ -1094,7 +1086,7 @@ impl ebml_decoder_decoder_helpers for reader::Decoder {\n         // context.  However, we do not bother, because region types\n         // are not used during trans.\n \n-        return do self.read_opaque |this, doc| {\n+        return self.read_opaque(|this, doc| {\n             debug!(\"read_ty({})\", type_string(doc));\n \n             let ty = tydecode::parse_ty_data(\n@@ -1105,7 +1097,7 @@ impl ebml_decoder_decoder_helpers for reader::Decoder {\n                 |s, a| this.convert_def_id(xcx, s, a));\n \n             ty\n-        };\n+        });\n \n         fn type_string(doc: ebml::Doc) -> ~str {\n             let mut str = ~\"\";\n@@ -1122,22 +1114,22 @@ impl ebml_decoder_decoder_helpers for reader::Decoder {\n \n     fn read_type_param_def(&mut self, xcx: @ExtendedDecodeContext)\n                            -> ty::TypeParameterDef {\n-        do self.read_opaque |this, doc| {\n+        self.read_opaque(|this, doc| {\n             tydecode::parse_type_param_def_data(\n                 *doc.data,\n                 doc.start,\n                 xcx.dcx.cdata.cnum,\n                 xcx.dcx.tcx,\n                 |s, a| this.convert_def_id(xcx, s, a))\n-        }\n+        })\n     }\n \n     fn read_ty_param_bounds_and_ty(&mut self, xcx: @ExtendedDecodeContext)\n                                    -> ty::ty_param_bounds_and_ty {\n-        do self.read_struct(\"ty_param_bounds_and_ty\", 2) |this| {\n+        self.read_struct(\"ty_param_bounds_and_ty\", 2, |this| {\n             ty::ty_param_bounds_and_ty {\n-                generics: do this.read_struct_field(\"generics\", 0) |this| {\n-                    do this.read_struct(\"Generics\", 2) |this| {\n+                generics: this.read_struct_field(\"generics\", 0, |this| {\n+                    this.read_struct(\"Generics\", 2, |this| {\n                         ty::Generics {\n                             type_param_defs:\n                                 this.read_struct_field(\"type_param_defs\",\n@@ -1153,13 +1145,13 @@ impl ebml_decoder_decoder_helpers for reader::Decoder {\n                                     Decodable::decode(this)\n                                 })\n                         }\n-                    }\n-                },\n+                    })\n+                }),\n                 ty: this.read_struct_field(\"ty\", 1, |this| {\n                     this.read_ty(xcx)\n                 })\n             }\n-        }\n+        })\n     }\n \n     fn convert_def_id(&mut self,\n@@ -1208,7 +1200,7 @@ fn decode_side_tables(xcx: @ExtendedDecodeContext,\n                       ast_doc: ebml::Doc) {\n     let dcx = xcx.dcx;\n     let tbl_doc = ast_doc.get(c::tag_table as uint);\n-    do reader::docs(tbl_doc) |tag, entry_doc| {\n+    reader::docs(tbl_doc, |tag, entry_doc| {\n         let id0 = entry_doc.get(c::tag_table_id as uint).as_int();\n         let id = xcx.tr_id(id0);\n \n@@ -1288,7 +1280,7 @@ fn decode_side_tables(xcx: @ExtendedDecodeContext,\n \n         debug!(\">< Side table doc loaded\");\n         true\n-    };\n+    });\n }\n \n // ______________________________________________________________________"}, {"sha": "774509ab0da58e705e86ac50b2980170bacffb02", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=8ceb374ab783c6417b60867e7f34bebe997936ac", "patch": "@@ -132,10 +132,10 @@ impl<'self> CheckLoanCtxt<'self> {\n         //! are issued for future scopes and thus they may have been\n         //! *issued* but not yet be in effect.\n \n-        do self.dfcx_loans.each_bit_on_entry_frozen(scope_id) |loan_index| {\n+        self.dfcx_loans.each_bit_on_entry_frozen(scope_id, |loan_index| {\n             let loan = &self.all_loans[loan_index];\n             op(loan)\n-        }\n+        })\n     }\n \n     pub fn each_in_scope_loan(&self,\n@@ -146,13 +146,13 @@ impl<'self> CheckLoanCtxt<'self> {\n         //! currently in scope.\n \n         let region_maps = self.tcx().region_maps;\n-        do self.each_issued_loan(scope_id) |loan| {\n+        self.each_issued_loan(scope_id, |loan| {\n             if region_maps.is_subscope_of(scope_id, loan.kill_scope) {\n                 op(loan)\n             } else {\n                 true\n             }\n-        }\n+        })\n     }\n \n     pub fn each_in_scope_restriction(&self,\n@@ -163,7 +163,7 @@ impl<'self> CheckLoanCtxt<'self> {\n         //! Iterates through all the in-scope restrictions for the\n         //! given `loan_path`\n \n-        do self.each_in_scope_loan(scope_id) |loan| {\n+        self.each_in_scope_loan(scope_id, |loan| {\n             let mut ret = true;\n             for restr in loan.restrictions.iter() {\n                 if restr.loan_path == loan_path {\n@@ -174,18 +174,18 @@ impl<'self> CheckLoanCtxt<'self> {\n                 }\n             }\n             ret\n-        }\n+        })\n     }\n \n     pub fn loans_generated_by(&self, scope_id: ast::NodeId) -> ~[uint] {\n         //! Returns a vector of the loans that are generated as\n         //! we encounter `scope_id`.\n \n         let mut result = ~[];\n-        do self.dfcx_loans.each_gen_bit_frozen(scope_id) |loan_index| {\n+        self.dfcx_loans.each_gen_bit_frozen(scope_id, |loan_index| {\n             result.push(loan_index);\n             true\n-        };\n+        });\n         return result;\n     }\n \n@@ -200,13 +200,13 @@ impl<'self> CheckLoanCtxt<'self> {\n         let new_loan_indices = self.loans_generated_by(scope_id);\n         debug!(\"new_loan_indices = {:?}\", new_loan_indices);\n \n-        do self.each_issued_loan(scope_id) |issued_loan| {\n+        self.each_issued_loan(scope_id, |issued_loan| {\n             for &new_loan_index in new_loan_indices.iter() {\n                 let new_loan = &self.all_loans[new_loan_index];\n                 self.report_error_if_loans_conflict(issued_loan, new_loan);\n             }\n             true\n-        };\n+        });\n \n         for (i, &x) in new_loan_indices.iter().enumerate() {\n             let old_loan = &self.all_loans[x];\n@@ -317,15 +317,15 @@ impl<'self> CheckLoanCtxt<'self> {\n \n         debug!(\"check_if_path_is_moved(id={:?}, use_kind={:?}, lp={})\",\n                id, use_kind, lp.repr(self.bccx.tcx));\n-        do self.move_data.each_move_of(id, lp) |move, moved_lp| {\n+        self.move_data.each_move_of(id, lp, |move, moved_lp| {\n             self.bccx.report_use_of_moved_value(\n                 span,\n                 use_kind,\n                 lp,\n                 move,\n                 moved_lp);\n             false\n-        };\n+        });\n     }\n \n     pub fn check_assignment(&self, expr: @ast::Expr) {\n@@ -357,13 +357,13 @@ impl<'self> CheckLoanCtxt<'self> {\n         if self.is_local_variable(cmt) {\n             assert!(cmt.mutbl.is_immutable()); // no \"const\" locals\n             let lp = opt_loan_path(cmt).unwrap();\n-            do self.move_data.each_assignment_of(expr.id, lp) |assign| {\n+            self.move_data.each_assignment_of(expr.id, lp, |assign| {\n                 self.bccx.report_reassigned_immutable_variable(\n                     expr.span,\n                     lp,\n                     assign);\n                 false\n-            };\n+            });\n             return;\n         }\n \n@@ -546,16 +546,16 @@ impl<'self> CheckLoanCtxt<'self> {\n             // `RESTR_MUTATE` restriction whenever the contents of an\n             // owned pointer are borrowed, and hence while `v[*]` is not\n             // restricted from being written, `v` is.\n-            let cont = do this.each_in_scope_restriction(expr.id, loan_path)\n-                |loan, restr|\n-            {\n+            let cont = this.each_in_scope_restriction(expr.id,\n+                                                      loan_path,\n+                                                      |loan, restr| {\n                 if restr.set.intersects(RESTR_MUTATE) {\n                     this.report_illegal_mutation(expr, loan_path, loan);\n                     false\n                 } else {\n                     true\n                 }\n-            };\n+            });\n \n             if !cont { return false }\n \n@@ -621,7 +621,7 @@ impl<'self> CheckLoanCtxt<'self> {\n                 }\n \n                 // Check for a non-const loan of `loan_path`\n-                let cont = do this.each_in_scope_loan(expr.id) |loan| {\n+                let cont = this.each_in_scope_loan(expr.id, |loan| {\n                     if loan.loan_path == loan_path &&\n                             loan.mutbl != ConstMutability {\n                         this.report_illegal_mutation(expr,\n@@ -631,7 +631,7 @@ impl<'self> CheckLoanCtxt<'self> {\n                     } else {\n                         true\n                     }\n-                };\n+                });\n \n                 if !cont { return false }\n             }\n@@ -666,7 +666,7 @@ impl<'self> CheckLoanCtxt<'self> {\n     }\n \n     fn check_move_out_from_id(&self, id: ast::NodeId, span: Span) {\n-        do self.move_data.each_path_moved_by(id) |_, move_path| {\n+        self.move_data.each_path_moved_by(id, |_, move_path| {\n             match self.analyze_move_out_from(id, move_path) {\n                 MoveOk => {}\n                 MoveWhileBorrowed(loan_path, loan_span) => {\n@@ -682,7 +682,7 @@ impl<'self> CheckLoanCtxt<'self> {\n                 }\n             }\n             true\n-        };\n+        });\n     }\n \n     pub fn analyze_move_out_from(&self,\n@@ -696,11 +696,11 @@ impl<'self> CheckLoanCtxt<'self> {\n         let mut ret = MoveOk;\n \n         // check for a conflicting loan:\n-        do self.each_in_scope_restriction(expr_id, move_path) |loan, _| {\n+        self.each_in_scope_restriction(expr_id, move_path, |loan, _| {\n             // Any restriction prevents moves.\n             ret = MoveWhileBorrowed(loan.loan_path, loan.span);\n             false\n-        };\n+        });\n \n         ret\n     }"}, {"sha": "410cf658a985148b2487bf9ed6b67b2cf1b759df", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=8ceb374ab783c6417b60867e7f34bebe997936ac", "patch": "@@ -161,27 +161,25 @@ fn gather_loans_in_local(this: &mut GatherLoanCtxt,\n         None => {\n             // Variable declarations without initializers are considered \"moves\":\n             let tcx = this.bccx.tcx;\n-            do pat_util::pat_bindings(tcx.def_map, local.pat)\n-                |_, id, span, _| {\n+            pat_util::pat_bindings(tcx.def_map, local.pat, |_, id, span, _| {\n                 gather_moves::gather_decl(this.bccx,\n                                           this.move_data,\n                                           id,\n                                           span,\n                                           id);\n-            }\n+            })\n         }\n         Some(init) => {\n             // Variable declarations with initializers are considered \"assigns\":\n             let tcx = this.bccx.tcx;\n-            do pat_util::pat_bindings(tcx.def_map, local.pat)\n-                |_, id, span, _| {\n+            pat_util::pat_bindings(tcx.def_map, local.pat, |_, id, span, _| {\n                 gather_moves::gather_assignment(this.bccx,\n                                                 this.move_data,\n                                                 id,\n                                                 span,\n                                                 @LpVar(id),\n                                                 id);\n-            }\n+            });\n             let init_cmt = this.bccx.cat_expr(init);\n             this.gather_pat(init_cmt, local.pat, None);\n         }\n@@ -692,7 +690,7 @@ impl<'self> GatherLoanCtxt<'self> {\n          * moves (non-`ref` bindings with linear type).\n          */\n \n-        do self.bccx.cat_pattern(discr_cmt, root_pat) |cmt, pat| {\n+        self.bccx.cat_pattern(discr_cmt, root_pat, |cmt, pat| {\n             match pat.node {\n               ast::PatIdent(bm, _, _) if self.pat_is_binding(pat) => {\n                 match bm {\n@@ -781,7 +779,7 @@ impl<'self> GatherLoanCtxt<'self> {\n \n               _ => {}\n             }\n-        }\n+        })\n     }\n \n     pub fn vec_slice_info(&self, pat: @ast::Pat, slice_ty: ty::t)"}, {"sha": "abeaef054314121d654095dc2cad9aa7d072cae9", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=8ceb374ab783c6417b60867e7f34bebe997936ac", "patch": "@@ -318,15 +318,15 @@ pub fn opt_loan_path(cmt: mc::cmt) -> Option<@LoanPath> {\n         }\n \n         mc::cat_deref(cmt_base, _, pk) => {\n-            do opt_loan_path(cmt_base).map |lp| {\n+            opt_loan_path(cmt_base).map(|lp| {\n                 @LpExtend(lp, cmt.mutbl, LpDeref(pk))\n-            }\n+            })\n         }\n \n         mc::cat_interior(cmt_base, ik) => {\n-            do opt_loan_path(cmt_base).map |lp| {\n+            opt_loan_path(cmt_base).map(|lp| {\n                 @LpExtend(lp, cmt.mutbl, LpInterior(ik))\n-            }\n+            })\n         }\n \n         mc::cat_downcast(cmt_base) |"}, {"sha": "7b060e6ac7db8237c38e77428f15ce0309843d7a", "filename": "src/librustc/middle/borrowck/move_data.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs?ref=8ceb374ab783c6417b60867e7f34bebe997936ac", "patch": "@@ -277,10 +277,10 @@ impl MoveData {\n \n         match self.path_map.find_copy(&lp) {\n             Some(index) => {\n-                do self.each_base_path(index) |p| {\n+                self.each_base_path(index, |p| {\n                     result.push(p);\n                     true\n-                };\n+                });\n             }\n             None => {\n                 match *lp {\n@@ -448,7 +448,7 @@ impl MoveData {\n                             f: |MoveIndex| -> bool)\n                             -> bool {\n         let mut ret = true;\n-        do self.each_extending_path(index0) |index| {\n+        self.each_extending_path(index0, |index| {\n             let mut p = self.path(index).first_move;\n             while p != InvalidMoveIndex {\n                 if !f(p) {\n@@ -458,18 +458,18 @@ impl MoveData {\n                 p = self.move(p).next_move;\n             }\n             ret\n-        };\n+        });\n         ret\n     }\n \n     fn kill_moves(&self,\n                   path: MovePathIndex,\n                   kill_id: ast::NodeId,\n                   dfcx_moves: &mut MoveDataFlow) {\n-        do self.each_applicable_move(path) |move_index| {\n+        self.each_applicable_move(path, |move_index| {\n             dfcx_moves.add_kill(kill_id, *move_index);\n             true\n-        };\n+        });\n     }\n }\n \n@@ -511,11 +511,11 @@ impl FlowedMoveData {\n          * Iterates through each path moved by `id`\n          */\n \n-        do self.dfcx_moves.each_gen_bit_frozen(id) |index| {\n+        self.dfcx_moves.each_gen_bit_frozen(id, |index| {\n             let move = &self.move_data.moves[index];\n             let moved_path = move.path;\n             f(move, self.move_data.path(moved_path).loan_path)\n-        }\n+        })\n     }\n \n     pub fn each_move_of(&self,\n@@ -549,7 +549,7 @@ impl FlowedMoveData {\n \n         let mut ret = true;\n \n-        do self.dfcx_moves.each_bit_on_entry_frozen(id) |index| {\n+        self.dfcx_moves.each_bit_on_entry_frozen(id, |index| {\n             let move = &self.move_data.moves[index];\n             let moved_path = move.path;\n             if base_indices.iter().any(|x| x == &moved_path) {\n@@ -560,20 +560,20 @@ impl FlowedMoveData {\n                 }\n             } else {\n                 for &loan_path_index in opt_loan_path_index.iter() {\n-                    let cont = do self.move_data.each_base_path(moved_path) |p| {\n+                    let cont = self.move_data.each_base_path(moved_path, |p| {\n                         if p == loan_path_index {\n                             // Scenario 3: some extension of `loan_path`\n                             // was moved\n                             f(move, self.move_data.path(moved_path).loan_path)\n                         } else {\n                             true\n                         }\n-                    };\n+                    });\n                     if !cont { ret = false; break }\n                 }\n             }\n             ret\n-        }\n+        })\n     }\n \n     pub fn is_assignee(&self,\n@@ -605,14 +605,14 @@ impl FlowedMoveData {\n             }\n         };\n \n-        do self.dfcx_assign.each_bit_on_entry_frozen(id) |index| {\n+        self.dfcx_assign.each_bit_on_entry_frozen(id, |index| {\n             let assignment = &self.move_data.var_assignments[index];\n             if assignment.path == loan_path_index && !f(assignment) {\n                 false\n             } else {\n                 true\n             }\n-        }\n+        })\n     }\n }\n "}, {"sha": "a65dc88ce9984a290b1d4d8e3d2540372b581931", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=8ceb374ab783c6417b60867e7f34bebe997936ac", "patch": "@@ -134,13 +134,13 @@ fn check_arms(cx: &MatchCheckCtxt, arms: &[Arm]) {\n                 }\n             };\n \n-            do walk_pat(*pat) |p| {\n+            walk_pat(*pat, |p| {\n                 if pat_matches_nan(p) {\n                     cx.tcx.sess.span_warn(p.span, \"unmatchable NaN in pattern, \\\n                                                    use the is_nan method in a guard instead\");\n                 }\n                 true\n-            };\n+            });\n \n             let v = ~[*pat];\n             match is_useful(cx, &seen, v) {\n@@ -275,14 +275,14 @@ fn is_useful(cx: &MatchCheckCtxt, m: &matrix, v: &[@Pat]) -> useful {\n                 is_useful_specialized(cx, m, v, vec(n), n, left_ty)\n               }\n               ty::ty_unboxed_vec(*) | ty::ty_evec(*) => {\n-                let max_len = do m.rev_iter().fold(0) |max_len, r| {\n+                let max_len = m.rev_iter().fold(0, |max_len, r| {\n                   match r[0].node {\n                     PatVec(ref before, _, ref after) => {\n                       num::max(before.len() + after.len(), max_len)\n                     }\n                     _ => max_len\n                   }\n-                };\n+                });\n                 for n in iter::range(0u, max_len + 1) {\n                   match is_useful_specialized(cx, m, v, vec(n), n, left_ty) {\n                     not_useful => (),\n@@ -454,14 +454,14 @@ fn missing_ctor(cx: &MatchCheckCtxt,\n       ty::ty_unboxed_vec(*) | ty::ty_evec(*) => {\n \n         // Find the lengths and slices of all vector patterns.\n-        let vec_pat_lens = do m.iter().filter_map |r| {\n+        let vec_pat_lens = m.iter().filter_map(|r| {\n             match r[0].node {\n                 PatVec(ref before, ref slice, ref after) => {\n                     Some((before.len() + after.len(), slice.is_some()))\n                 }\n                 _ => None\n             }\n-        }.collect::<~[(uint, bool)]>();\n+        }).collect::<~[(uint, bool)]>();\n \n         // Sort them by length such that for patterns of the same length,\n         // those with a destructured slice come first.\n@@ -886,7 +886,7 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n     let mut by_ref_span = None;\n     let mut any_by_move = false;\n     for pat in pats.iter() {\n-        do pat_bindings(def_map, *pat) |bm, id, span, _path| {\n+        pat_bindings(def_map, *pat, |bm, id, span, _path| {\n             match bm {\n                 BindByRef(_) => {\n                     by_ref_span = Some(span);\n@@ -897,7 +897,7 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n                     }\n                 }\n             }\n-        }\n+        })\n     }\n \n     let check_move: |&Pat, Option<@Pat>| = |p, sub| {\n@@ -925,7 +925,7 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n \n     if !any_by_move { return; } // pointless micro-optimization\n     for pat in pats.iter() {\n-        do walk_pat(*pat) |p| {\n+        walk_pat(*pat, |p| {\n             if pat_is_binding(def_map, p) {\n                 match p.node {\n                     PatIdent(_, _, sub) => {\n@@ -943,6 +943,6 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n                 }\n             }\n             true\n-        };\n+        });\n     }\n }"}, {"sha": "28d6f9515a83609fdffe479c71160fc0e7830ced", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=8ceb374ab783c6417b60867e7f34bebe997936ac", "patch": "@@ -219,9 +219,7 @@ impl ConstEvalVisitor {\n             }\n \n             ast::ExprStruct(_, ref fs, None) => {\n-                let cs = do fs.iter().map |f| {\n-                    self.classify(f.expr)\n-                };\n+                let cs = fs.iter().map(|f| self.classify(f.expr));\n                 join_all(cs)\n             }\n "}, {"sha": "e10e53d257598a8f28b170226a618ceb1384f792", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=8ceb374ab783c6417b60867e7f34bebe997936ac", "patch": "@@ -208,17 +208,17 @@ impl<O:DataFlowOperator> DataFlowContext<O> {\n     fn compute_id_range(&mut self, id: ast::NodeId) -> (uint, uint) {\n         let mut expanded = false;\n         let len = self.nodeid_to_bitset.len();\n-        let n = do self.nodeid_to_bitset.find_or_insert_with(id) |_| {\n+        let n = self.nodeid_to_bitset.find_or_insert_with(id, |_| {\n             expanded = true;\n             len\n-        };\n+        });\n         if expanded {\n             let entry = if self.oper.initial_value() { uint::max_value } else {0};\n-            do self.words_per_id.times {\n+            self.words_per_id.times(|| {\n                 self.gens.push(0);\n                 self.kills.push(0);\n                 self.on_entry.push(entry);\n-            }\n+            })\n         }\n         let start = *n * self.words_per_id;\n         let end = start + self.words_per_id;\n@@ -835,12 +835,12 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n         debug!(\"DataFlowContext::walk_pat(pat={}, in_out={})\",\n                pat.repr(self.dfcx.tcx), bits_to_str(reslice(in_out)));\n \n-        do ast_util::walk_pat(pat) |p| {\n+        ast_util::walk_pat(pat, |p| {\n             debug!(\"  p.id={:?} in_out={}\", p.id, bits_to_str(reslice(in_out)));\n             self.merge_with_entry_set(p.id, in_out);\n             self.dfcx.apply_gen_kill(p.id, in_out);\n             true\n-        };\n+        });\n     }\n \n     fn walk_pat_alternatives(&mut self,"}, {"sha": "ce2aae3e36bcfcdd2c3ce3f59f0decff4f5ca79e", "filename": "src/librustc/middle/graph.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fgraph.rs?ref=8ceb374ab783c6417b60867e7f34bebe997936ac", "patch": "@@ -318,22 +318,22 @@ mod test {\n     fn each_node() {\n         let graph = create_graph();\n         let expected = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\"];\n-        do graph.each_node |idx, node| {\n+        graph.each_node(|idx, node| {\n             assert_eq!(&expected[*idx], graph.node_data(idx));\n             assert_eq!(expected[*idx], node.data);\n             true\n-        };\n+        });\n     }\n \n     #[test]\n     fn each_edge() {\n         let graph = create_graph();\n         let expected = [\"AB\", \"BC\", \"BD\", \"DE\", \"EC\", \"FB\"];\n-        do graph.each_edge |idx, edge| {\n+        graph.each_edge(|idx, edge| {\n             assert_eq!(&expected[*idx], graph.edge_data(idx));\n             assert_eq!(expected[*idx], edge.data);\n             true\n-        };\n+        });\n     }\n \n     fn test_adjacent_edges<N:Eq,E:Eq>(graph: &Graph<N,E>,\n@@ -344,7 +344,7 @@ mod test {\n         assert_eq!(graph.node_data(start_index), &start_data);\n \n         let mut counter = 0;\n-        do graph.each_incoming_edge(start_index) |edge_index, edge| {\n+        graph.each_incoming_edge(start_index, |edge_index, edge| {\n             assert_eq!(graph.edge_data(edge_index), &edge.data);\n             assert!(counter < expected_incoming.len());\n             debug!(\"counter={:?} expected={:?} edge_index={:?} edge={:?}\",\n@@ -358,11 +358,11 @@ mod test {\n             }\n             counter += 1;\n             true\n-        };\n+        });\n         assert_eq!(counter, expected_incoming.len());\n \n         let mut counter = 0;\n-        do graph.each_outgoing_edge(start_index) |edge_index, edge| {\n+        graph.each_outgoing_edge(start_index, |edge_index, edge| {\n             assert_eq!(graph.edge_data(edge_index), &edge.data);\n             assert!(counter < expected_outgoing.len());\n             debug!(\"counter={:?} expected={:?} edge_index={:?} edge={:?}\",\n@@ -376,7 +376,7 @@ mod test {\n             }\n             counter += 1;\n             true\n-        };\n+        });\n         assert_eq!(counter, expected_outgoing.len());\n     }\n "}, {"sha": "3bc103519dac9707211877ea848072c209285c2b", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=8ceb374ab783c6417b60867e7f34bebe997936ac", "patch": "@@ -125,14 +125,14 @@ fn check_impl_of_trait(cx: &mut Context, it: @item, trait_ref: &trait_ref, self_\n     // If this trait has builtin-kind supertraits, meet them.\n     let self_ty: ty::t = ty::node_id_to_type(cx.tcx, it.id);\n     debug!(\"checking impl with self type {:?}\", ty::get(self_ty).sty);\n-    do check_builtin_bounds(cx, self_ty, trait_def.bounds) |missing| {\n+    check_builtin_bounds(cx, self_ty, trait_def.bounds, |missing| {\n         cx.tcx.sess.span_err(self_type.span,\n             format!(\"the type `{}', which does not fulfill `{}`, cannot implement this \\\n                   trait\", ty_to_str(cx.tcx, self_ty), missing.user_string(cx.tcx)));\n         cx.tcx.sess.span_note(self_type.span,\n             format!(\"types implementing this trait must fulfill `{}`\",\n                  trait_def.bounds.user_string(cx.tcx)));\n-    }\n+    });\n \n     // If this is a destructor, check kinds.\n     if cx.tcx.lang_items.drop_trait() == Some(trait_def_id) {\n@@ -255,12 +255,12 @@ fn check_fn(\n     fn_id: NodeId) {\n \n     // Check kinds on free variables:\n-    do with_appropriate_checker(cx, fn_id) |chk| {\n+    with_appropriate_checker(cx, fn_id, |chk| {\n         let r = freevars::get_freevars(cx.tcx, fn_id);\n         for fv in r.iter() {\n             chk(cx, *fv);\n         }\n-    }\n+    });\n \n     visit::walk_fn(cx, fk, decl, body, sp, fn_id, ());\n }\n@@ -374,20 +374,23 @@ pub fn check_typaram_bounds(cx: &Context,\n                     ty: ty::t,\n                     type_param_def: &ty::TypeParameterDef)\n {\n-    do check_builtin_bounds(cx, ty, type_param_def.bounds.builtin_bounds) |missing| {\n+    check_builtin_bounds(cx,\n+                         ty,\n+                         type_param_def.bounds.builtin_bounds,\n+                         |missing| {\n         cx.tcx.sess.span_err(\n             sp,\n             format!(\"instantiating a type parameter with an incompatible type \\\n                   `{}`, which does not fulfill `{}`\",\n                  ty_to_str(cx.tcx, ty),\n                  missing.user_string(cx.tcx)));\n-    }\n+    });\n }\n \n pub fn check_freevar_bounds(cx: &Context, sp: Span, ty: ty::t,\n                             bounds: ty::BuiltinBounds, referenced_ty: Option<ty::t>)\n {\n-    do check_builtin_bounds(cx, ty, bounds) |missing| {\n+    check_builtin_bounds(cx, ty, bounds, |missing| {\n         // Will be Some if the freevar is implicitly borrowed (stack closure).\n         // Emit a less mysterious error message in this case.\n         match referenced_ty {\n@@ -404,18 +407,18 @@ pub fn check_freevar_bounds(cx: &Context, sp: Span, ty: ty::t,\n             sp,\n             format!(\"this closure's environment must satisfy `{}`\",\n                  bounds.user_string(cx.tcx)));\n-    }\n+    });\n }\n \n pub fn check_trait_cast_bounds(cx: &Context, sp: Span, ty: ty::t,\n                                bounds: ty::BuiltinBounds) {\n-    do check_builtin_bounds(cx, ty, bounds) |missing| {\n+    check_builtin_bounds(cx, ty, bounds, |missing| {\n         cx.tcx.sess.span_err(sp,\n             format!(\"cannot pack type `{}`, which does not fulfill \\\n                   `{}`, as a trait bounded by {}\",\n                  ty_to_str(cx.tcx, ty), missing.user_string(cx.tcx),\n                  bounds.user_string(cx.tcx)));\n-    }\n+    });\n }\n \n fn is_nullary_variant(cx: &Context, ex: @Expr) -> bool {"}, {"sha": "5babebef2f662780297f0cd6d47ae5aa6c65d8ea", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=8ceb374ab783c6417b60867e7f34bebe997936ac", "patch": "@@ -413,14 +413,13 @@ impl LanguageItemCollector {\n \n     pub fn collect_external_language_items(&mut self) {\n         let crate_store = self.session.cstore;\n-        do iter_crate_data(crate_store) |crate_number, _crate_metadata| {\n-            do each_lang_item(crate_store, crate_number)\n-                    |node_id, item_index| {\n+        iter_crate_data(crate_store, |crate_number, _crate_metadata| {\n+            each_lang_item(crate_store, crate_number, |node_id, item_index| {\n                 let def_id = ast::DefId { crate: crate_number, node: node_id };\n                 self.collect_item(item_index, def_id);\n                 true\n-            };\n-        }\n+            });\n+        })\n     }\n \n     pub fn collect(&mut self, crate: &ast::Crate) {"}, {"sha": "29e28204bd98f10aedb61e16e0a0244cf5c2e229", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 27, "deletions": 29, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=8ceb374ab783c6417b60867e7f34bebe997936ac", "patch": "@@ -441,7 +441,7 @@ impl<'self> Context<'self> {\n         // of what we changed so we can roll everything back after invoking the\n         // specified closure\n         let mut pushed = 0u;\n-        do each_lint(self.tcx.sess, attrs) |meta, level, lintname| {\n+        each_lint(self.tcx.sess, attrs, |meta, level, lintname| {\n             match self.dict.find_equiv(&lintname) {\n                 None => {\n                     self.span_lint(\n@@ -467,7 +467,7 @@ impl<'self> Context<'self> {\n                 }\n             }\n             true\n-        };\n+        });\n \n         let old_is_doc_hidden = self.is_doc_hidden;\n         self.is_doc_hidden = self.is_doc_hidden ||\n@@ -479,10 +479,10 @@ impl<'self> Context<'self> {\n \n         // rollback\n         self.is_doc_hidden = old_is_doc_hidden;\n-        do pushed.times {\n+        pushed.times(|| {\n             let (lint, lvl, src) = self.lint_stack.pop();\n             self.set_level(lint, lvl, src);\n-        }\n+        })\n     }\n \n     fn visit_ids(&self, f: |&mut ast_util::IdVisitor<Context>|) {\n@@ -1135,11 +1135,11 @@ fn check_stability(cx: &Context, e: &ast::Expr) {\n         // this crate\n         match cx.tcx.items.find(&id.node) {\n             Some(ast_node) => {\n-                let s = do ast_node.with_attrs |attrs| {\n-                    do attrs.map |a| {\n+                let s = ast_node.with_attrs(|attrs| {\n+                    attrs.map(|a| {\n                         attr::find_stability(a.iter().map(|a| a.meta()))\n-                    }\n-                };\n+                    })\n+                });\n                 match s {\n                     Some(s) => s,\n \n@@ -1157,11 +1157,11 @@ fn check_stability(cx: &Context, e: &ast::Expr) {\n         let mut s = None;\n         // run through all the attributes and take the first\n         // stability one.\n-        do csearch::get_item_attrs(cx.tcx.cstore, id) |meta_items| {\n+        csearch::get_item_attrs(cx.tcx.cstore, id, |meta_items| {\n             if s.is_none() {\n                 s = attr::find_stability(meta_items.move_iter())\n             }\n-        }\n+        });\n         s\n     };\n \n@@ -1189,20 +1189,18 @@ fn check_stability(cx: &Context, e: &ast::Expr) {\n \n impl<'self> Visitor<()> for Context<'self> {\n     fn visit_item(&mut self, it: @ast::item, _: ()) {\n-        do self.with_lint_attrs(it.attrs) |cx| {\n+        self.with_lint_attrs(it.attrs, |cx| {\n             check_item_ctypes(cx, it);\n             check_item_non_camel_case_types(cx, it);\n             check_item_non_uppercase_statics(cx, it);\n             check_heap_item(cx, it);\n             check_missing_doc_item(cx, it);\n             check_attrs_usage(cx, it.attrs);\n \n-            do cx.visit_ids |v| {\n-                v.visit_item(it, ());\n-            }\n+            cx.visit_ids(|v| v.visit_item(it, ()));\n \n             visit::walk_item(cx, it, ());\n-        }\n+        })\n     }\n \n     fn visit_foreign_item(&mut self, it: @ast::foreign_item, _: ()) {\n@@ -1266,28 +1264,28 @@ impl<'self> Visitor<()> for Context<'self> {\n \n         match *fk {\n             visit::fk_method(_, _, m) => {\n-                do self.with_lint_attrs(m.attrs) |cx| {\n+                self.with_lint_attrs(m.attrs, |cx| {\n                     check_missing_doc_method(cx, m);\n                     check_attrs_usage(cx, m.attrs);\n \n-                    do cx.visit_ids |v| {\n+                    cx.visit_ids(|v| {\n                         v.visit_fn(fk, decl, body, span, id, ());\n-                    }\n+                    });\n                     recurse(cx);\n-                }\n+                })\n             }\n             _ => recurse(self),\n         }\n     }\n \n \n     fn visit_ty_method(&mut self, t: &ast::TypeMethod, _: ()) {\n-        do self.with_lint_attrs(t.attrs) |cx| {\n+        self.with_lint_attrs(t.attrs, |cx| {\n             check_missing_doc_ty_method(cx, t);\n             check_attrs_usage(cx, t.attrs);\n \n             visit::walk_ty_method(cx, t, ());\n-        }\n+        })\n     }\n \n     fn visit_struct_def(&mut self,\n@@ -1303,21 +1301,21 @@ impl<'self> Visitor<()> for Context<'self> {\n     }\n \n     fn visit_struct_field(&mut self, s: @ast::struct_field, _: ()) {\n-        do self.with_lint_attrs(s.node.attrs) |cx| {\n+        self.with_lint_attrs(s.node.attrs, |cx| {\n             check_missing_doc_struct_field(cx, s);\n             check_attrs_usage(cx, s.node.attrs);\n \n             visit::walk_struct_field(cx, s, ());\n-        }\n+        })\n     }\n \n     fn visit_variant(&mut self, v: &ast::variant, g: &ast::Generics, _: ()) {\n-        do self.with_lint_attrs(v.node.attrs) |cx| {\n+        self.with_lint_attrs(v.node.attrs, |cx| {\n             check_missing_doc_variant(cx, v);\n             check_attrs_usage(cx, v.node.attrs);\n \n             visit::walk_variant(cx, v, g, ());\n-        }\n+        })\n     }\n }\n \n@@ -1356,16 +1354,16 @@ pub fn check_crate(tcx: ty::ctxt,\n     for &(lint, level) in tcx.sess.opts.lint_opts.iter() {\n         cx.set_level(lint, level, CommandLine);\n     }\n-    do cx.with_lint_attrs(crate.attrs) |cx| {\n-        do cx.visit_ids |v| {\n+    cx.with_lint_attrs(crate.attrs, |cx| {\n+        cx.visit_ids(|v| {\n             v.visited_outermost = true;\n             visit::walk_crate(v, crate, ());\n-        }\n+        });\n \n         check_crate_attrs_usage(cx, crate.attrs);\n \n         visit::walk_crate(cx, crate, ());\n-    }\n+    });\n \n     // If we missed any lints added to the session, then there's a bug somewhere\n     // in the iteration code."}, {"sha": "4f137f1f5c45d717c97ff1f307df4c790e6d0047", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 44, "deletions": 42, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=8ceb374ab783c6417b60867e7f34bebe997936ac", "patch": "@@ -381,12 +381,13 @@ fn visit_fn(v: &mut LivenessVisitor,\n     }\n \n     for arg in decl.inputs.iter() {\n-        do pat_util::pat_bindings(this.tcx.def_map, arg.pat)\n-                |_bm, arg_id, _x, path| {\n+        pat_util::pat_bindings(this.tcx.def_map,\n+                               arg.pat,\n+                               |_bm, arg_id, _x, path| {\n             debug!(\"adding argument {}\", arg_id);\n             let ident = ast_util::path_to_ident(path);\n             fn_maps.add_variable(Arg(arg_id, ident));\n-        }\n+        })\n     };\n \n     // Add `this`, whether explicit or implicit.\n@@ -429,7 +430,7 @@ fn visit_fn(v: &mut LivenessVisitor,\n \n fn visit_local(v: &mut LivenessVisitor, local: @Local, this: @mut IrMaps) {\n     let def_map = this.tcx.def_map;\n-    do pat_util::pat_bindings(def_map, local.pat) |bm, p_id, sp, path| {\n+    pat_util::pat_bindings(def_map, local.pat, |bm, p_id, sp, path| {\n         debug!(\"adding local variable {}\", p_id);\n         let name = ast_util::path_to_ident(path);\n         this.add_live_node_for_node(p_id, VarDefNode(sp));\n@@ -447,14 +448,14 @@ fn visit_local(v: &mut LivenessVisitor, local: @Local, this: @mut IrMaps) {\n           is_mutbl: mutbl,\n           kind: kind\n         }));\n-    }\n+    });\n     visit::walk_local(v, local, this);\n }\n \n fn visit_arm(v: &mut LivenessVisitor, arm: &Arm, this: @mut IrMaps) {\n     let def_map = this.tcx.def_map;\n     for pat in arm.pats.iter() {\n-        do pat_util::pat_bindings(def_map, *pat) |bm, p_id, sp, path| {\n+        pat_util::pat_bindings(def_map, *pat, |bm, p_id, sp, path| {\n             debug!(\"adding local variable {} from match with bm {:?}\",\n                    p_id, bm);\n             let name = ast_util::path_to_ident(path);\n@@ -469,7 +470,7 @@ fn visit_arm(v: &mut LivenessVisitor, arm: &Arm, this: @mut IrMaps) {\n                 is_mutbl: mutbl,\n                 kind: FromMatch(bm)\n             }));\n-        }\n+        })\n     }\n     visit::walk_arm(v, arm, this);\n }\n@@ -628,9 +629,9 @@ impl Liveness {\n         match expr.node {\n           ExprPath(_) => {\n             let def = self.tcx.def_map.get_copy(&expr.id);\n-            do moves::moved_variable_node_id_from_def(def).map |rdef| {\n+            moves::moved_variable_node_id_from_def(def).map(|rdef| {\n                 self.variable(rdef, expr.span)\n-            }\n+            })\n           }\n           _ => None\n         }\n@@ -644,9 +645,9 @@ impl Liveness {\n                                  -> Option<Variable> {\n         match self.tcx.def_map.find(&node_id) {\n           Some(&def) => {\n-            do moves::moved_variable_node_id_from_def(def).map |rdef| {\n+            moves::moved_variable_node_id_from_def(def).map(|rdef| {\n                 self.variable(rdef, span)\n-            }\n+            })\n           }\n           None => {\n             self.tcx.sess.span_bug(\n@@ -659,11 +660,11 @@ impl Liveness {\n                         pat: @Pat,\n                         f: |LiveNode, Variable, Span, NodeId|) {\n         let def_map = self.tcx.def_map;\n-        do pat_util::pat_bindings(def_map, pat) |_bm, p_id, sp, _n| {\n+        pat_util::pat_bindings(def_map, pat, |_bm, p_id, sp, _n| {\n             let ln = self.live_node(p_id, sp);\n             let var = self.variable(p_id, sp);\n             f(ln, var, sp, p_id);\n-        }\n+        })\n     }\n \n     pub fn arm_pats_bindings(&self,\n@@ -685,11 +686,11 @@ impl Liveness {\n     pub fn define_bindings_in_arm_pats(&self, pats: &[@Pat], succ: LiveNode)\n                                        -> LiveNode {\n         let mut succ = succ;\n-        do self.arm_pats_bindings(pats) |ln, var, _sp, _id| {\n+        self.arm_pats_bindings(pats, |ln, var, _sp, _id| {\n             self.init_from_succ(ln, succ);\n             self.define(ln, var);\n             succ = ln;\n-        }\n+        });\n         succ\n     }\n \n@@ -792,14 +793,14 @@ impl Liveness {\n     }\n \n     pub fn ln_str(&self, ln: LiveNode) -> ~str {\n-        str::from_utf8_owned(do io::mem::with_mem_writer |wr| {\n+        str::from_utf8_owned(io::mem::with_mem_writer(|wr| {\n             let wr = wr as &mut io::Writer;\n             write!(wr, \"[ln({}) of kind {:?} reads\", *ln, self.ir.lnks[*ln]);\n             self.write_vars(wr, ln, |idx| self.users[idx].reader );\n             write!(wr, \"  writes\");\n             self.write_vars(wr, ln, |idx| self.users[idx].writer );\n             write!(wr, \"  precedes {}]\", self.successors[*ln].to_str());\n-        })\n+        }))\n     }\n \n     pub fn init_empty(&self, ln: LiveNode, succ_ln: LiveNode) {\n@@ -833,7 +834,7 @@ impl Liveness {\n         if ln == succ_ln { return false; }\n \n         let mut changed = false;\n-        do self.indices2(ln, succ_ln) |idx, succ_idx| {\n+        self.indices2(ln, succ_ln, |idx, succ_idx| {\n             let users = &mut *self.users;\n             changed |= copy_if_invalid(users[succ_idx].reader,\n                                        &mut users[idx].reader);\n@@ -843,7 +844,7 @@ impl Liveness {\n                 users[idx].used = true;\n                 changed = true;\n             }\n-        }\n+        });\n \n         debug!(\"merge_from_succ(ln={}, succ={}, first_merge={}, changed={})\",\n                ln.to_str(), self.ln_str(succ_ln), first_merge, changed);\n@@ -939,9 +940,9 @@ impl Liveness {\n     pub fn propagate_through_block(&self, blk: &Block, succ: LiveNode)\n                                    -> LiveNode {\n         let succ = self.propagate_through_opt_expr(blk.expr, succ);\n-        do blk.stmts.rev_iter().fold(succ) |succ, stmt| {\n+        blk.stmts.rev_iter().fold(succ, |succ, stmt| {\n             self.propagate_through_stmt(*stmt, succ)\n-        }\n+        })\n     }\n \n     pub fn propagate_through_stmt(&self, stmt: &Stmt, succ: LiveNode)\n@@ -993,18 +994,18 @@ impl Liveness {\n \n     pub fn propagate_through_exprs(&self, exprs: &[@Expr], succ: LiveNode)\n                                    -> LiveNode {\n-        do exprs.rev_iter().fold(succ) |succ, expr| {\n+        exprs.rev_iter().fold(succ, |succ, expr| {\n             self.propagate_through_expr(*expr, succ)\n-        }\n+        })\n     }\n \n     pub fn propagate_through_opt_expr(&self,\n                                       opt_expr: Option<@Expr>,\n                                       succ: LiveNode)\n                                       -> LiveNode {\n-        do opt_expr.iter().fold(succ) |succ, expr| {\n+        opt_expr.iter().fold(succ, |succ, expr| {\n             self.propagate_through_expr(*expr, succ)\n-        }\n+        })\n     }\n \n     pub fn propagate_through_expr(&self, expr: @Expr, succ: LiveNode)\n@@ -1037,12 +1038,12 @@ impl Liveness {\n                  // the construction of a closure itself is not important,\n                  // but we have to consider the closed over variables.\n                  let caps = self.ir.captures(expr);\n-                 do caps.rev_iter().fold(succ) |succ, cap| {\n+                 caps.rev_iter().fold(succ, |succ, cap| {\n                      self.init_from_succ(cap.ln, succ);\n                      let var = self.variable(cap.var_nid, expr.span);\n                      self.acc(cap.ln, var, ACC_READ | ACC_USE);\n                      cap.ln\n-                 }\n+                 })\n               })\n           }\n \n@@ -1177,9 +1178,9 @@ impl Liveness {\n \n           ExprStruct(_, ref fields, with_expr) => {\n             let succ = self.propagate_through_opt_expr(with_expr, succ);\n-            do fields.rev_iter().fold(succ) |succ, field| {\n+            fields.rev_iter().fold(succ, |succ, field| {\n                 self.propagate_through_expr(field.expr, succ)\n-            }\n+            })\n           }\n \n           ExprCall(f, ref args, _) => {\n@@ -1230,15 +1231,15 @@ impl Liveness {\n           }\n \n           ExprInlineAsm(ref ia) => {\n-            let succ = do ia.inputs.rev_iter().fold(succ) |succ, &(_, expr)| {\n+            let succ = ia.inputs.rev_iter().fold(succ, |succ, &(_, expr)| {\n                 self.propagate_through_expr(expr, succ)\n-            };\n-            do ia.outputs.rev_iter().fold(succ) |succ, &(_, expr)| {\n+            });\n+            ia.outputs.rev_iter().fold(succ, |succ, &(_, expr)| {\n                 // see comment on lvalues in\n                 // propagate_through_lvalue_components()\n                 let succ = self.write_lvalue(expr, succ, ACC_WRITE);\n                 self.propagate_through_lvalue_components(expr, succ)\n-            }\n+            })\n           }\n \n           ExprLogLevel |\n@@ -1437,7 +1438,7 @@ fn check_local(this: &mut Liveness, local: @Local) {\n         // should not be live at this point.\n \n         debug!(\"check_local() with no initializer\");\n-        do this.pat_bindings(local.pat) |ln, var, sp, id| {\n+        this.pat_bindings(local.pat, |ln, var, sp, id| {\n             if !this.warn_about_unused(sp, id, ln, var) {\n                 match this.live_on_exit(ln, var) {\n                   None => { /* not live: good */ }\n@@ -1448,17 +1449,17 @@ fn check_local(this: &mut Liveness, local: @Local) {\n                   }\n                 }\n             }\n-        }\n+        })\n       }\n     }\n \n     visit::walk_local(this, local, ());\n }\n \n fn check_arm(this: &mut Liveness, arm: &Arm) {\n-    do this.arm_pats_bindings(arm.pats) |ln, var, sp, id| {\n+    this.arm_pats_bindings(arm.pats, |ln, var, sp, id| {\n         this.warn_about_unused(sp, id, ln, var);\n-    }\n+    });\n     visit::walk_arm(this, arm, ());\n }\n \n@@ -1620,20 +1621,21 @@ impl Liveness {\n \n     pub fn warn_about_unused_args(&self, decl: &fn_decl, entry_ln: LiveNode) {\n         for arg in decl.inputs.iter() {\n-            do pat_util::pat_bindings(self.tcx.def_map, arg.pat)\n-                    |_bm, p_id, sp, _n| {\n+            pat_util::pat_bindings(self.tcx.def_map,\n+                                   arg.pat,\n+                                   |_bm, p_id, sp, _n| {\n                 let var = self.variable(p_id, sp);\n                 self.warn_about_unused(sp, p_id, entry_ln, var);\n-            }\n+            })\n         }\n     }\n \n     pub fn warn_about_unused_or_dead_vars_in_pat(&self, pat: @Pat) {\n-        do self.pat_bindings(pat) |ln, var, sp, id| {\n+        self.pat_bindings(pat, |ln, var, sp, id| {\n             if !self.warn_about_unused(sp, id, ln, var) {\n                 self.warn_about_dead_assign(sp, id, ln, var);\n             }\n-        }\n+        })\n     }\n \n     pub fn warn_about_unused(&self,"}, {"sha": "93465dc9bac9144832372b6e9da33ae805e6ddb4", "filename": "src/librustc/middle/moves.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=8ceb374ab783c6417b60867e7f34bebe997936ac", "patch": "@@ -614,7 +614,7 @@ impl VisitContext {\n          * into itself or not based on its type and annotation.\n          */\n \n-        do pat_bindings(self.tcx.def_map, pat) |bm, id, _span, path| {\n+        pat_bindings(self.tcx.def_map, pat, |bm, id, _span, path| {\n             let binding_moves = match bm {\n                 BindByRef(_) => false,\n                 BindByValue(_) => {\n@@ -633,7 +633,7 @@ impl VisitContext {\n             if binding_moves {\n                 self.move_maps.moves_map.insert(id);\n             }\n-        }\n+        })\n     }\n \n     pub fn use_receiver(&mut self,"}, {"sha": "69e9e4d880df05352f6b26f37df4dc478251c1d6", "filename": "src/librustc/middle/pat_util.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fpat_util.rs?ref=8ceb374ab783c6417b60867e7f34bebe997936ac", "patch": "@@ -22,9 +22,9 @@ pub type PatIdMap = HashMap<Ident, NodeId>;\n // use the NodeId of their namesake in the first pattern.\n pub fn pat_id_map(dm: resolve::DefMap, pat: &Pat) -> PatIdMap {\n     let mut map = HashMap::new();\n-    do pat_bindings(dm, pat) |_bm, p_id, _s, n| {\n+    pat_bindings(dm, pat, |_bm, p_id, _s, n| {\n       map.insert(path_to_ident(n), p_id);\n-    };\n+    });\n     map\n }\n \n@@ -75,15 +75,15 @@ pub fn pat_is_binding_or_wild(dm: resolve::DefMap, pat: &Pat) -> bool {\n pub fn pat_bindings(dm: resolve::DefMap,\n                     pat: &Pat,\n                     it: |BindingMode, NodeId, Span, &Path|) {\n-    do walk_pat(pat) |p| {\n+    walk_pat(pat, |p| {\n         match p.node {\n           PatIdent(binding_mode, ref pth, _) if pat_is_binding(dm, p) => {\n             it(binding_mode, p.id, p.span, pth);\n           }\n           _ => {}\n         }\n         true\n-    };\n+    });\n }\n \n pub fn pat_binding_ids(dm: resolve::DefMap, pat: &Pat) -> ~[NodeId] {\n@@ -96,13 +96,13 @@ pub fn pat_binding_ids(dm: resolve::DefMap, pat: &Pat) -> ~[NodeId] {\n /// an ident, e.g. `foo`, or `Foo(foo)` or `foo @ Bar(*)`.\n pub fn pat_contains_bindings(dm: resolve::DefMap, pat: &Pat) -> bool {\n     let mut contains_bindings = false;\n-    do walk_pat(pat) |p| {\n+    walk_pat(pat, |p| {\n         if pat_is_binding(dm, p) {\n             contains_bindings = true;\n             false // there's at least one binding, can short circuit now.\n         } else {\n             true\n         }\n-    };\n+    });\n     contains_bindings\n }"}, {"sha": "49f26568d3726babaa7345d08f945966409afad0", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 78, "deletions": 66, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=8ceb374ab783c6417b60867e7f34bebe997936ac", "patch": "@@ -909,11 +909,12 @@ impl<'self> Visitor<ReducedGraphParent> for BuildReducedGraphVisitor<'self> {\n \n     fn visit_foreign_item(&mut self, foreign_item: @foreign_item,\n                           context:ReducedGraphParent) {\n-        do self.resolver.build_reduced_graph_for_foreign_item(foreign_item,\n-                                                              context) |r, c| {\n+        self.resolver.build_reduced_graph_for_foreign_item(foreign_item,\n+                                                           context,\n+                                                           |r, c| {\n             let mut v = BuildReducedGraphVisitor{ resolver: r };\n             visit::walk_foreign_item(&mut v, foreign_item, c);\n-        }\n+        })\n     }\n \n     fn visit_view_item(&mut self, view_item:&view_item, context:ReducedGraphParent) {\n@@ -1227,11 +1228,11 @@ impl Resolver {\n \n                 // If this is a newtype or unit-like struct, define a name\n                 // in the value namespace as well\n-                do ctor_id.while_some |cid| {\n+                ctor_id.while_some(|cid| {\n                     name_bindings.define_value(DefStruct(local_def(cid)), sp,\n                                                is_public);\n                     None\n-                }\n+                });\n \n                 // Record the def ID of this struct.\n                 self.structs.insert(local_def(item.id));\n@@ -1553,12 +1554,12 @@ impl Resolver {\n                 let def = DefFn(local_def(foreign_item.id), unsafe_fn);\n                 name_bindings.define_value(def, foreign_item.span, is_public);\n \n-                do self.with_type_parameter_rib(\n-                    HasTypeParameters(\n-                        generics, foreign_item.id, 0, NormalRibKind)) |this|\n-                {\n-                    f(this, new_parent)\n-                }\n+                self.with_type_parameter_rib(\n+                    HasTypeParameters(generics,\n+                                      foreign_item.id,\n+                                      0,\n+                                      NormalRibKind),\n+                    |this| f(this, new_parent));\n             }\n             foreign_item_static(_, m) => {\n                 let def = DefStatic(local_def(foreign_item.id), m);\n@@ -1758,15 +1759,17 @@ impl Resolver {\n                     DefForeignMod(def_id) => {\n                         // Foreign modules have no names. Recur and populate\n                         // eagerly.\n-                        do csearch::each_child_of_item(self.session.cstore,\n-                                                       def_id)\n-                                |def_like, child_ident, vis| {\n+                        csearch::each_child_of_item(self.session.cstore,\n+                                                    def_id,\n+                                                    |def_like,\n+                                                     child_ident,\n+                                                     vis| {\n                             self.build_reduced_graph_for_external_crate_def(\n                                 root,\n                                 def_like,\n                                 child_ident,\n                                 vis)\n-                        }\n+                        });\n                     }\n                     _ => {\n                         let (child_name_bindings, new_parent) =\n@@ -1893,15 +1896,16 @@ impl Resolver {\n             Some(def_id) => def_id,\n         };\n \n-        do csearch::each_child_of_item(self.session.cstore, def_id)\n-                |def_like, child_ident, visibility| {\n+        csearch::each_child_of_item(self.session.cstore,\n+                                    def_id,\n+                                    |def_like, child_ident, visibility| {\n             debug!(\"(populating external module) ... found ident: {}\",\n                    token::ident_to_str(&child_ident));\n             self.build_reduced_graph_for_external_crate_def(module,\n                                                             def_like,\n                                                             child_ident,\n                                                             visibility)\n-        }\n+        });\n         module.populated = true\n     }\n \n@@ -1918,14 +1922,14 @@ impl Resolver {\n     /// crate.\n     fn build_reduced_graph_for_external_crate(&mut self,\n                                               root: @mut Module) {\n-        do csearch::each_top_level_item_of_crate(self.session.cstore,\n-                                                 root.def_id.unwrap().crate)\n-                |def_like, ident, visibility| {\n+        csearch::each_top_level_item_of_crate(self.session.cstore,\n+                                              root.def_id.unwrap().crate,\n+                                              |def_like, ident, visibility| {\n             self.build_reduced_graph_for_external_crate_def(root,\n                                                             def_like,\n                                                             ident,\n                                                             visibility)\n-        }\n+        });\n     }\n \n     /// Creates and adds an import directive to the given module.\n@@ -3544,20 +3548,23 @@ impl Resolver {\n                 // n.b. the discr expr gets visted twice.\n                 // but maybe it's okay since the first time will signal an\n                 // error if there is one? -- tjc\n-                do self.with_type_parameter_rib(\n-                    HasTypeParameters(\n-                        generics, item.id, 0, NormalRibKind)) |this| {\n+                self.with_type_parameter_rib(HasTypeParameters(generics,\n+                                                               item.id,\n+                                                               0,\n+                                                               NormalRibKind),\n+                                             |this| {\n                     visit::walk_item(this, item, ());\n-                }\n+                });\n             }\n \n             item_ty(_, ref generics) => {\n-                do self.with_type_parameter_rib\n-                        (HasTypeParameters(generics, item.id, 0,\n-                                           NormalRibKind))\n-                        |this| {\n+                self.with_type_parameter_rib(HasTypeParameters(generics,\n+                                                               item.id,\n+                                                               0,\n+                                                               NormalRibKind),\n+                                             |this| {\n                     visit::walk_item(this, item, ());\n-                }\n+                });\n             }\n \n             item_impl(ref generics,\n@@ -3581,10 +3588,11 @@ impl Resolver {\n                                               DlDef(DefSelfTy(item.id)));\n \n                 // Create a new rib for the trait-wide type parameters.\n-                do self.with_type_parameter_rib\n-                        (HasTypeParameters(generics, item.id, 0,\n-                                           NormalRibKind)) |this| {\n-\n+                self.with_type_parameter_rib(HasTypeParameters(generics,\n+                                                               item.id,\n+                                                               0,\n+                                                               NormalRibKind),\n+                                             |this| {\n                     this.resolve_type_parameters(&generics.ty_params);\n \n                     // Resolve derived traits.\n@@ -3600,11 +3608,12 @@ impl Resolver {\n \n                         match *method {\n                           required(ref ty_m) => {\n-                            do this.with_type_parameter_rib\n+                            this.with_type_parameter_rib\n                                 (HasTypeParameters(&ty_m.generics,\n                                                    item.id,\n                                                    generics.ty_params.len(),\n-                                        MethodRibKind(item.id, Required))) |this| {\n+                                        MethodRibKind(item.id, Required)),\n+                                 |this| {\n \n                                 // Resolve the method-specific type\n                                 // parameters.\n@@ -3616,7 +3625,7 @@ impl Resolver {\n                                 }\n \n                                 this.resolve_type(&ty_m.decl.output);\n-                            }\n+                            });\n                           }\n                           provided(m) => {\n                               this.resolve_method(MethodRibKind(item.id,\n@@ -3626,7 +3635,7 @@ impl Resolver {\n                           }\n                         }\n                     }\n-                }\n+                });\n \n                 self.type_ribs.pop();\n             }\n@@ -3638,14 +3647,14 @@ impl Resolver {\n             }\n \n             item_mod(ref module_) => {\n-                do self.with_scope(Some(item.ident)) |this| {\n+                self.with_scope(Some(item.ident), |this| {\n                     this.resolve_module(module_, item.span, item.ident,\n                                         item.id);\n-                }\n+                });\n             }\n \n             item_foreign_mod(ref foreign_module) => {\n-                do self.with_scope(Some(item.ident)) |this| {\n+                self.with_scope(Some(item.ident), |this| {\n                     for foreign_item in foreign_module.items.iter() {\n                         match foreign_item.node {\n                             foreign_item_fn(_, ref generics) => {\n@@ -3664,7 +3673,7 @@ impl Resolver {\n                             }\n                         }\n                     }\n-                }\n+                });\n             }\n \n             item_fn(ref fn_decl, _, _, ref generics, ref block) => {\n@@ -3764,7 +3773,7 @@ impl Resolver {\n         self.label_ribs.push(function_label_rib);\n \n         // If this function has type parameters, add them now.\n-        do self.with_type_parameter_rib(type_parameters) |this| {\n+        self.with_type_parameter_rib(type_parameters, |this| {\n             // Resolve the type parameters.\n             match type_parameters {\n                 NoTypeParameters => {\n@@ -3815,7 +3824,7 @@ impl Resolver {\n             this.resolve_block(block);\n \n             debug!(\"(resolving function) leaving function\");\n-        }\n+        });\n \n         self.label_ribs.pop();\n         self.value_ribs.pop();\n@@ -3890,18 +3899,19 @@ impl Resolver {\n         }\n \n         // If applicable, create a rib for the type parameters.\n-        do self.with_type_parameter_rib(HasTypeParameters\n-                                        (generics, id, 0,\n-                                         OpaqueFunctionRibKind)) |this| {\n-\n+        self.with_type_parameter_rib(HasTypeParameters(generics,\n+                                                       id,\n+                                                       0,\n+                                                       OpaqueFunctionRibKind),\n+                                     |this| {\n             // Resolve the type parameters.\n             this.resolve_type_parameters(&generics.ty_params);\n \n             // Resolve fields.\n             for field in fields.iter() {\n                 this.resolve_type(&field.node.ty);\n             }\n-        }\n+        });\n     }\n \n     // Does this really need to take a RibKind or is it always going\n@@ -3937,9 +3947,11 @@ impl Resolver {\n                                   methods: &[@method]) {\n         // If applicable, create a rib for the type parameters.\n         let outer_type_parameter_count = generics.ty_params.len();\n-        do self.with_type_parameter_rib(HasTypeParameters\n-                                        (generics, id, 0,\n-                                         NormalRibKind)) |this| {\n+        self.with_type_parameter_rib(HasTypeParameters(generics,\n+                                                       id,\n+                                                       0,\n+                                                       NormalRibKind),\n+                                     |this| {\n             // Resolve the type parameters.\n             this.resolve_type_parameters(&generics.ty_params);\n \n@@ -4000,7 +4012,7 @@ impl Resolver {\n                 Some(r) => { this.current_trait_refs = r; }\n                 None => ()\n             }\n-        }\n+        });\n     }\n \n     fn resolve_module(&mut self,\n@@ -4037,12 +4049,12 @@ impl Resolver {\n     // user and one 'x' came from the macro.\n     fn binding_mode_map(&mut self, pat: @Pat) -> BindingMap {\n         let mut result = HashMap::new();\n-        do pat_bindings(self.def_map, pat) |binding_mode, _id, sp, path| {\n+        pat_bindings(self.def_map, pat, |binding_mode, _id, sp, path| {\n             let name = mtwt_resolve(path_to_ident(path));\n             result.insert(name,\n                           binding_info {span: sp,\n                                         binding_mode: binding_mode});\n-        }\n+        });\n         return result;\n     }\n \n@@ -4210,19 +4222,19 @@ impl Resolver {\n                     }\n                 }\n \n-                do bounds.as_ref().map |bound_vec| {\n+                bounds.as_ref().map(|bound_vec| {\n                     for bound in bound_vec.iter() {\n                         self.resolve_type_parameter_bound(ty.id, bound);\n                     }\n-                };\n+                });\n             }\n \n             ty_closure(c) => {\n-                do c.bounds.as_ref().map |bounds| {\n+                c.bounds.as_ref().map(|bounds| {\n                     for bound in bounds.iter() {\n                         self.resolve_type_parameter_bound(ty.id, bound);\n                     }\n-                };\n+                });\n                 visit::walk_ty(self, ty, ());\n             }\n \n@@ -4240,7 +4252,7 @@ impl Resolver {\n                        // pattern that binds them\n                        bindings_list: Option<@mut HashMap<Name,NodeId>>) {\n         let pat_id = pattern.id;\n-        do walk_pat(pattern) |pattern| {\n+        walk_pat(pattern, |pattern| {\n             match pattern.node {\n                 PatIdent(binding_mode, ref path, _)\n                         if !path.global && path.segments.len() == 1 => {\n@@ -4480,7 +4492,7 @@ impl Resolver {\n                 }\n             }\n             true\n-        };\n+        });\n     }\n \n     fn resolve_bare_identifier_pattern(&mut self, name: Ident)\n@@ -5056,14 +5068,14 @@ impl Resolver {\n             }\n \n             ExprLoop(_, Some(label)) => {\n-                do self.with_label_rib |this| {\n+                self.with_label_rib(|this| {\n                     let def_like = DlDef(DefLabel(expr.id));\n                     let rib = this.label_ribs[this.label_ribs.len() - 1];\n                     // plain insert (no renaming)\n                     rib.bindings.insert(label.name, def_like);\n \n                     visit::walk_expr(this, expr, ());\n-                }\n+                })\n             }\n \n             ExprForLoop(*) => fail!(\"non-desugared expr_for_loop\"),\n@@ -5316,15 +5328,15 @@ impl Resolver {\n         debug!(\"(recording def) recording {:?} for {:?}, last private {:?}\",\n                 def, node_id, lp);\n         self.last_private.insert(node_id, lp);\n-        do self.def_map.insert_or_update_with(node_id, def) |_, old_value| {\n+        self.def_map.insert_or_update_with(node_id, def, |_, old_value| {\n             // Resolve appears to \"resolve\" the same ID multiple\n             // times, so here is a sanity check it at least comes to\n             // the same conclusion! - nmatsakis\n             if def != *old_value {\n                 self.session.bug(format!(\"node_id {:?} resolved first to {:?} \\\n                                       and then {:?}\", node_id, *old_value, def));\n             }\n-        };\n+        });\n     }\n \n     fn enforce_default_binding_mode(&mut self,"}, {"sha": "1162f845ed07ac7f40d6df167b8bb0a2233dd17d", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 55, "deletions": 55, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=8ceb374ab783c6417b60867e7f34bebe997936ac", "patch": "@@ -446,7 +446,7 @@ fn expand_nested_bindings<'r>(bcx: @mut Block,\n            bcx.val_to_str(val));\n     let _indenter = indenter();\n \n-    do m.map |br| {\n+    m.map(|br| {\n         match br.pats[col].node {\n             ast::PatIdent(_, ref path, Some(inner)) => {\n                 let pats = vec::append(\n@@ -465,7 +465,7 @@ fn expand_nested_bindings<'r>(bcx: @mut Block,\n             }\n             _ => (*br).clone(),\n         }\n-    }\n+    })\n }\n \n fn assert_is_binding_or_wild(bcx: @mut Block, p: @ast::Pat) {\n@@ -543,13 +543,13 @@ fn enter_default<'r>(bcx: @mut Block,\n     let _indenter = indenter();\n \n     // Collect all of the matches that can match against anything.\n-    let matches = do enter_match(bcx, dm, m, col, val) |p| {\n+    let matches = enter_match(bcx, dm, m, col, val, |p| {\n         match p.node {\n           ast::PatWild | ast::PatWildMulti | ast::PatTup(_) => Some(~[]),\n           ast::PatIdent(_, _, None) if pat_is_binding(dm, p) => Some(~[]),\n           _ => None\n         }\n-    };\n+    });\n \n     // Ok, now, this is pretty subtle. A \"default\" match is a match\n     // that needs to be considered if none of the actual checks on the\n@@ -616,7 +616,7 @@ fn enter_opt<'r>(bcx: @mut Block,\n     let tcx = bcx.tcx();\n     let dummy = @ast::Pat {id: 0, node: ast::PatWild, span: dummy_sp()};\n     let mut i = 0;\n-    do enter_match(bcx, tcx.def_map, m, col, val) |p| {\n+    enter_match(bcx, tcx.def_map, m, col, val, |p| {\n         let answer = match p.node {\n             ast::PatEnum(*) |\n             ast::PatIdent(_, _, None) if pat_is_const(tcx.def_map, p) => {\n@@ -731,7 +731,7 @@ fn enter_opt<'r>(bcx: @mut Block,\n         };\n         i += 1;\n         answer\n-    }\n+    })\n }\n \n fn enter_rec_or_struct<'r>(bcx: @mut Block,\n@@ -749,7 +749,7 @@ fn enter_rec_or_struct<'r>(bcx: @mut Block,\n     let _indenter = indenter();\n \n     let dummy = @ast::Pat {id: 0, node: ast::PatWild, span: dummy_sp()};\n-    do enter_match(bcx, dm, m, col, val) |p| {\n+    enter_match(bcx, dm, m, col, val, |p| {\n         match p.node {\n             ast::PatStruct(_, ref fpats, _) => {\n                 let mut pats = ~[];\n@@ -766,7 +766,7 @@ fn enter_rec_or_struct<'r>(bcx: @mut Block,\n                 Some(vec::from_elem(fields.len(), dummy))\n             }\n         }\n-    }\n+    })\n }\n \n fn enter_tup<'r>(bcx: @mut Block,\n@@ -784,15 +784,15 @@ fn enter_tup<'r>(bcx: @mut Block,\n     let _indenter = indenter();\n \n     let dummy = @ast::Pat {id: 0, node: ast::PatWild, span: dummy_sp()};\n-    do enter_match(bcx, dm, m, col, val) |p| {\n+    enter_match(bcx, dm, m, col, val, |p| {\n         match p.node {\n             ast::PatTup(ref elts) => Some((*elts).clone()),\n             _ => {\n                 assert_is_binding_or_wild(bcx, p);\n                 Some(vec::from_elem(n_elts, dummy))\n             }\n         }\n-    }\n+    })\n }\n \n fn enter_tuple_struct<'r>(bcx: @mut Block,\n@@ -810,15 +810,15 @@ fn enter_tuple_struct<'r>(bcx: @mut Block,\n     let _indenter = indenter();\n \n     let dummy = @ast::Pat {id: 0, node: ast::PatWild, span: dummy_sp()};\n-    do enter_match(bcx, dm, m, col, val) |p| {\n+    enter_match(bcx, dm, m, col, val, |p| {\n         match p.node {\n             ast::PatEnum(_, Some(ref elts)) => Some((*elts).clone()),\n             _ => {\n                 assert_is_binding_or_wild(bcx, p);\n                 Some(vec::from_elem(n_elts, dummy))\n             }\n         }\n-    }\n+    })\n }\n \n fn enter_box<'r>(bcx: @mut Block,\n@@ -835,7 +835,7 @@ fn enter_box<'r>(bcx: @mut Block,\n     let _indenter = indenter();\n \n     let dummy = @ast::Pat {id: 0, node: ast::PatWild, span: dummy_sp()};\n-    do enter_match(bcx, dm, m, col, val) |p| {\n+    enter_match(bcx, dm, m, col, val, |p| {\n         match p.node {\n             ast::PatBox(sub) => {\n                 Some(~[sub])\n@@ -845,7 +845,7 @@ fn enter_box<'r>(bcx: @mut Block,\n                 Some(~[dummy])\n             }\n         }\n-    }\n+    })\n }\n \n fn enter_uniq<'r>(bcx: @mut Block,\n@@ -862,7 +862,7 @@ fn enter_uniq<'r>(bcx: @mut Block,\n     let _indenter = indenter();\n \n     let dummy = @ast::Pat {id: 0, node: ast::PatWild, span: dummy_sp()};\n-    do enter_match(bcx, dm, m, col, val) |p| {\n+    enter_match(bcx, dm, m, col, val, |p| {\n         match p.node {\n             ast::PatUniq(sub) => {\n                 Some(~[sub])\n@@ -872,7 +872,7 @@ fn enter_uniq<'r>(bcx: @mut Block,\n                 Some(~[dummy])\n             }\n         }\n-    }\n+    })\n }\n \n fn enter_region<'r>(bcx: @mut Block,\n@@ -889,7 +889,7 @@ fn enter_region<'r>(bcx: @mut Block,\n     let _indenter = indenter();\n \n     let dummy = @ast::Pat { id: 0, node: ast::PatWild, span: dummy_sp() };\n-    do enter_match(bcx, dm, m, col, val) |p| {\n+    enter_match(bcx, dm, m, col, val, |p| {\n         match p.node {\n             ast::PatRegion(sub) => {\n                 Some(~[sub])\n@@ -899,7 +899,7 @@ fn enter_region<'r>(bcx: @mut Block,\n                 Some(~[dummy])\n             }\n         }\n-    }\n+    })\n }\n \n // Returns the options in one column of matches. An option is something that\n@@ -998,9 +998,9 @@ fn extract_variant_args(bcx: @mut Block,\n                             val: ValueRef)\n     -> ExtractedBlock {\n     let _icx = push_ctxt(\"match::extract_variant_args\");\n-    let args = do vec::from_fn(adt::num_args(repr, disr_val)) |i| {\n+    let args = vec::from_fn(adt::num_args(repr, disr_val), |i| {\n         adt::trans_field_ptr(bcx, repr, val, disr_val, i)\n-    };\n+    });\n \n     ExtractedBlock { vals: args, bcx: bcx }\n }\n@@ -1028,7 +1028,7 @@ fn extract_vec_elems(bcx: @mut Block,\n     let (bcx, base, len) = vec_datum.get_vec_base_and_len(bcx, pat_span, pat_id, 0);\n     let vt = tvec::vec_types(bcx, node_id_type(bcx, pat_id));\n \n-    let mut elems = do vec::from_fn(elem_count) |i| {\n+    let mut elems = vec::from_fn(elem_count, |i| {\n         match slice {\n             None => GEPi(bcx, base, [i]),\n             Some(n) if i < n => GEPi(bcx, base, [i]),\n@@ -1039,7 +1039,7 @@ fn extract_vec_elems(bcx: @mut Block,\n             }\n             _ => unsafe { llvm::LLVMGetUndef(vt.llunit_ty.to_ref()) }\n         }\n-    };\n+    });\n     if slice.is_some() {\n         let n = slice.unwrap();\n         let slice_byte_offset = Mul(bcx, vt.llunit_size, C_uint(bcx.ccx(), n));\n@@ -1108,11 +1108,11 @@ fn pats_require_rooting(bcx: @mut Block,\n                             m: &[Match],\n                             col: uint)\n                          -> bool {\n-    do m.iter().any |br| {\n+    m.iter().any(|br| {\n         let pat_id = br.pats[col].id;\n         let key = root_map_key {id: pat_id, derefs: 0u };\n         bcx.ccx().maps.root_map.contains_key(&key)\n-    }\n+    })\n }\n \n fn root_pats_as_necessary(mut bcx: @mut Block,\n@@ -1137,12 +1137,12 @@ fn root_pats_as_necessary(mut bcx: @mut Block,\n // matches may be wildcards like _ or identifiers).\n macro_rules! any_pat (\n     ($m:expr, $pattern:pat) => (\n-        do ($m).iter().any |br| {\n+        ($m).iter().any(|br| {\n             match br.pats[col].node {\n                 $pattern => true,\n                 _ => false\n             }\n-        }\n+        })\n     )\n )\n \n@@ -1163,7 +1163,7 @@ fn any_tup_pat(m: &[Match], col: uint) -> bool {\n }\n \n fn any_tuple_struct_pat(bcx: @mut Block, m: &[Match], col: uint) -> bool {\n-    do m.iter().any |br| {\n+    m.iter().any(|br| {\n         let pat = br.pats[col];\n         match pat.node {\n             ast::PatEnum(_, Some(_)) => {\n@@ -1175,7 +1175,7 @@ fn any_tuple_struct_pat(bcx: @mut Block, m: &[Match], col: uint) -> bool {\n             }\n             _ => false\n         }\n-    }\n+    })\n }\n \n trait CustomFailureHandler {\n@@ -1335,11 +1335,11 @@ fn store_non_ref_bindings(bcx: @mut Block,\n                 let datum = Datum {val: llval, ty: binding_info.ty,\n                                    mode: ByRef(ZeroMem)};\n                 bcx = datum.store_to(bcx, INIT, lldest);\n-                do opt_temp_cleanups.mutate |temp_cleanups| {\n+                opt_temp_cleanups.mutate(|temp_cleanups| {\n                     add_clean_temp_mem(bcx, lldest, binding_info.ty);\n                     temp_cleanups.push(lldest);\n                     temp_cleanups\n-                };\n+                });\n             }\n             TrByRef => {}\n         }\n@@ -1412,10 +1412,9 @@ fn compile_guard(bcx: @mut Block,\n     bcx = insert_lllocals(bcx, data.bindings_map, false);\n \n     let val = unpack_result!(bcx, {\n-        do with_scope_result(bcx, guard_expr.info(),\n-                             \"guard\") |bcx| {\n+        with_scope_result(bcx, guard_expr.info(), \"guard\", |bcx| {\n             expr::trans_to_datum(bcx, guard_expr).to_result()\n-        }\n+        })\n     });\n     let val = bool_to_i1(bcx, val);\n \n@@ -1424,13 +1423,13 @@ fn compile_guard(bcx: @mut Block,\n         revoke_clean(bcx, *llval);\n     }\n \n-    return do with_cond(bcx, Not(bcx, val)) |bcx| {\n+    return with_cond(bcx, Not(bcx, val), |bcx| {\n         // Guard does not match: free the values we copied,\n         // and remove all bindings from the lllocals table\n         let bcx = drop_bindings(bcx, data);\n         compile_submatch(bcx, m, vals, chk);\n         bcx\n-    };\n+    });\n \n     fn drop_bindings(bcx: @mut Block, data: &ArmData) -> @mut Block {\n         let mut bcx = bcx;\n@@ -1530,7 +1529,7 @@ fn compile_submatch_continue(mut bcx: @mut Block,\n         Some(ref rec_fields) => {\n             let pat_ty = node_id_type(bcx, pat_id);\n             let pat_repr = adt::represent_type(bcx.ccx(), pat_ty);\n-            do expr::with_field_tys(tcx, pat_ty, None) |discr, field_tys| {\n+            expr::with_field_tys(tcx, pat_ty, None, |discr, field_tys| {\n                 let rec_vals = rec_fields.map(|field_name| {\n                         let ix = ty::field_idx_strict(tcx, field_name.name, field_tys);\n                         adt::trans_field_ptr(bcx, pat_repr, val, discr, ix)\n@@ -1540,7 +1539,7 @@ fn compile_submatch_continue(mut bcx: @mut Block,\n                         enter_rec_or_struct(bcx, dm, m, col, *rec_fields, val),\n                         vec::append(rec_vals, vals_left),\n                         chk);\n-            }\n+            });\n             return;\n         }\n         None => {}\n@@ -1553,9 +1552,9 @@ fn compile_submatch_continue(mut bcx: @mut Block,\n           ty::ty_tup(ref elts) => elts.len(),\n           _ => ccx.sess.bug(\"non-tuple type in tuple pattern\")\n         };\n-        let tup_vals = do vec::from_fn(n_tup_elts) |i| {\n+        let tup_vals = vec::from_fn(n_tup_elts, |i| {\n             adt::trans_field_ptr(bcx, tup_repr, val, 0, i)\n-        };\n+        });\n         compile_submatch(bcx, enter_tup(bcx, dm, m, col, val, n_tup_elts),\n                          vec::append(tup_vals, vals_left), chk);\n         return;\n@@ -1575,9 +1574,9 @@ fn compile_submatch_continue(mut bcx: @mut Block,\n         }\n \n         let struct_repr = adt::represent_type(bcx.ccx(), struct_ty);\n-        let llstructvals = do vec::from_fn(struct_element_count) |i| {\n+        let llstructvals = vec::from_fn(struct_element_count, |i| {\n             adt::trans_field_ptr(bcx, struct_repr, val, 0, i)\n-        };\n+        });\n         compile_submatch(bcx,\n                          enter_tuple_struct(bcx, dm, m, col, val,\n                                             struct_element_count),\n@@ -1696,8 +1695,7 @@ fn compile_submatch_continue(mut bcx: @mut Block,\n               compare => {\n                   let t = node_id_type(bcx, pat_id);\n                   let Result {bcx: after_cx, val: matches} = {\n-                      do with_scope_result(bcx, None,\n-                                           \"compaReScope\") |bcx| {\n+                      with_scope_result(bcx, None, \"compaReScope\", |bcx| {\n                           match trans_opt(bcx, opt) {\n                               single_result(\n                                   Result {bcx, val}) => {\n@@ -1723,15 +1721,17 @@ fn compile_submatch_continue(mut bcx: @mut Block,\n                                   rslt(bcx, And(bcx, llge, llle))\n                               }\n                           }\n-                      }\n+                      })\n                   };\n                   bcx = sub_block(after_cx, \"compare_next\");\n                   CondBr(after_cx, matches, opt_cx.llbb, bcx.llbb);\n               }\n               compare_vec_len => {\n                   let Result {bcx: after_cx, val: matches} = {\n-                      do with_scope_result(bcx, None,\n-                                           \"compare_vec_len_scope\") |bcx| {\n+                      with_scope_result(bcx,\n+                                        None,\n+                                        \"compare_vec_len_scope\",\n+                                        |bcx| {\n                           match trans_opt(bcx, opt) {\n                               single_result(\n                                   Result {bcx, val}) => {\n@@ -1761,7 +1761,7 @@ fn compile_submatch_continue(mut bcx: @mut Block,\n                                   rslt(bcx, And(bcx, llge, llle))\n                               }\n                           }\n-                      }\n+                      })\n                   };\n                   bcx = sub_block(after_cx, \"compare_vec_len_next\");\n \n@@ -1821,9 +1821,9 @@ pub fn trans_match(bcx: @mut Block,\n                    arms: &[ast::Arm],\n                    dest: Dest) -> @mut Block {\n     let _icx = push_ctxt(\"match::trans_match\");\n-    do with_scope(bcx, match_expr.info(), \"match\") |bcx| {\n+    with_scope(bcx, match_expr.info(), \"match\", |bcx| {\n         trans_match_inner(bcx, discr_expr, arms, dest)\n-    }\n+    })\n }\n \n fn create_bindings_map(bcx: @mut Block, pat: @ast::Pat) -> BindingsMap {\n@@ -1834,7 +1834,7 @@ fn create_bindings_map(bcx: @mut Block, pat: @ast::Pat) -> BindingsMap {\n     let ccx = bcx.ccx();\n     let tcx = bcx.tcx();\n     let mut bindings_map = HashMap::new();\n-    do pat_bindings(tcx.def_map, pat) |bm, p_id, span, path| {\n+    pat_bindings(tcx.def_map, pat, |bm, p_id, span, path| {\n         let ident = path_to_ident(path);\n         let variable_ty = node_id_type(bcx, p_id);\n         let llvariable_ty = type_of::type_of(ccx, variable_ty);\n@@ -1862,7 +1862,7 @@ fn create_bindings_map(bcx: @mut Block, pat: @ast::Pat) -> BindingsMap {\n             span: span,\n             ty: variable_ty\n         });\n-    }\n+    });\n     return bindings_map;\n }\n \n@@ -2009,11 +2009,11 @@ pub fn store_local(bcx: @mut Block,\n         // create dummy memory for the variables if we have no\n         // value to store into them immediately\n         let tcx = bcx.tcx();\n-        do pat_bindings(tcx.def_map, pat) |_, p_id, _, path| {\n+        pat_bindings(tcx.def_map, pat, |_, p_id, _, path| {\n             bcx = mk_binding_alloca(\n                 bcx, p_id, path, BindLocal,\n                 |bcx, var_ty, llval| { zero_mem(bcx, llval, var_ty); bcx });\n-        }\n+        });\n         bcx\n     }\n }\n@@ -2201,14 +2201,14 @@ fn bind_irrefutable_pat(bcx: @mut Block,\n             let tcx = bcx.tcx();\n             let pat_ty = node_id_type(bcx, pat.id);\n             let pat_repr = adt::represent_type(bcx.ccx(), pat_ty);\n-            do expr::with_field_tys(tcx, pat_ty, None) |discr, field_tys| {\n+            expr::with_field_tys(tcx, pat_ty, None, |discr, field_tys| {\n                 for f in fields.iter() {\n                     let ix = ty::field_idx_strict(tcx, f.ident.name, field_tys);\n                     let fldptr = adt::trans_field_ptr(bcx, pat_repr, val,\n                                                       discr, ix);\n                     bcx = bind_irrefutable_pat(bcx, f.pat, fldptr, binding_mode);\n                 }\n-            }\n+            })\n         }\n         ast::PatTup(ref elems) => {\n             let repr = adt::represent_node(bcx, pat.id);"}, {"sha": "d6631f6d833cd4fa2205ebe1088efd25a48baf7c", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=8ceb374ab783c6417b60867e7f34bebe997936ac", "patch": "@@ -135,9 +135,9 @@ fn represent_type_uncached(cx: &mut CrateContext, t: ty::t) -> Repr {\n         }\n         ty::ty_struct(def_id, ref substs) => {\n             let fields = ty::lookup_struct_fields(cx.tcx, def_id);\n-            let mut ftys = do fields.map |field| {\n+            let mut ftys = fields.map(|field| {\n                 ty::lookup_field_type(cx.tcx, def_id, field.id, substs)\n-            };\n+            });\n             let packed = ty::lookup_packed(cx.tcx, def_id);\n             let dtor = ty::ty_dtor(cx.tcx, def_id).has_drop_flag();\n             if dtor { ftys.push(ty::mk_bool()); }\n@@ -259,12 +259,12 @@ impl Case {\n }\n \n fn get_cases(tcx: ty::ctxt, def_id: ast::DefId, substs: &ty::substs) -> ~[Case] {\n-    do ty::enum_variants(tcx, def_id).map |vi| {\n-        let arg_tys = do vi.args.map |&raw_ty| {\n+    ty::enum_variants(tcx, def_id).map(|vi| {\n+        let arg_tys = vi.args.map(|&raw_ty| {\n             ty::subst(tcx, substs, raw_ty)\n-        };\n+        });\n         Case { discr: vi.disr_val, tys: arg_tys }\n-    }\n+    })\n }\n \n \n@@ -659,9 +659,7 @@ fn struct_field_ptr(bcx: @mut Block, st: &Struct, val: ValueRef, ix: uint,\n     let ccx = bcx.ccx();\n \n     let val = if needs_cast {\n-        let fields = do st.fields.map |&ty| {\n-            type_of::type_of(ccx, ty)\n-        };\n+        let fields = st.fields.map(|&ty| type_of::type_of(ccx, ty));\n         let real_ty = Type::struct_(fields, st.packed);\n         PointerCast(bcx, val, real_ty.ptr_to())\n     } else {\n@@ -725,10 +723,10 @@ pub fn trans_const(ccx: &mut CrateContext, r: &Repr, discr: Disr,\n                 C_struct(build_const_struct(ccx, nonnull, vals), false)\n             } else {\n                 assert_eq!(vals.len(), 0);\n-                let vals = do nonnull.fields.iter().enumerate().map |(i, &ty)| {\n+                let vals = nonnull.fields.iter().enumerate().map(|(i, &ty)| {\n                     let llty = type_of::sizing_type_of(ccx, ty);\n                     if i == ptrfield { C_null(llty) } else { C_undef(llty) }\n-                }.collect::<~[ValueRef]>();\n+                }).collect::<~[ValueRef]>();\n                 C_struct(build_const_struct(ccx, nonnull, vals), false)\n             }\n         }"}, {"sha": "7b936b61976bcdb1dec651da636428ae2494c15a", "filename": "src/librustc/middle/trans/asm.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs?ref=8ceb374ab783c6417b60867e7f34bebe997936ac", "patch": "@@ -35,22 +35,22 @@ pub fn trans_inline_asm(bcx: @mut Block, ia: &ast::inline_asm) -> @mut Block {\n     let mut output_types = ~[];\n \n     // Prepare the output operands\n-    let outputs = do ia.outputs.map |&(c, out)| {\n+    let outputs = ia.outputs.map(|&(c, out)| {\n         constraints.push(c);\n \n         let out_datum = unpack_datum!(bcx, trans_to_datum(bcx, out));\n         output_types.push(type_of(bcx.ccx(), out_datum.ty));\n         out_datum.val\n \n-    };\n+    });\n \n     for c in cleanups.iter() {\n         revoke_clean(bcx, *c);\n     }\n     cleanups.clear();\n \n     // Now the input operands\n-    let inputs = do ia.inputs.map |&(c, input)| {\n+    let inputs = ia.inputs.map(|&(c, input)| {\n         constraints.push(c);\n \n         unpack_result!(bcx, {\n@@ -61,8 +61,7 @@ pub fn trans_inline_asm(bcx: @mut Block, ia: &ast::inline_asm) -> @mut Block {\n                                    &mut cleanups,\n                                    callee::DontAutorefArg)\n         })\n-\n-    };\n+    });\n \n     for c in cleanups.iter() {\n         revoke_clean(bcx, *c);\n@@ -103,11 +102,11 @@ pub fn trans_inline_asm(bcx: @mut Block, ia: &ast::inline_asm) -> @mut Block {\n         ast::asm_intel => lib::llvm::AD_Intel\n     };\n \n-    let r = do ia.asm.with_c_str |a| {\n-        do constraints.with_c_str |c| {\n+    let r = ia.asm.with_c_str(|a| {\n+        constraints.with_c_str(|c| {\n             InlineAsmCall(bcx, a, c, inputs, output_type, ia.volatile, ia.alignstack, dialect)\n-        }\n-    };\n+        })\n+    });\n \n     // Again, based on how many outputs we have\n     if numOutputs == 1 {"}, {"sha": "de93b08f0859c579f5ae92135de0973a31bbf925", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 83, "deletions": 79, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=8ceb374ab783c6417b60867e7f34bebe997936ac", "patch": "@@ -94,12 +94,12 @@ pub use middle::trans::context::task_llcx;\n local_data_key!(task_local_insn_key: ~[&'static str])\n \n pub fn with_insn_ctxt(blk: |&[&'static str]|) {\n-    do local_data::get(task_local_insn_key) |c| {\n+    local_data::get(task_local_insn_key, |c| {\n         match c {\n             Some(ctx) => blk(*ctx),\n             None => ()\n         }\n-    }\n+    })\n }\n \n pub fn init_insn_ctxt() {\n@@ -111,23 +111,23 @@ pub struct _InsnCtxt { _x: () }\n #[unsafe_destructor]\n impl Drop for _InsnCtxt {\n     fn drop(&mut self) {\n-        do local_data::modify(task_local_insn_key) |c| {\n-            do c.map |mut ctx| {\n+        local_data::modify(task_local_insn_key, |c| {\n+            c.map(|mut ctx| {\n                 ctx.pop();\n                 ctx\n-            }\n-        }\n+            })\n+        })\n     }\n }\n \n pub fn push_ctxt(s: &'static str) -> _InsnCtxt {\n     debug!(\"new InsnCtxt: {}\", s);\n-    do local_data::modify(task_local_insn_key) |c| {\n-        do c.map |mut ctx| {\n+    local_data::modify(task_local_insn_key, |c| {\n+        c.map(|mut ctx| {\n             ctx.push(s);\n             ctx\n-        }\n-    }\n+        })\n+    });\n     _InsnCtxt { _x: () }\n }\n \n@@ -175,11 +175,11 @@ impl<'self> Drop for StatRecorder<'self> {\n \n // only use this for foreign function ABIs and glue, use `decl_rust_fn` for Rust functions\n pub fn decl_fn(llmod: ModuleRef, name: &str, cc: lib::llvm::CallConv, ty: Type) -> ValueRef {\n-    let llfn: ValueRef = do name.with_c_str |buf| {\n+    let llfn: ValueRef = name.with_c_str(|buf| {\n         unsafe {\n             llvm::LLVMGetOrInsertFunction(llmod, buf, ty.to_ref())\n         }\n-    };\n+    });\n \n     lib::llvm::SetFunctionCallConv(llfn, cc);\n     // Function addresses in Rust are never significant, allowing functions to be merged.\n@@ -211,9 +211,9 @@ fn get_extern_rust_fn(ccx: &mut CrateContext, inputs: &[ty::t], output: ty::t,\n         None => ()\n     }\n     let f = decl_rust_fn(ccx, inputs, output, name);\n-    do csearch::get_item_attrs(ccx.tcx.cstore, did) |meta_items| {\n+    csearch::get_item_attrs(ccx.tcx.cstore, did, |meta_items| {\n         set_llvm_fn_attrs(meta_items.iter().map(|&x| attr::mk_attr(x)).to_owned_vec(), f)\n-    }\n+    });\n     ccx.externs.insert(name.to_owned(), f);\n     f\n }\n@@ -285,9 +285,9 @@ pub fn get_extern_const(externs: &mut ExternMap, llmod: ModuleRef,\n         None => ()\n     }\n     unsafe {\n-        let c = do name.with_c_str |buf| {\n+        let c = name.with_c_str(|buf| {\n             llvm::LLVMAddGlobal(llmod, ty.to_ref(), buf)\n-        };\n+        });\n         externs.insert(name.to_owned(), c);\n         return c;\n     }\n@@ -496,9 +496,9 @@ pub fn set_always_inline(f: ValueRef) {\n }\n \n pub fn set_no_split_stack(f: ValueRef) {\n-    do \"no-split-stack\".with_c_str |buf| {\n+    \"no-split-stack\".with_c_str(|buf| {\n         unsafe { llvm::LLVMAddFunctionAttrString(f, buf); }\n-    }\n+    })\n }\n \n // Double-check that we never ask LLVM to declare the same symbol twice. It\n@@ -563,11 +563,11 @@ pub fn get_res_dtor(ccx: @mut CrateContext,\n // Structural comparison: a rather involved form of glue.\n pub fn maybe_name_value(cx: &CrateContext, v: ValueRef, s: &str) {\n     if cx.sess.opts.save_temps {\n-        do s.with_c_str |buf| {\n+        s.with_c_str(|buf| {\n             unsafe {\n                 llvm::LLVMSetValueName(v, buf)\n             }\n-        }\n+        })\n     }\n }\n \n@@ -704,12 +704,12 @@ pub fn iter_structural_ty(cx: @mut Block, av: ValueRef, t: ty::t,\n     match ty::get(t).sty {\n       ty::ty_struct(*) => {\n           let repr = adt::represent_type(cx.ccx(), t);\n-          do expr::with_field_tys(cx.tcx(), t, None) |discr, field_tys| {\n+          expr::with_field_tys(cx.tcx(), t, None, |discr, field_tys| {\n               for (i, field_ty) in field_tys.iter().enumerate() {\n                   let llfld_a = adt::trans_field_ptr(cx, repr, av, discr, i);\n                   cx = f(cx, llfld_a, field_ty.mt.ty);\n               }\n-          }\n+          })\n       }\n       ty::ty_estr(ty::vstore_fixed(_)) |\n       ty::ty_evec(_, ty::vstore_fixed(_)) => {\n@@ -836,9 +836,9 @@ pub fn fail_if_zero(cx: @mut Block, span: Span, divrem: ast::BinOp,\n                           ty_to_str(cx.ccx().tcx, rhs_t));\n       }\n     };\n-    do with_cond(cx, is_zero) |bcx| {\n+    with_cond(cx, is_zero, |bcx| {\n         controlflow::trans_fail(bcx, Some(span), text)\n-    }\n+    })\n }\n \n pub fn null_env_ptr(ccx: &CrateContext) -> ValueRef {\n@@ -959,12 +959,12 @@ pub fn need_invoke(bcx: @mut Block) -> bool {\n \n pub fn have_cached_lpad(bcx: @mut Block) -> bool {\n     let mut res = false;\n-    do in_lpad_scope_cx(bcx) |inf| {\n+    in_lpad_scope_cx(bcx, |inf| {\n         match inf.landing_pad {\n           Some(_) => res = true,\n           None => res = false\n         }\n-    }\n+    });\n     return res;\n }\n \n@@ -993,7 +993,7 @@ pub fn get_landing_pad(bcx: @mut Block) -> BasicBlockRef {\n \n     let mut cached = None;\n     let mut pad_bcx = bcx; // Guaranteed to be set below\n-    do in_lpad_scope_cx(bcx) |inf| {\n+    in_lpad_scope_cx(bcx, |inf| {\n         // If there is a valid landing pad still around, use it\n         match inf.landing_pad {\n           Some(target) => cached = Some(target),\n@@ -1002,7 +1002,7 @@ pub fn get_landing_pad(bcx: @mut Block) -> BasicBlockRef {\n             inf.landing_pad = Some(pad_bcx.llbb);\n           }\n         }\n-    }\n+    });\n     // Can't return from block above\n     match cached { Some(b) => return b, None => () }\n     // The landing pad return type (the type being propagated). Not sure what\n@@ -1187,9 +1187,9 @@ pub fn new_block(cx: @mut FunctionContext,\n                  opt_node_info: Option<NodeInfo>)\n               -> @mut Block {\n     unsafe {\n-        let llbb = do name.with_c_str |buf| {\n+        let llbb = name.with_c_str(|buf| {\n             llvm::LLVMAppendBasicBlockInContext(cx.ccx.llcx, cx.llfn, buf)\n-        };\n+        });\n         let bcx = @mut Block::new(llbb,\n                                   parent,\n                                   is_lpad,\n@@ -1614,18 +1614,18 @@ pub struct BasicBlocks {\n pub fn mk_staticallocas_basic_block(llfn: ValueRef) -> BasicBlockRef {\n     unsafe {\n         let cx = task_llcx();\n-        do \"static_allocas\".with_c_str | buf| {\n+        \"static_allocas\".with_c_str(|buf| {\n             llvm::LLVMAppendBasicBlockInContext(cx, llfn, buf)\n-        }\n+        })\n     }\n }\n \n pub fn mk_return_basic_block(llfn: ValueRef) -> BasicBlockRef {\n     unsafe {\n         let cx = task_llcx();\n-        do \"return\".with_c_str |buf| {\n+        \"return\".with_c_str(|buf| {\n             llvm::LLVMAppendBasicBlockInContext(cx, llfn, buf)\n-        }\n+        })\n     }\n }\n \n@@ -1765,9 +1765,9 @@ pub fn create_llargs_for_fn_args(cx: @mut FunctionContext,\n \n     // Return an array containing the ValueRefs that we get from\n     // llvm::LLVMGetParam for each argument.\n-    do vec::from_fn(args.len()) |i| {\n+    vec::from_fn(args.len(), |i| {\n         unsafe { llvm::LLVMGetParam(cx.llfn, cx.arg_pos(i) as c_uint) }\n-    }\n+    })\n }\n \n pub fn copy_args_to_allocas(fcx: @mut FunctionContext,\n@@ -2076,7 +2076,7 @@ pub fn trans_enum_variant_or_tuple_like_struct<A:IdAndTy>(\n     llfndecl: ValueRef)\n {\n     // Translate variant arguments to function arguments.\n-    let fn_args = do args.map |varg| {\n+    let fn_args = args.map(|varg| {\n         ast::arg {\n             ty: (*varg.ty()).clone(),\n             pat: ast_util::ident_to_pat(\n@@ -2085,7 +2085,7 @@ pub fn trans_enum_variant_or_tuple_like_struct<A:IdAndTy>(\n                 special_idents::arg),\n             id: varg.id(),\n         }\n-    };\n+    });\n \n     let no_substs: &[ty::t] = [];\n     let ty_param_substs = match param_substs {\n@@ -2386,11 +2386,11 @@ pub fn create_entry_wrapper(ccx: @mut CrateContext,\n             \"main\"\n         };\n         let llfn = decl_cdecl_fn(ccx.llmod, main_name, llfty);\n-        let llbb = do \"top\".with_c_str |buf| {\n+        let llbb = \"top\".with_c_str(|buf| {\n             unsafe {\n                 llvm::LLVMAppendBasicBlockInContext(ccx.llcx, llfn, buf)\n             }\n-        };\n+        });\n         let bld = ccx.builder.B;\n         unsafe {\n             llvm::LLVMPositionBuilderAtEnd(bld, llbb);\n@@ -2409,9 +2409,9 @@ pub fn create_entry_wrapper(ccx: @mut CrateContext,\n                 };\n \n                 let args = {\n-                    let opaque_rust_main = do \"rust_main\".with_c_str |buf| {\n+                    let opaque_rust_main = \"rust_main\".with_c_str(|buf| {\n                         llvm::LLVMBuildPointerCast(bld, rust_main, Type::i8p().to_ref(), buf)\n-                    };\n+                    });\n \n                     ~[\n                         C_null(Type::opaque_box(ccx).ptr_to()),\n@@ -2432,9 +2432,9 @@ pub fn create_entry_wrapper(ccx: @mut CrateContext,\n                 (rust_main, args)\n             };\n \n-            let result = do args.as_imm_buf |buf, len| {\n+            let result = args.as_imm_buf(|buf, len| {\n                 llvm::LLVMBuildCall(bld, start_fn, buf, len as c_uint, noname())\n-            };\n+            });\n \n             llvm::LLVMBuildRet(bld, result);\n         }\n@@ -2509,9 +2509,9 @@ pub fn get_item_val(ccx: @mut CrateContext, id: ast::NodeId) -> ValueRef {\n \n                             unsafe {\n                                 let llty = llvm::LLVMTypeOf(v);\n-                                let g = do sym.with_c_str |buf| {\n+                                let g = sym.with_c_str(|buf| {\n                                     llvm::LLVMAddGlobal(ccx.llmod, llty, buf)\n-                                };\n+                                });\n \n                                 if !ccx.reachable.contains(&id) {\n                                     lib::llvm::SetLinkage(g, lib::llvm::InternalLinkage);\n@@ -2571,9 +2571,9 @@ pub fn get_item_val(ccx: @mut CrateContext, id: ast::NodeId) -> ValueRef {\n \n                     match (attr::first_attr_value_str_by_name(i.attrs, \"link_section\")) {\n                         Some(sect) => unsafe {\n-                            do sect.with_c_str |buf| {\n+                            sect.with_c_str(|buf| {\n                                 llvm::LLVMSetSection(v, buf);\n-                            }\n+                            })\n                         },\n                         None => ()\n                     }\n@@ -2618,11 +2618,14 @@ pub fn get_item_val(ccx: @mut CrateContext, id: ast::NodeId) -> ValueRef {\n                             if attr::contains_name(ni.attrs, \"crate_map\") {\n                                 if *ccx.sess.building_library {\n                                     let s = \"_rust_crate_map_toplevel\";\n-                                    let g = unsafe { do s.with_c_str |buf| {\n-                                        let ty = type_of(ccx, ty);\n-                                        llvm::LLVMAddGlobal(ccx.llmod,\n-                                                            ty.to_ref(), buf)\n-                                    } };\n+                                    let g = unsafe {\n+                                        s.with_c_str(|buf| {\n+                                            let ty = type_of(ccx, ty);\n+                                            llvm::LLVMAddGlobal(ccx.llmod,\n+                                                                ty.to_ref(),\n+                                                                buf)\n+                                        })\n+                                    };\n                                     lib::llvm::SetLinkage(g,\n                                         lib::llvm::ExternalWeakLinkage);\n                                     g\n@@ -2632,11 +2635,11 @@ pub fn get_item_val(ccx: @mut CrateContext, id: ast::NodeId) -> ValueRef {\n                             } else {\n                                 let ident = foreign::link_name(ccx, ni);\n                                 unsafe {\n-                                    do ident.with_c_str |buf| {\n+                                    ident.with_c_str(|buf| {\n                                         let ty = type_of(ccx, ty);\n                                         llvm::LLVMAddGlobal(ccx.llmod,\n                                                             ty.to_ref(), buf)\n-                                    }\n+                                    })\n                                 }\n                             }\n                         }\n@@ -2904,11 +2907,11 @@ pub fn decl_gc_metadata(ccx: &mut CrateContext, llmod_id: &str) {\n     }\n \n     let gc_metadata_name = ~\"_gc_module_metadata_\" + llmod_id;\n-    let gc_metadata = do gc_metadata_name.with_c_str |buf| {\n+    let gc_metadata = gc_metadata_name.with_c_str(|buf| {\n         unsafe {\n             llvm::LLVMAddGlobal(ccx.llmod, Type::i32().to_ref(), buf)\n         }\n-    };\n+    });\n     unsafe {\n         llvm::LLVMSetGlobalConstant(gc_metadata, True);\n         lib::llvm::SetLinkage(gc_metadata, lib::llvm::ExternalLinkage);\n@@ -2920,11 +2923,11 @@ pub fn create_module_map(ccx: &mut CrateContext) -> (ValueRef, uint) {\n     let str_slice_type = Type::struct_([Type::i8p(), ccx.int_type], false);\n     let elttype = Type::struct_([str_slice_type, ccx.int_type], false);\n     let maptype = Type::array(&elttype, ccx.module_data.len() as u64);\n-    let map = do \"_rust_mod_map\".with_c_str |buf| {\n+    let map = \"_rust_mod_map\".with_c_str(|buf| {\n         unsafe {\n             llvm::LLVMAddGlobal(ccx.llmod, maptype.to_ref(), buf)\n         }\n-    };\n+    });\n     lib::llvm::SetLinkage(map, lib::llvm::InternalLinkage);\n     let mut elts: ~[ValueRef] = ~[];\n \n@@ -2973,11 +2976,11 @@ pub fn decl_crate_map(sess: session::Session, mapmeta: LinkMeta,\n         slicetype,          // sub crate-maps\n         int_type.ptr_to(),  // event loop factory\n     ], false);\n-    let map = do sym_name.with_c_str |buf| {\n+    let map = sym_name.with_c_str(|buf| {\n         unsafe {\n             llvm::LLVMAddGlobal(llmod, maptype.to_ref(), buf)\n         }\n-    };\n+    });\n     // On windows we'd like to export the toplevel cratemap\n     // such that we can find it from libstd.\n     if targ_cfg.os == OsWin32 && \"toplevel\" == mapname {\n@@ -2999,21 +3002,21 @@ pub fn fill_crate_map(ccx: &mut CrateContext, map: ValueRef) {\n                       cdata.name,\n                       cstore::get_crate_vers(cstore, i),\n                       cstore::get_crate_hash(cstore, i));\n-        let cr = do nm.with_c_str |buf| {\n+        let cr = nm.with_c_str(|buf| {\n             unsafe {\n                 llvm::LLVMAddGlobal(ccx.llmod, ccx.int_type.to_ref(), buf)\n             }\n-        };\n+        });\n         subcrates.push(p2i(ccx, cr));\n         i += 1;\n     }\n     let event_loop_factory = if !*ccx.sess.building_library {\n         match ccx.tcx.lang_items.event_loop_factory() {\n             Some(did) => unsafe {\n                 let name = csearch::get_symbol(ccx.sess.cstore, did);\n-                let global = do name.with_c_str |buf| {\n+                let global = name.with_c_str(|buf| {\n                     llvm::LLVMAddGlobal(ccx.llmod, ccx.int_type.to_ref(), buf)\n-                };\n+                });\n                 global\n             },\n             None => C_null(ccx.int_type.ptr_to())\n@@ -3023,9 +3026,9 @@ pub fn fill_crate_map(ccx: &mut CrateContext, map: ValueRef) {\n     };\n     unsafe {\n         let maptype = Type::array(&ccx.int_type, subcrates.len() as u64);\n-        let vec_elements = do \"_crate_map_child_vectors\".with_c_str |buf| {\n+        let vec_elements = \"_crate_map_child_vectors\".with_c_str(|buf| {\n             llvm::LLVMAddGlobal(ccx.llmod, maptype.to_ref(), buf)\n-        };\n+        });\n         lib::llvm::SetLinkage(vec_elements, lib::llvm::InternalLinkage);\n \n         llvm::LLVMSetInitializer(vec_elements, C_array(ccx.int_type, subcrates));\n@@ -3077,23 +3080,23 @@ pub fn write_metadata(cx: &CrateContext, crate: &ast::Crate) {\n     let encode_parms = crate_ctxt_to_encode_parms(cx, encode_inlined_item);\n     let llmeta = C_bytes(encoder::encode_metadata(encode_parms, crate));\n     let llconst = C_struct([llmeta], false);\n-    let mut llglobal = do \"rust_metadata\".with_c_str |buf| {\n+    let mut llglobal = \"rust_metadata\".with_c_str(|buf| {\n         unsafe {\n             llvm::LLVMAddGlobal(cx.llmod, val_ty(llconst).to_ref(), buf)\n         }\n-    };\n+    });\n     unsafe {\n         llvm::LLVMSetInitializer(llglobal, llconst);\n-        do cx.sess.targ_cfg.target_strs.meta_sect_name.with_c_str |buf| {\n+        cx.sess.targ_cfg.target_strs.meta_sect_name.with_c_str(|buf| {\n             llvm::LLVMSetSection(llglobal, buf)\n-        };\n+        });\n         lib::llvm::SetLinkage(llglobal, lib::llvm::InternalLinkage);\n \n         let t_ptr_i8 = Type::i8p();\n         llglobal = llvm::LLVMConstBitCast(llglobal, t_ptr_i8.to_ref());\n-        let llvm_used = do \"llvm.used\".with_c_str |buf| {\n+        let llvm_used = \"llvm.used\".with_c_str(|buf| {\n             llvm::LLVMAddGlobal(cx.llmod, Type::array(&t_ptr_i8, 1).to_ref(), buf)\n-        };\n+        });\n         lib::llvm::SetLinkage(llvm_used, lib::llvm::AppendingLinkage);\n         llvm::LLVMSetInitializer(llvm_used, C_array(t_ptr_i8, [llglobal]));\n     }\n@@ -3103,9 +3106,9 @@ pub fn write_metadata(cx: &CrateContext, crate: &ast::Crate) {\n pub fn write_abi_version(ccx: &mut CrateContext) {\n     unsafe {\n         let llval = C_uint(ccx, abi::abi_version);\n-        let llglobal = do \"rust_abi_version\".with_c_str |buf| {\n+        let llglobal = \"rust_abi_version\".with_c_str(|buf| {\n             llvm::LLVMAddGlobal(ccx.llmod, val_ty(llval).to_ref(), buf)\n-        };\n+        });\n         llvm::LLVMSetInitializer(llglobal, llval);\n         llvm::LLVMSetGlobalConstant(llglobal, True);\n     }\n@@ -3161,12 +3164,12 @@ pub fn trans_crate(sess: session::Session,\n \n         let maptype = val_ty(ccx.crate_map).to_ref();\n \n-        do \"__rust_crate_map_toplevel\".with_c_str |buf| {\n+        \"__rust_crate_map_toplevel\".with_c_str(|buf| {\n             unsafe {\n                 llvm::LLVMAddAlias(ccx.llmod, maptype,\n                                    ccx.crate_map, buf);\n             }\n-        }\n+        })\n     }\n \n     glue::emit_tydescs(ccx);\n@@ -3189,9 +3192,10 @@ pub fn trans_crate(sess: session::Session,\n         println!(\"n_inlines: {}\", ccx.stats.n_inlines);\n         println!(\"n_closures: {}\", ccx.stats.n_closures);\n         println(\"fn stats:\");\n-        do sort::quick_sort(ccx.stats.fn_stats) |&(_, _, insns_a), &(_, _, insns_b)| {\n+        sort::quick_sort(ccx.stats.fn_stats,\n+                         |&(_, _, insns_a), &(_, _, insns_b)| {\n             insns_a > insns_b\n-        }\n+        });\n         for tuple in ccx.stats.fn_stats.iter() {\n             match *tuple {\n                 (ref name, ms, insns) => {"}, {"sha": "7541a14fc720cf0696b81494ac89976f0c94cbf5", "filename": "src/librustc/middle/trans/builder.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs?ref=8ceb374ab783c6417b60867e7f34bebe997936ac", "patch": "@@ -51,7 +51,7 @@ impl Builder {\n             self.ccx.stats.n_llvm_insns += 1;\n         }\n         if self.ccx.sess.count_llvm_insns() {\n-            do base::with_insn_ctxt |v| {\n+            base::with_insn_ctxt(|v| {\n                 let h = &mut self.ccx.stats.llvm_insns;\n \n                 // Build version of path with cycles removed.\n@@ -85,7 +85,7 @@ impl Builder {\n                     _ => 0u\n                 };\n                 h.insert(s, n+1u);\n-            }\n+            })\n         }\n     }\n \n@@ -419,9 +419,9 @@ impl Builder {\n             if name.is_empty() {\n                 llvm::LLVMBuildAlloca(self.llbuilder, ty.to_ref(), noname())\n             } else {\n-                do name.with_c_str |c| {\n+                name.with_c_str(|c| {\n                     llvm::LLVMBuildAlloca(self.llbuilder, ty.to_ref(), c)\n-                }\n+                })\n             }\n         }\n     }\n@@ -465,11 +465,11 @@ impl Builder {\n             let min = llvm::LLVMConstInt(t, lo, signed);\n             let max = llvm::LLVMConstInt(t, hi, signed);\n \n-            do [min, max].as_imm_buf |ptr, len| {\n+            [min, max].as_imm_buf(|ptr, len| {\n                 llvm::LLVMSetMetadata(value, lib::llvm::MD_range as c_uint,\n                                       llvm::LLVMMDNodeInContext(self.ccx.llcx,\n                                                                 ptr, len as c_uint));\n-            }\n+            })\n         }\n \n         value\n@@ -518,7 +518,7 @@ impl Builder {\n             }\n             self.inbounds_gep(base, small_vec.slice(0, ixs.len()))\n         } else {\n-            let v = do ixs.iter().map |i| { C_i32(*i as i32) }.collect::<~[ValueRef]>();\n+            let v = ixs.iter().map(|i| C_i32(*i as i32)).collect::<~[ValueRef]>();\n             self.count_insn(\"gepi\");\n             self.inbounds_gep(base, v)\n         }\n@@ -736,12 +736,12 @@ impl Builder {\n             let sanitized = text.replace(\"$\", \"\");\n             let comment_text = format!(\"\\\\# {}\", sanitized.replace(\"\\n\", \"\\n\\t# \"));\n             self.count_insn(\"inlineasm\");\n-            let asm = do comment_text.with_c_str |c| {\n+            let asm = comment_text.with_c_str(|c| {\n                 unsafe {\n                     llvm::LLVMConstInlineAsm(Type::func([], &Type::void()).to_ref(),\n                                              c, noname(), False, False)\n                 }\n-            };\n+            });\n             self.call(asm, [], []);\n         }\n     }\n@@ -757,10 +757,10 @@ impl Builder {\n         let alignstack = if alignstack { lib::llvm::True }\n                          else          { lib::llvm::False };\n \n-        let argtys = do inputs.map |v| {\n+        let argtys = inputs.map(|v| {\n             debug!(\"Asm Input Type: {:?}\", self.ccx.tn.val_to_str(*v));\n             val_ty(*v)\n-        };\n+        });\n \n         debug!(\"Asm Output Type: {:?}\", self.ccx.tn.type_to_str(output));\n         let fty = Type::func(argtys, &output);\n@@ -878,9 +878,9 @@ impl Builder {\n             let BB: BasicBlockRef = llvm::LLVMGetInsertBlock(self.llbuilder);\n             let FN: ValueRef = llvm::LLVMGetBasicBlockParent(BB);\n             let M: ModuleRef = llvm::LLVMGetGlobalParent(FN);\n-            let T: ValueRef = do \"llvm.trap\".with_c_str |buf| {\n+            let T: ValueRef = \"llvm.trap\".with_c_str(|buf| {\n                 llvm::LLVMGetNamedFunction(M, buf)\n-            };\n+            });\n             assert!((T as int != 0));\n             let args: &[ValueRef] = [];\n             self.count_insn(\"trap\");"}, {"sha": "10c34b0b928886fe765cae6291737462660a3a9d", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=8ceb374ab783c6417b60867e7f34bebe997936ac", "patch": "@@ -616,7 +616,7 @@ pub fn trans_call_inner(in_cx: @mut Block,\n      */\n \n \n-    do base::with_scope_result(in_cx, call_info, \"call\") |cx| {\n+    base::with_scope_result(in_cx, call_info, \"call\", |cx| {\n         let callee = get_callee(cx);\n         let mut bcx = callee.bcx;\n         let ccx = cx.ccx();\n@@ -776,7 +776,7 @@ pub fn trans_call_inner(in_cx: @mut Block,\n         }\n \n         rslt(bcx, llresult)\n-    }\n+    })\n }\n \n pub enum CallArgs<'self> {"}, {"sha": "768d3cbd4b2c8fb034dbe2323061f673180b4803", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=8ceb374ab783c6417b60867e7f34bebe997936ac", "patch": "@@ -438,10 +438,10 @@ pub fn make_closure_glue(cx: @mut Block,\n         ast::OwnedSigil | ast::ManagedSigil => {\n             let box_cell_v = GEPi(cx, v, [0u, abi::fn_field_box]);\n             let box_ptr_v = Load(cx, box_cell_v);\n-            do with_cond(cx, IsNotNull(cx, box_ptr_v)) |bcx| {\n+            with_cond(cx, IsNotNull(cx, box_ptr_v), |bcx| {\n                 let closure_ty = ty::mk_opaque_closure_ptr(tcx, sigil);\n                 glue_fn(bcx, box_cell_v, closure_ty)\n-            }\n+            })\n         }\n     }\n }\n@@ -481,7 +481,7 @@ pub fn make_opaque_cbox_free_glue(\n     }\n \n     let ccx = bcx.ccx();\n-    do with_cond(bcx, IsNotNull(bcx, cbox)) |bcx| {\n+    with_cond(bcx, IsNotNull(bcx, cbox), |bcx| {\n         // Load the type descr found in the cbox\n         let lltydescty = ccx.tydesc_type.ptr_to();\n         let cbox = Load(bcx, cbox);\n@@ -498,5 +498,5 @@ pub fn make_opaque_cbox_free_glue(\n         glue::trans_exchange_free(bcx, cbox);\n \n         bcx\n-    }\n+    })\n }"}, {"sha": "7b2e439f2d253b486f759aaaf6f218638c94d7f4", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 29, "deletions": 31, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=8ceb374ab783c6417b60867e7f34bebe997936ac", "patch": "@@ -453,14 +453,14 @@ pub fn add_clean(bcx: @mut Block, val: ValueRef, t: ty::t) {\n     debug!(\"add_clean({}, {}, {})\", bcx.to_str(), bcx.val_to_str(val), t.repr(bcx.tcx()));\n \n     let cleanup_type = cleanup_type(bcx.tcx(), t);\n-    do in_scope_cx(bcx, None) |scope_info| {\n+    in_scope_cx(bcx, None, |scope_info| {\n         scope_info.cleanups.push(clean(@TypeDroppingCleanupFunction {\n             val: val,\n             t: t,\n         } as @CleanupFunction,\n         cleanup_type));\n         grow_scope_clean(scope_info);\n-    }\n+    })\n }\n \n pub fn add_clean_temp_immediate(cx: @mut Block, val: ValueRef, ty: ty::t) {\n@@ -469,15 +469,15 @@ pub fn add_clean_temp_immediate(cx: @mut Block, val: ValueRef, ty: ty::t) {\n            cx.to_str(), cx.val_to_str(val),\n            ty.repr(cx.tcx()));\n     let cleanup_type = cleanup_type(cx.tcx(), ty);\n-    do in_scope_cx(cx, None) |scope_info| {\n+    in_scope_cx(cx, None, |scope_info| {\n         scope_info.cleanups.push(clean_temp(val,\n             @ImmediateTypeDroppingCleanupFunction {\n                 val: val,\n                 t: ty,\n             } as @CleanupFunction,\n             cleanup_type));\n         grow_scope_clean(scope_info);\n-    }\n+    })\n }\n \n pub fn add_clean_temp_mem(bcx: @mut Block, val: ValueRef, t: ty::t) {\n@@ -498,15 +498,15 @@ pub fn add_clean_temp_mem_in_scope_(bcx: @mut Block, scope_id: Option<ast::NodeI\n            bcx.to_str(), bcx.val_to_str(val),\n            t.repr(bcx.tcx()));\n     let cleanup_type = cleanup_type(bcx.tcx(), t);\n-    do in_scope_cx(bcx, scope_id) |scope_info| {\n+    in_scope_cx(bcx, scope_id, |scope_info| {\n         scope_info.cleanups.push(clean_temp(val,\n             @TypeDroppingCleanupFunction {\n                 val: val,\n                 t: t,\n             } as @CleanupFunction,\n             cleanup_type));\n         grow_scope_clean(scope_info);\n-    }\n+    })\n }\n pub fn add_clean_return_to_mut(bcx: @mut Block,\n                                scope_id: ast::NodeId,\n@@ -527,7 +527,7 @@ pub fn add_clean_return_to_mut(bcx: @mut Block,\n            bcx.to_str(),\n            bcx.val_to_str(frozen_val_ref),\n            bcx.val_to_str(bits_val_ref));\n-    do in_scope_cx(bcx, Some(scope_id)) |scope_info| {\n+    in_scope_cx(bcx, Some(scope_id), |scope_info| {\n         scope_info.cleanups.push(clean_temp(\n                 frozen_val_ref,\n                 @WriteGuardReleasingCleanupFunction {\n@@ -539,7 +539,7 @@ pub fn add_clean_return_to_mut(bcx: @mut Block,\n                 } as @CleanupFunction,\n                 normal_exit_only));\n         grow_scope_clean(scope_info);\n-    }\n+    })\n }\n pub fn add_clean_free(cx: @mut Block, ptr: ValueRef, heap: heap) {\n     let free_fn = match heap {\n@@ -554,20 +554,20 @@ pub fn add_clean_free(cx: @mut Block, ptr: ValueRef, heap: heap) {\n             } as @CleanupFunction\n         }\n     };\n-    do in_scope_cx(cx, None) |scope_info| {\n+    in_scope_cx(cx, None, |scope_info| {\n         scope_info.cleanups.push(clean_temp(ptr,\n                                             free_fn,\n                                             normal_exit_and_unwind));\n         grow_scope_clean(scope_info);\n-    }\n+    })\n }\n \n // Note that this only works for temporaries. We should, at some point, move\n // to a system where we can also cancel the cleanup on local variables, but\n // this will be more involved. For now, we simply zero out the local, and the\n // drop glue checks whether it is zero.\n pub fn revoke_clean(cx: @mut Block, val: ValueRef) {\n-    do in_scope_cx(cx, None) |scope_info| {\n+    in_scope_cx(cx, None, |scope_info| {\n         let cleanup_pos = scope_info.cleanups.iter().position(\n             |cu| match *cu {\n                 clean_temp(v, _, _) if v == val => true,\n@@ -580,7 +580,7 @@ pub fn revoke_clean(cx: @mut Block, val: ValueRef) {\n                                                       scope_info.cleanups.len()));\n             shrink_scope_clean(scope_info, *i);\n         }\n-    }\n+    })\n }\n \n pub fn block_cleanups(bcx: &mut Block) -> ~[cleanup] {\n@@ -844,9 +844,7 @@ pub fn C_integral(t: Type, u: u64, sign_extend: bool) -> ValueRef {\n \n pub fn C_floating(s: &str, t: Type) -> ValueRef {\n     unsafe {\n-        do s.with_c_str |buf| {\n-            llvm::LLVMConstRealOfString(t.to_ref(), buf)\n-        }\n+        s.with_c_str(|buf| llvm::LLVMConstRealOfString(t.to_ref(), buf))\n     }\n }\n \n@@ -896,14 +894,14 @@ pub fn C_cstr(cx: &mut CrateContext, s: @str) -> ValueRef {\n             None => ()\n         }\n \n-        let sc = do s.as_imm_buf |buf, buflen| {\n+        let sc = s.as_imm_buf(|buf, buflen| {\n             llvm::LLVMConstStringInContext(cx.llcx, buf as *c_char, buflen as c_uint, False)\n-        };\n+        });\n \n         let gsym = token::gensym(\"str\");\n-        let g = do format!(\"str{}\", gsym).with_c_str |buf| {\n+        let g = format!(\"str{}\", gsym).with_c_str(|buf| {\n             llvm::LLVMAddGlobal(cx.llmod, val_ty(sc).to_ref(), buf)\n-        };\n+        });\n         llvm::LLVMSetInitializer(g, sc);\n         llvm::LLVMSetGlobalConstant(g, True);\n         lib::llvm::SetLinkage(g, lib::llvm::InternalLinkage);\n@@ -930,9 +928,9 @@ pub fn C_binary_slice(cx: &mut CrateContext, data: &[u8]) -> ValueRef {\n         let lldata = C_bytes(data);\n \n         let gsym = token::gensym(\"binary\");\n-        let g = do format!(\"binary{}\", gsym).with_c_str |buf| {\n+        let g = format!(\"binary{}\", gsym).with_c_str(|buf| {\n             llvm::LLVMAddGlobal(cx.llmod, val_ty(lldata).to_ref(), buf)\n-        };\n+        });\n         llvm::LLVMSetInitializer(g, lldata);\n         llvm::LLVMSetGlobalConstant(g, True);\n         lib::llvm::SetLinkage(g, lib::llvm::InternalLinkage);\n@@ -954,17 +952,17 @@ pub fn C_zero_byte_arr(size: uint) -> ValueRef {\n \n pub fn C_struct(elts: &[ValueRef], packed: bool) -> ValueRef {\n     unsafe {\n-        do elts.as_imm_buf |ptr, len| {\n+        elts.as_imm_buf(|ptr, len| {\n             llvm::LLVMConstStructInContext(base::task_llcx(), ptr, len as c_uint, packed as Bool)\n-        }\n+        })\n     }\n }\n \n pub fn C_named_struct(T: Type, elts: &[ValueRef]) -> ValueRef {\n     unsafe {\n-        do elts.as_imm_buf |ptr, len| {\n+        elts.as_imm_buf(|ptr, len| {\n             llvm::LLVMConstNamedStruct(T.to_ref(), ptr, len as c_uint)\n-        }\n+        })\n     }\n }\n \n@@ -990,9 +988,9 @@ pub fn get_param(fndecl: ValueRef, param: uint) -> ValueRef {\n pub fn const_get_elt(cx: &CrateContext, v: ValueRef, us: &[c_uint])\n                   -> ValueRef {\n     unsafe {\n-        let r = do us.as_imm_buf |p, len| {\n+        let r = us.as_imm_buf(|p, len| {\n             llvm::LLVMConstExtractValue(v, p, len as c_uint)\n-        };\n+        });\n \n         debug!(\"const_get_elt(v={}, us={:?}, r={})\",\n                cx.tn.val_to_str(v), us, cx.tn.val_to_str(r));\n@@ -1151,9 +1149,9 @@ pub fn node_id_type_params(bcx: &mut Block, id: ast::NodeId) -> ~[ty::t] {\n \n     match bcx.fcx.param_substs {\n       Some(substs) => {\n-        do params.iter().map |t| {\n+        params.iter().map(|t| {\n             ty::subst_tps(tcx, substs.tys, substs.self_ty, *t)\n-        }.collect()\n+        }).collect()\n       }\n       _ => params\n     }\n@@ -1207,9 +1205,9 @@ pub fn resolve_vtable_under_param_substs(tcx: ty::ctxt,\n         typeck::vtable_static(trait_id, ref tys, sub) => {\n             let tys = match param_substs {\n                 Some(substs) => {\n-                    do tys.iter().map |t| {\n+                    tys.iter().map(|t| {\n                         ty::subst_tps(tcx, substs.tys, substs.self_ty, *t)\n-                    }.collect()\n+                    }).collect()\n                 }\n                 _ => tys.to_owned()\n             };"}, {"sha": "04da76cec9e5ac0c336b4eb7b8a18142e3cd9efe", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=8ceb374ab783c6417b60867e7f34bebe997936ac", "patch": "@@ -100,9 +100,9 @@ fn const_vec(cx: @mut CrateContext, e: &ast::Expr, es: &[@ast::Expr]) -> (ValueR\n \n fn const_addr_of(cx: &mut CrateContext, cv: ValueRef) -> ValueRef {\n     unsafe {\n-        let gv = do \"const\".with_c_str |name| {\n+        let gv = \"const\".with_c_str(|name| {\n             llvm::LLVMAddGlobal(cx.llmod, val_ty(cv).to_ref(), name)\n-        };\n+        });\n         llvm::LLVMSetInitializer(gv, cv);\n         llvm::LLVMSetGlobalConstant(gv, True);\n         SetLinkage(gv, PrivateLinkage);\n@@ -191,12 +191,12 @@ pub fn const_expr(cx: @mut CrateContext, e: &ast::Expr) -> (ValueRef, bool) {\n         Some(@ty::AutoDerefRef(ref adj)) => {\n             let mut ty = ety;\n             let mut maybe_ptr = None;\n-            do adj.autoderefs.times {\n+            adj.autoderefs.times(|| {\n                 let (dv, dt) = const_deref(cx, llconst, ty, false);\n                 maybe_ptr = Some(llconst);\n                 llconst = dv;\n                 ty = dt;\n-            }\n+            });\n \n             match adj.autoref {\n                 None => { }\n@@ -385,10 +385,10 @@ fn const_expr_unadjusted(cx: @mut CrateContext,\n               let bt = ty::expr_ty_adjusted(cx.tcx, base);\n               let brepr = adt::represent_type(cx, bt);\n               let (bv, inlineable) = const_expr(cx, base);\n-              do expr::with_field_tys(cx.tcx, bt, None) |discr, field_tys| {\n+              expr::with_field_tys(cx.tcx, bt, None, |discr, field_tys| {\n                   let ix = ty::field_idx_strict(cx.tcx, field.name, field_tys);\n                   (adt::const_get_field(cx, brepr, bv, discr, ix), inlineable)\n-              }\n+              })\n           }\n \n           ast::ExprIndex(_, base, index) => {\n@@ -504,8 +504,7 @@ fn const_expr_unadjusted(cx: @mut CrateContext,\n                 None => None\n               };\n \n-              do expr::with_field_tys(tcx, ety, Some(e.id))\n-                  |discr, field_tys| {\n+              expr::with_field_tys(tcx, ety, Some(e.id), |discr, field_tys| {\n                   let cs = field_tys.iter().enumerate()\n                       .map(|(ix, &field_ty)| {\n                       match fs.iter().find(|f| field_ty.ident.name == f.ident.node.name) {\n@@ -524,7 +523,7 @@ fn const_expr_unadjusted(cx: @mut CrateContext,\n                   let (cs, inlineable) = vec::unzip(cs.move_iter());\n                   (adt::trans_const(cx, repr, discr, cs),\n                    inlineable.iter().fold(true, |a, &b| a && b))\n-              }\n+              })\n           }\n           ast::ExprVec(ref es, ast::MutImmutable) => {\n             let (v, _, inlineable) = const_vec(cx, e, *es);\n@@ -541,9 +540,9 @@ fn const_expr_unadjusted(cx: @mut CrateContext,\n               ast::ExprVec(ref es, ast::MutImmutable) => {\n                 let (cv, llunitty, _) = const_vec(cx, e, *es);\n                 let llty = val_ty(cv);\n-                let gv = do \"const\".with_c_str |name| {\n+                let gv = \"const\".with_c_str(|name| {\n                     llvm::LLVMAddGlobal(cx.llmod, llty.to_ref(), name)\n-                };\n+                });\n                 llvm::LLVMSetInitializer(gv, cv);\n                 llvm::LLVMSetGlobalConstant(gv, True);\n                 SetLinkage(gv, PrivateLinkage);"}, {"sha": "851a1233dcca76c62c0f0d6c996721189d765f23", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=8ceb374ab783c6417b60867e7f34bebe997936ac", "patch": "@@ -131,17 +131,15 @@ impl CrateContext {\n         unsafe {\n             let llcx = llvm::LLVMContextCreate();\n             set_task_llcx(llcx);\n-            let llmod = do name.with_c_str |buf| {\n+            let llmod = name.with_c_str(|buf| {\n                 llvm::LLVMModuleCreateWithNameInContext(buf, llcx)\n-            };\n+            });\n             let data_layout: &str = sess.targ_cfg.target_strs.data_layout;\n             let targ_triple: &str = sess.targ_cfg.target_strs.target_triple;\n-            do data_layout.with_c_str |buf| {\n-                llvm::LLVMSetDataLayout(llmod, buf)\n-            };\n-            do targ_triple.with_c_str |buf| {\n+            data_layout.with_c_str(|buf| llvm::LLVMSetDataLayout(llmod, buf));\n+            targ_triple.with_c_str(|buf| {\n                 llvm::LLVMRustSetNormalizedTarget(llmod, buf)\n-            };\n+            });\n             let targ_cfg = sess.targ_cfg;\n \n             let td = mk_target_data(sess.targ_cfg.target_strs.data_layout);"}, {"sha": "1360c9c7c9ba9dc040b765ce009c2031cb95438d", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=8ceb374ab783c6417b60867e7f34bebe997936ac", "patch": "@@ -74,23 +74,26 @@ pub fn trans_if(bcx: @mut Block,\n                 None => {}\n             }\n             // if true { .. } [else { .. }]\n-            return do with_scope(bcx, thn.info(), \"if_true_then\") |bcx| {\n+            return with_scope(bcx, thn.info(), \"if_true_then\", |bcx| {\n                 let bcx_out = trans_block(bcx, thn, dest);\n                 debuginfo::clear_source_location(bcx.fcx);\n                 trans_block_cleanups(bcx_out, block_cleanups(bcx))\n-            }\n+            })\n         } else {\n             let mut trans = TransItemVisitor { ccx: bcx.fcx.ccx } ;\n             trans.visit_block(thn, ());\n \n             match els {\n                 // if false { .. } else { .. }\n                 Some(elexpr) => {\n-                    return do with_scope(bcx, elexpr.info(), \"if_false_then\") |bcx| {\n+                    return with_scope(bcx,\n+                                      elexpr.info(),\n+                                      \"if_false_then\",\n+                                      |bcx| {\n                         let bcx_out = trans_if_else(bcx, elexpr, dest);\n                         debuginfo::clear_source_location(bcx.fcx);\n                         trans_block_cleanups(bcx_out, block_cleanups(bcx))\n-                    }\n+                    })\n                 }\n                 // if false { .. }\n                 None => return bcx,"}, {"sha": "4fd6e08c8b5847510b9107fb0e75901bba704a7e", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=8ceb374ab783c6417b60867e7f34bebe997936ac", "patch": "@@ -290,9 +290,9 @@ impl Datum {\n                 ByRef(_) => {\n                     let cast = PointerCast(bcx, dst, val_ty(self.val));\n                     let cmp = ICmp(bcx, lib::llvm::IntNE, cast, self.val);\n-                    do with_cond(bcx, cmp) |bcx| {\n+                    with_cond(bcx, cmp, |bcx| {\n                         self.copy_to_no_check(bcx, action, dst)\n-                    }\n+                    })\n                 }\n                 ByValue => {\n                     self.copy_to_no_check(bcx, action, dst)"}, {"sha": "caed9fb8e9c745e1cfeaa3cbe4281b375b0ff666", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 144, "deletions": 127, "changes": 271, "blob_url": "https://github.com/rust-lang/rust/blob/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=8ceb374ab783c6417b60867e7f34bebe997936ac", "patch": "@@ -254,8 +254,7 @@ pub fn create_local_var_metadata(bcx: @mut Block,\n     let cx = bcx.ccx();\n     let def_map = cx.tcx.def_map;\n \n-    do pat_util::pat_bindings(def_map, local.pat) |_, node_id, span, path_ref| {\n-\n+    pat_util::pat_bindings(def_map, local.pat, |_, node_id, span, path_ref| {\n         let var_ident = ast_util::path_to_ident(path_ref);\n         let var_type = node_id_type(bcx, node_id);\n \n@@ -276,7 +275,7 @@ pub fn create_local_var_metadata(bcx: @mut Block,\n                       DirectVariable { alloca: llptr },\n                       LocalVariable,\n                       span);\n-    }\n+    })\n }\n \n /// Creates debug information for a variable captured in a closure.\n@@ -449,8 +448,7 @@ pub fn create_argument_metadata(bcx: @mut Block,\n     let def_map = cx.tcx.def_map;\n     let scope_metadata = bcx.fcx.debug_context.get_ref(cx, arg.pat.span).fn_metadata;\n \n-    do pat_util::pat_bindings(def_map, arg.pat) |_, node_id, span, path_ref| {\n-\n+    pat_util::pat_bindings(def_map, arg.pat, |_, node_id, span, path_ref| {\n         let llptr = match bcx.fcx.llargs.find_copy(&node_id) {\n             Some(v) => v,\n             None => {\n@@ -481,7 +479,7 @@ pub fn create_argument_metadata(bcx: @mut Block,\n                       DirectVariable { alloca: llptr },\n                       ArgumentVariable(argument_index),\n                       span);\n-    }\n+    })\n }\n \n /// Sets the current debug location at the beginning of the span.\n@@ -655,27 +653,28 @@ pub fn create_function_debug_context(cx: &mut CrateContext,\n \n     let scope_line = get_scope_line(cx, top_level_block, loc.line);\n \n-    let fn_metadata = do function_name.with_c_str |function_name| {\n-                      do linkage_name.with_c_str |linkage_name| {\n-        unsafe {\n-            llvm::LLVMDIBuilderCreateFunction(\n-                DIB(cx),\n-                containing_scope,\n-                function_name,\n-                linkage_name,\n-                file_metadata,\n-                loc.line as c_uint,\n-                function_type_metadata,\n-                false,\n-                true,\n-                scope_line as c_uint,\n-                FlagPrototyped as c_uint,\n-                cx.sess.opts.optimize != session::No,\n-                llfn,\n-                template_parameters,\n-                ptr::null())\n-        }\n-    }};\n+    let fn_metadata = function_name.with_c_str(|function_name| {\n+                          linkage_name.with_c_str(|linkage_name| {\n+            unsafe {\n+                llvm::LLVMDIBuilderCreateFunction(\n+                    DIB(cx),\n+                    containing_scope,\n+                    function_name,\n+                    linkage_name,\n+                    file_metadata,\n+                    loc.line as c_uint,\n+                    function_type_metadata,\n+                    false,\n+                    true,\n+                    scope_line as c_uint,\n+                    FlagPrototyped as c_uint,\n+                    cx.sess.opts.optimize != session::No,\n+                    llfn,\n+                    template_parameters,\n+                    ptr::null())\n+            }\n+        })\n+    });\n \n     // Initialize fn debug context (including scope map and namespace map)\n     let mut fn_debug_context = ~FunctionDebugContextData {\n@@ -685,7 +684,7 @@ pub fn create_function_debug_context(cx: &mut CrateContext,\n         source_locations_enabled: false,\n     };\n \n-    let arg_pats = do fn_decl.inputs.map |arg_ref| { arg_ref.pat };\n+    let arg_pats = fn_decl.inputs.map(|arg_ref| arg_ref.pat);\n     populate_scope_map(cx, arg_pats, top_level_block, fn_metadata, &mut fn_debug_context.scope_map);\n \n     return FunctionDebugContext(fn_debug_context);\n@@ -780,7 +779,7 @@ pub fn create_function_debug_context(cx: &mut CrateContext,\n \n                 let ident = special_idents::type_self;\n \n-                let param_metadata = do token::ident_to_str(&ident).with_c_str |name| {\n+                let param_metadata = token::ident_to_str(&ident).with_c_str(|name| {\n                     unsafe {\n                         llvm::LLVMDIBuilderCreateTemplateTypeParameter(\n                             DIB(cx),\n@@ -791,7 +790,7 @@ pub fn create_function_debug_context(cx: &mut CrateContext,\n                             0,\n                             0)\n                     }\n-                };\n+                });\n \n                 template_params.push(param_metadata);\n             }\n@@ -818,7 +817,7 @@ pub fn create_function_debug_context(cx: &mut CrateContext,\n             // Again, only create type information if extra_debuginfo is enabled\n             if cx.sess.opts.extra_debuginfo {\n                 let actual_type_metadata = type_metadata(cx, actual_type, codemap::dummy_sp());\n-                let param_metadata = do token::ident_to_str(&ident).with_c_str |name| {\n+                let param_metadata = token::ident_to_str(&ident).with_c_str(|name| {\n                     unsafe {\n                         llvm::LLVMDIBuilderCreateTemplateTypeParameter(\n                             DIB(cx),\n@@ -829,7 +828,7 @@ pub fn create_function_debug_context(cx: &mut CrateContext,\n                             0,\n                             0)\n                     }\n-                };\n+                });\n                 template_params.push(param_metadata);\n             }\n         }\n@@ -875,24 +874,28 @@ fn compile_unit_metadata(cx: @mut CrateContext) {\n     let work_dir = cx.sess.working_dir.as_str().unwrap();\n     let producer = format!(\"rustc version {}\", env!(\"CFG_VERSION\"));\n \n-    do crate_name.with_c_str |crate_name| {\n-    do work_dir.with_c_str |work_dir| {\n-    do producer.with_c_str |producer| {\n-    do \"\".with_c_str |flags| {\n-    do \"\".with_c_str |split_name| {\n-        unsafe {\n-            llvm::LLVMDIBuilderCreateCompileUnit(\n-                dcx.builder,\n-                DW_LANG_RUST,\n-                crate_name,\n-                work_dir,\n-                producer,\n-                cx.sess.opts.optimize != session::No,\n-                flags,\n-                0,\n-                split_name);\n-        }\n-    }}}}};\n+    crate_name.with_c_str(|crate_name| {\n+        work_dir.with_c_str(|work_dir| {\n+            producer.with_c_str(|producer| {\n+                \"\".with_c_str(|flags| {\n+                    \"\".with_c_str(|split_name| {\n+                        unsafe {\n+                            llvm::LLVMDIBuilderCreateCompileUnit(\n+                                dcx.builder,\n+                                DW_LANG_RUST,\n+                                crate_name,\n+                                work_dir,\n+                                producer,\n+                                cx.sess.opts.optimize != session::No,\n+                                flags,\n+                                0,\n+                                split_name);\n+                        }\n+                    })\n+                })\n+            })\n+        })\n+    });\n }\n \n fn declare_local(bcx: @mut Block,\n@@ -917,7 +920,7 @@ fn declare_local(bcx: @mut Block,\n         CapturedVariable => 0\n     } as c_uint;\n \n-    let (var_alloca, var_metadata) = do name.with_c_str |name| {\n+    let (var_alloca, var_metadata) = name.with_c_str(|name| {\n         match variable_access {\n             DirectVariable { alloca } => (\n                 alloca,\n@@ -952,7 +955,7 @@ fn declare_local(bcx: @mut Block,\n                 }\n             )\n         }\n-    };\n+    });\n \n     set_debug_location(cx, DebugLocation::new(scope_metadata, loc.line, *loc.col));\n     unsafe {\n@@ -992,12 +995,13 @@ fn file_metadata(cx: &mut CrateContext, full_path: &str) -> DIFile {\n         };\n \n     let file_metadata =\n-        do file_name.with_c_str |file_name| {\n-        do work_dir.with_c_str |work_dir| {\n-            unsafe {\n-                llvm::LLVMDIBuilderCreateFile(DIB(cx), file_name, work_dir)\n-            }\n-        }};\n+        file_name.with_c_str(|file_name| {\n+            work_dir.with_c_str(|work_dir| {\n+                unsafe {\n+                    llvm::LLVMDIBuilderCreateFile(DIB(cx), file_name, work_dir)\n+                }\n+            })\n+        });\n \n     debug_context(cx).created_files.insert(full_path.to_owned(), file_metadata);\n     return file_metadata;\n@@ -1053,7 +1057,7 @@ fn basic_type_metadata(cx: &mut CrateContext, t: ty::t) -> DIType {\n \n     let llvm_type = type_of::type_of(cx, t);\n     let (size, align) = size_and_align_of(cx, llvm_type);\n-    let ty_metadata = do name.with_c_str |name| {\n+    let ty_metadata = name.with_c_str(|name| {\n         unsafe {\n             llvm::LLVMDIBuilderCreateBasicType(\n                 DIB(cx),\n@@ -1062,7 +1066,7 @@ fn basic_type_metadata(cx: &mut CrateContext, t: ty::t) -> DIType {\n                 bytes_to_bits(align),\n                 encoding)\n         }\n-    };\n+    });\n \n     return ty_metadata;\n }\n@@ -1074,7 +1078,7 @@ fn pointer_type_metadata(cx: &mut CrateContext,\n     let pointer_llvm_type = type_of::type_of(cx, pointer_type);\n     let (pointer_size, pointer_align) = size_and_align_of(cx, pointer_llvm_type);\n     let name = ppaux::ty_to_str(cx.tcx, pointer_type);\n-    let ptr_metadata = do name.with_c_str |name| {\n+    let ptr_metadata = name.with_c_str(|name| {\n         unsafe {\n             llvm::LLVMDIBuilderCreatePointerType(\n                 DIB(cx),\n@@ -1083,7 +1087,7 @@ fn pointer_type_metadata(cx: &mut CrateContext,\n                 bytes_to_bits(pointer_align),\n                 name)\n         }\n-    };\n+    });\n     return ptr_metadata;\n }\n \n@@ -1100,7 +1104,7 @@ struct StructMemberDescriptionFactory {\n impl MemberDescriptionFactory for StructMemberDescriptionFactory {\n     fn create_member_descriptions(&self, cx: &mut CrateContext)\n                                   -> ~[MemberDescription] {\n-        do self.fields.map |field| {\n+        self.fields.map(|field| {\n             let name = if field.ident.name == special_idents::unnamed_field.name {\n                 @\"\"\n             } else {\n@@ -1113,7 +1117,7 @@ impl MemberDescriptionFactory for StructMemberDescriptionFactory {\n                 type_metadata: type_metadata(cx, field.mt.ty, self.span),\n                 offset: ComputedMemberOffset,\n             }\n-        }\n+        })\n     }\n }\n \n@@ -1210,14 +1214,14 @@ struct TupleMemberDescriptionFactory {\n impl MemberDescriptionFactory for TupleMemberDescriptionFactory {\n     fn create_member_descriptions(&self, cx: &mut CrateContext)\n                                   -> ~[MemberDescription] {\n-        do self.component_types.map |&component_type| {\n+        self.component_types.map(|&component_type| {\n             MemberDescription {\n                 name: @\"\",\n                 llvm_type: type_of::type_of(cx, component_type),\n                 type_metadata: type_metadata(cx, component_type, self.span),\n                 offset: ComputedMemberOffset,\n             }\n-        }\n+        })\n     }\n }\n \n@@ -1267,10 +1271,10 @@ impl MemberDescriptionFactory for GeneralMemberDescriptionFactory {\n             _ => cx.sess.bug(\"unreachable\")\n         };\n \n-        do struct_defs\n+        struct_defs\n             .iter()\n             .enumerate()\n-            .map |(i, struct_def)| {\n+            .map(|(i, struct_def)| {\n                 let (variant_type_metadata, variant_llvm_type, member_desc_factory) =\n                     describe_variant(cx,\n                                      struct_def,\n@@ -1295,7 +1299,7 @@ impl MemberDescriptionFactory for GeneralMemberDescriptionFactory {\n                     type_metadata: variant_type_metadata,\n                     offset: FixedMemberOffset { bytes: 0 },\n                 }\n-        }.collect()\n+        }).collect()\n     }\n }\n \n@@ -1308,7 +1312,7 @@ struct EnumVariantMemberDescriptionFactory {\n impl MemberDescriptionFactory for EnumVariantMemberDescriptionFactory {\n     fn create_member_descriptions(&self, cx: &mut CrateContext)\n                                   -> ~[MemberDescription] {\n-        do self.args.iter().enumerate().map |(i, &(name, ty))| {\n+        self.args.iter().enumerate().map(|(i, &(name, ty))| {\n             MemberDescription {\n                 name: name,\n                 llvm_type: type_of::type_of(cx, ty),\n@@ -1318,7 +1322,7 @@ impl MemberDescriptionFactory for EnumVariantMemberDescriptionFactory {\n                 },\n                 offset: ComputedMemberOffset,\n             }\n-        }.collect()\n+        }).collect()\n     }\n }\n \n@@ -1360,8 +1364,8 @@ fn describe_variant(cx: &mut CrateContext,\n \n     // Get the argument names from the enum variant info\n     let mut arg_names = match variant_info.arg_names {\n-        Some(ref names) => do names.map |ident| { token::ident_to_str(ident) },\n-        None => do variant_info.args.map |_| { @\"\" }\n+        Some(ref names) => names.map(|ident| token::ident_to_str(ident)),\n+        None => variant_info.args.map(|_| @\"\")\n     };\n \n     // If this is not a univariant enum, there is also the (unnamed) discriminant field\n@@ -1420,14 +1424,14 @@ fn prepare_enum_metadata(cx: &mut CrateContext,\n             let name: &str = token::ident_to_str(&v.name);\n             let discriminant_value = v.disr_val as c_ulonglong;\n \n-            do name.with_c_str |name| {\n+            name.with_c_str(|name| {\n                 unsafe {\n                     llvm::LLVMDIBuilderCreateEnumerator(\n                         DIB(cx),\n                         name,\n                         discriminant_value)\n                 }\n-            }\n+            })\n         })\n         .collect();\n \n@@ -1436,7 +1440,7 @@ fn prepare_enum_metadata(cx: &mut CrateContext,\n         let (discriminant_size, discriminant_align) = size_and_align_of(cx, discriminant_llvm_type);\n         let discriminant_base_type_metadata = type_metadata(cx, adt::ty_of_inttype(inttype),\n                                                             codemap::dummy_sp());\n-        do enum_name.with_c_str |enum_name| {\n+        enum_name.with_c_str(|enum_name| {\n             unsafe {\n                 llvm::LLVMDIBuilderCreateEnumerationType(\n                     DIB(cx),\n@@ -1449,7 +1453,7 @@ fn prepare_enum_metadata(cx: &mut CrateContext,\n                     create_DIArray(DIB(cx), enumerators_metadata),\n                     discriminant_base_type_metadata)\n             }\n-        }\n+        })\n     };\n \n     let type_rep = adt::represent_type(cx, enum_type);\n@@ -1482,7 +1486,7 @@ fn prepare_enum_metadata(cx: &mut CrateContext,\n             let enum_llvm_type = type_of::type_of(cx, enum_type);\n             let (enum_type_size, enum_type_align) = size_and_align_of(cx, enum_llvm_type);\n \n-            let enum_metadata = do enum_name.with_c_str |enum_name| {\n+            let enum_metadata = enum_name.with_c_str(|enum_name| {\n                 unsafe {\n                     llvm::LLVMDIBuilderCreateUnionType(\n                     DIB(cx),\n@@ -1495,7 +1499,8 @@ fn prepare_enum_metadata(cx: &mut CrateContext,\n                     0, // Flags\n                     ptr::null(),\n                     0) // RuntimeLang\n-            }};\n+                }\n+            });\n \n             UnfinishedMetadata {\n                 cache_id: cache_id_for_type(enum_type),\n@@ -1605,7 +1610,7 @@ fn set_members_of_composite_type(cx: &mut CrateContext,\n                 ComputedMemberOffset => machine::llelement_offset(cx, composite_llvm_type, i)\n             };\n \n-            do member_description.name.with_c_str |member_name| {\n+            member_description.name.with_c_str(|member_name| {\n                 unsafe {\n                     llvm::LLVMDIBuilderCreateMemberType(\n                         DIB(cx),\n@@ -1619,7 +1624,7 @@ fn set_members_of_composite_type(cx: &mut CrateContext,\n                         0,\n                         member_description.type_metadata)\n                 }\n-            }\n+            })\n         })\n         .collect();\n \n@@ -1649,27 +1654,29 @@ fn create_struct_stub(cx: &mut CrateContext,\n     };\n \n     return unsafe {\n-        do struct_type_name.with_c_str |name| {\n-        do unique_id.with_c_str |unique_id| {\n-            // LLVMDIBuilderCreateStructType() wants an empty array. A null pointer will lead to\n-            // hard to trace and debug LLVM assertions later on in llvm/lib/IR/Value.cpp\n-            let empty_array = create_DIArray(DIB(cx), []);\n+        struct_type_name.with_c_str(|name| {\n+            unique_id.with_c_str(|unique_id| {\n+                // LLVMDIBuilderCreateStructType() wants an empty array. A null pointer will lead to\n+                // hard to trace and debug LLVM assertions later on in llvm/lib/IR/Value.cpp\n+                let empty_array = create_DIArray(DIB(cx), []);\n \n-            llvm::LLVMDIBuilderCreateStructType(\n-                DIB(cx),\n-                containing_scope,\n-                name,\n-                file_metadata,\n-                loc.line as c_uint,\n-                bytes_to_bits(struct_size),\n-                bytes_to_bits(struct_align),\n-                0,\n-                ptr::null(),\n-                empty_array,\n-                0,\n-                ptr::null(),\n-                unique_id)\n-    }}};\n+                llvm::LLVMDIBuilderCreateStructType(\n+                    DIB(cx),\n+                    containing_scope,\n+                    name,\n+                    file_metadata,\n+                    loc.line as c_uint,\n+                    bytes_to_bits(struct_size),\n+                    bytes_to_bits(struct_align),\n+                    0,\n+                    ptr::null(),\n+                    empty_array,\n+                    0,\n+                    ptr::null(),\n+                    unique_id)\n+            })\n+        })\n+    };\n }\n \n fn boxed_type_metadata(cx: &mut CrateContext,\n@@ -1979,7 +1986,7 @@ fn unimplemented_type_metadata(cx: &mut CrateContext, t: ty::t) -> DIType {\n     debug!(\"unimplemented_type_metadata: {:?}\", ty::get(t));\n \n     let name = ppaux::ty_to_str(cx.tcx, t);\n-    let metadata = do format!(\"NYI<{}>\", name).with_c_str |name| {\n+    let metadata = format!(\"NYI<{}>\", name).with_c_str(|name| {\n         unsafe {\n             llvm::LLVMDIBuilderCreateBasicType(\n                 DIB(cx),\n@@ -1988,7 +1995,7 @@ fn unimplemented_type_metadata(cx: &mut CrateContext, t: ty::t) -> DIType {\n                 8_u64,\n                 DW_ATE_unsigned as c_uint)\n             }\n-        };\n+        });\n \n     return metadata;\n }\n@@ -2261,10 +2268,10 @@ fn populate_scope_map(cx: &mut CrateContext,\n     // Push argument identifiers onto the stack so arguments integrate nicely with variable\n     // shadowing.\n     for &arg_pat in arg_pats.iter() {\n-        do pat_util::pat_bindings(def_map, arg_pat) |_, _, _, path_ref| {\n+        pat_util::pat_bindings(def_map, arg_pat, |_, _, _, path_ref| {\n             let ident = ast_util::path_to_ident(path_ref);\n             scope_stack.push(ScopeStackEntry { scope_metadata: fn_metadata, ident: Some(ident) });\n-        }\n+        })\n     }\n \n     walk_block(cx, fn_entry_block, &mut scope_stack, scope_map);\n@@ -2550,11 +2557,13 @@ fn populate_scope_map(cx: &mut CrateContext,\n             ast::ExprIf(@ref cond_exp, ref then_block, ref opt_else_exp) => {\n                 walk_expr(cx, cond_exp, scope_stack, scope_map);\n \n-                do with_new_scope(cx, then_block.span, scope_stack, scope_map) |cx,\n-                                                                                scope_stack,\n-                                                                                scope_map| {\n+                with_new_scope(cx,\n+                               then_block.span,\n+                               scope_stack,\n+                               scope_map,\n+                               |cx, scope_stack, scope_map| {\n                     walk_block(cx, then_block, scope_stack, scope_map);\n-                }\n+                });\n \n                 match *opt_else_exp {\n                     Some(@ref else_exp) => walk_expr(cx, else_exp, scope_stack, scope_map),\n@@ -2565,11 +2574,13 @@ fn populate_scope_map(cx: &mut CrateContext,\n             ast::ExprWhile(@ref cond_exp, ref loop_body) => {\n                 walk_expr(cx, cond_exp, scope_stack, scope_map);\n \n-                do with_new_scope(cx, loop_body.span, scope_stack, scope_map) |cx,\n-                                                                               scope_stack,\n-                                                                               scope_map| {\n+                with_new_scope(cx,\n+                               loop_body.span,\n+                               scope_stack,\n+                               scope_map,\n+                               |cx, scope_stack, scope_map| {\n                     walk_block(cx, loop_body, scope_stack, scope_map);\n-                }\n+                })\n             }\n \n             ast::ExprForLoop(_, _, _, _) => {\n@@ -2584,24 +2595,28 @@ fn populate_scope_map(cx: &mut CrateContext,\n \n             ast::ExprLoop(ref block, _) |\n             ast::ExprBlock(ref block)   => {\n-                do with_new_scope(cx, block.span, scope_stack, scope_map) |cx,\n-                                                                           scope_stack,\n-                                                                           scope_map| {\n+                with_new_scope(cx,\n+                               block.span,\n+                               scope_stack,\n+                               scope_map,\n+                               |cx, scope_stack, scope_map| {\n                     walk_block(cx, block, scope_stack, scope_map);\n-                }\n+                })\n             }\n \n             ast::ExprFnBlock(ast::fn_decl { inputs: ref inputs, _ }, ref block) |\n             ast::ExprProc(ast::fn_decl { inputs: ref inputs, _ }, ref block) => {\n-                do with_new_scope(cx, block.span, scope_stack, scope_map) |cx,\n-                                                                           scope_stack,\n-                                                                           scope_map| {\n+                with_new_scope(cx,\n+                               block.span,\n+                               scope_stack,\n+                               scope_map,\n+                               |cx, scope_stack, scope_map| {\n                     for &ast::arg { pat: pattern, _ } in inputs.iter() {\n                         walk_pattern(cx, pattern, scope_stack, scope_map);\n                     }\n \n                     walk_block(cx, block, scope_stack, scope_map);\n-                }\n+                })\n             }\n \n             // ast::expr_loop_body(@ref inner_exp) |\n@@ -2646,9 +2661,11 @@ fn populate_scope_map(cx: &mut CrateContext,\n                 for arm_ref in arms.iter() {\n                     let arm_span = arm_ref.pats[0].span;\n \n-                    do with_new_scope(cx, arm_span, scope_stack, scope_map) |cx,\n-                                                                             scope_stack,\n-                                                                             scope_map| {\n+                    with_new_scope(cx,\n+                                   arm_span,\n+                                   scope_stack,\n+                                   scope_map,\n+                                   |cx, scope_stack, scope_map| {\n                         for &pat in arm_ref.pats.iter() {\n                             walk_pattern(cx, pat, scope_stack, scope_map);\n                         }\n@@ -2658,7 +2675,7 @@ fn populate_scope_map(cx: &mut CrateContext,\n                         }\n \n                         walk_block(cx, &arm_ref.body, scope_stack, scope_map);\n-                    }\n+                    })\n                 }\n             }\n \n@@ -2769,14 +2786,14 @@ fn namespace_for_item(cx: &mut CrateContext,\n                 let namespace_name = token::ident_to_str(&ident);\n \n                 let namespace_metadata = unsafe {\n-                    do namespace_name.with_c_str |namespace_name| {\n+                    namespace_name.with_c_str(|namespace_name| {\n                         llvm::LLVMDIBuilderCreateNameSpace(\n                             DIB(cx),\n                             parent_scope,\n                             namespace_name,\n                             ptr::null(), // cannot reconstruct file ...\n                             0)           // ... or line information, but that's not so important.\n-                    }\n+                    })\n                 };\n \n                 let node = @NamespaceTreeNode {"}, {"sha": "4d69c95d281b235e14aee829a91aefcfd724ca6d", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 28, "deletions": 25, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=8ceb374ab783c6417b60867e7f34bebe997936ac", "patch": "@@ -693,10 +693,12 @@ fn trans_rvalue_dps_unadjusted(bcx: @mut Block, expr: &ast::Expr,\n             return _match::trans_match(bcx, expr, discr, *arms, dest);\n         }\n         ast::ExprBlock(ref blk) => {\n-            return do base::with_scope(bcx, blk.info(),\n-                                       \"block-expr body\") |bcx| {\n+            return base::with_scope(bcx,\n+                                    blk.info(),\n+                                    \"block-expr body\",\n+                                    |bcx| {\n                 controlflow::trans_block(bcx, blk, dest)\n-            };\n+            });\n         }\n         ast::ExprStruct(_, ref fields, base) => {\n             return trans_rec_or_struct(bcx, (*fields), base, expr.span, expr.id, dest);\n@@ -930,17 +932,18 @@ fn trans_lvalue_unadjusted(bcx: @mut Block, expr: &ast::Expr) -> DatumBlock {\n \n         let base_datum = unpack_datum!(bcx, trans_to_datum(bcx, base));\n         let repr = adt::represent_type(bcx.ccx(), base_datum.ty);\n-        do with_field_tys(bcx.tcx(), base_datum.ty, None) |discr, field_tys| {\n+        with_field_tys(bcx.tcx(), base_datum.ty, None, |discr, field_tys| {\n             let ix = ty::field_idx_strict(bcx.tcx(), field.name, field_tys);\n             DatumBlock {\n-                datum: do base_datum.get_element(bcx,\n-                                                 field_tys[ix].mt.ty,\n-                                                 ZeroMem) |srcval| {\n+                datum: base_datum.get_element(bcx,\n+                                              field_tys[ix].mt.ty,\n+                                              ZeroMem,\n+                                              |srcval| {\n                     adt::trans_field_ptr(bcx, repr, srcval, discr, ix)\n-                },\n+                }),\n                 bcx: bcx\n             }\n-        }\n+        })\n     }\n \n     fn trans_index(bcx: @mut Block,\n@@ -984,9 +987,9 @@ fn trans_lvalue_unadjusted(bcx: @mut Block, expr: &ast::Expr) -> DatumBlock {\n         let bounds_check = ICmp(bcx, lib::llvm::IntUGE, ix_val, len);\n         let expect = ccx.intrinsics.get_copy(&(\"llvm.expect.i1\"));\n         let expected = Call(bcx, expect, [bounds_check, C_i1(false)], []);\n-        let bcx = do with_cond(bcx, expected) |bcx| {\n+        let bcx = with_cond(bcx, expected, |bcx| {\n             controlflow::trans_fail_bounds_check(bcx, index_expr.span, ix_val, len)\n-        };\n+        });\n         let elt = InBoundsGEP(bcx, base, [ix_val]);\n         let elt = PointerCast(bcx, elt, vt.llunit_ty.ptr_to());\n         return DatumBlock {\n@@ -1044,11 +1047,11 @@ fn trans_lvalue_unadjusted(bcx: @mut Block, expr: &ast::Expr) -> DatumBlock {\n                             let symbol = csearch::get_symbol(\n                                 bcx.ccx().sess.cstore,\n                                 did);\n-                            let llval = do symbol.with_c_str |buf| {\n+                            let llval = symbol.with_c_str(|buf| {\n                                 llvm::LLVMAddGlobal(bcx.ccx().llmod,\n                                                     llty.to_ref(),\n                                                     buf)\n-                            };\n+                            });\n                             let extern_const_values = &mut bcx.ccx().extern_const_values;\n                             extern_const_values.insert(did, llval);\n                             llval\n@@ -1208,10 +1211,10 @@ fn trans_rec_or_struct(bcx: @mut Block,\n \n     let ty = node_id_type(bcx, id);\n     let tcx = bcx.tcx();\n-    do with_field_tys(tcx, ty, Some(id)) |discr, field_tys| {\n+    with_field_tys(tcx, ty, Some(id), |discr, field_tys| {\n         let mut need_base = vec::from_elem(field_tys.len(), true);\n \n-        let numbered_fields = do fields.map |field| {\n+        let numbered_fields = fields.map(|field| {\n             let opt_pos =\n                 field_tys.iter().position(|field_ty|\n                                           field_ty.ident.name == field.ident.node.name);\n@@ -1225,7 +1228,7 @@ fn trans_rec_or_struct(bcx: @mut Block,\n                                       \"Couldn't find field in struct type\")\n                 }\n             }\n-        };\n+        });\n         let optbase = match base {\n             Some(base_expr) => {\n                 let mut leftovers = ~[];\n@@ -1247,7 +1250,7 @@ fn trans_rec_or_struct(bcx: @mut Block,\n \n         let repr = adt::represent_type(bcx.ccx(), ty);\n         trans_adt(bcx, repr, discr, numbered_fields, optbase, dest)\n-    }\n+    })\n }\n \n /**\n@@ -1308,9 +1311,9 @@ fn trans_adt(bcx: @mut Block, repr: &adt::Repr, discr: ty::Disr,\n         // And, would it ever be reasonable to be here with discr != 0?\n         let base_datum = unpack_datum!(bcx, trans_to_datum(bcx, base.expr));\n         for &(i, t) in base.fields.iter() {\n-            let datum = do base_datum.get_element(bcx, t, ZeroMem) |srcval| {\n+            let datum = base_datum.get_element(bcx, t, ZeroMem, |srcval| {\n                 adt::trans_field_ptr(bcx, repr, srcval, discr, i)\n-            };\n+            });\n             let dest = adt::trans_field_ptr(bcx, repr, addr, discr, i);\n             bcx = datum.store_to(bcx, INIT, dest);\n         }\n@@ -1541,9 +1544,9 @@ fn trans_lazy_binop(bcx: @mut Block,\n     let bcx = bcx;\n \n     let Result {bcx: past_lhs, val: lhs} = {\n-        do base::with_scope_result(bcx, a.info(), \"lhs\") |bcx| {\n+        base::with_scope_result(bcx, a.info(), \"lhs\", |bcx| {\n             trans_to_datum(bcx, a).to_result()\n-        }\n+        })\n     };\n \n     if past_lhs.unreachable {\n@@ -1560,9 +1563,9 @@ fn trans_lazy_binop(bcx: @mut Block,\n     }\n \n     let Result {bcx: past_rhs, val: rhs} = {\n-        do base::with_scope_result(before_rhs, b.info(), \"rhs\") |bcx| {\n+        base::with_scope_result(before_rhs, b.info(), \"rhs\", |bcx| {\n             trans_to_datum(bcx, b).to_result()\n-        }\n+        })\n     };\n \n     if past_rhs.unreachable {\n@@ -1830,9 +1833,9 @@ pub fn trans_log_level(bcx: @mut Block) -> DatumBlock {\n             ccx, modpath, \"loglevel\");\n         let global;\n         unsafe {\n-            global = do s.with_c_str |buf| {\n+            global = s.with_c_str(|buf| {\n                 llvm::LLVMAddGlobal(ccx.llmod, Type::i32().to_ref(), buf)\n-            };\n+            });\n             llvm::LLVMSetGlobalConstant(global, False);\n             llvm::LLVMSetInitializer(global, C_null(Type::i32()));\n             lib::llvm::SetLinkage(global, lib::llvm::InternalLinkage);"}, {"sha": "742683307020086f0feeb436bd6c8d1777e20a71", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=8ceb374ab783c6417b60867e7f34bebe997936ac", "patch": "@@ -647,11 +647,11 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: @mut CrateContext,\n         }\n \n         // Perform the call itself\n-        let llrust_ret_val = do llrust_args.as_imm_buf |ptr, len| {\n+        let llrust_ret_val = llrust_args.as_imm_buf(|ptr, len| {\n             debug!(\"calling llrustfn = {}\", ccx.tn.val_to_str(llrustfn));\n             llvm::LLVMBuildCall(builder, llrustfn, ptr,\n                                 len as c_uint, noname())\n-        };\n+        });\n \n         // Get the return value where the foreign fn expects it.\n         let llforeign_ret_ty = match tys.fn_ty.ret_ty.cast {"}, {"sha": "70d983a01fa4f1e39cadfe68d2179ebd558ec4d6", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=8ceb374ab783c6417b60867e7f34bebe997936ac", "patch": "@@ -336,7 +336,7 @@ pub fn call_tydesc_glue(cx: @mut Block, v: ValueRef, t: ty::t, field: uint)\n \n pub fn make_visit_glue(bcx: @mut Block, v: ValueRef, t: ty::t) -> @mut Block {\n     let _icx = push_ctxt(\"make_visit_glue\");\n-    do with_scope(bcx, None, \"visitor cleanup\") |bcx| {\n+    with_scope(bcx, None, \"visitor cleanup\", |bcx| {\n         let mut bcx = bcx;\n         let (visitor_trait, object_ty) = match ty::visitor_object_ty(bcx.tcx(),\n                                                                      ty::ReStatic) {\n@@ -350,7 +350,7 @@ pub fn make_visit_glue(bcx: @mut Block, v: ValueRef, t: ty::t) -> @mut Block {\n         // The visitor is a boxed object and needs to be dropped\n         add_clean(bcx, v, object_ty);\n         bcx\n-    }\n+    })\n }\n \n pub fn make_free_glue(bcx: @mut Block, v: ValueRef, t: ty::t) -> @mut Block {\n@@ -394,9 +394,9 @@ pub fn trans_struct_drop_flag(bcx: @mut Block, t: ty::t, v0: ValueRef, dtor_did:\n                               class_did: ast::DefId, substs: &ty::substs) -> @mut Block {\n     let repr = adt::represent_type(bcx.ccx(), t);\n     let drop_flag = adt::trans_drop_flag_ptr(bcx, repr, v0);\n-    do with_cond(bcx, IsNotNull(bcx, Load(bcx, drop_flag))) |cx| {\n+    with_cond(bcx, IsNotNull(bcx, Load(bcx, drop_flag)), |cx| {\n         trans_struct_drop(cx, t, v0, dtor_did, class_did, substs)\n-    }\n+    })\n }\n \n pub fn trans_struct_drop(bcx: @mut Block, t: ty::t, v0: ValueRef, dtor_did: ast::DefId,\n@@ -420,7 +420,7 @@ pub fn trans_struct_drop(bcx: @mut Block, t: ty::t, v0: ValueRef, dtor_did: ast:\n     // Be sure to put all of the fields into a scope so we can use an invoke\n     // instruction to call the user destructor but still call the field\n     // destructors if the user destructor fails.\n-    do with_scope(bcx, None, \"field drops\") |bcx| {\n+    with_scope(bcx, None, \"field drops\", |bcx| {\n         let self_arg = PointerCast(bcx, v0, params[0]);\n         let args = ~[self_arg];\n \n@@ -434,7 +434,7 @@ pub fn trans_struct_drop(bcx: @mut Block, t: ty::t, v0: ValueRef, dtor_did: ast:\n \n         let (_, bcx) = invoke(bcx, dtor_addr, args, []);\n         bcx\n-    }\n+    })\n }\n \n pub fn make_drop_glue(bcx: @mut Block, v0: ValueRef, t: ty::t) -> @mut Block {\n@@ -480,7 +480,7 @@ pub fn make_drop_glue(bcx: @mut Block, v0: ValueRef, t: ty::t) -> @mut Block {\n       ty::ty_trait(_, _, ty::UniqTraitStore, _, _) => {\n           let lluniquevalue = GEPi(bcx, v0, [0, abi::trt_field_box]);\n           // Only drop the value when it is non-null\n-          do with_cond(bcx, IsNotNull(bcx, Load(bcx, lluniquevalue))) |bcx| {\n+          with_cond(bcx, IsNotNull(bcx, Load(bcx, lluniquevalue)), |bcx| {\n               let llvtable = Load(bcx, GEPi(bcx, v0, [0, abi::trt_field_vtable]));\n \n               // Cast the vtable to a pointer to a pointer to a tydesc.\n@@ -493,7 +493,7 @@ pub fn make_drop_glue(bcx: @mut Block, v0: ValueRef, t: ty::t) -> @mut Block {\n                                     abi::tydesc_field_free_glue,\n                                     None);\n               bcx\n-          }\n+          })\n       }\n       ty::ty_opaque_closure_ptr(ck) => {\n         closure::make_opaque_cbox_drop_glue(bcx, ck, v0)\n@@ -618,11 +618,11 @@ pub fn declare_tydesc(ccx: &mut CrateContext, t: ty::t) -> @mut tydesc_info {\n     let name = mangle_internal_name_by_type_and_seq(ccx, t, \"tydesc\").to_managed();\n     note_unique_llvm_symbol(ccx, name);\n     debug!(\"+++ declare_tydesc {} {}\", ppaux::ty_to_str(ccx.tcx, t), name);\n-    let gvar = do name.with_c_str |buf| {\n+    let gvar = name.with_c_str(|buf| {\n         unsafe {\n             llvm::LLVMAddGlobal(ccx.llmod, ccx.tydesc_type.to_ref(), buf)\n         }\n-    };\n+    });\n \n     let ty_name = C_estr_slice(ccx, ppaux::ty_to_str(ccx.tcx, t).to_managed());\n "}, {"sha": "71d2204b94f35d63aba7f755a5dda8ff3a81ee44", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=8ceb374ab783c6417b60867e7f34bebe997936ac", "patch": "@@ -545,14 +545,14 @@ pub fn get_vtable(bcx: @mut Block,\n     }\n \n     // Not in the cache. Actually build it.\n-    let methods = do origins.flat_map |origin| {\n+    let methods = origins.flat_map(|origin| {\n         match *origin {\n             typeck::vtable_static(id, ref substs, sub_vtables) => {\n                 emit_vtable_methods(bcx, id, *substs, sub_vtables)\n             }\n             _ => ccx.sess.bug(\"get_vtable: expected a static origin\"),\n         }\n-    };\n+    });\n \n     // Generate a type descriptor for the vtable.\n     let tydesc = get_tydesc(ccx, self_ty);\n@@ -578,9 +578,9 @@ pub fn make_vtable(ccx: &mut CrateContext,\n \n         let tbl = C_struct(components, false);\n         let sym = token::gensym(\"vtable\");\n-        let vt_gvar = do format!(\"vtable{}\", sym).with_c_str |buf| {\n+        let vt_gvar = format!(\"vtable{}\", sym).with_c_str(|buf| {\n             llvm::LLVMAddGlobal(ccx.llmod, val_ty(tbl).to_ref(), buf)\n-        };\n+        });\n         llvm::LLVMSetInitializer(vt_gvar, tbl);\n         llvm::LLVMSetGlobalConstant(vt_gvar, lib::llvm::True);\n         lib::llvm::SetLinkage(vt_gvar, lib::llvm::InternalLinkage);\n@@ -605,7 +605,7 @@ fn emit_vtable_methods(bcx: @mut Block,\n     ty::populate_implementations_for_trait_if_necessary(bcx.tcx(), trt_id);\n \n     let trait_method_def_ids = ty::trait_method_def_ids(tcx, trt_id);\n-    do trait_method_def_ids.map |method_def_id| {\n+    trait_method_def_ids.map(|method_def_id| {\n         let ident = ty::method(tcx, *method_def_id).ident;\n         // The substitutions we have are on the impl, so we grab\n         // the method type from the impl to substitute into.\n@@ -626,7 +626,7 @@ fn emit_vtable_methods(bcx: @mut Block,\n             trans_fn_ref_with_vtables(bcx, m_id, 0,\n                                       substs, Some(vtables)).llfn\n         }\n-    }\n+    })\n }\n \n pub fn trans_trait_cast(bcx: @mut Block,"}, {"sha": "ccfe0d6e9794982ff7953c50864963c592048421", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=8ceb374ab783c6417b60867e7f34bebe997936ac", "patch": "@@ -213,12 +213,12 @@ impl Reflector {\n           ty::ty_tup(ref tys) => {\n               let extra = ~[self.c_uint(tys.len())]\n                   + self.c_size_and_align(t);\n-              do self.bracketed(\"tup\", extra) |this| {\n+              self.bracketed(\"tup\", extra, |this| {\n                   for (i, t) in tys.iter().enumerate() {\n                       let extra = ~[this.c_uint(i), this.c_tydesc(*t)];\n                       this.visit(\"tup_field\", extra);\n                   }\n-              }\n+              })\n           }\n \n           // FIXME (#2594): fetch constants out of intrinsic\n@@ -262,15 +262,15 @@ impl Reflector {\n               let extra = ~[self.c_slice(ty_to_str(tcx, t).to_managed()),\n                             self.c_bool(named_fields),\n                             self.c_uint(fields.len())] + self.c_size_and_align(t);\n-              do self.bracketed(\"class\", extra) |this| {\n+              self.bracketed(\"class\", extra, |this| {\n                   for (i, field) in fields.iter().enumerate() {\n                       let extra = ~[this.c_uint(i),\n                                     this.c_slice(bcx.ccx().sess.str_of(field.ident)),\n                                     this.c_bool(named_fields)]\n                           + this.c_mt(&field.mt);\n                       this.visit(\"class_field\", extra);\n                   }\n-              }\n+              })\n           }\n \n           // FIXME (#2595): visiting all the variants in turn is probably\n@@ -320,14 +320,14 @@ impl Reflector {\n \n             let enum_args = ~[self.c_uint(variants.len()), make_get_disr()]\n                 + self.c_size_and_align(t);\n-            do self.bracketed(\"enum\", enum_args) |this| {\n+            self.bracketed(\"enum\", enum_args, |this| {\n                 for (i, v) in variants.iter().enumerate() {\n                     let name = ccx.sess.str_of(v.name);\n                     let variant_args = ~[this.c_uint(i),\n                                          C_u64(v.disr_val),\n                                          this.c_uint(v.args.len()),\n                                          this.c_slice(name)];\n-                    do this.bracketed(\"enum_variant\", variant_args) |this| {\n+                    this.bracketed(\"enum_variant\", variant_args, |this| {\n                         for (j, a) in v.args.iter().enumerate() {\n                             let bcx = this.bcx;\n                             let null = C_null(llptrty);\n@@ -338,9 +338,9 @@ impl Reflector {\n                                                this.c_tydesc(*a)];\n                             this.visit(\"enum_variant_field\", field_args);\n                         }\n-                    }\n+                    })\n                 }\n-            }\n+            })\n           }\n \n           ty::ty_trait(_, _, _, _, _) => {"}, {"sha": "18b45fb461381617bfa23b17928c37fb2720270f", "filename": "src/librustc/middle/trans/uniq.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Ftrans%2Funiq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Ftrans%2Funiq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Funiq.rs?ref=8ceb374ab783c6417b60867e7f34bebe997936ac", "patch": "@@ -23,7 +23,7 @@ pub fn make_free_glue(bcx: @mut Block, vptrptr: ValueRef, box_ty: ty::t)\n     let box_datum = immediate_rvalue(Load(bcx, vptrptr), box_ty);\n \n     let not_null = IsNotNull(bcx, box_datum.val);\n-    do with_cond(bcx, not_null) |bcx| {\n+    with_cond(bcx, not_null, |bcx| {\n         let body_datum = box_datum.box_body(bcx);\n         let bcx = glue::drop_ty(bcx, body_datum.to_ref_llval(bcx),\n                                 body_datum.ty);\n@@ -32,5 +32,5 @@ pub fn make_free_glue(bcx: @mut Block, vptrptr: ValueRef, box_ty: ty::t)\n         } else {\n             glue::trans_exchange_free(bcx, box_datum.val)\n         }\n-    }\n+    })\n }"}, {"sha": "59bc397a55884f96e9a105642f4938634ff4075b", "filename": "src/librustc/middle/trans/value.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Ftrans%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Ftrans%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fvalue.rs?ref=8ceb374ab783c6417b60867e7f34bebe997936ac", "patch": "@@ -52,7 +52,7 @@ impl Value {\n     pub fn get_dominating_store(self, bcx: &mut Block) -> Option<Value> {\n         match self.get_single_user().and_then(|user| user.as_store_inst()) {\n             Some(store) => {\n-                do store.get_parent().and_then |store_bb| {\n+                store.get_parent().and_then(|store_bb| {\n                     let mut bb = BasicBlock(bcx.llbb);\n                     let mut ret = Some(store);\n                     while *bb != *store_bb {\n@@ -62,7 +62,7 @@ impl Value {\n                         }\n                     }\n                     ret\n-                }\n+                })\n             }\n             _ => None\n         }\n@@ -150,8 +150,8 @@ impl Iterator<Value> for UserIterator {\n     fn next(&mut self) -> Option<Value> {\n         let current = self.next;\n \n-        self.next = do current.and_then |u| { u.get_next_use() };\n+        self.next = current.and_then(|u| u.get_next_use());\n \n-        do current.map |u| { u.get_user() }\n+        current.map(|u| u.get_user())\n     }\n }"}, {"sha": "00487830490e74b3c54a6de3a9f8d9ead02c0028", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 44, "deletions": 44, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=8ceb374ab783c6417b60867e7f34bebe997936ac", "patch": "@@ -1684,7 +1684,7 @@ fn type_needs_unwind_cleanup_(cx: ctxt, ty: t,\n \n     let mut encountered_box = encountered_box;\n     let mut needs_unwind_cleanup = false;\n-    do maybe_walk_ty(ty) |ty| {\n+    maybe_walk_ty(ty, |ty| {\n         let old_encountered_box = encountered_box;\n         let result = match get(ty).sty {\n           ty_box(_) | ty_opaque_box => {\n@@ -1729,7 +1729,7 @@ fn type_needs_unwind_cleanup_(cx: ctxt, ty: t,\n \n         encountered_box = old_encountered_box;\n         result\n-    }\n+    });\n \n     return needs_unwind_cleanup;\n }\n@@ -2207,14 +2207,14 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n                                -> TypeContents {\n         let _i = indenter();\n         let mut tc = TC::All;\n-        do each_inherited_builtin_bound(cx, bounds, traits) |bound| {\n+        each_inherited_builtin_bound(cx, bounds, traits, |bound| {\n             tc = tc - match bound {\n                 BoundStatic => TC::Nonstatic,\n                 BoundSend => TC::Nonsendable,\n                 BoundFreeze => TC::Nonfreezable,\n                 BoundSized => TC::Nonsized,\n             };\n-        }\n+        });\n         return tc;\n \n         // Iterates over all builtin bounds on the type parameter def, including\n@@ -2227,13 +2227,13 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n                 f(bound);\n             }\n \n-            do each_bound_trait_and_supertraits(cx, traits) |trait_ref| {\n+            each_bound_trait_and_supertraits(cx, traits, |trait_ref| {\n                 let trait_def = lookup_trait_def(cx, trait_ref.def_id);\n                 for bound in trait_def.bounds.iter() {\n                     f(bound);\n                 }\n                 true\n-            };\n+            });\n         }\n     }\n }\n@@ -2327,12 +2327,12 @@ pub fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n             ty_enum(did, ref substs) => {\n                 seen.push(did);\n                 let vs = enum_variants(cx, did);\n-                let r = !vs.is_empty() && do vs.iter().all |variant| {\n-                    do variant.args.iter().any |aty| {\n+                let r = !vs.is_empty() && vs.iter().all(|variant| {\n+                    variant.args.iter().any(|aty| {\n                         let sty = subst(cx, substs, *aty);\n                         type_requires(cx, seen, r_ty, sty)\n-                    }\n-                };\n+                    })\n+                });\n                 seen.pop();\n                 r\n             }\n@@ -2490,11 +2490,11 @@ pub fn type_is_pod(cx: ctxt, ty: t) -> bool {\n       ty_opaque_closure_ptr(_) => result = true,\n       ty_struct(did, ref substs) => {\n         let fields = lookup_struct_fields(cx, did);\n-        result = do fields.iter().all |f| {\n+        result = fields.iter().all(|f| {\n             let fty = ty::lookup_item_type(cx, f.id);\n             let sty = subst(cx, substs, fty.ty);\n             type_is_pod(cx, sty)\n-        };\n+        });\n       }\n \n       ty_estr(vstore_slice(*)) | ty_evec(_, vstore_slice(*)) => {\n@@ -3000,7 +3000,7 @@ pub fn method_call_type_param_defs(tcx: ctxt,\n                                    method_map: typeck::method_map,\n                                    id: ast::NodeId)\n                                    -> Option<@~[TypeParameterDef]> {\n-    do method_map.find(&id).map |method| {\n+    method_map.find(&id).map(|method| {\n         match method.origin {\n           typeck::method_static(did) => {\n             // n.b.: When we encode impl methods, the bounds\n@@ -3026,7 +3026,7 @@ pub fn method_call_type_param_defs(tcx: ctxt,\n                                   n_mth).generics.type_param_defs)\n           }\n         }\n-    }\n+    })\n }\n \n pub fn resolve_expr(tcx: ctxt, expr: &ast::Expr) -> ast::Def {\n@@ -3217,14 +3217,14 @@ pub fn method_idx(id: ast::Ident, meths: &[@Method]) -> Option<uint> {\n /// to a bitset or some other representation.\n pub fn param_tys_in_type(ty: t) -> ~[param_ty] {\n     let mut rslt = ~[];\n-    do walk_ty(ty) |ty| {\n+    walk_ty(ty, |ty| {\n         match get(ty).sty {\n           ty_param(p) => {\n             rslt.push(p);\n           }\n           _ => ()\n         }\n-    }\n+    });\n     rslt\n }\n \n@@ -3233,12 +3233,12 @@ pub fn occurs_check(tcx: ctxt, sp: Span, vid: TyVid, rt: t) {\n     // contain duplicates.  (Integral type vars aren't counted.)\n     fn vars_in_type(ty: t) -> ~[TyVid] {\n         let mut rslt = ~[];\n-        do walk_ty(ty) |ty| {\n+        walk_ty(ty, |ty| {\n             match get(ty).sty {\n               ty_infer(TyVar(v)) => rslt.push(v),\n               _ => ()\n             }\n-        }\n+        });\n         rslt\n     }\n \n@@ -3644,9 +3644,9 @@ fn struct_ctor_id(cx: ctxt, struct_did: ast::DefId) -> Option<ast::DefId> {\n         Some(&ast_map::node_item(item, _)) => {\n             match item.node {\n                 ast::item_struct(struct_def, _) => {\n-                    do struct_def.ctor_id.map |ctor_id| {\n+                    struct_def.ctor_id.map(|ctor_id| {\n                         ast_util::local_def(ctor_id)\n-                    }\n+                    })\n                 }\n                 _ => cx.sess.bug(\"called struct_ctor_id on non-struct\")\n             }\n@@ -3698,13 +3698,13 @@ impl VariantInfo {\n                 assert!(fields.len() > 0);\n \n                 let arg_tys = ty_fn_args(ctor_ty).map(|a| *a);\n-                let arg_names = do fields.map |field| {\n+                let arg_names = fields.map(|field| {\n                     match field.node.kind {\n                         named_field(ident, _) => ident,\n                         unnamed_field => cx.sess.bug(\n                             \"enum_variants: all fields in struct must have a name\")\n                     }\n-                };\n+                });\n \n                 return VariantInfo {\n                     args: arg_tys,\n@@ -3724,7 +3724,7 @@ pub fn substd_enum_variants(cx: ctxt,\n                             id: ast::DefId,\n                             substs: &substs)\n                          -> ~[@VariantInfo] {\n-    do enum_variants(cx, id).iter().map |variant_info| {\n+    enum_variants(cx, id).iter().map(|variant_info| {\n         let substd_args = variant_info.args.iter()\n             .map(|aty| subst(cx, substs, *aty)).collect();\n \n@@ -3735,7 +3735,7 @@ pub fn substd_enum_variants(cx: ctxt,\n             ctor_ty: substd_ctor_ty,\n             ..(**variant_info).clone()\n         }\n-    }.collect()\n+    }).collect()\n }\n \n pub fn item_path_str(cx: ctxt, id: ast::DefId) -> ~str {\n@@ -3967,11 +3967,11 @@ pub fn each_attr(tcx: ctxt, did: DefId, f: |@MetaItem| -> bool) -> bool {\n         }\n     } else {\n         let mut cont = true;\n-        do csearch::get_item_attrs(tcx.cstore, did) |meta_items| {\n+        csearch::get_item_attrs(tcx.cstore, did, |meta_items| {\n             if cont {\n                 cont = meta_items.iter().advance(|ptrptr| f(*ptrptr));\n             }\n-        }\n+        });\n         return cont;\n     }\n }\n@@ -4083,7 +4083,7 @@ pub fn lookup_struct_field(cx: ctxt,\n }\n \n fn struct_field_tys(fields: &[@struct_field]) -> ~[field_ty] {\n-    do fields.map |field| {\n+    fields.map(|field| {\n         match field.node.kind {\n             named_field(ident, visibility) => {\n                 field_ty {\n@@ -4101,14 +4101,14 @@ fn struct_field_tys(fields: &[@struct_field]) -> ~[field_ty] {\n                 }\n             }\n         }\n-    }\n+    })\n }\n \n // Returns a list of fields corresponding to the struct's items. trans uses\n // this. Takes a list of substs with which to instantiate field types.\n pub fn struct_fields(cx: ctxt, did: ast::DefId, substs: &substs)\n                      -> ~[field] {\n-    do lookup_struct_fields(cx, did).map |f| {\n+    lookup_struct_fields(cx, did).map(|f| {\n        field {\n             // FIXME #6993: change type of field to Name and get rid of new()\n             ident: ast::Ident::new(f.name),\n@@ -4117,7 +4117,7 @@ pub fn struct_fields(cx: ctxt, did: ast::DefId, substs: &substs)\n                 mutbl: MutImmutable\n             }\n         }\n-    }\n+    })\n }\n \n pub fn is_binopable(cx: ctxt, ty: t, op: ast::BinOp) -> bool {\n@@ -4381,27 +4381,27 @@ pub fn count_traits_and_supertraits(tcx: ctxt,\n                                     type_param_defs: &[TypeParameterDef]) -> uint {\n     let mut total = 0;\n     for type_param_def in type_param_defs.iter() {\n-        do each_bound_trait_and_supertraits(\n-            tcx, type_param_def.bounds.trait_bounds) |_| {\n+        each_bound_trait_and_supertraits(\n+            tcx, type_param_def.bounds.trait_bounds, |_| {\n             total += 1;\n             true\n-        };\n+        });\n     }\n     return total;\n }\n \n pub fn get_tydesc_ty(tcx: ctxt) -> Result<t, ~str> {\n-    do tcx.lang_items.require(TyDescStructLangItem).map |tydesc_lang_item| {\n+    tcx.lang_items.require(TyDescStructLangItem).map(|tydesc_lang_item| {\n         tcx.intrinsic_defs.find_copy(&tydesc_lang_item)\n             .expect(\"Failed to resolve TyDesc\")\n-    }\n+    })\n }\n \n pub fn get_opaque_ty(tcx: ctxt) -> Result<t, ~str> {\n-    do tcx.lang_items.require(OpaqueStructLangItem).map |opaque_lang_item| {\n+    tcx.lang_items.require(OpaqueStructLangItem).map(|opaque_lang_item| {\n         tcx.intrinsic_defs.find_copy(&opaque_lang_item)\n             .expect(\"Failed to resolve Opaque\")\n-    }\n+    })\n }\n \n pub fn visitor_object_ty(tcx: ctxt,\n@@ -4460,7 +4460,7 @@ pub fn populate_implementations_for_type_if_necessary(tcx: ctxt,\n         return\n     }\n \n-    do csearch::each_implementation_for_type(tcx.sess.cstore, type_id)\n+    csearch::each_implementation_for_type(tcx.sess.cstore, type_id,\n             |implementation_def_id| {\n         let implementation = @csearch::get_impl(tcx, implementation_def_id);\n \n@@ -4498,7 +4498,7 @@ pub fn populate_implementations_for_type_if_necessary(tcx: ctxt,\n \n         // Store the implementation info.\n         tcx.impls.insert(implementation_def_id, implementation);\n-    }\n+    });\n \n     tcx.populated_external_types.insert(type_id);\n }\n@@ -4515,7 +4515,7 @@ pub fn populate_implementations_for_trait_if_necessary(\n         return\n     }\n \n-    do csearch::each_implementation_for_trait(tcx.sess.cstore, trait_id)\n+    csearch::each_implementation_for_trait(tcx.sess.cstore, trait_id,\n             |implementation_def_id| {\n         let implementation = @csearch::get_impl(tcx, implementation_def_id);\n \n@@ -4532,7 +4532,7 @@ pub fn populate_implementations_for_trait_if_necessary(\n \n         // Store the implementation info.\n         tcx.impls.insert(implementation_def_id, implementation);\n-    }\n+    });\n \n     tcx.populated_external_traits.insert(trait_id);\n }\n@@ -4607,9 +4607,9 @@ pub fn hash_crate_independent(tcx: ctxt, t: t, local_hash: @str) -> u64 {\n         iter(hash, &mt.mutbl);\n     };\n     fn iter<T: IterBytes>(hash: &mut SipState, t: &T) {\n-        do t.iter_bytes(true) |bytes| { hash.input(bytes); true };\n+        t.iter_bytes(true, |bytes| { hash.input(bytes); true });\n     }\n-    do ty::walk_ty(t) |t| {\n+    ty::walk_ty(t, |t| {\n         match ty::get(t).sty {\n             ty_nil => hash.input([0]),\n             ty_bot => hash.input([1]),\n@@ -4714,7 +4714,7 @@ pub fn hash_crate_independent(tcx: ctxt, t: t, local_hash: @str) -> u64 {\n                 mt(&mut hash, m);\n             }\n         }\n-    }\n+    });\n \n     hash.result_u64()\n }"}, {"sha": "77dbb66fd7f5860fb987276272de37b61c5a3d06", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=8ceb374ab783c6417b60867e7f34bebe997936ac", "patch": "@@ -635,9 +635,9 @@ fn ty_of_method_or_bare_fn<AC:AstConv>(\n     // that function type\n     let rb = rscope::BindingRscope::new(id);\n \n-    let opt_transformed_self_ty = do opt_self_info.map |self_info| {\n+    let opt_transformed_self_ty = opt_self_info.map(|self_info| {\n         transform_self_ty(this, &rb, self_info)\n-    };\n+    });\n \n     let input_tys = decl.inputs.map(|a| ty_of_arg(this, &rb, a, None));\n \n@@ -730,14 +730,14 @@ pub fn ty_of_closure<AC:AstConv,RS:RegionScope>(\n     // that function type\n     let rb = rscope::BindingRscope::new(id);\n \n-    let input_tys = do decl.inputs.iter().enumerate().map |(i, a)| {\n-        let expected_arg_ty = do expected_sig.as_ref().and_then |e| {\n+    let input_tys = decl.inputs.iter().enumerate().map(|(i, a)| {\n+        let expected_arg_ty = expected_sig.as_ref().and_then(|e| {\n             // no guarantee that the correct number of expected args\n             // were supplied\n             if i < e.inputs.len() {Some(e.inputs[i])} else {None}\n-        };\n+        });\n         ty_of_arg(this, &rb, a, expected_arg_ty)\n-    }.collect();\n+    }).collect();\n \n     let expected_ret_ty = expected_sig.map(|e| e.output);\n     let output_ty = match decl.output.node {"}, {"sha": "c7503e25684a12ca01bd39a5130d4c5b726fc5f2", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=8ceb374ab783c6417b60867e7f34bebe997936ac", "patch": "@@ -378,14 +378,13 @@ impl<'self> LookupContext<'self> {\n         // we find the trait the method came from, counting up the\n         // methods from them.\n         let mut method_count = 0;\n-        do ty::each_bound_trait_and_supertraits(tcx, &[subtrait])\n-            |bound_ref| {\n+        ty::each_bound_trait_and_supertraits(tcx, &[subtrait], |bound_ref| {\n             if bound_ref.def_id == trait_ref.def_id { false }\n                 else {\n                 method_count += ty::trait_methods(tcx, bound_ref.def_id).len();\n                 true\n             }\n-        };\n+        });\n         return method_count + n_method;\n     }\n \n@@ -412,7 +411,7 @@ impl<'self> LookupContext<'self> {\n         };\n         let trait_ref = @TraitRef { def_id: did, substs: rcvr_substs.clone() };\n \n-        do self.push_inherent_candidates_from_bounds_inner(&[trait_ref])\n+        self.push_inherent_candidates_from_bounds_inner(&[trait_ref],\n             |new_trait_ref, m, method_num, _bound_num| {\n             let vtable_index =\n                 self.get_method_index(new_trait_ref, trait_ref, method_num);\n@@ -436,7 +435,7 @@ impl<'self> LookupContext<'self> {\n                         real_index: vtable_index\n                     })\n             }\n-        };\n+        });\n     }\n \n     fn push_inherent_candidates_from_param(&self,\n@@ -464,7 +463,7 @@ impl<'self> LookupContext<'self> {\n                                             self_ty: ty::t,\n                                             bounds: &[@TraitRef],\n                                             param: param_index) {\n-        do self.push_inherent_candidates_from_bounds_inner(bounds)\n+        self.push_inherent_candidates_from_bounds_inner(bounds,\n             |trait_ref, m, method_num, bound_num| {\n             Candidate {\n                 rcvr_match_condition: RcvrMatchesIfSubtype(self_ty),\n@@ -478,7 +477,7 @@ impl<'self> LookupContext<'self> {\n                         bound_num: bound_num,\n                     })\n             }\n-        }\n+        })\n     }\n \n     // Do a search through a list of bounds, using a callback to actually\n@@ -493,7 +492,7 @@ impl<'self> LookupContext<'self> {\n         let tcx = self.tcx();\n         let mut next_bound_idx = 0; // count only trait bounds\n \n-        do ty::each_bound_trait_and_supertraits(tcx, bounds) |bound_trait_ref| {\n+        ty::each_bound_trait_and_supertraits(tcx, bounds, |bound_trait_ref| {\n             let this_bound_idx = next_bound_idx;\n             next_bound_idx += 1;\n \n@@ -518,7 +517,7 @@ impl<'self> LookupContext<'self> {\n                 }\n             }\n             true\n-        };\n+        });\n     }\n \n "}, {"sha": "b9d6744e53b193314654f04fe57ac14d119debd0", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=8ceb374ab783c6417b60867e7f34bebe997936ac", "patch": "@@ -392,12 +392,10 @@ impl Visitor<()> for GatherLocalsVisitor {\n     }\n \n     fn visit_block(&mut self, b:&ast::Block, _:()) {\n-            // non-obvious: the `blk` variable maps to region lb, so\n-            // we have to keep this up-to-date.  This\n-            // is... unfortunate.  It'd be nice to not need this.\n-            do self.fcx.with_region_lb(b.id) {\n-                visit::walk_block(self, b, ());\n-            }\n+        // non-obvious: the `blk` variable maps to region lb, so\n+        // we have to keep this up-to-date.  This\n+        // is... unfortunate.  It'd be nice to not need this.\n+        self.fcx.with_region_lb(b.id, || visit::walk_block(self, b, ()));\n     }\n \n         // Don't descend into fns and items\n@@ -517,10 +515,11 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n         // Add formal parameters.\n         for (arg_ty, input) in arg_tys.iter().zip(decl.inputs.iter()) {\n             // Create type variables for each argument.\n-            do pat_util::pat_bindings(tcx.def_map, input.pat)\n-                    |_bm, pat_id, _sp, _path| {\n+            pat_util::pat_bindings(tcx.def_map,\n+                                   input.pat,\n+                                   |_bm, pat_id, _sp, _path| {\n                 visit.assign(pat_id, None);\n-            }\n+            });\n \n             // Check the pattern.\n             let pcx = pat_ctxt {\n@@ -1392,17 +1391,17 @@ pub fn valid_range_bounds(ccx: @mut CrateCtxt,\n pub fn check_expr_has_type(\n     fcx: @mut FnCtxt, expr: @ast::Expr,\n     expected: ty::t) {\n-    do check_expr_with_unifier(fcx, expr, Some(expected)) {\n+    check_expr_with_unifier(fcx, expr, Some(expected), || {\n         demand::suptype(fcx, expr.span, expected, fcx.expr_ty(expr));\n-    }\n+    });\n }\n \n pub fn check_expr_coercable_to_type(\n     fcx: @mut FnCtxt, expr: @ast::Expr,\n     expected: ty::t) {\n-    do check_expr_with_unifier(fcx, expr, Some(expected)) {\n+    check_expr_with_unifier(fcx, expr, Some(expected), || {\n         demand::coerce(fcx, expr.span, expected, expr)\n-    }\n+    });\n }\n \n pub fn check_expr_with_hint(\n@@ -1462,9 +1461,7 @@ pub fn lookup_field_ty(tcx: ty::ctxt,\n                        substs: &ty::substs) -> Option<ty::t> {\n \n     let o_field = items.iter().find(|f| f.name == fieldname);\n-    do o_field.map() |f| {\n-        ty::lookup_field_type(tcx, class_id, f.id, substs)\n-    }\n+    o_field.map(|f| ty::lookup_field_type(tcx, class_id, f.id, substs))\n }\n \n // Controls whether the arguments are automatically referenced. This is useful\n@@ -2693,7 +2690,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         }\n       }\n       ast::ExprUnary(callee_id, unop, oprnd) => {\n-        let exp_inner = do unpack_expected(fcx, expected) |sty| {\n+        let exp_inner = unpack_expected(fcx, expected, |sty| {\n             match unop {\n               ast::UnBox(_) | ast::UnUniq => match *sty {\n                 ty::ty_box(ref mt) | ty::ty_uniq(ref mt) => Some(mt.ty),\n@@ -2702,7 +2699,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n               ast::UnNot | ast::UnNeg => expected,\n               ast::UnDeref => None\n             }\n-        };\n+        });\n         check_expr_with_opt_hint(fcx, oprnd, exp_inner);\n         let mut oprnd_t = fcx.expr_ty(oprnd);\n         if !ty::type_is_error(oprnd_t) &&\n@@ -2925,12 +2922,15 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                                            expected,\n                                            |x| Some((*x).clone()));\n         let inner_ty = match expected_sty {\n-            Some(ty::ty_closure(_)) => expected.unwrap(),\n+            Some(ty::ty_closure(ref closure_ty))\n+                    if closure_ty.sigil == ast::OwnedSigil => {\n+                expected.unwrap()\n+            }\n             _ => match expected {\n                 Some(expected_t) => {\n                     fcx.type_error_message(expr.span, |actual| {\n                         format!(\"last argument in `do` call \\\n-                              has non-closure type: {}\",\n+                              has non-procedure type: {}\",\n                              actual)\n                     }, expected_t, None);\n                     let err_ty = ty::mk_err();\n@@ -3137,7 +3137,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         let mut bot_field = false;\n         let mut err_field = false;\n \n-        let elt_ts = do elts.iter().enumerate().map |(i, e)| {\n+        let elt_ts = elts.iter().enumerate().map(|(i, e)| {\n             let opt_hint = match flds {\n                 Some(ref fs) if i < fs.len() => Some(fs[i]),\n                 _ => None\n@@ -3147,7 +3147,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n             err_field = err_field || ty::type_is_error(t);\n             bot_field = bot_field || ty::type_is_bot(t);\n             t\n-        }.collect();\n+        }).collect();\n         if bot_field {\n             fcx.write_bot(id);\n         } else if err_field {\n@@ -3355,7 +3355,7 @@ pub fn check_block_with_expected(fcx: @mut FnCtxt,\n     let purity_state = fcx.ps.recurse(blk);\n     let prev = replace(&mut fcx.ps, purity_state);\n \n-    do fcx.with_region_lb(blk.id) {\n+    fcx.with_region_lb(blk.id, || {\n         let mut warned = false;\n         let mut last_was_bot = false;\n         let mut any_bot = false;\n@@ -3408,7 +3408,7 @@ pub fn check_block_with_expected(fcx: @mut FnCtxt,\n               }\n           }\n         };\n-    }\n+    });\n \n     fcx.ps = prev;\n }"}, {"sha": "98ef129dd208f54ecfb99643ec6ae4a28039bbfc", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=8ceb374ab783c6417b60867e7f34bebe997936ac", "patch": "@@ -212,7 +212,7 @@ fn visit_local(rcx: &mut Rcx, l: @ast::Local) {\n fn constrain_bindings_in_pat(pat: @ast::Pat, rcx: &mut Rcx) {\n     let tcx = rcx.fcx.tcx();\n     debug!(\"regionck::visit_pat(pat={})\", pat.repr(tcx));\n-    do pat_util::pat_bindings(tcx.def_map, pat) |_, id, span, _| {\n+    pat_util::pat_bindings(tcx.def_map, pat, |_, id, span, _| {\n         // If we have a variable that contains region'd data, that\n         // data will be accessible from anywhere that the variable is\n         // accessed. We must be wary of loops like this:\n@@ -240,7 +240,7 @@ fn constrain_bindings_in_pat(pat: @ast::Pat, rcx: &mut Rcx) {\n         constrain_regions_in_type_of_node(\n             rcx, id, encl_region,\n             infer::BindingTypeIsNotValidAtDecl(span));\n-    }\n+    })\n }\n \n fn visit_expr(rcx: &mut Rcx, expr: @ast::Expr) {\n@@ -735,7 +735,7 @@ fn constrain_regions_in_type(\n            region_to_str(tcx, \"\", false, minimum_lifetime),\n            ty_to_str(tcx, ty));\n \n-    do relate_nested_regions(tcx, Some(minimum_lifetime), ty) |r_sub, r_sup| {\n+    relate_nested_regions(tcx, Some(minimum_lifetime), ty, |r_sub, r_sup| {\n         debug!(\"relate_nested_regions(r_sub={}, r_sup={})\",\n                 r_sub.repr(tcx),\n                 r_sup.repr(tcx));\n@@ -754,7 +754,7 @@ fn constrain_regions_in_type(\n                 true, infer::ReferenceOutlivesReferent(ty, origin.span()),\n                 r_sub, r_sup);\n         }\n-    }\n+    });\n \n     return (e == rcx.errors_reported);\n }"}, {"sha": "782a5276b7470e7157cfe6abadecd9fcf74f8221", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=8ceb374ab783c6417b60867e7f34bebe997936ac", "patch": "@@ -132,7 +132,7 @@ fn lookup_vtables_for_param(vcx: &VtableContext,\n     // ty is the value supplied for the type parameter A...\n     let mut param_result = ~[];\n \n-    do ty::each_bound_trait_and_supertraits(tcx, type_param_bounds.trait_bounds) |trait_ref| {\n+    ty::each_bound_trait_and_supertraits(tcx, type_param_bounds.trait_bounds, |trait_ref| {\n         // ...and here trait_ref is each bound that was declared on A,\n         // expressed in terms of the type parameters.\n \n@@ -161,7 +161,7 @@ fn lookup_vtables_for_param(vcx: &VtableContext,\n             }\n         }\n         true\n-    };\n+    });\n \n     debug!(\"lookup_vtables_for_param result(\\\n             location_info={:?}, \\\n@@ -291,7 +291,7 @@ fn lookup_vtable_from_bounds(vcx: &VtableContext,\n \n     let mut n_bound = 0;\n     let mut ret = None;\n-    do ty::each_bound_trait_and_supertraits(tcx, bounds) |bound_trait_ref| {\n+    ty::each_bound_trait_and_supertraits(tcx, bounds, |bound_trait_ref| {\n         debug!(\"checking bounds trait {}\",\n                bound_trait_ref.repr(vcx.tcx()));\n \n@@ -309,7 +309,7 @@ fn lookup_vtable_from_bounds(vcx: &VtableContext,\n             n_bound += 1;\n             true\n         }\n-    };\n+    });\n     ret\n }\n \n@@ -483,12 +483,12 @@ fn fixup_substs(vcx: &VtableContext,\n                          ty::RegionTraitStore(ty::ReStatic),\n                          ast::MutImmutable,\n                          ty::EmptyBuiltinBounds());\n-    do fixup_ty(vcx, location_info, t, is_early).map |t_f| {\n+    fixup_ty(vcx, location_info, t, is_early).map(|t_f| {\n         match ty::get(t_f).sty {\n           ty::ty_trait(_, ref substs_f, _, _, _) => (*substs_f).clone(),\n           _ => fail!(\"t_f should be a trait\")\n         }\n-    }\n+    })\n }\n \n fn fixup_ty(vcx: &VtableContext,\n@@ -560,7 +560,7 @@ pub fn early_resolve_expr(ex: @ast::Expr,\n     let cx = fcx.ccx;\n     match ex.node {\n       ast::ExprPath(*) => {\n-        do fcx.opt_node_ty_substs(ex.id) |substs| {\n+        fcx.opt_node_ty_substs(ex.id, |substs| {\n             debug!(\"vtable resolution on parameter bounds for expr {}\",\n                    ex.repr(fcx.tcx()));\n             let def = cx.tcx.def_map.get_copy(&ex.id);\n@@ -580,7 +580,7 @@ pub fn early_resolve_expr(ex: @ast::Expr,\n                 }\n             }\n             true\n-        };\n+        });\n       }\n \n       ast::ExprParen(e) => {"}, {"sha": "e2da054527c66835adbe0519eb6af0966caa7e57", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=8ceb374ab783c6417b60867e7f34bebe997936ac", "patch": "@@ -180,7 +180,7 @@ fn resolve_type_vars_for_node(wbcx: &mut WbCtxt, sp: Span, id: ast::NodeId)\n                id, ppaux::ty_to_str(tcx, n_ty), ppaux::ty_to_str(tcx, t));\n         write_ty_to_tcx(tcx, id, t);\n         let mut ret = Some(t);\n-        do fcx.opt_node_ty_substs(id) |substs| {\n+        fcx.opt_node_ty_substs(id, |substs| {\n           let mut new_tps = ~[];\n           for subst in substs.tps.iter() {\n               match resolve_type_vars_in_type(fcx, sp, *subst) {\n@@ -190,7 +190,7 @@ fn resolve_type_vars_for_node(wbcx: &mut WbCtxt, sp: Span, id: ast::NodeId)\n           }\n           write_substs_to_tcx(tcx, id, new_tps);\n           ret.is_some()\n-        };\n+        });\n         ret\n       }\n     }"}, {"sha": "115058824c6ff8e3d32374c93507f33db0321393", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=8ceb374ab783c6417b60867e7f34bebe997936ac", "patch": "@@ -102,7 +102,7 @@ pub fn type_is_defined_in_local_crate(original_type: t) -> bool {\n      */\n \n     let mut found_nominal = false;\n-    do ty::walk_ty(original_type) |t| {\n+    ty::walk_ty(original_type, |t| {\n         match get(t).sty {\n             ty_enum(def_id, _) |\n             ty_trait(def_id, _, _, _, _) |\n@@ -114,7 +114,7 @@ pub fn type_is_defined_in_local_crate(original_type: t) -> bool {\n \n             _ => { }\n         }\n-    }\n+    });\n     return found_nominal;\n }\n \n@@ -413,22 +413,22 @@ impl CoherenceChecker {\n     }\n \n     pub fn check_implementation_coherence(&self) {\n-        do self.crate_context.tcx.trait_impls.each_key |&trait_id| {\n+        self.crate_context.tcx.trait_impls.each_key(|&trait_id| {\n             self.check_implementation_coherence_of(trait_id);\n             true\n-        };\n+        });\n     }\n \n     pub fn check_implementation_coherence_of(&self, trait_def_id: DefId) {\n         // Unify pairs of polytypes.\n-        do self.iter_impls_of_trait(trait_def_id) |a| {\n+        self.iter_impls_of_trait(trait_def_id, |a| {\n             let implementation_a = a;\n             let polytype_a =\n                 self.get_self_type_for_implementation(implementation_a);\n \n             // \"We have an impl of trait <trait_def_id> for type <polytype_a>,\n             // and that impl is <implementation_a>\"\n-            do self.iter_impls_of_trait(trait_def_id) |b| {\n+            self.iter_impls_of_trait(trait_def_id, |b| {\n                 let implementation_b = b;\n \n                 // An impl is coherent with itself\n@@ -447,8 +447,8 @@ impl CoherenceChecker {\n                                           \"note conflicting implementation here\");\n                     }\n                 }\n-            }\n-        }\n+            })\n+        })\n     }\n \n     pub fn iter_impls_of_trait(&self, trait_def_id: DefId, f: |@Impl|) {\n@@ -665,12 +665,12 @@ impl CoherenceChecker {\n         let mut impls_seen = HashSet::new();\n \n         let crate_store = self.crate_context.tcx.sess.cstore;\n-        do iter_crate_data(crate_store) |crate_number, _crate_metadata| {\n-            do each_impl(crate_store, crate_number) |def_id| {\n+        iter_crate_data(crate_store, |crate_number, _crate_metadata| {\n+            each_impl(crate_store, crate_number, |def_id| {\n                 assert_eq!(crate_number, def_id.crate);\n                 self.add_external_impl(&mut impls_seen, def_id)\n-            }\n-        }\n+            })\n+        })\n     }\n \n     //"}, {"sha": "aa99c2b0f3751405406f95f41bd4bf8b20a19fe0", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=8ceb374ab783c6417b60867e7f34bebe997936ac", "patch": "@@ -264,20 +264,20 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt,\n \n         // Represents [A',B',C']\n         let num_trait_bounds = trait_ty_generics.type_param_defs.len();\n-        let non_shifted_trait_tps = do vec::from_fn(num_trait_bounds) |i| {\n+        let non_shifted_trait_tps = vec::from_fn(num_trait_bounds, |i| {\n             ty::mk_param(tcx, i, trait_ty_generics.type_param_defs[i].def_id)\n-        };\n+        });\n \n         // Represents [D']\n         let self_param = ty::mk_param(tcx, num_trait_bounds,\n                                       dummy_defid);\n \n         // Represents [E',F',G']\n         let num_method_bounds = m.generics.type_param_defs.len();\n-        let shifted_method_tps = do vec::from_fn(num_method_bounds) |i| {\n+        let shifted_method_tps = vec::from_fn(num_method_bounds, |i| {\n             ty::mk_param(tcx, i + num_trait_bounds + 1,\n                          m.generics.type_param_defs[i].def_id)\n-        };\n+        });\n \n         // Convert the regions 'a, 'b, 'c defined on the trait into\n         // bound regions on the fn."}, {"sha": "e825aca2eec65e60ee77c19e7bb5d95a91800fe0", "filename": "src/librustc/middle/typeck/infer/coercion.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs?ref=8ceb374ab783c6417b60867e7f34bebe997936ac", "patch": "@@ -98,45 +98,45 @@ impl Coerce {\n         // See above for details.\n         match ty::get(b).sty {\n             ty::ty_rptr(_, mt_b) => {\n-                return do self.unpack_actual_value(a) |sty_a| {\n+                return self.unpack_actual_value(a, |sty_a| {\n                     self.coerce_borrowed_pointer(a, sty_a, b, mt_b)\n-                };\n+                });\n             }\n \n             ty::ty_estr(vstore_slice(_)) => {\n-                return do self.unpack_actual_value(a) |sty_a| {\n+                return self.unpack_actual_value(a, |sty_a| {\n                     self.coerce_borrowed_string(a, sty_a, b)\n-                };\n+                });\n             }\n \n             ty::ty_evec(mt_b, vstore_slice(_)) => {\n-                return do self.unpack_actual_value(a) |sty_a| {\n+                return self.unpack_actual_value(a, |sty_a| {\n                     self.coerce_borrowed_vector(a, sty_a, b, mt_b)\n-                };\n+                });\n             }\n \n             ty::ty_closure(ty::ClosureTy {sigil: ast::BorrowedSigil, _}) => {\n-                return do self.unpack_actual_value(a) |sty_a| {\n+                return self.unpack_actual_value(a, |sty_a| {\n                     self.coerce_borrowed_fn(a, sty_a, b)\n-                };\n+                });\n             }\n \n             ty::ty_trait(_, _, ty::RegionTraitStore(*), m, _) => {\n-                return do self.unpack_actual_value(a) |sty_a| {\n+                return self.unpack_actual_value(a, |sty_a| {\n                     self.coerce_borrowed_object(a, sty_a, b, m)\n-                };\n+                });\n             }\n \n             ty::ty_ptr(mt_b) => {\n-                return do self.unpack_actual_value(a) |sty_a| {\n+                return self.unpack_actual_value(a, |sty_a| {\n                     self.coerce_unsafe_ptr(a, sty_a, b, mt_b)\n-                };\n+                });\n             }\n \n             _ => {}\n         }\n \n-        do self.unpack_actual_value(a) |sty_a| {\n+        self.unpack_actual_value(a, |sty_a| {\n             match *sty_a {\n                 ty::ty_bare_fn(ref a_f) => {\n                     // Bare functions are coercable to any closure type.\n@@ -151,7 +151,7 @@ impl Coerce {\n                     self.subtype(a, b)\n                 }\n             }\n-        }\n+        })\n     }\n \n     pub fn subtype(&self, a: ty::t, b: ty::t) -> CoerceResult {\n@@ -342,9 +342,9 @@ impl Coerce {\n                                fn_ty_a: &ty::BareFnTy,\n                                b: ty::t)\n                                -> CoerceResult {\n-        do self.unpack_actual_value(b) |sty_b| {\n+        self.unpack_actual_value(b, |sty_b| {\n             self.coerce_from_bare_fn_post_unpack(a, fn_ty_a, b, sty_b)\n-        }\n+        })\n     }\n \n     pub fn coerce_from_bare_fn_post_unpack(&self,"}, {"sha": "cdbd70ce3a7296f657b2d16a90a119840f75a3a9", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 34, "deletions": 52, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=8ceb374ab783c6417b60867e7f34bebe997936ac", "patch": "@@ -232,9 +232,7 @@ pub trait Combine {\n     }\n \n     fn args(&self, a: ty::t, b: ty::t) -> cres<ty::t> {\n-        do self.contratys(a, b).and_then |t| {\n-            Ok(t)\n-        }\n+        self.contratys(a, b).and_then(|t| Ok(t))\n     }\n \n     fn sigils(&self, p1: ast::Sigil, p2: ast::Sigil) -> cres<ast::Sigil> {\n@@ -270,9 +268,9 @@ pub trait Combine {\n \n         match (a, b) {\n             (ty::vstore_slice(a_r), ty::vstore_slice(b_r)) => {\n-                do self.contraregions(a_r, b_r).and_then |r| {\n+                self.contraregions(a_r, b_r).and_then(|r| {\n                     Ok(ty::vstore_slice(r))\n-                }\n+                })\n             }\n \n             _ if a == b => {\n@@ -294,9 +292,9 @@ pub trait Combine {\n \n         match (a, b) {\n             (ty::RegionTraitStore(a_r), ty::RegionTraitStore(b_r)) => {\n-                do self.contraregions(a_r, b_r).and_then |r| {\n+                self.contraregions(a_r, b_r).and_then(|r| {\n                     Ok(ty::RegionTraitStore(r))\n-                }\n+                })\n             }\n \n             _ if a == b => {\n@@ -346,11 +344,9 @@ pub fn expected_found<C:Combine,T>(\n \n pub fn eq_tys<C:Combine>(this: &C, a: ty::t, b: ty::t) -> ures {\n     let suber = this.sub();\n-    do this.infcx().try {\n-        do suber.tys(a, b).and_then |_ok| {\n-            suber.contratys(a, b)\n-        }.to_ures()\n-    }\n+    this.infcx().try(|| {\n+        suber.tys(a, b).and_then(|_ok| suber.contratys(a, b)).to_ures()\n+    })\n }\n \n pub fn eq_regions<C:Combine>(this: &C, a: ty::Region, b: ty::Region)\n@@ -359,11 +355,9 @@ pub fn eq_regions<C:Combine>(this: &C, a: ty::Region, b: ty::Region)\n             a.repr(this.infcx().tcx),\n             b.repr(this.infcx().tcx));\n     let sub = this.sub();\n-    do indent {\n+    indent(|| {\n         this.infcx().try(|| {\n-            do sub.regions(a, b).and_then |_r| {\n-                sub.contraregions(a, b)\n-            }\n+            sub.regions(a, b).and_then(|_r| sub.contraregions(a, b))\n         }).or_else(|e| {\n             // substitute a better error, but use the regions\n             // found in the original error\n@@ -373,7 +367,7 @@ pub fn eq_regions<C:Combine>(this: &C, a: ty::Region, b: ty::Region)\n               _ => Err(e)\n             }\n         }).to_ures()\n-    }\n+    })\n }\n \n pub fn eq_opt_regions<C:Combine>(\n@@ -382,25 +376,19 @@ pub fn eq_opt_regions<C:Combine>(\n     b: Option<ty::Region>) -> cres<Option<ty::Region>> {\n \n     match (a, b) {\n-      (None, None) => {\n-        Ok(None)\n-      }\n-      (Some(a), Some(b)) => {\n-        do eq_regions(this, a, b).then {\n-            Ok(Some(a))\n+        (None, None) => Ok(None),\n+        (Some(a), Some(b)) => eq_regions(this, a, b).then(|| Ok(Some(a))),\n+        (_, _) => {\n+            // If these two substitutions are for the same type (and\n+            // they should be), then the type should either\n+            // consistently have a region parameter or not have a\n+            // region parameter.\n+            this.infcx().tcx.sess.bug(\n+                format!(\"substitution a had opt_region {} and \\\n+                      b had opt_region {}\",\n+                     a.inf_str(this.infcx()),\n+                     b.inf_str(this.infcx())));\n         }\n-      }\n-      (_, _) => {\n-        // If these two substitutions are for the same type (and\n-        // they should be), then the type should either\n-        // consistently have a region parameter or not have a\n-        // region parameter.\n-        this.infcx().tcx.sess.bug(\n-            format!(\"substitution a had opt_region {} and \\\n-                  b had opt_region {}\",\n-                 a.inf_str(this.infcx()),\n-                 b.inf_str(this.infcx())));\n-      }\n     }\n }\n \n@@ -528,21 +516,15 @@ pub fn super_tys<C:Combine>(this: &C, a: ty::t, b: ty::t) -> cres<ty::t> {\n       }\n \n       (&ty::ty_box(ref a_mt), &ty::ty_box(ref b_mt)) => {\n-        do this.mts(a_mt, b_mt).and_then |mt| {\n-            Ok(ty::mk_box(tcx, mt))\n-        }\n+        this.mts(a_mt, b_mt).and_then(|mt| Ok(ty::mk_box(tcx, mt)))\n       }\n \n       (&ty::ty_uniq(ref a_mt), &ty::ty_uniq(ref b_mt)) => {\n-        do this.mts(a_mt, b_mt).and_then |mt| {\n-            Ok(ty::mk_uniq(tcx, mt))\n-        }\n+        this.mts(a_mt, b_mt).and_then(|mt| Ok(ty::mk_uniq(tcx, mt)))\n       }\n \n       (&ty::ty_ptr(ref a_mt), &ty::ty_ptr(ref b_mt)) => {\n-        do this.mts(a_mt, b_mt).and_then |mt| {\n-            Ok(ty::mk_ptr(tcx, mt))\n-        }\n+        this.mts(a_mt, b_mt).and_then(|mt| Ok(ty::mk_ptr(tcx, mt)))\n       }\n \n       (&ty::ty_rptr(a_r, ref a_mt), &ty::ty_rptr(b_r, ref b_mt)) => {\n@@ -552,11 +534,11 @@ pub fn super_tys<C:Combine>(this: &C, a: ty::t, b: ty::t) -> cres<ty::t> {\n       }\n \n       (&ty::ty_evec(ref a_mt, vs_a), &ty::ty_evec(ref b_mt, vs_b)) => {\n-        do this.mts(a_mt, b_mt).and_then |mt| {\n-            do this.vstores(ty::terr_vec, vs_a, vs_b).and_then |vs| {\n+        this.mts(a_mt, b_mt).and_then(|mt| {\n+            this.vstores(ty::terr_vec, vs_a, vs_b).and_then(|vs| {\n                 Ok(ty::mk_evec(tcx, mt, vs))\n-            }\n-        }\n+            })\n+        })\n       }\n \n       (&ty::ty_estr(vs_a), &ty::ty_estr(vs_b)) => {\n@@ -576,15 +558,15 @@ pub fn super_tys<C:Combine>(this: &C, a: ty::t, b: ty::t) -> cres<ty::t> {\n       }\n \n       (&ty::ty_bare_fn(ref a_fty), &ty::ty_bare_fn(ref b_fty)) => {\n-        do this.bare_fn_tys(a_fty, b_fty).and_then |fty| {\n+        this.bare_fn_tys(a_fty, b_fty).and_then(|fty| {\n             Ok(ty::mk_bare_fn(tcx, fty))\n-        }\n+        })\n       }\n \n       (&ty::ty_closure(ref a_fty), &ty::ty_closure(ref b_fty)) => {\n-        do this.closure_tys(a_fty, b_fty).and_then |fty| {\n+        this.closure_tys(a_fty, b_fty).and_then(|fty| {\n             Ok(ty::mk_closure(tcx, fty))\n-        }\n+        })\n       }\n \n       _ => Err(ty::terr_sorts(expected_found(this, a, b)))"}, {"sha": "8f344095aea8c1b593085be794db7005649df2de", "filename": "src/librustc/middle/typeck/infer/lattice.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs?ref=8ceb374ab783c6417b60867e7f34bebe997936ac", "patch": "@@ -230,9 +230,7 @@ impl CombineFieldsLatticeMethods for CombineFields {\n             (&Some(_),       &None) => Ok((*a).clone()),\n             (&None,          &Some(_)) => Ok((*b).clone()),\n             (&Some(ref v_a), &Some(ref v_b)) => {\n-                do lattice_op(self, v_a, v_b).and_then |v| {\n-                    Ok(Some(v))\n-                }\n+                lattice_op(self, v_a, v_b).and_then(|v| Ok(Some(v)))\n             }\n         }\n     }\n@@ -471,9 +469,9 @@ pub fn lattice_vars<L:LatticeDir + Combine,\n     // Otherwise, we need to merge A and B into one variable.  We can\n     // then use either variable as an upper bound:\n     let cf = this.combine_fields();\n-    do cf.var_sub_var(a_vid.clone(), b_vid.clone()).then {\n+    cf.var_sub_var(a_vid.clone(), b_vid.clone()).then(|| {\n         Ok(VarResult(a_vid.clone()))\n-    }\n+    })\n }\n \n pub fn lattice_var_and_t<L:LatticeDir + Combine,\n@@ -508,11 +506,11 @@ pub fn lattice_var_and_t<L:LatticeDir + Combine,\n             // and then return b.\n             debug!(\"bnd=None\");\n             let a_bounds = this.with_bnd(a_bounds, (*b).clone());\n-            do this.combine_fields().bnds(&a_bounds.lb, &a_bounds.ub).then {\n+            this.combine_fields().bnds(&a_bounds.lb, &a_bounds.ub).then(|| {\n                 this.infcx().set(a_id.clone(),\n                                  Root(a_bounds.clone(), nde_a.rank));\n                 Ok((*b).clone())\n-            }\n+            })\n         }\n     }\n }"}, {"sha": "edac978041b677e75e446375245f7af130131dce", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 35, "deletions": 38, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=8ceb374ab783c6417b60867e7f34bebe997936ac", "patch": "@@ -290,10 +290,7 @@ pub fn common_supertype(cx: @mut InferCtxt,\n         values: Types(expected_found(a_is_expected, a, b))\n     };\n \n-    let result = do cx.commit {\n-        cx.lub(a_is_expected, trace).tys(a, b)\n-    };\n-\n+    let result = cx.commit(|| cx.lub(a_is_expected, trace).tys(a, b));\n     match result {\n         Ok(t) => t,\n         Err(ref err) => {\n@@ -310,28 +307,28 @@ pub fn mk_subty(cx: @mut InferCtxt,\n                 b: ty::t)\n              -> ures {\n     debug!(\"mk_subty({} <: {})\", a.inf_str(cx), b.inf_str(cx));\n-    do indent {\n-        do cx.commit {\n+    indent(|| {\n+        cx.commit(|| {\n             let trace = TypeTrace {\n                 origin: origin,\n                 values: Types(expected_found(a_is_expected, a, b))\n             };\n             cx.sub(a_is_expected, trace).tys(a, b)\n-        }\n-    }.to_ures()\n+        })\n+    }).to_ures()\n }\n \n pub fn can_mk_subty(cx: @mut InferCtxt, a: ty::t, b: ty::t) -> ures {\n     debug!(\"can_mk_subty({} <: {})\", a.inf_str(cx), b.inf_str(cx));\n-    do indent {\n-        do cx.probe {\n+    indent(|| {\n+        cx.probe(|| {\n             let trace = TypeTrace {\n                 origin: Misc(codemap::dummy_sp()),\n                 values: Types(expected_found(true, a, b))\n             };\n             cx.sub(true, trace).tys(a, b)\n-        }\n-    }.to_ures()\n+        })\n+    }).to_ures()\n }\n \n pub fn mk_subr(cx: @mut InferCtxt,\n@@ -352,16 +349,16 @@ pub fn mk_eqty(cx: @mut InferCtxt,\n                b: ty::t)\n             -> ures {\n     debug!(\"mk_eqty({} <: {})\", a.inf_str(cx), b.inf_str(cx));\n-    do indent {\n-        do cx.commit {\n+    indent(|| {\n+        cx.commit(|| {\n             let trace = TypeTrace {\n                 origin: origin,\n                 values: Types(expected_found(a_is_expected, a, b))\n             };\n             let suber = cx.sub(a_is_expected, trace);\n             eq_tys(&suber, a, b)\n-        }\n-    }.to_ures()\n+        })\n+    }).to_ures()\n }\n \n pub fn mk_sub_trait_refs(cx: @mut InferCtxt,\n@@ -373,16 +370,16 @@ pub fn mk_sub_trait_refs(cx: @mut InferCtxt,\n {\n     debug!(\"mk_sub_trait_refs({} <: {})\",\n            a.inf_str(cx), b.inf_str(cx));\n-    do indent {\n-        do cx.commit {\n+    indent(|| {\n+        cx.commit(|| {\n             let trace = TypeTrace {\n                 origin: origin,\n                 values: TraitRefs(expected_found(a_is_expected, a, b))\n             };\n             let suber = cx.sub(a_is_expected, trace);\n             suber.trait_refs(a, b)\n-        }\n-    }.to_ures()\n+        })\n+    }).to_ures()\n }\n \n fn expected_found<T>(a_is_expected: bool,\n@@ -402,28 +399,28 @@ pub fn mk_coercety(cx: @mut InferCtxt,\n                    b: ty::t)\n                 -> CoerceResult {\n     debug!(\"mk_coercety({} -> {})\", a.inf_str(cx), b.inf_str(cx));\n-    do indent {\n-        do cx.commit {\n+    indent(|| {\n+        cx.commit(|| {\n             let trace = TypeTrace {\n                 origin: origin,\n                 values: Types(expected_found(a_is_expected, a, b))\n             };\n             Coerce(cx.combine_fields(a_is_expected, trace)).tys(a, b)\n-        }\n-    }\n+        })\n+    })\n }\n \n pub fn can_mk_coercety(cx: @mut InferCtxt, a: ty::t, b: ty::t) -> ures {\n     debug!(\"can_mk_coercety({} -> {})\", a.inf_str(cx), b.inf_str(cx));\n-    do indent {\n-        do cx.probe {\n+    indent(|| {\n+        cx.probe(|| {\n             let trace = TypeTrace {\n                 origin: Misc(codemap::dummy_sp()),\n                 values: Types(expected_found(true, a, b))\n             };\n             Coerce(cx.combine_fields(true, trace)).tys(a, b)\n-        }\n-    }.to_ures()\n+        })\n+    }).to_ures()\n }\n \n // See comment on the type `resolve_state` below\n@@ -472,13 +469,13 @@ trait CresCompare<T> {\n \n impl<T:Clone + Eq> CresCompare<T> for cres<T> {\n     fn compare(&self, t: T, f: || -> ty::type_err) -> cres<T> {\n-        do (*self).clone().and_then |s| {\n+        (*self).clone().and_then(|s| {\n             if s == t {\n                 (*self).clone()\n             } else {\n                 Err(f())\n             }\n-        }\n+        })\n     }\n }\n \n@@ -553,14 +550,14 @@ impl InferCtxt {\n         assert!(!self.in_snapshot());\n \n         debug!(\"commit()\");\n-        do indent {\n+        indent(|| {\n             let r = self.try(|| f());\n \n             self.ty_var_bindings.bindings.truncate(0);\n             self.int_var_bindings.bindings.truncate(0);\n             self.region_vars.commit();\n             r\n-        }\n+        })\n     }\n \n     /// Execute `f`, unroll bindings on failure\n@@ -581,12 +578,12 @@ impl InferCtxt {\n     /// Execute `f` then unroll any bindings it creates\n     pub fn probe<T,E>(@mut self, f: || -> Result<T,E>) -> Result<T,E> {\n         debug!(\"probe()\");\n-        do indent {\n+        indent(|| {\n             let snapshot = self.start_snapshot();\n             let r = f();\n             self.rollback_to(&snapshot);\n             r\n-        }\n+        })\n     }\n }\n \n@@ -737,12 +734,12 @@ impl InferCtxt {\n                                                 err: Option<&ty::type_err>) {\n         debug!(\"hi! expected_ty = {:?}, actual_ty = {}\", expected_ty, actual_ty);\n \n-        let error_str = do err.map_default(~\"\") |t_err| {\n+        let error_str = err.map_default(~\"\", |t_err| {\n             format!(\" ({})\", ty::type_err_to_str(self.tcx, t_err))\n-        };\n-        let resolved_expected = do expected_ty.map |e_ty| {\n+        });\n+        let resolved_expected = expected_ty.map(|e_ty| {\n             self.resolve_type_vars_if_possible(e_ty)\n-        };\n+        });\n         if !resolved_expected.map_default(false, |e| { ty::type_is_error(e) }) {\n             match resolved_expected {\n                 None => self.tcx.sess.span_err(sp,"}, {"sha": "f639139d265e4c835791c6e4059885f85974e3bb", "filename": "src/librustc/middle/typeck/infer/region_inference/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs?ref=8ceb374ab783c6417b60867e7f34bebe997936ac", "patch": "@@ -764,7 +764,7 @@ impl RegionVarBindings {\n     }\n \n     fn expansion(&self, var_data: &mut [VarData]) {\n-        do self.iterate_until_fixed_point(\"Expansion\") |constraint| {\n+        self.iterate_until_fixed_point(\"Expansion\", |constraint| {\n             match *constraint {\n               ConstrainRegSubVar(a_region, b_vid) => {\n                 let b_data = &mut var_data[b_vid.to_uint()];\n@@ -788,7 +788,7 @@ impl RegionVarBindings {\n                 false\n               }\n             }\n-        }\n+        })\n     }\n \n     fn expand_node(&self,\n@@ -829,7 +829,7 @@ impl RegionVarBindings {\n \n     fn contraction(&self,\n                    var_data: &mut [VarData]) {\n-        do self.iterate_until_fixed_point(\"Contraction\") |constraint| {\n+        self.iterate_until_fixed_point(\"Contraction\", |constraint| {\n             match *constraint {\n               ConstrainRegSubVar(*) => {\n                 // This is an expansion constraint.  Ignore.\n@@ -853,7 +853,7 @@ impl RegionVarBindings {\n                 false\n               }\n             }\n-        }\n+        })\n     }\n \n     fn contract_node(&self,\n@@ -1225,7 +1225,7 @@ impl RegionVarBindings {\n             debug!(\"process_edges(source_vid={:?}, dir={:?})\", source_vid, dir);\n \n             let source_node_index = NodeIndex(source_vid.to_uint());\n-            do graph.each_adjacent_edge(source_node_index, dir) |_, edge| {\n+            graph.each_adjacent_edge(source_node_index, dir, |_, edge| {\n                 match edge.data {\n                     ConstrainVarSubVar(from_vid, to_vid) => {\n                         let opp_vid =\n@@ -1246,7 +1246,7 @@ impl RegionVarBindings {\n                     ConstrainRegSubReg(*) => {}\n                 }\n                 true\n-            };\n+            });\n         }\n     }\n "}, {"sha": "210d7fd7c80b144a28dac97d6c5df2b585d3e913", "filename": "src/librustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=8ceb374ab783c6417b60867e7f34bebe997936ac", "patch": "@@ -167,13 +167,13 @@ impl Combine for Sub {\n         // Second, we instantiate each bound region in the supertype with a\n         // fresh concrete region.\n         let (skol_map, _, b_sig) = {\n-            do replace_bound_regions_in_fn_sig(self.infcx.tcx, None, b) |br| {\n+            replace_bound_regions_in_fn_sig(self.infcx.tcx, None, b, |br| {\n                 let skol = self.infcx.region_vars.new_skolemized(br);\n                 debug!(\"Bound region {} skolemized to {:?}\",\n                        bound_region_to_str(self.infcx.tcx, \"\", false, br),\n                        skol);\n                 skol\n-            }\n+            })\n         };\n \n         debug!(\"a_sig={}\", a_sig.inf_str(self.infcx));"}, {"sha": "6afbcf053b8cdc122fa5db2829037e5a40f8970b", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=8ceb374ab783c6417b60867e7f34bebe997936ac", "patch": "@@ -330,10 +330,10 @@ impl get_and_find_region for isr_alist {\n \n     fn find(&self, br: ty::BoundRegion) -> Option<ty::Region> {\n         let mut ret = None;\n-        do list::each(*self) |isr| {\n+        list::each(*self, |isr| {\n             let (isr_br, isr_r) = *isr;\n             if isr_br == br { ret = Some(isr_r); false } else { true }\n-        };\n+        });\n         ret\n     }\n }"}, {"sha": "11c2aca6c343fc7d8503c3a71c144c31a39089f5", "filename": "src/librustdoc/clean.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustdoc%2Fclean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustdoc%2Fclean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean.rs?ref=8ceb374ab783c6417b60867e7f34bebe997936ac", "patch": "@@ -79,9 +79,9 @@ impl Clean<Crate> for visit_ast::RustdocVisitor {\n         let cx = local_data::get(super::ctxtkey, |x| *x.unwrap());\n \n         let mut externs = HashMap::new();\n-        do cstore::iter_crate_data(cx.sess.cstore) |n, meta| {\n+        cstore::iter_crate_data(cx.sess.cstore, |n, meta| {\n             externs.insert(n, meta.clean());\n-        }\n+        });\n \n         Crate {\n             name: match maybe_meta {"}, {"sha": "0f490fd960e37842aba4cd14532a7af39efb541c", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=8ceb374ab783c6417b60867e7f34bebe997936ac", "patch": "@@ -170,11 +170,11 @@ fn path(w: &mut io::Writer, path: &clean::Path, print_all: bool,\n     }\n \n     // Did someone say rightward-drift?\n-    do local_data::get(current_location_key) |loc| {\n+    local_data::get(current_location_key, |loc| {\n         let loc = loc.unwrap();\n \n-        do local_data::get(cache_key) |cache| {\n-            do cache.unwrap().read |cache| {\n+        local_data::get(cache_key, |cache| {\n+            cache.unwrap().read(|cache| {\n                 let abs_root = root(cache, loc.as_slice());\n                 let rel_root = match path.segments[0].name.as_slice() {\n                     \"self\" => Some(~\"./\"),\n@@ -238,9 +238,9 @@ fn path(w: &mut io::Writer, path: &clean::Path, print_all: bool,\n                     }\n                 }\n                 write!(w, \"{}\", generics);\n-            }\n-        }\n-    }\n+            })\n+        })\n+    })\n }\n \n /// Helper to render type parameters\n@@ -262,11 +262,11 @@ impl fmt::Default for clean::Type {\n     fn fmt(g: &clean::Type, f: &mut fmt::Formatter) {\n         match *g {\n             clean::TyParamBinder(id) | clean::Generic(id) => {\n-                do local_data::get(cache_key) |cache| {\n-                    do cache.unwrap().read |m| {\n+                local_data::get(cache_key, |cache| {\n+                    cache.unwrap().read(|m| {\n                         f.buf.write(m.typarams.get(&id).as_bytes());\n-                    }\n-                }\n+                    })\n+                })\n             }\n             clean::ResolvedPath{id, typarams: ref tp, path: ref path} => {\n                 resolved_path(f.buf, id, path, false);"}, {"sha": "ac7c50fdfd809673571474ea653919dbcec324a2", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=8ceb374ab783c6417b60867e7f34bebe997936ac", "patch": "@@ -109,14 +109,14 @@ fn render(w: &mut io::Writer, s: &str) {\n         let markdown = sd_markdown_new(extensions, 16, &callbacks,\n                                        &options as *html_renderopt as *libc::c_void);\n \n-        do s.as_imm_buf |data, len| {\n+        s.as_imm_buf(|data, len| {\n             sd_markdown_render(ob, data, len as libc::size_t, markdown);\n-        }\n+        });\n         sd_markdown_free(markdown);\n \n-        do vec::raw::buf_as_slice((*ob).data, (*ob).size as uint) |buf| {\n+        vec::raw::buf_as_slice((*ob).data, (*ob).size as uint, |buf| {\n             w.write(buf);\n-        }\n+        });\n \n         bufrelease(ob);\n     }"}, {"sha": "819316313b6778b3d82f510ff183f77652e4cccf", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 35, "deletions": 37, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=8ceb374ab783c6417b60867e7f34bebe997936ac", "patch": "@@ -320,15 +320,15 @@ fn write(dst: Path, contents: &str) {\n /// Makes a directory on the filesystem, failing the task if an error occurs and\n /// skipping if the directory already exists.\n fn mkdir(path: &Path) {\n-    do io::io_error::cond.trap(|err| {\n+    io::io_error::cond.trap(|err| {\n         error!(\"Couldn't create directory `{}`: {}\",\n                 path.display(), err.desc);\n         fail!()\n-    }).inside {\n+    }).inside(|| {\n         if !path.is_dir() {\n             fs::mkdir(path, io::UserRWX);\n         }\n-    }\n+    })\n }\n \n /// Takes a path to a source file and cleans the path to it. This canonicalizes\n@@ -439,11 +439,11 @@ impl<'self> SourceCollector<'self> {\n         // Create the intermediate directories\n         let mut cur = self.dst.clone();\n         let mut root_path = ~\"../../\";\n-        do clean_srcpath(p.dirname()) |component| {\n+        clean_srcpath(p.dirname(), |component| {\n             cur.push(component);\n             mkdir(&cur);\n             root_path.push_str(\"../\");\n-        }\n+        });\n \n         cur.push(p.filename().expect(\"source has no filename\") + bytes!(\".html\"));\n         let mut w = BufferedWriter::new(File::create(&cur).unwrap());\n@@ -492,9 +492,9 @@ impl DocFolder for Cache {\n             clean::ImplItem(ref i) => {\n                 match i.trait_ {\n                     Some(clean::ResolvedPath{ id, _ }) => {\n-                        let v = do self.implementors.find_or_insert_with(id) |_|{\n+                        let v = self.implementors.find_or_insert_with(id, |_|{\n                             ~[]\n-                        };\n+                        });\n                         match i.for_ {\n                             clean::ResolvedPath{_} => {\n                                 v.unshift(PathType(i.for_.clone()));\n@@ -595,9 +595,9 @@ impl DocFolder for Cache {\n                     clean::Item{ attrs, inner: clean::ImplItem(i), _ } => {\n                         match i.for_ {\n                             clean::ResolvedPath { id, _ } => {\n-                                let v = do self.impls.find_or_insert_with(id) |_| {\n+                                let v = self.impls.find_or_insert_with(id, |_| {\n                                     ~[]\n-                                };\n+                                });\n                                 // extract relevant documentation for this impl\n                                 match attrs.move_iter().find(|a| {\n                                     match *a {\n@@ -726,16 +726,16 @@ impl Context {\n                         Process(cx, item) => {\n                             let mut cx = cx;\n                             let item = Cell::new(item);\n-                            do (|| {\n-                                do cx.item(item.take()) |cx, item| {\n+                            (|| {\n+                                cx.item(item.take(), |cx, item| {\n                                     prog_chan.send(JobNew);\n                                     chan.send(Process(cx.clone(), item));\n-                                }\n-                            }).finally {\n+                                })\n+                            }).finally(|| {\n                                 // If we fail, everything else should still get\n                                 // completed\n                                 prog_chan.send(JobDone);\n-                            }\n+                            })\n                         }\n                         Die => break,\n                     }\n@@ -803,7 +803,7 @@ impl Context {\n             clean::ModuleItem(*) => {\n                 let name = item.name.get_ref().to_owned();\n                 let item = Cell::new(item);\n-                do self.recurse(name) |this| {\n+                self.recurse(name, |this| {\n                     let item = item.take();\n                     let dst = this.dst.join(\"index.html\");\n                     render(File::create(&dst).unwrap(), this, &item, false);\n@@ -816,7 +816,7 @@ impl Context {\n                     for item in m.items.move_iter() {\n                         f(this, item);\n                     }\n-                }\n+                })\n             }\n \n             // Things which don't have names (like impls) don't get special\n@@ -875,9 +875,9 @@ impl<'self> fmt::Default for Item<'self> {\n \n         if it.cx.include_sources {\n             let mut path = ~[];\n-            do clean_srcpath(it.item.source.filename.as_bytes()) |component| {\n+            clean_srcpath(it.item.source.filename.as_bytes(), |component| {\n                 path.push(component.to_owned());\n-            }\n+            });\n             let href = if it.item.source.loline == it.item.source.hiline {\n                 format!(\"{}\", it.item.source.loline)\n             } else {\n@@ -1012,9 +1012,7 @@ fn item_module(w: &mut Writer, cx: &Context,\n     }\n \n     debug!(\"{:?}\", indices);\n-    do sort::quick_sort(indices) |&i1, &i2| {\n-        lt(&items[i1], &items[i2], i1, i2)\n-    }\n+    sort::quick_sort(indices, |&i1, &i2| lt(&items[i1], &items[i2], i1, i2));\n \n     debug!(\"{:?}\", indices);\n     let mut curty = \"\";\n@@ -1200,8 +1198,8 @@ fn item_trait(w: &mut Writer, it: &clean::Item, t: &clean::Trait) {\n         write!(w, \"</div>\");\n     }\n \n-    do local_data::get(cache_key) |cache| {\n-        do cache.unwrap().read |cache| {\n+    local_data::get(cache_key, |cache| {\n+        cache.unwrap().read(|cache| {\n             match cache.implementors.find(&it.id) {\n                 Some(implementors) => {\n                     write!(w, \"\n@@ -1223,8 +1221,8 @@ fn item_trait(w: &mut Writer, it: &clean::Item, t: &clean::Trait) {\n                 }\n                 None => {}\n             }\n-        }\n-    }\n+        })\n+    })\n }\n \n fn render_method(w: &mut Writer, meth: &clean::Item, withlink: bool) {\n@@ -1412,9 +1410,9 @@ fn render_struct(w: &mut Writer, it: &clean::Item,\n }\n \n fn render_methods(w: &mut Writer, it: &clean::Item) {\n-    do local_data::get(cache_key) |cache| {\n+    local_data::get(cache_key, |cache| {\n         let cache = cache.unwrap();\n-        do cache.read |c| {\n+        cache.read(|c| {\n             match c.impls.find(&it.id) {\n                 Some(v) => {\n                     let mut non_trait = v.iter().filter(|p| {\n@@ -1442,8 +1440,8 @@ fn render_methods(w: &mut Writer, it: &clean::Item) {\n                 }\n                 None => {}\n             }\n-        }\n-    }\n+        })\n+    })\n }\n \n fn render_impl(w: &mut Writer, i: &clean::Impl, dox: &Option<~str>) {\n@@ -1492,8 +1490,8 @@ fn render_impl(w: &mut Writer, i: &clean::Impl, dox: &Option<~str>) {\n             None => continue,\n             Some(id) => id,\n         };\n-        do local_data::get(cache_key) |cache| {\n-            do cache.unwrap().read |cache| {\n+        local_data::get(cache_key, |cache| {\n+            cache.unwrap().read(|cache| {\n                 match cache.traits.find(&trait_id) {\n                     Some(t) => {\n                         let name = meth.name.clone();\n@@ -1513,17 +1511,17 @@ fn render_impl(w: &mut Writer, i: &clean::Impl, dox: &Option<~str>) {\n                     }\n                     None => {}\n                 }\n-            }\n-        }\n+            })\n+        })\n     }\n \n     // If we've implemented a trait, then also emit documentation for all\n     // default methods which weren't overridden in the implementation block.\n     match trait_id {\n         None => {}\n         Some(id) => {\n-            do local_data::get(cache_key) |cache| {\n-                do cache.unwrap().read |cache| {\n+            local_data::get(cache_key, |cache| {\n+                cache.unwrap().read(|cache| {\n                     match cache.traits.find(&id) {\n                         Some(t) => {\n                             for method in t.methods.iter() {\n@@ -1538,8 +1536,8 @@ fn render_impl(w: &mut Writer, i: &clean::Impl, dox: &Option<~str>) {\n                         }\n                         None => {}\n                     }\n-                }\n-            }\n+                })\n+            })\n         }\n     }\n     write!(w, \"</div>\");"}, {"sha": "f7705f93a79eeb598bc9f6ba9574f403af46e66c", "filename": "src/librustdoc/passes.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustdoc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustdoc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses.rs?ref=8ceb374ab783c6417b60867e7f34bebe997936ac", "patch": "@@ -57,9 +57,9 @@ pub fn strip_private(crate: clean::Crate) -> plugins::PluginResult {\n     // This stripper collects all *retained* nodes.\n     let mut retained = HashSet::new();\n     let crate = Cell::new(crate);\n-    let exported_items = do local_data::get(super::analysiskey) |analysis| {\n+    let exported_items = local_data::get(super::analysiskey, |analysis| {\n         analysis.unwrap().exported_items.clone()\n-    };\n+    });\n     let mut crate = crate.take();\n \n     // strip all private items\n@@ -231,7 +231,7 @@ pub fn unindent(s: &str) -> ~str {\n     let lines = s.lines_any().collect::<~[&str]>();\n     let mut saw_first_line = false;\n     let mut saw_second_line = false;\n-    let min_indent = do lines.iter().fold(uint::max_value) |min_indent, line| {\n+    let min_indent = lines.iter().fold(uint::max_value, |min_indent, line| {\n \n         // After we see the first non-whitespace line, look at\n         // the line we have. If it is not whitespace, and therefore\n@@ -257,7 +257,7 @@ pub fn unindent(s: &str) -> ~str {\n         } else {\n             saw_first_line = true;\n             let mut spaces = 0;\n-            do line.chars().all |char| {\n+            line.chars().all(|char| {\n                 // Only comparing against space because I wouldn't\n                 // know what to do with mixed whitespace chars\n                 if char == ' ' {\n@@ -266,22 +266,22 @@ pub fn unindent(s: &str) -> ~str {\n                 } else {\n                     false\n                 }\n-            };\n+            });\n             num::min(min_indent, spaces)\n         }\n-    };\n+    });\n \n     match lines {\n         [head, .. tail] => {\n             let mut unindented = ~[ head.trim() ];\n-            unindented.push_all(do tail.map |&line| {\n+            unindented.push_all(tail.map(|&line| {\n                 if line.is_whitespace() {\n                     line\n                 } else {\n                     assert!(line.len() >= min_indent);\n                     line.slice_from(min_indent)\n                 }\n-            });\n+            }));\n             unindented.connect(\"\\n\")\n         }\n         [] => s.to_owned()"}, {"sha": "b1e3d1bd879ec02661d1d21050409274b0d5c362", "filename": "src/librustpkg/installed_packages.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustpkg%2Finstalled_packages.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustpkg%2Finstalled_packages.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Finstalled_packages.rs?ref=8ceb374ab783c6417b60867e7f34bebe997936ac", "patch": "@@ -19,7 +19,7 @@ use std::io::fs;\n pub fn list_installed_packages(f: |&PkgId| -> bool) -> bool  {\n     let workspaces = rust_path();\n     for p in workspaces.iter() {\n-        let binfiles = do io::ignore_io_error { fs::readdir(&p.join(\"bin\")) };\n+        let binfiles = io::ignore_io_error(|| fs::readdir(&p.join(\"bin\")));\n         for exec in binfiles.iter() {\n             // FIXME (#9639): This needs to handle non-utf8 paths\n             match exec.filestem_str() {\n@@ -31,7 +31,7 @@ pub fn list_installed_packages(f: |&PkgId| -> bool) -> bool  {\n                 }\n             }\n         }\n-        let libfiles = do io::ignore_io_error { fs::readdir(&p.join(\"lib\")) };\n+        let libfiles = io::ignore_io_error(|| fs::readdir(&p.join(\"lib\")));\n         for lib in libfiles.iter() {\n             debug!(\"Full name: {}\", lib.display());\n             match has_library(lib) {\n@@ -42,10 +42,10 @@ pub fn list_installed_packages(f: |&PkgId| -> bool) -> bool  {\n                     let rel_p = lib.path_relative_from(&parent).unwrap();\n                     debug!(\"Rel: {}\", rel_p.display());\n                     let rel_path = rel_p.join(basename);\n-                    do rel_path.display().with_str |s| {\n+                    rel_path.display().with_str(|s| {\n                         debug!(\"Rel name: {}\", s);\n                         f(&PkgId::new(s));\n-                    }\n+                    });\n                 }\n                 None => ()\n             }\n@@ -55,7 +55,7 @@ pub fn list_installed_packages(f: |&PkgId| -> bool) -> bool  {\n }\n \n pub fn has_library(p: &Path) -> Option<~str> {\n-    let files = do io::ignore_io_error { fs::readdir(p) };\n+    let files = io::ignore_io_error(|| fs::readdir(p));\n     for path in files.iter() {\n         if path.extension_str() == Some(os::consts::DLL_EXTENSION) {\n             let stuff : &str = path.filestem_str().expect(\"has_library: weird path\");\n@@ -71,13 +71,13 @@ pub fn has_library(p: &Path) -> Option<~str> {\n \n pub fn package_is_installed(p: &PkgId) -> bool {\n     let mut is_installed = false;\n-    do list_installed_packages() |installed| {\n+    list_installed_packages(|installed| {\n         if installed == p {\n             is_installed = true;\n             false\n         } else {\n             true\n         }\n-    };\n+    });\n     is_installed\n }"}, {"sha": "f40238364f3f5f8ee67b9a9c57b17b426992064e", "filename": "src/librustpkg/lib.rs", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustpkg%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustpkg%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Flib.rs?ref=8ceb374ab783c6417b60867e7f34bebe997936ac", "patch": "@@ -255,7 +255,7 @@ impl CtxMethods for BuildContext {\n             // argument\n             let pkgid = PkgId::new(args[0].clone());\n             let mut dest_ws = default_workspace();\n-            do each_pkg_parent_workspace(&self.context, &pkgid) |workspace| {\n+            each_pkg_parent_workspace(&self.context, &pkgid, |workspace| {\n                 debug!(\"found pkg {} in workspace {}, trying to build\",\n                        pkgid.to_str(), workspace.display());\n                 dest_ws = determine_destination(os::getcwd(),\n@@ -265,7 +265,7 @@ impl CtxMethods for BuildContext {\n                                               false, pkgid.clone());\n                 self.build(&mut pkg_src, what);\n                 true\n-            };\n+            });\n             // n.b. If this builds multiple packages, it only returns the workspace for\n             // the last one. The whole building-multiple-packages-with-the-same-ID is weird\n             // anyway and there are no tests for it, so maybe take it out\n@@ -353,12 +353,10 @@ impl CtxMethods for BuildContext {\n             }\n             \"list\" => {\n                 println(\"Installed packages:\");\n-                do installed_packages::list_installed_packages |pkg_id| {\n-                    do pkg_id.path.display().with_str |s| {\n-                        println(s);\n-                    }\n+                installed_packages::list_installed_packages(|pkg_id| {\n+                    pkg_id.path.display().with_str(|s| println(s));\n                     true\n-                };\n+                });\n             }\n             \"prefer\" => {\n                 if args.len() < 1 {\n@@ -402,12 +400,12 @@ impl CtxMethods for BuildContext {\n                 else {\n                     let rp = rust_path();\n                     assert!(!rp.is_empty());\n-                    do each_pkg_parent_workspace(&self.context, &pkgid) |workspace| {\n+                    each_pkg_parent_workspace(&self.context, &pkgid, |workspace| {\n                         path_util::uninstall_package_from(workspace, &pkgid);\n                         note(format!(\"Uninstalled package {} (was installed in {})\",\n                                   pkgid.to_str(), workspace.display()));\n                         true\n-                    };\n+                    });\n                 }\n             }\n             \"unprefer\" => {\n@@ -471,19 +469,19 @@ impl CtxMethods for BuildContext {\n                 // Build the package script if needed\n                 let script_build = format!(\"build_package_script({})\",\n                                            package_script_path.display());\n-                let pkg_exe = do self.workcache_context.with_prep(script_build) |prep| {\n+                let pkg_exe = self.workcache_context.with_prep(script_build, |prep| {\n                     let subsysroot = sysroot.clone();\n                     let psp = package_script_path.clone();\n                     let ws = workspace.clone();\n                     let pid = pkgid.clone();\n-                    do prep.exec |exec| {\n+                    prep.exec(|exec| {\n                         let mut pscript = PkgScript::parse(subsysroot.clone(),\n                                                            psp.clone(),\n                                                            &ws,\n                                                            &pid);\n                         pscript.build_custom(exec)\n-                    }\n-                };\n+                    })\n+                });\n                 // We always *run* the package script\n                 let (cfgs, hook_result) = PkgScript::run_custom(&Path::new(pkg_exe), &sysroot);\n                 debug!(\"Command return code = {:?}\", hook_result);\n@@ -620,7 +618,7 @@ impl CtxMethods for BuildContext {\n                target_exec.display(), target_lib,\n                maybe_executable, maybe_library);\n \n-        do self.workcache_context.with_prep(id.install_tag()) |prep| {\n+        self.workcache_context.with_prep(id.install_tag(), |prep| {\n             for ee in maybe_executable.iter() {\n                 // FIXME (#9639): This needs to handle non-utf8 paths\n                 prep.declare_input(\"binary\",\n@@ -638,7 +636,7 @@ impl CtxMethods for BuildContext {\n             let sub_target_ex = target_exec.clone();\n             let sub_target_lib = target_lib.clone();\n             let sub_build_inputs = build_inputs.to_owned();\n-            do prep.exec |exe_thing| {\n+            prep.exec(|exe_thing| {\n                 let mut outputs = ~[];\n                 // Declare all the *inputs* to the declared input too, as inputs\n                 for executable in subex.iter() {\n@@ -684,8 +682,8 @@ impl CtxMethods for BuildContext {\n                     outputs.push(target_lib.as_str().unwrap().to_owned());\n                 }\n                 outputs\n-            }\n-        }\n+            })\n+        })\n     }\n \n     fn prefer(&self, _id: &str, _vers: Option<~str>)  {"}, {"sha": "04ac30e3732876930c05bf9f855dcc03081babd8", "filename": "src/librustpkg/package_id.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustpkg%2Fpackage_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustpkg%2Fpackage_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpackage_id.rs?ref=8ceb374ab783c6417b60867e7f34bebe997936ac", "patch": "@@ -87,10 +87,10 @@ impl PkgId {\n \n     pub fn hash(&self) -> ~str {\n         // FIXME (#9639): hash should take a &[u8] so we can hash the real path\n-        do self.path.display().with_str |s| {\n+        self.path.display().with_str(|s| {\n             let vers = self.version.to_str();\n             format!(\"{}-{}-{}\", s, hash(s + vers), vers)\n-        }\n+        })\n     }\n \n     pub fn short_name_with_version(&self) -> ~str {"}, {"sha": "9d0812efe28d0466efdbb2b706f6b925441f1555", "filename": "src/librustpkg/package_source.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustpkg%2Fpackage_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustpkg%2Fpackage_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpackage_source.rs?ref=8ceb374ab783c6417b60867e7f34bebe997936ac", "patch": "@@ -291,11 +291,9 @@ impl PkgSrc {\n \n                 let mut failed = false;\n \n-                do cond.trap(|_| {\n+                cond.trap(|_| {\n                     failed = true;\n-                }).inside {\n-                    git_clone_url(url, &clone_target, &pkgid.version);\n-                };\n+                }).inside(|| git_clone_url(url, &clone_target, &pkgid.version));\n \n                 if failed {\n                     return None;\n@@ -400,7 +398,7 @@ impl PkgSrc {\n             debug!(\"build_crates: compiling {}\", path.display());\n             let cfgs = crate.cfgs + cfgs;\n \n-            do ctx.workcache_context.with_prep(crate_tag(&path)) |prep| {\n+            ctx.workcache_context.with_prep(crate_tag(&path), |prep| {\n                 debug!(\"Building crate {}, declaring it as an input\", path.display());\n                 // FIXME (#9639): This needs to handle non-utf8 paths\n                 prep.declare_input(\"file\", path.as_str().unwrap(),\n@@ -414,7 +412,7 @@ impl PkgSrc {\n                 let sub_deps = deps.clone();\n                 let inputs = inputs_to_discover.map(|&(ref k, ref p)|\n                                                     (k.clone(), p.as_str().unwrap().to_owned()));\n-                do prep.exec |exec| {\n+                prep.exec(|exec| {\n                     for &(ref kind, ref p) in inputs.iter() {\n                         let pth = Path::new(p.clone());\n                         exec.discover_input(*kind, *p, if *kind == ~\"file\" {\n@@ -445,8 +443,8 @@ impl PkgSrc {\n                     let result = result.as_ref().map(|p|p.as_str().unwrap());\n                     debug!(\"Result of compiling {} was {}\", subpath.display(), result.to_str());\n                     result.to_str()\n-                }\n-            };\n+                })\n+            });\n         }\n     }\n "}, {"sha": "9d5b5e91fe27cf96db876c23cc9f5eda8e2e1ae8", "filename": "src/librustpkg/path_util.rs", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustpkg%2Fpath_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustpkg%2Fpath_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpath_util.rs?ref=8ceb374ab783c6417b60867e7f34bebe997936ac", "patch": "@@ -76,15 +76,15 @@ pub fn workspace_contains_package_id_(pkgid: &PkgId, workspace: &Path,\n         if p.is_dir() {\n             if p == src_dir.join(&pkgid.path) || {\n                 let pf = p.filename_str();\n-                do pf.iter().any |&g| {\n+                pf.iter().any(|&g| {\n                     match split_version_general(g, '-') {\n                         None => false,\n                         Some((ref might_match, ref vers)) => {\n                             *might_match == pkgid.short_name\n                                 && (pkgid.version == *vers || pkgid.version == NoVersion)\n                         }\n                     }\n-                }\n+                })\n             } {\n                 found = Some(p.clone());\n             }\n@@ -215,7 +215,7 @@ pub fn system_library(sysroot: &Path, lib_name: &str) -> Option<Path> {\n \n fn library_in(short_name: &str, version: &Version, dir_to_search: &Path) -> Option<Path> {\n     debug!(\"Listing directory {}\", dir_to_search.display());\n-    let dir_contents = do io::ignore_io_error { fs::readdir(dir_to_search) };\n+    let dir_contents = io::ignore_io_error(|| fs::readdir(dir_to_search));\n     debug!(\"dir has {:?} entries\", dir_contents.len());\n \n     let lib_prefix = format!(\"{}{}\", os::consts::DLL_PREFIX, short_name);\n@@ -225,14 +225,14 @@ fn library_in(short_name: &str, version: &Version, dir_to_search: &Path) -> Opti\n \n     // Find a filename that matches the pattern:\n     // (lib_prefix)-hash-(version)(lib_suffix)\n-    let mut libraries = do dir_contents.iter().filter |p| {\n+    let mut libraries = dir_contents.iter().filter(|p| {\n         let extension = p.extension_str();\n         debug!(\"p = {}, p's extension is {:?}\", p.display(), extension);\n         match extension {\n             None => false,\n             Some(ref s) => lib_filetype == *s\n         }\n-    };\n+    });\n \n     let mut result_filename = None;\n     for p_path in libraries {\n@@ -277,11 +277,11 @@ fn library_in(short_name: &str, version: &Version, dir_to_search: &Path) -> Opti\n \n     // Return the filename that matches, which we now know exists\n     // (if result_filename != None)\n-    let abs_path = do result_filename.map |result_filename| {\n+    let abs_path = result_filename.map(|result_filename| {\n         let absolute_path = dir_to_search.join(&result_filename);\n         debug!(\"result_filename = {}\", absolute_path.display());\n         absolute_path\n-    };\n+    });\n \n     abs_path\n }\n@@ -463,19 +463,14 @@ pub fn versionize(p: &Path, v: &Version) -> Path {\n #[cfg(target_os = \"win32\")]\n pub fn chmod_read_only(p: &Path) -> bool {\n     unsafe {\n-        do p.with_c_str |src_buf| {\n-            libc::chmod(src_buf, S_IRUSR as libc::c_int) == 0 as libc::c_int\n-        }\n+        p.with_c_str(|src_buf| libc::chmod(src_buf, S_IRUSR as libc::c_int) == 0 as libc::c_int)\n     }\n }\n \n #[cfg(not(target_os = \"win32\"))]\n pub fn chmod_read_only(p: &Path) -> bool {\n     unsafe {\n-        do p.with_c_str |src_buf| {\n-            libc::chmod(src_buf, S_IRUSR as libc::mode_t) == 0\n-                as libc::c_int\n-        }\n+        p.with_c_str(|src_buf| libc::chmod(src_buf, S_IRUSR as libc::mode_t) == 0 as libc::c_int)\n     }\n }\n "}, {"sha": "396ef756c7610836ea99ddb388fb526cc7be1531", "filename": "src/librustpkg/sha1.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustpkg%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustpkg%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fsha1.rs?ref=8ceb374ab783c6417b60867e7f34bebe997936ac", "patch": "@@ -51,11 +51,11 @@ fn read_u32v_be(dst: &mut[u32], input: &[u8]) {\n     unsafe {\n         let mut x: *mut i32 = transmute(dst.unsafe_mut_ref(0));\n         let mut y: *i32 = transmute(input.unsafe_ref(0));\n-        do dst.len().times() {\n+        dst.len().times(|| {\n             *x = to_be32(*y);\n             x = x.offset(1);\n             y = y.offset(1);\n-        }\n+        })\n     }\n }\n \n@@ -613,29 +613,23 @@ mod bench {\n     pub fn sha1_10(bh: & mut BenchHarness) {\n         let mut sh = Sha1::new();\n         let bytes = [1u8, ..10];\n-        do bh.iter {\n-            sh.input(bytes);\n-        }\n+        bh.iter(|| sh.input(bytes));\n         bh.bytes = bytes.len() as u64;\n     }\n \n     #[bench]\n     pub fn sha1_1k(bh: & mut BenchHarness) {\n         let mut sh = Sha1::new();\n         let bytes = [1u8, ..1024];\n-        do bh.iter {\n-            sh.input(bytes);\n-        }\n+        bh.iter(|| sh.input(bytes));\n         bh.bytes = bytes.len() as u64;\n     }\n \n     #[bench]\n     pub fn sha1_64k(bh: & mut BenchHarness) {\n         let mut sh = Sha1::new();\n         let bytes = [1u8, ..65536];\n-        do bh.iter {\n-            sh.input(bytes);\n-        }\n+        bh.iter(|| sh.input(bytes));\n         bh.bytes = bytes.len() as u64;\n     }\n }"}, {"sha": "7413e7847b4ceb1dc4b39814e222742878084881", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=8ceb374ab783c6417b60867e7f34bebe997936ac", "patch": "@@ -384,9 +384,7 @@ fn executable_exists(repo: &Path, short_name: &str) -> bool {\n fn test_executable_exists(repo: &Path, short_name: &str) -> bool {\n     debug!(\"test_executable_exists: repo = {}, short_name = {}\", repo.display(), short_name);\n     let exec = built_test_in_workspace(&PkgId::new(short_name), repo);\n-    do exec.map_default(false) |exec| {\n-        exec.exists() && is_rwx(&exec)\n-    }\n+    exec.map_default(false, |exec| exec.exists() && is_rwx(&exec));\n }\n \n fn remove_executable_file(p: &PkgId, workspace: &Path) {\n@@ -544,12 +542,12 @@ fn frob_source_file(workspace: &Path, pkgid: &PkgId, filename: &str) {\n     debug!(\"Frobbed? {:?}\", maybe_p);\n     match maybe_p {\n         Some(ref p) => {\n-            do io::io_error::cond.trap(|e| {\n+            io::io_error::cond.trap(|e| {\n                 cond.raise((p.clone(), format!(\"Bad path: {}\", e.desc)));\n-            }).inside {\n+            }).inside(|| {\n                 let mut w = File::open_mode(p, io::Append, io::Write);\n                 w.write(bytes!(\"/* hi */\\n\"));\n-            }\n+            })\n         }\n         None => fail!(\"frob_source_file failed to find a source file in {}\",\n                            pkg_src_dir.display())\n@@ -744,26 +742,26 @@ fn test_package_ids_must_be_relative_path_like() {\n     assert!(\"github.com/catamorphism/test-pkg-0.1\" ==\n             PkgId::new(\"github.com/catamorphism/test-pkg\").to_str());\n \n-    do cond.trap(|(p, e)| {\n+    cond.trap(|(p, e)| {\n         assert!(p.filename().is_none())\n         assert!(\"0-length pkgid\" == e);\n         whatever.clone()\n-    }).inside {\n+    }).inside(|| {\n         let x = PkgId::new(\"\");\n         assert_eq!(~\"foo-0.1\", x.to_str());\n-    }\n+    });\n \n-    do cond.trap(|(p, e)| {\n+    cond.trap(|(p, e)| {\n         let abs = os::make_absolute(&Path::new(\"foo/bar/quux\"));\n         assert_eq!(p, abs);\n         assert!(\"absolute pkgid\" == e);\n         whatever.clone()\n-    }).inside {\n+    }).inside(|| {\n         let zp = os::make_absolute(&Path::new(\"foo/bar/quux\"));\n         // FIXME (#9639): This needs to handle non-utf8 paths\n         let z = PkgId::new(zp.as_str().unwrap());\n         assert_eq!(~\"foo-0.1\", z.to_str());\n-    }\n+    })\n \n }\n "}, {"sha": "180f8cc74cee68c9d900a93e7361e666c3cee13e", "filename": "src/librustpkg/testsuite/pass/src/c-dependencies/pkg.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fc-dependencies%2Fpkg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fc-dependencies%2Fpkg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fc-dependencies%2Fpkg.rs?ref=8ceb374ab783c6417b60867e7f34bebe997936ac", "patch": "@@ -44,13 +44,13 @@ pub fn main() {\n     let my_workspace = api::my_workspace(&context.context, \"cdep\");\n     let foo_c_name = my_workspace.join_many([\"src\", \"cdep-0.1\", \"foo.c\"]);\n \n-    let out_lib_path = do context.workcache_context.with_prep(\"foo.c\") |prep| {\n+    let out_lib_path = context.workcache_context.with_prep(\"foo.c\", |prep| {\n         let sub_cx = context.context.clone();\n         debug!(\"foo_c_name = {}\", foo_c_name.display());\n         prep.declare_input(\"file\",\n                            foo_c_name.as_str().unwrap().to_owned(),\n                            digest_file_with_date(&foo_c_name));\n-        let out_path = do prep.exec |exec| {\n+        let out_path = prep.exec(|exec| {\n             let out_path = api::build_library_in_workspace(exec,\n                                                            &mut sub_cx.clone(),\n                                                            \"cdep\",\n@@ -60,9 +60,9 @@ pub fn main() {\n                                                            \"foo\");\n             let out_p = Path::new(out_path);\n             out_p.as_str().unwrap().to_owned()\n-        };\n+        });\n         out_path\n-    };\n+    });\n     let out_lib_path = Path::new(out_lib_path);\n     debug!(\"out_lib_path = {}\", out_lib_path.display());\n     context.add_library_path(out_lib_path.dir_path());"}, {"sha": "9842508a5c3203bab9cd0976d934d513b8c1492e", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ceb374ab783c6417b60867e7f34bebe997936ac/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=8ceb374ab783c6417b60867e7f34bebe997936ac", "patch": "@@ -81,21 +81,19 @@ fn fold_mod(_ctx: @mut ReadyCtx, m: &ast::_mod, fold: &CrateSetup)\n             -> ast::_mod {\n     fn strip_main(item: @ast::item) -> @ast::item {\n         @ast::item {\n-            attrs: do item.attrs.iter().filter_map |attr| {\n+            attrs: item.attrs.iter().filter_map(|attr| {\n                 if \"main\" != attr.name() {\n                     Some(*attr)\n                 } else {\n                     None\n                 }\n-            }.collect(),\n+            }).collect(),\n             .. (*item).clone()\n         }\n     }\n \n     fold::noop_fold_mod(&ast::_mod {\n-        items: do m.items.map |item| {\n-            strip_main(*item)\n-        },\n+        items: m.items.map(|item| strip_main(*item)),\n         .. (*m).clone()\n     }, fold)\n }\n@@ -493,21 +491,21 @@ impl<'self> Visitor<()> for ViewItemVisitor<'self> {\n                         // and the `PkgSrc` constructor will detect that;\n                         // or else it's already in a workspace and we'll build into that\n                         // workspace\n-                        let pkg_src = do cond.trap(|_| {\n+                        let pkg_src = cond.trap(|_| {\n                                  // Nonexistent package? Then print a better error\n                                  error(format!(\"Package {} depends on {}, but I don't know \\\n                                                how to find it\",\n                                                self.parent.path.display(),\n                                                pkg_id.path.display()));\n                                  fail!()\n-                        }).inside {\n+                        }).inside(|| {\n                             PkgSrc::new(source_workspace.clone(),\n                                         dest_workspace.clone(),\n                                         // Use the rust_path_hack to search for dependencies iff\n                                         // we were already using it\n                                         self.context.context.use_rust_path_hack,\n                                         pkg_id.clone())\n-                        };\n+                        });\n                         let (outputs_disc, inputs_disc) =\n                             self.context.install(\n                                 pkg_src,"}]}