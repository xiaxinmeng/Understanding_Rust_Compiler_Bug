{"sha": "21c157442c1e97745b91b8c3286ceabbc9f7be3f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIxYzE1NzQ0MmMxZTk3NzQ1YjkxYjhjMzI4NmNlYWJiYzlmN2JlM2Y=", "commit": {"author": {"name": "Ivan Tham", "email": "pickfire@riseup.net", "date": "2020-12-07T16:32:13Z"}, "committer": {"name": "Ivan Tham", "email": "pickfire@riseup.net", "date": "2021-03-17T01:04:08Z"}, "message": "Add pub as optional check_front_matter\n\nasync-pub check created a regression for default", "tree": {"sha": "39ecec1819bc132cf4e7dc278313a2c337172d75", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/39ecec1819bc132cf4e7dc278313a2c337172d75"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/21c157442c1e97745b91b8c3286ceabbc9f7be3f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/21c157442c1e97745b91b8c3286ceabbc9f7be3f", "html_url": "https://github.com/rust-lang/rust/commit/21c157442c1e97745b91b8c3286ceabbc9f7be3f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/21c157442c1e97745b91b8c3286ceabbc9f7be3f/comments", "author": {"login": "pickfire", "id": 4687791, "node_id": "MDQ6VXNlcjQ2ODc3OTE=", "avatar_url": "https://avatars.githubusercontent.com/u/4687791?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pickfire", "html_url": "https://github.com/pickfire", "followers_url": "https://api.github.com/users/pickfire/followers", "following_url": "https://api.github.com/users/pickfire/following{/other_user}", "gists_url": "https://api.github.com/users/pickfire/gists{/gist_id}", "starred_url": "https://api.github.com/users/pickfire/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pickfire/subscriptions", "organizations_url": "https://api.github.com/users/pickfire/orgs", "repos_url": "https://api.github.com/users/pickfire/repos", "events_url": "https://api.github.com/users/pickfire/events{/privacy}", "received_events_url": "https://api.github.com/users/pickfire/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pickfire", "id": 4687791, "node_id": "MDQ6VXNlcjQ2ODc3OTE=", "avatar_url": "https://avatars.githubusercontent.com/u/4687791?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pickfire", "html_url": "https://github.com/pickfire", "followers_url": "https://api.github.com/users/pickfire/followers", "following_url": "https://api.github.com/users/pickfire/following{/other_user}", "gists_url": "https://api.github.com/users/pickfire/gists{/gist_id}", "starred_url": "https://api.github.com/users/pickfire/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pickfire/subscriptions", "organizations_url": "https://api.github.com/users/pickfire/orgs", "repos_url": "https://api.github.com/users/pickfire/repos", "events_url": "https://api.github.com/users/pickfire/events{/privacy}", "received_events_url": "https://api.github.com/users/pickfire/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c44a5feb0526edf44782c2c3e9012b3e408be725", "url": "https://api.github.com/repos/rust-lang/rust/commits/c44a5feb0526edf44782c2c3e9012b3e408be725", "html_url": "https://github.com/rust-lang/rust/commit/c44a5feb0526edf44782c2c3e9012b3e408be725"}], "stats": {"total": 64, "additions": 39, "deletions": 25}, "files": [{"sha": "65c104bf80b7ad4fd45074a813bd1abe3d15fa50", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/21c157442c1e97745b91b8c3286ceabbc9f7be3f/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21c157442c1e97745b91b8c3286ceabbc9f7be3f/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=21c157442c1e97745b91b8c3286ceabbc9f7be3f", "patch": "@@ -204,6 +204,7 @@ impl<'a> Parser<'a> {\n         def: &mut Defaultness,\n         req_name: ReqName,\n     ) -> PResult<'a, Option<ItemInfo>> {\n+        let def_final = def == &Defaultness::Final;\n         let mut def = || mem::replace(def, Defaultness::Final);\n \n         let info = if self.eat_keyword(kw::Use) {\n@@ -226,7 +227,7 @@ impl<'a> Parser<'a> {\n             }\n \n             (Ident::invalid(), ItemKind::Use(tree))\n-        } else if self.check_fn_front_matter() {\n+        } else if self.check_fn_front_matter(def_final) {\n             // FUNCTION ITEM\n             let (ident, sig, generics, body) = self.parse_fn(attrs, req_name, lo)?;\n             (ident, ItemKind::Fn(box FnKind(def(), sig, generics, body)))\n@@ -1636,19 +1637,27 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Is the current token the start of an `FnHeader` / not a valid parse?\n-    pub(super) fn check_fn_front_matter(&mut self) -> bool {\n+    ///\n+    /// `check_pub` adds additional `pub` to the checks in case users place it\n+    /// wrongly, can be used to ensure `pub` never comes after `default`.\n+    pub(super) fn check_fn_front_matter(&mut self, check_pub: bool) -> bool {\n         // We use an over-approximation here.\n         // `const const`, `fn const` won't parse, but we're not stepping over other syntax either.\n-        // `pub` is added in case users got confused with the ordering like `async pub fn`.\n-        const QUALS: [Symbol; 5] = [kw::Pub, kw::Const, kw::Async, kw::Unsafe, kw::Extern];\n+        // `pub` is added in case users got confused with the ordering like `async pub fn`,\n+        // only if it wasn't preceeded by `default` as `default pub` is invalid.\n+        let quals: &[Symbol] = if check_pub {\n+            &[kw::Pub, kw::Const, kw::Async, kw::Unsafe, kw::Extern]\n+        } else {\n+            &[kw::Const, kw::Async, kw::Unsafe, kw::Extern]\n+        };\n         self.check_keyword(kw::Fn) // Definitely an `fn`.\n             // `$qual fn` or `$qual $qual`:\n-            || QUALS.iter().any(|&kw| self.check_keyword(kw))\n+            || quals.iter().any(|&kw| self.check_keyword(kw))\n                 && self.look_ahead(1, |t| {\n                     // `$qual fn`, e.g. `const fn` or `async fn`.\n                     t.is_keyword(kw::Fn)\n                     // Two qualifiers `$qual $qual` is enough, e.g. `async unsafe`.\n-                    || t.is_non_raw_ident_where(|i| QUALS.contains(&i.name)\n+                    || t.is_non_raw_ident_where(|i| quals.contains(&i.name)\n                         // Rule out 2015 `const async: T = val`.\n                         && i.is_reserved()\n                         // Rule out unsafe extern block."}, {"sha": "0f7b8ebd376b9e5c6438afd070f3c456bb1d3be9", "filename": "compiler/rustc_parse/src/parser/ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/21c157442c1e97745b91b8c3286ceabbc9f7be3f/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21c157442c1e97745b91b8c3286ceabbc9f7be3f/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs?ref=21c157442c1e97745b91b8c3286ceabbc9f7be3f", "patch": "@@ -209,15 +209,15 @@ impl<'a> Parser<'a> {\n         } else if self.eat_keyword(kw::Underscore) {\n             // A type to be inferred `_`\n             TyKind::Infer\n-        } else if self.check_fn_front_matter() {\n+        } else if self.check_fn_front_matter(false) {\n             // Function pointer type\n             self.parse_ty_bare_fn(lo, Vec::new(), recover_return_sign)?\n         } else if self.check_keyword(kw::For) {\n             // Function pointer type or bound list (trait object type) starting with a poly-trait.\n             //   `for<'lt> [unsafe] [extern \"ABI\"] fn (&'lt S) -> T`\n             //   `for<'lt> Trait1<'lt> + Trait2 + 'a`\n             let lifetime_defs = self.parse_late_bound_lifetime_defs()?;\n-            if self.check_fn_front_matter() {\n+            if self.check_fn_front_matter(false) {\n                 self.parse_ty_bare_fn(lo, lifetime_defs, recover_return_sign)?\n             } else {\n                 let path = self.parse_path(PathStyle::Type)?;"}, {"sha": "52338c1f13aadde7c3ac78af8ef1284bbe6f4ead", "filename": "src/test/ui/parser/default.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/21c157442c1e97745b91b8c3286ceabbc9f7be3f/src%2Ftest%2Fui%2Fparser%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21c157442c1e97745b91b8c3286ceabbc9f7be3f/src%2Ftest%2Fui%2Fparser%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fdefault.rs?ref=21c157442c1e97745b91b8c3286ceabbc9f7be3f", "patch": "@@ -1,4 +1,3 @@\n-// ignore-tidy-linelength\n // Test successful and unsuccessful parsing of the `default` contextual keyword\n \n #![feature(specialization)]\n@@ -22,7 +21,8 @@ impl Foo for u16 {\n \n impl Foo for u32 { //~ ERROR not all trait items implemented, missing: `foo`\n     default pub fn foo<T: Default>() -> T { T::default() }\n-    //~^ ERROR expected one of `async`, `const`, `extern`, `fn`, `pub`, `unsafe`, or `use`, found keyword `pub`\n+    //~^ ERROR `default` is not followed by an item\n+    //~| ERROR non-item in item list\n }\n \n fn main() {}"}, {"sha": "5b763ae72f5eee88fdf9ead93d1fbce7981eaf9e", "filename": "src/test/ui/parser/default.stderr", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/21c157442c1e97745b91b8c3286ceabbc9f7be3f/src%2Ftest%2Fui%2Fparser%2Fdefault.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21c157442c1e97745b91b8c3286ceabbc9f7be3f/src%2Ftest%2Fui%2Fparser%2Fdefault.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fdefault.stderr?ref=21c157442c1e97745b91b8c3286ceabbc9f7be3f", "patch": "@@ -1,25 +1,30 @@\n-error: expected one of `async`, `const`, `extern`, `fn`, `pub`, `unsafe`, or `use`, found keyword `pub`\n-  --> $DIR/default.rs:24:13\n+error: `default` is not followed by an item\n+  --> $DIR/default.rs:23:5\n+   |\n+LL |     default pub fn foo<T: Default>() -> T { T::default() }\n+   |     ^^^^^^^ the `default` qualifier\n+   |\n+   = note: only `fn`, `const`, `type`, or `impl` items may be prefixed by `default`\n+\n+error: non-item in item list\n+  --> $DIR/default.rs:23:13\n    |\n LL | impl Foo for u32 {\n-   |                  - while parsing this item list starting here\n+   |                  - item list starts here\n LL |     default pub fn foo<T: Default>() -> T { T::default() }\n-   |             ^^^\n-   |             |\n-   |             expected one of 7 possible tokens\n-   |             help: visibility `pub` must come before `default pub`: `pub default pub`\n-LL |\n+   |             ^^^ non-item starts here\n+...\n LL | }\n-   | - the item list ends here\n+   | - item list ends here\n \n error[E0449]: unnecessary visibility qualifier\n-  --> $DIR/default.rs:18:5\n+  --> $DIR/default.rs:17:5\n    |\n LL |     pub default fn foo<T: Default>() -> T {\n    |     ^^^ `pub` not permitted here because it's implied\n \n warning: the feature `specialization` is incomplete and may not be safe to use and/or cause compiler crashes\n-  --> $DIR/default.rs:4:12\n+  --> $DIR/default.rs:3:12\n    |\n LL | #![feature(specialization)]\n    |            ^^^^^^^^^^^^^^\n@@ -29,15 +34,15 @@ LL | #![feature(specialization)]\n    = help: consider using `min_specialization` instead, which is more stable and complete\n \n error[E0046]: not all trait items implemented, missing: `foo`\n-  --> $DIR/default.rs:23:1\n+  --> $DIR/default.rs:22:1\n    |\n LL |     fn foo<T: Default>() -> T;\n    |     -------------------------- `foo` from trait\n ...\n LL | impl Foo for u32 {\n    | ^^^^^^^^^^^^^^^^ missing `foo` in implementation\n \n-error: aborting due to 3 previous errors; 1 warning emitted\n+error: aborting due to 4 previous errors; 1 warning emitted\n \n Some errors have detailed explanations: E0046, E0449.\n For more information about an error, try `rustc --explain E0046`."}, {"sha": "e249a93df92a2174b4ab221f7c07788560667f9f", "filename": "src/test/ui/parser/issue-63116.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/21c157442c1e97745b91b8c3286ceabbc9f7be3f/src%2Ftest%2Fui%2Fparser%2Fissue-63116.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/21c157442c1e97745b91b8c3286ceabbc9f7be3f/src%2Ftest%2Fui%2Fparser%2Fissue-63116.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-63116.stderr?ref=21c157442c1e97745b91b8c3286ceabbc9f7be3f", "patch": "@@ -1,4 +1,4 @@\n-=rror: this file contains an unclosed delimiter\n+error: this file contains an unclosed delimiter\n   --> $DIR/issue-63116.rs:3:18\n    |\n LL | impl W <s(f;Y(;]\n@@ -12,7 +12,7 @@ error: expected one of `!`, `(`, `)`, `+`, `,`, `::`, or `<`, found `;`\n LL | impl W <s(f;Y(;]\n    |            ^ expected one of 7 possible tokens\n \n-error: expected one of `!`, `&&`, `&`, `(`, `)`, `*`, `+`, `,`, `->`, `...`, `::`, `<`, `>`, `?`, `[`, `_`, `async`, `const`, `dyn`, `extern`, `fn`, `for`, `impl`, `pub`, `unsafe`, lifetime, or path, found `;`\n+error: expected one of `!`, `&&`, `&`, `(`, `)`, `*`, `+`, `,`, `->`, `...`, `::`, `:`, `<`, `=`, `>`, `?`, `[`, `_`, `async`, `const`, `dyn`, `extern`, `fn`, `for`, `impl`, `unsafe`, lifetime, or path, found `;`\n   --> $DIR/issue-63116.rs:3:15\n    |\n LL | impl W <s(f;Y(;]"}]}