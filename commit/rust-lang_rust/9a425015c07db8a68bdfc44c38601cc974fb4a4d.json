{"sha": "9a425015c07db8a68bdfc44c38601cc974fb4a4d", "node_id": "C_kwDOAAsO6NoAKDlhNDI1MDE1YzA3ZGI4YTY4YmRmYzQ0YzM4NjAxY2M5NzRmYjRhNGQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-25T11:27:33Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-25T11:27:33Z"}, "message": "Auto merge of #9692 - llogiq:mutable-key-more-arcs, r=Alexendoo\n\nmake ignored internally mutable types for `mutable-key` configurable\n\nWe had some false positives where people would create their own types that had interior mutability unrelated to hash/eq. This addition lets you configure this as e.g. `arc-like-types=[\"bytes::Bytes\"]`\n\nThis fixes #5325 by allowing users to specify the types whose innards like `Arc` should be ignored (the generic types are still checked) for the sake of detecting inner mutability.\n\nr? `@Alexendoo`\n\n---\n\nchangelog: Allow configuring types to ignore internal mutability in `mutable-key`", "tree": {"sha": "d71a7aaa0295ac2bb1b01cb05a74db68e8b5e153", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d71a7aaa0295ac2bb1b01cb05a74db68e8b5e153"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9a425015c07db8a68bdfc44c38601cc974fb4a4d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9a425015c07db8a68bdfc44c38601cc974fb4a4d", "html_url": "https://github.com/rust-lang/rust/commit/9a425015c07db8a68bdfc44c38601cc974fb4a4d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9a425015c07db8a68bdfc44c38601cc974fb4a4d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "df67ebba5ea9373d9aa06e856f5fdb1265954203", "url": "https://api.github.com/repos/rust-lang/rust/commits/df67ebba5ea9373d9aa06e856f5fdb1265954203", "html_url": "https://github.com/rust-lang/rust/commit/df67ebba5ea9373d9aa06e856f5fdb1265954203"}, {"sha": "eba36e6d95aef2d6415327a27ab3a91069333b97", "url": "https://api.github.com/repos/rust-lang/rust/commits/eba36e6d95aef2d6415327a27ab3a91069333b97", "html_url": "https://github.com/rust-lang/rust/commit/eba36e6d95aef2d6415327a27ab3a91069333b97"}], "stats": {"total": 265, "additions": 199, "deletions": 66}, "files": [{"sha": "e95e8749c61899b1b7fd76c7c178027d3cc55408", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9a425015c07db8a68bdfc44c38601cc974fb4a4d/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a425015c07db8a68bdfc44c38601cc974fb4a4d/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=9a425015c07db8a68bdfc44c38601cc974fb4a4d", "patch": "@@ -727,7 +727,8 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     let max_trait_bounds = conf.max_trait_bounds;\n     store.register_late_pass(move |_| Box::new(trait_bounds::TraitBounds::new(max_trait_bounds)));\n     store.register_late_pass(|_| Box::new(comparison_chain::ComparisonChain));\n-    store.register_late_pass(|_| Box::new(mut_key::MutableKeyType));\n+    let ignore_interior_mutability = conf.ignore_interior_mutability.clone();\n+    store.register_late_pass(move |_| Box::new(mut_key::MutableKeyType::new(ignore_interior_mutability.clone())));\n     store.register_early_pass(|| Box::new(reference::DerefAddrOf));\n     store.register_early_pass(|| Box::new(double_parens::DoubleParens));\n     store.register_late_pass(|_| Box::new(format_impl::FormatImpl::new()));"}, {"sha": "3d643e4e65c453760cc76abe7f7a8546cf2f278e", "filename": "clippy_lints/src/mut_key.rs", "status": "modified", "additions": 95, "deletions": 63, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/9a425015c07db8a68bdfc44c38601cc974fb4a4d/clippy_lints%2Fsrc%2Fmut_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a425015c07db8a68bdfc44c38601cc974fb4a4d/clippy_lints%2Fsrc%2Fmut_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_key.rs?ref=9a425015c07db8a68bdfc44c38601cc974fb4a4d", "patch": "@@ -1,10 +1,12 @@\n use clippy_utils::diagnostics::span_lint;\n-use clippy_utils::trait_ref_of_method;\n+use clippy_utils::{def_path_res, trait_ref_of_method};\n+use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n+use rustc_hir::def::Namespace;\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty::TypeVisitable;\n use rustc_middle::ty::{Adt, Array, Ref, Slice, Tuple, Ty};\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::source_map::Span;\n use rustc_span::symbol::sym;\n use std::iter;\n@@ -78,98 +80,128 @@ declare_clippy_lint! {\n     \"Check for mutable `Map`/`Set` key type\"\n }\n \n-declare_lint_pass!(MutableKeyType => [ MUTABLE_KEY_TYPE ]);\n+#[derive(Clone)]\n+pub struct MutableKeyType {\n+    ignore_interior_mutability: Vec<String>,\n+    ignore_mut_def_ids: FxHashSet<hir::def_id::DefId>,\n+}\n+\n+impl_lint_pass!(MutableKeyType => [ MUTABLE_KEY_TYPE ]);\n \n impl<'tcx> LateLintPass<'tcx> for MutableKeyType {\n+    fn check_crate(&mut self, cx: &LateContext<'tcx>) {\n+        self.ignore_mut_def_ids.clear();\n+        let mut path = Vec::new();\n+        for ty in &self.ignore_interior_mutability {\n+            path.extend(ty.split(\"::\"));\n+            if let Some(id) = def_path_res(cx, &path[..], Some(Namespace::TypeNS)).opt_def_id() {\n+                self.ignore_mut_def_ids.insert(id);\n+            }\n+            path.clear();\n+        }\n+    }\n+\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::Item<'tcx>) {\n         if let hir::ItemKind::Fn(ref sig, ..) = item.kind {\n-            check_sig(cx, item.hir_id(), sig.decl);\n+            self.check_sig(cx, item.hir_id(), sig.decl);\n         }\n     }\n \n     fn check_impl_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::ImplItem<'tcx>) {\n         if let hir::ImplItemKind::Fn(ref sig, ..) = item.kind {\n             if trait_ref_of_method(cx, item.def_id.def_id).is_none() {\n-                check_sig(cx, item.hir_id(), sig.decl);\n+                self.check_sig(cx, item.hir_id(), sig.decl);\n             }\n         }\n     }\n \n     fn check_trait_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::TraitItem<'tcx>) {\n         if let hir::TraitItemKind::Fn(ref sig, ..) = item.kind {\n-            check_sig(cx, item.hir_id(), sig.decl);\n+            self.check_sig(cx, item.hir_id(), sig.decl);\n         }\n     }\n \n     fn check_local(&mut self, cx: &LateContext<'_>, local: &hir::Local<'_>) {\n         if let hir::PatKind::Wild = local.pat.kind {\n             return;\n         }\n-        check_ty(cx, local.span, cx.typeck_results().pat_ty(local.pat));\n+        self.check_ty_(cx, local.span, cx.typeck_results().pat_ty(local.pat));\n     }\n }\n \n-fn check_sig<'tcx>(cx: &LateContext<'tcx>, item_hir_id: hir::HirId, decl: &hir::FnDecl<'_>) {\n-    let fn_def_id = cx.tcx.hir().local_def_id(item_hir_id);\n-    let fn_sig = cx.tcx.fn_sig(fn_def_id);\n-    for (hir_ty, ty) in iter::zip(decl.inputs, fn_sig.inputs().skip_binder()) {\n-        check_ty(cx, hir_ty.span, *ty);\n+impl MutableKeyType {\n+    pub fn new(ignore_interior_mutability: Vec<String>) -> Self {\n+        Self {\n+            ignore_interior_mutability,\n+            ignore_mut_def_ids: FxHashSet::default(),\n+        }\n     }\n-    check_ty(cx, decl.output.span(), cx.tcx.erase_late_bound_regions(fn_sig.output()));\n-}\n \n-// We want to lint 1. sets or maps with 2. not immutable key types and 3. no unerased\n-// generics (because the compiler cannot ensure immutability for unknown types).\n-fn check_ty<'tcx>(cx: &LateContext<'tcx>, span: Span, ty: Ty<'tcx>) {\n-    let ty = ty.peel_refs();\n-    if let Adt(def, substs) = ty.kind() {\n-        let is_keyed_type = [sym::HashMap, sym::BTreeMap, sym::HashSet, sym::BTreeSet]\n-            .iter()\n-            .any(|diag_item| cx.tcx.is_diagnostic_item(*diag_item, def.did()));\n-        if is_keyed_type && is_interior_mutable_type(cx, substs.type_at(0), span) {\n-            span_lint(cx, MUTABLE_KEY_TYPE, span, \"mutable key type\");\n+    fn check_sig<'tcx>(&self, cx: &LateContext<'tcx>, item_hir_id: hir::HirId, decl: &hir::FnDecl<'_>) {\n+        let fn_def_id = cx.tcx.hir().local_def_id(item_hir_id);\n+        let fn_sig = cx.tcx.fn_sig(fn_def_id);\n+        for (hir_ty, ty) in iter::zip(decl.inputs, fn_sig.inputs().skip_binder()) {\n+            self.check_ty_(cx, hir_ty.span, *ty);\n         }\n+        self.check_ty_(cx, decl.output.span(), cx.tcx.erase_late_bound_regions(fn_sig.output()));\n     }\n-}\n \n-/// Determines if a type contains interior mutability which would affect its implementation of\n-/// [`Hash`] or [`Ord`].\n-fn is_interior_mutable_type<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, span: Span) -> bool {\n-    match *ty.kind() {\n-        Ref(_, inner_ty, mutbl) => mutbl == hir::Mutability::Mut || is_interior_mutable_type(cx, inner_ty, span),\n-        Slice(inner_ty) => is_interior_mutable_type(cx, inner_ty, span),\n-        Array(inner_ty, size) => {\n-            size.try_eval_usize(cx.tcx, cx.param_env).map_or(true, |u| u != 0)\n-                && is_interior_mutable_type(cx, inner_ty, span)\n-        },\n-        Tuple(fields) => fields.iter().any(|ty| is_interior_mutable_type(cx, ty, span)),\n-        Adt(def, substs) => {\n-            // Special case for collections in `std` who's impl of `Hash` or `Ord` delegates to\n-            // that of their type parameters.  Note: we don't include `HashSet` and `HashMap`\n-            // because they have no impl for `Hash` or `Ord`.\n-            let is_std_collection = [\n-                sym::Option,\n-                sym::Result,\n-                sym::LinkedList,\n-                sym::Vec,\n-                sym::VecDeque,\n-                sym::BTreeMap,\n-                sym::BTreeSet,\n-                sym::Rc,\n-                sym::Arc,\n-            ]\n-            .iter()\n-            .any(|diag_item| cx.tcx.is_diagnostic_item(*diag_item, def.did()));\n-            let is_box = Some(def.did()) == cx.tcx.lang_items().owned_box();\n-            if is_std_collection || is_box {\n-                // The type is mutable if any of its type parameters are\n-                substs.types().any(|ty| is_interior_mutable_type(cx, ty, span))\n-            } else {\n-                !ty.has_escaping_bound_vars()\n-                    && cx.tcx.layout_of(cx.param_env.and(ty)).is_ok()\n-                    && !ty.is_freeze(cx.tcx.at(span), cx.param_env)\n+    // We want to lint 1. sets or maps with 2. not immutable key types and 3. no unerased\n+    // generics (because the compiler cannot ensure immutability for unknown types).\n+    fn check_ty_<'tcx>(&self, cx: &LateContext<'tcx>, span: Span, ty: Ty<'tcx>) {\n+        let ty = ty.peel_refs();\n+        if let Adt(def, substs) = ty.kind() {\n+            let is_keyed_type = [sym::HashMap, sym::BTreeMap, sym::HashSet, sym::BTreeSet]\n+                .iter()\n+                .any(|diag_item| cx.tcx.is_diagnostic_item(*diag_item, def.did()));\n+            if is_keyed_type && self.is_interior_mutable_type(cx, substs.type_at(0), span) {\n+                span_lint(cx, MUTABLE_KEY_TYPE, span, \"mutable key type\");\n             }\n-        },\n-        _ => false,\n+        }\n+    }\n+\n+    /// Determines if a type contains interior mutability which would affect its implementation of\n+    /// [`Hash`] or [`Ord`].\n+    fn is_interior_mutable_type<'tcx>(&self, cx: &LateContext<'tcx>, ty: Ty<'tcx>, span: Span) -> bool {\n+        match *ty.kind() {\n+            Ref(_, inner_ty, mutbl) => {\n+                mutbl == hir::Mutability::Mut || self.is_interior_mutable_type(cx, inner_ty, span)\n+            },\n+            Slice(inner_ty) => self.is_interior_mutable_type(cx, inner_ty, span),\n+            Array(inner_ty, size) => {\n+                size.try_eval_usize(cx.tcx, cx.param_env).map_or(true, |u| u != 0)\n+                    && self.is_interior_mutable_type(cx, inner_ty, span)\n+            },\n+            Tuple(fields) => fields.iter().any(|ty| self.is_interior_mutable_type(cx, ty, span)),\n+            Adt(def, substs) => {\n+                // Special case for collections in `std` who's impl of `Hash` or `Ord` delegates to\n+                // that of their type parameters.  Note: we don't include `HashSet` and `HashMap`\n+                // because they have no impl for `Hash` or `Ord`.\n+                let def_id = def.did();\n+                let is_std_collection = [\n+                    sym::Option,\n+                    sym::Result,\n+                    sym::LinkedList,\n+                    sym::Vec,\n+                    sym::VecDeque,\n+                    sym::BTreeMap,\n+                    sym::BTreeSet,\n+                    sym::Rc,\n+                    sym::Arc,\n+                ]\n+                .iter()\n+                .any(|diag_item| cx.tcx.is_diagnostic_item(*diag_item, def_id));\n+                let is_box = Some(def_id) == cx.tcx.lang_items().owned_box();\n+                if is_std_collection || is_box || self.ignore_mut_def_ids.contains(&def_id) {\n+                    // The type is mutable if any of its type parameters are\n+                    substs.types().any(|ty| self.is_interior_mutable_type(cx, ty, span))\n+                } else {\n+                    !ty.has_escaping_bound_vars()\n+                        && cx.tcx.layout_of(cx.param_env.and(ty)).is_ok()\n+                        && !ty.is_freeze(cx.tcx.at(span), cx.param_env)\n+                }\n+            },\n+            _ => false,\n+        }\n     }\n }"}, {"sha": "05f62258143459b5c312626ee0b6a0824963aaf8", "filename": "clippy_lints/src/utils/conf.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9a425015c07db8a68bdfc44c38601cc974fb4a4d/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a425015c07db8a68bdfc44c38601cc974fb4a4d/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fconf.rs?ref=9a425015c07db8a68bdfc44c38601cc974fb4a4d", "patch": "@@ -389,10 +389,15 @@ define_Conf! {\n     ///\n     /// Whether `dbg!` should be allowed in test functions\n     (allow_dbg_in_tests: bool = false),\n-    /// Lint: RESULT_LARGE_ERR\n+    /// Lint: RESULT_LARGE_ERR.\n     ///\n     /// The maximum size of the `Err`-variant in a `Result` returned from a function\n     (large_error_threshold: u64 = 128),\n+    /// Lint: MUTABLE_KEY.\n+    ///\n+    /// A list of paths to types that should be treated like `Arc`, i.e. ignored but\n+    /// for the generic parameters for determining interior mutability\n+    (ignore_interior_mutability: Vec<String> = Vec::from([\"bytes::Bytes\".into()])),\n }\n \n /// Search for the configuration file."}, {"sha": "dda4660fb7a3f58301e98126b30dfbc8705290b1", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 41, "deletions": 1, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/9a425015c07db8a68bdfc44c38601cc974fb4a4d/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a425015c07db8a68bdfc44c38601cc974fb4a4d/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=9a425015c07db8a68bdfc44c38601cc974fb4a4d", "patch": "@@ -598,7 +598,13 @@ pub fn def_path_res(cx: &LateContext<'_>, path: &[&str], namespace_hint: Option<\n         [primitive] => {\n             return PrimTy::from_name(Symbol::intern(primitive)).map_or(Res::Err, Res::PrimTy);\n         },\n-        [base, ref path @ ..] => (base, path),\n+        [base, ref path @ ..] => {\n+            let crate_name = cx.sess().opts.crate_name.as_deref();\n+            if Some(base) == crate_name {\n+                return def_path_res_local(cx, path);\n+            }\n+            (base, path)\n+        },\n         _ => return Res::Err,\n     };\n     let tcx = cx.tcx;\n@@ -642,7 +648,41 @@ pub fn def_path_res(cx: &LateContext<'_>, path: &[&str], namespace_hint: Option<\n             return last;\n         }\n     }\n+    Res::Err\n+}\n \n+fn def_path_res_local(cx: &LateContext<'_>, mut path: &[&str]) -> Res {\n+    let map = cx.tcx.hir();\n+    let mut ids = map.root_module().item_ids;\n+    while let Some(&segment) = path.first() {\n+        let mut next_ids = None;\n+        for i in ids {\n+            if let Some(Node::Item(hir::Item {\n+                ident,\n+                kind,\n+                def_id: item_def_id,\n+                ..\n+            })) = map.find(i.hir_id())\n+            {\n+                if ident.name.as_str() == segment {\n+                    path = &path[1..];\n+                    if path.is_empty() {\n+                        let def_id = item_def_id.to_def_id();\n+                        return Res::Def(cx.tcx.def_kind(def_id), def_id);\n+                    }\n+                    if let ItemKind::Mod(m) = kind {\n+                        next_ids = Some(m.item_ids);\n+                    };\n+                    break;\n+                }\n+            }\n+        }\n+        if let Some(next_ids) = next_ids {\n+            ids = next_ids;\n+        } else {\n+            break;\n+        }\n+    }\n     Res::Err\n }\n "}, {"sha": "6d33e192ee893e6e4d75204a17686f471236500e", "filename": "tests/ui-toml/mut_key/clippy.toml", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a425015c07db8a68bdfc44c38601cc974fb4a4d/tests%2Fui-toml%2Fmut_key%2Fclippy.toml", "raw_url": "https://github.com/rust-lang/rust/raw/9a425015c07db8a68bdfc44c38601cc974fb4a4d/tests%2Fui-toml%2Fmut_key%2Fclippy.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Fmut_key%2Fclippy.toml?ref=9a425015c07db8a68bdfc44c38601cc974fb4a4d", "patch": "@@ -0,0 +1 @@\n+ignore-interior-mutability = [\"mut_key::Counted\"]\n\\ No newline at end of file"}, {"sha": "667c51cb4a3f348ad202c5111e1609e2565ead55", "filename": "tests/ui-toml/mut_key/mut_key.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/9a425015c07db8a68bdfc44c38601cc974fb4a4d/tests%2Fui-toml%2Fmut_key%2Fmut_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a425015c07db8a68bdfc44c38601cc974fb4a4d/tests%2Fui-toml%2Fmut_key%2Fmut_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Fmut_key%2Fmut_key.rs?ref=9a425015c07db8a68bdfc44c38601cc974fb4a4d", "patch": "@@ -0,0 +1,53 @@\n+// compile-flags: --crate-name mut_key\n+\n+#![warn(clippy::mutable_key_type)]\n+\n+use std::cmp::{Eq, PartialEq};\n+use std::collections::{HashMap, HashSet};\n+use std::hash::{Hash, Hasher};\n+use std::ops::Deref;\n+use std::sync::atomic::{AtomicUsize, Ordering};\n+\n+struct Counted<T> {\n+    count: AtomicUsize,\n+    val: T,\n+}\n+\n+impl<T: Clone> Clone for Counted<T> {\n+    fn clone(&self) -> Self {\n+        Self {\n+            count: AtomicUsize::new(0),\n+            val: self.val.clone(),\n+        }\n+    }\n+}\n+\n+impl<T: PartialEq> PartialEq for Counted<T> {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.val == other.val\n+    }\n+}\n+impl<T: PartialEq + Eq> Eq for Counted<T> {}\n+\n+impl<T: Hash> Hash for Counted<T> {\n+    fn hash<H: Hasher>(&self, state: &mut H) {\n+        self.val.hash(state);\n+    }\n+}\n+\n+impl<T> Deref for Counted<T> {\n+    type Target = T;\n+\n+    fn deref(&self) -> &T {\n+        self.count.fetch_add(1, Ordering::AcqRel);\n+        &self.val\n+    }\n+}\n+\n+// This is not linted because `\"mut_key::Counted\"` is in\n+// `arc_like_types` in `clippy.toml`\n+fn should_not_take_this_arg(_v: HashSet<Counted<String>>) {}\n+\n+fn main() {\n+    should_not_take_this_arg(HashSet::new());\n+}"}, {"sha": "b7842c36240c1d8f3377fb8bd9a97281c6c12600", "filename": "tests/ui-toml/toml_unknown_key/conf_unknown_key.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a425015c07db8a68bdfc44c38601cc974fb4a4d/tests%2Fui-toml%2Ftoml_unknown_key%2Fconf_unknown_key.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a425015c07db8a68bdfc44c38601cc974fb4a4d/tests%2Fui-toml%2Ftoml_unknown_key%2Fconf_unknown_key.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Ftoml_unknown_key%2Fconf_unknown_key.stderr?ref=9a425015c07db8a68bdfc44c38601cc974fb4a4d", "patch": "@@ -20,6 +20,7 @@ error: error reading Clippy's configuration file `$DIR/clippy.toml`: unknown fie\n            enforced-import-renames\n            enum-variant-name-threshold\n            enum-variant-size-threshold\n+           ignore-interior-mutability\n            large-error-threshold\n            literal-representation-threshold\n            matches-for-let-else"}]}