{"sha": "1b87ce0d4092045728c1c68282769d555706f273", "node_id": "C_kwDOAAsO6NoAKDFiODdjZTBkNDA5MjA0NTcyOGMxYzY4MjgyNzY5ZDU1NTcwNmYyNzM", "commit": {"author": {"name": "Ding Xiang Fei", "email": "dingxiangfei2009@protonmail.ch", "date": "2022-09-04T15:17:43Z"}, "committer": {"name": "Ding Xiang Fei", "email": "dingxiangfei2009@protonmail.ch", "date": "2022-09-15T02:07:54Z"}, "message": "reorder nesting scopes and declare bindings without drop schedule", "tree": {"sha": "4a7547387cbffe3f2bb0bf7530c02745b4b574c3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4a7547387cbffe3f2bb0bf7530c02745b4b574c3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1b87ce0d4092045728c1c68282769d555706f273", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE0u8S3YU336XkLsQOPNdIZH7vY1kFAmMiiPoACgkQPNdIZH7v\nY1kHcg/+NzeWSkjkM0P6NgtBav55UmkIXj4Ui8aJZ3ykON0J76cNr7AZMPnTM/R2\naUWblvtwCqiqKf5d79S9J9x/JNlBsKkOOceNsy77XXES6x5vBxq5GCywy/JbCOp+\n9kCxlpV2iUUvOe/s1r+oLPAheyDUFzeQ3AGqBD/XvsrTUNULXPOAY9NP6Iexdu0x\nDFyh5r/h9cgQP3/DAZWbNWBE8++ZzZKTU7RCPH6wziHHeDLuyoZwG3dFAiVw2GXw\nw5SbgAjXrrcwRiUqck8byBrV8kgLe88uHbHIwiPL29JU/5ApqoaVEGtpSLV5ltJA\nT0/dufwqNHe4pOeahAiKXfH5QE8dy8cshZNLYEDqV2di5UIIrTzRFHTL+Y2gRe/G\nxtJwyDC+ohjTn9HXCjzkFZi1TET4SNKB3bgSCjq6u3mcXZZ6ogsNfIAqwFVTwl9O\nLnvp70B08tT3qJEAFNbUFhSjdxDM3UQLLO75ohEgVmdKfy58fxoFVS183wQ5Kkgg\npPyjwtFESRN/3zXJbUlEOtnpXe9RtPdLwY36yPTs4ughLFsqubyg5X405ekqUKdm\nTi2fRXCEOwLJdbOkSUx9uTV2uYhWI/+YuKoKZE5i4SwfOiUyGRtDiV6m2L7elXyl\nmlxf4luCgueIM8FvDklJRBh5Lstb5aLF096OgsH4No+xtY9s6/A=\n=deEg\n-----END PGP SIGNATURE-----", "payload": "tree 4a7547387cbffe3f2bb0bf7530c02745b4b574c3\nparent 750bd1a7ff3e010611b97ee75d30b7cbf5f3a03c\nauthor Ding Xiang Fei <dingxiangfei2009@protonmail.ch> 1662304663 +0800\ncommitter Ding Xiang Fei <dingxiangfei2009@protonmail.ch> 1663207674 +0800\n\nreorder nesting scopes and declare bindings without drop schedule\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1b87ce0d4092045728c1c68282769d555706f273", "html_url": "https://github.com/rust-lang/rust/commit/1b87ce0d4092045728c1c68282769d555706f273", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1b87ce0d4092045728c1c68282769d555706f273/comments", "author": {"login": "dingxiangfei2009", "id": 6884440, "node_id": "MDQ6VXNlcjY4ODQ0NDA=", "avatar_url": "https://avatars.githubusercontent.com/u/6884440?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dingxiangfei2009", "html_url": "https://github.com/dingxiangfei2009", "followers_url": "https://api.github.com/users/dingxiangfei2009/followers", "following_url": "https://api.github.com/users/dingxiangfei2009/following{/other_user}", "gists_url": "https://api.github.com/users/dingxiangfei2009/gists{/gist_id}", "starred_url": "https://api.github.com/users/dingxiangfei2009/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dingxiangfei2009/subscriptions", "organizations_url": "https://api.github.com/users/dingxiangfei2009/orgs", "repos_url": "https://api.github.com/users/dingxiangfei2009/repos", "events_url": "https://api.github.com/users/dingxiangfei2009/events{/privacy}", "received_events_url": "https://api.github.com/users/dingxiangfei2009/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dingxiangfei2009", "id": 6884440, "node_id": "MDQ6VXNlcjY4ODQ0NDA=", "avatar_url": "https://avatars.githubusercontent.com/u/6884440?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dingxiangfei2009", "html_url": "https://github.com/dingxiangfei2009", "followers_url": "https://api.github.com/users/dingxiangfei2009/followers", "following_url": "https://api.github.com/users/dingxiangfei2009/following{/other_user}", "gists_url": "https://api.github.com/users/dingxiangfei2009/gists{/gist_id}", "starred_url": "https://api.github.com/users/dingxiangfei2009/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dingxiangfei2009/subscriptions", "organizations_url": "https://api.github.com/users/dingxiangfei2009/orgs", "repos_url": "https://api.github.com/users/dingxiangfei2009/repos", "events_url": "https://api.github.com/users/dingxiangfei2009/events{/privacy}", "received_events_url": "https://api.github.com/users/dingxiangfei2009/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "750bd1a7ff3e010611b97ee75d30b7cbf5f3a03c", "url": "https://api.github.com/repos/rust-lang/rust/commits/750bd1a7ff3e010611b97ee75d30b7cbf5f3a03c", "html_url": "https://github.com/rust-lang/rust/commit/750bd1a7ff3e010611b97ee75d30b7cbf5f3a03c"}], "stats": {"total": 187, "additions": 122, "deletions": 65}, "files": [{"sha": "e2cd27d03394f0c6cbe5de6e9b3ab3aa534542f4", "filename": "compiler/rustc_mir_build/src/build/block.rs", "status": "modified", "additions": 95, "deletions": 22, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/1b87ce0d4092045728c1c68282769d555706f273/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b87ce0d4092045728c1c68282769d555706f273/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs?ref=1b87ce0d4092045728c1c68282769d555706f273", "patch": "@@ -109,13 +109,99 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         )\n                     );\n                 }\n+                StmtKind::Let {\n+                    remainder_scope,\n+                    init_scope,\n+                    pattern,\n+                    initializer: Some(initializer),\n+                    lint_level,\n+                    else_block: Some(else_block),\n+                } => {\n+                    let ignores_expr_result = matches!(pattern.kind, PatKind::Wild);\n+                    this.block_context.push(BlockFrame::Statement { ignores_expr_result });\n+                    // This place is not really used because this destination place\n+                    // should never be used to take values at the end of the failure\n+                    // block.\n+                    let else_block_span = this.thir[*else_block].span;\n+                    let dummy_place = this.temp(this.tcx.types.never, else_block_span);\n+                    let failure_entry = this.cfg.start_new_block();\n+                    let failure_block;\n+                    unpack!(\n+                        failure_block = this.ast_block(\n+                            dummy_place,\n+                            failure_entry,\n+                            *else_block,\n+                            this.source_info(else_block_span),\n+                        )\n+                    );\n+                    this.cfg.terminate(\n+                        failure_block,\n+                        this.source_info(else_block_span),\n+                        TerminatorKind::Unreachable,\n+                    );\n+\n+                    // Declare the bindings, which may create a source scope.\n+                    let remainder_span = remainder_scope.span(this.tcx, this.region_scope_tree);\n+                    this.push_scope((*remainder_scope, source_info));\n+                    let_scope_stack.push(remainder_scope);\n+\n+                    let visibility_scope =\n+                        Some(this.new_source_scope(remainder_span, LintLevel::Inherited, None));\n+\n+                    let init = &this.thir[*initializer];\n+                    let initializer_span = init.span;\n+                    this.declare_bindings(\n+                        visibility_scope,\n+                        remainder_span,\n+                        pattern,\n+                        ArmHasGuard(false),\n+                        Some((None, initializer_span)),\n+                    );\n+                    this.visit_primary_bindings(\n+                        pattern,\n+                        UserTypeProjections::none(),\n+                        &mut |this, _, _, _, node, span, _, _| {\n+                            this.storage_live_binding(block, node, span, OutsideGuard, false);\n+                        },\n+                    );\n+                    let failure = unpack!(\n+                        block = this.in_opt_scope(\n+                            opt_destruction_scope.map(|de| (de, source_info)),\n+                            |this| {\n+                                let scope = (*init_scope, source_info);\n+                                this.in_scope(scope, *lint_level, |this| {\n+                                    this.ast_let_else(\n+                                        block,\n+                                        init,\n+                                        initializer_span,\n+                                        *else_block,\n+                                        &last_remainder_scope,\n+                                        pattern,\n+                                    )\n+                                })\n+                            }\n+                        )\n+                    );\n+                    this.cfg.goto(failure, source_info, failure_entry);\n+\n+                    if let Some(source_scope) = visibility_scope {\n+                        this.source_scope = source_scope;\n+                    }\n+                    last_remainder_scope = *remainder_scope;\n+                }\n+                StmtKind::Let { init_scope, initializer: None, else_block: Some(_), .. } => {\n+                    span_bug!(\n+                        init_scope.span(this.tcx, this.region_scope_tree),\n+                        \"initializer is missing, but else block is present in this let binding\",\n+                    )\n+                }\n                 StmtKind::Let {\n                     remainder_scope,\n                     init_scope,\n                     ref pattern,\n                     initializer,\n                     lint_level,\n-                    else_block,\n+                    else_block: None,\n                 } => {\n                     let ignores_expr_result = matches!(pattern.kind, PatKind::Wild);\n                     this.block_context.push(BlockFrame::Statement { ignores_expr_result });\n@@ -141,27 +227,14 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                                 |this| {\n                                     let scope = (*init_scope, source_info);\n                                     this.in_scope(scope, *lint_level, |this| {\n-                                        if let Some(else_block) = else_block {\n-                                            this.ast_let_else(\n-                                                block,\n-                                                init,\n-                                                initializer_span,\n-                                                *else_block,\n-                                                visibility_scope,\n-                                                last_remainder_scope,\n-                                                remainder_span,\n-                                                pattern,\n-                                            )\n-                                        } else {\n-                                            this.declare_bindings(\n-                                                visibility_scope,\n-                                                remainder_span,\n-                                                pattern,\n-                                                ArmHasGuard(false),\n-                                                Some((None, initializer_span)),\n-                                            );\n-                                            this.expr_into_pattern(block, pattern, init) // irrefutable pattern\n-                                        }\n+                                        this.declare_bindings(\n+                                            visibility_scope,\n+                                            remainder_span,\n+                                            pattern,\n+                                            ArmHasGuard(false),\n+                                            Some((None, initializer_span)),\n+                                        );\n+                                        this.expr_into_pattern(block, &pattern, init) // irrefutable pattern\n                                     })\n                                 },\n                             )"}, {"sha": "e0727725f68d5a92524cf01a57d101716a3d051b", "filename": "compiler/rustc_mir_build/src/build/matches/mod.rs", "status": "modified", "additions": 6, "deletions": 34, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/1b87ce0d4092045728c1c68282769d555706f273/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b87ce0d4092045728c1c68282769d555706f273/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs?ref=1b87ce0d4092045728c1c68282769d555706f273", "patch": "@@ -699,7 +699,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         self.cfg.push(block, Statement { source_info, kind: StatementKind::StorageLive(local_id) });\n         // Although there is almost always scope for given variable in corner cases\n         // like #92893 we might get variable with no scope.\n-        if let Some(region_scope) = self.region_scope_tree.var_scope(var.0.local_id) && schedule_drop{\n+        if let Some(region_scope) = self.region_scope_tree.var_scope(var.0.local_id) && schedule_drop {\n             self.schedule_drop(span, region_scope, local_id, DropKind::Storage);\n         }\n         Place::from(local_id)\n@@ -2274,23 +2274,14 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         init: &Expr<'tcx>,\n         initializer_span: Span,\n         else_block: BlockId,\n-        visibility_scope: Option<SourceScope>,\n-        remainder_scope: region::Scope,\n-        remainder_span: Span,\n+        let_else_scope: &region::Scope,\n         pattern: &Pat<'tcx>,\n-    ) -> BlockAnd<()> {\n+    ) -> BlockAnd<BasicBlock> {\n         let else_block_span = self.thir[else_block].span;\n-        let (matching, failure) = self.in_if_then_scope(remainder_scope, |this| {\n+        let (matching, failure) = self.in_if_then_scope(*let_else_scope, |this| {\n             let scrutinee = unpack!(block = this.lower_scrutinee(block, init, initializer_span));\n             let pat = Pat { ty: init.ty, span: else_block_span, kind: PatKind::Wild };\n             let mut wildcard = Candidate::new(scrutinee.clone(), &pat, false);\n-            this.declare_bindings(\n-                visibility_scope,\n-                remainder_span,\n-                pattern,\n-                ArmHasGuard(false),\n-                Some((None, initializer_span)),\n-            );\n             let mut candidate = Candidate::new(scrutinee.clone(), pattern, false);\n             let fake_borrow_temps = this.lower_match_tree(\n                 block,\n@@ -2321,28 +2312,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 None,\n                 None,\n             );\n-            this.break_for_else(failure, remainder_scope, this.source_info(initializer_span));\n+            this.break_for_else(failure, *let_else_scope, this.source_info(initializer_span));\n             matching.unit()\n         });\n-\n-        // This place is not really used because this destination place\n-        // should never be used to take values at the end of the failure\n-        // block.\n-        let dummy_place = self.temp(self.tcx.types.never, else_block_span);\n-        let failure_block;\n-        unpack!(\n-            failure_block = self.ast_block(\n-                dummy_place,\n-                failure,\n-                else_block,\n-                self.source_info(else_block_span),\n-            )\n-        );\n-        self.cfg.terminate(\n-            failure_block,\n-            self.source_info(else_block_span),\n-            TerminatorKind::Unreachable,\n-        );\n-        matching.unit()\n+        matching.and(failure)\n     }\n }"}, {"sha": "594a7e450b8e52abd3324428cbb50eb3d5f04f1a", "filename": "compiler/rustc_typeck/src/check/region.rs", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/1b87ce0d4092045728c1c68282769d555706f273/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b87ce0d4092045728c1c68282769d555706f273/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregion.rs?ref=1b87ce0d4092045728c1c68282769d555706f273", "patch": "@@ -126,6 +126,20 @@ fn resolve_block<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, blk: &'tcx h\n \n         for (i, statement) in blk.stmts.iter().enumerate() {\n             match statement.kind {\n+                hir::StmtKind::Local(hir::Local { els: Some(els), .. }) => {\n+                    // Let-else has a special lexical structure for variables.\n+                    let mut prev_cx = visitor.cx;\n+                    visitor.enter_scope(Scope {\n+                        id: blk.hir_id.local_id,\n+                        data: ScopeData::Remainder(FirstStatementIndex::new(i)),\n+                    });\n+                    visitor.cx.var_parent = visitor.cx.parent;\n+                    visitor.visit_stmt(statement);\n+                    mem::swap(&mut prev_cx, &mut visitor.cx);\n+                    // We need to back out temporarily and\n+                    visitor.visit_block(els);\n+                    visitor.cx = prev_cx;\n+                }\n                 hir::StmtKind::Local(..) | hir::StmtKind::Item(..) => {\n                     // Each declaration introduces a subscope for bindings\n                     // introduced by the declaration; this subscope covers a\n@@ -138,10 +152,10 @@ fn resolve_block<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, blk: &'tcx h\n                         data: ScopeData::Remainder(FirstStatementIndex::new(i)),\n                     });\n                     visitor.cx.var_parent = visitor.cx.parent;\n+                    visitor.visit_stmt(statement)\n                 }\n-                hir::StmtKind::Expr(..) | hir::StmtKind::Semi(..) => {}\n+                hir::StmtKind::Expr(..) | hir::StmtKind::Semi(..) => visitor.visit_stmt(statement),\n             }\n-            visitor.visit_stmt(statement)\n         }\n         walk_list!(visitor, visit_expr, &blk.expr);\n     }\n@@ -460,7 +474,6 @@ fn resolve_local<'tcx>(\n     visitor: &mut RegionResolutionVisitor<'tcx>,\n     pat: Option<&'tcx hir::Pat<'tcx>>,\n     init: Option<&'tcx hir::Expr<'tcx>>,\n-    els: Option<&'tcx hir::Block<'tcx>>,\n ) {\n     debug!(\"resolve_local(pat={:?}, init={:?})\", pat, init);\n \n@@ -547,9 +560,6 @@ fn resolve_local<'tcx>(\n     if let Some(pat) = pat {\n         visitor.visit_pat(pat);\n     }\n-    if let Some(els) = els {\n-        visitor.visit_block(els);\n-    }\n \n     /// Returns `true` if `pat` match the `P&` non-terminal.\n     ///\n@@ -766,7 +776,7 @@ impl<'tcx> Visitor<'tcx> for RegionResolutionVisitor<'tcx> {\n             // (i.e., `'static`), which means that after `g` returns, it drops,\n             // and all the associated destruction scope rules apply.\n             self.cx.var_parent = None;\n-            resolve_local(self, None, Some(&body.value), None);\n+            resolve_local(self, None, Some(&body.value));\n         }\n \n         if body.generator_kind.is_some() {\n@@ -793,7 +803,7 @@ impl<'tcx> Visitor<'tcx> for RegionResolutionVisitor<'tcx> {\n         resolve_expr(self, ex);\n     }\n     fn visit_local(&mut self, l: &'tcx Local<'tcx>) {\n-        resolve_local(self, Some(&l.pat), l.init, l.els)\n+        resolve_local(self, Some(&l.pat), l.init)\n     }\n }\n "}, {"sha": "0058f7016dcfa0729bf7349bece6bb0859accb77", "filename": "src/test/ui/async-await/async-await-let-else.no-drop-tracking.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1b87ce0d4092045728c1c68282769d555706f273/src%2Ftest%2Fui%2Fasync-await%2Fasync-await-let-else.no-drop-tracking.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1b87ce0d4092045728c1c68282769d555706f273/src%2Ftest%2Fui%2Fasync-await%2Fasync-await-let-else.no-drop-tracking.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-await-let-else.no-drop-tracking.stderr?ref=1b87ce0d4092045728c1c68282769d555706f273", "patch": "@@ -35,7 +35,8 @@ LL |         bar2(Rc::new(())).await\n    |              |\n    |              has type `Rc<()>` which is not `Send`\n LL |     };\n-   |      - `Rc::new(())` is later dropped here\n+LL | }\n+   | - `Rc::new(())` is later dropped here\n note: required by a bound in `is_send`\n   --> $DIR/async-await-let-else.rs:19:15\n    |"}, {"sha": "8542c3496b045f5eb8682fce59884274bdcf9560", "filename": "src/test/ui/let-else/let-else-temporary-lifetime.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1b87ce0d4092045728c1c68282769d555706f273/src%2Ftest%2Fui%2Flet-else%2Flet-else-temporary-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b87ce0d4092045728c1c68282769d555706f273/src%2Ftest%2Fui%2Flet-else%2Flet-else-temporary-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flet-else%2Flet-else-temporary-lifetime.rs?ref=1b87ce0d4092045728c1c68282769d555706f273", "patch": "@@ -1,4 +1,5 @@\n // run-pass\n+// compile-flags: -Zvalidate-mir\n #![feature(let_else)]\n \n use std::fmt::Display;"}]}