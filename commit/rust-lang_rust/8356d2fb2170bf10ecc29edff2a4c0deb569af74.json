{"sha": "8356d2fb2170bf10ecc29edff2a4c0deb569af74", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgzNTZkMmZiMjE3MGJmMTBlY2MyOWVkZmYyYTRjMGRlYjU2OWFmNzQ=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-06-08T15:43:27Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-06-16T10:17:15Z"}, "message": "lint items whose name starts/ends with their enclosing module's name", "tree": {"sha": "7587c1a0d30b7617ce5aed6b0338ad2e6f7fed67", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7587c1a0d30b7617ce5aed6b0338ad2e6f7fed67"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8356d2fb2170bf10ecc29edff2a4c0deb569af74", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1\n\niQIcBAABAgAGBQJXYnysAAoJEFbW7qD8Z6xGj5oQAJfCw8zXO1ecZofpJhFnUNCS\noMrQMQWHooXSuQ2XWGUYFcg/qtHDRA9Z2sRiF7PDbcTWNjNZ96PGqQv3VRJcnChE\nK5M+Bs6iNeIuaXRGZ0FVFVNDDUMvDrT0jRzg8iRkX30G2MPo21XYEeHmhMPrl6cE\nh1XqjhV/ANzQ4AOedZniD/QOjmeKkRAnmFwGtV9wJoODodJKKMNId/hFAjNqKu2U\nsu3P4r7XNtBWf1ibw2vkNf8X3gFsM7+L9D1yfxLo2N9FcIyNsZpKgp5HFcygcgH6\nB4EMGys2WF3w8tUI0swR+PTJCUs7T840ao7Elf2p6g6k9EpH7qD5EvmIUvnr9rLa\nCvJDH6KnatBvb69/oTK+bMjLgnJNq3UPwu/OmUlGUPmmSVG/VE4S9yo3S3a8KQ8/\nH0h0qMTTVE0PnJxrM0xaUCCF7SCDnkVdfh3Q//01++PZmj4uFGJX4ZawR4lgnV8f\n+7ap0esR4IXks6Q7x/e5Z+Z63eHMDnQlJMe8/N4hVm7yIw3U+eDU21DHXxzWWDaf\nQbuxYMqdToJ9Zs0BWOSE8uinSLNWtnSLNdtOv6ZTqyKxz2Y8pmFN4nMairCJ0ntE\nc1s3k9h0RRHw6D70KpcynPfBcURB5GNBZpjvcSndIUbyLd/EqVwPIOQqbJnY08eE\nWF5QU06+OIwtL1Xm7W+f\n=jYMn\n-----END PGP SIGNATURE-----", "payload": "tree 7587c1a0d30b7617ce5aed6b0338ad2e6f7fed67\nparent 32894d503e720130cc6fd0fa193afa2d9f7d4431\nauthor Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1465400607 +0200\ncommitter Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1466072235 +0200\n\nlint items whose name starts/ends with their enclosing module's name"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8356d2fb2170bf10ecc29edff2a4c0deb569af74", "html_url": "https://github.com/rust-lang/rust/commit/8356d2fb2170bf10ecc29edff2a4c0deb569af74", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8356d2fb2170bf10ecc29edff2a4c0deb569af74/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "32894d503e720130cc6fd0fa193afa2d9f7d4431", "url": "https://api.github.com/repos/rust-lang/rust/commits/32894d503e720130cc6fd0fa193afa2d9f7d4431", "html_url": "https://github.com/rust-lang/rust/commit/32894d503e720130cc6fd0fa193afa2d9f7d4431"}], "stats": {"total": 159, "additions": 105, "deletions": 54}, "files": [{"sha": "5ef507e2786bf2d6228dd245edf56c8040e0d562", "filename": "clippy_lints/src/enum_variants.rs", "status": "modified", "additions": 105, "deletions": 54, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/8356d2fb2170bf10ecc29edff2a4c0deb569af74/clippy_lints%2Fsrc%2Fenum_variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8356d2fb2170bf10ecc29edff2a4c0deb569af74/clippy_lints%2Fsrc%2Fenum_variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fenum_variants.rs?ref=8356d2fb2170bf10ecc29edff2a4c0deb569af74", "patch": "@@ -2,9 +2,10 @@\n \n use rustc::lint::*;\n use syntax::ast::*;\n+use syntax::codemap::Span;\n use syntax::parse::token::InternedString;\n use utils::{span_help_and_lint, span_lint};\n-use utils::{camel_case_from, camel_case_until};\n+use utils::{camel_case_from, camel_case_until, in_macro};\n \n /// **What it does:** Warns on enum variants that are prefixed or suffixed by the same characters\n ///\n@@ -18,7 +19,10 @@ declare_lint! {\n     \"finds enums where all variants share a prefix/postfix\"\n }\n \n-pub struct EnumVariantNames;\n+#[derive(Default)]\n+pub struct EnumVariantNames {\n+    modules: Vec<String>,\n+}\n \n impl LintPass for EnumVariantNames {\n     fn get_lints(&self) -> LintArray {\n@@ -44,65 +48,112 @@ fn partial_rmatch(post: &str, name: &str) -> usize {\n     post.chars().rev().zip(name_iter.rev()).take_while(|&(l, r)| l == r).count()\n }\n \n+// FIXME: #600\n+#[allow(while_let_on_iterator)]\n+fn check_variant(cx: &EarlyContext, def: &EnumDef, item_name: &str, item_name_chars: usize, span: Span) {\n+    for var in &def.variants {\n+        let name = var2str(var);\n+        if partial_match(item_name, &name) == item_name_chars {\n+            span_lint(cx, ENUM_VARIANT_NAMES, var.span, \"Variant name starts with the enum's name\");\n+        }\n+        if partial_rmatch(item_name, &name) == item_name_chars {\n+            span_lint(cx, ENUM_VARIANT_NAMES, var.span, \"Variant name ends with the enum's name\");\n+        }\n+    }\n+    if def.variants.len() < 2 {\n+        return;\n+    }\n+    let first = var2str(&def.variants[0]);\n+    let mut pre = &first[..camel_case_until(&*first)];\n+    let mut post = &first[camel_case_from(&*first)..];\n+    for var in &def.variants {\n+        let name = var2str(var);\n+\n+        let pre_match = partial_match(pre, &name);\n+        pre = &pre[..pre_match];\n+        let pre_camel = camel_case_until(pre);\n+        pre = &pre[..pre_camel];\n+        while let Some((next, last)) = name[pre.len()..].chars().zip(pre.chars().rev()).next() {\n+            if next.is_lowercase() {\n+                let last = pre.len() - last.len_utf8();\n+                let last_camel = camel_case_until(&pre[..last]);\n+                pre = &pre[..last_camel];\n+            } else {\n+                break;\n+            }\n+        }\n+\n+        let post_match = partial_rmatch(post, &name);\n+        let post_end = post.len() - post_match;\n+        post = &post[post_end..];\n+        let post_camel = camel_case_from(post);\n+        post = &post[post_camel..];\n+    }\n+    let (what, value) = match (pre.is_empty(), post.is_empty()) {\n+        (true, true) => return,\n+        (false, _) => (\"pre\", pre),\n+        (true, false) => (\"post\", post),\n+    };\n+    span_help_and_lint(cx,\n+                       ENUM_VARIANT_NAMES,\n+                       span,\n+                       &format!(\"All variants have the same {}fix: `{}`\", what, value),\n+                       &format!(\"remove the {}fixes and use full paths to \\\n+                                 the variants instead of glob imports\",\n+                                what));\n+}\n+\n+fn to_camel_case(item_name: &str) -> String {\n+    let mut s = String::new();\n+    let mut up = true;\n+    for c in item_name.chars() {\n+        if c.is_uppercase() {\n+            // we only turn snake case text into CamelCase\n+            return item_name.to_string();\n+        }\n+        if c == '_' {\n+            up = true;\n+            continue;\n+        }\n+        if up {\n+            up = false;\n+            s.extend(c.to_uppercase());\n+        } else {\n+            s.push(c);\n+        }\n+    }\n+    s\n+}\n+\n impl EarlyLintPass for EnumVariantNames {\n-    // FIXME: #600\n-    #[allow(while_let_on_iterator)]\n+    fn check_item_post(&mut self, _cx: &EarlyContext, _item: &Item) {\n+        let last = self.modules.pop();\n+        assert!(last.is_some());\n+    }\n+\n     fn check_item(&mut self, cx: &EarlyContext, item: &Item) {\n         let item_name = item.ident.name.as_str();\n         let item_name_chars = item_name.chars().count();\n-        if let ItemKind::Enum(ref def, _) = item.node {\n-            for var in &def.variants {\n-                let name = var2str(var);\n-                let matching = partial_match(&item_name, &name);\n-                let rmatching = partial_rmatch(&item_name, &name);\n-                if matching == item_name_chars {\n-                    span_lint(cx, ENUM_VARIANT_NAMES, var.span, \"Variant name starts with the enum's name\");\n-                }\n-                if rmatching == item_name_chars {\n-                    span_lint(cx, ENUM_VARIANT_NAMES, var.span, \"Variant name ends with the enum's name\");\n-                }\n-            }\n-            if def.variants.len() < 2 {\n-                return;\n-            }\n-            let first = var2str(&def.variants[0]);\n-            let mut pre = &first[..camel_case_until(&*first)];\n-            let mut post = &first[camel_case_from(&*first)..];\n-            for var in &def.variants {\n-                let name = var2str(var);\n-\n-                let pre_match = partial_match(pre, &name);\n-                pre = &pre[..pre_match];\n-                let pre_camel = camel_case_until(pre);\n-                pre = &pre[..pre_camel];\n-                while let Some((next, last)) = name[pre.len()..].chars().zip(pre.chars().rev()).next() {\n-                    if next.is_lowercase() {\n-                        let last = pre.len() - last.len_utf8();\n-                        let last_camel = camel_case_until(&pre[..last]);\n-                        pre = &pre[..last_camel];\n-                    } else {\n-                        break;\n+        let item_camel = to_camel_case(&item_name);\n+        if !in_macro(cx, item.span) {\n+            if let Some(mod_camel) = self.modules.last() {\n+                // constants don't have surrounding modules\n+                if !mod_camel.is_empty() {\n+                    let matching = partial_match(mod_camel, &item_camel);\n+                    let rmatching = partial_rmatch(mod_camel, &item_camel);\n+                    let nchars = mod_camel.chars().count();\n+                    if matching == nchars {\n+                        span_lint(cx, ENUM_VARIANT_NAMES, item.span, &format!(\"Item name ({}) starts with its containing module's name ({})\", item_camel, mod_camel));\n+                    }\n+                    if rmatching == nchars {\n+                        span_lint(cx, ENUM_VARIANT_NAMES, item.span, &format!(\"Item name ({}) ends with its containing module's name ({})\", item_camel, mod_camel));\n                     }\n                 }\n-\n-                let post_match = partial_rmatch(post, &name);\n-                let post_end = post.len() - post_match;\n-                post = &post[post_end..];\n-                let post_camel = camel_case_from(post);\n-                post = &post[post_camel..];\n             }\n-            let (what, value) = match (pre.is_empty(), post.is_empty()) {\n-                (true, true) => return,\n-                (false, _) => (\"pre\", pre),\n-                (true, false) => (\"post\", post),\n-            };\n-            span_help_and_lint(cx,\n-                               ENUM_VARIANT_NAMES,\n-                               item.span,\n-                               &format!(\"All variants have the same {}fix: `{}`\", what, value),\n-                               &format!(\"remove the {}fixes and use full paths to \\\n-                                         the variants instead of glob imports\",\n-                                        what));\n         }\n+        if let ItemKind::Enum(ref def, _) = item.node {\n+            check_variant(cx, def, &item_name, item_name_chars, item.span);\n+        }\n+        self.modules.push(item_camel);\n     }\n }"}]}