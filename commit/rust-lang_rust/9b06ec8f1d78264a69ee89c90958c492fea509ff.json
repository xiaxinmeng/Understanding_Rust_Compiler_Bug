{"sha": "9b06ec8f1d78264a69ee89c90958c492fea509ff", "node_id": "MDY6Q29tbWl0NzI0NzEyOjliMDZlYzhmMWQ3ODI2NGE2OWVlODljOTA5NThjNDkyZmVhNTA5ZmY=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2018-07-30T12:36:32Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2018-07-30T12:36:32Z"}, "message": "Implement intrinsic discriminant_value and fix bug in discriminant reading", "tree": {"sha": "8ccfc8eee2f3d9230090828adcd25f491185ac67", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8ccfc8eee2f3d9230090828adcd25f491185ac67"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9b06ec8f1d78264a69ee89c90958c492fea509ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9b06ec8f1d78264a69ee89c90958c492fea509ff", "html_url": "https://github.com/rust-lang/rust/commit/9b06ec8f1d78264a69ee89c90958c492fea509ff", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9b06ec8f1d78264a69ee89c90958c492fea509ff/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "812fd6dacaf070859e7adf96a0371ba8b01f6953", "url": "https://api.github.com/repos/rust-lang/rust/commits/812fd6dacaf070859e7adf96a0371ba8b01f6953", "html_url": "https://github.com/rust-lang/rust/commit/812fd6dacaf070859e7adf96a0371ba8b01f6953"}], "stats": {"total": 129, "additions": 69, "deletions": 60}, "files": [{"sha": "6e1c81e7bf1b95f152e24ca465cb1ee3606cf430", "filename": "src/abi.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9b06ec8f1d78264a69ee89c90958c492fea509ff/src%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b06ec8f1d78264a69ee89c90958c492fea509ff/src%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi.rs?ref=9b06ec8f1d78264a69ee89c90958c492fea509ff", "patch": "@@ -263,6 +263,12 @@ pub fn codegen_call<'a, 'tcx: 'a>(\n                     let count = args[2];*/\n                     unimplemented!(\"copy\");\n                 }\n+                \"discriminant_value\" => {\n+                    assert_eq!(args.len(), 1);\n+                    let discr = ::base::trans_get_discriminant(fx, args[0], ret.layout());\n+                    ret.write_cvalue(fx, discr);\n+                    unimplemented!(\"discriminant\");\n+                }\n                 \"size_of\" => {\n                     assert_eq!(args.len(), 0);\n                     let size_of = fx.layout_of(substs.type_at(0)).size.bytes();"}, {"sha": "641cead4f3268828c61393a4afce594289323799", "filename": "src/base.rs", "status": "modified", "additions": 63, "deletions": 60, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/9b06ec8f1d78264a69ee89c90958c492fea509ff/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b06ec8f1d78264a69ee89c90958c492fea509ff/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=9b06ec8f1d78264a69ee89c90958c492fea509ff", "patch": "@@ -11,7 +11,7 @@ pub fn trans_mono_item<'a, 'tcx: 'a>(cx: &mut CodegenCx<'a, 'tcx, CurrentBackend\n             } => {\n                 let mut mir = ::std::io::Cursor::new(Vec::new());\n                 ::rustc_mir::util::write_mir_pretty(tcx, Some(def_id), &mut mir).unwrap();\n-                tcx.sess.warn(&format!(\"{:?}:\\n\\n{}\", def_id, String::from_utf8_lossy(&mir.into_inner())));\n+                tcx.sess.warn(&format!(\"{:?}:\\n\\n{}\", inst, String::from_utf8_lossy(&mir.into_inner())));\n \n                 let fn_ty = inst.ty(tcx);\n                 let fn_ty = tcx.subst_and_normalize_erasing_regions(\n@@ -334,65 +334,9 @@ fn trans_stmt<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, cur_ebb: Ebb, stmt: &\n                 Rvalue::Cast(CastKind::ClosureFnPointer, operand, ty) => unimplemented!(\"rval closure_fn_ptr {:?} {:?}\", operand, ty),\n                 Rvalue::Cast(CastKind::Unsize, operand, ty) => return Err(format!(\"rval unsize {:?} {:?}\", operand, ty)),\n                 Rvalue::Discriminant(place) => {\n-                    let place = trans_place(fx, place);\n-                    let dest_cton_ty = fx.cton_type(dest_layout.ty).unwrap();\n-                    let layout = lval.layout();\n-\n-                    if layout.abi == layout::Abi::Uninhabited {\n-                        fx.bcx.ins().trap(TrapCode::User(!0));\n-                    }\n-                    match layout.variants {\n-                        layout::Variants::Single { index } => {\n-                            let discr_val = layout.ty.ty_adt_def().map_or(\n-                                index as u128,\n-                                |def| def.discriminant_for_variant(fx.tcx, index).val);\n-                            let val = CValue::const_val(fx, dest_layout.ty, discr_val as u64 as i64);\n-                            lval.write_cvalue(fx, val);\n-                            return Ok(());\n-                        }\n-                        layout::Variants::Tagged { .. } |\n-                        layout::Variants::NicheFilling { .. } => {},\n-                    }\n-\n-                    let discr = place.to_cvalue(fx).value_field(fx, mir::Field::new(0));\n-                    let discr_ty = discr.layout().ty;\n-                    let lldiscr = discr.load_value(fx);\n-                    match layout.variants {\n-                        layout::Variants::Single { .. } => bug!(),\n-                        layout::Variants::Tagged { ref tag, .. } => {\n-                            let signed = match tag.value {\n-                                layout::Int(_, signed) => signed,\n-                                _ => false\n-                            };\n-                            let val = cton_intcast(fx, lldiscr, discr_ty, dest_layout.ty, signed);\n-                            lval.write_cvalue(fx, CValue::ByVal(val, dest_layout));\n-                        }\n-                        layout::Variants::NicheFilling {\n-                            dataful_variant,\n-                            ref niche_variants,\n-                            niche_start,\n-                            ..\n-                        } => {\n-                            let niche_llty = fx.cton_type(discr_ty).unwrap();\n-                            if niche_variants.start() == niche_variants.end() {\n-                                let b = fx.bcx.ins().icmp_imm(IntCC::Equal, lldiscr, niche_start as u64 as i64);\n-                                let if_true = fx.bcx.ins().iconst(dest_cton_ty, *niche_variants.start() as u64 as i64);\n-                                let if_false = fx.bcx.ins().iconst(dest_cton_ty, dataful_variant as u64 as i64);\n-                                let val = fx.bcx.ins().select(b, if_true, if_false);\n-                                lval.write_cvalue(fx, CValue::ByVal(val, dest_layout));\n-                            } else {\n-                                // Rebase from niche values to discriminant values.\n-                                let delta = niche_start.wrapping_sub(*niche_variants.start() as u128);\n-                                let delta = fx.bcx.ins().iconst(niche_llty, delta as u64 as i64);\n-                                let lldiscr = fx.bcx.ins().isub(lldiscr, delta);\n-                                let b = fx.bcx.ins().icmp_imm(IntCC::UnsignedLessThanOrEqual, lldiscr, *niche_variants.end() as u64 as i64);\n-                                let if_true = cton_intcast(fx, lldiscr, discr_ty, dest_layout.ty, false);\n-                                let if_false = fx.bcx.ins().iconst(niche_llty, dataful_variant as u64 as i64);\n-                                let val = fx.bcx.ins().select(b, if_true, if_false);\n-                                lval.write_cvalue(fx, CValue::ByVal(val, dest_layout));\n-                            }\n-                        }\n-                    }\n+                    let place = trans_place(fx, place).to_cvalue(fx);\n+                    let discr = trans_get_discriminant(fx, place, dest_layout);\n+                    lval.write_cvalue(fx, discr);\n                 }\n                 Rvalue::Repeat(operand, times) => unimplemented!(\"rval repeat {:?} {:?}\", operand, times),\n                 Rvalue::Len(lval) => return Err(format!(\"rval len {:?}\", lval)),\n@@ -408,6 +352,65 @@ fn trans_stmt<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, cur_ebb: Ebb, stmt: &\n     Ok(())\n }\n \n+pub fn trans_get_discriminant<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, value: CValue<'tcx>, dest_layout: TyLayout<'tcx>) -> CValue<'tcx> {\n+    let layout = value.layout();\n+\n+    if layout.abi == layout::Abi::Uninhabited {\n+        fx.bcx.ins().trap(TrapCode::User(!0));\n+    }\n+    match layout.variants {\n+        layout::Variants::Single { index } => {\n+            let discr_val = layout.ty.ty_adt_def().map_or(\n+                index as u128,\n+                |def| def.discriminant_for_variant(fx.tcx, index).val);\n+            return CValue::const_val(fx, dest_layout.ty, discr_val as u64 as i64);\n+        }\n+        layout::Variants::Tagged { .. } |\n+        layout::Variants::NicheFilling { .. } => {},\n+    }\n+\n+    let discr = value.value_field(fx, mir::Field::new(0));\n+    let discr_ty = discr.layout().ty;\n+    let lldiscr = discr.load_value(fx);\n+    match layout.variants {\n+        layout::Variants::Single { .. } => bug!(),\n+        layout::Variants::Tagged { ref tag, .. } => {\n+            let signed = match tag.value {\n+                layout::Int(_, signed) => signed,\n+                _ => false\n+            };\n+            let val = cton_intcast(fx, lldiscr, discr_ty, dest_layout.ty, signed);\n+            return CValue::ByVal(val, dest_layout);\n+        }\n+        layout::Variants::NicheFilling {\n+            dataful_variant,\n+            ref niche_variants,\n+            niche_start,\n+            ..\n+        } => {\n+            let niche_llty = fx.cton_type(discr_ty).unwrap();\n+            if niche_variants.start() == niche_variants.end() {\n+                let dest_cton_ty = fx.cton_type(dest_layout.ty).unwrap();\n+                let b = fx.bcx.ins().icmp_imm(IntCC::Equal, lldiscr, niche_start as u64 as i64);\n+                let if_true = fx.bcx.ins().iconst(dest_cton_ty, *niche_variants.start() as u64 as i64);\n+                let if_false = fx.bcx.ins().iconst(dest_cton_ty, dataful_variant as u64 as i64);\n+                let val = fx.bcx.ins().select(b, if_true, if_false);\n+                return CValue::ByVal(val, dest_layout);\n+            } else {\n+                // Rebase from niche values to discriminant values.\n+                let delta = niche_start.wrapping_sub(*niche_variants.start() as u128);\n+                let delta = fx.bcx.ins().iconst(niche_llty, delta as u64 as i64);\n+                let lldiscr = fx.bcx.ins().isub(lldiscr, delta);\n+                let b = fx.bcx.ins().icmp_imm(IntCC::UnsignedLessThanOrEqual, lldiscr, *niche_variants.end() as u64 as i64);\n+                let if_true = cton_intcast(fx, lldiscr, discr_ty, dest_layout.ty, false);\n+                let if_false = fx.bcx.ins().iconst(niche_llty, dataful_variant as u64 as i64);\n+                let val = fx.bcx.ins().select(b, if_true, if_false);\n+                return CValue::ByVal(val, dest_layout);\n+            }\n+        }\n+    }\n+}\n+\n macro_rules! binop_match {\n     (@single $fx:expr, $bug_fmt:expr, $var:expr, $lhs:expr, $rhs:expr, bug) => {\n         bug!(\"bin op {} on {} lhs: {:?} rhs: {:?}\", stringify!($var), $bug_fmt, $lhs, $rhs)"}]}