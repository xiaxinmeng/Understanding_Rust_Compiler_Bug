{"sha": "1141d448d960eedba0a5647d525910de706bf778", "node_id": "MDY6Q29tbWl0NzI0NzEyOjExNDFkNDQ4ZDk2MGVlZGJhMGE1NjQ3ZDUyNTkxMGRlNzA2YmY3Nzg=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-08-14T10:33:44Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-08-14T10:33:44Z"}, "message": "Add derive intention", "tree": {"sha": "144842663edc382addc6b2cb115717d5bb7eb736", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/144842663edc382addc6b2cb115717d5bb7eb736"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1141d448d960eedba0a5647d525910de706bf778", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1141d448d960eedba0a5647d525910de706bf778", "html_url": "https://github.com/rust-lang/rust/commit/1141d448d960eedba0a5647d525910de706bf778", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1141d448d960eedba0a5647d525910de706bf778/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5953a348bd6102a868f303d3f732a6ec7d465833", "url": "https://api.github.com/repos/rust-lang/rust/commits/5953a348bd6102a868f303d3f732a6ec7d465833", "html_url": "https://github.com/rust-lang/rust/commit/5953a348bd6102a868f303d3f732a6ec7d465833"}], "stats": {"total": 301, "additions": 114, "deletions": 187}, "files": [{"sha": "6e2c73f293e6dfd7550db04a9bc8349c6a26c348", "filename": "crates/libeditor/src/code_actions.rs", "status": "modified", "additions": 25, "deletions": 2, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/1141d448d960eedba0a5647d525910de706bf778/crates%2Flibeditor%2Fsrc%2Fcode_actions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1141d448d960eedba0a5647d525910de706bf778/crates%2Flibeditor%2Fsrc%2Fcode_actions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibeditor%2Fsrc%2Fcode_actions.rs?ref=1141d448d960eedba0a5647d525910de706bf778", "patch": "@@ -1,11 +1,12 @@\n use {TextUnit, File, EditBuilder, Edit};\n use libsyntax2::{\n-    ast::AstNode,\n+    ast::{self, AstNode},\n     SyntaxKind::COMMA,\n     SyntaxNodeRef,\n+    SyntaxRoot,\n     algo::{\n         Direction, siblings,\n-        find_leaf_at_offset,\n+        find_leaf_at_offset, ancestors,\n     },\n };\n \n@@ -24,10 +25,32 @@ pub fn flip_comma<'a>(file: &'a File, offset: TextUnit) -> Option<impl FnOnce()\n     })\n }\n \n+pub fn add_derive<'a>(file: &'a File, offset: TextUnit) -> Option<impl FnOnce() -> Edit + 'a> {\n+    let syntax = file.syntax();\n+    let syntax = syntax.as_ref();\n+    let nominal = find_node::<ast::NominalDef<_>>(syntax, offset)?;\n+    Some(move || {\n+        let mut edit = EditBuilder::new();\n+        edit.insert(nominal.syntax().range().start(), \"#[derive()]\\n\".to_string());\n+        edit.finish()\n+    })\n+}\n+\n fn non_trivia_sibling(node: SyntaxNodeRef, direction: Direction) -> Option<SyntaxNodeRef> {\n     siblings(node, direction)\n         .skip(1)\n         .find(|node| !node.kind().is_trivia())\n }\n \n+fn find_non_trivia_leaf(syntax: SyntaxNodeRef, offset: TextUnit) -> Option<SyntaxNodeRef> {\n+    find_leaf_at_offset(syntax, offset)\n+        .find(|leaf| !leaf.kind().is_trivia())\n+}\n+\n+fn find_node<'a, N: AstNode<&'a SyntaxRoot>>(syntax: SyntaxNodeRef<'a>, offset: TextUnit) -> Option<N> {\n+    let leaf = find_non_trivia_leaf(syntax, offset)?;\n+    ancestors(leaf)\n+        .filter_map(N::cast)\n+        .next()\n+}\n "}, {"sha": "2c46ca45f0050a5241126c7caecc5b5f8409de73", "filename": "crates/libeditor/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1141d448d960eedba0a5647d525910de706bf778/crates%2Flibeditor%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1141d448d960eedba0a5647d525910de706bf778/crates%2Flibeditor%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibeditor%2Fsrc%2Flib.rs?ref=1141d448d960eedba0a5647d525910de706bf778", "patch": "@@ -21,7 +21,7 @@ pub use self::{\n     extend_selection::extend_selection,\n     symbols::{StructureNode, file_structure, FileSymbol, file_symbols},\n     edit::{EditBuilder, Edit, AtomEdit},\n-    code_actions::{flip_comma},\n+    code_actions::{flip_comma, add_derive},\n };\n \n #[derive(Debug)]"}, {"sha": "46404f537678f69584d09d93f438c7c16abae9a7", "filename": "crates/libsyntax2/src/algo/search.rs", "status": "removed", "additions": 0, "deletions": 136, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/5953a348bd6102a868f303d3f732a6ec7d465833/crates%2Flibsyntax2%2Fsrc%2Falgo%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5953a348bd6102a868f303d3f732a6ec7d465833/crates%2Flibsyntax2%2Fsrc%2Falgo%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibsyntax2%2Fsrc%2Falgo%2Fsearch.rs?ref=5953a348bd6102a868f303d3f732a6ec7d465833", "patch": "@@ -1,136 +0,0 @@\n-use {Node, NodeType, TextUnit, TextRange};\n-use ::visitor::{visitor, process_subtree_bottom_up};\n-\n-pub fn child_of_type(node: Node, ty: NodeType) -> Option<Node> {\n-    node.children().find(|n| n.ty() == ty)\n-}\n-\n-pub fn children_of_type<'f>(node: Node<'f>, ty: NodeType) -> Box<Iterator<Item=Node<'f>> + 'f> {\n-    Box::new(node.children().filter(move |n| n.ty() == ty))\n-}\n-\n-pub fn subtree<'f>(node: Node<'f>) -> Box<Iterator<Item=Node<'f>> + 'f> {\n-    Box::new(node.children().flat_map(subtree).chain(::std::iter::once(node)))\n-}\n-\n-pub fn descendants_of_type<'f>(node: Node<'f>, ty: NodeType) -> Vec<Node<'f>> {\n-    process_subtree_bottom_up(\n-        node,\n-        visitor(Vec::new())\n-            .visit_nodes(&[ty], |node, nodes| nodes.push(node))\n-    )\n-}\n-\n-pub fn child_of_type_exn(node: Node, ty: NodeType) -> Node {\n-    child_of_type(node, ty).unwrap_or_else(|| {\n-        panic!(\"No child of type {:?} for {:?}\\\n-                ----\\\n-                {}\\\n-                ----\", ty, node.ty(), node.text())\n-    })\n-}\n-\n-\n-pub fn ancestors(node: Node) -> Ancestors {\n-    Ancestors(Some(node))\n-}\n-\n-pub struct Ancestors<'f>(Option<Node<'f>>);\n-\n-impl<'f> Iterator for Ancestors<'f> {\n-    type Item = Node<'f>;\n-\n-    fn next(&mut self) -> Option<Self::Item> {\n-        let current = self.0;\n-        self.0 = current.and_then(|n| n.parent());\n-        current\n-    }\n-}\n-\n-pub fn is_leaf(node: Node) -> bool {\n-    node.children().next().is_none() && !node.range().is_empty()\n-}\n-\n-\n-#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n-pub enum Direction {\n-    Left, Right\n-}\n-\n-pub fn sibling(node: Node, dir: Direction) -> Option<Node> {\n-    let (parent, idx) = child_position(node)?;\n-    let idx = match dir {\n-        Direction::Left => idx.checked_sub(1)?,\n-        Direction::Right => idx + 1,\n-    };\n-    parent.children().nth(idx)\n-}\n-\n-pub mod ast {\n-    use {Node, AstNode, TextUnit, AstChildren};\n-    use visitor::{visitor, process_subtree_bottom_up};\n-    use super::{ancestors, find_leaf_at_offset, LeafAtOffset};\n-\n-    pub fn ancestor<'f, T: AstNode<'f>>(node: Node<'f>) -> Option<T> {\n-        ancestors(node)\n-            .filter_map(T::wrap)\n-            .next()\n-    }\n-\n-    pub fn ancestor_exn<'f, T: AstNode<'f>>(node: Node<'f>) -> T {\n-        ancestor(node).unwrap()\n-    }\n-\n-    pub fn children_of_type<'f, N: AstNode<'f>>(node: Node<'f>) -> AstChildren<N> {\n-        AstChildren::new(node.children())\n-    }\n-\n-    pub fn descendants_of_type<'f, N: AstNode<'f>>(node: Node<'f>) -> Vec<N> {\n-        process_subtree_bottom_up(\n-            node,\n-            visitor(Vec::new())\n-                .visit::<N, _>(|node, acc| acc.push(node))\n-        )\n-    }\n-\n-    pub fn node_at_offset<'f, T: AstNode<'f>>(node: Node<'f>, offset: TextUnit) -> Option<T> {\n-        match find_leaf_at_offset(node, offset) {\n-            LeafAtOffset::None => None,\n-            LeafAtOffset::Single(node) => ancestor(node),\n-            LeafAtOffset::Between(left, right) => ancestor(left).or_else(|| ancestor(right)),\n-        }\n-    }\n-}\n-\n-pub mod traversal {\n-    use {Node};\n-\n-    pub fn bottom_up<'f, F: FnMut(Node<'f>)>(node: Node<'f>, mut f: F)\n-    {\n-        go(node, &mut f);\n-\n-        fn go<'f, F: FnMut(Node<'f>)>(node: Node<'f>, f: &mut F) {\n-            for child in node.children() {\n-                go(child, f)\n-            }\n-            f(node);\n-        }\n-    }\n-}\n-\n-fn child_position(child: Node) -> Option<(Node, usize)> {\n-    child.parent()\n-        .map(|parent| {\n-            (parent, parent.children().position(|n| n == child).unwrap())\n-        })\n-}\n-\n-fn common_ancestor<'f>(n1: Node<'f>, n2: Node<'f>) -> Node<'f> {\n-    for p in ancestors(n1) {\n-        if ancestors(n2).any(|a| a == p) {\n-            return p;\n-        }\n-    }\n-    panic!(\"Can't find common ancestor of {:?} and {:?}\", n1, n2)\n-}\n-"}, {"sha": "80670ce714bf5efa32d6fb237251057ba75b3942", "filename": "crates/libsyntax2/src/ast/generated.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/1141d448d960eedba0a5647d525910de706bf778/crates%2Flibsyntax2%2Fsrc%2Fast%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1141d448d960eedba0a5647d525910de706bf778/crates%2Flibsyntax2%2Fsrc%2Fast%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibsyntax2%2Fsrc%2Fast%2Fgenerated.rs?ref=1141d448d960eedba0a5647d525910de706bf778", "patch": "@@ -267,6 +267,31 @@ impl<R: TreeRoot> AstNode<R> for NeverType<R> {\n \n impl<R: TreeRoot> NeverType<R> {}\n \n+// NominalDef\n+#[derive(Debug, Clone, Copy)]\n+pub enum NominalDef<R: TreeRoot = Arc<SyntaxRoot>> {\n+    StructDef(StructDef<R>),\n+    EnumDef(EnumDef<R>),\n+}\n+\n+impl<R: TreeRoot> AstNode<R> for NominalDef<R> {\n+    fn cast(syntax: SyntaxNode<R>) -> Option<Self> {\n+        match syntax.kind() {\n+            STRUCT_DEF => Some(NominalDef::StructDef(StructDef { syntax })),\n+            ENUM_DEF => Some(NominalDef::EnumDef(EnumDef { syntax })),\n+            _ => None,\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxNode<R> {\n+        match self {\n+            NominalDef::StructDef(inner) => inner.syntax(),\n+            NominalDef::EnumDef(inner) => inner.syntax(),\n+        }\n+    }\n+}\n+\n+impl<R: TreeRoot> NominalDef<R> {}\n+\n // ParenType\n #[derive(Debug, Clone, Copy)]\n pub struct ParenType<R: TreeRoot = Arc<SyntaxRoot>> {"}, {"sha": "3ae403bb58437d7b349b9d7da836e9ff4d49bccf", "filename": "crates/libsyntax2/src/grammar.ron", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1141d448d960eedba0a5647d525910de706bf778/crates%2Flibsyntax2%2Fsrc%2Fgrammar.ron", "raw_url": "https://github.com/rust-lang/rust/raw/1141d448d960eedba0a5647d525910de706bf778/crates%2Flibsyntax2%2Fsrc%2Fgrammar.ron", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibsyntax2%2Fsrc%2Fgrammar.ron?ref=1141d448d960eedba0a5647d525910de706bf778", "patch": "@@ -261,6 +261,8 @@ Grammar(\n             \"ForType\",\n             \"ImplTraitType\",\n             \"DynTraitType\",\n-        ])\n+        ]),\n+\n+        \"NominalDef\": ( enum: [\"StructDef\", \"EnumDef\"]),\n     },\n )"}, {"sha": "9de6f480bf1a439ee0354a936b8ef18ddb8c9db5", "filename": "crates/server/src/main_loop/handlers.rs", "status": "modified", "additions": 60, "deletions": 47, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/1141d448d960eedba0a5647d525910de706bf778/crates%2Fserver%2Fsrc%2Fmain_loop%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1141d448d960eedba0a5647d525910de706bf778/crates%2Fserver%2Fsrc%2Fmain_loop%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fserver%2Fsrc%2Fmain_loop%2Fhandlers.rs?ref=1141d448d960eedba0a5647d525910de706bf778", "patch": "@@ -87,27 +87,28 @@ pub fn handle_code_action(\n     let file = world.file_syntax(&path)?;\n     let line_index = world.file_line_index(&path)?;\n     let offset = params.range.conv_with(&line_index).start();\n-    let ret = if libeditor::flip_comma(&file, offset).is_some() {\n-        let cmd = apply_code_action_cmd(\n-            ActionId::FlipComma,\n-            params.text_document,\n-            offset,\n-        );\n-        Some(vec![cmd])\n-    } else {\n-        None\n-    };\n-    Ok(ret)\n+    let mut ret = Vec::new();\n+\n+    let actions = &[\n+        (ActionId::FlipComma, libeditor::flip_comma(&file, offset).is_some()),\n+        (ActionId::AddDerive, libeditor::add_derive(&file, offset).is_some()),\n+    ];\n+\n+    for (id, edit) in actions {\n+        if *edit {\n+            let cmd = apply_code_action_cmd(*id, params.text_document.clone(), offset);\n+            ret.push(cmd);\n+        }\n+    }\n+    return Ok(Some(ret));\n }\n \n pub fn handle_workspace_symbol(\n     world: World,\n     params: req::WorkspaceSymbolParams,\n ) -> Result<Option<Vec<SymbolInformation>>> {\n-    let mut acc = Vec::new();\n-\n+    let all_symbols = params.query.contains(\"#\");\n     let query = {\n-        let all_symbols = params.query.contains(\"#\");\n         let query: String = params.query.chars()\n             .filter(|&c| c != '#')\n             .collect();\n@@ -118,19 +119,29 @@ pub fn handle_workspace_symbol(\n         q.limit(128);\n         q\n     };\n+    let mut res = exec_query(&world, query)?;\n+    if res.is_empty() && !all_symbols {\n+        let mut query = Query::new(params.query);\n+        query.limit(128);\n+        res = exec_query(&world, query)?;\n+    }\n \n-    for (path, symbol) in world.world_symbols(query) {\n-        let line_index = world.file_line_index(path)?;\n-        let info = SymbolInformation {\n-            name: symbol.name.to_string(),\n-            kind: symbol.kind.conv(),\n-            location: (path, symbol.node_range).try_conv_with(&line_index)?,\n-            container_name: None,\n-        };\n-        acc.push(info);\n-    };\n+    return Ok(Some(res));\n \n-    Ok(Some(acc))\n+    fn exec_query(world: &World, query: Query) -> Result<Vec<SymbolInformation>> {\n+        let mut res = Vec::new();\n+        for (path, symbol) in world.world_symbols(query) {\n+            let line_index = world.file_line_index(path)?;\n+            let info = SymbolInformation {\n+                name: symbol.name.to_string(),\n+                kind: symbol.kind.conv(),\n+                location: (path, symbol.node_range).try_conv_with(&line_index)?,\n+                container_name: None,\n+            };\n+            res.push(info);\n+        };\n+        Ok(res)\n+    }\n }\n \n pub fn handle_goto_definition(\n@@ -161,28 +172,28 @@ pub fn handle_execute_command(\n     }\n     let arg = params.arguments.pop().unwrap();\n     let arg: ActionRequest = from_value(arg)?;\n-    match arg.id {\n-        ActionId::FlipComma => {\n-            let path = arg.text_document.file_path()?;\n-            let file = world.file_syntax(&path)?;\n-            let line_index = world.file_line_index(&path)?;\n-            let edit = match libeditor::flip_comma(&file, arg.offset) {\n-                Some(edit) => edit(),\n-                None => bail!(\"command not applicable\"),\n-            };\n-            let mut changes = HashMap::new();\n-            changes.insert(\n-                arg.text_document.uri,\n-                edit.conv_with(&line_index),\n-            );\n-            let edit = WorkspaceEdit {\n-                changes: Some(changes),\n-                document_changes: None,\n-            };\n+    let path = arg.text_document.file_path()?;\n+    let file = world.file_syntax(&path)?;\n+    let edit = match arg.id {\n+        ActionId::FlipComma => libeditor::flip_comma(&file, arg.offset).map(|edit| edit()),\n+        ActionId::AddDerive => libeditor::add_derive(&file, arg.offset).map(|edit| edit()),\n+    };\n+    let edit = match edit {\n+        Some(edit) => edit,\n+        None => bail!(\"command not applicable\"),\n+    };\n+    let line_index = world.file_line_index(&path)?;\n+    let mut changes = HashMap::new();\n+    changes.insert(\n+        arg.text_document.uri,\n+        edit.conv_with(&line_index),\n+    );\n+    let edit = WorkspaceEdit {\n+        changes: Some(changes),\n+        document_changes: None,\n+    };\n \n-            Ok(req::ApplyWorkspaceEditParams { edit })\n-        }\n-    }\n+    Ok(req::ApplyWorkspaceEditParams { edit })\n }\n \n #[derive(Serialize, Deserialize)]\n@@ -207,13 +218,15 @@ fn apply_code_action_cmd(id: ActionId, doc: TextDocumentIdentifier, offset: Text\n \n #[derive(Serialize, Deserialize, Clone, Copy)]\n enum ActionId {\n-    FlipComma\n+    FlipComma,\n+    AddDerive,\n }\n \n impl ActionId {\n     fn title(&self) -> &'static str {\n         match *self {\n             ActionId::FlipComma => \"Flip `,`\",\n+            ActionId::AddDerive => \"Add `#[derive]`\",\n         }\n     }\n }"}]}