{"sha": "65b448273dd280401cd440a6740a7cd891525ba3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY1YjQ0ODI3M2RkMjgwNDAxY2Q0NDBhNjc0MGE3Y2Q4OTE1MjViYTM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-03T19:46:17Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-03T19:46:17Z"}, "message": "Auto merge of #71006 - ecstatic-morse:dataflow-bidi, r=ecstatic-morse\n\nUse existing framework for backward dataflow analyses\n\nThis PR adds support for backward analyses to the dataflow framework and adds a new live variable analysis (based on the existing one in `librustc_mir/util/liveness.rs`). By adding these to the framework instead of having a separate API, all newly implemented backward dataflow analyses get cursors/visitors, `rustc_peek` tests, and graphviz visualizations for free. In the near-term, this makes it much easier to implement global dead-store elimination, and I believe that this will enable even more MIR optimizations in the future.\n\nThis PR makes many changes to the dataflow API, since some concepts and terminology only make sense in forward dataflow. Below is a list of the important changes.\n- ~~`entry_set` -> `fixpoint` (the fixpoint for backward dataflow problems is after the block's terminator)~~\n- `seek_{before,after}` -> `seek_{before,after}_primary_effect` (the unprefixed dataflow effect is now referred to as the \"primary\" effect instead of the \"after\" effect. The \"before\" effect remains the same, although I considered changing it to the \"antecedent\" effect. In both backward and forward dataflow, the \"before\" effect is applied prior to the \"primary\" effect. I feel very strongly that this is the correct choice, as it means consumers don't have to switch between `seek_before` and `seek_after` based on the direction of their analysis.\n- `seek_after_assume_call_returns` is now gone. Users can use `ResultsCursor::apply_custom_effect` to emulate it.\n- `visit_{statement,terminator}_exit` -> `visit_{statement,terminator}_after_primary_effect`\n- `visit_{statement,terminator}` -> `visit_{statement,terminator}_before_primary_effect`\n\nImplementing this also required refactoring the dataflow cursor implementation so it could work in both directions. This is a large percentage of the diff, since the cursor code is rather complex. The fact that the cursor is exhaustively tested in both directions should reassure whomever is unlucky enough to review this :rofl:.\n\nIn order to avoid computing the reverse CFG for forward dataflow analyses, I've added some hacks to the existing `mir::BodyAndCache` interface. I've requested changes to this interface that would let me implement this more efficiently.\n\nr? @eddyb (feel free to reassign)\ncc @rust-lang/wg-mir-opt", "tree": {"sha": "44de98be60df34ae33435052aabec8e33d164201", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/44de98be60df34ae33435052aabec8e33d164201"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/65b448273dd280401cd440a6740a7cd891525ba3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/65b448273dd280401cd440a6740a7cd891525ba3", "html_url": "https://github.com/rust-lang/rust/commit/65b448273dd280401cd440a6740a7cd891525ba3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/65b448273dd280401cd440a6740a7cd891525ba3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ea733c3a59be77b752d6d3f722596bfd5b1fcf31", "url": "https://api.github.com/repos/rust-lang/rust/commits/ea733c3a59be77b752d6d3f722596bfd5b1fcf31", "html_url": "https://github.com/rust-lang/rust/commit/ea733c3a59be77b752d6d3f722596bfd5b1fcf31"}, {"sha": "21c72b6979a990436e271503916f003148c4ce02", "url": "https://api.github.com/repos/rust-lang/rust/commits/21c72b6979a990436e271503916f003148c4ce02", "html_url": "https://github.com/rust-lang/rust/commit/21c72b6979a990436e271503916f003148c4ce02"}], "stats": {"total": 2078, "additions": 1369, "deletions": 709}, "files": [{"sha": "9fcaf2818e83166516357f6c4efee6634d173f30", "filename": "src/librustc_codegen_ssa/mir/analyze.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/65b448273dd280401cd440a6740a7cd891525ba3/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65b448273dd280401cd440a6740a7cd891525ba3/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs?ref=65b448273dd280401cd440a6740a7cd891525ba3", "patch": "@@ -269,7 +269,8 @@ impl<'mir, 'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> Visitor<'tcx>\n \n     fn visit_local(&mut self, &local: &mir::Local, context: PlaceContext, location: Location) {\n         match context {\n-            PlaceContext::MutatingUse(MutatingUseContext::Call) => {\n+            PlaceContext::MutatingUse(MutatingUseContext::Call)\n+            | PlaceContext::MutatingUse(MutatingUseContext::Yield) => {\n                 self.assign(local, location);\n             }\n "}, {"sha": "97f7cccdb600b46db66fa00293f679a40ceb6ac5", "filename": "src/librustc_middle/mir/visit.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/65b448273dd280401cd440a6740a7cd891525ba3/src%2Flibrustc_middle%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65b448273dd280401cd440a6740a7cd891525ba3/src%2Flibrustc_middle%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fvisit.rs?ref=65b448273dd280401cd440a6740a7cd891525ba3", "patch": "@@ -510,7 +510,7 @@ macro_rules! make_mir_visitor {\n                         self.visit_operand(value, source_location);\n                         self.visit_place(\n                             resume_arg,\n-                            PlaceContext::MutatingUse(MutatingUseContext::Store),\n+                            PlaceContext::MutatingUse(MutatingUseContext::Yield),\n                             source_location,\n                         );\n                     }\n@@ -1052,6 +1052,8 @@ pub enum MutatingUseContext {\n     AsmOutput,\n     /// Destination of a call.\n     Call,\n+    /// Destination of a yield.\n+    Yield,\n     /// Being dropped.\n     Drop,\n     /// Mutable borrow."}, {"sha": "7d8a2b540a94470b2a4d3e31ae1cb71091e3da70", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/65b448273dd280401cd440a6740a7cd891525ba3/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65b448273dd280401cd440a6740a7cd891525ba3/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=65b448273dd280401cd440a6740a7cd891525ba3", "patch": "@@ -518,7 +518,7 @@ crate struct MirBorrowckCtxt<'cx, 'tcx> {\n impl<'cx, 'tcx> dataflow::ResultsVisitor<'cx, 'tcx> for MirBorrowckCtxt<'cx, 'tcx> {\n     type FlowState = Flows<'cx, 'tcx>;\n \n-    fn visit_statement(\n+    fn visit_statement_before_primary_effect(\n         &mut self,\n         flow_state: &Flows<'cx, 'tcx>,\n         stmt: &'cx Statement<'tcx>,\n@@ -607,7 +607,7 @@ impl<'cx, 'tcx> dataflow::ResultsVisitor<'cx, 'tcx> for MirBorrowckCtxt<'cx, 'tc\n         }\n     }\n \n-    fn visit_terminator(\n+    fn visit_terminator_before_primary_effect(\n         &mut self,\n         flow_state: &Flows<'cx, 'tcx>,\n         term: &'cx Terminator<'tcx>,\n@@ -701,7 +701,7 @@ impl<'cx, 'tcx> dataflow::ResultsVisitor<'cx, 'tcx> for MirBorrowckCtxt<'cx, 'tc\n         }\n     }\n \n-    fn visit_terminator_exit(\n+    fn visit_terminator_after_primary_effect(\n         &mut self,\n         flow_state: &Flows<'cx, 'tcx>,\n         term: &'cx Terminator<'tcx>,"}, {"sha": "41c77cf21a76f9c8d5702168a2b5f2f204cb6586", "filename": "src/librustc_mir/borrow_check/type_check/liveness/trace.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/65b448273dd280401cd440a6740a7cd891525ba3/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fliveness%2Ftrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65b448273dd280401cd440a6740a7cd891525ba3/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fliveness%2Ftrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fliveness%2Ftrace.rs?ref=65b448273dd280401cd440a6740a7cd891525ba3", "patch": "@@ -408,7 +408,7 @@ impl LivenessContext<'_, '_, '_, 'tcx> {\n     /// DROP of some local variable will have an effect -- note that\n     /// drops, as they may unwind, are always terminators.\n     fn initialized_at_terminator(&mut self, block: BasicBlock, mpi: MovePathIndex) -> bool {\n-        self.flow_inits.seek_before(self.body.terminator_loc(block));\n+        self.flow_inits.seek_before_primary_effect(self.body.terminator_loc(block));\n         self.initialized_at_curr_loc(mpi)\n     }\n \n@@ -418,7 +418,7 @@ impl LivenessContext<'_, '_, '_, 'tcx> {\n     /// **Warning:** Does not account for the result of `Call`\n     /// instructions.\n     fn initialized_at_exit(&mut self, block: BasicBlock, mpi: MovePathIndex) -> bool {\n-        self.flow_inits.seek_after(self.body.terminator_loc(block));\n+        self.flow_inits.seek_after_primary_effect(self.body.terminator_loc(block));\n         self.initialized_at_curr_loc(mpi)\n     }\n "}, {"sha": "2ae353adfc7f3a792aa7590b14a000b9b8655685", "filename": "src/librustc_mir/dataflow/framework/cursor.rs", "status": "modified", "additions": 121, "deletions": 189, "changes": 310, "blob_url": "https://github.com/rust-lang/rust/blob/65b448273dd280401cd440a6740a7cd891525ba3/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fcursor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65b448273dd280401cd440a6740a7cd891525ba3/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fcursor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fcursor.rs?ref=65b448273dd280401cd440a6740a7cd891525ba3", "patch": "@@ -1,21 +1,22 @@\n //! Random access inspection of the results of a dataflow analysis.\n \n use std::borrow::Borrow;\n+use std::cmp::Ordering;\n \n use rustc_index::bit_set::BitSet;\n-use rustc_middle::mir::{self, BasicBlock, Location, TerminatorKind};\n+use rustc_middle::mir::{self, BasicBlock, Location};\n \n-use super::{Analysis, Results};\n+use super::{Analysis, Direction, Effect, EffectIndex, Results};\n \n /// A `ResultsCursor` that borrows the underlying `Results`.\n pub type ResultsRefCursor<'a, 'mir, 'tcx, A> = ResultsCursor<'mir, 'tcx, A, &'a Results<'tcx, A>>;\n \n /// Allows random access inspection of the results of a dataflow analysis.\n ///\n /// This cursor only has linear performance within a basic block when its statements are visited in\n-/// order. In the worst case\u2014when statements are visited in *reverse* order\u2014performance will be\n-/// quadratic in the number of statements in the block. The order in which basic blocks are\n-/// inspected has no impact on performance.\n+/// the same order as the `DIRECTION` of the analysis. In the worst case\u2014when statements are\n+/// visited in *reverse* order\u2014performance will be quadratic in the number of statements in the\n+/// block. The order in which basic blocks are inspected has no impact on performance.\n ///\n /// A `ResultsCursor` can either own (the default) or borrow the dataflow results it inspects. The\n /// type of ownership is determined by `R` (see `ResultsRefCursor` above).\n@@ -29,32 +30,38 @@ where\n \n     pos: CursorPosition,\n \n-    /// When this flag is set, the cursor is pointing at a `Call` or `Yield` terminator whose call\n-    /// return or resume effect has been applied to `state`.\n+    /// Indicates that `state` has been modified with a custom effect.\n     ///\n-    /// This flag helps to ensure that multiple calls to `seek_after_assume_success` with the\n-    /// same target will result in exactly one invocation of `apply_call_return_effect`. It is\n-    /// sufficient to clear this only in `seek_to_block_start`, since seeking away from a\n-    /// terminator will always require a cursor reset.\n-    success_effect_applied: bool,\n+    /// When this flag is set, we need to reset to an entry set before doing a seek.\n+    state_needs_reset: bool,\n }\n \n impl<'mir, 'tcx, A, R> ResultsCursor<'mir, 'tcx, A, R>\n where\n     A: Analysis<'tcx>,\n     R: Borrow<Results<'tcx, A>>,\n {\n-    /// Returns a new cursor for `results` that points to the start of the `START_BLOCK`.\n+    /// Returns a new cursor that can inspect `results`.\n     pub fn new(body: &'mir mir::Body<'tcx>, results: R) -> Self {\n+        let bits_per_block = results.borrow().entry_set_for_block(mir::START_BLOCK).domain_size();\n+\n         ResultsCursor {\n             body,\n-            pos: CursorPosition::BlockStart(mir::START_BLOCK),\n-            state: results.borrow().entry_sets[mir::START_BLOCK].clone(),\n-            success_effect_applied: false,\n             results,\n+\n+            // Initialize to an empty `BitSet` and set `state_needs_reset` to tell the cursor that\n+            // it needs to reset to block entry before the first seek. The cursor position is\n+            // immaterial.\n+            state_needs_reset: true,\n+            state: BitSet::new_empty(bits_per_block),\n+            pos: CursorPosition::block_entry(mir::START_BLOCK),\n         }\n     }\n \n+    pub fn body(&self) -> &'mir mir::Body<'tcx> {\n+        self.body\n+    }\n+\n     /// Returns the `Analysis` used to generate the underlying results.\n     pub fn analysis(&self) -> &A {\n         &self.results.borrow().analysis\n@@ -72,209 +79,134 @@ where\n         self.state.contains(elem)\n     }\n \n-    /// Resets the cursor to the start of the given basic block.\n-    pub fn seek_to_block_start(&mut self, block: BasicBlock) {\n-        self.state.overwrite(&self.results.borrow().entry_sets[block]);\n-        self.pos = CursorPosition::BlockStart(block);\n-        self.success_effect_applied = false;\n-    }\n-\n-    /// Advances the cursor to hold all effects up to and including to the \"before\" effect of the\n-    /// statement (or terminator) at the given location.\n+    /// Resets the cursor to hold the entry set for the given basic block.\n     ///\n-    /// If you wish to observe the full effect of a statement or terminator, not just the \"before\"\n-    /// effect, use `seek_after` or `seek_after_assume_success`.\n-    pub fn seek_before(&mut self, target: Location) {\n-        assert!(target <= self.body.terminator_loc(target.block));\n-        self.seek_(target, false);\n+    /// For forward dataflow analyses, this is the dataflow state prior to the first statement.\n+    ///\n+    /// For backward dataflow analyses, this is the dataflow state after the terminator.\n+    pub(super) fn seek_to_block_entry(&mut self, block: BasicBlock) {\n+        self.state.overwrite(&self.results.borrow().entry_set_for_block(block));\n+        self.pos = CursorPosition::block_entry(block);\n+        self.state_needs_reset = false;\n     }\n \n-    /// Advances the cursor to hold the full effect of all statements (and possibly closing\n-    /// terminators) up to and including the `target`.\n+    /// Resets the cursor to hold the state prior to the first statement in a basic block.\n     ///\n-    /// If the `target` is a `Call` terminator, any call return effect for that terminator will\n-    /// **not** be observed. Use `seek_after_assume_success` if you wish to observe the call\n-    /// return effect.\n-    pub fn seek_after(&mut self, target: Location) {\n-        assert!(target <= self.body.terminator_loc(target.block));\n-\n-        // If we have already applied the call return effect, we are currently pointing at a `Call`\n-        // terminator. Unconditionally reset the dataflow cursor, since there is no way to \"undo\"\n-        // the call return effect.\n-        if self.success_effect_applied {\n-            self.seek_to_block_start(target.block);\n+    /// For forward analyses, this is the entry set for the given block.\n+    ///\n+    /// For backward analyses, this is the state that will be propagated to its\n+    /// predecessors (ignoring edge-specific effects).\n+    pub fn seek_to_block_start(&mut self, block: BasicBlock) {\n+        if A::Direction::is_forward() {\n+            self.seek_to_block_entry(block)\n+        } else {\n+            self.seek_after(Location { block, statement_index: 0 }, Effect::Primary)\n         }\n-\n-        self.seek_(target, true);\n     }\n \n-    /// Advances the cursor to hold all effects up to and including of the statement (or\n-    /// terminator) at the given location.\n+    /// Resets the cursor to hold the state after the terminator in a basic block.\n     ///\n-    /// If the `target` is a `Call` or `Yield` terminator, any call return or resume effect for that\n-    /// terminator will be observed. Use `seek_after` if you do **not** wish to observe the\n-    /// \"success\" effect.\n-    pub fn seek_after_assume_success(&mut self, target: Location) {\n-        let terminator_loc = self.body.terminator_loc(target.block);\n-        assert!(target.statement_index <= terminator_loc.statement_index);\n-\n-        self.seek_(target, true);\n-\n-        if target != terminator_loc || self.success_effect_applied {\n-            return;\n-        }\n-\n-        // Apply the effect of the \"success\" path of the terminator.\n-\n-        self.success_effect_applied = true;\n-        let terminator = self.body.basic_blocks()[target.block].terminator();\n-        match &terminator.kind {\n-            TerminatorKind::Call { destination: Some((return_place, _)), func, args, .. } => {\n-                self.results.borrow().analysis.apply_call_return_effect(\n-                    &mut self.state,\n-                    target.block,\n-                    func,\n-                    args,\n-                    *return_place,\n-                );\n-            }\n-            TerminatorKind::Yield { resume, resume_arg, .. } => {\n-                self.results.borrow().analysis.apply_yield_resume_effect(\n-                    &mut self.state,\n-                    *resume,\n-                    *resume_arg,\n-                );\n-            }\n-            _ => {}\n+    /// For backward analyses, this is the entry set for the given block.\n+    ///\n+    /// For forward analyses, this is the state that will be propagated to its\n+    /// successors (ignoring edge-specific effects).\n+    pub fn seek_to_block_end(&mut self, block: BasicBlock) {\n+        if A::Direction::is_backward() {\n+            self.seek_to_block_entry(block)\n+        } else {\n+            self.seek_after(self.body.terminator_loc(block), Effect::Primary)\n         }\n     }\n \n-    fn seek_(&mut self, target: Location, apply_after_effect_at_target: bool) {\n-        use CursorPosition::*;\n-\n-        match self.pos {\n-            // Return early if we are already at the target location.\n-            Before(curr) if curr == target && !apply_after_effect_at_target => return,\n-            After(curr) if curr == target && apply_after_effect_at_target => return,\n+    /// Advances the cursor to hold the dataflow state at `target` before its \"primary\" effect is\n+    /// applied.\n+    ///\n+    /// The \"before\" effect at the target location *will be* applied.\n+    pub fn seek_before_primary_effect(&mut self, target: Location) {\n+        self.seek_after(target, Effect::Before)\n+    }\n \n-            // Otherwise, we must reset to the start of the target block if...\n+    /// Advances the cursor to hold the dataflow state at `target` after its \"primary\" effect is\n+    /// applied.\n+    ///\n+    /// The \"before\" effect at the target location will be applied as well.\n+    pub fn seek_after_primary_effect(&mut self, target: Location) {\n+        self.seek_after(target, Effect::Primary)\n+    }\n \n-            // we are in a different block entirely.\n-            BlockStart(block) | Before(Location { block, .. }) | After(Location { block, .. })\n-                if block != target.block =>\n-            {\n-                self.seek_to_block_start(target.block)\n-            }\n+    fn seek_after(&mut self, target: Location, effect: Effect) {\n+        assert!(target <= self.body.terminator_loc(target.block));\n \n-            // we are in the same block but have advanced past the target statement.\n-            Before(curr) | After(curr) if curr.statement_index > target.statement_index => {\n-                self.seek_to_block_start(target.block)\n+        // Reset to the entry of the target block if any of the following are true:\n+        //   - A custom effect has been applied to the cursor state.\n+        //   - We are in a different block than the target.\n+        //   - We are in the same block but have advanced past the target effect.\n+        if self.state_needs_reset || self.pos.block != target.block {\n+            self.seek_to_block_entry(target.block);\n+        } else if let Some(curr_effect) = self.pos.curr_effect_index {\n+            let mut ord = curr_effect.statement_index.cmp(&target.statement_index);\n+            if A::Direction::is_backward() {\n+                ord = ord.reverse()\n             }\n \n-            // we have already applied the entire effect of a statement but only wish to observe\n-            // its \"before\" effect.\n-            After(curr)\n-                if curr.statement_index == target.statement_index\n-                    && !apply_after_effect_at_target =>\n-            {\n-                self.seek_to_block_start(target.block)\n+            match ord.then_with(|| curr_effect.effect.cmp(&effect)) {\n+                Ordering::Equal => return,\n+                Ordering::Greater => self.seek_to_block_entry(target.block),\n+                Ordering::Less => {}\n             }\n-\n-            // N.B., `success_effect_applied` is checked in `seek_after`, not here.\n-            _ => (),\n         }\n \n-        let analysis = &self.results.borrow().analysis;\n-        let block_data = &self.body.basic_blocks()[target.block];\n-\n         // At this point, the cursor is in the same block as the target location at an earlier\n         // statement.\n-        debug_assert_eq!(target.block, self.pos.block());\n-\n-        // Find the first statement whose transfer function has not yet been applied.\n-        let first_unapplied_statement = match self.pos {\n-            BlockStart(_) => 0,\n-            After(Location { statement_index, .. }) => statement_index + 1,\n-\n-            // If we have only applied the \"before\" effect for the current statement, apply the\n-            // remainder before continuing.\n-            Before(curr) => {\n-                if curr.statement_index == block_data.statements.len() {\n-                    let terminator = block_data.terminator();\n-                    analysis.apply_terminator_effect(&mut self.state, terminator, curr);\n-                } else {\n-                    let statement = &block_data.statements[curr.statement_index];\n-                    analysis.apply_statement_effect(&mut self.state, statement, curr);\n-                }\n-\n-                // If all we needed to do was go from `Before` to `After` in the same statement,\n-                // we are now done.\n-                if curr.statement_index == target.statement_index {\n-                    debug_assert!(apply_after_effect_at_target);\n-                    self.pos = After(target);\n-                    return;\n-                }\n-\n-                curr.statement_index + 1\n-            }\n+        debug_assert_eq!(target.block, self.pos.block);\n+\n+        let block_data = &self.body[target.block];\n+        let next_effect = if A::Direction::is_forward() {\n+            #[rustfmt::skip]\n+            self.pos.curr_effect_index.map_or_else(\n+                || Effect::Before.at_index(0),\n+                EffectIndex::next_in_forward_order,\n+            )\n+        } else {\n+            self.pos.curr_effect_index.map_or_else(\n+                || Effect::Before.at_index(block_data.statements.len()),\n+                EffectIndex::next_in_backward_order,\n+            )\n         };\n \n-        // We have now applied all effects prior to `first_unapplied_statement`.\n-\n-        // Apply the effects of all statements before `target`.\n-        let mut location = Location { block: target.block, statement_index: 0 };\n-        for statement_index in first_unapplied_statement..target.statement_index {\n-            location.statement_index = statement_index;\n-            let statement = &block_data.statements[statement_index];\n-            analysis.apply_before_statement_effect(&mut self.state, statement, location);\n-            analysis.apply_statement_effect(&mut self.state, statement, location);\n-        }\n-\n-        // Apply the effect of the statement (or terminator) at `target`.\n-        location.statement_index = target.statement_index;\n-        if target.statement_index == block_data.statements.len() {\n-            let terminator = &block_data.terminator();\n-            analysis.apply_before_terminator_effect(&mut self.state, terminator, location);\n-\n-            if apply_after_effect_at_target {\n-                analysis.apply_terminator_effect(&mut self.state, terminator, location);\n-                self.pos = After(target);\n-            } else {\n-                self.pos = Before(target);\n-            }\n-        } else {\n-            let statement = &block_data.statements[target.statement_index];\n-            analysis.apply_before_statement_effect(&mut self.state, statement, location);\n+        let analysis = &self.results.borrow().analysis;\n+        let target_effect_index = effect.at_index(target.statement_index);\n+\n+        A::Direction::apply_effects_in_range(\n+            analysis,\n+            &mut self.state,\n+            target.block,\n+            block_data,\n+            next_effect..=target_effect_index,\n+        );\n+\n+        self.pos =\n+            CursorPosition { block: target.block, curr_effect_index: Some(target_effect_index) };\n+    }\n \n-            if apply_after_effect_at_target {\n-                analysis.apply_statement_effect(&mut self.state, statement, location);\n-                self.pos = After(target)\n-            } else {\n-                self.pos = Before(target);\n-            }\n-        }\n+    /// Applies `f` to the cursor's internal state.\n+    ///\n+    /// This can be used, e.g., to apply the call return effect directly to the cursor without\n+    /// creating an extra copy of the dataflow state.\n+    pub fn apply_custom_effect(&mut self, f: impl FnOnce(&A, &mut BitSet<A::Idx>)) {\n+        f(&self.results.borrow().analysis, &mut self.state);\n+        self.state_needs_reset = true;\n     }\n }\n \n #[derive(Clone, Copy, Debug)]\n-enum CursorPosition {\n-    /// No effects within this block have been applied.\n-    BlockStart(BasicBlock),\n-\n-    /// Only the \"before\" effect of the statement (or terminator) at this location has been\n-    /// applied (along with the effects of all previous statements).\n-    Before(Location),\n-\n-    /// The effects of all statements up to and including the one at this location have been\n-    /// applied.\n-    After(Location),\n+struct CursorPosition {\n+    block: BasicBlock,\n+    curr_effect_index: Option<EffectIndex>,\n }\n \n impl CursorPosition {\n-    fn block(&self) -> BasicBlock {\n-        match *self {\n-            Self::BlockStart(block) => block,\n-            Self::Before(loc) | Self::After(loc) => loc.block,\n-        }\n+    fn block_entry(block: BasicBlock) -> CursorPosition {\n+        CursorPosition { block, curr_effect_index: None }\n     }\n }"}, {"sha": "76f703ec9136fd20a636587374f0ac860eedcd55", "filename": "src/librustc_mir/dataflow/framework/direction.rs", "status": "added", "additions": 570, "deletions": 0, "changes": 570, "blob_url": "https://github.com/rust-lang/rust/blob/65b448273dd280401cd440a6740a7cd891525ba3/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fdirection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65b448273dd280401cd440a6740a7cd891525ba3/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fdirection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fdirection.rs?ref=65b448273dd280401cd440a6740a7cd891525ba3", "patch": "@@ -0,0 +1,570 @@\n+use rustc_index::bit_set::BitSet;\n+use rustc_middle::mir::{self, BasicBlock, Location};\n+use rustc_middle::ty::{self, TyCtxt};\n+use std::ops::RangeInclusive;\n+\n+use super::visitor::{ResultsVisitable, ResultsVisitor};\n+use super::{Analysis, Effect, EffectIndex, GenKillAnalysis, GenKillSet};\n+\n+pub trait Direction {\n+    fn is_forward() -> bool;\n+\n+    fn is_backward() -> bool {\n+        !Self::is_forward()\n+    }\n+\n+    /// Applies all effects between the given `EffectIndex`s.\n+    ///\n+    /// `effects.start()` must precede or equal `effects.end()` in this direction.\n+    fn apply_effects_in_range<A>(\n+        analysis: &A,\n+        state: &mut BitSet<A::Idx>,\n+        block: BasicBlock,\n+        block_data: &mir::BasicBlockData<'tcx>,\n+        effects: RangeInclusive<EffectIndex>,\n+    ) where\n+        A: Analysis<'tcx>;\n+\n+    fn apply_effects_in_block<A>(\n+        analysis: &A,\n+        state: &mut BitSet<A::Idx>,\n+        block: BasicBlock,\n+        block_data: &mir::BasicBlockData<'tcx>,\n+    ) where\n+        A: Analysis<'tcx>;\n+\n+    fn gen_kill_effects_in_block<A>(\n+        analysis: &A,\n+        trans: &mut GenKillSet<A::Idx>,\n+        block: BasicBlock,\n+        block_data: &mir::BasicBlockData<'tcx>,\n+    ) where\n+        A: GenKillAnalysis<'tcx>;\n+\n+    fn visit_results_in_block<F, R>(\n+        state: &mut F,\n+        block: BasicBlock,\n+        block_data: &'mir mir::BasicBlockData<'tcx>,\n+        results: &R,\n+        vis: &mut impl ResultsVisitor<'mir, 'tcx, FlowState = F>,\n+    ) where\n+        R: ResultsVisitable<'tcx, FlowState = F>;\n+\n+    fn join_state_into_successors_of<A>(\n+        analysis: &A,\n+        tcx: TyCtxt<'tcx>,\n+        body: &mir::Body<'tcx>,\n+        dead_unwinds: Option<&BitSet<BasicBlock>>,\n+        exit_state: &mut BitSet<A::Idx>,\n+        block: (BasicBlock, &'_ mir::BasicBlockData<'tcx>),\n+        propagate: impl FnMut(BasicBlock, &BitSet<A::Idx>),\n+    ) where\n+        A: Analysis<'tcx>;\n+}\n+\n+/// Dataflow that runs from the exit of a block (the terminator), to its entry (the first statement).\n+pub struct Backward;\n+\n+impl Direction for Backward {\n+    fn is_forward() -> bool {\n+        false\n+    }\n+\n+    fn apply_effects_in_block<A>(\n+        analysis: &A,\n+        state: &mut BitSet<A::Idx>,\n+        block: BasicBlock,\n+        block_data: &mir::BasicBlockData<'tcx>,\n+    ) where\n+        A: Analysis<'tcx>,\n+    {\n+        let terminator = block_data.terminator();\n+        let location = Location { block, statement_index: block_data.statements.len() };\n+        analysis.apply_before_terminator_effect(state, terminator, location);\n+        analysis.apply_terminator_effect(state, terminator, location);\n+\n+        for (statement_index, statement) in block_data.statements.iter().enumerate().rev() {\n+            let location = Location { block, statement_index };\n+            analysis.apply_before_statement_effect(state, statement, location);\n+            analysis.apply_statement_effect(state, statement, location);\n+        }\n+    }\n+\n+    fn gen_kill_effects_in_block<A>(\n+        analysis: &A,\n+        trans: &mut GenKillSet<A::Idx>,\n+        block: BasicBlock,\n+        block_data: &mir::BasicBlockData<'tcx>,\n+    ) where\n+        A: GenKillAnalysis<'tcx>,\n+    {\n+        let terminator = block_data.terminator();\n+        let location = Location { block, statement_index: block_data.statements.len() };\n+        analysis.before_terminator_effect(trans, terminator, location);\n+        analysis.terminator_effect(trans, terminator, location);\n+\n+        for (statement_index, statement) in block_data.statements.iter().enumerate().rev() {\n+            let location = Location { block, statement_index };\n+            analysis.before_statement_effect(trans, statement, location);\n+            analysis.statement_effect(trans, statement, location);\n+        }\n+    }\n+\n+    fn apply_effects_in_range<A>(\n+        analysis: &A,\n+        state: &mut BitSet<A::Idx>,\n+        block: BasicBlock,\n+        block_data: &mir::BasicBlockData<'tcx>,\n+        effects: RangeInclusive<EffectIndex>,\n+    ) where\n+        A: Analysis<'tcx>,\n+    {\n+        let (from, to) = (*effects.start(), *effects.end());\n+        let terminator_index = block_data.statements.len();\n+\n+        assert!(from.statement_index <= terminator_index);\n+        assert!(!to.precedes_in_backward_order(from));\n+\n+        // Handle the statement (or terminator) at `from`.\n+\n+        let next_effect = match from.effect {\n+            // If we need to apply the terminator effect in all or in part, do so now.\n+            _ if from.statement_index == terminator_index => {\n+                let location = Location { block, statement_index: from.statement_index };\n+                let terminator = block_data.terminator();\n+\n+                if from.effect == Effect::Before {\n+                    analysis.apply_before_terminator_effect(state, terminator, location);\n+                    if to == Effect::Before.at_index(terminator_index) {\n+                        return;\n+                    }\n+                }\n+\n+                analysis.apply_terminator_effect(state, terminator, location);\n+                if to == Effect::Primary.at_index(terminator_index) {\n+                    return;\n+                }\n+\n+                // If `from.statement_index` is `0`, we will have hit one of the earlier comparisons\n+                // with `to`.\n+                from.statement_index - 1\n+            }\n+\n+            Effect::Primary => {\n+                let location = Location { block, statement_index: from.statement_index };\n+                let statement = &block_data.statements[from.statement_index];\n+\n+                analysis.apply_statement_effect(state, statement, location);\n+                if to == Effect::Primary.at_index(from.statement_index) {\n+                    return;\n+                }\n+\n+                from.statement_index - 1\n+            }\n+\n+            Effect::Before => from.statement_index,\n+        };\n+\n+        // Handle all statements between `first_unapplied_idx` and `to.statement_index`.\n+\n+        for statement_index in (to.statement_index..next_effect).rev().map(|i| i + 1) {\n+            let location = Location { block, statement_index };\n+            let statement = &block_data.statements[statement_index];\n+            analysis.apply_before_statement_effect(state, statement, location);\n+            analysis.apply_statement_effect(state, statement, location);\n+        }\n+\n+        // Handle the statement at `to`.\n+\n+        let location = Location { block, statement_index: to.statement_index };\n+        let statement = &block_data.statements[to.statement_index];\n+        analysis.apply_before_statement_effect(state, statement, location);\n+\n+        if to.effect == Effect::Before {\n+            return;\n+        }\n+\n+        analysis.apply_statement_effect(state, statement, location);\n+    }\n+\n+    fn visit_results_in_block<F, R>(\n+        state: &mut F,\n+        block: BasicBlock,\n+        block_data: &'mir mir::BasicBlockData<'tcx>,\n+        results: &R,\n+        vis: &mut impl ResultsVisitor<'mir, 'tcx, FlowState = F>,\n+    ) where\n+        R: ResultsVisitable<'tcx, FlowState = F>,\n+    {\n+        results.reset_to_block_entry(state, block);\n+\n+        vis.visit_block_end(&state, block_data, block);\n+\n+        // Terminator\n+        let loc = Location { block, statement_index: block_data.statements.len() };\n+        let term = block_data.terminator();\n+        results.reconstruct_before_terminator_effect(state, term, loc);\n+        vis.visit_terminator_before_primary_effect(state, term, loc);\n+        results.reconstruct_terminator_effect(state, term, loc);\n+        vis.visit_terminator_after_primary_effect(state, term, loc);\n+\n+        for (statement_index, stmt) in block_data.statements.iter().enumerate().rev() {\n+            let loc = Location { block, statement_index };\n+            results.reconstruct_before_statement_effect(state, stmt, loc);\n+            vis.visit_statement_before_primary_effect(state, stmt, loc);\n+            results.reconstruct_statement_effect(state, stmt, loc);\n+            vis.visit_statement_after_primary_effect(state, stmt, loc);\n+        }\n+\n+        vis.visit_block_start(state, block_data, block);\n+    }\n+\n+    fn join_state_into_successors_of<A>(\n+        analysis: &A,\n+        _tcx: TyCtxt<'tcx>,\n+        body: &mir::Body<'tcx>,\n+        dead_unwinds: Option<&BitSet<BasicBlock>>,\n+        exit_state: &mut BitSet<A::Idx>,\n+        (bb, _bb_data): (BasicBlock, &'_ mir::BasicBlockData<'tcx>),\n+        mut propagate: impl FnMut(BasicBlock, &BitSet<A::Idx>),\n+    ) where\n+        A: Analysis<'tcx>,\n+    {\n+        for pred in body.predecessors()[bb].iter().copied() {\n+            match body[pred].terminator().kind {\n+                // Apply terminator-specific edge effects.\n+                //\n+                // FIXME(ecstaticmorse): Avoid cloning the exit state unconditionally.\n+                mir::TerminatorKind::Call {\n+                    destination: Some((return_place, dest)),\n+                    ref func,\n+                    ref args,\n+                    ..\n+                } if dest == bb => {\n+                    let mut tmp = exit_state.clone();\n+                    analysis.apply_call_return_effect(&mut tmp, pred, func, args, return_place);\n+                    propagate(pred, &tmp);\n+                }\n+\n+                mir::TerminatorKind::Yield { resume, resume_arg, .. } if resume == bb => {\n+                    let mut tmp = exit_state.clone();\n+                    analysis.apply_yield_resume_effect(&mut tmp, resume, resume_arg);\n+                    propagate(pred, &tmp);\n+                }\n+\n+                // Ignore dead unwinds.\n+                mir::TerminatorKind::Call { cleanup: Some(unwind), .. }\n+                | mir::TerminatorKind::Assert { cleanup: Some(unwind), .. }\n+                | mir::TerminatorKind::Drop { unwind: Some(unwind), .. }\n+                | mir::TerminatorKind::DropAndReplace { unwind: Some(unwind), .. }\n+                | mir::TerminatorKind::FalseUnwind { unwind: Some(unwind), .. }\n+                    if unwind == bb =>\n+                {\n+                    if dead_unwinds.map_or(true, |dead| !dead.contains(bb)) {\n+                        propagate(pred, exit_state);\n+                    }\n+                }\n+\n+                _ => propagate(pred, exit_state),\n+            }\n+        }\n+    }\n+}\n+\n+/// Dataflow that runs from the entry of a block (the first statement), to its exit (terminator).\n+pub struct Forward;\n+\n+impl Direction for Forward {\n+    fn is_forward() -> bool {\n+        true\n+    }\n+\n+    fn apply_effects_in_block<A>(\n+        analysis: &A,\n+        state: &mut BitSet<A::Idx>,\n+        block: BasicBlock,\n+        block_data: &mir::BasicBlockData<'tcx>,\n+    ) where\n+        A: Analysis<'tcx>,\n+    {\n+        for (statement_index, statement) in block_data.statements.iter().enumerate() {\n+            let location = Location { block, statement_index };\n+            analysis.apply_before_statement_effect(state, statement, location);\n+            analysis.apply_statement_effect(state, statement, location);\n+        }\n+\n+        let terminator = block_data.terminator();\n+        let location = Location { block, statement_index: block_data.statements.len() };\n+        analysis.apply_before_terminator_effect(state, terminator, location);\n+        analysis.apply_terminator_effect(state, terminator, location);\n+    }\n+\n+    fn gen_kill_effects_in_block<A>(\n+        analysis: &A,\n+        trans: &mut GenKillSet<A::Idx>,\n+        block: BasicBlock,\n+        block_data: &mir::BasicBlockData<'tcx>,\n+    ) where\n+        A: GenKillAnalysis<'tcx>,\n+    {\n+        for (statement_index, statement) in block_data.statements.iter().enumerate() {\n+            let location = Location { block, statement_index };\n+            analysis.before_statement_effect(trans, statement, location);\n+            analysis.statement_effect(trans, statement, location);\n+        }\n+\n+        let terminator = block_data.terminator();\n+        let location = Location { block, statement_index: block_data.statements.len() };\n+        analysis.before_terminator_effect(trans, terminator, location);\n+        analysis.terminator_effect(trans, terminator, location);\n+    }\n+\n+    fn apply_effects_in_range<A>(\n+        analysis: &A,\n+        state: &mut BitSet<A::Idx>,\n+        block: BasicBlock,\n+        block_data: &mir::BasicBlockData<'tcx>,\n+        effects: RangeInclusive<EffectIndex>,\n+    ) where\n+        A: Analysis<'tcx>,\n+    {\n+        let (from, to) = (*effects.start(), *effects.end());\n+        let terminator_index = block_data.statements.len();\n+\n+        assert!(to.statement_index <= terminator_index);\n+        assert!(!to.precedes_in_forward_order(from));\n+\n+        // If we have applied the before affect of the statement or terminator at `from` but not its\n+        // after effect, do so now and start the loop below from the next statement.\n+\n+        let first_unapplied_index = match from.effect {\n+            Effect::Before => from.statement_index,\n+\n+            Effect::Primary if from.statement_index == terminator_index => {\n+                debug_assert_eq!(from, to);\n+\n+                let location = Location { block, statement_index: terminator_index };\n+                let terminator = block_data.terminator();\n+                analysis.apply_terminator_effect(state, terminator, location);\n+                return;\n+            }\n+\n+            Effect::Primary => {\n+                let location = Location { block, statement_index: from.statement_index };\n+                let statement = &block_data.statements[from.statement_index];\n+                analysis.apply_statement_effect(state, statement, location);\n+\n+                // If we only needed to apply the after effect of the statement at `idx`, we are done.\n+                if from == to {\n+                    return;\n+                }\n+\n+                from.statement_index + 1\n+            }\n+        };\n+\n+        // Handle all statements between `from` and `to` whose effects must be applied in full.\n+\n+        for statement_index in first_unapplied_index..to.statement_index {\n+            let location = Location { block, statement_index };\n+            let statement = &block_data.statements[statement_index];\n+            analysis.apply_before_statement_effect(state, statement, location);\n+            analysis.apply_statement_effect(state, statement, location);\n+        }\n+\n+        // Handle the statement or terminator at `to`.\n+\n+        let location = Location { block, statement_index: to.statement_index };\n+        if to.statement_index == terminator_index {\n+            let terminator = block_data.terminator();\n+            analysis.apply_before_terminator_effect(state, terminator, location);\n+\n+            if to.effect == Effect::Primary {\n+                analysis.apply_terminator_effect(state, terminator, location);\n+            }\n+        } else {\n+            let statement = &block_data.statements[to.statement_index];\n+            analysis.apply_before_statement_effect(state, statement, location);\n+\n+            if to.effect == Effect::Primary {\n+                analysis.apply_statement_effect(state, statement, location);\n+            }\n+        }\n+    }\n+\n+    fn visit_results_in_block<F, R>(\n+        state: &mut F,\n+        block: BasicBlock,\n+        block_data: &'mir mir::BasicBlockData<'tcx>,\n+        results: &R,\n+        vis: &mut impl ResultsVisitor<'mir, 'tcx, FlowState = F>,\n+    ) where\n+        R: ResultsVisitable<'tcx, FlowState = F>,\n+    {\n+        results.reset_to_block_entry(state, block);\n+\n+        vis.visit_block_start(state, block_data, block);\n+\n+        for (statement_index, stmt) in block_data.statements.iter().enumerate() {\n+            let loc = Location { block, statement_index };\n+            results.reconstruct_before_statement_effect(state, stmt, loc);\n+            vis.visit_statement_before_primary_effect(state, stmt, loc);\n+            results.reconstruct_statement_effect(state, stmt, loc);\n+            vis.visit_statement_after_primary_effect(state, stmt, loc);\n+        }\n+\n+        let loc = Location { block, statement_index: block_data.statements.len() };\n+        let term = block_data.terminator();\n+        results.reconstruct_before_terminator_effect(state, term, loc);\n+        vis.visit_terminator_before_primary_effect(state, term, loc);\n+        results.reconstruct_terminator_effect(state, term, loc);\n+        vis.visit_terminator_after_primary_effect(state, term, loc);\n+\n+        vis.visit_block_end(state, block_data, block);\n+    }\n+\n+    fn join_state_into_successors_of<A>(\n+        analysis: &A,\n+        tcx: TyCtxt<'tcx>,\n+        body: &mir::Body<'tcx>,\n+        dead_unwinds: Option<&BitSet<BasicBlock>>,\n+        exit_state: &mut BitSet<A::Idx>,\n+        (bb, bb_data): (BasicBlock, &'_ mir::BasicBlockData<'tcx>),\n+        mut propagate: impl FnMut(BasicBlock, &BitSet<A::Idx>),\n+    ) where\n+        A: Analysis<'tcx>,\n+    {\n+        use mir::TerminatorKind::*;\n+        match bb_data.terminator().kind {\n+            Return | Resume | Abort | GeneratorDrop | Unreachable => {}\n+\n+            Goto { target } => propagate(target, exit_state),\n+\n+            Assert { target, cleanup: unwind, expected: _, msg: _, cond: _ }\n+            | Drop { target, unwind, location: _ }\n+            | DropAndReplace { target, unwind, value: _, location: _ }\n+            | FalseUnwind { real_target: target, unwind } => {\n+                if let Some(unwind) = unwind {\n+                    if dead_unwinds.map_or(true, |dead| !dead.contains(bb)) {\n+                        propagate(unwind, exit_state);\n+                    }\n+                }\n+\n+                propagate(target, exit_state);\n+            }\n+\n+            FalseEdges { real_target, imaginary_target } => {\n+                propagate(real_target, exit_state);\n+                propagate(imaginary_target, exit_state);\n+            }\n+\n+            Yield { resume: target, drop, resume_arg, value: _ } => {\n+                if let Some(drop) = drop {\n+                    propagate(drop, exit_state);\n+                }\n+\n+                analysis.apply_yield_resume_effect(exit_state, target, resume_arg);\n+                propagate(target, exit_state);\n+            }\n+\n+            Call { cleanup, destination, ref func, ref args, from_hir_call: _ } => {\n+                if let Some(unwind) = cleanup {\n+                    if dead_unwinds.map_or(true, |dead| !dead.contains(bb)) {\n+                        propagate(unwind, exit_state);\n+                    }\n+                }\n+\n+                if let Some((dest_place, target)) = destination {\n+                    // N.B.: This must be done *last*, otherwise the unwind path will see the call\n+                    // return effect.\n+                    analysis.apply_call_return_effect(exit_state, bb, func, args, dest_place);\n+                    propagate(target, exit_state);\n+                }\n+            }\n+\n+            SwitchInt { ref targets, ref values, ref discr, switch_ty: _ } => {\n+                let enum_ = discr\n+                    .place()\n+                    .and_then(|discr| switch_on_enum_discriminant(tcx, &body, bb_data, discr));\n+                match enum_ {\n+                    // If this is a switch on an enum discriminant, a custom effect may be applied\n+                    // along each outgoing edge.\n+                    Some((enum_place, enum_def)) => {\n+                        // MIR building adds discriminants to the `values` array in the same order as they\n+                        // are yielded by `AdtDef::discriminants`. We rely on this to match each\n+                        // discriminant in `values` to its corresponding variant in linear time.\n+                        let mut tmp = BitSet::new_empty(exit_state.domain_size());\n+                        let mut discriminants = enum_def.discriminants(tcx);\n+                        for (value, target) in values.iter().zip(targets.iter().copied()) {\n+                            let (variant_idx, _) =\n+                                discriminants.find(|&(_, discr)| discr.val == *value).expect(\n+                                    \"Order of `AdtDef::discriminants` differed \\\n+                                         from that of `SwitchInt::values`\",\n+                                );\n+\n+                            tmp.overwrite(exit_state);\n+                            analysis.apply_discriminant_switch_effect(\n+                                &mut tmp,\n+                                bb,\n+                                enum_place,\n+                                enum_def,\n+                                variant_idx,\n+                            );\n+                            propagate(target, &tmp);\n+                        }\n+\n+                        // Move out of `tmp` so we don't accidentally use it below.\n+                        std::mem::drop(tmp);\n+\n+                        // Propagate dataflow state along the \"otherwise\" edge.\n+                        let otherwise = targets.last().copied().unwrap();\n+                        propagate(otherwise, exit_state)\n+                    }\n+\n+                    // Otherwise, it's just a normal `SwitchInt`, and every successor sees the same\n+                    // exit state.\n+                    None => {\n+                        for target in targets.iter().copied() {\n+                            propagate(target, exit_state);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+/// Inspect a `SwitchInt`-terminated basic block to see if the condition of that `SwitchInt` is\n+/// an enum discriminant.\n+///\n+/// We expect such blocks to have a call to `discriminant` as their last statement like so:\n+///   _42 = discriminant(_1)\n+///   SwitchInt(_42, ..)\n+///\n+/// If the basic block matches this pattern, this function returns the place corresponding to the\n+/// enum (`_1` in the example above) as well as the `AdtDef` of that enum.\n+fn switch_on_enum_discriminant(\n+    tcx: TyCtxt<'tcx>,\n+    body: &'mir mir::Body<'tcx>,\n+    block: &'mir mir::BasicBlockData<'tcx>,\n+    switch_on: mir::Place<'tcx>,\n+) -> Option<(mir::Place<'tcx>, &'tcx ty::AdtDef)> {\n+    match block.statements.last().map(|stmt| &stmt.kind) {\n+        Some(mir::StatementKind::Assign(box (lhs, mir::Rvalue::Discriminant(discriminated))))\n+            if *lhs == switch_on =>\n+        {\n+            match &discriminated.ty(body, tcx).ty.kind {\n+                ty::Adt(def, _) => Some((*discriminated, def)),\n+\n+                // `Rvalue::Discriminant` is also used to get the active yield point for a\n+                // generator, but we do not need edge-specific effects in that case. This may\n+                // change in the future.\n+                ty::Generator(..) => None,\n+\n+                t => bug!(\"`discriminant` called on unexpected type {:?}\", t),\n+            }\n+        }\n+\n+        _ => None,\n+    }\n+}"}, {"sha": "32e569fdc3589f9b754dd319827a7bfa84ea4979", "filename": "src/librustc_mir/dataflow/framework/engine.rs", "status": "modified", "additions": 102, "deletions": 236, "changes": 338, "blob_url": "https://github.com/rust-lang/rust/blob/65b448273dd280401cd440a6740a7cd891525ba3/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65b448273dd280401cd440a6740a7cd891525ba3/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fengine.rs?ref=65b448273dd280401cd440a6740a7cd891525ba3", "patch": "@@ -9,14 +9,58 @@ use rustc_data_structures::work_queue::WorkQueue;\n use rustc_hir::def_id::DefId;\n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::IndexVec;\n-use rustc_middle::mir::{self, traversal, BasicBlock, Location};\n+use rustc_middle::mir::{self, traversal, BasicBlock};\n use rustc_middle::ty::{self, TyCtxt};\n use rustc_span::symbol::{sym, Symbol};\n \n use super::graphviz;\n-use super::{Analysis, GenKillAnalysis, GenKillSet, Results};\n+use super::{\n+    visit_results, Analysis, Direction, GenKillAnalysis, GenKillSet, ResultsCursor, ResultsVisitor,\n+};\n use crate::util::pretty::dump_enabled;\n \n+/// A dataflow analysis that has converged to fixpoint.\n+pub struct Results<'tcx, A>\n+where\n+    A: Analysis<'tcx>,\n+{\n+    pub analysis: A,\n+    pub(super) entry_sets: IndexVec<BasicBlock, BitSet<A::Idx>>,\n+}\n+\n+impl<A> Results<'tcx, A>\n+where\n+    A: Analysis<'tcx>,\n+{\n+    /// Creates a `ResultsCursor` that can inspect these `Results`.\n+    pub fn into_results_cursor(self, body: &'mir mir::Body<'tcx>) -> ResultsCursor<'mir, 'tcx, A> {\n+        ResultsCursor::new(body, self)\n+    }\n+\n+    /// Gets the dataflow state for the given block.\n+    pub fn entry_set_for_block(&self, block: BasicBlock) -> &BitSet<A::Idx> {\n+        &self.entry_sets[block]\n+    }\n+\n+    pub fn visit_with(\n+        &self,\n+        body: &'mir mir::Body<'tcx>,\n+        blocks: impl IntoIterator<Item = BasicBlock>,\n+        vis: &mut impl ResultsVisitor<'mir, 'tcx, FlowState = BitSet<A::Idx>>,\n+    ) {\n+        visit_results(body, blocks, self, vis)\n+    }\n+\n+    pub fn visit_in_rpo_with(\n+        &self,\n+        body: &'mir mir::Body<'tcx>,\n+        vis: &mut impl ResultsVisitor<'mir, 'tcx, FlowState = BitSet<A::Idx>>,\n+    ) {\n+        let blocks = mir::traversal::reverse_postorder(body);\n+        visit_results(body, blocks.map(|(bb, _)| bb), self, vis)\n+    }\n+}\n+\n /// A solver for dataflow problems.\n pub struct Engine<'a, 'tcx, A>\n where\n@@ -61,17 +105,7 @@ where\n \n         for (block, block_data) in body.basic_blocks().iter_enumerated() {\n             let trans = &mut trans_for_block[block];\n-\n-            for (i, statement) in block_data.statements.iter().enumerate() {\n-                let loc = Location { block, statement_index: i };\n-                analysis.before_statement_effect(trans, statement, loc);\n-                analysis.statement_effect(trans, statement, loc);\n-            }\n-\n-            let terminator = block_data.terminator();\n-            let loc = Location { block, statement_index: block_data.statements.len() };\n-            analysis.before_terminator_effect(trans, terminator, loc);\n-            analysis.terminator_effect(trans, terminator, loc);\n+            A::Direction::gen_kill_effects_in_block(&analysis, trans, block, block_data);\n         }\n \n         Self::new(tcx, body, def_id, analysis, Some(trans_for_block))\n@@ -111,9 +145,13 @@ where\n             BitSet::new_empty(bits_per_block)\n         };\n \n-        let mut entry_sets = IndexVec::from_elem(bottom_value_set, body.basic_blocks());\n+        let mut entry_sets = IndexVec::from_elem(bottom_value_set.clone(), body.basic_blocks());\n         analysis.initialize_start_block(body, &mut entry_sets[mir::START_BLOCK]);\n \n+        if A::Direction::is_backward() && entry_sets[mir::START_BLOCK] != bottom_value_set {\n+            bug!(\"`initialize_start_block` is not yet supported for backward dataflow analyses\");\n+        }\n+\n         Engine {\n             analysis,\n             bits_per_block,\n@@ -137,251 +175,79 @@ where\n     }\n \n     /// Computes the fixpoint for this dataflow problem and returns it.\n-    pub fn iterate_to_fixpoint(mut self) -> Results<'tcx, A> {\n-        let mut temp_state = BitSet::new_empty(self.bits_per_block);\n+    pub fn iterate_to_fixpoint(self) -> Results<'tcx, A> {\n+        let Engine {\n+            analysis,\n+            bits_per_block,\n+            body,\n+            dead_unwinds,\n+            def_id,\n+            mut entry_sets,\n+            tcx,\n+            trans_for_block,\n+            ..\n+        } = self;\n \n         let mut dirty_queue: WorkQueue<BasicBlock> =\n-            WorkQueue::with_none(self.body.basic_blocks().len());\n+            WorkQueue::with_none(body.basic_blocks().len());\n \n-        for (bb, _) in traversal::reverse_postorder(self.body) {\n-            dirty_queue.insert(bb);\n+        if A::Direction::is_forward() {\n+            for (bb, _) in traversal::reverse_postorder(body) {\n+                dirty_queue.insert(bb);\n+            }\n+        } else {\n+            // Reverse post-order on the reverse CFG may generate a better iteration order for\n+            // backward dataflow analyses, but probably not enough to matter.\n+            for (bb, _) in traversal::postorder(body) {\n+                dirty_queue.insert(bb);\n+            }\n         }\n \n         // Add blocks that are not reachable from START_BLOCK to the work queue. These blocks will\n         // be processed after the ones added above.\n-        for bb in self.body.basic_blocks().indices() {\n+        //\n+        // FIXME(ecstaticmorse): Is this actually necessary? In principle, we shouldn't need to\n+        // know the dataflow state in unreachable basic blocks.\n+        for bb in body.basic_blocks().indices() {\n             dirty_queue.insert(bb);\n         }\n \n+        let mut state = BitSet::new_empty(bits_per_block);\n         while let Some(bb) = dirty_queue.pop() {\n-            let bb_data = &self.body[bb];\n-            let on_entry = &self.entry_sets[bb];\n+            let bb_data = &body[bb];\n \n-            temp_state.overwrite(on_entry);\n-            self.apply_whole_block_effect(&mut temp_state, bb, bb_data);\n+            // Apply the block transfer function, using the cached one if it exists.\n+            state.overwrite(&entry_sets[bb]);\n+            match &trans_for_block {\n+                Some(trans_for_block) => trans_for_block[bb].apply(&mut state),\n+                None => A::Direction::apply_effects_in_block(&analysis, &mut state, bb, bb_data),\n+            }\n \n-            self.propagate_bits_into_graph_successors_of(\n-                &mut temp_state,\n+            A::Direction::join_state_into_successors_of(\n+                &analysis,\n+                tcx,\n+                body,\n+                dead_unwinds,\n+                &mut state,\n                 (bb, bb_data),\n-                &mut dirty_queue,\n+                |target: BasicBlock, state: &BitSet<A::Idx>| {\n+                    let set_changed = analysis.join(&mut entry_sets[target], state);\n+                    if set_changed {\n+                        dirty_queue.insert(target);\n+                    }\n+                },\n             );\n         }\n \n-        let Engine { tcx, body, def_id, trans_for_block, entry_sets, analysis, .. } = self;\n         let results = Results { analysis, entry_sets };\n \n-        let res = write_graphviz_results(tcx, def_id, body, &results, trans_for_block);\n+        let res = write_graphviz_results(tcx, def_id, &body, &results, trans_for_block);\n         if let Err(e) = res {\n             warn!(\"Failed to write graphviz dataflow results: {}\", e);\n         }\n \n         results\n     }\n-\n-    /// Applies the cumulative effect of an entire block, excluding the call return effect if one\n-    /// exists.\n-    fn apply_whole_block_effect(\n-        &self,\n-        state: &mut BitSet<A::Idx>,\n-        block: BasicBlock,\n-        block_data: &mir::BasicBlockData<'tcx>,\n-    ) {\n-        // Use the cached block transfer function if available.\n-        if let Some(trans_for_block) = &self.trans_for_block {\n-            trans_for_block[block].apply(state);\n-            return;\n-        }\n-\n-        // Otherwise apply effects one-by-one.\n-\n-        for (statement_index, statement) in block_data.statements.iter().enumerate() {\n-            let location = Location { block, statement_index };\n-            self.analysis.apply_before_statement_effect(state, statement, location);\n-            self.analysis.apply_statement_effect(state, statement, location);\n-        }\n-\n-        let terminator = block_data.terminator();\n-        let location = Location { block, statement_index: block_data.statements.len() };\n-        self.analysis.apply_before_terminator_effect(state, terminator, location);\n-        self.analysis.apply_terminator_effect(state, terminator, location);\n-    }\n-\n-    fn propagate_bits_into_graph_successors_of(\n-        &mut self,\n-        in_out: &mut BitSet<A::Idx>,\n-        (bb, bb_data): (BasicBlock, &'a mir::BasicBlockData<'tcx>),\n-        dirty_list: &mut WorkQueue<BasicBlock>,\n-    ) {\n-        use mir::TerminatorKind::*;\n-\n-        match bb_data.terminator().kind {\n-            Return | Resume | Abort | GeneratorDrop | Unreachable => {}\n-\n-            Goto { target }\n-            | Assert { target, cleanup: None, .. }\n-            | Drop { target, location: _, unwind: None }\n-            | DropAndReplace { target, value: _, location: _, unwind: None } => {\n-                self.propagate_bits_into_entry_set_for(in_out, target, dirty_list)\n-            }\n-\n-            Yield { resume: target, drop, resume_arg, .. } => {\n-                if let Some(drop) = drop {\n-                    self.propagate_bits_into_entry_set_for(in_out, drop, dirty_list);\n-                }\n-\n-                self.analysis.apply_yield_resume_effect(in_out, target, resume_arg);\n-                self.propagate_bits_into_entry_set_for(in_out, target, dirty_list);\n-            }\n-\n-            Assert { target, cleanup: Some(unwind), .. }\n-            | Drop { target, location: _, unwind: Some(unwind) }\n-            | DropAndReplace { target, value: _, location: _, unwind: Some(unwind) } => {\n-                self.propagate_bits_into_entry_set_for(in_out, target, dirty_list);\n-                if self.dead_unwinds.map_or(true, |bbs| !bbs.contains(bb)) {\n-                    self.propagate_bits_into_entry_set_for(in_out, unwind, dirty_list);\n-                }\n-            }\n-\n-            SwitchInt { ref targets, ref values, ref discr, .. } => {\n-                let Engine { tcx, body, .. } = *self;\n-                let enum_ = discr\n-                    .place()\n-                    .and_then(|discr| switch_on_enum_discriminant(tcx, body, bb_data, discr));\n-                match enum_ {\n-                    // If this is a switch on an enum discriminant, a custom effect may be applied\n-                    // along each outgoing edge.\n-                    Some((enum_place, enum_def)) => {\n-                        self.propagate_bits_into_enum_discriminant_switch_successors(\n-                            in_out, bb, enum_def, enum_place, dirty_list, &*values, &*targets,\n-                        );\n-                    }\n-\n-                    // Otherwise, it's just a normal `SwitchInt`, and every successor sees the same\n-                    // exit state.\n-                    None => {\n-                        for target in targets.iter().copied() {\n-                            self.propagate_bits_into_entry_set_for(&in_out, target, dirty_list);\n-                        }\n-                    }\n-                }\n-            }\n-\n-            Call { cleanup, ref destination, ref func, ref args, .. } => {\n-                if let Some(unwind) = cleanup {\n-                    if self.dead_unwinds.map_or(true, |bbs| !bbs.contains(bb)) {\n-                        self.propagate_bits_into_entry_set_for(in_out, unwind, dirty_list);\n-                    }\n-                }\n-\n-                if let Some((dest_place, dest_bb)) = *destination {\n-                    // N.B.: This must be done *last*, otherwise the unwind path will see the call\n-                    // return effect.\n-                    self.analysis.apply_call_return_effect(in_out, bb, func, args, dest_place);\n-                    self.propagate_bits_into_entry_set_for(in_out, dest_bb, dirty_list);\n-                }\n-            }\n-\n-            FalseEdges { real_target, imaginary_target } => {\n-                self.propagate_bits_into_entry_set_for(in_out, real_target, dirty_list);\n-                self.propagate_bits_into_entry_set_for(in_out, imaginary_target, dirty_list);\n-            }\n-\n-            FalseUnwind { real_target, unwind } => {\n-                self.propagate_bits_into_entry_set_for(in_out, real_target, dirty_list);\n-                if let Some(unwind) = unwind {\n-                    if self.dead_unwinds.map_or(true, |bbs| !bbs.contains(bb)) {\n-                        self.propagate_bits_into_entry_set_for(in_out, unwind, dirty_list);\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    fn propagate_bits_into_entry_set_for(\n-        &mut self,\n-        in_out: &BitSet<A::Idx>,\n-        bb: BasicBlock,\n-        dirty_queue: &mut WorkQueue<BasicBlock>,\n-    ) {\n-        let entry_set = &mut self.entry_sets[bb];\n-        let set_changed = self.analysis.join(entry_set, &in_out);\n-        if set_changed {\n-            dirty_queue.insert(bb);\n-        }\n-    }\n-\n-    fn propagate_bits_into_enum_discriminant_switch_successors(\n-        &mut self,\n-        in_out: &mut BitSet<A::Idx>,\n-        bb: BasicBlock,\n-        enum_def: &'tcx ty::AdtDef,\n-        enum_place: mir::Place<'tcx>,\n-        dirty_list: &mut WorkQueue<BasicBlock>,\n-        values: &[u128],\n-        targets: &[BasicBlock],\n-    ) {\n-        // MIR building adds discriminants to the `values` array in the same order as they\n-        // are yielded by `AdtDef::discriminants`. We rely on this to match each\n-        // discriminant in `values` to its corresponding variant in linear time.\n-        let mut tmp = BitSet::new_empty(in_out.domain_size());\n-        let mut discriminants = enum_def.discriminants(self.tcx);\n-        for (value, target) in values.iter().zip(targets.iter().copied()) {\n-            let (variant_idx, _) = discriminants.find(|&(_, discr)| discr.val == *value).expect(\n-                \"Order of `AdtDef::discriminants` differed from that of `SwitchInt::values`\",\n-            );\n-\n-            tmp.overwrite(in_out);\n-            self.analysis.apply_discriminant_switch_effect(\n-                &mut tmp,\n-                bb,\n-                enum_place,\n-                enum_def,\n-                variant_idx,\n-            );\n-            self.propagate_bits_into_entry_set_for(&tmp, target, dirty_list);\n-        }\n-\n-        std::mem::drop(tmp);\n-\n-        // Propagate dataflow state along the \"otherwise\" edge.\n-        let otherwise = targets.last().copied().unwrap();\n-        self.propagate_bits_into_entry_set_for(&in_out, otherwise, dirty_list);\n-    }\n-}\n-\n-/// Inspect a `SwitchInt`-terminated basic block to see if the condition of that `SwitchInt` is\n-/// an enum discriminant.\n-///\n-/// We expect such blocks to have a call to `discriminant` as their last statement like so:\n-///   _42 = discriminant(_1)\n-///   SwitchInt(_42, ..)\n-///\n-/// If the basic block matches this pattern, this function returns the place corresponding to the\n-/// enum (`_1` in the example above) as well as the `AdtDef` of that enum.\n-fn switch_on_enum_discriminant(\n-    tcx: TyCtxt<'tcx>,\n-    body: &'mir mir::Body<'tcx>,\n-    block: &'mir mir::BasicBlockData<'tcx>,\n-    switch_on: mir::Place<'tcx>,\n-) -> Option<(mir::Place<'tcx>, &'tcx ty::AdtDef)> {\n-    match block.statements.last().map(|stmt| &stmt.kind) {\n-        Some(mir::StatementKind::Assign(box (lhs, mir::Rvalue::Discriminant(discriminated))))\n-            if *lhs == switch_on =>\n-        {\n-            match &discriminated.ty(body, tcx).ty.kind {\n-                ty::Adt(def, _) => Some((*discriminated, def)),\n-\n-                // `Rvalue::Discriminant` is also used to get the active yield point for a\n-                // generator, but we do not need edge-specific effects in that case. This may\n-                // change in the future.\n-                ty::Generator(..) => None,\n-\n-                t => bug!(\"`discriminant` called on unexpected type {:?}\", t),\n-            }\n-        }\n-\n-        _ => None,\n-    }\n }\n \n // Graphviz\n@@ -431,12 +297,12 @@ where\n             if let Some(trans_for_block) = block_transfer_functions {\n                 Box::new(graphviz::BlockTransferFunc::new(body, trans_for_block))\n             } else {\n-                Box::new(graphviz::SimpleDiff::new(bits_per_block))\n+                Box::new(graphviz::SimpleDiff::new(body, &results))\n             }\n         }\n \n         // Default to the `SimpleDiff` output style.\n-        _ => Box::new(graphviz::SimpleDiff::new(bits_per_block)),\n+        _ => Box::new(graphviz::SimpleDiff::new(body, &results)),\n     };\n \n     debug!(\"printing dataflow results for {:?} to {}\", def_id, path.display());"}, {"sha": "e3ba26eaf8b372ba74e40c22b899c2aef11e15ad", "filename": "src/librustc_mir/dataflow/framework/graphviz.rs", "status": "modified", "additions": 91, "deletions": 44, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/65b448273dd280401cd440a6740a7cd891525ba3/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65b448273dd280401cd440a6740a7cd891525ba3/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fgraphviz.rs?ref=65b448273dd280401cd440a6740a7cd891525ba3", "patch": "@@ -8,7 +8,7 @@ use rustc_index::bit_set::{BitSet, HybridBitSet};\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_middle::mir::{self, BasicBlock, Body, Location};\n \n-use super::{Analysis, GenKillSet, Results, ResultsRefCursor};\n+use super::{Analysis, Direction, GenKillSet, Results, ResultsRefCursor};\n use crate::util::graphviz_safe_def_name;\n \n pub struct Formatter<'a, 'tcx, A>\n@@ -49,7 +49,7 @@ pub struct CfgEdge {\n     index: usize,\n }\n \n-fn outgoing_edges(body: &Body<'_>, bb: BasicBlock) -> Vec<CfgEdge> {\n+fn dataflow_successors(body: &Body<'tcx>, bb: BasicBlock) -> Vec<CfgEdge> {\n     body[bb]\n         .terminator()\n         .successors()\n@@ -105,7 +105,7 @@ where\n         self.body\n             .basic_blocks()\n             .indices()\n-            .flat_map(|bb| outgoing_edges(self.body, bb))\n+            .flat_map(|bb| dataflow_successors(self.body, bb))\n             .collect::<Vec<_>>()\n             .into()\n     }\n@@ -192,12 +192,12 @@ where\n             self.write_block_header_with_state_columns(w, block)?;\n         }\n \n-        // C: Entry state\n+        // C: State at start of block\n         self.bg = Background::Light;\n         self.results.seek_to_block_start(block);\n         let block_entry_state = self.results.get().clone();\n \n-        self.write_row_with_full_state(w, \"\", \"(on entry)\")?;\n+        self.write_row_with_full_state(w, \"\", \"(on start)\")?;\n \n         // D: Statement transfer functions\n         for (i, statement) in body[block].statements.iter().enumerate() {\n@@ -214,37 +214,72 @@ where\n \n         self.write_row_for_location(w, \"T\", &terminator_str, terminator_loc)?;\n \n-        // F: Exit state\n+        // F: State at end of block\n \n         // Write the full dataflow state immediately after the terminator if it differs from the\n         // state at block entry.\n-        self.results.seek_after(terminator_loc);\n-        if self.results.get() != &block_entry_state {\n+        self.results.seek_to_block_end(block);\n+        if self.results.get() != &block_entry_state || A::Direction::is_backward() {\n             let after_terminator_name = match terminator.kind {\n                 mir::TerminatorKind::Call { destination: Some(_), .. } => \"(on unwind)\",\n-                _ => \"(on exit)\",\n+                _ => \"(on end)\",\n             };\n \n             self.write_row_with_full_state(w, \"\", after_terminator_name)?;\n         }\n \n         // Write any changes caused by terminator-specific effects\n-        if let mir::TerminatorKind::Call { destination: Some(_), .. } = terminator.kind {\n-            let num_state_columns = self.num_state_columns();\n-            self.write_row(w, \"\", \"(on successful return)\", |this, w, fmt| {\n-                write!(\n-                    w,\n-                    r#\"<td balign=\"left\" colspan=\"{colspan}\" {fmt} align=\"left\">\"#,\n-                    colspan = num_state_columns,\n-                    fmt = fmt,\n-                )?;\n-\n-                let state_on_unwind = this.results.get().clone();\n-                this.results.seek_after_assume_success(terminator_loc);\n-                write_diff(w, this.results.analysis(), &state_on_unwind, this.results.get())?;\n-\n-                write!(w, \"</td>\")\n-            })?;\n+        let num_state_columns = self.num_state_columns();\n+        match terminator.kind {\n+            mir::TerminatorKind::Call {\n+                destination: Some((return_place, _)),\n+                ref func,\n+                ref args,\n+                ..\n+            } => {\n+                self.write_row(w, \"\", \"(on successful return)\", |this, w, fmt| {\n+                    write!(\n+                        w,\n+                        r#\"<td balign=\"left\" colspan=\"{colspan}\" {fmt} align=\"left\">\"#,\n+                        colspan = num_state_columns,\n+                        fmt = fmt,\n+                    )?;\n+\n+                    let state_on_unwind = this.results.get().clone();\n+                    this.results.apply_custom_effect(|analysis, state| {\n+                        analysis.apply_call_return_effect(state, block, func, args, return_place);\n+                    });\n+\n+                    write_diff(w, this.results.analysis(), &state_on_unwind, this.results.get())?;\n+                    write!(w, \"</td>\")\n+                })?;\n+            }\n+\n+            mir::TerminatorKind::Yield { resume, resume_arg, .. } => {\n+                self.write_row(w, \"\", \"(on yield resume)\", |this, w, fmt| {\n+                    write!(\n+                        w,\n+                        r#\"<td balign=\"left\" colspan=\"{colspan}\" {fmt} align=\"left\">\"#,\n+                        colspan = num_state_columns,\n+                        fmt = fmt,\n+                    )?;\n+\n+                    let state_on_generator_drop = this.results.get().clone();\n+                    this.results.apply_custom_effect(|analysis, state| {\n+                        analysis.apply_yield_resume_effect(state, resume, resume_arg);\n+                    });\n+\n+                    write_diff(\n+                        w,\n+                        this.results.analysis(),\n+                        &state_on_generator_drop,\n+                        this.results.get(),\n+                    )?;\n+                    write!(w, \"</td>\")\n+                })?;\n+            }\n+\n+            _ => {}\n         };\n \n         write!(w, \"</table>\")\n@@ -403,18 +438,23 @@ where\n }\n \n /// Prints a single column containing the state vector immediately *after* each statement.\n-pub struct SimpleDiff<T: Idx> {\n-    prev_state: BitSet<T>,\n-    prev_loc: Location,\n+pub struct SimpleDiff<'a, 'tcx, A>\n+where\n+    A: Analysis<'tcx>,\n+{\n+    prev_state: ResultsRefCursor<'a, 'a, 'tcx, A>,\n }\n \n-impl<T: Idx> SimpleDiff<T> {\n-    pub fn new(bits_per_block: usize) -> Self {\n-        SimpleDiff { prev_state: BitSet::new_empty(bits_per_block), prev_loc: Location::START }\n+impl<A> SimpleDiff<'a, 'tcx, A>\n+where\n+    A: Analysis<'tcx>,\n+{\n+    pub fn new(body: &'a Body<'tcx>, results: &'a Results<'tcx, A>) -> Self {\n+        SimpleDiff { prev_state: ResultsRefCursor::new(body, results) }\n     }\n }\n \n-impl<A> StateFormatter<'tcx, A> for SimpleDiff<A::Idx>\n+impl<A> StateFormatter<'tcx, A> for SimpleDiff<'_, 'tcx, A>\n where\n     A: Analysis<'tcx>,\n {\n@@ -429,20 +469,27 @@ where\n         results: &mut ResultsRefCursor<'_, '_, 'tcx, A>,\n         location: Location,\n     ) -> io::Result<()> {\n-        if location.statement_index == 0 {\n-            results.seek_to_block_start(location.block);\n-            self.prev_state.overwrite(results.get());\n+        if A::Direction::is_forward() {\n+            if location.statement_index == 0 {\n+                self.prev_state.seek_to_block_start(location.block);\n+            } else {\n+                self.prev_state.seek_after_primary_effect(Location {\n+                    statement_index: location.statement_index - 1,\n+                    ..location\n+                });\n+            }\n         } else {\n-            // Ensure that we are visiting statements in order, so `prev_state` is correct.\n-            assert_eq!(self.prev_loc.successor_within_block(), location);\n+            if location == results.body().terminator_loc(location.block) {\n+                self.prev_state.seek_to_block_end(location.block);\n+            } else {\n+                self.prev_state.seek_after_primary_effect(location.successor_within_block());\n+            }\n         }\n \n-        self.prev_loc = location;\n         write!(w, r#\"<td {fmt} balign=\"left\" align=\"left\">\"#, fmt = fmt)?;\n-        results.seek_after(location);\n+        results.seek_after_primary_effect(location);\n         let curr_state = results.get();\n-        write_diff(&mut w, results.analysis(), &self.prev_state, curr_state)?;\n-        self.prev_state.overwrite(curr_state);\n+        write_diff(&mut w, results.analysis(), self.prev_state.get(), curr_state)?;\n         write!(w, \"</td>\")\n     }\n }\n@@ -476,7 +523,7 @@ where\n         location: Location,\n     ) -> io::Result<()> {\n         if location.statement_index == 0 {\n-            results.seek_to_block_start(location.block);\n+            results.seek_to_block_entry(location.block);\n             self.prev_state.overwrite(results.get());\n         } else {\n             // Ensure that we are visiting statements in order, so `prev_state` is correct.\n@@ -488,7 +535,7 @@ where\n         // Before\n \n         write!(w, r#\"<td {fmt} align=\"left\">\"#, fmt = fmt)?;\n-        results.seek_before(location);\n+        results.seek_before_primary_effect(location);\n         let curr_state = results.get();\n         write_diff(&mut w, results.analysis(), &self.prev_state, curr_state)?;\n         self.prev_state.overwrite(curr_state);\n@@ -497,7 +544,7 @@ where\n         // After\n \n         write!(w, r#\"<td {fmt} align=\"left\">\"#, fmt = fmt)?;\n-        results.seek_after(location);\n+        results.seek_after_primary_effect(location);\n         let curr_state = results.get();\n         write_diff(&mut w, results.analysis(), &self.prev_state, curr_state)?;\n         self.prev_state.overwrite(curr_state);"}, {"sha": "a21bbacb4676646ae5aca028f2e608e95ea6bc71", "filename": "src/librustc_mir/dataflow/framework/mod.rs", "status": "modified", "additions": 77, "deletions": 45, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/65b448273dd280401cd440a6740a7cd891525ba3/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65b448273dd280401cd440a6740a7cd891525ba3/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fmod.rs?ref=65b448273dd280401cd440a6740a7cd891525ba3", "patch": "@@ -30,67 +30,28 @@\n //!\n //! [gen-kill]: https://en.wikipedia.org/wiki/Data-flow_analysis#Bit_vector_problems\n \n+use std::cmp::Ordering;\n use std::io;\n \n use rustc_hir::def_id::DefId;\n use rustc_index::bit_set::{BitSet, HybridBitSet};\n-use rustc_index::vec::{Idx, IndexVec};\n+use rustc_index::vec::Idx;\n use rustc_middle::mir::{self, BasicBlock, Location};\n use rustc_middle::ty::{self, TyCtxt};\n use rustc_target::abi::VariantIdx;\n \n mod cursor;\n+mod direction;\n mod engine;\n mod graphviz;\n mod visitor;\n \n pub use self::cursor::{ResultsCursor, ResultsRefCursor};\n-pub use self::engine::Engine;\n+pub use self::direction::{Backward, Direction, Forward};\n+pub use self::engine::{Engine, Results};\n pub use self::visitor::{visit_results, ResultsVisitor};\n pub use self::visitor::{BorrowckFlowState, BorrowckResults};\n \n-/// A dataflow analysis that has converged to fixpoint.\n-pub struct Results<'tcx, A>\n-where\n-    A: Analysis<'tcx>,\n-{\n-    pub analysis: A,\n-    entry_sets: IndexVec<BasicBlock, BitSet<A::Idx>>,\n-}\n-\n-impl<A> Results<'tcx, A>\n-where\n-    A: Analysis<'tcx>,\n-{\n-    /// Creates a `ResultsCursor` that can inspect these `Results`.\n-    pub fn into_results_cursor(self, body: &'mir mir::Body<'tcx>) -> ResultsCursor<'mir, 'tcx, A> {\n-        ResultsCursor::new(body, self)\n-    }\n-\n-    /// Gets the entry set for the given block.\n-    pub fn entry_set_for_block(&self, block: BasicBlock) -> &BitSet<A::Idx> {\n-        &self.entry_sets[block]\n-    }\n-\n-    pub fn visit_with(\n-        &self,\n-        body: &'mir mir::Body<'tcx>,\n-        blocks: impl IntoIterator<Item = BasicBlock>,\n-        vis: &mut impl ResultsVisitor<'mir, 'tcx, FlowState = BitSet<A::Idx>>,\n-    ) {\n-        visit_results(body, blocks, self, vis)\n-    }\n-\n-    pub fn visit_in_rpo_with(\n-        &self,\n-        body: &'mir mir::Body<'tcx>,\n-        vis: &mut impl ResultsVisitor<'mir, 'tcx, FlowState = BitSet<A::Idx>>,\n-    ) {\n-        let blocks = mir::traversal::reverse_postorder(body);\n-        visit_results(body, blocks.map(|(bb, _)| bb), self, vis)\n-    }\n-}\n-\n /// Parameterization for the precise form of data flow that is used.\n ///\n /// `BottomValue` determines whether the initial entry set for each basic block is empty or full.\n@@ -144,6 +105,9 @@ pub trait AnalysisDomain<'tcx>: BottomValue {\n     /// The type of the elements in the state vector.\n     type Idx: Idx;\n \n+    /// The direction of this analyis. Either `Forward` or `Backward`.\n+    type Direction: Direction = Forward;\n+\n     /// A descriptive name for this analysis. Used only for debugging.\n     ///\n     /// This name should be brief and contain no spaces, periods or other characters that are not\n@@ -155,6 +119,13 @@ pub trait AnalysisDomain<'tcx>: BottomValue {\n \n     /// Mutates the entry set of the `START_BLOCK` to contain the initial state for dataflow\n     /// analysis.\n+    ///\n+    /// For backward analyses, initial state besides the bottom value is not yet supported. Trying\n+    /// to mutate the initial state will result in a panic.\n+    //\n+    // FIXME: For backward dataflow analyses, the initial state should be applied to every basic\n+    // block where control flow could exit the MIR body (e.g., those terminated with `return` or\n+    // `resume`). It's not obvious how to handle `yield` points in generators, however.\n     fn initialize_start_block(&self, body: &mir::Body<'tcx>, state: &mut BitSet<Self::Idx>);\n \n     /// Prints an element in the state vector for debugging.\n@@ -247,6 +218,8 @@ pub trait Analysis<'tcx>: AnalysisDomain<'tcx> {\n     ///\n     /// Much like `apply_call_return_effect`, this effect is only propagated along a single\n     /// outgoing edge from this basic block.\n+    ///\n+    /// FIXME: This class of effects is not supported for backward dataflow analyses.\n     fn apply_discriminant_switch_effect(\n         &self,\n         _state: &mut BitSet<Self::Idx>,\n@@ -338,7 +311,7 @@ pub trait GenKillAnalysis<'tcx>: Analysis<'tcx> {\n     /// See `Analysis::apply_yield_resume_effect`.\n     fn yield_resume_effect(\n         &self,\n-        _trans: &mut BitSet<Self::Idx>,\n+        _trans: &mut impl GenKill<Self::Idx>,\n         _resume_block: BasicBlock,\n         _resume_place: mir::Place<'tcx>,\n     ) {\n@@ -520,5 +493,64 @@ impl<T: Idx> GenKill<T> for BitSet<T> {\n     }\n }\n \n+// NOTE: DO NOT CHANGE VARIANT ORDER. The derived `Ord` impls rely on the current order.\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]\n+pub enum Effect {\n+    /// The \"before\" effect (e.g., `apply_before_statement_effect`) for a statement (or\n+    /// terminator).\n+    Before,\n+\n+    /// The \"primary\" effect (e.g., `apply_statement_effect`) for a statement (or terminator).\n+    Primary,\n+}\n+\n+impl Effect {\n+    pub const fn at_index(self, statement_index: usize) -> EffectIndex {\n+        EffectIndex { effect: self, statement_index }\n+    }\n+}\n+\n+#[derive(Clone, Copy, Debug, PartialEq, Eq)]\n+pub struct EffectIndex {\n+    statement_index: usize,\n+    effect: Effect,\n+}\n+\n+impl EffectIndex {\n+    fn next_in_forward_order(self) -> Self {\n+        match self.effect {\n+            Effect::Before => Effect::Primary.at_index(self.statement_index),\n+            Effect::Primary => Effect::Before.at_index(self.statement_index + 1),\n+        }\n+    }\n+\n+    fn next_in_backward_order(self) -> Self {\n+        match self.effect {\n+            Effect::Before => Effect::Primary.at_index(self.statement_index),\n+            Effect::Primary => Effect::Before.at_index(self.statement_index - 1),\n+        }\n+    }\n+\n+    /// Returns `true` if the effect at `self` should be applied eariler than the effect at `other`\n+    /// in forward order.\n+    fn precedes_in_forward_order(self, other: Self) -> bool {\n+        let ord = self\n+            .statement_index\n+            .cmp(&other.statement_index)\n+            .then_with(|| self.effect.cmp(&other.effect));\n+        ord == Ordering::Less\n+    }\n+\n+    /// Returns `true` if the effect at `self` should be applied earlier than the effect at `other`\n+    /// in backward order.\n+    fn precedes_in_backward_order(self, other: Self) -> bool {\n+        let ord = other\n+            .statement_index\n+            .cmp(&self.statement_index)\n+            .then_with(|| self.effect.cmp(&other.effect));\n+        ord == Ordering::Less\n+    }\n+}\n+\n #[cfg(test)]\n mod tests;"}, {"sha": "a8dce7079b7a8b08ff8a564776a3ae13d57abc0f", "filename": "src/librustc_mir/dataflow/framework/tests.rs", "status": "modified", "additions": 77, "deletions": 86, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/65b448273dd280401cd440a6740a7cd891525ba3/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65b448273dd280401cd440a6740a7cd891525ba3/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Ftests.rs?ref=65b448273dd280401cd440a6740a7cd891525ba3", "patch": "@@ -1,5 +1,7 @@\n //! A test for the logic that updates the state in a `ResultsCursor` during seek.\n \n+use std::marker::PhantomData;\n+\n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::IndexVec;\n use rustc_middle::mir::{self, BasicBlock, Location};\n@@ -9,16 +11,6 @@ use rustc_span::DUMMY_SP;\n use super::*;\n use crate::dataflow::BottomValue;\n \n-/// Returns `true` if the given location points to a `Call` terminator that can return\n-/// successfully.\n-fn is_call_terminator_non_diverging(body: &mir::Body<'_>, loc: Location) -> bool {\n-    loc == body.terminator_loc(loc.block)\n-        && matches!(\n-            body[loc.block].terminator().kind,\n-            mir::TerminatorKind::Call { destination: Some(_), ..  }\n-        )\n-}\n-\n /// Creates a `mir::Body` with a few disconnected basic blocks.\n ///\n /// This is the `Body` that will be used by the `MockAnalysis` below. The shape of its CFG is not\n@@ -79,20 +71,20 @@ fn mock_body() -> mir::Body<'static> {\n /// | Location               | Before            | After  |\n /// |------------------------|-------------------|--------|\n /// | (on_entry)             | {102}                     ||\n-/// | Statement 0            | +0                | +1     |\n+/// | statement 0            | +0                | +1     |\n /// | statement 1            | +2                | +3     |\n /// | `Call` terminator      | +4                | +5     |\n /// | (on unwind)            | {102,0,1,2,3,4,5}         ||\n-/// | (on successful return) | +6                        ||\n ///\n /// The `102` in the block's entry set is derived from the basic block index and ensures that the\n /// expected state is unique across all basic blocks. Remember, it is generated by\n /// `mock_entry_sets`, not from actually running `MockAnalysis` to fixpoint.\n-struct MockAnalysis<'tcx> {\n+struct MockAnalysis<'tcx, D> {\n     body: &'tcx mir::Body<'tcx>,\n+    dir: PhantomData<D>,\n }\n \n-impl MockAnalysis<'tcx> {\n+impl<D: Direction> MockAnalysis<'tcx, D> {\n     const BASIC_BLOCK_OFFSET: usize = 100;\n \n     /// The entry set for each `BasicBlock` is the ID of that block offset by a fixed amount to\n@@ -115,25 +107,14 @@ impl MockAnalysis<'tcx> {\n     }\n \n     /// Returns the index that should be added to the dataflow state at the given target.\n-    ///\n-    /// This index is only unique within a given basic block. `SeekAfter` and\n-    /// `SeekAfterAssumeCallReturns` have the same effect unless `target` is a `Call` terminator.\n-    fn effect_at_target(&self, target: SeekTarget) -> Option<usize> {\n-        use SeekTarget::*;\n-\n-        let idx = match target {\n-            BlockStart(_) => return None,\n-\n-            AfterAssumeCallReturns(loc) if is_call_terminator_non_diverging(self.body, loc) => {\n-                loc.statement_index * 2 + 2\n-            }\n-\n-            Before(loc) => loc.statement_index * 2,\n-            After(loc) | AfterAssumeCallReturns(loc) => loc.statement_index * 2 + 1,\n+    fn effect(&self, loc: EffectIndex) -> usize {\n+        let idx = match loc.effect {\n+            Effect::Before => loc.statement_index * 2,\n+            Effect::Primary => loc.statement_index * 2 + 1,\n         };\n \n         assert!(idx < Self::BASIC_BLOCK_OFFSET, \"Too many statements in basic block\");\n-        Some(idx)\n+        idx\n     }\n \n     /// Returns the expected state at the given `SeekTarget`.\n@@ -143,27 +124,48 @@ impl MockAnalysis<'tcx> {\n     /// basic block.\n     ///\n     /// For example, the expected state when calling\n-    /// `seek_before(Location { block: 2, statement_index: 2 })` would be `[102, 0, 1, 2, 3, 4]`.\n+    /// `seek_before_primary_effect(Location { block: 2, statement_index: 2 })`\n+    /// would be `[102, 0, 1, 2, 3, 4]`.\n     fn expected_state_at_target(&self, target: SeekTarget) -> BitSet<usize> {\n+        let block = target.block();\n         let mut ret = BitSet::new_empty(self.bits_per_block(self.body));\n-        ret.insert(Self::BASIC_BLOCK_OFFSET + target.block().index());\n+        ret.insert(Self::BASIC_BLOCK_OFFSET + block.index());\n \n-        if let Some(target_effect) = self.effect_at_target(target) {\n-            for i in 0..=target_effect {\n-                ret.insert(i);\n+        let target = match target {\n+            SeekTarget::BlockEntry { .. } => return ret,\n+            SeekTarget::Before(loc) => Effect::Before.at_index(loc.statement_index),\n+            SeekTarget::After(loc) => Effect::Primary.at_index(loc.statement_index),\n+        };\n+\n+        let mut pos = if D::is_forward() {\n+            Effect::Before.at_index(0)\n+        } else {\n+            Effect::Before.at_index(self.body[block].statements.len())\n+        };\n+\n+        loop {\n+            ret.insert(self.effect(pos));\n+\n+            if pos == target {\n+                return ret;\n             }\n-        }\n \n-        ret\n+            if D::is_forward() {\n+                pos = pos.next_in_forward_order();\n+            } else {\n+                pos = pos.next_in_backward_order();\n+            }\n+        }\n     }\n }\n \n-impl BottomValue for MockAnalysis<'tcx> {\n+impl<D: Direction> BottomValue for MockAnalysis<'tcx, D> {\n     const BOTTOM_VALUE: bool = false;\n }\n \n-impl AnalysisDomain<'tcx> for MockAnalysis<'tcx> {\n+impl<D: Direction> AnalysisDomain<'tcx> for MockAnalysis<'tcx, D> {\n     type Idx = usize;\n+    type Direction = D;\n \n     const NAME: &'static str = \"mock\";\n \n@@ -176,14 +178,14 @@ impl AnalysisDomain<'tcx> for MockAnalysis<'tcx> {\n     }\n }\n \n-impl Analysis<'tcx> for MockAnalysis<'tcx> {\n+impl<D: Direction> Analysis<'tcx> for MockAnalysis<'tcx, D> {\n     fn apply_statement_effect(\n         &self,\n         state: &mut BitSet<Self::Idx>,\n         _statement: &mir::Statement<'tcx>,\n         location: Location,\n     ) {\n-        let idx = self.effect_at_target(SeekTarget::After(location)).unwrap();\n+        let idx = self.effect(Effect::Primary.at_index(location.statement_index));\n         assert!(state.insert(idx));\n     }\n \n@@ -193,7 +195,7 @@ impl Analysis<'tcx> for MockAnalysis<'tcx> {\n         _statement: &mir::Statement<'tcx>,\n         location: Location,\n     ) {\n-        let idx = self.effect_at_target(SeekTarget::Before(location)).unwrap();\n+        let idx = self.effect(Effect::Before.at_index(location.statement_index));\n         assert!(state.insert(idx));\n     }\n \n@@ -203,7 +205,7 @@ impl Analysis<'tcx> for MockAnalysis<'tcx> {\n         _terminator: &mir::Terminator<'tcx>,\n         location: Location,\n     ) {\n-        let idx = self.effect_at_target(SeekTarget::After(location)).unwrap();\n+        let idx = self.effect(Effect::Primary.at_index(location.statement_index));\n         assert!(state.insert(idx));\n     }\n \n@@ -213,90 +215,62 @@ impl Analysis<'tcx> for MockAnalysis<'tcx> {\n         _terminator: &mir::Terminator<'tcx>,\n         location: Location,\n     ) {\n-        let idx = self.effect_at_target(SeekTarget::Before(location)).unwrap();\n+        let idx = self.effect(Effect::Before.at_index(location.statement_index));\n         assert!(state.insert(idx));\n     }\n \n     fn apply_call_return_effect(\n         &self,\n-        state: &mut BitSet<Self::Idx>,\n-        block: BasicBlock,\n+        _state: &mut BitSet<Self::Idx>,\n+        _block: BasicBlock,\n         _func: &mir::Operand<'tcx>,\n         _args: &[mir::Operand<'tcx>],\n         _return_place: mir::Place<'tcx>,\n     ) {\n-        let location = self.body.terminator_loc(block);\n-        let idx = self.effect_at_target(SeekTarget::AfterAssumeCallReturns(location)).unwrap();\n-        assert!(state.insert(idx));\n     }\n }\n \n #[derive(Clone, Copy, Debug, PartialEq, Eq)]\n enum SeekTarget {\n-    BlockStart(BasicBlock),\n+    BlockEntry(BasicBlock),\n     Before(Location),\n     After(Location),\n-    AfterAssumeCallReturns(Location),\n }\n \n impl SeekTarget {\n     fn block(&self) -> BasicBlock {\n         use SeekTarget::*;\n \n         match *self {\n-            BlockStart(block) => block,\n-            Before(loc) | After(loc) | AfterAssumeCallReturns(loc) => loc.block,\n+            BlockEntry(block) => block,\n+            Before(loc) | After(loc) => loc.block,\n         }\n     }\n \n     /// An iterator over all possible `SeekTarget`s in a given block in order, starting with\n-    /// `BlockStart`.\n-    ///\n-    /// This includes both `After` and `AfterAssumeCallReturns` for every `Location`.\n+    /// `BlockEntry`.\n     fn iter_in_block(body: &mir::Body<'_>, block: BasicBlock) -> impl Iterator<Item = Self> {\n         let statements_and_terminator = (0..=body[block].statements.len())\n-            .flat_map(|i| (0..3).map(move |j| (i, j)))\n+            .flat_map(|i| (0..2).map(move |j| (i, j)))\n             .map(move |(i, kind)| {\n                 let loc = Location { block, statement_index: i };\n                 match kind {\n                     0 => SeekTarget::Before(loc),\n                     1 => SeekTarget::After(loc),\n-                    2 => SeekTarget::AfterAssumeCallReturns(loc),\n                     _ => unreachable!(),\n                 }\n             });\n \n-        std::iter::once(SeekTarget::BlockStart(block)).chain(statements_and_terminator)\n+        std::iter::once(SeekTarget::BlockEntry(block)).chain(statements_and_terminator)\n     }\n }\n \n-#[test]\n-fn cursor_seek() {\n-    let body = mock_body();\n-    let body = &body;\n-    let analysis = MockAnalysis { body };\n+fn test_cursor<D: Direction>(analysis: MockAnalysis<'tcx, D>) {\n+    let body = analysis.body;\n \n     let mut cursor =\n         Results { entry_sets: analysis.mock_entry_sets(), analysis }.into_results_cursor(body);\n \n-    // Sanity check: the mock call return effect is unique and actually being applied.\n-    let call_terminator_loc = Location { block: BasicBlock::from_usize(2), statement_index: 2 };\n-    assert!(is_call_terminator_non_diverging(body, call_terminator_loc));\n-\n-    let call_return_effect = cursor\n-        .analysis()\n-        .effect_at_target(SeekTarget::AfterAssumeCallReturns(call_terminator_loc))\n-        .unwrap();\n-    assert_ne!(\n-        call_return_effect,\n-        cursor.analysis().effect_at_target(SeekTarget::After(call_terminator_loc)).unwrap()\n-    );\n-\n-    cursor.seek_after(call_terminator_loc);\n-    assert!(!cursor.get().contains(call_return_effect));\n-    cursor.seek_after_assume_success(call_terminator_loc);\n-    assert!(cursor.get().contains(call_return_effect));\n-\n     let every_target = || {\n         body.basic_blocks()\n             .iter_enumerated()\n@@ -307,10 +281,9 @@ fn cursor_seek() {\n         use SeekTarget::*;\n \n         match targ {\n-            BlockStart(block) => cursor.seek_to_block_start(block),\n-            Before(loc) => cursor.seek_before(loc),\n-            After(loc) => cursor.seek_after(loc),\n-            AfterAssumeCallReturns(loc) => cursor.seek_after_assume_success(loc),\n+            BlockEntry(block) => cursor.seek_to_block_entry(block),\n+            Before(loc) => cursor.seek_before_primary_effect(loc),\n+            After(loc) => cursor.seek_after_primary_effect(loc),\n         }\n \n         assert_eq!(cursor.get(), &cursor.analysis().expected_state_at_target(targ));\n@@ -325,8 +298,26 @@ fn cursor_seek() {\n         seek_to_target(from);\n \n         for to in every_target() {\n+            dbg!(from);\n+            dbg!(to);\n             seek_to_target(to);\n             seek_to_target(from);\n         }\n     }\n }\n+\n+#[test]\n+fn backward_cursor() {\n+    let body = mock_body();\n+    let body = &body;\n+    let analysis = MockAnalysis { body, dir: PhantomData::<Backward> };\n+    test_cursor(analysis)\n+}\n+\n+#[test]\n+fn forward_cursor() {\n+    let body = mock_body();\n+    let body = &body;\n+    let analysis = MockAnalysis { body, dir: PhantomData::<Forward> };\n+    test_cursor(analysis)\n+}"}, {"sha": "0df9322e7fe088e222a71fd632ad6d0817732a8f", "filename": "src/librustc_mir/dataflow/framework/visitor.rs", "status": "modified", "additions": 38, "deletions": 35, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/65b448273dd280401cd440a6740a7cd891525ba3/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65b448273dd280401cd440a6740a7cd891525ba3/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fvisitor.rs?ref=65b448273dd280401cd440a6740a7cd891525ba3", "patch": "@@ -1,50 +1,41 @@\n use rustc_index::bit_set::BitSet;\n use rustc_middle::mir::{self, BasicBlock, Location};\n \n-use super::{Analysis, Results};\n+use super::{Analysis, Direction, Results};\n use crate::dataflow::impls::{borrows::Borrows, EverInitializedPlaces, MaybeUninitializedPlaces};\n \n /// Calls the corresponding method in `ResultsVisitor` for every location in a `mir::Body` with the\n /// dataflow state at that location.\n-pub fn visit_results<F>(\n+pub fn visit_results<F, V>(\n     body: &'mir mir::Body<'tcx>,\n     blocks: impl IntoIterator<Item = BasicBlock>,\n-    results: &impl ResultsVisitable<'tcx, FlowState = F>,\n+    results: &V,\n     vis: &mut impl ResultsVisitor<'mir, 'tcx, FlowState = F>,\n-) {\n+) where\n+    V: ResultsVisitable<'tcx, FlowState = F>,\n+{\n     let mut state = results.new_flow_state(body);\n \n     for block in blocks {\n         let block_data = &body[block];\n-        results.reset_to_block_start(&mut state, block);\n-\n-        for (statement_index, stmt) in block_data.statements.iter().enumerate() {\n-            let loc = Location { block, statement_index };\n-\n-            results.reconstruct_before_statement_effect(&mut state, stmt, loc);\n-            vis.visit_statement(&state, stmt, loc);\n-\n-            results.reconstruct_statement_effect(&mut state, stmt, loc);\n-            vis.visit_statement_exit(&state, stmt, loc);\n-        }\n-\n-        let loc = body.terminator_loc(block);\n-        let term = block_data.terminator();\n-\n-        results.reconstruct_before_terminator_effect(&mut state, term, loc);\n-        vis.visit_terminator(&state, term, loc);\n-\n-        results.reconstruct_terminator_effect(&mut state, term, loc);\n-        vis.visit_terminator_exit(&state, term, loc);\n+        V::Direction::visit_results_in_block(&mut state, block, block_data, results, vis);\n     }\n }\n \n pub trait ResultsVisitor<'mir, 'tcx> {\n     type FlowState;\n \n+    fn visit_block_start(\n+        &mut self,\n+        _state: &Self::FlowState,\n+        _block_data: &'mir mir::BasicBlockData<'tcx>,\n+        _block: BasicBlock,\n+    ) {\n+    }\n+\n     /// Called with the `before_statement_effect` of the given statement applied to `state` but not\n     /// its `statement_effect`.\n-    fn visit_statement(\n+    fn visit_statement_before_primary_effect(\n         &mut self,\n         _state: &Self::FlowState,\n         _statement: &'mir mir::Statement<'tcx>,\n@@ -54,7 +45,7 @@ pub trait ResultsVisitor<'mir, 'tcx> {\n \n     /// Called with both the `before_statement_effect` and the `statement_effect` of the given\n     /// statement applied to `state`.\n-    fn visit_statement_exit(\n+    fn visit_statement_after_primary_effect(\n         &mut self,\n         _state: &Self::FlowState,\n         _statement: &'mir mir::Statement<'tcx>,\n@@ -64,7 +55,7 @@ pub trait ResultsVisitor<'mir, 'tcx> {\n \n     /// Called with the `before_terminator_effect` of the given terminator applied to `state` but not\n     /// its `terminator_effect`.\n-    fn visit_terminator(\n+    fn visit_terminator_before_primary_effect(\n         &mut self,\n         _state: &Self::FlowState,\n         _terminator: &'mir mir::Terminator<'tcx>,\n@@ -76,29 +67,38 @@ pub trait ResultsVisitor<'mir, 'tcx> {\n     /// terminator applied to `state`.\n     ///\n     /// The `call_return_effect` (if one exists) will *not* be applied to `state`.\n-    fn visit_terminator_exit(\n+    fn visit_terminator_after_primary_effect(\n         &mut self,\n         _state: &Self::FlowState,\n         _terminator: &'mir mir::Terminator<'tcx>,\n         _location: Location,\n     ) {\n     }\n+\n+    fn visit_block_end(\n+        &mut self,\n+        _state: &Self::FlowState,\n+        _block_data: &'mir mir::BasicBlockData<'tcx>,\n+        _block: BasicBlock,\n+    ) {\n+    }\n }\n \n /// Things that can be visited by a `ResultsVisitor`.\n ///\n /// This trait exists so that we can visit the results of multiple dataflow analyses simultaneously.\n /// DO NOT IMPLEMENT MANUALLY. Instead, use the `impl_visitable` macro below.\n pub trait ResultsVisitable<'tcx> {\n+    type Direction: Direction;\n     type FlowState;\n \n     /// Creates an empty `FlowState` to hold the transient state for these dataflow results.\n     ///\n-    /// The value of the newly created `FlowState` will be overwritten by `reset_to_block_start`\n+    /// The value of the newly created `FlowState` will be overwritten by `reset_to_block_entry`\n     /// before it can be observed by a `ResultsVisitor`.\n     fn new_flow_state(&self, body: &mir::Body<'tcx>) -> Self::FlowState;\n \n-    fn reset_to_block_start(&self, state: &mut Self::FlowState, block: BasicBlock);\n+    fn reset_to_block_entry(&self, state: &mut Self::FlowState, block: BasicBlock);\n \n     fn reconstruct_before_statement_effect(\n         &self,\n@@ -135,11 +135,13 @@ where\n {\n     type FlowState = BitSet<A::Idx>;\n \n+    type Direction = A::Direction;\n+\n     fn new_flow_state(&self, body: &mir::Body<'tcx>) -> Self::FlowState {\n         BitSet::new_empty(self.analysis.bits_per_block(body))\n     }\n \n-    fn reset_to_block_start(&self, state: &mut Self::FlowState, block: BasicBlock) {\n+    fn reset_to_block_entry(&self, state: &mut Self::FlowState, block: BasicBlock) {\n         state.overwrite(&self.entry_set_for_block(block));\n     }\n \n@@ -204,10 +206,11 @@ macro_rules! impl_visitable {\n     ( $(\n         $T:ident { $( $field:ident : $A:ident ),* $(,)? }\n     )* ) => { $(\n-        impl<'tcx, $($A),*> ResultsVisitable<'tcx> for $T<$( Results<'tcx, $A> ),*>\n+        impl<'tcx, $($A),*, D: Direction> ResultsVisitable<'tcx> for $T<$( Results<'tcx, $A> ),*>\n         where\n-            $( $A: Analysis<'tcx>, )*\n+            $( $A: Analysis<'tcx, Direction = D>, )*\n         {\n+            type Direction = D;\n             type FlowState = $T<$( BitSet<$A::Idx> ),*>;\n \n             fn new_flow_state(&self, body: &mir::Body<'tcx>) -> Self::FlowState {\n@@ -216,12 +219,12 @@ macro_rules! impl_visitable {\n                 }\n             }\n \n-            fn reset_to_block_start(\n+            fn reset_to_block_entry(\n                 &self,\n                 state: &mut Self::FlowState,\n                 block: BasicBlock,\n             ) {\n-                $( state.$field.overwrite(&self.$field.entry_sets[block]); )*\n+                $( state.$field.overwrite(&self.$field.entry_set_for_block(block)); )*\n             }\n \n             fn reconstruct_before_statement_effect("}, {"sha": "5e9bec89ac08d0982da4abb48c3b9f3eaee16fdb", "filename": "src/librustc_mir/dataflow/impls/liveness.rs", "status": "added", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/65b448273dd280401cd440a6740a7cd891525ba3/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65b448273dd280401cd440a6740a7cd891525ba3/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fliveness.rs?ref=65b448273dd280401cd440a6740a7cd891525ba3", "patch": "@@ -0,0 +1,137 @@\n+use rustc_index::bit_set::BitSet;\n+use rustc_middle::mir::visit::{MutatingUseContext, NonMutatingUseContext, PlaceContext, Visitor};\n+use rustc_middle::mir::{self, Local, Location};\n+\n+use crate::dataflow::{AnalysisDomain, Backward, BottomValue, GenKill, GenKillAnalysis};\n+\n+/// A [live-variable dataflow analysis][liveness].\n+///\n+/// [liveness]: https://en.wikipedia.org/wiki/Live_variable_analysis\n+pub struct MaybeLiveLocals;\n+\n+impl MaybeLiveLocals {\n+    fn transfer_function<T>(&self, trans: &'a mut T) -> TransferFunction<'a, T> {\n+        TransferFunction(trans)\n+    }\n+}\n+\n+impl BottomValue for MaybeLiveLocals {\n+    // bottom = not live\n+    const BOTTOM_VALUE: bool = false;\n+}\n+\n+impl AnalysisDomain<'tcx> for MaybeLiveLocals {\n+    type Idx = Local;\n+    type Direction = Backward;\n+\n+    const NAME: &'static str = \"liveness\";\n+\n+    fn bits_per_block(&self, body: &mir::Body<'tcx>) -> usize {\n+        body.local_decls.len()\n+    }\n+\n+    fn initialize_start_block(&self, _: &mir::Body<'tcx>, _: &mut BitSet<Self::Idx>) {\n+        // No variables are live until we observe a use\n+    }\n+}\n+\n+impl GenKillAnalysis<'tcx> for MaybeLiveLocals {\n+    fn statement_effect(\n+        &self,\n+        trans: &mut impl GenKill<Self::Idx>,\n+        statement: &mir::Statement<'tcx>,\n+        location: Location,\n+    ) {\n+        self.transfer_function(trans).visit_statement(statement, location);\n+    }\n+\n+    fn terminator_effect(\n+        &self,\n+        trans: &mut impl GenKill<Self::Idx>,\n+        terminator: &mir::Terminator<'tcx>,\n+        location: Location,\n+    ) {\n+        self.transfer_function(trans).visit_terminator(terminator, location);\n+    }\n+\n+    fn call_return_effect(\n+        &self,\n+        trans: &mut impl GenKill<Self::Idx>,\n+        _block: mir::BasicBlock,\n+        _func: &mir::Operand<'tcx>,\n+        _args: &[mir::Operand<'tcx>],\n+        dest_place: mir::Place<'tcx>,\n+    ) {\n+        if let Some(local) = dest_place.as_local() {\n+            trans.kill(local);\n+        }\n+    }\n+\n+    fn yield_resume_effect(\n+        &self,\n+        trans: &mut impl GenKill<Self::Idx>,\n+        _resume_block: mir::BasicBlock,\n+        resume_place: mir::Place<'tcx>,\n+    ) {\n+        if let Some(local) = resume_place.as_local() {\n+            trans.kill(local);\n+        }\n+    }\n+}\n+\n+struct TransferFunction<'a, T>(&'a mut T);\n+\n+impl<'tcx, T> Visitor<'tcx> for TransferFunction<'_, T>\n+where\n+    T: GenKill<Local>,\n+{\n+    fn visit_local(&mut self, &local: &Local, context: PlaceContext, _: Location) {\n+        match DefUse::for_place(context) {\n+            Some(DefUse::Def) => self.0.kill(local),\n+            Some(DefUse::Use) => self.0.gen(local),\n+            _ => {}\n+        }\n+    }\n+}\n+\n+#[derive(Eq, PartialEq, Clone)]\n+enum DefUse {\n+    Def,\n+    Use,\n+}\n+\n+impl DefUse {\n+    fn for_place(context: PlaceContext) -> Option<DefUse> {\n+        match context {\n+            PlaceContext::NonUse(_) => None,\n+\n+            PlaceContext::MutatingUse(MutatingUseContext::Store) => Some(DefUse::Def),\n+\n+            // `MutatingUseContext::Call` and `MutatingUseContext::Yield` indicate that this is the\n+            // destination place for a `Call` return or `Yield` resume respectively. Since this is\n+            // only a `Def` when the function returns succesfully, we handle this case separately\n+            // in `call_return_effect` above.\n+            PlaceContext::MutatingUse(MutatingUseContext::Call | MutatingUseContext::Yield) => None,\n+\n+            // All other contexts are uses...\n+            PlaceContext::MutatingUse(\n+                MutatingUseContext::AddressOf\n+                | MutatingUseContext::AsmOutput\n+                | MutatingUseContext::Borrow\n+                | MutatingUseContext::Drop\n+                | MutatingUseContext::Projection\n+                | MutatingUseContext::Retag,\n+            )\n+            | PlaceContext::NonMutatingUse(\n+                NonMutatingUseContext::AddressOf\n+                | NonMutatingUseContext::Copy\n+                | NonMutatingUseContext::Inspect\n+                | NonMutatingUseContext::Move\n+                | NonMutatingUseContext::Projection\n+                | NonMutatingUseContext::ShallowBorrow\n+                | NonMutatingUseContext::SharedBorrow\n+                | NonMutatingUseContext::UniqueBorrow,\n+            ) => Some(DefUse::Use),\n+        }\n+    }\n+}"}, {"sha": "222ae137d96e225f15405342f07b86764df907d3", "filename": "src/librustc_mir/dataflow/impls/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/65b448273dd280401cd440a6740a7cd891525ba3/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65b448273dd280401cd440a6740a7cd891525ba3/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs?ref=65b448273dd280401cd440a6740a7cd891525ba3", "patch": "@@ -21,9 +21,11 @@ use super::on_lookup_result_bits;\n use crate::dataflow::drop_flag_effects;\n \n mod borrowed_locals;\n+mod liveness;\n mod storage_liveness;\n \n pub use self::borrowed_locals::*;\n+pub use self::liveness::MaybeLiveLocals;\n pub use self::storage_liveness::*;\n \n pub(super) mod borrows;"}, {"sha": "4c784c3f1a1281db9089970313c3a60cf45cc2c8", "filename": "src/librustc_mir/dataflow/impls/storage_liveness.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/65b448273dd280401cd440a6740a7cd891525ba3/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65b448273dd280401cd440a6740a7cd891525ba3/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs?ref=65b448273dd280401cd440a6740a7cd891525ba3", "patch": "@@ -250,7 +250,7 @@ impl<'mir, 'tcx> dataflow::GenKillAnalysis<'tcx> for MaybeRequiresStorage<'mir,\n \n     fn yield_resume_effect(\n         &self,\n-        trans: &mut BitSet<Self::Idx>,\n+        trans: &mut impl GenKill<Self::Idx>,\n         _resume_block: BasicBlock,\n         resume_place: mir::Place<'tcx>,\n     ) {\n@@ -283,7 +283,7 @@ where\n     fn visit_local(&mut self, local: &Local, context: PlaceContext, loc: Location) {\n         if PlaceContext::NonMutatingUse(NonMutatingUseContext::Move) == context {\n             let mut borrowed_locals = self.borrowed_locals.borrow_mut();\n-            borrowed_locals.seek_before(loc);\n+            borrowed_locals.seek_before_primary_effect(loc);\n             if !borrowed_locals.contains(*local) {\n                 self.trans.kill(*local);\n             }"}, {"sha": "a05b4a5385d9c391234abee618b80f68bbd50f7f", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/65b448273dd280401cd440a6740a7cd891525ba3/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65b448273dd280401cd440a6740a7cd891525ba3/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=65b448273dd280401cd440a6740a7cd891525ba3", "patch": "@@ -4,13 +4,14 @@ use rustc_span::symbol::{sym, Symbol};\n \n pub(crate) use self::drop_flag_effects::*;\n pub use self::framework::{\n-    visit_results, Analysis, AnalysisDomain, BorrowckFlowState, BorrowckResults, BottomValue,\n-    Engine, GenKill, GenKillAnalysis, Results, ResultsCursor, ResultsRefCursor, ResultsVisitor,\n+    visit_results, Analysis, AnalysisDomain, Backward, BorrowckFlowState, BorrowckResults,\n+    BottomValue, Engine, Forward, GenKill, GenKillAnalysis, Results, ResultsCursor,\n+    ResultsRefCursor, ResultsVisitor,\n };\n pub use self::impls::{\n     borrows::Borrows, DefinitelyInitializedPlaces, EverInitializedPlaces, MaybeBorrowedLocals,\n-    MaybeInitializedPlaces, MaybeMutBorrowedLocals, MaybeRequiresStorage, MaybeStorageLive,\n-    MaybeUninitializedPlaces,\n+    MaybeInitializedPlaces, MaybeLiveLocals, MaybeMutBorrowedLocals, MaybeRequiresStorage,\n+    MaybeStorageLive, MaybeUninitializedPlaces,\n };\n \n use self::move_paths::MoveData;"}, {"sha": "09f8588cee287bad9cd3431e8a0a928b2704e900", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/65b448273dd280401cd440a6740a7cd891525ba3/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65b448273dd280401cd440a6740a7cd891525ba3/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=65b448273dd280401cd440a6740a7cd891525ba3", "patch": "@@ -9,8 +9,9 @@ Rust MIR: a lowered representation of Rust.\n #![feature(bool_to_option)]\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n-#![feature(const_if_match)]\n #![feature(const_fn)]\n+#![feature(const_if_match)]\n+#![feature(const_loop)]\n #![feature(const_panic)]\n #![feature(crate_visibility_modifier)]\n #![feature(decl_macro)]\n@@ -22,6 +23,7 @@ Rust MIR: a lowered representation of Rust.\n #![feature(trusted_len)]\n #![feature(try_blocks)]\n #![feature(associated_type_bounds)]\n+#![feature(associated_type_defaults)]\n #![feature(range_is_empty)]\n #![feature(stmt_expr_attributes)]\n #![feature(trait_alias)]"}, {"sha": "691903c9069b55603f8497ff357f6b359618d580", "filename": "src/librustc_mir/transform/check_consts/validation.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/65b448273dd280401cd440a6740a7cd891525ba3/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65b448273dd280401cd440a6740a7cd891525ba3/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs?ref=65b448273dd280401cd440a6740a7cd891525ba3", "patch": "@@ -61,7 +61,7 @@ impl Qualifs<'mir, 'tcx> {\n                 .into_results_cursor(&body)\n         });\n \n-        indirectly_mutable.seek_before(location);\n+        indirectly_mutable.seek_before_primary_effect(location);\n         indirectly_mutable.get().contains(local)\n     }\n \n@@ -88,7 +88,7 @@ impl Qualifs<'mir, 'tcx> {\n                 .into_results_cursor(&body)\n         });\n \n-        needs_drop.seek_before(location);\n+        needs_drop.seek_before_primary_effect(location);\n         needs_drop.get().contains(local) || self.indirectly_mutable(ccx, local, location)\n     }\n \n@@ -115,7 +115,7 @@ impl Qualifs<'mir, 'tcx> {\n                 .into_results_cursor(&body)\n         });\n \n-        has_mut_interior.seek_before(location);\n+        has_mut_interior.seek_before_primary_effect(location);\n         has_mut_interior.get().contains(local) || self.indirectly_mutable(ccx, local, location)\n     }\n \n@@ -161,7 +161,7 @@ impl Qualifs<'mir, 'tcx> {\n                     .iterate_to_fixpoint()\n                     .into_results_cursor(&ccx.body);\n \n-                cursor.seek_after(return_loc);\n+                cursor.seek_after_primary_effect(return_loc);\n                 cursor.contains(RETURN_PLACE)\n             }\n         };"}, {"sha": "a1becf062eea6e32d89157be33fb85fd52ee73ab", "filename": "src/librustc_mir/transform/elaborate_drops.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/65b448273dd280401cd440a6740a7cd891525ba3/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65b448273dd280401cd440a6740a7cd891525ba3/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs?ref=65b448273dd280401cd440a6740a7cd891525ba3", "patch": "@@ -101,7 +101,7 @@ fn find_dead_unwinds<'tcx>(\n             }\n         };\n \n-        flow_inits.seek_before(body.terminator_loc(bb));\n+        flow_inits.seek_before_primary_effect(body.terminator_loc(bb));\n         debug!(\n             \"find_dead_unwinds @ {:?}: path({:?})={:?}; init_data={:?}\",\n             bb,\n@@ -131,8 +131,8 @@ struct InitializationData<'mir, 'tcx> {\n \n impl InitializationData<'_, '_> {\n     fn seek_before(&mut self, loc: Location) {\n-        self.inits.seek_before(loc);\n-        self.uninits.seek_before(loc);\n+        self.inits.seek_before_primary_effect(loc);\n+        self.uninits.seek_before_primary_effect(loc);\n     }\n \n     fn maybe_live_dead(&self, path: MovePathIndex) -> (bool, bool) {"}, {"sha": "25804c2a62cfed7cdb9b8af7065584dc26a451aa", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 35, "deletions": 37, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/65b448273dd280401cd440a6740a7cd891525ba3/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65b448273dd280401cd440a6740a7cd891525ba3/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=65b448273dd280401cd440a6740a7cd891525ba3", "patch": "@@ -50,12 +50,13 @@\n //! Otherwise it drops all the values in scope at the last suspension point.\n \n use crate::dataflow::{self, Analysis};\n-use crate::dataflow::{MaybeBorrowedLocals, MaybeRequiresStorage, MaybeStorageLive};\n+use crate::dataflow::{\n+    MaybeBorrowedLocals, MaybeLiveLocals, MaybeRequiresStorage, MaybeStorageLive,\n+};\n use crate::transform::no_landing_pads::no_landing_pads;\n use crate::transform::simplify;\n use crate::transform::{MirPass, MirSource};\n use crate::util::dump_mir;\n-use crate::util::liveness;\n use crate::util::storage;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir as hir;\n@@ -195,7 +196,7 @@ struct SuspensionPoint<'tcx> {\n     /// Which block to jump to if the generator is dropped in this state.\n     drop: Option<BasicBlock>,\n     /// Set of locals that have live storage while at this suspension point.\n-    storage_liveness: liveness::LiveVarSet,\n+    storage_liveness: BitSet<Local>,\n }\n \n struct TransformVisitor<'tcx> {\n@@ -211,7 +212,7 @@ struct TransformVisitor<'tcx> {\n     remap: FxHashMap<Local, (Ty<'tcx>, VariantIdx, usize)>,\n \n     // A map from a suspension point in a block to the locals which have live storage at that point\n-    storage_liveness: IndexVec<BasicBlock, Option<liveness::LiveVarSet>>,\n+    storage_liveness: IndexVec<BasicBlock, Option<BitSet<Local>>>,\n \n     // A list of suspension points, generated during the transform\n     suspension_points: Vec<SuspensionPoint<'tcx>>,\n@@ -418,7 +419,7 @@ struct LivenessInfo {\n     /// GeneratorSavedLocal is indexed in terms of the elements in this set;\n     /// i.e. GeneratorSavedLocal::new(1) corresponds to the second local\n     /// included in this set.\n-    live_locals: liveness::LiveVarSet,\n+    live_locals: BitSet<Local>,\n \n     /// The set of saved locals live at each suspension point.\n     live_locals_at_suspension_points: Vec<BitSet<GeneratorSavedLocal>>,\n@@ -430,7 +431,7 @@ struct LivenessInfo {\n \n     /// For every suspending block, the locals which are storage-live across\n     /// that suspension point.\n-    storage_liveness: IndexVec<BasicBlock, Option<liveness::LiveVarSet>>,\n+    storage_liveness: IndexVec<BasicBlock, Option<BitSet<Local>>>,\n }\n \n fn locals_live_across_suspend_points(\n@@ -467,17 +468,22 @@ fn locals_live_across_suspend_points(\n         dataflow::ResultsCursor::new(body_ref, &requires_storage_results);\n \n     // Calculate the liveness of MIR locals ignoring borrows.\n-    let mut live_locals = liveness::LiveVarSet::new_empty(body.local_decls.len());\n-    let mut liveness = liveness::liveness_of_locals(body);\n-    liveness::dump_mir(tcx, \"generator_liveness\", source, body_ref, &liveness);\n+    let mut liveness = MaybeLiveLocals\n+        .into_engine(tcx, body_ref, def_id)\n+        .iterate_to_fixpoint()\n+        .into_results_cursor(body_ref);\n \n     let mut storage_liveness_map = IndexVec::from_elem(None, body.basic_blocks());\n     let mut live_locals_at_suspension_points = Vec::new();\n+    let mut live_locals_at_any_suspension_point = BitSet::new_empty(body.local_decls.len());\n \n     for (block, data) in body.basic_blocks().iter_enumerated() {\n         if let TerminatorKind::Yield { .. } = data.terminator().kind {\n             let loc = Location { block, statement_index: data.statements.len() };\n \n+            liveness.seek_to_block_end(block);\n+            let mut live_locals = liveness.get().clone();\n+\n             if !movable {\n                 // The `liveness` variable contains the liveness of MIR locals ignoring borrows.\n                 // This is correct for movable generators since borrows cannot live across\n@@ -489,59 +495,51 @@ fn locals_live_across_suspend_points(\n                 // If a borrow is converted to a raw reference, we must also assume that it lives\n                 // forever. Note that the final liveness is still bounded by the storage liveness\n                 // of the local, which happens using the `intersect` operation below.\n-                borrowed_locals_cursor.seek_before(loc);\n-                liveness.outs[block].union(borrowed_locals_cursor.get());\n+                borrowed_locals_cursor.seek_before_primary_effect(loc);\n+                live_locals.union(borrowed_locals_cursor.get());\n             }\n \n-            storage_live.seek_before(loc);\n-            let mut storage_liveness = storage_live.get().clone();\n-\n-            // Later passes handle the generator's `self` argument separately.\n-            storage_liveness.remove(SELF_ARG);\n-\n             // Store the storage liveness for later use so we can restore the state\n             // after a suspension point\n-            storage_liveness_map[block] = Some(storage_liveness);\n-\n-            requires_storage_cursor.seek_before(loc);\n-            let storage_required = requires_storage_cursor.get().clone();\n+            storage_live.seek_before_primary_effect(loc);\n+            storage_liveness_map[block] = Some(storage_live.get().clone());\n \n             // Locals live are live at this point only if they are used across\n             // suspension points (the `liveness` variable)\n             // and their storage is required (the `storage_required` variable)\n-            let mut live_locals_here = storage_required;\n-            live_locals_here.intersect(&liveness.outs[block]);\n+            requires_storage_cursor.seek_before_primary_effect(loc);\n+            live_locals.intersect(requires_storage_cursor.get());\n \n             // The generator argument is ignored.\n-            live_locals_here.remove(SELF_ARG);\n+            live_locals.remove(SELF_ARG);\n \n-            debug!(\"loc = {:?}, live_locals_here = {:?}\", loc, live_locals_here);\n+            debug!(\"loc = {:?}, live_locals = {:?}\", loc, live_locals);\n \n             // Add the locals live at this suspension point to the set of locals which live across\n             // any suspension points\n-            live_locals.union(&live_locals_here);\n+            live_locals_at_any_suspension_point.union(&live_locals);\n \n-            live_locals_at_suspension_points.push(live_locals_here);\n+            live_locals_at_suspension_points.push(live_locals);\n         }\n     }\n-    debug!(\"live_locals = {:?}\", live_locals);\n+    debug!(\"live_locals_anywhere = {:?}\", live_locals_at_any_suspension_point);\n \n     // Renumber our liveness_map bitsets to include only the locals we are\n     // saving.\n     let live_locals_at_suspension_points = live_locals_at_suspension_points\n         .iter()\n-        .map(|live_here| renumber_bitset(&live_here, &live_locals))\n+        .map(|live_here| renumber_bitset(&live_here, &live_locals_at_any_suspension_point))\n         .collect();\n \n     let storage_conflicts = compute_storage_conflicts(\n         body_ref,\n-        &live_locals,\n+        &live_locals_at_any_suspension_point,\n         always_live_locals.clone(),\n         requires_storage_results,\n     );\n \n     LivenessInfo {\n-        live_locals,\n+        live_locals: live_locals_at_any_suspension_point,\n         live_locals_at_suspension_points,\n         storage_conflicts,\n         storage_liveness: storage_liveness_map,\n@@ -555,7 +553,7 @@ fn locals_live_across_suspend_points(\n /// `[0, 1, 2]`. Thus, if `input = [3, 5]` we would return `[1, 2]`.\n fn renumber_bitset(\n     input: &BitSet<Local>,\n-    stored_locals: &liveness::LiveVarSet,\n+    stored_locals: &BitSet<Local>,\n ) -> BitSet<GeneratorSavedLocal> {\n     assert!(stored_locals.superset(&input), \"{:?} not a superset of {:?}\", stored_locals, input);\n     let mut out = BitSet::new_empty(stored_locals.count());\n@@ -575,7 +573,7 @@ fn renumber_bitset(\n /// computation; see `GeneratorLayout` for more.\n fn compute_storage_conflicts(\n     body: &'mir Body<'tcx>,\n-    stored_locals: &liveness::LiveVarSet,\n+    stored_locals: &BitSet<Local>,\n     always_live_locals: storage::AlwaysLiveLocals,\n     requires_storage: dataflow::Results<'tcx, MaybeRequiresStorage<'mir, 'tcx>>,\n ) -> BitMatrix<GeneratorSavedLocal, GeneratorSavedLocal> {\n@@ -630,7 +628,7 @@ fn compute_storage_conflicts(\n \n struct StorageConflictVisitor<'mir, 'tcx, 's> {\n     body: &'mir Body<'tcx>,\n-    stored_locals: &'s liveness::LiveVarSet,\n+    stored_locals: &'s BitSet<Local>,\n     // FIXME(tmandry): Consider using sparse bitsets here once we have good\n     // benchmarks for generators.\n     local_conflicts: BitMatrix<Local, Local>,\n@@ -639,7 +637,7 @@ struct StorageConflictVisitor<'mir, 'tcx, 's> {\n impl dataflow::ResultsVisitor<'mir, 'tcx> for StorageConflictVisitor<'mir, 'tcx, '_> {\n     type FlowState = BitSet<Local>;\n \n-    fn visit_statement(\n+    fn visit_statement_before_primary_effect(\n         &mut self,\n         state: &Self::FlowState,\n         _statement: &'mir Statement<'tcx>,\n@@ -648,7 +646,7 @@ impl dataflow::ResultsVisitor<'mir, 'tcx> for StorageConflictVisitor<'mir, 'tcx,\n         self.apply_state(state, loc);\n     }\n \n-    fn visit_terminator(\n+    fn visit_terminator_before_primary_effect(\n         &mut self,\n         state: &Self::FlowState,\n         _terminator: &'mir Terminator<'tcx>,\n@@ -689,7 +687,7 @@ fn compute_layout<'tcx>(\n ) -> (\n     FxHashMap<Local, (Ty<'tcx>, VariantIdx, usize)>,\n     GeneratorLayout<'tcx>,\n-    IndexVec<BasicBlock, Option<liveness::LiveVarSet>>,\n+    IndexVec<BasicBlock, Option<BitSet<Local>>>,\n ) {\n     // Use a liveness analysis to compute locals which are live across a suspension point\n     let LivenessInfo {"}, {"sha": "43ddc0c914c030e51f61e780ce76f0ff91bfa545", "filename": "src/librustc_mir/transform/rustc_peek.rs", "status": "modified", "additions": 51, "deletions": 15, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/65b448273dd280401cd440a6740a7cd891525ba3/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65b448273dd280401cd440a6740a7cd891525ba3/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs?ref=65b448273dd280401cd440a6740a7cd891525ba3", "patch": "@@ -15,7 +15,7 @@ use crate::dataflow::MaybeMutBorrowedLocals;\n use crate::dataflow::MoveDataParamEnv;\n use crate::dataflow::{Analysis, Results, ResultsCursor};\n use crate::dataflow::{\n-    DefinitelyInitializedPlaces, MaybeInitializedPlaces, MaybeUninitializedPlaces,\n+    DefinitelyInitializedPlaces, MaybeInitializedPlaces, MaybeLiveLocals, MaybeUninitializedPlaces,\n };\n \n pub struct SanityCheck;\n@@ -36,31 +36,45 @@ impl<'tcx> MirPass<'tcx> for SanityCheck {\n         let move_data = MoveData::gather_moves(body, tcx, param_env).unwrap();\n         let mdpe = MoveDataParamEnv { move_data, param_env };\n \n-        let flow_inits = MaybeInitializedPlaces::new(tcx, body, &mdpe)\n-            .into_engine(tcx, body, def_id)\n-            .iterate_to_fixpoint();\n-        let flow_uninits = MaybeUninitializedPlaces::new(tcx, body, &mdpe)\n-            .into_engine(tcx, body, def_id)\n-            .iterate_to_fixpoint();\n-        let flow_def_inits = DefinitelyInitializedPlaces::new(tcx, body, &mdpe)\n-            .into_engine(tcx, body, def_id)\n-            .iterate_to_fixpoint();\n-        let flow_mut_borrowed = MaybeMutBorrowedLocals::mut_borrows_only(tcx, body, param_env)\n-            .into_engine(tcx, body, def_id)\n-            .iterate_to_fixpoint();\n-\n         if has_rustc_mir_with(&attributes, sym::rustc_peek_maybe_init).is_some() {\n+            let flow_inits = MaybeInitializedPlaces::new(tcx, body, &mdpe)\n+                .into_engine(tcx, body, def_id)\n+                .iterate_to_fixpoint();\n+\n             sanity_check_via_rustc_peek(tcx, body, def_id, &attributes, &flow_inits);\n         }\n+\n         if has_rustc_mir_with(&attributes, sym::rustc_peek_maybe_uninit).is_some() {\n+            let flow_uninits = MaybeUninitializedPlaces::new(tcx, body, &mdpe)\n+                .into_engine(tcx, body, def_id)\n+                .iterate_to_fixpoint();\n+\n             sanity_check_via_rustc_peek(tcx, body, def_id, &attributes, &flow_uninits);\n         }\n+\n         if has_rustc_mir_with(&attributes, sym::rustc_peek_definite_init).is_some() {\n+            let flow_def_inits = DefinitelyInitializedPlaces::new(tcx, body, &mdpe)\n+                .into_engine(tcx, body, def_id)\n+                .iterate_to_fixpoint();\n+\n             sanity_check_via_rustc_peek(tcx, body, def_id, &attributes, &flow_def_inits);\n         }\n+\n         if has_rustc_mir_with(&attributes, sym::rustc_peek_indirectly_mutable).is_some() {\n+            let flow_mut_borrowed = MaybeMutBorrowedLocals::mut_borrows_only(tcx, body, param_env)\n+                .into_engine(tcx, body, def_id)\n+                .iterate_to_fixpoint();\n+\n             sanity_check_via_rustc_peek(tcx, body, def_id, &attributes, &flow_mut_borrowed);\n         }\n+\n+        if has_rustc_mir_with(&attributes, sym::rustc_peek_liveness).is_some() {\n+            let flow_liveness =\n+                MaybeLiveLocals.into_engine(tcx, body, def_id).iterate_to_fixpoint();\n+\n+            sanity_check_via_rustc_peek(tcx, body, def_id, &attributes, &flow_liveness);\n+        }\n+\n         if has_rustc_mir_with(&attributes, sym::stop_after_dataflow).is_some() {\n             tcx.sess.fatal(\"stop_after_dataflow ended compilation\");\n         }\n@@ -126,7 +140,7 @@ pub fn sanity_check_via_rustc_peek<'tcx, A>(\n                 mir::Rvalue::Use(mir::Operand::Move(place) | mir::Operand::Copy(place)),\n             ) => {\n                 let loc = Location { block: bb, statement_index };\n-                cursor.seek_before(loc);\n+                cursor.seek_before_primary_effect(loc);\n                 let state = cursor.get();\n                 results.analysis.peek_at(tcx, *place, state, call);\n             }\n@@ -286,3 +300,25 @@ impl<'tcx> RustcPeekAt<'tcx> for MaybeMutBorrowedLocals<'_, 'tcx> {\n         }\n     }\n }\n+\n+impl<'tcx> RustcPeekAt<'tcx> for MaybeLiveLocals {\n+    fn peek_at(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+        place: mir::Place<'tcx>,\n+        flow_state: &BitSet<Local>,\n+        call: PeekCall,\n+    ) {\n+        warn!(\"peek_at: place={:?}\", place);\n+        let local = if let Some(l) = place.as_local() {\n+            l\n+        } else {\n+            tcx.sess.span_err(call.span, \"rustc_peek: argument was not a local\");\n+            return;\n+        };\n+\n+        if !flow_state.contains(local) {\n+            tcx.sess.span_err(call.span, \"rustc_peek: bit not set\");\n+        }\n+    }\n+}"}, {"sha": "c261219cc73cc40ad0681fedc16cb35d69e3f7e5", "filename": "src/librustc_mir/util/liveness.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/65b448273dd280401cd440a6740a7cd891525ba3/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65b448273dd280401cd440a6740a7cd891525ba3/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fliveness.rs?ref=65b448273dd280401cd440a6740a7cd891525ba3", "patch": "@@ -133,6 +133,7 @@ pub fn categorize(context: PlaceContext) -> Option<DefUse> {\n         // the def in call only to the input from the success\n         // path and not the unwind path. -nmatsakis\n         PlaceContext::MutatingUse(MutatingUseContext::Call) |\n+        PlaceContext::MutatingUse(MutatingUseContext::Yield) |\n \n         // Storage live and storage dead aren't proper defines, but we can ignore\n         // values that come before them."}, {"sha": "a61647bfd655f781ce5882fbec29868931386a2d", "filename": "src/librustc_span/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/65b448273dd280401cd440a6740a7cd891525ba3/src%2Flibrustc_span%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65b448273dd280401cd440a6740a7cd891525ba3/src%2Flibrustc_span%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fsymbol.rs?ref=65b448273dd280401cd440a6740a7cd891525ba3", "patch": "@@ -656,6 +656,7 @@ symbols! {\n         rustc_partition_reused,\n         rustc_peek,\n         rustc_peek_definite_init,\n+        rustc_peek_liveness,\n         rustc_peek_maybe_init,\n         rustc_peek_maybe_uninit,\n         rustc_peek_indirectly_mutable,"}, {"sha": "34097d7526a6e40870fdc6214649c9598d9d3378", "filename": "src/test/ui/mir-dataflow/liveness-ptr.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/65b448273dd280401cd440a6740a7cd891525ba3/src%2Ftest%2Fui%2Fmir-dataflow%2Fliveness-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65b448273dd280401cd440a6740a7cd891525ba3/src%2Ftest%2Fui%2Fmir-dataflow%2Fliveness-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmir-dataflow%2Fliveness-ptr.rs?ref=65b448273dd280401cd440a6740a7cd891525ba3", "patch": "@@ -0,0 +1,28 @@\n+#![feature(core_intrinsics, rustc_attrs)]\n+\n+use std::intrinsics::rustc_peek;\n+\n+#[rustc_mir(rustc_peek_liveness, stop_after_dataflow)]\n+fn foo() -> i32 {\n+    let mut x: i32;\n+    let mut p: *const i32;\n+\n+    x = 0;\n+\n+    // `x` is live here since it is used in the next statement...\n+    unsafe { rustc_peek(x); }\n+\n+    p = &x;\n+\n+    // ... but not here, even while it can be accessed through `p`.\n+    unsafe { rustc_peek(x); } //~ ERROR rustc_peek: bit not set\n+    let tmp = unsafe { *p };\n+\n+    x = tmp + 1;\n+\n+    unsafe { rustc_peek(x); }\n+\n+    x\n+}\n+\n+fn main() {}"}, {"sha": "3397d0c5a121d8c7b01308e536d7f5622e4bbfca", "filename": "src/test/ui/mir-dataflow/liveness-ptr.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/65b448273dd280401cd440a6740a7cd891525ba3/src%2Ftest%2Fui%2Fmir-dataflow%2Fliveness-ptr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/65b448273dd280401cd440a6740a7cd891525ba3/src%2Ftest%2Fui%2Fmir-dataflow%2Fliveness-ptr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmir-dataflow%2Fliveness-ptr.stderr?ref=65b448273dd280401cd440a6740a7cd891525ba3", "patch": "@@ -0,0 +1,10 @@\n+error: rustc_peek: bit not set\n+  --> $DIR/liveness-ptr.rs:18:14\n+   |\n+LL |     unsafe { rustc_peek(x); }\n+   |              ^^^^^^^^^^^^^\n+\n+error: stop_after_dataflow ended compilation\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "d563eb886ae7e6618dc4832ef3a91572c02c0029", "filename": "src/tools/clippy/clippy_lints/src/redundant_clone.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/65b448273dd280401cd440a6740a7cd891525ba3/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65b448273dd280401cd440a6740a7cd891525ba3/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_clone.rs?ref=65b448273dd280401cd440a6740a7cd891525ba3", "patch": "@@ -591,7 +591,7 @@ struct PossibleBorrowerMap<'a, 'tcx> {\n impl PossibleBorrowerMap<'_, '_> {\n     /// Returns true if the set of borrowers of `borrowed` living at `at` matches with `borrowers`.\n     fn only_borrowers(&mut self, borrowers: &[mir::Local], borrowed: mir::Local, at: mir::Location) -> bool {\n-        self.maybe_live.seek_after(at);\n+        self.maybe_live.seek_after_primary_effect(at);\n \n         self.bitset.0.clear();\n         let maybe_live = &mut self.maybe_live;"}]}