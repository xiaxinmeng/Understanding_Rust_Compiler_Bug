{"sha": "5b467787b625d83d5cf210e70d56487e53ce4255", "node_id": "MDY6Q29tbWl0NzI0NzEyOjViNDY3Nzg3YjYyNWQ4M2Q1Y2YyMTBlNzBkNTY0ODdlNTNjZTQyNTU=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2021-03-30T09:34:30Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-03-30T09:34:30Z"}, "message": "Rollup merge of #83667 - estebank:cool-bears-hot-tip, r=lcnr\n\nSuggest box/pin/arc ing receiver on method calls\n\n_Extracted from https://fasterthanli.me/articles/pin-and-suffering_", "tree": {"sha": "9bf7115581ea57a0062aa8a02e1386b9693ec6aa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9bf7115581ea57a0062aa8a02e1386b9693ec6aa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5b467787b625d83d5cf210e70d56487e53ce4255", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgYvCnCRBK7hj4Ov3rIwAAdHIIABpW59rnbji1INsrTBxG556A\nviQMEFT0RBrDbiN5BOIIR7x+fchPw225VtwyJyW1WnHHjPTitO2xpHFtmqAhI0r0\nPrTooWFk6dDs5g8HJizyXGqeE7FfCnNWZ/wzjnKqau1EMccqiVHbBNzryGeXr++D\nIMqMR3umA4U+EgLKOGVwvOXoRTq/xH9CEN52qKIhEFvm1ZGHgIP7HqykBUfxBOeC\nCSjQy4ZS7D+NIzpANXFGO1ldbuN0J40e0uskORB4GTP72mlJc8dwdrFmj4TNUBrI\nBI2lnZGbfaLDAnsKkA7+3/x0t0wCttFj0ODXO1Yc+sxl4ZKyMj139wRbRcuC3eY=\n=ABQx\n-----END PGP SIGNATURE-----\n", "payload": "tree 9bf7115581ea57a0062aa8a02e1386b9693ec6aa\nparent 36eee62c08ebdd0f4605d7f7574cdd6db245eaaa\nparent 0195f8d3751ed2c14c405686c41064c4c41baa39\nauthor Dylan DPC <dylan.dpc@gmail.com> 1617096870 +0200\ncommitter GitHub <noreply@github.com> 1617096870 +0200\n\nRollup merge of #83667 - estebank:cool-bears-hot-tip, r=lcnr\n\nSuggest box/pin/arc ing receiver on method calls\n\n_Extracted from https://fasterthanli.me/articles/pin-and-suffering_\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5b467787b625d83d5cf210e70d56487e53ce4255", "html_url": "https://github.com/rust-lang/rust/commit/5b467787b625d83d5cf210e70d56487e53ce4255", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5b467787b625d83d5cf210e70d56487e53ce4255/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "36eee62c08ebdd0f4605d7f7574cdd6db245eaaa", "url": "https://api.github.com/repos/rust-lang/rust/commits/36eee62c08ebdd0f4605d7f7574cdd6db245eaaa", "html_url": "https://github.com/rust-lang/rust/commit/36eee62c08ebdd0f4605d7f7574cdd6db245eaaa"}, {"sha": "0195f8d3751ed2c14c405686c41064c4c41baa39", "url": "https://api.github.com/repos/rust-lang/rust/commits/0195f8d3751ed2c14c405686c41064c4c41baa39", "html_url": "https://github.com/rust-lang/rust/commit/0195f8d3751ed2c14c405686c41064c4c41baa39"}], "stats": {"total": 340, "additions": 179, "deletions": 161}, "files": [{"sha": "30d60514063d993b29f6c1de36075c9d8c288b89", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 16, "deletions": 57, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/5b467787b625d83d5cf210e70d56487e53ce4255/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b467787b625d83d5cf210e70d56487e53ce4255/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=5b467787b625d83d5cf210e70d56487e53ce4255", "patch": "@@ -6,7 +6,7 @@ use crate::astconv::AstConv as _;\n use crate::check::cast;\n use crate::check::coercion::CoerceMany;\n use crate::check::fatally_break_rust;\n-use crate::check::method::{probe, MethodError, SelfSource};\n+use crate::check::method::SelfSource;\n use crate::check::report_unexpected_variant_res;\n use crate::check::BreakableCtxt;\n use crate::check::Diverges;\n@@ -30,7 +30,6 @@ use rustc_errors::{pluralize, struct_span_err, Applicability, DiagnosticBuilder,\n use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, DefKind, Res};\n use rustc_hir::def_id::DefId;\n-use rustc_hir::lang_items::LangItem;\n use rustc_hir::{ExprKind, QPath};\n use rustc_infer::infer;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n@@ -461,7 +460,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.resolve_lang_item_path(lang_item, expr.span, expr.hir_id).1\n     }\n \n-    fn check_expr_path(&self, qpath: &hir::QPath<'_>, expr: &'tcx hir::Expr<'tcx>) -> Ty<'tcx> {\n+    fn check_expr_path(\n+        &self,\n+        qpath: &'tcx hir::QPath<'tcx>,\n+        expr: &'tcx hir::Expr<'tcx>,\n+    ) -> Ty<'tcx> {\n         let tcx = self.tcx;\n         let (res, opt_ty, segs) = self.resolve_ty_and_res_ufcs(qpath, expr.hir_id, expr.span);\n         let ty = match res {\n@@ -947,7 +950,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n             Err(error) => {\n                 if segment.ident.name != kw::Empty {\n-                    self.report_extended_method_error(segment, span, args, rcvr_t, error);\n+                    if let Some(mut err) = self.report_method_error(\n+                        span,\n+                        rcvr_t,\n+                        segment.ident,\n+                        SelfSource::MethodCall(&args[0]),\n+                        error,\n+                        Some(args),\n+                    ) {\n+                        err.emit();\n+                    }\n                 }\n                 Err(())\n             }\n@@ -964,59 +976,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         )\n     }\n \n-    fn report_extended_method_error(\n-        &self,\n-        segment: &hir::PathSegment<'_>,\n-        span: Span,\n-        args: &'tcx [hir::Expr<'tcx>],\n-        rcvr_t: Ty<'tcx>,\n-        error: MethodError<'tcx>,\n-    ) {\n-        let rcvr = &args[0];\n-        let try_alt_rcvr = |err: &mut DiagnosticBuilder<'_>, new_rcvr_t| {\n-            if let Some(new_rcvr_t) = new_rcvr_t {\n-                if let Ok(pick) = self.lookup_probe(\n-                    span,\n-                    segment.ident,\n-                    new_rcvr_t,\n-                    rcvr,\n-                    probe::ProbeScope::AllTraits,\n-                ) {\n-                    debug!(\"try_alt_rcvr: pick candidate {:?}\", pick);\n-                    // Make sure the method is defined for the *actual* receiver:\n-                    // we don't want to treat `Box<Self>` as a receiver if\n-                    // it only works because of an autoderef to `&self`\n-                    if pick.autoderefs == 0 {\n-                        err.span_label(\n-                            pick.item.ident.span,\n-                            &format!(\"the method is available for `{}` here\", new_rcvr_t),\n-                        );\n-                    }\n-                }\n-            }\n-        };\n-\n-        if let Some(mut err) = self.report_method_error(\n-            span,\n-            rcvr_t,\n-            segment.ident,\n-            SelfSource::MethodCall(rcvr),\n-            error,\n-            Some(args),\n-        ) {\n-            if let ty::Adt(..) = rcvr_t.kind() {\n-                // Try alternative arbitrary self types that could fulfill this call.\n-                // FIXME: probe for all types that *could* be arbitrary self-types, not\n-                // just this list.\n-                try_alt_rcvr(&mut err, self.tcx.mk_lang_item(rcvr_t, LangItem::OwnedBox));\n-                try_alt_rcvr(&mut err, self.tcx.mk_lang_item(rcvr_t, LangItem::Pin));\n-                try_alt_rcvr(&mut err, self.tcx.mk_diagnostic_item(rcvr_t, sym::Arc));\n-                try_alt_rcvr(&mut err, self.tcx.mk_diagnostic_item(rcvr_t, sym::Rc));\n-            }\n-            err.emit();\n-        }\n-    }\n-\n     fn check_expr_cast(\n         &self,\n         e: &'tcx hir::Expr<'tcx>,"}, {"sha": "a7a412f06becc706a24d9f6c294162de27bc6f78", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/_impl.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5b467787b625d83d5cf210e70d56487e53ce4255/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b467787b625d83d5cf210e70d56487e53ce4255/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs?ref=5b467787b625d83d5cf210e70d56487e53ce4255", "patch": "@@ -905,12 +905,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     /// Resolves an associated value path into a base type and associated constant, or method\n     /// resolution. The newly resolved definition is written into `type_dependent_defs`.\n-    pub fn resolve_ty_and_res_ufcs<'b>(\n+    pub fn resolve_ty_and_res_ufcs(\n         &self,\n-        qpath: &'b QPath<'b>,\n+        qpath: &'tcx QPath<'tcx>,\n         hir_id: hir::HirId,\n         span: Span,\n-    ) -> (Res, Option<Ty<'tcx>>, &'b [hir::PathSegment<'b>]) {\n+    ) -> (Res, Option<Ty<'tcx>>, &'tcx [hir::PathSegment<'tcx>]) {\n         debug!(\"resolve_ty_and_res_ufcs: qpath={:?} hir_id={:?} span={:?}\", qpath, hir_id, span);\n         let (ty, qself, item_segment) = match *qpath {\n             QPath::Resolved(ref opt_qself, ref path) => {"}, {"sha": "c74fd25f76d37fae78ec4b90866169e0305fe998", "filename": "compiler/rustc_typeck/src/check/method/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b467787b625d83d5cf210e70d56487e53ce4255/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b467787b625d83d5cf210e70d56487e53ce4255/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs?ref=5b467787b625d83d5cf210e70d56487e53ce4255", "patch": "@@ -45,6 +45,7 @@ pub struct MethodCallee<'tcx> {\n     pub sig: ty::FnSig<'tcx>,\n }\n \n+#[derive(Debug)]\n pub enum MethodError<'tcx> {\n     // Did not find an applicable method, but we did find various near-misses that may work.\n     NoMatch(NoMatchData<'tcx>),\n@@ -66,6 +67,7 @@ pub enum MethodError<'tcx> {\n \n // Contains a list of static methods that may apply, a list of unsatisfied trait predicates which\n // could lead to matches if satisfied, and a list of not-in-scope traits which may work.\n+#[derive(Debug)]\n pub struct NoMatchData<'tcx> {\n     pub static_candidates: Vec<CandidateSource>,\n     pub unsatisfied_predicates: Vec<(ty::Predicate<'tcx>, Option<ty::Predicate<'tcx>>)>,"}, {"sha": "72eff009473a11b26b2c6d8ad6b4392cc0cc417a", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 78, "deletions": 9, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/5b467787b625d83d5cf210e70d56487e53ce4255/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b467787b625d83d5cf210e70d56487e53ce4255/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=5b467787b625d83d5cf210e70d56487e53ce4255", "patch": "@@ -68,12 +68,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    pub fn report_method_error<'b>(\n+    pub fn report_method_error(\n         &self,\n         span: Span,\n         rcvr_ty: Ty<'tcx>,\n         item_name: Ident,\n-        source: SelfSource<'b>,\n+        source: SelfSource<'tcx>,\n         error: MethodError<'tcx>,\n         args: Option<&'tcx [hir::Expr<'tcx>]>,\n     ) -> Option<DiagnosticBuilder<'_>> {\n@@ -323,8 +323,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 err.span_suggestion(\n                                     lit.span,\n                                     &format!(\n-                                        \"you must specify a concrete type for \\\n-                                              this numeric value, like `{}`\",\n+                                        \"you must specify a concrete type for this numeric value, \\\n+                                         like `{}`\",\n                                         concrete_type\n                                     ),\n                                     format!(\"{}_{}\", snippet, concrete_type),\n@@ -975,17 +975,78 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn suggest_traits_to_import<'b>(\n+    fn suggest_traits_to_import(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n         span: Span,\n         rcvr_ty: Ty<'tcx>,\n         item_name: Ident,\n-        source: SelfSource<'b>,\n+        source: SelfSource<'tcx>,\n         valid_out_of_scope_traits: Vec<DefId>,\n         unsatisfied_predicates: &[(ty::Predicate<'tcx>, Option<ty::Predicate<'tcx>>)],\n     ) {\n-        if self.suggest_valid_traits(err, valid_out_of_scope_traits) {\n+        let mut alt_rcvr_sugg = false;\n+        if let SelfSource::MethodCall(rcvr) = source {\n+            info!(?span, ?item_name, ?rcvr_ty, ?rcvr);\n+            if let ty::Adt(..) = rcvr_ty.kind() {\n+                // Try alternative arbitrary self types that could fulfill this call.\n+                // FIXME: probe for all types that *could* be arbitrary self-types, not\n+                // just this list.\n+                for (rcvr_ty, post) in &[\n+                    (rcvr_ty, \"\"),\n+                    (self.tcx.mk_mut_ref(&ty::ReErased, rcvr_ty), \"&mut \"),\n+                    (self.tcx.mk_imm_ref(&ty::ReErased, rcvr_ty), \"&\"),\n+                ] {\n+                    for (rcvr_ty, pre) in &[\n+                        (self.tcx.mk_lang_item(rcvr_ty, LangItem::OwnedBox), \"Box::new\"),\n+                        (self.tcx.mk_lang_item(rcvr_ty, LangItem::Pin), \"Pin::new\"),\n+                        (self.tcx.mk_diagnostic_item(rcvr_ty, sym::Arc), \"Arc::new\"),\n+                        (self.tcx.mk_diagnostic_item(rcvr_ty, sym::Rc), \"Rc::new\"),\n+                    ] {\n+                        if let Some(new_rcvr_t) = *rcvr_ty {\n+                            if let Ok(pick) = self.lookup_probe(\n+                                span,\n+                                item_name,\n+                                new_rcvr_t,\n+                                rcvr,\n+                                crate::check::method::probe::ProbeScope::AllTraits,\n+                            ) {\n+                                debug!(\"try_alt_rcvr: pick candidate {:?}\", pick);\n+                                // Make sure the method is defined for the *actual* receiver:\n+                                // we don't want to treat `Box<Self>` as a receiver if\n+                                // it only works because of an autoderef to `&self`\n+                                if pick.autoderefs == 0\n+                                    // We don't want to suggest a container type when the missing method is\n+                                    // `.clone()`, otherwise we'd suggest `Arc::new(foo).clone()`, which is\n+                                    // far from what the user really wants.\n+                                    && Some(pick.item.container.id()) != self.tcx.lang_items().clone_trait()\n+                                {\n+                                    err.span_label(\n+                                        pick.item.ident.span,\n+                                        &format!(\n+                                            \"the method is available for `{}` here\",\n+                                            new_rcvr_t\n+                                        ),\n+                                    );\n+                                    err.multipart_suggestion(\n+                                        \"consider wrapping the receiver expression with the \\\n+                                         appropriate type\",\n+                                        vec![\n+                                            (rcvr.span.shrink_to_lo(), format!(\"{}({}\", pre, post)),\n+                                            (rcvr.span.shrink_to_hi(), \")\".to_string()),\n+                                        ],\n+                                        Applicability::MaybeIncorrect,\n+                                    );\n+                                    // We don't care about the other suggestions.\n+                                    alt_rcvr_sugg = true;\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        if !alt_rcvr_sugg && self.suggest_valid_traits(err, valid_out_of_scope_traits) {\n             return;\n         }\n \n@@ -1075,6 +1136,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 \"the method might not be found because of this arbitrary self type\",\n             );\n         }\n+        if alt_rcvr_sugg {\n+            return;\n+        }\n \n         if !candidates.is_empty() {\n             // Sort from most relevant to least relevant.\n@@ -1284,7 +1348,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     /// Checks whether there is a local type somewhere in the chain of\n     /// autoderefs of `rcvr_ty`.\n-    fn type_derefs_to_local(&self, span: Span, rcvr_ty: Ty<'tcx>, source: SelfSource<'_>) -> bool {\n+    fn type_derefs_to_local(\n+        &self,\n+        span: Span,\n+        rcvr_ty: Ty<'tcx>,\n+        source: SelfSource<'tcx>,\n+    ) -> bool {\n         fn is_local(ty: Ty<'_>) -> bool {\n             match ty.kind() {\n                 ty::Adt(def, _) => def.did.is_local(),\n@@ -1310,7 +1379,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n }\n \n-#[derive(Copy, Clone)]\n+#[derive(Copy, Clone, Debug)]\n pub enum SelfSource<'a> {\n     QPath(&'a hir::Ty<'a>),\n     MethodCall(&'a hir::Expr<'a> /* rcvr */),"}, {"sha": "53593b9bab4b82a184704ebbc1c2d611e91e1109", "filename": "compiler/rustc_typeck/src/check/pat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b467787b625d83d5cf210e70d56487e53ce4255/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b467787b625d83d5cf210e70d56487e53ce4255/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs?ref=5b467787b625d83d5cf210e70d56487e53ce4255", "patch": "@@ -861,7 +861,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn check_pat_tuple_struct(\n         &self,\n         pat: &'tcx Pat<'tcx>,\n-        qpath: &hir::QPath<'_>,\n+        qpath: &'tcx hir::QPath<'tcx>,\n         subpats: &'tcx [&'tcx Pat<'tcx>],\n         ddpos: Option<usize>,\n         expected: Ty<'tcx>,"}, {"sha": "0d1fe684f60e223042e2e1a02b8f2112f9cae7de", "filename": "src/test/ui/async-await/pin-needed-to-poll.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/5b467787b625d83d5cf210e70d56487e53ce4255/src%2Ftest%2Fui%2Fasync-await%2Fpin-needed-to-poll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b467787b625d83d5cf210e70d56487e53ce4255/src%2Ftest%2Fui%2Fasync-await%2Fpin-needed-to-poll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fpin-needed-to-poll.rs?ref=5b467787b625d83d5cf210e70d56487e53ce4255", "patch": "@@ -0,0 +1,47 @@\n+use std::{\n+    future::Future,\n+    pin::Pin,\n+    task::{Context, Poll},\n+};\n+\n+struct Sleep;\n+\n+impl Future for Sleep {\n+    type Output = ();\n+\n+    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {\n+        Poll::Ready(())\n+    }\n+}\n+\n+impl Drop for Sleep {\n+    fn drop(&mut self) {}\n+}\n+\n+fn sleep() -> Sleep {\n+    Sleep\n+}\n+\n+\n+struct MyFuture {\n+    sleep: Sleep,\n+}\n+\n+impl MyFuture {\n+    fn new() -> Self {\n+        Self {\n+            sleep: sleep(),\n+        }\n+    }\n+}\n+\n+impl Future for MyFuture {\n+    type Output = ();\n+\n+    fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {\n+        self.sleep.poll(cx)\n+        //~^ ERROR no method named `poll` found for struct `Sleep` in the current scope\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "0756a4d59c19b1fe3d19f16d72d540a7bb1d9e70", "filename": "src/test/ui/async-await/pin-needed-to-poll.stderr", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5b467787b625d83d5cf210e70d56487e53ce4255/src%2Ftest%2Fui%2Fasync-await%2Fpin-needed-to-poll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5b467787b625d83d5cf210e70d56487e53ce4255/src%2Ftest%2Fui%2Fasync-await%2Fpin-needed-to-poll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fpin-needed-to-poll.stderr?ref=5b467787b625d83d5cf210e70d56487e53ce4255", "patch": "@@ -0,0 +1,22 @@\n+error[E0599]: no method named `poll` found for struct `Sleep` in the current scope\n+  --> $DIR/pin-needed-to-poll.rs:42:20\n+   |\n+LL | struct Sleep;\n+   | ------------- method `poll` not found for this\n+...\n+LL |         self.sleep.poll(cx)\n+   |                    ^^^^ method not found in `Sleep`\n+   | \n+  ::: $SRC_DIR/core/src/future/future.rs:LL:COL\n+   |\n+LL |     fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output>;\n+   |        ---- the method is available for `Pin<&mut Sleep>` here\n+   |\n+help: consider wrapping the receiver expression with the appropriate type\n+   |\n+LL |         Pin::new(&mut self.sleep).poll(cx)\n+   |         ^^^^^^^^^^^^^           ^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0599`."}, {"sha": "79095452f9d02230a361e3c945109469081c9483", "filename": "src/test/ui/copy-a-resource.stderr", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5b467787b625d83d5cf210e70d56487e53ce4255/src%2Ftest%2Fui%2Fcopy-a-resource.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5b467787b625d83d5cf210e70d56487e53ce4255/src%2Ftest%2Fui%2Fcopy-a-resource.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcopy-a-resource.stderr?ref=5b467787b625d83d5cf210e70d56487e53ce4255", "patch": "@@ -6,14 +6,6 @@ LL | struct Foo {\n ...\n LL |     let _y = x.clone();\n    |                ^^^^^ method not found in `Foo`\n-   | \n-  ::: $SRC_DIR/core/src/clone.rs:LL:COL\n-   |\n-LL |     fn clone(&self) -> Self;\n-   |        -----\n-   |        |\n-   |        the method is available for `Arc<Foo>` here\n-   |        the method is available for `Rc<Foo>` here\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `clone`, perhaps you need to implement it:"}, {"sha": "fd993d0f9d8854059c3bac4facd829919c742dad", "filename": "src/test/ui/derives/derive-assoc-type-not-impl.stderr", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5b467787b625d83d5cf210e70d56487e53ce4255/src%2Ftest%2Fui%2Fderives%2Fderive-assoc-type-not-impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5b467787b625d83d5cf210e70d56487e53ce4255/src%2Ftest%2Fui%2Fderives%2Fderive-assoc-type-not-impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fderive-assoc-type-not-impl.stderr?ref=5b467787b625d83d5cf210e70d56487e53ce4255", "patch": "@@ -12,14 +12,6 @@ LL | struct NotClone;\n ...\n LL |     Bar::<NotClone> { x: 1 }.clone();\n    |                              ^^^^^ method cannot be called on `Bar<NotClone>` due to unsatisfied trait bounds\n-   | \n-  ::: $SRC_DIR/core/src/clone.rs:LL:COL\n-   |\n-LL |     fn clone(&self) -> Self;\n-   |        -----\n-   |        |\n-   |        the method is available for `Arc<Bar<NotClone>>` here\n-   |        the method is available for `Rc<Bar<NotClone>>` here\n    |\n    = note: the following trait bounds were not satisfied:\n            `NotClone: Clone`"}, {"sha": "b3bc946292f70ce7c54eb63422a366057d48acb6", "filename": "src/test/ui/issues/issue-2823.stderr", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5b467787b625d83d5cf210e70d56487e53ce4255/src%2Ftest%2Fui%2Fissues%2Fissue-2823.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5b467787b625d83d5cf210e70d56487e53ce4255/src%2Ftest%2Fui%2Fissues%2Fissue-2823.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-2823.stderr?ref=5b467787b625d83d5cf210e70d56487e53ce4255", "patch": "@@ -6,14 +6,6 @@ LL | struct C {\n ...\n LL |     let _d = c.clone();\n    |                ^^^^^ method not found in `C`\n-   | \n-  ::: $SRC_DIR/core/src/clone.rs:LL:COL\n-   |\n-LL |     fn clone(&self) -> Self;\n-   |        -----\n-   |        |\n-   |        the method is available for `Arc<C>` here\n-   |        the method is available for `Rc<C>` here\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `clone`, perhaps you need to implement it:"}, {"sha": "4dd6b4bbb68bebe0c6f39d8f841fed16d5fb0358", "filename": "src/test/ui/issues/issue-69725.stderr", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5b467787b625d83d5cf210e70d56487e53ce4255/src%2Ftest%2Fui%2Fissues%2Fissue-69725.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5b467787b625d83d5cf210e70d56487e53ce4255/src%2Ftest%2Fui%2Fissues%2Fissue-69725.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-69725.stderr?ref=5b467787b625d83d5cf210e70d56487e53ce4255", "patch": "@@ -8,14 +8,6 @@ LL |     let _ = Struct::<A>::new().clone();\n    |\n LL | pub struct Struct<A>(A);\n    | ------------------------ doesn't satisfy `Struct<A>: Clone`\n-   | \n-  ::: $SRC_DIR/core/src/clone.rs:LL:COL\n-   |\n-LL |     fn clone(&self) -> Self;\n-   |        -----\n-   |        |\n-   |        the method is available for `Arc<Struct<A>>` here\n-   |        the method is available for `Rc<Struct<A>>` here\n    |\n    = note: the following trait bounds were not satisfied:\n            `A: Clone`"}, {"sha": "99af04e7cd97e2b3d743d9f61eafac399ffd9f2c", "filename": "src/test/ui/non-copyable-void.stderr", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5b467787b625d83d5cf210e70d56487e53ce4255/src%2Ftest%2Fui%2Fnon-copyable-void.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5b467787b625d83d5cf210e70d56487e53ce4255/src%2Ftest%2Fui%2Fnon-copyable-void.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnon-copyable-void.stderr?ref=5b467787b625d83d5cf210e70d56487e53ce4255", "patch": "@@ -3,14 +3,6 @@ error[E0599]: no method named `clone` found for enum `c_void` in the current sco\n    |\n LL |         let _z = (*y).clone();\n    |                       ^^^^^ method not found in `c_void`\n-   | \n-  ::: $SRC_DIR/core/src/clone.rs:LL:COL\n-   |\n-LL |     fn clone(&self) -> Self;\n-   |        -----\n-   |        |\n-   |        the method is available for `Arc<c_void>` here\n-   |        the method is available for `Rc<c_void>` here\n \n error: aborting due to previous error\n "}, {"sha": "4674c16eb433a12230ddbef3768fdd7cd4929e8e", "filename": "src/test/ui/noncopyable-class.stderr", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5b467787b625d83d5cf210e70d56487e53ce4255/src%2Ftest%2Fui%2Fnoncopyable-class.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5b467787b625d83d5cf210e70d56487e53ce4255/src%2Ftest%2Fui%2Fnoncopyable-class.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnoncopyable-class.stderr?ref=5b467787b625d83d5cf210e70d56487e53ce4255", "patch": "@@ -6,14 +6,6 @@ LL | struct Foo {\n ...\n LL |     let _y = x.clone();\n    |                ^^^^^ method not found in `Foo`\n-   | \n-  ::: $SRC_DIR/core/src/clone.rs:LL:COL\n-   |\n-LL |     fn clone(&self) -> Self;\n-   |        -----\n-   |        |\n-   |        the method is available for `Arc<Foo>` here\n-   |        the method is available for `Rc<Foo>` here\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `clone`, perhaps you need to implement it:"}, {"sha": "b804ddfb024bf310ccb36d1d4e853f549cf3c07a", "filename": "src/test/ui/self/point-at-arbitrary-self-type-method.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5b467787b625d83d5cf210e70d56487e53ce4255/src%2Ftest%2Fui%2Fself%2Fpoint-at-arbitrary-self-type-method.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5b467787b625d83d5cf210e70d56487e53ce4255/src%2Ftest%2Fui%2Fself%2Fpoint-at-arbitrary-self-type-method.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Fpoint-at-arbitrary-self-type-method.stderr?ref=5b467787b625d83d5cf210e70d56487e53ce4255", "patch": "@@ -9,6 +9,11 @@ LL |     fn foo(self: Box<Self>) {}\n ...\n LL |     A.foo();\n    |       ^^^ method not found in `A`\n+   |\n+help: consider wrapping the receiver expression with the appropriate type\n+   |\n+LL |     Box::new(A).foo();\n+   |     ^^^^^^^^^ ^\n \n error: aborting due to previous error\n "}, {"sha": "e1ed0e42f985c4be2cc6603e11afa237e01eff99", "filename": "src/test/ui/self/point-at-arbitrary-self-type-trait-method.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5b467787b625d83d5cf210e70d56487e53ce4255/src%2Ftest%2Fui%2Fself%2Fpoint-at-arbitrary-self-type-trait-method.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5b467787b625d83d5cf210e70d56487e53ce4255/src%2Ftest%2Fui%2Fself%2Fpoint-at-arbitrary-self-type-trait-method.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Fpoint-at-arbitrary-self-type-trait-method.stderr?ref=5b467787b625d83d5cf210e70d56487e53ce4255", "patch": "@@ -10,6 +10,11 @@ LL | struct A;\n ...\n LL |     A.foo()\n    |       ^^^ method not found in `A`\n+   |\n+help: consider wrapping the receiver expression with the appropriate type\n+   |\n+LL |     Box::new(A).foo()\n+   |     ^^^^^^^^^ ^\n \n error: aborting due to previous error\n "}, {"sha": "916a6c2bf12af6277f3affdfbb205a216295f3dc", "filename": "src/test/ui/suggestions/lifetimes/missing-lifetimes-in-signature.nll.stderr", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/36eee62c08ebdd0f4605d7f7574cdd6db245eaaa/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Fmissing-lifetimes-in-signature.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/36eee62c08ebdd0f4605d7f7574cdd6db245eaaa/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Fmissing-lifetimes-in-signature.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Fmissing-lifetimes-in-signature.nll.stderr?ref=36eee62c08ebdd0f4605d7f7574cdd6db245eaaa", "patch": "@@ -1,11 +0,0 @@\n-error[E0261]: use of undeclared lifetime name `'a`\n-  --> $DIR/missing-lifetimes-in-signature.rs:36:11\n-   |\n-LL | fn baz<G: 'a, T>(g: G, dest: &mut T) -> impl FnOnce() + '_\n-   |        -  ^^ undeclared lifetime\n-   |        |\n-   |        help: consider introducing lifetime `'a` here: `'a,`\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0261`."}, {"sha": "01e36a4a62a1bcc01715166670471d9f3f1e6d38", "filename": "src/test/ui/traits/negative-impls/explicitly-unimplemented-error-message.stderr", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5b467787b625d83d5cf210e70d56487e53ce4255/src%2Ftest%2Fui%2Ftraits%2Fnegative-impls%2Fexplicitly-unimplemented-error-message.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5b467787b625d83d5cf210e70d56487e53ce4255/src%2Ftest%2Fui%2Ftraits%2Fnegative-impls%2Fexplicitly-unimplemented-error-message.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fnegative-impls%2Fexplicitly-unimplemented-error-message.stderr?ref=5b467787b625d83d5cf210e70d56487e53ce4255", "patch": "@@ -6,14 +6,6 @@ LL | struct Qux;\n ...\n LL |     Qux.clone();\n    |         ^^^^^ method not found in `Qux`\n-   | \n-  ::: $SRC_DIR/core/src/clone.rs:LL:COL\n-   |\n-LL |     fn clone(&self) -> Self;\n-   |        -----\n-   |        |\n-   |        the method is available for `Arc<Qux>` here\n-   |        the method is available for `Rc<Qux>` here\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the trait `Clone` defines an item `clone`, but is explicitely unimplemented"}, {"sha": "546394664dfe8ecd8bdaafc038b6b4a688a26fcd", "filename": "src/test/ui/union/union-derive-clone.stderr", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5b467787b625d83d5cf210e70d56487e53ce4255/src%2Ftest%2Fui%2Funion%2Funion-derive-clone.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5b467787b625d83d5cf210e70d56487e53ce4255/src%2Ftest%2Fui%2Funion%2Funion-derive-clone.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-derive-clone.stderr?ref=5b467787b625d83d5cf210e70d56487e53ce4255", "patch": "@@ -25,14 +25,6 @@ LL | struct CloneNoCopy;\n ...\n LL |     let w = u.clone();\n    |               ^^^^^ method cannot be called on `U5<CloneNoCopy>` due to unsatisfied trait bounds\n-   | \n-  ::: $SRC_DIR/core/src/clone.rs:LL:COL\n-   |\n-LL |     fn clone(&self) -> Self;\n-   |        -----\n-   |        |\n-   |        the method is available for `Arc<U5<CloneNoCopy>>` here\n-   |        the method is available for `Rc<U5<CloneNoCopy>>` here\n    |\n    = note: the following trait bounds were not satisfied:\n            `CloneNoCopy: Copy`"}, {"sha": "6a355dd2562862003d8bc26663c1ef93cddb6cbd", "filename": "src/test/ui/unique-object-noncopyable.stderr", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5b467787b625d83d5cf210e70d56487e53ce4255/src%2Ftest%2Fui%2Funique-object-noncopyable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5b467787b625d83d5cf210e70d56487e53ce4255/src%2Ftest%2Fui%2Funique-object-noncopyable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funique-object-noncopyable.stderr?ref=5b467787b625d83d5cf210e70d56487e53ce4255", "patch": "@@ -10,14 +10,6 @@ LL |   trait Foo {\n LL |       let _z = y.clone();\n    |                  ^^^^^ method cannot be called on `Box<dyn Foo>` due to unsatisfied trait bounds\n    | \n-  ::: $SRC_DIR/core/src/clone.rs:LL:COL\n-   |\n-LL |       fn clone(&self) -> Self;\n-   |          -----\n-   |          |\n-   |          the method is available for `Arc<Box<dyn Foo>>` here\n-   |          the method is available for `Rc<Box<dyn Foo>>` here\n-   | \n   ::: $SRC_DIR/alloc/src/boxed.rs:LL:COL\n    |\n LL | / pub struct Box<"}, {"sha": "a4421bcf8097e6ff17cde0c2f78cda6907ad7eb3", "filename": "src/test/ui/unique-pinned-nocopy.stderr", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5b467787b625d83d5cf210e70d56487e53ce4255/src%2Ftest%2Fui%2Funique-pinned-nocopy.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5b467787b625d83d5cf210e70d56487e53ce4255/src%2Ftest%2Fui%2Funique-pinned-nocopy.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funique-pinned-nocopy.stderr?ref=5b467787b625d83d5cf210e70d56487e53ce4255", "patch": "@@ -7,14 +7,6 @@ LL |   struct R {\n LL |       let _j = i.clone();\n    |                  ^^^^^ method cannot be called on `Box<R>` due to unsatisfied trait bounds\n    | \n-  ::: $SRC_DIR/core/src/clone.rs:LL:COL\n-   |\n-LL |       fn clone(&self) -> Self;\n-   |          -----\n-   |          |\n-   |          the method is available for `Arc<Box<R>>` here\n-   |          the method is available for `Rc<Box<R>>` here\n-   | \n   ::: $SRC_DIR/alloc/src/boxed.rs:LL:COL\n    |\n LL | / pub struct Box<"}]}