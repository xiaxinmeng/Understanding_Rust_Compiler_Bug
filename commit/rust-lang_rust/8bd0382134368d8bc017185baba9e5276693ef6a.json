{"sha": "8bd0382134368d8bc017185baba9e5276693ef6a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhiZDAzODIxMzQzNjhkOGJjMDE3MTg1YmFiYTllNTI3NjY5M2VmNmE=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2019-09-26T15:18:31Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2019-09-26T17:21:09Z"}, "message": "Rename `Pat.node` to `Pat.kind`", "tree": {"sha": "6541f5e3f12613a63d7a030feeb980a56e738663", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6541f5e3f12613a63d7a030feeb980a56e738663"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8bd0382134368d8bc017185baba9e5276693ef6a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8bd0382134368d8bc017185baba9e5276693ef6a", "html_url": "https://github.com/rust-lang/rust/commit/8bd0382134368d8bc017185baba9e5276693ef6a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8bd0382134368d8bc017185baba9e5276693ef6a/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "95f6d72a60461a4a432d7e8971bb6a1899456b56", "url": "https://api.github.com/repos/rust-lang/rust/commits/95f6d72a60461a4a432d7e8971bb6a1899456b56", "html_url": "https://github.com/rust-lang/rust/commit/95f6d72a60461a4a432d7e8971bb6a1899456b56"}], "stats": {"total": 270, "additions": 135, "deletions": 135}, "files": [{"sha": "89b27f0b7b364b5d1b7937767c2d3281264a4bfc", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=8bd0382134368d8bc017185baba9e5276693ef6a", "patch": "@@ -696,7 +696,7 @@ pub fn walk_assoc_type_binding<'v, V: Visitor<'v>>(visitor: &mut V,\n \n pub fn walk_pat<'v, V: Visitor<'v>>(visitor: &mut V, pattern: &'v Pat) {\n     visitor.visit_id(pattern.hir_id);\n-    match pattern.node {\n+    match pattern.kind {\n         PatKind::TupleStruct(ref qpath, ref children, _) => {\n             visitor.visit_qpath(qpath, pattern.hir_id, pattern.span);\n             walk_list!(visitor, visit_pat, children);"}, {"sha": "5f2343065f769103b815a4f6e11787e3f4a20310", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=8bd0382134368d8bc017185baba9e5276693ef6a", "patch": "@@ -425,7 +425,7 @@ impl<'a> LoweringContext<'a> {\n \n         impl<'tcx, 'interner> Visitor<'tcx> for MiscCollector<'tcx, 'interner> {\n             fn visit_pat(&mut self, p: &'tcx Pat) {\n-                if let PatKind::Paren(..) | PatKind::Rest = p.node {\n+                if let PatKind::Paren(..) | PatKind::Rest = p.kind {\n                     // Doesn't generate a HIR node\n                 } else if let Some(owner) = self.hir_id_owner {\n                     self.lctx.lower_node_id_with_owner(p.id, owner);\n@@ -2095,7 +2095,7 @@ impl<'a> LoweringContext<'a> {\n     fn lower_fn_params_to_names(&mut self, decl: &FnDecl) -> hir::HirVec<Ident> {\n         decl.inputs\n             .iter()\n-            .map(|param| match param.pat.node {\n+            .map(|param| match param.pat.kind {\n                 PatKind::Ident(_, ident, _) => ident,\n                 _ => Ident::new(kw::Invalid, param.pat.span),\n             })\n@@ -2172,7 +2172,7 @@ impl<'a> LoweringContext<'a> {\n             implicit_self: decl.inputs.get(0).map_or(\n                 hir::ImplicitSelfKind::None,\n                 |arg| {\n-                    let is_mutable_pat = match arg.pat.node {\n+                    let is_mutable_pat = match arg.pat.kind {\n                         PatKind::Ident(BindingMode::ByValue(mt), _, _) |\n                         PatKind::Ident(BindingMode::ByRef(mt), _, _) =>\n                             mt == Mutability::Mutable,\n@@ -2688,7 +2688,7 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn lower_pat(&mut self, p: &Pat) -> P<hir::Pat> {\n-        let node = match p.node {\n+        let node = match p.kind {\n             PatKind::Wild => hir::PatKind::Wild,\n             PatKind::Ident(ref binding_mode, ident, ref sub) => {\n                 let lower_sub = |this: &mut Self| sub.as_ref().map(|x| this.lower_pat(x));\n@@ -2805,7 +2805,7 @@ impl<'a> LoweringContext<'a> {\n         let mut iter = pats.iter();\n         while let Some(pat) = iter.next() {\n             // Interpret the first `((ref mut?)? x @)? ..` pattern as a subslice pattern.\n-            match pat.node {\n+            match pat.kind {\n                 PatKind::Rest => {\n                     prev_rest_span = Some(pat.span);\n                     slice = Some(self.pat_wild_with_node_id_of(pat));\n@@ -2827,7 +2827,7 @@ impl<'a> LoweringContext<'a> {\n \n         while let Some(pat) = iter.next() {\n             // There was a previous subslice pattern; make sure we don't allow more.\n-            let rest_span = match pat.node {\n+            let rest_span = match pat.kind {\n                 PatKind::Rest => Some(pat.span),\n                 PatKind::Ident(.., Some(ref sub)) if sub.is_rest() => {\n                     // The `HirValidator` is merciless; add a `_` pattern to avoid ICEs.\n@@ -2884,10 +2884,10 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     /// Construct a `Pat` with the `HirId` of `p.id` lowered.\n-    fn pat_with_node_id_of(&mut self, p: &Pat, node: hir::PatKind) -> P<hir::Pat> {\n+    fn pat_with_node_id_of(&mut self, p: &Pat, kind: hir::PatKind) -> P<hir::Pat> {\n         P(hir::Pat {\n             hir_id: self.lower_node_id(p.id),\n-            node,\n+            kind,\n             span: p.span,\n         })\n     }\n@@ -3112,7 +3112,7 @@ impl<'a> LoweringContext<'a> {\n         (\n             P(hir::Pat {\n                 hir_id,\n-                node: hir::PatKind::Binding(bm, hir_id, ident.with_span_pos(span), None),\n+                kind: hir::PatKind::Binding(bm, hir_id, ident.with_span_pos(span), None),\n                 span,\n             }),\n             hir_id\n@@ -3123,10 +3123,10 @@ impl<'a> LoweringContext<'a> {\n         self.pat(span, hir::PatKind::Wild)\n     }\n \n-    fn pat(&mut self, span: Span, pat: hir::PatKind) -> P<hir::Pat> {\n+    fn pat(&mut self, span: Span, kind: hir::PatKind) -> P<hir::Pat> {\n         P(hir::Pat {\n             hir_id: self.next_id(),\n-            node: pat,\n+            kind,\n             span,\n         })\n     }"}, {"sha": "f98ce418909b62988f245c86c6adb66cbfda5fc5", "filename": "src/librustc/hir/lowering/item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs?ref=8bd0382134368d8bc017185baba9e5276693ef6a", "patch": "@@ -1133,7 +1133,7 @@ impl LoweringContext<'_> {\n \n                 // Check if this is a binding pattern, if so, we can optimize and avoid adding a\n                 // `let <pat> = __argN;` statement. In this case, we do not rename the parameter.\n-                let (ident, is_simple_parameter) = match parameter.pat.node {\n+                let (ident, is_simple_parameter) = match parameter.pat.kind {\n                     hir::PatKind::Binding(hir::BindingAnnotation::Unannotated, _, ident, _) =>\n                         (ident, true),\n                     _ => {"}, {"sha": "815a239405cdc3f1642e96e4951d2a40e6f59486", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=8bd0382134368d8bc017185baba9e5276693ef6a", "patch": "@@ -427,7 +427,7 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n     }\n \n     fn visit_pat(&mut self, pat: &'hir Pat) {\n-        let node = if let PatKind::Binding(..) = pat.node {\n+        let node = if let PatKind::Binding(..) = pat.kind {\n             Node::Binding(pat)\n         } else {\n             Node::Pat(pat)"}, {"sha": "538f181dd33140729fb43cc92fff215ea99a62e3", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=8bd0382134368d8bc017185baba9e5276693ef6a", "patch": "@@ -257,7 +257,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n     }\n \n     fn visit_pat(&mut self, pat: &'a Pat) {\n-        match pat.node {\n+        match pat.kind {\n             PatKind::Mac(..) => return self.visit_macro_invoc(pat.id),\n             _ => visit::walk_pat(self, pat),\n         }"}, {"sha": "a8f460b740c9b53d1b522bfb2fbe1b3a409dd662", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=8bd0382134368d8bc017185baba9e5276693ef6a", "patch": "@@ -948,7 +948,7 @@ impl<'hir> Map<'hir> {\n             Node::Field(f) => f.ident.name,\n             Node::Lifetime(lt) => lt.name.ident().name,\n             Node::GenericParam(param) => param.name.ident().name,\n-            Node::Binding(&Pat { node: PatKind::Binding(_, _, l, _), .. }) => l.name,\n+            Node::Binding(&Pat { kind: PatKind::Binding(_, _, l, _), .. }) => l.name,\n             Node::Ctor(..) => self.name(self.get_parent_item(id)),\n             _ => bug!(\"no name for {}\", self.node_to_string(id))\n         }"}, {"sha": "1a9166c2988d3d38f786d39fe52ff1ab87832e37", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=8bd0382134368d8bc017185baba9e5276693ef6a", "patch": "@@ -869,7 +869,7 @@ pub struct Block {\n pub struct Pat {\n     #[stable_hasher(ignore)]\n     pub hir_id: HirId,\n-    pub node: PatKind,\n+    pub kind: PatKind,\n     pub span: Span,\n }\n \n@@ -888,7 +888,7 @@ impl Pat {\n         }\n \n         use PatKind::*;\n-        match &self.node {\n+        match &self.kind {\n             Wild | Lit(_) | Range(..) | Binding(.., None) | Path(_) => true,\n             Box(s) | Ref(s, _) | Binding(.., Some(s)) => s.walk_short_(it),\n             Struct(_, fields, _) => fields.iter().all(|field| field.pat.walk_short_(it)),\n@@ -919,7 +919,7 @@ impl Pat {\n         }\n \n         use PatKind::*;\n-        match &self.node {\n+        match &self.kind {\n             Wild | Lit(_) | Range(..) | Binding(.., None) | Path(_) => {},\n             Box(s) | Ref(s, _) | Binding(.., Some(s)) => s.walk_(it),\n             Struct(_, fields, _) => fields.iter().for_each(|field| field.pat.walk_(it)),\n@@ -1295,7 +1295,7 @@ impl Arm {\n     // HACK(or_patterns; Centril | dlrobertson): Remove this and\n     // correctly handle each case in which this method is used.\n     pub fn top_pats_hack(&self) -> &[P<Pat>] {\n-        match &self.pat.node {\n+        match &self.pat.kind {\n             PatKind::Or(pats) => pats,\n             _ => std::slice::from_ref(&self.pat),\n         }"}, {"sha": "feb0d97822c42a604f6ad5cc67e880d96163b286", "filename": "src/librustc/hir/pat_util.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Flibrustc%2Fhir%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Flibrustc%2Fhir%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fpat_util.rs?ref=8bd0382134368d8bc017185baba9e5276693ef6a", "patch": "@@ -45,7 +45,7 @@ impl<T: ExactSizeIterator> EnumerateAndAdjustIterator for T {\n \n impl hir::Pat {\n     pub fn is_refutable(&self) -> bool {\n-        match self.node {\n+        match self.kind {\n             PatKind::Lit(_) |\n             PatKind::Range(..) |\n             PatKind::Path(hir::QPath::Resolved(Some(..), _)) |\n@@ -68,7 +68,7 @@ impl hir::Pat {\n     /// `match foo() { Some(a) => (), None => () }`\n     pub fn each_binding(&self, mut f: impl FnMut(hir::BindingAnnotation, HirId, Span, ast::Ident)) {\n         self.walk(|p| {\n-            if let PatKind::Binding(binding_mode, _, ident, _) = p.node {\n+            if let PatKind::Binding(binding_mode, _, ident, _) = p.kind {\n                 f(binding_mode, p.hir_id, p.span, ident);\n             }\n             true\n@@ -83,7 +83,7 @@ impl hir::Pat {\n         &self,\n         f: &mut impl FnMut(hir::BindingAnnotation, HirId, Span, ast::Ident),\n     ) {\n-        self.walk(|p| match &p.node {\n+        self.walk(|p| match &p.kind {\n             PatKind::Or(ps) => {\n                 ps[0].each_binding_or_first(f);\n                 false\n@@ -99,7 +99,7 @@ impl hir::Pat {\n     /// Checks if the pattern contains any patterns that bind something to\n     /// an ident, e.g., `foo`, or `Foo(foo)` or `foo @ Bar(..)`.\n     pub fn contains_bindings(&self) -> bool {\n-        self.satisfies(|p| match p.node {\n+        self.satisfies(|p| match p.kind {\n             PatKind::Binding(..) => true,\n             _ => false,\n         })\n@@ -108,7 +108,7 @@ impl hir::Pat {\n     /// Checks if the pattern contains any patterns that bind something to\n     /// an ident or wildcard, e.g., `foo`, or `Foo(_)`, `foo @ Bar(..)`,\n     pub fn contains_bindings_or_wild(&self) -> bool {\n-        self.satisfies(|p| match p.node {\n+        self.satisfies(|p| match p.kind {\n             PatKind::Binding(..) | PatKind::Wild => true,\n             _ => false,\n         })\n@@ -129,7 +129,7 @@ impl hir::Pat {\n     }\n \n     pub fn simple_ident(&self) -> Option<ast::Ident> {\n-        match self.node {\n+        match self.kind {\n             PatKind::Binding(hir::BindingAnnotation::Unannotated, _, ident, None) |\n             PatKind::Binding(hir::BindingAnnotation::Mutable, _, ident, None) => Some(ident),\n             _ => None,\n@@ -139,7 +139,7 @@ impl hir::Pat {\n     /// Returns variants that are necessary to exist for the pattern to match.\n     pub fn necessary_variants(&self) -> Vec<DefId> {\n         let mut variants = vec![];\n-        self.walk(|p| match &p.node {\n+        self.walk(|p| match &p.kind {\n             PatKind::Or(_) => false,\n             PatKind::Path(hir::QPath::Resolved(_, path)) |\n             PatKind::TupleStruct(hir::QPath::Resolved(_, path), ..) |"}, {"sha": "81b89b92210ac8aa95f0fd8c468c6136fd69340a", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=8bd0382134368d8bc017185baba9e5276693ef6a", "patch": "@@ -1617,7 +1617,7 @@ impl<'a> State<'a> {\n         self.ann.pre(self, AnnNode::Pat(pat));\n         // Pat isn't normalized, but the beauty of it\n         // is that it doesn't matter\n-        match pat.node {\n+        match pat.kind {\n             PatKind::Wild => self.s.word(\"_\"),\n             PatKind::Binding(binding_mode, _, ident, ref sub) => {\n                 match binding_mode {\n@@ -1710,7 +1710,7 @@ impl<'a> State<'a> {\n                 self.pclose();\n             }\n             PatKind::Box(ref inner) => {\n-                let is_range_inner = match inner.node {\n+                let is_range_inner = match inner.kind {\n                     PatKind::Range(..) => true,\n                     _ => false,\n                 };\n@@ -1724,7 +1724,7 @@ impl<'a> State<'a> {\n                 }\n             }\n             PatKind::Ref(ref inner, mutbl) => {\n-                let is_range_inner = match inner.node {\n+                let is_range_inner = match inner.kind {\n                     PatKind::Range(..) => true,\n                     _ => false,\n                 };\n@@ -1757,7 +1757,7 @@ impl<'a> State<'a> {\n                     if !before.is_empty() {\n                         self.word_space(\",\");\n                     }\n-                    if let PatKind::Wild = p.node {\n+                    if let PatKind::Wild = p.kind {\n                         // Print nothing.\n                     } else {\n                         self.print_pat(&p);"}, {"sha": "5c5f7f6120082d1d83c1344347a2160f52c1be23", "filename": "src/librustc/hir/upvars.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Flibrustc%2Fhir%2Fupvars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Flibrustc%2Fhir%2Fupvars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fupvars.rs?ref=8bd0382134368d8bc017185baba9e5276693ef6a", "patch": "@@ -47,7 +47,7 @@ impl Visitor<'tcx> for LocalCollector {\n     }\n \n     fn visit_pat(&mut self, pat: &'tcx hir::Pat) {\n-        if let hir::PatKind::Binding(_, hir_id, ..) = pat.node {\n+        if let hir::PatKind::Binding(_, hir_id, ..) = pat.kind {\n             self.locals.insert(hir_id);\n         }\n         intravisit::walk_pat(self, pat);"}, {"sha": "8a27c5b35c51428991ae467be4c8d1877901e8e3", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=8bd0382134368d8bc017185baba9e5276693ef6a", "patch": "@@ -133,7 +133,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n             _ => span_bug!(lhs.span, \"non-ADT in struct pattern\")\n         };\n         for pat in pats {\n-            if let PatKind::Wild = pat.pat.node {\n+            if let PatKind::Wild = pat.pat.kind {\n                 continue;\n             }\n             let index = self.tcx.field_index(pat.hir_id, self.tables);\n@@ -269,7 +269,7 @@ impl<'a, 'tcx> Visitor<'tcx> for MarkSymbolVisitor<'a, 'tcx> {\n     }\n \n     fn visit_pat(&mut self, pat: &'tcx hir::Pat) {\n-        match pat.node {\n+        match pat.kind {\n             PatKind::Struct(ref path, ref fields, _) => {\n                 let res = self.tables.qpath_res(path, pat.hir_id);\n                 self.handle_field_pattern_match(pat, res, fields);"}, {"sha": "bb17905dd78f6b143dac7513db4919bbe7f882b8", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=8bd0382134368d8bc017185baba9e5276693ef6a", "patch": "@@ -812,7 +812,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n         debug!(\"determine_pat_move_mode cmt_discr={:?} pat={:?}\", cmt_discr, pat);\n \n         return_if_err!(self.mc.cat_pattern(cmt_discr, pat, |cmt_pat, pat| {\n-            if let PatKind::Binding(..) = pat.node {\n+            if let PatKind::Binding(..) = pat.kind {\n                 let bm = *self.mc.tables.pat_binding_modes()\n                                         .get(pat.hir_id)\n                                         .expect(\"missing binding mode\");\n@@ -839,7 +839,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n         let tcx = self.tcx();\n         let ExprUseVisitor { ref mc, ref mut delegate, param_env } = *self;\n         return_if_err!(mc.cat_pattern(cmt_discr.clone(), pat, |cmt_pat, pat| {\n-            if let PatKind::Binding(_, canonical_id, ..) = pat.node {\n+            if let PatKind::Binding(_, canonical_id, ..) = pat.kind {\n                 debug!(\n                     \"walk_pat: binding cmt_pat={:?} pat={:?} match_mode={:?}\",\n                     cmt_pat,\n@@ -885,7 +885,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n         // to the above loop's visit of than the bindings that form\n         // the leaves of the pattern tree structure.\n         return_if_err!(mc.cat_pattern(cmt_discr, pat, |cmt_pat, pat| {\n-            let qpath = match pat.node {\n+            let qpath = match pat.kind {\n                 PatKind::Path(ref qpath) |\n                 PatKind::TupleStruct(ref qpath, ..) |\n                 PatKind::Struct(ref qpath, ..) => qpath,"}, {"sha": "162b03c83590c346571a368d6fc0d05ff1113690", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=8bd0382134368d8bc017185baba9e5276693ef6a", "patch": "@@ -372,7 +372,7 @@ fn visit_fn<'tcx>(\n     let body = ir.tcx.hir().body(body_id);\n \n     for param in &body.params {\n-        let is_shorthand = match param.pat.node {\n+        let is_shorthand = match param.pat.kind {\n             crate::hir::PatKind::Struct(..) => true,\n             _ => false,\n         };\n@@ -412,7 +412,7 @@ fn add_from_pat(ir: &mut IrMaps<'_>, pat: &P<hir::Pat>) {\n     pats.push_back(pat);\n     while let Some(pat) = pats.pop_front() {\n         use crate::hir::PatKind::*;\n-        match &pat.node {\n+        match &pat.kind {\n             Binding(.., inner_pat) => {\n                 pats.extend(inner_pat.iter());\n             }"}, {"sha": "c6a46f60927e8fe660e8506e6a1858db2d3894d8", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=8bd0382134368d8bc017185baba9e5276693ef6a", "patch": "@@ -271,7 +271,7 @@ impl MutabilityCategory {\n         id: hir::HirId,\n     ) -> MutabilityCategory {\n         let ret = match tcx.hir().get(id) {\n-            Node::Binding(p) => match p.node {\n+            Node::Binding(p) => match p.kind {\n                 PatKind::Binding(..) => {\n                     let bm = *tables.pat_binding_modes()\n                                     .get(p.hir_id)\n@@ -486,7 +486,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n \n         // This code detects whether we are looking at a `ref x`,\n         // and if so, figures out what the type *being borrowed* is.\n-        let ret_ty = match pat.node {\n+        let ret_ty = match pat.kind {\n             PatKind::Binding(..) => {\n                 let bm = *self.tables\n                               .pat_binding_modes()\n@@ -1212,7 +1212,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         // that (where the `ref` on `x` is implied).\n         op(cmt.clone(), pat);\n \n-        match pat.node {\n+        match pat.kind {\n             PatKind::TupleStruct(ref qpath, ref subpats, ddpos) => {\n                 let res = self.tables.qpath_res(qpath, pat.hir_id);\n                 let (cmt, expected_len) = match res {"}, {"sha": "a3c21d8af46c7d1c6c3100de5ef8a14c7a716d6c", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=8bd0382134368d8bc017185baba9e5276693ef6a", "patch": "@@ -850,7 +850,7 @@ fn resolve_pat<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, pat: &'tcx hir\n     visitor.record_child_scope(Scope { id: pat.hir_id.local_id, data: ScopeData::Node });\n \n     // If this is a binding then record the lifetime of that binding.\n-    if let PatKind::Binding(..) = pat.node {\n+    if let PatKind::Binding(..) = pat.kind {\n         record_var_lifetime(visitor, pat.hir_id.local_id, pat.span);\n     }\n \n@@ -1198,7 +1198,7 @@ fn resolve_local<'tcx>(\n         // In the former case (the implicit ref version), the temporary is created by the\n         // & expression, and its lifetime would be extended to the end of the block (due\n         // to a different rule, not the below code).\n-        match pat.node {\n+        match pat.kind {\n             PatKind::Binding(hir::BindingAnnotation::Ref, ..) |\n             PatKind::Binding(hir::BindingAnnotation::RefMut, ..) => true,\n "}, {"sha": "5dc10dbc54df63e840e8fff1a0cdcd5ca68b1bb2", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=8bd0382134368d8bc017185baba9e5276693ef6a", "patch": "@@ -1010,7 +1010,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                                 \"{}({})\",\n                                 ident,\n                                 body.params.iter()\n-                                    .map(|arg| match &arg.pat.node {\n+                                    .map(|arg| match &arg.pat.kind {\n                                         hir::PatKind::Binding(_, _, ident, None)\n                                         if ident.name != kw::SelfLower => ident.to_string(),\n                                         _ => \"_\".to_string(),\n@@ -1141,7 +1141,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                  self.tcx.hir().body(id).params.iter()\n                     .map(|arg| {\n                         if let hir::Pat {\n-                            node: hir::PatKind::Tuple(ref args, _),\n+                            kind: hir::PatKind::Tuple(ref args, _),\n                             span,\n                             ..\n                         } = *arg.pat {"}, {"sha": "ef35e3615cdc372376cad7e77b944330a7b3e1ae", "filename": "src/librustc_ast_borrowck/cfg/construct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Flibrustc_ast_borrowck%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Flibrustc_ast_borrowck%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_borrowck%2Fcfg%2Fconstruct.rs?ref=8bd0382134368d8bc017185baba9e5276693ef6a", "patch": "@@ -114,7 +114,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n     }\n \n     fn pat(&mut self, pat: &hir::Pat, pred: CFGIndex) -> CFGIndex {\n-        match pat.node {\n+        match pat.kind {\n             PatKind::Binding(.., None) |\n             PatKind::Path(_) |\n             PatKind::Lit(..) |"}, {"sha": "ed31bc9106e28e40436c17a2e2508939d673707c", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=8bd0382134368d8bc017185baba9e5276693ef6a", "patch": "@@ -159,7 +159,7 @@ declare_lint_pass!(NonShorthandFieldPatterns => [NON_SHORTHAND_FIELD_PATTERNS]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonShorthandFieldPatterns {\n     fn check_pat(&mut self, cx: &LateContext<'_, '_>, pat: &hir::Pat) {\n-        if let PatKind::Struct(ref qpath, ref field_pats, _) = pat.node {\n+        if let PatKind::Struct(ref qpath, ref field_pats, _) = pat.kind {\n             let variant = cx.tables.pat_ty(pat).ty_adt_def()\n                                    .expect(\"struct pattern type is not an ADT\")\n                                    .variant_of_res(cx.tables.qpath_res(qpath, pat.hir_id));\n@@ -173,7 +173,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonShorthandFieldPatterns {\n                     // (Issue #49588)\n                     continue;\n                 }\n-                if let PatKind::Binding(_, _, ident, None) = fieldpat.pat.node {\n+                if let PatKind::Binding(_, _, ident, None) = fieldpat.pat.kind {\n                     if cx.tcx.find_field_index(ident, &variant) ==\n                        Some(cx.tcx.field_index(fieldpat.hir_id, cx.tables)) {\n                         let mut err = cx.struct_span_lint(NON_SHORTHAND_FIELD_PATTERNS,\n@@ -614,7 +614,7 @@ impl EarlyLintPass for AnonymousParameters {\n         match it.node {\n             ast::TraitItemKind::Method(ref sig, _) => {\n                 for arg in sig.decl.inputs.iter() {\n-                    match arg.pat.node {\n+                    match arg.pat.kind {\n                         ast::PatKind::Ident(_, ident, None) => {\n                             if ident.name == kw::Invalid {\n                                 let ty_snip = cx\n@@ -1321,15 +1321,15 @@ impl EarlyLintPass for EllipsisInclusiveRangePatterns {\n         /// If `pat` is a `...` pattern, return the start and end of the range, as well as the span\n         /// corresponding to the ellipsis.\n         fn matches_ellipsis_pat(pat: &ast::Pat) -> Option<(&P<Expr>, &P<Expr>, Span)> {\n-            match &pat.node {\n+            match &pat.kind {\n                 PatKind::Range(a, b, Spanned { span, node: RangeEnd::Included(DotDotDot), .. }) => {\n                     Some((a, b, *span))\n                 }\n                 _ => None,\n             }\n         }\n \n-        let (parenthesise, endpoints) = match &pat.node {\n+        let (parenthesise, endpoints) = match &pat.kind {\n             PatKind::Ref(subpat, _) => (true, matches_ellipsis_pat(&subpat)),\n             _ => (false, matches_ellipsis_pat(pat)),\n         };"}, {"sha": "cf67be21c1adae640c2f230709582b8ceaba0ec4", "filename": "src/librustc_lint/nonstandard_style.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Flibrustc_lint%2Fnonstandard_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Flibrustc_lint%2Fnonstandard_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fnonstandard_style.rs?ref=8bd0382134368d8bc017185baba9e5276693ef6a", "patch": "@@ -341,7 +341,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonSnakeCase {\n     }\n \n     fn check_pat(&mut self, cx: &LateContext<'_, '_>, p: &hir::Pat) {\n-        if let &PatKind::Binding(_, _, ident, _) = &p.node {\n+        if let &PatKind::Binding(_, _, ident, _) = &p.kind {\n             self.check_snake_case(cx, \"variable\", &ident);\n         }\n     }\n@@ -412,7 +412,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonUpperCaseGlobals {\n \n     fn check_pat(&mut self, cx: &LateContext<'_, '_>, p: &hir::Pat) {\n         // Lint for constants that look like binding identifiers (#7526)\n-        if let PatKind::Path(hir::QPath::Resolved(None, ref path)) = p.node {\n+        if let PatKind::Path(hir::QPath::Resolved(None, ref path)) = p.kind {\n             if let Res::Def(DefKind::Const, _) = path.res {\n                 if path.segments.len() == 1 {\n                     NonUpperCaseGlobals::check_upper_case("}, {"sha": "d13e4ad8a8b0b68d7560efd00de30ccc9093f2dd", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=8bd0382134368d8bc017185baba9e5276693ef6a", "patch": "@@ -416,8 +416,8 @@ impl UnusedParens {\n     ) {\n         use ast::{PatKind, BindingMode::ByValue, Mutability::Mutable};\n \n-        if let PatKind::Paren(inner) = &value.node {\n-            match inner.node {\n+        if let PatKind::Paren(inner) = &value.kind {\n+            match inner.kind {\n                 // The lint visitor will visit each subpattern of `p`. We do not want to lint\n                 // any range pattern no matter where it occurs in the pattern. For something like\n                 // `&(a..=b)`, there is a recursive `check_pat` on `a` and `b`, but we will assume\n@@ -566,7 +566,7 @@ impl EarlyLintPass for UnusedParens {\n \n     fn check_pat(&mut self, cx: &EarlyContext<'_>, p: &ast::Pat) {\n         use ast::{PatKind::*, Mutability};\n-        match &p.node {\n+        match &p.kind {\n             // Do not lint on `(..)` as that will result in the other arms being useless.\n             Paren(_)\n             // The other cases do not contain sub-patterns."}, {"sha": "d47a1a7bc895eac74ce466c0705fb81f97d233ae", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=8bd0382134368d8bc017185baba9e5276693ef6a", "patch": "@@ -1047,7 +1047,7 @@ impl EncodeContext<'tcx> {\n         self.tcx.dep_graph.with_ignore(|| {\n             let body = self.tcx.hir().body(body_id);\n             self.lazy(body.params.iter().map(|arg| {\n-                match arg.pat.node {\n+                match arg.pat.kind {\n                     PatKind::Binding(_, _, ident, _) => ident.name,\n                     _ => kw::Invalid,\n                 }"}, {"sha": "d0dd06f64d16497493e52f125cb7784d7cc4b99b", "filename": "src/librustc_mir/borrow_check/mutability_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs?ref=8bd0382134368d8bc017185baba9e5276693ef6a", "patch": "@@ -338,7 +338,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                         _,\n                         upvar_ident,\n                         _,\n-                    ) = pat.node\n+                    ) = pat.kind\n                     {\n                         err.span_suggestion(\n                             upvar_ident.span,"}, {"sha": "ff24286c51b7713f3970cab4be6e14dfbdf8a3ca", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=8bd0382134368d8bc017185baba9e5276693ef6a", "patch": "@@ -559,7 +559,7 @@ where\n             };\n             let mut mutability = Mutability::Not;\n             if let Some(Node::Binding(pat)) = tcx_hir.find(var_hir_id) {\n-                if let hir::PatKind::Binding(_, _, ident, _) = pat.node {\n+                if let hir::PatKind::Binding(_, _, ident, _) = pat.kind {\n                     debuginfo.debug_name = ident.name;\n                     if let Some(&bm) = hir.tables.pat_binding_modes().get(pat.hir_id) {\n                         if bm == ty::BindByValue(hir::MutMutable) {"}, {"sha": "822c9318dc3917e5b7d97933f0e13756c5c78f21", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=8bd0382134368d8bc017185baba9e5276693ef6a", "patch": "@@ -270,7 +270,7 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n                 \"refutable pattern in {}: {} not covered\",\n                 origin, joined_patterns\n             );\n-            err.span_label(pat.span, match &pat.node {\n+            err.span_label(pat.span, match &pat.kind {\n                 PatKind::Path(hir::QPath::Resolved(None, path))\n                     if path.segments.len() == 1 && path.segments[0].args.is_none() => {\n                     format!(\"interpreted as {} {} pattern, not new variable\",\n@@ -286,7 +286,7 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n \n fn check_for_bindings_named_same_as_variants(cx: &MatchVisitor<'_, '_>, pat: &Pat) {\n     pat.walk(|p| {\n-        if let PatKind::Binding(_, _, ident, None) = p.node {\n+        if let PatKind::Binding(_, _, ident, None) = p.kind {\n             if let Some(&bm) = cx.tables.pat_binding_modes().get(p.hir_id) {\n                 if bm != ty::BindByValue(hir::MutImmutable) {\n                     // Nothing to check.\n@@ -321,7 +321,7 @@ fn check_for_bindings_named_same_as_variants(cx: &MatchVisitor<'_, '_>, pat: &Pa\n \n /// Checks for common cases of \"catchall\" patterns that may not be intended as such.\n fn pat_is_catchall(pat: &Pat) -> bool {\n-    match pat.node {\n+    match pat.kind {\n         PatKind::Binding(.., None) => true,\n         PatKind::Binding(.., Some(ref s)) => pat_is_catchall(s),\n         PatKind::Ref(ref s, _) => pat_is_catchall(s),\n@@ -568,7 +568,7 @@ fn check_legality_of_move_bindings(cx: &mut MatchVisitor<'_, '_>, has_guard: boo\n     };\n \n     pat.walk(|p| {\n-        if let PatKind::Binding(.., sub) = &p.node {\n+        if let PatKind::Binding(.., sub) = &p.kind {\n             if let Some(&bm) = cx.tables.pat_binding_modes().get(p.hir_id) {\n                 if let ty::BindByValue(..) = bm {\n                     let pat_ty = cx.tables.node_type(p.hir_id);\n@@ -618,7 +618,7 @@ impl<'v> Visitor<'v> for AtBindingPatternVisitor<'_, '_, '_> {\n     }\n \n     fn visit_pat(&mut self, pat: &Pat) {\n-        match pat.node {\n+        match pat.kind {\n             PatKind::Binding(.., ref subpat) => {\n                 if !self.bindings_allowed {\n                     struct_span_err!(self.cx.tcx.sess, pat.span, E0303,"}, {"sha": "2a8c8739605344fcfb803f39f95c439662b01fc5", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=8bd0382134368d8bc017185baba9e5276693ef6a", "patch": "@@ -449,7 +449,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n     fn lower_pattern_unadjusted(&mut self, pat: &'tcx hir::Pat) -> Pattern<'tcx> {\n         let mut ty = self.tables.node_type(pat.hir_id);\n \n-        let kind = match pat.node {\n+        let kind = match pat.kind {\n             PatKind::Wild => PatternKind::Wild,\n \n             PatKind::Lit(ref value) => self.lower_lit(value),"}, {"sha": "853fcb1beabf574b8e45976fe0758885bfa018ec", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=8bd0382134368d8bc017185baba9e5276693ef6a", "patch": "@@ -200,7 +200,7 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, 'tcx, M\n                         if let Some((&var_hir_id, _)) = upvars.get_index(field) {\n                             let node = self.ecx.tcx.hir().get(var_hir_id);\n                             if let hir::Node::Binding(pat) = node {\n-                                if let hir::PatKind::Binding(_, _, ident, _) = pat.node {\n+                                if let hir::PatKind::Binding(_, _, ident, _) = pat.kind {\n                                     name = Some(ident.name);\n                                 }\n                             }"}, {"sha": "2511ee14759524677754a08ef94a0b9a3fe267a4", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=8bd0382134368d8bc017185baba9e5276693ef6a", "patch": "@@ -231,7 +231,7 @@ impl<'a> AstValidator<'a> {\n \n     fn check_decl_no_pat<ReportFn: Fn(Span, bool)>(&self, decl: &FnDecl, report_err: ReportFn) {\n         for arg in &decl.inputs {\n-            match arg.pat.node {\n+            match arg.pat.kind {\n                 PatKind::Ident(BindingMode::ByValue(Mutability::Immutable), _, None) |\n                 PatKind::Wild => {}\n                 PatKind::Ident(BindingMode::ByValue(Mutability::Mutable), _, None) =>\n@@ -786,7 +786,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n     }\n \n     fn visit_pat(&mut self, pat: &'a Pat) {\n-        match pat.node {\n+        match pat.kind {\n             PatKind::Lit(ref expr) => {\n                 self.check_expr_within_pat(expr, false);\n             }"}, {"sha": "39086ec8b9be39b1d6bbde490f31c9d46a8a33ca", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=8bd0382134368d8bc017185baba9e5276693ef6a", "patch": "@@ -1062,7 +1062,7 @@ impl<'a, 'tcx> Visitor<'tcx> for NamePrivacyVisitor<'a, 'tcx> {\n     }\n \n     fn visit_pat(&mut self, pat: &'tcx hir::Pat) {\n-        match pat.node {\n+        match pat.kind {\n             PatKind::Struct(ref qpath, ref fields, _) => {\n                 let res = self.tables.qpath_res(qpath, pat.hir_id);\n                 let adt = self.tables.pat_ty(pat).ty_adt_def().unwrap();"}, {"sha": "bb73efe0f6f1176f8af3a7263db2619b3739d99d", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=8bd0382134368d8bc017185baba9e5276693ef6a", "patch": "@@ -1134,7 +1134,7 @@ macro_rules! method {\n impl<'a, 'b> Visitor<'b> for BuildReducedGraphVisitor<'a, 'b> {\n     method!(visit_impl_item: ast::ImplItem, ast::ImplItemKind::Macro, walk_impl_item, node);\n     method!(visit_expr:      ast::Expr,     ast::ExprKind::Mac,       walk_expr, kind);\n-    method!(visit_pat:       ast::Pat,      ast::PatKind::Mac,        walk_pat, node);\n+    method!(visit_pat:       ast::Pat,      ast::PatKind::Mac,        walk_pat, kind);\n     method!(visit_ty:        ast::Ty,       ast::TyKind::Mac,         walk_ty, node);\n \n     fn visit_item(&mut self, item: &'b Item) {"}, {"sha": "e5ddf0d340d6dbeeb935ef34a7eb104ff4497e62", "filename": "src/librustc_resolve/late.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Flibrustc_resolve%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Flibrustc_resolve%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate.rs?ref=8bd0382134368d8bc017185baba9e5276693ef6a", "patch": "@@ -1146,7 +1146,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n         let mut binding_map = FxHashMap::default();\n \n         pat.walk(&mut |pat| {\n-            match pat.node {\n+            match pat.kind {\n                 PatKind::Ident(binding_mode, ident, ref sub_pat)\n                     if sub_pat.is_some() || self.is_base_res_local(pat.id) =>\n                 {\n@@ -1246,7 +1246,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n \n     /// Check the consistency of the outermost or-patterns.\n     fn check_consistent_bindings_top(&mut self, pat: &Pat) {\n-        pat.walk(&mut |pat| match pat.node {\n+        pat.walk(&mut |pat| match pat.kind {\n             PatKind::Or(ref ps) => {\n                 self.check_consistent_bindings(ps);\n                 false\n@@ -1308,8 +1308,8 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n     ) {\n         // Visit all direct subpatterns of this pattern.\n         pat.walk(&mut |pat| {\n-            debug!(\"resolve_pattern pat={:?} node={:?}\", pat, pat.node);\n-            match pat.node {\n+            debug!(\"resolve_pattern pat={:?} node={:?}\", pat, pat.kind);\n+            match pat.kind {\n                 PatKind::Ident(bmode, ident, ref sub) => {\n                     // First try to resolve the identifier as some existing entity,\n                     // then fall back to a fresh binding."}, {"sha": "5fd04be77000c9b73e486f46b6aefefbb2d36c2c", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=8bd0382134368d8bc017185baba9e5276693ef6a", "patch": "@@ -864,7 +864,7 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n     }\n \n     fn process_pat(&mut self, p: &'l ast::Pat) {\n-        match p.node {\n+        match p.kind {\n             PatKind::Struct(ref _path, ref fields, _) => {\n                 // FIXME do something with _path?\n                 let hir_id = self.tcx.hir().node_to_hir_id(p.id);"}, {"sha": "8ce85e01da15f68b71c925c4968b8911eab9c780", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=8bd0382134368d8bc017185baba9e5276693ef6a", "patch": "@@ -640,15 +640,15 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n                 ..\n             }) |\n             Node::Pat(&hir::Pat {\n-                node: hir::PatKind::Path(ref qpath),\n+                kind: hir::PatKind::Path(ref qpath),\n                 ..\n             }) |\n             Node::Pat(&hir::Pat {\n-                node: hir::PatKind::Struct(ref qpath, ..),\n+                kind: hir::PatKind::Struct(ref qpath, ..),\n                 ..\n             }) |\n             Node::Pat(&hir::Pat {\n-                node: hir::PatKind::TupleStruct(ref qpath, ..),\n+                kind: hir::PatKind::TupleStruct(ref qpath, ..),\n                 ..\n             }) |\n             Node::Ty(&hir::Ty {\n@@ -659,7 +659,7 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n             }\n \n             Node::Binding(&hir::Pat {\n-                node: hir::PatKind::Binding(_, canonical_id, ..),\n+                kind: hir::PatKind::Binding(_, canonical_id, ..),\n                 ..\n             }) => Res::Local(canonical_id),\n \n@@ -965,7 +965,7 @@ impl<'l> PathCollector<'l> {\n \n impl<'l> Visitor<'l> for PathCollector<'l> {\n     fn visit_pat(&mut self, p: &'l ast::Pat) {\n-        match p.node {\n+        match p.kind {\n             PatKind::Struct(ref path, ..) => {\n                 self.collected_paths.push((p.id, path));\n             }"}, {"sha": "d2d3854d2758cc6311e0941ca90ed332f171ed01", "filename": "src/librustc_typeck/check/generator_interior.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs?ref=8bd0382134368d8bc017185baba9e5276693ef6a", "patch": "@@ -167,7 +167,7 @@ impl<'a, 'tcx> Visitor<'tcx> for InteriorVisitor<'a, 'tcx> {\n \n         self.expr_count += 1;\n \n-        if let PatKind::Binding(..) = pat.node {\n+        if let PatKind::Binding(..) = pat.kind {\n             let scope = self.region_scope_tree.var_scope(pat.hir_id.local_id);\n             let ty = self.fcx.tables.borrow().pat_ty(pat);\n             self.record(ty, Some(scope), None, pat.span);"}, {"sha": "cef2fdcda2faba623477da5716db8afd0edf9c58", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=8bd0382134368d8bc017185baba9e5276693ef6a", "patch": "@@ -1032,7 +1032,7 @@ impl<'a, 'tcx> Visitor<'tcx> for GatherLocalsVisitor<'a, 'tcx> {\n \n     // Add pattern bindings.\n     fn visit_pat(&mut self, p: &'tcx hir::Pat) {\n-        if let PatKind::Binding(_, _, ident, _) = p.node {\n+        if let PatKind::Binding(_, _, ident, _) = p.kind {\n             let var_ty = self.assign(p.span, p.hir_id, None);\n \n             if !self.fcx.tcx.features().unsized_locals {\n@@ -4205,7 +4205,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 })) => {\n                     let body = hir.body(*body_id);\n                     sugg_call = body.params.iter()\n-                        .map(|param| match &param.pat.node {\n+                        .map(|param| match &param.pat.kind {\n                             hir::PatKind::Binding(_, _, ident, None)\n                             if ident.name != kw::SelfLower => ident.to_string(),\n                             _ => \"_\".to_string(),\n@@ -4223,7 +4223,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     msg = \"call this closure\";\n                     let body = hir.body(*body_id);\n                     sugg_call = body.params.iter()\n-                        .map(|param| match &param.pat.node {\n+                        .map(|param| match &param.pat.kind {\n                             hir::PatKind::Binding(_, _, ident, None)\n                             if ident.name != kw::SelfLower => ident.to_string(),\n                             _ => \"_\".to_string(),"}, {"sha": "53ee0777c7c1d81db03366c22b68556444d17b34", "filename": "src/librustc_typeck/check/pat.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs?ref=8bd0382134368d8bc017185baba9e5276693ef6a", "patch": "@@ -59,14 +59,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ) {\n         debug!(\"check_pat(pat={:?},expected={:?},def_bm={:?})\", pat, expected, def_bm);\n \n-        let path_resolution = match &pat.node {\n+        let path_resolution = match &pat.kind {\n             PatKind::Path(qpath) => Some(self.resolve_ty_and_res_ufcs(qpath, pat.hir_id, pat.span)),\n             _ => None,\n         };\n         let is_nrp = self.is_non_ref_pat(pat, path_resolution.map(|(res, ..)| res));\n         let (expected, def_bm) = self.calc_default_binding_mode(pat, expected, def_bm, is_nrp);\n \n-        let ty = match &pat.node {\n+        let ty = match &pat.kind {\n             PatKind::Wild => expected,\n             PatKind::Lit(lt) => self.check_pat_lit(pat.span, lt, expected, discrim_span),\n             PatKind::Range(begin, end, _) => {\n@@ -193,7 +193,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // ```\n             //\n             // See issue #46688.\n-            let def_bm = match pat.node {\n+            let def_bm = match pat.kind {\n                 PatKind::Ref(..) => ty::BindByValue(hir::MutImmutable),\n                 _ => def_bm,\n             };\n@@ -204,7 +204,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// Is the pattern a \"non reference pattern\"?\n     /// When the pattern is a path pattern, `opt_path_res` must be `Some(res)`.\n     fn is_non_ref_pat(&self, pat: &'tcx Pat, opt_path_res: Option<Res>) -> bool {\n-        match pat.node {\n+        match pat.kind {\n             PatKind::Struct(..) |\n             PatKind::TupleStruct(..) |\n             PatKind::Tuple(..) |\n@@ -472,7 +472,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expected: Ty<'tcx>,\n     ) {\n         let tcx = self.tcx;\n-        if let PatKind::Binding(..) = inner.node {\n+        if let PatKind::Binding(..) = inner.kind {\n             let binding_parent_id = tcx.hir().get_parent_node(pat.hir_id);\n             let binding_parent = tcx.hir().get(binding_parent_id);\n             debug!(\"inner {:?} pat {:?} parent {:?}\", inner, pat, binding_parent);\n@@ -505,7 +505,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     pub fn check_dereferencable(&self, span: Span, expected: Ty<'tcx>, inner: &Pat) -> bool {\n-        if let PatKind::Binding(..) = inner.node {\n+        if let PatKind::Binding(..) = inner.kind {\n             if let Some(mt) = self.shallow_resolve(expected).builtin_deref(true) {\n                 if let ty::Dynamic(..) = mt.ty.kind {\n                     // This is \"x = SomeTrait\" being reduced from\n@@ -617,7 +617,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                               res.descr(),\n                               hir::print::to_string(tcx.hir(), |s| s.print_qpath(qpath, false)));\n             let mut err = struct_span_err!(tcx.sess, pat.span, E0164, \"{}\", msg);\n-            match (res, &pat.node) {\n+            match (res, &pat.kind) {\n                 (Res::Def(DefKind::Fn, _), _) | (Res::Def(DefKind::Method, _), _) => {\n                     err.span_label(pat.span, \"`fn` calls are not allowed in patterns\");\n                     err.help(\"for more information, visit \\"}, {"sha": "90407780a302d8c4bc32cccfa2fab04a866928b6", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=8bd0382134368d8bc017185baba9e5276693ef6a", "patch": "@@ -1097,7 +1097,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n         ignore_err!(self.with_mc(|mc| {\n             mc.cat_pattern(discr_cmt, root_pat, |sub_cmt, sub_pat| {\n                 // `ref x` pattern\n-                if let PatKind::Binding(..) = sub_pat.node {\n+                if let PatKind::Binding(..) = sub_pat.kind {\n                     if let Some(&bm) = mc.tables.pat_binding_modes().get(sub_pat.hir_id) {\n                         if let ty::BindByReference(mutbl) = bm {\n                             self.link_region_from_node_type("}, {"sha": "de78c1cdfaba3ab27718ed78e4ebc4384ffd1ee3", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=8bd0382134368d8bc017185baba9e5276693ef6a", "patch": "@@ -270,7 +270,7 @@ impl<'cx, 'tcx> Visitor<'tcx> for WritebackCx<'cx, 'tcx> {\n     }\n \n     fn visit_pat(&mut self, p: &'tcx hir::Pat) {\n-        match p.node {\n+        match p.kind {\n             hir::PatKind::Binding(..) => {\n                 if let Some(&bm) = self.fcx.tables.borrow().pat_binding_modes().get(p.hir_id) {\n                     self.tables.pat_binding_modes_mut().insert(p.hir_id, bm);"}, {"sha": "b438d149220540b3b4fbfaa8008c8be6a3d01fd2", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=8bd0382134368d8bc017185baba9e5276693ef6a", "patch": "@@ -4182,7 +4182,7 @@ fn name_from_pat(p: &hir::Pat) -> String {\n     use rustc::hir::*;\n     debug!(\"trying to get a name from pattern: {:?}\", p);\n \n-    match p.node {\n+    match p.kind {\n         PatKind::Wild => \"_\".to_string(),\n         PatKind::Binding(_, _, ident, _) => ident.to_string(),\n         PatKind::TupleStruct(ref p, ..) | PatKind::Path(ref p) => qpath_to_string(p),"}, {"sha": "8b9bbb6816d7e2bf8a38d08baa558fc6b70f6422", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=8bd0382134368d8bc017185baba9e5276693ef6a", "patch": "@@ -511,7 +511,7 @@ pub struct Block {\n #[derive(Clone, RustcEncodable, RustcDecodable)]\n pub struct Pat {\n     pub id: NodeId,\n-    pub node: PatKind,\n+    pub kind: PatKind,\n     pub span: Span,\n }\n \n@@ -525,7 +525,7 @@ impl Pat {\n     /// Attempt reparsing the pattern as a type.\n     /// This is intended for use by diagnostics.\n     pub(super) fn to_ty(&self) -> Option<P<Ty>> {\n-        let node = match &self.node {\n+        let node = match &self.kind {\n             // In a type expression `_` is an inference variable.\n             PatKind::Wild => TyKind::Infer,\n             // An IDENT pattern with no binding mode would be valid as path to a type. E.g. `u32`.\n@@ -569,7 +569,7 @@ impl Pat {\n             return;\n         }\n \n-        match &self.node {\n+        match &self.kind {\n             PatKind::Ident(_, _, Some(p)) => p.walk(it),\n             PatKind::Struct(_, fields, _) => fields.iter().for_each(|field| field.pat.walk(it)),\n             PatKind::TupleStruct(_, s)\n@@ -591,7 +591,7 @@ impl Pat {\n \n     /// Is this a `..` pattern?\n     pub fn is_rest(&self) -> bool {\n-        match self.node {\n+        match self.kind {\n             PatKind::Rest => true,\n             _ => false,\n         }\n@@ -1821,7 +1821,7 @@ pub type ExplicitSelf = Spanned<SelfKind>;\n \n impl Param {\n     pub fn to_self(&self) -> Option<ExplicitSelf> {\n-        if let PatKind::Ident(BindingMode::ByValue(mutbl), ident, _) = self.pat.node {\n+        if let PatKind::Ident(BindingMode::ByValue(mutbl), ident, _) = self.pat.kind {\n             if ident.name == kw::SelfLower {\n                 return match self.ty.node {\n                     TyKind::ImplicitSelf => Some(respan(self.pat.span, SelfKind::Value(mutbl))),\n@@ -1839,7 +1839,7 @@ impl Param {\n     }\n \n     pub fn is_self(&self) -> bool {\n-        if let PatKind::Ident(_, ident, _) = self.pat.node {\n+        if let PatKind::Ident(_, ident, _) = self.pat.kind {\n             ident.name == kw::SelfLower\n         } else {\n             false\n@@ -1857,7 +1857,7 @@ impl Param {\n             attrs,\n             pat: P(Pat {\n                 id: DUMMY_NODE_ID,\n-                node: PatKind::Ident(BindingMode::ByValue(mutbl), eself_ident, None),\n+                kind: PatKind::Ident(BindingMode::ByValue(mutbl), eself_ident, None),\n                 span,\n             }),\n             span,"}, {"sha": "990358c674ff76eae1e678753f767296babede75", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=8bd0382134368d8bc017185baba9e5276693ef6a", "patch": "@@ -298,7 +298,7 @@ impl<'a> StripUnconfigured<'a> {\n     }\n \n     pub fn configure_pat(&mut self, pat: &mut P<ast::Pat>) {\n-        if let ast::PatKind::Struct(_path, fields, _etc) = &mut pat.node {\n+        if let ast::PatKind::Struct(_path, fields, _etc) = &mut pat.kind {\n             fields.flat_map_in_place(|field| self.configure(field));\n         }\n     }"}, {"sha": "6af6027ba9d954a9b1da8c1f21e8e4033190ae22", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=8bd0382134368d8bc017185baba9e5276693ef6a", "patch": "@@ -511,7 +511,7 @@ impl MacResult for MacEager {\n                 return Some(P(ast::Pat {\n                     id: ast::DUMMY_NODE_ID,\n                     span: e.span,\n-                    node: PatKind::Lit(e),\n+                    kind: PatKind::Lit(e),\n                 }));\n             }\n         }\n@@ -559,7 +559,7 @@ impl DummyResult {\n     pub fn raw_pat(sp: Span) -> ast::Pat {\n         ast::Pat {\n             id: ast::DUMMY_NODE_ID,\n-            node: PatKind::Wild,\n+            kind: PatKind::Wild,\n             span: sp,\n         }\n     }"}, {"sha": "ff52bd1e971c0ee89047257aaaf353c6113da148", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=8bd0382134368d8bc017185baba9e5276693ef6a", "patch": "@@ -411,8 +411,8 @@ impl<'a> ExtCtxt<'a> {\n     }\n \n \n-    pub fn pat(&self, span: Span, pat: PatKind) -> P<ast::Pat> {\n-        P(ast::Pat { id: ast::DUMMY_NODE_ID, node: pat, span })\n+    pub fn pat(&self, span: Span, kind: PatKind) -> P<ast::Pat> {\n+        P(ast::Pat { id: ast::DUMMY_NODE_ID, kind, span })\n     }\n     pub fn pat_wild(&self, span: Span) -> P<ast::Pat> {\n         self.pat(span, PatKind::Wild)"}, {"sha": "c03dd832cb689943c531f2e5e946f1a7b1ecf64d", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=8bd0382134368d8bc017185baba9e5276693ef6a", "patch": "@@ -1172,13 +1172,13 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n \n     fn visit_pat(&mut self, pat: &mut P<ast::Pat>) {\n         self.cfg.configure_pat(pat);\n-        match pat.node {\n+        match pat.kind {\n             PatKind::Mac(_) => {}\n             _ => return noop_visit_pat(pat, self),\n         }\n \n         visit_clobber(pat, |mut pat| {\n-            match mem::replace(&mut pat.node, PatKind::Wild) {\n+            match mem::replace(&mut pat.kind, PatKind::Wild) {\n                 PatKind::Mac(mac) =>\n                     self.collect_bang(mac, pat.span, AstFragmentKind::Pat).make_pat(),\n                 _ => unreachable!(),"}, {"sha": "c2f77b96ad80b4e33e356920b1ca0d9073020390", "filename": "src/libsyntax/ext/placeholders.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fplaceholders.rs?ref=8bd0382134368d8bc017185baba9e5276693ef6a", "patch": "@@ -39,7 +39,7 @@ pub fn placeholder(kind: AstFragmentKind, id: ast::NodeId) -> AstFragment {\n     });\n     let pat = P(ast::Pat {\n         id,\n-        node: ast::PatKind::Mac(mac_placeholder()),\n+        kind: ast::PatKind::Mac(mac_placeholder()),\n         span,\n     });\n \n@@ -68,7 +68,7 @@ pub fn placeholder(kind: AstFragmentKind, id: ast::NodeId) -> AstFragment {\n                 node: ast::ForeignItemKind::Macro(mac_placeholder()),\n             }]),\n         AstFragmentKind::Pat => AstFragment::Pat(P(ast::Pat {\n-            id, span, node: ast::PatKind::Mac(mac_placeholder()),\n+            id, span, kind: ast::PatKind::Mac(mac_placeholder()),\n         })),\n         AstFragmentKind::Ty => AstFragment::Ty(P(ast::Ty {\n             id, span, node: ast::TyKind::Mac(mac_placeholder()),\n@@ -311,7 +311,7 @@ impl<'a, 'b> MutVisitor for PlaceholderExpander<'a, 'b> {\n     }\n \n     fn visit_pat(&mut self, pat: &mut P<ast::Pat>) {\n-        match pat.node {\n+        match pat.kind {\n             ast::PatKind::Mac(_) => *pat = self.remove(pat.id).make_pat(),\n             _ => noop_visit_pat(pat, self),\n         }"}, {"sha": "c9a31dc68bff7dfa9cc6fd9ed1eeaad68d2560d4", "filename": "src/libsyntax/feature_gate/check.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Flibsyntax%2Ffeature_gate%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Flibsyntax%2Ffeature_gate%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate%2Fcheck.rs?ref=8bd0382134368d8bc017185baba9e5276693ef6a", "patch": "@@ -487,11 +487,11 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n     }\n \n     fn visit_pat(&mut self, pattern: &'a ast::Pat) {\n-        match &pattern.node {\n+        match &pattern.kind {\n             PatKind::Slice(pats) => {\n                 for pat in &*pats {\n                     let span = pat.span;\n-                    let inner_pat = match &pat.node {\n+                    let inner_pat = match &pat.kind {\n                         PatKind::Ident(.., Some(pat)) => pat,\n                         _ => pat,\n                     };"}, {"sha": "b8c5b7497de17604e95c6a891c49fc778c58560d", "filename": "src/libsyntax/mut_visit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Flibsyntax%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Flibsyntax%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fmut_visit.rs?ref=8bd0382134368d8bc017185baba9e5276693ef6a", "patch": "@@ -1055,9 +1055,9 @@ pub fn noop_flat_map_foreign_item<T: MutVisitor>(mut item: ForeignItem, visitor:\n }\n \n pub fn noop_visit_pat<T: MutVisitor>(pat: &mut P<Pat>, vis: &mut T) {\n-    let Pat { id, node, span } = pat.deref_mut();\n+    let Pat { id, kind, span } = pat.deref_mut();\n     vis.visit_id(id);\n-    match node {\n+    match kind {\n         PatKind::Wild | PatKind::Rest => {}\n         PatKind::Ident(_binding_mode, ident, sub) => {\n             vis.visit_ident(ident);"}, {"sha": "ecc1cdd8bca00eef08ff8ad6bca13bc18734cc32", "filename": "src/libsyntax/parse/diagnostics.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs?ref=8bd0382134368d8bc017185baba9e5276693ef6a", "patch": "@@ -21,7 +21,7 @@ use std::mem;\n crate fn dummy_arg(ident: Ident) -> Param {\n     let pat = P(Pat {\n         id: ast::DUMMY_NODE_ID,\n-        node: PatKind::Ident(BindingMode::ByValue(Mutability::Immutable), ident, None),\n+        kind: PatKind::Ident(BindingMode::ByValue(Mutability::Immutable), ident, None),\n         span: ident.span,\n     });\n     let ty = Ty {\n@@ -148,7 +148,7 @@ impl RecoverQPath for Pat {\n     fn recovered(qself: Option<QSelf>, path: ast::Path) -> Self {\n         Self {\n             span: path.span,\n-            node: PatKind::Path(qself, path),\n+            kind: PatKind::Path(qself, path),\n             id: ast::DUMMY_NODE_ID,\n         }\n     }\n@@ -978,7 +978,7 @@ impl<'a> Parser<'a> {\n                     .emit();\n \n                 // Unwrap `(pat)` into `pat` to avoid the `unused_parens` lint.\n-                pat.and_then(|pat| match pat.node {\n+                pat.and_then(|pat| match pat.kind {\n                     PatKind::Paren(pat) => pat,\n                     _ => P(pat),\n                 })\n@@ -1237,7 +1237,7 @@ impl<'a> Parser<'a> {\n                 Applicability::HasPlaceholders,\n             );\n             return Some(ident);\n-        } else if let PatKind::Ident(_, ident, _) = pat.node {\n+        } else if let PatKind::Ident(_, ident, _) = pat.kind {\n             if require_name && (\n                 is_trait_item ||\n                 self.token == token::Comma ||\n@@ -1283,7 +1283,7 @@ impl<'a> Parser<'a> {\n \n         // Pretend the pattern is `_`, to avoid duplicate errors from AST validation.\n         let pat = P(Pat {\n-            node: PatKind::Wild,\n+            kind: PatKind::Wild,\n             span: pat.span,\n             id: ast::DUMMY_NODE_ID\n         });\n@@ -1360,15 +1360,15 @@ impl<'a> Parser<'a> {\n         let mut seen_inputs = FxHashSet::default();\n         for input in fn_inputs.iter_mut() {\n             let opt_ident = if let (PatKind::Ident(_, ident, _), TyKind::Err) = (\n-                &input.pat.node, &input.ty.node,\n+                &input.pat.kind, &input.ty.node,\n             ) {\n                 Some(*ident)\n             } else {\n                 None\n             };\n             if let Some(ident) = opt_ident {\n                 if seen_inputs.contains(&ident) {\n-                    input.pat.node = PatKind::Wild;\n+                    input.pat.kind = PatKind::Wild;\n                 }\n                 seen_inputs.insert(ident);\n             }"}, {"sha": "de72f1c4d4906f66749bef670870c0478b1afa35", "filename": "src/libsyntax/parse/parser/pat.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Flibsyntax%2Fparse%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Flibsyntax%2Fparse%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fpat.rs?ref=8bd0382134368d8bc017185baba9e5276693ef6a", "patch": "@@ -66,7 +66,7 @@ impl<'a> Parser<'a> {\n         self.recover_leading_vert(\"not allowed in a parameter pattern\");\n         let pat = self.parse_pat_with_or(PARAM_EXPECTED, GateOr::No, RecoverComma::No)?;\n \n-        if let PatKind::Or(..) = &pat.node {\n+        if let PatKind::Or(..) = &pat.kind {\n             self.ban_illegal_fn_param_or_pat(&pat);\n         }\n \n@@ -324,7 +324,7 @@ impl<'a> Parser<'a> {\n \n     /// Ban a range pattern if it has an ambiguous interpretation.\n     fn ban_pat_range_if_ambiguous(&self, pat: &Pat) -> PResult<'a, ()> {\n-        match pat.node {\n+        match pat.kind {\n             PatKind::Range(\n                 .., Spanned { node: RangeEnd::Included(RangeSyntax::DotDotDot), .. }\n             ) => return Ok(()),\n@@ -399,12 +399,12 @@ impl<'a> Parser<'a> {\n \n         // Unwrap; If we don't have `mut $ident`, error.\n         let pat = pat.into_inner();\n-        match &pat.node {\n+        match &pat.kind {\n             PatKind::Ident(..) => {}\n             _ => self.ban_mut_general_pat(mut_span, &pat, changed_any_binding),\n         }\n \n-        Ok(pat.node)\n+        Ok(pat.kind)\n     }\n \n     /// Recover on `mut ref? ident @ pat` and suggest\n@@ -430,7 +430,7 @@ impl<'a> Parser<'a> {\n         impl MutVisitor for AddMut {\n             fn visit_pat(&mut self, pat: &mut P<Pat>) {\n                 if let PatKind::Ident(BindingMode::ByValue(ref mut m @ Mutability::Immutable), ..)\n-                    = pat.node\n+                    = pat.kind\n                 {\n                     *m = Mutability::Mutable;\n                     self.0 = true;\n@@ -890,7 +890,7 @@ impl<'a> Parser<'a> {\n         self.mk_pat(span, PatKind::Ident(bm, ident, None))\n     }\n \n-    fn mk_pat(&self, span: Span, node: PatKind) -> P<Pat> {\n-        P(Pat { node, span, id: ast::DUMMY_NODE_ID })\n+    fn mk_pat(&self, span: Span, kind: PatKind) -> P<Pat> {\n+        P(Pat { kind, span, id: ast::DUMMY_NODE_ID })\n     }\n }"}, {"sha": "7b7148588501339386d566ca0d82833a4ca12243", "filename": "src/libsyntax/parse/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Flibsyntax%2Fparse%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Flibsyntax%2Fparse%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftests.rs?ref=8bd0382134368d8bc017185baba9e5276693ef6a", "patch": "@@ -171,7 +171,7 @@ fn get_spans_of_pat_idents(src: &str) -> Vec<Span> {\n     }\n     impl<'a> crate::visit::Visitor<'a> for PatIdentVisitor {\n         fn visit_pat(&mut self, p: &'a ast::Pat) {\n-            match p.node {\n+            match p.kind {\n                 PatKind::Ident(_ , ref ident, _) => {\n                     self.spans.push(ident.span.clone());\n                 }"}, {"sha": "e5060fdd39de3ac9d934f029311c205909bc9ffb", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=8bd0382134368d8bc017185baba9e5276693ef6a", "patch": "@@ -2353,7 +2353,7 @@ impl<'a> State<'a> {\n         self.ann.pre(self, AnnNode::Pat(pat));\n         /* Pat isn't normalized, but the beauty of it\n          is that it doesn't matter */\n-        match pat.node {\n+        match pat.kind {\n             PatKind::Wild => self.s.word(\"_\"),\n             PatKind::Ident(binding_mode, ident, ref sub) => {\n                 match binding_mode {\n@@ -2766,7 +2766,7 @@ impl<'a> State<'a> {\n                 if let Some(eself) = input.to_self() {\n                     self.print_explicit_self(&eself);\n                 } else {\n-                    let invalid = if let PatKind::Ident(_, ident, _) = input.pat.node {\n+                    let invalid = if let PatKind::Ident(_, ident, _) = input.pat.kind {\n                         ident.name == kw::Invalid\n                     } else {\n                         false"}, {"sha": "5b790837f0aa1d88766b5d817553d7392f1d9fc9", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=8bd0382134368d8bc017185baba9e5276693ef6a", "patch": "@@ -443,7 +443,7 @@ pub fn walk_assoc_ty_constraint<'a, V: Visitor<'a>>(visitor: &mut V,\n }\n \n pub fn walk_pat<'a, V: Visitor<'a>>(visitor: &mut V, pattern: &'a Pat) {\n-    match pattern.node {\n+    match pattern.kind {\n         PatKind::TupleStruct(ref path, ref elems) => {\n             visitor.visit_path(path, pattern.id);\n             walk_list!(visitor, visit_pat, elems);"}, {"sha": "745e3695ec1c452246090dc4466fffd829cd767f", "filename": "src/test/ui-fulldeps/pprust-expr-roundtrip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Ftest%2Fui-fulldeps%2Fpprust-expr-roundtrip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bd0382134368d8bc017185baba9e5276693ef6a/src%2Ftest%2Fui-fulldeps%2Fpprust-expr-roundtrip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fpprust-expr-roundtrip.rs?ref=8bd0382134368d8bc017185baba9e5276693ef6a", "patch": "@@ -154,7 +154,7 @@ fn iter_exprs(depth: usize, f: &mut dyn FnMut(P<Expr>)) {\n             19 => {\n                 let pat = P(Pat {\n                     id: DUMMY_NODE_ID,\n-                    node: PatKind::Wild,\n+                    kind: PatKind::Wild,\n                     span: DUMMY_SP,\n                 });\n                 iter_exprs(depth - 1, &mut |e| g(ExprKind::Let(pat.clone(), e)))"}]}