{"sha": "6f19484c93b1d3bcbef8a271443742a3db3e8fae", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZmMTk0ODRjOTNiMWQzYmNiZWY4YTI3MTQ0Mzc0MmEzZGIzZThmYWU=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2021-05-20T18:40:02Z"}, "committer": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2021-05-20T18:40:02Z"}, "message": "Support `#[register_attr]` and `#[register_tool]`", "tree": {"sha": "024719fdb69de56eadad477026a2df230cf66a1f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/024719fdb69de56eadad477026a2df230cf66a1f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6f19484c93b1d3bcbef8a271443742a3db3e8fae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6f19484c93b1d3bcbef8a271443742a3db3e8fae", "html_url": "https://github.com/rust-lang/rust/commit/6f19484c93b1d3bcbef8a271443742a3db3e8fae", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6f19484c93b1d3bcbef8a271443742a3db3e8fae/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "df824c2f81db07782a6f64c31e5981ba1593256e", "url": "https://api.github.com/repos/rust-lang/rust/commits/df824c2f81db07782a6f64c31e5981ba1593256e", "html_url": "https://github.com/rust-lang/rust/commit/df824c2f81db07782a6f64c31e5981ba1593256e"}], "stats": {"total": 126, "additions": 94, "deletions": 32}, "files": [{"sha": "e76d039b8a51bfe5a7742541580eee53a2c0e92a", "filename": "crates/hir_def/src/nameres/collector.rs", "status": "modified", "additions": 75, "deletions": 32, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/6f19484c93b1d3bcbef8a271443742a3db3e8fae/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f19484c93b1d3bcbef8a271443742a3db3e8fae/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=6f19484c93b1d3bcbef8a271443742a3db3e8fae", "patch": "@@ -20,7 +20,7 @@ use rustc_hash::{FxHashMap, FxHashSet};\n use syntax::ast;\n \n use crate::{\n-    attr::{Attr, AttrId, Attrs},\n+    attr::{Attr, AttrId, AttrInput, Attrs},\n     builtin_attr,\n     db::DefDatabase,\n     derive_macro_as_call_id,\n@@ -102,6 +102,8 @@ pub(super) fn collect_defs(\n         from_glob_import: Default::default(),\n         skip_attrs: Default::default(),\n         derive_helpers_in_scope: Default::default(),\n+        registered_attrs: Default::default(),\n+        registered_tools: Default::default(),\n     };\n     match block {\n         Some(block) => {\n@@ -257,6 +259,10 @@ struct DefCollector<'a> {\n     /// Tracks which custom derives are in scope for an item, to allow resolution of derive helper\n     /// attributes.\n     derive_helpers_in_scope: FxHashMap<AstId<ast::Item>, Vec<Name>>,\n+    /// Custom attributes registered with `#![register_attr]`.\n+    registered_attrs: Vec<String>,\n+    /// Custom tool modules registered with `#![register_tool]`.\n+    registered_tools: Vec<String>,\n }\n \n impl DefCollector<'_> {\n@@ -265,11 +271,39 @@ impl DefCollector<'_> {\n         let item_tree = self.db.file_item_tree(file_id.into());\n         let module_id = self.def_map.root;\n         self.def_map.modules[module_id].origin = ModuleOrigin::CrateRoot { definition: file_id };\n-        if item_tree\n-            .top_level_attrs(self.db, self.def_map.krate)\n-            .cfg()\n-            .map_or(true, |cfg| self.cfg_options.check(&cfg) != Some(false))\n-        {\n+\n+        let attrs = item_tree.top_level_attrs(self.db, self.def_map.krate);\n+        if attrs.cfg().map_or(true, |cfg| self.cfg_options.check(&cfg) != Some(false)) {\n+            // Process other crate-level attributes.\n+            for attr in &*attrs {\n+                let attr_name = match attr.path.as_ident() {\n+                    Some(name) => name,\n+                    None => continue,\n+                };\n+\n+                let registered_name = if *attr_name == hir_expand::name![register_attr]\n+                    || *attr_name == hir_expand::name![register_tool]\n+                {\n+                    match &attr.input {\n+                        Some(AttrInput::TokenTree(subtree)) => match &*subtree.token_trees {\n+                            [tt::TokenTree::Leaf(tt::Leaf::Ident(name))] => name.as_name(),\n+                            _ => continue,\n+                        },\n+                        _ => continue,\n+                    }\n+                } else {\n+                    continue;\n+                };\n+\n+                if *attr_name == hir_expand::name![register_attr] {\n+                    self.registered_attrs.push(registered_name.to_string());\n+                    cov_mark::hit!(register_attr);\n+                } else {\n+                    self.registered_tools.push(registered_name.to_string());\n+                    cov_mark::hit!(register_tool);\n+                }\n+            }\n+\n             ModCollector {\n                 def_collector: &mut *self,\n                 macro_depth: 0,\n@@ -1479,30 +1513,6 @@ impl ModCollector<'_, '_> {\n     /// If `ignore_up_to` is `Some`, attributes precending and including that attribute will be\n     /// assumed to be resolved already.\n     fn resolve_attributes(&mut self, attrs: &Attrs, mod_item: ModItem) -> Result<(), ()> {\n-        fn is_builtin_attr(path: &ModPath) -> bool {\n-            if path.kind == PathKind::Plain {\n-                if let Some(tool_module) = path.segments().first() {\n-                    let tool_module = tool_module.to_string();\n-                    if builtin_attr::TOOL_MODULES.iter().any(|m| tool_module == *m) {\n-                        return true;\n-                    }\n-                }\n-\n-                if let Some(name) = path.as_ident() {\n-                    let name = name.to_string();\n-                    if builtin_attr::INERT_ATTRIBUTES\n-                        .iter()\n-                        .chain(builtin_attr::EXTRA_ATTRIBUTES)\n-                        .any(|attr| name == *attr)\n-                    {\n-                        return true;\n-                    }\n-                }\n-            }\n-\n-            false\n-        }\n-\n         let mut ignore_up_to =\n             self.def_collector.skip_attrs.get(&InFile::new(self.file_id, mod_item)).copied();\n         for attr in attrs.iter().skip_while(|attr| match ignore_up_to {\n@@ -1515,7 +1525,7 @@ impl ModCollector<'_, '_> {\n         }) {\n             if attr.path.as_ident() == Some(&hir_expand::name![derive]) {\n                 self.collect_derive(attr, mod_item);\n-            } else if is_builtin_attr(&attr.path) {\n+            } else if self.is_builtin_or_registered_attr(&attr.path) {\n                 continue;\n             } else {\n                 log::debug!(\"non-builtin attribute {}\", attr.path);\n@@ -1538,6 +1548,37 @@ impl ModCollector<'_, '_> {\n         Ok(())\n     }\n \n+    fn is_builtin_or_registered_attr(&self, path: &ModPath) -> bool {\n+        if path.kind == PathKind::Plain {\n+            if let Some(tool_module) = path.segments().first() {\n+                let tool_module = tool_module.to_string();\n+                if builtin_attr::TOOL_MODULES\n+                    .iter()\n+                    .copied()\n+                    .chain(self.def_collector.registered_tools.iter().map(|s| &**s))\n+                    .any(|m| tool_module == *m)\n+                {\n+                    return true;\n+                }\n+            }\n+\n+            if let Some(name) = path.as_ident() {\n+                let name = name.to_string();\n+                if builtin_attr::INERT_ATTRIBUTES\n+                    .iter()\n+                    .chain(builtin_attr::EXTRA_ATTRIBUTES)\n+                    .copied()\n+                    .chain(self.def_collector.registered_attrs.iter().map(|s| &**s))\n+                    .any(|attr| name == *attr)\n+                {\n+                    return true;\n+                }\n+            }\n+        }\n+\n+        false\n+    }\n+\n     fn collect_derive(&mut self, attr: &Attr, mod_item: ModItem) {\n         let ast_id: FileAstId<ast::Item> = match mod_item {\n             ModItem::Struct(it) => self.item_tree[it].ast_id.upcast(),\n@@ -1780,7 +1821,9 @@ mod tests {\n             exports_proc_macros: false,\n             from_glob_import: Default::default(),\n             skip_attrs: Default::default(),\n-            derive_helpers_in_scope: FxHashMap::default(),\n+            derive_helpers_in_scope: Default::default(),\n+            registered_attrs: Default::default(),\n+            registered_tools: Default::default(),\n         };\n         collector.seed_with_top_level();\n         collector.collect();"}, {"sha": "75147d973a2dc77db5171917ada8a97dc7ad248e", "filename": "crates/hir_def/src/nameres/tests/diagnostics.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6f19484c93b1d3bcbef8a271443742a3db3e8fae/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f19484c93b1d3bcbef8a271443742a3db3e8fae/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fdiagnostics.rs?ref=6f19484c93b1d3bcbef8a271443742a3db3e8fae", "patch": "@@ -237,3 +237,20 @@ fn good_out_dir_diagnostic() {\n         \"#,\n     );\n }\n+\n+#[test]\n+fn register_attr_and_tool() {\n+    cov_mark::check!(register_attr);\n+    cov_mark::check!(register_tool);\n+    check_no_diagnostics(\n+        r#\"\n+#![register_tool(tool)]\n+#![register_attr(attr)]\n+\n+#[tool::path]\n+#[attr]\n+struct S;\n+        \"#,\n+    );\n+    // NB: we don't currently emit diagnostics here\n+}"}, {"sha": "ef67ea2e99b5d8dd835ea25a355459e2c929bdf2", "filename": "crates/hir_expand/src/name.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6f19484c93b1d3bcbef8a271443742a3db3e8fae/crates%2Fhir_expand%2Fsrc%2Fname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f19484c93b1d3bcbef8a271443742a3db3e8fae/crates%2Fhir_expand%2Fsrc%2Fname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fname.rs?ref=6f19484c93b1d3bcbef8a271443742a3db3e8fae", "patch": "@@ -164,6 +164,8 @@ pub mod known {\n         doc,\n         cfg,\n         cfg_attr,\n+        register_attr,\n+        register_tool,\n         // Components of known path (value or mod name)\n         std,\n         core,"}]}