{"sha": "fdd49b97133a77ff652017d24b72ced37d4a822d", "node_id": "C_kwDOAAsO6NoAKGZkZDQ5Yjk3MTMzYTc3ZmY2NTIwMTdkMjRiNzJjZWQzN2Q0YTgyMmQ", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-11-17T20:11:21Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-11-17T20:11:21Z"}, "message": "Merge #10789\n\n10789: internal: Check for derive attributes by item path, not `derive` identifier r=Veykril a=Veykril\n\nPrior we only checked if an attribute is the exact `derive` identifier and nothing else to collect derive attributes. That means when we encounter the following:\r\n```rs\r\n#[::core::macros::builtin::derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\r\npub struct ModPath {\r\n    pub kind: PathKind,\r\n    segments: Vec<Name>,\r\n}\r\n```\r\nWe won't actually expand the derive attributes, but instead we just expand the `derive` attribute with our dummy identity expander.\r\n\r\nThe changes here make it so we actually lookup the attribute path, check if it is the derive attribute and then collect the derives.\r\n\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "31d7f6f05c2f0333a97674288f8208f92dd6e591", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/31d7f6f05c2f0333a97674288f8208f92dd6e591"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fdd49b97133a77ff652017d24b72ced37d4a822d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhlWHpCRBK7hj4Ov3rIwAAttAIAFro+ARlPujrfIn5J961xPi9\nYDsKMhBTerS7bJKhFjkf+1hGCw8mVRfYtCvhvKVG0icZvUUv4W1ecgHBq8S7cAKo\nmGAL2fqXqlKA8tmV8hfW+23BANXLquXR+qr+HDCmlYJWUk0B9XSnhIgKVW4xcL02\nchJq5IXeDin9urqHgVO9CGwG31+VBI7pOgogWOsKV1D612XNd63rqmVbytgeaoSe\noRqD4g2RcQc4WbFANi2Nxy/FDB0VvKPGDlYbrSiPLzdk0vYpl1oyaedJfEvAML04\nC/VvJLZCrBelCEg3U+Y4BEvWfdhLc4syjLS8T/f881b1i/WDACD7fUxyrJMjDm0=\n=JZN6\n-----END PGP SIGNATURE-----\n", "payload": "tree 31d7f6f05c2f0333a97674288f8208f92dd6e591\nparent 32f425d801ad46c888a3a3639c5e2edbff4f3811\nparent f72512f1c61a915402979ffe83dd2ac09970ab27\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1637179881 +0000\ncommitter GitHub <noreply@github.com> 1637179881 +0000\n\nMerge #10789\n\n10789: internal: Check for derive attributes by item path, not `derive` identifier r=Veykril a=Veykril\n\nPrior we only checked if an attribute is the exact `derive` identifier and nothing else to collect derive attributes. That means when we encounter the following:\r\n```rs\r\n#[::core::macros::builtin::derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\r\npub struct ModPath {\r\n    pub kind: PathKind,\r\n    segments: Vec<Name>,\r\n}\r\n```\r\nWe won't actually expand the derive attributes, but instead we just expand the `derive` attribute with our dummy identity expander.\r\n\r\nThe changes here make it so we actually lookup the attribute path, check if it is the derive attribute and then collect the derives.\r\n\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fdd49b97133a77ff652017d24b72ced37d4a822d", "html_url": "https://github.com/rust-lang/rust/commit/fdd49b97133a77ff652017d24b72ced37d4a822d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fdd49b97133a77ff652017d24b72ced37d4a822d/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "32f425d801ad46c888a3a3639c5e2edbff4f3811", "url": "https://api.github.com/repos/rust-lang/rust/commits/32f425d801ad46c888a3a3639c5e2edbff4f3811", "html_url": "https://github.com/rust-lang/rust/commit/32f425d801ad46c888a3a3639c5e2edbff4f3811"}, {"sha": "f72512f1c61a915402979ffe83dd2ac09970ab27", "url": "https://api.github.com/repos/rust-lang/rust/commits/f72512f1c61a915402979ffe83dd2ac09970ab27", "html_url": "https://github.com/rust-lang/rust/commit/f72512f1c61a915402979ffe83dd2ac09970ab27"}], "stats": {"total": 457, "additions": 188, "deletions": 269}, "files": [{"sha": "fd45eccf5aaec925d4c0eb65f1954ffb1011012f", "filename": "crates/hir_def/src/attr.rs", "status": "modified", "additions": 27, "deletions": 33, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/fdd49b97133a77ff652017d24b72ced37d4a822d/crates%2Fhir_def%2Fsrc%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdd49b97133a77ff652017d24b72ced37d4a822d/crates%2Fhir_def%2Fsrc%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fattr.rs?ref=fdd49b97133a77ff652017d24b72ced37d4a822d", "patch": "@@ -8,7 +8,7 @@ use either::Either;\n use hir_expand::{hygiene::Hygiene, name::AsName, AstId, InFile};\n use itertools::Itertools;\n use la_arena::ArenaMap;\n-use mbe::{syntax_node_to_token_tree, DelimiterKind};\n+use mbe::{syntax_node_to_token_tree, DelimiterKind, Punct};\n use smallvec::{smallvec, SmallVec};\n use syntax::{\n     ast::{self, AstNode, HasAttrs, IsString},\n@@ -722,41 +722,35 @@ impl Attr {\n     /// Parses this attribute as a `#[derive]`, returns an iterator that yields all contained paths\n     /// to derive macros.\n     ///\n-    /// Returns `None` when the attribute is not a well-formed `#[derive]` attribute.\n+    /// Returns `None` when the attribute does not have a well-formed `#[derive]` attribute input.\n     pub(crate) fn parse_derive(&self) -> Option<impl Iterator<Item = ModPath>> {\n-        if self.path.as_ident() != Some(&hir_expand::name![derive]) {\n-            return None;\n-        }\n-\n-        match self.input.as_deref() {\n-            Some(AttrInput::TokenTree(args, _)) => {\n-                let mut counter = 0;\n-                let paths = args\n-                    .token_trees\n-                    .iter()\n-                    .group_by(move |tt| {\n-                        match tt {\n-                            tt::TokenTree::Leaf(tt::Leaf::Punct(p)) if p.char == ',' => {\n-                                counter += 1;\n-                            }\n-                            _ => {}\n-                        }\n-                        counter\n-                    })\n-                    .into_iter()\n-                    .map(|(_, tts)| {\n-                        let segments = tts.filter_map(|tt| match tt {\n-                            tt::TokenTree::Leaf(tt::Leaf::Ident(id)) => Some(id.as_name()),\n-                            _ => None,\n-                        });\n-                        ModPath::from_segments(PathKind::Plain, segments)\n-                    })\n-                    .collect::<Vec<_>>();\n-\n-                Some(paths.into_iter())\n+        if let Some(AttrInput::TokenTree(args, _)) = self.input.as_deref() {\n+            if args.delimiter_kind() != Some(DelimiterKind::Parenthesis) {\n+                return None;\n             }\n-            _ => None,\n+            let mut counter = 0;\n+            let paths = args\n+                .token_trees\n+                .iter()\n+                .group_by(move |tt| {\n+                    if let tt::TokenTree::Leaf(tt::Leaf::Punct(Punct { char: ',', .. })) = tt {\n+                        counter += 1;\n+                    }\n+                    counter\n+                })\n+                .into_iter()\n+                .map(|(_, tts)| {\n+                    let segments = tts.filter_map(|tt| match tt {\n+                        tt::TokenTree::Leaf(tt::Leaf::Ident(id)) => Some(id.as_name()),\n+                        _ => None,\n+                    });\n+                    ModPath::from_segments(PathKind::Plain, segments)\n+                })\n+                .collect::<Vec<_>>();\n+\n+            return Some(paths.into_iter());\n         }\n+        None\n     }\n \n     pub fn string_value(&self) -> Option<&SmolStr> {"}, {"sha": "b68ede40039138f02ea71e51ecfb18dd0415fbcd", "filename": "crates/hir_def/src/lib.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fdd49b97133a77ff652017d24b72ced37d4a822d/crates%2Fhir_def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdd49b97133a77ff652017d24b72ced37d4a822d/crates%2Fhir_def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Flib.rs?ref=fdd49b97133a77ff652017d24b72ced37d4a822d", "patch": "@@ -776,13 +776,10 @@ fn attr_macro_as_call_id(\n     macro_attr: &Attr,\n     db: &dyn db::DefDatabase,\n     krate: CrateId,\n-    resolver: impl Fn(path::ModPath) -> Option<MacroDefId>,\n+    def: Option<MacroDefId>,\n ) -> Result<MacroCallId, UnresolvedMacro> {\n     let attr_path = &item_attr.path;\n-\n-    let def = resolver(attr_path.clone())\n-        .filter(MacroDefId::is_attribute)\n-        .ok_or_else(|| UnresolvedMacro { path: attr_path.clone() })?;\n+    let def = def.ok_or_else(|| UnresolvedMacro { path: attr_path.clone() })?;\n     let last_segment =\n         attr_path.segments().last().ok_or_else(|| UnresolvedMacro { path: attr_path.clone() })?;\n     let mut arg = match macro_attr.input.as_deref() {"}, {"sha": "8ee33101e4d010a6dc6938c859cbdd24484e3313", "filename": "crates/hir_def/src/macro_expansion_tests/builtin_derive_macro.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fdd49b97133a77ff652017d24b72ced37d4a822d/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests%2Fbuiltin_derive_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdd49b97133a77ff652017d24b72ced37d4a822d/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests%2Fbuiltin_derive_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests%2Fbuiltin_derive_macro.rs?ref=fdd49b97133a77ff652017d24b72ced37d4a822d", "patch": "@@ -26,12 +26,16 @@ fn test_copy_expand_in_core() {\n     check(\n         r#\"\n #[rustc_builtin_macro]\n+macro derive {}\n+#[rustc_builtin_macro]\n macro Copy {}\n #[derive(Copy)]\n struct Foo;\n \"#,\n         expect![[r##\"\n #[rustc_builtin_macro]\n+macro derive {}\n+#[rustc_builtin_macro]\n macro Copy {}\n #[derive(Copy)]\n struct Foo;"}, {"sha": "901872eddab904b4e86c07323ec621cb42b43cb1", "filename": "crates/hir_def/src/macro_expansion_tests/proc_macros.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fdd49b97133a77ff652017d24b72ced37d4a822d/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests%2Fproc_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdd49b97133a77ff652017d24b72ced37d4a822d/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests%2Fproc_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests%2Fproc_macros.rs?ref=fdd49b97133a77ff652017d24b72ced37d4a822d", "patch": "@@ -31,6 +31,7 @@ fn derive_censoring() {\n     check(\n         r#\"\n //- proc_macros: derive_identity\n+//- minicore:derive\n #[attr1]\n #[derive(Foo)]\n #[derive(proc_macros::DeriveIdentity)]"}, {"sha": "bafba0672fceab9db07481acde1d4ec47689189e", "filename": "crates/hir_def/src/nameres/collector.rs", "status": "modified", "additions": 101, "deletions": 118, "changes": 219, "blob_url": "https://github.com/rust-lang/rust/blob/fdd49b97133a77ff652017d24b72ced37d4a822d/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdd49b97133a77ff652017d24b72ced37d4a822d/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=fdd49b97133a77ff652017d24b72ced37d4a822d", "patch": "@@ -9,7 +9,7 @@ use base_db::{CrateId, Edition, FileId, ProcMacroId};\n use cfg::{CfgExpr, CfgOptions};\n use hir_expand::{\n     ast_id_map::FileAstId,\n-    builtin_attr_macro::{find_builtin_attr, is_builtin_test_or_bench_attr},\n+    builtin_attr_macro::find_builtin_attr,\n     builtin_derive_macro::find_builtin_derive,\n     builtin_fn_macro::find_builtin_macro,\n     name::{name, AsName, Name},\n@@ -781,7 +781,7 @@ impl DefCollector<'_> {\n     }\n \n     fn resolve_extern_crate(&self, name: &Name) -> PerNs {\n-        if name == &name!(self) {\n+        if *name == name!(self) {\n             cov_mark::hit!(extern_crate_self_as);\n             let root = match self.def_map.block {\n                 Some(_) => {\n@@ -1054,14 +1054,15 @@ impl DefCollector<'_> {\n \n             match &directive.kind {\n                 MacroDirectiveKind::FnLike { ast_id, expand_to } => {\n-                    match macro_call_as_call_id(\n+                    let call_id = macro_call_as_call_id(\n                         ast_id,\n                         *expand_to,\n                         self.db,\n                         self.def_map.krate,\n                         &resolver,\n                         &mut |_err| (),\n-                    ) {\n+                    );\n+                    match call_id {\n                         Ok(Ok(call_id)) => {\n                             resolved.push((directive.module_id, call_id, directive.depth));\n                             res = ReachedFixedPoint::No;\n@@ -1071,13 +1072,14 @@ impl DefCollector<'_> {\n                     }\n                 }\n                 MacroDirectiveKind::Derive { ast_id, derive_attr } => {\n-                    match derive_macro_as_call_id(\n+                    let call_id = derive_macro_as_call_id(\n                         ast_id,\n                         *derive_attr,\n                         self.db,\n                         self.def_map.krate,\n                         &resolver,\n-                    ) {\n+                    );\n+                    match call_id {\n                         Ok(call_id) => {\n                             self.def_map.modules[directive.module_id].scope.add_derive_macro_invoc(\n                                 ast_id.ast_id,\n@@ -1089,73 +1091,103 @@ impl DefCollector<'_> {\n                             res = ReachedFixedPoint::No;\n                             return false;\n                         }\n-                        Err(UnresolvedMacro { .. }) => (),\n+                        Err(UnresolvedMacro { .. }) => {}\n                     }\n                 }\n                 MacroDirectiveKind::Attr { ast_id, mod_item, attr } => {\n+                    let file_id = ast_id.ast_id.file_id;\n+                    let mut recollect_without = |collector: &mut Self, item_tree| {\n+                        // Remove the original directive since we resolved it.\n+                        let mod_dir = collector.mod_dirs[&directive.module_id].clone();\n+                        collector.skip_attrs.insert(InFile::new(file_id, *mod_item), attr.id);\n+                        ModCollector {\n+                            def_collector: collector,\n+                            macro_depth: directive.depth,\n+                            module_id: directive.module_id,\n+                            tree_id: TreeId::new(file_id, None),\n+                            item_tree,\n+                            mod_dir,\n+                        }\n+                        .collect(&[*mod_item]);\n+                        res = ReachedFixedPoint::No;\n+                        false\n+                    };\n+\n                     if let Some(ident) = ast_id.path.as_ident() {\n                         if let Some(helpers) = self.derive_helpers_in_scope.get(&ast_id.ast_id) {\n                             if helpers.contains(ident) {\n                                 cov_mark::hit!(resolved_derive_helper);\n-\n                                 // Resolved to derive helper. Collect the item's attributes again,\n                                 // starting after the derive helper.\n-                                let file_id = ast_id.ast_id.file_id;\n                                 let item_tree = self.db.file_item_tree(file_id);\n-                                let mod_dir = self.mod_dirs[&directive.module_id].clone();\n-                                self.skip_attrs.insert(InFile::new(file_id, *mod_item), attr.id);\n-                                ModCollector {\n-                                    def_collector: &mut *self,\n-                                    macro_depth: directive.depth,\n-                                    module_id: directive.module_id,\n-                                    tree_id: TreeId::new(file_id, None),\n-                                    item_tree: &item_tree,\n-                                    mod_dir,\n-                                }\n-                                .collect(&[*mod_item]);\n+                                return recollect_without(self, &item_tree);\n+                            }\n+                        }\n+                    }\n \n-                                // Remove the original directive since we resolved it.\n+                    let def = resolver(ast_id.path.clone()).filter(MacroDefId::is_attribute);\n+                    if matches!(\n+                        def,\n+                        Some(MacroDefId {  kind:MacroDefKind::BuiltInAttr(expander, _),.. })\n+                        if expander.is_derive()\n+                    ) {\n+                        // Resolved to `#[derive]`\n+                        let file_id = ast_id.ast_id.file_id;\n+                        let item_tree = self.db.file_item_tree(file_id);\n+\n+                        let ast_id: FileAstId<ast::Item> = match *mod_item {\n+                            ModItem::Struct(it) => item_tree[it].ast_id.upcast(),\n+                            ModItem::Union(it) => item_tree[it].ast_id.upcast(),\n+                            ModItem::Enum(it) => item_tree[it].ast_id.upcast(),\n+                            _ => {\n+                                // Cannot use derive on this item.\n+                                // FIXME: diagnose\n                                 res = ReachedFixedPoint::No;\n                                 return false;\n                             }\n+                        };\n+\n+                        match attr.parse_derive() {\n+                            Some(derive_macros) => {\n+                                for path in derive_macros {\n+                                    let ast_id = AstIdWithPath::new(file_id, ast_id, path);\n+                                    self.unresolved_macros.push(MacroDirective {\n+                                        module_id: directive.module_id,\n+                                        depth: directive.depth + 1,\n+                                        kind: MacroDirectiveKind::Derive {\n+                                            ast_id,\n+                                            derive_attr: attr.id,\n+                                        },\n+                                    });\n+                                }\n+                            }\n+                            None => {\n+                                // FIXME: diagnose\n+                                tracing::debug!(\"malformed derive: {:?}\", attr);\n+                            }\n                         }\n+\n+                        return recollect_without(self, &item_tree);\n                     }\n \n                     if !self.db.enable_proc_attr_macros() {\n                         return true;\n                     }\n \n-                    // Not resolved to a derive helper, so try to resolve as a macro.\n-                    match attr_macro_as_call_id(\n-                        ast_id,\n-                        attr,\n-                        self.db,\n-                        self.def_map.krate,\n-                        &resolver,\n-                    ) {\n+                    // Not resolved to a derive helper or the derive attribute, so try to resolve as a normal attribute.\n+                    match attr_macro_as_call_id(ast_id, attr, self.db, self.def_map.krate, def) {\n                         Ok(call_id) => {\n                             let loc: MacroCallLoc = self.db.lookup_intern_macro_call(call_id);\n \n                             // Skip #[test]/#[bench] expansion, which would merely result in more memory usage\n                             // due to duplicating functions into macro expansions\n-                            if is_builtin_test_or_bench_attr(loc.def) {\n-                                let file_id = ast_id.ast_id.file_id;\n+                            if matches!(\n+                                loc.def.kind,\n+                                MacroDefKind::BuiltInAttr(expander, _)\n+                                if expander.is_test() || expander.is_bench()\n+                            ) {\n                                 let item_tree = self.db.file_item_tree(file_id);\n-                                let mod_dir = self.mod_dirs[&directive.module_id].clone();\n-                                self.skip_attrs.insert(InFile::new(file_id, *mod_item), attr.id);\n-                                ModCollector {\n-                                    def_collector: &mut *self,\n-                                    macro_depth: directive.depth,\n-                                    module_id: directive.module_id,\n-                                    tree_id: TreeId::new(file_id, None),\n-                                    item_tree: &item_tree,\n-                                    mod_dir,\n-                                }\n-                                .collect(&[*mod_item]);\n-\n-                                // Remove the original directive since we resolved it.\n-                                res = ReachedFixedPoint::No;\n-                                return false;\n+                                return recollect_without(self, &item_tree);\n                             }\n \n                             if let MacroDefKind::ProcMacro(exp, ..) = loc.def.kind {\n@@ -1171,21 +1203,7 @@ impl DefCollector<'_> {\n \n                                     let file_id = ast_id.ast_id.file_id;\n                                     let item_tree = self.db.file_item_tree(file_id);\n-                                    let mod_dir = self.mod_dirs[&directive.module_id].clone();\n-                                    self.skip_attrs\n-                                        .insert(InFile::new(file_id, *mod_item), attr.id);\n-                                    ModCollector {\n-                                        def_collector: &mut *self,\n-                                        macro_depth: directive.depth,\n-                                        module_id: directive.module_id,\n-                                        tree_id: TreeId::new(file_id, None),\n-                                        item_tree: &item_tree,\n-                                        mod_dir,\n-                                    }\n-                                    .collect(&[*mod_item]);\n-\n-                                    // Remove the macro directive.\n-                                    return false;\n+                                    return recollect_without(self, &item_tree);\n                                 }\n                             }\n \n@@ -1281,7 +1299,7 @@ impl DefCollector<'_> {\n         for directive in &self.unresolved_macros {\n             match &directive.kind {\n                 MacroDirectiveKind::FnLike { ast_id, expand_to } => {\n-                    match macro_call_as_call_id(\n+                    let macro_call_as_call_id = macro_call_as_call_id(\n                         ast_id,\n                         *expand_to,\n                         self.db,\n@@ -1297,15 +1315,13 @@ impl DefCollector<'_> {\n                             resolved_res.resolved_def.take_macros()\n                         },\n                         &mut |_| (),\n-                    ) {\n-                        Ok(_) => (),\n-                        Err(UnresolvedMacro { path }) => {\n-                            self.def_map.diagnostics.push(DefDiagnostic::unresolved_macro_call(\n-                                directive.module_id,\n-                                ast_id.ast_id,\n-                                path,\n-                            ));\n-                        }\n+                    );\n+                    if let Err(UnresolvedMacro { path }) = macro_call_as_call_id {\n+                        self.def_map.diagnostics.push(DefDiagnostic::unresolved_macro_call(\n+                            directive.module_id,\n+                            ast_id.ast_id,\n+                            path,\n+                        ));\n                     }\n                 }\n                 MacroDirectiveKind::Derive { .. } | MacroDirectiveKind::Attr { .. } => {\n@@ -1747,26 +1763,23 @@ impl ModCollector<'_, '_> {\n             });\n \n         for attr in iter {\n-            if attr.path.as_ident() == Some(&hir_expand::name![derive]) {\n-                self.collect_derive(attr, mod_item);\n-            } else if self.is_builtin_or_registered_attr(&attr.path) {\n+            if self.is_builtin_or_registered_attr(&attr.path) {\n                 continue;\n-            } else {\n-                tracing::debug!(\"non-builtin attribute {}\", attr.path);\n+            }\n+            tracing::debug!(\"non-builtin attribute {}\", attr.path);\n \n-                let ast_id = AstIdWithPath::new(\n-                    self.file_id(),\n-                    mod_item.ast_id(self.item_tree),\n-                    attr.path.as_ref().clone(),\n-                );\n-                self.def_collector.unresolved_macros.push(MacroDirective {\n-                    module_id: self.module_id,\n-                    depth: self.macro_depth + 1,\n-                    kind: MacroDirectiveKind::Attr { ast_id, attr: attr.clone(), mod_item },\n-                });\n+            let ast_id = AstIdWithPath::new(\n+                self.file_id(),\n+                mod_item.ast_id(self.item_tree),\n+                attr.path.as_ref().clone(),\n+            );\n+            self.def_collector.unresolved_macros.push(MacroDirective {\n+                module_id: self.module_id,\n+                depth: self.macro_depth + 1,\n+                kind: MacroDirectiveKind::Attr { ast_id, attr: attr.clone(), mod_item },\n+            });\n \n-                return Err(());\n-            }\n+            return Err(());\n         }\n \n         Ok(())\n@@ -1800,36 +1813,6 @@ impl ModCollector<'_, '_> {\n         false\n     }\n \n-    fn collect_derive(&mut self, attr: &Attr, mod_item: ModItem) {\n-        let ast_id: FileAstId<ast::Item> = match mod_item {\n-            ModItem::Struct(it) => self.item_tree[it].ast_id.upcast(),\n-            ModItem::Union(it) => self.item_tree[it].ast_id.upcast(),\n-            ModItem::Enum(it) => self.item_tree[it].ast_id.upcast(),\n-            _ => {\n-                // Cannot use derive on this item.\n-                // FIXME: diagnose\n-                return;\n-            }\n-        };\n-\n-        match attr.parse_derive() {\n-            Some(derive_macros) => {\n-                for path in derive_macros {\n-                    let ast_id = AstIdWithPath::new(self.file_id(), ast_id, path);\n-                    self.def_collector.unresolved_macros.push(MacroDirective {\n-                        module_id: self.module_id,\n-                        depth: self.macro_depth + 1,\n-                        kind: MacroDirectiveKind::Derive { ast_id, derive_attr: attr.id },\n-                    });\n-                }\n-            }\n-            None => {\n-                // FIXME: diagnose\n-                tracing::debug!(\"malformed derive: {:?}\", attr);\n-            }\n-        }\n-    }\n-\n     /// If `attrs` registers a procedural macro, collects its definition.\n     fn collect_proc_macro_def(&mut self, func_name: &Name, ast_id: AstId<ast::Fn>, attrs: &Attrs) {\n         // FIXME: this should only be done in the root module of `proc-macro` crates, not everywhere"}, {"sha": "fbb1320d6e8248d21fd81886df23b3c9f14f0ea1", "filename": "crates/hir_def/src/nameres/tests/macros.rs", "status": "modified", "additions": 27, "deletions": 20, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/fdd49b97133a77ff652017d24b72ced37d4a822d/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdd49b97133a77ff652017d24b72ced37d4a822d/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs?ref=fdd49b97133a77ff652017d24b72ced37d4a822d", "patch": "@@ -669,19 +669,20 @@ pub struct bar;\n fn expand_derive() {\n     let map = compute_crate_def_map(\n         r#\"\n-        //- /main.rs crate:main deps:core\n-        use core::Copy;\n-\n-        #[derive(Copy, core::Clone)]\n-        struct Foo;\n+//- /main.rs crate:main deps:core\n+use core::Copy;\n \n-        //- /core.rs crate:core\n-        #[rustc_builtin_macro]\n-        pub macro Copy {}\n+#[core::derive(Copy, core::Clone)]\n+struct Foo;\n \n-        #[rustc_builtin_macro]\n-        pub macro Clone {}\n-        \"#,\n+//- /core.rs crate:core\n+#[rustc_builtin_macro]\n+pub macro derive($item:item) {}\n+#[rustc_builtin_macro]\n+pub macro Copy {}\n+#[rustc_builtin_macro]\n+pub macro Clone {}\n+\"#,\n     );\n     assert_eq!(map.modules[map.root].scope.impls().len(), 2);\n }\n@@ -712,17 +713,19 @@ fn builtin_derive_with_unresolved_attributes_fall_back() {\n     cov_mark::check!(unresolved_attribute_fallback);\n     let map = compute_crate_def_map(\n         r#\"\n-        //- /main.rs crate:main deps:core\n-        use core::Clone;\n+//- /main.rs crate:main deps:core\n+use core::{Clone, derive};\n \n-        #[derive(Clone)]\n-        #[unresolved]\n-        struct Foo;\n+#[derive(Clone)]\n+#[unresolved]\n+struct Foo;\n \n-        //- /core.rs crate:core\n-        #[rustc_builtin_macro]\n-        pub macro Clone {}\n-        \"#,\n+//- /core.rs crate:core\n+#[rustc_builtin_macro]\n+pub macro derive($item:item) {}\n+#[rustc_builtin_macro]\n+pub macro Clone {}\n+\"#,\n     );\n     assert_eq!(map.modules[map.root].scope.impls().len(), 1);\n }\n@@ -799,6 +802,9 @@ fn resolves_derive_helper() {\n     check(\n         r#\"\n //- /main.rs crate:main deps:proc\n+#[rustc_builtin_macro]\n+pub macro derive($item:item) {}\n+\n #[derive(proc::Derive)]\n #[helper]\n #[unresolved]\n@@ -811,6 +817,7 @@ fn derive() {}\n         expect![[r#\"\n             crate\n             S: t v\n+            derive: m\n         \"#]],\n     );\n }"}, {"sha": "8da8c2ee4f2e01f5813df5f7c48370c2f9cbe16e", "filename": "crates/hir_expand/src/builtin_attr_macro.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/fdd49b97133a77ff652017d24b72ced37d4a822d/crates%2Fhir_expand%2Fsrc%2Fbuiltin_attr_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdd49b97133a77ff652017d24b72ced37d4a822d/crates%2Fhir_expand%2Fsrc%2Fbuiltin_attr_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fbuiltin_attr_macro.rs?ref=fdd49b97133a77ff652017d24b72ced37d4a822d", "patch": "@@ -36,6 +36,18 @@ macro_rules! register_builtin {\n     };\n }\n \n+impl BuiltinAttrExpander {\n+    pub fn is_derive(self) -> bool {\n+        matches!(self, BuiltinAttrExpander::Derive)\n+    }\n+    pub fn is_test(self) -> bool {\n+        matches!(self, BuiltinAttrExpander::Test)\n+    }\n+    pub fn is_bench(self) -> bool {\n+        matches!(self, BuiltinAttrExpander::Bench)\n+    }\n+}\n+\n register_builtin! {\n     (bench, Bench) => dummy_attr_expand,\n     (cfg_accessible, CfgAccessible) => dummy_attr_expand,\n@@ -46,16 +58,6 @@ register_builtin! {\n     (test_case, TestCase) => dummy_attr_expand\n }\n \n-pub fn is_builtin_test_or_bench_attr(makro: MacroDefId) -> bool {\n-    match makro.kind {\n-        MacroDefKind::BuiltInAttr(expander, ..) => {\n-            BuiltinAttrExpander::find_by_name(&name!(test)) == Some(expander)\n-                || BuiltinAttrExpander::find_by_name(&name!(bench)) == Some(expander)\n-        }\n-        _ => false,\n-    }\n-}\n-\n pub fn find_builtin_attr(\n     ident: &name::Name,\n     krate: CrateId,"}, {"sha": "a61175f273350b4e291666f9c482768ad5f6062f", "filename": "crates/hir_ty/src/tests/macros.rs", "status": "modified", "additions": 3, "deletions": 67, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/fdd49b97133a77ff652017d24b72ced37d4a822d/crates%2Fhir_ty%2Fsrc%2Ftests%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdd49b97133a77ff652017d24b72ced37d4a822d/crates%2Fhir_ty%2Fsrc%2Ftests%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fmacros.rs?ref=fdd49b97133a77ff652017d24b72ced37d4a822d", "patch": "@@ -974,61 +974,12 @@ fn infer_builtin_macros_env() {\n fn infer_derive_clone_simple() {\n     check_types(\n         r#\"\n-//- /main.rs crate:main deps:core\n+//- minicore: derive, clone\n #[derive(Clone)]\n struct S;\n fn test() {\n     S.clone();\n } //^^^^^^^^^ S\n-\n-//- /lib.rs crate:core\n-pub mod prelude {\n-    pub mod rust_2018 {\n-        #[rustc_builtin_macro]\n-        pub macro Clone {}\n-        pub use crate::clone::Clone;\n-    }\n-}\n-\n-pub mod clone {\n-    pub trait Clone {\n-        fn clone(&self) -> Self;\n-    }\n-}\n-\"#,\n-    );\n-}\n-\n-#[test]\n-fn infer_derive_clone_in_core() {\n-    check_types(\n-        r#\"\n-//- /lib.rs crate:core\n-#[prelude_import]\n-use prelude::rust_2018::*;\n-\n-pub mod prelude {\n-    pub mod rust_2018 {\n-        #[rustc_builtin_macro]\n-        pub macro Clone {}\n-        pub use crate::clone::Clone;\n-    }\n-}\n-\n-pub mod clone {\n-    pub trait Clone {\n-        fn clone(&self) -> Self;\n-    }\n-}\n-\n-#[derive(Clone)]\n-pub struct S;\n-\n-//- /main.rs crate:main deps:core\n-use core::S;\n-fn test() {\n-    S.clone();\n-} //^^^^^^^^^ S\n \"#,\n     );\n }\n@@ -1037,7 +988,7 @@ fn test() {\n fn infer_derive_clone_with_params() {\n     check_types(\n         r#\"\n-//- /main.rs crate:main deps:core\n+//- minicore: clone, derive\n #[derive(Clone)]\n struct S;\n #[derive(Clone)]\n@@ -1048,21 +999,6 @@ fn test() {\n     x;\n   //^ (Wrapper<S>, {unknown})\n }\n-\n-//- /lib.rs crate:core\n-pub mod prelude {\n-    pub mod rust_2018 {\n-        #[rustc_builtin_macro]\n-        pub macro Clone {}\n-        pub use crate::clone::Clone;\n-    }\n-}\n-\n-pub mod clone {\n-    pub trait Clone {\n-        fn clone(&self) -> Self;\n-    }\n-}\n \"#,\n     );\n }\n@@ -1072,7 +1008,7 @@ fn infer_custom_derive_simple() {\n     // FIXME: this test current now do nothing\n     check_types(\n         r#\"\n-//- /main.rs crate:main\n+//- minicore: derive\n use foo::Foo;\n \n #[derive(Foo)]"}, {"sha": "57c078ef57df64e4848c66283d12c56bc351171a", "filename": "crates/ide/src/expand_macro.rs", "status": "modified", "additions": 7, "deletions": 15, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/fdd49b97133a77ff652017d24b72ced37d4a822d/crates%2Fide%2Fsrc%2Fexpand_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdd49b97133a77ff652017d24b72ced37d4a822d/crates%2Fide%2Fsrc%2Fexpand_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fexpand_macro.rs?ref=fdd49b97133a77ff652017d24b72ced37d4a822d", "patch": "@@ -367,17 +367,15 @@ fn main() {\n         check(\n             r#\"\n //- proc_macros: identity\n-\n-#[rustc_builtin_macro]\n-pub macro Clone {}\n+//- minicore: clone, derive\n \n #[proc_macros::identity]\n #[derive(C$0lone)]\n struct Foo {}\n \"#,\n             expect![[r#\"\n                 Clone\n-                impl< >crate::clone::Clone for Foo< >{}\n+                impl< >core::clone::Clone for Foo< >{}\n \n             \"#]],\n         );\n@@ -387,18 +385,15 @@ struct Foo {}\n     fn macro_expand_derive2() {\n         check(\n             r#\"\n-#[rustc_builtin_macro]\n-pub macro Clone {}\n-#[rustc_builtin_macro]\n-pub macro Copy {}\n+//- minicore: copy, clone, derive\n \n #[derive(Cop$0y)]\n #[derive(Clone)]\n struct Foo {}\n \"#,\n             expect![[r#\"\n                 Copy\n-                impl< >crate::marker::Copy for Foo< >{}\n+                impl< >core::marker::Copy for Foo< >{}\n \n             \"#]],\n         );\n@@ -408,19 +403,16 @@ struct Foo {}\n     fn macro_expand_derive_multi() {\n         check(\n             r#\"\n-#[rustc_builtin_macro]\n-pub macro Clone {}\n-#[rustc_builtin_macro]\n-pub macro Copy {}\n+//- minicore: copy, clone, derive\n \n #[derive(Cop$0y, Clone)]\n struct Foo {}\n \"#,\n             expect![[r#\"\n                 Copy, Clone\n-                impl< >crate::marker::Copy for Foo< >{}\n+                impl< >core::marker::Copy for Foo< >{}\n \n-                impl< >crate::clone::Clone for Foo< >{}\n+                impl< >core::clone::Clone for Foo< >{}\n \n             \"#]],\n         );"}, {"sha": "9e555dc49e62415f554bb94dcb80bd30d6ca4ac9", "filename": "crates/rust-analyzer/tests/slow-tests/main.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fdd49b97133a77ff652017d24b72ced37d4a822d/crates%2Frust-analyzer%2Ftests%2Fslow-tests%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdd49b97133a77ff652017d24b72ced37d4a822d/crates%2Frust-analyzer%2Ftests%2Fslow-tests%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Ftests%2Fslow-tests%2Fmain.rs?ref=fdd49b97133a77ff652017d24b72ced37d4a822d", "patch": "@@ -805,6 +805,9 @@ bar = {path = \"../bar\"}\n \n //- /foo/src/main.rs\n use bar::Bar;\n+\n+#[rustc_builtin_macro]\n+macro derive($item:item) {}\n trait Bar {\n   fn bar();\n }\n@@ -875,7 +878,7 @@ pub fn foo(_input: TokenStream) -> TokenStream {\n     let res = server.send_request::<HoverRequest>(HoverParams {\n         text_document_position_params: TextDocumentPositionParams::new(\n             server.doc_id(\"foo/src/main.rs\"),\n-            Position::new(7, 9),\n+            Position::new(10, 9),\n         ),\n         work_done_progress_params: Default::default(),\n     });"}]}