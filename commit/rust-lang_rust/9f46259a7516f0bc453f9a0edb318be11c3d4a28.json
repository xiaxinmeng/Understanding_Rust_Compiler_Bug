{"sha": "9f46259a7516f0bc453f9a0edb318be11c3d4a28", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlmNDYyNTlhNzUxNmYwYmM0NTNmOWEwZWRiMzE4YmUxMWMzZDRhMjg=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2020-10-23T20:34:32Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-02-13T20:14:58Z"}, "message": "Return a Result for query cache.", "tree": {"sha": "55b26907ee1216468c0fddb6580a6faeed11fa4c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/55b26907ee1216468c0fddb6580a6faeed11fa4c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9f46259a7516f0bc453f9a0edb318be11c3d4a28", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9f46259a7516f0bc453f9a0edb318be11c3d4a28", "html_url": "https://github.com/rust-lang/rust/commit/9f46259a7516f0bc453f9a0edb318be11c3d4a28", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9f46259a7516f0bc453f9a0edb318be11c3d4a28/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f8ab649dfd8866e35e3281e04534fe024e4095f7", "url": "https://api.github.com/repos/rust-lang/rust/commits/f8ab649dfd8866e35e3281e04534fe024e4095f7", "html_url": "https://github.com/rust-lang/rust/commit/f8ab649dfd8866e35e3281e04534fe024e4095f7"}], "stats": {"total": 155, "additions": 68, "deletions": 87}, "files": [{"sha": "1ec32939d9f8d267f3b22ab6e0dcac9337bedb27", "filename": "compiler/rustc_query_system/src/query/caches.rs", "status": "modified", "additions": 26, "deletions": 30, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/9f46259a7516f0bc453f9a0edb318be11c3d4a28/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fcaches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f46259a7516f0bc453f9a0edb318be11c3d4a28/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fcaches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fcaches.rs?ref=9f46259a7516f0bc453f9a0edb318be11c3d4a28", "patch": "@@ -31,17 +31,15 @@ pub trait QueryCache: QueryStorage {\n     /// It returns the shard index and a lock guard to the shard,\n     /// which will be used if the query is not in the cache and we need\n     /// to compute it.\n-    fn lookup<D, Q, R, OnHit, OnMiss>(\n+    fn lookup<'s, D, Q, R, OnHit>(\n         &self,\n-        state: &QueryState<D, Q, Self>,\n-        key: Self::Key,\n+        state: &'s QueryState<D, Q, Self>,\n+        key: &Self::Key,\n         // `on_hit` can be called while holding a lock to the query state shard.\n         on_hit: OnHit,\n-        on_miss: OnMiss,\n-    ) -> R\n+    ) -> Result<R, QueryLookup<'s, D, Q, Self::Key, Self::Sharded>>\n     where\n-        OnHit: FnOnce(&Self::Stored, DepNodeIndex) -> R,\n-        OnMiss: FnOnce(Self::Key, QueryLookup<'_, D, Q, Self::Key, Self::Sharded>) -> R;\n+        OnHit: FnOnce(&Self::Stored, DepNodeIndex) -> R;\n \n     fn complete(\n         &self,\n@@ -95,23 +93,24 @@ where\n     type Sharded = FxHashMap<K, (V, DepNodeIndex)>;\n \n     #[inline(always)]\n-    fn lookup<D, Q, R, OnHit, OnMiss>(\n+    fn lookup<'s, D, Q, R, OnHit>(\n         &self,\n-        state: &QueryState<D, Q, Self>,\n-        key: K,\n+        state: &'s QueryState<D, Q, Self>,\n+        key: &K,\n         on_hit: OnHit,\n-        on_miss: OnMiss,\n-    ) -> R\n+    ) -> Result<R, QueryLookup<'s, D, Q, K, Self::Sharded>>\n     where\n         OnHit: FnOnce(&V, DepNodeIndex) -> R,\n-        OnMiss: FnOnce(K, QueryLookup<'_, D, Q, K, Self::Sharded>) -> R,\n     {\n-        let mut lookup = state.get_lookup(&key);\n-        let lock = &mut *lookup.lock;\n+        let lookup = state.get_lookup(key);\n+        let result = lookup.lock.cache.raw_entry().from_key_hashed_nocheck(lookup.key_hash, key);\n \n-        let result = lock.cache.raw_entry().from_key_hashed_nocheck(lookup.key_hash, &key);\n-\n-        if let Some((_, value)) = result { on_hit(&value.0, value.1) } else { on_miss(key, lookup) }\n+        if let Some((_, value)) = result {\n+            let hit_result = on_hit(&value.0, value.1);\n+            Ok(hit_result)\n+        } else {\n+            Err(lookup)\n+        }\n     }\n \n     #[inline]\n@@ -177,26 +176,23 @@ where\n     type Sharded = FxHashMap<K, &'tcx (V, DepNodeIndex)>;\n \n     #[inline(always)]\n-    fn lookup<D, Q, R, OnHit, OnMiss>(\n+    fn lookup<'s, D, Q, R, OnHit>(\n         &self,\n-        state: &QueryState<D, Q, Self>,\n-        key: K,\n+        state: &'s QueryState<D, Q, Self>,\n+        key: &K,\n         on_hit: OnHit,\n-        on_miss: OnMiss,\n-    ) -> R\n+    ) -> Result<R, QueryLookup<'s, D, Q, K, Self::Sharded>>\n     where\n         OnHit: FnOnce(&&'tcx V, DepNodeIndex) -> R,\n-        OnMiss: FnOnce(K, QueryLookup<'_, D, Q, K, Self::Sharded>) -> R,\n     {\n-        let mut lookup = state.get_lookup(&key);\n-        let lock = &mut *lookup.lock;\n-\n-        let result = lock.cache.raw_entry().from_key_hashed_nocheck(lookup.key_hash, &key);\n+        let lookup = state.get_lookup(key);\n+        let result = lookup.lock.cache.raw_entry().from_key_hashed_nocheck(lookup.key_hash, key);\n \n         if let Some((_, value)) = result {\n-            on_hit(&&value.0, value.1)\n+            let hit_result = on_hit(&&value.0, value.1);\n+            Ok(hit_result)\n         } else {\n-            on_miss(key, lookup)\n+            Err(lookup)\n         }\n     }\n "}, {"sha": "4f93017200f59b81821e9a0e512cb288337c3cb6", "filename": "compiler/rustc_query_system/src/query/plumbing.rs", "status": "modified", "additions": 42, "deletions": 57, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/9f46259a7516f0bc453f9a0edb318be11c3d4a28/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f46259a7516f0bc453f9a0edb318be11c3d4a28/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs?ref=9f46259a7516f0bc453f9a0edb318be11c3d4a28", "patch": "@@ -248,13 +248,8 @@ where\n                 return TryGetJob::Cycle(value);\n             }\n \n-            let cached = try_get_cached(\n-                tcx,\n-                state,\n-                (*key).clone(),\n-                |value, index| (value.clone(), index),\n-                |_, _| panic!(\"value must be in cache after waiting\"),\n-            );\n+            let cached = try_get_cached(tcx, state, key, |value, index| (value.clone(), index))\n+                .unwrap_or_else(|_| panic!(\"value must be in cache after waiting\"));\n \n             if let Some(prof_timer) = _query_blocked_prof_timer.take() {\n                 prof_timer.finish_with_query_invocation_id(cached.1.into());\n@@ -356,35 +351,28 @@ where\n /// It returns the shard index and a lock guard to the shard,\n /// which will be used if the query is not in the cache and we need\n /// to compute it.\n-fn try_get_cached<CTX, C, R, OnHit, OnMiss>(\n+fn try_get_cached<'a, CTX, C, R, OnHit>(\n     tcx: CTX,\n-    state: &QueryState<CTX::DepKind, CTX::Query, C>,\n-    key: C::Key,\n+    state: &'a QueryState<CTX::DepKind, CTX::Query, C>,\n+    key: &C::Key,\n     // `on_hit` can be called while holding a lock to the query cache\n     on_hit: OnHit,\n-    on_miss: OnMiss,\n-) -> R\n+) -> Result<R, QueryLookup<'a, CTX::DepKind, CTX::Query, C::Key, C::Sharded>>\n where\n     C: QueryCache,\n     CTX: QueryContext,\n     OnHit: FnOnce(&C::Stored, DepNodeIndex) -> R,\n-    OnMiss: FnOnce(C::Key, QueryLookup<'_, CTX::DepKind, CTX::Query, C::Key, C::Sharded>) -> R,\n {\n-    state.cache.lookup(\n-        state,\n-        key,\n-        |value, index| {\n-            if unlikely!(tcx.profiler().enabled()) {\n-                tcx.profiler().query_cache_hit(index.into());\n-            }\n-            #[cfg(debug_assertions)]\n-            {\n-                state.cache_hits.fetch_add(1, Ordering::Relaxed);\n-            }\n-            on_hit(value, index)\n-        },\n-        on_miss,\n-    )\n+    state.cache.lookup(state, &key, |value, index| {\n+        if unlikely!(tcx.profiler().enabled()) {\n+            tcx.profiler().query_cache_hit(index.into());\n+        }\n+        #[cfg(debug_assertions)]\n+        {\n+            state.cache_hits.fetch_add(1, Ordering::Relaxed);\n+        }\n+        on_hit(value, index)\n+    })\n }\n \n fn try_execute_query<CTX, C>(\n@@ -626,16 +614,14 @@ where\n     C: QueryCache,\n     C::Key: crate::dep_graph::DepNodeParams<CTX>,\n {\n-    try_get_cached(\n-        tcx,\n-        state,\n-        key,\n-        |value, index| {\n-            tcx.dep_graph().read_index(index);\n-            value.clone()\n-        },\n-        |key, lookup| try_execute_query(tcx, state, span, key, lookup, query),\n-    )\n+    let cached = try_get_cached(tcx, state, &key, |value, index| {\n+        tcx.dep_graph().read_index(index);\n+        value.clone()\n+    });\n+    match cached {\n+        Ok(value) => value,\n+        Err(lookup) => try_execute_query(tcx, state, span, key, lookup, query),\n+    }\n }\n \n /// Ensure that either this query has all green inputs or been executed.\n@@ -694,25 +680,24 @@ fn force_query_impl<CTX, C>(\n     // We may be concurrently trying both execute and force a query.\n     // Ensure that only one of them runs the query.\n \n-    try_get_cached(\n-        tcx,\n-        state,\n-        key,\n-        |_, _| {\n-            // Cache hit, do nothing\n-        },\n-        |key, lookup| {\n-            let job = match JobOwner::<'_, CTX::DepKind, CTX::Query, C>::try_start(\n-                tcx, state, span, &key, lookup, query,\n-            ) {\n-                TryGetJob::NotYetStarted(job) => job,\n-                TryGetJob::Cycle(_) => return,\n-                #[cfg(parallel_compiler)]\n-                TryGetJob::JobCompleted(_) => return,\n-            };\n-            force_query_with_job(tcx, key, job, dep_node, query);\n-        },\n-    );\n+    let cached = try_get_cached(tcx, state, &key, |_, _| {\n+        // Cache hit, do nothing\n+    });\n+\n+    let lookup = match cached {\n+        Ok(()) => return,\n+        Err(lookup) => lookup,\n+    };\n+\n+    let job = match JobOwner::<'_, CTX::DepKind, CTX::Query, C>::try_start(\n+        tcx, state, span, &key, lookup, query,\n+    ) {\n+        TryGetJob::NotYetStarted(job) => job,\n+        TryGetJob::Cycle(_) => return,\n+        #[cfg(parallel_compiler)]\n+        TryGetJob::JobCompleted(_) => return,\n+    };\n+    force_query_with_job(tcx, key, job, dep_node, query);\n }\n \n pub enum QueryMode {"}]}