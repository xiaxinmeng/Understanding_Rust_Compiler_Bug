{"sha": "95423d28f221ac67bad7e7c6396b983705a056ae", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk1NDIzZDI4ZjIyMWFjNjdiYWQ3ZTdjNjM5NmI5ODM3MDVhMDU2YWU=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2012-10-18T16:10:37Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2012-10-18T17:09:42Z"}, "message": "libcore: call [u8] values bytes, not bufs", "tree": {"sha": "bc1d2daaa732086c58fb45d7bb7fed17b76fe326", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bc1d2daaa732086c58fb45d7bb7fed17b76fe326"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/95423d28f221ac67bad7e7c6396b983705a056ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/95423d28f221ac67bad7e7c6396b983705a056ae", "html_url": "https://github.com/rust-lang/rust/commit/95423d28f221ac67bad7e7c6396b983705a056ae", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/95423d28f221ac67bad7e7c6396b983705a056ae/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e3b1471acdfe6121a8e0f657d8caa27393703253", "url": "https://api.github.com/repos/rust-lang/rust/commits/e3b1471acdfe6121a8e0f657d8caa27393703253", "html_url": "https://github.com/rust-lang/rust/commit/e3b1471acdfe6121a8e0f657d8caa27393703253"}], "stats": {"total": 100, "additions": 52, "deletions": 48}, "files": [{"sha": "92315285d043c240dd254c8b5f4171fdccd80126", "filename": "src/libcore/io.rs", "status": "modified", "additions": 50, "deletions": 46, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/95423d28f221ac67bad7e7c6396b983705a056ae/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95423d28f221ac67bad7e7c6396b983705a056ae/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=95423d28f221ac67bad7e7c6396b983705a056ae", "patch": "@@ -37,7 +37,7 @@ pub trait Reader {\n     // FIXME (#2004): Seekable really should be orthogonal.\n \n     // FIXME (#2982): This should probably return an error.\n-    fn read(buf: &[mut u8], len: uint) -> uint;\n+    fn read(bytes: &[mut u8], len: uint) -> uint;\n     fn read_byte() -> int;\n     fn unread_byte(int);\n     fn eof() -> bool;\n@@ -65,32 +65,32 @@ pub trait ReaderUtil {\n \n impl<T: Reader> T : ReaderUtil {\n     fn read_bytes(len: uint) -> ~[u8] {\n-        let mut buf = vec::with_capacity(len);\n-        unsafe { vec::raw::set_len(&mut buf, len); }\n+        let mut bytes = vec::with_capacity(len);\n+        unsafe { vec::raw::set_len(&mut bytes, len); }\n \n-        let count = self.read(buf, len);\n+        let count = self.read(bytes, len);\n \n-        unsafe { vec::raw::set_len(&mut buf, count); }\n-        move buf\n+        unsafe { vec::raw::set_len(&mut bytes, count); }\n+        move bytes\n     }\n     fn read_line() -> ~str {\n-        let mut buf = ~[];\n+        let mut bytes = ~[];\n         loop {\n             let ch = self.read_byte();\n             if ch == -1 || ch == 10 { break; }\n-            buf.push(ch as u8);\n+            bytes.push(ch as u8);\n         }\n-        str::from_bytes(buf)\n+        str::from_bytes(bytes)\n     }\n \n     fn read_chars(n: uint) -> ~[char] {\n         // returns the (consumed offset, n_req), appends characters to &chars\n-        fn chars_from_bytes<T: Reader>(buf: &~[u8], chars: &mut ~[char])\n+        fn chars_from_bytes<T: Reader>(bytes: &~[u8], chars: &mut ~[char])\n             -> (uint, uint) {\n             let mut i = 0;\n-            let buf_len = buf.len();\n-            while i < buf_len {\n-                let b0 = buf[i];\n+            let bytes_len = bytes.len();\n+            while i < bytes_len {\n+                let b0 = bytes[i];\n                 let w = str::utf8_char_width(b0);\n                 let end = i + w;\n                 i += 1;\n@@ -100,12 +100,12 @@ impl<T: Reader> T : ReaderUtil {\n                     loop;\n                 }\n                 // can't satisfy this char with the existing data\n-                if end > buf_len {\n-                    return (i - 1, end - buf_len);\n+                if end > bytes_len {\n+                    return (i - 1, end - bytes_len);\n                 }\n                 let mut val = 0;\n                 while i < end {\n-                    let next = buf[i] as int;\n+                    let next = bytes[i] as int;\n                     i += 1;\n                     assert (next > -1);\n                     assert (next & 192 == 128);\n@@ -119,7 +119,7 @@ impl<T: Reader> T : ReaderUtil {\n             }\n             return (i, 0);\n         }\n-        let mut buf: ~[u8] = ~[];\n+        let mut bytes: ~[u8] = ~[];\n         let mut chars: ~[char] = ~[];\n         // might need more bytes, but reading n will never over-read\n         let mut nbread = n;\n@@ -130,15 +130,15 @@ impl<T: Reader> T : ReaderUtil {\n                 // we're split in a unicode char?\n                 break;\n             }\n-            buf.push_all(data);\n-            let (offset, nbreq) = chars_from_bytes::<T>(&buf, &mut chars);\n+            bytes.push_all(data);\n+            let (offset, nbreq) = chars_from_bytes::<T>(&bytes, &mut chars);\n             let ncreq = n - chars.len();\n             // again we either know we need a certain number of bytes\n             // to complete a character, or we make sure we don't\n             // over-read by reading 1-byte per char needed\n             nbread = if ncreq > nbreq { ncreq } else { nbreq };\n             if nbread > 0 {\n-                buf = vec::slice(buf, offset, buf.len());\n+                bytes = vec::slice(bytes, offset, bytes.len());\n             }\n         }\n         move chars\n@@ -154,12 +154,12 @@ impl<T: Reader> T : ReaderUtil {\n     }\n \n     fn read_c_str() -> ~str {\n-        let mut buf: ~[u8] = ~[];\n+        let mut bytes: ~[u8] = ~[];\n         loop {\n             let ch = self.read_byte();\n-            if ch < 1 { break; } else { buf.push(ch as u8); }\n+            if ch < 1 { break; } else { bytes.push(ch as u8); }\n         }\n-        str::from_bytes(buf)\n+        str::from_bytes(bytes)\n     }\n \n     // FIXME deal with eof? // #2004\n@@ -191,9 +191,9 @@ impl<T: Reader> T : ReaderUtil {\n     }\n \n     fn read_whole_stream() -> ~[u8] {\n-        let mut buf: ~[u8] = ~[];\n-        while !self.eof() { buf.push_all(self.read_bytes(2048u)); }\n-        move buf\n+        let mut bytes: ~[u8] = ~[];\n+        while !self.eof() { bytes.push_all(self.read_bytes(2048u)); }\n+        move bytes\n     }\n \n     fn each_byte(it: fn(int) -> bool) {\n@@ -226,8 +226,8 @@ fn convert_whence(whence: SeekStyle) -> i32 {\n }\n \n impl *libc::FILE: Reader {\n-    fn read(buf: &[mut u8], len: uint) -> uint {\n-        do vec::as_mut_buf(buf) |buf_p, buf_len| {\n+    fn read(bytes: &[mut u8], len: uint) -> uint {\n+        do vec::as_mut_buf(bytes) |buf_p, buf_len| {\n             assert buf_len <= len;\n \n             let count = libc::fread(buf_p as *mut c_void, 1u as size_t,\n@@ -250,7 +250,9 @@ impl *libc::FILE: Reader {\n // duration of its lifetime.\n // FIXME there really should be a better way to do this // #2004\n impl<T: Reader, C> {base: T, cleanup: C}: Reader {\n-    fn read(buf: &[mut u8], len: uint) -> uint { self.base.read(buf, len) }\n+    fn read(bytes: &[mut u8], len: uint) -> uint {\n+        self.base.read(bytes, len)\n+    }\n     fn read_byte() -> int { self.base.read_byte() }\n     fn unread_byte(byte: int) { self.base.unread_byte(byte); }\n     fn eof() -> bool { self.base.eof() }\n@@ -604,10 +606,10 @@ impl<T: Writer> T : WriterUtil {\n         self.write_str(&\"\\n\");\n     }\n     fn write_int(n: int) {\n-        int::to_str_bytes(n, 10u, |buf| self.write(buf))\n+        int::to_str_bytes(n, 10u, |bytes| self.write(bytes))\n     }\n     fn write_uint(n: uint) {\n-        uint::to_str_bytes(false, n, 10u, |buf| self.write(buf))\n+        uint::to_str_bytes(false, n, 10u, |bytes| self.write(bytes))\n     }\n     fn write_le_uint(n: uint) {\n         u64_to_le_bytes(n as u64, uint::bytes, |v| self.write(v))\n@@ -689,34 +691,34 @@ pub fn print(s: &str) { stdout().write_str(s); }\n pub fn println(s: &str) { stdout().write_line(s); }\n \n pub struct BytesWriter {\n-    buf: DVec<u8>,\n+    bytes: DVec<u8>,\n     mut pos: uint,\n }\n \n impl BytesWriter: Writer {\n     fn write(v: &[const u8]) {\n-        do self.buf.swap |buf| {\n-            let mut buf <- buf;\n+        do self.bytes.swap |bytes| {\n+            let mut bytes <- bytes;\n             let v_len = v.len();\n-            let buf_len = buf.len();\n+            let bytes_len = bytes.len();\n \n-            let count = uint::max(buf_len, self.pos + v_len);\n-            vec::reserve(&mut buf, count);\n-            unsafe { vec::raw::set_len(&mut buf, count); }\n+            let count = uint::max(bytes_len, self.pos + v_len);\n+            vec::reserve(&mut bytes, count);\n+            unsafe { vec::raw::set_len(&mut bytes, count); }\n \n             {\n-                let view = vec::mut_view(buf, self.pos, count);\n+                let view = vec::mut_view(bytes, self.pos, count);\n                 vec::bytes::memcpy(view, v, v_len);\n             }\n \n             self.pos += v_len;\n \n-            move buf\n+            move bytes\n         }\n     }\n     fn seek(offset: int, whence: SeekStyle) {\n         let pos = self.pos;\n-        let len = self.buf.len();\n+        let len = self.bytes.len();\n         self.pos = seek_in_buf(offset, pos, len, whence);\n     }\n     fn tell() -> uint { self.pos }\n@@ -733,14 +735,14 @@ impl @BytesWriter : Writer {\n }\n \n pub pure fn BytesWriter() -> BytesWriter {\n-    BytesWriter { buf: DVec(), mut pos: 0u }\n+    BytesWriter { bytes: DVec(), mut pos: 0u }\n }\n \n pub pure fn with_bytes_writer(f: fn(Writer)) -> ~[u8] {\n     let wr = @BytesWriter();\n     f(wr as Writer);\n     // FIXME (#3758): This should not be needed.\n-    unsafe { wr.buf.check_out(|buf| move buf) }\n+    unsafe { wr.bytes.check_out(|bytes| move bytes) }\n }\n \n pub pure fn with_str_writer(f: fn(Writer)) -> ~str {\n@@ -981,15 +983,17 @@ mod tests {\n     fn bytes_buffer_overwrite() {\n         let wr = BytesWriter();\n         wr.write(~[0u8, 1u8, 2u8, 3u8]);\n-        assert wr.buf.borrow(|buf| buf == ~[0u8, 1u8, 2u8, 3u8]);\n+        assert wr.bytes.borrow(|bytes| bytes == ~[0u8, 1u8, 2u8, 3u8]);\n         wr.seek(-2, SeekCur);\n         wr.write(~[4u8, 5u8, 6u8, 7u8]);\n-        assert wr.buf.borrow(|buf| buf == ~[0u8, 1u8, 4u8, 5u8, 6u8, 7u8]);\n+        assert wr.bytes.borrow(|bytes| bytes ==\n+            ~[0u8, 1u8, 4u8, 5u8, 6u8, 7u8]);\n         wr.seek(-2, SeekEnd);\n         wr.write(~[8u8]);\n         wr.seek(1, SeekSet);\n         wr.write(~[9u8]);\n-        assert wr.buf.borrow(|buf| buf == ~[0u8, 9u8, 4u8, 5u8, 8u8, 7u8]);\n+        assert wr.bytes.borrow(|bytes| bytes ==\n+            ~[0u8, 9u8, 4u8, 5u8, 8u8, 7u8]);\n     }\n }\n "}, {"sha": "1579705dd0ecb55f1bff27d0647d819526c5e458", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/95423d28f221ac67bad7e7c6396b983705a056ae/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95423d28f221ac67bad7e7c6396b983705a056ae/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=95423d28f221ac67bad7e7c6396b983705a056ae", "patch": "@@ -1162,7 +1162,7 @@ fn encode_metadata(parms: encode_parms, crate: @crate) -> ~[u8] {\n \n     if (parms.tcx.sess.meta_stats()) {\n \n-        do wr.buf.borrow |v| {\n+        do wr.bytes.borrow |v| {\n             do v.each |e| {\n                 if *e == 0 {\n                     ecx.stats.zero_bytes += 1;\n@@ -1195,7 +1195,7 @@ fn encode_metadata(parms: encode_parms, crate: @crate) -> ~[u8] {\n \n     (do str::as_bytes(&~\"rust\\x00\\x00\\x00\\x01\") |bytes| {\n         vec::slice(*bytes, 0, 8)\n-    }) + flate::deflate_bytes(wr.buf.check_out(|buf| buf))\n+    }) + flate::deflate_bytes(wr.bytes.check_out(|buf| buf))\n }\n \n // Get the encoded string for a type"}]}