{"sha": "aca2735d1e1589dd474858f4cef9ef638d741e5b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFjYTI3MzVkMWUxNTg5ZGQ0NzQ4NThmNGNlZjllZjYzOGQ3NDFlNWI=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2020-10-24T18:53:16Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2020-10-24T18:53:16Z"}, "message": "Support insertion in SyntaxRewriter", "tree": {"sha": "25e08ef466ed8b6f023a9f123f1767a253975742", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/25e08ef466ed8b6f023a9f123f1767a253975742"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aca2735d1e1589dd474858f4cef9ef638d741e5b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aca2735d1e1589dd474858f4cef9ef638d741e5b", "html_url": "https://github.com/rust-lang/rust/commit/aca2735d1e1589dd474858f4cef9ef638d741e5b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aca2735d1e1589dd474858f4cef9ef638d741e5b/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d5c294f78ca9c621e38b23102e3b5ca1bdd175f3", "url": "https://api.github.com/repos/rust-lang/rust/commits/d5c294f78ca9c621e38b23102e3b5ca1bdd175f3", "html_url": "https://github.com/rust-lang/rust/commit/d5c294f78ca9c621e38b23102e3b5ca1bdd175f3"}], "stats": {"total": 158, "additions": 134, "deletions": 24}, "files": [{"sha": "0baae2f5778285459b1f25691617ebde5b5d8cdb", "filename": "crates/syntax/src/algo.rs", "status": "modified", "additions": 134, "deletions": 24, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/aca2735d1e1589dd474858f4cef9ef638d741e5b/crates%2Fsyntax%2Fsrc%2Falgo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aca2735d1e1589dd474858f4cef9ef638d741e5b/crates%2Fsyntax%2Fsrc%2Falgo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Falgo.rs?ref=aca2735d1e1589dd474858f4cef9ef638d741e5b", "patch": "@@ -289,11 +289,19 @@ fn _replace_children(\n     with_children(parent, new_children)\n }\n \n+#[derive(Debug, PartialEq, Eq, Hash)]\n+enum InsertPos {\n+    FirstChildOf(SyntaxNode),\n+    Before(SyntaxElement),\n+    After(SyntaxElement),\n+}\n+\n #[derive(Default)]\n pub struct SyntaxRewriter<'a> {\n     f: Option<Box<dyn Fn(&SyntaxElement) -> Option<SyntaxElement> + 'a>>,\n     //FIXME: add debug_assertions that all elements are in fact from the same file.\n     replacements: FxHashMap<SyntaxElement, Replacement>,\n+    insertions: IndexMap<InsertPos, Vec<SyntaxElement>>,\n }\n \n impl fmt::Debug for SyntaxRewriter<'_> {\n@@ -304,13 +312,86 @@ impl fmt::Debug for SyntaxRewriter<'_> {\n \n impl<'a> SyntaxRewriter<'a> {\n     pub fn from_fn(f: impl Fn(&SyntaxElement) -> Option<SyntaxElement> + 'a) -> SyntaxRewriter<'a> {\n-        SyntaxRewriter { f: Some(Box::new(f)), replacements: FxHashMap::default() }\n+        SyntaxRewriter {\n+            f: Some(Box::new(f)),\n+            replacements: FxHashMap::default(),\n+            insertions: IndexMap::default(),\n+        }\n     }\n     pub fn delete<T: Clone + Into<SyntaxElement>>(&mut self, what: &T) {\n         let what = what.clone().into();\n         let replacement = Replacement::Delete;\n         self.replacements.insert(what, replacement);\n     }\n+    pub fn insert_before<T: Clone + Into<SyntaxElement>, U: Clone + Into<SyntaxElement>>(\n+        &mut self,\n+        before: &T,\n+        what: &U,\n+    ) {\n+        self.insertions\n+            .entry(InsertPos::Before(before.clone().into()))\n+            .or_insert_with(Vec::new)\n+            .push(what.clone().into());\n+    }\n+    pub fn insert_after<T: Clone + Into<SyntaxElement>, U: Clone + Into<SyntaxElement>>(\n+        &mut self,\n+        after: &T,\n+        what: &U,\n+    ) {\n+        self.insertions\n+            .entry(InsertPos::After(after.clone().into()))\n+            .or_insert_with(Vec::new)\n+            .push(what.clone().into());\n+    }\n+    pub fn insert_as_first_child<T: Clone + Into<SyntaxNode>, U: Clone + Into<SyntaxElement>>(\n+        &mut self,\n+        parent: &T,\n+        what: &U,\n+    ) {\n+        self.insertions\n+            .entry(InsertPos::FirstChildOf(parent.clone().into()))\n+            .or_insert_with(Vec::new)\n+            .push(what.clone().into());\n+    }\n+    pub fn insert_many_before<\n+        T: Clone + Into<SyntaxElement>,\n+        U: IntoIterator<Item = SyntaxElement>,\n+    >(\n+        &mut self,\n+        before: &T,\n+        what: U,\n+    ) {\n+        self.insertions\n+            .entry(InsertPos::Before(before.clone().into()))\n+            .or_insert_with(Vec::new)\n+            .extend(what);\n+    }\n+    pub fn insert_many_after<\n+        T: Clone + Into<SyntaxElement>,\n+        U: IntoIterator<Item = SyntaxElement>,\n+    >(\n+        &mut self,\n+        after: &T,\n+        what: U,\n+    ) {\n+        self.insertions\n+            .entry(InsertPos::After(after.clone().into()))\n+            .or_insert_with(Vec::new)\n+            .extend(what);\n+    }\n+    pub fn insert_many_as_first_children<\n+        T: Clone + Into<SyntaxNode>,\n+        U: IntoIterator<Item = SyntaxElement>,\n+    >(\n+        &mut self,\n+        parent: &T,\n+        what: U,\n+    ) {\n+        self.insertions\n+            .entry(InsertPos::FirstChildOf(parent.clone().into()))\n+            .or_insert_with(Vec::new)\n+            .extend(what)\n+    }\n     pub fn replace<T: Clone + Into<SyntaxElement>>(&mut self, what: &T, with: &T) {\n         let what = what.clone().into();\n         let replacement = Replacement::Single(with.clone().into());\n@@ -330,7 +411,7 @@ impl<'a> SyntaxRewriter<'a> {\n     }\n \n     pub fn rewrite(&self, node: &SyntaxNode) -> SyntaxNode {\n-        if self.f.is_none() && self.replacements.is_empty() {\n+        if self.f.is_none() && self.replacements.is_empty() && self.insertions.is_empty() {\n             return node.clone();\n         }\n         self.rewrite_children(node)\n@@ -346,14 +427,22 @@ impl<'a> SyntaxRewriter<'a> {\n     ///\n     /// Returns `None` when there are no replacements.\n     pub fn rewrite_root(&self) -> Option<SyntaxNode> {\n+        fn element_to_node_or_parent(element: &SyntaxElement) -> SyntaxNode {\n+            match element {\n+                SyntaxElement::Node(it) => it.clone(),\n+                SyntaxElement::Token(it) => it.parent(),\n+            }\n+        }\n+\n         assert!(self.f.is_none());\n         self.replacements\n             .keys()\n-            .map(|element| match element {\n-                SyntaxElement::Node(it) => it.clone(),\n-                SyntaxElement::Token(it) => it.parent(),\n-            })\n-            // If we only have one replacement, we must return its parent node, since `rewrite` does\n+            .map(element_to_node_or_parent)\n+            .chain(self.insertions.keys().map(|pos| match pos {\n+                InsertPos::FirstChildOf(it) => it.clone(),\n+                InsertPos::Before(it) | InsertPos::After(it) => element_to_node_or_parent(it),\n+            }))\n+            // If we only have one replacement/insertion, we must return its parent node, since `rewrite` does\n             // not replace the node passed to it.\n             .map(|it| it.parent().unwrap_or(it))\n             .fold1(|a, b| least_common_ancestor(&a, &b).unwrap())\n@@ -367,9 +456,16 @@ impl<'a> SyntaxRewriter<'a> {\n         self.replacements.get(element).cloned()\n     }\n \n+    fn insertions(&self, pos: &InsertPos) -> Option<impl Iterator<Item = SyntaxElement> + '_> {\n+        self.insertions.get(pos).map(|insertions| insertions.iter().cloned())\n+    }\n+\n     fn rewrite_children(&self, node: &SyntaxNode) -> SyntaxNode {\n         //  FIXME: this could be made much faster.\n         let mut new_children = Vec::new();\n+        if let Some(elements) = self.insertions(&InsertPos::FirstChildOf(node.clone())) {\n+            new_children.extend(elements.map(element_to_green));\n+        }\n         for child in node.children_with_tokens() {\n             self.rewrite_self(&mut new_children, &child);\n         }\n@@ -381,36 +477,50 @@ impl<'a> SyntaxRewriter<'a> {\n         acc: &mut Vec<NodeOrToken<rowan::GreenNode, rowan::GreenToken>>,\n         element: &SyntaxElement,\n     ) {\n+        if let Some(elements) = self.insertions(&InsertPos::Before(element.clone())) {\n+            acc.extend(elements.map(element_to_green));\n+        }\n         if let Some(replacement) = self.replacement(&element) {\n             match replacement {\n-                Replacement::Single(NodeOrToken::Node(it)) => {\n-                    acc.push(NodeOrToken::Node(it.green().clone()))\n-                }\n-                Replacement::Single(NodeOrToken::Token(it)) => {\n-                    acc.push(NodeOrToken::Token(it.green().clone()))\n-                }\n+                Replacement::Single(element) => acc.push(element_to_green(element)),\n                 Replacement::Many(replacements) => {\n-                    acc.extend(replacements.iter().map(|it| match it {\n-                        NodeOrToken::Node(it) => NodeOrToken::Node(it.green().clone()),\n-                        NodeOrToken::Token(it) => NodeOrToken::Token(it.green().clone()),\n-                    }))\n+                    acc.extend(replacements.into_iter().map(element_to_green))\n                 }\n                 Replacement::Delete => (),\n             };\n-            return;\n+        } else {\n+            match element {\n+                NodeOrToken::Token(it) => acc.push(NodeOrToken::Token(it.green().clone())),\n+                NodeOrToken::Node(it) => {\n+                    acc.push(NodeOrToken::Node(self.rewrite_children(it).green().clone()));\n+                }\n+            }\n         }\n-        let res = match element {\n-            NodeOrToken::Token(it) => NodeOrToken::Token(it.green().clone()),\n-            NodeOrToken::Node(it) => NodeOrToken::Node(self.rewrite_children(it).green().clone()),\n-        };\n-        acc.push(res)\n+        if let Some(elements) = self.insertions(&InsertPos::After(element.clone())) {\n+            acc.extend(elements.map(element_to_green));\n+        }\n+    }\n+}\n+\n+fn element_to_green(element: SyntaxElement) -> NodeOrToken<rowan::GreenNode, rowan::GreenToken> {\n+    match element {\n+        NodeOrToken::Node(it) => NodeOrToken::Node(it.green().clone()),\n+        NodeOrToken::Token(it) => NodeOrToken::Token(it.green().clone()),\n     }\n }\n \n impl ops::AddAssign for SyntaxRewriter<'_> {\n     fn add_assign(&mut self, rhs: SyntaxRewriter) {\n         assert!(rhs.f.is_none());\n-        self.replacements.extend(rhs.replacements)\n+        self.replacements.extend(rhs.replacements);\n+        for (pos, insertions) in rhs.insertions.into_iter() {\n+            match self.insertions.entry(pos) {\n+                indexmap::map::Entry::Occupied(mut occupied) => {\n+                    occupied.get_mut().extend(insertions)\n+                }\n+                indexmap::map::Entry::Vacant(vacant) => drop(vacant.insert(insertions)),\n+            }\n+        }\n     }\n }\n "}]}