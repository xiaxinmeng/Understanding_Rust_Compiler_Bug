{"sha": "e42521aa58be928dd62b5450c443368d29ab6a65", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU0MjUyMWFhNThiZTkyOGRkNjJiNTQ1MGM0NDMzNjhkMjlhYjZhNjU=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-03-27T17:07:41Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-03-27T17:07:41Z"}, "message": "rollup merge of #23535: pnkfelix/fsk-filling-drop\n\nReplace zeroing-on-drop with filling-on-drop.\n\nThis is meant to set the stage for removing *all* zeroing and filling (on drop) in the future.\n\nNote that the code is meant to be entirely abstract with respect to the particular values used for the drop flags: the final commit demonstrates how to go from zeroing-on-drop to filling-on-drop by changing the value of three constants (in two files).\n\nSee further discussion on the internals thread:\n  http://internals.rust-lang.org/t/attention-hackers-filling-drop/1715/11\n\n[breaking-change] especially for structs / enums using `#[unsafe_no_drop_flag]`.", "tree": {"sha": "1324a267ef6c9c47d1abd33c4540aa1103d11767", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1324a267ef6c9c47d1abd33c4540aa1103d11767"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e42521aa58be928dd62b5450c443368d29ab6a65", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e42521aa58be928dd62b5450c443368d29ab6a65", "html_url": "https://github.com/rust-lang/rust/commit/e42521aa58be928dd62b5450c443368d29ab6a65", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e42521aa58be928dd62b5450c443368d29ab6a65/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0e5052c396f6692406c58a21bf75db0ec5344c4b", "url": "https://api.github.com/repos/rust-lang/rust/commits/0e5052c396f6692406c58a21bf75db0ec5344c4b", "html_url": "https://github.com/rust-lang/rust/commit/0e5052c396f6692406c58a21bf75db0ec5344c4b"}, {"sha": "b68ca84ef162943286c315126b52e1a6c3f49b3a", "url": "https://api.github.com/repos/rust-lang/rust/commits/b68ca84ef162943286c315126b52e1a6c3f49b3a", "html_url": "https://github.com/rust-lang/rust/commit/b68ca84ef162943286c315126b52e1a6c3f49b3a"}], "stats": {"total": 700, "additions": 637, "deletions": 63}, "files": [{"sha": "e107d19a87c04dcf1c3c666619511ca7cbcbfadf", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e42521aa58be928dd62b5450c443368d29ab6a65/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e42521aa58be928dd62b5450c443368d29ab6a65/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=e42521aa58be928dd62b5450c443368d29ab6a65", "patch": "@@ -354,7 +354,8 @@ impl<T> Drop for Arc<T> {\n         // more than once (but it is guaranteed to be zeroed after the first if\n         // it's run more than once)\n         let ptr = *self._ptr;\n-        if ptr.is_null() { return }\n+        // if ptr.is_null() { return }\n+        if ptr.is_null() || ptr as usize == mem::POST_DROP_USIZE { return }\n \n         // Because `fetch_sub` is already atomic, we do not need to synchronize\n         // with other threads unless we are going to delete the object. This\n@@ -485,7 +486,7 @@ impl<T> Drop for Weak<T> {\n         let ptr = *self._ptr;\n \n         // see comments above for why this check is here\n-        if ptr.is_null() { return }\n+        if ptr.is_null() || ptr as usize == mem::POST_DROP_USIZE { return }\n \n         // If we find out that we were the last weak pointer, then its time to\n         // deallocate the data entirely. See the discussion in Arc::drop() about"}, {"sha": "b92dfa9117e6beb5745f97c106a758ebfedef1fe", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e42521aa58be928dd62b5450c443368d29ab6a65/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e42521aa58be928dd62b5450c443368d29ab6a65/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=e42521aa58be928dd62b5450c443368d29ab6a65", "patch": "@@ -75,7 +75,7 @@\n #![feature(box_syntax)]\n #![feature(optin_builtin_traits)]\n #![feature(unboxed_closures)]\n-#![feature(unsafe_no_drop_flag)]\n+#![feature(unsafe_no_drop_flag, filling_drop)]\n #![feature(core)]\n #![feature(unique)]\n #![cfg_attr(test, feature(test, alloc, rustc_private))]"}, {"sha": "e0d7e32ecf504b0cff31bde6ac1f6790e12e181a", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e42521aa58be928dd62b5450c443368d29ab6a65/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e42521aa58be928dd62b5450c443368d29ab6a65/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=e42521aa58be928dd62b5450c443368d29ab6a65", "patch": "@@ -160,7 +160,7 @@ use core::default::Default;\n use core::fmt;\n use core::hash::{Hasher, Hash};\n use core::marker;\n-use core::mem::{min_align_of, size_of, forget};\n+use core::mem::{self, min_align_of, size_of, forget};\n use core::nonzero::NonZero;\n use core::ops::{Deref, Drop};\n use core::option::Option;\n@@ -407,7 +407,7 @@ impl<T> Drop for Rc<T> {\n     fn drop(&mut self) {\n         unsafe {\n             let ptr = *self._ptr;\n-            if !ptr.is_null() {\n+            if !ptr.is_null() && ptr as usize != mem::POST_DROP_USIZE {\n                 self.dec_strong();\n                 if self.strong() == 0 {\n                     ptr::read(&**self); // destroy the contained object\n@@ -718,7 +718,7 @@ impl<T> Drop for Weak<T> {\n     fn drop(&mut self) {\n         unsafe {\n             let ptr = *self._ptr;\n-            if !ptr.is_null() {\n+            if !ptr.is_null() && ptr as usize != mem::POST_DROP_USIZE {\n                 self.dec_weak();\n                 // the weak count starts at 1, and will only go to zero if all\n                 // the strong pointers have disappeared."}, {"sha": "bf57d745a0dcea07b244f2393d1c9bb8b5f77987", "filename": "src/libcollections/btree/node.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e42521aa58be928dd62b5450c443368d29ab6a65/src%2Flibcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e42521aa58be928dd62b5450c443368d29ab6a65/src%2Flibcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fnode.rs?ref=e42521aa58be928dd62b5450c443368d29ab6a65", "patch": "@@ -280,9 +280,11 @@ impl<T> Drop for RawItems<T> {\n #[unsafe_destructor]\n impl<K, V> Drop for Node<K, V> {\n     fn drop(&mut self) {\n-        if self.keys.is_null() {\n+        if self.keys.is_null() ||\n+            (unsafe { self.keys.get() as *const K as usize == mem::POST_DROP_USIZE })\n+        {\n             // Since we have #[unsafe_no_drop_flag], we have to watch\n-            // out for a null value being stored in self.keys. (Using\n+            // out for the sentinel value being stored in self.keys. (Using\n             // null is technically a violation of the `Unique`\n             // requirements, though.)\n             return;"}, {"sha": "e32ee34887cec02eea13fed66b2072c3edbce17f", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e42521aa58be928dd62b5450c443368d29ab6a65/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e42521aa58be928dd62b5450c443368d29ab6a65/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=e42521aa58be928dd62b5450c443368d29ab6a65", "patch": "@@ -36,7 +36,7 @@\n #![feature(unicode)]\n #![feature(unsafe_destructor)]\n #![feature(unique)]\n-#![feature(unsafe_no_drop_flag)]\n+#![feature(unsafe_no_drop_flag, filling_drop)]\n #![feature(step_by)]\n #![feature(str_char)]\n #![feature(convert)]"}, {"sha": "cf0163f3ef4a6b674d3d2423cc3ba457e01e9fdc", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e42521aa58be928dd62b5450c443368d29ab6a65/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e42521aa58be928dd62b5450c443368d29ab6a65/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=e42521aa58be928dd62b5450c443368d29ab6a65", "patch": "@@ -1694,7 +1694,7 @@ impl<T> Drop for Vec<T> {\n     fn drop(&mut self) {\n         // This is (and should always remain) a no-op if the fields are\n         // zeroed (when moving out, because of #[unsafe_no_drop_flag]).\n-        if self.cap != 0 {\n+        if self.cap != 0 && self.cap != mem::POST_DROP_USIZE {\n             unsafe {\n                 for x in &*self {\n                     ptr::read(x);\n@@ -1977,7 +1977,7 @@ impl<'a, T> ExactSizeIterator for Drain<'a, T> {}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Drop for Drain<'a, T> {\n     fn drop(&mut self) {\n-        // self.ptr == self.end == null if drop has already been called,\n+        // self.ptr == self.end == mem::POST_DROP_USIZE if drop has already been called,\n         // so we can use #[unsafe_no_drop_flag].\n \n         // destroy the remaining elements"}, {"sha": "eb74a41db55e354f43641559f796d514ad0db26d", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e42521aa58be928dd62b5450c443368d29ab6a65/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e42521aa58be928dd62b5450c443368d29ab6a65/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=e42521aa58be928dd62b5450c443368d29ab6a65", "patch": "@@ -191,13 +191,35 @@ extern \"rust-intrinsic\" {\n     /// crate it is invoked in.\n     pub fn type_id<T: ?Sized + 'static>() -> u64;\n \n+    /// Create a value initialized to so that its drop flag,\n+    /// if any, says that it has been dropped.\n+    ///\n+    /// `init_dropped` is unsafe because it returns a datum with all\n+    /// of its bytes set to the drop flag, which generally does not\n+    /// correspond to a valid value.\n+    ///\n+    /// This intrinsic is likely to be deprecated in the future when\n+    /// Rust moves to non-zeroing dynamic drop (and thus removes the\n+    /// embedded drop flags that are being established by this\n+    /// intrinsic).\n+    #[cfg(not(stage0))]\n+    pub fn init_dropped<T>() -> T;\n+\n     /// Create a value initialized to zero.\n     ///\n     /// `init` is unsafe because it returns a zeroed-out datum,\n-    /// which is unsafe unless T is Copy.\n+    /// which is unsafe unless T is `Copy`.  Also, even if T is\n+    /// `Copy`, an all-zero value may not correspond to any legitimate\n+    /// state for the type in question.\n     pub fn init<T>() -> T;\n \n     /// Create an uninitialized value.\n+    ///\n+    /// `uninit` is unsafe because there is no guarantee of what its\n+    /// contents are. In particular its drop-flag may be set to any\n+    /// state, which means it may claim either dropped or\n+    /// undropped. In the general case one must use `ptr::write` to\n+    /// initialize memory previous set to the result of `uninit`.\n     pub fn uninit<T>() -> T;\n \n     /// Move a value out of scope without running drop glue."}, {"sha": "434a5d17a9254cd6cf1627cd7d2129f81808621c", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/e42521aa58be928dd62b5450c443368d29ab6a65/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e42521aa58be928dd62b5450c443368d29ab6a65/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=e42521aa58be928dd62b5450c443368d29ab6a65", "patch": "@@ -158,6 +158,32 @@ pub unsafe fn zeroed<T>() -> T {\n     intrinsics::init()\n }\n \n+/// Create a value initialized to an unspecified series of bytes.\n+///\n+/// The byte sequence usually indicates that the value at the memory\n+/// in question has been dropped. Thus, *if* T carries a drop flag,\n+/// any associated destructor will not be run when the value falls out\n+/// of scope.\n+///\n+/// Some code at one time used the `zeroed` function above to\n+/// accomplish this goal.\n+///\n+/// This function is expected to be deprecated with the transition\n+/// to non-zeroing drop.\n+#[inline]\n+#[unstable(feature = \"filling_drop\")]\n+pub unsafe fn dropped<T>() -> T {\n+    #[cfg(stage0)]\n+    #[inline(always)]\n+    unsafe fn dropped_impl<T>() -> T { zeroed() }\n+\n+    #[cfg(not(stage0))]\n+    #[inline(always)]\n+    unsafe fn dropped_impl<T>() -> T { intrinsics::init_dropped() }\n+\n+    dropped_impl()\n+}\n+\n /// Create an uninitialized value.\n ///\n /// Care must be taken when using this function, if the type `T` has a destructor and the value\n@@ -291,6 +317,49 @@ pub fn replace<T>(dest: &mut T, mut src: T) -> T {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn drop<T>(_x: T) { }\n \n+macro_rules! repeat_u8_as_u32 {\n+    ($name:expr) => { (($name as u32) << 24 |\n+                       ($name as u32) << 16 |\n+                       ($name as u32) <<  8 |\n+                       ($name as u32)) }\n+}\n+macro_rules! repeat_u8_as_u64 {\n+    ($name:expr) => { ((repeat_u8_as_u32!($name) as u64) << 32 |\n+                       (repeat_u8_as_u32!($name) as u64)) }\n+}\n+\n+// NOTE: Keep synchronized with values used in librustc_trans::trans::adt.\n+//\n+// In particular, the POST_DROP_U8 marker must never equal the\n+// DTOR_NEEDED_U8 marker.\n+//\n+// For a while pnkfelix was using 0xc1 here.\n+// But having the sign bit set is a pain, so 0x1d is probably better.\n+//\n+// And of course, 0x00 brings back the old world of zero'ing on drop.\n+#[cfg(not(stage0))] #[unstable(feature = \"filling_drop\")]\n+pub const POST_DROP_U8: u8 = 0x1d;\n+#[cfg(not(stage0))] #[unstable(feature = \"filling_drop\")]\n+pub const POST_DROP_U32: u32 = repeat_u8_as_u32!(POST_DROP_U8);\n+#[cfg(not(stage0))]  #[unstable(feature = \"filling_drop\")]\n+pub const POST_DROP_U64: u64 = repeat_u8_as_u64!(POST_DROP_U8);\n+\n+#[cfg(target_pointer_width = \"32\")]\n+#[cfg(not(stage0))]  #[unstable(feature = \"filling_drop\")]\n+pub const POST_DROP_USIZE: usize = POST_DROP_U32 as usize;\n+#[cfg(target_pointer_width = \"64\")]\n+#[cfg(not(stage0))]  #[unstable(feature = \"filling_drop\")]\n+pub const POST_DROP_USIZE: usize = POST_DROP_U64 as usize;\n+\n+#[cfg(stage0)]  #[unstable(feature = \"filling_drop\")]\n+pub const POST_DROP_U8: u8 = 0;\n+#[cfg(stage0)]  #[unstable(feature = \"filling_drop\")]\n+pub const POST_DROP_U32: u32 = 0;\n+#[cfg(stage0)]  #[unstable(feature = \"filling_drop\")]\n+pub const POST_DROP_U64: u64 = 0;\n+#[cfg(stage0)]  #[unstable(feature = \"filling_drop\")]\n+pub const POST_DROP_USIZE: usize = 0;\n+\n /// Interprets `src` as `&U`, and then reads `src` without moving the contained value.\n ///\n /// This function will unsafely assume the pointer `src` is valid for `sizeof(U)` bytes by"}, {"sha": "07d018dea929651d983768c8b1f3e940ca99515f", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e42521aa58be928dd62b5450c443368d29ab6a65/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e42521aa58be928dd62b5450c443368d29ab6a65/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=e42521aa58be928dd62b5450c443368d29ab6a65", "patch": "@@ -230,6 +230,21 @@ pub unsafe fn read_and_zero<T>(dest: *mut T) -> T {\n     tmp\n }\n \n+/// Variant of read_and_zero that writes the specific drop-flag byte\n+/// (which may be more appropriate than zero).\n+#[inline(always)]\n+#[unstable(feature = \"core\",\n+           reason = \"may play a larger role in std::ptr future extensions\")]\n+pub unsafe fn read_and_drop<T>(dest: *mut T) -> T {\n+    // Copy the data out from `dest`:\n+    let tmp = read(&*dest);\n+\n+    // Now mark `dest` as dropped:\n+    write_bytes(dest, mem::POST_DROP_U8, 1);\n+\n+    tmp\n+}\n+\n /// Overwrites a memory location with the given value without reading or\n /// dropping the old value.\n ///"}, {"sha": "578d5dd83d58463e7a59289b01d11c2f4f0595ed", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e42521aa58be928dd62b5450c443368d29ab6a65/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e42521aa58be928dd62b5450c443368d29ab6a65/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=e42521aa58be928dd62b5450c443368d29ab6a65", "patch": "@@ -604,6 +604,8 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n           \"Print the size of enums and their variants\"),\n     force_overflow_checks: Option<bool> = (None, parse_opt_bool,\n           \"Force overflow checks on or off\"),\n+    force_dropflag_checks: Option<bool> = (None, parse_opt_bool,\n+          \"Force drop flag checks on or off\"),\n }\n \n pub fn default_lib_output() -> CrateType {"}, {"sha": "d583eef0e0f7b0ba9f529e910601b33a181d15bd", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e42521aa58be928dd62b5450c443368d29ab6a65/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e42521aa58be928dd62b5450c443368d29ab6a65/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=e42521aa58be928dd62b5450c443368d29ab6a65", "patch": "@@ -1528,7 +1528,7 @@ pub fn store_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let scope = cleanup::var_scope(tcx, p_id);\n             bcx = mk_binding_alloca(\n                 bcx, p_id, &path1.node, scope, (),\n-                |(), bcx, llval, ty| { zero_mem(bcx, llval, ty); bcx });\n+                |(), bcx, llval, ty| { drop_done_fill_mem(bcx, llval, ty); bcx });\n         });\n         bcx\n     }"}, {"sha": "dddc2d2be48b041339d281d2f0d9cbdf2ccc1ebc", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 75, "deletions": 23, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/e42521aa58be928dd62b5450c443368d29ab6a65/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e42521aa58be928dd62b5450c443368d29ab6a65/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=e42521aa58be928dd62b5450c443368d29ab6a65", "patch": "@@ -81,14 +81,18 @@ pub enum Repr<'tcx> {\n     /// Structs with destructors need a dynamic destroyedness flag to\n     /// avoid running the destructor too many times; this is included\n     /// in the `Struct` if present.\n-    Univariant(Struct<'tcx>, bool),\n+    /// (The flag if nonzero, represents the initialization value to use;\n+    ///  if zero, then use no flag at all.)\n+    Univariant(Struct<'tcx>, u8),\n     /// General-case enums: for each case there is a struct, and they\n     /// all start with a field for the discriminant.\n     ///\n     /// Types with destructors need a dynamic destroyedness flag to\n     /// avoid running the destructor too many times; the last argument\n     /// indicates whether such a flag is present.\n-    General(IntType, Vec<Struct<'tcx>>, bool),\n+    /// (The flag, if nonzero, represents the initialization value to use;\n+    ///  if zero, then use no flag at all.)\n+    General(IntType, Vec<Struct<'tcx>>, u8),\n     /// Two cases distinguished by a nullable pointer: the case with discriminant\n     /// `nndiscr` must have single field which is known to be nonnull due to its type.\n     /// The other case is known to be zero sized. Hence we represent the enum\n@@ -151,11 +155,59 @@ pub fn represent_type<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     repr\n }\n \n+macro_rules! repeat_u8_as_u32 {\n+    ($name:expr) => { (($name as u32) << 24 |\n+                       ($name as u32) << 16 |\n+                       ($name as u32) <<  8 |\n+                       ($name as u32)) }\n+}\n+macro_rules! repeat_u8_as_u64 {\n+    ($name:expr) => { ((repeat_u8_as_u32!($name) as u64) << 32 |\n+                       (repeat_u8_as_u32!($name) as u64)) }\n+}\n+\n+pub const DTOR_NEEDED: u8 = 0xd4;\n+pub const DTOR_NEEDED_U32: u32 = repeat_u8_as_u32!(DTOR_NEEDED);\n+pub const DTOR_NEEDED_U64: u64 = repeat_u8_as_u64!(DTOR_NEEDED);\n+#[allow(dead_code)]\n+pub fn dtor_needed_usize(ccx: &CrateContext) -> usize {\n+    match &ccx.tcx().sess.target.target.target_pointer_width[..] {\n+        \"32\" => DTOR_NEEDED_U32 as usize,\n+        \"64\" => DTOR_NEEDED_U64 as usize,\n+        tws => panic!(\"Unsupported target word size for int: {}\", tws),\n+    }\n+}\n+\n+pub const DTOR_DONE: u8 = 0x1d;\n+pub const DTOR_DONE_U32: u32 = repeat_u8_as_u32!(DTOR_DONE);\n+pub const DTOR_DONE_U64: u64 = repeat_u8_as_u64!(DTOR_DONE);\n+#[allow(dead_code)]\n+pub fn dtor_done_usize(ccx: &CrateContext) -> usize {\n+    match &ccx.tcx().sess.target.target.target_pointer_width[..] {\n+        \"32\" => DTOR_DONE_U32 as usize,\n+        \"64\" => DTOR_DONE_U64 as usize,\n+        tws => panic!(\"Unsupported target word size for int: {}\", tws),\n+    }\n+}\n+\n+fn dtor_to_init_u8(dtor: bool) -> u8 {\n+    if dtor { DTOR_NEEDED } else { 0 }\n+}\n+\n+pub trait GetDtorType<'tcx> { fn dtor_type(&self) -> Ty<'tcx>; }\n+impl<'tcx> GetDtorType<'tcx> for ty::ctxt<'tcx> {\n+    fn dtor_type(&self) -> Ty<'tcx> { self.types.u8 }\n+}\n+\n+fn dtor_active(flag: u8) -> bool {\n+    flag != 0\n+}\n+\n fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                      t: Ty<'tcx>) -> Repr<'tcx> {\n     match t.sty {\n         ty::ty_tup(ref elems) => {\n-            Univariant(mk_struct(cx, &elems[..], false, t), false)\n+            Univariant(mk_struct(cx, &elems[..], false, t), 0)\n         }\n         ty::ty_struct(def_id, substs) => {\n             let fields = ty::lookup_struct_fields(cx.tcx(), def_id);\n@@ -165,15 +217,15 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             }).collect::<Vec<_>>();\n             let packed = ty::lookup_packed(cx.tcx(), def_id);\n             let dtor = ty::ty_dtor(cx.tcx(), def_id).has_drop_flag();\n-            if dtor { ftys.push(cx.tcx().types.bool); }\n+            if dtor { ftys.push(cx.tcx().dtor_type()); }\n \n-            Univariant(mk_struct(cx, &ftys[..], packed, t), dtor)\n+            Univariant(mk_struct(cx, &ftys[..], packed, t), dtor_to_init_u8(dtor))\n         }\n         ty::ty_closure(def_id, substs) => {\n             let typer = NormalizingClosureTyper::new(cx.tcx());\n             let upvars = typer.closure_upvars(def_id, substs).unwrap();\n             let upvar_types = upvars.iter().map(|u| u.ty).collect::<Vec<_>>();\n-            Univariant(mk_struct(cx, &upvar_types[..], false, t), false)\n+            Univariant(mk_struct(cx, &upvar_types[..], false, t), 0)\n         }\n         ty::ty_enum(def_id, substs) => {\n             let cases = get_cases(cx.tcx(), def_id, substs);\n@@ -186,9 +238,9 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 // Uninhabitable; represent as unit\n                 // (Typechecking will reject discriminant-sizing attrs.)\n                 assert_eq!(hint, attr::ReprAny);\n-                let ftys = if dtor { vec!(cx.tcx().types.bool) } else { vec!() };\n+                let ftys = if dtor { vec!(cx.tcx().dtor_type()) } else { vec!() };\n                 return Univariant(mk_struct(cx, &ftys[..], false, t),\n-                                  dtor);\n+                                  dtor_to_init_u8(dtor));\n             }\n \n             if !dtor && cases.iter().all(|c| c.tys.len() == 0) {\n@@ -218,9 +270,9 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 // (Typechecking will reject discriminant-sizing attrs.)\n                 assert_eq!(hint, attr::ReprAny);\n                 let mut ftys = cases[0].tys.clone();\n-                if dtor { ftys.push(cx.tcx().types.bool); }\n+                if dtor { ftys.push(cx.tcx().dtor_type()); }\n                 return Univariant(mk_struct(cx, &ftys[..], false, t),\n-                                  dtor);\n+                                  dtor_to_init_u8(dtor));\n             }\n \n             if !dtor && cases.len() == 2 && hint == attr::ReprAny {\n@@ -266,7 +318,7 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             let fields : Vec<_> = cases.iter().map(|c| {\n                 let mut ftys = vec!(ty_of_inttype(cx.tcx(), min_ity));\n                 ftys.push_all(&c.tys);\n-                if dtor { ftys.push(cx.tcx().types.bool); }\n+                if dtor { ftys.push(cx.tcx().dtor_type()); }\n                 mk_struct(cx, &ftys, false, t)\n             }).collect();\n \n@@ -319,13 +371,13 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             let fields : Vec<_> = cases.iter().map(|c| {\n                 let mut ftys = vec!(ty_of_inttype(cx.tcx(), ity));\n                 ftys.push_all(&c.tys);\n-                if dtor { ftys.push(cx.tcx().types.bool); }\n+                if dtor { ftys.push(cx.tcx().dtor_type()); }\n                 mk_struct(cx, &ftys[..], false, t)\n             }).collect();\n \n             ensure_enum_fits_in_address_space(cx, &fields[..], t);\n \n-            General(ity, fields, dtor)\n+            General(ity, fields, dtor_to_init_u8(dtor))\n         }\n         _ => cx.sess().bug(&format!(\"adt::represent_type called on non-ADT type: {}\",\n                            ty_to_string(cx.tcx(), t)))\n@@ -830,18 +882,18 @@ pub fn trans_set_discr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, r: &Repr<'tcx>,\n                   val)\n         }\n         General(ity, ref cases, dtor) => {\n-            if dtor {\n+            if dtor_active(dtor) {\n                 let ptr = trans_field_ptr(bcx, r, val, discr,\n                                           cases[discr as uint].fields.len() - 2);\n-                Store(bcx, C_u8(bcx.ccx(), 1), ptr);\n+                Store(bcx, C_u8(bcx.ccx(), DTOR_NEEDED as usize), ptr);\n             }\n             Store(bcx, C_integral(ll_inttype(bcx.ccx(), ity), discr as u64, true),\n                   GEPi(bcx, val, &[0, 0]))\n         }\n         Univariant(ref st, dtor) => {\n             assert_eq!(discr, 0);\n-            if dtor {\n-                Store(bcx, C_u8(bcx.ccx(), 1),\n+            if dtor_active(dtor) {\n+                Store(bcx, C_u8(bcx.ccx(), DTOR_NEEDED as usize),\n                     GEPi(bcx, val, &[0, st.fields.len() - 1]));\n             }\n         }\n@@ -875,10 +927,10 @@ pub fn num_args(r: &Repr, discr: Disr) -> uint {\n         CEnum(..) => 0,\n         Univariant(ref st, dtor) => {\n             assert_eq!(discr, 0);\n-            st.fields.len() - (if dtor { 1 } else { 0 })\n+            st.fields.len() - (if dtor_active(dtor) { 1 } else { 0 })\n         }\n         General(_, ref cases, dtor) => {\n-            cases[discr as uint].fields.len() - 1 - (if dtor { 1 } else { 0 })\n+            cases[discr as uint].fields.len() - 1 - (if dtor_active(dtor) { 1 } else { 0 })\n         }\n         RawNullablePointer { nndiscr, ref nullfields, .. } => {\n             if discr == nndiscr { 1 } else { nullfields.len() }\n@@ -992,17 +1044,17 @@ pub fn trans_drop_flag_ptr<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>, r: &Repr<'tcx\n                                        -> datum::DatumBlock<'blk, 'tcx, datum::Expr>\n {\n     let tcx = bcx.tcx();\n-    let ptr_ty = ty::mk_imm_ptr(bcx.tcx(), tcx.types.bool);\n+    let ptr_ty = ty::mk_imm_ptr(bcx.tcx(), tcx.dtor_type());\n     match *r {\n-        Univariant(ref st, true) => {\n+        Univariant(ref st, dtor) if dtor_active(dtor) => {\n             let flag_ptr = GEPi(bcx, val, &[0, st.fields.len() - 1]);\n             datum::immediate_rvalue_bcx(bcx, flag_ptr, ptr_ty).to_expr_datumblock()\n         }\n-        General(_, _, true) => {\n+        General(_, _, dtor) if dtor_active(dtor) => {\n             let fcx = bcx.fcx;\n             let custom_cleanup_scope = fcx.push_custom_cleanup_scope();\n             let scratch = unpack_datum!(bcx, datum::lvalue_scratch_datum(\n-                bcx, tcx.types.bool, \"drop_flag\",\n+                bcx, tcx.dtor_type(), \"drop_flag\",\n                 cleanup::CustomScope(custom_cleanup_scope), (), |_, bcx, _| bcx\n             ));\n             bcx = fold_variants(bcx, r, val, |variant_cx, st, value| {"}, {"sha": "f482e4fa72b84531c67ac9d1a3897d46cdede060", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 23, "deletions": 9, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/e42521aa58be928dd62b5450c443368d29ab6a65/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e42521aa58be928dd62b5450c443368d29ab6a65/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=e42521aa58be928dd62b5450c443368d29ab6a65", "patch": "@@ -1146,20 +1146,27 @@ pub fn memcpy_ty<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     }\n }\n \n-pub fn zero_mem<'blk, 'tcx>(cx: Block<'blk, 'tcx>, llptr: ValueRef, t: Ty<'tcx>) {\n+pub fn drop_done_fill_mem<'blk, 'tcx>(cx: Block<'blk, 'tcx>, llptr: ValueRef, t: Ty<'tcx>) {\n     if cx.unreachable.get() { return; }\n-    let _icx = push_ctxt(\"zero_mem\");\n+    let _icx = push_ctxt(\"drop_done_fill_mem\");\n     let bcx = cx;\n-    memzero(&B(bcx), llptr, t);\n+    memfill(&B(bcx), llptr, t, adt::DTOR_DONE);\n }\n \n-// Always use this function instead of storing a zero constant to the memory\n-// in question. If you store a zero constant, LLVM will drown in vreg\n+pub fn init_zero_mem<'blk, 'tcx>(cx: Block<'blk, 'tcx>, llptr: ValueRef, t: Ty<'tcx>) {\n+    if cx.unreachable.get() { return; }\n+    let _icx = push_ctxt(\"init_zero_mem\");\n+    let bcx = cx;\n+    memfill(&B(bcx), llptr, t, 0);\n+}\n+\n+// Always use this function instead of storing a constant byte to the memory\n+// in question. e.g. if you store a zero constant, LLVM will drown in vreg\n // allocation for large data structures, and the generated code will be\n // awful. (A telltale sign of this is large quantities of\n // `mov [byte ptr foo],0` in the generated code.)\n-fn memzero<'a, 'tcx>(b: &Builder<'a, 'tcx>, llptr: ValueRef, ty: Ty<'tcx>) {\n-    let _icx = push_ctxt(\"memzero\");\n+fn memfill<'a, 'tcx>(b: &Builder<'a, 'tcx>, llptr: ValueRef, ty: Ty<'tcx>, byte: u8) {\n+    let _icx = push_ctxt(\"memfill\");\n     let ccx = b.ccx;\n \n     let llty = type_of::type_of(ccx, ty);\n@@ -1172,7 +1179,7 @@ fn memzero<'a, 'tcx>(b: &Builder<'a, 'tcx>, llptr: ValueRef, ty: Ty<'tcx>) {\n \n     let llintrinsicfn = ccx.get_intrinsic(&intrinsic_key);\n     let llptr = b.pointercast(llptr, Type::i8(ccx).ptr_to());\n-    let llzeroval = C_u8(ccx, 0);\n+    let llzeroval = C_u8(ccx, byte as usize);\n     let size = machine::llsize_of(ccx, llty);\n     let align = C_i32(ccx, type_of::align_of(ccx, ty) as i32);\n     let volatile = C_bool(ccx, false);\n@@ -3022,6 +3029,12 @@ pub fn trans_crate<'tcx>(analysis: ty::CrateAnalysis<'tcx>)\n         tcx.sess.opts.debug_assertions\n     };\n \n+    let check_dropflag = if let Some(v) = tcx.sess.opts.debugging_opts.force_dropflag_checks {\n+        v\n+    } else {\n+        tcx.sess.opts.debug_assertions\n+    };\n+\n     // Before we touch LLVM, make sure that multithreading is enabled.\n     unsafe {\n         use std::sync::{Once, ONCE_INIT};\n@@ -3050,7 +3063,8 @@ pub fn trans_crate<'tcx>(analysis: ty::CrateAnalysis<'tcx>)\n                                              Sha256::new(),\n                                              link_meta.clone(),\n                                              reachable,\n-                                             check_overflow);\n+                                             check_overflow,\n+                                             check_dropflag);\n \n     {\n         let ccx = shared_ccx.get_ccx(0);"}, {"sha": "c7897f9b62ea5b16a62b48669fe570d036825e84", "filename": "src/librustc_trans/trans/cleanup.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e42521aa58be928dd62b5450c443368d29ab6a65/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e42521aa58be928dd62b5450c443368d29ab6a65/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs?ref=e42521aa58be928dd62b5450c443368d29ab6a65", "patch": "@@ -1015,7 +1015,7 @@ impl<'tcx> Cleanup<'tcx> for DropValue<'tcx> {\n             glue::drop_ty(bcx, self.val, self.ty, debug_loc)\n         };\n         if self.zero {\n-            base::zero_mem(bcx, self.val, self.ty);\n+            base::drop_done_fill_mem(bcx, self.val, self.ty);\n         }\n         bcx\n     }"}, {"sha": "b834050a6d929b2f71be37047c8ee0ca6188fe4d", "filename": "src/librustc_trans/trans/context.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e42521aa58be928dd62b5450c443368d29ab6a65/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e42521aa58be928dd62b5450c443368d29ab6a65/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs?ref=e42521aa58be928dd62b5450c443368d29ab6a65", "patch": "@@ -69,6 +69,7 @@ pub struct SharedCrateContext<'tcx> {\n     tcx: ty::ctxt<'tcx>,\n     stats: Stats,\n     check_overflow: bool,\n+    check_drop_flag_for_sanity: bool,\n \n     available_monomorphizations: RefCell<FnvHashSet<String>>,\n     available_drop_glues: RefCell<FnvHashMap<Ty<'tcx>, String>>,\n@@ -242,7 +243,8 @@ impl<'tcx> SharedCrateContext<'tcx> {\n                symbol_hasher: Sha256,\n                link_meta: LinkMeta,\n                reachable: NodeSet,\n-               check_overflow: bool)\n+               check_overflow: bool,\n+               check_drop_flag_for_sanity: bool)\n                -> SharedCrateContext<'tcx> {\n         let (metadata_llcx, metadata_llmod) = unsafe {\n             create_context_and_module(&tcx.sess, \"metadata\")\n@@ -271,6 +273,7 @@ impl<'tcx> SharedCrateContext<'tcx> {\n                 fn_stats: RefCell::new(Vec::new()),\n             },\n             check_overflow: check_overflow,\n+            check_drop_flag_for_sanity: check_drop_flag_for_sanity,\n             available_monomorphizations: RefCell::new(FnvHashSet()),\n             available_drop_glues: RefCell::new(FnvHashMap()),\n         };\n@@ -727,6 +730,13 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n     pub fn check_overflow(&self) -> bool {\n         self.shared.check_overflow\n     }\n+\n+    pub fn check_drop_flag_for_sanity(&self) -> bool {\n+        // This controls whether we emit a conditional llvm.debugtrap\n+        // guarded on whether the dropflag is one of its (two) valid\n+        // values.\n+        self.shared.check_drop_flag_for_sanity\n+    }\n }\n \n fn declare_intrinsic(ccx: &CrateContext, key: & &'static str) -> Option<ValueRef> {"}, {"sha": "399b7eb102e83cc478a67588e90e43375b51ce7d", "filename": "src/librustc_trans/trans/datum.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e42521aa58be928dd62b5450c443368d29ab6a65/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e42521aa58be928dd62b5450c443368d29ab6a65/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs?ref=e42521aa58be928dd62b5450c443368d29ab6a65", "patch": "@@ -307,8 +307,8 @@ impl KindOps for Lvalue {\n                               -> Block<'blk, 'tcx> {\n         let _icx = push_ctxt(\"<Lvalue as KindOps>::post_store\");\n         if bcx.fcx.type_needs_drop(ty) {\n-            // cancel cleanup of affine values by zeroing out\n-            let () = zero_mem(bcx, val, ty);\n+            // cancel cleanup of affine values by drop-filling the memory\n+            let () = drop_done_fill_mem(bcx, val, ty);\n             bcx\n         } else {\n             bcx"}, {"sha": "32b4d14177c2a050fbd512c4df1b0efe32b09448", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 41, "deletions": 5, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/e42521aa58be928dd62b5450c443368d29ab6a65/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e42521aa58be928dd62b5450c443368d29ab6a65/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=e42521aa58be928dd62b5450c443368d29ab6a65", "patch": "@@ -21,6 +21,7 @@ use middle::lang_items::ExchangeFreeFnLangItem;\n use middle::subst;\n use middle::subst::{Subst, Substs};\n use trans::adt;\n+use trans::adt::GetDtorType; // for tcx.dtor_type()\n use trans::base::*;\n use trans::build::*;\n use trans::callee;\n@@ -231,9 +232,31 @@ fn trans_struct_drop_flag<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         Load(bcx, llval)\n     };\n     let drop_flag = unpack_datum!(bcx, adt::trans_drop_flag_ptr(bcx, &*repr, struct_data));\n-    with_cond(bcx, load_ty(bcx, drop_flag.val, bcx.tcx().types.bool), |cx| {\n+    let loaded = load_ty(bcx, drop_flag.val, bcx.tcx().dtor_type());\n+    let drop_flag_llty = type_of(bcx.fcx.ccx, bcx.tcx().dtor_type());\n+    let init_val = C_integral(drop_flag_llty, adt::DTOR_NEEDED as u64, false);\n+\n+    let bcx = if !bcx.ccx().check_drop_flag_for_sanity() {\n+        bcx\n+    } else {\n+        let drop_flag_llty = type_of(bcx.fcx.ccx, bcx.tcx().dtor_type());\n+        let done_val = C_integral(drop_flag_llty, adt::DTOR_DONE as u64, false);\n+        let not_init = ICmp(bcx, llvm::IntNE, loaded, init_val, DebugLoc::None);\n+        let not_done = ICmp(bcx, llvm::IntNE, loaded, done_val, DebugLoc::None);\n+        let drop_flag_neither_initialized_nor_cleared =\n+            And(bcx, not_init, not_done, DebugLoc::None);\n+        with_cond(bcx, drop_flag_neither_initialized_nor_cleared, |cx| {\n+            let llfn = cx.ccx().get_intrinsic(&(\"llvm.debugtrap\"));\n+            Call(cx, llfn, &[], None, DebugLoc::None);\n+            cx\n+        })\n+    };\n+\n+    let drop_flag_dtor_needed = ICmp(bcx, llvm::IntEQ, loaded, init_val, DebugLoc::None);\n+    with_cond(bcx, drop_flag_dtor_needed, |cx| {\n         trans_struct_drop(cx, t, v0, dtor_did, class_did, substs)\n     })\n+\n }\n \n fn trans_struct_drop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n@@ -395,13 +418,24 @@ fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, t: Ty<'tcx>)\n                               -> Block<'blk, 'tcx> {\n     // NB: v0 is an *alias* of type t here, not a direct value.\n     let _icx = push_ctxt(\"make_drop_glue\");\n+\n+    // Only drop the value when it ... well, we used to check for\n+    // non-null, (and maybe we need to continue doing so), but we now\n+    // must definitely check for special bit-patterns corresponding to\n+    // the special dtor markings.\n+\n+    let inttype = Type::int(bcx.ccx());\n+    let dropped_pattern = C_integral(inttype, adt::dtor_done_usize(bcx.fcx.ccx) as u64, false);\n+\n     match t.sty {\n         ty::ty_uniq(content_ty) => {\n             if !type_is_sized(bcx.tcx(), content_ty) {\n                 let llval = GEPi(bcx, v0, &[0, abi::FAT_PTR_ADDR]);\n                 let llbox = Load(bcx, llval);\n-                let not_null = IsNotNull(bcx, llbox);\n-                with_cond(bcx, not_null, |bcx| {\n+                let llbox_as_usize = PtrToInt(bcx, llbox, Type::int(bcx.ccx()));\n+                let drop_flag_not_dropped_already =\n+                    ICmp(bcx, llvm::IntNE, llbox_as_usize, dropped_pattern, DebugLoc::None);\n+                with_cond(bcx, drop_flag_not_dropped_already, |bcx| {\n                     let bcx = drop_ty(bcx, v0, content_ty, DebugLoc::None);\n                     let info = GEPi(bcx, v0, &[0, abi::FAT_PTR_EXTRA]);\n                     let info = Load(bcx, info);\n@@ -420,8 +454,10 @@ fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, t: Ty<'tcx>)\n             } else {\n                 let llval = v0;\n                 let llbox = Load(bcx, llval);\n-                let not_null = IsNotNull(bcx, llbox);\n-                with_cond(bcx, not_null, |bcx| {\n+                let llbox_as_usize = PtrToInt(bcx, llbox, inttype);\n+                let drop_flag_not_dropped_already =\n+                    ICmp(bcx, llvm::IntNE, llbox_as_usize, dropped_pattern, DebugLoc::None);\n+                with_cond(bcx, drop_flag_not_dropped_already, |bcx| {\n                     let bcx = drop_ty(bcx, llbox, content_ty, DebugLoc::None);\n                     trans_exchange_free_ty(bcx, llbox, content_ty, DebugLoc::None)\n                 })"}, {"sha": "ee0274b182794b19c550ad7973d8f32ab832c2f7", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e42521aa58be928dd62b5450c443368d29ab6a65/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e42521aa58be928dd62b5450c443368d29ab6a65/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=e42521aa58be928dd62b5450c443368d29ab6a65", "patch": "@@ -359,11 +359,18 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                 &ccx.link_meta().crate_hash);\n             C_u64(ccx, hash)\n         }\n+        (_, \"init_dropped\") => {\n+            let tp_ty = *substs.types.get(FnSpace, 0);\n+            if !return_type_is_void(ccx, tp_ty) {\n+                drop_done_fill_mem(bcx, llresult, tp_ty);\n+            }\n+            C_nil(ccx)\n+        }\n         (_, \"init\") => {\n             let tp_ty = *substs.types.get(FnSpace, 0);\n             if !return_type_is_void(ccx, tp_ty) {\n                 // Just zero out the stack slot. (See comment on base::memzero for explanation)\n-                zero_mem(bcx, llresult, tp_ty);\n+                init_zero_mem(bcx, llresult, tp_ty);\n             }\n             C_nil(ccx)\n         }"}, {"sha": "2ec21ac26c42ca16d494af7380525ecf7c219e6b", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e42521aa58be928dd62b5450c443368d29ab6a65/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e42521aa58be928dd62b5450c443368d29ab6a65/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=e42521aa58be928dd62b5450c443368d29ab6a65", "patch": "@@ -5379,7 +5379,7 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n             \"breakpoint\" => (0, Vec::new(), ty::mk_nil(tcx)),\n             \"size_of\" |\n             \"pref_align_of\" | \"min_align_of\" => (1, Vec::new(), ccx.tcx.types.uint),\n-            \"init\" => (1, Vec::new(), param(ccx, 0)),\n+            \"init\" | \"init_dropped\" => (1, Vec::new(), param(ccx, 0)),\n             \"uninit\" => (1, Vec::new(), param(ccx, 0)),\n             \"forget\" => (1, vec!( param(ccx, 0) ), ty::mk_nil(tcx)),\n             \"transmute\" => (2, vec!( param(ccx, 0) ), param(ccx, 1)),"}, {"sha": "710f0fe19db8e6d36782a44700db27857982277a", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e42521aa58be928dd62b5450c443368d29ab6a65/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e42521aa58be928dd62b5450c443368d29ab6a65/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=e42521aa58be928dd62b5450c443368d29ab6a65", "patch": "@@ -985,7 +985,7 @@ impl<K: Clone, V: Clone> Clone for RawTable<K, V> {\n #[unsafe_destructor]\n impl<K, V> Drop for RawTable<K, V> {\n     fn drop(&mut self) {\n-        if self.capacity == 0 {\n+        if self.capacity == 0 || self.capacity == mem::POST_DROP_USIZE {\n             return;\n         }\n "}, {"sha": "3724b26b2020a8d3ada9291a4fa2775af304d62a", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e42521aa58be928dd62b5450c443368d29ab6a65/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e42521aa58be928dd62b5450c443368d29ab6a65/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=e42521aa58be928dd62b5450c443368d29ab6a65", "patch": "@@ -121,7 +121,7 @@\n #![feature(unboxed_closures)]\n #![feature(unicode)]\n #![feature(unsafe_destructor)]\n-#![feature(unsafe_no_drop_flag)]\n+#![feature(unsafe_no_drop_flag, filling_drop)]\n #![feature(macro_reexport)]\n #![feature(int_uint)]\n #![feature(unique)]"}, {"sha": "d4451cc7b71243ea87a0b847d2e6941412a7d1f1", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e42521aa58be928dd62b5450c443368d29ab6a65/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e42521aa58be928dd62b5450c443368d29ab6a65/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=e42521aa58be928dd62b5450c443368d29ab6a65", "patch": "@@ -40,7 +40,7 @@ impl<T> MoveMap<T> for Vec<T> {\n         for p in &mut self {\n             unsafe {\n                 // FIXME(#5016) this shouldn't need to zero to be safe.\n-                ptr::write(p, f(ptr::read_and_zero(p)));\n+                ptr::write(p, f(ptr::read_and_drop(p)));\n             }\n         }\n         self"}, {"sha": "7e0bcd3e1dc3f8a2229823209c8d47a9cb722bdc", "filename": "src/libsyntax/ptr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e42521aa58be928dd62b5450c443368d29ab6a65/src%2Flibsyntax%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e42521aa58be928dd62b5450c443368d29ab6a65/src%2Flibsyntax%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fptr.rs?ref=e42521aa58be928dd62b5450c443368d29ab6a65", "patch": "@@ -71,8 +71,8 @@ impl<T: 'static> P<T> {\n     {\n         unsafe {\n             let p = &mut *self.ptr;\n-            // FIXME(#5016) this shouldn't need to zero to be safe.\n-            ptr::write(p, f(ptr::read_and_zero(p)));\n+            // FIXME(#5016) this shouldn't need to drop-fill to be safe.\n+            ptr::write(p, f(ptr::read_and_drop(p)));\n         }\n         self\n     }"}, {"sha": "a93a488c1b5fd1a6d7dd01b9a8432e0bea4c99ac", "filename": "src/test/run-pass/box-of-array-of-drop-1.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/e42521aa58be928dd62b5450c443368d29ab6a65/src%2Ftest%2Frun-pass%2Fbox-of-array-of-drop-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e42521aa58be928dd62b5450c443368d29ab6a65/src%2Ftest%2Frun-pass%2Fbox-of-array-of-drop-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbox-of-array-of-drop-1.rs?ref=e42521aa58be928dd62b5450c443368d29ab6a65", "patch": "@@ -0,0 +1,52 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we cleanup a fixed size Box<[D; k]> properly when D has a\n+// destructor.\n+\n+use std::thread;\n+use std::sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT, Ordering};\n+\n+static LOG: AtomicUsize = ATOMIC_USIZE_INIT;\n+\n+struct D(u8);\n+\n+impl Drop for D {\n+    fn drop(&mut self) {\n+        println!(\"Dropping {}\", self.0);\n+        let old = LOG.load(Ordering::SeqCst);\n+        LOG.compare_and_swap(old, old << 4 | self.0 as usize, Ordering::SeqCst);\n+    }\n+}\n+\n+fn main() {\n+    fn die() -> D { panic!(\"Oh no\"); }\n+    let g = thread::spawn(|| {\n+        let _b1: Box<[D; 4]> = Box::new([D( 1), D( 2), D( 3), D( 4)]);\n+        let _b2: Box<[D; 4]> = Box::new([D( 5), D( 6), D( 7), D( 8)]);\n+        let _b3: Box<[D; 4]> = Box::new([D( 9), D(10), die(), D(12)]);\n+        let _b4: Box<[D; 4]> = Box::new([D(13), D(14), D(15), D(16)]);\n+    });\n+    assert!(g.join().is_err());\n+\n+    // When the panic occurs, we will be in the midst of constructing\n+    // the input to `_b3`.  Therefore, we drop the elements of the\n+    // partially filled array first, before we get around to dropping\n+    // the elements of `_b1` and _b2`.\n+\n+    // Issue 23222: The order in which the elements actually get\n+    // dropped is a little funky. See similar notes in nested-vec-3;\n+    // in essence, I would not be surprised if we change the ordering\n+    // given in `expect` in the future.\n+\n+    let expect = 0x__A_9__5_6_7_8__1_2_3_4;\n+    let actual = LOG.load(Ordering::SeqCst);\n+    assert!(actual == expect, \"expect: 0x{:x} actual: 0x{:x}\", expect, actual);\n+}"}, {"sha": "715571364c8def8e7a2ee389af3e7751a5629ed3", "filename": "src/test/run-pass/box-of-array-of-drop-2.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/e42521aa58be928dd62b5450c443368d29ab6a65/src%2Ftest%2Frun-pass%2Fbox-of-array-of-drop-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e42521aa58be928dd62b5450c443368d29ab6a65/src%2Ftest%2Frun-pass%2Fbox-of-array-of-drop-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbox-of-array-of-drop-2.rs?ref=e42521aa58be928dd62b5450c443368d29ab6a65", "patch": "@@ -0,0 +1,52 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we cleanup dynamic sized Box<[D]> properly when D has a\n+// destructor.\n+\n+use std::thread;\n+use std::sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT, Ordering};\n+\n+static LOG: AtomicUsize = ATOMIC_USIZE_INIT;\n+\n+struct D(u8);\n+\n+impl Drop for D {\n+    fn drop(&mut self) {\n+        println!(\"Dropping {}\", self.0);\n+        let old = LOG.load(Ordering::SeqCst);\n+        LOG.compare_and_swap(old, old << 4 | self.0 as usize, Ordering::SeqCst);\n+    }\n+}\n+\n+fn main() {\n+    fn die() -> D { panic!(\"Oh no\"); }\n+    let g = thread::spawn(|| {\n+        let _b1: Box<[D; 4]> = Box::new([D( 1), D( 2), D( 3), D( 4)]);\n+        let _b2: Box<[D; 4]> = Box::new([D( 5), D( 6), D( 7), D( 8)]);\n+        let _b3: Box<[D; 4]> = Box::new([D( 9), D(10), die(), D(12)]);\n+        let _b4: Box<[D; 4]> = Box::new([D(13), D(14), D(15), D(16)]);\n+    });\n+    assert!(g.join().is_err());\n+\n+    // When the panic occurs, we will be in the midst of constructing\n+    // the input to `_b3`.  Therefore, we drop the elements of the\n+    // partially filled array first, before we get around to dropping\n+    // the elements of `_b1` and _b2`.\n+\n+    // Issue 23222: The order in which the elements actually get\n+    // dropped is a little funky. See similar notes in nested-vec-3;\n+    // in essence, I would not be surprised if we change the ordering\n+    // given in `expect` in the future.\n+\n+    let expect = 0x__A_9__5_6_7_8__1_2_3_4;\n+    let actual = LOG.load(Ordering::SeqCst);\n+    assert!(actual == expect, \"expect: 0x{:x} actual: 0x{:x}\", expect, actual);\n+}"}, {"sha": "02f6cc70fd5b8adcf6f9f1319c99cec52e9d1697", "filename": "src/test/run-pass/drop-flag-sanity-check.rs", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/e42521aa58be928dd62b5450c443368d29ab6a65/src%2Ftest%2Frun-pass%2Fdrop-flag-sanity-check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e42521aa58be928dd62b5450c443368d29ab6a65/src%2Ftest%2Frun-pass%2Fdrop-flag-sanity-check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdrop-flag-sanity-check.rs?ref=e42521aa58be928dd62b5450c443368d29ab6a65", "patch": "@@ -0,0 +1,69 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -Z force-dropflag-checks=on\n+\n+// Quick-and-dirty test to ensure -Z force-dropflag-checks=on works as\n+// expected. Note that the inlined drop-flag is slated for removal\n+// (RFC 320); when that happens, the -Z flag and this test should\n+// simply be removed.\n+//\n+// See also drop-flag-skip-sanity-check.rs.\n+\n+#![feature(old_io)]\n+\n+use std::env;\n+use std::old_io::process::{Command, ExitSignal, ExitStatus};\n+\n+fn main() {\n+    let args: Vec<String> = env::args().collect();\n+    if args.len() > 1 && args[1] == \"test\" {\n+        return test();\n+    }\n+\n+    let mut p = Command::new(&args[0]).arg(\"test\").spawn().unwrap();\n+    // The invocation should fail due to the drop-flag sanity check.\n+    assert!(!p.wait().unwrap().success());\n+}\n+\n+#[derive(Debug)]\n+struct Corrupted {\n+    x: u8\n+}\n+\n+impl Drop for Corrupted {\n+    fn drop(&mut self) { println!(\"dropping\"); }\n+}\n+\n+fn test() {\n+    {\n+        let mut c1 = Corrupted { x: 1 };\n+        let mut c2 = Corrupted { x: 2 };\n+        unsafe {\n+            let p1 = &mut c1 as *mut Corrupted as *mut u8;\n+            let p2 = &mut c2 as *mut Corrupted as *mut u8;\n+            for i in 0..std::mem::size_of::<Corrupted>() {\n+                // corrupt everything, *including the drop flag.\n+                //\n+                // (We corrupt via two different means to safeguard\n+                // against the hypothetical assignment of the\n+                // dtor_needed/dtor_done values to v and v+k.  that\n+                // happen to match with one of the corruption values\n+                // below.)\n+                *p1.offset(i as isize) += 2;\n+                *p2.offset(i as isize) += 3;\n+            }\n+        }\n+        // Here, at the end of the scope of `c1` and `c2`, the\n+        // drop-glue should detect the corruption of (at least one of)\n+        // the drop-flags.\n+    }\n+    println!(\"We should never get here.\");\n+}"}, {"sha": "7066b4017af2325a6b054b5b80872e106c419814", "filename": "src/test/run-pass/drop-flag-skip-sanity-check.rs", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/e42521aa58be928dd62b5450c443368d29ab6a65/src%2Ftest%2Frun-pass%2Fdrop-flag-skip-sanity-check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e42521aa58be928dd62b5450c443368d29ab6a65/src%2Ftest%2Frun-pass%2Fdrop-flag-skip-sanity-check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdrop-flag-skip-sanity-check.rs?ref=e42521aa58be928dd62b5450c443368d29ab6a65", "patch": "@@ -0,0 +1,69 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -Z force-dropflag-checks=off\n+\n+// Quick-and-dirty test to ensure -Z force-dropflag-checks=off works as\n+// expected. Note that the inlined drop-flag is slated for removal\n+// (RFC 320); when that happens, the -Z flag and this test should\n+// simply be removed.\n+//\n+// See also drop-flag-sanity-check.rs.\n+\n+#![feature(old_io)]\n+\n+use std::env;\n+use std::old_io::process::{Command, ExitSignal, ExitStatus};\n+\n+fn main() {\n+    let args: Vec<String> = env::args().collect();\n+    if args.len() > 1 && args[1] == \"test\" {\n+        return test();\n+    }\n+\n+    let mut p = Command::new(&args[0]).arg(\"test\").spawn().unwrap();\n+    // Invocatinn should succeed as drop-flag sanity check is skipped.\n+    assert!(p.wait().unwrap().success());\n+}\n+\n+#[derive(Debug)]\n+struct Corrupted {\n+    x: u8\n+}\n+\n+impl Drop for Corrupted {\n+    fn drop(&mut self) { println!(\"dropping\"); }\n+}\n+\n+fn test() {\n+    {\n+        let mut c1 = Corrupted { x: 1 };\n+        let mut c2 = Corrupted { x: 2 };\n+        unsafe {\n+            let p1 = &mut c1 as *mut Corrupted as *mut u8;\n+            let p2 = &mut c2 as *mut Corrupted as *mut u8;\n+            for i in 0..std::mem::size_of::<Corrupted>() {\n+                // corrupt everything, *including the drop flag.\n+                //\n+                // (We corrupt via two different means to safeguard\n+                // against the hypothetical assignment of the\n+                // dtor_needed/dtor_done values to v and v+k.  that\n+                // happen to match with one of the corruption values\n+                // below.)\n+                *p1.offset(i as isize) += 2;\n+                *p2.offset(i as isize) += 3;\n+            }\n+        }\n+        // Here, at the end of the scope of `c1` and `c2`, the\n+        // drop-glue should detect the corruption of (at least one of)\n+        // the drop-flags.\n+    }\n+    println!(\"We should never get here.\");\n+}"}, {"sha": "c0585afc22ff8c32a72c176e1b854a92be6c71e3", "filename": "src/test/run-pass/intrinsic-move-val.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e42521aa58be928dd62b5450c443368d29ab6a65/src%2Ftest%2Frun-pass%2Fintrinsic-move-val.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e42521aa58be928dd62b5450c443368d29ab6a65/src%2Ftest%2Frun-pass%2Fintrinsic-move-val.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fintrinsic-move-val.rs?ref=e42521aa58be928dd62b5450c443368d29ab6a65", "patch": "@@ -13,8 +13,10 @@\n #![allow(unknown_features)]\n #![feature(box_syntax)]\n #![feature(intrinsics)]\n+// needed to check for drop fill word.\n+#![feature(filling_drop)]\n \n-use std::mem::transmute;\n+use std::mem::{self, transmute};\n \n mod rusti {\n     extern \"rust-intrinsic\" {\n@@ -30,6 +32,7 @@ pub fn main() {\n         let mut z: *const uint = transmute(&x);\n         rusti::move_val_init(&mut y, x);\n         assert_eq!(*y, 1);\n-        assert_eq!(*z, 0); // `x` is nulled out, not directly visible\n+        // `x` is nulled out, not directly visible\n+        assert_eq!(*z, mem::POST_DROP_USIZE);\n     }\n }"}, {"sha": "2b92ed38eab803c683770277b5971e26fc462a52", "filename": "src/test/run-pass/nested-vec-1.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e42521aa58be928dd62b5450c443368d29ab6a65/src%2Ftest%2Frun-pass%2Fnested-vec-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e42521aa58be928dd62b5450c443368d29ab6a65/src%2Ftest%2Frun-pass%2Fnested-vec-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnested-vec-1.rs?ref=e42521aa58be928dd62b5450c443368d29ab6a65", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that using the `vec!` macro nested within itself works\n+\n+fn main() {\n+    let nested = vec![vec![1u32, 2u32, 3u32]];\n+    assert_eq!(nested[0][1], 2);\n+}"}, {"sha": "669f9e4f4bb7e77174d7639183ceee77e2bc18b8", "filename": "src/test/run-pass/nested-vec-2.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e42521aa58be928dd62b5450c443368d29ab6a65/src%2Ftest%2Frun-pass%2Fnested-vec-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e42521aa58be928dd62b5450c443368d29ab6a65/src%2Ftest%2Frun-pass%2Fnested-vec-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnested-vec-2.rs?ref=e42521aa58be928dd62b5450c443368d29ab6a65", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that using the `vec!` macro nested within itself works\n+// when the contents implement Drop\n+\n+struct D(u32);\n+\n+impl Drop for D {\n+    fn drop(&mut self) { println!(\"Dropping {}\", self.0); }\n+}\n+\n+fn main() {\n+    let nested = vec![vec![D(1u32), D(2u32), D(3u32)]];\n+    assert_eq!(nested[0][1].0, 2);\n+}"}, {"sha": "60cf795c918bb1692e5c749ff96b96cd92568808", "filename": "src/test/run-pass/nested-vec-3.rs", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/e42521aa58be928dd62b5450c443368d29ab6a65/src%2Ftest%2Frun-pass%2Fnested-vec-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e42521aa58be928dd62b5450c443368d29ab6a65/src%2Ftest%2Frun-pass%2Fnested-vec-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnested-vec-3.rs?ref=e42521aa58be928dd62b5450c443368d29ab6a65", "patch": "@@ -0,0 +1,60 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that using the `vec!` macro nested within itself works when\n+// the contents implement Drop and we hit a panic in the middle of\n+// construction.\n+\n+\n+use std::thread;\n+use std::sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT, Ordering};\n+\n+static LOG: AtomicUsize = ATOMIC_USIZE_INIT;\n+\n+struct D(u8);\n+\n+impl Drop for D {\n+    fn drop(&mut self) {\n+        println!(\"Dropping {}\", self.0);\n+        let old = LOG.load(Ordering::SeqCst);\n+        LOG.compare_and_swap(old, old << 4 | self.0 as usize, Ordering::SeqCst);\n+    }\n+}\n+\n+fn main() {\n+    fn die() -> D { panic!(\"Oh no\"); }\n+    let g = thread::spawn(|| {\n+        let _nested = vec![vec![D( 1), D( 2), D( 3), D( 4)],\n+                           vec![D( 5), D( 6), D( 7), D( 8)],\n+                           vec![D( 9), D(10), die(), D(12)],\n+                           vec![D(13), D(14), D(15), D(16)]];\n+    });\n+    assert!(g.join().is_err());\n+\n+    // When the panic occurs, we will be in the midst of constructing the\n+    // second inner vector.  Therefore, we drop the elements of the\n+    // partially filled vector first, before we get around to dropping\n+    // the elements of the filled vector.\n+\n+    // Issue 23222: The order in which the elements actually get\n+    // dropped is a little funky: as noted above, we'll drop the 9+10\n+    // first, but due to #23222, they get dropped in reverse\n+    // order. Likewise, again due to #23222, we will drop the second\n+    // filled vec before the first filled vec.\n+    //\n+    // If Issue 23222 is \"fixed\", then presumably the corrected\n+    // expected order of events will be 0x__9_A__1_2_3_4__5_6_7_8;\n+    // that is, we would still drop 9+10 first, since they belong to\n+    // the more deeply nested expression when the panic occurs.\n+\n+    let expect = 0x__A_9__5_6_7_8__1_2_3_4;\n+    let actual = LOG.load(Ordering::SeqCst);\n+    assert!(actual == expect, \"expect: 0x{:x} actual: 0x{:x}\", expect, actual);\n+}"}]}