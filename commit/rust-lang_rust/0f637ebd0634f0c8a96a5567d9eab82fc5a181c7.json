{"sha": "0f637ebd0634f0c8a96a5567d9eab82fc5a181c7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBmNjM3ZWJkMDYzNGYwYzhhOTZhNTU2N2Q5ZWFiODJmYzVhMTgxYzc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-25T15:56:27Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-25T15:56:27Z"}, "message": "auto merge of #11790 : lfairy/rust/rename-num-consts, r=alexcrichton\n\nThe following are renamed:\r\n\r\n* `min_value` => `MIN`\r\n* `max_value` => `MAX`\r\n* `bits` => `BITS`\r\n* `bytes` => `BYTES`\r\n\r\nAll tests pass, except for `run-pass/phase-syntax-link-does-resolve.rs`. I doubt that failure is related, though.\r\n\r\nFixes #10010.", "tree": {"sha": "e04711efa643d68c4ad3195fff43cdc9918cac6a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e04711efa643d68c4ad3195fff43cdc9918cac6a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0f637ebd0634f0c8a96a5567d9eab82fc5a181c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0f637ebd0634f0c8a96a5567d9eab82fc5a181c7", "html_url": "https://github.com/rust-lang/rust/commit/0f637ebd0634f0c8a96a5567d9eab82fc5a181c7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0f637ebd0634f0c8a96a5567d9eab82fc5a181c7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "caabbb8388e180ce585dbe1872ad1759d411aab6", "url": "https://api.github.com/repos/rust-lang/rust/commits/caabbb8388e180ce585dbe1872ad1759d411aab6", "html_url": "https://github.com/rust-lang/rust/commit/caabbb8388e180ce585dbe1872ad1759d411aab6"}, {"sha": "988e4f0a1c2802921375271bdc19f03650c024d2", "url": "https://api.github.com/repos/rust-lang/rust/commits/988e4f0a1c2802921375271bdc19f03650c024d2", "html_url": "https://github.com/rust-lang/rust/commit/988e4f0a1c2802921375271bdc19f03650c024d2"}], "stats": {"total": 888, "additions": 444, "deletions": 444}, "files": [{"sha": "7211907f483212578caaa14049ff69b10e7ffb48", "filename": "src/libextra/bitv.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/0f637ebd0634f0c8a96a5567d9eab82fc5a181c7/src%2Flibextra%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f637ebd0634f0c8a96a5567d9eab82fc5a181c7/src%2Flibextra%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbitv.rs?ref=0f637ebd0634f0c8a96a5567d9eab82fc5a181c7", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -121,8 +121,8 @@ struct BigBitv {\n  */\n #[inline]\n fn big_mask(nbits: uint, elem: uint) -> uint {\n-    let rmd = nbits % uint::bits;\n-    let nelems = nbits/uint::bits + if rmd == 0 {0} else {1};\n+    let rmd = nbits % uint::BITS;\n+    let nelems = nbits/uint::BITS + if rmd == 0 {0} else {1};\n \n     if elem < nelems - 1 || rmd == 0 {\n         !0\n@@ -192,16 +192,16 @@ impl BigBitv {\n \n     #[inline]\n     pub fn get(&self, i: uint) -> bool {\n-        let w = i / uint::bits;\n-        let b = i % uint::bits;\n+        let w = i / uint::BITS;\n+        let b = i % uint::BITS;\n         let x = 1 & self.storage[w] >> b;\n         x == 1\n     }\n \n     #[inline]\n     pub fn set(&mut self, i: uint, x: bool) {\n-        let w = i / uint::bits;\n-        let b = i % uint::bits;\n+        let w = i / uint::BITS;\n+        let b = i % uint::BITS;\n         let flag = 1 << b;\n         self.storage[w] = if x { self.storage[w] | flag }\n                           else { self.storage[w] & !flag };\n@@ -269,20 +269,20 @@ impl Bitv {\n \n impl Bitv {\n     pub fn new(nbits: uint, init: bool) -> Bitv {\n-        let rep = if nbits < uint::bits {\n+        let rep = if nbits < uint::BITS {\n             Small(SmallBitv::new(if init {(1<<nbits)-1} else {0}))\n-        } else if nbits == uint::bits {\n+        } else if nbits == uint::BITS {\n             Small(SmallBitv::new(if init {!0} else {0}))\n         } else {\n-            let exact = nbits % uint::bits == 0;\n-            let nelems = nbits/uint::bits + if exact {0} else {1};\n+            let exact = nbits % uint::BITS == 0;\n+            let nelems = nbits/uint::BITS + if exact {0} else {1};\n             let s =\n                 if init {\n                     if exact {\n                         vec::from_elem(nelems, !0u)\n                     } else {\n                         let mut v = vec::from_elem(nelems-1, !0u);\n-                        v.push((1<<nbits % uint::bits)-1);\n+                        v.push((1<<nbits % uint::BITS)-1);\n                         v\n                     }\n                 } else { vec::from_elem(nelems, 0u)};\n@@ -576,7 +576,7 @@ fn iterate_bits(base: uint, bits: uint, f: |uint| -> bool) -> bool {\n     if bits == 0 {\n         return true;\n     }\n-    for i in range(0u, uint::bits) {\n+    for i in range(0u, uint::BITS) {\n         if bits & (1 << i) != 0 {\n             if !f(base + i) {\n                 return false;\n@@ -680,7 +680,7 @@ impl BitvSet {\n \n     /// Returns the capacity in bits for this bit vector. Inserting any\n     /// element less than this amount will not trigger a resizing.\n-    pub fn capacity(&self) -> uint { self.bitv.storage.len() * uint::bits }\n+    pub fn capacity(&self) -> uint { self.bitv.storage.len() * uint::BITS }\n \n     /// Consumes this set to return the underlying bit vector\n     pub fn unwrap(self) -> Bitv {\n@@ -693,7 +693,7 @@ impl BitvSet {\n     fn other_op(&mut self, other: &BitvSet, f: |uint, uint| -> uint) {\n         fn nbits(mut w: uint) -> uint {\n             let mut bits = 0;\n-            for _ in range(0u, uint::bits) {\n+            for _ in range(0u, uint::BITS) {\n                 if w == 0 {\n                     break;\n                 }\n@@ -703,7 +703,7 @@ impl BitvSet {\n             return bits;\n         }\n         if self.capacity() < other.capacity() {\n-            self.bitv.storage.grow(other.capacity() / uint::bits, &0);\n+            self.bitv.storage.grow(other.capacity() / uint::BITS, &0);\n         }\n         for (i, &w) in other.bitv.storage.iter().enumerate() {\n             let old = self.bitv.storage[i];\n@@ -808,7 +808,7 @@ impl Mutable for BitvSet {\n \n impl Set<uint> for BitvSet {\n     fn contains(&self, value: &uint) -> bool {\n-        *value < self.bitv.storage.len() * uint::bits && self.bitv.get(*value)\n+        *value < self.bitv.storage.len() * uint::BITS && self.bitv.get(*value)\n     }\n \n     fn is_disjoint(&self, other: &BitvSet) -> bool {\n@@ -846,7 +846,7 @@ impl MutableSet<uint> for BitvSet {\n         }\n         let nbits = self.capacity();\n         if value >= nbits {\n-            let newsize = num::max(value, nbits * 2) / uint::bits + 1;\n+            let newsize = num::max(value, nbits * 2) / uint::BITS + 1;\n             assert!(newsize > self.bitv.storage.len());\n             self.bitv.storage.grow(newsize, &0);\n         }\n@@ -884,7 +884,7 @@ impl BitvSet {\n         let min = num::min(self.bitv.storage.len(), other.bitv.storage.len());\n         self.bitv.storage.slice(0, min).iter().enumerate()\n             .zip(Repeat::new(&other.bitv.storage))\n-            .map(|((i, &w), o_store)| (i * uint::bits, w, o_store[i]))\n+            .map(|((i, &w), o_store)| (i * uint::BITS, w, o_store[i]))\n     }\n \n     /// Visits each word in `self` or `other` that extends beyond the other. This\n@@ -903,11 +903,11 @@ impl BitvSet {\n         if olen < slen {\n             self.bitv.storage.slice_from(olen).iter().enumerate()\n                 .zip(Repeat::new(olen))\n-                .map(|((i, &w), min)| (true, (i + min) * uint::bits, w))\n+                .map(|((i, &w), min)| (true, (i + min) * uint::BITS, w))\n         } else {\n             other.bitv.storage.slice_from(slen).iter().enumerate()\n                 .zip(Repeat::new(slen))\n-                .map(|((i, &w), min)| (false, (i + min) * uint::bits, w))\n+                .map(|((i, &w), min)| (false, (i + min) * uint::BITS, w))\n         }\n     }\n }\n@@ -1529,7 +1529,7 @@ mod tests {\n \n         assert!(a.insert(1000));\n         assert!(a.remove(&1000));\n-        assert_eq!(a.capacity(), uint::bits);\n+        assert_eq!(a.capacity(), uint::BITS);\n     }\n \n     #[test]\n@@ -1561,16 +1561,16 @@ mod tests {\n         let mut r = rng();\n         let mut bitv = 0 as uint;\n         b.iter(|| {\n-            bitv |= (1 << ((r.next_u32() as uint) % uint::bits));\n+            bitv |= (1 << ((r.next_u32() as uint) % uint::BITS));\n         })\n     }\n \n     #[bench]\n     fn bench_small_bitv_small(b: &mut BenchHarness) {\n         let mut r = rng();\n-        let mut bitv = SmallBitv::new(uint::bits);\n+        let mut bitv = SmallBitv::new(uint::BITS);\n         b.iter(|| {\n-            bitv.set((r.next_u32() as uint) % uint::bits, true);\n+            bitv.set((r.next_u32() as uint) % uint::BITS, true);\n         })\n     }\n \n@@ -1579,15 +1579,15 @@ mod tests {\n         let mut r = rng();\n         let mut bitv = BigBitv::new(~[0]);\n         b.iter(|| {\n-            bitv.set((r.next_u32() as uint) % uint::bits, true);\n+            bitv.set((r.next_u32() as uint) % uint::BITS, true);\n         })\n     }\n \n     #[bench]\n     fn bench_big_bitv_big(b: &mut BenchHarness) {\n         let mut r = rng();\n         let mut storage = ~[];\n-        storage.grow(BENCH_BITS / uint::bits, &0u);\n+        storage.grow(BENCH_BITS / uint::BITS, &0u);\n         let mut bitv = BigBitv::new(storage);\n         b.iter(|| {\n             bitv.set((r.next_u32() as uint) % BENCH_BITS, true);\n@@ -1606,9 +1606,9 @@ mod tests {\n     #[bench]\n     fn bench_bitv_small(b: &mut BenchHarness) {\n         let mut r = rng();\n-        let mut bitv = Bitv::new(uint::bits, false);\n+        let mut bitv = Bitv::new(uint::BITS, false);\n         b.iter(|| {\n-            bitv.set((r.next_u32() as uint) % uint::bits, true);\n+            bitv.set((r.next_u32() as uint) % uint::BITS, true);\n         })\n     }\n \n@@ -1617,7 +1617,7 @@ mod tests {\n         let mut r = rng();\n         let mut bitv = BitvSet::new();\n         b.iter(|| {\n-            bitv.insert((r.next_u32() as uint) % uint::bits);\n+            bitv.insert((r.next_u32() as uint) % uint::BITS);\n         })\n     }\n \n@@ -1641,7 +1641,7 @@ mod tests {\n \n     #[bench]\n     fn bench_btv_small_iter(b: &mut BenchHarness) {\n-        let bitv = Bitv::new(uint::bits, false);\n+        let bitv = Bitv::new(uint::BITS, false);\n         b.iter(|| {\n             let mut _sum = 0;\n             for pres in bitv.iter() {"}, {"sha": "a44cf2ec06348768e6fa4f4079a6eba82aad3569", "filename": "src/libextra/ebml.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f637ebd0634f0c8a96a5567d9eab82fc5a181c7/src%2Flibextra%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f637ebd0634f0c8a96a5567d9eab82fc5a181c7/src%2Flibextra%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Febml.rs?ref=0f637ebd0634f0c8a96a5567d9eab82fc5a181c7", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -364,7 +364,7 @@ pub mod reader {\n         fn read_u8 (&mut self) -> u8  { doc_as_u8 (self.next_doc(EsU8 )) }\n         fn read_uint(&mut self) -> uint {\n             let v = doc_as_u64(self.next_doc(EsUint));\n-            if v > (::std::uint::max_value as u64) {\n+            if v > (::std::uint::MAX as u64) {\n                 fail!(\"uint {} too large for this architecture\", v);\n             }\n             v as uint\n@@ -384,7 +384,7 @@ pub mod reader {\n         }\n         fn read_int(&mut self) -> int {\n             let v = doc_as_u64(self.next_doc(EsInt)) as i64;\n-            if v > (int::max_value as i64) || v < (int::min_value as i64) {\n+            if v > (int::MAX as i64) || v < (int::MIN as i64) {\n                 debug!(\"FIXME \\\\#6122: Removing this makes this function miscompile\");\n                 fail!(\"int {} out of range for this architecture\", v);\n             }"}, {"sha": "6fd1e805b1b4488d31d56dd07235885e1be00889", "filename": "src/libextra/getopts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f637ebd0634f0c8a96a5567d9eab82fc5a181c7/src%2Flibextra%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f637ebd0634f0c8a96a5567d9eab82fc5a181c7/src%2Flibextra%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fgetopts.rs?ref=0f637ebd0634f0c8a96a5567d9eab82fc5a181c7", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -848,7 +848,7 @@ pub mod groups {\n         t(\"hello\", 15, [~\"hello\"]);\n         t(\"\\nMary had a little lamb\\nLittle lamb\\n\", 15,\n             [~\"Mary had a\", ~\"little lamb\", ~\"Little lamb\"]);\n-        t(\"\\nMary had a little lamb\\nLittle lamb\\n\", ::std::uint::max_value,\n+        t(\"\\nMary had a little lamb\\nLittle lamb\\n\", ::std::uint::MAX,\n             [~\"Mary had a little lamb\\nLittle lamb\"]);\n     }\n } // end groups module"}, {"sha": "1e1c09431b6149d52aa5d08a9cebee653cffa278", "filename": "src/libextra/num/bigint.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/0f637ebd0634f0c8a96a5567d9eab82fc5a181c7/src%2Flibextra%2Fnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f637ebd0634f0c8a96a5567d9eab82fc5a181c7/src%2Flibextra%2Fnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Fbigint.rs?ref=0f637ebd0634f0c8a96a5567d9eab82fc5a181c7", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -1186,7 +1186,7 @@ impl ToPrimitive for BigInt {\n                     if n < m {\n                         Some(-(n as i64))\n                     } else if n == m {\n-                        Some(i64::min_value)\n+                        Some(i64::MIN)\n                     } else {\n                         None\n                     }\n@@ -1213,7 +1213,7 @@ impl FromPrimitive for BigInt {\n                 Some(BigInt::from_biguint(Plus, n))\n             })\n         } else if n < 0 {\n-            FromPrimitive::from_u64(u64::max_value - (n as u64) + 1).and_then(\n+            FromPrimitive::from_u64(u64::MAX - (n as u64) + 1).and_then(\n                 |n| {\n                     Some(BigInt::from_biguint(Minus, n))\n                 })\n@@ -1625,7 +1625,7 @@ mod biguint_tests {\n \n         check(Zero::zero(), 0);\n         check(One::one(), 1);\n-        check(i64::max_value.to_biguint().unwrap(), i64::max_value);\n+        check(i64::MAX.to_biguint().unwrap(), i64::MAX);\n \n         check(BigUint::new(~[                   ]), 0);\n         check(BigUint::new(~[ 1                 ]), (1 << (0*BigDigit::bits)));\n@@ -1635,9 +1635,9 @@ mod biguint_tests {\n         check(BigUint::new(~[ 0,  0,  1         ]), (1 << (2*BigDigit::bits)));\n         check(BigUint::new(~[-1, -1, -1         ]), (1 << (3*BigDigit::bits)) - 1);\n         check(BigUint::new(~[ 0,  0,  0,  1     ]), (1 << (3*BigDigit::bits)));\n-        check(BigUint::new(~[-1, -1, -1, -1 >> 1]), i64::max_value);\n+        check(BigUint::new(~[-1, -1, -1, -1 >> 1]), i64::MAX);\n \n-        assert_eq!(i64::min_value.to_biguint(), None);\n+        assert_eq!(i64::MIN.to_biguint(), None);\n         assert_eq!(BigUint::new(~[-1, -1, -1, -1    ]).to_i64(), None);\n         assert_eq!(BigUint::new(~[ 0,  0,  0,  0,  1]).to_i64(), None);\n         assert_eq!(BigUint::new(~[-1, -1, -1, -1, -1]).to_i64(), None);\n@@ -1654,15 +1654,15 @@ mod biguint_tests {\n \n         check(Zero::zero(), 0);\n         check(One::one(), 1);\n-        check(i64::max_value.to_biguint().unwrap(), i64::max_value);\n+        check(i64::MAX.to_biguint().unwrap(), i64::MAX);\n \n         check(BigUint::new(~[           ]), 0);\n         check(BigUint::new(~[ 1         ]), (1 << (0*BigDigit::bits)));\n         check(BigUint::new(~[-1         ]), (1 << (1*BigDigit::bits)) - 1);\n         check(BigUint::new(~[ 0,  1     ]), (1 << (1*BigDigit::bits)));\n-        check(BigUint::new(~[-1, -1 >> 1]), i64::max_value);\n+        check(BigUint::new(~[-1, -1 >> 1]), i64::MAX);\n \n-        assert_eq!(i64::min_value.to_biguint(), None);\n+        assert_eq!(i64::MIN.to_biguint(), None);\n         assert_eq!(BigUint::new(~[-1, -1    ]).to_i64(), None);\n         assert_eq!(BigUint::new(~[ 0,  0,  1]).to_i64(), None);\n         assert_eq!(BigUint::new(~[-1, -1, -1]).to_i64(), None);\n@@ -1679,8 +1679,8 @@ mod biguint_tests {\n \n         check(Zero::zero(), 0);\n         check(One::one(), 1);\n-        check(u64::min_value.to_biguint().unwrap(), u64::min_value);\n-        check(u64::max_value.to_biguint().unwrap(), u64::max_value);\n+        check(u64::MIN.to_biguint().unwrap(), u64::MIN);\n+        check(u64::MAX.to_biguint().unwrap(), u64::MAX);\n \n         check(BigUint::new(~[              ]), 0);\n         check(BigUint::new(~[ 1            ]), (1 << (0*BigDigit::bits)));\n@@ -1690,7 +1690,7 @@ mod biguint_tests {\n         check(BigUint::new(~[ 0,  0,  1    ]), (1 << (2*BigDigit::bits)));\n         check(BigUint::new(~[-1, -1, -1    ]), (1 << (3*BigDigit::bits)) - 1);\n         check(BigUint::new(~[ 0,  0,  0,  1]), (1 << (3*BigDigit::bits)));\n-        check(BigUint::new(~[-1, -1, -1, -1]), u64::max_value);\n+        check(BigUint::new(~[-1, -1, -1, -1]), u64::MAX);\n \n         assert_eq!(BigUint::new(~[ 0,  0,  0,  0,  1]).to_u64(), None);\n         assert_eq!(BigUint::new(~[-1, -1, -1, -1, -1]).to_u64(), None);\n@@ -1707,14 +1707,14 @@ mod biguint_tests {\n \n         check(Zero::zero(), 0);\n         check(One::one(), 1);\n-        check(u64::min_value.to_biguint().unwrap(), u64::min_value);\n-        check(u64::max_value.to_biguint().unwrap(), u64::max_value);\n+        check(u64::MIN.to_biguint().unwrap(), u64::MIN);\n+        check(u64::MAX.to_biguint().unwrap(), u64::MAX);\n \n         check(BigUint::new(~[      ]), 0);\n         check(BigUint::new(~[ 1    ]), (1 << (0*BigDigit::bits)));\n         check(BigUint::new(~[-1    ]), (1 << (1*BigDigit::bits)) - 1);\n         check(BigUint::new(~[ 0,  1]), (1 << (1*BigDigit::bits)));\n-        check(BigUint::new(~[-1, -1]), u64::max_value);\n+        check(BigUint::new(~[-1, -1]), u64::MAX);\n \n         assert_eq!(BigUint::new(~[ 0,  0,  1]).to_u64(), None);\n         assert_eq!(BigUint::new(~[-1, -1, -1]).to_u64(), None);\n@@ -2166,11 +2166,11 @@ mod bigint_tests {\n \n         check(Zero::zero(), 0);\n         check(One::one(), 1);\n-        check(i64::min_value.to_bigint().unwrap(), i64::min_value);\n-        check(i64::max_value.to_bigint().unwrap(), i64::max_value);\n+        check(i64::MIN.to_bigint().unwrap(), i64::MIN);\n+        check(i64::MAX.to_bigint().unwrap(), i64::MAX);\n \n         assert_eq!(\n-            (i64::max_value as u64 + 1).to_bigint().unwrap().to_i64(),\n+            (i64::MAX as u64 + 1).to_bigint().unwrap().to_i64(),\n             None);\n \n         assert_eq!(\n@@ -2196,14 +2196,14 @@ mod bigint_tests {\n \n         check(Zero::zero(), 0);\n         check(One::one(), 1);\n-        check(u64::min_value.to_bigint().unwrap(), u64::min_value);\n-        check(u64::max_value.to_bigint().unwrap(), u64::max_value);\n+        check(u64::MIN.to_bigint().unwrap(), u64::MIN);\n+        check(u64::MAX.to_bigint().unwrap(), u64::MAX);\n \n         assert_eq!(\n             BigInt::from_biguint(Plus, BigUint::new(~[1, 2, 3, 4, 5])).to_u64(),\n             None);\n \n-        let max_value: BigUint = FromPrimitive::from_u64(u64::max_value).unwrap();\n+        let max_value: BigUint = FromPrimitive::from_u64(u64::MAX).unwrap();\n         assert_eq!(BigInt::from_biguint(Minus, max_value).to_u64(), None);\n         assert_eq!(BigInt::from_biguint(Minus, BigUint::new(~[1, 2, 3, 4, 5])).to_u64(), None);\n     }"}, {"sha": "5916557abdb8178864f761278307e30196839759", "filename": "src/libgreen/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f637ebd0634f0c8a96a5567d9eab82fc5a181c7/src%2Flibgreen%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f637ebd0634f0c8a96a5567d9eab82fc5a181c7/src%2Flibgreen%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fcontext.rs?ref=0f637ebd0634f0c8a96a5567d9eab82fc5a181c7", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -131,7 +131,7 @@ impl Context {\n                 // If we're going back to one of the original contexts or\n                 // something that's possibly not a \"normal task\", then reset\n                 // the stack limit to 0 to make morestack never fail\n-                None => stack::record_stack_bounds(0, uint::max_value),\n+                None => stack::record_stack_bounds(0, uint::MAX),\n             }\n             rust_swap_registers(out_regs, in_regs)\n         }"}, {"sha": "299a880f02d8d60c0c2ed6f36a56cf68f162334a", "filename": "src/librustc/middle/borrowck/move_data.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f637ebd0634f0c8a96a5567d9eab82fc5a181c7/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f637ebd0634f0c8a96a5567d9eab82fc5a181c7/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs?ref=0f637ebd0634f0c8a96a5567d9eab82fc5a181c7", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -80,7 +80,7 @@ impl Clone for MovePathIndex {\n }\n \n static InvalidMovePathIndex: MovePathIndex =\n-    MovePathIndex(uint::max_value);\n+    MovePathIndex(uint::MAX);\n \n /// Index into `MoveData.moves`, used like a pointer\n #[deriving(Eq)]\n@@ -93,7 +93,7 @@ impl MoveIndex {\n }\n \n static InvalidMoveIndex: MoveIndex =\n-    MoveIndex(uint::max_value);\n+    MoveIndex(uint::MAX);\n \n pub struct MovePath {\n     /// Loan path corresponding to this move path"}, {"sha": "9115125324c38a7fbd391d6f6d5c2e0da3c5abcc", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0f637ebd0634f0c8a96a5567d9eab82fc5a181c7/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f637ebd0634f0c8a96a5567d9eab82fc5a181c7/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=0f637ebd0634f0c8a96a5567d9eab82fc5a181c7", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -42,7 +42,7 @@ pub struct DataFlowContext<O> {\n     priv bits_per_id: uint,\n \n     /// number of words we will use to store bits_per_id.\n-    /// equal to bits_per_id/uint::bits rounded up.\n+    /// equal to bits_per_id/uint::BITS rounded up.\n     priv words_per_id: uint,\n \n     // mapping from node to bitset index.\n@@ -129,7 +129,7 @@ impl<O:DataFlowOperator> DataFlowContext<O> {\n                oper: O,\n                id_range: IdRange,\n                bits_per_id: uint) -> DataFlowContext<O> {\n-        let words_per_id = (bits_per_id + uint::bits - 1) / uint::bits;\n+        let words_per_id = (bits_per_id + uint::BITS - 1) / uint::BITS;\n \n         debug!(\"DataFlowContext::new(id_range={:?}, bits_per_id={:?}, words_per_id={:?})\",\n                id_range, bits_per_id, words_per_id);\n@@ -213,7 +213,7 @@ impl<O:DataFlowOperator> DataFlowContext<O> {\n             len\n         });\n         if expanded {\n-            let entry = if self.oper.initial_value() { uint::max_value } else {0};\n+            let entry = if self.oper.initial_value() { uint::MAX } else {0};\n             self.words_per_id.times(|| {\n                 self.gens.push(0);\n                 self.kills.push(0);\n@@ -291,13 +291,13 @@ impl<O:DataFlowOperator> DataFlowContext<O> {\n \n         for (word_index, &word) in words.iter().enumerate() {\n             if word != 0 {\n-                let base_index = word_index * uint::bits;\n-                for offset in range(0u, uint::bits) {\n+                let base_index = word_index * uint::BITS;\n+                for offset in range(0u, uint::BITS) {\n                     let bit = 1 << offset;\n                     if (word & bit) != 0 {\n                         // NB: we round up the total number of bits\n                         // that we store in any given bit set so that\n-                        // it is an even multiple of uint::bits.  This\n+                        // it is an even multiple of uint::BITS.  This\n                         // means that there may be some stray bits at\n                         // the end that do not correspond to any\n                         // actual value.  So before we callback, check\n@@ -908,7 +908,7 @@ impl<'a, O:DataFlowOperator> PropagationContext<'a, O> {\n     }\n \n     fn reset(&mut self, bits: &mut [uint]) {\n-        let e = if self.dfcx.oper.initial_value() {uint::max_value} else {0};\n+        let e = if self.dfcx.oper.initial_value() {uint::MAX} else {0};\n         for b in bits.mut_iter() { *b = e; }\n     }\n \n@@ -959,7 +959,7 @@ fn bits_to_str(words: &[uint]) -> ~str {\n \n     for &word in words.iter() {\n         let mut v = word;\n-        for _ in range(0u, uint::bytes) {\n+        for _ in range(0u, uint::BYTES) {\n             result.push_char(sep);\n             result.push_str(format!(\"{:02x}\", v & 0xFF));\n             v >>= 8;\n@@ -997,8 +997,8 @@ fn bitwise(out_vec: &mut [uint], in_vec: &[uint], op: |uint, uint| -> uint)\n fn set_bit(words: &mut [uint], bit: uint) -> bool {\n     debug!(\"set_bit: words={} bit={}\",\n            mut_bits_to_str(words), bit_str(bit));\n-    let word = bit / uint::bits;\n-    let bit_in_word = bit % uint::bits;\n+    let word = bit / uint::BITS;\n+    let bit_in_word = bit % uint::BITS;\n     let bit_mask = 1 << bit_in_word;\n     debug!(\"word={} bit_in_word={} bit_mask={}\", word, bit_in_word, word);\n     let oldv = words[word];"}, {"sha": "a83e1f601249304aef224dcc19818cc944df8635", "filename": "src/librustc/middle/graph.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f637ebd0634f0c8a96a5567d9eab82fc5a181c7/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f637ebd0634f0c8a96a5567d9eab82fc5a181c7/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fgraph.rs?ref=0f637ebd0634f0c8a96a5567d9eab82fc5a181c7", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -56,11 +56,11 @@ pub struct Edge<E> {\n \n #[deriving(Eq)]\n pub struct NodeIndex(uint);\n-pub static InvalidNodeIndex: NodeIndex = NodeIndex(uint::max_value);\n+pub static InvalidNodeIndex: NodeIndex = NodeIndex(uint::MAX);\n \n #[deriving(Eq)]\n pub struct EdgeIndex(uint);\n-pub static InvalidEdgeIndex: EdgeIndex = EdgeIndex(uint::max_value);\n+pub static InvalidEdgeIndex: EdgeIndex = EdgeIndex(uint::MAX);\n \n // Use a private field here to guarantee no more instances are created:\n pub struct Direction { priv repr: uint }"}, {"sha": "8b139150f4ca1dd8d0e4cfe7f28fcf6ecf9f0faf", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0f637ebd0634f0c8a96a5567d9eab82fc5a181c7/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f637ebd0634f0c8a96a5567d9eab82fc5a181c7/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=0f637ebd0634f0c8a96a5567d9eab82fc5a181c7", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -724,21 +724,21 @@ fn check_type_limits(cx: &Context, e: &ast::Expr) {\n     // warnings are consistent between 32- and 64-bit platforms\n     fn int_ty_range(int_ty: ast::IntTy) -> (i64, i64) {\n         match int_ty {\n-            ast::TyI =>    (i64::min_value,        i64::max_value),\n-            ast::TyI8 =>   (i8::min_value  as i64, i8::max_value  as i64),\n-            ast::TyI16 =>  (i16::min_value as i64, i16::max_value as i64),\n-            ast::TyI32 =>  (i32::min_value as i64, i32::max_value as i64),\n-            ast::TyI64 =>  (i64::min_value,        i64::max_value)\n+            ast::TyI =>    (i64::MIN,        i64::MAX),\n+            ast::TyI8 =>   (i8::MIN  as i64, i8::MAX  as i64),\n+            ast::TyI16 =>  (i16::MIN as i64, i16::MAX as i64),\n+            ast::TyI32 =>  (i32::MIN as i64, i32::MAX as i64),\n+            ast::TyI64 =>  (i64::MIN,        i64::MAX)\n         }\n     }\n \n     fn uint_ty_range(uint_ty: ast::UintTy) -> (u64, u64) {\n         match uint_ty {\n-            ast::TyU =>   (u64::min_value,         u64::max_value),\n-            ast::TyU8 =>  (u8::min_value   as u64, u8::max_value   as u64),\n-            ast::TyU16 => (u16::min_value  as u64, u16::max_value  as u64),\n-            ast::TyU32 => (u32::min_value  as u64, u32::max_value  as u64),\n-            ast::TyU64 => (u64::min_value,         u64::max_value)\n+            ast::TyU =>   (u64::MIN,         u64::MAX),\n+            ast::TyU8 =>  (u8::MIN   as u64, u8::MAX   as u64),\n+            ast::TyU16 => (u16::MIN  as u64, u16::MAX  as u64),\n+            ast::TyU32 => (u32::MIN  as u64, u32::MAX  as u64),\n+            ast::TyU64 => (u64::MIN,         u64::MAX)\n         }\n     }\n "}, {"sha": "180b97ce270c29aa551329984ce15a071d82a802", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f637ebd0634f0c8a96a5567d9eab82fc5a181c7/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f637ebd0634f0c8a96a5567d9eab82fc5a181c7/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=0f637ebd0634f0c8a96a5567d9eab82fc5a181c7", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -215,11 +215,11 @@ impl to_str::ToStr for Variable {\n \n impl LiveNode {\n     pub fn is_valid(&self) -> bool {\n-        self.get() != uint::max_value\n+        self.get() != uint::MAX\n     }\n }\n \n-fn invalid_node() -> LiveNode { LiveNode(uint::max_value) }\n+fn invalid_node() -> LiveNode { LiveNode(uint::MAX) }\n \n struct CaptureInfo {\n     ln: LiveNode,"}, {"sha": "a96b1b868681e9fa8f2cc922549601b21c28f03e", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f637ebd0634f0c8a96a5567d9eab82fc5a181c7/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f637ebd0634f0c8a96a5567d9eab82fc5a181c7/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=0f637ebd0634f0c8a96a5567d9eab82fc5a181c7", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -5112,7 +5112,7 @@ impl Resolver {\n             let bindings = value_ribs.get()[j].bindings.borrow();\n             for (&k, _) in bindings.get().iter() {\n                 maybes.push(interner_get(k));\n-                values.push(uint::max_value);\n+                values.push(uint::MAX);\n             }\n         }\n \n@@ -5126,7 +5126,7 @@ impl Resolver {\n         }\n \n         if values.len() > 0 &&\n-            values[smallest] != uint::max_value &&\n+            values[smallest] != uint::MAX &&\n             values[smallest] < name.len() + 2 &&\n             values[smallest] <= max_distance &&\n             name != maybes[smallest] {"}, {"sha": "54998e06f8e4566d22ff0e179f1efafb40065963", "filename": "src/librustc/middle/typeck/infer/region_inference/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f637ebd0634f0c8a96a5567d9eab82fc5a181c7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f637ebd0634f0c8a96a5567d9eab82fc5a181c7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs?ref=0f637ebd0634f0c8a96a5567d9eab82fc5a181c7", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -1010,7 +1010,7 @@ impl RegionVarBindings {\n         // idea is to report errors that derive from independent\n         // regions of the graph, but not those that derive from\n         // overlapping locations.\n-        let mut dup_vec = vec::from_elem(self.num_vars(), uint::max_value);\n+        let mut dup_vec = vec::from_elem(self.num_vars(), uint::MAX);\n \n         let mut opt_graph = None;\n \n@@ -1238,7 +1238,7 @@ impl RegionVarBindings {\n             let classification = var_data[node_idx.to_uint()].classification;\n \n             // check whether we've visited this node on some previous walk\n-            if dup_vec[node_idx.to_uint()] == uint::max_value {\n+            if dup_vec[node_idx.to_uint()] == uint::MAX {\n                 dup_vec[node_idx.to_uint()] = orig_node_idx.to_uint();\n             } else if dup_vec[node_idx.to_uint()] != orig_node_idx.to_uint() {\n                 state.dup_found = true;"}, {"sha": "53b42baf402a74302b3d3d09f201c92e05a131e6", "filename": "src/librustdoc/passes.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f637ebd0634f0c8a96a5567d9eab82fc5a181c7/src%2Flibrustdoc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f637ebd0634f0c8a96a5567d9eab82fc5a181c7/src%2Flibrustdoc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses.rs?ref=0f637ebd0634f0c8a96a5567d9eab82fc5a181c7", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -231,7 +231,7 @@ pub fn unindent(s: &str) -> ~str {\n     let lines = s.lines_any().collect::<~[&str]>();\n     let mut saw_first_line = false;\n     let mut saw_second_line = false;\n-    let min_indent = lines.iter().fold(uint::max_value, |min_indent, line| {\n+    let min_indent = lines.iter().fold(uint::MAX, |min_indent, line| {\n \n         // After we see the first non-whitespace line, look at\n         // the line we have. If it is not whitespace, and therefore\n@@ -243,7 +243,7 @@ pub fn unindent(s: &str) -> ~str {\n             !line.is_whitespace();\n \n         let min_indent = if ignore_previous_indents {\n-            uint::max_value\n+            uint::MAX\n         } else {\n             min_indent\n         };"}, {"sha": "1281f3d6a5c3bd6eba32df91b5f16484b0bda7a9", "filename": "src/libstd/comm/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f637ebd0634f0c8a96a5567d9eab82fc5a181c7/src%2Flibstd%2Fcomm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f637ebd0634f0c8a96a5567d9eab82fc5a181c7/src%2Flibstd%2Fcomm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fmod.rs?ref=0f637ebd0634f0c8a96a5567d9eab82fc5a181c7", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -367,7 +367,7 @@ struct Packet {\n // All implementations -- the fun part\n ///////////////////////////////////////////////////////////////////////////////\n \n-static DISCONNECTED: int = int::min_value;\n+static DISCONNECTED: int = int::MIN;\n static RESCHED_FREQ: int = 200;\n \n impl Packet {"}, {"sha": "c9102a6843503bd8af5f9c9a3384b81805254445", "filename": "src/libstd/comm/select.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f637ebd0634f0c8a96a5567d9eab82fc5a181c7/src%2Flibstd%2Fcomm%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f637ebd0634f0c8a96a5567d9eab82fc5a181c7/src%2Flibstd%2Fcomm%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fselect.rs?ref=0f637ebd0634f0c8a96a5567d9eab82fc5a181c7", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -182,7 +182,7 @@ impl Select {\n             assert!(amt > 0);\n \n             let mut ready_index = amt;\n-            let mut ready_id = uint::max_value;\n+            let mut ready_id = uint::MAX;\n             let mut iter = self.iter().enumerate();\n \n             // Acquire a number of blocking contexts, and block on each one\n@@ -245,7 +245,7 @@ impl Select {\n                 assert!(!(*packet).selecting.load(Relaxed));\n             }\n \n-            assert!(ready_id != uint::max_value);\n+            assert!(ready_id != uint::MAX);\n             return ready_id;\n         }\n     }"}, {"sha": "6a9da944f8b1ddbfcf8248103dbd2298b55a0511", "filename": "src/libstd/io/extensions.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0f637ebd0634f0c8a96a5567d9eab82fc5a181c7/src%2Flibstd%2Fio%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f637ebd0634f0c8a96a5567d9eab82fc5a181c7/src%2Flibstd%2Fio%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fextensions.rs?ref=0f637ebd0634f0c8a96a5567d9eab82fc5a181c7", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -401,7 +401,7 @@ mod test {\n \n     #[test]\n     fn test_read_write_le_mem() {\n-        let uints = [0, 1, 2, 42, 10_123, 100_123_456, ::u64::max_value];\n+        let uints = [0, 1, 2, 42, 10_123, 100_123_456, ::u64::MAX];\n \n         let mut writer = MemWriter::new();\n         for i in uints.iter() {\n@@ -417,7 +417,7 @@ mod test {\n \n     #[test]\n     fn test_read_write_be() {\n-        let uints = [0, 1, 2, 42, 10_123, 100_123_456, ::u64::max_value];\n+        let uints = [0, 1, 2, 42, 10_123, 100_123_456, ::u64::MAX];\n \n         let mut writer = MemWriter::new();\n         for i in uints.iter() {\n@@ -432,7 +432,7 @@ mod test {\n \n     #[test]\n     fn test_read_be_int_n() {\n-        let ints = [::i32::min_value, -123456, -42, -5, 0, 1, ::i32::max_value];\n+        let ints = [::i32::MIN, -123456, -42, -5, 0, 1, ::i32::MAX];\n \n         let mut writer = MemWriter::new();\n         for i in ints.iter() {"}, {"sha": "027c4f183446b42def53051468933b2b432a2331", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0f637ebd0634f0c8a96a5567d9eab82fc5a181c7/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f637ebd0634f0c8a96a5567d9eab82fc5a181c7/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=0f637ebd0634f0c8a96a5567d9eab82fc5a181c7", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -680,28 +680,28 @@ pub trait Reader {\n     ///\n     /// The number of bytes returned is system-dependant.\n     fn read_le_uint(&mut self) -> uint {\n-        self.read_le_uint_n(uint::bytes) as uint\n+        self.read_le_uint_n(uint::BYTES) as uint\n     }\n \n     /// Reads a little-endian integer.\n     ///\n     /// The number of bytes returned is system-dependant.\n     fn read_le_int(&mut self) -> int {\n-        self.read_le_int_n(int::bytes) as int\n+        self.read_le_int_n(int::BYTES) as int\n     }\n \n     /// Reads a big-endian unsigned integer.\n     ///\n     /// The number of bytes returned is system-dependant.\n     fn read_be_uint(&mut self) -> uint {\n-        self.read_be_uint_n(uint::bytes) as uint\n+        self.read_be_uint_n(uint::BYTES) as uint\n     }\n \n     /// Reads a big-endian integer.\n     ///\n     /// The number of bytes returned is system-dependant.\n     fn read_be_int(&mut self) -> int {\n-        self.read_be_int_n(int::bytes) as int\n+        self.read_be_int_n(int::BYTES) as int\n     }\n \n     /// Reads a big-endian `u64`.\n@@ -915,22 +915,22 @@ pub trait Writer {\n \n     /// Write a little-endian uint (number of bytes depends on system).\n     fn write_le_uint(&mut self, n: uint) {\n-        extensions::u64_to_le_bytes(n as u64, uint::bytes, |v| self.write(v))\n+        extensions::u64_to_le_bytes(n as u64, uint::BYTES, |v| self.write(v))\n     }\n \n     /// Write a little-endian int (number of bytes depends on system).\n     fn write_le_int(&mut self, n: int) {\n-        extensions::u64_to_le_bytes(n as u64, int::bytes, |v| self.write(v))\n+        extensions::u64_to_le_bytes(n as u64, int::BYTES, |v| self.write(v))\n     }\n \n     /// Write a big-endian uint (number of bytes depends on system).\n     fn write_be_uint(&mut self, n: uint) {\n-        extensions::u64_to_be_bytes(n as u64, uint::bytes, |v| self.write(v))\n+        extensions::u64_to_be_bytes(n as u64, uint::BYTES, |v| self.write(v))\n     }\n \n     /// Write a big-endian int (number of bytes depends on system).\n     fn write_be_int(&mut self, n: int) {\n-        extensions::u64_to_be_bytes(n as u64, int::bytes, |v| self.write(v))\n+        extensions::u64_to_be_bytes(n as u64, int::BYTES, |v| self.write(v))\n     }\n \n     /// Write a big-endian u64 (8 bytes)."}, {"sha": "5a38b7cb2e19686eaf0c7cccea4884197a55c249", "filename": "src/libstd/iter.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0f637ebd0634f0c8a96a5567d9eab82fc5a181c7/src%2Flibstd%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f637ebd0634f0c8a96a5567d9eab82fc5a181c7/src%2Flibstd%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fiter.rs?ref=0f637ebd0634f0c8a96a5567d9eab82fc5a181c7", "patch": "@@ -681,7 +681,7 @@ pub trait DoubleEndedIterator<A>: Iterator<A> {\n     /// of the original iterator.\n     ///\n     /// Note: Random access with flipped indices still only applies to the first\n-    /// `uint::max_value` elements of the original iterator.\n+    /// `uint::MAX` elements of the original iterator.\n     #[inline]\n     fn rev(self) -> Rev<Self> {\n         Rev{iter: self}\n@@ -713,7 +713,7 @@ impl<'a, A, T: DoubleEndedIterator<&'a mut A>> MutableDoubleEndedIterator for T\n ///\n /// A `RandomAccessIterator` should be either infinite or a `DoubleEndedIterator`.\n pub trait RandomAccessIterator<A>: Iterator<A> {\n-    /// Return the number of indexable elements. At most `std::uint::max_value`\n+    /// Return the number of indexable elements. At most `std::uint::MAX`\n     /// elements are indexable, even if the iterator represents a longer range.\n     fn indexable(&self) -> uint;\n \n@@ -952,7 +952,7 @@ impl<A, T: Clone + Iterator<A>> Iterator<A> for Cycle<T> {\n         match self.orig.size_hint() {\n             sz @ (0, Some(0)) => sz,\n             (0, _) => (0, None),\n-            _ => (uint::max_value, None)\n+            _ => (uint::MAX, None)\n         }\n     }\n }\n@@ -961,7 +961,7 @@ impl<A, T: Clone + RandomAccessIterator<A>> RandomAccessIterator<A> for Cycle<T>\n     #[inline]\n     fn indexable(&self) -> uint {\n         if self.orig.indexable() > 0 {\n-            uint::max_value\n+            uint::MAX\n         } else {\n             0\n         }\n@@ -1823,7 +1823,7 @@ impl<A: Add<A, A> + Clone> Iterator<A> for Counter<A> {\n \n     #[inline]\n     fn size_hint(&self) -> (uint, Option<uint>) {\n-        (uint::max_value, None) // Too bad we can't specify an infinite lower bound\n+        (uint::MAX, None) // Too bad we can't specify an infinite lower bound\n     }\n }\n \n@@ -2049,7 +2049,7 @@ impl<A: Clone> Iterator<A> for Repeat<A> {\n     #[inline]\n     fn next(&mut self) -> Option<A> { self.idx(0) }\n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) { (uint::max_value, None) }\n+    fn size_hint(&self) -> (uint, Option<uint>) { (uint::MAX, None) }\n }\n \n impl<A: Clone> DoubleEndedIterator<A> for Repeat<A> {\n@@ -2059,7 +2059,7 @@ impl<A: Clone> DoubleEndedIterator<A> for Repeat<A> {\n \n impl<A: Clone> RandomAccessIterator<A> for Repeat<A> {\n     #[inline]\n-    fn indexable(&self) -> uint { uint::max_value }\n+    fn indexable(&self) -> uint { uint::MAX }\n     #[inline]\n     fn idx(&self, _: uint) -> Option<A> { Some(self.element.clone()) }\n }\n@@ -2417,7 +2417,7 @@ mod tests {\n     fn test_cycle() {\n         let cycle_len = 3;\n         let it = count(0u, 1).take(cycle_len).cycle();\n-        assert_eq!(it.size_hint(), (uint::max_value, None));\n+        assert_eq!(it.size_hint(), (uint::MAX, None));\n         for (i, x) in it.take(100).enumerate() {\n             assert_eq!(i % cycle_len, x);\n         }\n@@ -2489,19 +2489,19 @@ mod tests {\n         let v2 = &[10, 11, 12];\n         let vi = v.iter();\n \n-        assert_eq!(c.size_hint(), (uint::max_value, None));\n+        assert_eq!(c.size_hint(), (uint::MAX, None));\n         assert_eq!(vi.size_hint(), (10, Some(10)));\n \n         assert_eq!(c.take(5).size_hint(), (5, Some(5)));\n         assert_eq!(c.skip(5).size_hint().second(), None);\n         assert_eq!(c.take_while(|_| false).size_hint(), (0, None));\n         assert_eq!(c.skip_while(|_| false).size_hint(), (0, None));\n-        assert_eq!(c.enumerate().size_hint(), (uint::max_value, None));\n-        assert_eq!(c.chain(vi.map(|&i| i)).size_hint(), (uint::max_value, None));\n+        assert_eq!(c.enumerate().size_hint(), (uint::MAX, None));\n+        assert_eq!(c.chain(vi.map(|&i| i)).size_hint(), (uint::MAX, None));\n         assert_eq!(c.zip(vi).size_hint(), (10, Some(10)));\n         assert_eq!(c.scan(0, |_,_| Some(0)).size_hint(), (0, None));\n         assert_eq!(c.filter(|_| false).size_hint(), (0, None));\n-        assert_eq!(c.map(|_| 0).size_hint(), (uint::max_value, None));\n+        assert_eq!(c.map(|_| 0).size_hint(), (uint::MAX, None));\n         assert_eq!(c.filter_map(|_| Some(0)).size_hint(), (0, None));\n \n         assert_eq!(vi.take(5).size_hint(), (5, Some(5)));\n@@ -2894,7 +2894,7 @@ mod tests {\n \n         assert_eq!(range(0i, 100).size_hint(), (100, Some(100)));\n         // this test is only meaningful when sizeof uint < sizeof u64\n-        assert_eq!(range(uint::max_value - 1, uint::max_value).size_hint(), (1, Some(1)));\n+        assert_eq!(range(uint::MAX - 1, uint::MAX).size_hint(), (1, Some(1)));\n         assert_eq!(range(-10i, -1).size_hint(), (9, Some(9)));\n         assert_eq!(range(Foo, Foo).size_hint(), (0, None));\n     }"}, {"sha": "96e182adb82e1e8b19f24ef8f74aa742f7500564", "filename": "src/libstd/num/int.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0f637ebd0634f0c8a96a5567d9eab82fc5a181c7/src%2Flibstd%2Fnum%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f637ebd0634f0c8a96a5567d9eab82fc5a181c7/src%2Flibstd%2Fnum%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint.rs?ref=0f637ebd0634f0c8a96a5567d9eab82fc5a181c7", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -123,7 +123,7 @@ impl CheckedMul for int {\n \n #[test]\n fn test_overflows() {\n-    assert!((::int::max_value > 0));\n-    assert!((::int::min_value <= 0));\n-    assert!((::int::min_value + ::int::max_value + 1 == 0));\n+    assert!((::int::MAX > 0));\n+    assert!((::int::MIN <= 0));\n+    assert!((::int::MIN + ::int::MAX + 1 == 0));\n }"}, {"sha": "ca65ade40699c874336df9f3ba587924aa1568ed", "filename": "src/libstd/num/int_macros.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0f637ebd0634f0c8a96a5567d9eab82fc5a181c7/src%2Flibstd%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f637ebd0634f0c8a96a5567d9eab82fc5a181c7/src%2Flibstd%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint_macros.rs?ref=0f637ebd0634f0c8a96a5567d9eab82fc5a181c7", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -15,23 +15,23 @@ macro_rules! int_module (($T:ty, $bits:expr) => (\n \n // FIXME(#11621): Should be deprecated once CTFE is implemented in favour of\n // calling the `mem::size_of` function.\n-pub static bits : uint = $bits;\n+pub static BITS : uint = $bits;\n // FIXME(#11621): Should be deprecated once CTFE is implemented in favour of\n // calling the `mem::size_of` function.\n-pub static bytes : uint = ($bits / 8);\n+pub static BYTES : uint = ($bits / 8);\n \n // FIXME(#11621): Should be deprecated once CTFE is implemented in favour of\n // calling the `Bounded::min_value` function.\n-pub static min_value: $T = (-1 as $T) << (bits - 1);\n-// FIXME(#9837): Compute min_value like this so the high bits that shouldn't exist are 0.\n+pub static MIN: $T = (-1 as $T) << (BITS - 1);\n+// FIXME(#9837): Compute MIN like this so the high bits that shouldn't exist are 0.\n // FIXME(#11621): Should be deprecated once CTFE is implemented in favour of\n // calling the `Bounded::max_value` function.\n-pub static max_value: $T = !min_value;\n+pub static MAX: $T = !MIN;\n \n impl CheckedDiv for $T {\n     #[inline]\n     fn checked_div(&self, v: &$T) -> Option<$T> {\n-        if *v == 0 || (*self == min_value && *v == -1) {\n+        if *v == 0 || (*self == MIN && *v == -1) {\n             None\n         } else {\n             Some(self / *v)\n@@ -361,10 +361,10 @@ impl Not<$T> for $T {\n \n impl Bounded for $T {\n     #[inline]\n-    fn min_value() -> $T { min_value }\n+    fn min_value() -> $T { MIN }\n \n     #[inline]\n-    fn max_value() -> $T { max_value }\n+    fn max_value() -> $T { MAX }\n }\n \n impl Int for $T {}\n@@ -757,7 +757,7 @@ mod tests {\n     fn test_signed_checked_div() {\n         assert_eq!(10i.checked_div(&2), Some(5));\n         assert_eq!(5i.checked_div(&0), None);\n-        assert_eq!(int::min_value.checked_div(&-1), None);\n+        assert_eq!(int::MIN.checked_div(&-1), None);\n     }\n }\n "}, {"sha": "478029b85613f28b7d0bdb4b66dc21bd2fdd161c", "filename": "src/libstd/num/mod.rs", "status": "modified", "additions": 245, "deletions": 245, "changes": 490, "blob_url": "https://github.com/rust-lang/rust/blob/0f637ebd0634f0c8a96a5567d9eab82fc5a181c7/src%2Flibstd%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f637ebd0634f0c8a96a5567d9eab82fc5a181c7/src%2Flibstd%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fmod.rs?ref=0f637ebd0634f0c8a96a5567d9eab82fc5a181c7", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -1159,423 +1159,423 @@ mod tests {\n \n     #[test]\n     fn test_cast_range_int_min() {\n-        assert_eq!(int::min_value.to_int(),  Some(int::min_value as int));\n-        assert_eq!(int::min_value.to_i8(),   None);\n-        assert_eq!(int::min_value.to_i16(),  None);\n-        // int::min_value.to_i32() is word-size specific\n-        assert_eq!(int::min_value.to_i64(),  Some(int::min_value as i64));\n-        assert_eq!(int::min_value.to_uint(), None);\n-        assert_eq!(int::min_value.to_u8(),   None);\n-        assert_eq!(int::min_value.to_u16(),  None);\n-        assert_eq!(int::min_value.to_u32(),  None);\n-        assert_eq!(int::min_value.to_u64(),  None);\n+        assert_eq!(int::MIN.to_int(),  Some(int::MIN as int));\n+        assert_eq!(int::MIN.to_i8(),   None);\n+        assert_eq!(int::MIN.to_i16(),  None);\n+        // int::MIN.to_i32() is word-size specific\n+        assert_eq!(int::MIN.to_i64(),  Some(int::MIN as i64));\n+        assert_eq!(int::MIN.to_uint(), None);\n+        assert_eq!(int::MIN.to_u8(),   None);\n+        assert_eq!(int::MIN.to_u16(),  None);\n+        assert_eq!(int::MIN.to_u32(),  None);\n+        assert_eq!(int::MIN.to_u64(),  None);\n \n         #[cfg(target_word_size = \"32\")]\n         fn check_word_size() {\n-            assert_eq!(int::min_value.to_i32(), Some(int::min_value as i32));\n+            assert_eq!(int::MIN.to_i32(), Some(int::MIN as i32));\n         }\n \n         #[cfg(target_word_size = \"64\")]\n         fn check_word_size() {\n-            assert_eq!(int::min_value.to_i32(), None);\n+            assert_eq!(int::MIN.to_i32(), None);\n         }\n \n         check_word_size();\n     }\n \n     #[test]\n     fn test_cast_range_i8_min() {\n-        assert_eq!(i8::min_value.to_int(),  Some(i8::min_value as int));\n-        assert_eq!(i8::min_value.to_i8(),   Some(i8::min_value as i8));\n-        assert_eq!(i8::min_value.to_i16(),  Some(i8::min_value as i16));\n-        assert_eq!(i8::min_value.to_i32(),  Some(i8::min_value as i32));\n-        assert_eq!(i8::min_value.to_i64(),  Some(i8::min_value as i64));\n-        assert_eq!(i8::min_value.to_uint(), None);\n-        assert_eq!(i8::min_value.to_u8(),   None);\n-        assert_eq!(i8::min_value.to_u16(),  None);\n-        assert_eq!(i8::min_value.to_u32(),  None);\n-        assert_eq!(i8::min_value.to_u64(),  None);\n+        assert_eq!(i8::MIN.to_int(),  Some(i8::MIN as int));\n+        assert_eq!(i8::MIN.to_i8(),   Some(i8::MIN as i8));\n+        assert_eq!(i8::MIN.to_i16(),  Some(i8::MIN as i16));\n+        assert_eq!(i8::MIN.to_i32(),  Some(i8::MIN as i32));\n+        assert_eq!(i8::MIN.to_i64(),  Some(i8::MIN as i64));\n+        assert_eq!(i8::MIN.to_uint(), None);\n+        assert_eq!(i8::MIN.to_u8(),   None);\n+        assert_eq!(i8::MIN.to_u16(),  None);\n+        assert_eq!(i8::MIN.to_u32(),  None);\n+        assert_eq!(i8::MIN.to_u64(),  None);\n     }\n \n     #[test]\n     fn test_cast_range_i16_min() {\n-        assert_eq!(i16::min_value.to_int(),  Some(i16::min_value as int));\n-        assert_eq!(i16::min_value.to_i8(),   None);\n-        assert_eq!(i16::min_value.to_i16(),  Some(i16::min_value as i16));\n-        assert_eq!(i16::min_value.to_i32(),  Some(i16::min_value as i32));\n-        assert_eq!(i16::min_value.to_i64(),  Some(i16::min_value as i64));\n-        assert_eq!(i16::min_value.to_uint(), None);\n-        assert_eq!(i16::min_value.to_u8(),   None);\n-        assert_eq!(i16::min_value.to_u16(),  None);\n-        assert_eq!(i16::min_value.to_u32(),  None);\n-        assert_eq!(i16::min_value.to_u64(),  None);\n+        assert_eq!(i16::MIN.to_int(),  Some(i16::MIN as int));\n+        assert_eq!(i16::MIN.to_i8(),   None);\n+        assert_eq!(i16::MIN.to_i16(),  Some(i16::MIN as i16));\n+        assert_eq!(i16::MIN.to_i32(),  Some(i16::MIN as i32));\n+        assert_eq!(i16::MIN.to_i64(),  Some(i16::MIN as i64));\n+        assert_eq!(i16::MIN.to_uint(), None);\n+        assert_eq!(i16::MIN.to_u8(),   None);\n+        assert_eq!(i16::MIN.to_u16(),  None);\n+        assert_eq!(i16::MIN.to_u32(),  None);\n+        assert_eq!(i16::MIN.to_u64(),  None);\n     }\n \n     #[test]\n     fn test_cast_range_i32_min() {\n-        assert_eq!(i32::min_value.to_int(),  Some(i32::min_value as int));\n-        assert_eq!(i32::min_value.to_i8(),   None);\n-        assert_eq!(i32::min_value.to_i16(),  None);\n-        assert_eq!(i32::min_value.to_i32(),  Some(i32::min_value as i32));\n-        assert_eq!(i32::min_value.to_i64(),  Some(i32::min_value as i64));\n-        assert_eq!(i32::min_value.to_uint(), None);\n-        assert_eq!(i32::min_value.to_u8(),   None);\n-        assert_eq!(i32::min_value.to_u16(),  None);\n-        assert_eq!(i32::min_value.to_u32(),  None);\n-        assert_eq!(i32::min_value.to_u64(),  None);\n+        assert_eq!(i32::MIN.to_int(),  Some(i32::MIN as int));\n+        assert_eq!(i32::MIN.to_i8(),   None);\n+        assert_eq!(i32::MIN.to_i16(),  None);\n+        assert_eq!(i32::MIN.to_i32(),  Some(i32::MIN as i32));\n+        assert_eq!(i32::MIN.to_i64(),  Some(i32::MIN as i64));\n+        assert_eq!(i32::MIN.to_uint(), None);\n+        assert_eq!(i32::MIN.to_u8(),   None);\n+        assert_eq!(i32::MIN.to_u16(),  None);\n+        assert_eq!(i32::MIN.to_u32(),  None);\n+        assert_eq!(i32::MIN.to_u64(),  None);\n     }\n \n     #[test]\n     fn test_cast_range_i64_min() {\n-        // i64::min_value.to_int() is word-size specific\n-        assert_eq!(i64::min_value.to_i8(),   None);\n-        assert_eq!(i64::min_value.to_i16(),  None);\n-        assert_eq!(i64::min_value.to_i32(),  None);\n-        assert_eq!(i64::min_value.to_i64(),  Some(i64::min_value as i64));\n-        assert_eq!(i64::min_value.to_uint(), None);\n-        assert_eq!(i64::min_value.to_u8(),   None);\n-        assert_eq!(i64::min_value.to_u16(),  None);\n-        assert_eq!(i64::min_value.to_u32(),  None);\n-        assert_eq!(i64::min_value.to_u64(),  None);\n+        // i64::MIN.to_int() is word-size specific\n+        assert_eq!(i64::MIN.to_i8(),   None);\n+        assert_eq!(i64::MIN.to_i16(),  None);\n+        assert_eq!(i64::MIN.to_i32(),  None);\n+        assert_eq!(i64::MIN.to_i64(),  Some(i64::MIN as i64));\n+        assert_eq!(i64::MIN.to_uint(), None);\n+        assert_eq!(i64::MIN.to_u8(),   None);\n+        assert_eq!(i64::MIN.to_u16(),  None);\n+        assert_eq!(i64::MIN.to_u32(),  None);\n+        assert_eq!(i64::MIN.to_u64(),  None);\n \n         #[cfg(target_word_size = \"32\")]\n         fn check_word_size() {\n-            assert_eq!(i64::min_value.to_int(), None);\n+            assert_eq!(i64::MIN.to_int(), None);\n         }\n \n         #[cfg(target_word_size = \"64\")]\n         fn check_word_size() {\n-            assert_eq!(i64::min_value.to_int(), Some(i64::min_value as int));\n+            assert_eq!(i64::MIN.to_int(), Some(i64::MIN as int));\n         }\n \n         check_word_size();\n     }\n \n     #[test]\n     fn test_cast_range_int_max() {\n-        assert_eq!(int::max_value.to_int(),  Some(int::max_value as int));\n-        assert_eq!(int::max_value.to_i8(),   None);\n-        assert_eq!(int::max_value.to_i16(),  None);\n-        // int::max_value.to_i32() is word-size specific\n-        assert_eq!(int::max_value.to_i64(),  Some(int::max_value as i64));\n-        assert_eq!(int::max_value.to_u8(),   None);\n-        assert_eq!(int::max_value.to_u16(),  None);\n-        // int::max_value.to_u32() is word-size specific\n-        assert_eq!(int::max_value.to_u64(),  Some(int::max_value as u64));\n+        assert_eq!(int::MAX.to_int(),  Some(int::MAX as int));\n+        assert_eq!(int::MAX.to_i8(),   None);\n+        assert_eq!(int::MAX.to_i16(),  None);\n+        // int::MAX.to_i32() is word-size specific\n+        assert_eq!(int::MAX.to_i64(),  Some(int::MAX as i64));\n+        assert_eq!(int::MAX.to_u8(),   None);\n+        assert_eq!(int::MAX.to_u16(),  None);\n+        // int::MAX.to_u32() is word-size specific\n+        assert_eq!(int::MAX.to_u64(),  Some(int::MAX as u64));\n \n         #[cfg(target_word_size = \"32\")]\n         fn check_word_size() {\n-            assert_eq!(int::max_value.to_i32(), Some(int::max_value as i32));\n-            assert_eq!(int::max_value.to_u32(), Some(int::max_value as u32));\n+            assert_eq!(int::MAX.to_i32(), Some(int::MAX as i32));\n+            assert_eq!(int::MAX.to_u32(), Some(int::MAX as u32));\n         }\n \n         #[cfg(target_word_size = \"64\")]\n         fn check_word_size() {\n-            assert_eq!(int::max_value.to_i32(), None);\n-            assert_eq!(int::max_value.to_u32(), None);\n+            assert_eq!(int::MAX.to_i32(), None);\n+            assert_eq!(int::MAX.to_u32(), None);\n         }\n \n         check_word_size();\n     }\n \n     #[test]\n     fn test_cast_range_i8_max() {\n-        assert_eq!(i8::max_value.to_int(),  Some(i8::max_value as int));\n-        assert_eq!(i8::max_value.to_i8(),   Some(i8::max_value as i8));\n-        assert_eq!(i8::max_value.to_i16(),  Some(i8::max_value as i16));\n-        assert_eq!(i8::max_value.to_i32(),  Some(i8::max_value as i32));\n-        assert_eq!(i8::max_value.to_i64(),  Some(i8::max_value as i64));\n-        assert_eq!(i8::max_value.to_uint(), Some(i8::max_value as uint));\n-        assert_eq!(i8::max_value.to_u8(),   Some(i8::max_value as u8));\n-        assert_eq!(i8::max_value.to_u16(),  Some(i8::max_value as u16));\n-        assert_eq!(i8::max_value.to_u32(),  Some(i8::max_value as u32));\n-        assert_eq!(i8::max_value.to_u64(),  Some(i8::max_value as u64));\n+        assert_eq!(i8::MAX.to_int(),  Some(i8::MAX as int));\n+        assert_eq!(i8::MAX.to_i8(),   Some(i8::MAX as i8));\n+        assert_eq!(i8::MAX.to_i16(),  Some(i8::MAX as i16));\n+        assert_eq!(i8::MAX.to_i32(),  Some(i8::MAX as i32));\n+        assert_eq!(i8::MAX.to_i64(),  Some(i8::MAX as i64));\n+        assert_eq!(i8::MAX.to_uint(), Some(i8::MAX as uint));\n+        assert_eq!(i8::MAX.to_u8(),   Some(i8::MAX as u8));\n+        assert_eq!(i8::MAX.to_u16(),  Some(i8::MAX as u16));\n+        assert_eq!(i8::MAX.to_u32(),  Some(i8::MAX as u32));\n+        assert_eq!(i8::MAX.to_u64(),  Some(i8::MAX as u64));\n     }\n \n     #[test]\n     fn test_cast_range_i16_max() {\n-        assert_eq!(i16::max_value.to_int(),  Some(i16::max_value as int));\n-        assert_eq!(i16::max_value.to_i8(),   None);\n-        assert_eq!(i16::max_value.to_i16(),  Some(i16::max_value as i16));\n-        assert_eq!(i16::max_value.to_i32(),  Some(i16::max_value as i32));\n-        assert_eq!(i16::max_value.to_i64(),  Some(i16::max_value as i64));\n-        assert_eq!(i16::max_value.to_uint(), Some(i16::max_value as uint));\n-        assert_eq!(i16::max_value.to_u8(),   None);\n-        assert_eq!(i16::max_value.to_u16(),  Some(i16::max_value as u16));\n-        assert_eq!(i16::max_value.to_u32(),  Some(i16::max_value as u32));\n-        assert_eq!(i16::max_value.to_u64(),  Some(i16::max_value as u64));\n+        assert_eq!(i16::MAX.to_int(),  Some(i16::MAX as int));\n+        assert_eq!(i16::MAX.to_i8(),   None);\n+        assert_eq!(i16::MAX.to_i16(),  Some(i16::MAX as i16));\n+        assert_eq!(i16::MAX.to_i32(),  Some(i16::MAX as i32));\n+        assert_eq!(i16::MAX.to_i64(),  Some(i16::MAX as i64));\n+        assert_eq!(i16::MAX.to_uint(), Some(i16::MAX as uint));\n+        assert_eq!(i16::MAX.to_u8(),   None);\n+        assert_eq!(i16::MAX.to_u16(),  Some(i16::MAX as u16));\n+        assert_eq!(i16::MAX.to_u32(),  Some(i16::MAX as u32));\n+        assert_eq!(i16::MAX.to_u64(),  Some(i16::MAX as u64));\n     }\n \n     #[test]\n     fn test_cast_range_i32_max() {\n-        assert_eq!(i32::max_value.to_int(),  Some(i32::max_value as int));\n-        assert_eq!(i32::max_value.to_i8(),   None);\n-        assert_eq!(i32::max_value.to_i16(),  None);\n-        assert_eq!(i32::max_value.to_i32(),  Some(i32::max_value as i32));\n-        assert_eq!(i32::max_value.to_i64(),  Some(i32::max_value as i64));\n-        assert_eq!(i32::max_value.to_uint(), Some(i32::max_value as uint));\n-        assert_eq!(i32::max_value.to_u8(),   None);\n-        assert_eq!(i32::max_value.to_u16(),  None);\n-        assert_eq!(i32::max_value.to_u32(),  Some(i32::max_value as u32));\n-        assert_eq!(i32::max_value.to_u64(),  Some(i32::max_value as u64));\n+        assert_eq!(i32::MAX.to_int(),  Some(i32::MAX as int));\n+        assert_eq!(i32::MAX.to_i8(),   None);\n+        assert_eq!(i32::MAX.to_i16(),  None);\n+        assert_eq!(i32::MAX.to_i32(),  Some(i32::MAX as i32));\n+        assert_eq!(i32::MAX.to_i64(),  Some(i32::MAX as i64));\n+        assert_eq!(i32::MAX.to_uint(), Some(i32::MAX as uint));\n+        assert_eq!(i32::MAX.to_u8(),   None);\n+        assert_eq!(i32::MAX.to_u16(),  None);\n+        assert_eq!(i32::MAX.to_u32(),  Some(i32::MAX as u32));\n+        assert_eq!(i32::MAX.to_u64(),  Some(i32::MAX as u64));\n     }\n \n     #[test]\n     fn test_cast_range_i64_max() {\n-        // i64::max_value.to_int() is word-size specific\n-        assert_eq!(i64::max_value.to_i8(),   None);\n-        assert_eq!(i64::max_value.to_i16(),  None);\n-        assert_eq!(i64::max_value.to_i32(),  None);\n-        assert_eq!(i64::max_value.to_i64(),  Some(i64::max_value as i64));\n-        // i64::max_value.to_uint() is word-size specific\n-        assert_eq!(i64::max_value.to_u8(),   None);\n-        assert_eq!(i64::max_value.to_u16(),  None);\n-        assert_eq!(i64::max_value.to_u32(),  None);\n-        assert_eq!(i64::max_value.to_u64(),  Some(i64::max_value as u64));\n+        // i64::MAX.to_int() is word-size specific\n+        assert_eq!(i64::MAX.to_i8(),   None);\n+        assert_eq!(i64::MAX.to_i16(),  None);\n+        assert_eq!(i64::MAX.to_i32(),  None);\n+        assert_eq!(i64::MAX.to_i64(),  Some(i64::MAX as i64));\n+        // i64::MAX.to_uint() is word-size specific\n+        assert_eq!(i64::MAX.to_u8(),   None);\n+        assert_eq!(i64::MAX.to_u16(),  None);\n+        assert_eq!(i64::MAX.to_u32(),  None);\n+        assert_eq!(i64::MAX.to_u64(),  Some(i64::MAX as u64));\n \n         #[cfg(target_word_size = \"32\")]\n         fn check_word_size() {\n-            assert_eq!(i64::max_value.to_int(),  None);\n-            assert_eq!(i64::max_value.to_uint(), None);\n+            assert_eq!(i64::MAX.to_int(),  None);\n+            assert_eq!(i64::MAX.to_uint(), None);\n         }\n \n         #[cfg(target_word_size = \"64\")]\n         fn check_word_size() {\n-            assert_eq!(i64::max_value.to_int(),  Some(i64::max_value as int));\n-            assert_eq!(i64::max_value.to_uint(), Some(i64::max_value as uint));\n+            assert_eq!(i64::MAX.to_int(),  Some(i64::MAX as int));\n+            assert_eq!(i64::MAX.to_uint(), Some(i64::MAX as uint));\n         }\n \n         check_word_size();\n     }\n \n     #[test]\n     fn test_cast_range_uint_min() {\n-        assert_eq!(uint::min_value.to_int(),  Some(uint::min_value as int));\n-        assert_eq!(uint::min_value.to_i8(),   Some(uint::min_value as i8));\n-        assert_eq!(uint::min_value.to_i16(),  Some(uint::min_value as i16));\n-        assert_eq!(uint::min_value.to_i32(),  Some(uint::min_value as i32));\n-        assert_eq!(uint::min_value.to_i64(),  Some(uint::min_value as i64));\n-        assert_eq!(uint::min_value.to_uint(), Some(uint::min_value as uint));\n-        assert_eq!(uint::min_value.to_u8(),   Some(uint::min_value as u8));\n-        assert_eq!(uint::min_value.to_u16(),  Some(uint::min_value as u16));\n-        assert_eq!(uint::min_value.to_u32(),  Some(uint::min_value as u32));\n-        assert_eq!(uint::min_value.to_u64(),  Some(uint::min_value as u64));\n+        assert_eq!(uint::MIN.to_int(),  Some(uint::MIN as int));\n+        assert_eq!(uint::MIN.to_i8(),   Some(uint::MIN as i8));\n+        assert_eq!(uint::MIN.to_i16(),  Some(uint::MIN as i16));\n+        assert_eq!(uint::MIN.to_i32(),  Some(uint::MIN as i32));\n+        assert_eq!(uint::MIN.to_i64(),  Some(uint::MIN as i64));\n+        assert_eq!(uint::MIN.to_uint(), Some(uint::MIN as uint));\n+        assert_eq!(uint::MIN.to_u8(),   Some(uint::MIN as u8));\n+        assert_eq!(uint::MIN.to_u16(),  Some(uint::MIN as u16));\n+        assert_eq!(uint::MIN.to_u32(),  Some(uint::MIN as u32));\n+        assert_eq!(uint::MIN.to_u64(),  Some(uint::MIN as u64));\n     }\n \n     #[test]\n     fn test_cast_range_u8_min() {\n-        assert_eq!(u8::min_value.to_int(),  Some(u8::min_value as int));\n-        assert_eq!(u8::min_value.to_i8(),   Some(u8::min_value as i8));\n-        assert_eq!(u8::min_value.to_i16(),  Some(u8::min_value as i16));\n-        assert_eq!(u8::min_value.to_i32(),  Some(u8::min_value as i32));\n-        assert_eq!(u8::min_value.to_i64(),  Some(u8::min_value as i64));\n-        assert_eq!(u8::min_value.to_uint(), Some(u8::min_value as uint));\n-        assert_eq!(u8::min_value.to_u8(),   Some(u8::min_value as u8));\n-        assert_eq!(u8::min_value.to_u16(),  Some(u8::min_value as u16));\n-        assert_eq!(u8::min_value.to_u32(),  Some(u8::min_value as u32));\n-        assert_eq!(u8::min_value.to_u64(),  Some(u8::min_value as u64));\n+        assert_eq!(u8::MIN.to_int(),  Some(u8::MIN as int));\n+        assert_eq!(u8::MIN.to_i8(),   Some(u8::MIN as i8));\n+        assert_eq!(u8::MIN.to_i16(),  Some(u8::MIN as i16));\n+        assert_eq!(u8::MIN.to_i32(),  Some(u8::MIN as i32));\n+        assert_eq!(u8::MIN.to_i64(),  Some(u8::MIN as i64));\n+        assert_eq!(u8::MIN.to_uint(), Some(u8::MIN as uint));\n+        assert_eq!(u8::MIN.to_u8(),   Some(u8::MIN as u8));\n+        assert_eq!(u8::MIN.to_u16(),  Some(u8::MIN as u16));\n+        assert_eq!(u8::MIN.to_u32(),  Some(u8::MIN as u32));\n+        assert_eq!(u8::MIN.to_u64(),  Some(u8::MIN as u64));\n     }\n \n     #[test]\n     fn test_cast_range_u16_min() {\n-        assert_eq!(u16::min_value.to_int(),  Some(u16::min_value as int));\n-        assert_eq!(u16::min_value.to_i8(),   Some(u16::min_value as i8));\n-        assert_eq!(u16::min_value.to_i16(),  Some(u16::min_value as i16));\n-        assert_eq!(u16::min_value.to_i32(),  Some(u16::min_value as i32));\n-        assert_eq!(u16::min_value.to_i64(),  Some(u16::min_value as i64));\n-        assert_eq!(u16::min_value.to_uint(), Some(u16::min_value as uint));\n-        assert_eq!(u16::min_value.to_u8(),   Some(u16::min_value as u8));\n-        assert_eq!(u16::min_value.to_u16(),  Some(u16::min_value as u16));\n-        assert_eq!(u16::min_value.to_u32(),  Some(u16::min_value as u32));\n-        assert_eq!(u16::min_value.to_u64(),  Some(u16::min_value as u64));\n+        assert_eq!(u16::MIN.to_int(),  Some(u16::MIN as int));\n+        assert_eq!(u16::MIN.to_i8(),   Some(u16::MIN as i8));\n+        assert_eq!(u16::MIN.to_i16(),  Some(u16::MIN as i16));\n+        assert_eq!(u16::MIN.to_i32(),  Some(u16::MIN as i32));\n+        assert_eq!(u16::MIN.to_i64(),  Some(u16::MIN as i64));\n+        assert_eq!(u16::MIN.to_uint(), Some(u16::MIN as uint));\n+        assert_eq!(u16::MIN.to_u8(),   Some(u16::MIN as u8));\n+        assert_eq!(u16::MIN.to_u16(),  Some(u16::MIN as u16));\n+        assert_eq!(u16::MIN.to_u32(),  Some(u16::MIN as u32));\n+        assert_eq!(u16::MIN.to_u64(),  Some(u16::MIN as u64));\n     }\n \n     #[test]\n     fn test_cast_range_u32_min() {\n-        assert_eq!(u32::min_value.to_int(),  Some(u32::min_value as int));\n-        assert_eq!(u32::min_value.to_i8(),   Some(u32::min_value as i8));\n-        assert_eq!(u32::min_value.to_i16(),  Some(u32::min_value as i16));\n-        assert_eq!(u32::min_value.to_i32(),  Some(u32::min_value as i32));\n-        assert_eq!(u32::min_value.to_i64(),  Some(u32::min_value as i64));\n-        assert_eq!(u32::min_value.to_uint(), Some(u32::min_value as uint));\n-        assert_eq!(u32::min_value.to_u8(),   Some(u32::min_value as u8));\n-        assert_eq!(u32::min_value.to_u16(),  Some(u32::min_value as u16));\n-        assert_eq!(u32::min_value.to_u32(),  Some(u32::min_value as u32));\n-        assert_eq!(u32::min_value.to_u64(),  Some(u32::min_value as u64));\n+        assert_eq!(u32::MIN.to_int(),  Some(u32::MIN as int));\n+        assert_eq!(u32::MIN.to_i8(),   Some(u32::MIN as i8));\n+        assert_eq!(u32::MIN.to_i16(),  Some(u32::MIN as i16));\n+        assert_eq!(u32::MIN.to_i32(),  Some(u32::MIN as i32));\n+        assert_eq!(u32::MIN.to_i64(),  Some(u32::MIN as i64));\n+        assert_eq!(u32::MIN.to_uint(), Some(u32::MIN as uint));\n+        assert_eq!(u32::MIN.to_u8(),   Some(u32::MIN as u8));\n+        assert_eq!(u32::MIN.to_u16(),  Some(u32::MIN as u16));\n+        assert_eq!(u32::MIN.to_u32(),  Some(u32::MIN as u32));\n+        assert_eq!(u32::MIN.to_u64(),  Some(u32::MIN as u64));\n     }\n \n     #[test]\n     fn test_cast_range_u64_min() {\n-        assert_eq!(u64::min_value.to_int(),  Some(u64::min_value as int));\n-        assert_eq!(u64::min_value.to_i8(),   Some(u64::min_value as i8));\n-        assert_eq!(u64::min_value.to_i16(),  Some(u64::min_value as i16));\n-        assert_eq!(u64::min_value.to_i32(),  Some(u64::min_value as i32));\n-        assert_eq!(u64::min_value.to_i64(),  Some(u64::min_value as i64));\n-        assert_eq!(u64::min_value.to_uint(), Some(u64::min_value as uint));\n-        assert_eq!(u64::min_value.to_u8(),   Some(u64::min_value as u8));\n-        assert_eq!(u64::min_value.to_u16(),  Some(u64::min_value as u16));\n-        assert_eq!(u64::min_value.to_u32(),  Some(u64::min_value as u32));\n-        assert_eq!(u64::min_value.to_u64(),  Some(u64::min_value as u64));\n+        assert_eq!(u64::MIN.to_int(),  Some(u64::MIN as int));\n+        assert_eq!(u64::MIN.to_i8(),   Some(u64::MIN as i8));\n+        assert_eq!(u64::MIN.to_i16(),  Some(u64::MIN as i16));\n+        assert_eq!(u64::MIN.to_i32(),  Some(u64::MIN as i32));\n+        assert_eq!(u64::MIN.to_i64(),  Some(u64::MIN as i64));\n+        assert_eq!(u64::MIN.to_uint(), Some(u64::MIN as uint));\n+        assert_eq!(u64::MIN.to_u8(),   Some(u64::MIN as u8));\n+        assert_eq!(u64::MIN.to_u16(),  Some(u64::MIN as u16));\n+        assert_eq!(u64::MIN.to_u32(),  Some(u64::MIN as u32));\n+        assert_eq!(u64::MIN.to_u64(),  Some(u64::MIN as u64));\n     }\n \n     #[test]\n     fn test_cast_range_uint_max() {\n-        assert_eq!(uint::max_value.to_int(),  None);\n-        assert_eq!(uint::max_value.to_i8(),   None);\n-        assert_eq!(uint::max_value.to_i16(),  None);\n-        assert_eq!(uint::max_value.to_i32(),  None);\n-        // uint::max_value.to_i64() is word-size specific\n-        assert_eq!(uint::max_value.to_u8(),   None);\n-        assert_eq!(uint::max_value.to_u16(),  None);\n-        // uint::max_value.to_u32() is word-size specific\n-        assert_eq!(uint::max_value.to_u64(),  Some(uint::max_value as u64));\n+        assert_eq!(uint::MAX.to_int(),  None);\n+        assert_eq!(uint::MAX.to_i8(),   None);\n+        assert_eq!(uint::MAX.to_i16(),  None);\n+        assert_eq!(uint::MAX.to_i32(),  None);\n+        // uint::MAX.to_i64() is word-size specific\n+        assert_eq!(uint::MAX.to_u8(),   None);\n+        assert_eq!(uint::MAX.to_u16(),  None);\n+        // uint::MAX.to_u32() is word-size specific\n+        assert_eq!(uint::MAX.to_u64(),  Some(uint::MAX as u64));\n \n         #[cfg(target_word_size = \"32\")]\n         fn check_word_size() {\n-            assert_eq!(uint::max_value.to_u32(), Some(uint::max_value as u32));\n-            assert_eq!(uint::max_value.to_i64(), Some(uint::max_value as i64));\n+            assert_eq!(uint::MAX.to_u32(), Some(uint::MAX as u32));\n+            assert_eq!(uint::MAX.to_i64(), Some(uint::MAX as i64));\n         }\n \n         #[cfg(target_word_size = \"64\")]\n         fn check_word_size() {\n-            assert_eq!(uint::max_value.to_u32(), None);\n-            assert_eq!(uint::max_value.to_i64(), None);\n+            assert_eq!(uint::MAX.to_u32(), None);\n+            assert_eq!(uint::MAX.to_i64(), None);\n         }\n \n         check_word_size();\n     }\n \n     #[test]\n     fn test_cast_range_u8_max() {\n-        assert_eq!(u8::max_value.to_int(),  Some(u8::max_value as int));\n-        assert_eq!(u8::max_value.to_i8(),   None);\n-        assert_eq!(u8::max_value.to_i16(),  Some(u8::max_value as i16));\n-        assert_eq!(u8::max_value.to_i32(),  Some(u8::max_value as i32));\n-        assert_eq!(u8::max_value.to_i64(),  Some(u8::max_value as i64));\n-        assert_eq!(u8::max_value.to_uint(), Some(u8::max_value as uint));\n-        assert_eq!(u8::max_value.to_u8(),   Some(u8::max_value as u8));\n-        assert_eq!(u8::max_value.to_u16(),  Some(u8::max_value as u16));\n-        assert_eq!(u8::max_value.to_u32(),  Some(u8::max_value as u32));\n-        assert_eq!(u8::max_value.to_u64(),  Some(u8::max_value as u64));\n+        assert_eq!(u8::MAX.to_int(),  Some(u8::MAX as int));\n+        assert_eq!(u8::MAX.to_i8(),   None);\n+        assert_eq!(u8::MAX.to_i16(),  Some(u8::MAX as i16));\n+        assert_eq!(u8::MAX.to_i32(),  Some(u8::MAX as i32));\n+        assert_eq!(u8::MAX.to_i64(),  Some(u8::MAX as i64));\n+        assert_eq!(u8::MAX.to_uint(), Some(u8::MAX as uint));\n+        assert_eq!(u8::MAX.to_u8(),   Some(u8::MAX as u8));\n+        assert_eq!(u8::MAX.to_u16(),  Some(u8::MAX as u16));\n+        assert_eq!(u8::MAX.to_u32(),  Some(u8::MAX as u32));\n+        assert_eq!(u8::MAX.to_u64(),  Some(u8::MAX as u64));\n     }\n \n     #[test]\n     fn test_cast_range_u16_max() {\n-        assert_eq!(u16::max_value.to_int(),  Some(u16::max_value as int));\n-        assert_eq!(u16::max_value.to_i8(),   None);\n-        assert_eq!(u16::max_value.to_i16(),  None);\n-        assert_eq!(u16::max_value.to_i32(),  Some(u16::max_value as i32));\n-        assert_eq!(u16::max_value.to_i64(),  Some(u16::max_value as i64));\n-        assert_eq!(u16::max_value.to_uint(), Some(u16::max_value as uint));\n-        assert_eq!(u16::max_value.to_u8(),   None);\n-        assert_eq!(u16::max_value.to_u16(),  Some(u16::max_value as u16));\n-        assert_eq!(u16::max_value.to_u32(),  Some(u16::max_value as u32));\n-        assert_eq!(u16::max_value.to_u64(),  Some(u16::max_value as u64));\n+        assert_eq!(u16::MAX.to_int(),  Some(u16::MAX as int));\n+        assert_eq!(u16::MAX.to_i8(),   None);\n+        assert_eq!(u16::MAX.to_i16(),  None);\n+        assert_eq!(u16::MAX.to_i32(),  Some(u16::MAX as i32));\n+        assert_eq!(u16::MAX.to_i64(),  Some(u16::MAX as i64));\n+        assert_eq!(u16::MAX.to_uint(), Some(u16::MAX as uint));\n+        assert_eq!(u16::MAX.to_u8(),   None);\n+        assert_eq!(u16::MAX.to_u16(),  Some(u16::MAX as u16));\n+        assert_eq!(u16::MAX.to_u32(),  Some(u16::MAX as u32));\n+        assert_eq!(u16::MAX.to_u64(),  Some(u16::MAX as u64));\n     }\n \n     #[test]\n     fn test_cast_range_u32_max() {\n-        // u32::max_value.to_int() is word-size specific\n-        assert_eq!(u32::max_value.to_i8(),   None);\n-        assert_eq!(u32::max_value.to_i16(),  None);\n-        assert_eq!(u32::max_value.to_i32(),  None);\n-        assert_eq!(u32::max_value.to_i64(),  Some(u32::max_value as i64));\n-        assert_eq!(u32::max_value.to_uint(), Some(u32::max_value as uint));\n-        assert_eq!(u32::max_value.to_u8(),   None);\n-        assert_eq!(u32::max_value.to_u16(),  None);\n-        assert_eq!(u32::max_value.to_u32(),  Some(u32::max_value as u32));\n-        assert_eq!(u32::max_value.to_u64(),  Some(u32::max_value as u64));\n+        // u32::MAX.to_int() is word-size specific\n+        assert_eq!(u32::MAX.to_i8(),   None);\n+        assert_eq!(u32::MAX.to_i16(),  None);\n+        assert_eq!(u32::MAX.to_i32(),  None);\n+        assert_eq!(u32::MAX.to_i64(),  Some(u32::MAX as i64));\n+        assert_eq!(u32::MAX.to_uint(), Some(u32::MAX as uint));\n+        assert_eq!(u32::MAX.to_u8(),   None);\n+        assert_eq!(u32::MAX.to_u16(),  None);\n+        assert_eq!(u32::MAX.to_u32(),  Some(u32::MAX as u32));\n+        assert_eq!(u32::MAX.to_u64(),  Some(u32::MAX as u64));\n \n         #[cfg(target_word_size = \"32\")]\n         fn check_word_size() {\n-            assert_eq!(u32::max_value.to_int(),  None);\n+            assert_eq!(u32::MAX.to_int(),  None);\n         }\n \n         #[cfg(target_word_size = \"64\")]\n         fn check_word_size() {\n-            assert_eq!(u32::max_value.to_int(),  Some(u32::max_value as int));\n+            assert_eq!(u32::MAX.to_int(),  Some(u32::MAX as int));\n         }\n \n         check_word_size();\n     }\n \n     #[test]\n     fn test_cast_range_u64_max() {\n-        assert_eq!(u64::max_value.to_int(),  None);\n-        assert_eq!(u64::max_value.to_i8(),   None);\n-        assert_eq!(u64::max_value.to_i16(),  None);\n-        assert_eq!(u64::max_value.to_i32(),  None);\n-        assert_eq!(u64::max_value.to_i64(),  None);\n-        // u64::max_value.to_uint() is word-size specific\n-        assert_eq!(u64::max_value.to_u8(),   None);\n-        assert_eq!(u64::max_value.to_u16(),  None);\n-        assert_eq!(u64::max_value.to_u32(),  None);\n-        assert_eq!(u64::max_value.to_u64(),  Some(u64::max_value as u64));\n+        assert_eq!(u64::MAX.to_int(),  None);\n+        assert_eq!(u64::MAX.to_i8(),   None);\n+        assert_eq!(u64::MAX.to_i16(),  None);\n+        assert_eq!(u64::MAX.to_i32(),  None);\n+        assert_eq!(u64::MAX.to_i64(),  None);\n+        // u64::MAX.to_uint() is word-size specific\n+        assert_eq!(u64::MAX.to_u8(),   None);\n+        assert_eq!(u64::MAX.to_u16(),  None);\n+        assert_eq!(u64::MAX.to_u32(),  None);\n+        assert_eq!(u64::MAX.to_u64(),  Some(u64::MAX as u64));\n \n         #[cfg(target_word_size = \"32\")]\n         fn check_word_size() {\n-            assert_eq!(u64::max_value.to_uint(), None);\n+            assert_eq!(u64::MAX.to_uint(), None);\n         }\n \n         #[cfg(target_word_size = \"64\")]\n         fn check_word_size() {\n-            assert_eq!(u64::max_value.to_uint(), Some(u64::max_value as uint));\n+            assert_eq!(u64::MAX.to_uint(), Some(u64::MAX as uint));\n         }\n \n         check_word_size();\n     }\n \n     #[test]\n     fn test_saturating_add_uint() {\n-        use uint::max_value;\n+        use uint::MAX;\n         assert_eq!(3u.saturating_add(5u), 8u);\n-        assert_eq!(3u.saturating_add(max_value-1), max_value);\n-        assert_eq!(max_value.saturating_add(max_value), max_value);\n-        assert_eq!((max_value-2).saturating_add(1), max_value-1);\n+        assert_eq!(3u.saturating_add(MAX-1), MAX);\n+        assert_eq!(MAX.saturating_add(MAX), MAX);\n+        assert_eq!((MAX-2).saturating_add(1), MAX-1);\n     }\n \n     #[test]\n     fn test_saturating_sub_uint() {\n-        use uint::max_value;\n+        use uint::MAX;\n         assert_eq!(5u.saturating_sub(3u), 2u);\n         assert_eq!(3u.saturating_sub(5u), 0u);\n         assert_eq!(0u.saturating_sub(1u), 0u);\n-        assert_eq!((max_value-1).saturating_sub(max_value), 0);\n+        assert_eq!((MAX-1).saturating_sub(MAX), 0);\n     }\n \n     #[test]\n     fn test_saturating_add_int() {\n-        use int::{min_value,max_value};\n+        use int::{MIN,MAX};\n         assert_eq!(3i.saturating_add(5i), 8i);\n-        assert_eq!(3i.saturating_add(max_value-1), max_value);\n-        assert_eq!(max_value.saturating_add(max_value), max_value);\n-        assert_eq!((max_value-2).saturating_add(1), max_value-1);\n+        assert_eq!(3i.saturating_add(MAX-1), MAX);\n+        assert_eq!(MAX.saturating_add(MAX), MAX);\n+        assert_eq!((MAX-2).saturating_add(1), MAX-1);\n         assert_eq!(3i.saturating_add(-5i), -2i);\n-        assert_eq!(min_value.saturating_add(-1i), min_value);\n-        assert_eq!((-2i).saturating_add(-max_value), min_value);\n+        assert_eq!(MIN.saturating_add(-1i), MIN);\n+        assert_eq!((-2i).saturating_add(-MAX), MIN);\n     }\n \n     #[test]\n     fn test_saturating_sub_int() {\n-        use int::{min_value,max_value};\n+        use int::{MIN,MAX};\n         assert_eq!(3i.saturating_sub(5i), -2i);\n-        assert_eq!(min_value.saturating_sub(1i), min_value);\n-        assert_eq!((-2i).saturating_sub(max_value), min_value);\n+        assert_eq!(MIN.saturating_sub(1i), MIN);\n+        assert_eq!((-2i).saturating_sub(MAX), MIN);\n         assert_eq!(3i.saturating_sub(-5i), 8i);\n-        assert_eq!(3i.saturating_sub(-(max_value-1)), max_value);\n-        assert_eq!(max_value.saturating_sub(-max_value), max_value);\n-        assert_eq!((max_value-2).saturating_sub(-1), max_value-1);\n+        assert_eq!(3i.saturating_sub(-(MAX-1)), MAX);\n+        assert_eq!(MAX.saturating_sub(-MAX), MAX);\n+        assert_eq!((MAX-2).saturating_sub(-1), MAX-1);\n     }\n \n     #[test]\n     fn test_checked_add() {\n-        let five_less = uint::max_value - 5;\n-        assert_eq!(five_less.checked_add(&0), Some(uint::max_value - 5));\n-        assert_eq!(five_less.checked_add(&1), Some(uint::max_value - 4));\n-        assert_eq!(five_less.checked_add(&2), Some(uint::max_value - 3));\n-        assert_eq!(five_less.checked_add(&3), Some(uint::max_value - 2));\n-        assert_eq!(five_less.checked_add(&4), Some(uint::max_value - 1));\n-        assert_eq!(five_less.checked_add(&5), Some(uint::max_value));\n+        let five_less = uint::MAX - 5;\n+        assert_eq!(five_less.checked_add(&0), Some(uint::MAX - 5));\n+        assert_eq!(five_less.checked_add(&1), Some(uint::MAX - 4));\n+        assert_eq!(five_less.checked_add(&2), Some(uint::MAX - 3));\n+        assert_eq!(five_less.checked_add(&3), Some(uint::MAX - 2));\n+        assert_eq!(five_less.checked_add(&4), Some(uint::MAX - 1));\n+        assert_eq!(five_less.checked_add(&5), Some(uint::MAX));\n         assert_eq!(five_less.checked_add(&6), None);\n         assert_eq!(five_less.checked_add(&7), None);\n     }\n@@ -1594,7 +1594,7 @@ mod tests {\n \n     #[test]\n     fn test_checked_mul() {\n-        let third = uint::max_value / 3;\n+        let third = uint::MAX / 3;\n         assert_eq!(third.checked_mul(&0), Some(0));\n         assert_eq!(third.checked_mul(&1), Some(third));\n         assert_eq!(third.checked_mul(&2), Some(third * 2));"}, {"sha": "3eeae6283b382ff192cdcbb00eea4a3d8d98a25f", "filename": "src/libstd/num/uint.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0f637ebd0634f0c8a96a5567d9eab82fc5a181c7/src%2Flibstd%2Fnum%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f637ebd0634f0c8a96a5567d9eab82fc5a181c7/src%2Flibstd%2Fnum%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint.rs?ref=0f637ebd0634f0c8a96a5567d9eab82fc5a181c7", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -25,7 +25,7 @@ use option::{Option, Some, None};\n use str;\n use unstable::intrinsics;\n \n-uint_module!(uint, int, ::int::bits)\n+uint_module!(uint, int, ::int::BITS)\n \n ///\n /// Divide two numbers, return the result, rounded up.\n@@ -234,9 +234,9 @@ fn test_next_power_of_two() {\n #[test]\n fn test_overflows() {\n     use uint;\n-    assert!((uint::max_value > 0u));\n-    assert!((uint::min_value <= 0u));\n-    assert!((uint::min_value + uint::max_value + 1u == 0u));\n+    assert!((uint::MAX > 0u));\n+    assert!((uint::MIN <= 0u));\n+    assert!((uint::MIN + uint::MAX + 1u == 0u));\n }\n \n #[test]"}, {"sha": "5b9767e68e8dafdf61d62c38df676417f82ba976", "filename": "src/libstd/num/uint_macros.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0f637ebd0634f0c8a96a5567d9eab82fc5a181c7/src%2Flibstd%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f637ebd0634f0c8a96a5567d9eab82fc5a181c7/src%2Flibstd%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint_macros.rs?ref=0f637ebd0634f0c8a96a5567d9eab82fc5a181c7", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -13,11 +13,11 @@\n \n macro_rules! uint_module (($T:ty, $T_SIGNED:ty, $bits:expr) => (\n \n-pub static bits : uint = $bits;\n-pub static bytes : uint = ($bits / 8);\n+pub static BITS : uint = $bits;\n+pub static BYTES : uint = ($bits / 8);\n \n-pub static min_value: $T = 0 as $T;\n-pub static max_value: $T = 0 as $T - 1 as $T;\n+pub static MIN: $T = 0 as $T;\n+pub static MAX: $T = 0 as $T - 1 as $T;\n \n impl CheckedDiv for $T {\n     #[inline]\n@@ -214,10 +214,10 @@ impl Not<$T> for $T {\n \n impl Bounded for $T {\n     #[inline]\n-    fn min_value() -> $T { min_value }\n+    fn min_value() -> $T { MIN }\n \n     #[inline]\n-    fn max_value() -> $T { max_value }\n+    fn max_value() -> $T { MAX }\n }\n \n impl Int for $T {}\n@@ -398,7 +398,7 @@ mod tests {\n         assert_eq!(0b0110 as $T, (0b1100 as $T).bitxor(&(0b1010 as $T)));\n         assert_eq!(0b1110 as $T, (0b0111 as $T).shl(&(1 as $T)));\n         assert_eq!(0b0111 as $T, (0b1110 as $T).shr(&(1 as $T)));\n-        assert_eq!(max_value - (0b1011 as $T), (0b1011 as $T).not());\n+        assert_eq!(MAX - (0b1011 as $T), (0b1011 as $T).not());\n     }\n \n     #[test]"}, {"sha": "833f20210434b651eca55ad501941d933173873f", "filename": "src/libstd/option.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f637ebd0634f0c8a96a5567d9eab82fc5a181c7/src%2Flibstd%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f637ebd0634f0c8a96a5567d9eab82fc5a181c7/src%2Flibstd%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foption.rs?ref=0f637ebd0634f0c8a96a5567d9eab82fc5a181c7", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -441,7 +441,7 @@ impl<A> ExactSize<A> for Item<A> {}\n /// checking for overflow:\n ///\n ///     fn inc_conditionally(x: uint) -> Option<uint> {\n-///         if x == uint::max_value { return None; }\n+///         if x == uint::MAX { return None; }\n ///         else { return Some(x+1u); }\n ///     }\n ///     let v = [1u, 2, 3];"}, {"sha": "8f4752b3c44c7e3f684e118fdda574b1b5193be3", "filename": "src/libstd/rand/rand_impls.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f637ebd0634f0c8a96a5567d9eab82fc5a181c7/src%2Flibstd%2Frand%2Frand_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f637ebd0634f0c8a96a5567d9eab82fc5a181c7/src%2Flibstd%2Frand%2Frand_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Frand_impls.rs?ref=0f637ebd0634f0c8a96a5567d9eab82fc5a181c7", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -19,7 +19,7 @@ use uint;\n impl Rand for int {\n     #[inline]\n     fn rand<R: Rng>(rng: &mut R) -> int {\n-        if int::bits == 32 {\n+        if int::BITS == 32 {\n             rng.gen::<i32>() as int\n         } else {\n             rng.gen::<i64>() as int\n@@ -58,7 +58,7 @@ impl Rand for i64 {\n impl Rand for uint {\n     #[inline]\n     fn rand<R: Rng>(rng: &mut R) -> uint {\n-        if uint::bits == 32 {\n+        if uint::BITS == 32 {\n             rng.gen::<u32>() as uint\n         } else {\n             rng.gen::<u64>() as uint"}, {"sha": "62049e8b4c99ae4e53f06bb9b28327d0f9a79b3e", "filename": "src/libstd/result.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f637ebd0634f0c8a96a5567d9eab82fc5a181c7/src%2Flibstd%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f637ebd0634f0c8a96a5567d9eab82fc5a181c7/src%2Flibstd%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fresult.rs?ref=0f637ebd0634f0c8a96a5567d9eab82fc5a181c7", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -227,7 +227,7 @@ impl<T: fmt::Default, E: fmt::Default> fmt::Default for Result<T, E> {\n /// checking for overflow:\n ///\n ///     fn inc_conditionally(x: uint) -> Result<uint, &'static str> {\n-///         if x == uint::max_value { return Err(\"overflow\"); }\n+///         if x == uint::MAX { return Err(\"overflow\"); }\n ///         else { return Ok(x+1u); }\n ///     }\n ///     let v = [1u, 2, 3];"}, {"sha": "d543af1bf9bf78852f45e4fede76745da852fa63", "filename": "src/libstd/rt/thread.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f637ebd0634f0c8a96a5567d9eab82fc5a181c7/src%2Flibstd%2Frt%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f637ebd0634f0c8a96a5567d9eab82fc5a181c7/src%2Flibstd%2Frt%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fthread.rs?ref=0f637ebd0634f0c8a96a5567d9eab82fc5a181c7", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -43,7 +43,7 @@ static DEFAULT_STACK_SIZE: uint = 1024 * 1024;\n extern fn thread_start(main: *libc::c_void) -> imp::rust_thread_return {\n     use unstable::stack;\n     unsafe {\n-        stack::record_stack_bounds(0, uint::max_value);\n+        stack::record_stack_bounds(0, uint::MAX);\n         let f: ~proc() = cast::transmute(main);\n         (*f)();\n         cast::transmute(0 as imp::rust_thread_return)"}, {"sha": "ef0930fabf1cd2605c20c00d27108475765d7301", "filename": "src/libstd/trie.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0f637ebd0634f0c8a96a5567d9eab82fc5a181c7/src%2Flibstd%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f637ebd0634f0c8a96a5567d9eab82fc5a181c7/src%2Flibstd%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftrie.rs?ref=0f637ebd0634f0c8a96a5567d9eab82fc5a181c7", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -21,7 +21,7 @@ use vec;\n static SHIFT: uint = 4;\n static SIZE: uint = 1 << SHIFT;\n static MASK: uint = SIZE - 1;\n-static NUM_CHUNKS: uint = uint::bits / SHIFT;\n+static NUM_CHUNKS: uint = uint::BITS / SHIFT;\n \n enum Child<T> {\n     Internal(~TrieNode<T>),\n@@ -396,7 +396,7 @@ impl<T> TrieNode<T> {\n // if this was done via a trait, the key could be generic\n #[inline]\n fn chunk(n: uint, idx: uint) -> uint {\n-    let sh = uint::bits - (SHIFT * (idx + 1));\n+    let sh = uint::BITS - (SHIFT * (idx + 1));\n     (n >> sh) & MASK\n }\n \n@@ -728,14 +728,14 @@ mod test_map {\n     fn test_each_reverse_break() {\n         let mut m = TrieMap::new();\n \n-        for x in range(uint::max_value - 10000, uint::max_value).rev() {\n+        for x in range(uint::MAX - 10000, uint::MAX).rev() {\n             m.insert(x, x / 2);\n         }\n \n-        let mut n = uint::max_value - 1;\n+        let mut n = uint::MAX - 1;\n         m.each_reverse(|k, v| {\n-            if n == uint::max_value - 5000 { false } else {\n-                assert!(n > uint::max_value - 5000);\n+            if n == uint::MAX - 5000 { false } else {\n+                assert!(n > uint::MAX - 5000);\n \n                 assert_eq!(*k, n);\n                 assert_eq!(*v, n / 2);\n@@ -777,8 +777,8 @@ mod test_map {\n         let empty_map : TrieMap<uint> = TrieMap::new();\n         assert_eq!(empty_map.iter().next(), None);\n \n-        let first = uint::max_value - 10000;\n-        let last = uint::max_value;\n+        let first = uint::MAX - 10000;\n+        let last = uint::MAX;\n \n         let mut map = TrieMap::new();\n         for x in range(first, last).rev() {\n@@ -799,8 +799,8 @@ mod test_map {\n         let mut empty_map : TrieMap<uint> = TrieMap::new();\n         assert!(empty_map.mut_iter().next().is_none());\n \n-        let first = uint::max_value - 10000;\n-        let last = uint::max_value;\n+        let first = uint::MAX - 10000;\n+        let last = uint::MAX;\n \n         let mut map = TrieMap::new();\n         for x in range(first, last).rev() {\n@@ -1014,7 +1014,7 @@ mod test_set {\n     #[test]\n     fn test_sane_chunk() {\n         let x = 1;\n-        let y = 1 << (uint::bits - 1);\n+        let y = 1 << (uint::BITS - 1);\n \n         let mut trie = TrieSet::new();\n "}, {"sha": "ba965f2b5c5b2f0513efe220ae855309e4b05377", "filename": "src/libstd/unstable/mutex.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0f637ebd0634f0c8a96a5567d9eab82fc5a181c7/src%2Flibstd%2Funstable%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f637ebd0634f0c8a96a5567d9eab82fc5a181c7/src%2Flibstd%2Funstable%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fmutex.rs?ref=0f637ebd0634f0c8a96a5567d9eab82fc5a181c7", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -389,9 +389,9 @@ impl Once {\n \n         let prev = self.cnt.fetch_add(1, atomics::SeqCst);\n         if prev < 0 {\n-            // Make sure we never overflow, we'll never have int::min_value\n+            // Make sure we never overflow, we'll never have int::MIN\n             // simultaneous calls to `doit` to make this value go back to 0\n-            self.cnt.store(int::min_value, atomics::SeqCst);\n+            self.cnt.store(int::MIN, atomics::SeqCst);\n             return\n         }\n \n@@ -401,7 +401,7 @@ impl Once {\n         unsafe { self.mutex.lock() }\n         if self.cnt.load(atomics::SeqCst) > 0 {\n             f();\n-            let prev = self.cnt.swap(int::min_value, atomics::SeqCst);\n+            let prev = self.cnt.swap(int::MIN, atomics::SeqCst);\n             self.lock_cnt.store(prev, atomics::SeqCst);\n         }\n         unsafe { self.mutex.unlock() }"}, {"sha": "3cc05ee82282e06bf42d612da7ac4e60bdd9a5f0", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f637ebd0634f0c8a96a5567d9eab82fc5a181c7/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f637ebd0634f0c8a96a5567d9eab82fc5a181c7/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=0f637ebd0634f0c8a96a5567d9eab82fc5a181c7", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -1072,7 +1072,7 @@ impl<'a,T> ImmutableVector<'a, T> for &'a [T] {\n \n     #[inline]\n     fn split(self, pred: 'a |&T| -> bool) -> Splits<'a, T> {\n-        self.splitn(uint::max_value, pred)\n+        self.splitn(uint::MAX, pred)\n     }\n \n     #[inline]\n@@ -1087,7 +1087,7 @@ impl<'a,T> ImmutableVector<'a, T> for &'a [T] {\n \n     #[inline]\n     fn rsplit(self, pred: 'a |&T| -> bool) -> RevSplits<'a, T> {\n-        self.rsplitn(uint::max_value, pred)\n+        self.rsplitn(uint::MAX, pred)\n     }\n \n     #[inline]"}, {"sha": "d3504f8d204660fbc3f27dfd8de3bae7c7c03a92", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f637ebd0634f0c8a96a5567d9eab82fc5a181c7/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f637ebd0634f0c8a96a5567d9eab82fc5a181c7/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=0f637ebd0634f0c8a96a5567d9eab82fc5a181c7", "patch": "@@ -340,8 +340,8 @@ pub struct IdRange {\n impl IdRange {\n     pub fn max() -> IdRange {\n         IdRange {\n-            min: u32::max_value,\n-            max: u32::min_value,\n+            min: u32::MAX,\n+            max: u32::MIN,\n         }\n     }\n "}, {"sha": "aa5e4e01ae0a050aeecd023493aa9770448972fe", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f637ebd0634f0c8a96a5567d9eab82fc5a181c7/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f637ebd0634f0c8a96a5567d9eab82fc5a181c7/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=0f637ebd0634f0c8a96a5567d9eab82fc5a181c7", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -78,7 +78,7 @@ pub fn strip_doc_comment_decoration(comment: &str) -> ~str {\n \n     /// remove a \"[ \\t]*\\*\" block from each line, if possible\n     fn horizontal_trim(lines: ~[~str]) -> ~[~str] {\n-        let mut i = uint::max_value;\n+        let mut i = uint::MAX;\n         let mut can_trim = true;\n         let mut first = true;\n         for line in lines.iter() {"}, {"sha": "be4ad0781f272f9ee40110772d5b1b79000ca3e9", "filename": "src/test/run-fail/bounds-check-no-overflow.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f637ebd0634f0c8a96a5567d9eab82fc5a181c7/src%2Ftest%2Frun-fail%2Fbounds-check-no-overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f637ebd0634f0c8a96a5567d9eab82fc5a181c7/src%2Ftest%2Frun-fail%2Fbounds-check-no-overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fbounds-check-no-overflow.rs?ref=0f637ebd0634f0c8a96a5567d9eab82fc5a181c7", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -10,10 +10,10 @@\n \n // error-pattern:index out of bounds: the len is 3 but the index is\n \n-use std::uint::max_value;\n+use std::uint;\n use std::mem::size_of;\n \n fn main() {\n     let xs = [1, 2, 3];\n-    xs[max_value / size_of::<int>() + 1];\n+    xs[uint::MAX / size_of::<int>() + 1];\n }"}, {"sha": "60f3dd9b277f33d3b33562c69fd6aba72080ce9e", "filename": "src/test/run-fail/bug-2470-bounds-check-overflow-2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f637ebd0634f0c8a96a5567d9eab82fc5a181c7/src%2Ftest%2Frun-fail%2Fbug-2470-bounds-check-overflow-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f637ebd0634f0c8a96a5567d9eab82fc5a181c7/src%2Ftest%2Frun-fail%2Fbug-2470-bounds-check-overflow-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fbug-2470-bounds-check-overflow-2.rs?ref=0f637ebd0634f0c8a96a5567d9eab82fc5a181c7", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -21,7 +21,7 @@ fn main() {\n     // length (in bytes), because the scaling of the index will cause it to\n     // wrap around to a small number.\n \n-    let idx = uint::max_value & !(uint::max_value >> 1u);\n+    let idx = uint::MAX & !(uint::MAX >> 1u);\n     error!(\"ov2 idx = 0x%x\", idx);\n \n     // This should fail."}, {"sha": "62c4c5c735a223f5756369c1746874ef03568221", "filename": "src/test/run-fail/bug-2470-bounds-check-overflow-3.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f637ebd0634f0c8a96a5567d9eab82fc5a181c7/src%2Ftest%2Frun-fail%2Fbug-2470-bounds-check-overflow-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f637ebd0634f0c8a96a5567d9eab82fc5a181c7/src%2Ftest%2Frun-fail%2Fbug-2470-bounds-check-overflow-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fbug-2470-bounds-check-overflow-3.rs?ref=0f637ebd0634f0c8a96a5567d9eab82fc5a181c7", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -23,7 +23,7 @@ fn main() {\n \n     // This test is only meaningful on 32-bit hosts.\n \n-    let idx = u64::max_value & !(u64::max_value >> 1u);\n+    let idx = u64::MAX & !(u64::MAX >> 1u);\n     error!(\"ov3 idx = 0x%8.8x%8.8x\",\n            (idx >> 32) as uint,\n            idx as uint);"}, {"sha": "bf63290a011f917afd5dd55ac84de45c295c9489", "filename": "src/test/run-pass/deriving-primitive.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f637ebd0634f0c8a96a5567d9eab82fc5a181c7/src%2Ftest%2Frun-pass%2Fderiving-primitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f637ebd0634f0c8a96a5567d9eab82fc5a181c7/src%2Ftest%2Frun-pass%2Fderiving-primitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-primitive.rs?ref=0f637ebd0634f0c8a96a5567d9eab82fc5a181c7", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -13,14 +13,14 @@ use std::int;\n \n #[deriving(Eq, FromPrimitive)]\n enum A {\n-    Foo = int::max_value,\n+    Foo = int::MAX,\n     Bar = 1,\n     Baz = 3,\n     Qux,\n }\n \n pub fn main() {\n-    let x: Option<A> = FromPrimitive::from_int(int::max_value);\n+    let x: Option<A> = FromPrimitive::from_int(int::MAX);\n     assert_eq!(x, Some(Foo));\n \n     let x: Option<A> = FromPrimitive::from_int(1);"}]}