{"sha": "f309dc3c0fae39b993f95058a619f8591e9935df", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYzMDlkYzNjMGZhZTM5Yjk5M2Y5NTA1OGE2MTlmODU5MWU5OTM1ZGY=", "commit": {"author": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-02-10T00:22:53Z"}, "committer": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-02-12T13:30:52Z"}, "message": "Add the MATCH_SAME_ARMS lint", "tree": {"sha": "e7ffb00346e6f8f5f96a37d20a832abc5e2783fd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e7ffb00346e6f8f5f96a37d20a832abc5e2783fd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f309dc3c0fae39b993f95058a619f8591e9935df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f309dc3c0fae39b993f95058a619f8591e9935df", "html_url": "https://github.com/rust-lang/rust/commit/f309dc3c0fae39b993f95058a619f8591e9935df", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f309dc3c0fae39b993f95058a619f8591e9935df/comments", "author": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cbbc667b1b77764949714285356f475159bd2491", "url": "https://api.github.com/repos/rust-lang/rust/commits/cbbc667b1b77764949714285356f475159bd2491", "html_url": "https://github.com/rust-lang/rust/commit/cbbc667b1b77764949714285356f475159bd2491"}], "stats": {"total": 201, "additions": 162, "deletions": 39}, "files": [{"sha": "c2d3b16074cc4f8043e349778d338451ab110bff", "filename": "README.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f309dc3c0fae39b993f95058a619f8591e9935df/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/f309dc3c0fae39b993f95058a619f8591e9935df/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=f309dc3c0fae39b993f95058a619f8591e9935df", "patch": "@@ -6,7 +6,7 @@ A collection of lints to catch common mistakes and improve your Rust code.\n [Jump to usage instructions](#usage)\n \n ##Lints\n-There are 119 lints included in this crate:\n+There are 120 lints included in this crate:\n \n name                                                                                                           | default | meaning\n ---------------------------------------------------------------------------------------------------------------|---------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n@@ -65,6 +65,7 @@ name\n [match_bool](https://github.com/Manishearth/rust-clippy/wiki#match_bool)                                       | warn    | a match on boolean expression; recommends `if..else` block instead\n [match_overlapping_arm](https://github.com/Manishearth/rust-clippy/wiki#match_overlapping_arm)                 | warn    | a match has overlapping arms\n [match_ref_pats](https://github.com/Manishearth/rust-clippy/wiki#match_ref_pats)                               | warn    | a match or `if let` has all arms prefixed with `&`; the match expression can be dereferenced instead\n+[match_same_arms](https://github.com/Manishearth/rust-clippy/wiki#match_same_arms)                             | warn    | `match` with identical arm bodies\n [min_max](https://github.com/Manishearth/rust-clippy/wiki#min_max)                                             | warn    | `min(_, max(_, _))` (or vice versa) with bounds clamping the result to a constant\n [modulo_one](https://github.com/Manishearth/rust-clippy/wiki#modulo_one)                                       | warn    | taking a number modulo 1, which always returns 0\n [mut_mut](https://github.com/Manishearth/rust-clippy/wiki#mut_mut)                                             | allow   | usage of double-mut refs, e.g. `&mut &mut ...` (either copy'n'paste error, or shows a fundamental misunderstanding of references)"}, {"sha": "aea17c3132dd113e635108a5c5f0cd22b7d2bcae", "filename": "src/copies.rs", "status": "modified", "additions": 110, "deletions": 16, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/f309dc3c0fae39b993f95058a619f8591e9935df/src%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f309dc3c0fae39b993f95058a619f8591e9935df/src%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcopies.rs?ref=f309dc3c0fae39b993f95058a619f8591e9935df", "patch": "@@ -1,7 +1,9 @@\n use rustc::lint::*;\n+use rustc::middle::ty;\n use rustc_front::hir::*;\n use std::collections::HashMap;\n use std::collections::hash_map::Entry;\n+use syntax::parse::token::InternedString;\n use utils::{SpanlessEq, SpanlessHash};\n use utils::{get_parent_expr, in_macro, span_note_and_lint};\n \n@@ -33,14 +35,34 @@ declare_lint! {\n     \"if with the same *then* and *else* blocks\"\n }\n \n+/// **What it does:** This lint checks for `match` with identical arm bodies.\n+///\n+/// **Why is this bad?** This is probably a copy & paste error.\n+///\n+/// **Known problems:** Hopefully none.\n+///\n+/// **Example:**\n+/// ```rust,ignore\n+/// match foo {\n+///     Bar => bar(),\n+///     Quz => quz(),\n+///     Baz => bar(), // <= oups\n+/// ```\n+declare_lint! {\n+    pub MATCH_SAME_ARMS,\n+    Warn,\n+    \"`match` with identical arm bodies\"\n+}\n+\n #[derive(Copy, Clone, Debug)]\n pub struct CopyAndPaste;\n \n impl LintPass for CopyAndPaste {\n     fn get_lints(&self) -> LintArray {\n         lint_array![\n             IFS_SAME_COND,\n-            IF_SAME_THEN_ELSE\n+            IF_SAME_THEN_ELSE,\n+            MATCH_SAME_ARMS\n         ]\n     }\n }\n@@ -58,39 +80,63 @@ impl LateLintPass for CopyAndPaste {\n             let (conds, blocks) = if_sequence(expr);\n             lint_same_then_else(cx, &blocks);\n             lint_same_cond(cx, &conds);\n+            lint_match_arms(cx, expr);\n         }\n     }\n }\n \n /// Implementation of `IF_SAME_THEN_ELSE`.\n fn lint_same_then_else(cx: &LateContext, blocks: &[&Block]) {\n-    let hash = |block| -> u64 {\n+    let hash : &Fn(&&Block) -> u64 = &|block| -> u64 {\n         let mut h = SpanlessHash::new(cx);\n         h.hash_block(block);\n         h.finish()\n     };\n-    let eq = |lhs, rhs| -> bool {\n+\n+    let eq : &Fn(&&Block, &&Block) -> bool = &|&lhs, &rhs| -> bool {\n         SpanlessEq::new(cx).eq_block(lhs, rhs)\n     };\n \n     if let Some((i, j)) = search_same(blocks, hash, eq) {\n-        span_note_and_lint(cx, IF_SAME_THEN_ELSE, j.span, \"this if has identical blocks\", i.span, \"same as this\");\n+        span_note_and_lint(cx, IF_SAME_THEN_ELSE, j.span, \"this `if` has identical blocks\", i.span, \"same as this\");\n     }\n }\n \n /// Implementation of `IFS_SAME_COND`.\n fn lint_same_cond(cx: &LateContext, conds: &[&Expr]) {\n-    let hash = |expr| -> u64 {\n+    let hash : &Fn(&&Expr) -> u64 = &|expr| -> u64 {\n         let mut h = SpanlessHash::new(cx);\n         h.hash_expr(expr);\n         h.finish()\n     };\n-    let eq = |lhs, rhs| -> bool {\n+\n+    let eq : &Fn(&&Expr, &&Expr) -> bool = &|&lhs, &rhs| -> bool {\n         SpanlessEq::new(cx).ignore_fn().eq_expr(lhs, rhs)\n     };\n \n     if let Some((i, j)) = search_same(conds, hash, eq) {\n-        span_note_and_lint(cx, IFS_SAME_COND, j.span, \"this if has the same condition as a previous if\", i.span, \"same as this\");\n+        span_note_and_lint(cx, IFS_SAME_COND, j.span, \"this `if` has the same condition as a previous if\", i.span, \"same as this\");\n+    }\n+}\n+\n+/// Implementation if `MATCH_SAME_ARMS`.\n+fn lint_match_arms(cx: &LateContext, expr: &Expr) {\n+    let hash = |arm: &Arm| -> u64 {\n+        let mut h = SpanlessHash::new(cx);\n+        h.hash_expr(&arm.body);\n+        h.finish()\n+    };\n+\n+    let eq = |lhs: &Arm, rhs: &Arm| -> bool {\n+        SpanlessEq::new(cx).eq_expr(&lhs.body, &rhs.body) &&\n+            // all patterns should have the same bindings\n+            bindings(cx, &lhs.pats[0]) == bindings(cx, &rhs.pats[0])\n+    };\n+\n+    if let ExprMatch(_, ref arms, MatchSource::Normal) = expr.node {\n+        if let Some((i, j)) = search_same(&**arms, hash, eq) {\n+            span_note_and_lint(cx, MATCH_SAME_ARMS, j.body.span, \"this `match` has identical arm bodies\", i.body.span, \"same as this\");\n+        }\n     }\n }\n \n@@ -123,11 +169,59 @@ fn if_sequence(mut expr: &Expr) -> (Vec<&Expr>, Vec<&Block>) {\n     (conds, blocks)\n }\n \n-fn search_same<'a, T, Hash, Eq>(exprs: &[&'a T],\n-                                hash: Hash,\n-                                eq: Eq) -> Option<(&'a T, &'a T)>\n-where Hash: Fn(&'a T) -> u64,\n-      Eq: Fn(&'a T, &'a T) -> bool {\n+/// Return the list of bindings in a pattern.\n+fn bindings<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, pat: &Pat) -> HashMap<InternedString, ty::Ty<'tcx>> {\n+    fn bindings_impl<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, pat: &Pat, map: &mut HashMap<InternedString, ty::Ty<'tcx>>) {\n+        match pat.node {\n+            PatBox(ref pat) | PatRegion(ref pat, _) => bindings_impl(cx, pat, map),\n+            PatEnum(_, Some(ref pats)) => {\n+                for pat in pats {\n+                    bindings_impl(cx, pat, map);\n+                }\n+            }\n+            PatIdent(_, ref ident, ref as_pat) => {\n+                if let Entry::Vacant(v) = map.entry(ident.node.name.as_str()) {\n+                    v.insert(cx.tcx.pat_ty(pat));\n+                }\n+                if let Some(ref as_pat) = *as_pat {\n+                    bindings_impl(cx, as_pat, map);\n+                }\n+            },\n+            PatStruct(_, ref fields, _) => {\n+                for pat in fields {\n+                    bindings_impl(cx, &pat.node.pat, map);\n+                }\n+            }\n+            PatTup(ref fields) => {\n+                for pat in fields {\n+                    bindings_impl(cx, pat, map);\n+                }\n+            }\n+            PatVec(ref lhs, ref mid, ref rhs) => {\n+                for pat in lhs {\n+                    bindings_impl(cx, pat, map);\n+                }\n+                if let Some(ref mid) = *mid {\n+                    bindings_impl(cx, mid, map);\n+                }\n+                for pat in rhs {\n+                    bindings_impl(cx, pat, map);\n+                }\n+            }\n+            PatEnum(..) | PatLit(..) | PatQPath(..) | PatRange(..) | PatWild => (),\n+        }\n+    }\n+\n+    let mut result = HashMap::new();\n+    bindings_impl(cx, pat, &mut result);\n+    result\n+}\n+\n+fn search_same<T, Hash, Eq>(exprs: &[T],\n+                            hash: Hash,\n+                            eq: Eq) -> Option<(&T, &T)>\n+where Hash: Fn(&T) -> u64,\n+      Eq: Fn(&T, &T) -> bool {\n     // common cases\n     if exprs.len() < 2 {\n         return None;\n@@ -141,14 +235,14 @@ where Hash: Fn(&'a T) -> u64,\n         }\n     }\n \n-    let mut map : HashMap<_, Vec<&'a _>> = HashMap::with_capacity(exprs.len());\n+    let mut map : HashMap<_, Vec<&_>> = HashMap::with_capacity(exprs.len());\n \n-    for &expr in exprs {\n+    for expr in exprs {\n         match map.entry(hash(expr)) {\n             Entry::Occupied(o) => {\n                 for o in o.get() {\n-                    if eq(o, expr) {\n-                        return Some((o, expr))\n+                    if eq(&o, expr) {\n+                        return Some((&o, expr))\n                     }\n                 }\n             }"}, {"sha": "675dbdd2dd712500ea8acfc76439c26eeb8c4f75", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f309dc3c0fae39b993f95058a619f8591e9935df/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f309dc3c0fae39b993f95058a619f8591e9935df/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=f309dc3c0fae39b993f95058a619f8591e9935df", "patch": "@@ -196,6 +196,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n         collapsible_if::COLLAPSIBLE_IF,\n         copies::IF_SAME_THEN_ELSE,\n         copies::IFS_SAME_COND,\n+        copies::MATCH_SAME_ARMS,\n         cyclomatic_complexity::CYCLOMATIC_COMPLEXITY,\n         derive::DERIVE_HASH_NOT_EQ,\n         derive::EXPL_IMPL_CLONE_ON_COPY,"}, {"sha": "623f9967bd40a10bfde235f4965741bbc5fe4962", "filename": "tests/compile-fail/copies.rs", "status": "modified", "additions": 49, "deletions": 22, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/f309dc3c0fae39b993f95058a619f8591e9935df/tests%2Fcompile-fail%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f309dc3c0fae39b993f95058a619f8591e9935df/tests%2Fcompile-fail%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fcopies.rs?ref=f309dc3c0fae39b993f95058a619f8591e9935df", "patch": "@@ -5,15 +5,18 @@\n #![allow(let_and_return)]\n #![allow(needless_return)]\n #![allow(unused_variables)]\n+#![allow(cyclomatic_complexity)]\n \n+fn bar<T>(_: T) {}\n fn foo() -> bool { unimplemented!() }\n \n #[deny(if_same_then_else)]\n+#[deny(match_same_arms)]\n fn if_same_then_else() -> &'static str {\n     if true {\n         foo();\n     }\n-    else { //~ERROR this if has identical blocks\n+    else { //~ERROR this `if` has identical blocks\n         foo();\n     }\n \n@@ -29,7 +32,7 @@ fn if_same_then_else() -> &'static str {\n         foo();\n         42\n     }\n-    else { //~ERROR this if has identical blocks\n+    else { //~ERROR this `if` has identical blocks\n         foo();\n         42\n     };\n@@ -41,7 +44,7 @@ fn if_same_then_else() -> &'static str {\n     let _ = if true {\n         42\n     }\n-    else { //~ERROR this if has identical blocks\n+    else { //~ERROR this `if` has identical blocks\n         42\n     };\n \n@@ -56,7 +59,7 @@ fn if_same_then_else() -> &'static str {\n         while foo() { break; }\n         bar + 1;\n     }\n-    else { //~ERROR this if has identical blocks\n+    else { //~ERROR this `if` has identical blocks\n         let bar = if true {\n             42\n         }\n@@ -69,29 +72,29 @@ fn if_same_then_else() -> &'static str {\n     }\n \n     if true {\n-        match 42 {\n-            42 => (),\n-            a if a > 0 => (),\n-            10...15 => (),\n-            _ => (),\n-        }\n+        let _ = match 42 {\n+            42 => 1,\n+            a if a > 0 => 2,\n+            10...15 => 3,\n+            _ => 4,\n+        };\n     }\n     else if false {\n         foo();\n     }\n-    else if foo() { //~ERROR this if has identical blocks\n-        match 42 {\n-            42 => (),\n-            a if a > 0 => (),\n-            10...15 => (),\n-            _ => (),\n-        }\n+    else if foo() { //~ERROR this `if` has identical blocks\n+        let _ = match 42 {\n+            42 => 1,\n+            a if a > 0 => 2,\n+            10...15 => 3,\n+            _ => 4,\n+        };\n     }\n \n     if true {\n         if let Some(a) = Some(42) {}\n     }\n-    else { //~ERROR this if has identical blocks\n+    else { //~ERROR this `if` has identical blocks\n         if let Some(a) = Some(42) {}\n     }\n \n@@ -102,6 +105,30 @@ fn if_same_then_else() -> &'static str {\n         if let Some(a) = Some(43) {}\n     }\n \n+    let _ = match 42 {\n+        42 => foo(),\n+        51 => foo(), //~ERROR this `match` has identical arm bodies\n+        _ => true,\n+    };\n+\n+    let _ = match Some(42) {\n+        Some(42) => 24,\n+        Some(a) => 24, // bindings are different\n+        None => 0,\n+    };\n+\n+    match (Some(42), Some(42)) {\n+        (Some(a), None) => bar(a),\n+        (None, Some(a)) => bar(a), //~ERROR this `match` has identical arm bodies\n+        _ => (),\n+    }\n+\n+    match (Some(42), Some(\"\")) {\n+        (Some(a), None) => bar(a),\n+        (None, Some(a)) => bar(a), // bindings have different types\n+        _ => (),\n+    }\n+\n     if true {\n         let foo = \"\";\n         return &foo[0..];\n@@ -110,7 +137,7 @@ fn if_same_then_else() -> &'static str {\n         let foo = \"bar\";\n         return &foo[0..];\n     }\n-    else { //~ERROR this if has identical blocks\n+    else { //~ERROR this `if` has identical blocks\n         let foo = \"\";\n         return &foo[0..];\n     }\n@@ -124,19 +151,19 @@ fn ifs_same_cond() {\n \n     if b {\n     }\n-    else if b { //~ERROR this if has the same condition as a previous if\n+    else if b { //~ERROR this `if` has the same condition as a previous if\n     }\n \n     if a == 1 {\n     }\n-    else if a == 1 { //~ERROR this if has the same condition as a previous if\n+    else if a == 1 { //~ERROR this `if` has the same condition as a previous if\n     }\n \n     if 2*a == 1 {\n     }\n     else if 2*a == 2 {\n     }\n-    else if 2*a == 1 { //~ERROR this if has the same condition as a previous if\n+    else if 2*a == 1 { //~ERROR this `if` has the same condition as a previous if\n     }\n     else if a == 1 {\n     }"}]}