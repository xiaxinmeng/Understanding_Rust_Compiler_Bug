{"sha": "577054c6ded13a70ee07d6fc3397518ae1e81710", "node_id": "C_kwDOAAsO6NoAKDU3NzA1NGM2ZGVkMTNhNzBlZTA3ZDZmYzMzOTc1MThhZTFlODE3MTA", "commit": {"author": {"name": "Andy Wang", "email": "cbeuw.andy@gmail.com", "date": "2022-05-16T21:26:38Z"}, "committer": {"name": "Andy Wang", "email": "cbeuw.andy@gmail.com", "date": "2022-06-06T18:15:54Z"}, "message": "Rename variables in AllocationMap", "tree": {"sha": "0c0e3cc7f3842f7ce92d42e27178d8b0099afa67", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0c0e3cc7f3842f7ce92d42e27178d8b0099afa67"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/577054c6ded13a70ee07d6fc3397518ae1e81710", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEE7dcbcBMl24/h63ldGBtJ+fOPM3QFAmKeRFoACgkQGBtJ+fOP\nM3TxaAv/fVsCB/eqT5CgYr/8A1pIKR0uuaQTvhK4lPmuSrbnMG6MmQt9NjrxFAle\nVxd9fjcau5oKBz1EzggC3nNyedRKZoYRdXcq6zXs7aVexMiataOTpINY6AEczHnr\nwOcWVNwT53DRtGoKp55tVXK4dySIzzJbw5RLUzmb3P2GyQrkdrrCmVeCcrZFgvjU\n6l2kr8misLb/8f38/kmQcc/OcNdYj+0ZMtjHyYx0C21RhsIXzaxiNKrtSBLE5fFc\nJTCWJTUqAfYpc+nLKMINCXtveyGQIec6sDCUQXk4to4Qlx4APNkj+88rSsnrInHA\nWEigJfe6U+Awg6s1nYgYotTpTX160wYl10ovPCqHs8xxKDbfkne+prOyuZ9GnvYB\nmGhIbP+uTQtqg4W9P6F6JHz0aSlL5ZdAU1v8p4PDRSE/70Ecqewp25EM/7bPtWds\nNOVbjUiq/CIIR4qrKi7yhSzpea89HLnd/B6dLLu5THyOa+7SJc2ur0BxsIQTgChp\nozAsG5Bd\n=JAHw\n-----END PGP SIGNATURE-----", "payload": "tree 0c0e3cc7f3842f7ce92d42e27178d8b0099afa67\nparent 6b54c9237789c275a82eeb483052b302f490b57c\nauthor Andy Wang <cbeuw.andy@gmail.com> 1652736398 +0100\ncommitter Andy Wang <cbeuw.andy@gmail.com> 1654539354 +0100\n\nRename variables in AllocationMap\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/577054c6ded13a70ee07d6fc3397518ae1e81710", "html_url": "https://github.com/rust-lang/rust/commit/577054c6ded13a70ee07d6fc3397518ae1e81710", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/577054c6ded13a70ee07d6fc3397518ae1e81710/comments", "author": {"login": "cbeuw", "id": 7034308, "node_id": "MDQ6VXNlcjcwMzQzMDg=", "avatar_url": "https://avatars.githubusercontent.com/u/7034308?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cbeuw", "html_url": "https://github.com/cbeuw", "followers_url": "https://api.github.com/users/cbeuw/followers", "following_url": "https://api.github.com/users/cbeuw/following{/other_user}", "gists_url": "https://api.github.com/users/cbeuw/gists{/gist_id}", "starred_url": "https://api.github.com/users/cbeuw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cbeuw/subscriptions", "organizations_url": "https://api.github.com/users/cbeuw/orgs", "repos_url": "https://api.github.com/users/cbeuw/repos", "events_url": "https://api.github.com/users/cbeuw/events{/privacy}", "received_events_url": "https://api.github.com/users/cbeuw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cbeuw", "id": 7034308, "node_id": "MDQ6VXNlcjcwMzQzMDg=", "avatar_url": "https://avatars.githubusercontent.com/u/7034308?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cbeuw", "html_url": "https://github.com/cbeuw", "followers_url": "https://api.github.com/users/cbeuw/followers", "following_url": "https://api.github.com/users/cbeuw/following{/other_user}", "gists_url": "https://api.github.com/users/cbeuw/gists{/gist_id}", "starred_url": "https://api.github.com/users/cbeuw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cbeuw/subscriptions", "organizations_url": "https://api.github.com/users/cbeuw/orgs", "repos_url": "https://api.github.com/users/cbeuw/repos", "events_url": "https://api.github.com/users/cbeuw/events{/privacy}", "received_events_url": "https://api.github.com/users/cbeuw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6b54c9237789c275a82eeb483052b302f490b57c", "url": "https://api.github.com/repos/rust-lang/rust/commits/6b54c9237789c275a82eeb483052b302f490b57c", "html_url": "https://github.com/rust-lang/rust/commit/6b54c9237789c275a82eeb483052b302f490b57c"}], "stats": {"total": 105, "additions": 54, "deletions": 51}, "files": [{"sha": "2524389c0be834683c62230e2627dec8c056a37e", "filename": "src/concurrency/allocation_map.rs", "status": "modified", "additions": 38, "deletions": 35, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/577054c6ded13a70ee07d6fc3397518ae1e81710/src%2Fconcurrency%2Fallocation_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/577054c6ded13a70ee07d6fc3397518ae1e81710/src%2Fconcurrency%2Fallocation_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconcurrency%2Fallocation_map.rs?ref=577054c6ded13a70ee07d6fc3397518ae1e81710", "patch": "@@ -49,7 +49,7 @@ impl<T> AllocationMap<T> {\n         loop {\n             if left == right {\n                 // No element contains the given offset. But the\n-                // index is where such element should be placed at.\n+                // position is where such element should be placed at.\n                 return Err(left);\n             }\n             let candidate = left.checked_add(right).unwrap() / 2;\n@@ -73,68 +73,71 @@ impl<T> AllocationMap<T> {\n     /// an existing allocation\n     pub fn access_type(&self, range: AllocRange) -> AccessType {\n         match self.find_offset(range.start) {\n-            Ok(index) => {\n+            Ok(pos) => {\n                 // Start of the range belongs to an existing object, now let's check the overlapping situation\n-                let elem = &self.v[index];\n+                let elem = &self.v[pos];\n                 // FIXME: derive Eq for AllocRange in rustc\n                 if elem.range.start == range.start && elem.range.size == range.size {\n                     // Happy case: perfectly overlapping access\n-                    AccessType::PerfectlyOverlapping(index)\n+                    AccessType::PerfectlyOverlapping(pos)\n                 } else {\n                     // FIXME: add a last() method to AllocRange that returns the last inclusive offset (end() is exclusive)\n-                    let end_index = match self.find_offset(range.end() - Size::from_bytes(1)) {\n-                        // If the end lands in an existing object, add one to get the exclusive index\n-                        Ok(inclusive) => inclusive + 1,\n-                        Err(exclusive) => exclusive,\n+                    let end_pos = match self.find_offset(range.end() - Size::from_bytes(1)) {\n+                        // If the end lands in an existing object, add one to get the exclusive position\n+                        Ok(inclusive_pos) => inclusive_pos + 1,\n+                        Err(exclusive_pos) => exclusive_pos,\n                     };\n \n-                    AccessType::ImperfectlyOverlapping(index..end_index)\n+                    AccessType::ImperfectlyOverlapping(pos..end_pos)\n                 }\n             }\n-            Err(index) => {\n+            Err(pos) => {\n                 // Start of the range doesn't belong to an existing object\n                 match self.find_offset(range.end() - Size::from_bytes(1)) {\n                     // Neither does the end\n-                    Err(end_index) =>\n-                        if index == end_index {\n+                    Err(end_pos) =>\n+                        if pos == end_pos {\n                             // There's nothing between the start and the end, so the range thing is empty\n-                            AccessType::Empty(index)\n+                            AccessType::Empty(pos)\n                         } else {\n                             // Otherwise we have entirely covered an existing object\n-                            AccessType::ImperfectlyOverlapping(index..end_index)\n+                            AccessType::ImperfectlyOverlapping(pos..end_pos)\n                         },\n                     // Otherwise at least part of it overlaps with something else\n-                    Ok(end_index) => AccessType::ImperfectlyOverlapping(index..end_index + 1),\n+                    Ok(end_pos) => AccessType::ImperfectlyOverlapping(pos..end_pos + 1),\n                 }\n             }\n         }\n     }\n \n     /// Inserts an object and its occupied range at given position\n-    pub fn insert(&mut self, index: Position, range: AllocRange, data: T) {\n-        self.v.insert(index, Elem { range, data });\n+    // The Position can be calculated from AllocRange, but the only user of AllocationMap\n+    // always calls access_type before calling insert/index/index_mut, and we don't\n+    // want to repeat the binary search on each time, so we ask the caller to supply Position\n+    pub fn insert_at_pos(&mut self, pos: Position, range: AllocRange, data: T) {\n+        self.v.insert(pos, Elem { range, data });\n         // If we aren't the first element, then our start must be greater than the preivous element's end\n-        if index > 0 {\n-            debug_assert!(self.v[index - 1].range.end() <= range.start);\n+        if pos > 0 {\n+            debug_assert!(self.v[pos - 1].range.end() <= range.start);\n         }\n         // If we aren't the last element, then our end must be smaller than next element's start\n-        if index < self.v.len() - 1 {\n-            debug_assert!(range.end() <= self.v[index + 1].range.start);\n+        if pos < self.v.len() - 1 {\n+            debug_assert!(range.end() <= self.v[pos + 1].range.start);\n         }\n     }\n }\n \n impl<T> Index<Position> for AllocationMap<T> {\n     type Output = T;\n \n-    fn index(&self, index: usize) -> &Self::Output {\n-        &self.v[index].data\n+    fn index(&self, pos: Position) -> &Self::Output {\n+        &self.v[pos].data\n     }\n }\n \n impl<T> IndexMut<Position> for AllocationMap<T> {\n-    fn index_mut(&mut self, index: usize) -> &mut Self::Output {\n-        &mut self.v[index].data\n+    fn index_mut(&mut self, pos: Position) -> &mut Self::Output {\n+        &mut self.v[pos].data\n     }\n }\n \n@@ -150,10 +153,10 @@ mod tests {\n         let four = Size::from_bytes(4);\n         let map = AllocationMap::<()>::new();\n \n-        // Correctly tells where we should insert the first element (at index 0)\n+        // Correctly tells where we should insert the first element (at position 0)\n         assert_eq!(map.find_offset(Size::from_bytes(3)), Err(0));\n \n-        // Correctly tells the access type along with the supposed index\n+        // Correctly tells the access type along with the supposed position\n         assert_eq!(map.access_type(alloc_range(Size::ZERO, four)), AccessType::Empty(0));\n     }\n \n@@ -166,10 +169,10 @@ mod tests {\n \n         // |_|_|_|_|#|#|#|#|_|_|_|_|...\n         //  0 1 2 3 4 5 6 7 8 9 a b c d\n-        map.insert(0, alloc_range(four, four), \"#\");\n+        map.insert_at_pos(0, alloc_range(four, four), \"#\");\n         // |_|_|_|_|#|#|#|#|_|_|_|_|...\n         //  0 ^ ^ ^ ^ 5 6 7 8 9 a b c d\n-        map.insert(0, alloc_range(Size::from_bytes(1), four), \"@\");\n+        map.insert_at_pos(0, alloc_range(Size::from_bytes(1), four), \"@\");\n     }\n \n     #[test]\n@@ -180,7 +183,7 @@ mod tests {\n \n         // |#|#|#|#|_|_|...\n         //  0 1 2 3 4 5\n-        map.insert(0, alloc_range(Size::ZERO, four), \"#\");\n+        map.insert_at_pos(0, alloc_range(Size::ZERO, four), \"#\");\n         // |#|#|#|#|_|_|...\n         //  0 1 2 3 ^ 5\n         assert_eq!(map.find_offset(four), Err(1));\n@@ -191,7 +194,7 @@ mod tests {\n         let eight = Size::from_bytes(8);\n         // |#|#|#|#|_|_|_|_|@|@|@|@|_|_|...\n         //  0 1 2 3 4 5 6 7 8 9 a b c d\n-        map.insert(1, alloc_range(eight, four), \"@\");\n+        map.insert_at_pos(1, alloc_range(eight, four), \"@\");\n         // |#|#|#|#|_|_|_|_|@|@|@|@|_|_|...\n         //  0 1 2 3 4 5 6 ^ 8 9 a b c d\n         assert_eq!(map.find_offset(Size::from_bytes(7)), Err(1));\n@@ -208,7 +211,7 @@ mod tests {\n \n         // |#|#|#|#|_|_|...\n         //  0 1 2 3 4 5\n-        map.insert(0, alloc_range(Size::ZERO, four), \"#\");\n+        map.insert_at_pos(0, alloc_range(Size::ZERO, four), \"#\");\n         // |#|#|#|#|_|_|...\n         //  ^ ^ ^ ^ 4 5\n         assert_eq!(map.find_offset(Size::ZERO), Ok(0));\n@@ -219,7 +222,7 @@ mod tests {\n \n         // |#|#|#|#|@|@|@|@|_|...\n         //  0 1 2 3 4 5 6 7 8\n-        map.insert(1, alloc_range(four, four), \"@\");\n+        map.insert_at_pos(1, alloc_range(four, four), \"@\");\n         // |#|#|#|#|@|@|@|@|_|...\n         //  0 1 2 3 ^ ^ ^ ^ 8\n         assert_eq!(map.find_offset(four), Ok(1));\n@@ -234,7 +237,7 @@ mod tests {\n \n         // |_|_|_|_|#|#|#|#|_|_|_|_|...\n         //  0 1 2 3 4 5 6 7 8 9 a b c d\n-        map.insert(0, alloc_range(four, four), \"#\");\n+        map.insert_at_pos(0, alloc_range(four, four), \"#\");\n         // |_|_|_|_|#|#|#|#|_|_|_|_|...\n         //  0 1 ^ ^ ^ ^ 6 7 8 9 a b c d\n         assert_eq!(\n@@ -256,7 +259,7 @@ mod tests {\n \n         // |_|_|_|_|#|#|#|#|_|_|@|@|_|_|...\n         //  0 1 2 3 4 5 6 7 8 9 a b c d\n-        map.insert(1, alloc_range(Size::from_bytes(10), Size::from_bytes(2)), \"@\");\n+        map.insert_at_pos(1, alloc_range(Size::from_bytes(10), Size::from_bytes(2)), \"@\");\n         // |_|_|_|_|#|#|#|#|_|_|@|@|_|_|...\n         //  0 1 2 3 4 5 ^ ^ ^ ^ ^ ^ ^ ^\n         assert_eq!("}, {"sha": "bd4ae06892bd0eb82e20d1200b7ad8b402c4f77e", "filename": "src/concurrency/weak_memory.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/577054c6ded13a70ee07d6fc3397518ae1e81710/src%2Fconcurrency%2Fweak_memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/577054c6ded13a70ee07d6fc3397518ae1e81710/src%2Fconcurrency%2Fweak_memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconcurrency%2Fweak_memory.rs?ref=577054c6ded13a70ee07d6fc3397518ae1e81710", "patch": "@@ -120,27 +120,27 @@ impl StoreBufferAlloc {\n         range: AllocRange,\n     ) -> InterpResult<'tcx, Ref<'_, StoreBuffer>> {\n         let access_type = self.store_buffer.borrow().access_type(range);\n-        let index = match access_type {\n-            AccessType::PerfectlyOverlapping(index) => index,\n-            AccessType::Empty(index) => {\n+        let pos = match access_type {\n+            AccessType::PerfectlyOverlapping(pos) => pos,\n+            AccessType::Empty(pos) => {\n                 // First atomic access on this range, allocate a new StoreBuffer\n                 let mut buffer = self.store_buffer.borrow_mut();\n-                buffer.insert(index, range, StoreBuffer::default());\n-                index\n+                buffer.insert_at_pos(pos, range, StoreBuffer::default());\n+                pos\n             }\n-            AccessType::ImperfectlyOverlapping(index_range) => {\n+            AccessType::ImperfectlyOverlapping(pos_range) => {\n                 // Accesses that imperfectly overlaps with existing atomic objects\n                 // do not have well-defined behaviours.\n                 // FIXME: if this access happens before all previous accesses on every object it overlaps\n                 // with, then we would like to tolerate it. However this is not easy to check.\n-                if index_range.start + 1 == index_range.end {\n+                if pos_range.start + 1 == pos_range.end {\n                     throw_ub_format!(\"mixed-size access on an existing atomic object\");\n                 } else {\n                     throw_ub_format!(\"access overlaps with multiple existing atomic objects\");\n                 }\n             }\n         };\n-        Ok(Ref::map(self.store_buffer.borrow(), |buffer| &buffer[index]))\n+        Ok(Ref::map(self.store_buffer.borrow(), |buffer| &buffer[pos]))\n     }\n \n     /// Gets a mutable store buffer associated with an atomic object in this allocation\n@@ -150,21 +150,21 @@ impl StoreBufferAlloc {\n     ) -> InterpResult<'tcx, &mut StoreBuffer> {\n         let buffer = self.store_buffer.get_mut();\n         let access_type = buffer.access_type(range);\n-        let index = match access_type {\n-            AccessType::PerfectlyOverlapping(index) => index,\n-            AccessType::Empty(index) => {\n-                buffer.insert(index, range, StoreBuffer::default());\n-                index\n+        let pos = match access_type {\n+            AccessType::PerfectlyOverlapping(pos) => pos,\n+            AccessType::Empty(pos) => {\n+                buffer.insert_at_pos(pos, range, StoreBuffer::default());\n+                pos\n             }\n-            AccessType::ImperfectlyOverlapping(index_range) => {\n-                if index_range.start + 1 == index_range.end {\n+            AccessType::ImperfectlyOverlapping(pos_range) => {\n+                if pos_range.start + 1 == pos_range.end {\n                     throw_ub_format!(\"mixed-size access on an existing atomic object\");\n                 } else {\n                     throw_ub_format!(\"access overlaps with multiple existing atomic objects\");\n                 }\n             }\n         };\n-        Ok(&mut buffer[index])\n+        Ok(&mut buffer[pos])\n     }\n }\n "}]}