{"sha": "02017b30ebebfaeb64a5a86a885773f38057beba", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAyMDE3YjMwZWJlYmZhZWI2NGE1YTg2YTg4NTc3M2YzODA1N2JlYmE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-10-21T21:42:25Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-11-03T09:35:00Z"}, "message": "New trans codepath that builds fn body from MIR instead.", "tree": {"sha": "bc8d306b34f78fb084780c8adcf5fe8b37dbf2f0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bc8d306b34f78fb084780c8adcf5fe8b37dbf2f0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/02017b30ebebfaeb64a5a86a885773f38057beba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/02017b30ebebfaeb64a5a86a885773f38057beba", "html_url": "https://github.com/rust-lang/rust/commit/02017b30ebebfaeb64a5a86a885773f38057beba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/02017b30ebebfaeb64a5a86a885773f38057beba/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "877b93add2a0d7cc603fa3146a3b9b0af0215e9d", "url": "https://api.github.com/repos/rust-lang/rust/commits/877b93add2a0d7cc603fa3146a3b9b0af0215e9d", "html_url": "https://github.com/rust-lang/rust/commit/877b93add2a0d7cc603fa3146a3b9b0af0215e9d"}], "stats": {"total": 887, "additions": 887, "deletions": 0}, "files": [{"sha": "8d6ba53dd222d9b52c220887d5cb444524368137", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/02017b30ebebfaeb64a5a86a885773f38057beba/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02017b30ebebfaeb64a5a86a885773f38057beba/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=02017b30ebebfaeb64a5a86a885773f38057beba", "patch": "@@ -743,6 +743,12 @@ pub fn C_floating(s: &str, t: Type) -> ValueRef {\n     }\n }\n \n+pub fn C_floating_f64(f: f64, t: Type) -> ValueRef {\n+    unsafe {\n+        llvm::LLVMConstReal(t.to_ref(), f)\n+    }\n+}\n+\n pub fn C_nil(ccx: &CrateContext) -> ValueRef {\n     C_struct(ccx, &[], false)\n }"}, {"sha": "c9f4123c17127aabc7a66132743e4d0a40a1b99d", "filename": "src/librustc_trans/trans/mir/block.rs", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/02017b30ebebfaeb64a5a86a885773f38057beba/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02017b30ebebfaeb64a5a86a885773f38057beba/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs?ref=02017b30ebebfaeb64a5a86a885773f38057beba", "patch": "@@ -0,0 +1,106 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use llvm::BasicBlockRef;\n+use rustc_mir::repr as mir;\n+use trans::base;\n+use trans::build;\n+use trans::common::Block;\n+use trans::debuginfo::DebugLoc;\n+\n+use super::MirContext;\n+\n+impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n+    pub fn trans_block(&mut self, bb: mir::BasicBlock) {\n+        debug!(\"trans_block({:?})\", bb);\n+\n+        let mut bcx = self.bcx(bb);\n+        let data = self.mir.basic_block_data(bb);\n+\n+        for statement in &data.statements {\n+            bcx = self.trans_statement(bcx, statement);\n+        }\n+\n+        debug!(\"trans_block: terminator: {:?}\", data.terminator);\n+\n+        match data.terminator {\n+            mir::Terminator::Goto { target } => {\n+                build::Br(bcx, self.llblock(target), DebugLoc::None)\n+            }\n+\n+            mir::Terminator::Panic { .. } => {\n+                unimplemented!()\n+            }\n+\n+            mir::Terminator::If { ref cond, targets: [true_bb, false_bb] } => {\n+                let cond = self.trans_operand(bcx, cond);\n+                let lltrue = self.llblock(true_bb);\n+                let llfalse = self.llblock(false_bb);\n+                build::CondBr(bcx, cond.llval, lltrue, llfalse, DebugLoc::None);\n+            }\n+\n+            mir::Terminator::Switch { .. } => {\n+                unimplemented!()\n+            }\n+\n+            mir::Terminator::Diverge => {\n+                if let Some(llpersonalityslot) = self.llpersonalityslot {\n+                    let lp = build::Load(bcx, llpersonalityslot);\n+                    // FIXME(lifetime) base::call_lifetime_end(bcx, self.personality);\n+                    build::Resume(bcx, lp);\n+                } else {\n+                    // This fn never encountered anything fallible, so\n+                    // a Diverge cannot actually happen. Note that we\n+                    // do a total hack to ensure that we visit the\n+                    // DIVERGE block last.\n+                    build::Unreachable(bcx);\n+                }\n+            }\n+\n+            mir::Terminator::Return => {\n+                let return_ty = bcx.monomorphize(&self.mir.return_ty);\n+                base::build_return_block(bcx.fcx, bcx, return_ty, DebugLoc::None);\n+            }\n+\n+            mir::Terminator::Call { .. } => {\n+                unimplemented!()\n+                //let llbb = unimplemented!(); // self.make_landing_pad(panic_bb);\n+                //\n+                //let tr_dest = self.trans_lvalue(bcx, &data.destination);\n+                //\n+                //// Create the callee. This will always be a fn\n+                //// ptr and hence a kind of scalar.\n+                //let callee = self.trans_operand(bcx, &data.func);\n+                //\n+                //// Process the arguments.\n+                //\n+                //let args = unimplemented!();\n+                //\n+                //callee::trans_call_inner(bcx,\n+                //                         DebugLoc::None,\n+                //                         |bcx, _| Callee {\n+                //                             bcx: bcx,\n+                //                             data: CalleeData::Fn(callee.llval),\n+                //                             ty: callee.ty,\n+                //                         },\n+                //                         args,\n+                //                         Some(Dest::SaveIn(tr_dest.llval)));\n+            }\n+        }\n+    }\n+\n+    fn bcx(&self, bb: mir::BasicBlock) -> Block<'bcx, 'tcx> {\n+        self.blocks[bb.index()]\n+    }\n+\n+    fn llblock(&self, bb: mir::BasicBlock) -> BasicBlockRef {\n+        self.blocks[bb.index()].llbb\n+    }\n+}"}, {"sha": "1b61001834a997b7e2eeae6c99982e2dce679f24", "filename": "src/librustc_trans/trans/mir/constant.rs", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/02017b30ebebfaeb64a5a86a885773f38057beba/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02017b30ebebfaeb64a5a86a885773f38057beba/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fconstant.rs?ref=02017b30ebebfaeb64a5a86a885773f38057beba", "patch": "@@ -0,0 +1,63 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use llvm::ValueRef;\n+use rustc::middle::const_eval::ConstVal;\n+use rustc_mir::repr as mir;\n+use trans::consts::{self, TrueConst};\n+use trans::common::{self, Block};\n+use trans::type_of;\n+\n+use super::MirContext;\n+\n+impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n+    pub fn trans_constant(&mut self,\n+                          bcx: Block<'bcx, 'tcx>,\n+                          constant: &mir::Constant<'tcx>)\n+                          -> ValueRef\n+    {\n+        let ccx = bcx.ccx();\n+        let constant_ty = bcx.monomorphize(&constant.ty);\n+        let llty = type_of::type_of(ccx, constant_ty);\n+        match constant.literal {\n+            mir::Literal::Item { .. } => {\n+                unimplemented!()\n+            }\n+            mir::Literal::Value { ref value } => {\n+                match *value {\n+                    ConstVal::Float(v) => common::C_floating_f64(v, llty),\n+                    ConstVal::Bool(v) => common::C_bool(ccx, v),\n+                    ConstVal::Int(v) => common::C_integral(llty, v as u64, true),\n+                    ConstVal::Uint(v) => common::C_integral(llty, v, false),\n+                    ConstVal::Str(ref v) => common::C_str_slice(ccx, v.clone()),\n+                    ConstVal::ByteStr(ref v) => consts::addr_of(ccx,\n+                                                                common::C_bytes(ccx, v),\n+                                                                1,\n+                                                                \"byte_str\"),\n+                    ConstVal::Struct(id) | ConstVal::Tuple(id) => {\n+                        let expr = bcx.tcx().map.expect_expr(id);\n+                        let (llval, _) = match consts::const_expr(ccx,\n+                                                                  expr,\n+                                                                  bcx.fcx.param_substs,\n+                                                                  None,\n+                                                                  TrueConst::Yes) {\n+                            Ok(v) => v,\n+                            Err(_) => panic!(\"constant eval failure\"),\n+                        };\n+                        llval\n+                    }\n+                    ConstVal::Function(_) => {\n+                        unimplemented!()\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "282c6a7e6de17e797c612590341a8a4cd3c3f554", "filename": "src/librustc_trans/trans/mir/lvalue.rs", "status": "added", "additions": 149, "deletions": 0, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/02017b30ebebfaeb64a5a86a885773f38057beba/src%2Flibrustc_trans%2Ftrans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02017b30ebebfaeb64a5a86a885773f38057beba/src%2Flibrustc_trans%2Ftrans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Flvalue.rs?ref=02017b30ebebfaeb64a5a86a885773f38057beba", "patch": "@@ -0,0 +1,149 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use llvm::ValueRef;\n+use rustc::middle::ty::Ty;\n+use rustc_mir::repr as mir;\n+use rustc_mir::tcx::LvalueTy;\n+use trans::adt;\n+use trans::base;\n+use trans::build;\n+use trans::common::{self, Block};\n+use trans::debuginfo::DebugLoc;\n+use trans::machine;\n+use trans::tvec;\n+\n+use super::MirContext;\n+\n+#[derive(Copy, Clone)]\n+pub struct LvalueRef<'tcx> {\n+    /// Pointer to the contents of the lvalue\n+    pub llval: ValueRef,\n+\n+    /// Monomorphized type of this lvalue, including variant information\n+    pub ty: LvalueTy<'tcx>,\n+}\n+\n+impl<'tcx> LvalueRef<'tcx> {\n+    pub fn new(llval: ValueRef, lvalue_ty: LvalueTy<'tcx>) -> LvalueRef<'tcx> {\n+        LvalueRef { llval: llval, ty: lvalue_ty }\n+    }\n+\n+    pub fn alloca<'bcx>(bcx: Block<'bcx, 'tcx>,\n+                        ty: Ty<'tcx>,\n+                        name: &str)\n+                        -> LvalueRef<'tcx>\n+    {\n+        let lltemp = base::alloc_ty(bcx, ty, name);\n+        LvalueRef::new(lltemp, LvalueTy::from_ty(ty))\n+    }\n+}\n+\n+impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n+    pub fn trans_lvalue(&mut self,\n+                        bcx: Block<'bcx, 'tcx>,\n+                        lvalue: &mir::Lvalue<'tcx>)\n+                        -> LvalueRef<'tcx> {\n+        debug!(\"trans_lvalue(lvalue={:?})\", lvalue);\n+\n+        let fcx = bcx.fcx;\n+        let ccx = fcx.ccx;\n+        let tcx = bcx.tcx();\n+        match *lvalue {\n+            mir::Lvalue::Var(index) => self.vars[index as usize],\n+            mir::Lvalue::Temp(index) => self.temps[index as usize],\n+            mir::Lvalue::Arg(index) => self.args[index as usize],\n+            mir::Lvalue::Static(_def_id) => unimplemented!(),\n+            mir::Lvalue::ReturnPointer => {\n+                let return_ty = bcx.monomorphize(&self.mir.return_ty);\n+                let llval = fcx.get_ret_slot(bcx, return_ty, \"return\");\n+                LvalueRef::new(llval, LvalueTy::from_ty(return_ty.unwrap()))\n+            }\n+            mir::Lvalue::Projection(ref projection) => {\n+                let tr_base = self.trans_lvalue(bcx, &projection.base);\n+                let projected_ty = tr_base.ty.projection_ty(tcx, &projection.elem);\n+                let llprojected = match projection.elem {\n+                    mir::ProjectionElem::Deref => {\n+                        let base_ty = tr_base.ty.to_ty(tcx);\n+                        base::load_ty(bcx, tr_base.llval, base_ty)\n+                    }\n+                    mir::ProjectionElem::Field(ref field) => {\n+                        let base_ty = tr_base.ty.to_ty(tcx);\n+                        let base_repr = adt::represent_type(ccx, base_ty);\n+                        let discr = match tr_base.ty {\n+                            LvalueTy::Ty { .. } => 0,\n+                            LvalueTy::Downcast { adt_def: _, substs: _, variant_index: v } => v,\n+                        };\n+                        let discr = discr as u64;\n+                        adt::trans_field_ptr(bcx, &base_repr, tr_base.llval, discr, field.index())\n+                    }\n+                    mir::ProjectionElem::Index(ref index) => {\n+                        let base_ty = tr_base.ty.to_ty(tcx);\n+                        let index = self.trans_operand(bcx, index);\n+                        let llindex = self.prepare_index(bcx, index.llval);\n+                        let (llbase, _) = tvec::get_base_and_len(bcx, tr_base.llval, base_ty);\n+                        build::InBoundsGEP(bcx, llbase, &[llindex])\n+                    }\n+                    mir::ProjectionElem::ConstantIndex { offset,\n+                                                         from_end: false,\n+                                                         min_length: _ } => {\n+                        let base_ty = tr_base.ty.to_ty(tcx);\n+                        let lloffset = common::C_u32(bcx.ccx(), offset);\n+                        let llindex = self.prepare_index(bcx, lloffset);\n+                        let (llbase, _) = tvec::get_base_and_len(bcx,\n+                                                                 tr_base.llval,\n+                                                                 base_ty);\n+                        build::InBoundsGEP(bcx, llbase, &[llindex])\n+                    }\n+                    mir::ProjectionElem::ConstantIndex { offset,\n+                                                         from_end: true,\n+                                                         min_length: _ } => {\n+                        let lloffset = common::C_u32(bcx.ccx(), offset);\n+                        let base_ty = tr_base.ty.to_ty(tcx);\n+                        let (llbase, lllen) = tvec::get_base_and_len(bcx,\n+                                                                     tr_base.llval,\n+                                                                     base_ty);\n+                        let llindex = build::Sub(bcx, lllen, lloffset, DebugLoc::None);\n+                        let llindex = self.prepare_index(bcx, llindex);\n+                        build::InBoundsGEP(bcx, llbase, &[llindex])\n+                    }\n+                    mir::ProjectionElem::Downcast(..) => {\n+                        tr_base.llval\n+                    }\n+                };\n+                LvalueRef {\n+                    llval: llprojected,\n+                    ty: projected_ty,\n+                }\n+            }\n+        }\n+    }\n+\n+    /// Adjust the bitwidth of an index since LLVM is less forgiving\n+    /// than we are.\n+    ///\n+    /// nmatsakis: is this still necessary? Not sure.\n+    fn prepare_index(&mut self,\n+                     bcx: Block<'bcx, 'tcx>,\n+                     llindex: ValueRef)\n+                     -> ValueRef\n+    {\n+        let ccx = bcx.ccx();\n+        let index_size = machine::llbitsize_of_real(bcx.ccx(), common::val_ty(llindex));\n+        let int_size = machine::llbitsize_of_real(bcx.ccx(), ccx.int_type());\n+        if index_size < int_size {\n+            build::ZExt(bcx, llindex, ccx.int_type())\n+        } else if index_size > int_size {\n+            build::Trunc(bcx, llindex, ccx.int_type())\n+        } else {\n+            llindex\n+        }\n+    }\n+}"}, {"sha": "6ed839d1a442d073999d7e82512743a81e7f287a", "filename": "src/librustc_trans/trans/mir/mod.rs", "status": "added", "additions": 162, "deletions": 0, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/02017b30ebebfaeb64a5a86a885773f38057beba/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02017b30ebebfaeb64a5a86a885773f38057beba/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fmod.rs?ref=02017b30ebebfaeb64a5a86a885773f38057beba", "patch": "@@ -0,0 +1,162 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use libc::c_uint;\n+use llvm::{self, ValueRef};\n+use rustc_mir::repr as mir;\n+use rustc_mir::tcx::LvalueTy;\n+use std::cell::Cell;\n+use trans::base;\n+use trans::build;\n+use trans::common::{self, Block};\n+use trans::debuginfo::DebugLoc;\n+use trans::expr;\n+use trans::type_of;\n+\n+use self::lvalue::LvalueRef;\n+\n+// FIXME DebugLoc is always None right now\n+\n+/// Master context for translating MIR.\n+pub struct MirContext<'bcx, 'tcx:'bcx> {\n+    mir: &'bcx mir::Mir<'tcx>,\n+\n+    /// When unwinding is initiated, we have to store this personality\n+    /// value somewhere so that we can load it and re-use it in the\n+    /// resume instruction. The personality is (afaik) some kind of\n+    /// value used for C++ unwinding, which must filter by type: we\n+    /// don't really care about it very much. Anyway, this value\n+    /// contains an alloca into which the personality is stored and\n+    /// then later loaded when generating the DIVERGE_BLOCK.\n+    llpersonalityslot: Option<ValueRef>,\n+\n+    /// A `Block` for each MIR `BasicBlock`\n+    blocks: Vec<Block<'bcx, 'tcx>>,\n+\n+    /// An LLVM alloca for each MIR `VarDecl`\n+    vars: Vec<LvalueRef<'tcx>>,\n+\n+    /// An LLVM alloca for each MIR `TempDecl`\n+    temps: Vec<LvalueRef<'tcx>>,\n+\n+    /// The arguments to the function; as args are lvalues, these are\n+    /// always indirect, though we try to avoid creating an alloca\n+    /// when we can (and just reuse the pointer the caller provided).\n+    args: Vec<LvalueRef<'tcx>>,\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+\n+pub fn trans_mir<'bcx, 'tcx>(bcx: Block<'bcx, 'tcx>) {\n+    let fcx = bcx.fcx;\n+    let mir = bcx.mir();\n+\n+    let mir_blocks = bcx.mir().all_basic_blocks();\n+\n+    // Allocate variable and temp allocas\n+    let vars = mir.var_decls.iter()\n+                            .map(|decl| (bcx.monomorphize(&decl.ty), decl.name))\n+                            .map(|(mty, name)| LvalueRef::alloca(bcx, mty, &name.as_str()))\n+                            .collect();\n+    let temps = mir.temp_decls.iter()\n+                              .map(|decl| bcx.monomorphize(&decl.ty))\n+                              .enumerate()\n+                              .map(|(i, mty)| LvalueRef::alloca(bcx, mty, &format!(\"temp{:?}\", i)))\n+                              .collect();\n+    let args = arg_value_refs(bcx, mir);\n+\n+    // Allocate a `Block` for every basic block\n+    let block_bcxs: Vec<Block<'bcx,'tcx>> =\n+        mir_blocks.iter()\n+                  .map(|&bb| fcx.new_block(false, &format!(\"{:?}\", bb), None))\n+                  .collect();\n+\n+    // Branch to the START block\n+    let start_bcx = block_bcxs[mir::START_BLOCK.index()];\n+    build::Br(bcx, start_bcx.llbb, DebugLoc::None);\n+\n+    let mut mircx = MirContext {\n+        mir: mir,\n+        llpersonalityslot: None,\n+        blocks: block_bcxs,\n+        vars: vars,\n+        temps: temps,\n+        args: args,\n+    };\n+\n+    // Translate the body of each block\n+    for &bb in &mir_blocks {\n+        if bb != mir::DIVERGE_BLOCK {\n+            mircx.trans_block(bb);\n+        }\n+    }\n+\n+    // Total hack: translate DIVERGE_BLOCK last. This is so that any\n+    // panics which the fn may do can initialize the\n+    // `llpersonalityslot` cell. We don't do this up front because the\n+    // LLVM type of it is (frankly) annoying to compute.\n+    mircx.trans_block(mir::DIVERGE_BLOCK);\n+}\n+\n+/// Produce, for each argument, a `ValueRef` pointing at the\n+/// argument's value. As arguments are lvalues, these are always\n+/// indirect.\n+fn arg_value_refs<'bcx, 'tcx>(bcx: Block<'bcx, 'tcx>,\n+                              mir: &mir::Mir<'tcx>)\n+                              -> Vec<LvalueRef<'tcx>> {\n+    // FIXME tupled_args? I think I'd rather that mapping is done in MIR land though\n+    let fcx = bcx.fcx;\n+    let tcx = bcx.tcx();\n+    let mut idx = fcx.arg_offset() as c_uint;\n+    mir.arg_decls\n+       .iter()\n+       .enumerate()\n+       .map(|(arg_index, arg_decl)| {\n+           let arg_ty = bcx.monomorphize(&arg_decl.ty);\n+           let llval = if type_of::arg_is_indirect(bcx.ccx(), arg_ty) {\n+               // Don't copy an indirect argument to an alloca, the caller\n+               // already put it in a temporary alloca and gave it up, unless\n+               // we emit extra-debug-info, which requires local allocas :(.\n+               // FIXME: lifetimes, debug info\n+               let llarg = llvm::get_param(fcx.llfn, idx);\n+               idx += 1;\n+               llarg\n+           } else if common::type_is_fat_ptr(tcx, arg_ty) {\n+               // we pass fat pointers as two words, but we want to\n+               // represent them internally as a pointer two two words,\n+               // so make an alloca to store them in.\n+               let lldata = llvm::get_param(fcx.llfn, idx);\n+               let llextra = llvm::get_param(fcx.llfn, idx + 1);\n+               idx += 2;\n+               let lltemp = base::alloc_ty(bcx, arg_ty, &format!(\"arg{}\", arg_index));\n+               build::Store(bcx, lldata, expr::get_dataptr(bcx, lltemp));\n+               build::Store(bcx, llextra, expr::get_dataptr(bcx, lltemp));\n+               lltemp\n+           } else {\n+               // otherwise, arg is passed by value, so make a\n+               // temporary and store it there\n+               let llarg = llvm::get_param(fcx.llfn, idx);\n+               idx += 1;\n+               let lltemp = base::alloc_ty(bcx, arg_ty, &format!(\"arg{}\", arg_index));\n+               build::Store(bcx, llarg, lltemp);\n+               lltemp\n+           };\n+           LvalueRef::new(llval, LvalueTy::from_ty(arg_ty))\n+       })\n+       .collect()\n+}\n+\n+mod block;\n+mod constant;\n+mod lvalue;\n+mod rvalue;\n+mod operand;\n+mod statement;\n+"}, {"sha": "786b84ae80759815e9cab11a7e436729d0a68887", "filename": "src/librustc_trans/trans/mir/operand.rs", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/02017b30ebebfaeb64a5a86a885773f38057beba/src%2Flibrustc_trans%2Ftrans%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02017b30ebebfaeb64a5a86a885773f38057beba/src%2Flibrustc_trans%2Ftrans%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Foperand.rs?ref=02017b30ebebfaeb64a5a86a885773f38057beba", "patch": "@@ -0,0 +1,90 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use llvm::ValueRef;\n+use rustc::middle::ty::Ty;\n+use rustc_mir::repr as mir;\n+use trans::base;\n+use trans::build;\n+use trans::common::Block;\n+use trans::datum;\n+\n+use super::MirContext;\n+\n+pub struct OperandRef<'tcx> {\n+    // This will be \"indirect\" if `appropriate_rvalue_mode` returns\n+    // ByRef, and otherwise ByValue.\n+    pub llval: ValueRef,\n+\n+    // The type of value being returned.\n+    pub ty: Ty<'tcx>\n+}\n+\n+impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n+    pub fn trans_operand(&mut self,\n+                         bcx: Block<'bcx, 'tcx>,\n+                         operand: &mir::Operand<'tcx>)\n+                         -> OperandRef<'tcx>\n+    {\n+        debug!(\"trans_operand(operand={:?})\", operand);\n+\n+        match *operand {\n+            mir::Operand::Consume(ref lvalue) => {\n+                let tr_lvalue = self.trans_lvalue(bcx, lvalue);\n+                let ty = tr_lvalue.ty.to_ty(bcx.tcx());\n+                debug!(\"trans_operand: tr_lvalue={} @ {:?}\",\n+                       bcx.val_to_string(tr_lvalue.llval),\n+                       ty);\n+                let llval = match datum::appropriate_rvalue_mode(bcx.ccx(), ty) {\n+                    datum::ByValue => build::Load(bcx, tr_lvalue.llval),\n+                    datum::ByRef => tr_lvalue.llval,\n+                };\n+                OperandRef {\n+                    llval: llval,\n+                    ty: ty\n+                }\n+            }\n+\n+            mir::Operand::Constant(ref constant) => {\n+                let llval = self.trans_constant(bcx, constant);\n+                let ty = bcx.monomorphize(&constant.ty);\n+                OperandRef {\n+                    llval: llval,\n+                    ty: ty,\n+                }\n+            }\n+        }\n+    }\n+\n+    pub fn trans_operand_into(&mut self,\n+                              bcx: Block<'bcx, 'tcx>,\n+                              lldest: ValueRef,\n+                              operand: &mir::Operand<'tcx>)\n+    {\n+        debug!(\"trans_operand_into(lldest={}, operand={:?})\",\n+               bcx.val_to_string(lldest),\n+               operand);\n+\n+        match *operand {\n+            mir::Operand::Consume(ref lvalue) => {\n+                let tr_lvalue = self.trans_lvalue(bcx, lvalue);\n+                let lvalue_ty = tr_lvalue.ty.to_ty(bcx.tcx());\n+                debug!(\"trans_operand_into: tr_lvalue={} @ {:?}\",\n+                       bcx.val_to_string(tr_lvalue.llval),\n+                       lvalue_ty);\n+                base::memcpy_ty(bcx, lldest, tr_lvalue.llval, lvalue_ty);\n+            }\n+\n+            mir::Operand::Constant(..) => {\n+                unimplemented!()\n+            }\n+        }\n+    }\n+}"}, {"sha": "416aa061276fe3052ebd5f208f7438ffe3ba061e", "filename": "src/librustc_trans/trans/mir/rvalue.rs", "status": "added", "additions": 238, "deletions": 0, "changes": 238, "blob_url": "https://github.com/rust-lang/rust/blob/02017b30ebebfaeb64a5a86a885773f38057beba/src%2Flibrustc_trans%2Ftrans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02017b30ebebfaeb64a5a86a885773f38057beba/src%2Flibrustc_trans%2Ftrans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Frvalue.rs?ref=02017b30ebebfaeb64a5a86a885773f38057beba", "patch": "@@ -0,0 +1,238 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use back::abi;\n+use llvm::ValueRef;\n+use rustc::middle::ty::Ty;\n+use rustc_front::hir;\n+use rustc_mir::repr as mir;\n+\n+use trans::asm;\n+use trans::base;\n+use trans::build;\n+use trans::common::{self, Block, Result};\n+use trans::debuginfo::DebugLoc;\n+use trans::declare;\n+use trans::machine;\n+use trans::type_::Type;\n+use trans::type_of;\n+use trans::tvec;\n+\n+use super::MirContext;\n+use super::operand::OperandRef;\n+\n+impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n+    pub fn trans_rvalue(&mut self,\n+                        bcx: Block<'bcx, 'tcx>,\n+                        lldest: ValueRef,\n+                        rvalue: &mir::Rvalue<'tcx>)\n+                        -> Block<'bcx, 'tcx>\n+    {\n+        debug!(\"trans_rvalue(lldest={}, rvalue={:?})\",\n+               bcx.val_to_string(lldest),\n+               rvalue);\n+\n+        match *rvalue {\n+            mir::Rvalue::Use(ref operand) => {\n+                self.trans_operand_into(bcx, lldest, operand);\n+                bcx\n+            }\n+\n+            mir::Rvalue::Cast(..) => {\n+                unimplemented!()\n+            }\n+\n+            mir::Rvalue::Repeat(..) => {\n+                unimplemented!()\n+            }\n+\n+            mir::Rvalue::Ref(_, _, ref lvalue) => {\n+                let tr_lvalue = self.trans_lvalue(bcx, lvalue);\n+                // Note: lvalues are indirect, so storing the `llval` into the\n+                // destination effectively creates a reference.\n+                build::Store(bcx, tr_lvalue.llval, lldest);\n+                bcx\n+            }\n+\n+            mir::Rvalue::Len(ref lvalue) => {\n+                let tr_lvalue = self.trans_lvalue(bcx, lvalue);\n+                let (_, lllen) = tvec::get_base_and_len(bcx,\n+                                                        tr_lvalue.llval,\n+                                                        tr_lvalue.ty.to_ty(bcx.tcx()));\n+                build::Store(bcx, lllen, lldest);\n+                bcx\n+            }\n+\n+            mir::Rvalue::BinaryOp(op, ref lhs, ref rhs) => {\n+                let lhs = self.trans_operand(bcx, lhs);\n+                let rhs = self.trans_operand(bcx, rhs);\n+                let is_float = lhs.ty.is_fp();\n+                let is_signed = lhs.ty.is_signed();\n+                let binop_debug_loc = DebugLoc::None;\n+                let llval = match op {\n+                    mir::BinOp::Add => if is_float {\n+                        build::FAdd(bcx, lhs.llval, rhs.llval, binop_debug_loc)\n+                    } else {\n+                        build::Add(bcx, lhs.llval, rhs.llval, binop_debug_loc)\n+                    },\n+                    mir::BinOp::Sub => if is_float {\n+                        build::FSub(bcx, lhs.llval, rhs.llval, binop_debug_loc)\n+                    } else {\n+                        build::Sub(bcx, lhs.llval, rhs.llval, binop_debug_loc)\n+                    },\n+                    mir::BinOp::Mul => if is_float {\n+                        build::FMul(bcx, lhs.llval, rhs.llval, binop_debug_loc)\n+                    } else {\n+                        build::Mul(bcx, lhs.llval, rhs.llval, binop_debug_loc)\n+                    },\n+                    mir::BinOp::Div => if is_float {\n+                        build::FDiv(bcx, lhs.llval, rhs.llval, binop_debug_loc)\n+                    } else if is_signed {\n+                        build::SDiv(bcx, lhs.llval, rhs.llval, binop_debug_loc)\n+                    } else {\n+                        build::UDiv(bcx, lhs.llval, rhs.llval, binop_debug_loc)\n+                    },\n+                    mir::BinOp::Rem => if is_float {\n+                        // LLVM currently always lowers the `frem` instructions appropriate\n+                        // library calls typically found in libm. Notably f64 gets wired up\n+                        // to `fmod` and f32 gets wired up to `fmodf`. Inconveniently for\n+                        // us, 32-bit MSVC does not actually have a `fmodf` symbol, it's\n+                        // instead just an inline function in a header that goes up to a\n+                        // f64, uses `fmod`, and then comes back down to a f32.\n+                        //\n+                        // Although LLVM knows that `fmodf` doesn't exist on MSVC, it will\n+                        // still unconditionally lower frem instructions over 32-bit floats\n+                        // to a call to `fmodf`. To work around this we special case MSVC\n+                        // 32-bit float rem instructions and instead do the call out to\n+                        // `fmod` ourselves.\n+                        //\n+                        // Note that this is currently duplicated with src/libcore/ops.rs\n+                        // which does the same thing, and it would be nice to perhaps unify\n+                        // these two implementations on day! Also note that we call `fmod`\n+                        // for both 32 and 64-bit floats because if we emit any FRem\n+                        // instruction at all then LLVM is capable of optimizing it into a\n+                        // 32-bit FRem (which we're trying to avoid).\n+                        let tcx = bcx.tcx();\n+                        let use_fmod = tcx.sess.target.target.options.is_like_msvc &&\n+                            tcx.sess.target.target.arch == \"x86\";\n+                        if use_fmod {\n+                            let f64t = Type::f64(bcx.ccx());\n+                            let fty = Type::func(&[f64t, f64t], &f64t);\n+                            let llfn = declare::declare_cfn(bcx.ccx(), \"fmod\", fty,\n+                                                            tcx.types.f64);\n+                            if lhs.ty == tcx.types.f32 {\n+                                let lllhs = build::FPExt(bcx, lhs.llval, f64t);\n+                                let llrhs = build::FPExt(bcx, rhs.llval, f64t);\n+                                let llres = build::Call(bcx, llfn, &[lllhs, llrhs],\n+                                                        None, binop_debug_loc);\n+                                build::FPTrunc(bcx, llres, Type::f32(bcx.ccx()))\n+                            } else {\n+                                build::Call(bcx, llfn, &[lhs.llval, rhs.llval],\n+                                            None, binop_debug_loc)\n+                            }\n+                        } else {\n+                            build::FRem(bcx, lhs.llval, rhs.llval, binop_debug_loc)\n+                        }\n+                    } else if is_signed {\n+                        build::SRem(bcx, lhs.llval, rhs.llval, binop_debug_loc)\n+                    } else {\n+                        build::URem(bcx, lhs.llval, rhs.llval, binop_debug_loc)\n+                    },\n+                    mir::BinOp::BitOr => build::Or(bcx, lhs.llval, rhs.llval, binop_debug_loc),\n+                    mir::BinOp::BitAnd => build::And(bcx, lhs.llval, rhs.llval, binop_debug_loc),\n+                    mir::BinOp::BitXor => build::Xor(bcx, lhs.llval, rhs.llval, binop_debug_loc),\n+                    mir::BinOp::Shl => common::build_unchecked_lshift(bcx,\n+                                                                      lhs.llval,\n+                                                                      rhs.llval,\n+                                                                      binop_debug_loc),\n+                    mir::BinOp::Shr => common::build_unchecked_rshift(bcx,\n+                                                                      lhs.ty,\n+                                                                      lhs.llval,\n+                                                                      rhs.llval,\n+                                                                      binop_debug_loc),\n+                    mir::BinOp::Eq => base::compare_scalar_types(bcx, lhs.llval, rhs.llval, lhs.ty,\n+                                                                 hir::BiEq, binop_debug_loc),\n+                    mir::BinOp::Lt => base::compare_scalar_types(bcx, lhs.llval, rhs.llval, lhs.ty,\n+                                                                 hir::BiLt, binop_debug_loc),\n+                    mir::BinOp::Le => base::compare_scalar_types(bcx, lhs.llval, rhs.llval, lhs.ty,\n+                                                                 hir::BiLe, binop_debug_loc),\n+                    mir::BinOp::Ne => base::compare_scalar_types(bcx, lhs.llval, rhs.llval, lhs.ty,\n+                                                                 hir::BiNe, binop_debug_loc),\n+                    mir::BinOp::Ge => base::compare_scalar_types(bcx, lhs.llval, rhs.llval, lhs.ty,\n+                                                                 hir::BiGe, binop_debug_loc),\n+                    mir::BinOp::Gt => base::compare_scalar_types(bcx, lhs.llval, rhs.llval, lhs.ty,\n+                                                                 hir::BiGt, binop_debug_loc),\n+                };\n+                build::Store(bcx, llval, lldest);\n+                bcx\n+            }\n+\n+            mir::Rvalue::UnaryOp(op, ref operand) => {\n+                let operand = self.trans_operand(bcx, operand);\n+                let is_float = operand.ty.is_fp();\n+                let debug_loc = DebugLoc::None;\n+                let llval = match op {\n+                    mir::UnOp::Not => build::Not(bcx, operand.llval, debug_loc),\n+                    mir::UnOp::Neg => if is_float {\n+                        build::FNeg(bcx, operand.llval, debug_loc)\n+                    } else {\n+                        build::Neg(bcx, operand.llval, debug_loc)\n+                    }\n+                };\n+                build::Store(bcx, llval, lldest);\n+                bcx\n+            }\n+\n+            mir::Rvalue::Box(content_ty) => {\n+                let content_ty: Ty<'tcx> = content_ty;\n+                let llty = type_of::type_of(bcx.ccx(), content_ty);\n+                let llsize = machine::llsize_of(bcx.ccx(), llty);\n+                let align = type_of::align_of(bcx.ccx(), content_ty);\n+                let llalign = common::C_uint(bcx.ccx(), align);\n+                let llty_ptr = llty.ptr_to();\n+                let box_ty = bcx.tcx().mk_box(content_ty);\n+                let Result { bcx, val: llval } = base::malloc_raw_dyn(bcx,\n+                                                                      llty_ptr,\n+                                                                      box_ty,\n+                                                                      llsize,\n+                                                                      llalign,\n+                                                                      DebugLoc::None);\n+                build::Store(bcx, llval, lldest);\n+                bcx\n+            }\n+\n+            mir::Rvalue::Aggregate(_, ref operands) => {\n+                for (i, operand) in operands.iter().enumerate() {\n+                    let lldest_i = build::GEPi(bcx, lldest, &[0, i]);\n+                    self.trans_operand_into(bcx, lldest_i, operand);\n+                }\n+                bcx\n+            }\n+\n+            mir::Rvalue::Slice { ref input, from_start, from_end } => {\n+                let ccx = bcx.ccx();\n+                let input = self.trans_lvalue(bcx, input);\n+                let (llbase, lllen) = tvec::get_base_and_len(bcx,\n+                                                             input.llval,\n+                                                             input.ty.to_ty(bcx.tcx()));\n+                let llbase1 = build::GEPi(bcx, llbase, &[from_start]);\n+                let adj = common::C_uint(ccx, from_start + from_end);\n+                let lllen1 = build::Sub(bcx, lllen, adj, DebugLoc::None);\n+                build::Store(bcx, llbase1, build::GEPi(bcx, lldest, &[0, abi::FAT_PTR_ADDR]));\n+                build::Store(bcx, lllen1, build::GEPi(bcx, lldest, &[0, abi::FAT_PTR_EXTRA]));\n+                bcx\n+            }\n+\n+            mir::Rvalue::InlineAsm(inline_asm) => {\n+                asm::trans_inline_asm(bcx, inline_asm)\n+            }\n+        }\n+    }\n+}"}, {"sha": "17a20fb817c89c28ae0f6544e8e52e501339b375", "filename": "src/librustc_trans/trans/mir/statement.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/02017b30ebebfaeb64a5a86a885773f38057beba/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02017b30ebebfaeb64a5a86a885773f38057beba/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fstatement.rs?ref=02017b30ebebfaeb64a5a86a885773f38057beba", "patch": "@@ -0,0 +1,48 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::middle::ty::LvaluePreference;\n+use rustc_mir::repr as mir;\n+use trans::common::Block;\n+use trans::debuginfo::DebugLoc;\n+use trans::glue;\n+\n+use super::MirContext;\n+\n+impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n+    pub fn trans_statement(&mut self,\n+                           bcx: Block<'bcx, 'tcx>,\n+                           statement: &mir::Statement<'tcx>)\n+                           -> Block<'bcx, 'tcx> {\n+        debug!(\"trans_statement(statement={:?})\", statement);\n+\n+        match statement.kind {\n+            mir::StatementKind::Assign(ref lvalue, ref rvalue) => {\n+                let tr_dest = self.trans_lvalue(bcx, lvalue);\n+                self.trans_rvalue(bcx, tr_dest.llval, rvalue);\n+                bcx\n+            }\n+\n+            mir::StatementKind::Drop(mir::DropKind::Deep, ref lvalue) => {\n+                let tr_lvalue = self.trans_lvalue(bcx, lvalue);\n+                let ty = tr_lvalue.ty.to_ty(bcx.tcx());\n+                glue::drop_ty(bcx, tr_lvalue.llval, ty, DebugLoc::None)\n+            }\n+\n+            mir::StatementKind::Drop(mir::DropKind::Free, ref lvalue) => {\n+                let tr_lvalue = self.trans_lvalue(bcx, lvalue);\n+                let ty = tr_lvalue.ty.to_ty(bcx.tcx());\n+                let content_ty = ty.builtin_deref(true, LvaluePreference::NoPreference);\n+                let content_ty = content_ty.unwrap().ty;\n+                glue::trans_exchange_free_ty(bcx, tr_lvalue.llval, content_ty, DebugLoc::None)\n+            }\n+        }\n+    }\n+}"}, {"sha": "fa37b00553982f5534d701ae2bc37c9d6665259d", "filename": "src/librustc_trans/trans/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/02017b30ebebfaeb64a5a86a885773f38057beba/src%2Flibrustc_trans%2Ftrans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02017b30ebebfaeb64a5a86a885773f38057beba/src%2Flibrustc_trans%2Ftrans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmod.rs?ref=02017b30ebebfaeb64a5a86a885773f38057beba", "patch": "@@ -52,6 +52,7 @@ mod llrepr;\n mod machine;\n mod _match;\n mod meth;\n+mod mir;\n mod monomorphize;\n mod tvec;\n mod type_;"}, {"sha": "9a06ab78e73b45efd2023a2c450c372ffca8c1e7", "filename": "src/test/run-pass/mir_trans_spike1.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/02017b30ebebfaeb64a5a86a885773f38057beba/src%2Ftest%2Frun-pass%2Fmir_trans_spike1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02017b30ebebfaeb64a5a86a885773f38057beba/src%2Ftest%2Frun-pass%2Fmir_trans_spike1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir_trans_spike1.rs?ref=02017b30ebebfaeb64a5a86a885773f38057beba", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// A simple spike test for MIR version of trans.\n+\n+#![feature(rustc_attrs)]\n+\n+#[rustc_mir]\n+fn sum(x: i32, y: i32) -> i32 {\n+    x + y\n+}\n+\n+fn main() {\n+    let x = sum(22, 44);\n+    assert_eq!(x, 66);\n+    println!(\"sum()={:?}\", x);\n+}"}]}