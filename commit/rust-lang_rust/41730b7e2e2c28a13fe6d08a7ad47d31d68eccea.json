{"sha": "41730b7e2e2c28a13fe6d08a7ad47d31d68eccea", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQxNzMwYjdlMmUyYzI4YTEzZmU2ZDA4YTdhZDQ3ZDMxZDY4ZWNjZWE=", "commit": {"author": {"name": "Simon Sapin", "email": "simon.sapin@exyr.org", "date": "2018-06-27T16:09:21Z"}, "committer": {"name": "Simon Sapin", "email": "simon.sapin@exyr.org", "date": "2018-07-06T23:41:30Z"}, "message": "Rc: remove unused allocation from Weak::new()\n\nSame as https://github.com/rust-lang/rust/pull/50357", "tree": {"sha": "a9c525a2caca2b58e2ac27be70a77c04ba49d86a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a9c525a2caca2b58e2ac27be70a77c04ba49d86a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/41730b7e2e2c28a13fe6d08a7ad47d31d68eccea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/41730b7e2e2c28a13fe6d08a7ad47d31d68eccea", "html_url": "https://github.com/rust-lang/rust/commit/41730b7e2e2c28a13fe6d08a7ad47d31d68eccea", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/41730b7e2e2c28a13fe6d08a7ad47d31d68eccea/comments", "author": {"login": "SimonSapin", "id": 291359, "node_id": "MDQ6VXNlcjI5MTM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/291359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimonSapin", "html_url": "https://github.com/SimonSapin", "followers_url": "https://api.github.com/users/SimonSapin/followers", "following_url": "https://api.github.com/users/SimonSapin/following{/other_user}", "gists_url": "https://api.github.com/users/SimonSapin/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimonSapin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimonSapin/subscriptions", "organizations_url": "https://api.github.com/users/SimonSapin/orgs", "repos_url": "https://api.github.com/users/SimonSapin/repos", "events_url": "https://api.github.com/users/SimonSapin/events{/privacy}", "received_events_url": "https://api.github.com/users/SimonSapin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SimonSapin", "id": 291359, "node_id": "MDQ6VXNlcjI5MTM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/291359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimonSapin", "html_url": "https://github.com/SimonSapin", "followers_url": "https://api.github.com/users/SimonSapin/followers", "following_url": "https://api.github.com/users/SimonSapin/following{/other_user}", "gists_url": "https://api.github.com/users/SimonSapin/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimonSapin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimonSapin/subscriptions", "organizations_url": "https://api.github.com/users/SimonSapin/orgs", "repos_url": "https://api.github.com/users/SimonSapin/repos", "events_url": "https://api.github.com/users/SimonSapin/events{/privacy}", "received_events_url": "https://api.github.com/users/SimonSapin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6e2c49ff0e61e13aa3381eefba7923672a3c085f", "url": "https://api.github.com/repos/rust-lang/rust/commits/6e2c49ff0e61e13aa3381eefba7923672a3c085f", "html_url": "https://github.com/rust-lang/rust/commit/6e2c49ff0e61e13aa3381eefba7923672a3c085f"}], "stats": {"total": 61, "additions": 37, "deletions": 24}, "files": [{"sha": "3f32abe1ea9599316215aecf1317e115ed16bb7f", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 36, "deletions": 23, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/41730b7e2e2c28a13fe6d08a7ad47d31d68eccea/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41730b7e2e2c28a13fe6d08a7ad47d31d68eccea/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=41730b7e2e2c28a13fe6d08a7ad47d31d68eccea", "patch": "@@ -253,14 +253,15 @@ use core::hash::{Hash, Hasher};\n use core::intrinsics::abort;\n use core::marker;\n use core::marker::{Unsize, PhantomData};\n-use core::mem::{self, align_of_val, forget, size_of_val, uninitialized};\n+use core::mem::{self, align_of_val, forget, size_of_val};\n use core::ops::Deref;\n use core::ops::CoerceUnsized;\n use core::ptr::{self, NonNull};\n use core::convert::From;\n \n use alloc::{Global, Alloc, Layout, box_free, handle_alloc_error};\n use string::String;\n+use sync::is_dangling;\n use vec::Vec;\n \n struct RcBox<T: ?Sized> {\n@@ -1153,6 +1154,10 @@ impl<T> From<Vec<T>> for Rc<[T]> {\n /// [`None`]: ../../std/option/enum.Option.html#variant.None\n #[stable(feature = \"rc_weak\", since = \"1.4.0\")]\n pub struct Weak<T: ?Sized> {\n+    // This is a `NonNull` to allow optimizing the size of this type in enums,\n+    // but it is not necessarily a valid pointer.\n+    // `Weak::new` sets this to a dangling pointer so that it doesn\u2019t need\n+    // to allocate space on the heap.\n     ptr: NonNull<RcBox<T>>,\n }\n \n@@ -1165,8 +1170,8 @@ impl<T: ?Sized> !marker::Sync for Weak<T> {}\n impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<Weak<U>> for Weak<T> {}\n \n impl<T> Weak<T> {\n-    /// Constructs a new `Weak<T>`, allocating memory for `T` without initializing\n-    /// it. Calling [`upgrade`] on the return value always gives [`None`].\n+    /// Constructs a new `Weak<T>`, without allocating any memory.\n+    /// Calling [`upgrade`] on the return value always gives [`None`].\n     ///\n     /// [`upgrade`]: struct.Weak.html#method.upgrade\n     /// [`None`]: ../../std/option/enum.Option.html\n@@ -1181,14 +1186,8 @@ impl<T> Weak<T> {\n     /// ```\n     #[stable(feature = \"downgraded_weak\", since = \"1.10.0\")]\n     pub fn new() -> Weak<T> {\n-        unsafe {\n-            Weak {\n-                ptr: Box::into_raw_non_null(box RcBox {\n-                    strong: Cell::new(0),\n-                    weak: Cell::new(1),\n-                    value: uninitialized(),\n-                }),\n-            }\n+        Weak {\n+            ptr: NonNull::dangling(),\n         }\n     }\n }\n@@ -1222,13 +1221,25 @@ impl<T: ?Sized> Weak<T> {\n     /// ```\n     #[stable(feature = \"rc_weak\", since = \"1.4.0\")]\n     pub fn upgrade(&self) -> Option<Rc<T>> {\n-        if self.strong() == 0 {\n+        let inner = self.inner()?;\n+        if inner.strong() == 0 {\n             None\n         } else {\n-            self.inc_strong();\n+            inner.inc_strong();\n             Some(Rc { ptr: self.ptr, phantom: PhantomData })\n         }\n     }\n+\n+    /// Return `None` when the pointer is dangling and there is no allocated `RcBox`,\n+    /// i.e. this `Weak` was created by `Weak::new`\n+    #[inline]\n+    fn inner(&self) -> Option<&RcBox<T>> {\n+        if is_dangling(self.ptr) {\n+            None\n+        } else {\n+            Some(unsafe { self.ptr.as_ref() })\n+        }\n+    }\n }\n \n #[stable(feature = \"rc_weak\", since = \"1.4.0\")]\n@@ -1258,12 +1269,14 @@ impl<T: ?Sized> Drop for Weak<T> {\n     /// assert!(other_weak_foo.upgrade().is_none());\n     /// ```\n     fn drop(&mut self) {\n-        unsafe {\n-            self.dec_weak();\n+        if let Some(inner) = self.inner() {\n+            inner.dec_weak();\n             // the weak count starts at 1, and will only go to zero if all\n             // the strong pointers have disappeared.\n-            if self.weak() == 0 {\n-                Global.dealloc(self.ptr.cast(), Layout::for_value(self.ptr.as_ref()));\n+            if inner.weak() == 0 {\n+                unsafe {\n+                    Global.dealloc(self.ptr.cast(), Layout::for_value(self.ptr.as_ref()));\n+                }\n             }\n         }\n     }\n@@ -1284,7 +1297,9 @@ impl<T: ?Sized> Clone for Weak<T> {\n     /// ```\n     #[inline]\n     fn clone(&self) -> Weak<T> {\n-        self.inc_weak();\n+        if let Some(inner) = self.inner() {\n+            inner.inc_weak()\n+        }\n         Weak { ptr: self.ptr }\n     }\n }\n@@ -1317,7 +1332,7 @@ impl<T> Default for Weak<T> {\n     }\n }\n \n-// NOTE: We checked_add here to deal with mem::forget safety. In particular\n+// NOTE: We checked_add here to deal with mem::forget safely. In particular\n // if you mem::forget Rcs (or Weaks), the ref-count can overflow, and then\n // you can free the allocation while outstanding Rcs (or Weaks) exist.\n // We abort because this is such a degenerate scenario that we don't care about\n@@ -1370,12 +1385,10 @@ impl<T: ?Sized> RcBoxPtr<T> for Rc<T> {\n     }\n }\n \n-impl<T: ?Sized> RcBoxPtr<T> for Weak<T> {\n+impl<T: ?Sized> RcBoxPtr<T> for RcBox<T> {\n     #[inline(always)]\n     fn inner(&self) -> &RcBox<T> {\n-        unsafe {\n-            self.ptr.as_ref()\n-        }\n+        self\n     }\n }\n "}, {"sha": "ea8616bf1d05c8d24d3846899d53b591a01d2a63", "filename": "src/liballoc/sync.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41730b7e2e2c28a13fe6d08a7ad47d31d68eccea/src%2Fliballoc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41730b7e2e2c28a13fe6d08a7ad47d31d68eccea/src%2Fliballoc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync.rs?ref=41730b7e2e2c28a13fe6d08a7ad47d31d68eccea", "patch": "@@ -1038,7 +1038,7 @@ impl<T> Weak<T> {\n     }\n }\n \n-fn is_dangling<T: ?Sized>(ptr: NonNull<T>) -> bool {\n+pub(crate) fn is_dangling<T: ?Sized>(ptr: NonNull<T>) -> bool {\n     let address = ptr.as_ptr() as *mut () as usize;\n     let align = align_of_val(unsafe { ptr.as_ref() });\n     address == align"}]}