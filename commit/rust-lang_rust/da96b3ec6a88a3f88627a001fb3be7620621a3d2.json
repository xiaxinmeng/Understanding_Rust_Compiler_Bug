{"sha": "da96b3ec6a88a3f88627a001fb3be7620621a3d2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRhOTZiM2VjNmE4OGEzZjg4NjI3YTAwMWZiM2JlNzYyMDYyMWEzZDI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-28T21:15:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-28T21:15:37Z"}, "message": "auto merge of #8447 : alexcrichton/rust/local-data-merge, r=brson\n\nThis moves all local_data stuff into the `local_data` module and only that\r\nmodule alone. It also removes a fair amount of \"super-unsafe\" code in favor of\r\njust vanilla code generated by the compiler at the same time.\r\n\r\nCloses #8113", "tree": {"sha": "eaf6e2f9c10d9d49e64c984c770c0bb0d077f3ed", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eaf6e2f9c10d9d49e64c984c770c0bb0d077f3ed"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/da96b3ec6a88a3f88627a001fb3be7620621a3d2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/da96b3ec6a88a3f88627a001fb3be7620621a3d2", "html_url": "https://github.com/rust-lang/rust/commit/da96b3ec6a88a3f88627a001fb3be7620621a3d2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/da96b3ec6a88a3f88627a001fb3be7620621a3d2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9c33ef5a7c24abe258be5c130dec1c77e72de86b", "url": "https://api.github.com/repos/rust-lang/rust/commits/9c33ef5a7c24abe258be5c130dec1c77e72de86b", "html_url": "https://github.com/rust-lang/rust/commit/9c33ef5a7c24abe258be5c130dec1c77e72de86b"}, {"sha": "06a7195e9e9cea81854c39ce2c1376fe588bc1b0", "url": "https://api.github.com/repos/rust-lang/rust/commits/06a7195e9e9cea81854c39ce2c1376fe588bc1b0", "html_url": "https://github.com/rust-lang/rust/commit/06a7195e9e9cea81854c39ce2c1376fe588bc1b0"}], "stats": {"total": 1016, "additions": 467, "deletions": 549}, "files": [{"sha": "88e7dd692fec850419d90e5a512a31d02d66c49a", "filename": "src/libstd/local_data.rs", "status": "modified", "additions": 453, "deletions": 207, "changes": 660, "blob_url": "https://github.com/rust-lang/rust/blob/da96b3ec6a88a3f88627a001fb3be7620621a3d2/src%2Flibstd%2Flocal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da96b3ec6a88a3f88627a001fb3be7620621a3d2/src%2Flibstd%2Flocal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flocal_data.rs?ref=da96b3ec6a88a3f88627a001fb3be7620621a3d2", "patch": "@@ -39,11 +39,11 @@ magic.\n \n */\n \n+use cast;\n+use libc;\n use prelude::*;\n-\n-use task::local_data_priv::*;\n-\n-#[cfg(test)] use task;\n+use rt::task::{Task, LocalStorage};\n+use util;\n \n /**\n  * Indexes a task-local data slot. This pointer is used for comparison to\n@@ -60,263 +60,509 @@ pub type Key<T> = &'static KeyValue<T>;\n \n pub enum KeyValue<T> { Key }\n \n-/**\n- * Remove a task-local data value from the table, returning the\n- * reference that was originally created to insert it.\n- */\n-pub fn pop<T: 'static>(key: Key<T>) -> Option<T> {\n-    unsafe { local_pop(Handle::new(), key) }\n-}\n-\n-/**\n- * Retrieve a task-local data value. It will also be kept alive in the\n- * table until explicitly removed.\n- */\n-pub fn get<T: 'static, U>(key: Key<T>, f: &fn(Option<&T>) -> U) -> U {\n-    unsafe { local_get(Handle::new(), key, f) }\n-}\n+trait LocalData {}\n+impl<T: 'static> LocalData for T {}\n \n-/**\n- * Retrieve a mutable borrowed pointer to a task-local data value.\n- */\n-pub fn get_mut<T: 'static, U>(key: Key<T>, f: &fn(Option<&mut T>) -> U) -> U {\n-    unsafe { local_get_mut(Handle::new(), key, f) }\n+// The task-local-map stores all TLS information for the currently running task.\n+// It is stored as an owned pointer into the runtime, and it's only allocated\n+// when TLS is used for the first time. This map must be very carefully\n+// constructed because it has many mutable loans unsoundly handed out on it to\n+// the various invocations of TLS requests.\n+//\n+// One of the most important operations is loaning a value via `get` to a\n+// caller. In doing so, the slot that the TLS entry is occupying cannot be\n+// invalidated because upon returning it's loan state must be updated. Currently\n+// the TLS map is a vector, but this is possibly dangerous because the vector\n+// can be reallocated/moved when new values are pushed onto it.\n+//\n+// This problem currently isn't solved in a very elegant way. Inside the `get`\n+// function, it internally \"invalidates\" all references after the loan is\n+// finished and looks up into the vector again. In theory this will prevent\n+// pointers from being moved under our feet so long as LLVM doesn't go too crazy\n+// with the optimizations.\n+//\n+// n.b. If TLS is used heavily in future, this could be made more efficient with\n+//      a proper map.\n+#[doc(hidden)]\n+pub type Map = ~[Option<(*libc::c_void, TLSValue, LoanState)>];\n+type TLSValue = ~LocalData;\n+\n+// Gets the map from the runtime. Lazily initialises if not done so already.\n+unsafe fn get_local_map() -> &mut Map {\n+    use rt::local::Local;\n+\n+    let task: *mut Task = Local::unsafe_borrow();\n+    match &mut (*task).storage {\n+        // If the at_exit function is already set, then we just need to take\n+        // a loan out on the TLS map stored inside\n+        &LocalStorage(Some(ref mut map_ptr)) => {\n+            return map_ptr;\n+        }\n+        // If this is the first time we've accessed TLS, perform similar\n+        // actions to the oldsched way of doing things.\n+        &LocalStorage(ref mut slot) => {\n+            *slot = Some(~[]);\n+            match *slot {\n+                Some(ref mut map_ptr) => { return map_ptr }\n+                None => abort()\n+            }\n+        }\n+    }\n }\n \n-/**\n- * Store a value in task-local data. If this key already has a value,\n- * that value is overwritten (and its destructor is run).\n- */\n-pub fn set<T: 'static>(key: Key<T>, data: T) {\n-    unsafe { local_set(Handle::new(), key, data) }\n+#[deriving(Eq)]\n+enum LoanState {\n+    NoLoan, ImmLoan, MutLoan\n }\n \n-/**\n- * Modify a task-local data value. If the function returns 'None', the\n- * data is removed (and its reference dropped).\n- */\n-pub fn modify<T: 'static>(key: Key<T>, f: &fn(Option<T>) -> Option<T>) {\n-    unsafe {\n-        match f(pop(::cast::unsafe_copy(&key))) {\n-            Some(next) => { set(key, next); }\n-            None => {}\n+impl LoanState {\n+    fn describe(&self) -> &'static str {\n+        match *self {\n+            NoLoan => \"no loan\",\n+            ImmLoan => \"immutable\",\n+            MutLoan => \"mutable\"\n         }\n     }\n }\n \n-#[test]\n-fn test_tls_multitask() {\n-    static my_key: Key<@~str> = &Key;\n-    set(my_key, @~\"parent data\");\n-    do task::spawn {\n-        // TLS shouldn't carry over.\n-        assert!(get(my_key, |k| k.map_move(|k| *k)).is_none());\n-        set(my_key, @~\"child data\");\n-        assert!(*(get(my_key, |k| k.map_move(|k| *k)).unwrap()) ==\n-                ~\"child data\");\n-        // should be cleaned up for us\n+fn key_to_key_value<T: 'static>(key: Key<T>) -> *libc::c_void {\n+    unsafe { cast::transmute(key) }\n+}\n+\n+/// Removes a task-local value from task-local storage. This will return\n+/// Some(value) if the key was present in TLS, otherwise it will return None.\n+///\n+/// A runtime assertion will be triggered it removal of TLS value is attempted\n+/// while the value is still loaned out via `get` or `get_mut`.\n+pub fn pop<T: 'static>(key: Key<T>) -> Option<T> {\n+    let map = unsafe { get_local_map() };\n+    let key_value = key_to_key_value(key);\n+\n+    for entry in map.mut_iter() {\n+        match *entry {\n+            Some((k, _, loan)) if k == key_value => {\n+                if loan != NoLoan {\n+                    fail!(\"TLS value cannot be removed because it is currently \\\n+                          borrowed as %s\", loan.describe());\n+                }\n+                // Move the data out of the `entry` slot via util::replace.\n+                // This is guaranteed to succeed because we already matched\n+                // on `Some` above.\n+                let data = match util::replace(entry, None) {\n+                    Some((_, data, _)) => data,\n+                    None => abort()\n+                };\n+\n+                // Move `data` into transmute to get out the memory that it\n+                // owns, we must free it manually later.\n+                let (_vtable, box): (uint, ~~T) = unsafe {\n+                    cast::transmute(data)\n+                };\n+\n+                // Now that we own `box`, we can just move out of it as we would\n+                // with any other data.\n+                return Some(**box);\n+            }\n+            _ => {}\n+        }\n     }\n-    // Must work multiple times\n-    assert!(*(get(my_key, |k| k.map_move(|k| *k)).unwrap()) == ~\"parent data\");\n-    assert!(*(get(my_key, |k| k.map_move(|k| *k)).unwrap()) == ~\"parent data\");\n-    assert!(*(get(my_key, |k| k.map_move(|k| *k)).unwrap()) == ~\"parent data\");\n+    return None;\n }\n \n-#[test]\n-fn test_tls_overwrite() {\n-    static my_key: Key<@~str> = &Key;\n-    set(my_key, @~\"first data\");\n-    set(my_key, @~\"next data\"); // Shouldn't leak.\n-    assert!(*(get(my_key, |k| k.map_move(|k| *k)).unwrap()) == ~\"next data\");\n+/// Retrieves a value from TLS. The closure provided is yielded `Some` of a\n+/// reference to the value located in TLS if one exists, or `None` if the key\n+/// provided is not present in TLS currently.\n+///\n+/// It is considered a runtime error to attempt to get a value which is already\n+/// on loan via the `get_mut` method provided.\n+pub fn get<T: 'static, U>(key: Key<T>, f: &fn(Option<&T>) -> U) -> U {\n+    get_with(key, ImmLoan, f)\n }\n \n-#[test]\n-fn test_tls_pop() {\n-    static my_key: Key<@~str> = &Key;\n-    set(my_key, @~\"weasel\");\n-    assert!(*(pop(my_key).unwrap()) == ~\"weasel\");\n-    // Pop must remove the data from the map.\n-    assert!(pop(my_key).is_none());\n+/// Retrieves a mutable value from TLS. The closure provided is yielded `Some`\n+/// of a reference to the mutable value located in TLS if one exists, or `None`\n+/// if the key provided is not present in TLS currently.\n+///\n+/// It is considered a runtime error to attempt to get a value which is already\n+/// on loan via this or the `get` methods. This is similar to how it's a runtime\n+/// error to take two mutable loans on an `@mut` box.\n+pub fn get_mut<T: 'static, U>(key: Key<T>, f: &fn(Option<&mut T>) -> U) -> U {\n+    do get_with(key, MutLoan) |x| {\n+        match x {\n+            None => f(None),\n+            // We're violating a lot of compiler guarantees with this\n+            // invocation of `transmute_mut`, but we're doing runtime checks to\n+            // ensure that it's always valid (only one at a time).\n+            //\n+            // there is no need to be upset!\n+            Some(x) => { f(Some(unsafe { cast::transmute_mut(x) })) }\n+        }\n+    }\n }\n \n-#[test]\n-fn test_tls_modify() {\n-    static my_key: Key<@~str> = &Key;\n-    modify(my_key, |data| {\n-        match data {\n-            Some(@ref val) => fail!(\"unwelcome value: %s\", *val),\n-            None           => Some(@~\"first data\")\n+fn get_with<T: 'static, U>(key: Key<T>,\n+                           state: LoanState,\n+                           f: &fn(Option<&T>) -> U) -> U {\n+    // This function must be extremely careful. Because TLS can store owned\n+    // values, and we must have some form of `get` function other than `pop`,\n+    // this function has to give a `&` reference back to the caller.\n+    //\n+    // One option is to return the reference, but this cannot be sound because\n+    // the actual lifetime of the object is not known. The slot in TLS could not\n+    // be modified until the object goes out of scope, but the TLS code cannot\n+    // know when this happens.\n+    //\n+    // For this reason, the reference is yielded to a specified closure. This\n+    // way the TLS code knows exactly what the lifetime of the yielded pointer\n+    // is, allowing callers to acquire references to owned data. This is also\n+    // sound so long as measures are taken to ensure that while a TLS slot is\n+    // loaned out to a caller, it's not modified recursively.\n+    let map = unsafe { get_local_map() };\n+    let key_value = key_to_key_value(key);\n+\n+    let pos = map.iter().position(|entry| {\n+        match *entry {\n+            Some((k, _, _)) if k == key_value => true, _ => false\n         }\n     });\n-    modify(my_key, |data| {\n-        match data {\n-            Some(@~\"first data\") => Some(@~\"next data\"),\n-            Some(@ref val)       => fail!(\"wrong value: %s\", *val),\n-            None                 => fail!(\"missing value\")\n+    match pos {\n+        None => { return f(None); }\n+        Some(i) => {\n+            let ret;\n+            let mut return_loan = false;\n+            match map[i] {\n+                Some((_, ref data, ref mut loan)) => {\n+                    match (state, *loan) {\n+                        (_, NoLoan) => {\n+                            *loan = state;\n+                            return_loan = true;\n+                        }\n+                        (ImmLoan, ImmLoan) => {}\n+                        (want, cur) => {\n+                            fail!(\"TLS slot cannot be borrowed as %s because \\\n+                                   it is already borrowed as %s\",\n+                                  want.describe(), cur.describe());\n+                        }\n+                    }\n+                    // data was created with `~~T as ~LocalData`, so we extract\n+                    // pointer part of the trait, (as ~~T), and then use\n+                    // compiler coercions to achieve a '&' pointer.\n+                    unsafe {\n+                        match *cast::transmute::<&TLSValue, &(uint, ~~T)>(data){\n+                            (_vtable, ref box) => {\n+                                let value: &T = **box;\n+                                ret = f(Some(value));\n+                            }\n+                        }\n+                    }\n+                }\n+                _ => abort()\n+            }\n+\n+            // n.b. 'data' and 'loans' are both invalid pointers at the point\n+            // 'f' returned because `f` could have appended more TLS items which\n+            // in turn relocated the vector. Hence we do another lookup here to\n+            // fixup the loans.\n+            if return_loan {\n+                match map[i] {\n+                    Some((_, _, ref mut loan)) => { *loan = NoLoan; }\n+                    None => abort()\n+                }\n+            }\n+            return ret;\n         }\n-    });\n-    assert!(*(pop(my_key).unwrap()) == ~\"next data\");\n+    }\n }\n \n-#[test]\n-fn test_tls_crust_automorestack_memorial_bug() {\n-    // This might result in a stack-canary clobber if the runtime fails to\n-    // set sp_limit to 0 when calling the cleanup extern - it might\n-    // automatically jump over to the rust stack, which causes next_c_sp\n-    // to get recorded as something within a rust stack segment. Then a\n-    // subsequent upcall (esp. for logging, think vsnprintf) would run on\n-    // a stack smaller than 1 MB.\n-    static my_key: Key<@~str> = &Key;\n-    do task::spawn {\n-        set(my_key, @~\"hax\");\n-    }\n+fn abort() -> ! {\n+    #[fixed_stack_segment]; #[inline(never)];\n+    unsafe { libc::abort() }\n }\n \n-#[test]\n-fn test_tls_multiple_types() {\n-    static str_key: Key<@~str> = &Key;\n-    static box_key: Key<@@()> = &Key;\n-    static int_key: Key<@int> = &Key;\n-    do task::spawn {\n-        set(str_key, @~\"string data\");\n-        set(box_key, @@());\n-        set(int_key, @42);\n+/// Inserts a value into task local storage. If the key is already present in\n+/// TLS, then the previous value is removed and replaced with the provided data.\n+///\n+/// It is considered a runtime error to attempt to set a key which is currently\n+/// on loan via the `get` or `get_mut` methods.\n+pub fn set<T: 'static>(key: Key<T>, data: T) {\n+    let map = unsafe { get_local_map() };\n+    let keyval = key_to_key_value(key);\n+\n+    // When the task-local map is destroyed, all the data needs to be cleaned\n+    // up. For this reason we can't do some clever tricks to store '~T' as a\n+    // '*c_void' or something like that. To solve the problem, we cast\n+    // everything to a trait (LocalData) which is then stored inside the map.\n+    // Upon destruction of the map, all the objects will be destroyed and the\n+    // traits have enough information about them to destroy themselves.\n+    //\n+    // FIXME(#7673): This should be \"~data as ~LocalData\" (only one sigil)\n+    let data = ~~data as ~LocalData:;\n+\n+    fn insertion_position(map: &mut Map,\n+                          key: *libc::c_void) -> Option<uint> {\n+        // First see if the map contains this key already\n+        let curspot = map.iter().position(|entry| {\n+            match *entry {\n+                Some((ekey, _, loan)) if key == ekey => {\n+                    if loan != NoLoan {\n+                        fail!(\"TLS value cannot be overwritten because it is\n+                               already borrowed as %s\", loan.describe())\n+                    }\n+                    true\n+                }\n+                _ => false,\n+            }\n+        });\n+        // If it doesn't contain the key, just find a slot that's None\n+        match curspot {\n+            Some(i) => Some(i),\n+            None => map.iter().position(|entry| entry.is_none())\n+        }\n+    }\n+\n+    // The type of the local data map must ascribe to Send, so we do the\n+    // transmute here to add the Send bound back on. This doesn't actually\n+    // matter because TLS will always own the data (until its moved out) and\n+    // we're not actually sending it to other schedulers or anything.\n+    let data: ~LocalData = unsafe { cast::transmute(data) };\n+    match insertion_position(map, keyval) {\n+        Some(i) => { map[i] = Some((keyval, data, NoLoan)); }\n+        None => { map.push(Some((keyval, data, NoLoan))); }\n     }\n }\n \n-#[test]\n-fn test_tls_overwrite_multiple_types() {\n-    static str_key: Key<@~str> = &Key;\n-    static box_key: Key<@@()> = &Key;\n-    static int_key: Key<@int> = &Key;\n-    do task::spawn {\n-        set(str_key, @~\"string data\");\n-        set(int_key, @42);\n-        // This could cause a segfault if overwriting-destruction is done\n-        // with the crazy polymorphic transmute rather than the provided\n-        // finaliser.\n-        set(int_key, @31337);\n+/// Modifies a task-local value by temporarily removing it from task-local\n+/// storage and then re-inserting if `Some` is returned from the closure.\n+///\n+/// This function will have the same runtime errors as generated from `pop` and\n+/// `set` (the key must not currently be on loan\n+pub fn modify<T: 'static>(key: Key<T>, f: &fn(Option<T>) -> Option<T>) {\n+    match f(pop(key)) {\n+        Some(next) => { set(key, next); }\n+        None => {}\n     }\n }\n \n-#[test]\n-#[should_fail]\n-fn test_tls_cleanup_on_failure() {\n-    static str_key: Key<@~str> = &Key;\n-    static box_key: Key<@@()> = &Key;\n-    static int_key: Key<@int> = &Key;\n-    set(str_key, @~\"parent data\");\n-    set(box_key, @@());\n-    do task::spawn {\n-        // spawn_linked\n-        set(str_key, @~\"string data\");\n+#[cfg(test)]\n+mod tests {\n+    use prelude::*;\n+    use super::*;\n+    use task;\n+\n+    #[test]\n+    fn test_tls_multitask() {\n+        static my_key: Key<@~str> = &Key;\n+        set(my_key, @~\"parent data\");\n+        do task::spawn {\n+            // TLS shouldn't carry over.\n+            assert!(get(my_key, |k| k.map_move(|k| *k)).is_none());\n+            set(my_key, @~\"child data\");\n+            assert!(*(get(my_key, |k| k.map_move(|k| *k)).unwrap()) ==\n+                    ~\"child data\");\n+            // should be cleaned up for us\n+        }\n+        // Must work multiple times\n+        assert!(*(get(my_key, |k| k.map_move(|k| *k)).unwrap()) == ~\"parent data\");\n+        assert!(*(get(my_key, |k| k.map_move(|k| *k)).unwrap()) == ~\"parent data\");\n+        assert!(*(get(my_key, |k| k.map_move(|k| *k)).unwrap()) == ~\"parent data\");\n+    }\n+\n+    #[test]\n+    fn test_tls_overwrite() {\n+        static my_key: Key<@~str> = &Key;\n+        set(my_key, @~\"first data\");\n+        set(my_key, @~\"next data\"); // Shouldn't leak.\n+        assert!(*(get(my_key, |k| k.map_move(|k| *k)).unwrap()) == ~\"next data\");\n+    }\n+\n+    #[test]\n+    fn test_tls_pop() {\n+        static my_key: Key<@~str> = &Key;\n+        set(my_key, @~\"weasel\");\n+        assert!(*(pop(my_key).unwrap()) == ~\"weasel\");\n+        // Pop must remove the data from the map.\n+        assert!(pop(my_key).is_none());\n+    }\n+\n+    #[test]\n+    fn test_tls_modify() {\n+        static my_key: Key<@~str> = &Key;\n+        modify(my_key, |data| {\n+            match data {\n+                Some(@ref val) => fail!(\"unwelcome value: %s\", *val),\n+                None           => Some(@~\"first data\")\n+            }\n+        });\n+        modify(my_key, |data| {\n+            match data {\n+                Some(@~\"first data\") => Some(@~\"next data\"),\n+                Some(@ref val)       => fail!(\"wrong value: %s\", *val),\n+                None                 => fail!(\"missing value\")\n+            }\n+        });\n+        assert!(*(pop(my_key).unwrap()) == ~\"next data\");\n+    }\n+\n+    #[test]\n+    fn test_tls_crust_automorestack_memorial_bug() {\n+        // This might result in a stack-canary clobber if the runtime fails to\n+        // set sp_limit to 0 when calling the cleanup extern - it might\n+        // automatically jump over to the rust stack, which causes next_c_sp\n+        // to get recorded as something within a rust stack segment. Then a\n+        // subsequent upcall (esp. for logging, think vsnprintf) would run on\n+        // a stack smaller than 1 MB.\n+        static my_key: Key<@~str> = &Key;\n+        do task::spawn {\n+            set(my_key, @~\"hax\");\n+        }\n+    }\n+\n+    #[test]\n+    fn test_tls_multiple_types() {\n+        static str_key: Key<@~str> = &Key;\n+        static box_key: Key<@@()> = &Key;\n+        static int_key: Key<@int> = &Key;\n+        do task::spawn {\n+            set(str_key, @~\"string data\");\n+            set(box_key, @@());\n+            set(int_key, @42);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_tls_overwrite_multiple_types() {\n+        static str_key: Key<@~str> = &Key;\n+        static box_key: Key<@@()> = &Key;\n+        static int_key: Key<@int> = &Key;\n+        do task::spawn {\n+            set(str_key, @~\"string data\");\n+            set(int_key, @42);\n+            // This could cause a segfault if overwriting-destruction is done\n+            // with the crazy polymorphic transmute rather than the provided\n+            // finaliser.\n+            set(int_key, @31337);\n+        }\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn test_tls_cleanup_on_failure() {\n+        static str_key: Key<@~str> = &Key;\n+        static box_key: Key<@@()> = &Key;\n+        static int_key: Key<@int> = &Key;\n+        set(str_key, @~\"parent data\");\n         set(box_key, @@());\n-        set(int_key, @42);\n+        do task::spawn {\n+            // spawn_linked\n+            set(str_key, @~\"string data\");\n+            set(box_key, @@());\n+            set(int_key, @42);\n+            fail!();\n+        }\n+        // Not quite nondeterministic.\n+        set(int_key, @31337);\n         fail!();\n     }\n-    // Not quite nondeterministic.\n-    set(int_key, @31337);\n-    fail!();\n-}\n \n-#[test]\n-fn test_static_pointer() {\n-    static key: Key<@&'static int> = &Key;\n-    static VALUE: int = 0;\n-    let v: @&'static int = @&VALUE;\n-    set(key, v);\n-}\n+    #[test]\n+    fn test_static_pointer() {\n+        static key: Key<@&'static int> = &Key;\n+        static VALUE: int = 0;\n+        let v: @&'static int = @&VALUE;\n+        set(key, v);\n+    }\n \n-#[test]\n-fn test_owned() {\n-    static key: Key<~int> = &Key;\n-    set(key, ~1);\n+    #[test]\n+    fn test_owned() {\n+        static key: Key<~int> = &Key;\n+        set(key, ~1);\n \n-    do get(key) |v| {\n         do get(key) |v| {\n             do get(key) |v| {\n+                do get(key) |v| {\n+                    assert_eq!(**v.unwrap(), 1);\n+                }\n                 assert_eq!(**v.unwrap(), 1);\n             }\n             assert_eq!(**v.unwrap(), 1);\n         }\n-        assert_eq!(**v.unwrap(), 1);\n-    }\n-    set(key, ~2);\n-    do get(key) |v| {\n-        assert_eq!(**v.unwrap(), 2);\n+        set(key, ~2);\n+        do get(key) |v| {\n+            assert_eq!(**v.unwrap(), 2);\n+        }\n     }\n-}\n \n-#[test]\n-fn test_get_mut() {\n-    static key: Key<int> = &Key;\n-    set(key, 1);\n+    #[test]\n+    fn test_get_mut() {\n+        static key: Key<int> = &Key;\n+        set(key, 1);\n \n-    do get_mut(key) |v| {\n-        *v.unwrap() = 2;\n-    }\n+        do get_mut(key) |v| {\n+            *v.unwrap() = 2;\n+        }\n \n-    do get(key) |v| {\n-        assert_eq!(*v.unwrap(), 2);\n+        do get(key) |v| {\n+            assert_eq!(*v.unwrap(), 2);\n+        }\n     }\n-}\n \n-#[test]\n-fn test_same_key_type() {\n-    static key1: Key<int> = &Key;\n-    static key2: Key<int> = &Key;\n-    static key3: Key<int> = &Key;\n-    static key4: Key<int> = &Key;\n-    static key5: Key<int> = &Key;\n-    set(key1, 1);\n-    set(key2, 2);\n-    set(key3, 3);\n-    set(key4, 4);\n-    set(key5, 5);\n-\n-    get(key1, |x| assert_eq!(*x.unwrap(), 1));\n-    get(key2, |x| assert_eq!(*x.unwrap(), 2));\n-    get(key3, |x| assert_eq!(*x.unwrap(), 3));\n-    get(key4, |x| assert_eq!(*x.unwrap(), 4));\n-    get(key5, |x| assert_eq!(*x.unwrap(), 5));\n-}\n+    #[test]\n+    fn test_same_key_type() {\n+        static key1: Key<int> = &Key;\n+        static key2: Key<int> = &Key;\n+        static key3: Key<int> = &Key;\n+        static key4: Key<int> = &Key;\n+        static key5: Key<int> = &Key;\n+        set(key1, 1);\n+        set(key2, 2);\n+        set(key3, 3);\n+        set(key4, 4);\n+        set(key5, 5);\n+\n+        get(key1, |x| assert_eq!(*x.unwrap(), 1));\n+        get(key2, |x| assert_eq!(*x.unwrap(), 2));\n+        get(key3, |x| assert_eq!(*x.unwrap(), 3));\n+        get(key4, |x| assert_eq!(*x.unwrap(), 4));\n+        get(key5, |x| assert_eq!(*x.unwrap(), 5));\n+    }\n \n-#[test]\n-#[should_fail]\n-fn test_nested_get_set1() {\n-    static key: Key<int> = &Key;\n-    set(key, 4);\n-    do get(key) |_| {\n+    #[test]\n+    #[should_fail]\n+    fn test_nested_get_set1() {\n+        static key: Key<int> = &Key;\n         set(key, 4);\n+        do get(key) |_| {\n+            set(key, 4);\n+        }\n     }\n-}\n \n-#[test]\n-#[should_fail]\n-fn test_nested_get_mut2() {\n-    static key: Key<int> = &Key;\n-    set(key, 4);\n-    do get(key) |_| {\n-        get_mut(key, |_| {})\n+    #[test]\n+    #[should_fail]\n+    fn test_nested_get_mut2() {\n+        static key: Key<int> = &Key;\n+        set(key, 4);\n+        do get(key) |_| {\n+            get_mut(key, |_| {})\n+        }\n     }\n-}\n \n-#[test]\n-#[should_fail]\n-fn test_nested_get_mut3() {\n-    static key: Key<int> = &Key;\n-    set(key, 4);\n-    do get_mut(key) |_| {\n-        get(key, |_| {})\n+    #[test]\n+    #[should_fail]\n+    fn test_nested_get_mut3() {\n+        static key: Key<int> = &Key;\n+        set(key, 4);\n+        do get_mut(key) |_| {\n+            get(key, |_| {})\n+        }\n     }\n-}\n \n-#[test]\n-#[should_fail]\n-fn test_nested_get_mut4() {\n-    static key: Key<int> = &Key;\n-    set(key, 4);\n-    do get_mut(key) |_| {\n-        get_mut(key, |_| {})\n+    #[test]\n+    #[should_fail]\n+    fn test_nested_get_mut4() {\n+        static key: Key<int> = &Key;\n+        set(key, 4);\n+        do get_mut(key) |_| {\n+            get_mut(key, |_| {})\n+        }\n     }\n }"}, {"sha": "7728a388c658a689c023f7b583acb00093684ee0", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/da96b3ec6a88a3f88627a001fb3be7620621a3d2/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da96b3ec6a88a3f88627a001fb3be7620621a3d2/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=da96b3ec6a88a3f88627a001fb3be7620621a3d2", "patch": "@@ -55,10 +55,6 @@ Several modules in `core` are clients of `rt`:\n */\n \n #[doc(hidden)];\n-#[deny(unused_imports)];\n-#[deny(unused_mut)];\n-#[deny(unused_variable)];\n-#[deny(unused_unsafe)];\n \n use cell::Cell;\n use clone::Clone;"}, {"sha": "da81aab0f7849eb6bfd5742629af46168b383219", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/da96b3ec6a88a3f88627a001fb3be7620621a3d2/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da96b3ec6a88a3f88627a001fb3be7620621a3d2/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=da96b3ec6a88a3f88627a001fb3be7620621a3d2", "patch": "@@ -16,8 +16,8 @@\n use borrow;\n use cast::transmute;\n use cleanup;\n+use local_data;\n use libc::{c_void, uintptr_t};\n-use ptr;\n use prelude::*;\n use option::{Option, Some, None};\n use rt::borrowck;\n@@ -80,7 +80,7 @@ pub enum SchedHome {\n }\n \n pub struct GarbageCollector;\n-pub struct LocalStorage(*c_void, Option<extern \"Rust\" fn(*c_void)>);\n+pub struct LocalStorage(Option<local_data::Map>);\n \n pub struct Unwinder {\n     unwinding: bool,\n@@ -130,7 +130,7 @@ impl Task {\n         Task {\n             heap: LocalHeap::new(),\n             gc: GarbageCollector,\n-            storage: LocalStorage(ptr::null(), None),\n+            storage: LocalStorage(None),\n             logger: StdErrLogger,\n             unwinder: Unwinder { unwinding: false },\n             taskgroup: None,\n@@ -164,7 +164,7 @@ impl Task {\n         Task {\n             heap: LocalHeap::new(),\n             gc: GarbageCollector,\n-            storage: LocalStorage(ptr::null(), None),\n+            storage: LocalStorage(None),\n             logger: StdErrLogger,\n             unwinder: Unwinder { unwinding: false },\n             taskgroup: None,\n@@ -186,7 +186,7 @@ impl Task {\n         Task {\n             heap: LocalHeap::new(),\n             gc: GarbageCollector,\n-            storage: LocalStorage(ptr::null(), None),\n+            storage: LocalStorage(None),\n             logger: StdErrLogger,\n             unwinder: Unwinder { unwinding: false },\n             taskgroup: None,\n@@ -233,15 +233,8 @@ impl Task {\n \n             // Run the task main function, then do some cleanup.\n             do f.finally {\n-\n-                // Destroy task-local storage. This may run user dtors.\n-                match self.storage {\n-                    LocalStorage(ptr, Some(ref dtor)) => {\n-                        (*dtor)(ptr)\n-                    }\n-                    _ => ()\n-                }\n-\n+                // First, destroy task-local storage. This may run user dtors.\n+                //\n                 // FIXME #8302: Dear diary. I'm so tired and confused.\n                 // There's some interaction in rustc between the box\n                 // annihilator and the TLS dtor by which TLS is\n@@ -253,7 +246,13 @@ impl Task {\n                 // TLS would be reinitialized but never destroyed,\n                 // but somehow this works. I have no idea what's going\n                 // on but this seems to make things magically work. FML.\n-                self.storage = LocalStorage(ptr::null(), None);\n+                //\n+                // (added after initial comment) A possible interaction here is\n+                // that the destructors for the objects in TLS themselves invoke\n+                // TLS, or possibly some destructors for those objects being\n+                // annihilated invoke TLS. Sadly these two operations seemed to\n+                // be intertwined, and miraculously work for now...\n+                self.storage.take();\n \n                 // Destroy remaining boxes. Also may run user dtors.\n                 unsafe { cleanup::annihilate(); }"}, {"sha": "2c2dfd8f689c2915cb59aa0a5a198273f27dd6a3", "filename": "src/libstd/task/local_data_priv.rs", "status": "removed", "additions": 0, "deletions": 322, "changes": 322, "blob_url": "https://github.com/rust-lang/rust/blob/9c33ef5a7c24abe258be5c130dec1c77e72de86b/src%2Flibstd%2Ftask%2Flocal_data_priv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c33ef5a7c24abe258be5c130dec1c77e72de86b/src%2Flibstd%2Ftask%2Flocal_data_priv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Flocal_data_priv.rs?ref=9c33ef5a7c24abe258be5c130dec1c77e72de86b", "patch": "@@ -1,322 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#[allow(missing_doc)];\n-\n-use cast;\n-use libc;\n-use local_data;\n-use prelude::*;\n-use ptr;\n-use unstable::raw;\n-use util;\n-\n-use rt::task::{Task, LocalStorage};\n-\n-pub enum Handle {\n-    NewHandle(*mut LocalStorage)\n-}\n-\n-impl Handle {\n-    pub fn new() -> Handle {\n-        use rt::local::Local;\n-        unsafe {\n-            let task: *mut Task = Local::unsafe_borrow();\n-            NewHandle(&mut (*task).storage)\n-        }\n-    }\n-}\n-\n-#[deriving(Eq)]\n-enum LoanState {\n-    NoLoan, ImmLoan, MutLoan\n-}\n-\n-impl LoanState {\n-    fn describe(&self) -> &'static str {\n-        match *self {\n-            NoLoan => \"no loan\",\n-            ImmLoan => \"immutable\",\n-            MutLoan => \"mutable\"\n-        }\n-    }\n-}\n-\n-trait LocalData {}\n-impl<T: 'static> LocalData for T {}\n-\n-// The task-local-map stores all TLS information for the currently running task.\n-// It is stored as an owned pointer into the runtime, and it's only allocated\n-// when TLS is used for the first time. This map must be very carefully\n-// constructed because it has many mutable loans unsoundly handed out on it to\n-// the various invocations of TLS requests.\n-//\n-// One of the most important operations is loaning a value via `get` to a\n-// caller. In doing so, the slot that the TLS entry is occupying cannot be\n-// invalidated because upon returning it's loan state must be updated. Currently\n-// the TLS map is a vector, but this is possibly dangerous because the vector\n-// can be reallocated/moved when new values are pushed onto it.\n-//\n-// This problem currently isn't solved in a very elegant way. Inside the `get`\n-// function, it internally \"invalidates\" all references after the loan is\n-// finished and looks up into the vector again. In theory this will prevent\n-// pointers from being moved under our feet so long as LLVM doesn't go too crazy\n-// with the optimizations.\n-//\n-// n.b. Other structures are not sufficient right now:\n-//          * HashMap uses ~[T] internally (push reallocates/moves)\n-//          * TreeMap is plausible, but it's in extra\n-//          * dlist plausible, but not in std\n-//          * a custom owned linked list was attempted, but difficult to write\n-//            and involved a lot of extra code bloat\n-//\n-// n.b. Has to be stored with a pointer at outermost layer; the foreign call\n-//      returns void *.\n-//\n-// n.b. If TLS is used heavily in future, this could be made more efficient with\n-//      a proper map.\n-type TaskLocalMap = ~[Option<(*libc::c_void, TLSValue, LoanState)>];\n-type TLSValue = ~LocalData:;\n-\n-fn cleanup_task_local_map(map_ptr: *libc::c_void) {\n-    unsafe {\n-        assert!(!map_ptr.is_null());\n-        // Get and keep the single reference that was created at the\n-        // beginning.\n-        let _map: TaskLocalMap = cast::transmute(map_ptr);\n-        // All local_data will be destroyed along with the map.\n-    }\n-}\n-\n-// Gets the map from the runtime. Lazily initialises if not done so already.\n-unsafe fn get_local_map(handle: Handle) -> &mut TaskLocalMap {\n-\n-    unsafe fn newsched_map(local: *mut LocalStorage) -> &mut TaskLocalMap {\n-        // This is based on the same idea as the oldsched code above.\n-        match &mut *local {\n-            // If the at_exit function is already set, then we just need to take\n-            // a loan out on the TLS map stored inside\n-            &LocalStorage(ref mut map_ptr, Some(_)) => {\n-                assert!(map_ptr.is_not_null());\n-                return cast::transmute(map_ptr);\n-            }\n-            // If this is the first time we've accessed TLS, perform similar\n-            // actions to the oldsched way of doing things.\n-            &LocalStorage(ref mut map_ptr, ref mut at_exit) => {\n-                assert!(map_ptr.is_null());\n-                assert!(at_exit.is_none());\n-                let map: TaskLocalMap = ~[];\n-                *map_ptr = cast::transmute(map);\n-                *at_exit = Some(cleanup_task_local_map);\n-                return cast::transmute(map_ptr);\n-            }\n-        }\n-    }\n-\n-    match handle {\n-        NewHandle(local_storage) => newsched_map(local_storage)\n-    }\n-}\n-\n-unsafe fn key_to_key_value<T: 'static>(key: local_data::Key<T>) -> *libc::c_void {\n-    let pair: raw::Closure = cast::transmute_copy(&key);\n-    return pair.code as *libc::c_void;\n-}\n-\n-pub unsafe fn local_pop<T: 'static>(handle: Handle,\n-                                    key: local_data::Key<T>) -> Option<T> {\n-    let map = get_local_map(handle);\n-    let key_value = key_to_key_value(key);\n-\n-    for entry in map.mut_iter() {\n-        match *entry {\n-            Some((k, _, loan)) if k == key_value => {\n-                if loan != NoLoan {\n-                    fail!(\"TLS value cannot be removed because it is already \\\n-                          borrowed as %s\", loan.describe());\n-                }\n-                // Move the data out of the `entry` slot via util::replace. This\n-                // is guaranteed to succeed because we already matched on `Some`\n-                // above.\n-                let data = match util::replace(entry, None) {\n-                    Some((_, data, _)) => data,\n-                    None => abort(),\n-                };\n-\n-                // Move `data` into transmute to get out the memory that it\n-                // owns, we must free it manually later.\n-                let (_vtable, box): (uint, ~~T) = cast::transmute(data);\n-\n-                // Read the box's value (using the compiler's built-in\n-                // auto-deref functionality to obtain a pointer to the base)\n-                let ret = ptr::read_ptr(cast::transmute::<&T, *mut T>(*box));\n-\n-                // Finally free the allocated memory. we don't want this to\n-                // actually touch the memory inside because it's all duplicated\n-                // now, so the box is transmuted to a 0-sized type. We also use\n-                // a type which references `T` because currently the layout\n-                // could depend on whether T contains managed pointers or not.\n-                let _: ~~[T, ..0] = cast::transmute(box);\n-\n-                // Everything is now deallocated, and we own the value that was\n-                // located inside TLS, so we now return it.\n-                return Some(ret);\n-            }\n-            _ => {}\n-        }\n-    }\n-    return None;\n-}\n-\n-pub unsafe fn local_get<T: 'static, U>(handle: Handle,\n-                                       key: local_data::Key<T>,\n-                                       f: &fn(Option<&T>) -> U) -> U {\n-    local_get_with(handle, key, ImmLoan, f)\n-}\n-\n-pub unsafe fn local_get_mut<T: 'static, U>(handle: Handle,\n-                                           key: local_data::Key<T>,\n-                                           f: &fn(Option<&mut T>) -> U) -> U {\n-    do local_get_with(handle, key, MutLoan) |x| {\n-        match x {\n-            None => f(None),\n-            // We're violating a lot of compiler guarantees with this\n-            // invocation of `transmute_mut`, but we're doing runtime checks to\n-            // ensure that it's always valid (only one at a time).\n-            //\n-            // there is no need to be upset!\n-            Some(x) => { f(Some(cast::transmute_mut(x))) }\n-        }\n-    }\n-}\n-\n-unsafe fn local_get_with<T: 'static, U>(handle: Handle,\n-                                        key: local_data::Key<T>,\n-                                        state: LoanState,\n-                                        f: &fn(Option<&T>) -> U) -> U {\n-    // This function must be extremely careful. Because TLS can store owned\n-    // values, and we must have some form of `get` function other than `pop`,\n-    // this function has to give a `&` reference back to the caller.\n-    //\n-    // One option is to return the reference, but this cannot be sound because\n-    // the actual lifetime of the object is not known. The slot in TLS could not\n-    // be modified until the object goes out of scope, but the TLS code cannot\n-    // know when this happens.\n-    //\n-    // For this reason, the reference is yielded to a specified closure. This\n-    // way the TLS code knows exactly what the lifetime of the yielded pointer\n-    // is, allowing callers to acquire references to owned data. This is also\n-    // sound so long as measures are taken to ensure that while a TLS slot is\n-    // loaned out to a caller, it's not modified recursively.\n-    let map = get_local_map(handle);\n-    let key_value = key_to_key_value(key);\n-\n-    let pos = map.iter().position(|entry| {\n-        match *entry {\n-            Some((k, _, _)) if k == key_value => true, _ => false\n-        }\n-    });\n-    match pos {\n-        None => { return f(None); }\n-        Some(i) => {\n-            let ret;\n-            let mut return_loan = false;\n-            match map[i] {\n-                Some((_, ref data, ref mut loan)) => {\n-                    match (state, *loan) {\n-                        (_, NoLoan) => {\n-                            *loan = state;\n-                            return_loan = true;\n-                        }\n-                        (ImmLoan, ImmLoan) => {}\n-                        (want, cur) => {\n-                            fail!(\"TLS slot cannot be borrowed as %s because \\\n-                                   it is already borrowed as %s\",\n-                                  want.describe(), cur.describe());\n-                        }\n-                    }\n-                    // data was created with `~~T as ~LocalData`, so we extract\n-                    // pointer part of the trait, (as ~~T), and then use\n-                    // compiler coercions to achieve a '&' pointer.\n-                    match *cast::transmute::<&TLSValue, &(uint, ~~T)>(data) {\n-                        (_vtable, ref box) => {\n-                            let value: &T = **box;\n-                            ret = f(Some(value));\n-                        }\n-                    }\n-                }\n-                _ => abort()\n-            }\n-\n-            // n.b. 'data' and 'loans' are both invalid pointers at the point\n-            // 'f' returned because `f` could have appended more TLS items which\n-            // in turn relocated the vector. Hence we do another lookup here to\n-            // fixup the loans.\n-            if return_loan {\n-                match map[i] {\n-                    Some((_, _, ref mut loan)) => { *loan = NoLoan; }\n-                    None => { abort(); }\n-                }\n-            }\n-            return ret;\n-        }\n-    }\n-}\n-\n-fn abort() -> ! {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    unsafe { libc::abort() }\n-}\n-\n-pub unsafe fn local_set<T: 'static>(handle: Handle,\n-                                    key: local_data::Key<T>,\n-                                    data: T) {\n-    let map = get_local_map(handle);\n-    let keyval = key_to_key_value(key);\n-\n-    // When the task-local map is destroyed, all the data needs to be cleaned\n-    // up. For this reason we can't do some clever tricks to store '~T' as a\n-    // '*c_void' or something like that. To solve the problem, we cast\n-    // everything to a trait (LocalData) which is then stored inside the map.\n-    // Upon destruction of the map, all the objects will be destroyed and the\n-    // traits have enough information about them to destroy themselves.\n-    //\n-    // FIXME(#7673): This should be \"~data as ~LocalData\" (without the colon at\n-    //               the end, and only one sigil)\n-    let data = ~~data as ~LocalData:;\n-\n-    fn insertion_position(map: &mut TaskLocalMap,\n-                          key: *libc::c_void) -> Option<uint> {\n-        // First see if the map contains this key already\n-        let curspot = map.iter().position(|entry| {\n-            match *entry {\n-                Some((ekey, _, loan)) if key == ekey => {\n-                    if loan != NoLoan {\n-                        fail!(\"TLS value cannot be overwritten because it is\n-                               already borrowed as %s\", loan.describe())\n-                    }\n-                    true\n-                }\n-                _ => false,\n-            }\n-        });\n-        // If it doesn't contain the key, just find a slot that's None\n-        match curspot {\n-            Some(i) => Some(i),\n-            None => map.iter().position(|entry| entry.is_none())\n-        }\n-    }\n-\n-    match insertion_position(map, keyval) {\n-        Some(i) => { map[i] = Some((keyval, data, NoLoan)); }\n-        None => { map.push(Some((keyval, data, NoLoan))); }\n-    }\n-}"}, {"sha": "b52dd3a906bd687811f8a829f8386d26d5dda037", "filename": "src/libstd/task/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/da96b3ec6a88a3f88627a001fb3be7620621a3d2/src%2Flibstd%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da96b3ec6a88a3f88627a001fb3be7620621a3d2/src%2Flibstd%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fmod.rs?ref=da96b3ec6a88a3f88627a001fb3be7620621a3d2", "patch": "@@ -52,7 +52,6 @@ use util;\n #[cfg(test)] use ptr;\n #[cfg(test)] use task;\n \n-mod local_data_priv;\n pub mod spawn;\n \n /**"}]}