{"sha": "d21e4d8411aef3baa776685b7b51e20cc75c7329", "node_id": "C_kwDOAAsO6NoAKGQyMWU0ZDg0MTFhZWYzYmFhNzc2Njg1YjdiNTFlMjBjYzc1YzczMjk", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-02-24T02:35:15Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-03-10T23:49:42Z"}, "message": "Actually cache goals", "tree": {"sha": "f131b72d2d60c1c0e8348b0e37f6531a611685d0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f131b72d2d60c1c0e8348b0e37f6531a611685d0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d21e4d8411aef3baa776685b7b51e20cc75c7329", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d21e4d8411aef3baa776685b7b51e20cc75c7329", "html_url": "https://github.com/rust-lang/rust/commit/d21e4d8411aef3baa776685b7b51e20cc75c7329", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d21e4d8411aef3baa776685b7b51e20cc75c7329/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "67698aa6adafadfc36667cdb06ac8bfcffe71f90", "url": "https://api.github.com/repos/rust-lang/rust/commits/67698aa6adafadfc36667cdb06ac8bfcffe71f90", "html_url": "https://github.com/rust-lang/rust/commit/67698aa6adafadfc36667cdb06ac8bfcffe71f90"}], "stats": {"total": 135, "additions": 65, "deletions": 70}, "files": [{"sha": "e95f6f91357ef18a74ed44b6866ba8e7c412c5c2", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d21e4d8411aef3baa776685b7b51e20cc75c7329/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d21e4d8411aef3baa776685b7b51e20cc75c7329/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=d21e4d8411aef3baa776685b7b51e20cc75c7329", "patch": "@@ -17,6 +17,7 @@ use crate::mir::{\n };\n use crate::thir::Thir;\n use crate::traits;\n+use crate::traits::solve;\n use crate::traits::solve::{ExternalConstraints, ExternalConstraintsData};\n use crate::ty::query::{self, TyCtxtAt};\n use crate::ty::{\n@@ -537,6 +538,9 @@ pub struct GlobalCtxt<'tcx> {\n     /// Merge this with `selection_cache`?\n     pub evaluation_cache: traits::EvaluationCache<'tcx>,\n \n+    /// Caches the results of goal evaluation in the new solver.\n+    pub new_solver_evaluation_cache: solve::EvaluationCache<'tcx>,\n+\n     /// Data layout specification for the current target.\n     pub data_layout: TargetDataLayout,\n \n@@ -712,6 +716,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             pred_rcache: Default::default(),\n             selection_cache: Default::default(),\n             evaluation_cache: Default::default(),\n+            new_solver_evaluation_cache: Default::default(),\n             data_layout,\n             alloc_map: Lock::new(interpret::AllocMap::new()),\n         }"}, {"sha": "d1b4fa554c5f2f5e1e3a73009d9be82cdade3cc4", "filename": "compiler/rustc_trait_selection/src/solve/search_graph/cache.rs", "status": "modified", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/d21e4d8411aef3baa776685b7b51e20cc75c7329/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d21e4d8411aef3baa776685b7b51e20cc75c7329/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fcache.rs?ref=d21e4d8411aef3baa776685b7b51e20cc75c7329", "patch": "@@ -8,12 +8,10 @@\n //!\n //! FIXME(@lcnr): Write that section, feel free to ping me if you need help here\n //! before then or if I still haven't done that before January 2023.\n-use super::overflow::OverflowData;\n use super::StackDepth;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_index::vec::IndexVec;\n use rustc_middle::traits::solve::{CanonicalGoal, QueryResult};\n-use rustc_middle::ty::TyCtxt;\n \n rustc_index::newtype_index! {\n     pub struct EntryIndex {}\n@@ -98,26 +96,3 @@ impl<'tcx> ProvisionalCache<'tcx> {\n         self.entries[entry_index].response\n     }\n }\n-\n-pub(super) fn try_move_finished_goal_to_global_cache<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    overflow_data: &mut OverflowData,\n-    stack: &IndexVec<super::StackDepth, super::StackElem<'tcx>>,\n-    goal: CanonicalGoal<'tcx>,\n-    response: QueryResult<'tcx>,\n-) {\n-    // We move goals to the global cache if we either did not hit an overflow or if it's\n-    // the root goal as that will now always hit the same overflow limit.\n-    //\n-    // NOTE: We cannot move any non-root goals to the global cache even if their final result\n-    // isn't impacted by the overflow as that goal still has unstable query dependencies\n-    // because it didn't go its full depth.\n-    //\n-    // FIXME(@lcnr): We could still cache subtrees which are not impacted by overflow though.\n-    // Tracking that info correctly isn't trivial, so I haven't implemented it for now.\n-    let should_cache_globally = !overflow_data.did_overflow() || stack.is_empty();\n-    if should_cache_globally {\n-        // FIXME: move the provisional entry to the global cache.\n-        let _ = (tcx, goal, response);\n-    }\n-}"}, {"sha": "f1b840aac556abfaf4d2d45278a5f0eb02c4f57d", "filename": "compiler/rustc_trait_selection/src/solve/search_graph/mod.rs", "status": "modified", "additions": 60, "deletions": 45, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/d21e4d8411aef3baa776685b7b51e20cc75c7329/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d21e4d8411aef3baa776685b7b51e20cc75c7329/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fmod.rs?ref=d21e4d8411aef3baa776685b7b51e20cc75c7329", "patch": "@@ -6,6 +6,7 @@ pub(super) use crate::solve::search_graph::overflow::OverflowHandler;\n use cache::ProvisionalCache;\n use overflow::OverflowData;\n use rustc_index::vec::IndexVec;\n+use rustc_middle::dep_graph::DepKind;\n use rustc_middle::traits::solve::{CanonicalGoal, Certainty, MaybeCause, QueryResult};\n use rustc_middle::ty::TyCtxt;\n use std::{collections::hash_map::Entry, mem};\n@@ -139,10 +140,9 @@ impl<'tcx> SearchGraph<'tcx> {\n     /// updated the provisional cache and we have to recompute the current goal.\n     ///\n     /// FIXME: Refer to the rustc-dev-guide entry once it exists.\n-    #[instrument(level = \"debug\", skip(self, tcx, actual_goal), ret)]\n+    #[instrument(level = \"debug\", skip(self, actual_goal), ret)]\n     fn try_finalize_goal(\n         &mut self,\n-        tcx: TyCtxt<'tcx>,\n         actual_goal: CanonicalGoal<'tcx>,\n         response: QueryResult<'tcx>,\n     ) -> bool {\n@@ -176,72 +176,87 @@ impl<'tcx> SearchGraph<'tcx> {\n             self.stack.push(StackElem { goal, has_been_used: false });\n             false\n         } else {\n-            self.try_move_finished_goal_to_global_cache(tcx, stack_elem);\n             true\n         }\n     }\n \n-    fn try_move_finished_goal_to_global_cache(\n+    pub(super) fn with_new_goal(\n         &mut self,\n         tcx: TyCtxt<'tcx>,\n-        stack_elem: StackElem<'tcx>,\n-    ) {\n-        let StackElem { goal, .. } = stack_elem;\n+        canonical_goal: CanonicalGoal<'tcx>,\n+        mut loop_body: impl FnMut(&mut Self) -> QueryResult<'tcx>,\n+    ) -> QueryResult<'tcx> {\n+        if let Some(result) = tcx.new_solver_evaluation_cache.get(&canonical_goal, tcx) {\n+            return result;\n+        }\n+\n+        match self.try_push_stack(tcx, canonical_goal) {\n+            Ok(()) => {}\n+            // Our goal is already on the stack, eager return.\n+            Err(response) => return response,\n+        }\n+\n+        // This is for global caching, so we properly track query dependencies.\n+        // Everything that affects the `Result` should be performed within this\n+        // `with_anon_task` closure.\n+        let (result, dep_node) = tcx.dep_graph.with_anon_task(tcx, DepKind::TraitSelect, || {\n+            self.repeat_while_none(\n+                |this| {\n+                    let result = this.deal_with_overflow(tcx, canonical_goal);\n+                    let _ = this.stack.pop().unwrap();\n+                    result\n+                },\n+                |this| {\n+                    let result = loop_body(this);\n+                    this.try_finalize_goal(canonical_goal, result).then(|| result)\n+                },\n+            )\n+        });\n+\n         let cache = &mut self.provisional_cache;\n-        let provisional_entry_index = *cache.lookup_table.get(&goal).unwrap();\n+        let provisional_entry_index = *cache.lookup_table.get(&canonical_goal).unwrap();\n         let provisional_entry = &mut cache.entries[provisional_entry_index];\n         let depth = provisional_entry.depth;\n \n         // If not, we're done with this goal.\n         //\n         // Check whether that this goal doesn't depend on a goal deeper on the stack\n-        // and if so, move it and all nested goals to the global cache.\n+        // and if so, move it to the global cache.\n         //\n         // Note that if any nested goal were to depend on something deeper on the stack,\n         // this would have also updated the depth of the current goal.\n         if depth == self.stack.next_index() {\n-            for (i, entry) in cache.entries.drain_enumerated(provisional_entry_index.index()..) {\n+            // If the current goal is the head of a cycle, we drop all other\n+            // cycle participants without moving them to the global cache.\n+            let other_cycle_participants = provisional_entry_index.index() + 1;\n+            for (i, entry) in cache.entries.drain_enumerated(other_cycle_participants..) {\n                 let actual_index = cache.lookup_table.remove(&entry.goal);\n                 debug_assert_eq!(Some(i), actual_index);\n                 debug_assert!(entry.depth == depth);\n-                cache::try_move_finished_goal_to_global_cache(\n-                    tcx,\n-                    &mut self.overflow_data,\n-                    &self.stack,\n-                    entry.goal,\n-                    entry.response,\n-                );\n             }\n-        }\n-    }\n \n-    pub(super) fn with_new_goal(\n-        &mut self,\n-        tcx: TyCtxt<'tcx>,\n-        canonical_goal: CanonicalGoal<'tcx>,\n-        mut loop_body: impl FnMut(&mut Self) -> QueryResult<'tcx>,\n-    ) -> QueryResult<'tcx> {\n-        match self.try_push_stack(tcx, canonical_goal) {\n-            Ok(()) => {}\n-            // Our goal is already on the stack, eager return.\n-            Err(response) => return response,\n+            let current_goal = cache.entries.pop().unwrap();\n+            let actual_index = cache.lookup_table.remove(&current_goal.goal);\n+            debug_assert_eq!(Some(provisional_entry_index), actual_index);\n+            debug_assert!(current_goal.depth == depth);\n+\n+            // We move the root goal to the global cache if we either did not hit an overflow or if it's\n+            // the root goal as that will now always hit the same overflow limit.\n+            //\n+            // NOTE: We cannot move any non-root goals to the global cache. When replaying the root goal's\n+            // dependencies, our non-root goal may no longer appear as child of the root goal.\n+            //\n+            // See https://github.com/rust-lang/rust/pull/108071 for some additional context.\n+            let should_cache_globally = !self.overflow_data.did_overflow() || self.stack.is_empty();\n+            if should_cache_globally {\n+                tcx.new_solver_evaluation_cache.insert(\n+                    current_goal.goal,\n+                    dep_node,\n+                    current_goal.response,\n+                );\n+            }\n         }\n \n-        self.repeat_while_none(\n-            |this| {\n-                let result = this.deal_with_overflow(tcx, canonical_goal);\n-                let stack_elem = this.stack.pop().unwrap();\n-                this.try_move_finished_goal_to_global_cache(tcx, stack_elem);\n-                result\n-            },\n-            |this| {\n-                let result = loop_body(this);\n-                if this.try_finalize_goal(tcx, canonical_goal, result) {\n-                    Some(result)\n-                } else {\n-                    None\n-                }\n-            },\n-        )\n+        result\n     }\n }"}]}