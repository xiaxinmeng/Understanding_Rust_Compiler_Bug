{"sha": "3ce31eb99076261291c1a0ae4b542f52e6ca0f0a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNjZTMxZWI5OTA3NjI2MTI5MWMxYTBhZTRiNTQyZjUyZTZjYTBmMGE=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-08-05T09:27:28Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-09-11T05:41:15Z"}, "message": "rustc: replace usize with u64 and ConstUsize.", "tree": {"sha": "bc809754d7052e60bbc8c4d08377fa41d2998450", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bc809754d7052e60bbc8c4d08377fa41d2998450"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3ce31eb99076261291c1a0ae4b542f52e6ca0f0a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3ce31eb99076261291c1a0ae4b542f52e6ca0f0a", "html_url": "https://github.com/rust-lang/rust/commit/3ce31eb99076261291c1a0ae4b542f52e6ca0f0a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3ce31eb99076261291c1a0ae4b542f52e6ca0f0a/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "932289c12d26803daf6b1990cb56bb974979bf9c", "url": "https://api.github.com/repos/rust-lang/rust/commits/932289c12d26803daf6b1990cb56bb974979bf9c", "html_url": "https://github.com/rust-lang/rust/commit/932289c12d26803daf6b1990cb56bb974979bf9c"}], "stats": {"total": 539, "additions": 265, "deletions": 274}, "files": [{"sha": "d213bc1de20a561af2d084544428bffacafd1355", "filename": "src/librustc/middle/const_val.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3ce31eb99076261291c1a0ae4b542f52e6ca0f0a/src%2Flibrustc%2Fmiddle%2Fconst_val.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce31eb99076261291c1a0ae4b542f52e6ca0f0a/src%2Flibrustc%2Fmiddle%2Fconst_val.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_val.rs?ref=3ce31eb99076261291c1a0ae4b542f52e6ca0f0a", "patch": "@@ -250,20 +250,15 @@ impl<'a, 'gcx, 'tcx> ConstEvalErr<'tcx> {\n pub fn eval_length(tcx: TyCtxt,\n                    count: hir::BodyId,\n                    reason: &str)\n-                   -> Result<usize, ErrorReported>\n+                   -> Result<ConstUsize, ErrorReported>\n {\n     let count_expr = &tcx.hir.body(count).value;\n     let count_def_id = tcx.hir.body_owner_def_id(count);\n     let param_env = ty::ParamEnv::empty(Reveal::UserFacing);\n     let substs = Substs::identity_for_item(tcx.global_tcx(), count_def_id);\n     match tcx.at(count_expr.span).const_eval(param_env.and((count_def_id, substs))) {\n-        Ok(&ty::Const { val: Integral(Usize(count)), .. }) => {\n-            let val = count.as_u64(tcx.sess.target.uint_type);\n-            assert_eq!(val as usize as u64, val);\n-            Ok(val as usize)\n-        },\n-        Ok(_) |\n-        Err(ConstEvalErr { kind: ErrKind::TypeckError, .. }) => Err(ErrorReported),\n+        Ok(&ty::Const { val: Integral(Usize(count)), .. }) => Ok(count),\n+        Ok(_) | Err(ConstEvalErr { kind: ErrKind::TypeckError, .. }) => Err(ErrorReported),\n         Err(err) => {\n             let mut diag = err.struct_error(tcx, count_expr.span, reason);\n "}, {"sha": "1a4d0dcd929c31ec7024df95b7ddd3715b6ecd44", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ce31eb99076261291c1a0ae4b542f52e6ca0f0a/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce31eb99076261291c1a0ae4b542f52e6ca0f0a/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=3ce31eb99076261291c1a0ae4b542f52e6ca0f0a", "patch": "@@ -876,7 +876,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n \n         // Always promote `[T; 0]` (even when e.g. borrowed mutably).\n         let promotable = match expr_ty.sty {\n-            ty::TyArray(_, 0) => true,\n+            ty::TyArray(_, len) if len.as_u64() == 0 => true,\n             _ => promotable,\n         };\n "}, {"sha": "7469402daf90f334aa63d324aab1ad7b6b5e025d", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3ce31eb99076261291c1a0ae4b542f52e6ca0f0a/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce31eb99076261291c1a0ae4b542f52e6ca0f0a/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=3ce31eb99076261291c1a0ae4b542f52e6ca0f0a", "patch": "@@ -70,7 +70,8 @@ impl<'a, 'gcx, 'tcx> LvalueTy<'tcx> {\n                 LvalueTy::Ty {\n                     ty: match ty.sty {\n                         ty::TyArray(inner, size) => {\n-                            tcx.mk_array(inner, size-(from as usize)-(to as usize))\n+                            let len = size.as_u64() - (from as u64) - (to as u64);\n+                            tcx.mk_array(inner, len)\n                         }\n                         ty::TySlice(..) => ty,\n                         _ => {\n@@ -146,11 +147,8 @@ impl<'tcx> Rvalue<'tcx> {\n     {\n         match *self {\n             Rvalue::Use(ref operand) => operand.ty(local_decls, tcx),\n-            Rvalue::Repeat(ref operand, ref count) => {\n-                let op_ty = operand.ty(local_decls, tcx);\n-                let count = count.as_u64(tcx.sess.target.uint_type);\n-                assert_eq!(count as usize as u64, count);\n-                tcx.mk_array(op_ty, count as usize)\n+            Rvalue::Repeat(ref operand, count) => {\n+                tcx.mk_array(operand.ty(local_decls, tcx), count.as_u64())\n             }\n             Rvalue::Ref(reg, bk, ref lv) => {\n                 let lv_ty = lv.ty(local_decls, tcx).to_ty(tcx);\n@@ -193,7 +191,7 @@ impl<'tcx> Rvalue<'tcx> {\n             Rvalue::Aggregate(ref ak, ref ops) => {\n                 match **ak {\n                     AggregateKind::Array(ty) => {\n-                        tcx.mk_array(ty, ops.len())\n+                        tcx.mk_array(ty, ops.len() as u64)\n                     }\n                     AggregateKind::Tuple => {\n                         tcx.mk_tup("}, {"sha": "b7e07f94f3df14b3ca57ae850146322da403ba97", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3ce31eb99076261291c1a0ae4b542f52e6ca0f0a/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce31eb99076261291c1a0ae4b542f52e6ca0f0a/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=3ce31eb99076261291c1a0ae4b542f52e6ca0f0a", "patch": "@@ -48,8 +48,8 @@ use std::path::PathBuf;\n \n pub struct Config {\n     pub target: Target,\n-    pub int_type: IntTy,\n-    pub uint_type: UintTy,\n+    pub isize_ty: IntTy,\n+    pub usize_ty: UintTy,\n }\n \n #[derive(Clone, Hash, Debug)]\n@@ -1149,7 +1149,7 @@ pub fn build_target_config(opts: &Options, sp: &Handler) -> Config {\n         }\n     };\n \n-    let (int_type, uint_type) = match &target.target_pointer_width[..] {\n+    let (isize_ty, usize_ty) = match &target.target_pointer_width[..] {\n         \"16\" => (ast::IntTy::I16, ast::UintTy::U16),\n         \"32\" => (ast::IntTy::I32, ast::UintTy::U32),\n         \"64\" => (ast::IntTy::I64, ast::UintTy::U64),\n@@ -1159,8 +1159,8 @@ pub fn build_target_config(opts: &Options, sp: &Handler) -> Config {\n \n     Config {\n         target,\n-        int_type,\n-        uint_type,\n+        isize_ty,\n+        usize_ty,\n     }\n }\n "}, {"sha": "7a671b5ebc6e077f152724b8645b05734d3d968e", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3ce31eb99076261291c1a0ae4b542f52e6ca0f0a/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce31eb99076261291c1a0ae4b542f52e6ca0f0a/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=3ce31eb99076261291c1a0ae4b542f52e6ca0f0a", "patch": "@@ -49,6 +49,7 @@ use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n                                            StableHasherResult};\n \n use arena::{TypedArena, DroplessArena};\n+use rustc_const_math::ConstUsize;\n use rustc_data_structures::indexed_vec::IndexVec;\n use std::borrow::Borrow;\n use std::cell::{Cell, RefCell};\n@@ -1754,7 +1755,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.mk_imm_ptr(self.mk_nil())\n     }\n \n-    pub fn mk_array(self, ty: Ty<'tcx>, n: usize) -> Ty<'tcx> {\n+    pub fn mk_array(self, ty: Ty<'tcx>, n: u64) -> Ty<'tcx> {\n+        let n = ConstUsize::new(n, self.sess.target.usize_ty).unwrap();\n         self.mk_ty(TyArray(ty, n))\n     }\n "}, {"sha": "3234a9de8c7917d45a785b222591fc3508eca651", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3ce31eb99076261291c1a0ae4b542f52e6ca0f0a/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce31eb99076261291c1a0ae4b542f52e6ca0f0a/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=3ce31eb99076261291c1a0ae4b542f52e6ca0f0a", "patch": "@@ -18,6 +18,8 @@ use syntax::ast;\n use errors::DiagnosticBuilder;\n use syntax_pos::Span;\n \n+use rustc_const_math::ConstUsize;\n+\n use hir;\n \n #[derive(Clone, Copy, Debug)]\n@@ -34,7 +36,7 @@ pub enum TypeError<'tcx> {\n     AbiMismatch(ExpectedFound<abi::Abi>),\n     Mutability,\n     TupleSize(ExpectedFound<usize>),\n-    FixedArraySize(ExpectedFound<usize>),\n+    FixedArraySize(ExpectedFound<ConstUsize>),\n     ArgCount,\n \n     RegionsDoesNotOutlive(Region<'tcx>, Region<'tcx>),"}, {"sha": "bb8ef28bbf5935af93cf38a01feae982a9e16a56", "filename": "src/librustc/ty/inhabitedness/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ce31eb99076261291c1a0ae4b542f52e6ca0f0a/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce31eb99076261291c1a0ae4b542f52e6ca0f0a/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs?ref=3ce31eb99076261291c1a0ae4b542f52e6ca0f0a", "patch": "@@ -205,7 +205,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n                 }))\n             },\n             TyArray(ty, len) => {\n-                if len == 0 {\n+                if len.as_u64() == 0 {\n                     DefIdForest::empty()\n                 } else {\n                     ty.uninhabited_from(visited, tcx)"}, {"sha": "4d94021d2c8c5d02eb54724ca6938548bfb371be", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3ce31eb99076261291c1a0ae4b542f52e6ca0f0a/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce31eb99076261291c1a0ae4b542f52e6ca0f0a/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=3ce31eb99076261291c1a0ae4b542f52e6ca0f0a", "patch": "@@ -837,7 +837,7 @@ impl<'a, 'tcx> Struct {\n \n             // Is this a fixed-size array of something non-zero\n             // with at least one element?\n-            (_, &ty::TyArray(ety, d)) if d > 0 => {\n+            (_, &ty::TyArray(ety, d)) if d.as_u64() > 0 => {\n                 Struct::non_zero_field_paths(\n                     tcx,\n                     param_env,\n@@ -1177,9 +1177,7 @@ impl<'a, 'tcx> Layout {\n             ty::TyArray(element, count) => {\n                 let element = element.layout(tcx, param_env)?;\n                 let element_size = element.size(dl);\n-                // FIXME(eddyb) Don't use host `usize` for array lengths.\n-                let usize_count: usize = count;\n-                let count = usize_count as u64;\n+                let count = count.as_u64();\n                 if element_size.checked_mul(count, dl).is_none() {\n                     return Err(LayoutError::SizeOverflow(ty));\n                 }"}, {"sha": "6634af59e787ee187ad09a8b41d993337bd020b2", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3ce31eb99076261291c1a0ae4b542f52e6ca0f0a/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce31eb99076261291c1a0ae4b542f52e6ca0f0a/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=3ce31eb99076261291c1a0ae4b542f52e6ca0f0a", "patch": "@@ -1665,11 +1665,11 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n         match repr_type {\n             attr::UnsignedInt(ty) => {\n                 ConstInt::new_unsigned_truncating(discr, ty,\n-                                                  tcx.sess.target.uint_type)\n+                                                  tcx.sess.target.usize_ty)\n             }\n             attr::SignedInt(ty) => {\n                 ConstInt::new_signed_truncating(discr as i128, ty,\n-                                                tcx.sess.target.int_type)\n+                                                tcx.sess.target.isize_ty)\n             }\n         }\n     }"}, {"sha": "0acb8a2c1d15931a545bc62fc668b911dbdd0c9c", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ce31eb99076261291c1a0ae4b542f52e6ca0f0a/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce31eb99076261291c1a0ae4b542f52e6ca0f0a/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=3ce31eb99076261291c1a0ae4b542f52e6ca0f0a", "patch": "@@ -429,7 +429,7 @@ pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n         {\n             let t = relation.relate(&a_t, &b_t)?;\n             if sz_a == sz_b {\n-                Ok(tcx.mk_array(t, sz_a))\n+                Ok(tcx.mk_array(t, sz_a.as_u64()))\n             } else {\n                 Err(TypeError::FixedArraySize(expected_found(relation, &sz_a, &sz_b)))\n             }"}, {"sha": "e01f9f24235c5f7d09f92bf9dbc131f2bc18ee2f", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3ce31eb99076261291c1a0ae4b542f52e6ca0f0a/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce31eb99076261291c1a0ae4b542f52e6ca0f0a/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=3ce31eb99076261291c1a0ae4b542f52e6ca0f0a", "patch": "@@ -27,6 +27,8 @@ use syntax::ast::{self, Name};\n use syntax::symbol::keywords;\n use util::nodemap::FxHashMap;\n \n+use rustc_const_math::ConstUsize;\n+\n use serialize;\n \n use hir;\n@@ -110,7 +112,7 @@ pub enum TypeVariants<'tcx> {\n     TyStr,\n \n     /// An array with the given length. Written as `[T; n]`.\n-    TyArray(Ty<'tcx>, usize),\n+    TyArray(Ty<'tcx>, ConstUsize),\n \n     /// The pointee of an array slice.  Written as `[T]`.\n     TySlice(Ty<'tcx>),"}, {"sha": "de4481116d6e19b15d4cd75703fcb9d3a39d0835", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3ce31eb99076261291c1a0ae4b542f52e6ca0f0a/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce31eb99076261291c1a0ae4b542f52e6ca0f0a/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=3ce31eb99076261291c1a0ae4b542f52e6ca0f0a", "patch": "@@ -53,7 +53,7 @@ macro_rules! typed_literal {\n             SignedInt(ast::IntTy::I32)   => ConstInt::I32($lit),\n             SignedInt(ast::IntTy::I64)   => ConstInt::I64($lit),\n             SignedInt(ast::IntTy::I128)   => ConstInt::I128($lit),\n-            SignedInt(ast::IntTy::Is) => match $tcx.sess.target.int_type {\n+            SignedInt(ast::IntTy::Is) => match $tcx.sess.target.isize_ty {\n                 ast::IntTy::I16 => ConstInt::Isize(ConstIsize::Is16($lit)),\n                 ast::IntTy::I32 => ConstInt::Isize(ConstIsize::Is32($lit)),\n                 ast::IntTy::I64 => ConstInt::Isize(ConstIsize::Is64($lit)),\n@@ -64,7 +64,7 @@ macro_rules! typed_literal {\n             UnsignedInt(ast::UintTy::U32) => ConstInt::U32($lit),\n             UnsignedInt(ast::UintTy::U64) => ConstInt::U64($lit),\n             UnsignedInt(ast::UintTy::U128) => ConstInt::U128($lit),\n-            UnsignedInt(ast::UintTy::Us) => match $tcx.sess.target.uint_type {\n+            UnsignedInt(ast::UintTy::Us) => match $tcx.sess.target.usize_ty {\n                 ast::UintTy::U16 => ConstInt::Usize(ConstUsize::Us16($lit)),\n                 ast::UintTy::U32 => ConstInt::Usize(ConstUsize::Us32($lit)),\n                 ast::UintTy::U64 => ConstInt::Usize(ConstUsize::Us64($lit)),\n@@ -638,7 +638,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn const_usize(&self, val: u16) -> ConstInt {\n-        match self.sess.target.uint_type {\n+        match self.sess.target.usize_ty {\n             ast::UintTy::U16 => ConstInt::Usize(ConstUsize::Us16(val as u16)),\n             ast::UintTy::U32 => ConstInt::Usize(ConstUsize::Us32(val as u32)),\n             ast::UintTy::U64 => ConstInt::Usize(ConstUsize::Us64(val as u64)),"}, {"sha": "429332873c05b02efb87044d474e859713ee45ce", "filename": "src/librustc_const_eval/_match.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/3ce31eb99076261291c1a0ae4b542f52e6ca0f0a/src%2Flibrustc_const_eval%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce31eb99076261291c1a0ae4b542f52e6ca0f0a/src%2Flibrustc_const_eval%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2F_match.rs?ref=3ce31eb99076261291c1a0ae4b542f52e6ca0f0a", "patch": "@@ -235,7 +235,7 @@ pub enum Constructor<'tcx> {\n     /// Ranges of literal values (`2...5` and `2..5`).\n     ConstantRange(&'tcx ty::Const<'tcx>, &'tcx ty::Const<'tcx>, RangeEnd),\n     /// Array patterns of length n.\n-    Slice(usize),\n+    Slice(u64),\n }\n \n impl<'tcx> Constructor<'tcx> {\n@@ -276,7 +276,7 @@ pub enum WitnessPreference {\n #[derive(Copy, Clone, Debug)]\n struct PatternContext<'tcx> {\n     ty: Ty<'tcx>,\n-    max_slice_length: usize,\n+    max_slice_length: u64,\n }\n \n /// A stack of patterns in reverse order of construction\n@@ -330,8 +330,8 @@ impl<'tcx> Witness<'tcx> {\n     {\n         let arity = constructor_arity(cx, ctor, ty);\n         let pat = {\n-            let len = self.0.len();\n-            let mut pats = self.0.drain(len-arity..).rev();\n+            let len = self.0.len() as u64;\n+            let mut pats = self.0.drain((len-arity) as usize..).rev();\n \n             match ty.sty {\n                 ty::TyAdt(..) |\n@@ -423,10 +423,10 @@ fn all_constructors<'a, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n             }\n         }\n         ty::TyArray(ref sub_ty, length) => {\n-            if length > 0 && cx.is_uninhabited(sub_ty) {\n+            if length.as_u64() > 0 && cx.is_uninhabited(sub_ty) {\n                 vec![]\n             } else {\n-                vec![Slice(length)]\n+                vec![Slice(length.as_u64())]\n             }\n         }\n         ty::TyAdt(def, substs) if def.is_enum() && def.variants.len() != 1 => {\n@@ -447,7 +447,7 @@ fn all_constructors<'a, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n \n fn max_slice_length<'p, 'a: 'p, 'tcx: 'a, I>(\n     _cx: &mut MatchCheckCtxt<'a, 'tcx>,\n-    patterns: I) -> usize\n+    patterns: I) -> u64\n     where I: Iterator<Item=&'p Pattern<'tcx>>\n {\n     // The exhaustiveness-checking paper does not include any details on\n@@ -521,15 +521,15 @@ fn max_slice_length<'p, 'a: 'p, 'tcx: 'a, I>(\n     for row in patterns {\n         match *row.kind {\n             PatternKind::Constant { value: &ty::Const { val: ConstVal::ByteStr(b), .. } } => {\n-                max_fixed_len = cmp::max(max_fixed_len, b.data.len());\n+                max_fixed_len = cmp::max(max_fixed_len, b.data.len() as u64);\n             }\n             PatternKind::Slice { ref prefix, slice: None, ref suffix } => {\n-                let fixed_len = prefix.len() + suffix.len();\n+                let fixed_len = prefix.len() as u64 + suffix.len() as u64;\n                 max_fixed_len = cmp::max(max_fixed_len, fixed_len);\n             }\n             PatternKind::Slice { ref prefix, slice: Some(_), ref suffix } => {\n-                max_prefix_len = cmp::max(max_prefix_len, prefix.len());\n-                max_suffix_len = cmp::max(max_suffix_len, suffix.len());\n+                max_prefix_len = cmp::max(max_prefix_len, prefix.len() as u64);\n+                max_suffix_len = cmp::max(max_suffix_len, suffix.len() as u64);\n             }\n             _ => {}\n         }\n@@ -729,11 +729,11 @@ fn pat_constructors<'tcx>(_cx: &mut MatchCheckCtxt,\n         PatternKind::Range { lo, hi, end } =>\n             Some(vec![ConstantRange(lo, hi, end)]),\n         PatternKind::Array { .. } => match pcx.ty.sty {\n-            ty::TyArray(_, length) => Some(vec![Slice(length)]),\n+            ty::TyArray(_, length) => Some(vec![Slice(length.as_u64())]),\n             _ => span_bug!(pat.span, \"bad ty {:?} for array pattern\", pcx.ty)\n         },\n         PatternKind::Slice { ref prefix, ref slice, ref suffix } => {\n-            let pat_len = prefix.len() + suffix.len();\n+            let pat_len = prefix.len() as u64 + suffix.len() as u64;\n             if slice.is_some() {\n                 Some((pat_len..pcx.max_slice_length+1).map(Slice).collect())\n             } else {\n@@ -748,18 +748,18 @@ fn pat_constructors<'tcx>(_cx: &mut MatchCheckCtxt,\n ///\n /// For instance, a tuple pattern (_, 42, Some([])) has the arity of 3.\n /// A struct pattern's arity is the number of fields it contains, etc.\n-fn constructor_arity(_cx: &MatchCheckCtxt, ctor: &Constructor, ty: Ty) -> usize {\n+fn constructor_arity(_cx: &MatchCheckCtxt, ctor: &Constructor, ty: Ty) -> u64 {\n     debug!(\"constructor_arity({:?}, {:?})\", ctor, ty);\n     match ty.sty {\n-        ty::TyTuple(ref fs, _) => fs.len(),\n+        ty::TyTuple(ref fs, _) => fs.len() as u64,\n         ty::TySlice(..) | ty::TyArray(..) => match *ctor {\n             Slice(length) => length,\n             ConstantValue(_) => 0,\n             _ => bug!(\"bad slice pattern {:?} {:?}\", ctor, ty)\n         },\n         ty::TyRef(..) => 1,\n         ty::TyAdt(adt, _) => {\n-            adt.variants[ctor.variant_index_for_adt(adt)].fields.len()\n+            adt.variants[ctor.variant_index_for_adt(adt)].fields.len() as u64\n         }\n         _ => 0\n     }\n@@ -777,7 +777,7 @@ fn constructor_sub_pattern_tys<'a, 'tcx: 'a>(cx: &MatchCheckCtxt<'a, 'tcx>,\n     match ty.sty {\n         ty::TyTuple(ref fs, _) => fs.into_iter().map(|t| *t).collect(),\n         ty::TySlice(ty) | ty::TyArray(ty, _) => match *ctor {\n-            Slice(length) => repeat(ty).take(length).collect(),\n+            Slice(length) => (0..length).map(|_| ty).collect(),\n             ConstantValue(_) => vec![],\n             _ => bug!(\"bad slice pattern {:?} {:?}\", ctor, ty)\n         },"}, {"sha": "9dab067f942e826ada0cc52c17105eb8c9287fc6", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/3ce31eb99076261291c1a0ae4b542f52e6ca0f0a/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce31eb99076261291c1a0ae4b542f52e6ca0f0a/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=3ce31eb99076261291c1a0ae4b542f52e6ca0f0a", "patch": "@@ -158,7 +158,7 @@ fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n                 },\n                 (&LitKind::Int(n, _), &ty::TyInt(IntTy::Is)) |\n                 (&LitKind::Int(n, Signed(IntTy::Is)), _) => {\n-                    match tcx.sess.target.int_type {\n+                    match tcx.sess.target.isize_ty {\n                         IntTy::I16 => if n == I16_OVERFLOW {\n                             Some(Isize(Is16(i16::min_value())))\n                         } else {\n@@ -342,12 +342,12 @@ fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n                 \"size_of\" => {\n                     let size = layout_of(substs.type_at(0))?.size(tcx).bytes();\n                     return Ok(mk_const(Integral(Usize(ConstUsize::new(size,\n-                        tcx.sess.target.uint_type).unwrap()))));\n+                        tcx.sess.target.usize_ty).unwrap()))));\n                 }\n                 \"min_align_of\" => {\n                     let align = layout_of(substs.type_at(0))?.align(tcx).abi();\n                     return Ok(mk_const(Integral(Usize(ConstUsize::new(align,\n-                        tcx.sess.target.uint_type).unwrap()))));\n+                        tcx.sess.target.usize_ty).unwrap()))));\n                 }\n                 _ => signal!(e, TypeckError)\n             }\n@@ -421,7 +421,7 @@ fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n         }\n         let arr = cx.eval(arr)?;\n         let idx = match cx.eval(idx)?.val {\n-            Integral(Usize(i)) => i.as_u64(tcx.sess.target.uint_type),\n+            Integral(Usize(i)) => i.as_u64(),\n             _ => signal!(idx, IndexNotUsize),\n         };\n         assert_eq!(idx as usize as u64, idx);\n@@ -431,7 +431,6 @@ fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n                     elem\n                 } else {\n                     let n = v.len() as u64;\n-                    assert_eq!(n as usize as u64, n);\n                     signal!(e, IndexOutOfBounds { len: n, index: idx })\n                 }\n             }\n@@ -457,7 +456,7 @@ fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n       }\n       hir::ExprRepeat(ref elem, _) => {\n           let n = match ty.sty {\n-            ty::TyArray(_, n) => n as u64,\n+            ty::TyArray(_, n) => n.as_u64(),\n             _ => span_bug!(e.span, \"typeck error\")\n           };\n           mk_const(Aggregate(Repeat(cx.eval(elem)?, n)))\n@@ -562,15 +561,15 @@ fn cast_const_int<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         ty::TyInt(ast::IntTy::I64) => Ok(Integral(I64(v as i128 as i64))),\n         ty::TyInt(ast::IntTy::I128) => Ok(Integral(I128(v as i128))),\n         ty::TyInt(ast::IntTy::Is) => {\n-            Ok(Integral(Isize(ConstIsize::new_truncating(v as i128, tcx.sess.target.int_type))))\n+            Ok(Integral(Isize(ConstIsize::new_truncating(v as i128, tcx.sess.target.isize_ty))))\n         },\n         ty::TyUint(ast::UintTy::U8) => Ok(Integral(U8(v as u8))),\n         ty::TyUint(ast::UintTy::U16) => Ok(Integral(U16(v as u16))),\n         ty::TyUint(ast::UintTy::U32) => Ok(Integral(U32(v as u32))),\n         ty::TyUint(ast::UintTy::U64) => Ok(Integral(U64(v as u64))),\n         ty::TyUint(ast::UintTy::U128) => Ok(Integral(U128(v as u128))),\n         ty::TyUint(ast::UintTy::Us) => {\n-            Ok(Integral(Usize(ConstUsize::new_truncating(v, tcx.sess.target.uint_type))))\n+            Ok(Integral(Usize(ConstUsize::new_truncating(v, tcx.sess.target.usize_ty))))\n         },\n         ty::TyFloat(fty) => {\n             if let Some(i) = val.to_u128() {\n@@ -636,7 +635,9 @@ fn cast_const<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 Err(ErrKind::UnimplementedConstVal(\"casting a bytestr to a raw ptr\"))\n             },\n             ty::TyRef(_, ty::TypeAndMut { ref ty, mutbl: hir::MutImmutable }) => match ty.sty {\n-                ty::TyArray(ty, n) if ty == tcx.types.u8 && n == b.data.len() => Ok(val),\n+                ty::TyArray(ty, n) if ty == tcx.types.u8 && n.as_u64() == b.data.len() as u64 => {\n+                    Ok(val)\n+                }\n                 ty::TySlice(_) => {\n                     Err(ErrKind::UnimplementedConstVal(\"casting a bytestr to slice\"))\n                 },\n@@ -678,12 +679,12 @@ fn lit_to_const<'a, 'tcx>(lit: &'tcx ast::LitKind,\n                 (&ty::TyInt(ity), _) |\n                 (_, Signed(ity)) => {\n                     Ok(Integral(ConstInt::new_signed_truncating(n as i128,\n-                        ity, tcx.sess.target.int_type)))\n+                        ity, tcx.sess.target.isize_ty)))\n                 }\n                 (&ty::TyUint(uty), _) |\n                 (_, Unsigned(uty)) => {\n                     Ok(Integral(ConstInt::new_unsigned_truncating(n as u128,\n-                        uty, tcx.sess.target.uint_type)))\n+                        uty, tcx.sess.target.usize_ty)))\n                 }\n                 _ => bug!()\n             }"}, {"sha": "6274796145e1f44ad8f24d72a626544906834922", "filename": "src/librustc_const_eval/pattern.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ce31eb99076261291c1a0ae4b542f52e6ca0f0a/src%2Flibrustc_const_eval%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce31eb99076261291c1a0ae4b542f52e6ca0f0a/src%2Flibrustc_const_eval%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fpattern.rs?ref=3ce31eb99076261291c1a0ae4b542f52e6ca0f0a", "patch": "@@ -537,7 +537,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n \n             ty::TyArray(_, len) => {\n                 // fixed-length array\n-                assert!(len >= prefix.len() + suffix.len());\n+                assert!(len.as_u64() >= prefix.len() as u64 + suffix.len() as u64);\n                 PatternKind::Array { prefix: prefix, slice: slice, suffix: suffix }\n             }\n "}, {"sha": "08473d729e4e5a24877696659e3a323750423cb5", "filename": "src/librustc_const_math/int.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3ce31eb99076261291c1a0ae4b542f52e6ca0f0a/src%2Flibrustc_const_math%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce31eb99076261291c1a0ae4b542f52e6ca0f0a/src%2Flibrustc_const_math%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_math%2Fint.rs?ref=3ce31eb99076261291c1a0ae4b542f52e6ca0f0a", "patch": "@@ -311,17 +311,13 @@ impl ::std::fmt::Display for ConstInt {\n             I32(i) => write!(fmt, \"{}i32\", i),\n             I64(i) => write!(fmt, \"{}i64\", i),\n             I128(i) => write!(fmt, \"{}i128\", i),\n-            Isize(ConstIsize::Is64(i)) => write!(fmt, \"{}isize\", i),\n-            Isize(ConstIsize::Is32(i)) => write!(fmt, \"{}isize\", i),\n-            Isize(ConstIsize::Is16(i)) => write!(fmt, \"{}isize\", i),\n+            Isize(i) => write!(fmt, \"{}isize\", i),\n             U8(i) => write!(fmt, \"{}u8\", i),\n             U16(i) => write!(fmt, \"{}u16\", i),\n             U32(i) => write!(fmt, \"{}u32\", i),\n             U64(i) => write!(fmt, \"{}u64\", i),\n             U128(i) => write!(fmt, \"{}u128\", i),\n-            Usize(ConstUsize::Us64(i)) => write!(fmt, \"{}usize\", i),\n-            Usize(ConstUsize::Us32(i)) => write!(fmt, \"{}usize\", i),\n-            Usize(ConstUsize::Us16(i)) => write!(fmt, \"{}usize\", i),\n+            Usize(i) => write!(fmt, \"{}usize\", i),\n         }\n     }\n }"}, {"sha": "50dfb60112991aa98fbe83b8182ca1dfb6129537", "filename": "src/librustc_const_math/is.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/3ce31eb99076261291c1a0ae4b542f52e6ca0f0a/src%2Flibrustc_const_math%2Fis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce31eb99076261291c1a0ae4b542f52e6ca0f0a/src%2Flibrustc_const_math%2Fis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_math%2Fis.rs?ref=3ce31eb99076261291c1a0ae4b542f52e6ca0f0a", "patch": "@@ -21,18 +21,22 @@ pub enum ConstIsize {\n }\n pub use self::ConstIsize::*;\n \n+impl ::std::fmt::Display for ConstIsize {\n+    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error> {\n+        write!(fmt, \"{}\", self.as_i64())\n+    }\n+}\n+\n impl ConstIsize {\n-    pub fn as_i64(self, target_int_ty: ast::IntTy) -> i64 {\n-        match (self, target_int_ty) {\n-            (Is16(i), ast::IntTy::I16) => i as i64,\n-            (Is32(i), ast::IntTy::I32) => i as i64,\n-            (Is64(i), ast::IntTy::I64) => i,\n-            _ => panic!(\"unable to convert self ({:?}) to target isize ({:?})\",\n-                        self, target_int_ty),\n+    pub fn as_i64(self) -> i64 {\n+        match self {\n+            Is16(i) => i as i64,\n+            Is32(i) => i as i64,\n+            Is64(i) => i,\n         }\n     }\n-    pub fn new(i: i64, target_int_ty: ast::IntTy) -> Result<Self, ConstMathErr> {\n-        match target_int_ty {\n+    pub fn new(i: i64, isize_ty: ast::IntTy) -> Result<Self, ConstMathErr> {\n+        match isize_ty {\n             ast::IntTy::I16 if i as i16 as i64 == i => Ok(Is16(i as i16)),\n             ast::IntTy::I16 => Err(LitOutOfRange(ast::IntTy::Is)),\n             ast::IntTy::I32 if i as i32 as i64 == i => Ok(Is32(i as i32)),\n@@ -41,8 +45,8 @@ impl ConstIsize {\n             _ => unreachable!(),\n         }\n     }\n-    pub fn new_truncating(i: i128, target_int_ty: ast::IntTy) -> Self {\n-        match target_int_ty {\n+    pub fn new_truncating(i: i128, isize_ty: ast::IntTy) -> Self {\n+        match isize_ty {\n             ast::IntTy::I16 => Is16(i as i16),\n             ast::IntTy::I32 => Is32(i as i32),\n             ast::IntTy::I64 => Is64(i as i64),"}, {"sha": "9876bc4d779a0cc1914547963fa9e0720ada0f0c", "filename": "src/librustc_const_math/us.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/3ce31eb99076261291c1a0ae4b542f52e6ca0f0a/src%2Flibrustc_const_math%2Fus.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce31eb99076261291c1a0ae4b542f52e6ca0f0a/src%2Flibrustc_const_math%2Fus.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_math%2Fus.rs?ref=3ce31eb99076261291c1a0ae4b542f52e6ca0f0a", "patch": "@@ -21,18 +21,22 @@ pub enum ConstUsize {\n }\n pub use self::ConstUsize::*;\n \n+impl ::std::fmt::Display for ConstUsize {\n+    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error> {\n+        write!(fmt, \"{}\", self.as_u64())\n+    }\n+}\n+\n impl ConstUsize {\n-    pub fn as_u64(self, target_uint_ty: ast::UintTy) -> u64 {\n-        match (self, target_uint_ty) {\n-            (Us16(i), ast::UintTy::U16) => i as u64,\n-            (Us32(i), ast::UintTy::U32) => i as u64,\n-            (Us64(i), ast::UintTy::U64) => i,\n-            _ => panic!(\"unable to convert self ({:?}) to target usize ({:?})\",\n-                        self, target_uint_ty),\n+    pub fn as_u64(self) -> u64 {\n+        match self {\n+            Us16(i) => i as u64,\n+            Us32(i) => i as u64,\n+            Us64(i) => i,\n         }\n     }\n-    pub fn new(i: u64, target_uint_ty: ast::UintTy) -> Result<Self, ConstMathErr> {\n-        match target_uint_ty {\n+    pub fn new(i: u64, usize_ty: ast::UintTy) -> Result<Self, ConstMathErr> {\n+        match usize_ty {\n             ast::UintTy::U16 if i as u16 as u64 == i => Ok(Us16(i as u16)),\n             ast::UintTy::U16 => Err(ULitOutOfRange(ast::UintTy::Us)),\n             ast::UintTy::U32 if i as u32 as u64 == i => Ok(Us32(i as u32)),\n@@ -41,8 +45,8 @@ impl ConstUsize {\n             _ => unreachable!(),\n         }\n     }\n-    pub fn new_truncating(i: u128, target_uint_ty: ast::UintTy) -> Self {\n-        match target_uint_ty {\n+    pub fn new_truncating(i: u128, usize_ty: ast::UintTy) -> Self {\n+        match usize_ty {\n             ast::UintTy::U16 => Us16(i as u16),\n             ast::UintTy::U32 => Us32(i as u32),\n             ast::UintTy::U64 => Us64(i as u64),"}, {"sha": "9259474ee27c47752c37aa04013bd35835585c5b", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3ce31eb99076261291c1a0ae4b542f52e6ca0f0a/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce31eb99076261291c1a0ae4b542f52e6ca0f0a/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=3ce31eb99076261291c1a0ae4b542f52e6ca0f0a", "patch": "@@ -801,13 +801,13 @@ fn walk_ty() {\n     test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n         let tcx = env.infcx.tcx;\n         let int_ty = tcx.types.isize;\n-        let uint_ty = tcx.types.usize;\n-        let tup1_ty = tcx.intern_tup(&[int_ty, uint_ty, int_ty, uint_ty], false);\n-        let tup2_ty = tcx.intern_tup(&[tup1_ty, tup1_ty, uint_ty], false);\n+        let usize_ty = tcx.types.usize;\n+        let tup1_ty = tcx.intern_tup(&[int_ty, usize_ty, int_ty, usize_ty], false);\n+        let tup2_ty = tcx.intern_tup(&[tup1_ty, tup1_ty, usize_ty], false);\n         let walked: Vec<_> = tup2_ty.walk().collect();\n         assert_eq!(walked,\n-                   [tup2_ty, tup1_ty, int_ty, uint_ty, int_ty, uint_ty, tup1_ty, int_ty,\n-                    uint_ty, int_ty, uint_ty, uint_ty]);\n+                   [tup2_ty, tup1_ty, int_ty, usize_ty, int_ty, usize_ty, tup1_ty, int_ty,\n+                    usize_ty, int_ty, usize_ty, usize_ty]);\n     })\n }\n \n@@ -816,20 +816,20 @@ fn walk_ty_skip_subtree() {\n     test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n         let tcx = env.infcx.tcx;\n         let int_ty = tcx.types.isize;\n-        let uint_ty = tcx.types.usize;\n-        let tup1_ty = tcx.intern_tup(&[int_ty, uint_ty, int_ty, uint_ty], false);\n-        let tup2_ty = tcx.intern_tup(&[tup1_ty, tup1_ty, uint_ty], false);\n+        let usize_ty = tcx.types.usize;\n+        let tup1_ty = tcx.intern_tup(&[int_ty, usize_ty, int_ty, usize_ty], false);\n+        let tup2_ty = tcx.intern_tup(&[tup1_ty, tup1_ty, usize_ty], false);\n \n         // types we expect to see (in order), plus a boolean saying\n         // whether to skip the subtree.\n         let mut expected = vec![(tup2_ty, false),\n                                 (tup1_ty, false),\n                                 (int_ty, false),\n-                                (uint_ty, false),\n+                                (usize_ty, false),\n                                 (int_ty, false),\n-                                (uint_ty, false),\n+                                (usize_ty, false),\n                                 (tup1_ty, true), // skip the isize/usize/isize/usize\n-                                (uint_ty, false)];\n+                                (usize_ty, false)];\n         expected.reverse();\n \n         let mut walker = tup2_ty.walk();"}, {"sha": "d3a5d52b295afa54938281d317249855537beed6", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3ce31eb99076261291c1a0ae4b542f52e6ca0f0a/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce31eb99076261291c1a0ae4b542f52e6ca0f0a/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=3ce31eb99076261291c1a0ae4b542f52e6ca0f0a", "patch": "@@ -93,8 +93,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n \n                 if binop.node.is_shift() {\n                     let opt_ty_bits = match cx.tables.node_id_to_type(l.hir_id).sty {\n-                        ty::TyInt(t) => Some(int_ty_bits(t, cx.sess().target.int_type)),\n-                        ty::TyUint(t) => Some(uint_ty_bits(t, cx.sess().target.uint_type)),\n+                        ty::TyInt(t) => Some(int_ty_bits(t, cx.sess().target.isize_ty)),\n+                        ty::TyUint(t) => Some(uint_ty_bits(t, cx.sess().target.usize_ty)),\n                         _ => None,\n                     };\n \n@@ -141,7 +141,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                             ast::LitKind::Int(v, ast::LitIntType::Signed(_)) |\n                             ast::LitKind::Int(v, ast::LitIntType::Unsuffixed) => {\n                                 let int_type = if let ast::IntTy::Is = t {\n-                                    cx.sess().target.int_type\n+                                    cx.sess().target.isize_ty\n                                 } else {\n                                     t\n                                 };\n@@ -164,7 +164,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                     }\n                     ty::TyUint(t) => {\n                         let uint_type = if let ast::UintTy::Us = t {\n-                            cx.sess().target.uint_type\n+                            cx.sess().target.usize_ty\n                         } else {\n                             t\n                         };\n@@ -250,9 +250,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n             }\n         }\n \n-        fn int_ty_bits(int_ty: ast::IntTy, target_int_ty: ast::IntTy) -> u64 {\n+        fn int_ty_bits(int_ty: ast::IntTy, isize_ty: ast::IntTy) -> u64 {\n             match int_ty {\n-                ast::IntTy::Is => int_ty_bits(target_int_ty, target_int_ty),\n+                ast::IntTy::Is => int_ty_bits(isize_ty, isize_ty),\n                 ast::IntTy::I8 => 8,\n                 ast::IntTy::I16 => 16 as u64,\n                 ast::IntTy::I32 => 32,\n@@ -261,9 +261,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n             }\n         }\n \n-        fn uint_ty_bits(uint_ty: ast::UintTy, target_uint_ty: ast::UintTy) -> u64 {\n+        fn uint_ty_bits(uint_ty: ast::UintTy, usize_ty: ast::UintTy) -> u64 {\n             match uint_ty {\n-                ast::UintTy::Us => uint_ty_bits(target_uint_ty, target_uint_ty),\n+                ast::UintTy::Us => uint_ty_bits(usize_ty, usize_ty),\n                 ast::UintTy::U8 => 8,\n                 ast::UintTy::U16 => 16,\n                 ast::UintTy::U32 => 32,"}, {"sha": "eeae4bce335ca692680d7e7496b9d0711da17ff6", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3ce31eb99076261291c1a0ae4b542f52e6ca0f0a/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce31eb99076261291c1a0ae4b542f52e6ca0f0a/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=3ce31eb99076261291c1a0ae4b542f52e6ca0f0a", "patch": "@@ -388,7 +388,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     ast::IntTy::I64 => ConstInt::I64(-1),\n                     ast::IntTy::I128 => ConstInt::I128(-1),\n                     ast::IntTy::Is => {\n-                        let int_ty = self.hir.tcx().sess.target.int_type;\n+                        let int_ty = self.hir.tcx().sess.target.isize_ty;\n                         let val = ConstIsize::new(-1, int_ty).unwrap();\n                         ConstInt::Isize(val)\n                     }\n@@ -420,7 +420,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     ast::IntTy::I64 => ConstInt::I64(i64::min_value()),\n                     ast::IntTy::I128 => ConstInt::I128(i128::min_value()),\n                     ast::IntTy::Is => {\n-                        let int_ty = self.hir.tcx().sess.target.int_type;\n+                        let int_ty = self.hir.tcx().sess.target.isize_ty;\n                         let min = match int_ty {\n                             ast::IntTy::I16 => std::i16::MIN as i64,\n                             ast::IntTy::I32 => std::i32::MIN as i64,"}, {"sha": "7b91c43aa37222dbeaf0a8f1c255d2fe0a6eb861", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ce31eb99076261291c1a0ae4b542f52e6ca0f0a/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce31eb99076261291c1a0ae4b542f52e6ca0f0a/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=3ce31eb99076261291c1a0ae4b542f52e6ca0f0a", "patch": "@@ -279,7 +279,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n                     assert!(ty.is_slice());\n \n-                    let array_ty = tcx.mk_array(tcx.types.u8, bytes.data.len());\n+                    let array_ty = tcx.mk_array(tcx.types.u8, bytes.data.len() as u64);\n                     let array_ref = tcx.mk_imm_ref(tcx.types.re_static, array_ty);\n                     let array = self.literal_operand(test.span, array_ref, Literal::Value {\n                         value"}, {"sha": "1976b70ac0a2367c98f5c556a065518fe75418bb", "filename": "src/librustc_mir/build/misc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3ce31eb99076261291c1a0ae4b542f52e6ca0f0a/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce31eb99076261291c1a0ae4b542f52e6ca0f0a/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs?ref=3ce31eb99076261291c1a0ae4b542f52e6ca0f0a", "patch": "@@ -75,7 +75,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     ast::UintTy::U64 => ConstInt::U64(0),\n                     ast::UintTy::U128 => ConstInt::U128(0),\n                     ast::UintTy::Us => {\n-                        let uint_ty = self.hir.tcx().sess.target.uint_type;\n+                        let uint_ty = self.hir.tcx().sess.target.usize_ty;\n                         let val = ConstUsize::new(0, uint_ty).unwrap();\n                         ConstInt::Usize(val)\n                     }\n@@ -96,7 +96,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     ast::IntTy::I64 => ConstInt::I64(0),\n                     ast::IntTy::I128 => ConstInt::I128(0),\n                     ast::IntTy::Is => {\n-                        let int_ty = self.hir.tcx().sess.target.int_type;\n+                        let int_ty = self.hir.tcx().sess.target.isize_ty;\n                         let val = ConstIsize::new(0, int_ty).unwrap();\n                         ConstInt::Isize(val)\n                     }"}, {"sha": "f5e15979006af50f96569e30238fcd282d3cc540", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ce31eb99076261291c1a0ae4b542f52e6ca0f0a/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce31eb99076261291c1a0ae4b542f52e6ca0f0a/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=3ce31eb99076261291c1a0ae4b542f52e6ca0f0a", "patch": "@@ -112,7 +112,7 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn usize_literal(&mut self, value: u64) -> Literal<'tcx> {\n-        match ConstUsize::new(value, self.tcx.sess.target.uint_type) {\n+        match ConstUsize::new(value, self.tcx.sess.target.usize_ty) {\n             Ok(val) => {\n                 Literal::Value {\n                     value: self.tcx.mk_const(ty::Const {"}, {"sha": "eddd4f39f4333e708966073a466a633d90c21b5c", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3ce31eb99076261291c1a0ae4b542f52e6ca0f0a/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce31eb99076261291c1a0ae4b542f52e6ca0f0a/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=3ce31eb99076261291c1a0ae4b542f52e6ca0f0a", "patch": "@@ -292,7 +292,7 @@ fn build_clone_shim<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n \n     match self_ty.sty {\n         _ if is_copy => builder.copy_shim(),\n-        ty::TyArray(ty, len) => builder.array_shim(ty, len),\n+        ty::TyArray(ty, len) => builder.array_shim(ty, len.as_u64()),\n         ty::TyTuple(tys, _) => builder.tuple_shim(tys),\n         _ => {\n             bug!(\"clone shim for `{:?}` which is not `Copy` and is not an aggregate\", self_ty);\n@@ -470,8 +470,8 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n         );\n     }\n \n-    fn make_usize(&self, value: usize) -> Box<Constant<'tcx>> {\n-        let value = ConstUsize::new(value as u64, self.tcx.sess.target.uint_type).unwrap();\n+    fn make_usize(&self, value: u64) -> Box<Constant<'tcx>> {\n+        let value = ConstUsize::new(value, self.tcx.sess.target.usize_ty).unwrap();\n         box Constant {\n             span: self.span,\n             ty: self.tcx.types.usize,\n@@ -484,7 +484,7 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n         }\n     }\n \n-    fn array_shim(&mut self, ty: ty::Ty<'tcx>, len: usize) {\n+    fn array_shim(&mut self, ty: ty::Ty<'tcx>, len: u64) {\n         let tcx = self.tcx;\n         let span = self.span;\n         let rcvr = Lvalue::Local(Local::new(1+0)).deref();"}, {"sha": "30074becb09c7eb2378c57c55af7bbc775f0d458", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3ce31eb99076261291c1a0ae4b542f52e6ca0f0a/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce31eb99076261291c1a0ae4b542f52e6ca0f0a/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=3ce31eb99076261291c1a0ae4b542f52e6ca0f0a", "patch": "@@ -695,8 +695,8 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                             }\n                             _ => false\n                         }\n-                    } else if let ty::TyArray(_, 0) = ty.sty {\n-                        self.mode == Mode::Fn\n+                    } else if let ty::TyArray(_, len) = ty.sty {\n+                        len.as_u64() == 0 && self.mode == Mode::Fn\n                     } else {\n                         false\n                     };"}, {"sha": "07134451a4e298901ee9d51fb71690668ef7d8a0", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3ce31eb99076261291c1a0ae4b542f52e6ca0f0a/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce31eb99076261291c1a0ae4b542f52e6ca0f0a/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=3ce31eb99076261291c1a0ae4b542f52e6ca0f0a", "patch": "@@ -209,7 +209,8 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n                 LvalueTy::Ty {\n                     ty: match base_ty.sty {\n                         ty::TyArray(inner, size) => {\n-                            let min_size = (from as usize) + (to as usize);\n+                            let size = size.as_u64();\n+                            let min_size = (from as u64) + (to as u64);\n                             if let Some(rest_size) = size.checked_sub(min_size) {\n                                 tcx.mk_array(inner, rest_size)\n                             } else {"}, {"sha": "4211c8df5ca0385dd8ae27112ec42bc442cc65fb", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3ce31eb99076261291c1a0ae4b542f52e6ca0f0a/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce31eb99076261291c1a0ae4b542f52e6ca0f0a/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=3ce31eb99076261291c1a0ae4b542f52e6ca0f0a", "patch": "@@ -11,7 +11,7 @@\n use llvm::{self, ValueRef, AttributePlace};\n use base;\n use builder::Builder;\n-use common::{instance_ty, ty_fn_sig, type_is_fat_ptr, C_uint};\n+use common::{instance_ty, ty_fn_sig, type_is_fat_ptr, C_usize};\n use context::CrateContext;\n use cabi_x86;\n use cabi_x86_64;\n@@ -527,7 +527,7 @@ impl<'a, 'tcx> ArgType<'tcx> {\n         }\n         let ccx = bcx.ccx;\n         if self.is_indirect() {\n-            let llsz = C_uint(ccx, self.layout.size(ccx).bytes());\n+            let llsz = C_usize(ccx, self.layout.size(ccx).bytes());\n             let llalign = self.layout.align(ccx).abi();\n             base::call_memcpy(bcx, dst, val, llsz, llalign as u32);\n         } else if let Some(ty) = self.cast {\n@@ -564,7 +564,7 @@ impl<'a, 'tcx> ArgType<'tcx> {\n                 base::call_memcpy(bcx,\n                                   bcx.pointercast(dst, Type::i8p(ccx)),\n                                   bcx.pointercast(llscratch, Type::i8p(ccx)),\n-                                  C_uint(ccx, self.layout.size(ccx).bytes()),\n+                                  C_usize(ccx, self.layout.size(ccx).bytes()),\n                                   cmp::min(self.layout.align(ccx).abi() as u32,\n                                            llalign_of_min(ccx, ty)));\n "}, {"sha": "23a45a7962abfacf6c5cbffa7ddce260d0eaa1ee", "filename": "src/librustc_trans/adt.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3ce31eb99076261291c1a0ae4b542f52e6ca0f0a/src%2Flibrustc_trans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce31eb99076261291c1a0ae4b542f52e6ca0f0a/src%2Flibrustc_trans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fadt.rs?ref=3ce31eb99076261291c1a0ae4b542f52e6ca0f0a", "patch": "@@ -397,11 +397,11 @@ pub fn trans_set_discr<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, t: Ty<'tcx>, val: Valu\n     match *l {\n         layout::CEnum{ discr, min, max, .. } => {\n             assert_discr_in_range(min, max, to);\n-            bcx.store(C_integral(Type::from_integer(bcx.ccx, discr), to, true),\n+            bcx.store(C_int(Type::from_integer(bcx.ccx, discr), to as i64),\n                   val, None);\n         }\n         layout::General{ discr, .. } => {\n-            bcx.store(C_integral(Type::from_integer(bcx.ccx, discr), to, true),\n+            bcx.store(C_int(Type::from_integer(bcx.ccx, discr), to as i64),\n                   bcx.struct_gep(val, 0), None);\n         }\n         layout::Univariant { .. }\n@@ -423,7 +423,7 @@ pub fn trans_set_discr<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, t: Ty<'tcx>, val: Valu\n                     // than storing null to single target field.\n                     let llptr = bcx.pointercast(val, Type::i8(bcx.ccx).ptr_to());\n                     let fill_byte = C_u8(bcx.ccx, 0);\n-                    let size = C_uint(bcx.ccx, nonnull.stride().bytes());\n+                    let size = C_usize(bcx.ccx, nonnull.stride().bytes());\n                     let align = C_i32(bcx.ccx, nonnull.align.abi() as i32);\n                     base::call_memset(bcx, llptr, fill_byte, size, align, false);\n                 } else {"}, {"sha": "96499424be1f62c2d04be96966c828258b993641", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3ce31eb99076261291c1a0ae4b542f52e6ca0f0a/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce31eb99076261291c1a0ae4b542f52e6ca0f0a/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=3ce31eb99076261291c1a0ae4b542f52e6ca0f0a", "patch": "@@ -53,7 +53,7 @@ use mir::lvalue::LvalueRef;\n use attributes;\n use builder::Builder;\n use callee;\n-use common::{C_bool, C_bytes_in_context, C_i32, C_uint};\n+use common::{C_bool, C_bytes_in_context, C_i32, C_usize};\n use collector::{self, TransItemCollectionMode};\n use common::{C_struct_in_context, C_u64, C_undef, C_array};\n use common::CrateContext;\n@@ -201,7 +201,7 @@ pub fn unsized_info<'ccx, 'tcx>(ccx: &CrateContext<'ccx, 'tcx>,\n                                 -> ValueRef {\n     let (source, target) = ccx.tcx().struct_lockstep_tails(source, target);\n     match (&source.sty, &target.sty) {\n-        (&ty::TyArray(_, len), &ty::TySlice(_)) => C_uint(ccx, len),\n+        (&ty::TyArray(_, len), &ty::TySlice(_)) => C_usize(ccx, len.as_u64()),\n         (&ty::TyDynamic(..), &ty::TyDynamic(..)) => {\n             // For now, upcasts are limited to changes in marker\n             // traits, and hence never actually require an actual\n@@ -524,7 +524,7 @@ pub fn call_memcpy<'a, 'tcx>(b: &Builder<'a, 'tcx>,\n     let memcpy = ccx.get_intrinsic(&key);\n     let src_ptr = b.pointercast(src, Type::i8p(ccx));\n     let dst_ptr = b.pointercast(dst, Type::i8p(ccx));\n-    let size = b.intcast(n_bytes, ccx.int_type(), false);\n+    let size = b.intcast(n_bytes, ccx.isize_ty(), false);\n     let align = C_i32(ccx, align as i32);\n     let volatile = C_bool(ccx, false);\n     b.call(memcpy, &[dst_ptr, src_ptr, size, align, volatile], None);\n@@ -545,7 +545,7 @@ pub fn memcpy_ty<'a, 'tcx>(\n     }\n \n     let align = align.unwrap_or_else(|| ccx.align_of(t));\n-    call_memcpy(bcx, dst, src, C_uint(ccx, size), align);\n+    call_memcpy(bcx, dst, src, C_usize(ccx, size), align);\n }\n \n pub fn call_memset<'a, 'tcx>(b: &Builder<'a, 'tcx>,\n@@ -696,7 +696,7 @@ fn maybe_create_entry_wrapper(ccx: &CrateContext) {\n                        sp: Span,\n                        rust_main: ValueRef,\n                        use_start_lang_item: bool) {\n-        let llfty = Type::func(&[ccx.int_type(), Type::i8p(ccx).ptr_to()], &ccx.int_type());\n+        let llfty = Type::func(&[ccx.isize_ty(), Type::i8p(ccx).ptr_to()], &ccx.isize_ty());\n \n         if declare::get_defined_value(ccx, \"main\").is_some() {\n             // FIXME: We should be smart and show a better diagnostic here."}, {"sha": "67c95b92e523b6adc4924defe6d6732575e61e37", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 20, "deletions": 29, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/3ce31eb99076261291c1a0ae4b542f52e6ca0f0a/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce31eb99076261291c1a0ae4b542f52e6ca0f0a/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=3ce31eb99076261291c1a0ae4b542f52e6ca0f0a", "patch": "@@ -221,9 +221,15 @@ pub fn C_undef(t: Type) -> ValueRef {\n     }\n }\n \n-pub fn C_integral(t: Type, u: u64, sign_extend: bool) -> ValueRef {\n+pub fn C_int(t: Type, i: i64) -> ValueRef {\n     unsafe {\n-        llvm::LLVMConstInt(t.to_ref(), u, sign_extend as Bool)\n+        llvm::LLVMConstInt(t.to_ref(), i as u64, True)\n+    }\n+}\n+\n+pub fn C_uint(t: Type, i: u64) -> ValueRef {\n+    unsafe {\n+        llvm::LLVMConstInt(t.to_ref(), i, False)\n     }\n }\n \n@@ -239,49 +245,34 @@ pub fn C_nil(ccx: &CrateContext) -> ValueRef {\n }\n \n pub fn C_bool(ccx: &CrateContext, val: bool) -> ValueRef {\n-    C_integral(Type::i1(ccx), val as u64, false)\n+    C_uint(Type::i1(ccx), val as u64)\n }\n \n pub fn C_i32(ccx: &CrateContext, i: i32) -> ValueRef {\n-    C_integral(Type::i32(ccx), i as u64, true)\n+    C_int(Type::i32(ccx), i as i64)\n }\n \n pub fn C_u32(ccx: &CrateContext, i: u32) -> ValueRef {\n-    C_integral(Type::i32(ccx), i as u64, false)\n+    C_uint(Type::i32(ccx), i as u64)\n }\n \n pub fn C_u64(ccx: &CrateContext, i: u64) -> ValueRef {\n-    C_integral(Type::i64(ccx), i, false)\n+    C_uint(Type::i64(ccx), i)\n }\n \n-pub fn C_uint<I: AsU64>(ccx: &CrateContext, i: I) -> ValueRef {\n-    let v = i.as_u64();\n-\n-    let bit_size = machine::llbitsize_of_real(ccx, ccx.int_type());\n+pub fn C_usize(ccx: &CrateContext, i: u64) -> ValueRef {\n+    let bit_size = machine::llbitsize_of_real(ccx, ccx.isize_ty());\n \n     if bit_size < 64 {\n         // make sure it doesn't overflow\n-        assert!(v < (1<<bit_size));\n+        assert!(i < (1<<bit_size));\n     }\n \n-    C_integral(ccx.int_type(), v, false)\n+    C_uint(ccx.isize_ty(), i)\n }\n \n-pub trait AsI64 { fn as_i64(self) -> i64; }\n-pub trait AsU64 { fn as_u64(self) -> u64; }\n-\n-// FIXME: remove the intptr conversions, because they\n-// are host-architecture-dependent\n-impl AsI64 for i64 { fn as_i64(self) -> i64 { self as i64 }}\n-impl AsI64 for i32 { fn as_i64(self) -> i64 { self as i64 }}\n-impl AsI64 for isize { fn as_i64(self) -> i64 { self as i64 }}\n-\n-impl AsU64 for u64  { fn as_u64(self) -> u64 { self as u64 }}\n-impl AsU64 for u32  { fn as_u64(self) -> u64 { self as u64 }}\n-impl AsU64 for usize { fn as_u64(self) -> u64 { self as u64 }}\n-\n pub fn C_u8(ccx: &CrateContext, i: u8) -> ValueRef {\n-    C_integral(Type::i8(ccx), i as u64, false)\n+    C_uint(Type::i8(ccx), i as u64)\n }\n \n \n@@ -315,7 +306,7 @@ pub fn C_cstr(cx: &CrateContext, s: InternedString, null_terminated: bool) -> Va\n pub fn C_str_slice(cx: &CrateContext, s: InternedString) -> ValueRef {\n     let len = s.len();\n     let cs = consts::ptrcast(C_cstr(cx, s, false), Type::i8p(cx));\n-    C_named_struct(cx.str_slice_type(), &[cs, C_uint(cx, len)])\n+    C_named_struct(cx.str_slice_type(), &[cs, C_usize(cx, len as u64)])\n }\n \n pub fn C_struct(cx: &CrateContext, elts: &[ValueRef], packed: bool) -> ValueRef {\n@@ -482,9 +473,9 @@ pub fn shift_mask_val<'a, 'tcx>(\n             // i8/u8 can shift by at most 7, i16/u16 by at most 15, etc.\n             let val = llty.int_width() - 1;\n             if invert {\n-                C_integral(mask_llty, !val, true)\n+                C_int(mask_llty, !val as i64)\n             } else {\n-                C_integral(mask_llty, val, false)\n+                C_uint(mask_llty, val)\n             }\n         },\n         TypeKind::Vector => {"}, {"sha": "77bddc7731b5bee0a3a65203102f9bc7f2e2dee6", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3ce31eb99076261291c1a0ae4b542f52e6ca0f0a/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce31eb99076261291c1a0ae4b542f52e6ca0f0a/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=3ce31eb99076261291c1a0ae4b542f52e6ca0f0a", "patch": "@@ -136,7 +136,7 @@ pub struct LocalCrateContext<'a, 'tcx: 'a> {\n     used_statics: RefCell<Vec<ValueRef>>,\n \n     lltypes: RefCell<FxHashMap<Ty<'tcx>, Type>>,\n-    int_type: Type,\n+    isize_ty: Type,\n     opaque_vec_type: Type,\n     str_slice_type: Type,\n \n@@ -398,7 +398,7 @@ impl<'a, 'tcx> LocalCrateContext<'a, 'tcx> {\n                 statics_to_rauw: RefCell::new(Vec::new()),\n                 used_statics: RefCell::new(Vec::new()),\n                 lltypes: RefCell::new(FxHashMap()),\n-                int_type: Type::from_ref(ptr::null_mut()),\n+                isize_ty: Type::from_ref(ptr::null_mut()),\n                 opaque_vec_type: Type::from_ref(ptr::null_mut()),\n                 str_slice_type: Type::from_ref(ptr::null_mut()),\n                 dbg_cx,\n@@ -410,23 +410,23 @@ impl<'a, 'tcx> LocalCrateContext<'a, 'tcx> {\n                 placeholder: PhantomData,\n             };\n \n-            let (int_type, opaque_vec_type, str_slice_ty, mut local_ccx) = {\n+            let (isize_ty, opaque_vec_type, str_slice_ty, mut local_ccx) = {\n                 // Do a little dance to create a dummy CrateContext, so we can\n                 // create some things in the LLVM module of this codegen unit\n                 let mut local_ccxs = vec![local_ccx];\n-                let (int_type, opaque_vec_type, str_slice_ty) = {\n+                let (isize_ty, opaque_vec_type, str_slice_ty) = {\n                     let dummy_ccx = LocalCrateContext::dummy_ccx(shared,\n                                                                  local_ccxs.as_mut_slice());\n                     let mut str_slice_ty = Type::named_struct(&dummy_ccx, \"str_slice\");\n                     str_slice_ty.set_struct_body(&[Type::i8p(&dummy_ccx),\n-                                                   Type::int(&dummy_ccx)],\n+                                                   Type::isize(&dummy_ccx)],\n                                                  false);\n-                    (Type::int(&dummy_ccx), Type::opaque_vec(&dummy_ccx), str_slice_ty)\n+                    (Type::isize(&dummy_ccx), Type::opaque_vec(&dummy_ccx), str_slice_ty)\n                 };\n-                (int_type, opaque_vec_type, str_slice_ty, local_ccxs.pop().unwrap())\n+                (isize_ty, opaque_vec_type, str_slice_ty, local_ccxs.pop().unwrap())\n             };\n \n-            local_ccx.int_type = int_type;\n+            local_ccx.isize_ty = isize_ty;\n             local_ccx.opaque_vec_type = opaque_vec_type;\n             local_ccx.str_slice_type = str_slice_ty;\n \n@@ -549,8 +549,8 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.local().stats\n     }\n \n-    pub fn int_type(&self) -> Type {\n-        self.local().int_type\n+    pub fn isize_ty(&self) -> Type {\n+        self.local().isize_ty\n     }\n \n     pub fn str_slice_type(&self) -> Type {"}, {"sha": "0ef93e73c4bc82c911a1332f8082201332190f92", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3ce31eb99076261291c1a0ae4b542f52e6ca0f0a/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce31eb99076261291c1a0ae4b542f52e6ca0f0a/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=3ce31eb99076261291c1a0ae4b542f52e6ca0f0a", "patch": "@@ -366,7 +366,7 @@ fn vec_slice_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                          -> bool {\n         member_llvm_types.len() == 2 &&\n         member_llvm_types[0] == type_of::type_of(cx, element_type).ptr_to() &&\n-        member_llvm_types[1] == cx.int_type()\n+        member_llvm_types[1] == cx.isize_ty()\n     }\n }\n \n@@ -530,7 +530,7 @@ pub fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             MetadataCreationResult::new(basic_type_metadata(cx, t), false)\n         }\n         ty::TyArray(typ, len) => {\n-            fixed_vec_metadata(cx, unique_type_id, typ, Some(len as u64), usage_site_span)\n+            fixed_vec_metadata(cx, unique_type_id, typ, Some(len.as_u64()), usage_site_span)\n         }\n         ty::TySlice(typ) => {\n             fixed_vec_metadata(cx, unique_type_id, typ, None, usage_site_span)"}, {"sha": "8dd0b4e466ce491bedcb291c963218b64317aaf6", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3ce31eb99076261291c1a0ae4b542f52e6ca0f0a/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce31eb99076261291c1a0ae4b542f52e6ca0f0a/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=3ce31eb99076261291c1a0ae4b542f52e6ca0f0a", "patch": "@@ -70,8 +70,8 @@ pub fn size_and_align_of_dst<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, t: Ty<'tcx>, inf\n         let align = bcx.ccx.align_of(t);\n         debug!(\"size_and_align_of_dst t={} info={:?} size: {} align: {}\",\n                t, Value(info), size, align);\n-        let size = C_uint(bcx.ccx, size);\n-        let align = C_uint(bcx.ccx, align);\n+        let size = C_usize(bcx.ccx, size);\n+        let align = C_usize(bcx.ccx, align as u64);\n         return (size, align);\n     }\n     assert!(!info.is_null());\n@@ -96,8 +96,8 @@ pub fn size_and_align_of_dst<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, t: Ty<'tcx>, inf\n             };\n             debug!(\"DST {} statically sized prefix size: {} align: {}\",\n                    t, sized_size, sized_align);\n-            let sized_size = C_uint(ccx, sized_size);\n-            let sized_align = C_uint(ccx, sized_align);\n+            let sized_size = C_usize(ccx, sized_size);\n+            let sized_align = C_usize(ccx, sized_align);\n \n             // Recurse to get the size of the dynamically sized field (must be\n             // the last field).\n@@ -128,7 +128,7 @@ pub fn size_and_align_of_dst<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, t: Ty<'tcx>, inf\n                 (Some(sized_align), Some(unsized_align)) => {\n                     // If both alignments are constant, (the sized_align should always be), then\n                     // pick the correct alignment statically.\n-                    C_uint(ccx, std::cmp::max(sized_align, unsized_align) as u64)\n+                    C_usize(ccx, std::cmp::max(sized_align, unsized_align) as u64)\n                 }\n                 _ => bcx.select(bcx.icmp(llvm::IntUGT, sized_align, unsized_align),\n                                 sized_align,\n@@ -146,7 +146,7 @@ pub fn size_and_align_of_dst<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, t: Ty<'tcx>, inf\n             //\n             //   `(size + (align-1)) & -align`\n \n-            let addend = bcx.sub(align, C_uint(bcx.ccx, 1_u64));\n+            let addend = bcx.sub(align, C_usize(bcx.ccx, 1));\n             let size = bcx.and(bcx.add(size, addend), bcx.neg(align));\n \n             (size, align)\n@@ -159,8 +159,8 @@ pub fn size_and_align_of_dst<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, t: Ty<'tcx>, inf\n             let unit = t.sequence_element_type(bcx.tcx());\n             // The info in this case is the length of the str, so the size is that\n             // times the unit size.\n-            (bcx.mul(info, C_uint(bcx.ccx, bcx.ccx.size_of(unit))),\n-             C_uint(bcx.ccx, bcx.ccx.align_of(unit)))\n+            (bcx.mul(info, C_usize(bcx.ccx, bcx.ccx.size_of(unit))),\n+             C_usize(bcx.ccx, bcx.ccx.align_of(unit) as u64))\n         }\n         _ => bug!(\"Unexpected unsized type, found {}\", t)\n     }"}, {"sha": "f78d80a197ca9a68ffa84c6c60bd46f227bdd8cb", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3ce31eb99076261291c1a0ae4b542f52e6ca0f0a/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce31eb99076261291c1a0ae4b542f52e6ca0f0a/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=3ce31eb99076261291c1a0ae4b542f52e6ca0f0a", "patch": "@@ -135,7 +135,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n         \"size_of\" => {\n             let tp_ty = substs.type_at(0);\n             let lltp_ty = type_of::type_of(ccx, tp_ty);\n-            C_uint(ccx, machine::llsize_of_alloc(ccx, lltp_ty))\n+            C_usize(ccx, machine::llsize_of_alloc(ccx, lltp_ty))\n         }\n         \"size_of_val\" => {\n             let tp_ty = substs.type_at(0);\n@@ -145,12 +145,12 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                 llsize\n             } else {\n                 let lltp_ty = type_of::type_of(ccx, tp_ty);\n-                C_uint(ccx, machine::llsize_of_alloc(ccx, lltp_ty))\n+                C_usize(ccx, machine::llsize_of_alloc(ccx, lltp_ty))\n             }\n         }\n         \"min_align_of\" => {\n             let tp_ty = substs.type_at(0);\n-            C_uint(ccx, ccx.align_of(tp_ty))\n+            C_usize(ccx, ccx.align_of(tp_ty) as u64)\n         }\n         \"min_align_of_val\" => {\n             let tp_ty = substs.type_at(0);\n@@ -159,13 +159,13 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                     glue::size_and_align_of_dst(bcx, tp_ty, llargs[1]);\n                 llalign\n             } else {\n-                C_uint(ccx, ccx.align_of(tp_ty))\n+                C_usize(ccx, ccx.align_of(tp_ty) as u64)\n             }\n         }\n         \"pref_align_of\" => {\n             let tp_ty = substs.type_at(0);\n             let lltp_ty = type_of::type_of(ccx, tp_ty);\n-            C_uint(ccx, machine::llalign_of_pref(ccx, lltp_ty))\n+            C_usize(ccx, machine::llalign_of_pref(ccx, lltp_ty) as u64)\n         }\n         \"type_name\" => {\n             let tp_ty = substs.type_at(0);\n@@ -182,7 +182,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                 // If we store a zero constant, LLVM will drown in vreg allocation for large data\n                 // structures, and the generated code will be awful. (A telltale sign of this is\n                 // large quantities of `mov [byte ptr foo],0` in the generated code.)\n-                memset_intrinsic(bcx, false, ty, llresult, C_u8(ccx, 0), C_uint(ccx, 1usize));\n+                memset_intrinsic(bcx, false, ty, llresult, C_u8(ccx, 0), C_usize(ccx, 1));\n             }\n             C_nil(ccx)\n         }\n@@ -386,10 +386,10 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n \n         \"align_offset\" => {\n             // `ptr as usize`\n-            let ptr_val = bcx.ptrtoint(llargs[0], bcx.ccx.int_type());\n+            let ptr_val = bcx.ptrtoint(llargs[0], bcx.ccx.isize_ty());\n             // `ptr_val % align`\n             let offset = bcx.urem(ptr_val, llargs[1]);\n-            let zero = C_null(bcx.ccx.int_type());\n+            let zero = C_null(bcx.ccx.isize_ty());\n             // `offset == 0`\n             let is_zero = bcx.icmp(llvm::IntPredicate::IntEQ, offset, zero);\n             // `if offset == 0 { 0 } else { offset - align }`\n@@ -688,7 +688,7 @@ fn copy_intrinsic<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n     let lltp_ty = type_of::type_of(ccx, tp_ty);\n     let align = C_i32(ccx, ccx.align_of(tp_ty) as i32);\n     let size = machine::llsize_of(ccx, lltp_ty);\n-    let int_size = machine::llbitsize_of_real(ccx, ccx.int_type());\n+    let int_size = machine::llbitsize_of_real(ccx, ccx.isize_ty());\n \n     let operation = if allow_overlap {\n         \"memmove\""}, {"sha": "bc383abc7e0ecc96aeb18ead69c13991aaa3d55f", "filename": "src/librustc_trans/machine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ce31eb99076261291c1a0ae4b542f52e6ca0f0a/src%2Flibrustc_trans%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce31eb99076261291c1a0ae4b542f52e6ca0f0a/src%2Flibrustc_trans%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmachine.rs?ref=3ce31eb99076261291c1a0ae4b542f52e6ca0f0a", "patch": "@@ -48,7 +48,7 @@ pub fn llsize_of(cx: &CrateContext, ty: Type) -> ValueRef {\n     // there's no need for that contrivance.  The instruction\n     // selection DAG generator would flatten that GEP(1) node into a\n     // constant of the type's alloc size, so let's save it some work.\n-    return C_uint(cx, llsize_of_alloc(cx, ty));\n+    return C_usize(cx, llsize_of_alloc(cx, ty));\n }\n \n // Returns the preferred alignment of the given type for the current target."}, {"sha": "6eedd53974e70482a76cca732d4c90ea6c2a6719", "filename": "src/librustc_trans/meth.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3ce31eb99076261291c1a0ae4b542f52e6ca0f0a/src%2Flibrustc_trans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce31eb99076261291c1a0ae4b542f52e6ca0f0a/src%2Flibrustc_trans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmeth.rs?ref=3ce31eb99076261291c1a0ae4b542f52e6ca0f0a", "patch": "@@ -46,7 +46,7 @@ impl<'a, 'tcx> VirtualIndex {\n         // Load the data pointer from the object.\n         debug!(\"get_int({:?}, {:?})\", Value(llvtable), self);\n \n-        let llvtable = bcx.pointercast(llvtable, Type::int(bcx.ccx).ptr_to());\n+        let llvtable = bcx.pointercast(llvtable, Type::isize(bcx.ccx).ptr_to());\n         let ptr = bcx.load(bcx.gepi(llvtable, &[self.0]), None);\n         // Vtable loads are invariant\n         bcx.set_invariant_load(ptr);\n@@ -81,8 +81,8 @@ pub fn get_vtable<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     let mut components: Vec<_> = [\n         callee::get_fn(ccx, monomorphize::resolve_drop_in_place(ccx.shared(), ty)),\n-        C_uint(ccx, ccx.size_of(ty)),\n-        C_uint(ccx, ccx.align_of(ty))\n+        C_usize(ccx, ccx.size_of(ty)),\n+        C_usize(ccx, ccx.align_of(ty) as u64)\n     ].iter().cloned().collect();\n \n     if let Some(trait_ref) = trait_ref {"}, {"sha": "f75c949fefe3a42601a22406742851e4e53390f2", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 25, "deletions": 30, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/3ce31eb99076261291c1a0ae4b542f52e6ca0f0a/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce31eb99076261291c1a0ae4b542f52e6ca0f0a/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=3ce31eb99076261291c1a0ae4b542f52e6ca0f0a", "patch": "@@ -26,8 +26,8 @@ use abi::{self, Abi};\n use callee;\n use builder::Builder;\n use common::{self, CrateContext, const_get_elt, val_ty};\n-use common::{C_array, C_bool, C_bytes, C_integral, C_big_integral, C_u32, C_u64};\n-use common::{C_null, C_struct, C_str_slice, C_undef, C_uint, C_vector, is_undef};\n+use common::{C_array, C_bool, C_bytes, C_int, C_uint, C_big_integral, C_u32, C_u64};\n+use common::{C_null, C_struct, C_str_slice, C_undef, C_usize, C_vector, is_undef};\n use common::const_to_opt_u128;\n use consts;\n use monomorphize;\n@@ -66,24 +66,18 @@ impl<'tcx> Const<'tcx> {\n     -> Const<'tcx> {\n         let tcx = ccx.tcx();\n         let (llval, ty) = match *ci {\n-            I8(v) => (C_integral(Type::i8(ccx), v as u64, true), tcx.types.i8),\n-            I16(v) => (C_integral(Type::i16(ccx), v as u64, true), tcx.types.i16),\n-            I32(v) => (C_integral(Type::i32(ccx), v as u64, true), tcx.types.i32),\n-            I64(v) => (C_integral(Type::i64(ccx), v as u64, true), tcx.types.i64),\n+            I8(v) => (C_int(Type::i8(ccx), v as i64), tcx.types.i8),\n+            I16(v) => (C_int(Type::i16(ccx), v as i64), tcx.types.i16),\n+            I32(v) => (C_int(Type::i32(ccx), v as i64), tcx.types.i32),\n+            I64(v) => (C_int(Type::i64(ccx), v as i64), tcx.types.i64),\n             I128(v) => (C_big_integral(Type::i128(ccx), v as u128), tcx.types.i128),\n-            Isize(v) => {\n-                let i = v.as_i64(ccx.tcx().sess.target.int_type);\n-                (C_integral(Type::int(ccx), i as u64, true), tcx.types.isize)\n-            },\n-            U8(v) => (C_integral(Type::i8(ccx), v as u64, false), tcx.types.u8),\n-            U16(v) => (C_integral(Type::i16(ccx), v as u64, false), tcx.types.u16),\n-            U32(v) => (C_integral(Type::i32(ccx), v as u64, false), tcx.types.u32),\n-            U64(v) => (C_integral(Type::i64(ccx), v, false), tcx.types.u64),\n+            Isize(v) => (C_int(Type::isize(ccx), v.as_i64()), tcx.types.isize),\n+            U8(v) => (C_uint(Type::i8(ccx), v as u64), tcx.types.u8),\n+            U16(v) => (C_uint(Type::i16(ccx), v as u64), tcx.types.u16),\n+            U32(v) => (C_uint(Type::i32(ccx), v as u64), tcx.types.u32),\n+            U64(v) => (C_uint(Type::i64(ccx), v), tcx.types.u64),\n             U128(v) => (C_big_integral(Type::i128(ccx), v), tcx.types.u128),\n-            Usize(v) => {\n-                let u = v.as_u64(ccx.tcx().sess.target.uint_type);\n-                (C_integral(Type::int(ccx), u, false), tcx.types.usize)\n-            },\n+            Usize(v) => (C_uint(Type::isize(ccx), v.as_u64()), tcx.types.usize),\n         };\n         Const { llval: llval, ty: ty }\n     }\n@@ -106,7 +100,7 @@ impl<'tcx> Const<'tcx> {\n             ConstVal::Integral(ref i) => return Const::from_constint(ccx, i),\n             ConstVal::Str(ref v) => C_str_slice(ccx, v.clone()),\n             ConstVal::ByteStr(v) => consts::addr_of(ccx, C_bytes(ccx, v.data), 1, \"byte_str\"),\n-            ConstVal::Char(c) => C_integral(Type::char(ccx), c as u64, false),\n+            ConstVal::Char(c) => C_uint(Type::char(ccx), c as u64),\n             ConstVal::Function(..) => C_null(type_of::type_of(ccx, ty)),\n             ConstVal::Variant(_) |\n             ConstVal::Aggregate(..) => {\n@@ -206,7 +200,7 @@ impl<'tcx> ConstLvalue<'tcx> {\n \n     pub fn len<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> ValueRef {\n         match self.ty.sty {\n-            ty::TyArray(_, n) => C_uint(ccx, n),\n+            ty::TyArray(_, n) => C_usize(ccx, n.as_u64()),\n             ty::TySlice(_) | ty::TyStr => {\n                 assert!(self.llextra != ptr::null_mut());\n                 self.llextra\n@@ -366,13 +360,13 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                         let result = if fn_ty.fn_sig(tcx).abi() == Abi::RustIntrinsic {\n                             match &tcx.item_name(def_id)[..] {\n                                 \"size_of\" => {\n-                                    let llval = C_uint(self.ccx,\n+                                    let llval = C_usize(self.ccx,\n                                         self.ccx.size_of(substs.type_at(0)));\n                                     Ok(Const::new(llval, tcx.types.usize))\n                                 }\n                                 \"min_align_of\" => {\n-                                    let llval = C_uint(self.ccx,\n-                                        self.ccx.align_of(substs.type_at(0)));\n+                                    let llval = C_usize(self.ccx,\n+                                        self.ccx.align_of(substs.type_at(0)) as u64);\n                                     Ok(Const::new(llval, tcx.types.usize))\n                                 }\n                                 _ => span_bug!(span, \"{:?} in constant\", terminator.kind)\n@@ -556,9 +550,10 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n         let val = match *rvalue {\n             mir::Rvalue::Use(ref operand) => self.const_operand(operand, span)?,\n \n-            mir::Rvalue::Repeat(ref elem, ref count) => {\n+            mir::Rvalue::Repeat(ref elem, count) => {\n                 let elem = self.const_operand(elem, span)?;\n-                let size = count.as_u64(tcx.sess.target.uint_type);\n+                let size = count.as_u64();\n+                assert_eq!(size as usize as u64, size);\n                 let fields = vec![elem.llval; size as usize];\n                 self.const_array(dest_ty, &fields)\n             }\n@@ -835,7 +830,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n \n             mir::Rvalue::NullaryOp(mir::NullOp::SizeOf, ty) => {\n                 assert!(self.ccx.shared().type_is_sized(ty));\n-                let llval = C_uint(self.ccx, self.ccx.size_of(ty));\n+                let llval = C_usize(self.ccx, self.ccx.size_of(ty));\n                 Const::new(llval, tcx.types.usize)\n             }\n \n@@ -853,10 +848,10 @@ fn to_const_int(value: ValueRef, t: Ty, tcx: TyCtxt) -> Option<ConstInt> {\n     match t.sty {\n         ty::TyInt(int_type) => const_to_opt_u128(value, true)\n             .and_then(|input| ConstInt::new_signed(input as i128, int_type,\n-                                                   tcx.sess.target.int_type)),\n+                                                   tcx.sess.target.isize_ty)),\n         ty::TyUint(uint_type) => const_to_opt_u128(value, false)\n             .and_then(|input| ConstInt::new_unsigned(input, uint_type,\n-                                                     tcx.sess.target.uint_type)),\n+                                                     tcx.sess.target.usize_ty)),\n         _ => None\n \n     }\n@@ -1037,11 +1032,11 @@ fn trans_const<'a, 'tcx>(\n             };\n             assert_eq!(vals.len(), 0);\n             adt::assert_discr_in_range(min, max, discr);\n-            C_integral(Type::from_integer(ccx, d), discr, true)\n+            C_int(Type::from_integer(ccx, d), discr as i64)\n         }\n         layout::General { discr: d, ref variants, .. } => {\n             let variant = &variants[variant_index];\n-            let lldiscr = C_integral(Type::from_integer(ccx, d), variant_index as u64, true);\n+            let lldiscr = C_int(Type::from_integer(ccx, d), variant_index as i64);\n             let mut vals_with_discr = vec![lldiscr];\n             vals_with_discr.extend_from_slice(vals);\n             let mut contents = build_const_struct(ccx, &variant, &vals_with_discr[..]);"}, {"sha": "d34885a1e932658274673cc08f4a53649327baaf", "filename": "src/librustc_trans/mir/lvalue.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3ce31eb99076261291c1a0ae4b542f52e6ca0f0a/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce31eb99076261291c1a0ae4b542f52e6ca0f0a/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Flvalue.rs?ref=3ce31eb99076261291c1a0ae4b542f52e6ca0f0a", "patch": "@@ -16,7 +16,7 @@ use rustc::mir::tcx::LvalueTy;\n use rustc_data_structures::indexed_vec::Idx;\n use adt;\n use builder::Builder;\n-use common::{self, CrateContext, C_uint};\n+use common::{self, CrateContext, C_usize};\n use consts;\n use machine;\n use type_of;\n@@ -106,7 +106,7 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n     pub fn len(&self, ccx: &CrateContext<'a, 'tcx>) -> ValueRef {\n         let ty = self.ty.to_ty(ccx.tcx());\n         match ty.sty {\n-            ty::TyArray(_, n) => common::C_uint(ccx, n),\n+            ty::TyArray(_, n) => common::C_usize(ccx, n.as_u64()),\n             ty::TySlice(_) | ty::TyStr => {\n                 assert!(self.llextra != ptr::null_mut());\n                 self.llextra\n@@ -186,7 +186,7 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n \n \n         let offset = st.offsets[ix].bytes();\n-        let unaligned_offset = C_uint(bcx.ccx, offset);\n+        let unaligned_offset = C_usize(bcx.ccx, offset);\n \n         // Get the alignment of the field\n         let (_, align) = glue::size_and_align_of_dst(bcx, fty, meta);\n@@ -197,7 +197,7 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n         //   (unaligned offset + (align - 1)) & -align\n \n         // Calculate offset\n-        let align_sub_1 = bcx.sub(align, C_uint(bcx.ccx, 1u64));\n+        let align_sub_1 = bcx.sub(align, C_usize(bcx.ccx, 1));\n         let offset = bcx.and(bcx.add(unaligned_offset, align_sub_1),\n         bcx.neg(align));\n \n@@ -276,7 +276,7 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n             // Slices already point to the array element type.\n             bcx.inbounds_gep(self.llval, &[llindex])\n         } else {\n-            let zero = common::C_uint(bcx.ccx, 0u64);\n+            let zero = common::C_usize(bcx.ccx, 0);\n             bcx.inbounds_gep(self.llval, &[zero, llindex])\n         }\n     }\n@@ -342,19 +342,19 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     mir::ProjectionElem::ConstantIndex { offset,\n                                                          from_end: false,\n                                                          min_length: _ } => {\n-                        let lloffset = C_uint(bcx.ccx, offset);\n+                        let lloffset = C_usize(bcx.ccx, offset as u64);\n                         ((tr_base.project_index(bcx, lloffset), align), ptr::null_mut())\n                     }\n                     mir::ProjectionElem::ConstantIndex { offset,\n                                                          from_end: true,\n                                                          min_length: _ } => {\n-                        let lloffset = C_uint(bcx.ccx, offset);\n+                        let lloffset = C_usize(bcx.ccx, offset as u64);\n                         let lllen = tr_base.len(bcx.ccx);\n                         let llindex = bcx.sub(lllen, lloffset);\n                         ((tr_base.project_index(bcx, llindex), align), ptr::null_mut())\n                     }\n                     mir::ProjectionElem::Subslice { from, to } => {\n-                        let llbase = tr_base.project_index(bcx, C_uint(bcx.ccx, from));\n+                        let llbase = tr_base.project_index(bcx, C_usize(bcx.ccx, from as u64));\n \n                         let base_ty = tr_base.ty.to_ty(bcx.tcx());\n                         match base_ty.sty {\n@@ -369,7 +369,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                             ty::TySlice(..) => {\n                                 assert!(tr_base.llextra != ptr::null_mut());\n                                 let lllen = bcx.sub(tr_base.llextra,\n-                                                    C_uint(bcx.ccx, from+to));\n+                                                    C_usize(bcx.ccx, (from as u64)+(to as u64)));\n                                 ((llbase, align), lllen)\n                             }\n                             _ => bug!(\"unexpected type {:?} in Subslice\", base_ty)\n@@ -397,11 +397,11 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     /// nmatsakis: is this still necessary? Not sure.\n     fn prepare_index(&mut self, bcx: &Builder<'a, 'tcx>, llindex: ValueRef) -> ValueRef {\n         let index_size = machine::llbitsize_of_real(bcx.ccx, common::val_ty(llindex));\n-        let int_size = machine::llbitsize_of_real(bcx.ccx, bcx.ccx.int_type());\n+        let int_size = machine::llbitsize_of_real(bcx.ccx, bcx.ccx.isize_ty());\n         if index_size < int_size {\n-            bcx.zext(llindex, bcx.ccx.int_type())\n+            bcx.zext(llindex, bcx.ccx.isize_ty())\n         } else if index_size > int_size {\n-            bcx.trunc(llindex, bcx.ccx.int_type())\n+            bcx.trunc(llindex, bcx.ccx.isize_ty())\n         } else {\n             llindex\n         }"}, {"sha": "0f2d0c7f296177e877184863d09f6001601a3dcc", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/3ce31eb99076261291c1a0ae4b542f52e6ca0f0a/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce31eb99076261291c1a0ae4b542f52e6ca0f0a/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=3ce31eb99076261291c1a0ae4b542f52e6ca0f0a", "patch": "@@ -19,8 +19,7 @@ use rustc::middle::lang_items::ExchangeMallocFnLangItem;\n use base;\n use builder::Builder;\n use callee;\n-use common::{self, val_ty, C_bool, C_null, C_uint};\n-use common::{C_integral, C_i32};\n+use common::{self, val_ty, C_bool, C_i32, C_null, C_usize, C_uint};\n use adt;\n use machine;\n use monomorphize;\n@@ -92,7 +91,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 bcx\n             }\n \n-            mir::Rvalue::Repeat(ref elem, ref count) => {\n+            mir::Rvalue::Repeat(ref elem, count) => {\n                 let dest_ty = dest.ty.to_ty(bcx.tcx());\n \n                 // No need to inizialize memory of a zero-sized slice\n@@ -101,8 +100,8 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 }\n \n                 let tr_elem = self.trans_operand(&bcx, elem);\n-                let size = count.as_u64(bcx.tcx().sess.target.uint_type);\n-                let size = C_uint(bcx.ccx, size);\n+                let size = count.as_u64();\n+                let size = C_usize(bcx.ccx, size);\n                 let base = base::get_dataptr(&bcx, dest.llval);\n                 let align = dest.alignment.to_align();\n \n@@ -113,7 +112,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                         let align = C_i32(bcx.ccx, align as i32);\n                         let ty = type_of::type_of(bcx.ccx, dest_ty);\n                         let size = machine::llsize_of(bcx.ccx, ty);\n-                        let fill = C_integral(Type::i8(bcx.ccx), 0, false);\n+                        let fill = C_uint(Type::i8(bcx.ccx), 0);\n                         base::call_memset(&bcx, base, fill, size, align, false);\n                         return bcx;\n                     }\n@@ -301,7 +300,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                                 base::call_assume(&bcx, bcx.icmp(\n                                     llvm::IntULE,\n                                     llval,\n-                                    C_integral(common::val_ty(llval), max, false)\n+                                    C_uint(common::val_ty(llval), max)\n                                 ));\n                             }\n \n@@ -464,7 +463,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n             mir::Rvalue::NullaryOp(mir::NullOp::SizeOf, ty) => {\n                 assert!(bcx.ccx.shared().type_is_sized(ty));\n-                let val = C_uint(bcx.ccx, bcx.ccx.size_of(ty));\n+                let val = C_usize(bcx.ccx, bcx.ccx.size_of(ty));\n                 let tcx = bcx.tcx();\n                 (bcx, OperandRef {\n                     val: OperandValue::Immediate(val),\n@@ -477,7 +476,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 let llty = type_of::type_of(bcx.ccx, content_ty);\n                 let llsize = machine::llsize_of(bcx.ccx, llty);\n                 let align = bcx.ccx.align_of(content_ty);\n-                let llalign = C_uint(bcx.ccx, align);\n+                let llalign = C_usize(bcx.ccx, align as u64);\n                 let llty_ptr = llty.ptr_to();\n                 let box_ty = bcx.tcx().mk_box(content_ty);\n \n@@ -522,7 +521,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             if let LocalRef::Operand(Some(op)) = self.locals[index] {\n                 if common::type_is_zero_size(bcx.ccx, op.ty) {\n                     if let ty::TyArray(_, n) = op.ty.sty {\n-                        return common::C_uint(bcx.ccx, n);\n+                        return common::C_usize(bcx.ccx, n.as_u64());\n                     }\n                 }\n             }"}, {"sha": "da4a4e55a67f4819356305a7b692979f8006b1af", "filename": "src/librustc_trans/tvec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3ce31eb99076261291c1a0ae4b542f52e6ca0f0a/src%2Flibrustc_trans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce31eb99076261291c1a0ae4b542f52e6ca0f0a/src%2Flibrustc_trans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftvec.rs?ref=3ce31eb99076261291c1a0ae4b542f52e6ca0f0a", "patch": "@@ -34,7 +34,7 @@ pub fn slice_for_each<'a, 'tcx, F>(\n     let next_bcx = bcx.build_sibling_block(\"slice_loop_next\");\n \n     let start = if zst {\n-        C_uint(bcx.ccx, 0usize)\n+        C_usize(bcx.ccx, 1)\n     } else {\n         data_ptr\n     };\n@@ -46,7 +46,7 @@ pub fn slice_for_each<'a, 'tcx, F>(\n     let keep_going = header_bcx.icmp(llvm::IntNE, current, end);\n     header_bcx.cond_br(keep_going, body_bcx.llbb(), next_bcx.llbb());\n \n-    let next = add(&body_bcx, current, C_uint(bcx.ccx, 1usize));\n+    let next = add(&body_bcx, current, C_usize(bcx.ccx, 1));\n     f(&body_bcx, if zst { data_ptr } else { current }, header_bcx.llbb());\n     header_bcx.add_incoming_to_phi(current, next, body_bcx.llbb());\n     next_bcx"}, {"sha": "e5e532703d7d002ecf3a245ec6c6cd2bdb0b0a62", "filename": "src/librustc_trans/type_.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3ce31eb99076261291c1a0ae4b542f52e6ca0f0a/src%2Flibrustc_trans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce31eb99076261291c1a0ae4b542f52e6ca0f0a/src%2Flibrustc_trans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_.rs?ref=3ce31eb99076261291c1a0ae4b542f52e6ca0f0a", "patch": "@@ -131,7 +131,7 @@ impl Type {\n         Type::i8_llcx(llcx).ptr_to()\n     }\n \n-    pub fn int(ccx: &CrateContext) -> Type {\n+    pub fn isize(ccx: &CrateContext) -> Type {\n         match &ccx.tcx().sess.target.target.target_pointer_width[..] {\n             \"16\" => Type::i16(ccx),\n             \"32\" => Type::i32(ccx),\n@@ -142,7 +142,7 @@ impl Type {\n \n     pub fn int_from_ty(ccx: &CrateContext, t: ast::IntTy) -> Type {\n         match t {\n-            ast::IntTy::Is => ccx.int_type(),\n+            ast::IntTy::Is => ccx.isize_ty(),\n             ast::IntTy::I8 => Type::i8(ccx),\n             ast::IntTy::I16 => Type::i16(ccx),\n             ast::IntTy::I32 => Type::i32(ccx),\n@@ -153,7 +153,7 @@ impl Type {\n \n     pub fn uint_from_ty(ccx: &CrateContext, t: ast::UintTy) -> Type {\n         match t {\n-            ast::UintTy::Us => ccx.int_type(),\n+            ast::UintTy::Us => ccx.isize_ty(),\n             ast::UintTy::U8 => Type::i8(ccx),\n             ast::UintTy::U16 => Type::i16(ccx),\n             ast::UintTy::U32 => Type::i32(ccx),\n@@ -207,7 +207,7 @@ impl Type {\n \n     pub fn vec(ccx: &CrateContext, ty: &Type) -> Type {\n         Type::struct_(ccx,\n-            &[Type::array(ty, 0), Type::int(ccx)],\n+            &[Type::array(ty, 0), Type::isize(ccx)],\n         false)\n     }\n "}, {"sha": "149a55f8c05d5bee9d3a9994a6947f013c48daf5", "filename": "src/librustc_trans/type_of.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3ce31eb99076261291c1a0ae4b542f52e6ca0f0a/src%2Flibrustc_trans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce31eb99076261291c1a0ae4b542f52e6ca0f0a/src%2Flibrustc_trans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_of.rs?ref=3ce31eb99076261291c1a0ae4b542f52e6ca0f0a", "patch": "@@ -148,9 +148,8 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n       }\n \n       ty::TyArray(ty, size) => {\n-          let size = size as u64;\n           let llty = in_memory_type_of(cx, ty);\n-          Type::array(&llty, size)\n+          Type::array(&llty, size.as_u64())\n       }\n \n       // Unsized slice types (and str) have the type of their element, and"}, {"sha": "fc05ce4cd662cd5f40ac708b510a3ec19b397f83", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ce31eb99076261291c1a0ae4b542f52e6ca0f0a/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce31eb99076261291c1a0ae4b542f52e6ca0f0a/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=3ce31eb99076261291c1a0ae4b542f52e6ca0f0a", "patch": "@@ -1083,7 +1083,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             }\n             hir::TyArray(ref ty, length) => {\n                 if let Ok(length) = eval_length(tcx, length, \"array length\") {\n-                    tcx.mk_array(self.ast_ty_to_ty(&ty), length)\n+                    tcx.mk_array(self.ast_ty_to_ty(&ty), length.as_u64())\n                 } else {\n                     self.tcx().types.err\n                 }"}, {"sha": "02017652a6c71715e482d1658f10820ed73e3b0e", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3ce31eb99076261291c1a0ae4b542f52e6ca0f0a/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce31eb99076261291c1a0ae4b542f52e6ca0f0a/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=3ce31eb99076261291c1a0ae4b542f52e6ca0f0a", "patch": "@@ -264,7 +264,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 let expected_ty = self.structurally_resolved_type(pat.span, expected);\n                 let (inner_ty, slice_ty) = match expected_ty.sty {\n                     ty::TyArray(inner_ty, size) => {\n-                        let min_len = before.len() + after.len();\n+                        let size = size.as_u64();\n+                        let min_len = before.len() as u64 + after.len() as u64;\n                         if slice.is_none() {\n                             if min_len != size {\n                                 struct_span_err!("}, {"sha": "fa8d3b9bcc1cb41cc2eb5df9f32285a90d9c9b96", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ce31eb99076261291c1a0ae4b542f52e6ca0f0a/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce31eb99076261291c1a0ae4b542f52e6ca0f0a/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=3ce31eb99076261291c1a0ae4b542f52e6ca0f0a", "patch": "@@ -360,7 +360,7 @@ pub fn check_platform_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             match name[\"simd_shuffle\".len()..].parse() {\n                 Ok(n) => {\n                     let params = vec![param(0), param(0),\n-                                      tcx.mk_ty(ty::TyArray(tcx.types.u32, n))];\n+                                      tcx.mk_array(tcx.types.u32, n)];\n                     (2, params, param(1))\n                 }\n                 Err(_) => {"}, {"sha": "0adfca6e886a7d43bbbdf7499e5e9b9116d49b5b", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/3ce31eb99076261291c1a0ae4b542f52e6ca0f0a/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce31eb99076261291c1a0ae4b542f52e6ca0f0a/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=3ce31eb99076261291c1a0ae4b542f52e6ca0f0a", "patch": "@@ -2636,7 +2636,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             ast::LitKind::Str(..) => tcx.mk_static_str(),\n             ast::LitKind::ByteStr(ref v) => {\n                 tcx.mk_imm_ref(tcx.types.re_static,\n-                                tcx.mk_array(tcx.types.u8, v.len()))\n+                                tcx.mk_array(tcx.types.u8, v.len() as u64))\n             }\n             ast::LitKind::Byte(_) => tcx.types.u8,\n             ast::LitKind::Char(_) => tcx.types.char,\n@@ -3895,11 +3895,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n               } else {\n                   self.next_ty_var(TypeVariableOrigin::TypeInference(expr.span))\n               };\n-              tcx.mk_array(element_ty, args.len())\n+              tcx.mk_array(element_ty, args.len() as u64)\n           }\n           hir::ExprRepeat(ref element, count) => {\n-            let count = eval_length(self.tcx, count, \"repeat count\")\n-                  .unwrap_or(0);\n+            let count = eval_length(self.tcx, count, \"repeat count\");\n \n             let uty = match expected {\n                 ExpectHasType(uty) => {\n@@ -3923,17 +3922,21 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n             };\n \n-            if count > 1 {\n-                // For [foo, ..n] where n > 1, `foo` must have\n-                // Copy type:\n-                let lang_item = self.tcx.require_lang_item(lang_items::CopyTraitLangItem);\n-                self.require_type_meets(t, expr.span, traits::RepeatVec, lang_item);\n+            if let Ok(count) = count {\n+                if count.as_u64() > 1 {\n+                    // For [foo, ..n] where n > 1, `foo` must have\n+                    // Copy type:\n+                    let lang_item = self.tcx.require_lang_item(lang_items::CopyTraitLangItem);\n+                    self.require_type_meets(t, expr.span, traits::RepeatVec, lang_item);\n+                }\n             }\n \n             if element_ty.references_error() {\n                 tcx.types.err\n+            } else if let Ok(count) = count {\n+                tcx.mk_ty(ty::TyArray(t, count))\n             } else {\n-                tcx.mk_array(t, count)\n+                tcx.types.err\n             }\n           }\n           hir::ExprTup(ref elts) => {"}, {"sha": "a78f15dd283c3d674cebeec17d5d011b695a03ac", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3ce31eb99076261291c1a0ae4b542f52e6ca0f0a/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce31eb99076261291c1a0ae4b542f52e6ca0f0a/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=3ce31eb99076261291c1a0ae4b542f52e6ca0f0a", "patch": "@@ -1555,7 +1555,7 @@ pub enum Type {\n     BareFunction(Box<BareFunctionDecl>),\n     Tuple(Vec<Type>),\n     Slice(Box<Type>),\n-    Array(Box<Type>, usize),\n+    Array(Box<Type>, String),\n     Never,\n     Unique(Box<Type>),\n     RawPointer(Mutability, Box<Type>),\n@@ -1785,7 +1785,7 @@ impl Clean<Type> for hir::Ty {\n             TyArray(ref ty, length) => {\n                 use rustc::middle::const_val::eval_length;\n                 let n = eval_length(cx.tcx, length, \"array length\").unwrap();\n-                Array(box ty.clean(cx), n)\n+                Array(box ty.clean(cx), n.to_string())\n             },\n             TyTup(ref tys) => Tuple(tys.clean(cx)),\n             TyPath(hir::QPath::Resolved(None, ref path)) => {\n@@ -1895,7 +1895,7 @@ impl<'tcx> Clean<Type> for ty::Ty<'tcx> {\n             ty::TyFloat(float_ty) => Primitive(float_ty.into()),\n             ty::TyStr => Primitive(PrimitiveType::Str),\n             ty::TySlice(ty) => Slice(box ty.clean(cx)),\n-            ty::TyArray(ty, n) => Array(box ty.clean(cx), n),\n+            ty::TyArray(ty, n) => Array(box ty.clean(cx), n.to_string()),\n             ty::TyRawPtr(mt) => RawPointer(mt.mutbl.clean(cx), box mt.ty.clean(cx)),\n             ty::TyRef(r, mt) => BorrowedRef {\n                 lifetime: r.clean(cx),"}, {"sha": "6303fd662bf2b02871540c151be9e507422bbdd9", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ce31eb99076261291c1a0ae4b542f52e6ca0f0a/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce31eb99076261291c1a0ae4b542f52e6ca0f0a/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=3ce31eb99076261291c1a0ae4b542f52e6ca0f0a", "patch": "@@ -633,7 +633,7 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter, use_absolute: bool) -> fmt:\n             fmt::Display::fmt(t, f)?;\n             primitive_link(f, PrimitiveType::Slice, \"]\")\n         }\n-        clean::Array(ref t, n) => {\n+        clean::Array(ref t, ref n) => {\n             primitive_link(f, PrimitiveType::Array, \"[\")?;\n             fmt::Display::fmt(t, f)?;\n             primitive_link(f, PrimitiveType::Array, &format!(\"; {}]\", n))"}]}