{"sha": "f3a87a7f1ff8089742bc8dc45b812dd844109034", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYzYTg3YTdmMWZmODA4OTc0MmJjOGRjNDViODEyZGQ4NDQxMDkwMzQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-10T07:11:25Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-10T07:11:25Z"}, "message": "auto merge of #12143 : brson/rust/swap, r=alexcrichton\n\nThinking about swap as an example of unsafe programming. This cleans it up a bit. It also removes type parametrization over `RawPtr` from the memcpy functions to make this compile.", "tree": {"sha": "f241823947117020a0ea0375f67099a13a2a2119", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f241823947117020a0ea0375f67099a13a2a2119"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f3a87a7f1ff8089742bc8dc45b812dd844109034", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f3a87a7f1ff8089742bc8dc45b812dd844109034", "html_url": "https://github.com/rust-lang/rust/commit/f3a87a7f1ff8089742bc8dc45b812dd844109034", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f3a87a7f1ff8089742bc8dc45b812dd844109034/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5bad63cef541d295e1fc4e4246d493f9837e0d18", "url": "https://api.github.com/repos/rust-lang/rust/commits/5bad63cef541d295e1fc4e4246d493f9837e0d18", "html_url": "https://github.com/rust-lang/rust/commit/5bad63cef541d295e1fc4e4246d493f9837e0d18"}, {"sha": "07c5e5d81363b6cdbca64637832620ab4870d258", "url": "https://api.github.com/repos/rust-lang/rust/commits/07c5e5d81363b6cdbca64637832620ab4870d258", "html_url": "https://github.com/rust-lang/rust/commit/07c5e5d81363b6cdbca64637832620ab4870d258"}], "stats": {"total": 52, "additions": 24, "deletions": 28}, "files": [{"sha": "ffdd70a6c144a6f0e300048d7f872ccd3a5ff085", "filename": "src/libstd/cast.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f3a87a7f1ff8089742bc8dc45b812dd844109034/src%2Flibstd%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3a87a7f1ff8089742bc8dc45b812dd844109034/src%2Flibstd%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcast.rs?ref=f3a87a7f1ff8089742bc8dc45b812dd844109034", "patch": "@@ -10,7 +10,6 @@\n \n //! Unsafe casting functions\n \n-use ptr::RawPtr;\n use mem;\n use unstable::intrinsics;\n use ptr::copy_nonoverlapping_memory;\n@@ -72,13 +71,13 @@ pub unsafe fn transmute_region<'a,'b,T>(ptr: &'a T) -> &'b T {\n \n /// Coerce an immutable reference to be mutable.\n #[inline]\n-pub unsafe fn transmute_mut_unsafe<T,P:RawPtr<T>>(ptr: P) -> *mut T {\n+pub unsafe fn transmute_mut_unsafe<T>(ptr: *T) -> *mut T {\n     transmute(ptr)\n }\n \n /// Coerce an immutable reference to be mutable.\n #[inline]\n-pub unsafe fn transmute_immut_unsafe<T,P:RawPtr<T>>(ptr: P) -> *T {\n+pub unsafe fn transmute_immut_unsafe<T>(ptr: *mut T) -> *T {\n     transmute(ptr)\n }\n "}, {"sha": "484f81f277f21377d3dcb640cc9f8e786739a49b", "filename": "src/libstd/ptr.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f3a87a7f1ff8089742bc8dc45b812dd844109034/src%2Flibstd%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3a87a7f1ff8089742bc8dc45b812dd844109034/src%2Flibstd%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fptr.rs?ref=f3a87a7f1ff8089742bc8dc45b812dd844109034", "patch": "@@ -92,8 +92,8 @@ pub fn is_not_null<T,P:RawPtr<T>>(ptr: P) -> bool { ptr.is_not_null() }\n  * and destination may overlap.\n  */\n #[inline]\n-pub unsafe fn copy_memory<T,P:RawPtr<T>>(dst: *mut T, src: P, count: uint) {\n-    intrinsics::copy_memory(dst, cast::transmute_immut_unsafe(src), count)\n+pub unsafe fn copy_memory<T>(dst: *mut T, src: *T, count: uint) {\n+    intrinsics::copy_memory(dst, src, count)\n }\n \n /**\n@@ -103,10 +103,10 @@ pub unsafe fn copy_memory<T,P:RawPtr<T>>(dst: *mut T, src: P, count: uint) {\n  * and destination may *not* overlap.\n  */\n #[inline]\n-pub unsafe fn copy_nonoverlapping_memory<T,P:RawPtr<T>>(dst: *mut T,\n-                                                        src: P,\n-                                                        count: uint) {\n-    intrinsics::copy_nonoverlapping_memory(dst, cast::transmute_immut_unsafe(src), count)\n+pub unsafe fn copy_nonoverlapping_memory<T>(dst: *mut T,\n+                                            src: *T,\n+                                            count: uint) {\n+    intrinsics::copy_nonoverlapping_memory(dst, src, count)\n }\n \n /**\n@@ -137,9 +137,9 @@ pub unsafe fn swap_ptr<T>(x: *mut T, y: *mut T) {\n     let t: *mut T = &mut tmp;\n \n     // Perform the swap\n-    copy_nonoverlapping_memory(t, x, 1);\n-    copy_memory(x, y, 1); // `x` and `y` may overlap\n-    copy_nonoverlapping_memory(y, t, 1);\n+    copy_nonoverlapping_memory(t, &*x, 1);\n+    copy_memory(x, &*y, 1); // `x` and `y` may overlap\n+    copy_nonoverlapping_memory(y, &*t, 1);\n \n     // y and t now point to the same thing, but we need to completely forget `tmp`\n     // because it's no longer relevant."}, {"sha": "644b5cefdc8762a24225774b336b3c87c59f7478", "filename": "src/libstd/util.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f3a87a7f1ff8089742bc8dc45b812dd844109034/src%2Flibstd%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3a87a7f1ff8089742bc8dc45b812dd844109034/src%2Flibstd%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Futil.rs?ref=f3a87a7f1ff8089742bc8dc45b812dd844109034", "patch": "@@ -26,19 +26,16 @@ pub fn id<T>(x: T) -> T { x }\n pub fn swap<T>(x: &mut T, y: &mut T) {\n     unsafe {\n         // Give ourselves some scratch space to work with\n-        let mut tmp: T = mem::uninit();\n-        let t: *mut T = &mut tmp;\n+        let mut t: T = mem::uninit();\n \n         // Perform the swap, `&mut` pointers never alias\n-        let x_raw: *mut T = x;\n-        let y_raw: *mut T = y;\n-        ptr::copy_nonoverlapping_memory(t, x_raw, 1);\n-        ptr::copy_nonoverlapping_memory(x, y_raw, 1);\n-        ptr::copy_nonoverlapping_memory(y, t, 1);\n+        ptr::copy_nonoverlapping_memory(&mut t, &*x, 1);\n+        ptr::copy_nonoverlapping_memory(x, &*y, 1);\n+        ptr::copy_nonoverlapping_memory(y, &t, 1);\n \n         // y and t now point to the same thing, but we need to completely forget `tmp`\n         // because it's no longer relevant.\n-        cast::forget(tmp);\n+        cast::forget(t);\n     }\n }\n "}, {"sha": "de865434a3e5e000b77ee164cd7a868eed7727e5", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f3a87a7f1ff8089742bc8dc45b812dd844109034/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3a87a7f1ff8089742bc8dc45b812dd844109034/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=f3a87a7f1ff8089742bc8dc45b812dd844109034", "patch": "@@ -1548,7 +1548,7 @@ impl<T> OwnedVector<T> for ~[T] {\n             let p = self.as_mut_ptr().offset(i as int);\n             // Shift everything over to make space. (Duplicating the\n             // `i`th element into two consecutive places.)\n-            ptr::copy_memory(p.offset(1), p, len - i);\n+            ptr::copy_memory(p.offset(1), &*p, len - i);\n             // Write it in, overwriting the first copy of the `i`th\n             // element.\n             mem::move_val_init(&mut *p, x);\n@@ -1567,7 +1567,7 @@ impl<T> OwnedVector<T> for ~[T] {\n                 let ret = Some(ptr::read_ptr(ptr as *T));\n \n                 // Shift everything down to fill in that spot.\n-                ptr::copy_memory(ptr, ptr.offset(1), len - i - 1);\n+                ptr::copy_memory(ptr, &*ptr.offset(1), len - i - 1);\n                 self.set_len(len - 1);\n \n                 ret\n@@ -1842,7 +1842,7 @@ fn insertion_sort<T>(v: &mut [T], compare: |&T, &T| -> Ordering) {\n             if i != j {\n                 let tmp = ptr::read_ptr(read_ptr);\n                 ptr::copy_memory(buf_v.offset(j + 1),\n-                                 buf_v.offset(j),\n+                                 &*buf_v.offset(j),\n                                  (i - j) as uint);\n                 ptr::copy_nonoverlapping_memory(buf_v.offset(j),\n                                                 &tmp as *T,\n@@ -1920,7 +1920,7 @@ fn merge_sort<T>(v: &mut [T], compare: |&T, &T| -> Ordering) {\n                 // that case, `i == j` so we don't copy. The\n                 // `.offset(j)` is always in bounds.\n                 ptr::copy_memory(buf_dat.offset(j + 1),\n-                                 buf_dat.offset(j),\n+                                 &*buf_dat.offset(j),\n                                  i - j as uint);\n                 ptr::copy_nonoverlapping_memory(buf_dat.offset(j), read_ptr, 1);\n             }\n@@ -1970,11 +1970,11 @@ fn merge_sort<T>(v: &mut [T], compare: |&T, &T| -> Ordering) {\n                     if left == right_start {\n                         // the number remaining in this run.\n                         let elems = (right_end as uint - right as uint) / mem::size_of::<T>();\n-                        ptr::copy_nonoverlapping_memory(out, right, elems);\n+                        ptr::copy_nonoverlapping_memory(out, &*right, elems);\n                         break;\n                     } else if right == right_end {\n                         let elems = (right_start as uint - left as uint) / mem::size_of::<T>();\n-                        ptr::copy_nonoverlapping_memory(out, left, elems);\n+                        ptr::copy_nonoverlapping_memory(out, &*left, elems);\n                         break;\n                     }\n \n@@ -1988,7 +1988,7 @@ fn merge_sort<T>(v: &mut [T], compare: |&T, &T| -> Ordering) {\n                     } else {\n                         step(&mut left)\n                     };\n-                    ptr::copy_nonoverlapping_memory(out, to_copy, 1);\n+                    ptr::copy_nonoverlapping_memory(out, &*to_copy, 1);\n                     step(&mut out);\n                 }\n             }\n@@ -2002,7 +2002,7 @@ fn merge_sort<T>(v: &mut [T], compare: |&T, &T| -> Ordering) {\n     // write the result to `v` in one go, so that there are never two copies\n     // of the same object in `v`.\n     unsafe {\n-        ptr::copy_nonoverlapping_memory(v.as_mut_ptr(), buf_dat, len);\n+        ptr::copy_nonoverlapping_memory(v.as_mut_ptr(), &*buf_dat, len);\n     }\n \n     // increment the pointer, returning the old pointer."}]}