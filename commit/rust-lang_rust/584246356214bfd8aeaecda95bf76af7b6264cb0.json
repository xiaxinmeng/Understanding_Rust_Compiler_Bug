{"sha": "584246356214bfd8aeaecda95bf76af7b6264cb0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU4NDI0NjM1NjIxNGJmZDhhZWFlY2RhOTViZjc2YWY3YjYyNjRjYjA=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-no-reply-9879165716479413131@oli-obk.de", "date": "2017-04-12T09:06:32Z"}, "committer": {"name": "Oliver Schneider", "email": "git-no-reply-9879165716479413131@oli-obk.de", "date": "2017-04-12T09:06:32Z"}, "message": "Run rustfmt", "tree": {"sha": "1dae197d0371d5f5b4ef6b840a92785789d77423", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1dae197d0371d5f5b4ef6b840a92785789d77423"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/584246356214bfd8aeaecda95bf76af7b6264cb0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/584246356214bfd8aeaecda95bf76af7b6264cb0", "html_url": "https://github.com/rust-lang/rust/commit/584246356214bfd8aeaecda95bf76af7b6264cb0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/584246356214bfd8aeaecda95bf76af7b6264cb0/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "81401ddc8ceaeb82fa49e9dfd221910f5240c497", "url": "https://api.github.com/repos/rust-lang/rust/commits/81401ddc8ceaeb82fa49e9dfd221910f5240c497", "html_url": "https://github.com/rust-lang/rust/commit/81401ddc8ceaeb82fa49e9dfd221910f5240c497"}], "stats": {"total": 386, "additions": 219, "deletions": 167}, "files": [{"sha": "6fe089cf91657fa445e0124dd0c0d0defdc87e96", "filename": "clippy_lints/src/copies.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/584246356214bfd8aeaecda95bf76af7b6264cb0/clippy_lints%2Fsrc%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/584246356214bfd8aeaecda95bf76af7b6264cb0/clippy_lints%2Fsrc%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcopies.rs?ref=584246356214bfd8aeaecda95bf76af7b6264cb0", "patch": "@@ -223,7 +223,7 @@ fn lint_match_arms(cx: &LateContext, expr: &Expr) {\n /// `if a { c } else if b { d } else { e }`.\n fn if_sequence(mut expr: &Expr) -> (SmallVector<&Expr>, SmallVector<&Block>) {\n     let mut conds = SmallVector::new();\n-    let mut blocks : SmallVector<&Block> = SmallVector::new();\n+    let mut blocks: SmallVector<&Block> = SmallVector::new();\n \n     while let ExprIf(ref cond, ref then_expr, ref else_expr) = expr.node {\n         conds.push(&**cond);\n@@ -315,10 +315,10 @@ fn search_same<T, Hash, Eq>(exprs: &[T], hash: Hash, eq: Eq) -> Option<(&T, &T)>\n         return None;\n     } else if exprs.len() == 2 {\n         return if eq(&exprs[0], &exprs[1]) {\n-                   Some((&exprs[0], &exprs[1]))\n-               } else {\n-                   None\n-               };\n+            Some((&exprs[0], &exprs[1]))\n+        } else {\n+            None\n+        };\n     }\n \n     let mut map: HashMap<_, Vec<&_>> = HashMap::with_capacity(exprs.len());"}, {"sha": "73d9f8ba16171d51a883dfed295a1bcedb768bb5", "filename": "clippy_lints/src/entry.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/584246356214bfd8aeaecda95bf76af7b6264cb0/clippy_lints%2Fsrc%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/584246356214bfd8aeaecda95bf76af7b6264cb0/clippy_lints%2Fsrc%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fentry.rs?ref=584246356214bfd8aeaecda95bf76af7b6264cb0", "patch": "@@ -46,11 +46,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for HashMapLint {\n                 if let Some((ty, map, key)) = check_cond(cx, check) {\n                     // in case of `if !m.contains_key(&k) { m.insert(k, v); }`\n                     // we can give a better error message\n-                    let sole_expr =  {\n+                    let sole_expr = {\n                         else_block.is_none() &&\n                         if let ExprBlock(ref then_block) = then_block.node {\n                             (then_block.expr.is_some() as usize) + then_block.stmts.len() == 1\n-                        }  else {\n+                        } else {\n                             true\n                         }\n                     };"}, {"sha": "764bcded5ede10baa73ab7490fa8e76f7e42109c", "filename": "clippy_lints/src/eq_op.rs", "status": "modified", "additions": 45, "deletions": 52, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/584246356214bfd8aeaecda95bf76af7b6264cb0/clippy_lints%2Fsrc%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/584246356214bfd8aeaecda95bf76af7b6264cb0/clippy_lints%2Fsrc%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feq_op.rs?ref=584246356214bfd8aeaecda95bf76af7b6264cb0", "patch": "@@ -56,29 +56,24 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EqOp {\n             if is_valid_operator(op) {\n                 if SpanlessEq::new(cx).ignore_fn().eq_expr(left, right) {\n                     span_lint(cx,\n-                            EQ_OP,\n-                            e.span,\n-                            &format!(\"equal expressions as operands to `{}`\", op.node.as_str()));\n+                              EQ_OP,\n+                              e.span,\n+                              &format!(\"equal expressions as operands to `{}`\", op.node.as_str()));\n                 } else {\n                     let trait_id = match op.node {\n                         BiAdd => cx.tcx.lang_items.add_trait(),\n                         BiSub => cx.tcx.lang_items.sub_trait(),\n                         BiMul => cx.tcx.lang_items.mul_trait(),\n                         BiDiv => cx.tcx.lang_items.div_trait(),\n                         BiRem => cx.tcx.lang_items.rem_trait(),\n-                        BiAnd |\n-                        BiOr => None,\n+                        BiAnd | BiOr => None,\n                         BiBitXor => cx.tcx.lang_items.bitxor_trait(),\n                         BiBitAnd => cx.tcx.lang_items.bitand_trait(),\n                         BiBitOr => cx.tcx.lang_items.bitor_trait(),\n                         BiShl => cx.tcx.lang_items.shl_trait(),\n                         BiShr => cx.tcx.lang_items.shr_trait(),\n-                        BiNe |\n-                        BiEq => cx.tcx.lang_items.eq_trait(),\n-                        BiLt |\n-                        BiLe |\n-                        BiGe |\n-                        BiGt => cx.tcx.lang_items.ord_trait(),\n+                        BiNe | BiEq => cx.tcx.lang_items.eq_trait(),\n+                        BiLt | BiLe | BiGe | BiGt => cx.tcx.lang_items.ord_trait(),\n                     };\n                     if let Some(trait_id) = trait_id {\n                         #[allow(match_same_arms)]\n@@ -90,57 +85,55 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EqOp {\n                             (&ExprAddrOf(_, ref l), &ExprAddrOf(_, ref r)) => {\n                                 if implements_trait(cx, cx.tables.expr_ty(l), trait_id, &[cx.tables.expr_ty(r)], None) {\n                                     span_lint_and_then(cx,\n-                                        OP_REF,\n-                                        e.span,\n-                                        \"taken reference of both operands, which is done automatically by the operator anyway\",\n-                                        |db| {\n-                                            let lsnip = snippet(cx, l.span, \"...\").to_string();\n-                                            let rsnip = snippet(cx, r.span, \"...\").to_string();\n-                                            multispan_sugg(db,\n-                                                        \"use the values directly\".to_string(),\n-                                                        vec![(left.span, lsnip),\n+                                                       OP_REF,\n+                                                       e.span,\n+                                                       \"taken reference of both operands, which is done automatically \\\n+                                                        by the operator anyway\",\n+                                                       |db| {\n+                                        let lsnip = snippet(cx, l.span, \"...\").to_string();\n+                                        let rsnip = snippet(cx, r.span, \"...\").to_string();\n+                                        multispan_sugg(db,\n+                                                       \"use the values directly\".to_string(),\n+                                                       vec![(left.span, lsnip),\n                                                             (right.span, rsnip)]);\n-                                        }\n-                                    )\n+                                    })\n                                 }\n-                            }\n+                            },\n                             // &foo == bar\n                             (&ExprAddrOf(_, ref l), _) => {\n-                                if implements_trait(cx, cx.tables.expr_ty(l), trait_id, &[cx.tables.expr_ty(right)], None) {\n-                                    span_lint_and_then(cx,\n-                                        OP_REF,\n-                                        e.span,\n-                                        \"taken reference of left operand\",\n-                                        |db| {\n-                                            let lsnip = snippet(cx, l.span, \"...\").to_string();\n-                                            let rsnip = Sugg::hir(cx, right, \"...\").deref().to_string();\n-                                            multispan_sugg(db,\n-                                                        \"dereference the right operand instead\".to_string(),\n-                                                        vec![(left.span, lsnip),\n+                                if implements_trait(cx,\n+                                                    cx.tables.expr_ty(l),\n+                                                    trait_id,\n+                                                    &[cx.tables.expr_ty(right)],\n+                                                    None) {\n+                                    span_lint_and_then(cx, OP_REF, e.span, \"taken reference of left operand\", |db| {\n+                                        let lsnip = snippet(cx, l.span, \"...\").to_string();\n+                                        let rsnip = Sugg::hir(cx, right, \"...\").deref().to_string();\n+                                        multispan_sugg(db,\n+                                                       \"dereference the right operand instead\".to_string(),\n+                                                       vec![(left.span, lsnip),\n                                                             (right.span, rsnip)]);\n-                                        }\n-                                    )\n+                                    })\n                                 }\n-                            }\n+                            },\n                             // foo == &bar\n                             (_, &ExprAddrOf(_, ref r)) => {\n-                                if implements_trait(cx, cx.tables.expr_ty(left), trait_id, &[cx.tables.expr_ty(r)], None) {\n-                                    span_lint_and_then(cx,\n-                                        OP_REF,\n-                                        e.span,\n-                                        \"taken reference of right operand\",\n-                                        |db| {\n-                                            let lsnip = Sugg::hir(cx, left, \"...\").deref().to_string();\n-                                            let rsnip = snippet(cx, r.span, \"...\").to_string();\n-                                            multispan_sugg(db,\n-                                                        \"dereference the left operand instead\".to_string(),\n-                                                        vec![(left.span, lsnip),\n+                                if implements_trait(cx,\n+                                                    cx.tables.expr_ty(left),\n+                                                    trait_id,\n+                                                    &[cx.tables.expr_ty(r)],\n+                                                    None) {\n+                                    span_lint_and_then(cx, OP_REF, e.span, \"taken reference of right operand\", |db| {\n+                                        let lsnip = Sugg::hir(cx, left, \"...\").deref().to_string();\n+                                        let rsnip = snippet(cx, r.span, \"...\").to_string();\n+                                        multispan_sugg(db,\n+                                                       \"dereference the left operand instead\".to_string(),\n+                                                       vec![(left.span, lsnip),\n                                                             (right.span, rsnip)]);\n-                                        }\n-                                    )\n+                                    })\n                                 }\n-                            }\n-                            _ => {}\n+                            },\n+                            _ => {},\n                         }\n                     }\n                 }"}, {"sha": "8f8c7db64cfd7faec8b6a4cd925343c449c5a399", "filename": "clippy_lints/src/formatting.rs", "status": "modified", "additions": 32, "deletions": 8, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/584246356214bfd8aeaecda95bf76af7b6264cb0/clippy_lints%2Fsrc%2Fformatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/584246356214bfd8aeaecda95bf76af7b6264cb0/clippy_lints%2Fsrc%2Fformatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformatting.rs?ref=584246356214bfd8aeaecda95bf76af7b6264cb0", "patch": "@@ -100,11 +100,19 @@ impl EarlyLintPass for Formatting {\n fn check_assign(cx: &EarlyContext, expr: &ast::Expr) {\n     if let ast::ExprKind::Assign(ref lhs, ref rhs) = expr.node {\n         if !differing_macro_contexts(lhs.span, rhs.span) && !in_macro(lhs.span) {\n-            let eq_span = Span { lo: lhs.span.hi, hi: rhs.span.lo, ctxt: NO_EXPANSION };\n+            let eq_span = Span {\n+                lo: lhs.span.hi,\n+                hi: rhs.span.lo,\n+                ctxt: NO_EXPANSION,\n+            };\n             if let ast::ExprKind::Unary(op, ref sub_rhs) = rhs.node {\n                 if let Some(eq_snippet) = snippet_opt(cx, eq_span) {\n                     let op = ast::UnOp::to_string(op);\n-                    let eqop_span= Span { lo: lhs.span.hi, hi: sub_rhs.span.lo, ctxt: NO_EXPANSION };\n+                    let eqop_span = Span {\n+                        lo: lhs.span.hi,\n+                        hi: sub_rhs.span.lo,\n+                        ctxt: NO_EXPANSION,\n+                    };\n                     if eq_snippet.ends_with('=') {\n                         span_note_and_lint(cx,\n                                            SUSPICIOUS_ASSIGNMENT_FORMATTING,\n@@ -127,7 +135,11 @@ fn check_else_if(cx: &EarlyContext, expr: &ast::Expr) {\n         if unsugar_if(else_).is_some() && !differing_macro_contexts(then.span, else_.span) && !in_macro(then.span) {\n             // this will be a span from the closing \u2018}\u2019 of the \u201cthen\u201d block (excluding) to the\n             // \u201cif\u201d of the \u201celse if\u201d block (excluding)\n-            let else_span = Span { lo: then.span.hi, hi: else_.span.lo, ctxt: NO_EXPANSION };\n+            let else_span = Span {\n+                lo: then.span.hi,\n+                hi: else_.span.lo,\n+                ctxt: NO_EXPANSION,\n+            };\n \n             // the snippet should look like \" else \\n    \" with maybe comments anywhere\n             // it\u2019s bad when there is a \u2018\\n\u2019 after the \u201celse\u201d\n@@ -154,9 +166,17 @@ fn check_array(cx: &EarlyContext, expr: &ast::Expr) {\n         for element in array {\n             if let ast::ExprKind::Binary(ref op, ref lhs, _) = element.node {\n                 if !differing_macro_contexts(lhs.span, op.span) {\n-                    let space_span = Span { lo: lhs.span.hi, hi: op.span.lo, ctxt: NO_EXPANSION };\n+                    let space_span = Span {\n+                        lo: lhs.span.hi,\n+                        hi: op.span.lo,\n+                        ctxt: NO_EXPANSION,\n+                    };\n                     if let Some(space_snippet) = snippet_opt(cx, space_span) {\n-                        let lint_span = Span { lo: lhs.span.hi, hi: lhs.span.hi, ctxt: NO_EXPANSION };\n+                        let lint_span = Span {\n+                            lo: lhs.span.hi,\n+                            hi: lhs.span.hi,\n+                            ctxt: NO_EXPANSION,\n+                        };\n                         if space_snippet.contains('\\n') {\n                             span_note_and_lint(cx,\n                                                POSSIBLE_MISSING_COMMA,\n@@ -174,10 +194,14 @@ fn check_array(cx: &EarlyContext, expr: &ast::Expr) {\n \n /// Implementation of the `SUSPICIOUS_ELSE_FORMATTING` lint for consecutive ifs.\n fn check_consecutive_ifs(cx: &EarlyContext, first: &ast::Expr, second: &ast::Expr) {\n-    if !differing_macro_contexts(first.span, second.span) && !in_macro(first.span) &&\n-       unsugar_if(first).is_some() && unsugar_if(second).is_some() {\n+    if !differing_macro_contexts(first.span, second.span) && !in_macro(first.span) && unsugar_if(first).is_some() &&\n+       unsugar_if(second).is_some() {\n         // where the else would be\n-        let else_span = Span { lo: first.span.hi, hi: second.span.lo, ctxt: NO_EXPANSION };\n+        let else_span = Span {\n+            lo: first.span.hi,\n+            hi: second.span.lo,\n+            ctxt: NO_EXPANSION,\n+        };\n \n         if let Some(else_snippet) = snippet_opt(cx, else_span) {\n             if !else_snippet.contains('\\n') {"}, {"sha": "a691e228a77583aeca24dee6c7afbebb3a7e3a9a", "filename": "clippy_lints/src/lifetimes.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/584246356214bfd8aeaecda95bf76af7b6264cb0/clippy_lints%2Fsrc%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/584246356214bfd8aeaecda95bf76af7b6264cb0/clippy_lints%2Fsrc%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flifetimes.rs?ref=584246356214bfd8aeaecda95bf76af7b6264cb0", "patch": "@@ -89,7 +89,13 @@ enum RefLt {\n     Named(Name),\n }\n \n-fn check_fn_inner<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, decl: &'tcx FnDecl, body: Option<BodyId>, generics: &'tcx Generics, span: Span) {\n+fn check_fn_inner<'a, 'tcx>(\n+    cx: &LateContext<'a, 'tcx>,\n+    decl: &'tcx FnDecl,\n+    body: Option<BodyId>,\n+    generics: &'tcx Generics,\n+    span: Span\n+) {\n     if in_external_macro(cx, span) || has_where_lifetimes(cx, &generics.where_clause) {\n         return;\n     }\n@@ -128,7 +134,7 @@ fn could_use_elision<'a, 'tcx: 'a>(\n     func: &'tcx FnDecl,\n     body: Option<BodyId>,\n     named_lts: &'tcx [LifetimeDef],\n-    bounds_lts: Vec<&'tcx Lifetime>,\n+    bounds_lts: Vec<&'tcx Lifetime>\n ) -> bool {\n     // There are two scenarios where elision works:\n     // * no output references, all input references have different LT\n@@ -265,11 +271,7 @@ impl<'v, 't> RefVisitor<'v, 't> {\n     }\n \n     fn into_vec(self) -> Option<Vec<RefLt>> {\n-        if self.abort {\n-            None\n-        } else {\n-            Some(self.lts)\n-        }\n+        if self.abort { None } else { Some(self.lts) }\n     }\n \n     fn collect_anonymous_lifetimes(&mut self, qpath: &QPath, ty: &Ty) {\n@@ -359,9 +361,11 @@ fn has_where_lifetimes<'a, 'tcx: 'a>(cx: &LateContext<'a, 'tcx>, where_clause: &\n                 // and check that all lifetimes are allowed\n                 match visitor.into_vec() {\n                     None => return false,\n-                    Some(lts) => for lt in lts {\n-                        if !allowed_lts.contains(&lt) {\n-                            return true;\n+                    Some(lts) => {\n+                        for lt in lts {\n+                            if !allowed_lts.contains(&lt) {\n+                                return true;\n+                            }\n                         }\n                     },\n                 }"}, {"sha": "7f0174fce5816494188195487bbdc37ac6dfaa1e", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/584246356214bfd8aeaecda95bf76af7b6264cb0/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/584246356214bfd8aeaecda95bf76af7b6264cb0/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=584246356214bfd8aeaecda95bf76af7b6264cb0", "patch": "@@ -409,8 +409,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     fn check_stmt(&mut self, cx: &LateContext<'a, 'tcx>, stmt: &'tcx Stmt) {\n         if let StmtSemi(ref expr, _) = stmt.node {\n             if let ExprMethodCall(ref method, _, ref args) = expr.node {\n-                if args.len() == 1 && method.node == \"collect\" &&\n-                   match_trait_method(cx, expr, &paths::ITERATOR) {\n+                if args.len() == 1 && method.node == \"collect\" && match_trait_method(cx, expr, &paths::ITERATOR) {\n                     span_lint(cx,\n                               UNUSED_COLLECT,\n                               expr.span,"}, {"sha": "c2fc932a67856a2c81bf67fc70f0ee92d555f8b3", "filename": "clippy_lints/src/misc.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/584246356214bfd8aeaecda95bf76af7b6264cb0/clippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/584246356214bfd8aeaecda95bf76af7b6264cb0/clippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc.rs?ref=584246356214bfd8aeaecda95bf76af7b6264cb0", "patch": "@@ -499,9 +499,7 @@ fn is_used(cx: &LateContext, expr: &Expr) -> bool {\n /// Test whether an expression is in a macro expansion (e.g. something generated by\n /// `#[derive(...)`] or the like).\n fn in_attributes_expansion(expr: &Expr) -> bool {\n-    expr.span.ctxt.outer().expn_info().map_or(false, |info| {\n-        matches!(info.callee.format, ExpnFormat::MacroAttribute(_))\n-    })\n+    expr.span.ctxt.outer().expn_info().map_or(false, |info| matches!(info.callee.format, ExpnFormat::MacroAttribute(_)))\n }\n \n /// Test whether `def` is a variable defined outside a macro."}, {"sha": "70ae9471babfd09765b99d3b3a2a739a7d84933b", "filename": "clippy_lints/src/needless_bool.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/584246356214bfd8aeaecda95bf76af7b6264cb0/clippy_lints%2Fsrc%2Fneedless_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/584246356214bfd8aeaecda95bf76af7b6264cb0/clippy_lints%2Fsrc%2Fneedless_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_bool.rs?ref=584246356214bfd8aeaecda95bf76af7b6264cb0", "patch": "@@ -77,27 +77,27 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessBool {\n                                    |db| { db.span_suggestion(e.span, \"you can reduce it to\", hint); });\n             };\n             if let ExprBlock(ref then_block) = then_block.node {\n-            match (fetch_bool_block(then_block), fetch_bool_expr(else_expr)) {\n-                (RetBool(true), RetBool(true)) |\n-                (Bool(true), Bool(true)) => {\n-                    span_lint(cx,\n-                              NEEDLESS_BOOL,\n-                              e.span,\n-                              \"this if-then-else expression will always return true\");\n-                },\n-                (RetBool(false), RetBool(false)) |\n-                (Bool(false), Bool(false)) => {\n-                    span_lint(cx,\n-                              NEEDLESS_BOOL,\n-                              e.span,\n-                              \"this if-then-else expression will always return false\");\n-                },\n-                (RetBool(true), RetBool(false)) => reduce(true, false),\n-                (Bool(true), Bool(false)) => reduce(false, false),\n-                (RetBool(false), RetBool(true)) => reduce(true, true),\n-                (Bool(false), Bool(true)) => reduce(false, true),\n-                _ => (),\n-            }\n+                match (fetch_bool_block(then_block), fetch_bool_expr(else_expr)) {\n+                    (RetBool(true), RetBool(true)) |\n+                    (Bool(true), Bool(true)) => {\n+                        span_lint(cx,\n+                                  NEEDLESS_BOOL,\n+                                  e.span,\n+                                  \"this if-then-else expression will always return true\");\n+                    },\n+                    (RetBool(false), RetBool(false)) |\n+                    (Bool(false), Bool(false)) => {\n+                        span_lint(cx,\n+                                  NEEDLESS_BOOL,\n+                                  e.span,\n+                                  \"this if-then-else expression will always return false\");\n+                    },\n+                    (RetBool(true), RetBool(false)) => reduce(true, false),\n+                    (Bool(true), Bool(false)) => reduce(false, false),\n+                    (RetBool(false), RetBool(true)) => reduce(true, true),\n+                    (Bool(false), Bool(true)) => reduce(false, true),\n+                    _ => (),\n+                }\n             } else {\n                 panic!(\"IfExpr 'then' node is not an ExprBlock\");\n             }"}, {"sha": "5820f600434883a74962746d2d596cad202be9ca", "filename": "clippy_lints/src/utils/hir.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/584246356214bfd8aeaecda95bf76af7b6264cb0/clippy_lints%2Fsrc%2Futils%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/584246356214bfd8aeaecda95bf76af7b6264cb0/clippy_lints%2Fsrc%2Futils%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhir.rs?ref=584246356214bfd8aeaecda95bf76af7b6264cb0", "patch": "@@ -97,7 +97,7 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n             },\n             (&ExprIndex(ref la, ref li), &ExprIndex(ref ra, ref ri)) => self.eq_expr(la, ra) && self.eq_expr(li, ri),\n             (&ExprIf(ref lc, ref lt, ref le), &ExprIf(ref rc, ref rt, ref re)) => {\n-                    self.eq_expr(lc, rc) && self.eq_expr(&**lt, &**rt) && both(le, re, |l, r| self.eq_expr(l, r))\n+                self.eq_expr(lc, rc) && self.eq_expr(&**lt, &**rt) && both(le, re, |l, r| self.eq_expr(l, r))\n             },\n             (&ExprLit(ref l), &ExprLit(ref r)) => l.node == r.node,\n             (&ExprLoop(ref lb, ref ll, ref lls), &ExprLoop(ref rb, ref rl, ref rls)) => {"}, {"sha": "87b430626319a0dad9d44a100a6fe3429491d0d6", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/584246356214bfd8aeaecda95bf76af7b6264cb0/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/584246356214bfd8aeaecda95bf76af7b6264cb0/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=584246356214bfd8aeaecda95bf76af7b6264cb0", "patch": "@@ -690,8 +690,10 @@ fn parse_attrs<F: FnMut(u64)>(sess: &Session, attrs: &[ast::Attribute], name: &'\n /// See also `is_direct_expn_of`.\n pub fn is_expn_of(mut span: Span, name: &str) -> Option<Span> {\n     loop {\n-        let span_name_span = span.ctxt.outer()\n-            .expn_info().map(|ei| (ei.callee.name(), ei.call_site));\n+        let span_name_span = span.ctxt\n+            .outer()\n+            .expn_info()\n+            .map(|ei| (ei.callee.name(), ei.call_site));\n \n         match span_name_span {\n             Some((mac_name, new_span)) if mac_name == name => return Some(new_span),\n@@ -709,8 +711,10 @@ pub fn is_expn_of(mut span: Span, name: &str) -> Option<Span> {\n /// `42` is considered expanded from `foo!` and `bar!` by `is_expn_of` but only `bar!` by\n /// `is_direct_expn_of`.\n pub fn is_direct_expn_of(span: Span, name: &str) -> Option<Span> {\n-    let span_name_span = span.ctxt.outer()\n-        .expn_info().map(|ei| (ei.callee.name(), ei.call_site));\n+    let span_name_span = span.ctxt\n+        .outer()\n+        .expn_info()\n+        .map(|ei| (ei.callee.name(), ei.call_site));\n \n     match span_name_span {\n         Some((mac_name, new_span)) if mac_name == name => Some(new_span),"}, {"sha": "a1e18ecc9b49061f4a06f81e39463f55f173d15a", "filename": "src/lib.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/584246356214bfd8aeaecda95bf76af7b6264cb0/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/584246356214bfd8aeaecda95bf76af7b6264cb0/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=584246356214bfd8aeaecda95bf76af7b6264cb0", "patch": "@@ -12,8 +12,13 @@ extern crate clippy_lints;\n #[plugin_registrar]\n pub fn plugin_registrar(reg: &mut Registry) {\n     if let Ok(lint_store) = reg.sess.lint_store.try_borrow() {\n-        if lint_store.get_lint_groups().iter().any(|&(s, _, _)| s == \"clippy\") {\n-            reg.sess.struct_warn(\"running cargo clippy on a crate that also imports the clippy plugin\").emit();\n+        if lint_store\n+               .get_lint_groups()\n+               .iter()\n+               .any(|&(s, _, _)| s == \"clippy\") {\n+            reg.sess\n+                .struct_warn(\"running cargo clippy on a crate that also imports the clippy plugin\")\n+                .emit();\n             return;\n         }\n     }"}, {"sha": "1b3dd4f05e0590db84fcfc3b82930a28dab39ab5", "filename": "src/main.rs", "status": "modified", "additions": 69, "deletions": 49, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/584246356214bfd8aeaecda95bf76af7b6264cb0/src%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/584246356214bfd8aeaecda95bf76af7b6264cb0/src%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmain.rs?ref=584246356214bfd8aeaecda95bf76af7b6264cb0", "patch": "@@ -43,9 +43,10 @@ impl<'a> CompilerCalls<'a> for ClippyCompilerCalls {\n         sopts: &config::Options,\n         cfg: &ast::CrateConfig,\n         descriptions: &rustc_errors::registry::Registry,\n-        output: ErrorOutputType\n+        output: ErrorOutputType,\n     ) -> Compilation {\n-        self.default.early_callback(matches, sopts, cfg, descriptions, output)\n+        self.default\n+            .early_callback(matches, sopts, cfg, descriptions, output)\n     }\n     fn no_input(\n         &mut self,\n@@ -54,19 +55,21 @@ impl<'a> CompilerCalls<'a> for ClippyCompilerCalls {\n         cfg: &ast::CrateConfig,\n         odir: &Option<PathBuf>,\n         ofile: &Option<PathBuf>,\n-        descriptions: &rustc_errors::registry::Registry\n+        descriptions: &rustc_errors::registry::Registry,\n     ) -> Option<(Input, Option<PathBuf>)> {\n-        self.default.no_input(matches, sopts, cfg, odir, ofile, descriptions)\n+        self.default\n+            .no_input(matches, sopts, cfg, odir, ofile, descriptions)\n     }\n     fn late_callback(\n         &mut self,\n         matches: &getopts::Matches,\n         sess: &Session,\n         input: &Input,\n         odir: &Option<PathBuf>,\n-        ofile: &Option<PathBuf>\n+        ofile: &Option<PathBuf>,\n     ) -> Compilation {\n-        self.default.late_callback(matches, sess, input, odir, ofile)\n+        self.default\n+            .late_callback(matches, sess, input, odir, ofile)\n     }\n     fn build_controller(&mut self, sess: &Session, matches: &getopts::Matches) -> driver::CompileController<'a> {\n         let mut control = self.default.build_controller(sess, matches);\n@@ -76,20 +79,23 @@ impl<'a> CompilerCalls<'a> for ClippyCompilerCalls {\n             control.after_parse.callback = Box::new(move |state| {\n                 {\n                     let mut registry = rustc_plugin::registry::Registry::new(state.session,\n-                                                                             state.krate\n+                                                                             state\n+                                                                                 .krate\n                                                                                  .as_ref()\n                                                                                  .expect(\"at this compilation stage \\\n                                                                                           the krate must be parsed\")\n                                                                                  .span);\n                     registry.args_hidden = Some(Vec::new());\n                     clippy_lints::register_plugins(&mut registry);\n \n-                    let rustc_plugin::registry::Registry { early_lint_passes,\n-                                                           late_lint_passes,\n-                                                           lint_groups,\n-                                                           llvm_passes,\n-                                                           attributes,\n-                                                           .. } = registry;\n+                    let rustc_plugin::registry::Registry {\n+                        early_lint_passes,\n+                        late_lint_passes,\n+                        lint_groups,\n+                        llvm_passes,\n+                        attributes,\n+                        ..\n+                    } = registry;\n                     let sess = &state.session;\n                     let mut ls = sess.lint_store.borrow_mut();\n                     for pass in early_lint_passes {\n@@ -172,29 +178,35 @@ pub fn main() {\n     if let Some(\"clippy\") = std::env::args().nth(1).as_ref().map(AsRef::as_ref) {\n         // this arm is executed on the initial call to `cargo clippy`\n \n-        let manifest_path_arg = std::env::args().skip(2).find(|val| val.starts_with(\"--manifest-path=\"));\n+        let manifest_path_arg = std::env::args()\n+            .skip(2)\n+            .find(|val| val.starts_with(\"--manifest-path=\"));\n \n-        let mut metadata = if let Ok(metadata) = cargo_metadata::metadata(manifest_path_arg.as_ref()\n-            .map(AsRef::as_ref)) {\n-            metadata\n-        } else {\n-            let _ = io::stderr().write_fmt(format_args!(\"error: Could not obtain cargo metadata.\\n\"));\n-            process::exit(101);\n-        };\n+        let mut metadata =\n+            if let Ok(metadata) = cargo_metadata::metadata(manifest_path_arg.as_ref().map(AsRef::as_ref)) {\n+                metadata\n+            } else {\n+                let _ = io::stderr().write_fmt(format_args!(\"error: Could not obtain cargo metadata.\\n\"));\n+                process::exit(101);\n+            };\n \n         let manifest_path = manifest_path_arg.map(|arg| PathBuf::from(Path::new(&arg[\"--manifest-path=\".len()..])));\n \n         let current_dir = std::env::current_dir();\n \n-        let package_index = metadata.packages\n+        let package_index = metadata\n+            .packages\n             .iter()\n             .position(|package| {\n                 let package_manifest_path = Path::new(&package.manifest_path);\n                 if let Some(ref manifest_path) = manifest_path {\n                     package_manifest_path == manifest_path\n                 } else {\n-                    let current_dir = current_dir.as_ref().expect(\"could not read current directory\");\n-                    let package_manifest_directory = package_manifest_path.parent()\n+                    let current_dir = current_dir\n+                        .as_ref()\n+                        .expect(\"could not read current directory\");\n+                    let package_manifest_directory = package_manifest_path\n+                        .parent()\n                         .expect(\"could not find parent directory of package manifest\");\n                     package_manifest_directory == current_dir\n                 }\n@@ -209,7 +221,9 @@ pub fn main() {\n                         std::process::exit(code);\n                     }\n                 } else if [\"bin\", \"example\", \"test\", \"bench\"].contains(&&**first) {\n-                    if let Err(code) = process(vec![format!(\"--{}\", first), target.name].into_iter().chain(args)) {\n+                    if let Err(code) = process(vec![format!(\"--{}\", first), target.name]\n+                                                   .into_iter()\n+                                                   .chain(args)) {\n                         std::process::exit(code);\n                     }\n                 }\n@@ -218,7 +232,8 @@ pub fn main() {\n             }\n         }\n     } else {\n-        // this arm is executed when cargo-clippy runs `cargo rustc` with the `RUSTC` env var set to itself\n+        // this arm is executed when cargo-clippy runs `cargo rustc` with the `RUSTC`\n+        // env var set to itself\n \n         let home = option_env!(\"RUSTUP_HOME\").or(option_env!(\"MULTIRUST_HOME\"));\n         let toolchain = option_env!(\"RUSTUP_TOOLCHAIN\").or(option_env!(\"MULTIRUST_TOOLCHAIN\"));\n@@ -240,31 +255,36 @@ pub fn main() {\n         };\n \n         rustc_driver::in_rustc_thread(|| {\n-                // this conditional check for the --sysroot flag is there so users can call `cargo-clippy` directly\n-                // without having to pass --sysroot or anything\n-                let mut args: Vec<String> = if env::args().any(|s| s == \"--sysroot\") {\n-                    env::args().collect()\n-                } else {\n-                    env::args().chain(Some(\"--sysroot\".to_owned())).chain(Some(sys_root)).collect()\n-                };\n-\n-                // this check ensures that dependencies are built but not linted and the final crate is\n-                // linted but not built\n-                let clippy_enabled = env::args().any(|s| s == \"-Zno-trans\");\n+            // this conditional check for the --sysroot flag is there so users can call\n+            // `cargo-clippy` directly\n+            // without having to pass --sysroot or anything\n+            let mut args: Vec<String> = if env::args().any(|s| s == \"--sysroot\") {\n+                env::args().collect()\n+            } else {\n+                env::args()\n+                    .chain(Some(\"--sysroot\".to_owned()))\n+                    .chain(Some(sys_root))\n+                    .collect()\n+            };\n+\n+            // this check ensures that dependencies are built but not linted and the final\n+            // crate is\n+            // linted but not built\n+            let clippy_enabled = env::args().any(|s| s == \"-Zno-trans\");\n+\n+            if clippy_enabled {\n+                args.extend_from_slice(&[\"--cfg\".to_owned(), r#\"feature=\"cargo-clippy\"\"#.to_owned()]);\n+            }\n \n-                if clippy_enabled {\n-                    args.extend_from_slice(&[\"--cfg\".to_owned(), r#\"feature=\"cargo-clippy\"\"#.to_owned()]);\n+            let mut ccc = ClippyCompilerCalls::new(clippy_enabled);\n+            let (result, _) = rustc_driver::run_compiler(&args, &mut ccc, None, None);\n+            if let Err(err_count) = result {\n+                if err_count > 0 {\n+                    std::process::exit(1);\n                 }\n-\n-                let mut ccc = ClippyCompilerCalls::new(clippy_enabled);\n-                let (result, _) = rustc_driver::run_compiler(&args, &mut ccc, None, None);\n-                if let Err(err_count) = result {\n-                    if err_count > 0 {\n-                        std::process::exit(1);\n-                    }\n-                }\n-            })\n-            .expect(\"rustc_thread failed\");\n+            }\n+        })\n+                .expect(\"rustc_thread failed\");\n     }\n }\n "}, {"sha": "c81b32c54bcedfe67d8a236e44cb1d1d25906878", "filename": "tests/cc_seme.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/584246356214bfd8aeaecda95bf76af7b6264cb0/tests%2Fcc_seme.rs", "raw_url": "https://github.com/rust-lang/rust/raw/584246356214bfd8aeaecda95bf76af7b6264cb0/tests%2Fcc_seme.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcc_seme.rs?ref=584246356214bfd8aeaecda95bf76af7b6264cb0", "patch": "@@ -14,14 +14,14 @@ struct Test {\n \n fn main() {\n     use Baz::*;\n-    let x = Test {\n-        t: Some(0),\n-        b: One,\n-    };\n+    let x = Test { t: Some(0), b: One };\n \n     match x {\n         Test { t: Some(_), b: One } => unreachable!(),\n-        Test { t: Some(42), b: Two } => unreachable!(),\n+        Test {\n+            t: Some(42),\n+            b: Two,\n+        } => unreachable!(),\n         Test { t: None, .. } => unreachable!(),\n         Test { .. } => unreachable!(),\n     }"}, {"sha": "ade8db2aa277d0cd5dae7f513ab2473c704f072d", "filename": "tests/matches.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/584246356214bfd8aeaecda95bf76af7b6264cb0/tests%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/584246356214bfd8aeaecda95bf76af7b6264cb0/tests%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmatches.rs?ref=584246356214bfd8aeaecda95bf76af7b6264cb0", "patch": "@@ -20,9 +20,13 @@ fn test_overlapping() {\n     assert_eq!(None, overlapping(&[sp(1, Bound::Included(4))]));\n     assert_eq!(None, overlapping(&[sp(1, Bound::Included(4)), sp(5, Bound::Included(6))]));\n     assert_eq!(None,\n-               overlapping(&[sp(1, Bound::Included(4)), sp(5, Bound::Included(6)), sp(10, Bound::Included(11))]));\n+               overlapping(&[sp(1, Bound::Included(4)),\n+                             sp(5, Bound::Included(6)),\n+                             sp(10, Bound::Included(11))]));\n     assert_eq!(Some((&sp(1, Bound::Included(4)), &sp(3, Bound::Included(6)))),\n                overlapping(&[sp(1, Bound::Included(4)), sp(3, Bound::Included(6))]));\n     assert_eq!(Some((&sp(5, Bound::Included(6)), &sp(6, Bound::Included(11)))),\n-               overlapping(&[sp(1, Bound::Included(4)), sp(5, Bound::Included(6)), sp(6, Bound::Included(11))]));\n+               overlapping(&[sp(1, Bound::Included(4)),\n+                             sp(5, Bound::Included(6)),\n+                             sp(6, Bound::Included(11))]));\n }"}, {"sha": "b323cb5d25b495f19401df07151263b566e5a949", "filename": "tests/used_underscore_binding_macro.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/584246356214bfd8aeaecda95bf76af7b6264cb0/tests%2Fused_underscore_binding_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/584246356214bfd8aeaecda95bf76af7b6264cb0/tests%2Fused_underscore_binding_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fused_underscore_binding_macro.rs?ref=584246356214bfd8aeaecda95bf76af7b6264cb0", "patch": "@@ -4,7 +4,8 @@\n #[macro_use]\n extern crate serde_derive;\n \n-/// Test that we do not lint for unused underscores in a `MacroAttribute` expansion\n+/// Test that we do not lint for unused underscores in a `MacroAttribute`\n+/// expansion\n #[deny(used_underscore_binding)]\n #[derive(Deserialize)]\n struct MacroAttributesTest {"}]}