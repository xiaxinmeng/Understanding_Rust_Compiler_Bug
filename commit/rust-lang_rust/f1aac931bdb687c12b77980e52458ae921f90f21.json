{"sha": "f1aac931bdb687c12b77980e52458ae921f90f21", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYxYWFjOTMxYmRiNjg3YzEyYjc3OTgwZTUyNDU4YWU5MjFmOTBmMjE=", "commit": {"author": {"name": "Devon Hollowood", "email": "devonhollowood@gmail.com", "date": "2015-12-27T09:22:53Z"}, "committer": {"name": "Devon Hollowood", "email": "devonhollowood@gmail.com", "date": "2015-12-27T09:22:53Z"}, "message": "Refactor `check_expr()` impl for `MethodsPass`", "tree": {"sha": "73713e1d74bf95dbc6ac9b1168032e547c1bff63", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/73713e1d74bf95dbc6ac9b1168032e547c1bff63"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f1aac931bdb687c12b77980e52458ae921f90f21", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f1aac931bdb687c12b77980e52458ae921f90f21", "html_url": "https://github.com/rust-lang/rust/commit/f1aac931bdb687c12b77980e52458ae921f90f21", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f1aac931bdb687c12b77980e52458ae921f90f21/comments", "author": {"login": "devonhollowood", "id": 7864326, "node_id": "MDQ6VXNlcjc4NjQzMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/7864326?v=4", "gravatar_id": "", "url": "https://api.github.com/users/devonhollowood", "html_url": "https://github.com/devonhollowood", "followers_url": "https://api.github.com/users/devonhollowood/followers", "following_url": "https://api.github.com/users/devonhollowood/following{/other_user}", "gists_url": "https://api.github.com/users/devonhollowood/gists{/gist_id}", "starred_url": "https://api.github.com/users/devonhollowood/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/devonhollowood/subscriptions", "organizations_url": "https://api.github.com/users/devonhollowood/orgs", "repos_url": "https://api.github.com/users/devonhollowood/repos", "events_url": "https://api.github.com/users/devonhollowood/events{/privacy}", "received_events_url": "https://api.github.com/users/devonhollowood/received_events", "type": "User", "site_admin": false}, "committer": {"login": "devonhollowood", "id": 7864326, "node_id": "MDQ6VXNlcjc4NjQzMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/7864326?v=4", "gravatar_id": "", "url": "https://api.github.com/users/devonhollowood", "html_url": "https://github.com/devonhollowood", "followers_url": "https://api.github.com/users/devonhollowood/followers", "following_url": "https://api.github.com/users/devonhollowood/following{/other_user}", "gists_url": "https://api.github.com/users/devonhollowood/gists{/gist_id}", "starred_url": "https://api.github.com/users/devonhollowood/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/devonhollowood/subscriptions", "organizations_url": "https://api.github.com/users/devonhollowood/orgs", "repos_url": "https://api.github.com/users/devonhollowood/repos", "events_url": "https://api.github.com/users/devonhollowood/events{/privacy}", "received_events_url": "https://api.github.com/users/devonhollowood/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dbf1cdf34aa89cdaba1bb9993e6aed221dfceb90", "url": "https://api.github.com/repos/rust-lang/rust/commits/dbf1cdf34aa89cdaba1bb9993e6aed221dfceb90", "html_url": "https://github.com/rust-lang/rust/commit/dbf1cdf34aa89cdaba1bb9993e6aed221dfceb90"}], "stats": {"total": 291, "additions": 188, "deletions": 103}, "files": [{"sha": "31e3bfb8f4aaa1809c38ee382d51d34f847840f0", "filename": "src/methods.rs", "status": "modified", "additions": 166, "deletions": 103, "changes": 269, "blob_url": "https://github.com/rust-lang/rust/blob/f1aac931bdb687c12b77980e52458ae921f90f21/src%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1aac931bdb687c12b77980e52458ae921f90f21/src%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmethods.rs?ref=f1aac931bdb687c12b77980e52458ae921f90f21", "patch": "@@ -5,8 +5,8 @@ use rustc::middle::subst::{Subst, TypeSpace};\n use std::iter;\n use std::borrow::Cow;\n \n-use utils::{snippet, span_lint, span_note_and_lint, match_path, match_type, walk_ptrs_ty_depth,\n-    walk_ptrs_ty};\n+use utils::{snippet, span_lint, span_note_and_lint, match_path, match_type, match_method_chain,\n+            walk_ptrs_ty_depth, walk_ptrs_ty};\n use utils::{OPTION_PATH, RESULT_PATH, STRING_PATH};\n \n use self::SelfKind::*;\n@@ -157,107 +157,21 @@ impl LintPass for MethodsPass {\n \n impl LateLintPass for MethodsPass {\n     fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n-\n-        if let ExprMethodCall(ref name, _, ref args) = expr.node {\n-            let (obj_ty, ptr_depth) = walk_ptrs_ty_depth(cx.tcx.expr_ty(&args[0]));\n-            match &*name.node.as_str() {\n-                \"unwrap\" if match_type(cx, obj_ty, &OPTION_PATH) => {\n-                    span_lint(cx, OPTION_UNWRAP_USED, expr.span,\n-                              \"used unwrap() on an Option value. If you don't want \\\n-                               to handle the None case gracefully, consider using \\\n-                               expect() to provide a better panic message\");\n-                },\n-                \"unwrap\" if match_type(cx, obj_ty, &RESULT_PATH) => {\n-                    span_lint(cx, RESULT_UNWRAP_USED, expr.span,\n-                              \"used unwrap() on a Result value. Graceful handling \\\n-                               of Err values is preferred\");\n-                },\n-                \"to_string\" if obj_ty.sty == ty::TyStr => {\n-                    let mut arg_str = snippet(cx, args[0].span, \"_\");\n-                    if ptr_depth > 1 {\n-                        arg_str = Cow::Owned(format!(\n-                            \"({}{})\",\n-                            iter::repeat('*').take(ptr_depth - 1).collect::<String>(),\n-                            arg_str));\n-                    }\n-                    span_lint(cx, STR_TO_STRING, expr.span, &format!(\n-                        \"`{}.to_owned()` is faster\", arg_str));\n-                },\n-                \"to_string\" if match_type(cx, obj_ty, &STRING_PATH) => {\n-                    span_lint(cx, STRING_TO_STRING, expr.span, \"`String.to_string()` is a no-op; use \\\n-                                                                `clone()` to make a copy\");\n-                },\n-                \"expect\" => if let ExprMethodCall(ref inner_name, _, ref inner_args) = args[0].node {\n-                    if inner_name.node.as_str() == \"ok\"\n-                            && match_type(cx, cx.tcx.expr_ty(&inner_args[0]), &RESULT_PATH) {\n-                        let result_type = cx.tcx.expr_ty(&inner_args[0]);\n-                        if let Some(error_type) = get_error_type(cx, result_type) {\n-                            if has_debug_impl(error_type, cx) {\n-                                span_lint(cx, OK_EXPECT, expr.span,\n-                                         \"called `ok().expect()` on a Result \\\n-                                          value. You can call `expect` directly \\\n-                                          on the `Result`\");\n-                            }\n-                        }\n-                    }\n-                },\n-                // check Option.map(_).unwrap_or(_)\n-                \"unwrap_or\" => if let ExprMethodCall(ref inner_name, _, ref inner_args) = args[0].node {\n-                    if inner_name.node.as_str() == \"map\"\n-                            && match_type(cx, cx.tcx.expr_ty(&inner_args[0]), &OPTION_PATH) {\n-                        // lint message\n-                        let msg =\n-                            \"called `map(f).unwrap_or(a)` on an Option value. This can be done \\\n-                             more directly by calling `map_or(a, f)` instead\";\n-                        // get args to map() and unwrap_or()\n-                        let map_arg = snippet(cx, inner_args[1].span, \"..\");\n-                        let unwrap_arg = snippet(cx, args[1].span, \"..\");\n-                        // lint, with note if neither arg is > 1 line and both map() and\n-                        // unwrap_or() have the same span\n-                        let multiline = map_arg.lines().count() > 1\n-                                        || unwrap_arg.lines().count() > 1;\n-                        let same_span = inner_args[1].span.expn_id == args[1].span.expn_id;\n-                        if same_span && !multiline {\n-                            span_note_and_lint(\n-                                cx, OPTION_MAP_UNWRAP_OR, expr.span, msg, expr.span,\n-                                &format!(\"replace this with map_or({1}, {0})\",\n-                                         map_arg, unwrap_arg)\n-                            );\n-                        }\n-                        else if same_span && multiline {\n-                            span_lint(cx, OPTION_MAP_UNWRAP_OR, expr.span, msg);\n-                        };\n-                    }\n-                },\n-                // check Option.map(_).unwrap_or_else(_)\n-                \"unwrap_or_else\" => if let ExprMethodCall(ref inner_name, _, ref inner_args) = args[0].node {\n-                    if inner_name.node.as_str() == \"map\"\n-                            && match_type(cx, cx.tcx.expr_ty(&inner_args[0]), &OPTION_PATH) {\n-                        // lint message\n-                        let msg =\n-                            \"called `map(f).unwrap_or_else(g)` on an Option value. This can be \\\n-                             done more directly by calling `map_or_else(g, f)` instead\";\n-                        // get args to map() and unwrap_or_else()\n-                        let map_arg = snippet(cx, inner_args[1].span, \"..\");\n-                        let unwrap_arg = snippet(cx, args[1].span, \"..\");\n-                        // lint, with note if neither arg is > 1 line and both map() and\n-                        // unwrap_or_else() have the same span\n-                        let multiline = map_arg.lines().count() > 1\n-                                        || unwrap_arg.lines().count() > 1;\n-                        let same_span = inner_args[1].span.expn_id == args[1].span.expn_id;\n-                        if same_span && !multiline {\n-                            span_note_and_lint(\n-                                cx, OPTION_MAP_UNWRAP_OR_ELSE, expr.span, msg, expr.span,\n-                                &format!(\"replace this with map_or_else({1}, {0})\",\n-                                         map_arg, unwrap_arg)\n-                            );\n-                        }\n-                        else if same_span && multiline {\n-                            span_lint(cx, OPTION_MAP_UNWRAP_OR_ELSE, expr.span, msg);\n-                        };\n-                    }\n-                },\n-                _ => {},\n+        if let ExprMethodCall(_, _, _) = expr.node {\n+            if match_method_chain(expr, &[\"unwrap\"]) {\n+                lint_unwrap(cx, expr);\n+            }\n+            else if match_method_chain(expr, &[\"to_string\"]) {\n+                lint_to_string(cx, expr);\n+            }\n+            else if match_method_chain(expr, &[\"ok\", \"expect\"]) {\n+                lint_ok_expect(cx, expr);\n+            }\n+            else if match_method_chain(expr, &[\"map\", \"unwrap_or\"]) {\n+                lint_map_unwrap_or(cx, expr);\n+            }\n+            else if match_method_chain(expr, &[\"map\", \"unwrap_or_else\"]) {\n+                lint_map_unwrap_or_else(cx, expr);\n             }\n         }\n     }\n@@ -304,6 +218,155 @@ impl LateLintPass for MethodsPass {\n     }\n }\n \n+/// lint use of `unwrap()` for `Option`s and `Result`s\n+fn lint_unwrap(cx: &LateContext, expr: &Expr) {\n+    let args = match expr.node {\n+        ExprMethodCall(_, _, ref args) => args,\n+        _ => panic!(\"clippy methods.rs: should not have called `lint_unwrap()` on a non-matching \\\n+                     expression!\"),\n+    };\n+\n+    let (obj_ty, _) = walk_ptrs_ty_depth(cx.tcx.expr_ty(&args[0]));\n+\n+    if match_type(cx, obj_ty, &OPTION_PATH) {\n+        span_lint(cx, OPTION_UNWRAP_USED, expr.span,\n+                  \"used unwrap() on an Option value. If you don't want to handle the None case \\\n+                   gracefully, consider using expect() to provide a better panic message\");\n+    }\n+    else if match_type(cx, obj_ty, &RESULT_PATH) {\n+        span_lint(cx, RESULT_UNWRAP_USED, expr.span,\n+                  \"used unwrap() on a Result value. Graceful handling of Err values is preferred\");\n+    }\n+}\n+\n+/// lint use of `to_string()` for `&str`s and `String`s\n+fn lint_to_string(cx: &LateContext, expr: &Expr) {\n+    let args = match expr.node {\n+        ExprMethodCall(_, _, ref args) => args,\n+        _ => panic!(\"clippy methods.rs: should not have called `lint_to_string()` on a \\\n+                     non-matching expression!\"),\n+    };\n+\n+    let (obj_ty, ptr_depth) = walk_ptrs_ty_depth(cx.tcx.expr_ty(&args[0]));\n+\n+    if obj_ty.sty == ty::TyStr {\n+        let mut arg_str = snippet(cx, args[0].span, \"_\");\n+        if ptr_depth > 1 {\n+            arg_str = Cow::Owned(format!(\n+                \"({}{})\",\n+                iter::repeat('*').take(ptr_depth - 1).collect::<String>(),\n+                arg_str));\n+        }\n+        span_lint(cx, STR_TO_STRING, expr.span,\n+                  &format!(\"`{}.to_owned()` is faster\", arg_str));\n+    }\n+    else if match_type(cx, obj_ty, &STRING_PATH) {\n+        span_lint(cx, STRING_TO_STRING, expr.span,\n+                  \"`String.to_string()` is a no-op; use `clone()` to make a copy\");\n+    }\n+}\n+\n+/// lint use of `ok().expect()` for `Result`s\n+fn lint_ok_expect(cx: &LateContext, expr: &Expr) {\n+    let expect_args = match expr.node {\n+        ExprMethodCall(_, _, ref expect_args) => expect_args,\n+        _ => panic!(\"clippy methods.rs: Should not have called `lint_ok_expect()` on a \\\n+                     non-matching expression!\")\n+    };\n+    let ok_args = match expect_args[0].node {\n+        ExprMethodCall(_, _, ref ok_args) => ok_args,\n+        _ => panic!(\"clippy methods.rs: Should not have called `lint_ok_expect()` on a \\\n+                     non-matching expression!\")\n+    };\n+\n+    // lint if the caller of `ok()` is a `Result`\n+    if match_type(cx, cx.tcx.expr_ty(&ok_args[0]), &RESULT_PATH) {\n+        let result_type = cx.tcx.expr_ty(&ok_args[0]);\n+        if let Some(error_type) = get_error_type(cx, result_type) {\n+            if has_debug_impl(error_type, cx) {\n+                span_lint(cx, OK_EXPECT, expr.span,\n+                          \"called `ok().expect()` on a Result value. You can call `expect` \\\n+                           directly on the `Result`\");\n+            }\n+        }\n+    }\n+}\n+\n+/// lint use of `map().unwrap_or()` for `Option`s\n+fn lint_map_unwrap_or(cx: &LateContext, expr: &Expr) {\n+    let unwrap_args = match expr.node {\n+        ExprMethodCall(_, _, ref unwrap_args) => unwrap_args,\n+        _ => panic!(\"clippy methods.rs: Should not have called `lint_map_unwrap_or()` on a \\\n+                     non-matching expression!\")\n+    };\n+    let map_args = match unwrap_args[0].node {\n+        ExprMethodCall(_, _, ref map_args) => map_args,\n+        _ => panic!(\"clippy methods.rs: Should not have called `lint_map_unwrap_or()` on a \\\n+                     non-matching expression!\")\n+    };\n+\n+    // lint if the caller of `map()` is an `Option`\n+    if match_type(cx, cx.tcx.expr_ty(&map_args[0]), &OPTION_PATH) {\n+        // lint message\n+        let msg = \"called `map(f).unwrap_or(a)` on an Option value. This can be done more \\\n+                   directly by calling `map_or(a, f)` instead\";\n+        // get snippets for args to map() and unwrap_or()\n+        let map_snippet = snippet(cx, map_args[1].span, \"..\");\n+        let unwrap_snippet = snippet(cx, unwrap_args[1].span, \"..\");\n+        // lint, with note if neither arg is > 1 line and both map() and\n+        // unwrap_or() have the same span\n+        let multiline = map_snippet.lines().count() > 1\n+                        || unwrap_snippet.lines().count() > 1;\n+        let same_span = map_args[1].span.expn_id == unwrap_args[1].span.expn_id;\n+        if same_span && !multiline {\n+            span_note_and_lint(\n+                cx, OPTION_MAP_UNWRAP_OR, expr.span, msg, expr.span,\n+                &format!(\"replace this with map_or({1}, {0})\", map_snippet, unwrap_snippet)\n+            );\n+        }\n+        else if same_span && multiline {\n+            span_lint(cx, OPTION_MAP_UNWRAP_OR, expr.span, msg);\n+        };\n+    }\n+}\n+\n+/// lint use of `map().unwrap_or_else()` for `Option`s\n+fn lint_map_unwrap_or_else(cx: &LateContext, expr: &Expr) {\n+    let unwrap_args = match expr.node {\n+        ExprMethodCall(_, _, ref unwrap_args) => unwrap_args,\n+        _ => panic!(\"clippy methods.rs: Should not have called `lint_map_unwrap_or_else()` on a \\\n+                     non-matching expression!\")\n+    };\n+    let map_args = match unwrap_args[0].node {\n+        ExprMethodCall(_, _, ref map_args) => map_args,\n+        _ => panic!(\"clippy methods.rs: Should not have called `lint_map_unwrap_or_else()` on a \\\n+                     non-matching expression!\")\n+    };\n+\n+    if match_type(cx, cx.tcx.expr_ty(&map_args[0]), &OPTION_PATH) {\n+        // lint message\n+        let msg = \"called `map(f).unwrap_or_else(g)` on an Option value. This can be done more \\\n+                   directly by calling `map_or_else(g, f)` instead\";\n+        // get snippets for args to map() and unwrap_or_else()\n+        let map_snippet = snippet(cx, map_args[1].span, \"..\");\n+        let unwrap_snippet = snippet(cx, unwrap_args[1].span, \"..\");\n+        // lint, with note if neither arg is > 1 line and both map() and\n+        // unwrap_or_else() have the same span\n+        let multiline = map_snippet.lines().count() > 1\n+                        || unwrap_snippet.lines().count() > 1;\n+        let same_span = map_args[1].span.expn_id == unwrap_args[1].span.expn_id;\n+        if same_span && !multiline {\n+            span_note_and_lint(\n+                cx, OPTION_MAP_UNWRAP_OR_ELSE, expr.span, msg, expr.span,\n+                &format!(\"replace this with map_or_else({1}, {0})\", map_snippet, unwrap_snippet)\n+            );\n+        }\n+        else if same_span && multiline {\n+            span_lint(cx, OPTION_MAP_UNWRAP_OR_ELSE, expr.span, msg);\n+        };\n+    }\n+}\n+\n // Given a `Result<T, E>` type, return its error type (`E`)\n fn get_error_type<'a>(cx: &LateContext, ty: ty::Ty<'a>) -> Option<ty::Ty<'a>> {\n     if !match_type(cx, ty, &RESULT_PATH) {"}, {"sha": "479ee142514133837eee71ef4a3fbd58934f9aca", "filename": "src/utils.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f1aac931bdb687c12b77980e52458ae921f90f21/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1aac931bdb687c12b77980e52458ae921f90f21/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=f1aac931bdb687c12b77980e52458ae921f90f21", "patch": "@@ -136,6 +136,7 @@ pub fn match_impl_method(cx: &LateContext, expr: &Expr, path: &[&str]) -> bool {\n         false\n     }\n }\n+\n /// check if method call given in \"expr\" belongs to given trait\n pub fn match_trait_method(cx: &LateContext, expr: &Expr, path: &[&str]) -> bool {\n     let method_call = ty::MethodCall::expr(expr.id);\n@@ -163,6 +164,27 @@ pub fn match_path_ast(path: &ast::Path, segments: &[&str]) -> bool {\n         |(a, b)| a.identifier.name.as_str() == *b)\n }\n \n+/// match an Expr against a chain of methods. For example, if `expr` represents the `.baz()` in\n+/// `foo.bar().baz()`, `matched_method_chain(expr, &[\"bar\", \"baz\"])` will return true.\n+pub fn match_method_chain(expr: &Expr, methods: &[&str]) -> bool {\n+    let mut current = &expr.node ;\n+    for method_name in methods.iter().rev() { // method chains are stored last -> first\n+        if let ExprMethodCall(ref name, _, ref args) = *current {\n+            if name.node.as_str() == *method_name {\n+                current = &args[0].node\n+            }\n+            else {\n+                return false;\n+            }\n+        }\n+        else {\n+            return false;\n+        }\n+    }\n+    true\n+}\n+\n+\n /// get the name of the item the expression is in, if available\n pub fn get_item_name(cx: &LateContext, expr: &Expr) -> Option<Name> {\n     let parent_id = cx.tcx.map.get_parent(expr.id);"}]}