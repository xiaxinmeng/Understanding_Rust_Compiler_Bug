{"sha": "e0b08533b4ffa73185fb6f510873ad57a56dac30", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUwYjA4NTMzYjRmZmE3MzE4NWZiNmY1MTA4NzNhZDU3YTU2ZGFjMzA=", "commit": {"author": {"name": "blake2-ppc", "email": "blake2-ppc", "date": "2013-08-08T20:07:21Z"}, "committer": {"name": "blake2-ppc", "email": "blake2-ppc", "date": "2013-08-08T20:07:21Z"}, "message": "std: Implement traits for the one-tuple\n\n(A,) did not have the trait implementations of 2- to 12- tuples.", "tree": {"sha": "d4f625ebf5a74414ed25b5cb6bbfe6ce262db092", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d4f625ebf5a74414ed25b5cb6bbfe6ce262db092"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e0b08533b4ffa73185fb6f510873ad57a56dac30", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e0b08533b4ffa73185fb6f510873ad57a56dac30", "html_url": "https://github.com/rust-lang/rust/commit/e0b08533b4ffa73185fb6f510873ad57a56dac30", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e0b08533b4ffa73185fb6f510873ad57a56dac30/comments", "author": null, "committer": null, "parents": [{"sha": "a2e3cdfc362e27152bb6a3ad6ba0cefc13f061a9", "url": "https://api.github.com/repos/rust-lang/rust/commits/a2e3cdfc362e27152bb6a3ad6ba0cefc13f061a9", "html_url": "https://github.com/rust-lang/rust/commit/a2e3cdfc362e27152bb6a3ad6ba0cefc13f061a9"}], "stats": {"total": 45, "additions": 25, "deletions": 20}, "files": [{"sha": "bf4c67e10919e1ce8367be9ab5a85ea1bec8e0c3", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e0b08533b4ffa73185fb6f510873ad57a56dac30/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0b08533b4ffa73185fb6f510873ad57a56dac30/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=e0b08533b4ffa73185fb6f510873ad57a56dac30", "patch": "@@ -69,6 +69,7 @@ pub use from_str::FromStr;\n pub use to_bytes::IterBytes;\n pub use to_str::{ToStr, ToStrConsume};\n pub use tuple::{CopyableTuple, ImmutableTuple, ExtendedTupleOps};\n+pub use tuple::{CloneableTuple1, ImmutableTuple1};\n pub use tuple::{CloneableTuple2, CloneableTuple3, CloneableTuple4, CloneableTuple5};\n pub use tuple::{CloneableTuple6, CloneableTuple7, CloneableTuple8, CloneableTuple9};\n pub use tuple::{CloneableTuple10, CloneableTuple11, CloneableTuple12};"}, {"sha": "3dc7f65b3add19fc4377d7cf9aec5fd85cc8d3f1", "filename": "src/libstd/tuple.rs", "status": "modified", "additions": 24, "deletions": 20, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/e0b08533b4ffa73185fb6f510873ad57a56dac30/src%2Flibstd%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0b08533b4ffa73185fb6f510873ad57a56dac30/src%2Flibstd%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftuple.rs?ref=e0b08533b4ffa73185fb6f510873ad57a56dac30", "patch": "@@ -148,7 +148,7 @@ macro_rules! tuple_impls {\n                     $(fn $get_fn(&self) -> $T;)+\n                 }\n \n-                impl<$($T:Clone),+> $cloneable_trait<$($T),+> for ($($T),+) {\n+                impl<$($T:Clone),+> $cloneable_trait<$($T),+> for ($($T,)+) {\n                     $(\n                         #[inline]\n                         fn $get_fn(&self) -> $T {\n@@ -161,7 +161,7 @@ macro_rules! tuple_impls {\n                     $(fn $get_ref_fn<'a>(&'a self) -> &'a $T;)+\n                 }\n \n-                impl<$($T),+> $immutable_trait<$($T),+> for ($($T),+) {\n+                impl<$($T),+> $immutable_trait<$($T),+> for ($($T,)+) {\n                     $(\n                         #[inline]\n                         fn $get_ref_fn<'a>(&'a self) -> &'a $T {\n@@ -170,59 +170,59 @@ macro_rules! tuple_impls {\n                     )+\n                 }\n \n-                impl<$($T:Clone),+> Clone for ($($T),+) {\n-                    fn clone(&self) -> ($($T),+) {\n-                        ($(self.$get_ref_fn().clone()),+)\n+                impl<$($T:Clone),+> Clone for ($($T,)+) {\n+                    fn clone(&self) -> ($($T,)+) {\n+                        ($(self.$get_ref_fn().clone(),)+)\n                     }\n                 }\n \n                 #[cfg(not(test))]\n-                impl<$($T:Eq),+> Eq for ($($T),+) {\n+                impl<$($T:Eq),+> Eq for ($($T,)+) {\n                     #[inline]\n-                    fn eq(&self, other: &($($T),+)) -> bool {\n+                    fn eq(&self, other: &($($T,)+)) -> bool {\n                         $(*self.$get_ref_fn() == *other.$get_ref_fn())&&+\n                     }\n                     #[inline]\n-                    fn ne(&self, other: &($($T),+)) -> bool {\n+                    fn ne(&self, other: &($($T,)+)) -> bool {\n                         !(*self == *other)\n                     }\n                 }\n \n                 #[cfg(not(test))]\n-                impl<$($T:TotalEq),+> TotalEq for ($($T),+) {\n+                impl<$($T:TotalEq),+> TotalEq for ($($T,)+) {\n                     #[inline]\n-                    fn equals(&self, other: &($($T),+)) -> bool {\n+                    fn equals(&self, other: &($($T,)+)) -> bool {\n                         $(self.$get_ref_fn().equals(other.$get_ref_fn()))&&+\n                     }\n                 }\n \n                 #[cfg(not(test))]\n-                impl<$($T:Ord),+> Ord for ($($T),+) {\n+                impl<$($T:Ord),+> Ord for ($($T,)+) {\n                     #[inline]\n-                    fn lt(&self, other: &($($T),+)) -> bool {\n+                    fn lt(&self, other: &($($T,)+)) -> bool {\n                         lexical_lt!($(self.$get_ref_fn(), other.$get_ref_fn()),+)\n                     }\n                     #[inline]\n-                    fn le(&self, other: &($($T),+)) -> bool { !(*other).lt(&(*self)) }\n+                    fn le(&self, other: &($($T,)+)) -> bool { !(*other).lt(&(*self)) }\n                     #[inline]\n-                    fn ge(&self, other: &($($T),+)) -> bool { !(*self).lt(other) }\n+                    fn ge(&self, other: &($($T,)+)) -> bool { !(*self).lt(other) }\n                     #[inline]\n-                    fn gt(&self, other: &($($T),+)) -> bool { (*other).lt(&(*self)) }\n+                    fn gt(&self, other: &($($T,)+)) -> bool { (*other).lt(&(*self)) }\n                 }\n \n                 #[cfg(not(test))]\n-                impl<$($T:TotalOrd),+> TotalOrd for ($($T),+) {\n+                impl<$($T:TotalOrd),+> TotalOrd for ($($T,)+) {\n                     #[inline]\n-                    fn cmp(&self, other: &($($T),+)) -> Ordering {\n+                    fn cmp(&self, other: &($($T,)+)) -> Ordering {\n                         lexical_cmp!($(self.$get_ref_fn(), other.$get_ref_fn()),+)\n                     }\n                 }\n \n                 #[cfg(not(test))]\n-                impl<$($T:Zero),+> Zero for ($($T),+) {\n+                impl<$($T:Zero),+> Zero for ($($T,)+) {\n                     #[inline]\n-                    fn zero() -> ($($T),+) {\n-                        ($(Zero::zero::<$T>()),+)\n+                    fn zero() -> ($($T,)+) {\n+                        ($(Zero::zero::<$T>(),)+)\n                     }\n                     #[inline]\n                     fn is_zero(&self) -> bool {\n@@ -259,6 +259,10 @@ macro_rules! lexical_cmp {\n \n \n tuple_impls! {\n+    (CloneableTuple1, ImmutableTuple1) {\n+        (n0, n0_ref) -> A { (ref a,) => a }\n+    }\n+\n     (CloneableTuple2, ImmutableTuple2) {\n         (n0, n0_ref) -> A { (ref a,_) => a }\n         (n1, n1_ref) -> B { (_,ref b) => b }"}]}