{"sha": "3b75dda7454ca26afc70aae55d48706441eceff9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNiNzVkZGE3NDU0Y2EyNmFmYzcwYWFlNTVkNDg3MDY0NDFlY2VmZjk=", "commit": {"author": {"name": "Vladyslav Katasonov", "email": "cpud47@gmail.com", "date": "2021-02-16T01:43:32Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-03-02T13:23:00Z"}, "message": "try to suggest name when extracting variable", "tree": {"sha": "6fa1f586b671b5c8c8ff0677fddb8555ea363469", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6fa1f586b671b5c8c8ff0677fddb8555ea363469"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3b75dda7454ca26afc70aae55d48706441eceff9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3b75dda7454ca26afc70aae55d48706441eceff9", "html_url": "https://github.com/rust-lang/rust/commit/3b75dda7454ca26afc70aae55d48706441eceff9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3b75dda7454ca26afc70aae55d48706441eceff9/comments", "author": {"login": "cpud36", "id": 4218373, "node_id": "MDQ6VXNlcjQyMTgzNzM=", "avatar_url": "https://avatars.githubusercontent.com/u/4218373?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cpud36", "html_url": "https://github.com/cpud36", "followers_url": "https://api.github.com/users/cpud36/followers", "following_url": "https://api.github.com/users/cpud36/following{/other_user}", "gists_url": "https://api.github.com/users/cpud36/gists{/gist_id}", "starred_url": "https://api.github.com/users/cpud36/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cpud36/subscriptions", "organizations_url": "https://api.github.com/users/cpud36/orgs", "repos_url": "https://api.github.com/users/cpud36/repos", "events_url": "https://api.github.com/users/cpud36/events{/privacy}", "received_events_url": "https://api.github.com/users/cpud36/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8eee9149e87ea58d4191d04ebe6faf57ac8485a3", "url": "https://api.github.com/repos/rust-lang/rust/commits/8eee9149e87ea58d4191d04ebe6faf57ac8485a3", "html_url": "https://github.com/rust-lang/rust/commit/8eee9149e87ea58d4191d04ebe6faf57ac8485a3"}], "stats": {"total": 294, "additions": 287, "deletions": 7}, "files": [{"sha": "32e54fd57539ebbd5f0f02a3105fcbd829dceb0d", "filename": "crates/ide_assists/src/handlers/extract_variable.rs", "status": "modified", "additions": 287, "deletions": 7, "changes": 294, "blob_url": "https://github.com/rust-lang/rust/blob/3b75dda7454ca26afc70aae55d48706441eceff9/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b75dda7454ca26afc70aae55d48706441eceff9/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_variable.rs?ref=3b75dda7454ca26afc70aae55d48706441eceff9", "patch": "@@ -1,6 +1,7 @@\n-use stdx::format_to;\n+use itertools::Itertools;\n+use stdx::{format_to, to_lower_snake_case};\n use syntax::{\n-    ast::{self, AstNode},\n+    ast::{self, AstNode, NameOwner},\n     SyntaxKind::{\n         BLOCK_EXPR, BREAK_EXPR, CLOSURE_EXPR, COMMENT, LOOP_EXPR, MATCH_ARM, PATH_EXPR, RETURN_EXPR,\n     },\n@@ -54,7 +55,7 @@ pub(crate) fn extract_variable(acc: &mut Assists, ctx: &AssistContext) -> Option\n \n             let var_name = match &field_shorthand {\n                 Some(it) => it.to_string(),\n-                None => \"var_name\".to_string(),\n+                None => suggest_variable_name(ctx, &to_extract),\n             };\n             let expr_range = match &field_shorthand {\n                 Some(it) => it.syntax().text_range().cover(to_extract.syntax().text_range()),\n@@ -173,6 +174,89 @@ impl Anchor {\n     }\n }\n \n+fn suggest_variable_name(ctx: &AssistContext, expr: &ast::Expr) -> String {\n+    // FIXME: account for existing names in the scope\n+    suggest_name_from_func(expr)\n+        .or_else(|| suggest_name_from_method(expr))\n+        .or_else(|| suggest_name_from_param(ctx, expr))\n+        .or_else(|| suggest_name_by_type(ctx, expr))\n+        .unwrap_or_else(|| \"var_name\".to_string())\n+}\n+\n+fn normalize_name(name: &str) -> Option<String> {\n+    let name = to_lower_snake_case(name);\n+\n+    let useless_names = [\"new\", \"default\", \"some\", \"none\", \"ok\", \"err\"];\n+    if useless_names.contains(&name.as_str()) {\n+        return None;\n+    }\n+\n+    Some(name)\n+}\n+\n+fn suggest_name_from_func(expr: &ast::Expr) -> Option<String> {\n+    let call = match expr {\n+        ast::Expr::CallExpr(call) => call,\n+        _ => return None,\n+    };\n+    let func = match call.expr()? {\n+        ast::Expr::PathExpr(path) => path,\n+        _ => return None,\n+    };\n+    let ident = func.path()?.segment()?.name_ref()?.ident_token()?;\n+    normalize_name(ident.text())\n+}\n+\n+fn suggest_name_from_method(expr: &ast::Expr) -> Option<String> {\n+    let method = match expr {\n+        ast::Expr::MethodCallExpr(call) => call,\n+        _ => return None,\n+    };\n+    let ident = method.name_ref()?.ident_token()?;\n+    normalize_name(ident.text())\n+}\n+\n+fn suggest_name_from_param(ctx: &AssistContext, expr: &ast::Expr) -> Option<String> {\n+    let arg_list = expr.syntax().parent().and_then(ast::ArgList::cast)?;\n+    let args_parent = arg_list.syntax().parent()?;\n+    let func = if let Some(call) = ast::CallExpr::cast(args_parent.clone()) {\n+        let func = call.expr()?;\n+        let func_ty = ctx.sema.type_of_expr(&func)?;\n+        func_ty.as_callable(ctx.db())?\n+    } else if let Some(method) = ast::MethodCallExpr::cast(args_parent) {\n+        ctx.sema.resolve_method_call_as_callable(&method)?\n+    } else {\n+        return None;\n+    };\n+\n+    let (idx, _) = arg_list.args().find_position(|it| it == expr).unwrap();\n+    let (pat, _) = func.params(ctx.db()).into_iter().nth(idx)?;\n+    let param = match pat? {\n+        either::Either::Right(ast::Pat::IdentPat(param)) => param,\n+        _ => return None,\n+    };\n+    let name = param.name()?;\n+    normalize_name(&name.to_string())\n+}\n+\n+fn suggest_name_by_type(ctx: &AssistContext, expr: &ast::Expr) -> Option<String> {\n+    let ty = ctx.sema.type_of_expr(expr)?;\n+    let ty = ty.remove_ref().unwrap_or(ty);\n+\n+    name_from_type(ty, ctx)\n+}\n+\n+fn name_from_type(ty: hir::Type, ctx: &AssistContext) -> Option<String> {\n+    let name = if let Some(adt) = ty.as_adt() {\n+        adt.name(ctx.db()).to_string()\n+    } else if let Some(trait_) = ty.as_dyn_trait() {\n+        trait_.name(ctx.db()).to_string()\n+    } else {\n+        return None;\n+    };\n+    normalize_name(&name)\n+}\n+\n #[cfg(test)]\n mod tests {\n     use test_utils::mark;\n@@ -274,8 +358,8 @@ fn foo() {\n \"#,\n             r#\"\n fn foo() {\n-    let $0var_name = bar(1 + 1);\n-    var_name\n+    let $0bar = bar(1 + 1);\n+    bar\n }\n \"#,\n         )\n@@ -401,8 +485,8 @@ fn main() {\n \",\n             \"\n fn main() {\n-    let $0var_name = bar.foo();\n-    let v = var_name;\n+    let $0foo = bar.foo();\n+    let v = foo;\n }\n \",\n         );\n@@ -556,6 +640,202 @@ fn main() {\n         )\n     }\n \n+    #[test]\n+    fn extract_var_name_from_type() {\n+        check_assist(\n+            extract_variable,\n+            r#\"\n+struct Test(i32);\n+\n+fn foo() -> Test {\n+    $0{ Test(10) }$0\n+}\n+\"#,\n+            r#\"\n+struct Test(i32);\n+\n+fn foo() -> Test {\n+    let $0test = { Test(10) };\n+    test\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn extract_var_name_from_parameter() {\n+        check_assist(\n+            extract_variable,\n+            r#\"\n+fn bar(test: u32, size: u32)\n+\n+fn foo() {\n+    bar(1, $01+1$0);\n+}\n+\"#,\n+            r#\"\n+fn bar(test: u32, size: u32)\n+\n+fn foo() {\n+    let $0size = 1+1;\n+    bar(1, size);\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn extract_var_parameter_name_has_precedence_over_type() {\n+        check_assist(\n+            extract_variable,\n+            r#\"\n+struct TextSize(u32);\n+fn bar(test: u32, size: TextSize)\n+\n+fn foo() {\n+    bar(1, $0{ TextSize(1+1) }$0);\n+}\n+\"#,\n+            r#\"\n+struct TextSize(u32);\n+fn bar(test: u32, size: TextSize)\n+\n+fn foo() {\n+    let $0size = { TextSize(1+1) };\n+    bar(1, size);\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn extract_var_name_from_function() {\n+        check_assist(\n+            extract_variable,\n+            r#\"\n+fn is_required(test: u32, size: u32) -> bool\n+\n+fn foo() -> bool {\n+    $0is_required(1, 2)$0\n+}\n+\"#,\n+            r#\"\n+fn is_required(test: u32, size: u32) -> bool\n+\n+fn foo() -> bool {\n+    let $0is_required = is_required(1, 2);\n+    is_required\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn extract_var_name_from_method() {\n+        check_assist(\n+            extract_variable,\n+            r#\"\n+struct S;\n+impl S {\n+    fn bar(&self, n: u32) -> u32 { n }\n+}\n+\n+fn foo() -> u32 {\n+    $0S.bar(1)$0\n+}\n+\"#,\n+            r#\"\n+struct S;\n+impl S {\n+    fn bar(&self, n: u32) -> u32 { n }\n+}\n+\n+fn foo() -> u32 {\n+    let $0bar = S.bar(1);\n+    bar\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn extract_var_name_from_method_param() {\n+        check_assist(\n+            extract_variable,\n+            r#\"\n+struct S;\n+impl S {\n+    fn bar(&self, n: u32, size: u32) { n }\n+}\n+\n+fn foo() {\n+    S.bar($01 + 1$0, 2)\n+}\n+\"#,\n+            r#\"\n+struct S;\n+impl S {\n+    fn bar(&self, n: u32, size: u32) { n }\n+}\n+\n+fn foo() {\n+    let $0n = 1 + 1;\n+    S.bar(n, 2)\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn extract_var_name_from_ufcs_method_param() {\n+        check_assist(\n+            extract_variable,\n+            r#\"\n+struct S;\n+impl S {\n+    fn bar(&self, n: u32, size: u32) { n }\n+}\n+\n+fn foo() {\n+    S::bar(&S, $01 + 1$0, 2)\n+}\n+\"#,\n+            r#\"\n+struct S;\n+impl S {\n+    fn bar(&self, n: u32, size: u32) { n }\n+}\n+\n+fn foo() {\n+    let $0n = 1 + 1;\n+    S::bar(&S, n, 2)\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn extract_var_function_name_has_precedence() {\n+        check_assist(\n+            extract_variable,\n+            r#\"\n+fn bar(test: u32, size: u32)\n+\n+fn foo() {\n+    bar(1, $0symbol_size(1, 2)$0);\n+}\n+\"#,\n+            r#\"\n+fn bar(test: u32, size: u32)\n+\n+fn foo() {\n+    let $0symbol_size = symbol_size(1, 2);\n+    bar(1, symbol_size);\n+}\n+\"#,\n+        )\n+    }\n+\n     #[test]\n     fn test_extract_var_for_return_not_applicable() {\n         check_assist_not_applicable(extract_variable, \"fn foo() { $0return$0; } \");"}]}