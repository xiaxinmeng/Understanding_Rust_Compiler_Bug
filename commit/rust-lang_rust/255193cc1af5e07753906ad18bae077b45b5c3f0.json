{"sha": "255193cc1af5e07753906ad18bae077b45b5c3f0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI1NTE5M2NjMWFmNWUwNzc1MzkwNmFkMThiYWUwNzdiNDViNWMzZjA=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-04-08T20:50:34Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-04-08T21:50:25Z"}, "message": "Removing no longer needed unsafe blocks", "tree": {"sha": "f4e9111de1ff4bca239408f6bd0e0518227930e1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f4e9111de1ff4bca239408f6bd0e0518227930e1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/255193cc1af5e07753906ad18bae077b45b5c3f0", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/255193cc1af5e07753906ad18bae077b45b5c3f0", "html_url": "https://github.com/rust-lang/rust/commit/255193cc1af5e07753906ad18bae077b45b5c3f0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/255193cc1af5e07753906ad18bae077b45b5c3f0/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3136fba5aeca9184c944829596b93e45886fecf2", "url": "https://api.github.com/repos/rust-lang/rust/commits/3136fba5aeca9184c944829596b93e45886fecf2", "html_url": "https://github.com/rust-lang/rust/commit/3136fba5aeca9184c944829596b93e45886fecf2"}], "stats": {"total": 862, "additions": 379, "deletions": 483}, "files": [{"sha": "6ca33540ceef61417c01b17f39e5fb3409a4e6a4", "filename": "src/libcore/char.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/255193cc1af5e07753906ad18bae077b45b5c3f0/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/255193cc1af5e07753906ad18bae077b45b5c3f0/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=255193cc1af5e07753906ad18bae077b45b5c3f0", "patch": "@@ -202,12 +202,10 @@ pub fn escape_unicode(c: char) -> ~str {\n                     else { ('U', 8u) });\n     assert!(str::len(s) <= pad);\n     let mut out = ~\"\\\\\";\n-    unsafe {\n-        str::push_str(&mut out, str::from_char(c));\n-        for uint::range(str::len(s), pad) |_i|\n-            { str::push_str(&mut out, ~\"0\"); }\n-        str::push_str(&mut out, s);\n-    }\n+    str::push_str(&mut out, str::from_char(c));\n+    for uint::range(str::len(s), pad) |_i|\n+        { str::push_str(&mut out, ~\"0\"); }\n+    str::push_str(&mut out, s);\n     out\n }\n "}, {"sha": "c229bc17311c9005984ba8b85e1ecb3eb848fbb6", "filename": "src/libcore/hash.rs", "status": "modified", "additions": 26, "deletions": 36, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/255193cc1af5e07753906ad18bae077b45b5c3f0/src%2Flibcore%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/255193cc1af5e07753906ad18bae077b45b5c3f0/src%2Flibcore%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash.rs?ref=255193cc1af5e07753906ad18bae077b45b5c3f0", "patch": "@@ -76,51 +76,43 @@ pub trait Streaming {\n impl<A:IterBytes> Hash for A {\n     #[inline(always)]\n     fn hash_keyed(&self, k0: u64, k1: u64) -> u64 {\n-        unsafe {\n-            let s = &State(k0, k1);\n-            for self.iter_bytes(true) |bytes| {\n-                s.input(bytes);\n-            }\n-            s.result_u64()\n+        let s = &State(k0, k1);\n+        for self.iter_bytes(true) |bytes| {\n+            s.input(bytes);\n         }\n+        s.result_u64()\n     }\n }\n \n fn hash_keyed_2<A: IterBytes,\n                 B: IterBytes>(a: &A, b: &B, k0: u64, k1: u64) -> u64 {\n-    unsafe {\n-        let s = &State(k0, k1);\n-        for a.iter_bytes(true) |bytes| { s.input(bytes); }\n-        for b.iter_bytes(true) |bytes| { s.input(bytes); }\n-        s.result_u64()\n-    }\n+    let s = &State(k0, k1);\n+    for a.iter_bytes(true) |bytes| { s.input(bytes); }\n+    for b.iter_bytes(true) |bytes| { s.input(bytes); }\n+    s.result_u64()\n }\n \n fn hash_keyed_3<A: IterBytes,\n                 B: IterBytes,\n                 C: IterBytes>(a: &A, b: &B, c: &C, k0: u64, k1: u64) -> u64 {\n-    unsafe {\n-        let s = &State(k0, k1);\n-        for a.iter_bytes(true) |bytes| { s.input(bytes); }\n-        for b.iter_bytes(true) |bytes| { s.input(bytes); }\n-        for c.iter_bytes(true) |bytes| { s.input(bytes); }\n-        s.result_u64()\n-    }\n+    let s = &State(k0, k1);\n+    for a.iter_bytes(true) |bytes| { s.input(bytes); }\n+    for b.iter_bytes(true) |bytes| { s.input(bytes); }\n+    for c.iter_bytes(true) |bytes| { s.input(bytes); }\n+    s.result_u64()\n }\n \n fn hash_keyed_4<A: IterBytes,\n                 B: IterBytes,\n                 C: IterBytes,\n                 D: IterBytes>(a: &A, b: &B, c: &C, d: &D, k0: u64, k1: u64)\n                            -> u64 {\n-    unsafe {\n-        let s = &State(k0, k1);\n-        for a.iter_bytes(true) |bytes| { s.input(bytes); }\n-        for b.iter_bytes(true) |bytes| { s.input(bytes); }\n-        for c.iter_bytes(true) |bytes| { s.input(bytes); }\n-        for d.iter_bytes(true) |bytes| { s.input(bytes); }\n-        s.result_u64()\n-    }\n+    let s = &State(k0, k1);\n+    for a.iter_bytes(true) |bytes| { s.input(bytes); }\n+    for b.iter_bytes(true) |bytes| { s.input(bytes); }\n+    for c.iter_bytes(true) |bytes| { s.input(bytes); }\n+    for d.iter_bytes(true) |bytes| { s.input(bytes); }\n+    s.result_u64()\n }\n \n fn hash_keyed_5<A: IterBytes,\n@@ -129,15 +121,13 @@ fn hash_keyed_5<A: IterBytes,\n                 D: IterBytes,\n                 E: IterBytes>(a: &A, b: &B, c: &C, d: &D, e: &E,\n                               k0: u64, k1: u64) -> u64 {\n-    unsafe {\n-        let s = &State(k0, k1);\n-        for a.iter_bytes(true) |bytes| { s.input(bytes); }\n-        for b.iter_bytes(true) |bytes| { s.input(bytes); }\n-        for c.iter_bytes(true) |bytes| { s.input(bytes); }\n-        for d.iter_bytes(true) |bytes| { s.input(bytes); }\n-        for e.iter_bytes(true) |bytes| { s.input(bytes); }\n-        s.result_u64()\n-    }\n+    let s = &State(k0, k1);\n+    for a.iter_bytes(true) |bytes| { s.input(bytes); }\n+    for b.iter_bytes(true) |bytes| { s.input(bytes); }\n+    for c.iter_bytes(true) |bytes| { s.input(bytes); }\n+    for d.iter_bytes(true) |bytes| { s.input(bytes); }\n+    for e.iter_bytes(true) |bytes| { s.input(bytes); }\n+    s.result_u64()\n }\n \n // Implement State as SipState"}, {"sha": "9374829dcb86bd0d77a1d19bc0c1ea06532e4e5e", "filename": "src/libcore/num/strconv.rs", "status": "modified", "additions": 33, "deletions": 47, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/255193cc1af5e07753906ad18bae077b45b5c3f0/src%2Flibcore%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/255193cc1af5e07753906ad18bae077b45b5c3f0/src%2Flibcore%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fstrconv.rs?ref=255193cc1af5e07753906ad18bae077b45b5c3f0", "patch": "@@ -228,10 +228,8 @@ pub fn to_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+NumStrConv+Copy+\n         deccum /= radix_gen;\n         deccum = deccum.round_to_zero();\n \n-        unsafe { // FIXME: Pureness workaround (#4568)\n-            buf.push(char::from_digit(current_digit.to_int() as uint, radix)\n-                 .unwrap() as u8);\n-        }\n+        buf.push(char::from_digit(current_digit.to_int() as uint, radix)\n+             .unwrap() as u8);\n \n         // No more digits to calculate for the non-fractional part -> break\n         if deccum == _0 { break; }\n@@ -247,21 +245,15 @@ pub fn to_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+NumStrConv+Copy+\n     // Decide what sign to put in front\n     match sign {\n         SignNeg | SignAll if neg => {\n-            unsafe { // FIXME: Pureness workaround (#4568)\n-                buf.push('-' as u8);\n-            }\n+            buf.push('-' as u8);\n         }\n         SignAll => {\n-            unsafe { // FIXME: Pureness workaround (#4568)\n-                buf.push('+' as u8);\n-            }\n+            buf.push('+' as u8);\n         }\n         _ => ()\n     }\n \n-    unsafe { // FIXME: Pureness workaround (#4568)\n-        vec::reverse(buf);\n-    }\n+    vec::reverse(buf);\n \n     // Remember start of the fractional digits.\n     // Points one beyond end of buf if none get generated,\n@@ -271,9 +263,7 @@ pub fn to_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+NumStrConv+Copy+\n     // Now emit the fractional part, if any\n     deccum = num.fractional_part();\n     if deccum != _0 || (limit_digits && exact && digit_count > 0) {\n-        unsafe { // FIXME: Pureness workaround (#4568)\n-            buf.push('.' as u8);\n-        }\n+        buf.push('.' as u8);\n         let mut dig = 0u;\n \n         // calculate new digits while\n@@ -299,10 +289,8 @@ pub fn to_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+NumStrConv+Copy+\n                 current_digit_signed\n             };\n \n-            unsafe { // FIXME: Pureness workaround (#4568)\n-                buf.push(char::from_digit(\n-                    current_digit.to_int() as uint, radix).unwrap() as u8);\n-            }\n+            buf.push(char::from_digit(\n+                current_digit.to_int() as uint, radix).unwrap() as u8);\n \n             // Decrease the deccumulator one fractional digit at a time\n             deccum = deccum.fractional_part();\n@@ -320,33 +308,31 @@ pub fn to_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+NumStrConv+Copy+\n                 char::from_digit(val, radix).unwrap() as u8\n             };\n \n-            unsafe { // FIXME: Pureness workaround (#4568)\n-                let extra_digit = ascii2value(buf.pop());\n-                if extra_digit >= radix / 2 { // -> need to round\n-                    let mut i: int = buf.len() as int - 1;\n-                    loop {\n-                        // If reached left end of number, have to\n-                        // insert additional digit:\n-                        if i < 0\n-                        || buf[i] == '-' as u8\n-                        || buf[i] == '+' as u8 {\n-                            buf.insert((i + 1) as uint, value2ascii(1));\n-                            break;\n-                        }\n-\n-                        // Skip the '.'\n-                        if buf[i] == '.' as u8 { i -= 1; loop; }\n-\n-                        // Either increment the digit,\n-                        // or set to 0 if max and carry the 1.\n-                        let current_digit = ascii2value(buf[i]);\n-                        if current_digit < (radix - 1) {\n-                            buf[i] = value2ascii(current_digit+1);\n-                            break;\n-                        } else {\n-                            buf[i] = value2ascii(0);\n-                            i -= 1;\n-                        }\n+            let extra_digit = ascii2value(buf.pop());\n+            if extra_digit >= radix / 2 { // -> need to round\n+                let mut i: int = buf.len() as int - 1;\n+                loop {\n+                    // If reached left end of number, have to\n+                    // insert additional digit:\n+                    if i < 0\n+                    || buf[i] == '-' as u8\n+                    || buf[i] == '+' as u8 {\n+                        buf.insert((i + 1) as uint, value2ascii(1));\n+                        break;\n+                    }\n+\n+                    // Skip the '.'\n+                    if buf[i] == '.' as u8 { i -= 1; loop; }\n+\n+                    // Either increment the digit,\n+                    // or set to 0 if max and carry the 1.\n+                    let current_digit = ascii2value(buf[i]);\n+                    if current_digit < (radix - 1) {\n+                        buf[i] = value2ascii(current_digit+1);\n+                        break;\n+                    } else {\n+                        buf[i] = value2ascii(0);\n+                        i -= 1;\n                     }\n                 }\n             }"}, {"sha": "8fd81a2060342ef12286b7aef483d5992dd2ba20", "filename": "src/libcore/result.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/255193cc1af5e07753906ad18bae077b45b5c3f0/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/255193cc1af5e07753906ad18bae077b45b5c3f0/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=255193cc1af5e07753906ad18bae077b45b5c3f0", "patch": "@@ -39,9 +39,8 @@ pub enum Result<T, U> {\n pub fn get<T:Copy,U>(res: &Result<T, U>) -> T {\n     match *res {\n       Ok(copy t) => t,\n-      Err(ref the_err) => unsafe {\n+      Err(ref the_err) =>\n         fail!(fmt!(\"get called on error result: %?\", *the_err))\n-      }\n     }\n }\n \n@@ -56,9 +55,8 @@ pub fn get<T:Copy,U>(res: &Result<T, U>) -> T {\n pub fn get_ref<'a, T, U>(res: &'a Result<T, U>) -> &'a T {\n     match *res {\n         Ok(ref t) => t,\n-        Err(ref the_err) => unsafe {\n+        Err(ref the_err) =>\n             fail!(fmt!(\"get_ref called on error result: %?\", *the_err))\n-        }\n     }\n }\n "}, {"sha": "f1605309fb4886cc59e2ac89e1571eca6ec11f52", "filename": "src/libcore/str.rs", "status": "modified", "additions": 24, "deletions": 34, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/255193cc1af5e07753906ad18bae077b45b5c3f0/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/255193cc1af5e07753906ad18bae077b45b5c3f0/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=255193cc1af5e07753906ad18bae077b45b5c3f0", "patch": "@@ -1020,11 +1020,9 @@ pub fn any(ss: &str, pred: &fn(char) -> bool) -> bool {\n /// Apply a function to each character\n pub fn map(ss: &str, ff: &fn(char) -> char) -> ~str {\n     let mut result = ~\"\";\n-    unsafe {\n-        reserve(&mut result, len(ss));\n-        for ss.each_char |cc| {\n-            str::push_char(&mut result, ff(cc));\n-        }\n+    reserve(&mut result, len(ss));\n+    for ss.each_char |cc| {\n+        str::push_char(&mut result, ff(cc));\n     }\n     result\n }\n@@ -1660,20 +1658,18 @@ pub fn to_utf16(s: &str) -> ~[u16] {\n         // Arithmetic with u32 literals is easier on the eyes than chars.\n         let mut ch = ch as u32;\n \n-        unsafe {\n-            if (ch & 0xFFFF_u32) == ch {\n-                // The BMP falls through (assuming non-surrogate, as it\n-                // should)\n-                assert!(ch <= 0xD7FF_u32 || ch >= 0xE000_u32);\n-                u.push(ch as u16)\n-            } else {\n-                // Supplementary planes break into surrogates.\n-                assert!(ch >= 0x1_0000_u32 && ch <= 0x10_FFFF_u32);\n-                ch -= 0x1_0000_u32;\n-                let w1 = 0xD800_u16 | ((ch >> 10) as u16);\n-                let w2 = 0xDC00_u16 | ((ch as u16) & 0x3FF_u16);\n-                u.push_all(~[w1, w2])\n-            }\n+        if (ch & 0xFFFF_u32) == ch {\n+            // The BMP falls through (assuming non-surrogate, as it\n+            // should)\n+            assert!(ch <= 0xD7FF_u32 || ch >= 0xE000_u32);\n+            u.push(ch as u16)\n+        } else {\n+            // Supplementary planes break into surrogates.\n+            assert!(ch >= 0x1_0000_u32 && ch <= 0x10_FFFF_u32);\n+            ch -= 0x1_0000_u32;\n+            let w1 = 0xD800_u16 | ((ch >> 10) as u16);\n+            let w2 = 0xDC00_u16 | ((ch as u16) & 0x3FF_u16);\n+            u.push_all(~[w1, w2])\n         }\n     }\n     u\n@@ -1705,16 +1701,14 @@ pub fn utf16_chars(v: &[u16], f: &fn(char)) {\n \n pub fn from_utf16(v: &[u16]) -> ~str {\n     let mut buf = ~\"\";\n-    unsafe {\n-        reserve(&mut buf, vec::len(v));\n-        utf16_chars(v, |ch| push_char(&mut buf, ch));\n-    }\n+    reserve(&mut buf, vec::len(v));\n+    utf16_chars(v, |ch| push_char(&mut buf, ch));\n     buf\n }\n \n pub fn with_capacity(capacity: uint) -> ~str {\n     let mut buf = ~\"\";\n-    unsafe { reserve(&mut buf, capacity); }\n+    reserve(&mut buf, capacity);\n     buf\n }\n \n@@ -2105,23 +2099,19 @@ pub fn capacity(s: &const ~str) -> uint {\n /// Escape each char in `s` with char::escape_default.\n pub fn escape_default(s: &str) -> ~str {\n     let mut out: ~str = ~\"\";\n-    unsafe {\n-        reserve_at_least(&mut out, str::len(s));\n-        for s.each_char |c| {\n-            push_str(&mut out, char::escape_default(c));\n-        }\n+    reserve_at_least(&mut out, str::len(s));\n+    for s.each_char |c| {\n+        push_str(&mut out, char::escape_default(c));\n     }\n     out\n }\n \n /// Escape each char in `s` with char::escape_unicode.\n pub fn escape_unicode(s: &str) -> ~str {\n     let mut out: ~str = ~\"\";\n-    unsafe {\n-        reserve_at_least(&mut out, str::len(s));\n-        for s.each_char |c| {\n-            push_str(&mut out, char::escape_unicode(c));\n-        }\n+    reserve_at_least(&mut out, str::len(s));\n+    for s.each_char |c| {\n+        push_str(&mut out, char::escape_unicode(c));\n     }\n     out\n }"}, {"sha": "980d4b445d04da8e7be66902b9025db92532d018", "filename": "src/libcore/to_str.rs", "status": "modified", "additions": 21, "deletions": 42, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/255193cc1af5e07753906ad18bae077b45b5c3f0/src%2Flibcore%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/255193cc1af5e07753906ad18bae077b45b5c3f0/src%2Flibcore%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fto_str.rs?ref=255193cc1af5e07753906ad18bae077b45b5c3f0", "patch": "@@ -72,63 +72,42 @@ impl<A:ToStr,B:ToStr,C:ToStr> ToStr for (A, B, C) {\n impl<'self,A:ToStr> ToStr for &'self [A] {\n     #[inline(always)]\n     fn to_str(&self) -> ~str {\n-        unsafe {\n-            // FIXME #4568\n-            // Bleh -- not really unsafe\n-            // push_str and push_char\n-            let mut acc = ~\"[\", first = true;\n-            for self.each |elt| {\n-                unsafe {\n-                    if first { first = false; }\n-                    else { str::push_str(&mut acc, ~\", \"); }\n-                    str::push_str(&mut acc, elt.to_str());\n-                }\n-            }\n-            str::push_char(&mut acc, ']');\n-            acc\n+        let mut acc = ~\"[\", first = true;\n+        for self.each |elt| {\n+            if first { first = false; }\n+            else { str::push_str(&mut acc, ~\", \"); }\n+            str::push_str(&mut acc, elt.to_str());\n         }\n+        str::push_char(&mut acc, ']');\n+        acc\n     }\n }\n \n impl<A:ToStr> ToStr for ~[A] {\n     #[inline(always)]\n     fn to_str(&self) -> ~str {\n-        unsafe {\n-            // FIXME #4568\n-            // Bleh -- not really unsafe\n-            // push_str and push_char\n-            let mut acc = ~\"[\", first = true;\n-            for self.each |elt| {\n-                unsafe {\n-                    if first { first = false; }\n-                    else { str::push_str(&mut acc, ~\", \"); }\n-                    str::push_str(&mut acc, elt.to_str());\n-                }\n-            }\n-            str::push_char(&mut acc, ']');\n-            acc\n+        let mut acc = ~\"[\", first = true;\n+        for self.each |elt| {\n+            if first { first = false; }\n+            else { str::push_str(&mut acc, ~\", \"); }\n+            str::push_str(&mut acc, elt.to_str());\n         }\n+        str::push_char(&mut acc, ']');\n+        acc\n     }\n }\n \n impl<A:ToStr> ToStr for @[A] {\n     #[inline(always)]\n     fn to_str(&self) -> ~str {\n-        unsafe {\n-            // FIXME #4568\n-            // Bleh -- not really unsafe\n-            // push_str and push_char\n-            let mut acc = ~\"[\", first = true;\n-            for self.each |elt| {\n-                unsafe {\n-                    if first { first = false; }\n-                    else { str::push_str(&mut acc, ~\", \"); }\n-                    str::push_str(&mut acc, elt.to_str());\n-                }\n-            }\n-            str::push_char(&mut acc, ']');\n-            acc\n+        let mut acc = ~\"[\", first = true;\n+        for self.each |elt| {\n+            if first { first = false; }\n+            else { str::push_str(&mut acc, ~\", \"); }\n+            str::push_str(&mut acc, elt.to_str());\n         }\n+        str::push_char(&mut acc, ']');\n+        acc\n     }\n }\n "}, {"sha": "5b06591f9ecc8c4f47628f7aeb9e2a7dc5e30f85", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 33, "deletions": 48, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/255193cc1af5e07753906ad18bae077b45b5c3f0/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/255193cc1af5e07753906ad18bae077b45b5c3f0/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=255193cc1af5e07753906ad18bae077b45b5c3f0", "patch": "@@ -167,7 +167,7 @@ pub fn from_slice<T:Copy>(t: &[T]) -> ~[T] {\n \n pub fn with_capacity<T>(capacity: uint) -> ~[T] {\n     let mut vec = ~[];\n-    unsafe { reserve(&mut vec, capacity); }\n+    reserve(&mut vec, capacity);\n     vec\n }\n \n@@ -186,7 +186,7 @@ pub fn with_capacity<T>(capacity: uint) -> ~[T] {\n #[inline(always)]\n pub fn build_sized<A>(size: uint, builder: &fn(push: &fn(v: A))) -> ~[A] {\n     let mut vec = with_capacity(size);\n-    builder(|x| unsafe { vec.push(x) });\n+    builder(|x| vec.push(x));\n     vec\n }\n \n@@ -437,12 +437,10 @@ pub fn partitioned<T:Copy>(v: &[T], f: &fn(&T) -> bool) -> (~[T], ~[T]) {\n     let mut rights = ~[];\n \n     for each(v) |elt| {\n-        unsafe {\n-            if f(elt) {\n-                lefts.push(*elt);\n-            } else {\n-                rights.push(*elt);\n-            }\n+        if f(elt) {\n+            lefts.push(*elt);\n+        } else {\n+            rights.push(*elt);\n         }\n     }\n \n@@ -735,16 +733,14 @@ pub fn dedup<T:Eq>(v: &mut ~[T]) {\n #[inline(always)]\n pub fn append<T:Copy>(lhs: ~[T], rhs: &const [T]) -> ~[T] {\n     let mut v = lhs;\n-    unsafe {\n-        v.push_all(rhs);\n-    }\n+    v.push_all(rhs);\n     v\n }\n \n #[inline(always)]\n pub fn append_one<T>(lhs: ~[T], x: T) -> ~[T] {\n     let mut v = lhs;\n-    unsafe { v.push(x); }\n+    v.push(x);\n     v\n }\n \n@@ -811,9 +807,7 @@ pub fn grow_set<T:Copy>(v: &mut ~[T], index: uint, initval: &T, val: T) {\n pub fn map<T, U>(v: &[T], f: &fn(t: &T) -> U) -> ~[U] {\n     let mut result = with_capacity(len(v));\n     for each(v) |elem| {\n-        unsafe {\n-            result.push(f(elem));\n-        }\n+        result.push(f(elem));\n     }\n     result\n }\n@@ -841,7 +835,7 @@ pub fn mapi<T, U>(v: &[T], f: &fn(uint, t: &T) -> U) -> ~[U] {\n  */\n pub fn flat_map<T, U>(v: &[T], f: &fn(t: &T) -> ~[U]) -> ~[U] {\n     let mut result = ~[];\n-    for each(v) |elem| { unsafe{ result.push_all_move(f(elem)); } }\n+    for each(v) |elem| { result.push_all_move(f(elem)); }\n     result\n }\n \n@@ -853,7 +847,7 @@ pub fn map2<T:Copy,U:Copy,V>(v0: &[T], v1: &[U],\n     let mut u: ~[V] = ~[];\n     let mut i = 0u;\n     while i < v0_len {\n-        unsafe { u.push(f(&v0[i], &v1[i])) };\n+        u.push(f(&v0[i], &v1[i]));\n         i += 1u;\n     }\n     u\n@@ -894,7 +888,7 @@ pub fn filter_mapped<T, U: Copy>(\n     for each(v) |elem| {\n         match f(elem) {\n           None => {/* no-op */ }\n-          Some(result_elem) => unsafe { result.push(result_elem); }\n+          Some(result_elem) => { result.push(result_elem); }\n         }\n     }\n     result\n@@ -927,7 +921,7 @@ pub fn filter<T>(v: ~[T], f: &fn(t: &T) -> bool) -> ~[T] {\n pub fn filtered<T:Copy>(v: &[T], f: &fn(t: &T) -> bool) -> ~[T] {\n     let mut result = ~[];\n     for each(v) |elem| {\n-        if f(elem) { unsafe { result.push(*elem); } }\n+        if f(elem) { result.push(*elem); }\n     }\n     result\n }\n@@ -959,7 +953,7 @@ pub fn retain<T>(v: &mut ~[T], f: &fn(t: &T) -> bool) {\n  */\n pub fn concat<T:Copy>(v: &[~[T]]) -> ~[T] {\n     let mut r = ~[];\n-    for each(v) |inner| { unsafe { r.push_all(*inner); } }\n+    for each(v) |inner| { r.push_all(*inner); }\n     r\n }\n \n@@ -968,8 +962,8 @@ pub fn connect<T:Copy>(v: &[~[T]], sep: &T) -> ~[T] {\n     let mut r: ~[T] = ~[];\n     let mut first = true;\n     for each(v) |inner| {\n-        if first { first = false; } else { unsafe { r.push(*sep); } }\n-        unsafe { r.push_all(*inner) };\n+        if first { first = false; } else { r.push(*sep); }\n+        r.push_all(*inner);\n     }\n     r\n }\n@@ -1236,10 +1230,8 @@ pub fn unzip_slice<T:Copy,U:Copy>(v: &[(T, U)]) -> (~[T], ~[U]) {\n     let mut ts = ~[], us = ~[];\n     for each(v) |p| {\n         let (t, u) = *p;\n-        unsafe {\n-            ts.push(t);\n-            us.push(u);\n-        }\n+        ts.push(t);\n+        us.push(u);\n     }\n     (ts, us)\n }\n@@ -1254,12 +1246,10 @@ pub fn unzip_slice<T:Copy,U:Copy>(v: &[(T, U)]) -> (~[T], ~[U]) {\n  */\n pub fn unzip<T,U>(v: ~[(T, U)]) -> (~[T], ~[U]) {\n     let mut ts = ~[], us = ~[];\n-    unsafe {\n-        do consume(v) |_i, p| {\n-            let (t, u) = p;\n-            ts.push(t);\n-            us.push(u);\n-        }\n+    do consume(v) |_i, p| {\n+        let (t, u) = p;\n+        ts.push(t);\n+        us.push(u);\n     }\n     (ts, us)\n }\n@@ -1274,7 +1264,8 @@ pub fn zip_slice<T:Copy,U:Copy>(v: &const [T], u: &const [U])\n     let mut i = 0u;\n     assert!(sz == len(u));\n     while i < sz {\n-        unsafe { zipped.push((v[i], u[i])); i += 1u; }\n+        zipped.push((v[i], u[i]));\n+        i += 1u;\n     }\n     zipped\n }\n@@ -1290,10 +1281,10 @@ pub fn zip<T, U>(mut v: ~[T], mut u: ~[U]) -> ~[(T, U)] {\n     assert!(i == len(u));\n     let mut w = with_capacity(i);\n     while i > 0 {\n-        unsafe { w.push((v.pop(),u.pop())); }\n+        w.push((v.pop(),u.pop()));\n         i -= 1;\n     }\n-    unsafe { reverse(w); }\n+    reverse(w);\n     w\n }\n \n@@ -1322,10 +1313,8 @@ pub fn reversed<T:Copy>(v: &const [T]) -> ~[T] {\n     let mut rs: ~[T] = ~[];\n     let mut i = len::<T>(v);\n     if i == 0 { return (rs); } else { i -= 1; }\n-    unsafe {\n-        while i != 0 { rs.push(v[i]); i -= 1; }\n-        rs.push(v[0]);\n-    }\n+    while i != 0 { rs.push(v[i]); i -= 1; }\n+    rs.push(v[0]);\n     rs\n }\n \n@@ -1495,12 +1484,10 @@ pub fn each_permutation<T:Copy>(v: &[T], put: &fn(ts: &[T]) -> bool) {\n         while i < ln {\n             let elt = v[i];\n             let mut rest = slice(v, 0u, i).to_vec();\n-            unsafe {\n-                rest.push_all(const_slice(v, i+1u, ln));\n-                for each_permutation(rest) |permutation| {\n-                    if !put(append(~[elt], permutation)) {\n-                        return;\n-                    }\n+            rest.push_all(const_slice(v, i+1u, ln));\n+            for each_permutation(rest) |permutation| {\n+                if !put(append(~[elt], permutation)) {\n+                    return;\n                 }\n             }\n             i += 1u;\n@@ -1514,9 +1501,7 @@ pub fn windowed<TT:Copy>(nn: uint, xx: &[TT]) -> ~[~[TT]] {\n     for vec::eachi (xx) |ii, _x| {\n         let len = xx.len();\n         if ii+nn <= len {\n-            unsafe {\n-                ww.push(slice(xx, ii, ii+nn).to_vec());\n-            }\n+            ww.push(slice(xx, ii, ii+nn).to_vec());\n         }\n     }\n     ww"}, {"sha": "781a720b1a4db6dbb075a4200cb2cb440dadf70e", "filename": "src/libstd/base64.rs", "status": "modified", "additions": 77, "deletions": 81, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/255193cc1af5e07753906ad18bae077b45b5c3f0/src%2Flibstd%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/255193cc1af5e07753906ad18bae077b45b5c3f0/src%2Flibstd%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbase64.rs?ref=255193cc1af5e07753906ad18bae077b45b5c3f0", "patch": "@@ -29,47 +29,45 @@ static CHARS: [char, ..64] = [\n impl<'self> ToBase64 for &'self [u8] {\n     fn to_base64(&self) -> ~str {\n         let mut s = ~\"\";\n-        unsafe {\n-            let len = self.len();\n-            str::reserve(&mut s, ((len + 3u) / 4u) * 3u);\n-\n-            let mut i = 0u;\n-\n-            while i < len - (len % 3u) {\n-                let n = (self[i] as uint) << 16u |\n-                        (self[i + 1u] as uint) << 8u |\n-                        (self[i + 2u] as uint);\n-\n-                // This 24-bit number gets separated into four 6-bit numbers.\n-                str::push_char(&mut s, CHARS[(n >> 18u) & 63u]);\n-                str::push_char(&mut s, CHARS[(n >> 12u) & 63u]);\n-                str::push_char(&mut s, CHARS[(n >> 6u) & 63u]);\n-                str::push_char(&mut s, CHARS[n & 63u]);\n-\n-                i += 3u;\n-            }\n-\n-            // Heh, would be cool if we knew this was exhaustive\n-            // (the dream of bounded integer types)\n-            match len % 3 {\n-              0 => (),\n-              1 => {\n-                let n = (self[i] as uint) << 16u;\n-                str::push_char(&mut s, CHARS[(n >> 18u) & 63u]);\n-                str::push_char(&mut s, CHARS[(n >> 12u) & 63u]);\n-                str::push_char(&mut s, '=');\n-                str::push_char(&mut s, '=');\n-              }\n-              2 => {\n-                let n = (self[i] as uint) << 16u |\n-                    (self[i + 1u] as uint) << 8u;\n-                str::push_char(&mut s, CHARS[(n >> 18u) & 63u]);\n-                str::push_char(&mut s, CHARS[(n >> 12u) & 63u]);\n-                str::push_char(&mut s, CHARS[(n >> 6u) & 63u]);\n-                str::push_char(&mut s, '=');\n-              }\n-              _ => fail!(~\"Algebra is broken, please alert the math police\")\n-            }\n+        let len = self.len();\n+        str::reserve(&mut s, ((len + 3u) / 4u) * 3u);\n+\n+        let mut i = 0u;\n+\n+        while i < len - (len % 3u) {\n+            let n = (self[i] as uint) << 16u |\n+                    (self[i + 1u] as uint) << 8u |\n+                    (self[i + 2u] as uint);\n+\n+            // This 24-bit number gets separated into four 6-bit numbers.\n+            str::push_char(&mut s, CHARS[(n >> 18u) & 63u]);\n+            str::push_char(&mut s, CHARS[(n >> 12u) & 63u]);\n+            str::push_char(&mut s, CHARS[(n >> 6u) & 63u]);\n+            str::push_char(&mut s, CHARS[n & 63u]);\n+\n+            i += 3u;\n+        }\n+\n+        // Heh, would be cool if we knew this was exhaustive\n+        // (the dream of bounded integer types)\n+        match len % 3 {\n+          0 => (),\n+          1 => {\n+            let n = (self[i] as uint) << 16u;\n+            str::push_char(&mut s, CHARS[(n >> 18u) & 63u]);\n+            str::push_char(&mut s, CHARS[(n >> 12u) & 63u]);\n+            str::push_char(&mut s, '=');\n+            str::push_char(&mut s, '=');\n+          }\n+          2 => {\n+            let n = (self[i] as uint) << 16u |\n+                (self[i + 1u] as uint) << 8u;\n+            str::push_char(&mut s, CHARS[(n >> 18u) & 63u]);\n+            str::push_char(&mut s, CHARS[(n >> 12u) & 63u]);\n+            str::push_char(&mut s, CHARS[(n >> 6u) & 63u]);\n+            str::push_char(&mut s, '=');\n+          }\n+          _ => fail!(~\"Algebra is broken, please alert the math police\")\n         }\n         s\n     }\n@@ -99,49 +97,47 @@ impl FromBase64 for ~[u8] {\n \n         let mut r = vec::with_capacity((len / 4u) * 3u - padding);\n \n-        unsafe {\n-            let mut i = 0u;\n-            while i < len {\n-                let mut n = 0u;\n-\n-                for iter::repeat(4u) {\n-                    let ch = self[i] as char;\n-                    n <<= 6u;\n-\n-                    if ch >= 'A' && ch <= 'Z' {\n-                        n |= (ch as uint) - 0x41u;\n-                    } else if ch >= 'a' && ch <= 'z' {\n-                        n |= (ch as uint) - 0x47u;\n-                    } else if ch >= '0' && ch <= '9' {\n-                        n |= (ch as uint) + 0x04u;\n-                    } else if ch == '+' {\n-                        n |= 0x3Eu;\n-                    } else if ch == '/' {\n-                        n |= 0x3Fu;\n-                    } else if ch == '=' {\n-                        match len - i {\n-                          1u => {\n-                            r.push(((n >> 16u) & 0xFFu) as u8);\n-                            r.push(((n >> 8u ) & 0xFFu) as u8);\n-                            return copy r;\n-                          }\n-                          2u => {\n-                            r.push(((n >> 10u) & 0xFFu) as u8);\n-                            return copy r;\n-                          }\n-                          _ => fail!(~\"invalid base64 padding\")\n-                        }\n-                    } else {\n-                        fail!(~\"invalid base64 character\");\n+        let mut i = 0u;\n+        while i < len {\n+            let mut n = 0u;\n+\n+            for iter::repeat(4u) {\n+                let ch = self[i] as char;\n+                n <<= 6u;\n+\n+                if ch >= 'A' && ch <= 'Z' {\n+                    n |= (ch as uint) - 0x41u;\n+                } else if ch >= 'a' && ch <= 'z' {\n+                    n |= (ch as uint) - 0x47u;\n+                } else if ch >= '0' && ch <= '9' {\n+                    n |= (ch as uint) + 0x04u;\n+                } else if ch == '+' {\n+                    n |= 0x3Eu;\n+                } else if ch == '/' {\n+                    n |= 0x3Fu;\n+                } else if ch == '=' {\n+                    match len - i {\n+                      1u => {\n+                        r.push(((n >> 16u) & 0xFFu) as u8);\n+                        r.push(((n >> 8u ) & 0xFFu) as u8);\n+                        return copy r;\n+                      }\n+                      2u => {\n+                        r.push(((n >> 10u) & 0xFFu) as u8);\n+                        return copy r;\n+                      }\n+                      _ => fail!(~\"invalid base64 padding\")\n                     }\n+                } else {\n+                    fail!(~\"invalid base64 character\");\n+                }\n \n-                    i += 1u;\n-                };\n+                i += 1u;\n+            };\n \n-                r.push(((n >> 16u) & 0xFFu) as u8);\n-                r.push(((n >> 8u ) & 0xFFu) as u8);\n-                r.push(((n       ) & 0xFFu) as u8);\n-            }\n+            r.push(((n >> 16u) & 0xFFu) as u8);\n+            r.push(((n >> 8u ) & 0xFFu) as u8);\n+            r.push(((n       ) & 0xFFu) as u8);\n         }\n         r\n     }"}, {"sha": "a490065b835c1f616c830f5cfdcaa059b448627a", "filename": "src/libstd/dlist.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/255193cc1af5e07753906ad18bae077b45b5c3f0/src%2Flibstd%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/255193cc1af5e07753906ad18bae077b45b5c3f0/src%2Flibstd%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdlist.rs?ref=255193cc1af5e07753906ad18bae077b45b5c3f0", "patch": "@@ -99,7 +99,7 @@ pub fn DList<T>() -> @mut DList<T> {\n /// Creates a new dlist with a single element\n pub fn from_elem<T>(data: T) -> @mut DList<T> {\n     let list = DList();\n-    unsafe { list.push(data); }\n+    list.push(data);\n     list\n }\n \n@@ -484,11 +484,8 @@ pub impl<T:Copy> DList<T> {\n     /// Get the elements of the list as a vector. O(n).\n     fn to_vec(@mut self) -> ~[T] {\n         let mut v = vec::with_capacity(self.size);\n-        unsafe {\n-            // Take this out of the unchecked when iter's functions are pure\n-            for iter::eachi(&self) |index,data| {\n-                v[index] = *data;\n-            }\n+        for iter::eachi(&self) |index,data| {\n+            v[index] = *data;\n         }\n         v\n     }"}, {"sha": "d733a60f34fffd4076d378acc5a6701f72fe9ef5", "filename": "src/libstd/json.rs", "status": "modified", "additions": 15, "deletions": 20, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/255193cc1af5e07753906ad18bae077b45b5c3f0/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/255193cc1af5e07753906ad18bae077b45b5c3f0/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=255193cc1af5e07753906ad18bae077b45b5c3f0", "patch": "@@ -342,10 +342,7 @@ pub fn to_writer(wr: @io::Writer, json: &Json) {\n \n /// Encodes a json value into a string\n pub fn to_str(json: &Json) -> ~str {\n-    unsafe {\n-        // ugh, should be safe\n-        io::with_str_writer(|wr| to_writer(wr, json))\n-    }\n+    io::with_str_writer(|wr| to_writer(wr, json))\n }\n \n /// Encodes a json value into a io::writer\n@@ -988,23 +985,21 @@ impl Ord for Json {\n                 match *other {\n                     Number(_) | String(_) | Boolean(_) | List(_) => false,\n                     Object(ref d1) => {\n-                        unsafe {\n-                            let mut d0_flat = ~[];\n-                            let mut d1_flat = ~[];\n-\n-                            // FIXME #4430: this is horribly inefficient...\n-                            for d0.each |&(k, v)| {\n-                                 d0_flat.push((@copy *k, @copy *v));\n-                            }\n-                            d0_flat.qsort();\n-\n-                            for d1.each |&(k, v)| {\n-                                d1_flat.push((@copy *k, @copy *v));\n-                            }\n-                            d1_flat.qsort();\n-\n-                            d0_flat < d1_flat\n+                        let mut d0_flat = ~[];\n+                        let mut d1_flat = ~[];\n+\n+                        // FIXME #4430: this is horribly inefficient...\n+                        for d0.each |&(k, v)| {\n+                             d0_flat.push((@copy *k, @copy *v));\n                         }\n+                        d0_flat.qsort();\n+\n+                        for d1.each |&(k, v)| {\n+                            d1_flat.push((@copy *k, @copy *v));\n+                        }\n+                        d1_flat.qsort();\n+\n+                        d0_flat < d1_flat\n                     }\n                     Null => true\n                 }"}, {"sha": "24dd08c362e991a88d3092186ddf07af2c6dd959", "filename": "src/libstd/md4.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/255193cc1af5e07753906ad18bae077b45b5c3f0/src%2Flibstd%2Fmd4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/255193cc1af5e07753906ad18bae077b45b5c3f0/src%2Flibstd%2Fmd4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmd4.rs?ref=255193cc1af5e07753906ad18bae077b45b5c3f0", "patch": "@@ -29,14 +29,14 @@ pub fn md4(msg: &[u8]) -> Quad {\n     let mut msg = vec::append(vec::from_slice(msg), ~[0x80u8]);\n     let mut bitlen = orig_len + 8u64;\n     while (bitlen + 64u64) % 512u64 > 0u64 {\n-        unsafe {msg.push(0u8);}\n+        msg.push(0u8);\n         bitlen += 8u64;\n     }\n \n     // append length\n     let mut i = 0u64;\n     while i < 8u64 {\n-        unsafe {msg.push((orig_len >> (i * 8u64)) as u8);}\n+        msg.push((orig_len >> (i * 8u64)) as u8);\n         i += 1u64;\n     }\n "}, {"sha": "ec5d2cded8d56d468f3d2db44dba201d5dd8aa58", "filename": "src/libstd/num/bigint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/255193cc1af5e07753906ad18bae077b45b5c3f0/src%2Flibstd%2Fnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/255193cc1af5e07753906ad18bae077b45b5c3f0/src%2Flibstd%2Fnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fbigint.rs?ref=255193cc1af5e07753906ad18bae077b45b5c3f0", "patch": "@@ -341,7 +341,7 @@ pub impl BigUint {\n \n         if new_len == v.len() { return BigUint { data: v }; }\n         let mut v = v;\n-        unsafe { v.truncate(new_len); }\n+        v.truncate(new_len);\n         return BigUint { data: v };\n     }\n "}, {"sha": "f5f7f5e326a792157cefceaea295a5c36d2b25f5", "filename": "src/libstd/sha1.rs", "status": "modified", "additions": 114, "deletions": 116, "changes": 230, "blob_url": "https://github.com/rust-lang/rust/blob/255193cc1af5e07753906ad18bae077b45b5c3f0/src%2Flibstd%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/255193cc1af5e07753906ad18bae077b45b5c3f0/src%2Flibstd%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsha1.rs?ref=255193cc1af5e07753906ad18bae077b45b5c3f0", "patch": "@@ -283,134 +283,132 @@ mod tests {\n \n     #[test]\n     pub fn test() {\n-        unsafe {\n-            struct Test {\n-                input: ~str,\n-                output: ~[u8],\n-                output_str: ~str,\n-            }\n+        struct Test {\n+            input: ~str,\n+            output: ~[u8],\n+            output_str: ~str,\n+        }\n \n-            fn a_million_letter_a() -> ~str {\n-                let mut i = 0;\n-                let mut rs = ~\"\";\n-                while i < 100000 {\n-                    str::push_str(&mut rs, ~\"aaaaaaaaaa\");\n-                    i += 1;\n-                }\n-                return rs;\n+        fn a_million_letter_a() -> ~str {\n+            let mut i = 0;\n+            let mut rs = ~\"\";\n+            while i < 100000 {\n+                str::push_str(&mut rs, ~\"aaaaaaaaaa\");\n+                i += 1;\n             }\n-            // Test messages from FIPS 180-1\n+            return rs;\n+        }\n+        // Test messages from FIPS 180-1\n \n-            let fips_180_1_tests = ~[\n-                Test {\n-                    input: ~\"abc\",\n-                    output: ~[\n-                        0xA9u8, 0x99u8, 0x3Eu8, 0x36u8,\n-                        0x47u8, 0x06u8, 0x81u8, 0x6Au8,\n-                        0xBAu8, 0x3Eu8, 0x25u8, 0x71u8,\n-                        0x78u8, 0x50u8, 0xC2u8, 0x6Cu8,\n-                        0x9Cu8, 0xD0u8, 0xD8u8, 0x9Du8,\n-                    ],\n-                    output_str: ~\"a9993e364706816aba3e25717850c26c9cd0d89d\"\n-                },\n-                Test {\n-                    input:\n-                         ~\"abcdbcdecdefdefgefghfghighij\" +\n-                         ~\"hijkijkljklmklmnlmnomnopnopq\",\n-                    output: ~[\n-                        0x84u8, 0x98u8, 0x3Eu8, 0x44u8,\n-                        0x1Cu8, 0x3Bu8, 0xD2u8, 0x6Eu8,\n-                        0xBAu8, 0xAEu8, 0x4Au8, 0xA1u8,\n-                        0xF9u8, 0x51u8, 0x29u8, 0xE5u8,\n-                        0xE5u8, 0x46u8, 0x70u8, 0xF1u8,\n-                    ],\n-                    output_str: ~\"84983e441c3bd26ebaae4aa1f95129e5e54670f1\"\n-                },\n-                Test {\n-                    input: a_million_letter_a(),\n-                    output: ~[\n-                        0x34u8, 0xAAu8, 0x97u8, 0x3Cu8,\n-                        0xD4u8, 0xC4u8, 0xDAu8, 0xA4u8,\n-                        0xF6u8, 0x1Eu8, 0xEBu8, 0x2Bu8,\n-                        0xDBu8, 0xADu8, 0x27u8, 0x31u8,\n-                        0x65u8, 0x34u8, 0x01u8, 0x6Fu8,\n-                    ],\n-                    output_str: ~\"34aa973cd4c4daa4f61eeb2bdbad27316534016f\"\n-                },\n-            ];\n-            // Examples from wikipedia\n+        let fips_180_1_tests = ~[\n+            Test {\n+                input: ~\"abc\",\n+                output: ~[\n+                    0xA9u8, 0x99u8, 0x3Eu8, 0x36u8,\n+                    0x47u8, 0x06u8, 0x81u8, 0x6Au8,\n+                    0xBAu8, 0x3Eu8, 0x25u8, 0x71u8,\n+                    0x78u8, 0x50u8, 0xC2u8, 0x6Cu8,\n+                    0x9Cu8, 0xD0u8, 0xD8u8, 0x9Du8,\n+                ],\n+                output_str: ~\"a9993e364706816aba3e25717850c26c9cd0d89d\"\n+            },\n+            Test {\n+                input:\n+                     ~\"abcdbcdecdefdefgefghfghighij\" +\n+                     ~\"hijkijkljklmklmnlmnomnopnopq\",\n+                output: ~[\n+                    0x84u8, 0x98u8, 0x3Eu8, 0x44u8,\n+                    0x1Cu8, 0x3Bu8, 0xD2u8, 0x6Eu8,\n+                    0xBAu8, 0xAEu8, 0x4Au8, 0xA1u8,\n+                    0xF9u8, 0x51u8, 0x29u8, 0xE5u8,\n+                    0xE5u8, 0x46u8, 0x70u8, 0xF1u8,\n+                ],\n+                output_str: ~\"84983e441c3bd26ebaae4aa1f95129e5e54670f1\"\n+            },\n+            Test {\n+                input: a_million_letter_a(),\n+                output: ~[\n+                    0x34u8, 0xAAu8, 0x97u8, 0x3Cu8,\n+                    0xD4u8, 0xC4u8, 0xDAu8, 0xA4u8,\n+                    0xF6u8, 0x1Eu8, 0xEBu8, 0x2Bu8,\n+                    0xDBu8, 0xADu8, 0x27u8, 0x31u8,\n+                    0x65u8, 0x34u8, 0x01u8, 0x6Fu8,\n+                ],\n+                output_str: ~\"34aa973cd4c4daa4f61eeb2bdbad27316534016f\"\n+            },\n+        ];\n+        // Examples from wikipedia\n \n-            let wikipedia_tests = ~[\n-                Test {\n-                    input: ~\"The quick brown fox jumps over the lazy dog\",\n-                    output: ~[\n-                        0x2fu8, 0xd4u8, 0xe1u8, 0xc6u8,\n-                        0x7au8, 0x2du8, 0x28u8, 0xfcu8,\n-                        0xedu8, 0x84u8, 0x9eu8, 0xe1u8,\n-                        0xbbu8, 0x76u8, 0xe7u8, 0x39u8,\n-                        0x1bu8, 0x93u8, 0xebu8, 0x12u8,\n-                    ],\n-                    output_str: ~\"2fd4e1c67a2d28fced849ee1bb76e7391b93eb12\",\n-                },\n-                Test {\n-                    input: ~\"The quick brown fox jumps over the lazy cog\",\n-                    output: ~[\n-                        0xdeu8, 0x9fu8, 0x2cu8, 0x7fu8,\n-                        0xd2u8, 0x5eu8, 0x1bu8, 0x3au8,\n-                        0xfau8, 0xd3u8, 0xe8u8, 0x5au8,\n-                        0x0bu8, 0xd1u8, 0x7du8, 0x9bu8,\n-                        0x10u8, 0x0du8, 0xb4u8, 0xb3u8,\n-                    ],\n-                    output_str: ~\"de9f2c7fd25e1b3afad3e85a0bd17d9b100db4b3\",\n-                },\n-            ];\n-            let tests = fips_180_1_tests + wikipedia_tests;\n-            fn check_vec_eq(v0: ~[u8], v1: ~[u8]) {\n-                assert!((vec::len::<u8>(v0) == vec::len::<u8>(v1)));\n-                let len = vec::len::<u8>(v0);\n-                let mut i = 0u;\n-                while i < len {\n-                    let a = v0[i];\n-                    let b = v1[i];\n-                    assert!((a == b));\n-                    i += 1u;\n-                }\n+        let wikipedia_tests = ~[\n+            Test {\n+                input: ~\"The quick brown fox jumps over the lazy dog\",\n+                output: ~[\n+                    0x2fu8, 0xd4u8, 0xe1u8, 0xc6u8,\n+                    0x7au8, 0x2du8, 0x28u8, 0xfcu8,\n+                    0xedu8, 0x84u8, 0x9eu8, 0xe1u8,\n+                    0xbbu8, 0x76u8, 0xe7u8, 0x39u8,\n+                    0x1bu8, 0x93u8, 0xebu8, 0x12u8,\n+                ],\n+                output_str: ~\"2fd4e1c67a2d28fced849ee1bb76e7391b93eb12\",\n+            },\n+            Test {\n+                input: ~\"The quick brown fox jumps over the lazy cog\",\n+                output: ~[\n+                    0xdeu8, 0x9fu8, 0x2cu8, 0x7fu8,\n+                    0xd2u8, 0x5eu8, 0x1bu8, 0x3au8,\n+                    0xfau8, 0xd3u8, 0xe8u8, 0x5au8,\n+                    0x0bu8, 0xd1u8, 0x7du8, 0x9bu8,\n+                    0x10u8, 0x0du8, 0xb4u8, 0xb3u8,\n+                ],\n+                output_str: ~\"de9f2c7fd25e1b3afad3e85a0bd17d9b100db4b3\",\n+            },\n+        ];\n+        let tests = fips_180_1_tests + wikipedia_tests;\n+        fn check_vec_eq(v0: ~[u8], v1: ~[u8]) {\n+            assert!((vec::len::<u8>(v0) == vec::len::<u8>(v1)));\n+            let len = vec::len::<u8>(v0);\n+            let mut i = 0u;\n+            while i < len {\n+                let a = v0[i];\n+                let b = v1[i];\n+                assert!((a == b));\n+                i += 1u;\n             }\n-            // Test that it works when accepting the message all at once\n+        }\n+        // Test that it works when accepting the message all at once\n \n-            let mut sh = sha1::sha1();\n-            for vec::each(tests) |t| {\n-                sh.input_str(t.input);\n-                let out = sh.result();\n-                check_vec_eq(t.output, out);\n+        let mut sh = sha1::sha1();\n+        for vec::each(tests) |t| {\n+            sh.input_str(t.input);\n+            let out = sh.result();\n+            check_vec_eq(t.output, out);\n \n-                let out_str = sh.result_str();\n-                assert!((out_str.len() == 40));\n-                assert!((out_str == t.output_str));\n+            let out_str = sh.result_str();\n+            assert!((out_str.len() == 40));\n+            assert!((out_str == t.output_str));\n \n-                sh.reset();\n-            }\n+            sh.reset();\n+        }\n \n \n-            // Test that it works when accepting the message in pieces\n-            for vec::each(tests) |t| {\n-                let len = str::len(t.input);\n-                let mut left = len;\n-                while left > 0u {\n-                    let take = (left + 1u) / 2u;\n-                    sh.input_str(str::slice(t.input, len - left,\n-                                 take + len - left).to_owned());\n-                    left = left - take;\n-                }\n-                let out = sh.result();\n-                check_vec_eq(t.output, out);\n+        // Test that it works when accepting the message in pieces\n+        for vec::each(tests) |t| {\n+            let len = str::len(t.input);\n+            let mut left = len;\n+            while left > 0u {\n+                let take = (left + 1u) / 2u;\n+                sh.input_str(str::slice(t.input, len - left,\n+                             take + len - left).to_owned());\n+                left = left - take;\n+            }\n+            let out = sh.result();\n+            check_vec_eq(t.output, out);\n \n-                let out_str = sh.result_str();\n-                assert!((out_str.len() == 40));\n-                assert!((out_str == t.output_str));\n+            let out_str = sh.result_str();\n+            assert!((out_str.len() == 40));\n+            assert!((out_str == t.output_str));\n \n-                sh.reset();\n-            }\n+            sh.reset();\n         }\n     }\n }"}, {"sha": "39ca9bb5ba66fee2e17ddc4765fc54f99115b703", "filename": "src/libstd/sort.rs", "status": "modified", "additions": 11, "deletions": 19, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/255193cc1af5e07753906ad18bae077b45b5c3f0/src%2Flibstd%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/255193cc1af5e07753906ad18bae077b45b5c3f0/src%2Flibstd%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsort.rs?ref=255193cc1af5e07753906ad18bae077b45b5c3f0", "patch": "@@ -27,7 +27,7 @@ type Le<'self, T> = &'self fn(v1: &T, v2: &T) -> bool;\n pub fn merge_sort<T:Copy>(v: &const [T], le: Le<T>) -> ~[T] {\n     type Slice = (uint, uint);\n \n-    unsafe {return merge_sort_(v, (0u, len(v)), le);}\n+    return merge_sort_(v, (0u, len(v)), le);\n \n     fn merge_sort_<T:Copy>(v: &const [T], slice: Slice, le: Le<T>)\n         -> ~[T] {\n@@ -68,14 +68,11 @@ fn part<T>(arr: &mut [T], left: uint,\n     let mut storage_index: uint = left;\n     let mut i: uint = left;\n     while i < right {\n-        // XXX: Unsafe because borrow check doesn't handle this right\n-        unsafe {\n-            let a: &T = cast::transmute(&mut arr[i]);\n-            let b: &T = cast::transmute(&mut arr[right]);\n-            if compare_func(a, b) {\n-                arr[i] <-> arr[storage_index];\n-                storage_index += 1;\n-            }\n+        let a: &mut T = &mut arr[i];\n+        let b: &mut T = &mut arr[right];\n+        if compare_func(a, b) {\n+            arr[i] <-> arr[storage_index];\n+            storage_index += 1;\n         }\n         i += 1;\n     }\n@@ -888,12 +885,9 @@ mod tests {\n         // tjc: funny that we have to use parens\n         fn ile(x: &(&'static str), y: &(&'static str)) -> bool\n         {\n-            unsafe // to_lower is not pure...\n-            {\n-                let x = x.to_lower();\n-                let y = y.to_lower();\n-                x <= y\n-            }\n+            let x = x.to_lower();\n+            let y = y.to_lower();\n+            x <= y\n         }\n \n         let names1 = ~[\"joe bob\", \"Joe Bob\", \"Jack Brown\", \"JOE Bob\",\n@@ -921,10 +915,8 @@ mod test_tim_sort {\n \n     impl Ord for CVal {\n         fn lt(&self, other: &CVal) -> bool {\n-            unsafe {\n-                let rng = rand::Rng();\n-                if rng.gen_float() > 0.995 { fail!(~\"It's happening!!!\"); }\n-            }\n+            let rng = rand::Rng();\n+            if rng.gen_float() > 0.995 { fail!(~\"It's happening!!!\"); }\n             (*self).val < other.val\n         }\n         fn le(&self, other: &CVal) -> bool { (*self).val <= other.val }"}, {"sha": "adfa12594aac152525ee1d757ca52f192dddeb4a", "filename": "src/libstd/time.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/255193cc1af5e07753906ad18bae077b45b5c3f0/src%2Flibstd%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/255193cc1af5e07753906ad18bae077b45b5c3f0/src%2Flibstd%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime.rs?ref=255193cc1af5e07753906ad18bae077b45b5c3f0", "patch": "@@ -176,16 +176,12 @@ pub fn now() -> Tm {\n \n /// Parses the time from the string according to the format string.\n pub fn strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n-    // unsafe only because do_strptime is annoying to make pure\n-    // (it does IO with a str_reader)\n-    unsafe {do_strptime(s, format)}\n+    do_strptime(s, format)\n }\n \n /// Formats the time according to the format string.\n pub fn strftime(format: &str, tm: &Tm) -> ~str {\n-    // unsafe only because do_strftime is annoying to make pure\n-    // (it does IO with a str_reader)\n-    unsafe { do_strftime(format, tm) }\n+    do_strftime(format, tm)\n }\n \n pub impl Tm {"}, {"sha": "fc08073686d0d0fa0eb3356fdf8f4d9808b60a75", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/255193cc1af5e07753906ad18bae077b45b5c3f0/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/255193cc1af5e07753906ad18bae077b45b5c3f0/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=255193cc1af5e07753906ad18bae077b45b5c3f0", "patch": "@@ -252,15 +252,13 @@ pub impl FileMap {\n \n     // get a line from the list of pre-computed line-beginnings\n     pub fn get_line(&self, line: int) -> ~str {\n-        unsafe {\n-            let begin: BytePos = self.lines[line] - self.start_pos;\n-            let begin = begin.to_uint();\n-            let end = match str::find_char_from(*self.src, '\\n', begin) {\n-                Some(e) => e,\n-                None => str::len(*self.src)\n-            };\n-            str::slice(*self.src, begin, end).to_owned()\n-        }\n+        let begin: BytePos = self.lines[line] - self.start_pos;\n+        let begin = begin.to_uint();\n+        let end = match str::find_char_from(*self.src, '\\n', begin) {\n+            Some(e) => e,\n+            None => str::len(*self.src)\n+        };\n+        str::slice(*self.src, begin, end).to_owned()\n     }\n \n     pub fn record_multibyte_char(&self, pos: BytePos, bytes: uint) {"}, {"sha": "de3d97de177d7ef2ea9a14f3362d31aa6bfc758b", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/255193cc1af5e07753906ad18bae077b45b5c3f0/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/255193cc1af5e07753906ad18bae077b45b5c3f0/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=255193cc1af5e07753906ad18bae077b45b5c3f0", "patch": "@@ -175,12 +175,10 @@ fn byte_offset(rdr: @mut StringReader) -> BytePos {\n }\n \n pub fn get_str_from(rdr: @mut StringReader, start: BytePos) -> ~str {\n-    unsafe {\n-        // I'm pretty skeptical about this subtraction. What if there's a\n-        // multi-byte character before the mark?\n-        return str::slice(*rdr.src, start.to_uint() - 1u,\n-                          byte_offset(rdr).to_uint() - 1u).to_owned();\n-    }\n+    // I'm pretty skeptical about this subtraction. What if there's a\n+    // multi-byte character before the mark?\n+    return str::slice(*rdr.src, start.to_uint() - 1u,\n+                      byte_offset(rdr).to_uint() - 1u).to_owned();\n }\n \n // EFFECT: advance the StringReader by one character. If a newline is"}]}