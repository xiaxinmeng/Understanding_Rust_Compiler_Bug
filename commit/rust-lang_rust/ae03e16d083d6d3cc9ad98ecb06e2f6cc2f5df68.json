{"sha": "ae03e16d083d6d3cc9ad98ecb06e2f6cc2f5df68", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFlMDNlMTZkMDgzZDZkM2NjOWFkOThlY2IwNmUyZjZjYzJmNWRmNjg=", "commit": {"author": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2020-01-23T06:48:09Z"}, "committer": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2020-02-07T01:41:28Z"}, "message": "Lift range_search up one level of abstraction", "tree": {"sha": "fb09d3826b0c4f6bbb1f62c5689e0c1e0c8ed861", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fb09d3826b0c4f6bbb1f62c5689e0c1e0c8ed861"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ae03e16d083d6d3cc9ad98ecb06e2f6cc2f5df68", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ae03e16d083d6d3cc9ad98ecb06e2f6cc2f5df68", "html_url": "https://github.com/rust-lang/rust/commit/ae03e16d083d6d3cc9ad98ecb06e2f6cc2f5df68", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ae03e16d083d6d3cc9ad98ecb06e2f6cc2f5df68/comments", "author": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "be051adb57f1ff28edf997c3379aed2934bff104", "url": "https://api.github.com/repos/rust-lang/rust/commits/be051adb57f1ff28edf997c3379aed2934bff104", "html_url": "https://github.com/rust-lang/rust/commit/be051adb57f1ff28edf997c3379aed2934bff104"}], "stats": {"total": 87, "additions": 45, "deletions": 42}, "files": [{"sha": "0b3f603686dc6e1e3f3ed996adf4568394a9e52b", "filename": "src/liballoc/collections/btree/map.rs", "status": "modified", "additions": 26, "deletions": 40, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/ae03e16d083d6d3cc9ad98ecb06e2f6cc2f5df68/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae03e16d083d6d3cc9ad98ecb06e2f6cc2f5df68/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs?ref=ae03e16d083d6d3cc9ad98ecb06e2f6cc2f5df68", "patch": "@@ -1861,65 +1861,51 @@ where\n     let mut max_node = root2;\n     let mut min_found = false;\n     let mut max_found = false;\n-    let mut diverged = false;\n \n     loop {\n-        let min_edge = match (min_found, range.start_bound()) {\n-            (false, Included(key)) => match search::search_linear(&min_node, key) {\n-                (i, true) => {\n+        let front = match (min_found, range.start_bound()) {\n+            (false, Included(key)) => match search::search_node(min_node, key) {\n+                Found(kv) => {\n                     min_found = true;\n-                    i\n+                    kv.left_edge()\n                 }\n-                (i, false) => i,\n+                GoDown(edge) => edge,\n             },\n-            (false, Excluded(key)) => match search::search_linear(&min_node, key) {\n-                (i, true) => {\n+            (false, Excluded(key)) => match search::search_node(min_node, key) {\n+                Found(kv) => {\n                     min_found = true;\n-                    i + 1\n+                    kv.right_edge()\n                 }\n-                (i, false) => i,\n+                GoDown(edge) => edge,\n             },\n-            (_, Unbounded) => 0,\n-            (true, Included(_)) => min_node.len(),\n-            (true, Excluded(_)) => 0,\n+            (true, Included(_)) => min_node.last_edge(),\n+            (true, Excluded(_)) => min_node.first_edge(),\n+            (_, Unbounded) => min_node.first_edge(),\n         };\n \n-        let max_edge = match (max_found, range.end_bound()) {\n-            (false, Included(key)) => match search::search_linear(&max_node, key) {\n-                (i, true) => {\n+        let back = match (max_found, range.end_bound()) {\n+            (false, Included(key)) => match search::search_node(max_node, key) {\n+                Found(kv) => {\n                     max_found = true;\n-                    i + 1\n+                    kv.right_edge()\n                 }\n-                (i, false) => i,\n+                GoDown(edge) => edge,\n             },\n-            (false, Excluded(key)) => match search::search_linear(&max_node, key) {\n-                (i, true) => {\n+            (false, Excluded(key)) => match search::search_node(max_node, key) {\n+                Found(kv) => {\n                     max_found = true;\n-                    i\n+                    kv.left_edge()\n                 }\n-                (i, false) => i,\n+                GoDown(edge) => edge,\n             },\n-            (_, Unbounded) => max_node.len(),\n-            (true, Included(_)) => 0,\n-            (true, Excluded(_)) => max_node.len(),\n+            (true, Included(_)) => max_node.first_edge(),\n+            (true, Excluded(_)) => max_node.last_edge(),\n+            (_, Unbounded) => max_node.last_edge(),\n         };\n \n-        if !diverged {\n-            if max_edge < min_edge {\n-                panic!(\"Ord is ill-defined in BTreeMap range\")\n-            }\n-            if min_edge != max_edge {\n-                diverged = true;\n-            }\n+        if front.partial_cmp(&back) == Some(Ordering::Greater) {\n+            panic!(\"Ord is ill-defined in BTreeMap range\");\n         }\n-\n-        // Safety guarantee: `min_edge` is always in range for `min_node`, because\n-        // `min_edge` is unconditionally calculated for each iteration's value of `min_node`,\n-        // either (if not found) as the edge index returned by `search_linear`,\n-        // or (if found) as the KV index returned by `search_linear`, possibly + 1.\n-        // Likewise for `max_node` versus `max_edge`.\n-        let front = unsafe { Handle::new_edge(min_node, min_edge) };\n-        let back = unsafe { Handle::new_edge(max_node, max_edge) };\n         match (front.force(), back.force()) {\n             (Leaf(f), Leaf(b)) => {\n                 return (f, b);"}, {"sha": "abf926186e82c1d3a12e16e874623d3890c7ddce", "filename": "src/liballoc/collections/btree/node.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ae03e16d083d6d3cc9ad98ecb06e2f6cc2f5df68/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae03e16d083d6d3cc9ad98ecb06e2f6cc2f5df68/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs?ref=ae03e16d083d6d3cc9ad98ecb06e2f6cc2f5df68", "patch": "@@ -31,6 +31,7 @@\n // - A node of length `n` has `n` keys, `n` values, and (in an internal node) `n + 1` edges.\n //   This implies that even an empty internal node has at least one edge.\n \n+use core::cmp::Ordering;\n use core::marker::PhantomData;\n use core::mem::{self, MaybeUninit};\n use core::ptr::{self, NonNull, Unique};\n@@ -832,6 +833,14 @@ impl<BorrowType, K, V, NodeType, HandleType> PartialEq\n     }\n }\n \n+impl<BorrowType, K, V, NodeType, HandleType> PartialOrd\n+    for Handle<NodeRef<BorrowType, K, V, NodeType>, HandleType>\n+{\n+    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n+        if self.node.node == other.node.node { Some(self.idx.cmp(&other.idx)) } else { None }\n+    }\n+}\n+\n impl<BorrowType, K, V, NodeType, HandleType>\n     Handle<NodeRef<BorrowType, K, V, NodeType>, HandleType>\n {"}, {"sha": "2ba5cebbdee74f788da20f6f88b1092df21a24b3", "filename": "src/liballoc/collections/btree/search.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ae03e16d083d6d3cc9ad98ecb06e2f6cc2f5df68/src%2Fliballoc%2Fcollections%2Fbtree%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae03e16d083d6d3cc9ad98ecb06e2f6cc2f5df68/src%2Fliballoc%2Fcollections%2Fbtree%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fsearch.rs?ref=ae03e16d083d6d3cc9ad98ecb06e2f6cc2f5df68", "patch": "@@ -10,6 +10,10 @@ pub enum SearchResult<BorrowType, K, V, FoundType, GoDownType> {\n     GoDown(Handle<NodeRef<BorrowType, K, V, GoDownType>, marker::Edge>),\n }\n \n+/// Looks up a given key in a (sub)tree headed by the given node, recursively.\n+/// Returns a `Found` with the handle of the matching KV, if any. Otherwise,\n+/// returns a `GoDown` with the handle of the possible leaf edge where the key\n+/// belongs.\n pub fn search_tree<BorrowType, K, V, Q: ?Sized>(\n     mut node: NodeRef<BorrowType, K, V, marker::LeafOrInternal>,\n     key: &Q,\n@@ -32,6 +36,10 @@ where\n     }\n }\n \n+/// Looks up a given key in a given node, without recursion.\n+/// Returns a `Found` with the handle of the matching KV, if any. Otherwise,\n+/// returns a `GoDown` with the handle of the edge where the key might be found.\n+/// If the node is a leaf, a `GoDown` edge is not an actual edge but a possible edge.\n pub fn search_node<BorrowType, K, V, Type, Q: ?Sized>(\n     node: NodeRef<BorrowType, K, V, Type>,\n     key: &Q,\n@@ -50,8 +58,8 @@ where\n /// or could exist, and whether it exists in the node itself. If it doesn't\n /// exist in the node itself, it may exist in the subtree with that index\n /// (if the node has subtrees). If the key doesn't exist in node or subtree,\n-/// the returned index is the position or subtree to insert at.\n-pub fn search_linear<BorrowType, K, V, Type, Q: ?Sized>(\n+/// the returned index is the position or subtree where the key belongs.\n+fn search_linear<BorrowType, K, V, Type, Q: ?Sized>(\n     node: &NodeRef<BorrowType, K, V, Type>,\n     key: &Q,\n ) -> (usize, bool)"}]}