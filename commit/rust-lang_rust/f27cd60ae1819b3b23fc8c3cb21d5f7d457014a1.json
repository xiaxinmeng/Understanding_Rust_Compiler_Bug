{"sha": "f27cd60ae1819b3b23fc8c3cb21d5f7d457014a1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYyN2NkNjBhZTE4MTliM2IyM2ZjOGMzY2IyMWQ1ZjdkNDU3MDE0YTE=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-11-06T10:04:10Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-11-07T15:54:31Z"}, "message": "no more action on ref or cast, but add new MIR statement for escaping a ptr to raw", "tree": {"sha": "f548de29565ba1739536057f2e2f362e79f71eef", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f548de29565ba1739536057f2e2f362e79f71eef"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f27cd60ae1819b3b23fc8c3cb21d5f7d457014a1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f27cd60ae1819b3b23fc8c3cb21d5f7d457014a1", "html_url": "https://github.com/rust-lang/rust/commit/f27cd60ae1819b3b23fc8c3cb21d5f7d457014a1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f27cd60ae1819b3b23fc8c3cb21d5f7d457014a1/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8315b11b6352cbd91ee096571c31ae7d3ac9613d", "url": "https://api.github.com/repos/rust-lang/rust/commits/8315b11b6352cbd91ee096571c31ae7d3ac9613d", "html_url": "https://github.com/rust-lang/rust/commit/8315b11b6352cbd91ee096571c31ae7d3ac9613d"}], "stats": {"total": 269, "additions": 159, "deletions": 110}, "files": [{"sha": "1bd02dfeacaadc435832a56a5328d193b03e086d", "filename": "src/librustc/ich/impls_mir.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f27cd60ae1819b3b23fc8c3cb21d5f7d457014a1/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f27cd60ae1819b3b23fc8c3cb21d5f7d457014a1/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_mir.rs?ref=f27cd60ae1819b3b23fc8c3cb21d5f7d457014a1", "patch": "@@ -257,6 +257,9 @@ for mir::StatementKind<'gcx> {\n             mir::StatementKind::EndRegion(ref region_scope) => {\n                 region_scope.hash_stable(hcx, hasher);\n             }\n+            mir::StatementKind::EscapeToRaw(ref place) => {\n+                place.hash_stable(hcx, hasher);\n+            }\n             mir::StatementKind::Retag { fn_entry, ref place } => {\n                 fn_entry.hash_stable(hcx, hasher);\n                 place.hash_stable(hcx, hasher);"}, {"sha": "0817c2e8bf273277ec8085f1ea7a82cf0caa3985", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f27cd60ae1819b3b23fc8c3cb21d5f7d457014a1/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f27cd60ae1819b3b23fc8c3cb21d5f7d457014a1/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=f27cd60ae1819b3b23fc8c3cb21d5f7d457014a1", "patch": "@@ -1766,6 +1766,13 @@ pub enum StatementKind<'tcx> {\n         place: Place<'tcx>,\n     },\n \n+    /// Escape the given reference to a raw pointer, so that it can be accessed\n+    /// without precise provenance tracking. These statements are currently only interpreted\n+    /// by miri and only generated when \"-Z mir-emit-retag\" is passed.\n+    /// See <https://internals.rust-lang.org/t/stacked-borrows-an-aliasing-model-for-rust/8153/>\n+    /// for more details.\n+    EscapeToRaw(Operand<'tcx>),\n+\n     /// Mark one terminating point of a region scope (i.e. static region).\n     /// (The starting point(s) arise implicitly from borrows.)\n     EndRegion(region::Scope),\n@@ -1827,6 +1834,7 @@ impl<'tcx> Debug for Statement<'tcx> {\n             EndRegion(ref ce) => write!(fmt, \"EndRegion({})\", ty::ReScope(*ce)),\n             Retag { fn_entry, ref place } =>\n                 write!(fmt, \"Retag({}{:?})\", if fn_entry { \"[fn entry] \" } else { \"\" }, place),\n+            EscapeToRaw(ref place) => write!(fmt, \"EscapeToRaw({:?})\", place),\n             StorageLive(ref place) => write!(fmt, \"StorageLive({:?})\", place),\n             StorageDead(ref place) => write!(fmt, \"StorageDead({:?})\", place),\n             SetDiscriminant {\n@@ -2968,6 +2976,7 @@ EnumTypeFoldableImpl! {\n         (StatementKind::StorageDead)(a),\n         (StatementKind::InlineAsm) { asm, outputs, inputs },\n         (StatementKind::Retag) { fn_entry, place },\n+        (StatementKind::EscapeToRaw)(place),\n         (StatementKind::EndRegion)(a),\n         (StatementKind::AscribeUserType)(a, v, b),\n         (StatementKind::Nop),"}, {"sha": "2a994ee0509c26acb7584994e649beb34632fddc", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f27cd60ae1819b3b23fc8c3cb21d5f7d457014a1/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f27cd60ae1819b3b23fc8c3cb21d5f7d457014a1/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=f27cd60ae1819b3b23fc8c3cb21d5f7d457014a1", "patch": "@@ -385,6 +385,9 @@ macro_rules! make_mir_visitor {\n                             location\n                         );\n                     }\n+                    StatementKind::EscapeToRaw(ref $($mutability)* op) => {\n+                        self.visit_operand(op, location);\n+                    }\n                     StatementKind::StorageLive(ref $($mutability)* local) => {\n                         self.visit_local(\n                             local,\n@@ -1022,7 +1025,7 @@ pub enum MutatingUseContext<'tcx> {\n     ///     f(&mut x.y);\n     ///\n     Projection,\n-    /// Retagging (updating the \"Stacked Borrows\" tag)\n+    /// Retagging, a \"Stacked Borrows\" shadow state operation\n     Retag,\n }\n "}, {"sha": "8bda2c98594e500e7b3844d7648c56f4a22e016a", "filename": "src/librustc_codegen_llvm/mir/statement.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f27cd60ae1819b3b23fc8c3cb21d5f7d457014a1/src%2Flibrustc_codegen_llvm%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f27cd60ae1819b3b23fc8c3cb21d5f7d457014a1/src%2Flibrustc_codegen_llvm%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fstatement.rs?ref=f27cd60ae1819b3b23fc8c3cb21d5f7d457014a1", "patch": "@@ -105,8 +105,9 @@ impl FunctionCx<'a, 'll, 'tcx> {\n                 bx\n             }\n             mir::StatementKind::FakeRead(..) |\n-            mir::StatementKind::EndRegion(_) |\n+            mir::StatementKind::EndRegion(..) |\n             mir::StatementKind::Retag { .. } |\n+            mir::StatementKind::EscapeToRaw { .. } |\n             mir::StatementKind::AscribeUserType(..) |\n             mir::StatementKind::Nop => bx,\n         }"}, {"sha": "533b777d67d7369bc18d3d4d76866ce26279d900", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f27cd60ae1819b3b23fc8c3cb21d5f7d457014a1/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f27cd60ae1819b3b23fc8c3cb21d5f7d457014a1/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=f27cd60ae1819b3b23fc8c3cb21d5f7d457014a1", "patch": "@@ -601,6 +601,7 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n             StatementKind::Nop\n             | StatementKind::AscribeUserType(..)\n             | StatementKind::Retag { .. }\n+            | StatementKind::EscapeToRaw { .. }\n             | StatementKind::StorageLive(..) => {\n                 // `Nop`, `AscribeUserType`, `Retag`, and `StorageLive` are irrelevant\n                 // to borrow check."}, {"sha": "576509c0fddda371290730177de46ab8a879fb68", "filename": "src/librustc_mir/borrow_check/nll/invalidation.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f27cd60ae1819b3b23fc8c3cb21d5f7d457014a1/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f27cd60ae1819b3b23fc8c3cb21d5f7d457014a1/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs?ref=f27cd60ae1819b3b23fc8c3cb21d5f7d457014a1", "patch": "@@ -137,6 +137,7 @@ impl<'cx, 'tcx, 'gcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx, 'gcx> {\n             StatementKind::Nop |\n             StatementKind::AscribeUserType(..) |\n             StatementKind::Retag { .. } |\n+            StatementKind::EscapeToRaw { .. } |\n             StatementKind::StorageLive(..) => {\n                 // `Nop`, `AscribeUserType`, `Retag`, and `StorageLive` are irrelevant\n                 // to borrow check."}, {"sha": "3c2301ba4a7d4b0281aa983d459edd4a63126119", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f27cd60ae1819b3b23fc8c3cb21d5f7d457014a1/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f27cd60ae1819b3b23fc8c3cb21d5f7d457014a1/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=f27cd60ae1819b3b23fc8c3cb21d5f7d457014a1", "patch": "@@ -1290,11 +1290,12 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 }\n             }\n             StatementKind::FakeRead(..)\n-            | StatementKind::StorageLive(_)\n-            | StatementKind::StorageDead(_)\n+            | StatementKind::StorageLive(..)\n+            | StatementKind::StorageDead(..)\n             | StatementKind::InlineAsm { .. }\n             | StatementKind::EndRegion(_)\n             | StatementKind::Retag { .. }\n+            | StatementKind::EscapeToRaw { .. }\n             | StatementKind::Nop => {}\n         }\n     }"}, {"sha": "811da9e1acca7eacc50d3aa050c4435509ba006e", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f27cd60ae1819b3b23fc8c3cb21d5f7d457014a1/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f27cd60ae1819b3b23fc8c3cb21d5f7d457014a1/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=f27cd60ae1819b3b23fc8c3cb21d5f7d457014a1", "patch": "@@ -339,6 +339,7 @@ impl<'a, 'gcx, 'tcx> BitDenotation for Borrows<'a, 'gcx, 'tcx> {\n             mir::StatementKind::SetDiscriminant { .. } |\n             mir::StatementKind::StorageLive(..) |\n             mir::StatementKind::Retag { .. } |\n+            mir::StatementKind::EscapeToRaw { .. } |\n             mir::StatementKind::AscribeUserType(..) |\n             mir::StatementKind::Nop => {}\n "}, {"sha": "e6e165ef3de4a4987bdea565416de6604be18865", "filename": "src/librustc_mir/dataflow/move_paths/builder.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f27cd60ae1819b3b23fc8c3cb21d5f7d457014a1/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f27cd60ae1819b3b23fc8c3cb21d5f7d457014a1/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs?ref=f27cd60ae1819b3b23fc8c3cb21d5f7d457014a1", "patch": "@@ -301,8 +301,9 @@ impl<'b, 'a, 'gcx, 'tcx> Gatherer<'b, 'a, 'gcx, 'tcx> {\n                 span_bug!(stmt.source_info.span,\n                           \"SetDiscriminant should not exist during borrowck\");\n             }\n-            StatementKind::EndRegion(_) |\n+            StatementKind::EndRegion(..) |\n             StatementKind::Retag { .. } |\n+            StatementKind::EscapeToRaw { .. } |\n             StatementKind::AscribeUserType(..) |\n             StatementKind::Nop => {}\n         }"}, {"sha": "118539fc58ebf2bb2299390554e8adf41bd52f94", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 7, "deletions": 20, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/f27cd60ae1819b3b23fc8c3cb21d5f7d457014a1/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f27cd60ae1819b3b23fc8c3cb21d5f7d457014a1/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=f27cd60ae1819b3b23fc8c3cb21d5f7d457014a1", "patch": "@@ -44,40 +44,28 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n             }\n \n             Misc => {\n-                let src_layout = src.layout;\n                 let src = self.read_immediate(src)?;\n \n-                let src = if M::ENABLE_PTR_TRACKING_HOOKS && src_layout.ty.is_region_ptr() {\n-                    // The only `Misc` casts on references are those creating raw pointers.\n-                    assert!(dest.layout.ty.is_unsafe_ptr());\n-                    // For the purpose of the \"ptr tag hooks\", treat this as creating\n-                    // a new, raw reference.\n-                    let place = self.ref_to_mplace(src)?;\n-                    self.create_ref(place, None)?\n-                } else {\n-                    *src\n-                };\n-\n-                if self.type_is_fat_ptr(src_layout.ty) {\n-                    match (src, self.type_is_fat_ptr(dest.layout.ty)) {\n+                if self.type_is_fat_ptr(src.layout.ty) {\n+                    match (*src, self.type_is_fat_ptr(dest.layout.ty)) {\n                         // pointers to extern types\n                         (Immediate::Scalar(_),_) |\n                         // slices and trait objects to other slices/trait objects\n                         (Immediate::ScalarPair(..), true) => {\n                             // No change to immediate\n-                            self.write_immediate(src, dest)?;\n+                            self.write_immediate(*src, dest)?;\n                         }\n                         // slices and trait objects to thin pointers (dropping the metadata)\n                         (Immediate::ScalarPair(data, _), false) => {\n                             self.write_scalar(data, dest)?;\n                         }\n                     }\n                 } else {\n-                    match src_layout.variants {\n+                    match src.layout.variants {\n                         layout::Variants::Single { index } => {\n-                            if let Some(def) = src_layout.ty.ty_adt_def() {\n+                            if let Some(def) = src.layout.ty.ty_adt_def() {\n                                 // Cast from a univariant enum\n-                                assert!(src_layout.is_zst());\n+                                assert!(src.layout.is_zst());\n                                 let discr_val = def\n                                     .discriminant_for_variant(*self.tcx, index)\n                                     .val;\n@@ -90,8 +78,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                         layout::Variants::NicheFilling { .. } => {},\n                     }\n \n-                    let src = src.to_scalar()?;\n-                    let dest_val = self.cast_scalar(src, src_layout, dest.layout)?;\n+                    let dest_val = self.cast_scalar(src.to_scalar()?, src.layout, dest.layout)?;\n                     self.write_scalar(dest_val, dest)?;\n                 }\n             }"}, {"sha": "214ffd071cc9fb2b06b83e9aa4ec80a62cd25468", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f27cd60ae1819b3b23fc8c3cb21d5f7d457014a1/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f27cd60ae1819b3b23fc8c3cb21d5f7d457014a1/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=f27cd60ae1819b3b23fc8c3cb21d5f7d457014a1", "patch": "@@ -211,18 +211,6 @@ pub trait Machine<'a, 'mir, 'tcx>: Sized {\n         kind: MemoryKind<Self::MemoryKinds>,\n     ) -> EvalResult<'tcx, Pointer<Self::PointerTag>>;\n \n-    /// Executed when evaluating the `&` operator: Creating a new reference.\n-    /// This has the chance to adjust the tag.  It should not change anything else!\n-    /// `mutability` can be `None` in case a raw ptr is being created.\n-    #[inline]\n-    fn tag_reference(\n-        _ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n-        place: MPlaceTy<'tcx, Self::PointerTag>,\n-        _mutability: Option<hir::Mutability>,\n-    ) -> EvalResult<'tcx, Scalar<Self::PointerTag>> {\n-        Ok(place.ptr)\n-    }\n-\n     /// Executed when evaluating the `*` operator: Following a reference.\n     /// This has the chance to adjust the tag.  It should not change anything else!\n     /// `mutability` can be `None` in case a raw ptr is being dereferenced.\n@@ -235,7 +223,7 @@ pub trait Machine<'a, 'mir, 'tcx>: Sized {\n         Ok(place.ptr)\n     }\n \n-    /// Execute a validation operation\n+    /// Execute a retagging operation\n     #[inline]\n     fn retag(\n         _ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n@@ -244,4 +232,13 @@ pub trait Machine<'a, 'mir, 'tcx>: Sized {\n     ) -> EvalResult<'tcx> {\n         Ok(())\n     }\n+\n+    /// Execute an escape-to-raw operation\n+    #[inline]\n+    fn escape_to_raw(\n+        _ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n+        _ptr: OpTy<'tcx, Self::PointerTag>,\n+    ) -> EvalResult<'tcx> {\n+        Ok(())\n+    }\n }"}, {"sha": "da62594cb22c01d12d2ce7b34fab97f711666386", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 11, "deletions": 19, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f27cd60ae1819b3b23fc8c3cb21d5f7d457014a1/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f27cd60ae1819b3b23fc8c3cb21d5f7d457014a1/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=f27cd60ae1819b3b23fc8c3cb21d5f7d457014a1", "patch": "@@ -151,6 +151,16 @@ impl<Tag> MemPlace<Tag> {\n         // it now must be aligned.\n         self.to_scalar_ptr_align().0.to_ptr()\n     }\n+\n+    /// Turn a mplace into a (thin or fat) pointer, as a reference, pointing to the same space.\n+    /// This is the inverse of `ref_to_mplace`.\n+    #[inline(always)]\n+    pub fn to_ref(self) -> Immediate<Tag> {\n+        match self.meta {\n+            None => Immediate::Scalar(self.ptr.into()),\n+            Some(meta) => Immediate::ScalarPair(self.ptr.into(), meta.into()),\n+        }\n+    }\n }\n \n impl<'tcx, Tag> MPlaceTy<'tcx, Tag> {\n@@ -266,7 +276,7 @@ where\n     M::MemoryMap: AllocMap<AllocId, (MemoryKind<M::MemoryKinds>, Allocation<Tag, M::AllocExtra>)>,\n {\n     /// Take a value, which represents a (thin or fat) reference, and make it a place.\n-    /// Alignment is just based on the type.  This is the inverse of `create_ref`.\n+    /// Alignment is just based on the type.  This is the inverse of `MemPlace::to_ref()`.\n     pub fn ref_to_mplace(\n         &self,\n         val: ImmTy<'tcx, M::PointerTag>,\n@@ -294,24 +304,6 @@ where\n         Ok(mplace)\n     }\n \n-    /// Turn a mplace into a (thin or fat) pointer, as a reference, pointing to the same space.\n-    /// This is the inverse of `ref_to_mplace`.\n-    /// `mutbl` indicates whether we are create a shared or mutable ref, or a raw pointer (`None`).\n-    pub fn create_ref(\n-        &mut self,\n-        mut place: MPlaceTy<'tcx, M::PointerTag>,\n-        mutbl: Option<hir::Mutability>,\n-    ) -> EvalResult<'tcx, Immediate<M::PointerTag>> {\n-        // Pointer tag tracking might want to adjust the tag\n-        if M::ENABLE_PTR_TRACKING_HOOKS {\n-            place.mplace.ptr = M::tag_reference(self, place, mutbl)?\n-        }\n-        Ok(match place.meta {\n-            None => Immediate::Scalar(place.ptr.into()),\n-            Some(meta) => Immediate::ScalarPair(place.ptr.into(), meta.into()),\n-        })\n-    }\n-\n     /// Offset a pointer to project to a field. Unlike place_field, this is always\n     /// possible without allocating, so it can take &self. Also return the field's layout.\n     /// This supports both struct and array fields."}, {"sha": "ac13e5982dae38549edd61a80b21579904807d41", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f27cd60ae1819b3b23fc8c3cb21d5f7d457014a1/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f27cd60ae1819b3b23fc8c3cb21d5f7d457014a1/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=f27cd60ae1819b3b23fc8c3cb21d5f7d457014a1", "patch": "@@ -12,7 +12,7 @@\n //!\n //! The main entry point is the `step` method.\n \n-use rustc::{hir, mir};\n+use rustc::mir;\n use rustc::ty::layout::LayoutOf;\n use rustc::mir::interpret::{EvalResult, Scalar, PointerArithmetic};\n \n@@ -118,12 +118,17 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n             // interpreter is solely intended for borrowck'ed code.\n             FakeRead(..) => {}\n \n-            // Retagging.\n+            // Stacked Borrows.\n             Retag { fn_entry, ref place } => {\n                 let dest = self.eval_place(place)?;\n                 M::retag(self, fn_entry, dest)?;\n             }\n+            EscapeToRaw(ref op) => {\n+                let op = self.eval_operand(op, None)?;\n+                M::escape_to_raw(self, op)?;\n+            }\n \n+            // Statements we do not track.\n             EndRegion(..) => {}\n             AscribeUserType(..) => {}\n \n@@ -247,19 +252,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                 )?;\n             }\n \n-            Ref(_, borrow_kind, ref place) => {\n+            Ref(_, _, ref place) => {\n                 let src = self.eval_place(place)?;\n                 let val = self.force_allocation(src)?;\n-                let mutbl = match borrow_kind {\n-                    mir::BorrowKind::Mut { .. } |\n-                    mir::BorrowKind::Unique =>\n-                        hir::MutMutable,\n-                    mir::BorrowKind::Shared |\n-                    mir::BorrowKind::Shallow =>\n-                        hir::MutImmutable,\n-                };\n-                let val = self.create_ref(val, Some(mutbl))?;\n-                self.write_immediate(val, dest)?;\n+                self.write_immediate(val.to_ref(), dest)?;\n             }\n \n             NullaryOp(mir::NullOp::Box, _) => {"}, {"sha": "4cd7ca8182e99bd63b72728cda93412840dc2a4b", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f27cd60ae1819b3b23fc8c3cb21d5f7d457014a1/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f27cd60ae1819b3b23fc8c3cb21d5f7d457014a1/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=f27cd60ae1819b3b23fc8c3cb21d5f7d457014a1", "patch": "@@ -447,10 +447,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         };\n \n         let arg = OpTy {\n-            op: Operand::Immediate(self.create_ref(\n-                place,\n-                None // this is a \"raw reference\"\n-            )?),\n+            op: Operand::Immediate(place.to_ref()),\n             layout: self.layout_of(self.tcx.mk_mut_ptr(place.layout.ty))?,\n         };\n "}, {"sha": "0be91c3c3399300ab8294fa0a26fdeed7cbf252c", "filename": "src/librustc_mir/transform/add_retag.rs", "status": "modified", "additions": 62, "deletions": 30, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/f27cd60ae1819b3b23fc8c3cb21d5f7d457014a1/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f27cd60ae1819b3b23fc8c3cb21d5f7d457014a1/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs?ref=f27cd60ae1819b3b23fc8c3cb21d5f7d457014a1", "patch": "@@ -20,20 +20,22 @@ use transform::{MirPass, MirSource};\n \n pub struct AddRetag;\n \n-/// Determines whether this place is local: If it is part of a local variable.\n-/// We do not consider writes to pointers local, only writes that immediately assign\n-/// to a local variable.\n-/// One important property here is that evaluating the place immediately after\n-/// the assignment must produce the same place as what was used during the assignment.\n-fn is_local<'tcx>(\n+/// Determines whether this place is \"stable\": Whether, if we evaluate it again\n+/// after the assignment, we can be sure to obtain the same place value.\n+/// (Concurrent accesses by other threads are no problem as these are anyway non-atomic\n+/// copies.  Data races are UB.)\n+fn is_stable<'tcx>(\n     place: &Place<'tcx>,\n ) -> bool {\n     use rustc::mir::Place::*;\n \n     match *place {\n-        Local { .. } => true,\n-        Promoted(_) |\n-        Static(_) => false,\n+        // Locals and statics have stable addresses, for sure\n+        Local { .. } |\n+        Promoted { .. } |\n+        Static { .. } =>\n+            true,\n+        // Recurse for projections\n         Projection(ref proj) => {\n             match proj.elem {\n                 ProjectionElem::Deref |\n@@ -47,15 +49,15 @@ fn is_local<'tcx>(\n                 ProjectionElem::Subslice { .. } |\n                 ProjectionElem::Downcast { .. } =>\n                     // These just offset by a constant, entirely independent of everything else.\n-                    is_local(&proj.base),\n+                    is_stable(&proj.base),\n             }\n         }\n     }\n }\n \n-/// Determine whether this type has a reference in it, recursing below compound types but\n+/// Determine whether this type may have a reference in it, recursing below compound types but\n /// not below references.\n-fn has_reference<'a, 'gcx, 'tcx>(ty: Ty<'tcx>, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> bool {\n+fn may_have_reference<'a, 'gcx, 'tcx>(ty: Ty<'tcx>, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> bool {\n     match ty.sty {\n         // Primitive types that are not references\n         ty::Bool | ty::Char |\n@@ -68,12 +70,12 @@ fn has_reference<'a, 'gcx, 'tcx>(ty: Ty<'tcx>, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> b\n         ty::Adt(..) if ty.is_box() => true,\n         // Compound types\n         ty::Array(ty, ..) | ty::Slice(ty) =>\n-            has_reference(ty, tcx),\n+            may_have_reference(ty, tcx),\n         ty::Tuple(tys) =>\n-            tys.iter().any(|ty| has_reference(ty, tcx)),\n+            tys.iter().any(|ty| may_have_reference(ty, tcx)),\n         ty::Adt(adt, substs) =>\n             adt.variants.iter().any(|v| v.fields.iter().any(|f|\n-                has_reference(f.ty(tcx, substs), tcx)\n+                may_have_reference(f.ty(tcx, substs), tcx)\n             )),\n         // Conservative fallback\n         _ => true,\n@@ -92,7 +94,9 @@ impl MirPass for AddRetag {\n         let (span, arg_count) = (mir.span, mir.arg_count);\n         let (basic_blocks, local_decls) = mir.basic_blocks_and_local_decls_mut();\n         let needs_retag = |place: &Place<'tcx>| {\n-            is_local(place) && has_reference(place.ty(&*local_decls, tcx).to_ty(tcx), tcx)\n+            // FIXME: Instead of giving up for unstable places, we should introduce\n+            // a temporary and retag on that.\n+            is_stable(place) && may_have_reference(place.ty(&*local_decls, tcx).to_ty(tcx), tcx)\n         };\n \n         // PART 1\n@@ -118,23 +122,29 @@ impl MirPass for AddRetag {\n         }\n \n         // PART 2\n-        // Retag return values of functions.\n+        // Retag return values of functions.  Also escape-to-raw the argument of `drop`.\n         // We collect the return destinations because we cannot mutate while iterating.\n         let mut returns: Vec<(SourceInfo, Place<'tcx>, BasicBlock)> = Vec::new();\n         for block_data in basic_blocks.iter_mut() {\n-            match block_data.terminator {\n-                Some(Terminator { kind: TerminatorKind::Call { ref destination, .. },\n-                                  source_info }) => {\n+            match block_data.terminator().kind {\n+                TerminatorKind::Call { ref destination, .. } => {\n                     // Remember the return destination for later\n                     if let Some(ref destination) = destination {\n                         if needs_retag(&destination.0) {\n-                            returns.push((source_info, destination.0.clone(), destination.1));\n+                            returns.push((\n+                                block_data.terminator().source_info,\n+                                destination.0.clone(),\n+                                destination.1,\n+                            ));\n                         }\n                     }\n                 }\n+                TerminatorKind::Drop { .. } |\n+                TerminatorKind::DropAndReplace { .. } => {\n+                    // `Drop` is also a call, but it doesn't return anything so we are good.\n+                }\n                 _ => {\n                     // Not a block ending in a Call -> ignore.\n-                    // `Drop` is also a call, but it doesn't return anything so we are good.\n                 }\n             }\n         }\n@@ -153,21 +163,43 @@ impl MirPass for AddRetag {\n             // iterate backwards using indices.\n             for i in (0..block_data.statements.len()).rev() {\n                 match block_data.statements[i].kind {\n-                    // Assignments can make values obtained elsewhere \"local\".\n-                    // We could try to be smart here and e.g. only retag if the assignment\n-                    // loaded from memory, but that seems risky: We might miss a subtle corner\n-                    // case.\n-                    StatementKind::Assign(ref place, box Rvalue::Use(..))\n-                    if needs_retag(place) => {\n+                    // If we are casting *from* a reference, we may have to escape-to-raw.\n+                    StatementKind::Assign(_, box Rvalue::Cast(\n+                        CastKind::Misc,\n+                        ref src,\n+                        dest_ty,\n+                    )) => {\n+                        let src_ty = src.ty(&*local_decls, tcx);\n+                        if src_ty.is_region_ptr() {\n+                            // The only `Misc` casts on references are those creating raw pointers.\n+                            assert!(dest_ty.is_unsafe_ptr());\n+                            // Insert escape-to-raw before the cast.  We are not concerned\n+                            // with stability here: Our EscapeToRaw will not change the value\n+                            // that the cast will then use.\n+                            // `src` might be a \"move\", but we rely on this not actually moving\n+                            // but just doing a memcpy.  It is crucial that we do EscapeToRaw\n+                            // on the src because we need it with its original type.\n+                            let source_info = block_data.statements[i].source_info;\n+                            block_data.statements.insert(i, Statement {\n+                                source_info,\n+                                kind: StatementKind::EscapeToRaw(src.clone()),\n+                            });\n+                        }\n+                    }\n+                    // Assignments of reference or ptr type are the ones where we may have\n+                    // to update tags.  This includes `x = &[mut] ...` and hence\n+                    // we also retag after taking a reference!\n+                    StatementKind::Assign(ref place, _) if needs_retag(place) => {\n                         // Insert a retag after the assignment.\n                         let source_info = block_data.statements[i].source_info;\n-                        block_data.statements.insert(i+1,Statement {\n+                        block_data.statements.insert(i+1, Statement {\n                             source_info,\n                             kind: StatementKind::Retag { fn_entry: false, place: place.clone() },\n                         });\n                     }\n+                    // Do nothing for the rest\n                     _ => {},\n-                }\n+                };\n             }\n         }\n     }"}, {"sha": "4ebeebca2273bbf48034609258f5df5dcaaf83d8", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f27cd60ae1819b3b23fc8c3cb21d5f7d457014a1/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f27cd60ae1819b3b23fc8c3cb21d5f7d457014a1/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=f27cd60ae1819b3b23fc8c3cb21d5f7d457014a1", "patch": "@@ -114,6 +114,7 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n             StatementKind::StorageDead(..) |\n             StatementKind::EndRegion(..) |\n             StatementKind::Retag { .. } |\n+            StatementKind::EscapeToRaw { .. } |\n             StatementKind::AscribeUserType(..) |\n             StatementKind::Nop => {\n                 // safe (at least as emitted during MIR construction)"}, {"sha": "5fd8332129664ae5ffadd160ba8d769e44ce12dc", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f27cd60ae1819b3b23fc8c3cb21d5f7d457014a1/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f27cd60ae1819b3b23fc8c3cb21d5f7d457014a1/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=f27cd60ae1819b3b23fc8c3cb21d5f7d457014a1", "patch": "@@ -1168,6 +1168,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                 StatementKind::InlineAsm {..} |\n                 StatementKind::EndRegion(_) |\n                 StatementKind::Retag { .. } |\n+                StatementKind::EscapeToRaw { .. } |\n                 StatementKind::AscribeUserType(..) |\n                 StatementKind::Nop => {}\n             }"}, {"sha": "ed13063cfdf1700d3abd4a64eaff14a5cd200f59", "filename": "src/librustc_mir/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f27cd60ae1819b3b23fc8c3cb21d5f7d457014a1/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f27cd60ae1819b3b23fc8c3cb21d5f7d457014a1/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs?ref=f27cd60ae1819b3b23fc8c3cb21d5f7d457014a1", "patch": "@@ -242,6 +242,7 @@ fn check_statement(\n         | StatementKind::StorageLive(_)\n         | StatementKind::StorageDead(_)\n         | StatementKind::Retag { .. }\n+        | StatementKind::EscapeToRaw { .. }\n         | StatementKind::EndRegion(_)\n         | StatementKind::AscribeUserType(..)\n         | StatementKind::Nop => Ok(()),"}, {"sha": "445ffbbcf3407b0d56ee25e5842412c343e9c3ec", "filename": "src/librustc_mir/transform/remove_noop_landing_pads.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f27cd60ae1819b3b23fc8c3cb21d5f7d457014a1/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f27cd60ae1819b3b23fc8c3cb21d5f7d457014a1/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs?ref=f27cd60ae1819b3b23fc8c3cb21d5f7d457014a1", "patch": "@@ -65,10 +65,11 @@ impl RemoveNoopLandingPads {\n                     // turn a landing pad to a non-nop\n                 }\n \n-                StatementKind::Assign(_, _) |\n+                StatementKind::Assign { .. } |\n                 StatementKind::SetDiscriminant { .. } |\n                 StatementKind::InlineAsm { .. } |\n-                StatementKind::Retag { .. } => {\n+                StatementKind::Retag { .. } |\n+                StatementKind::EscapeToRaw { .. } => {\n                     return false;\n                 }\n             }"}, {"sha": "8f026c706fdf7522b1aa3acbf427b5e8a9aac952", "filename": "src/librustc_mir/transform/rustc_peek.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f27cd60ae1819b3b23fc8c3cb21d5f7d457014a1/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f27cd60ae1819b3b23fc8c3cb21d5f7d457014a1/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs?ref=f27cd60ae1819b3b23fc8c3cb21d5f7d457014a1", "patch": "@@ -163,6 +163,7 @@ fn each_block<'a, 'tcx, O>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             mir::StatementKind::InlineAsm { .. } |\n             mir::StatementKind::EndRegion(_) |\n             mir::StatementKind::Retag { .. } |\n+            mir::StatementKind::EscapeToRaw { .. } |\n             mir::StatementKind::AscribeUserType(..) |\n             mir::StatementKind::Nop => continue,\n             mir::StatementKind::SetDiscriminant{ .. } =>"}, {"sha": "68840ed4a480476ad0cb1e29a46b55d01cbd68c4", "filename": "src/librustc_passes/mir_stats.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f27cd60ae1819b3b23fc8c3cb21d5f7d457014a1/src%2Flibrustc_passes%2Fmir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f27cd60ae1819b3b23fc8c3cb21d5f7d457014a1/src%2Flibrustc_passes%2Fmir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fmir_stats.rs?ref=f27cd60ae1819b3b23fc8c3cb21d5f7d457014a1", "patch": "@@ -85,6 +85,7 @@ impl<'a, 'tcx> mir_visit::Visitor<'tcx> for StatCollector<'a, 'tcx> {\n             StatementKind::FakeRead(..) => \"StatementKind::FakeRead\",\n             StatementKind::EndRegion(..) => \"StatementKind::EndRegion\",\n             StatementKind::Retag { .. } => \"StatementKind::Retag\",\n+            StatementKind::EscapeToRaw { .. } => \"StatementKind::EscapeToRaw\",\n             StatementKind::SetDiscriminant { .. } => \"StatementKind::SetDiscriminant\",\n             StatementKind::StorageLive(..) => \"StatementKind::StorageLive\",\n             StatementKind::StorageDead(..) => \"StatementKind::StorageDead\","}, {"sha": "1e5e1ad5ed1c55fddb6c9e3ae8d72453cc6819cf", "filename": "src/test/mir-opt/inline-retag.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f27cd60ae1819b3b23fc8c3cb21d5f7d457014a1/src%2Ftest%2Fmir-opt%2Finline-retag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f27cd60ae1819b3b23fc8c3cb21d5f7d457014a1/src%2Ftest%2Fmir-opt%2Finline-retag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline-retag.rs?ref=f27cd60ae1819b3b23fc8c3cb21d5f7d457014a1", "patch": "@@ -32,6 +32,8 @@ fn bar() -> bool {\n //     bb0: {\n //         ...\n //         Retag(_3);\n+//         ...\n+//         Retag(_3);\n //         Retag(_6);\n //         StorageLive(_9);\n //         _9 = (*_3);"}, {"sha": "7da55c0868cd2bf6d5a3611dd1482f706dc88ff4", "filename": "src/test/mir-opt/retag.rs", "status": "modified", "additions": 23, "deletions": 4, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/f27cd60ae1819b3b23fc8c3cb21d5f7d457014a1/src%2Ftest%2Fmir-opt%2Fretag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f27cd60ae1819b3b23fc8c3cb21d5f7d457014a1/src%2Ftest%2Fmir-opt%2Fretag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fretag.rs?ref=f27cd60ae1819b3b23fc8c3cb21d5f7d457014a1", "patch": "@@ -26,7 +26,9 @@ fn main() {\n     {\n         let v = Test(0).foo(&mut x); // just making sure we do not panic when there is a tuple struct ctor\n         let w = { v }; // assignment\n-        let _w = w; // reborrow\n+        let w = w; // reborrow\n+        // escape-to-raw (mut)\n+        let _w = w as *mut _;\n     }\n \n     // Also test closures\n@@ -35,6 +37,9 @@ fn main() {\n \n     // need to call `foo_shr` or it doesn't even get generated\n     Test(0).foo_shr(&0);\n+\n+    // escape-to-raw (shr)\n+    let _w = _w as *const _;\n }\n \n // END RUST SOURCE\n@@ -44,6 +49,7 @@ fn main() {\n //         Retag([fn entry] _2);\n //         ...\n //         _0 = &mut (*_3);\n+//         Retag(_0);\n //         ...\n //         return;\n //     }\n@@ -73,23 +79,36 @@ fn main() {\n //         _9 = move _3;\n //         Retag(_9);\n //         _8 = &mut (*_9);\n+//         Retag(_8);\n //         StorageDead(_9);\n //         StorageLive(_10);\n //         _10 = move _8;\n //         Retag(_10);\n //         ...\n-//         _13 = move _14(move _15) -> bb2;\n+//         _14 = &mut (*_10);\n+//         Retag(_14);\n+//         EscapeToRaw(move _14);\n+//         _13 = move _14 as *mut i32 (Misc);\n+//         ...\n+//         _17 = move _18(move _19) -> bb2;\n //     }\n //\n //     bb2: {\n-//         Retag(_13);\n+//         Retag(_17);\n+//         ...\n+//         _21 = const Test::foo_shr(move _22, move _24) -> bb3;\n+//     }\n+//\n+//     bb3: {\n //         ...\n+//         return;\n //     }\n+//\n //     ...\n // }\n // END rustc.main.EraseRegions.after.mir\n // START rustc.main-{{closure}}.EraseRegions.after.mir\n-// fn main::{{closure}}(_1: &[closure@NodeId(117)], _2: &i32) -> &i32 {\n+// fn main::{{closure}}(_1: &[closure@NodeId(124)], _2: &i32) -> &i32 {\n //     ...\n //     bb0: {\n //         Retag([fn entry] _1);"}]}