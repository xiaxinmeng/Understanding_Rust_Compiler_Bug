{"sha": "0cb7926e05a1bb53f7db49e9a989c27155152b41", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBjYjc5MjZlMDVhMWJiNTNmN2RiNDllOWE5ODljMjcxNTUxNTJiNDE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2019-03-20T16:45:24Z"}, "committer": {"name": "scalexm", "email": "alexandre@scalexm.fr", "date": "2019-03-20T19:17:12Z"}, "message": "refactor so that `relate_ty_var` can accommodate vid on a or b side", "tree": {"sha": "9c57d4a1ec76f463cb50d69dedbb07ae13528650", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9c57d4a1ec76f463cb50d69dedbb07ae13528650"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0cb7926e05a1bb53f7db49e9a989c27155152b41", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0cb7926e05a1bb53f7db49e9a989c27155152b41", "html_url": "https://github.com/rust-lang/rust/commit/0cb7926e05a1bb53f7db49e9a989c27155152b41", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0cb7926e05a1bb53f7db49e9a989c27155152b41/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "scalexm", "id": 1173131, "node_id": "MDQ6VXNlcjExNzMxMzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1173131?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scalexm", "html_url": "https://github.com/scalexm", "followers_url": "https://api.github.com/users/scalexm/followers", "following_url": "https://api.github.com/users/scalexm/following{/other_user}", "gists_url": "https://api.github.com/users/scalexm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scalexm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scalexm/subscriptions", "organizations_url": "https://api.github.com/users/scalexm/orgs", "repos_url": "https://api.github.com/users/scalexm/repos", "events_url": "https://api.github.com/users/scalexm/events{/privacy}", "received_events_url": "https://api.github.com/users/scalexm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "356ea0b405f08bd6a8fcff1138088802747a5ee9", "url": "https://api.github.com/repos/rust-lang/rust/commits/356ea0b405f08bd6a8fcff1138088802747a5ee9", "html_url": "https://github.com/rust-lang/rust/commit/356ea0b405f08bd6a8fcff1138088802747a5ee9"}], "stats": {"total": 152, "additions": 130, "deletions": 22}, "files": [{"sha": "735dcffc6d16dbf2a6414fa70a9322784dec1814", "filename": "src/librustc/infer/nll_relate/mod.rs", "status": "modified", "additions": 130, "deletions": 22, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/0cb7926e05a1bb53f7db49e9a989c27155152b41/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cb7926e05a1bb53f7db49e9a989c27155152b41/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs?ref=0cb7926e05a1bb53f7db49e9a989c27155152b41", "patch": "@@ -29,6 +29,7 @@ use crate::ty::relate::{self, Relate, RelateResult, TypeRelation};\n use crate::ty::subst::Kind;\n use crate::ty::{self, Ty, TyCtxt};\n use rustc_data_structures::fx::FxHashMap;\n+use std::fmt::Debug;\n \n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n pub enum NormalizationStrategy {\n@@ -294,14 +295,34 @@ where\n         }\n     }\n \n-    /// Relate a type inference variable with a value type.\n-    fn relate_ty_var(\n+    /// Relate a type inference variable with a value type. This works\n+    /// by creating a \"generalization\" G of the value where all the\n+    /// lifetimes are replaced with fresh inference values. This\n+    /// genearlization G becomes the value of the inference variable,\n+    /// and is then related in turn to the value. So e.g. if you had\n+    /// `vid = ?0` and `value = &'a u32`, we might first instantiate\n+    /// `?0` to a type like `&'0 u32` where `'0` is a fresh variable,\n+    /// and then relate `&'0 u32` with `&'a u32` (resulting in\n+    /// relations between `'0` and `'a`).\n+    ///\n+    /// The variable `pair` can be either a `(vid, ty)` or `(ty, vid)`\n+    /// -- in other words, it is always a (unresolved) inference\n+    /// variable `vid` and a type `ty` that are being related, but the\n+    /// vid may appear either as the \"a\" type or the \"b\" type,\n+    /// depending on where it appears in the tuple. The trait\n+    /// `VidValuePair` lets us work with the vid/type while preserving\n+    /// the \"sidedness\" when necessary -- the sidedness is relevant in\n+    /// particular for the variance and set of in-scope things.\n+    fn relate_ty_var<PAIR: VidValuePair<'tcx>>(\n         &mut self,\n-        vid: ty::TyVid,\n-        value_ty: Ty<'tcx>,\n+        pair: PAIR,\n     ) -> RelateResult<'tcx, Ty<'tcx>> {\n-        debug!(\"relate_ty_var(vid={:?}, value_ty={:?})\", vid, value_ty);\n+        debug!(\"relate_ty_var({:?})\", pair);\n+\n+        let vid = pair.vid();\n+        let value_ty = pair.value_ty();\n \n+        // FIXME -- this logic assumes invariance, but that is wrong\n         match value_ty.sty {\n             ty::Infer(ty::TyVar(value_vid)) => {\n                 // Two type variables: just equate them.\n@@ -338,13 +359,13 @@ where\n         // been fully instantiated and hence the set of scopes we have\n         // doesn't matter -- just to be sure, put an empty vector\n         // in there.\n-        let old_a_scopes = ::std::mem::replace(&mut self.a_scopes, vec![]);\n+        let old_a_scopes = ::std::mem::replace(pair.vid_scopes(self), vec![]);\n \n         // Relate the generalized kind to the original one.\n-        let result = self.relate(&generalized_ty, &value_ty);\n+        let result = pair.relate_generalized_ty(self, generalized_ty);\n \n         // Restore the old scopes now.\n-        self.a_scopes = old_a_scopes;\n+        *pair.vid_scopes(self) = old_a_scopes;\n \n         debug!(\"relate_ty_var: complete, result = {:?}\", result);\n         result\n@@ -370,6 +391,104 @@ where\n     }\n }\n \n+/// When we instantiate a inference variable with a value in\n+/// `relate_ty_var`, we always have the pair of a `TyVid` and a `Ty`,\n+/// but the ordering may vary (depending on whether the inference\n+/// variable was found on the `a` or `b` sides). Therefore, this trait\n+/// allows us to factor out common code, while preserving the order\n+/// when needed.\n+trait VidValuePair<'tcx>: Debug {\n+    /// Extract the inference variable (which could be either the\n+    /// first or second part of the tuple).\n+    fn vid(&self) -> ty::TyVid;\n+\n+    /// Extract the value it is being related to (which will be the\n+    /// opposite part of the tuple from the vid).\n+    fn value_ty(&self) -> Ty<'tcx>;\n+\n+    /// Extract the scopes that apply to whichever side of the tuple\n+    /// the vid was found on.  See the comment where this is called\n+    /// for more details on why we want them.\n+    fn vid_scopes<D: TypeRelatingDelegate<'tcx>>(\n+        &self,\n+        relate: &'r mut TypeRelating<'_, '_, 'tcx, D>,\n+    ) -> &'r mut Vec<BoundRegionScope<'tcx>>;\n+\n+    /// Given a generalized type G that should replace the vid, relate\n+    /// G to the value, putting G on whichever side the vid would have\n+    /// appeared.\n+    fn relate_generalized_ty<D>(\n+        &self,\n+        relate: &mut TypeRelating<'_, '_, 'tcx, D>,\n+        generalized_ty: Ty<'tcx>,\n+    ) -> RelateResult<'tcx, Ty<'tcx>>\n+    where\n+        D: TypeRelatingDelegate<'tcx>;\n+}\n+\n+impl VidValuePair<'tcx> for (ty::TyVid, Ty<'tcx>) {\n+    fn vid(&self) -> ty::TyVid {\n+        self.0\n+    }\n+\n+    fn value_ty(&self) -> Ty<'tcx> {\n+        self.1\n+    }\n+\n+    fn vid_scopes<D>(\n+        &self,\n+        relate: &'r mut TypeRelating<'_, '_, 'tcx, D>,\n+    ) -> &'r mut Vec<BoundRegionScope<'tcx>>\n+    where\n+        D: TypeRelatingDelegate<'tcx>,\n+    {\n+        &mut relate.a_scopes\n+    }\n+\n+    fn relate_generalized_ty<D>(\n+        &self,\n+        relate: &mut TypeRelating<'_, '_, 'tcx, D>,\n+        generalized_ty: Ty<'tcx>,\n+    ) -> RelateResult<'tcx, Ty<'tcx>>\n+    where\n+        D: TypeRelatingDelegate<'tcx>,\n+    {\n+        relate.relate(&generalized_ty, &self.value_ty())\n+    }\n+}\n+\n+// In this case, the \"vid\" is the \"b\" type.\n+impl VidValuePair<'tcx> for (Ty<'tcx>, ty::TyVid) {\n+    fn vid(&self) -> ty::TyVid {\n+        self.1\n+    }\n+\n+    fn value_ty(&self) -> Ty<'tcx> {\n+        self.0\n+    }\n+\n+    fn vid_scopes<D>(\n+        &self,\n+        relate: &'r mut TypeRelating<'_, '_, 'tcx, D>,\n+    ) -> &'r mut Vec<BoundRegionScope<'tcx>>\n+    where\n+        D: TypeRelatingDelegate<'tcx>,\n+    {\n+        &mut relate.b_scopes\n+    }\n+\n+    fn relate_generalized_ty<D>(\n+        &self,\n+        relate: &mut TypeRelating<'_, '_, 'tcx, D>,\n+        generalized_ty: Ty<'tcx>,\n+    ) -> RelateResult<'tcx, Ty<'tcx>>\n+    where\n+        D: TypeRelatingDelegate<'tcx>,\n+    {\n+        relate.relate(&self.value_ty(), &generalized_ty)\n+    }\n+}\n+\n impl<D> TypeRelation<'me, 'gcx, 'tcx> for TypeRelating<'me, 'gcx, 'tcx, D>\n where\n     D: TypeRelatingDelegate<'tcx>,\n@@ -427,17 +546,11 @@ where\n                     // Forbid inference variables in the RHS.\n                     bug!(\"unexpected inference var {:?}\", b)\n                 } else {\n-                    // We swap the order of `a` and `b` in the call to\n-                    // `relate_ty_var` below, so swap the corresponding scopes\n-                    // as well.\n-                    std::mem::swap(&mut self.a_scopes, &mut self.b_scopes);\n-                    let res = self.relate_ty_var(vid, a);\n-                    std::mem::swap(&mut self.a_scopes, &mut self.b_scopes);\n-                    res\n+                    self.relate_ty_var((a, vid))\n                 }\n             }\n \n-            (&ty::Infer(ty::TyVar(vid)), _) => self.relate_ty_var(vid, b),\n+            (&ty::Infer(ty::TyVar(vid)), _) => self.relate_ty_var((vid, b)),\n \n             (&ty::Projection(projection_ty), _)\n                 if D::normalization() == NormalizationStrategy::Lazy =>\n@@ -448,12 +561,7 @@ where\n             (_, &ty::Projection(projection_ty))\n                 if D::normalization() == NormalizationStrategy::Lazy =>\n             {\n-                // Swap the respective scopes of `a` and `b` (see comment\n-                // above).\n-                std::mem::swap(&mut self.a_scopes, &mut self.b_scopes);\n-                let res = self.relate_projection_ty(projection_ty, a);\n-                std::mem::swap(&mut self.a_scopes, &mut self.b_scopes);\n-                Ok(res)\n+                Ok(self.relate_projection_ty(projection_ty, a))\n             }\n \n             _ => {"}]}