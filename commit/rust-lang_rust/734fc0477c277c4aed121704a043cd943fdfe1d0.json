{"sha": "734fc0477c277c4aed121704a043cd943fdfe1d0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjczNGZjMDQ3N2MyNzdjNGFlZDEyMTcwNGEwNDNjZDk0M2ZkZmUxZDA=", "commit": {"author": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2020-07-22T20:37:08Z"}, "committer": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2020-08-07T17:51:26Z"}, "message": "BTreeMap: enforce the panic rule imposed by `replace`", "tree": {"sha": "a080fc9c09412201e2ba19c3a8b7db08e4c51758", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a080fc9c09412201e2ba19c3a8b7db08e4c51758"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/734fc0477c277c4aed121704a043cd943fdfe1d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/734fc0477c277c4aed121704a043cd943fdfe1d0", "html_url": "https://github.com/rust-lang/rust/commit/734fc0477c277c4aed121704a043cd943fdfe1d0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/734fc0477c277c4aed121704a043cd943fdfe1d0/comments", "author": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "119d2a1a98fe87d4ae6cabf12134a0ef2fb95851", "url": "https://api.github.com/repos/rust-lang/rust/commits/119d2a1a98fe87d4ae6cabf12134a0ef2fb95851", "html_url": "https://github.com/rust-lang/rust/commit/119d2a1a98fe87d4ae6cabf12134a0ef2fb95851"}], "stats": {"total": 104, "additions": 51, "deletions": 53}, "files": [{"sha": "33b1ee003ed3af1c98082a3cc2b942364aeca907", "filename": "library/alloc/src/collections/btree/navigate.rs", "status": "modified", "additions": 51, "deletions": 53, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/734fc0477c277c4aed121704a043cd943fdfe1d0/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnavigate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/734fc0477c277c4aed121704a043cd943fdfe1d0/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnavigate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnavigate.rs?ref=734fc0477c277c4aed121704a043cd943fdfe1d0", "patch": "@@ -1,3 +1,5 @@\n+use core::intrinsics;\n+use core::mem;\n use core::ptr;\n \n use super::node::{marker, ForceResult::*, Handle, NodeRef};\n@@ -79,16 +81,24 @@ def_next_kv_uncheched_dealloc! {unsafe fn next_kv_unchecked_dealloc: right_kv}\n def_next_kv_uncheched_dealloc! {unsafe fn next_back_kv_unchecked_dealloc: left_kv}\n \n /// This replaces the value behind the `v` unique reference by calling the\n-/// relevant function.\n+/// relevant function, and returns a result obtained along the way.\n ///\n-/// Safety: The change closure must not panic.\n+/// If a panic occurs in the `change` closure, the entire process will be aborted.\n #[inline]\n-unsafe fn replace<T, R>(v: &mut T, change: impl FnOnce(T) -> (T, R)) -> R {\n+fn replace<T, R>(v: &mut T, change: impl FnOnce(T) -> (T, R)) -> R {\n+    struct PanicGuard;\n+    impl Drop for PanicGuard {\n+        fn drop(&mut self) {\n+            intrinsics::abort()\n+        }\n+    }\n+    let guard = PanicGuard;\n     let value = unsafe { ptr::read(v) };\n     let (new_value, ret) = change(value);\n     unsafe {\n         ptr::write(v, new_value);\n     }\n+    mem::forget(guard);\n     ret\n }\n \n@@ -97,26 +107,22 @@ impl<'a, K, V> Handle<NodeRef<marker::Immut<'a>, K, V, marker::Leaf>, marker::Ed\n     /// key and value in between.\n     /// Unsafe because the caller must ensure that the leaf edge is not the last one in the tree.\n     pub unsafe fn next_unchecked(&mut self) -> (&'a K, &'a V) {\n-        unsafe {\n-            replace(self, |leaf_edge| {\n-                let kv = leaf_edge.next_kv();\n-                let kv = unwrap_unchecked(kv.ok());\n-                (kv.next_leaf_edge(), kv.into_kv())\n-            })\n-        }\n+        replace(self, |leaf_edge| {\n+            let kv = leaf_edge.next_kv();\n+            let kv = unsafe { unwrap_unchecked(kv.ok()) };\n+            (kv.next_leaf_edge(), kv.into_kv())\n+        })\n     }\n \n     /// Moves the leaf edge handle to the previous leaf edge and returns references to the\n     /// key and value in between.\n     /// Unsafe because the caller must ensure that the leaf edge is not the first one in the tree.\n     pub unsafe fn next_back_unchecked(&mut self) -> (&'a K, &'a V) {\n-        unsafe {\n-            replace(self, |leaf_edge| {\n-                let kv = leaf_edge.next_back_kv();\n-                let kv = unwrap_unchecked(kv.ok());\n-                (kv.next_back_leaf_edge(), kv.into_kv())\n-            })\n-        }\n+        replace(self, |leaf_edge| {\n+            let kv = leaf_edge.next_back_kv();\n+            let kv = unsafe { unwrap_unchecked(kv.ok()) };\n+            (kv.next_back_leaf_edge(), kv.into_kv())\n+        })\n     }\n }\n \n@@ -127,16 +133,14 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge\n     /// - The caller must ensure that the leaf edge is not the last one in the tree.\n     /// - Using the updated handle may well invalidate the returned references.\n     pub unsafe fn next_unchecked(&mut self) -> (&'a mut K, &'a mut V) {\n-        unsafe {\n-            let kv = replace(self, |leaf_edge| {\n-                let kv = leaf_edge.next_kv();\n-                let kv = unwrap_unchecked(kv.ok());\n-                (ptr::read(&kv).next_leaf_edge(), kv)\n-            });\n-            // Doing the descend (and perhaps another move) invalidates the references\n-            // returned by `into_kv_mut`, so we have to do this last.\n-            kv.into_kv_mut()\n-        }\n+        let kv = replace(self, |leaf_edge| {\n+            let kv = leaf_edge.next_kv();\n+            let kv = unsafe { unwrap_unchecked(kv.ok()) };\n+            (unsafe { ptr::read(&kv) }.next_leaf_edge(), kv)\n+        });\n+        // Doing the descend (and perhaps another move) invalidates the references\n+        // returned by `into_kv_mut`, so we have to do this last.\n+        kv.into_kv_mut()\n     }\n \n     /// Moves the leaf edge handle to the previous leaf and returns references to the\n@@ -145,16 +149,14 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge\n     /// - The caller must ensure that the leaf edge is not the first one in the tree.\n     /// - Using the updated handle may well invalidate the returned references.\n     pub unsafe fn next_back_unchecked(&mut self) -> (&'a mut K, &'a mut V) {\n-        unsafe {\n-            let kv = replace(self, |leaf_edge| {\n-                let kv = leaf_edge.next_back_kv();\n-                let kv = unwrap_unchecked(kv.ok());\n-                (ptr::read(&kv).next_back_leaf_edge(), kv)\n-            });\n-            // Doing the descend (and perhaps another move) invalidates the references\n-            // returned by `into_kv_mut`, so we have to do this last.\n-            kv.into_kv_mut()\n-        }\n+        let kv = replace(self, |leaf_edge| {\n+            let kv = leaf_edge.next_back_kv();\n+            let kv = unsafe { unwrap_unchecked(kv.ok()) };\n+            (unsafe { ptr::read(&kv) }.next_back_leaf_edge(), kv)\n+        });\n+        // Doing the descend (and perhaps another move) invalidates the references\n+        // returned by `into_kv_mut`, so we have to do this last.\n+        kv.into_kv_mut()\n     }\n }\n \n@@ -172,14 +174,12 @@ impl<K, V> Handle<NodeRef<marker::Owned, K, V, marker::Leaf>, marker::Edge> {\n     ///   call this method again subject to both preconditions listed in the first point,\n     ///   or call counterpart `next_back_unchecked` subject to its preconditions.\n     pub unsafe fn next_unchecked(&mut self) -> (K, V) {\n-        unsafe {\n-            replace(self, |leaf_edge| {\n-                let kv = next_kv_unchecked_dealloc(leaf_edge);\n-                let k = ptr::read(kv.reborrow().into_kv().0);\n-                let v = ptr::read(kv.reborrow().into_kv().1);\n-                (kv.next_leaf_edge(), (k, v))\n-            })\n-        }\n+        replace(self, |leaf_edge| {\n+            let kv = unsafe { next_kv_unchecked_dealloc(leaf_edge) };\n+            let k = unsafe { ptr::read(kv.reborrow().into_kv().0) };\n+            let v = unsafe { ptr::read(kv.reborrow().into_kv().1) };\n+            (kv.next_leaf_edge(), (k, v))\n+        })\n     }\n \n     /// Moves the leaf edge handle to the previous leaf edge and returns the key\n@@ -195,14 +195,12 @@ impl<K, V> Handle<NodeRef<marker::Owned, K, V, marker::Leaf>, marker::Edge> {\n     ///   call this method again subject to both preconditions listed in the first point,\n     ///   or call counterpart `next_unchecked` subject to its preconditions.\n     pub unsafe fn next_back_unchecked(&mut self) -> (K, V) {\n-        unsafe {\n-            replace(self, |leaf_edge| {\n-                let kv = next_back_kv_unchecked_dealloc(leaf_edge);\n-                let k = ptr::read(kv.reborrow().into_kv().0);\n-                let v = ptr::read(kv.reborrow().into_kv().1);\n-                (kv.next_back_leaf_edge(), (k, v))\n-            })\n-        }\n+        replace(self, |leaf_edge| {\n+            let kv = unsafe { next_back_kv_unchecked_dealloc(leaf_edge) };\n+            let k = unsafe { ptr::read(kv.reborrow().into_kv().0) };\n+            let v = unsafe { ptr::read(kv.reborrow().into_kv().1) };\n+            (kv.next_back_leaf_edge(), (k, v))\n+        })\n     }\n }\n "}]}