{"sha": "0e5cfd9f339c78384ef3fbcb4d230fa0bb363d54", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBlNWNmZDlmMzM5Yzc4Mzg0ZWYzZmJjYjRkMjMwZmEwYmIzNjNkNTQ=", "commit": {"author": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-06-13T23:14:01Z"}, "committer": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-06-21T23:11:11Z"}, "message": "Move vector addition out of trans and into libcore.", "tree": {"sha": "f71eefbe17ea2b94ab475a0bc63f690a1ea339e4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f71eefbe17ea2b94ab475a0bc63f690a1ea339e4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0e5cfd9f339c78384ef3fbcb4d230fa0bb363d54", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0e5cfd9f339c78384ef3fbcb4d230fa0bb363d54", "html_url": "https://github.com/rust-lang/rust/commit/0e5cfd9f339c78384ef3fbcb4d230fa0bb363d54", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0e5cfd9f339c78384ef3fbcb4d230fa0bb363d54/comments", "author": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f8fa0a243788e6b1028d254958cd19c6f10034fa", "url": "https://api.github.com/repos/rust-lang/rust/commits/f8fa0a243788e6b1028d254958cd19c6f10034fa", "html_url": "https://github.com/rust-lang/rust/commit/f8fa0a243788e6b1028d254958cd19c6f10034fa"}], "stats": {"total": 419, "additions": 172, "deletions": 247}, "files": [{"sha": "ef368fe7a8b2714c5a5bb9fe206cbcec65f80287", "filename": "src/libcore/dvec.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0e5cfd9f339c78384ef3fbcb4d230fa0bb363d54/src%2Flibcore%2Fdvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e5cfd9f339c78384ef3fbcb4d230fa0bb363d54/src%2Flibcore%2Fdvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdvec.rs?ref=0e5cfd9f339c78384ef3fbcb4d230fa0bb363d54", "patch": "@@ -137,7 +137,9 @@ impl extensions<A:copy> for dvec<A> {\n     #[doc = \"Append a single item to the end of the list\"]\n     fn push(t: A) {\n         self.swap { |v|\n-            let mut v <- v; v += [t]; v // more efficient than v + [t]\n+            let mut v <- v;\n+            vec::push(v, t);\n+            v\n         }\n     }\n \n@@ -170,7 +172,7 @@ impl extensions<A:copy> for dvec<A> {\n             vec::reserve(v, new_len);\n             let mut i = from_idx;\n             while i < to_idx {\n-                v += [ts[i]];\n+                vec::push(v, ts[i]);\n                 i += 1u;\n             }\n             v"}, {"sha": "2a89abc040f858f48c347bd91087c1dc77d9b239", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0e5cfd9f339c78384ef3fbcb4d230fa0bb363d54/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e5cfd9f339c78384ef3fbcb4d230fa0bb363d54/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=0e5cfd9f339c78384ef3fbcb4d230fa0bb363d54", "patch": "@@ -10,6 +10,7 @@ export is_null;\n export is_not_null;\n export memcpy;\n export memmove;\n+export memset;\n export buf_len;\n export position;\n export extensions;\n@@ -23,6 +24,8 @@ native mod libc_ {\n     fn memcpy(dest: *c_void, src: *c_void, n: libc::size_t) -> *c_void;\n     #[rust_stack]\n     fn memmove(dest: *c_void, src: *c_void, n: libc::size_t) -> *c_void;\n+    #[rust_stack]\n+    fn memset(dest: *c_void, c: libc::c_int, len: libc::size_t) -> *c_void;\n }\n \n #[abi = \"rust-intrinsic\"]\n@@ -108,6 +111,12 @@ unsafe fn memmove<T>(dst: *T, src: *T, count: uint)  {\n     libc_::memmove(dst as *c_void, src as *c_void, n as size_t);\n }\n \n+#[inline(always)]\n+unsafe fn memset<T>(dst: *mut T, c: int, count: uint)  {\n+    let n = count * sys::size_of::<T>();\n+    libc_::memset(dst as *c_void, c as libc::c_int, n as size_t);\n+}\n+\n #[doc = \"Extension methods for pointers\"]\n impl extensions<T> for *T {\n     #[doc = \"Returns true if the pointer is equal to the null pointer.\"]"}, {"sha": "078243dfaeef1047039e5fe9cef82d50eecb7bf7", "filename": "src/libcore/str.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0e5cfd9f339c78384ef3fbcb4d230fa0bb363d54/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e5cfd9f339c78384ef3fbcb4d230fa0bb363d54/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=0e5cfd9f339c78384ef3fbcb4d230fa0bb363d54", "patch": "@@ -1743,8 +1743,9 @@ mod unsafe {\n    Does not verify that the vector contains valid UTF-8.\n    \"]\n    unsafe fn from_bytes(v: [const u8]) -> str unsafe {\n-       let vcopy = v + [0u8];\n-       ret ::unsafe::transmute(vcopy);\n+       let mut vcopy : [u8] = ::unsafe::transmute(copy v);\n+       vec::push(vcopy, 0u8);\n+       ::unsafe::transmute(vcopy)\n    }\n \n    #[doc = \""}, {"sha": "a1b2ee23f0f9009df1630b29fa88b7cd7916566a", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 90, "deletions": 15, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/0e5cfd9f339c78384ef3fbcb4d230fa0bb363d54/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e5cfd9f339c78384ef3fbcb4d230fa0bb363d54/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=0e5cfd9f339c78384ef3fbcb4d230fa0bb363d54", "patch": "@@ -4,6 +4,7 @@ import option::{some, none};\n import ptr::addr_of;\n import libc::size_t;\n \n+export append;\n export init_op;\n export is_empty;\n export is_not_empty;\n@@ -187,7 +188,9 @@ pure fn from_elem<T: copy>(n_elts: uint, t: T) -> [T] {\n     let mut v = [];\n     unchecked{reserve(v, n_elts)}\n     let mut i: uint = 0u;\n-    while i < n_elts { v += [t]; i += 1u; }\n+    unsafe { // because push is impure\n+        while i < n_elts { push(v, t); i += 1u; }\n+    }\n     ret v;\n }\n \n@@ -372,11 +375,8 @@ fn shift<T: copy>(&v: [T]) -> T {\n }\n \n #[doc = \"Prepend an element to a vector\"]\n-fn unshift<T: copy>(&v: [const T], +t: T) {\n-    // n.b.---for most callers, using unshift() ought not to type check, but\n-    // it does. It's because the type system is unaware of the mutability of\n-    // `v` and so allows the vector to be covariant.\n-    v = [const t] + v;\n+fn unshift<T: copy>(&v: [T], +t: T) {\n+    v = [t] + v;\n }\n \n #[doc = \"Remove the last element from a vector and return it\"]\n@@ -390,12 +390,69 @@ fn pop<T>(&v: [const T]) -> T unsafe {\n }\n \n #[doc = \"Append an element to a vector\"]\n+#[inline(always)]\n fn push<T>(&v: [const T], +initval: T) {\n-    v += [initval];\n+    let ln = v.len();\n+    unsafe {\n+        reserve_at_least(v, ln + 1u);\n+        unsafe::set_len(v, ln + 1u);\n+        let p = ptr::mut_addr_of(v[ln]);\n+\n+        // FIXME: for performance, try replacing the memmove and <- with a\n+        // memset and unsafe::forget.\n+        ptr::memset(p, 0, 1u); // needed to stop drop glue from running on\n+                               // garbage data.\n+        *p = initval;\n+    }\n }\n \n+#[inline(always)]\n+fn push_all<T: copy>(&v: [const T], rhs: [const T]/&) {\n+    for uint::range(0u, rhs.len()) {|i|\n+        push(v, rhs[i]);\n+    }\n+}\n \n // Appending\n+#[inline(always)]\n+pure fn append<T: copy>(lhs: [T]/&, rhs: [const T]/&) -> [T] {\n+    let mut v = [];\n+    let mut i = 0u;\n+    while i < lhs.len() {\n+        unsafe { // This is impure, but it appears pure to the caller.\n+            push(v, lhs[i]);\n+        }\n+        i += 1u;\n+    }\n+    i = 0u;\n+    while i < rhs.len() {\n+        unsafe { // This is impure, but it appears pure to the caller.\n+            push(v, rhs[i]);\n+        }\n+        i += 1u;\n+    }\n+    ret v;\n+}\n+\n+#[inline(always)]\n+pure fn append_mut<T: copy>(lhs: [mut T]/&, rhs: [const T]/&) -> [mut T] {\n+    let mut v = [mut];\n+    let mut i = 0u;\n+    while i < lhs.len() {\n+        unsafe { // This is impure, but it appears pure to the caller.\n+            push(v, lhs[i]);\n+        }\n+        i += 1u;\n+    }\n+    i = 0u;\n+    while i < rhs.len() {\n+        unsafe { // This is impure, but it appears pure to the caller.\n+            push(v, rhs[i]);\n+        }\n+        i += 1u;\n+    }\n+    ret v;\n+}\n \n #[doc = \"\n Expands a vector in place, initializing the new elements to a given value\n@@ -409,7 +466,8 @@ Expands a vector in place, initializing the new elements to a given value\n fn grow<T: copy>(&v: [const T], n: uint, initval: T) {\n     reserve_at_least(v, len(v) + n);\n     let mut i: uint = 0u;\n-    while i < n { v += [initval]; i += 1u; }\n+\n+    while i < n { push(v, initval); i += 1u; }\n }\n \n #[doc = \"\n@@ -428,7 +486,7 @@ Function `init_op` is called `n` times with the values [0..`n`)\n fn grow_fn<T>(&v: [const T], n: uint, op: init_op<T>) {\n     reserve_at_least(v, len(v) + n);\n     let mut i: uint = 0u;\n-    while i < n { v += [op(i)]; i += 1u; }\n+    while i < n { push(v, op(i)); i += 1u; }\n }\n \n #[doc = \"\n@@ -453,7 +511,7 @@ Apply a function to each element of a vector and return the results\n pure fn map<T, U>(v: [T]/&, f: fn(T) -> U) -> [U] {\n     let mut result = [];\n     unchecked{reserve(result, len(v));}\n-    for each(v) {|elem| result += [f(elem)]; }\n+    for each(v) {|elem| unsafe { push(result, f(elem)); } }\n     ret result;\n }\n \n@@ -486,7 +544,10 @@ pure fn map2<T: copy, U: copy, V>(v0: [T]/&, v1: [U]/&,\n     if v0_len != len(v1) { fail; }\n     let mut u: [V] = [];\n     let mut i = 0u;\n-    while i < v0_len { u += [f(copy v0[i], copy v1[i])]; i += 1u; }\n+    while i < v0_len {\n+        unsafe { push(u, f(copy v0[i], copy v1[i])) };\n+        i += 1u;\n+    }\n     ret u;\n }\n \n@@ -502,7 +563,7 @@ pure fn filter_map<T, U: copy>(v: [T]/&, f: fn(T) -> option<U>)\n     for each(v) {|elem|\n         alt f(elem) {\n           none {/* no-op */ }\n-          some(result_elem) { result += [result_elem]; }\n+          some(result_elem) { unsafe { push(result, result_elem); } }\n         }\n     }\n     ret result;\n@@ -518,7 +579,7 @@ only those elements for which `f` returned true.\n pure fn filter<T: copy>(v: [T]/&, f: fn(T) -> bool) -> [T] {\n     let mut result = [];\n     for each(v) {|elem|\n-        if f(elem) { result += [elem]; }\n+        if f(elem) { unsafe { push(result, elem); } }\n     }\n     ret result;\n }\n@@ -530,7 +591,7 @@ Flattens a vector of vectors of T into a single vector of T.\n \"]\n pure fn concat<T: copy>(v: [[T]]/&) -> [T] {\n     let mut r = [];\n-    for each(v) {|inner| r += inner; }\n+    for each(v) {|inner| unsafe { push_all(r, inner); } }\n     ret r;\n }\n \n@@ -541,7 +602,7 @@ pure fn connect<T: copy>(v: [[T]]/&, sep: T) -> [T] {\n     let mut r: [T] = [];\n     let mut first = true;\n     for each(v) {|inner|\n-        if first { first = false; } else { r += [sep]; }\n+        if first { first = false; } else { unsafe { push(r, sep); } }\n         r += inner;\n     }\n     ret r;\n@@ -1025,6 +1086,20 @@ pure fn unpack_mut_slice<T,U>(s: [mut T]/&,\n     f(buf, len / sys::size_of::<T>())\n }\n \n+impl extensions<T: copy> for [T] {\n+    #[inline(always)]\n+    pure fn +(rhs: [T]/&) -> [T] {\n+        append(self, rhs)\n+    }\n+}\n+\n+impl extensions<T: copy> for [mut T] {\n+    #[inline(always)]\n+    pure fn +(rhs: [mut T]/&) -> [mut T] {\n+        append_mut(self, rhs)\n+    }\n+}\n+\n #[doc = \"Extension methods for vectors\"]\n impl extensions/&<T> for [const T]/& {\n     #[doc = \"Returns true if a vector contains no elements\"]"}, {"sha": "eafd2776d19bf9cda5c577578632b0bbab7b5912", "filename": "src/libstd/deque.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e5cfd9f339c78384ef3fbcb4d230fa0bb363d54/src%2Flibstd%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e5cfd9f339c78384ef3fbcb4d230fa0bb363d54/src%2Flibstd%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdeque.rs?ref=0e5cfd9f339c78384ef3fbcb4d230fa0bb363d54", "patch": "@@ -33,8 +33,8 @@ fn create<T: copy>() -> t<T> {\n         let nalloc = uint::next_power_of_two(nelts + 1u);\n         while i < nalloc {\n             if i < nelts {\n-                rv += [mut elts[(lo + i) % nelts]];\n-            } else { rv += [mut none]; }\n+                vec::push(rv, elts[(lo + i) % nelts]);\n+            } else { vec::push(rv, none); }\n             i += 1u;\n         }\n "}, {"sha": "a8cd3b65ef838c02ed325066881a2f417f0f5b78", "filename": "src/libstd/rope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e5cfd9f339c78384ef3fbcb4d230fa0bb363d54/src%2Flibstd%2Frope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e5cfd9f339c78384ef3fbcb4d230fa0bb363d54/src%2Flibstd%2Frope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frope.rs?ref=0e5cfd9f339c78384ef3fbcb4d230fa0bb363d54", "patch": "@@ -864,7 +864,7 @@ mod node {\n         loop {\n             alt (leaf_iterator::next(it)) {\n               option::none   { break; }\n-              option::some(x) { forest += [mut @leaf(x)]; }\n+              option::some(x) { vec::push(forest, @leaf(x)); }\n             }\n         }\n         //2. Rebuild tree from forest"}, {"sha": "e56bb25e55dd6d308eb8daaaaaec41a489d27a23", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0e5cfd9f339c78384ef3fbcb4d230fa0bb363d54/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e5cfd9f339c78384ef3fbcb4d230fa0bb363d54/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=0e5cfd9f339c78384ef3fbcb4d230fa0bb363d54", "patch": "@@ -480,12 +480,17 @@ fn id_visitor(vfn: fn@(node_id)) -> visit::vt<()> {\n             vfn(id);\n         },\n \n-        visit_fn: fn@(fk: visit::fn_kind, d: fn_decl,\n-                      _b: blk, _sp: span, id: node_id) {\n+        visit_fn: fn@(fk: visit::fn_kind, d: ast::fn_decl,\n+                      _b: ast::blk, _sp: span, id: ast::node_id) {\n             vfn(id);\n \n             alt fk {\n-              visit::fk_ctor(_, tps, self_id, parent_id) |\n+              visit::fk_ctor(nm, tps, self_id, parent_id) {\n+                vec::iter(tps) {|tp| vfn(tp.id)}\n+                vfn(id);\n+                vfn(self_id);\n+                vfn(parent_id.node);\n+              }\n               visit::fk_dtor(tps, self_id, parent_id) {\n                 vec::iter(tps) {|tp| vfn(tp.id)}\n                 vfn(id);\n@@ -500,7 +505,11 @@ fn id_visitor(vfn: fn@(node_id)) -> visit::vt<()> {\n                 vfn(m.self_id);\n                 vec::iter(tps) {|tp| vfn(tp.id)}\n               }\n-              visit::fk_anon(*) | visit::fk_fn_block(*) {\n+              visit::fk_anon(_, capture_clause)\n+              | visit::fk_fn_block(capture_clause) {\n+                for vec::each(*capture_clause) {|clause|\n+                    vfn(clause.id);\n+                }\n               }\n             }\n "}, {"sha": "b8362eb8734d5fe9338848e0ad83a2a871c77866", "filename": "src/libsyntax/parse/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e5cfd9f339c78384ef3fbcb4d230fa0bb363d54/src%2Flibsyntax%2Fparse%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e5cfd9f339c78384ef3fbcb4d230fa0bb363d54/src%2Flibsyntax%2Fparse%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcommon.rs?ref=0e5cfd9f339c78384ef3fbcb4d230fa0bb363d54", "patch": "@@ -159,7 +159,7 @@ impl parser_common for parser {\n                        else { self.expect(t); } }\n               _ { }\n             }\n-            v += [f(self)];\n+            vec::push(v, f(self));\n         }\n \n         ret v;\n@@ -202,7 +202,7 @@ impl parser_common for parser {\n               _ { }\n             }\n             if sep.trailing_sep_allowed && self.token == ket { break; }\n-            v += [f(self)];\n+            vec::push(v, f(self));\n         }\n         ret v;\n     }"}, {"sha": "2fae0850187284fb2c35151c9431cc8f97ac25cc", "filename": "src/rustc/middle/astencode.rs", "status": "modified", "additions": 17, "deletions": 182, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/0e5cfd9f339c78384ef3fbcb4d230fa0bb363d54/src%2Frustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e5cfd9f339c78384ef3fbcb4d230fa0bb363d54/src%2Frustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fastencode.rs?ref=0e5cfd9f339c78384ef3fbcb4d230fa0bb363d54", "patch": "@@ -66,8 +66,8 @@ type decode_ctxt = @{\n \n type extended_decode_ctxt = @{\n     dcx: decode_ctxt,\n-    from_id_range: id_range,\n-    to_id_range: id_range\n+    from_id_range: ast_util::id_range,\n+    to_id_range: ast_util::id_range\n };\n \n iface tr {\n@@ -86,9 +86,9 @@ fn encode_inlined_item(ecx: @e::encode_ctxt,\n            ast_map::path_to_str(path), *ii.ident(),\n            ebml_w.writer.tell()];\n \n-    let id_range = compute_id_range(ii);\n+    let id_range = ast_util::compute_id_range_for_inlined_item(ii);\n     ebml_w.wr_tag(c::tag_ast as uint) {||\n-        encode_id_range(ebml_w, id_range);\n+        ast_util::serialize_id_range(ebml_w, id_range);\n         encode_ast(ebml_w, simplify_ast(ii));\n         encode_side_tables_for_ii(ecx, maps, ebml_w, ii);\n     }\n@@ -108,7 +108,8 @@ fn decode_inlined_item(cdata: cstore::crate_metadata,\n       none { none }\n       some(ast_doc) {\n         #debug[\"> Decoding inlined fn: %s::?\", ast_map::path_to_str(path)];\n-        let from_id_range = decode_id_range(ast_doc);\n+        let ast_dsr = ebml::ebml_deserializer(ast_doc);\n+        let from_id_range = ast_util::deserialize_id_range(ast_dsr);\n         let to_id_range = reserve_id_range(dcx.tcx.sess, from_id_range);\n         let xcx = @{dcx: dcx,\n                     from_id_range: from_id_range,\n@@ -136,178 +137,10 @@ fn decode_inlined_item(cdata: cstore::crate_metadata,\n // ______________________________________________________________________\n // Enumerating the IDs which appear in an AST\n \n-type id_range = {min: ast::node_id, max: ast::node_id};\n-\n-fn empty(range: id_range) -> bool {\n-    range.min >= range.max\n-}\n-\n-fn visit_ids(item: ast::inlined_item, vfn: fn@(ast::node_id)) {\n-    let visitor = visit::mk_simple_visitor(@{\n-        visit_mod: fn@(_m: ast::_mod, _sp: span, id: ast::node_id) {\n-            vfn(id)\n-        },\n-\n-        visit_view_item: fn@(vi: @ast::view_item) {\n-            alt vi.node {\n-              ast::view_item_use(_, _, id) { vfn(id) }\n-              ast::view_item_import(vps) | ast::view_item_export(vps) {\n-                vec::iter(vps) {|vp|\n-                    alt vp.node {\n-                      ast::view_path_simple(_, _, id) { vfn(id) }\n-                      ast::view_path_glob(_, id) { vfn(id) }\n-                      ast::view_path_list(_, _, id) { vfn(id) }\n-                    }\n-                }\n-              }\n-            }\n-        },\n-\n-        visit_native_item: fn@(ni: @ast::native_item) {\n-            vfn(ni.id)\n-        },\n-\n-        visit_item: fn@(i: @ast::item) {\n-            vfn(i.id);\n-            alt i.node {\n-              ast::item_res(_, _, _, d_id, c_id, _) { vfn(d_id); vfn(c_id); }\n-              ast::item_enum(vs, _, _) { for vs.each {|v| vfn(v.node.id); } }\n-              _ {}\n-            }\n-        },\n-\n-        visit_local: fn@(l: @ast::local) {\n-            vfn(l.node.id);\n-        },\n-\n-        visit_block: fn@(b: ast::blk) {\n-            vfn(b.node.id);\n-        },\n-\n-        visit_stmt: fn@(s: @ast::stmt) {\n-            vfn(ast_util::stmt_id(*s));\n-        },\n-\n-        visit_arm: fn@(_a: ast::arm) { },\n-\n-        visit_pat: fn@(p: @ast::pat) {\n-            vfn(p.id)\n-        },\n-\n-        visit_decl: fn@(_d: @ast::decl) {\n-        },\n-\n-        visit_expr: fn@(e: @ast::expr) {\n-            vfn(e.id);\n-            alt e.node {\n-              ast::expr_unary(*) | ast::expr_binary(*) | ast::expr_index(*) {\n-                vfn(ast_util::op_expr_callee_id(e));\n-              }\n-              _ { /* fallthrough */ }\n-            }\n-        },\n-\n-        visit_ty: fn@(t: @ast::ty) {\n-            alt t.node {\n-              ast::ty_path(_, id) {\n-                vfn(id)\n-              }\n-              _ { /* fall through */ }\n-            }\n-        },\n-\n-        visit_ty_params: fn@(ps: [ast::ty_param]) {\n-            vec::iter(ps) {|p| vfn(p.id) }\n-        },\n-\n-        visit_constr: fn@(_p: @ast::path, _sp: span, id: ast::node_id) {\n-            vfn(id);\n-        },\n-\n-        visit_fn: fn@(fk: visit::fn_kind, d: ast::fn_decl,\n-                      _b: ast::blk, _sp: span, id: ast::node_id) {\n-            vfn(id);\n-\n-            alt fk {\n-              visit::fk_ctor(nm, tps, self_id, parent_id) {\n-                vec::iter(tps) {|tp| vfn(tp.id)}\n-                vfn(id);\n-                vfn(self_id);\n-                vfn(parent_id.node);\n-              }\n-              visit::fk_dtor(tps, self_id, parent_id) {\n-                vec::iter(tps) {|tp| vfn(tp.id)}\n-                vfn(id);\n-                vfn(self_id);\n-                vfn(parent_id.node);\n-              }\n-              visit::fk_item_fn(_, tps) |\n-              visit::fk_res(_, tps, _) {\n-                vec::iter(tps) {|tp| vfn(tp.id)}\n-              }\n-              visit::fk_method(_, tps, m) {\n-                vfn(m.self_id);\n-                vec::iter(tps) {|tp| vfn(tp.id)}\n-              }\n-              visit::fk_anon(_, capture_clause)\n-              | visit::fk_fn_block(capture_clause) {\n-                for vec::each(*capture_clause) {|clause|\n-                    vfn(clause.id);\n-                }\n-              }\n-            }\n-\n-            vec::iter(d.inputs) {|arg|\n-                vfn(arg.id)\n-            }\n-        },\n-\n-        visit_class_item: fn@(c: @ast::class_member) {\n-            alt c.node {\n-              ast::instance_var(_, _, _, id,_) {\n-                vfn(id)\n-              }\n-              ast::class_method(_) {\n-              }\n-            }\n-        }\n-    });\n-\n-    item.accept((), visitor)\n-}\n-\n-fn compute_id_range(item: ast::inlined_item) -> id_range {\n-    let min = @mut int::max_value;\n-    let max = @mut int::min_value;\n-    visit_ids(item) {|id|\n-        *min = int::min(*min, id);\n-        *max = int::max(*max, id + 1);\n-    }\n-    ret {min:*min, max:*max};\n-}\n-\n-fn encode_id_range(ebml_w: ebml::writer, id_range: id_range) {\n-    ebml_w.wr_tag(c::tag_id_range as uint) {||\n-        ebml_w.emit_tup(2u) {||\n-            ebml_w.emit_tup_elt(0u) {|| ebml_w.emit_int(id_range.min) }\n-            ebml_w.emit_tup_elt(1u) {|| ebml_w.emit_int(id_range.max) }\n-        }\n-    }\n-}\n-\n-fn decode_id_range(par_doc: ebml::doc) -> id_range {\n-    let range_doc = par_doc[c::tag_id_range];\n-    let dsr = ebml::ebml_deserializer(range_doc);\n-    dsr.read_tup(2u) {||\n-        {min: dsr.read_tup_elt(0u) {|| dsr.read_int() },\n-         max: dsr.read_tup_elt(1u) {|| dsr.read_int() }}\n-    }\n-}\n-\n fn reserve_id_range(sess: session,\n-                    from_id_range: id_range) -> id_range {\n+                    from_id_range: ast_util::id_range) -> ast_util::id_range {\n     // Handle the case of an empty range:\n-    if empty(from_id_range) { ret from_id_range; }\n+    if ast_util::empty(from_id_range) { ret from_id_range; }\n     let cnt = from_id_range.max - from_id_range.min;\n     let to_id_min = sess.parse_sess.next_id;\n     let to_id_max = sess.parse_sess.next_id + cnt;\n@@ -318,7 +151,7 @@ fn reserve_id_range(sess: session,\n impl translation_routines for extended_decode_ctxt {\n     fn tr_id(id: ast::node_id) -> ast::node_id {\n         // from_id_range should be non-empty\n-        assert !empty(self.from_id_range);\n+        assert !ast_util::empty(self.from_id_range);\n         (id - self.from_id_range.min + self.to_id_range.min)\n     }\n     fn tr_def_id(did: ast::def_id) -> ast::def_id {\n@@ -749,12 +582,14 @@ fn encode_side_tables_for_ii(ecx: @e::encode_ctxt,\n                              ebml_w: ebml::writer,\n                              ii: ast::inlined_item) {\n     ebml_w.wr_tag(c::tag_table as uint) {||\n-        visit_ids(ii, fn@(id: ast::node_id, copy ebml_w) {\n-            // Note: this will cause a copy of ebml_w, which is bad as\n-            // it has mut fields.  But I believe it's harmless since\n-            // we generate balanced EBML.\n-            encode_side_tables_for_id(ecx, maps, ebml_w, id)\n-        });\n+        ast_util::visit_ids_for_inlined_item(\n+            ii,\n+            fn@(id: ast::node_id, copy ebml_w) {\n+                // Note: this will cause a copy of ebml_w, which is bad as\n+                // it has mut fields.  But I believe it's harmless since\n+                // we generate balanced EBML.\n+                encode_side_tables_for_id(ecx, maps, ebml_w, id)\n+            });\n     }\n }\n "}, {"sha": "d308181d8c7101fd0bc2153159ed2c3aee79da26", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0e5cfd9f339c78384ef3fbcb4d230fa0bb363d54/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e5cfd9f339c78384ef3fbcb4d230fa0bb363d54/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=0e5cfd9f339c78384ef3fbcb4d230fa0bb363d54", "patch": "@@ -1444,7 +1444,7 @@ fn copy_val_no_check(bcx: block, action: copy_action, dst: ValueRef,\n // doesn't need to be dropped. (Issue #839)\n fn move_val(cx: block, action: copy_action, dst: ValueRef,\n             src: lval_result, t: ty::t) -> block {\n-    assert !cx.terminated;\n+\n     let _icx = cx.insn_ctxt(\"move_val\");\n     let mut src_val = src.val;\n     let tcx = cx.tcx();\n@@ -1777,7 +1777,10 @@ fn trans_assign_op(bcx: block, ex: @ast::expr, op: ast::binop,\n     // A user-defined operator method\n     alt bcx.ccx().maps.method_map.find(ex.id) {\n       some(origin) {\n+        let bcx = lhs_res.bcx;\n         let callee_id = ast_util::op_expr_callee_id(ex);\n+        #debug[\"user-defined method callee_id: %s\",\n+               ast_map::node_id_to_str(bcx.tcx().items, callee_id)];\n         let fty = node_id_type(bcx, callee_id);\n \n         let dty = expr_ty(bcx, dst);"}, {"sha": "164a089dc889d14606024e3f3c0f220baf1a29d9", "filename": "src/rustc/middle/trans/tvec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e5cfd9f339c78384ef3fbcb4d230fa0bb363d54/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e5cfd9f339c78384ef3fbcb4d230fa0bb363d54/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=0e5cfd9f339c78384ef3fbcb4d230fa0bb363d54", "patch": "@@ -190,7 +190,7 @@ fn trans_evec(bcx: block, args: [@ast::expr],\n         let lleltptr = InBoundsGEP(bcx, dataptr, [C_uint(ccx, i)]);\n         bcx = base::trans_expr_save_in(bcx, e, lleltptr);\n         add_clean_temp_mem(bcx, lleltptr, unit_ty);\n-        temp_cleanups += [lleltptr];\n+        vec::push(temp_cleanups, lleltptr);\n         i += 1u;\n     }\n "}, {"sha": "d20cbcfe4d47e70c0cfe9865667bc14867c9b032", "filename": "src/rustc/middle/tstate/annotate.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0e5cfd9f339c78384ef3fbcb4d230fa0bb363d54/src%2Frustc%2Fmiddle%2Ftstate%2Fannotate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e5cfd9f339c78384ef3fbcb4d230fa0bb363d54/src%2Frustc%2Fmiddle%2Ftstate%2Fannotate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fannotate.rs?ref=0e5cfd9f339c78384ef3fbcb4d230fa0bb363d54", "patch": "@@ -7,16 +7,18 @@ import aux::{num_constraints, get_fn_info, crate_ctxt, add_node};\n import ann::empty_ann;\n import pat_util::pat_binding_ids;\n \n-fn collect_ids_expr(e: @expr, rs: @mut [node_id]) { *rs += [e.id]; }\n+fn collect_ids_expr(e: @expr, rs: @mut [node_id]) { vec::push(*rs, e.id); }\n \n-fn collect_ids_block(b: blk, rs: @mut [node_id]) { *rs += [b.node.id]; }\n+fn collect_ids_block(b: blk, rs: @mut [node_id]) {\n+    vec::push(*rs, b.node.id);\n+}\n \n fn collect_ids_stmt(s: @stmt, rs: @mut [node_id]) {\n     alt s.node {\n       stmt_decl(_, id) | stmt_expr(_, id) | stmt_semi(_, id) {\n         #debug[\"node_id %s\", int::str(id)];\n         #debug[\"%s\", stmt_to_str(*s)];\n-        *rs += [id];\n+        vec::push(*rs, id);\n       }\n     }\n }"}, {"sha": "16834c379190f90055e17029ab81df4ec7c6ea85", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0e5cfd9f339c78384ef3fbcb4d230fa0bb363d54/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e5cfd9f339c78384ef3fbcb4d230fa0bb363d54/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=0e5cfd9f339c78384ef3fbcb4d230fa0bb363d54", "patch": "@@ -921,22 +921,6 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         let lhs_t = fcx.expr_ty(lhs);\n         let lhs_t = structurally_resolved_type(fcx, lhs.span, lhs_t);\n         ret alt (op, ty::get(lhs_t).struct) {\n-          (ast::add, ty::ty_vec(lhs_mt)) {\n-            // For adding vectors with type L=[ML TL] and R=[MR TR], the the\n-            // result [ML T] where TL <: T and TR <: T.  In other words, the\n-            // result type is (generally) the LUB of (TL, TR) and takes the\n-            // mutability from the LHS.\n-            let t_var = fcx.infcx.next_ty_var();\n-            let const_vec_t = ty::mk_vec(tcx, {ty: t_var,\n-                                               mutbl: ast::m_const});\n-            demand::suptype(fcx, lhs.span, const_vec_t, lhs_t);\n-            let rhs_bot = check_expr_with(fcx, rhs, const_vec_t);\n-            let result_vec_t = ty::mk_vec(tcx, {ty: t_var,\n-                                                mutbl: lhs_mt.mutbl});\n-            fcx.write_ty(expr.id, result_vec_t);\n-            lhs_bot | rhs_bot\n-          }\n-\n           (_, _) if ty::type_is_integral(lhs_t) &&\n           ast_util::is_shift_binop(op) {\n             // Shift is a special case: rhs can be any integral type"}, {"sha": "c1793477b2e388651102768893943271f118b863", "filename": "src/rustc/middle/typeck/check/method.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0e5cfd9f339c78384ef3fbcb4d230fa0bb363d54/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e5cfd9f339c78384ef3fbcb4d230fa0bb363d54/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=0e5cfd9f339c78384ef3fbcb4d230fa0bb363d54", "patch": "@@ -154,7 +154,6 @@ class lookup {\n     }\n \n     fn add_candidates_from_param(n: uint, did: ast::def_id) {\n-\n         let tcx = self.tcx();\n         let mut iface_bnd_idx = 0u; // count only iface bounds\n         let bounds = tcx.ty_param_bounds.get(did.node);\n@@ -202,6 +201,8 @@ class lookup {\n \n     fn add_candidates_from_iface(did: ast::def_id, iface_substs: ty::substs) {\n \n+        #debug[\"method_from_iface\"];\n+\n         let ms = *ty::iface_methods(self.tcx(), did);\n         for ms.eachi {|i, m|\n             if m.ident != self.m_name { cont; }\n@@ -235,6 +236,8 @@ class lookup {\n \n     fn add_candidates_from_class(did: ast::def_id, class_substs: ty::substs) {\n \n+        #debug[\"method_from_class\"];\n+\n         let ms = *ty::iface_methods(self.tcx(), did);\n \n         for ms.each {|m|\n@@ -285,6 +288,8 @@ class lookup {\n         let impls_vecs = self.fcx.ccx.impl_map.get(self.expr.id);\n         let mut added_any = false;\n \n+        #debug[\"method_from_scope\"];\n+\n         for list::each(impls_vecs) {|impls|\n             for vec::each(*impls) {|im|\n                 // Check whether this impl has a method with the right name.\n@@ -297,9 +302,11 @@ class lookup {\n \n                     // if we can assign the caller to the callee, that's a\n                     // potential match.  Collect those in the vector.\n-                    alt self.fcx.can_mk_assignty(\n+                    let can_assign = self.fcx.can_mk_assignty(\n                         self.self_expr, self.borrow_scope,\n-                        self.self_ty, impl_ty) {\n+                        self.self_ty, impl_ty);\n+                    #debug[\"can_assign = %?\", can_assign];\n+                    alt can_assign {\n                       result::err(_) { /* keep looking */ }\n                       result::ok(_) {\n                         let fty = self.ty_from_did(m.did);"}, {"sha": "9a29671e18436d51d3ac2c80c5f3dda22945c009", "filename": "src/test/bench/core-vec-append.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0e5cfd9f339c78384ef3fbcb4d230fa0bb363d54/src%2Ftest%2Fbench%2Fcore-vec-append.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e5cfd9f339c78384ef3fbcb4d230fa0bb363d54/src%2Ftest%2Fbench%2Fcore-vec-append.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-vec-append.rs?ref=0e5cfd9f339c78384ef3fbcb4d230fa0bb363d54", "patch": "@@ -8,6 +8,8 @@ fn collect_raw(num: uint) -> [uint] {\n     let mut result = [];\n     for uint::range(0u, num) { |i|\n         result += [i];\n+        //vec::push(result, i);\n+        //result = vec::append(result, [i]);\n     }\n     ret result;\n }\n@@ -43,18 +45,18 @@ fn main(args: [str]) {\n \n     let raw = mid - start;\n     let dvec = end - mid;\n-\n+    \n     let maxf = max as float;\n     let rawf = raw as float;\n     let dvecf = dvec as float;\n-\n+    \n     io::stdout().write_str(#fmt(\"Raw     : %? seconds\\n\", raw));\n     io::stdout().write_str(#fmt(\"        : %f op/sec\\n\", maxf/rawf));\n     io::stdout().write_str(#fmt(\"\\n\"));\n     io::stdout().write_str(#fmt(\"Dvec    : %? seconds\\n\", dvec));\n     io::stdout().write_str(#fmt(\"        : %f op/sec\\n\", maxf/dvecf));\n     io::stdout().write_str(#fmt(\"\\n\"));\n-\n+    \n     if dvec < raw {\n         io::stdout().write_str(#fmt(\"Dvec is %f%% faster than raw\\n\",\n                                     (rawf - dvecf) / rawf * 100.0));"}, {"sha": "736b61cb935f967a6dcca93399835f12fcb09329", "filename": "src/test/run-fail/zip-different-lengths.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e5cfd9f339c78384ef3fbcb4d230fa0bb363d54/src%2Ftest%2Frun-fail%2Fzip-different-lengths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e5cfd9f339c78384ef3fbcb4d230fa0bb363d54/src%2Ftest%2Frun-fail%2Fzip-different-lengths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fzip-different-lengths.rs?ref=0e5cfd9f339c78384ef3fbcb4d230fa0bb363d54", "patch": "@@ -10,15 +10,15 @@ fn enum_chars(start: u8, end: u8) -> [char] {\n     assert start < end;\n     let mut i = start;\n     let mut r = [];\n-    while i <= end { r += [i as char]; i += 1u as u8; }\n+    while i <= end { vec::push(r, i as char); i += 1u as u8; }\n     ret r;\n }\n \n fn enum_uints(start: uint, end: uint) -> [uint] {\n     assert start < end;\n     let mut i = start;\n     let mut r = [];\n-    while i <= end { r += [i]; i += 1u; }\n+    while i <= end { vec::push(r, i); i += 1u; }\n     ret r;\n }\n "}, {"sha": "c1473b1a0d4e69d8445aa64ec9c537143ccdab90", "filename": "src/test/run-pass/import-glob-crate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e5cfd9f339c78384ef3fbcb4d230fa0bb363d54/src%2Ftest%2Frun-pass%2Fimport-glob-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e5cfd9f339c78384ef3fbcb4d230fa0bb363d54/src%2Ftest%2Frun-pass%2Fimport-glob-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimport-glob-crate.rs?ref=0e5cfd9f339c78384ef3fbcb4d230fa0bb363d54", "patch": "@@ -4,6 +4,6 @@ import vec::*;\n \n fn main() {\n     let mut v = from_elem(0u, 0);\n-    v += [4, 2];\n+    v = vec::append(v, [4, 2]);\n     assert (reversed(v) == [2, 4]);\n }"}, {"sha": "15b9239c44bcc4a8e90e72818872a9474bc1bdba", "filename": "src/test/run-pass/vec-push.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0e5cfd9f339c78384ef3fbcb4d230fa0bb363d54/src%2Ftest%2Frun-pass%2Fvec-push.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e5cfd9f339c78384ef3fbcb4d230fa0bb363d54/src%2Ftest%2Frun-pass%2Fvec-push.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-push.rs?ref=0e5cfd9f339c78384ef3fbcb4d230fa0bb363d54", "patch": "@@ -1,5 +1 @@\n-\n-\n-fn push<T: copy>(&v: [const T], t: T) { v += [t]; }\n-\n-fn main() { let mut v = [1, 2, 3]; push(v, 1); }\n+fn main() { let mut v = [1, 2, 3]; vec::push(v, 1); }"}, {"sha": "9ffb564ace6531277541bdca8849a255679c263a", "filename": "src/test/run-pass/zip-same-length.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e5cfd9f339c78384ef3fbcb4d230fa0bb363d54/src%2Ftest%2Frun-pass%2Fzip-same-length.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e5cfd9f339c78384ef3fbcb4d230fa0bb363d54/src%2Ftest%2Frun-pass%2Fzip-same-length.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fzip-same-length.rs?ref=0e5cfd9f339c78384ef3fbcb4d230fa0bb363d54", "patch": "@@ -10,15 +10,15 @@ fn enum_chars(start: u8, end: u8) -> [char] {\n     assert start < end;\n     let mut i = start;\n     let mut r = [];\n-    while i <= end { r += [i as char]; i += 1u as u8; }\n+    while i <= end { vec::push(r, i as char); i += 1u as u8; }\n     ret r;\n }\n \n fn enum_uints(start: uint, end: uint) -> [uint] {\n     assert start < end;\n     let mut i = start;\n     let mut r = [];\n-    while i <= end { r += [i]; i += 1u; }\n+    while i <= end { vec::push(r, i); i += 1u; }\n     ret r;\n }\n "}]}