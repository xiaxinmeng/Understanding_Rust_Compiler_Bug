{"sha": "90fbe155f2104c9cbbec5ff1e79ee513e112fa9c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkwZmJlMTU1ZjIxMDRjOWNiYmVjNWZmMWU3OWVlNTEzZTExMmZhOWM=", "commit": {"author": {"name": "Martin Hafskjold Thoresen", "email": "martinhath@gmail.com", "date": "2017-01-17T17:58:49Z"}, "committer": {"name": "Martin Hafskjold Thoresen", "email": "martinhath@gmail.com", "date": "2017-01-17T18:25:48Z"}, "message": "Fix BinaryHeap place by only constructing vec::PlaceBack once", "tree": {"sha": "0166e1f753a5d497c6d4d75d1681c318417e210f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0166e1f753a5d497c6d4d75d1681c318417e210f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/90fbe155f2104c9cbbec5ff1e79ee513e112fa9c", "comment_count": 0, "verification": {"verified": false, "reason": "no_user", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQEzBAABCAAdFiEEidYQpaCqAbnv2ZiVbjkx6jLvHjAFAlh+Ya0ACgkQbjkx6jLv\nHjBitAf/UEykzxyIR0ST4bsYaep5rjtwHP0Eja8q1jtt/arEOryNp7W6BvPjX2aH\ntJe+MRclflw7XCY/12QUjRj2JkWqN0fetGqKm/3w/z4raMuQq5lvow0MGGhJUjvT\nHmi9BP4KPBqNr9WyQ4T3Rf7eNUt2i2Jq827WKQaxB0Pyf4OEeQzzOGTk0u2TbG4l\npS3L29kDLcwYqAHaSWvfXamUJupSaAxHxL6q5I8CvArRJfvK4fvPC6bzpnFeslFD\nY90wXQUe1PB7a74Jwp804TYFR7jVUNalklsKCRN+wDvarPHEYztv2OhxkK3aG41j\n8klZFOS7qAfHWQNtCIYZDULhssPwuA==\n=JBcp\n-----END PGP SIGNATURE-----", "payload": "tree 0166e1f753a5d497c6d4d75d1681c318417e210f\nparent fb3483c827e1ef8ad73b200fb73f1dd03994e510\nauthor Martin Hafskjold Thoresen <martinhath@gmail.com> 1484675929 +0100\ncommitter Martin Hafskjold Thoresen <martinhath@gmail.com> 1484677548 +0100\n\nFix BinaryHeap place by only constructing vec::PlaceBack once\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/90fbe155f2104c9cbbec5ff1e79ee513e112fa9c", "html_url": "https://github.com/rust-lang/rust/commit/90fbe155f2104c9cbbec5ff1e79ee513e112fa9c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/90fbe155f2104c9cbbec5ff1e79ee513e112fa9c/comments", "author": null, "committer": null, "parents": [{"sha": "fb3483c827e1ef8ad73b200fb73f1dd03994e510", "url": "https://api.github.com/repos/rust-lang/rust/commits/fb3483c827e1ef8ad73b200fb73f1dd03994e510", "html_url": "https://github.com/rust-lang/rust/commit/fb3483c827e1ef8ad73b200fb73f1dd03994e510"}], "stats": {"total": 79, "additions": 29, "deletions": 50}, "files": [{"sha": "b7c2a708baf492f91dfdc0976ac8d7dced7dbbbe", "filename": "src/libcollections/binary_heap.rs", "status": "modified", "additions": 24, "deletions": 45, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/90fbe155f2104c9cbbec5ff1e79ee513e112fa9c/src%2Flibcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90fbe155f2104c9cbbec5ff1e79ee513e112fa9c/src%2Flibcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbinary_heap.rs?ref=90fbe155f2104c9cbbec5ff1e79ee513e112fa9c", "patch": "@@ -673,7 +673,7 @@ impl<T: Ord> BinaryHeap<T> {\n     // the hole is filled back at the end of its scope, even on panic.\n     // Using a hole reduces the constant factor compared to using swaps,\n     // which involves twice as many moves.\n-    fn sift_up(&mut self, start: usize, pos: usize) {\n+    fn sift_up(&mut self, start: usize, pos: usize) -> usize {\n         unsafe {\n             // Take out the value at `pos` and create a hole.\n             let mut hole = Hole::new(&mut self.data, pos);\n@@ -685,21 +685,6 @@ impl<T: Ord> BinaryHeap<T> {\n                 }\n                 hole.move_to(parent);\n             }\n-        }\n-    }\n-\n-    fn sift_up_ind(&mut self, start: usize, pos: usize) -> usize {\n-        unsafe {\n-            // Take out the value at `pos` and create a hole.\n-            let mut hole = Hole::new(&mut self.data, pos);\n-\n-            while hole.pos() > start {\n-                let parent = (hole.pos() - 1) / 2;\n-                if hole.element() <= hole.get(parent) {\n-                    return hole.pos();\n-                }\n-                hole.move_to(parent);\n-            }\n             hole.pos()\n         }\n     }\n@@ -905,19 +890,6 @@ impl<T: Ord> BinaryHeap<T> {\n     }\n }\n \n-impl<T> BinaryHeap<T>\n-where T: Clone + Ord {\n-    /// kek\n-    #[unstable(feature = \"collection_placement\",\n-               reason = \"placement protocol is subject to change\",\n-               issue = \"30172\")]\n-    pub fn place(&mut self) -> PlaceIn<T> {\n-        PlaceIn {\n-            heap: self,\n-        }\n-    }\n-}\n-\n /// Hole represents a hole in a slice i.e. an index without valid value\n /// (because it was moved from or duplicated).\n /// In drop, `Hole` will restore the slice by filling the hole\n@@ -1222,45 +1194,52 @@ impl<'a, T: 'a + Ord + Copy> Extend<&'a T> for BinaryHeap<T> {\n #[unstable(feature = \"collection_placement\",\n            reason = \"placement protocol is subject to change\",\n            issue = \"30172\")]\n-pub struct PlaceIn<'a, T: 'a>\n+pub struct BinaryHeapPlace<'a, T: 'a>\n where T: Clone + Ord {\n-    heap: &'a mut BinaryHeap<T>,\n+    heap: *mut BinaryHeap<T>,\n+    place: vec::PlaceBack<'a, T>,\n }\n \n #[unstable(feature = \"collection_placement\",\n            reason = \"placement protocol is subject to change\",\n            issue = \"30172\")]\n-impl<'a, T> Place<T> for PlaceIn<'a, T>\n+impl<'a, T: 'a> Placer<T> for &'a mut BinaryHeap<T>\n where T: Clone + Ord {\n-    fn pointer(&mut self) -> *mut T {\n-        self.heap.data.place_back().pointer()\n+    type Place = BinaryHeapPlace<'a, T>;\n+\n+    fn make_place(self) -> Self::Place {\n+        let ptr = self as *mut BinaryHeap<T>;\n+        let place = Placer::make_place(self.data.place_back());\n+        BinaryHeapPlace {\n+            heap: ptr,\n+            place: place,\n+        }\n     }\n }\n \n #[unstable(feature = \"collection_placement\",\n            reason = \"placement protocol is subject to change\",\n            issue = \"30172\")]\n-impl<'a, T> Placer<T> for PlaceIn<'a, T>\n+impl<'a, T> Place<T> for BinaryHeapPlace<'a, T>\n where T: Clone + Ord {\n-    type Place = PlaceIn<'a, T>;\n-\n-    fn make_place(self) -> Self {\n-        let _ = self.heap.data.place_back().make_place();\n-        self\n+    fn pointer(&mut self) -> *mut T {\n+        self.place.pointer()\n     }\n }\n \n #[unstable(feature = \"collection_placement\",\n            reason = \"placement protocol is subject to change\",\n            issue = \"30172\")]\n-impl<'a, T> InPlace<T> for PlaceIn<'a, T>\n+impl<'a, T> InPlace<T> for BinaryHeapPlace<'a, T>\n where T: Clone + Ord {\n     type Owner = &'a T;\n \n     unsafe fn finalize(self) -> &'a T {\n-        let len = self.heap.len();\n-        let _ = self.heap.data.place_back().finalize();\n-        let i = self.heap.sift_up_ind(0, len);\n-        &mut self.heap.data[i]\n+        self.place.finalize();\n+\n+        let heap: &mut BinaryHeap<T> = &mut *self.heap;\n+        let len = heap.len();\n+        let i = heap.sift_up(0, len - 1);\n+        heap.data.get_unchecked(i)\n     }\n }"}, {"sha": "d284937a9e676a0a56ce4824c3b8abb2dd62f8b1", "filename": "src/libcollectionstest/binary_heap.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/90fbe155f2104c9cbbec5ff1e79ee513e112fa9c/src%2Flibcollectionstest%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90fbe155f2104c9cbbec5ff1e79ee513e112fa9c/src%2Flibcollectionstest%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fbinary_heap.rs?ref=90fbe155f2104c9cbbec5ff1e79ee513e112fa9c", "patch": "@@ -314,20 +314,20 @@ fn test_extend_specialization() {\n #[test]\n fn test_placement() {\n     let mut a = BinaryHeap::new();\n-    a.place() <- 2;\n-    a.place() <- 4;\n-    a.place() <- 3;\n+    &mut a <- 2;\n+    &mut a <- 4;\n+    &mut a <- 3;\n     assert_eq!(a.peek(), Some(&4));\n     assert_eq!(a.len(), 3);\n-    a.place() <- 1;\n+    &mut a <- 1;\n     assert_eq!(a.into_sorted_vec(), vec![1, 2, 3, 4]);\n }\n \n #[test]\n fn test_placement_panic() {\n     let mut heap = BinaryHeap::from(vec![1, 2, 3]);\n     fn mkpanic() -> usize { panic!() }\n-    let _ = panic::catch_unwind(panic::AssertUnwindSafe(|| { heap.place() <- mkpanic(); }));\n+    let _ = panic::catch_unwind(panic::AssertUnwindSafe(|| { &mut heap <- mkpanic(); }));\n     assert_eq!(heap.len(), 3);\n }\n "}]}