{"sha": "99c2f72814f3e3ab276b133cf18430a74e839f75", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk5YzJmNzI4MTRmM2UzYWIyNzZiMTMzY2YxODQzMGE3NGU4MzlmNzU=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2016-09-14T15:15:37Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-09-14T15:15:37Z"}, "message": "Rollup merge of #36363 - GuillaumeGomez:add_urls, r=steveklabnik\n\nAdd urls\n\nr? @steveklabnik", "tree": {"sha": "f8c39f8cc216f69f66211577eed0befb0488bd52", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f8c39f8cc216f69f66211577eed0befb0488bd52"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/99c2f72814f3e3ab276b133cf18430a74e839f75", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/99c2f72814f3e3ab276b133cf18430a74e839f75", "html_url": "https://github.com/rust-lang/rust/commit/99c2f72814f3e3ab276b133cf18430a74e839f75", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/99c2f72814f3e3ab276b133cf18430a74e839f75/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d939cbeefecf9f78bd53196ec9e3667ca6016fcd", "url": "https://api.github.com/repos/rust-lang/rust/commits/d939cbeefecf9f78bd53196ec9e3667ca6016fcd", "html_url": "https://github.com/rust-lang/rust/commit/d939cbeefecf9f78bd53196ec9e3667ca6016fcd"}, {"sha": "e3153cfd8896d97be89e3b1b26e44a3ebf8a6374", "url": "https://api.github.com/repos/rust-lang/rust/commits/e3153cfd8896d97be89e3b1b26e44a3ebf8a6374", "html_url": "https://github.com/rust-lang/rust/commit/e3153cfd8896d97be89e3b1b26e44a3ebf8a6374"}], "stats": {"total": 249, "additions": 160, "deletions": 89}, "files": [{"sha": "69355c6c6cc0bcdf6be87c0ef9b33c1f239f6ba6", "filename": "src/libcore/clone.rs", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/99c2f72814f3e3ab276b133cf18430a74e839f75/src%2Flibcore%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99c2f72814f3e3ab276b133cf18430a74e839f75/src%2Flibcore%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fclone.rs?ref=99c2f72814f3e3ab276b133cf18430a74e839f75", "patch": "@@ -14,10 +14,14 @@\n //! assign them or pass them as arguments, the receiver will get a copy,\n //! leaving the original value in place. These types do not require\n //! allocation to copy and do not have finalizers (i.e. they do not\n-//! contain owned boxes or implement `Drop`), so the compiler considers\n+//! contain owned boxes or implement [`Drop`]), so the compiler considers\n //! them cheap and safe to copy. For other types copies must be made\n-//! explicitly, by convention implementing the `Clone` trait and calling\n-//! the `clone` method.\n+//! explicitly, by convention implementing the [`Clone`] trait and calling\n+//! the [`clone`][clone] method.\n+//!\n+//! [`Clone`]: trait.Clone.html\n+//! [clone]: trait.Clone.html#tymethod.clone\n+//! [`Drop`]: ../../std/ops/trait.Drop.html\n //!\n //! Basic usage example:\n //!\n@@ -46,22 +50,22 @@\n \n /// A common trait for the ability to explicitly duplicate an object.\n ///\n-/// Differs from `Copy` in that `Copy` is implicit and extremely inexpensive, while\n+/// Differs from [`Copy`] in that [`Copy`] is implicit and extremely inexpensive, while\n /// `Clone` is always explicit and may or may not be expensive. In order to enforce\n-/// these characteristics, Rust does not allow you to reimplement `Copy`, but you\n+/// these characteristics, Rust does not allow you to reimplement [`Copy`], but you\n /// may reimplement `Clone` and run arbitrary code.\n ///\n-/// Since `Clone` is more general than `Copy`, you can automatically make anything\n-/// `Copy` be `Clone` as well.\n+/// Since `Clone` is more general than [`Copy`], you can automatically make anything\n+/// [`Copy`] be `Clone` as well.\n ///\n /// ## Derivable\n ///\n /// This trait can be used with `#[derive]` if all fields are `Clone`. The `derive`d\n-/// implementation of `clone()` calls `clone()` on each field.\n+/// implementation of [`clone()`] calls [`clone()`] on each field.\n ///\n /// ## How can I implement `Clone`?\n ///\n-/// Types that are `Copy` should have a trivial implementation of `Clone`. More formally:\n+/// Types that are [`Copy`] should have a trivial implementation of `Clone`. More formally:\n /// if `T: Copy`, `x: T`, and `y: &T`, then `let x = y.clone();` is equivalent to `let x = *y;`.\n /// Manual implementations should be careful to uphold this invariant; however, unsafe code\n /// must not rely on it to ensure memory safety.\n@@ -70,6 +74,9 @@\n /// library only implements `Clone` up until arrays of size 32. In this case, the implementation of\n /// `Clone` cannot be `derive`d, but can be implemented as:\n ///\n+/// [`Copy`]: ../../std/marker/trait.Copy.html\n+/// [`clone()`]: trait.Clone.html#tymethod.clone\n+///\n /// ```\n /// #[derive(Copy)]\n /// struct Stats {"}, {"sha": "c22c9f0d1c717fbd4ed03d693d0cd27d7055d19c", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 35, "deletions": 16, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/99c2f72814f3e3ab276b133cf18430a74e839f75/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99c2f72814f3e3ab276b133cf18430a74e839f75/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=99c2f72814f3e3ab276b133cf18430a74e839f75", "patch": "@@ -126,7 +126,7 @@ pub trait Unsize<T: ?Sized> {\n /// }\n /// ```\n ///\n-/// The `PointList` `struct` cannot implement `Copy`, because `Vec<T>` is not `Copy`. If we\n+/// The `PointList` `struct` cannot implement `Copy`, because [`Vec<T>`] is not `Copy`. If we\n /// attempt to derive a `Copy` implementation, we'll get an error:\n ///\n /// ```text\n@@ -136,10 +136,10 @@ pub trait Unsize<T: ?Sized> {\n /// ## When can my type _not_ be `Copy`?\n ///\n /// Some types can't be copied safely. For example, copying `&mut T` would create an aliased\n-/// mutable reference, and copying `String` would result in two attempts to free the same buffer.\n+/// mutable reference, and copying [`String`] would result in two attempts to free the same buffer.\n ///\n-/// Generalizing the latter case, any type implementing `Drop` can't be `Copy`, because it's\n-/// managing some resource besides its own `size_of::<T>()` bytes.\n+/// Generalizing the latter case, any type implementing [`Drop`] can't be `Copy`, because it's\n+/// managing some resource besides its own [`size_of::<T>()`] bytes.\n ///\n /// ## What if I derive `Copy` on a type that can't?\n ///\n@@ -156,8 +156,7 @@ pub trait Unsize<T: ?Sized> {\n ///\n /// ## Derivable\n ///\n-/// This trait can be used with `#[derive]` if all of its components implement `Copy` and the type\n-/// implements `Clone`. The implementation will copy the bytes of each field using `memcpy`.\n+/// This trait can be used with `#[derive]` if all of its components implement `Copy` and the type.\n ///\n /// ## How can I implement `Copy`?\n ///\n@@ -178,6 +177,11 @@ pub trait Unsize<T: ?Sized> {\n ///\n /// There is a small difference between the two: the `derive` strategy will also place a `Copy`\n /// bound on type parameters, which isn't always desired.\n+///\n+/// [`Vec<T>`]: ../../std/vec/struct.Vec.html\n+/// [`String`]: ../../std/string/struct.String.html\n+/// [`Drop`]: ../../std/ops/trait.Drop.html\n+/// [`size_of::<T>()`]: ../../std/mem/fn.size_of.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[lang = \"copy\"]\n pub trait Copy : Clone {\n@@ -190,11 +194,11 @@ pub trait Copy : Clone {\n /// thread-safe. In other words, there is no possibility of data races\n /// when passing `&T` references between threads.\n ///\n-/// As one would expect, primitive types like `u8` and `f64` are all\n+/// As one would expect, primitive types like [`u8`] and [`f64`] are all\n /// `Sync`, and so are simple aggregate types containing them (like\n /// tuples, structs and enums). More instances of basic `Sync` types\n /// include \"immutable\" types like `&T` and those with simple\n-/// inherited mutability, such as `Box<T>`, `Vec<T>` and most other\n+/// inherited mutability, such as [`Box<T>`], [`Vec<T>`] and most other\n /// collection types. (Generic parameters need to be `Sync` for their\n /// container to be `Sync`.)\n ///\n@@ -206,27 +210,42 @@ pub trait Copy : Clone {\n /// race.\n ///\n /// Types that are not `Sync` are those that have \"interior\n-/// mutability\" in a non-thread-safe way, such as `Cell` and `RefCell`\n-/// in `std::cell`. These types allow for mutation of their contents\n+/// mutability\" in a non-thread-safe way, such as [`Cell`] and [`RefCell`]\n+/// in [`std::cell`]. These types allow for mutation of their contents\n /// even when in an immutable, aliasable slot, e.g. the contents of\n-/// `&Cell<T>` can be `.set`, and do not ensure data races are\n+/// [`&Cell<T>`][`Cell`] can be [`.set`], and do not ensure data races are\n /// impossible, hence they cannot be `Sync`. A higher level example\n /// of a non-`Sync` type is the reference counted pointer\n-/// `std::rc::Rc`, because any reference `&Rc<T>` can clone a new\n+/// [`std::rc::Rc`][`Rc`], because any reference [`&Rc<T>`][`Rc`] can clone a new\n /// reference, which modifies the reference counts in a non-atomic\n /// way.\n ///\n /// For cases when one does need thread-safe interior mutability,\n-/// types like the atomics in `std::sync` and `Mutex` & `RWLock` in\n-/// the `sync` crate do ensure that any mutation cannot cause data\n+/// types like the atomics in [`std::sync`][`sync`] and [`Mutex`] / [`RwLock`] in\n+/// the [`sync`] crate do ensure that any mutation cannot cause data\n /// races.  Hence these types are `Sync`.\n ///\n-/// Any types with interior mutability must also use the `std::cell::UnsafeCell`\n+/// Any types with interior mutability must also use the [`std::cell::UnsafeCell`]\n /// wrapper around the value(s) which can be mutated when behind a `&`\n /// reference; not doing this is undefined behavior (for example,\n-/// `transmute`-ing from `&T` to `&mut T` is invalid).\n+/// [`transmute`]-ing from `&T` to `&mut T` is invalid).\n ///\n /// This trait is automatically derived when the compiler determines it's appropriate.\n+///\n+/// [`u8`]: ../../std/primitive.u8.html\n+/// [`f64`]: ../../std/primitive.f64.html\n+/// [`Vec<T>`]: ../../std/vec/struct.Vec.html\n+/// [`Box<T>`]: ../../std/boxed/struct.Box.html\n+/// [`Cell`]: ../../std/cell/struct.Cell.html\n+/// [`RefCell`]: ../../std/cell/struct.RefCell.html\n+/// [`std::cell`]: ../../std/cell/index.html\n+/// [`.set`]: ../../std/cell/struct.Cell.html#method.set\n+/// [`Rc`]: ../../std/rc/struct.Rc.html\n+/// [`sync`]: ../../std/sync/index.html\n+/// [`Mutex`]: ../../std/sync/struct.Mutex.html\n+/// [`RwLock`]: ../../std/sync/struct.RwLock.html\n+/// [`std::cell::UnsafeCell`]: ../../std/cell/struct.UnsafeCell.html\n+/// [`transmute`]: ../../std/mem/fn.transmute.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[lang = \"sync\"]\n #[rustc_on_unimplemented = \"`{Self}` cannot be shared between threads safely\"]"}, {"sha": "dacb396ee402815ef6e5969e36e5e76ac44618b2", "filename": "src/libcore/option.rs", "status": "modified", "additions": 50, "deletions": 28, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/99c2f72814f3e3ab276b133cf18430a74e839f75/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99c2f72814f3e3ab276b133cf18430a74e839f75/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=99c2f72814f3e3ab276b133cf18430a74e839f75", "patch": "@@ -10,9 +10,9 @@\n \n //! Optional values.\n //!\n-//! Type `Option` represents an optional value: every `Option`\n-//! is either `Some` and contains a value, or `None`, and\n-//! does not. `Option` types are very common in Rust code, as\n+//! Type [`Option`] represents an optional value: every [`Option`]\n+//! is either [`Some`] and contains a value, or [`None`], and\n+//! does not. [`Option`] types are very common in Rust code, as\n //! they have a number of uses:\n //!\n //! * Initial values\n@@ -26,8 +26,8 @@\n //! * Nullable pointers\n //! * Swapping things out of difficult situations\n //!\n-//! Options are commonly paired with pattern matching to query the presence\n-//! of a value and take action, always accounting for the `None` case.\n+//! [`Option`]s are commonly paired with pattern matching to query the presence\n+//! of a value and take action, always accounting for the [`None`] case.\n //!\n //! ```\n //! fn divide(numerator: f64, denominator: f64) -> Option<f64> {\n@@ -57,13 +57,13 @@\n //!\n //! Rust's pointer types must always point to a valid location; there are\n //! no \"null\" pointers. Instead, Rust has *optional* pointers, like\n-//! the optional owned box, `Option<Box<T>>`.\n+//! the optional owned box, [`Option`]`<`[`Box<T>`]`>`.\n //!\n-//! The following example uses `Option` to create an optional box of\n-//! `i32`. Notice that in order to use the inner `i32` value first the\n+//! The following example uses [`Option`] to create an optional box of\n+//! [`i32`]. Notice that in order to use the inner [`i32`] value first the\n //! `check_optional` function needs to use pattern matching to\n-//! determine whether the box has a value (i.e. it is `Some(...)`) or\n-//! not (`None`).\n+//! determine whether the box has a value (i.e. it is [`Some(...)`][`Some`]) or\n+//! not ([`None`]).\n //!\n //! ```\n //! let optional: Option<Box<i32>> = None;\n@@ -80,14 +80,14 @@\n //! }\n //! ```\n //!\n-//! This usage of `Option` to create safe nullable pointers is so\n+//! This usage of [`Option`] to create safe nullable pointers is so\n //! common that Rust does special optimizations to make the\n-//! representation of `Option<Box<T>>` a single pointer. Optional pointers\n+//! representation of [`Option`]`<`[`Box<T>`]`>` a single pointer. Optional pointers\n //! in Rust are stored as efficiently as any other pointer type.\n //!\n //! # Examples\n //!\n-//! Basic pattern matching on `Option`:\n+//! Basic pattern matching on [`Option`]:\n //!\n //! ```\n //! let msg = Some(\"howdy\");\n@@ -101,7 +101,7 @@\n //! let unwrapped_msg = msg.unwrap_or(\"default message\");\n //! ```\n //!\n-//! Initialize a result to `None` before a loop:\n+//! Initialize a result to [`None`] before a loop:\n //!\n //! ```\n //! enum Kingdom { Plant(u32, &'static str), Animal(u32, &'static str) }\n@@ -136,6 +136,12 @@\n //!     None => println!(\"there are no animals :(\"),\n //! }\n //! ```\n+//!\n+//! [`Option`]: enum.Option.html\n+//! [`Some`]: enum.Option.html#variant.Some\n+//! [`None`]: enum.Option.html#variant.None\n+//! [`Box<T>`]: ../../std/boxed/struct.Box.html\n+//! [`i32`]: ../../std/primitive.i32.html\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n@@ -156,7 +162,7 @@ pub enum Option<T> {\n     None,\n     /// Some value `T`\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T)\n+    Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n }\n \n /////////////////////////////////////////////////////////////////////////////\n@@ -168,7 +174,7 @@ impl<T> Option<T> {\n     // Querying the contained values\n     /////////////////////////////////////////////////////////////////////////\n \n-    /// Returns `true` if the option is a `Some` value\n+    /// Returns `true` if the option is a `Some` value.\n     ///\n     /// # Examples\n     ///\n@@ -188,7 +194,7 @@ impl<T> Option<T> {\n         }\n     }\n \n-    /// Returns `true` if the option is a `None` value\n+    /// Returns `true` if the option is a `None` value.\n     ///\n     /// # Examples\n     ///\n@@ -209,15 +215,17 @@ impl<T> Option<T> {\n     // Adapter for working with references\n     /////////////////////////////////////////////////////////////////////////\n \n-    /// Converts from `Option<T>` to `Option<&T>`\n+    /// Converts from `Option<T>` to `Option<&T>`.\n     ///\n     /// # Examples\n     ///\n     /// Convert an `Option<String>` into an `Option<usize>`, preserving the original.\n-    /// The `map` method takes the `self` argument by value, consuming the original,\n+    /// The [`map`] method takes the `self` argument by value, consuming the original,\n     /// so this technique uses `as_ref` to first take an `Option` to a reference\n     /// to the value inside the original.\n     ///\n+    /// [`map`]: enum.Option.html#method.map\n+    ///\n     /// ```\n     /// let num_as_str: Option<String> = Some(\"10\".to_string());\n     /// // First, cast `Option<String>` to `Option<&String>` with `as_ref`,\n@@ -234,7 +242,7 @@ impl<T> Option<T> {\n         }\n     }\n \n-    /// Converts from `Option<T>` to `Option<&mut T>`\n+    /// Converts from `Option<T>` to `Option<&mut T>`.\n     ///\n     /// # Examples\n     ///\n@@ -357,7 +365,7 @@ impl<T> Option<T> {\n     // Transforming contained values\n     /////////////////////////////////////////////////////////////////////////\n \n-    /// Maps an `Option<T>` to `Option<U>` by applying a function to a contained value\n+    /// Maps an `Option<T>` to `Option<U>` by applying a function to a contained value.\n     ///\n     /// # Examples\n     ///\n@@ -423,8 +431,12 @@ impl<T> Option<T> {\n         }\n     }\n \n-    /// Transforms the `Option<T>` into a `Result<T, E>`, mapping `Some(v)` to\n-    /// `Ok(v)` and `None` to `Err(err)`.\n+    /// Transforms the `Option<T>` into a [`Result<T, E>`], mapping `Some(v)` to\n+    /// [`Ok(v)`] and `None` to [`Err(err)`][Err].\n+    ///\n+    /// [`Result<T, E>`]: ../../std/result/enum.Result.html\n+    /// [`Ok(v)`]: ../../std/result/enum.Result.html#variant.Ok\n+    /// [Err]: ../../std/result/enum.Result.html#variant.Err\n     ///\n     /// # Examples\n     ///\n@@ -444,8 +456,12 @@ impl<T> Option<T> {\n         }\n     }\n \n-    /// Transforms the `Option<T>` into a `Result<T, E>`, mapping `Some(v)` to\n-    /// `Ok(v)` and `None` to `Err(err())`.\n+    /// Transforms the `Option<T>` into a [`Result<T, E>`], mapping `Some(v)` to\n+    /// [`Ok(v)`] and `None` to [`Err(err())`][Err].\n+    ///\n+    /// [`Result<T, E>`]: ../../std/result/enum.Result.html\n+    /// [`Ok(v)`]: ../../std/result/enum.Result.html#variant.Ok\n+    /// [Err]: ../../std/result/enum.Result.html#variant.Err\n     ///\n     /// # Examples\n     ///\n@@ -789,7 +805,9 @@ impl<A> DoubleEndedIterator for Item<A> {\n impl<A> ExactSizeIterator for Item<A> {}\n impl<A> FusedIterator for Item<A> {}\n \n-/// An iterator over a reference of the contained item in an Option.\n+/// An iterator over a reference of the contained item in an [`Option`].\n+///\n+/// [`Option`]: enum.Option.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Debug)]\n pub struct Iter<'a, A: 'a> { inner: Item<&'a A> }\n@@ -823,7 +841,9 @@ impl<'a, A> Clone for Iter<'a, A> {\n     }\n }\n \n-/// An iterator over a mutable reference of the contained item in an Option.\n+/// An iterator over a mutable reference of the contained item in an [`Option`].\n+///\n+/// [`Option`]: enum.Option.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Debug)]\n pub struct IterMut<'a, A: 'a> { inner: Item<&'a mut A> }\n@@ -850,7 +870,9 @@ impl<'a, A> ExactSizeIterator for IterMut<'a, A> {}\n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl<'a, A> FusedIterator for IterMut<'a, A> {}\n \n-/// An iterator over the item contained inside an Option.\n+/// An iterator over the item contained inside an [`Option`].\n+///\n+/// [`Option`]: enum.Option.html\n #[derive(Clone, Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<A> { inner: Item<A> }"}, {"sha": "96845259299be29b52f4c597e6c780eed0e48375", "filename": "src/libcore/result.rs", "status": "modified", "additions": 59, "deletions": 36, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/99c2f72814f3e3ab276b133cf18430a74e839f75/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99c2f72814f3e3ab276b133cf18430a74e839f75/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=99c2f72814f3e3ab276b133cf18430a74e839f75", "patch": "@@ -10,9 +10,9 @@\n \n //! Error handling with the `Result` type.\n //!\n-//! `Result<T, E>` is the type used for returning and propagating\n-//! errors. It is an enum with the variants, `Ok(T)`, representing\n-//! success and containing a value, and `Err(E)`, representing error\n+//! [`Result<T, E>`][`Result`] is the type used for returning and propagating\n+//! errors. It is an enum with the variants, [`Ok(T)`], representing\n+//! success and containing a value, and [`Err(E)`], representing error\n //! and containing an error value.\n //!\n //! ```\n@@ -23,11 +23,11 @@\n //! }\n //! ```\n //!\n-//! Functions return `Result` whenever errors are expected and\n-//! recoverable. In the `std` crate `Result` is most prominently used\n+//! Functions return [`Result`] whenever errors are expected and\n+//! recoverable. In the `std` crate, [`Result`] is most prominently used\n //! for [I/O](../../std/io/index.html).\n //!\n-//! A simple function returning `Result` might be\n+//! A simple function returning [`Result`] might be\n //! defined and used like so:\n //!\n //! ```\n@@ -50,8 +50,8 @@\n //! }\n //! ```\n //!\n-//! Pattern matching on `Result`s is clear and straightforward for\n-//! simple cases, but `Result` comes with some convenience methods\n+//! Pattern matching on [`Result`]s is clear and straightforward for\n+//! simple cases, but [`Result`] comes with some convenience methods\n //! that make working with it more succinct.\n //!\n //! ```\n@@ -80,14 +80,14 @@\n //!\n //! A common problem with using return values to indicate errors is\n //! that it is easy to ignore the return value, thus failing to handle\n-//! the error. Result is annotated with the #[must_use] attribute,\n+//! the error. [`Result`] is annotated with the `#[must_use]` attribute,\n //! which will cause the compiler to issue a warning when a Result\n-//! value is ignored. This makes `Result` especially useful with\n+//! value is ignored. This makes [`Result`] especially useful with\n //! functions that may encounter errors but don't otherwise return a\n //! useful value.\n //!\n-//! Consider the `write_all` method defined for I/O types\n-//! by the [`Write`](../../std/io/trait.Write.html) trait:\n+//! Consider the [`write_all`] method defined for I/O types\n+//! by the [`Write`] trait:\n //!\n //! ```\n //! use std::io;\n@@ -97,8 +97,8 @@\n //! }\n //! ```\n //!\n-//! *Note: The actual definition of `Write` uses `io::Result`, which\n-//! is just a synonym for `Result<T, io::Error>`.*\n+//! *Note: The actual definition of [`Write`] uses [`io::Result`], which\n+//! is just a synonym for [`Result`]`<T, `[`io::Error`]`>`.*\n //!\n //! This method doesn't produce a value, but the write may\n //! fail. It's crucial to handle the error case, and *not* write\n@@ -119,7 +119,7 @@\n //! warning (by default, controlled by the `unused_must_use` lint).\n //!\n //! You might instead, if you don't want to handle the error, simply\n-//! assert success with `expect`. This will panic if the\n+//! assert success with [`expect`]. This will panic if the\n //! write fails, providing a marginally useful message indicating why:\n //!\n //! ```{.no_run}\n@@ -139,7 +139,7 @@\n //! assert!(file.write_all(b\"important message\").is_ok());\n //! ```\n //!\n-//! Or propagate the error up the call stack with `try!`:\n+//! Or propagate the error up the call stack with [`try!`]:\n //!\n //! ```\n //! # use std::fs::File;\n@@ -156,7 +156,7 @@\n //! # The `try!` macro\n //!\n //! When writing code that calls many functions that return the\n-//! `Result` type, the error handling can be tedious.  The `try!`\n+//! [`Result`] type, the error handling can be tedious. The [`try!`]\n //! macro hides some of the boilerplate of propagating errors up the\n //! call stack.\n //!\n@@ -219,9 +219,9 @@\n //!\n //! *It's much nicer!*\n //!\n-//! Wrapping an expression in `try!` will result in the unwrapped\n-//! success (`Ok`) value, unless the result is `Err`, in which case\n-//! `Err` is returned early from the enclosing function. Its simple definition\n+//! Wrapping an expression in [`try!`] will result in the unwrapped\n+//! success ([`Ok`]) value, unless the result is [`Err`], in which case\n+//! [`Err`] is returned early from the enclosing function. Its simple definition\n //! makes it clear:\n //!\n //! ```\n@@ -230,9 +230,21 @@\n //! }\n //! ```\n //!\n-//! `try!` is imported by the prelude and is available everywhere, but it can only\n-//! be used in functions that return `Result` because of the early return of\n-//! `Err` that it provides.\n+//! [`try!`] is imported by the prelude and is available everywhere, but it can only\n+//! be used in functions that return [`Result`] because of the early return of\n+//! [`Err`] that it provides.\n+//!\n+//! [`expect`]: enum.Result.html#method.expect\n+//! [`Write`]: ../../std/io/trait.Write.html\n+//! [`write_all`]: ../../std/io/trait.Write.html#method.write_all\n+//! [`io::Result`]: ../../std/io/type.Result.html\n+//! [`try!`]: ../../std/macro.try.html\n+//! [`Result`]: enum.Result.html\n+//! [`Ok(T)`]: enum.Result.html#variant.Ok\n+//! [`Err(E)`]: enum.Result.html#variant.Err\n+//! [`io::Error`]: ../../std/io/struct.Error.html\n+//! [`Ok`]: enum.Result.html#variant.Ok\n+//! [`Err`]: enum.Result.html#variant.Err\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n@@ -264,7 +276,7 @@ impl<T, E> Result<T, E> {\n     // Querying the contained values\n     /////////////////////////////////////////////////////////////////////////\n \n-    /// Returns true if the result is `Ok`\n+    /// Returns true if the result is `Ok`.\n     ///\n     /// # Examples\n     ///\n@@ -286,7 +298,7 @@ impl<T, E> Result<T, E> {\n         }\n     }\n \n-    /// Returns true if the result is `Err`\n+    /// Returns true if the result is `Err`.\n     ///\n     /// # Examples\n     ///\n@@ -309,11 +321,13 @@ impl<T, E> Result<T, E> {\n     // Adapter for each variant\n     /////////////////////////////////////////////////////////////////////////\n \n-    /// Converts from `Result<T, E>` to `Option<T>`\n+    /// Converts from `Result<T, E>` to [`Option<T>`].\n     ///\n-    /// Converts `self` into an `Option<T>`, consuming `self`,\n+    /// Converts `self` into an [`Option<T>`], consuming `self`,\n     /// and discarding the error, if any.\n     ///\n+    /// [`Option<T>`]: ../../std/option/enum.Option.html\n+    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -334,11 +348,13 @@ impl<T, E> Result<T, E> {\n         }\n     }\n \n-    /// Converts from `Result<T, E>` to `Option<E>`\n+    /// Converts from `Result<T, E>` to [`Option<E>`].\n     ///\n-    /// Converts `self` into an `Option<E>`, consuming `self`,\n+    /// Converts `self` into an [`Option<E>`], consuming `self`,\n     /// and discarding the success value, if any.\n     ///\n+    /// [`Option<E>`]: ../../std/option/enum.Option.html\n+    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -363,7 +379,7 @@ impl<T, E> Result<T, E> {\n     // Adapter for working with references\n     /////////////////////////////////////////////////////////////////////////\n \n-    /// Converts from `Result<T, E>` to `Result<&T, &E>`\n+    /// Converts from `Result<T, E>` to `Result<&T, &E>`.\n     ///\n     /// Produces a new `Result`, containing a reference\n     /// into the original, leaving the original in place.\n@@ -388,7 +404,7 @@ impl<T, E> Result<T, E> {\n         }\n     }\n \n-    /// Converts from `Result<T, E>` to `Result<&mut T, &mut E>`\n+    /// Converts from `Result<T, E>` to `Result<&mut T, &mut E>`.\n     ///\n     /// # Examples\n     ///\n@@ -563,7 +579,7 @@ impl<T, E> Result<T, E> {\n \n     /// Calls `op` if the result is `Ok`, otherwise returns the `Err` value of `self`.\n     ///\n-    /// This function can be used for control flow based on result values.\n+    /// This function can be used for control flow based on `Result` values.\n     ///\n     /// # Examples\n     ///\n@@ -646,7 +662,7 @@ impl<T, E> Result<T, E> {\n     }\n \n     /// Unwraps a result, yielding the content of an `Ok`.\n-    /// Else it returns `optb`.\n+    /// Else, it returns `optb`.\n     ///\n     /// # Examples\n     ///\n@@ -837,7 +853,10 @@ impl<'a, T, E> IntoIterator for &'a mut Result<T, E> {\n // The Result Iterators\n /////////////////////////////////////////////////////////////////////////////\n \n-/// An iterator over a reference to the `Ok` variant of a `Result`.\n+/// An iterator over a reference to the [`Ok`] variant of a [`Result`].\n+///\n+/// [`Ok`]: enum.Result.html#variant.Ok\n+/// [`Result`]: enum.Result.html\n #[derive(Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a, T: 'a> { inner: Option<&'a T> }\n@@ -872,7 +891,10 @@ impl<'a, T> Clone for Iter<'a, T> {\n     fn clone(&self) -> Iter<'a, T> { Iter { inner: self.inner } }\n }\n \n-/// An iterator over a mutable reference to the `Ok` variant of a `Result`.\n+/// An iterator over a mutable reference to the [`Ok`] variant of a [`Result`].\n+///\n+/// [`Ok`]: enum.Result.html#variant.Ok\n+/// [`Result`]: enum.Result.html\n #[derive(Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IterMut<'a, T: 'a> { inner: Option<&'a mut T> }\n@@ -902,10 +924,11 @@ impl<'a, T> ExactSizeIterator for IterMut<'a, T> {}\n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl<'a, T> FusedIterator for IterMut<'a, T> {}\n \n-/// An iterator over the value in a `Ok` variant of a `Result`. This struct is\n+/// An iterator over the value in a [`Ok`] variant of a [`Result`]. This struct is\n /// created by the [`into_iter`] method on [`Result`][`Result`] (provided by\n /// the [`IntoIterator`] trait).\n ///\n+/// [`Ok`]: enum.Result.html#variant.Ok\n /// [`Result`]: enum.Result.html\n /// [`into_iter`]: ../iter/trait.IntoIterator.html#tymethod.into_iter\n /// [`IntoIterator`]: ../iter/trait.IntoIterator.html"}]}