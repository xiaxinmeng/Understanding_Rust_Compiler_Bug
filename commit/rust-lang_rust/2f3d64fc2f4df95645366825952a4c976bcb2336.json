{"sha": "2f3d64fc2f4df95645366825952a4c976bcb2336", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJmM2Q2NGZjMmY0ZGY5NTY0NTM2NjgyNTk1MmE0Yzk3NmJjYjIzMzY=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2020-07-19T14:02:22Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-07-19T14:02:22Z"}, "message": "Rollup merge of #74333 - poliorcetics:std-alloc-unsafe-op-in-unsafe-fn, r=LukasKalbertodt\n\nDeny unsafe operations in unsafe functions in libstd/alloc.rs\n\nPartial fix of #73904.\n\nThis encloses `unsafe` operations in `unsafe fn` in `libstd/alloc.rs`.\n\n@rustbot modify labels: F-unsafe-block-in-unsafe-fn", "tree": {"sha": "985fcc9498c94413c726268ad47e5ef94d825f7e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/985fcc9498c94413c726268ad47e5ef94d825f7e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2f3d64fc2f4df95645366825952a4c976bcb2336", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfFFJuCRBK7hj4Ov3rIwAAdHIIAENbkpYbpvEsBa7VWoH3GEI6\nPxAadQfe2SGgFLBf66Z3x23K9aWr+Un7ntCizL9p85JJHy4PWZYTSrIa5FycnjYm\nremc+amNLzg0Cq06l3BUlug9xUqQik6XDWG1bnBBSFlrlUniW35guZ2BgNqWwfmV\nNSAXaaXKlusyVaU6cc0L8TGpib2tQiCUMghgecFi0oa7ZP77aO2ibKcwOPwz+rg6\ndC3msiHJ5jti3PAZu8M4qrHW/spHaVVeHCIadAEx2yBOAJJIunapJ/XCK0iSlkQt\nawJdWSIj5VXD8yklO5HbgYWzhwibiRzK6eVRQ5ufG0ME1rh9QzlatHGhQRHKqbM=\n=HA+G\n-----END PGP SIGNATURE-----\n", "payload": "tree 985fcc9498c94413c726268ad47e5ef94d825f7e\nparent 47ea6d90b073ab977cf072e2f5f46d63de532cc6\nparent c38230e3b639783483277465ff3c3436a8fd5545\nauthor Manish Goregaokar <manishsmail@gmail.com> 1595167342 -0700\ncommitter GitHub <noreply@github.com> 1595167342 -0700\n\nRollup merge of #74333 - poliorcetics:std-alloc-unsafe-op-in-unsafe-fn, r=LukasKalbertodt\n\nDeny unsafe operations in unsafe functions in libstd/alloc.rs\n\nPartial fix of #73904.\n\nThis encloses `unsafe` operations in `unsafe fn` in `libstd/alloc.rs`.\n\n@rustbot modify labels: F-unsafe-block-in-unsafe-fn\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2f3d64fc2f4df95645366825952a4c976bcb2336", "html_url": "https://github.com/rust-lang/rust/commit/2f3d64fc2f4df95645366825952a4c976bcb2336", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2f3d64fc2f4df95645366825952a4c976bcb2336/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "47ea6d90b073ab977cf072e2f5f46d63de532cc6", "url": "https://api.github.com/repos/rust-lang/rust/commits/47ea6d90b073ab977cf072e2f5f46d63de532cc6", "html_url": "https://github.com/rust-lang/rust/commit/47ea6d90b073ab977cf072e2f5f46d63de532cc6"}, {"sha": "c38230e3b639783483277465ff3c3436a8fd5545", "url": "https://api.github.com/repos/rust-lang/rust/commits/c38230e3b639783483277465ff3c3436a8fd5545", "html_url": "https://github.com/rust-lang/rust/commit/c38230e3b639783483277465ff3c3436a8fd5545"}], "stats": {"total": 91, "additions": 71, "deletions": 20}, "files": [{"sha": "ecfaaeace513e329873de16187a83875b0c5a4c4", "filename": "src/libstd/alloc.rs", "status": "modified", "additions": 71, "deletions": 20, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/2f3d64fc2f4df95645366825952a4c976bcb2336/src%2Flibstd%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f3d64fc2f4df95645366825952a4c976bcb2336/src%2Flibstd%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Falloc.rs?ref=2f3d64fc2f4df95645366825952a4c976bcb2336", "patch": "@@ -59,6 +59,7 @@\n //! The `#[global_allocator]` can only be used once in a crate\n //! or its recursive dependencies.\n \n+#![deny(unsafe_op_in_unsafe_fn)]\n #![stable(feature = \"alloc_module\", since = \"1.28.0\")]\n \n use core::intrinsics;\n@@ -158,7 +159,9 @@ unsafe impl AllocRef for System {\n     #[inline]\n     unsafe fn dealloc(&mut self, ptr: NonNull<u8>, layout: Layout) {\n         if layout.size() != 0 {\n-            GlobalAlloc::dealloc(self, ptr.as_ptr(), layout)\n+            // SAFETY: The safety guarantees are explained in the documentation\n+            // for the `GlobalAlloc` trait and its `dealloc` method.\n+            unsafe { GlobalAlloc::dealloc(self, ptr.as_ptr(), layout) }\n         }\n     }\n \n@@ -184,16 +187,36 @@ unsafe impl AllocRef for System {\n         match placement {\n             ReallocPlacement::InPlace => Err(AllocErr),\n             ReallocPlacement::MayMove if layout.size() == 0 => {\n-                let new_layout = Layout::from_size_align_unchecked(new_size, layout.align());\n+                let new_layout =\n+                    // SAFETY: The new size and layout alignement guarantees\n+                    // are transfered to the caller (they come from parameters).\n+                    //\n+                    // See the preconditions for `Layout::from_size_align` to\n+                    // see what must be checked.\n+                    unsafe { Layout::from_size_align_unchecked(new_size, layout.align()) };\n                 self.alloc(new_layout, init)\n             }\n             ReallocPlacement::MayMove => {\n-                // `realloc` probably checks for `new_size > size` or something similar.\n-                intrinsics::assume(new_size > size);\n-                let ptr = GlobalAlloc::realloc(self, ptr.as_ptr(), layout, new_size);\n-                let memory =\n-                    MemoryBlock { ptr: NonNull::new(ptr).ok_or(AllocErr)?, size: new_size };\n-                init.init_offset(memory, size);\n+                // SAFETY:\n+                //\n+                // The safety guarantees are explained in the documentation\n+                // for the `GlobalAlloc` trait and its `dealloc` method.\n+                //\n+                // `realloc` probably checks for `new_size > size` or something\n+                // similar.\n+                //\n+                // For the guarantees about `init_offset`, see its documentation:\n+                // `ptr` is assumed valid (and checked for non-NUL) and\n+                // `memory.size` is set to `new_size` so the offset being `size`\n+                // is valid.\n+                let memory = unsafe {\n+                    intrinsics::assume(new_size > size);\n+                    let ptr = GlobalAlloc::realloc(self, ptr.as_ptr(), layout, new_size);\n+                    let memory =\n+                        MemoryBlock { ptr: NonNull::new(ptr).ok_or(AllocErr)?, size: new_size };\n+                    init.init_offset(memory, size);\n+                    memory\n+                };\n                 Ok(memory)\n             }\n         }\n@@ -220,14 +243,28 @@ unsafe impl AllocRef for System {\n         match placement {\n             ReallocPlacement::InPlace => Err(AllocErr),\n             ReallocPlacement::MayMove if new_size == 0 => {\n-                self.dealloc(ptr, layout);\n+                // SAFETY: see `GlobalAlloc::dealloc` for the guarantees that\n+                // must be respected. `ptr` and `layout` are parameters and so\n+                // those guarantees must be checked by the caller.\n+                unsafe { self.dealloc(ptr, layout) };\n                 Ok(MemoryBlock { ptr: layout.dangling(), size: 0 })\n             }\n             ReallocPlacement::MayMove => {\n-                // `realloc` probably checks for `new_size < size` or something similar.\n-                intrinsics::assume(new_size < size);\n-                let ptr = GlobalAlloc::realloc(self, ptr.as_ptr(), layout, new_size);\n-                Ok(MemoryBlock { ptr: NonNull::new(ptr).ok_or(AllocErr)?, size: new_size })\n+                // SAFETY:\n+                //\n+                // See `GlobalAlloc::realloc` for more informations about the\n+                // guarantees expected by this method. `ptr`, `layout` and\n+                // `new_size` are parameters and the responsability for their\n+                // correctness is left to the caller.\n+                //\n+                // `realloc` probably checks for `new_size < size` or something\n+                // similar.\n+                let memory = unsafe {\n+                    intrinsics::assume(new_size < size);\n+                    let ptr = GlobalAlloc::realloc(self, ptr.as_ptr(), layout, new_size);\n+                    MemoryBlock { ptr: NonNull::new(ptr).ok_or(AllocErr)?, size: new_size }\n+                };\n+                Ok(memory)\n             }\n         }\n     }\n@@ -300,13 +337,19 @@ pub mod __default_lib_allocator {\n \n     #[rustc_std_internal_symbol]\n     pub unsafe extern \"C\" fn __rdl_alloc(size: usize, align: usize) -> *mut u8 {\n-        let layout = Layout::from_size_align_unchecked(size, align);\n-        System.alloc(layout)\n+        // SAFETY: see the guarantees expected by `Layout::from_size_align` and\n+        // `GlobalAlloc::alloc`.\n+        unsafe {\n+            let layout = Layout::from_size_align_unchecked(size, align);\n+            System.alloc(layout)\n+        }\n     }\n \n     #[rustc_std_internal_symbol]\n     pub unsafe extern \"C\" fn __rdl_dealloc(ptr: *mut u8, size: usize, align: usize) {\n-        System.dealloc(ptr, Layout::from_size_align_unchecked(size, align))\n+        // SAFETY: see the guarantees expected by `Layout::from_size_align` and\n+        // `GlobalAlloc::dealloc`.\n+        unsafe { System.dealloc(ptr, Layout::from_size_align_unchecked(size, align)) }\n     }\n \n     #[rustc_std_internal_symbol]\n@@ -316,13 +359,21 @@ pub mod __default_lib_allocator {\n         align: usize,\n         new_size: usize,\n     ) -> *mut u8 {\n-        let old_layout = Layout::from_size_align_unchecked(old_size, align);\n-        System.realloc(ptr, old_layout, new_size)\n+        // SAFETY: see the guarantees expected by `Layout::from_size_align` and\n+        // `GlobalAlloc::realloc`.\n+        unsafe {\n+            let old_layout = Layout::from_size_align_unchecked(old_size, align);\n+            System.realloc(ptr, old_layout, new_size)\n+        }\n     }\n \n     #[rustc_std_internal_symbol]\n     pub unsafe extern \"C\" fn __rdl_alloc_zeroed(size: usize, align: usize) -> *mut u8 {\n-        let layout = Layout::from_size_align_unchecked(size, align);\n-        System.alloc_zeroed(layout)\n+        // SAFETY: see the guarantees expected by `Layout::from_size_align` and\n+        // `GlobalAlloc::alloc_zeroed`.\n+        unsafe {\n+            let layout = Layout::from_size_align_unchecked(size, align);\n+            System.alloc_zeroed(layout)\n+        }\n     }\n }"}]}