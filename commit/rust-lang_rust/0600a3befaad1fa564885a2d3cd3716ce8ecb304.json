{"sha": "0600a3befaad1fa564885a2d3cd3716ce8ecb304", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA2MDBhM2JlZmFhZDFmYTU2NDg4NWEyZDNjZDM3MTZjZThlY2IzMDQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-08-19T22:10:55Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-08-19T22:10:55Z"}, "message": "auto merge of #16201 : erickt/rust/json-ints, r=acrichto\n\nThis patch allows json to deserialize integers larger than 2^53 without losing precision. It does this by first keeping the integer portion of a number as a `i64`, and only casting it over to a `f64` if we have a decimal or exponent.", "tree": {"sha": "c897662a88c784e77f1829ffddd51a8f3946accc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c897662a88c784e77f1829ffddd51a8f3946accc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0600a3befaad1fa564885a2d3cd3716ce8ecb304", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0600a3befaad1fa564885a2d3cd3716ce8ecb304", "html_url": "https://github.com/rust-lang/rust/commit/0600a3befaad1fa564885a2d3cd3716ce8ecb304", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0600a3befaad1fa564885a2d3cd3716ce8ecb304/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "51b901e16048c5adbe1f12428fe5a79603478f83", "url": "https://api.github.com/repos/rust-lang/rust/commits/51b901e16048c5adbe1f12428fe5a79603478f83", "html_url": "https://github.com/rust-lang/rust/commit/51b901e16048c5adbe1f12428fe5a79603478f83"}, {"sha": "9b2328797472b710276ef9b627f9d18bd06fbe5a", "url": "https://api.github.com/repos/rust-lang/rust/commits/9b2328797472b710276ef9b627f9d18bd06fbe5a", "html_url": "https://github.com/rust-lang/rust/commit/9b2328797472b710276ef9b627f9d18bd06fbe5a"}], "stats": {"total": 513, "additions": 376, "deletions": 137}, "files": [{"sha": "cef50a1308fc5a8d44f4cd00200729f1e35973ae", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 374, "deletions": 135, "changes": 509, "blob_url": "https://github.com/rust-lang/rust/blob/0600a3befaad1fa564885a2d3cd3716ce8ecb304/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0600a3befaad1fa564885a2d3cd3716ce8ecb304/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=0600a3befaad1fa564885a2d3cd3716ce8ecb304", "patch": "@@ -209,7 +209,9 @@ use Encodable;\n /// Represents a json value\n #[deriving(Clone, PartialEq, PartialOrd)]\n pub enum Json {\n-    Number(f64),\n+    I64(i64),\n+    U64(u64),\n+    F64(f64),\n     String(String),\n     Boolean(bool),\n     List(List),\n@@ -836,7 +838,9 @@ impl<'a> ::Encoder<io::IoError> for PrettyEncoder<'a> {\n impl<E: ::Encoder<S>, S> Encodable<E, S> for Json {\n     fn encode(&self, e: &mut E) -> Result<(), S> {\n         match *self {\n-            Number(v) => v.encode(e),\n+            I64(v) => v.encode(e),\n+            U64(v) => v.encode(e),\n+            F64(v) => v.encode(e),\n             String(ref v) => v.encode(e),\n             Boolean(v) => v.encode(e),\n             List(ref v) => v.encode(e),\n@@ -958,14 +962,63 @@ impl Json {\n \n     /// Returns true if the Json value is a Number. Returns false otherwise.\n     pub fn is_number(&self) -> bool {\n-        self.as_number().is_some()\n+        match *self {\n+            I64(_) | U64(_) | F64(_) => true,\n+            _ => false,\n+        }\n+    }\n+\n+    /// Returns true if the Json value is a i64. Returns false otherwise.\n+    pub fn is_i64(&self) -> bool {\n+        match *self {\n+            I64(_) => true,\n+            _ => false,\n+        }\n+    }\n+\n+    /// Returns true if the Json value is a u64. Returns false otherwise.\n+    pub fn is_u64(&self) -> bool {\n+        match *self {\n+            U64(_) => true,\n+            _ => false,\n+        }\n+    }\n+\n+    /// Returns true if the Json value is a f64. Returns false otherwise.\n+    pub fn is_f64(&self) -> bool {\n+        match *self {\n+            F64(_) => true,\n+            _ => false,\n+        }\n     }\n \n-    /// If the Json value is a Number, returns the associated f64.\n+    /// If the Json value is a number, return or cast it to a i64.\n     /// Returns None otherwise.\n-    pub fn as_number(&self) -> Option<f64> {\n-        match self {\n-            &Number(n) => Some(n),\n+    pub fn as_i64(&self) -> Option<i64> {\n+        match *self {\n+            I64(n) => Some(n),\n+            U64(n) => num::cast(n),\n+            _ => None\n+        }\n+    }\n+\n+    /// If the Json value is a number, return or cast it to a u64.\n+    /// Returns None otherwise.\n+    pub fn as_u64(&self) -> Option<u64> {\n+        match *self {\n+            I64(n) => num::cast(n),\n+            U64(n) => Some(n),\n+            _ => None\n+        }\n+    }\n+\n+    /// If the Json value is a number, return or cast it to a f64.\n+    /// Returns None otherwise.\n+    pub fn as_f64(&self) -> Option<f64> {\n+        match *self {\n+            I64(n) => num::cast(n),\n+            U64(n) => num::cast(n),\n+            F64(n) => Some(n),\n             _ => None\n         }\n     }\n@@ -1007,7 +1060,9 @@ pub enum JsonEvent {\n     ListStart,\n     ListEnd,\n     BooleanValue(bool),\n-    NumberValue(f64),\n+    I64Value(i64),\n+    U64Value(u64),\n+    F64Value(f64),\n     StringValue(String),\n     NullValue,\n     Error(ParserError),\n@@ -1257,29 +1312,60 @@ impl<T: Iterator<char>> Parser<T> {\n               self.ch_is('\\r') { self.bump(); }\n     }\n \n-    fn parse_number(&mut self) -> Result<f64, ParserError> {\n-        let mut neg = 1.0;\n+    fn parse_number(&mut self) -> JsonEvent {\n+        let mut neg = false;\n \n         if self.ch_is('-') {\n             self.bump();\n-            neg = -1.0;\n+            neg = true;\n         }\n \n-        let mut res = try!(self.parse_integer());\n+        let res = match self.parse_u64() {\n+            Ok(res) => res,\n+            Err(e) => { return Error(e); }\n+        };\n \n-        if self.ch_is('.') {\n-            res = try!(self.parse_decimal(res));\n-        }\n+        if self.ch_is('.') || self.ch_is('e') || self.ch_is('E') {\n+            let mut res = res as f64;\n \n-        if self.ch_is('e') || self.ch_is('E') {\n-            res = try!(self.parse_exponent(res));\n-        }\n+            if self.ch_is('.') {\n+                res = match self.parse_decimal(res) {\n+                    Ok(res) => res,\n+                    Err(e) => { return Error(e); }\n+                };\n+            }\n \n-        Ok(neg * res)\n+            if self.ch_is('e') || self.ch_is('E') {\n+                res = match self.parse_exponent(res) {\n+                    Ok(res) => res,\n+                    Err(e) => { return Error(e); }\n+                };\n+            }\n+\n+            if neg {\n+                res *= -1.0;\n+            }\n+\n+            F64Value(res)\n+        } else {\n+            if neg {\n+                let res = -(res as i64);\n+\n+                // Make sure we didn't underflow.\n+                if res > 0 {\n+                    Error(SyntaxError(InvalidNumber, self.line, self.col))\n+                } else {\n+                    I64Value(res)\n+                }\n+            } else {\n+                U64Value(res)\n+            }\n+        }\n     }\n \n-    fn parse_integer(&mut self) -> Result<f64, ParserError> {\n-        let mut res = 0.0;\n+    fn parse_u64(&mut self) -> Result<u64, ParserError> {\n+        let mut accum = 0;\n+        let last_accum = 0; // necessary to detect overflow.\n \n         match self.ch_or_null() {\n             '0' => {\n@@ -1295,8 +1381,12 @@ impl<T: Iterator<char>> Parser<T> {\n                 while !self.eof() {\n                     match self.ch_or_null() {\n                         c @ '0' .. '9' => {\n-                            res *= 10.0;\n-                            res += ((c as int) - ('0' as int)) as f64;\n+                            accum *= 10;\n+                            accum += (c as u64) - ('0' as u64);\n+\n+                            // Detect overflow by comparing to the last value.\n+                            if accum <= last_accum { return self.error(InvalidNumber); }\n+\n                             self.bump();\n                         }\n                         _ => break,\n@@ -1305,7 +1395,8 @@ impl<T: Iterator<char>> Parser<T> {\n             }\n             _ => return self.error(InvalidNumber),\n         }\n-        Ok(res)\n+\n+        Ok(accum)\n     }\n \n     fn parse_decimal(&mut self, mut res: f64) -> Result<f64, ParserError> {\n@@ -1654,10 +1745,7 @@ impl<T: Iterator<char>> Parser<T> {\n             'n' => { self.parse_ident(\"ull\", NullValue) }\n             't' => { self.parse_ident(\"rue\", BooleanValue(true)) }\n             'f' => { self.parse_ident(\"alse\", BooleanValue(false)) }\n-            '0' .. '9' | '-' => match self.parse_number() {\n-                Ok(f) => NumberValue(f),\n-                Err(e) => Error(e),\n-            },\n+            '0' .. '9' | '-' => self.parse_number(),\n             '\"' => match self.parse_str() {\n                 Ok(s) => StringValue(s),\n                 Err(e) => Error(e),\n@@ -1721,7 +1809,9 @@ impl<T: Iterator<char>> Builder<T> {\n     fn build_value(&mut self) -> Result<Json, BuilderError> {\n         return match self.token {\n             Some(NullValue) => { Ok(Null) }\n-            Some(NumberValue(n)) => { Ok(Number(n)) }\n+            Some(I64Value(n)) => { Ok(I64(n)) }\n+            Some(U64Value(n)) => { Ok(U64(n)) }\n+            Some(F64Value(n)) => { Ok(F64(n)) }\n             Some(BooleanValue(b)) => { Ok(Boolean(b)) }\n             Some(StringValue(ref mut s)) => {\n                 let mut temp = String::new();\n@@ -1836,44 +1926,84 @@ macro_rules! expect(\n     })\n )\n \n+macro_rules! read_primitive {\n+    ($name:ident, $ty:ty) => {\n+        fn $name(&mut self) -> DecodeResult<$ty> {\n+            match self.pop() {\n+                I64(f) => {\n+                    match num::cast(f) {\n+                        Some(f) => Ok(f),\n+                        None => Err(ExpectedError(\"Number\".to_string(), format!(\"{}\", f))),\n+                    }\n+                }\n+                U64(f) => {\n+                    match num::cast(f) {\n+                        Some(f) => Ok(f),\n+                        None => Err(ExpectedError(\"Number\".to_string(), format!(\"{}\", f))),\n+                    }\n+                }\n+                F64(f) => {\n+                    match num::cast(f) {\n+                        Some(f) => Ok(f),\n+                        None => Err(ExpectedError(\"Number\".to_string(), format!(\"{}\", f))),\n+                    }\n+                }\n+                String(s) => {\n+                    // re: #12967.. a type w/ numeric keys (ie HashMap<uint, V> etc)\n+                    // is going to have a string here, as per JSON spec.\n+                    match std::from_str::from_str(s.as_slice()) {\n+                        Some(f) => Ok(f),\n+                        None => Err(ExpectedError(\"Number\".to_string(), s)),\n+                    }\n+                },\n+                value => Err(ExpectedError(\"Number\".to_string(), format!(\"{}\", value)))\n+            }\n+        }\n+    }\n+}\n+\n impl ::Decoder<DecoderError> for Decoder {\n     fn read_nil(&mut self) -> DecodeResult<()> {\n         debug!(\"read_nil\");\n         expect!(self.pop(), Null)\n     }\n \n-    fn read_u64(&mut self)  -> DecodeResult<u64 > { Ok(try!(self.read_f64()) as u64) }\n-    fn read_u32(&mut self)  -> DecodeResult<u32 > { Ok(try!(self.read_f64()) as u32) }\n-    fn read_u16(&mut self)  -> DecodeResult<u16 > { Ok(try!(self.read_f64()) as u16) }\n-    fn read_u8 (&mut self)  -> DecodeResult<u8  > { Ok(try!(self.read_f64()) as u8) }\n-    fn read_uint(&mut self) -> DecodeResult<uint> { Ok(try!(self.read_f64()) as uint) }\n+    read_primitive!(read_uint, uint)\n+    read_primitive!(read_u8, u8)\n+    read_primitive!(read_u16, u16)\n+    read_primitive!(read_u32, u32)\n+    read_primitive!(read_u64, u64)\n+    read_primitive!(read_int, int)\n+    read_primitive!(read_i8, i8)\n+    read_primitive!(read_i16, i16)\n+    read_primitive!(read_i32, i32)\n+    read_primitive!(read_i64, i64)\n \n-    fn read_i64(&mut self) -> DecodeResult<i64> { Ok(try!(self.read_f64()) as i64) }\n-    fn read_i32(&mut self) -> DecodeResult<i32> { Ok(try!(self.read_f64()) as i32) }\n-    fn read_i16(&mut self) -> DecodeResult<i16> { Ok(try!(self.read_f64()) as i16) }\n-    fn read_i8 (&mut self) -> DecodeResult<i8 > { Ok(try!(self.read_f64()) as i8) }\n-    fn read_int(&mut self) -> DecodeResult<int> { Ok(try!(self.read_f64()) as int) }\n-\n-    fn read_bool(&mut self) -> DecodeResult<bool> {\n-        debug!(\"read_bool\");\n-        expect!(self.pop(), Boolean)\n-    }\n+    fn read_f32(&mut self) -> DecodeResult<f32> { self.read_f64().map(|x| x as f32) }\n \n     fn read_f64(&mut self) -> DecodeResult<f64> {\n         debug!(\"read_f64\");\n         match self.pop() {\n-            Number(f) => Ok(f),\n+            I64(f) => Ok(f as f64),\n+            U64(f) => Ok(f as f64),\n+            F64(f) => Ok(f),\n             String(s) => {\n                 // re: #12967.. a type w/ numeric keys (ie HashMap<uint, V> etc)\n                 // is going to have a string here, as per JSON spec.\n-                Ok(std::from_str::from_str(s.as_slice()).unwrap())\n+                match std::from_str::from_str(s.as_slice()) {\n+                    Some(f) => Ok(f),\n+                    None => Err(ExpectedError(\"Number\".to_string(), s)),\n+                }\n             },\n             Null => Ok(f64::NAN),\n             value => Err(ExpectedError(\"Number\".to_string(), format!(\"{}\", value)))\n         }\n     }\n \n-    fn read_f32(&mut self) -> DecodeResult<f32> { self.read_f64().map(|x| x as f32) }\n+    fn read_bool(&mut self) -> DecodeResult<bool> {\n+        debug!(\"read_bool\");\n+        expect!(self.pop(), Boolean)\n+    }\n \n     fn read_char(&mut self) -> DecodeResult<char> {\n         let s = try!(self.read_str());\n@@ -2084,15 +2214,25 @@ pub trait ToJson {\n     fn to_json(&self) -> Json;\n }\n \n-macro_rules! to_json_impl(\n+macro_rules! to_json_impl_i64(\n     ($($t:ty), +) => (\n         $(impl ToJson for $t {\n-            fn to_json(&self) -> Json { Number(*self as f64) }\n+            fn to_json(&self) -> Json { I64(*self as i64) }\n         })+\n     )\n )\n \n-to_json_impl!(int, i8, i16, i32, i64, uint, u8, u16, u32, u64)\n+to_json_impl_i64!(int, i8, i16, i32, i64)\n+\n+macro_rules! to_json_impl_u64(\n+    ($($t:ty), +) => (\n+        $(impl ToJson for $t {\n+            fn to_json(&self) -> Json { U64(*self as u64) }\n+        })+\n+    )\n+)\n+\n+to_json_impl_u64!(uint, u8, u16, u32, u64)\n \n impl ToJson for Json {\n     fn to_json(&self) -> Json { self.clone() }\n@@ -2106,7 +2246,7 @@ impl ToJson for f64 {\n     fn to_json(&self) -> Json {\n         match self.classify() {\n             FPNaN | FPInfinite => Null,\n-            _                  => Number(*self)\n+            _                  => F64(*self)\n         }\n     }\n }\n@@ -2210,16 +2350,16 @@ mod tests {\n     extern crate test;\n     use self::test::Bencher;\n     use {Encodable, Decodable};\n-    use super::{Encoder, Decoder, Error, Boolean, Number, List, String, Null,\n+    use super::{Encoder, Decoder, Error, Boolean, I64, U64, F64, List, String, Null,\n                 PrettyEncoder, Object, Json, from_str, ParseError, ExpectedError,\n                 MissingFieldError, UnknownVariantError, DecodeResult, DecoderError,\n                 JsonEvent, Parser, StackElement,\n-                ObjectStart, ObjectEnd, ListStart, ListEnd, BooleanValue, NumberValue, StringValue,\n-                NullValue, SyntaxError, Key, Index, Stack,\n+                ObjectStart, ObjectEnd, ListStart, ListEnd, BooleanValue, U64Value,\n+                F64Value, StringValue, NullValue, SyntaxError, Key, Index, Stack,\n                 InvalidSyntax, InvalidNumber, EOFWhileParsingObject, EOFWhileParsingList,\n                 EOFWhileParsingValue, EOFWhileParsingString, KeyMustBeAString, ExpectedColon,\n                 TrailingCharacters};\n-    use std::{f32, f64, io};\n+    use std::{i64, u64, f32, f64, io};\n     use std::collections::TreeMap;\n \n     #[deriving(PartialEq, Encodable, Decodable, Show)]\n@@ -2264,29 +2404,40 @@ mod tests {\n         assert_eq!(Null.to_pretty_str().into_string(), \"null\".to_string());\n     }\n \n+    #[test]\n+    fn test_write_i64() {\n+        assert_eq!(U64(0).to_string().into_string(), \"0\".to_string());\n+        assert_eq!(U64(0).to_pretty_str().into_string(), \"0\".to_string());\n+\n+        assert_eq!(U64(1234).to_string().into_string(), \"1234\".to_string());\n+        assert_eq!(U64(1234).to_pretty_str().into_string(), \"1234\".to_string());\n+\n+        assert_eq!(I64(-5678).to_string().into_string(), \"-5678\".to_string());\n+        assert_eq!(I64(-5678).to_pretty_str().into_string(), \"-5678\".to_string());\n+    }\n \n     #[test]\n-    fn test_write_number() {\n-        assert_eq!(Number(3.0).to_string().into_string(), \"3\".to_string());\n-        assert_eq!(Number(3.0).to_pretty_str().into_string(), \"3\".to_string());\n+    fn test_write_f64() {\n+        assert_eq!(F64(3.0).to_string().into_string(), \"3\".to_string());\n+        assert_eq!(F64(3.0).to_pretty_str().into_string(), \"3\".to_string());\n \n-        assert_eq!(Number(3.1).to_string().into_string(), \"3.1\".to_string());\n-        assert_eq!(Number(3.1).to_pretty_str().into_string(), \"3.1\".to_string());\n+        assert_eq!(F64(3.1).to_string().into_string(), \"3.1\".to_string());\n+        assert_eq!(F64(3.1).to_pretty_str().into_string(), \"3.1\".to_string());\n \n-        assert_eq!(Number(-1.5).to_string().into_string(), \"-1.5\".to_string());\n-        assert_eq!(Number(-1.5).to_pretty_str().into_string(), \"-1.5\".to_string());\n+        assert_eq!(F64(-1.5).to_string().into_string(), \"-1.5\".to_string());\n+        assert_eq!(F64(-1.5).to_pretty_str().into_string(), \"-1.5\".to_string());\n \n-        assert_eq!(Number(0.5).to_string().into_string(), \"0.5\".to_string());\n-        assert_eq!(Number(0.5).to_pretty_str().into_string(), \"0.5\".to_string());\n+        assert_eq!(F64(0.5).to_string().into_string(), \"0.5\".to_string());\n+        assert_eq!(F64(0.5).to_pretty_str().into_string(), \"0.5\".to_string());\n \n-        assert_eq!(Number(f64::NAN).to_string().into_string(), \"null\".to_string());\n-        assert_eq!(Number(f64::NAN).to_pretty_str().into_string(), \"null\".to_string());\n+        assert_eq!(F64(f64::NAN).to_string().into_string(), \"null\".to_string());\n+        assert_eq!(F64(f64::NAN).to_pretty_str().into_string(), \"null\".to_string());\n \n-        assert_eq!(Number(f64::INFINITY).to_string().into_string(), \"null\".to_string());\n-        assert_eq!(Number(f64::INFINITY).to_pretty_str().into_string(), \"null\".to_string());\n+        assert_eq!(F64(f64::INFINITY).to_string().into_string(), \"null\".to_string());\n+        assert_eq!(F64(f64::INFINITY).to_pretty_str().into_string(), \"null\".to_string());\n \n-        assert_eq!(Number(f64::NEG_INFINITY).to_string().into_string(), \"null\".to_string());\n-        assert_eq!(Number(f64::NEG_INFINITY).to_pretty_str().into_string(), \"null\".to_string());\n+        assert_eq!(F64(f64::NEG_INFINITY).to_string().into_string(), \"null\".to_string());\n+        assert_eq!(F64(f64::NEG_INFINITY).to_pretty_str().into_string(), \"null\".to_string());\n     }\n \n     #[test]\n@@ -2324,7 +2475,7 @@ mod tests {\n         let long_test_list = List(vec![\n             Boolean(false),\n             Null,\n-            List(vec![String(\"foo\\nbar\".to_string()), Number(3.5)])]);\n+            List(vec![String(\"foo\\nbar\".to_string()), F64(3.5)])]);\n \n         assert_eq!(long_test_list.to_string().into_string(),\n             \"[false,null,[\\\"foo\\\\nbar\\\",3.5]]\".to_string());\n@@ -2539,14 +2690,21 @@ mod tests {\n         assert_eq!(from_str(\"1e\"),  Err(SyntaxError(InvalidNumber, 1, 3)));\n         assert_eq!(from_str(\"1e+\"), Err(SyntaxError(InvalidNumber, 1, 4)));\n \n-        assert_eq!(from_str(\"3\"), Ok(Number(3.0)));\n-        assert_eq!(from_str(\"3.1\"), Ok(Number(3.1)));\n-        assert_eq!(from_str(\"-1.2\"), Ok(Number(-1.2)));\n-        assert_eq!(from_str(\"0.4\"), Ok(Number(0.4)));\n-        assert_eq!(from_str(\"0.4e5\"), Ok(Number(0.4e5)));\n-        assert_eq!(from_str(\"0.4e+15\"), Ok(Number(0.4e15)));\n-        assert_eq!(from_str(\"0.4e-01\"), Ok(Number(0.4e-01)));\n-        assert_eq!(from_str(\" 3 \"), Ok(Number(3.0)));\n+        assert_eq!(from_str(\"18446744073709551616\"), Err(SyntaxError(InvalidNumber, 1, 20)));\n+        assert_eq!(from_str(\"-9223372036854775809\"), Err(SyntaxError(InvalidNumber, 1, 21)));\n+\n+        assert_eq!(from_str(\"3\"), Ok(U64(3)));\n+        assert_eq!(from_str(\"3.1\"), Ok(F64(3.1)));\n+        assert_eq!(from_str(\"-1.2\"), Ok(F64(-1.2)));\n+        assert_eq!(from_str(\"0.4\"), Ok(F64(0.4)));\n+        assert_eq!(from_str(\"0.4e5\"), Ok(F64(0.4e5)));\n+        assert_eq!(from_str(\"0.4e+15\"), Ok(F64(0.4e15)));\n+        assert_eq!(from_str(\"0.4e-01\"), Ok(F64(0.4e-01)));\n+        assert_eq!(from_str(\" 3 \"), Ok(U64(3)));\n+\n+        assert_eq!(from_str(\"-9223372036854775808\"), Ok(I64(i64::MIN)));\n+        assert_eq!(from_str(\"9223372036854775807\"), Ok(U64(i64::MAX as u64)));\n+        assert_eq!(from_str(\"18446744073709551615\"), Ok(U64(u64::MAX)));\n     }\n \n     #[test]\n@@ -2571,6 +2729,18 @@ mod tests {\n \n         let v: f64 = super::decode(\"0.4e-01\").unwrap();\n         assert_eq!(v, 0.4e-01);\n+\n+        let v: u64 = super::decode(\"0\").unwrap();\n+        assert_eq!(v, 0);\n+\n+        let v: u64 = super::decode(\"18446744073709551615\").unwrap();\n+        assert_eq!(v, u64::MAX);\n+\n+        let v: i64 = super::decode(\"-9223372036854775808\").unwrap();\n+        assert_eq!(v, i64::MIN);\n+\n+        let v: i64 = super::decode(\"9223372036854775807\").unwrap();\n+        assert_eq!(v, i64::MAX);\n     }\n \n     #[test]\n@@ -2622,11 +2792,11 @@ mod tests {\n         assert_eq!(from_str(\"[ false ]\"), Ok(List(vec![Boolean(false)])));\n         assert_eq!(from_str(\"[null]\"), Ok(List(vec![Null])));\n         assert_eq!(from_str(\"[3, 1]\"),\n-                     Ok(List(vec![Number(3.0), Number(1.0)])));\n+                     Ok(List(vec![U64(3), U64(1)])));\n         assert_eq!(from_str(\"\\n[3, 2]\\n\"),\n-                     Ok(List(vec![Number(3.0), Number(2.0)])));\n+                     Ok(List(vec![U64(3), U64(2)])));\n         assert_eq!(from_str(\"[2, [4, 1]]\"),\n-               Ok(List(vec![Number(2.0), List(vec![Number(4.0), Number(1.0)])])));\n+               Ok(List(vec![U64(2), List(vec![U64(4), U64(1)])])));\n     }\n \n     #[test]\n@@ -2664,7 +2834,7 @@ mod tests {\n \n         assert_eq!(from_str(\"{}\").unwrap(), mk_object([]));\n         assert_eq!(from_str(\"{\\\"a\\\": 3}\").unwrap(),\n-                  mk_object([(\"a\".to_string(), Number(3.0))]));\n+                  mk_object([(\"a\".to_string(), U64(3))]));\n \n         assert_eq!(from_str(\n                       \"{ \\\"a\\\": null, \\\"b\\\" : true }\").unwrap(),\n@@ -2678,7 +2848,7 @@ mod tests {\n         assert_eq!(from_str(\n                       \"{\\\"a\\\" : 1.0 ,\\\"b\\\": [ true ]}\").unwrap(),\n                   mk_object([\n-                      (\"a\".to_string(), Number(1.0)),\n+                      (\"a\".to_string(), F64(1.0)),\n                       (\"b\".to_string(), List(vec![Boolean(true)]))\n                   ]));\n         assert_eq!(from_str(\n@@ -2691,7 +2861,7 @@ mod tests {\n                           ]\\\n                       }\").unwrap(),\n                   mk_object([\n-                      (\"a\".to_string(), Number(1.0)),\n+                      (\"a\".to_string(), F64(1.0)),\n                       (\"b\".to_string(), List(vec![\n                           Boolean(true),\n                           String(\"foo\\nbar\".to_string()),\n@@ -2898,11 +3068,63 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_as_number(){\n+    fn test_is_i64(){\n+        let json_value = from_str(\"-12\").unwrap();\n+        assert!(json_value.is_i64());\n+\n+        let json_value = from_str(\"12\").unwrap();\n+        assert!(!json_value.is_i64());\n+\n+        let json_value = from_str(\"12.0\").unwrap();\n+        assert!(!json_value.is_i64());\n+    }\n+\n+    #[test]\n+    fn test_is_u64(){\n         let json_value = from_str(\"12\").unwrap();\n-        let json_num = json_value.as_number();\n-        let expected_num = 12f64;\n-        assert!(json_num.is_some() && json_num.unwrap() == expected_num);\n+        assert!(json_value.is_u64());\n+\n+        let json_value = from_str(\"-12\").unwrap();\n+        assert!(!json_value.is_u64());\n+\n+        let json_value = from_str(\"12.0\").unwrap();\n+        assert!(!json_value.is_u64());\n+    }\n+\n+    #[test]\n+    fn test_is_f64(){\n+        let json_value = from_str(\"12\").unwrap();\n+        assert!(!json_value.is_f64());\n+\n+        let json_value = from_str(\"-12\").unwrap();\n+        assert!(!json_value.is_f64());\n+\n+        let json_value = from_str(\"12.0\").unwrap();\n+        assert!(json_value.is_f64());\n+\n+        let json_value = from_str(\"-12.0\").unwrap();\n+        assert!(json_value.is_f64());\n+    }\n+\n+    #[test]\n+    fn test_as_i64(){\n+        let json_value = from_str(\"-12\").unwrap();\n+        let json_num = json_value.as_i64();\n+        assert_eq!(json_num, Some(-12));\n+    }\n+\n+    #[test]\n+    fn test_as_u64(){\n+        let json_value = from_str(\"12\").unwrap();\n+        let json_num = json_value.as_u64();\n+        assert_eq!(json_num, Some(12));\n+    }\n+\n+    #[test]\n+    fn test_as_f64(){\n+        let json_value = from_str(\"12.0\").unwrap();\n+        let json_num = json_value.as_f64();\n+        assert_eq!(json_num, Some(12f64));\n     }\n \n     #[test]\n@@ -2953,6 +3175,7 @@ mod tests {\n             _ => {} // it parsed and we are good to go\n         }\n     }\n+\n     #[test]\n     fn test_prettyencode_hashmap_with_numeric_key() {\n         use std::str::from_utf8;\n@@ -2973,6 +3196,7 @@ mod tests {\n             _ => {} // it parsed and we are good to go\n         }\n     }\n+\n     #[test]\n     fn test_hashmap_with_numeric_key_can_handle_double_quote_delimited_key() {\n         use std::collections::HashMap;\n@@ -2986,6 +3210,20 @@ mod tests {\n         let _hm: HashMap<uint, bool> = Decodable::decode(&mut decoder).unwrap();\n     }\n \n+    #[test]\n+    fn test_hashmap_with_numeric_key_will_error_with_string_keys() {\n+        use std::collections::HashMap;\n+        use Decodable;\n+        let json_str = \"{\\\"a\\\":true}\";\n+        let json_obj = match from_str(json_str) {\n+            Err(_) => fail!(\"Unable to parse json_str: {}\", json_str),\n+            Ok(o) => o\n+        };\n+        let mut decoder = Decoder::new(json_obj);\n+        let result: Result<HashMap<uint, bool>, DecoderError> = Decodable::decode(&mut decoder);\n+        assert_eq!(result, Err(ExpectedError(\"Number\".to_string(), \"a\".to_string())));\n+    }\n+\n     fn assert_stream_equal(src: &str,\n                            expected: Vec<(JsonEvent, Vec<StackElement>)>) {\n         let mut parser = Parser::new(src.chars());\n@@ -3007,17 +3245,17 @@ mod tests {\n     #[ignore(cfg(target_word_size = \"32\"))] // FIXME(#14064)\n     fn test_streaming_parser() {\n         assert_stream_equal(\n-            r#\"{ \"foo\":\"bar\", \"array\" : [0, 1, 2,3 ,4,5], \"idents\":[null,true,false]}\"#,\n+            r#\"{ \"foo\":\"bar\", \"array\" : [0, 1, 2, 3, 4, 5], \"idents\":[null,true,false]}\"#,\n             vec![\n                 (ObjectStart,             vec![]),\n                   (StringValue(\"bar\".to_string()),   vec![Key(\"foo\")]),\n                   (ListStart,             vec![Key(\"array\")]),\n-                    (NumberValue(0.0),    vec![Key(\"array\"), Index(0)]),\n-                    (NumberValue(1.0),    vec![Key(\"array\"), Index(1)]),\n-                    (NumberValue(2.0),    vec![Key(\"array\"), Index(2)]),\n-                    (NumberValue(3.0),    vec![Key(\"array\"), Index(3)]),\n-                    (NumberValue(4.0),    vec![Key(\"array\"), Index(4)]),\n-                    (NumberValue(5.0),    vec![Key(\"array\"), Index(5)]),\n+                    (U64Value(0),         vec![Key(\"array\"), Index(0)]),\n+                    (U64Value(1),         vec![Key(\"array\"), Index(1)]),\n+                    (U64Value(2),         vec![Key(\"array\"), Index(2)]),\n+                    (U64Value(3),         vec![Key(\"array\"), Index(3)]),\n+                    (U64Value(4),         vec![Key(\"array\"), Index(4)]),\n+                    (U64Value(5),         vec![Key(\"array\"), Index(5)]),\n                   (ListEnd,               vec![Key(\"array\")]),\n                   (ListStart,             vec![Key(\"idents\")]),\n                     (NullValue,           vec![Key(\"idents\"), Index(0)]),\n@@ -3061,7 +3299,7 @@ mod tests {\n             \"{\\\"a\\\": 3}\",\n             vec![\n                 (ObjectStart,        vec![]),\n-                  (NumberValue(3.0), vec![Key(\"a\")]),\n+                  (U64Value(3),      vec![Key(\"a\")]),\n                 (ObjectEnd,          vec![]),\n             ]\n         );\n@@ -3078,7 +3316,7 @@ mod tests {\n             \"{\\\"a\\\" : 1.0 ,\\\"b\\\": [ true ]}\",\n             vec![\n                 (ObjectStart,           vec![]),\n-                  (NumberValue(1.0),    vec![Key(\"a\")]),\n+                  (F64Value(1.0),       vec![Key(\"a\")]),\n                   (ListStart,           vec![Key(\"b\")]),\n                     (BooleanValue(true),vec![Key(\"b\"), Index(0)]),\n                   (ListEnd,             vec![Key(\"b\")]),\n@@ -3096,7 +3334,7 @@ mod tests {\n             }\"#,\n             vec![\n                 (ObjectStart,                   vec![]),\n-                  (NumberValue(1.0),            vec![Key(\"a\")]),\n+                  (F64Value(1.0),               vec![Key(\"a\")]),\n                   (ListStart,                   vec![Key(\"b\")]),\n                     (BooleanValue(true),        vec![Key(\"b\"), Index(0)]),\n                     (StringValue(\"foo\\nbar\".to_string()),  vec![Key(\"b\"), Index(1)]),\n@@ -3155,30 +3393,30 @@ mod tests {\n             \"[3, 1]\",\n             vec![\n                 (ListStart,     vec![]),\n-                    (NumberValue(3.0), vec![Index(0)]),\n-                    (NumberValue(1.0), vec![Index(1)]),\n+                    (U64Value(3), vec![Index(0)]),\n+                    (U64Value(1), vec![Index(1)]),\n                 (ListEnd,       vec![]),\n             ]\n         );\n         assert_stream_equal(\n             \"\\n[3, 2]\\n\",\n             vec![\n                 (ListStart,     vec![]),\n-                    (NumberValue(3.0), vec![Index(0)]),\n-                    (NumberValue(2.0), vec![Index(1)]),\n+                    (U64Value(3), vec![Index(0)]),\n+                    (U64Value(2), vec![Index(1)]),\n                 (ListEnd,       vec![]),\n             ]\n         );\n         assert_stream_equal(\n             \"[2, [4, 1]]\",\n             vec![\n-                (ListStart,                 vec![]),\n-                    (NumberValue(2.0),      vec![Index(0)]),\n-                    (ListStart,             vec![Index(1)]),\n-                        (NumberValue(4.0),  vec![Index(1), Index(0)]),\n-                        (NumberValue(1.0),  vec![Index(1), Index(1)]),\n-                    (ListEnd,               vec![Index(1)]),\n-                (ListEnd,                   vec![]),\n+                (ListStart,            vec![]),\n+                    (U64Value(2),      vec![Index(0)]),\n+                    (ListStart,        vec![Index(1)]),\n+                        (U64Value(4),  vec![Index(1), Index(0)]),\n+                        (U64Value(1),  vec![Index(1), Index(1)]),\n+                    (ListEnd,          vec![Index(1)]),\n+                (ListEnd,              vec![]),\n             ]\n         );\n \n@@ -3277,50 +3515,51 @@ mod tests {\n         use std::collections::{HashMap,TreeMap};\n         use super::ToJson;\n \n-        let list2 = List(vec!(Number(1.0_f64), Number(2.0_f64)));\n-        let list3 = List(vec!(Number(1.0f64), Number(2.0f64), Number(3.0f64)));\n+        let list2 = List(vec!(U64(1), U64(2)));\n+        let list3 = List(vec!(U64(1), U64(2), U64(3)));\n         let object = {\n             let mut tree_map = TreeMap::new();\n-            tree_map.insert(\"a\".to_string(), Number(1.0_f64));\n-            tree_map.insert(\"b\".to_string(), Number(2.0_f64));\n+            tree_map.insert(\"a\".to_string(), U64(1));\n+            tree_map.insert(\"b\".to_string(), U64(2));\n             Object(tree_map)\n         };\n \n         assert_eq!(list2.to_json(), list2);\n         assert_eq!(object.to_json(), object);\n-        assert_eq!(3_i.to_json(), Number(3.0_f64));\n-        assert_eq!(4_i8.to_json(), Number(4.0_f64));\n-        assert_eq!(5_i16.to_json(), Number(5.0_f64));\n-        assert_eq!(6_i32.to_json(), Number(6.0_f64));\n-        assert_eq!(7_i64.to_json(), Number(7.0_f64));\n-        assert_eq!(8_u.to_json(), Number(8.0_f64));\n-        assert_eq!(9_u8.to_json(), Number(9.0_f64));\n-        assert_eq!(10_u16.to_json(), Number(10.0_f64));\n-        assert_eq!(11_u32.to_json(), Number(11.0_f64));\n-        assert_eq!(12_u64.to_json(), Number(12.0_f64));\n-        assert_eq!(13.0_f32.to_json(), Number(13.0_f64));\n-        assert_eq!(14.0_f64.to_json(), Number(14.0_f64));\n+        assert_eq!(3_i.to_json(), I64(3));\n+        assert_eq!(4_i8.to_json(), I64(4));\n+        assert_eq!(5_i16.to_json(), I64(5));\n+        assert_eq!(6_i32.to_json(), I64(6));\n+        assert_eq!(7_i64.to_json(), I64(7));\n+        assert_eq!(8_u.to_json(), U64(8));\n+        assert_eq!(9_u8.to_json(), U64(9));\n+        assert_eq!(10_u16.to_json(), U64(10));\n+        assert_eq!(11_u32.to_json(), U64(11));\n+        assert_eq!(12_u64.to_json(), U64(12));\n+        assert_eq!(13.0_f32.to_json(), F64(13.0_f64));\n+        assert_eq!(14.0_f64.to_json(), F64(14.0_f64));\n         assert_eq!(().to_json(), Null);\n         assert_eq!(f32::INFINITY.to_json(), Null);\n         assert_eq!(f64::NAN.to_json(), Null);\n         assert_eq!(true.to_json(), Boolean(true));\n         assert_eq!(false.to_json(), Boolean(false));\n         assert_eq!(\"abc\".to_string().to_json(), String(\"abc\".to_string()));\n-        assert_eq!((1i, 2i).to_json(), list2);\n-        assert_eq!((1i, 2i, 3i).to_json(), list3);\n-        assert_eq!([1i, 2].to_json(), list2);\n-        assert_eq!((&[1i, 2, 3]).to_json(), list3);\n-        assert_eq!((vec![1i, 2]).to_json(), list2);\n-        assert_eq!(vec!(1i, 2i, 3i).to_json(), list3);\n+        assert_eq!((1u, 2u).to_json(), list2);\n+        assert_eq!((1u, 2u, 3u).to_json(), list3);\n+        assert_eq!([1u, 2].to_json(), list2);\n+        assert_eq!((&[1u, 2, 3]).to_json(), list3);\n+        assert_eq!((vec![1u, 2]).to_json(), list2);\n+        assert_eq!(vec!(1u, 2, 3).to_json(), list3);\n         let mut tree_map = TreeMap::new();\n-        tree_map.insert(\"a\".to_string(), 1i);\n+        tree_map.insert(\"a\".to_string(), 1u);\n         tree_map.insert(\"b\".to_string(), 2);\n         assert_eq!(tree_map.to_json(), object);\n         let mut hash_map = HashMap::new();\n-        hash_map.insert(\"a\".to_string(), 1i);\n+        hash_map.insert(\"a\".to_string(), 1u);\n         hash_map.insert(\"b\".to_string(), 2);\n         assert_eq!(hash_map.to_json(), object);\n-        assert_eq!(Some(15i).to_json(), Number(15f64));\n+        assert_eq!(Some(15i).to_json(), I64(15));\n+        assert_eq!(Some(15u).to_json(), U64(15));\n         assert_eq!(None::<int>.to_json(), Null);\n     }\n "}, {"sha": "f4b162f0dd8109e6c079ab43f985a7d90a1d9cb1", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0600a3befaad1fa564885a2d3cd3716ce8ecb304/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0600a3befaad1fa564885a2d3cd3716ce8ecb304/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=0600a3befaad1fa564885a2d3cd3716ce8ecb304", "patch": "@@ -1103,8 +1103,8 @@ fn calc_result(desc: &TestDesc, task_succeeded: bool) -> TestResult {\n impl ToJson for Metric {\n     fn to_json(&self) -> json::Json {\n         let mut map = TreeMap::new();\n-        map.insert(\"value\".to_string(), json::Number(self.value));\n-        map.insert(\"noise\".to_string(), json::Number(self.noise));\n+        map.insert(\"value\".to_string(), json::F64(self.value));\n+        map.insert(\"noise\".to_string(), json::F64(self.noise));\n         json::Object(map)\n     }\n }"}]}