{"sha": "ed734609719b0b18906c500c8ce91fc14a61cb19", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVkNzM0NjA5NzE5YjBiMTg5MDZjNTAwYzhjZTkxZmMxNGE2MWNiMTk=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-07-15T15:44:23Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-07-15T15:44:23Z"}, "message": "Folding ranges respect item visibilities", "tree": {"sha": "f86be0685f1e249ad056ebea21667b843646c9d7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f86be0685f1e249ad056ebea21667b843646c9d7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ed734609719b0b18906c500c8ce91fc14a61cb19", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ed734609719b0b18906c500c8ce91fc14a61cb19", "html_url": "https://github.com/rust-lang/rust/commit/ed734609719b0b18906c500c8ce91fc14a61cb19", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ed734609719b0b18906c500c8ce91fc14a61cb19/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "efea07f31c4786945fba076f8acae2ee825975d1", "url": "https://api.github.com/repos/rust-lang/rust/commits/efea07f31c4786945fba076f8acae2ee825975d1", "html_url": "https://github.com/rust-lang/rust/commit/efea07f31c4786945fba076f8acae2ee825975d1"}], "stats": {"total": 161, "additions": 75, "deletions": 86}, "files": [{"sha": "bfb4ce711cb7519b394efbf6fbdceb93a2f99654", "filename": "crates/ide/src/folding_ranges.rs", "status": "modified", "additions": 75, "deletions": 86, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/ed734609719b0b18906c500c8ce91fc14a61cb19/crates%2Fide%2Fsrc%2Ffolding_ranges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed734609719b0b18906c500c8ce91fc14a61cb19/crates%2Fide%2Fsrc%2Ffolding_ranges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Ffolding_ranges.rs?ref=ed734609719b0b18906c500c8ce91fc14a61cb19", "patch": "@@ -1,12 +1,14 @@\n use rustc_hash::FxHashSet;\n \n use syntax::{\n-    ast::{self, AstNode, AstToken, VisibilityOwner},\n-    Direction, NodeOrToken, SourceFile,\n+    ast::{self, AstNode, AstToken},\n+    match_ast, Direction, NodeOrToken, SourceFile,\n     SyntaxKind::{self, *},\n-    SyntaxNode, TextRange, TextSize,\n+    TextRange, TextSize,\n };\n \n+use std::hash::Hash;\n+\n const REGION_START: &str = \"// region:\";\n const REGION_END: &str = \"// endregion\";\n \n@@ -84,46 +86,39 @@ pub(crate) fn folding_ranges(file: &SourceFile) -> Vec<Fold> {\n                 }\n             }\n             NodeOrToken::Node(node) => {\n-                // Fold groups of imports\n-                if node.kind() == USE && !visited_imports.contains(&node) {\n-                    if let Some(range) = contiguous_range_for_group(&node, &mut visited_imports) {\n-                        res.push(Fold { range, kind: FoldKind::Imports })\n-                    }\n-                }\n-\n-                // Fold groups of mods\n-                if let Some(module) = ast::Module::cast(node.clone()) {\n-                    if !has_visibility(&node)\n-                        && !visited_mods.contains(&node)\n-                        && module.item_list().is_none()\n-                    {\n-                        if let Some(range) = contiguous_range_for_group_unless(\n-                            &node,\n-                            has_visibility,\n-                            &mut visited_mods,\n-                        ) {\n-                            res.push(Fold { range, kind: FoldKind::Mods })\n-                        }\n-                    }\n-                }\n-\n-                // Fold groups of consts\n-                if node.kind() == CONST && !visited_consts.contains(&node) {\n-                    if let Some(range) = contiguous_range_for_group(&node, &mut visited_consts) {\n-                        res.push(Fold { range, kind: FoldKind::Consts })\n-                    }\n-                }\n-                // Fold groups of consts\n-                if node.kind() == STATIC && !visited_statics.contains(&node) {\n-                    if let Some(range) = contiguous_range_for_group(&node, &mut visited_statics) {\n-                        res.push(Fold { range, kind: FoldKind::Statics })\n-                    }\n-                }\n-\n-                // Fold where clause\n-                if node.kind() == WHERE_CLAUSE {\n-                    if let Some(range) = fold_range_for_where_clause(&node) {\n-                        res.push(Fold { range, kind: FoldKind::WhereClause })\n+                match_ast! {\n+                    match node {\n+                        ast::Module(module) => {\n+                            if module.item_list().is_none() {\n+                                if let Some(range) = contiguous_range_for_item_group(\n+                                    module,\n+                                    &mut visited_mods,\n+                                ) {\n+                                    res.push(Fold { range, kind: FoldKind::Mods })\n+                                }\n+                            }\n+                        },\n+                        ast::Use(use_) => {\n+                            if let Some(range) = contiguous_range_for_item_group(use_, &mut visited_imports) {\n+                                res.push(Fold { range, kind: FoldKind::Imports })\n+                            }\n+                        },\n+                        ast::Const(konst) => {\n+                            if let Some(range) = contiguous_range_for_item_group(konst, &mut visited_consts) {\n+                                res.push(Fold { range, kind: FoldKind::Consts })\n+                            }\n+                        },\n+                        ast::Static(statik) => {\n+                            if let Some(range) = contiguous_range_for_item_group(statik, &mut visited_statics) {\n+                                res.push(Fold { range, kind: FoldKind::Statics })\n+                            }\n+                        },\n+                        ast::WhereClause(where_clause) => {\n+                            if let Some(range) = fold_range_for_where_clause(where_clause) {\n+                                res.push(Fold { range, kind: FoldKind::WhereClause })\n+                            }\n+                        },\n+                        _ => (),\n                     }\n                 }\n             }\n@@ -154,26 +149,16 @@ fn fold_kind(kind: SyntaxKind) -> Option<FoldKind> {\n     }\n }\n \n-fn has_visibility(node: &SyntaxNode) -> bool {\n-    ast::Module::cast(node.clone()).and_then(|m| m.visibility()).is_some()\n-}\n-\n-fn contiguous_range_for_group(\n-    first: &SyntaxNode,\n-    visited: &mut FxHashSet<SyntaxNode>,\n-) -> Option<TextRange> {\n-    contiguous_range_for_group_unless(first, |_| false, visited)\n-}\n-\n-fn contiguous_range_for_group_unless(\n-    first: &SyntaxNode,\n-    unless: impl Fn(&SyntaxNode) -> bool,\n-    visited: &mut FxHashSet<SyntaxNode>,\n-) -> Option<TextRange> {\n-    visited.insert(first.clone());\n+fn contiguous_range_for_item_group<N>(first: N, visited: &mut FxHashSet<N>) -> Option<TextRange>\n+where\n+    N: ast::VisibilityOwner + Clone + Hash + Eq,\n+{\n+    if !visited.insert(first.clone()) {\n+        return None;\n+    }\n \n-    let mut last = first.clone();\n-    for element in first.siblings_with_tokens(Direction::Next) {\n+    let (mut last, mut last_vis) = (first.clone(), first.visibility());\n+    for element in first.syntax().siblings_with_tokens(Direction::Next) {\n         let node = match element {\n             NodeOrToken::Token(token) => {\n                 if let Some(ws) = ast::Whitespace::cast(token) {\n@@ -189,23 +174,35 @@ fn contiguous_range_for_group_unless(\n             NodeOrToken::Node(node) => node,\n         };\n \n-        // Stop if we find a node that doesn't belong to the group\n-        if node.kind() != first.kind() || unless(&node) {\n-            break;\n+        if let Some(next) = N::cast(node) {\n+            let next_vis = next.visibility();\n+            if eq_visibility(next_vis.clone(), last_vis) {\n+                visited.insert(next.clone());\n+                last_vis = next_vis;\n+                last = next;\n+                continue;\n+            }\n         }\n-\n-        visited.insert(node.clone());\n-        last = node;\n+        // Stop if we find an item of a different kind or with a different visibility.\n+        break;\n     }\n \n-    if first != &last {\n-        Some(TextRange::new(first.text_range().start(), last.text_range().end()))\n+    if first != last {\n+        Some(TextRange::new(first.syntax().text_range().start(), last.syntax().text_range().end()))\n     } else {\n         // The group consists of only one element, therefore it cannot be folded\n         None\n     }\n }\n \n+fn eq_visibility(vis0: Option<ast::Visibility>, vis1: Option<ast::Visibility>) -> bool {\n+    match (vis0, vis1) {\n+        (None, None) => true,\n+        (Some(vis0), Some(vis1)) => vis0.is_eq_to(&vis1),\n+        _ => false,\n+    }\n+}\n+\n fn contiguous_range_for_comment(\n     first: ast::Comment,\n     visited: &mut FxHashSet<ast::Comment>,\n@@ -230,12 +227,9 @@ fn contiguous_range_for_comment(\n                 }\n                 if let Some(c) = ast::Comment::cast(token) {\n                     if c.kind() == group_kind {\n+                        let text = c.text().trim_start();\n                         // regions are not real comments\n-                        if c.text().trim().starts_with(\"// region:\")\n-                            || c.text().trim().starts_with(\"// endregion\")\n-                        {\n-                            break;\n-                        } else {\n+                        if !(text.starts_with(REGION_START) || text.starts_with(REGION_END)) {\n                             visited.insert(c.clone());\n                             last = c;\n                             continue;\n@@ -259,19 +253,14 @@ fn contiguous_range_for_comment(\n     }\n }\n \n-fn fold_range_for_where_clause(node: &SyntaxNode) -> Option<TextRange> {\n-    let first_where_pred = node.first_child();\n-    let last_where_pred = node.last_child();\n+fn fold_range_for_where_clause(where_clause: ast::WhereClause) -> Option<TextRange> {\n+    let first_where_pred = where_clause.predicates().next();\n+    let last_where_pred = where_clause.predicates().last();\n \n     if first_where_pred != last_where_pred {\n-        let mut it = node.descendants_with_tokens();\n-        if let (Some(_where_clause), Some(where_kw), Some(last_comma)) =\n-            (it.next(), it.next(), it.last())\n-        {\n-            let start = where_kw.text_range().end();\n-            let end = last_comma.text_range().end();\n-            return Some(TextRange::new(start, end));\n-        }\n+        let start = where_clause.where_token()?.text_range().end();\n+        let end = where_clause.syntax().text_range().end();\n+        return Some(TextRange::new(start, end));\n     }\n     None\n }"}]}