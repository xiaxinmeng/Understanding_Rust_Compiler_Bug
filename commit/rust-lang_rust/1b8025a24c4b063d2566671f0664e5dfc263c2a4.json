{"sha": "1b8025a24c4b063d2566671f0664e5dfc263c2a4", "node_id": "C_kwDOAAsO6NoAKDFiODAyNWEyNGM0YjA2M2QyNTY2NjcxZjA2NjRlNWRmYzI2M2MyYTQ", "commit": {"author": {"name": "Thom Chiovoloni", "email": "thom@shift.click", "date": "2022-08-29T22:36:01Z"}, "committer": {"name": "Thom Chiovoloni", "email": "thom@shift.click", "date": "2022-08-29T22:59:34Z"}, "message": "Fix some possible UB in std::sys::windows", "tree": {"sha": "92d1de58eb59e88e8d3f5887e6a3dfed62a41b2c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/92d1de58eb59e88e8d3f5887e6a3dfed62a41b2c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1b8025a24c4b063d2566671f0664e5dfc263c2a4", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niHUEABYKAB0WIQQszICQ1r0Zqrp7OLPXcz0dendfCgUCYw1E2QAKCRDXcz0dendf\nCj+mAP4+1j2FM9lYGxpNHj/VJgLOXCCDfDr9/S9fBKfORWurCgEA8DjmtfXKpbwK\nLLwI/SCRYX88y8TKqcyyCbUFmf8v5w0=\n=gm9H\n-----END PGP SIGNATURE-----", "payload": "tree 92d1de58eb59e88e8d3f5887e6a3dfed62a41b2c\nparent fcc2bddd262b26c3a4aeff2328e39b8e2b6d3254\nauthor Thom Chiovoloni <thom@shift.click> 1661812561 -0700\ncommitter Thom Chiovoloni <thom@shift.click> 1661813974 -0700\n\nFix some possible UB in std::sys::windows\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1b8025a24c4b063d2566671f0664e5dfc263c2a4", "html_url": "https://github.com/rust-lang/rust/commit/1b8025a24c4b063d2566671f0664e5dfc263c2a4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1b8025a24c4b063d2566671f0664e5dfc263c2a4/comments", "author": {"login": "thomcc", "id": 860665, "node_id": "MDQ6VXNlcjg2MDY2NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/860665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thomcc", "html_url": "https://github.com/thomcc", "followers_url": "https://api.github.com/users/thomcc/followers", "following_url": "https://api.github.com/users/thomcc/following{/other_user}", "gists_url": "https://api.github.com/users/thomcc/gists{/gist_id}", "starred_url": "https://api.github.com/users/thomcc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thomcc/subscriptions", "organizations_url": "https://api.github.com/users/thomcc/orgs", "repos_url": "https://api.github.com/users/thomcc/repos", "events_url": "https://api.github.com/users/thomcc/events{/privacy}", "received_events_url": "https://api.github.com/users/thomcc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "thomcc", "id": 860665, "node_id": "MDQ6VXNlcjg2MDY2NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/860665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thomcc", "html_url": "https://github.com/thomcc", "followers_url": "https://api.github.com/users/thomcc/followers", "following_url": "https://api.github.com/users/thomcc/following{/other_user}", "gists_url": "https://api.github.com/users/thomcc/gists{/gist_id}", "starred_url": "https://api.github.com/users/thomcc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thomcc/subscriptions", "organizations_url": "https://api.github.com/users/thomcc/orgs", "repos_url": "https://api.github.com/users/thomcc/repos", "events_url": "https://api.github.com/users/thomcc/events{/privacy}", "received_events_url": "https://api.github.com/users/thomcc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fcc2bddd262b26c3a4aeff2328e39b8e2b6d3254", "url": "https://api.github.com/repos/rust-lang/rust/commits/fcc2bddd262b26c3a4aeff2328e39b8e2b6d3254", "html_url": "https://github.com/rust-lang/rust/commit/fcc2bddd262b26c3a4aeff2328e39b8e2b6d3254"}], "stats": {"total": 87, "additions": 71, "deletions": 16}, "files": [{"sha": "865e2ad4b4347c19a8d5584d2784b1c9073a04d6", "filename": "library/std/src/sys/windows/c.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1b8025a24c4b063d2566671f0664e5dfc263c2a4/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b8025a24c4b063d2566671f0664e5dfc263c2a4/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs?ref=1b8025a24c4b063d2566671f0664e5dfc263c2a4", "patch": "@@ -503,6 +503,8 @@ pub struct FILE_END_OF_FILE_INFO {\n     pub EndOfFile: LARGE_INTEGER,\n }\n \n+/// NB: Use carefully! In general using this as a reference is likely to get the\n+/// provenance wrong for the `rest` field!\n #[repr(C)]\n pub struct REPARSE_DATA_BUFFER {\n     pub ReparseTag: c_uint,\n@@ -511,6 +513,8 @@ pub struct REPARSE_DATA_BUFFER {\n     pub rest: (),\n }\n \n+/// NB: Use carefully! In general using this as a reference is likely to get the\n+/// provenance wrong for the `PathBuffer` field!\n #[repr(C)]\n pub struct SYMBOLIC_LINK_REPARSE_BUFFER {\n     pub SubstituteNameOffset: c_ushort,\n@@ -521,6 +525,8 @@ pub struct SYMBOLIC_LINK_REPARSE_BUFFER {\n     pub PathBuffer: WCHAR,\n }\n \n+/// NB: Use carefully! In general using this as a reference is likely to get the\n+/// provenance wrong for the `PathBuffer` field!\n #[repr(C)]\n pub struct MOUNT_POINT_REPARSE_BUFFER {\n     pub SubstituteNameOffset: c_ushort,"}, {"sha": "01f914617a073c459d4cc1b9a860f6f51925ae7d", "filename": "library/std/src/sys/windows/fs.rs", "status": "modified", "additions": 24, "deletions": 16, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/1b8025a24c4b063d2566671f0664e5dfc263c2a4/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b8025a24c4b063d2566671f0664e5dfc263c2a4/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs?ref=1b8025a24c4b063d2566671f0664e5dfc263c2a4", "patch": "@@ -11,7 +11,7 @@ use crate::slice;\n use crate::sync::Arc;\n use crate::sys::handle::Handle;\n use crate::sys::time::SystemTime;\n-use crate::sys::{c, cvt};\n+use crate::sys::{c, cvt, AlignedAs};\n use crate::sys_common::{AsInner, FromInner, IntoInner};\n use crate::thread;\n \n@@ -47,6 +47,9 @@ pub struct ReadDir {\n     first: Option<c::WIN32_FIND_DATAW>,\n }\n \n+type AlignedReparseBuf =\n+    AlignedAs<c::REPARSE_DATA_BUFFER, [u8; c::MAXIMUM_REPARSE_DATA_BUFFER_SIZE]>;\n+\n struct FindNextFileHandle(c::HANDLE);\n \n unsafe impl Send for FindNextFileHandle {}\n@@ -326,9 +329,9 @@ impl File {\n             cvt(c::GetFileInformationByHandle(self.handle.as_raw_handle(), &mut info))?;\n             let mut reparse_tag = 0;\n             if info.dwFileAttributes & c::FILE_ATTRIBUTE_REPARSE_POINT != 0 {\n-                let mut b = [0; c::MAXIMUM_REPARSE_DATA_BUFFER_SIZE];\n+                let mut b = AlignedReparseBuf::new([0u8; c::MAXIMUM_REPARSE_DATA_BUFFER_SIZE]);\n                 if let Ok((_, buf)) = self.reparse_point(&mut b) {\n-                    reparse_tag = buf.ReparseTag;\n+                    reparse_tag = (*buf).ReparseTag;\n                 }\n             }\n             Ok(FileAttr {\n@@ -389,7 +392,7 @@ impl File {\n             attr.file_size = info.AllocationSize as u64;\n             attr.number_of_links = Some(info.NumberOfLinks);\n             if attr.file_type().is_reparse_point() {\n-                let mut b = [0; c::MAXIMUM_REPARSE_DATA_BUFFER_SIZE];\n+                let mut b = AlignedReparseBuf::new([0; c::MAXIMUM_REPARSE_DATA_BUFFER_SIZE]);\n                 if let Ok((_, buf)) = self.reparse_point(&mut b) {\n                     attr.reparse_tag = buf.ReparseTag;\n                 }\n@@ -458,10 +461,13 @@ impl File {\n         Ok(Self { handle: self.handle.try_clone()? })\n     }\n \n-    fn reparse_point<'a>(\n+    // NB: returned pointer is derived from `space`, and has provenance to\n+    // match. A raw pointer is returned rather than a reference in order to\n+    // avoid narrowing provenance to the actual `REPARSE_DATA_BUFFER`.\n+    fn reparse_point(\n         &self,\n-        space: &'a mut [u8; c::MAXIMUM_REPARSE_DATA_BUFFER_SIZE],\n-    ) -> io::Result<(c::DWORD, &'a c::REPARSE_DATA_BUFFER)> {\n+        space: &mut AlignedReparseBuf,\n+    ) -> io::Result<(c::DWORD, *const c::REPARSE_DATA_BUFFER)> {\n         unsafe {\n             let mut bytes = 0;\n             cvt({\n@@ -470,36 +476,38 @@ impl File {\n                     c::FSCTL_GET_REPARSE_POINT,\n                     ptr::null_mut(),\n                     0,\n-                    space.as_mut_ptr() as *mut _,\n-                    space.len() as c::DWORD,\n+                    space.value.as_mut_ptr() as *mut _,\n+                    space.value.len() as c::DWORD,\n                     &mut bytes,\n                     ptr::null_mut(),\n                 )\n             })?;\n-            Ok((bytes, &*(space.as_ptr() as *const c::REPARSE_DATA_BUFFER)))\n+            Ok((bytes, space.value.as_ptr().cast::<c::REPARSE_DATA_BUFFER>()))\n         }\n     }\n \n     fn readlink(&self) -> io::Result<PathBuf> {\n-        let mut space = [0u8; c::MAXIMUM_REPARSE_DATA_BUFFER_SIZE];\n+        let mut space = AlignedReparseBuf::new([0u8; c::MAXIMUM_REPARSE_DATA_BUFFER_SIZE]);\n         let (_bytes, buf) = self.reparse_point(&mut space)?;\n         unsafe {\n-            let (path_buffer, subst_off, subst_len, relative) = match buf.ReparseTag {\n+            let (path_buffer, subst_off, subst_len, relative) = match (*buf).ReparseTag {\n                 c::IO_REPARSE_TAG_SYMLINK => {\n                     let info: *const c::SYMBOLIC_LINK_REPARSE_BUFFER =\n-                        &buf.rest as *const _ as *const _;\n+                        ptr::addr_of!((*buf).rest).cast();\n+                    assert!(info.is_aligned());\n                     (\n-                        &(*info).PathBuffer as *const _ as *const u16,\n+                        ptr::addr_of!((*info).PathBuffer).cast::<u16>(),\n                         (*info).SubstituteNameOffset / 2,\n                         (*info).SubstituteNameLength / 2,\n                         (*info).Flags & c::SYMLINK_FLAG_RELATIVE != 0,\n                     )\n                 }\n                 c::IO_REPARSE_TAG_MOUNT_POINT => {\n                     let info: *const c::MOUNT_POINT_REPARSE_BUFFER =\n-                        &buf.rest as *const _ as *const _;\n+                        ptr::addr_of!((*buf).rest).cast();\n+                    assert!(info.is_aligned());\n                     (\n-                        &(*info).PathBuffer as *const _ as *const u16,\n+                        ptr::addr_of!((*info).PathBuffer).cast::<u16>(),\n                         (*info).SubstituteNameOffset / 2,\n                         (*info).SubstituteNameLength / 2,\n                         false,"}, {"sha": "fbbc5cb79fb8b7b671e04f46c50e917d56f5a39d", "filename": "library/std/src/sys/windows/mod.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1b8025a24c4b063d2566671f0664e5dfc263c2a4/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b8025a24c4b063d2566671f0664e5dfc263c2a4/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fmod.rs?ref=1b8025a24c4b063d2566671f0664e5dfc263c2a4", "patch": "@@ -329,3 +329,26 @@ pub fn abort_internal() -> ! {\n     }\n     crate::intrinsics::abort();\n }\n+\n+/// Used for some win32 buffers which are stack allocated, for example:\n+/// `AlignedAs<c::REPARSE_DATA_BUFFER, [u8; c::MAXIMUM_REPARSE_DATA_BUFFER_SIZE]>`\n+#[repr(C)]\n+#[derive(Copy, Clone)]\n+pub struct AlignedAs<Aligner, Alignee: ?Sized> {\n+    /// Use `[Aligner; 0]` as a sort of `PhantomAlignNextField<Aligner>`. This\n+    /// is a bit of a hack, and could break (in a way that's caught by tests) if\n+    /// #81996 is fixed.\n+    aligner: [Aligner; 0],\n+    /// The aligned value. Public rather than exposed via accessors so that if\n+    /// needed it can be used with `addr_of` and such (also, this is less code).\n+    pub value: Alignee,\n+}\n+\n+impl<Aligner, Alignee> AlignedAs<Aligner, Alignee> {\n+    // This is frequently used with large stack buffers, so force-inline to\n+    // try and avoid using 2x as much stack space in debug builds.\n+    #[inline(always)]\n+    pub const fn new(value: Alignee) -> Self {\n+        Self { aligner: [], value }\n+    }\n+}"}, {"sha": "532be0cf083ba0900467ff458fc5482c0dde62bd", "filename": "library/std/src/sys/windows/os/tests.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1b8025a24c4b063d2566671f0664e5dfc263c2a4/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fos%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b8025a24c4b063d2566671f0664e5dfc263c2a4/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fos%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fos%2Ftests.rs?ref=1b8025a24c4b063d2566671f0664e5dfc263c2a4", "patch": "@@ -11,3 +11,21 @@ fn ntstatus_error() {\n             .contains(\"FormatMessageW() returned error\")\n     );\n }\n+\n+#[test]\n+fn smoketest_aligned_as() {\n+    use crate::{\n+        mem::{align_of, size_of},\n+        ptr::addr_of,\n+        sys::{c, AlignedAs},\n+    };\n+    type AlignedReparseBuf =\n+        AlignedAs<c::REPARSE_DATA_BUFFER, [u8; c::MAXIMUM_REPARSE_DATA_BUFFER_SIZE]>;\n+    assert!(size_of::<AlignedReparseBuf>() >= c::MAXIMUM_REPARSE_DATA_BUFFER_SIZE);\n+    assert_eq!(align_of::<AlignedReparseBuf>(), align_of::<c::REPARSE_DATA_BUFFER>());\n+    let a = AlignedReparseBuf::new([0u8; c::MAXIMUM_REPARSE_DATA_BUFFER_SIZE]);\n+    // Quick and dirty offsetof check.\n+    assert_eq!(addr_of!(a).cast::<u8>(), addr_of!(a.value).cast::<u8>());\n+    // Smoke check that it's actually aligned.\n+    assert!(addr_of!(a.value).is_aligned_to(align_of::<c::REPARSE_DATA_BUFFER>()));\n+}"}]}