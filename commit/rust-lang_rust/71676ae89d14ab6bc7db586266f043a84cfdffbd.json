{"sha": "71676ae89d14ab6bc7db586266f043a84cfdffbd", "node_id": "C_kwDOAAsO6NoAKDcxNjc2YWU4OWQxNGFiNmJjN2RiNTg2MjY2ZjA0M2E4NGNmZGZmYmQ", "commit": {"author": {"name": "Wang Ruochen", "email": "wrc@ruo-chen.wang", "date": "2021-12-19T17:26:52Z"}, "committer": {"name": "Wang Ruochen", "email": "wrc@ruo-chen.wang", "date": "2021-12-19T17:26:52Z"}, "message": "Support \"move if to guard\" for if else chains", "tree": {"sha": "110de9b77c238f2a785db145b46cb781c577aee4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/110de9b77c238f2a785db145b46cb781c577aee4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/71676ae89d14ab6bc7db586266f043a84cfdffbd", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQEzBAABCAAdFiEEaiSth+M9lPoQjHQDxt6lcKOwJvwFAmG/a34ACgkQxt6lcKOw\nJvz2YAf8CYs6Rl8PHCQijFEJW6WM8yiy1/Ycmlep0rliqiiTjRX2Ioh5nUzzXt4W\n08ksnnLb/1QpCNsH6NSw82gT7EX7rKPcQp5N5gNyN1TBN1m2i4CdkopXKtaNA1eA\npzOKXugNwS+8t1j0e1g1vYweDs2IOHt1tkRj+HwzU5LdIaHfgL/OsOZ4HEb/YqKV\n+QbimixDP+KYnt1wOAiuysEzHny87Iylq96yrOZ1EKGVuzx4NUPsc8FVRipyf8kb\nHCcIYb+cHT4vd4toAkIfriLy/Rvg0h8qak05Jm3jiSjdy9bhd4BEduJtYkT+LJ52\nsBGEuP+iCK6V6ERysKSJY+yDb2AbZQ==\n=asrn\n-----END PGP SIGNATURE-----", "payload": "tree 110de9b77c238f2a785db145b46cb781c577aee4\nparent 638cc3e59f09b20e6ca6965ab1f3936e2467c497\nauthor Wang Ruochen <wrc@ruo-chen.wang> 1639934812 -0800\ncommitter Wang Ruochen <wrc@ruo-chen.wang> 1639934812 -0800\n\nSupport \"move if to guard\" for if else chains\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/71676ae89d14ab6bc7db586266f043a84cfdffbd", "html_url": "https://github.com/rust-lang/rust/commit/71676ae89d14ab6bc7db586266f043a84cfdffbd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/71676ae89d14ab6bc7db586266f043a84cfdffbd/comments", "author": {"login": "weirane", "id": 37568244, "node_id": "MDQ6VXNlcjM3NTY4MjQ0", "avatar_url": "https://avatars.githubusercontent.com/u/37568244?v=4", "gravatar_id": "", "url": "https://api.github.com/users/weirane", "html_url": "https://github.com/weirane", "followers_url": "https://api.github.com/users/weirane/followers", "following_url": "https://api.github.com/users/weirane/following{/other_user}", "gists_url": "https://api.github.com/users/weirane/gists{/gist_id}", "starred_url": "https://api.github.com/users/weirane/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/weirane/subscriptions", "organizations_url": "https://api.github.com/users/weirane/orgs", "repos_url": "https://api.github.com/users/weirane/repos", "events_url": "https://api.github.com/users/weirane/events{/privacy}", "received_events_url": "https://api.github.com/users/weirane/received_events", "type": "User", "site_admin": false}, "committer": {"login": "weirane", "id": 37568244, "node_id": "MDQ6VXNlcjM3NTY4MjQ0", "avatar_url": "https://avatars.githubusercontent.com/u/37568244?v=4", "gravatar_id": "", "url": "https://api.github.com/users/weirane", "html_url": "https://github.com/weirane", "followers_url": "https://api.github.com/users/weirane/followers", "following_url": "https://api.github.com/users/weirane/following{/other_user}", "gists_url": "https://api.github.com/users/weirane/gists{/gist_id}", "starred_url": "https://api.github.com/users/weirane/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/weirane/subscriptions", "organizations_url": "https://api.github.com/users/weirane/orgs", "repos_url": "https://api.github.com/users/weirane/repos", "events_url": "https://api.github.com/users/weirane/events{/privacy}", "received_events_url": "https://api.github.com/users/weirane/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "638cc3e59f09b20e6ca6965ab1f3936e2467c497", "url": "https://api.github.com/repos/rust-lang/rust/commits/638cc3e59f09b20e6ca6965ab1f3936e2467c497", "html_url": "https://github.com/rust-lang/rust/commit/638cc3e59f09b20e6ca6965ab1f3936e2467c497"}], "stats": {"total": 350, "additions": 292, "deletions": 58}, "files": [{"sha": "58c37471e63e386ef994f9eb3e598dd46a7c849f", "filename": "crates/ide_assists/src/handlers/move_guard.rs", "status": "modified", "additions": 292, "deletions": 58, "changes": 350, "blob_url": "https://github.com/rust-lang/rust/blob/71676ae89d14ab6bc7db586266f043a84cfdffbd/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fmove_guard.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71676ae89d14ab6bc7db586266f043a84cfdffbd/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fmove_guard.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fmove_guard.rs?ref=71676ae89d14ab6bc7db586266f043a84cfdffbd", "patch": "@@ -1,7 +1,8 @@\n use syntax::{\n-    ast::{edit::AstNodeEdit, make, AstNode, BlockExpr, ElseBranch, Expr, IfExpr, MatchArm},\n-    NodeOrToken,\n-    SyntaxKind::{COMMA, WHITESPACE},\n+    ast::{\n+        edit::AstNodeEdit, make, AstNode, BlockExpr, Condition, ElseBranch, Expr, IfExpr, MatchArm,\n+    },\n+    SyntaxKind::WHITESPACE,\n };\n \n use crate::{AssistContext, AssistId, AssistKind, Assists};\n@@ -115,73 +116,119 @@ pub(crate) fn move_arm_cond_to_match_guard(acc: &mut Assists, ctx: &AssistContex\n         }\n     })?;\n     let replace_node = replace_node.unwrap_or_else(|| if_expr.syntax().clone());\n-\n-    let cond = if_expr.condition()?;\n-    let then_block = if_expr.then_branch()?;\n-\n-    // Not support moving if let to arm guard\n-    if cond.is_pattern_cond() {\n-        return None;\n-    }\n-\n-    let buf = format!(\" if {}\", cond.syntax().text());\n-\n+    // Dedent if if_expr is in a BlockExpr\n+    let dedent = if replace_node != *if_expr.syntax() {\n+        cov_mark::hit!(move_guard_ifelse_in_block);\n+        1\n+    } else {\n+        cov_mark::hit!(move_guard_ifelse_else_block);\n+        0\n+    };\n+\n+    let (conds_blocks, tail) = parse_if_chain(if_expr)?;\n+\n+    let then_arm_end = match_arm.syntax().text_range().end();\n+    let indent_level = match_arm.indent_level();\n+    let spaces = \"    \".repeat(indent_level.0 as _);\n     acc.add(\n         AssistId(\"move_arm_cond_to_match_guard\", AssistKind::RefactorRewrite),\n         \"Move condition to match guard\",\n         replace_node.text_range(),\n         |edit| {\n-            let then_only_expr = then_block.statements().next().is_none();\n-\n-            match &then_block.tail_expr() {\n-                Some(then_expr) if then_only_expr => {\n-                    edit.replace(replace_node.text_range(), then_expr.syntax().text());\n-                    // Insert comma for expression if there isn't one\n-                    match match_arm.syntax().last_child_or_token() {\n-                        Some(NodeOrToken::Token(t)) if t.kind() == COMMA => {}\n-                        _ => {\n-                            cov_mark::hit!(move_guard_if_add_comma);\n-                            edit.insert(match_arm.syntax().text_range().end(), \",\");\n-                        }\n-                    }\n+            edit.delete(match_arm.syntax().text_range());\n+            let mut first = true;\n+            for (cond, block) in conds_blocks {\n+                if !first {\n+                    edit.insert(then_arm_end, format!(\"\\n{}\", spaces));\n+                } else {\n+                    first = false;\n                 }\n-                _ if replace_node != *if_expr.syntax() => {\n-                    // Dedent because if_expr is in a BlockExpr\n-                    let replace_with = then_block.dedent(1.into()).syntax().text();\n-                    edit.replace(replace_node.text_range(), replace_with)\n-                }\n-                _ => edit.replace(replace_node.text_range(), then_block.syntax().text()),\n-            }\n-\n-            edit.insert(match_pat.syntax().text_range().end(), buf);\n-\n-            // If with only an else branch\n-            if let Some(ElseBranch::Block(else_block)) = if_expr.else_branch() {\n-                let then_arm_end = match_arm.syntax().text_range().end();\n-                let else_only_expr = else_block.statements().next().is_none();\n-                let indent_level = match_arm.indent_level();\n-                let spaces = \"    \".repeat(indent_level.0 as _);\n-                edit.insert(then_arm_end, format!(\"\\n{}{} => \", spaces, match_pat));\n-                match &else_block.tail_expr() {\n-                    Some(else_expr) if else_only_expr => {\n-                        cov_mark::hit!(move_guard_ifelse_expr_only);\n-                        edit.insert(then_arm_end, else_expr.syntax().text());\n+                let guard = format!(\"{} if {} => \", match_pat, cond.syntax().text());\n+                edit.insert(then_arm_end, guard);\n+                let only_expr = block.statements().next().is_none();\n+                match &block.tail_expr() {\n+                    Some(then_expr) if only_expr => {\n+                        edit.insert(then_arm_end, then_expr.syntax().text());\n                         edit.insert(then_arm_end, \",\");\n                     }\n-                    _ if replace_node != *if_expr.syntax() => {\n-                        cov_mark::hit!(move_guard_ifelse_in_block);\n-                        edit.insert(then_arm_end, else_block.dedent(1.into()).syntax().text());\n-                    }\n                     _ => {\n-                        cov_mark::hit!(move_guard_ifelse_else_block);\n-                        edit.insert(then_arm_end, else_block.syntax().text());\n+                        let to_insert = block.dedent(dedent.into()).syntax().text();\n+                        edit.insert(then_arm_end, to_insert)\n+                    }\n+                }\n+            }\n+            match tail {\n+                Some(Tail::IfLet(e)) => {\n+                    cov_mark::hit!(move_guard_ifelse_iflet_tail);\n+                    let guard = format!(\"\\n{}{} => \", spaces, match_pat);\n+                    // Put the if-let expression in a block\n+                    let iflet_expr: Expr = e.reset_indent().indent(1.into()).into();\n+                    let iflet_block =\n+                        make::block_expr(std::iter::empty(), Some(iflet_expr)).indent(indent_level);\n+                    edit.insert(then_arm_end, guard);\n+                    edit.insert(then_arm_end, iflet_block.syntax().text());\n+                }\n+                Some(Tail::Else(e)) => {\n+                    cov_mark::hit!(move_guard_ifelse_else_tail);\n+                    let guard = format!(\"\\n{}{} => \", spaces, match_pat);\n+                    edit.insert(then_arm_end, guard);\n+                    let only_expr = e.statements().next().is_none();\n+                    match &e.tail_expr() {\n+                        Some(expr) if only_expr => {\n+                            cov_mark::hit!(move_guard_ifelse_expr_only);\n+                            edit.insert(then_arm_end, expr.syntax().text());\n+                            edit.insert(then_arm_end, \",\");\n+                        }\n+                        _ => {\n+                            let to_insert = e.dedent(dedent.into()).syntax().text();\n+                            edit.insert(then_arm_end, to_insert)\n+                        }\n                     }\n                 }\n+                _ => {\n+                    cov_mark::hit!(move_guard_ifelse_notail);\n+                }\n             }\n         },\n     )\n }\n \n+#[derive(Debug)]\n+enum Tail {\n+    Else(BlockExpr),\n+    IfLet(IfExpr),\n+}\n+\n+// Parses an if-else-if chain to get the conditons and the then branches until we encounter an else\n+// branch, an if-let branch or the end.\n+fn parse_if_chain(if_expr: IfExpr) -> Option<(Vec<(Condition, BlockExpr)>, Option<Tail>)> {\n+    let mut conds_blocks = Vec::new();\n+    let mut curr_if = if_expr;\n+    let mut applicable = false;\n+    let tail: Option<Tail> = loop {\n+        let cond = curr_if.condition()?;\n+        if cond.is_pattern_cond() {\n+            break Some(Tail::IfLet(curr_if));\n+        }\n+        conds_blocks.push((cond, curr_if.then_branch()?));\n+        applicable = true;\n+        match curr_if.else_branch() {\n+            Some(ElseBranch::IfExpr(e)) => {\n+                curr_if = e;\n+            }\n+            Some(ElseBranch::Block(b)) => {\n+                break Some(Tail::Else(b));\n+            }\n+            None => break None,\n+        }\n+    };\n+    if !applicable {\n+        // The first if branch is an if-let branch\n+        return None;\n+    }\n+    Some((conds_blocks, tail))\n+}\n+\n #[cfg(test)]\n mod tests {\n     use super::*;\n@@ -321,7 +368,6 @@ fn main() {\n \n     #[test]\n     fn move_arm_cond_in_block_to_match_guard_add_comma_works() {\n-        cov_mark::check!(move_guard_if_add_comma);\n         check_assist(\n             move_arm_cond_to_match_guard,\n             r#\"\n@@ -377,7 +423,7 @@ fn main() {\n             r#\"\n fn main() {\n     match 92 {\n-        x if x > 10 => {  },\n+        x if x > 10 => {  }\n         _ => true\n     }\n }\n@@ -406,7 +452,7 @@ fn main() {\n         x if x > 10 => {\n             92;\n             false\n-        },\n+        }\n         _ => true\n     }\n }\n@@ -519,7 +565,7 @@ fn main() {\n             r#\"\n fn main() {\n     match 92 {\n-        x if x > 10 => {  },\n+        x if x > 10 => {  }\n         x => { }\n         _ => true\n     }\n@@ -690,6 +736,194 @@ fn main() {\n         }\n     }\n }\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn move_arm_cond_to_match_guard_elseif() {\n+        check_assist(\n+            move_arm_cond_to_match_guard,\n+            r#\"\n+fn main() {\n+    match 92 {\n+        3 => true,\n+        x => if x > 10 {$0\n+            false\n+        } else if x > 5 {\n+            true\n+        } else if x > 4 {\n+            false\n+        } else {\n+            true\n+        },\n+    }\n+}\n+\"#,\n+            r#\"\n+fn main() {\n+    match 92 {\n+        3 => true,\n+        x if x > 10 => false,\n+        x if x > 5 => true,\n+        x if x > 4 => false,\n+        x => true,\n+    }\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn move_arm_cond_to_match_guard_elseif_in_block() {\n+        cov_mark::check!(move_guard_ifelse_in_block);\n+        check_assist(\n+            move_arm_cond_to_match_guard,\n+            r#\"\n+fn main() {\n+    match 92 {\n+        3 => true,\n+        x => {\n+            if x > 10 {$0\n+                false\n+            } else if x > 5 {\n+                true\n+            } else if x > 4 {\n+                false\n+            } else {\n+                true\n+            }\n+        }\n+    }\n+}\n+\"#,\n+            r#\"\n+fn main() {\n+    match 92 {\n+        3 => true,\n+        x if x > 10 => false,\n+        x if x > 5 => true,\n+        x if x > 4 => false,\n+        x => true,\n+    }\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn move_arm_cond_to_match_guard_elseif_chain() {\n+        cov_mark::check!(move_guard_ifelse_else_tail);\n+        check_assist(\n+            move_arm_cond_to_match_guard,\n+            r#\"\n+fn main() {\n+    match 92 {\n+        3 => 0,\n+        x => if x > 10 {$0\n+            1\n+        } else if x > 5 {\n+            2\n+        } else if x > 3 {\n+            42;\n+            3\n+        } else {\n+            4\n+        },\n+    }\n+}\n+\"#,\n+            r#\"\n+fn main() {\n+    match 92 {\n+        3 => 0,\n+        x if x > 10 => 1,\n+        x if x > 5 => 2,\n+        x if x > 3 => {\n+            42;\n+            3\n+        }\n+        x => 4,\n+    }\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn move_arm_cond_to_match_guard_elseif_iflet() {\n+        cov_mark::check!(move_guard_ifelse_iflet_tail);\n+        check_assist(\n+            move_arm_cond_to_match_guard,\n+            r#\"\n+fn main() {\n+    match 92 {\n+        3 => 0,\n+        x => if x > 10 {$0\n+            1\n+        } else if x > 5 {\n+            2\n+        } else if let 4 = 4 {\n+            42;\n+            3\n+        } else {\n+            4\n+        },\n+    }\n+}\n+\"#,\n+            r#\"\n+fn main() {\n+    match 92 {\n+        3 => 0,\n+        x if x > 10 => 1,\n+        x if x > 5 => 2,\n+        x => {\n+            if let 4 = 4 {\n+                42;\n+                3\n+            } else {\n+                4\n+            }\n+        }\n+    }\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn move_arm_cond_to_match_guard_elseif_notail() {\n+        cov_mark::check!(move_guard_ifelse_notail);\n+        check_assist(\n+            move_arm_cond_to_match_guard,\n+            r#\"\n+fn main() {\n+    match 92 {\n+        3 => 0,\n+        x => if x > 10 {$0\n+            1\n+        } else if x > 5 {\n+            2\n+        } else if x > 4 {\n+            42;\n+            3\n+        },\n+    }\n+}\n+\"#,\n+            r#\"\n+fn main() {\n+    match 92 {\n+        3 => 0,\n+        x if x > 10 => 1,\n+        x if x > 5 => 2,\n+        x if x > 4 => {\n+            42;\n+            3\n+        }\n+    }\n+}\n \"#,\n         )\n     }"}]}