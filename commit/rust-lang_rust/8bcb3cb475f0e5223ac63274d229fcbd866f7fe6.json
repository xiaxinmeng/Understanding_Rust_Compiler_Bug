{"sha": "8bcb3cb475f0e5223ac63274d229fcbd866f7fe6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhiY2IzY2I0NzVmMGU1MjIzYWM2MzI3NGQyMjlmY2JkODY2ZjdmZTY=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-05-12T04:49:15Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-05-12T04:49:15Z"}, "message": "rustc::metadata: use u64 for DefId's instead of strings.", "tree": {"sha": "c4e07e976b1685587c377843dc240e9e22d7bce6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c4e07e976b1685587c377843dc240e9e22d7bce6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8bcb3cb475f0e5223ac63274d229fcbd866f7fe6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8bcb3cb475f0e5223ac63274d229fcbd866f7fe6", "html_url": "https://github.com/rust-lang/rust/commit/8bcb3cb475f0e5223ac63274d229fcbd866f7fe6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8bcb3cb475f0e5223ac63274d229fcbd866f7fe6/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7129b259491690c4a159ff3d799457aeb05587a6", "url": "https://api.github.com/repos/rust-lang/rust/commits/7129b259491690c4a159ff3d799457aeb05587a6", "html_url": "https://github.com/rust-lang/rust/commit/7129b259491690c4a159ff3d799457aeb05587a6"}], "stats": {"total": 156, "additions": 71, "deletions": 85}, "files": [{"sha": "f7fb5d495a4572f4fb31855ac22e216df0854ff5", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 40, "deletions": 56, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/8bcb3cb475f0e5223ac63274d229fcbd866f7fe6/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bcb3cb475f0e5223ac63274d229fcbd866f7fe6/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=8bcb3cb475f0e5223ac63274d229fcbd866f7fe6", "patch": "@@ -21,7 +21,8 @@ use metadata::common::*;\n use metadata::csearch::MethodInfo;\n use metadata::csearch;\n use metadata::cstore;\n-use metadata::tydecode::{parse_ty_data, parse_region_data, parse_def_id,\n+use metadata::encoder::def_to_u64;\n+use metadata::tydecode::{parse_ty_data, parse_region_data,\n                          parse_type_param_def_data, parse_bare_fn_ty_data,\n                          parse_trait_ref_data, parse_predicate_data};\n use middle::def;\n@@ -190,29 +191,32 @@ fn item_symbol(item: rbml::Doc) -> String {\n     reader::get_doc(item, tag_items_data_item_symbol).as_str().to_string()\n }\n \n-fn item_parent_item(d: rbml::Doc) -> Option<ast::DefId> {\n+fn translated_def_id(cdata: Cmd, d: rbml::Doc) -> ast::DefId {\n+    let id = reader::doc_as_u64(d);\n+    let def_id = ast::DefId { krate: (id >> 32) as u32, node: id as u32 };\n+    translate_def_id(cdata, def_id)\n+}\n+\n+fn item_parent_item(cdata: Cmd, d: rbml::Doc) -> Option<ast::DefId> {\n     let mut ret = None;\n     reader::tagged_docs(d, tag_items_data_parent_item, |did| {\n-        ret = Some(reader::with_doc_data(did, parse_def_id));\n+        ret = Some(translated_def_id(cdata, did));\n         false\n     });\n     ret\n }\n \n-fn item_reqd_and_translated_parent_item(cnum: ast::CrateNum,\n-                                        d: rbml::Doc) -> ast::DefId {\n-    let trait_did = item_parent_item(d).expect(\"item without parent\");\n-    ast::DefId { krate: cnum, node: trait_did.node }\n+fn item_require_parent_item(cdata: Cmd, d: rbml::Doc) -> ast::DefId {\n+    translated_def_id(cdata, reader::get_doc(d, tag_items_data_parent_item))\n }\n \n fn item_def_id(d: rbml::Doc, cdata: Cmd) -> ast::DefId {\n-    let tagdoc = reader::get_doc(d, tag_def_id);\n-    return translate_def_id(cdata, reader::with_doc_data(tagdoc, parse_def_id));\n+    translated_def_id(cdata, reader::get_doc(d, tag_def_id))\n }\n \n fn get_provided_source(d: rbml::Doc, cdata: Cmd) -> Option<ast::DefId> {\n     reader::maybe_get_doc(d, tag_item_method_provided_source).map(|doc| {\n-        translate_def_id(cdata, reader::with_doc_data(doc, parse_def_id))\n+        translated_def_id(cdata, doc)\n     })\n }\n \n@@ -261,14 +265,12 @@ fn item_trait_ref<'tcx>(doc: rbml::Doc, tcx: &ty::ctxt<'tcx>, cdata: Cmd)\n }\n \n fn enum_variant_ids(item: rbml::Doc, cdata: Cmd) -> Vec<ast::DefId> {\n-    let mut ids: Vec<ast::DefId> = Vec::new();\n-    let v = tag_items_data_item_variant;\n-    reader::tagged_docs(item, v, |p| {\n-        let ext = reader::with_doc_data(p, parse_def_id);\n-        ids.push(ast::DefId { krate: cdata.cnum, node: ext.node });\n+    let mut ids = vec![];\n+    reader::tagged_docs(item, tag_items_data_item_variant, |p| {\n+        ids.push(translated_def_id(cdata, p));\n         true\n     });\n-    return ids;\n+    ids\n }\n \n fn item_path(item_doc: rbml::Doc) -> Vec<ast_map::PathElem> {\n@@ -303,8 +305,7 @@ fn item_name(intr: &IdentInterner, item: rbml::Doc) -> ast::Name {\n     }\n }\n \n-fn item_to_def_like(item: rbml::Doc, did: ast::DefId, cnum: ast::CrateNum)\n-    -> DefLike {\n+fn item_to_def_like(cdata: Cmd, item: rbml::Doc, did: ast::DefId) -> DefLike {\n     let fam = item_family(item);\n     match fam {\n         Constant  => {\n@@ -314,11 +315,9 @@ fn item_to_def_like(item: rbml::Doc, did: ast::DefId, cnum: ast::CrateNum)\n                 // See the comment for methods below.\n                 let provenance = if reader::maybe_get_doc(\n                       item, tag_item_trait_parent_sort).is_some() {\n-                    def::FromTrait(item_reqd_and_translated_parent_item(cnum,\n-                                                                        item))\n+                    def::FromTrait(item_require_parent_item(cdata, item))\n                 } else {\n-                    def::FromImpl(item_reqd_and_translated_parent_item(cnum,\n-                                                                       item))\n+                    def::FromImpl(item_require_parent_item(cdata, item))\n                 };\n                 DlDef(def::DefAssociatedConst(did, provenance))\n             } else {\n@@ -339,17 +338,15 @@ fn item_to_def_like(item: rbml::Doc, did: ast::DefId, cnum: ast::CrateNum)\n             // a trait_parent_sort.\n             let provenance = if reader::maybe_get_doc(\n                   item, tag_item_trait_parent_sort).is_some() {\n-                def::FromTrait(item_reqd_and_translated_parent_item(cnum,\n-                                                                    item))\n+                def::FromTrait(item_require_parent_item(cdata, item))\n             } else {\n-                def::FromImpl(item_reqd_and_translated_parent_item(cnum,\n-                                                                   item))\n+                def::FromImpl(item_require_parent_item(cdata, item))\n             };\n             DlDef(def::DefMethod(did, provenance))\n         }\n         Type => {\n             if item_sort(item) == Some('t') {\n-                let trait_did = item_reqd_and_translated_parent_item(cnum, item);\n+                let trait_did = item_require_parent_item(cdata, item);\n                 DlDef(def::DefAssociatedTy(trait_did, did))\n             } else {\n                 DlDef(def::DefTy(did, false))\n@@ -358,11 +355,11 @@ fn item_to_def_like(item: rbml::Doc, did: ast::DefId, cnum: ast::CrateNum)\n         Mod => DlDef(def::DefMod(did)),\n         ForeignMod => DlDef(def::DefForeignMod(did)),\n         StructVariant => {\n-            let enum_did = item_reqd_and_translated_parent_item(cnum, item);\n+            let enum_did = item_require_parent_item(cdata, item);\n             DlDef(def::DefVariant(enum_did, did, true))\n         }\n         TupleVariant => {\n-            let enum_did = item_reqd_and_translated_parent_item(cnum, item);\n+            let enum_did = item_require_parent_item(cdata, item);\n             DlDef(def::DefVariant(enum_did, did, false))\n         }\n         Trait => DlDef(def::DefTrait(did)),\n@@ -560,9 +557,7 @@ fn each_child_of_item_or_crate<F, G>(intr: Rc<IdentInterner>,\n {\n     // Iterate over all children.\n     let _ = reader::tagged_docs(item_doc, tag_mod_child, |child_info_doc| {\n-        let child_def_id = reader::with_doc_data(child_info_doc,\n-                                                 parse_def_id);\n-        let child_def_id = translate_def_id(cdata, child_def_id);\n+        let child_def_id = translated_def_id(cdata, child_info_doc);\n \n         // This item may be in yet another crate if it was the child of a\n         // reexport.\n@@ -584,9 +579,7 @@ fn each_child_of_item_or_crate<F, G>(intr: Rc<IdentInterner>,\n             Some(child_item_doc) => {\n                 // Hand off the item to the callback.\n                 let child_name = item_name(&*intr, child_item_doc);\n-                let def_like = item_to_def_like(child_item_doc,\n-                                                child_def_id,\n-                                                cdata.cnum);\n+                let def_like = item_to_def_like(crate_data, child_item_doc, child_def_id);\n                 let visibility = item_visibility(child_item_doc);\n                 callback(def_like, child_name, visibility);\n \n@@ -615,9 +608,8 @@ fn each_child_of_item_or_crate<F, G>(intr: Rc<IdentInterner>,\n                     if let StaticMethod = item_family(impl_method_doc) {\n                         // Hand off the static method to the callback.\n                         let static_method_name = item_name(&*intr, impl_method_doc);\n-                        let static_method_def_like = item_to_def_like(impl_method_doc,\n-                                                                      impl_item_def_id,\n-                                                                      cdata.cnum);\n+                        let static_method_def_like = item_to_def_like(cdata, impl_method_doc,\n+                                                                      impl_item_def_id);\n                         callback(static_method_def_like,\n                                  static_method_name,\n                                  item_visibility(impl_method_doc));\n@@ -633,9 +625,7 @@ fn each_child_of_item_or_crate<F, G>(intr: Rc<IdentInterner>,\n     let _ = each_reexport(item_doc, |reexport_doc| {\n         let def_id_doc = reader::get_doc(reexport_doc,\n                                          tag_items_data_item_reexport_def_id);\n-        let child_def_id = reader::with_doc_data(def_id_doc,\n-                                                 parse_def_id);\n-        let child_def_id = translate_def_id(cdata, child_def_id);\n+        let child_def_id = translated_def_id(cdata, def_id_doc);\n \n         let name_doc = reader::get_doc(reexport_doc,\n                                        tag_items_data_item_reexport_name);\n@@ -657,9 +647,7 @@ fn each_child_of_item_or_crate<F, G>(intr: Rc<IdentInterner>,\n         // Get the item.\n         if let Some(child_item_doc) = maybe_find_item(child_def_id.node, other_crates_items) {\n             // Hand off the item to the callback.\n-            let def_like = item_to_def_like(child_item_doc,\n-                                            child_def_id,\n-                                            child_def_id.krate);\n+            let def_like = item_to_def_like(crate_data, child_item_doc, child_def_id);\n             // These items have a public visibility because they're part of\n             // a public re-export.\n             callback(def_like, token::intern(name), ast::Public);\n@@ -733,9 +721,8 @@ pub fn maybe_get_item_ast<'tcx>(cdata: Cmd, tcx: &ty::ctxt<'tcx>, id: ast::NodeI\n     match decode_inlined_item(cdata, tcx, path, item_doc) {\n         Ok(ii) => csearch::FoundAst::Found(ii),\n         Err(path) => {\n-            match item_parent_item(item_doc) {\n+            match item_parent_item(cdata, item_doc) {\n                 Some(did) => {\n-                    let did = translate_def_id(cdata, did);\n                     let parent_item = lookup_item(did.node, cdata.data());\n                     match decode_inlined_item(cdata, tcx, path, parent_item) {\n                         Ok(ii) => csearch::FoundAst::FoundParent(did, ii),\n@@ -759,7 +746,7 @@ pub fn get_enum_variant_defs(intr: &IdentInterner,\n         let item = find_item(did.node, items);\n         let name = item_name(intr, item);\n         let visibility = item_visibility(item);\n-        match item_to_def_like(item, *did, cdata.cnum) {\n+        match item_to_def_like(cdata, item, *did) {\n             DlDef(def @ def::DefVariant(..)) => (def, name, visibility),\n             _ => unreachable!()\n         }\n@@ -889,8 +876,7 @@ pub fn get_impl_or_trait_item<'tcx>(intr: Rc<IdentInterner>,\n \n     let def_id = item_def_id(method_doc, cdata);\n \n-    let container_id = item_reqd_and_translated_parent_item(cdata.cnum,\n-                                                            method_doc);\n+    let container_id = item_require_parent_item(cdata, method_doc);\n     let container_doc = lookup_item(container_id.node, cdata.data());\n     let container = match item_family(container_doc) {\n         Trait => TraitContainer(container_id),\n@@ -1094,7 +1080,7 @@ pub fn get_tuple_struct_definition_if_ctor(cdata: Cmd,\n     let item = lookup_item(node_id, cdata.data());\n     let mut ret = None;\n     reader::tagged_docs(item, tag_items_data_item_is_tuple_struct_ctor, |_| {\n-        ret = Some(item_reqd_and_translated_parent_item(cdata.cnum, item));\n+        ret = Some(item_require_parent_item(cdata, item));\n         false\n     });\n     ret\n@@ -1144,7 +1130,7 @@ pub fn get_struct_fields(intr: Rc<IdentInterner>, cdata: Cmd, id: ast::NodeId)\n             let name = item_name(&*intr, an_item);\n             let did = item_def_id(an_item, cdata);\n             let tagdoc = reader::get_doc(an_item, tag_item_field_origin);\n-            let origin_id =  translate_def_id(cdata, reader::with_doc_data(tagdoc, parse_def_id));\n+            let origin_id =  translated_def_id(cdata, tagdoc);\n             result.push(ty::field_ty {\n                 name: name,\n                 id: did,\n@@ -1158,7 +1144,7 @@ pub fn get_struct_fields(intr: Rc<IdentInterner>, cdata: Cmd, id: ast::NodeId)\n         let did = item_def_id(an_item, cdata);\n         let tagdoc = reader::get_doc(an_item, tag_item_field_origin);\n         let f = item_family(an_item);\n-        let origin_id =  translate_def_id(cdata, reader::with_doc_data(tagdoc, parse_def_id));\n+        let origin_id =  translated_def_id(cdata, tagdoc);\n         result.push(ty::field_ty {\n             name: special_idents::unnamed_field.name,\n             id: did,\n@@ -1386,11 +1372,10 @@ pub fn each_implementation_for_trait<F>(cdata: Cmd,\n pub fn get_trait_of_item(cdata: Cmd, id: ast::NodeId, tcx: &ty::ctxt)\n                          -> Option<ast::DefId> {\n     let item_doc = lookup_item(id, cdata.data());\n-    let parent_item_id = match item_parent_item(item_doc) {\n+    let parent_item_id = match item_parent_item(cdata, item_doc) {\n         None => return None,\n         Some(item_id) => item_id,\n     };\n-    let parent_item_id = translate_def_id(cdata, parent_item_id);\n     let parent_item_doc = lookup_item(parent_item_id.node, cdata.data());\n     match item_family(parent_item_doc) {\n         Trait => Some(item_def_id(parent_item_doc, cdata)),\n@@ -1538,8 +1523,7 @@ fn doc_generics<'tcx>(base_doc: rbml::Doc,\n         let name = item_name(&*token::get_ident_interner(), ident_str_doc);\n         let def_id_doc = reader::get_doc(rp_doc,\n                                          tag_region_param_def_def_id);\n-        let def_id = reader::with_doc_data(def_id_doc, parse_def_id);\n-        let def_id = translate_def_id(cdata, def_id);\n+        let def_id = translated_def_id(cdata, def_id_doc);\n \n         let doc = reader::get_doc(rp_doc, tag_region_param_def_space);\n         let space = subst::ParamSpace::from_uint(reader::doc_as_u64(doc) as usize);"}, {"sha": "d7d30cada81b456d647da9e83ac0bfe9ee2c8e16", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 31, "deletions": 29, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/8bcb3cb475f0e5223ac63274d229fcbd866f7fe6/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bcb3cb475f0e5223ac63274d229fcbd866f7fe6/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=8bcb3cb475f0e5223ac63274d229fcbd866f7fe6", "patch": "@@ -91,8 +91,8 @@ fn encode_impl_type_basename(rbml_w: &mut Encoder, name: ast::Name) {\n     rbml_w.wr_tagged_str(tag_item_impl_type_basename, &token::get_name(name));\n }\n \n-pub fn encode_def_id(rbml_w: &mut Encoder, id: DefId) {\n-    rbml_w.wr_tagged_str(tag_def_id, &def_to_string(id));\n+fn encode_def_id(rbml_w: &mut Encoder, id: DefId) {\n+    rbml_w.wr_tagged_u64(tag_def_id, def_to_u64(id));\n }\n \n #[derive(Clone)]\n@@ -122,6 +122,10 @@ fn encode_family(rbml_w: &mut Encoder, c: char) {\n     rbml_w.wr_tagged_u8(tag_items_data_item_family, c as u8);\n }\n \n+pub fn def_to_u64(did: DefId) -> u64 {\n+    (did.krate as u64) << 32 | (did.node as u64)\n+}\n+\n pub fn def_to_string(did: DefId) -> String {\n     format!(\"{}:{}\", did.krate, did.node)\n }\n@@ -153,9 +157,9 @@ fn encode_bounds_and_type<'a, 'tcx>(rbml_w: &mut Encoder,\n }\n \n fn encode_variant_id(rbml_w: &mut Encoder, vid: DefId) {\n-    let s = def_to_string(vid);\n-    rbml_w.wr_tagged_str(tag_items_data_item_variant, &s[..]);\n-    rbml_w.wr_tagged_str(tag_mod_child, &s[..]);\n+    let id = def_to_u64(vid);\n+    rbml_w.wr_tagged_u64(tag_items_data_item_variant, id);\n+    rbml_w.wr_tagged_u64(tag_mod_child, id);\n }\n \n pub fn write_closure_type<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n@@ -260,7 +264,7 @@ fn encode_disr_val(_: &EncodeContext,\n }\n \n fn encode_parent_item(rbml_w: &mut Encoder, id: DefId) {\n-    rbml_w.wr_tagged_str(tag_items_data_parent_item, &def_to_string(id));\n+    rbml_w.wr_tagged_u64(tag_items_data_parent_item, def_to_u64(id));\n }\n \n fn encode_struct_fields(rbml_w: &mut Encoder,\n@@ -275,7 +279,7 @@ fn encode_struct_fields(rbml_w: &mut Encoder,\n         }\n         encode_struct_field_family(rbml_w, f.vis);\n         encode_def_id(rbml_w, f.id);\n-        rbml_w.wr_tagged_str(tag_item_field_origin, &def_to_string(origin));\n+        rbml_w.wr_tagged_u64(tag_item_field_origin, def_to_u64(origin));\n         rbml_w.end_tag();\n     }\n }\n@@ -358,8 +362,8 @@ fn encode_reexported_static_method(rbml_w: &mut Encoder,\n     debug!(\"(encode reexported static method) {}::{}\",\n             exp.name, token::get_name(method_name));\n     rbml_w.start_tag(tag_items_data_item_reexport);\n-    rbml_w.wr_tagged_str(tag_items_data_item_reexport_def_id,\n-                         &def_to_string(method_def_id));\n+    rbml_w.wr_tagged_u64(tag_items_data_item_reexport_def_id,\n+                         def_to_u64(method_def_id));\n     rbml_w.wr_tagged_str(tag_items_data_item_reexport_name,\n                          &format!(\"{}::{}\", exp.name,\n                                             token::get_name(method_name)));\n@@ -495,8 +499,8 @@ fn encode_reexports(ecx: &EncodeContext,\n                        exp.def_id.node,\n                        id);\n                 rbml_w.start_tag(tag_items_data_item_reexport);\n-                rbml_w.wr_tagged_str(tag_items_data_item_reexport_def_id,\n-                                     &def_to_string(exp.def_id));\n+                rbml_w.wr_tagged_u64(tag_items_data_item_reexport_def_id,\n+                                     def_to_u64(exp.def_id));\n                 rbml_w.wr_tagged_str(tag_items_data_item_reexport_name,\n                                      exp.name.as_str());\n                 rbml_w.end_tag();\n@@ -526,12 +530,12 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n \n     // Encode info about all the module children.\n     for item in &md.items {\n-        rbml_w.wr_tagged_str(tag_mod_child,\n-                             &def_to_string(local_def(item.id)));\n+        rbml_w.wr_tagged_u64(tag_mod_child,\n+                             def_to_u64(local_def(item.id)));\n \n         each_auxiliary_node_id(&**item, |auxiliary_node_id| {\n-            rbml_w.wr_tagged_str(tag_mod_child,\n-                                 &def_to_string(local_def(auxiliary_node_id)));\n+            rbml_w.wr_tagged_u64(tag_mod_child,\n+                                 def_to_u64(local_def(auxiliary_node_id)));\n             true\n         });\n \n@@ -541,8 +545,7 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n                    token::get_ident(ident),\n                    did, ecx.tcx.map.node_to_string(did));\n \n-            rbml_w.wr_tagged_str(tag_mod_impl,\n-                                 &def_to_string(local_def(did)));\n+            rbml_w.wr_tagged_u64(tag_mod_impl, def_to_u64(local_def(did)));\n         }\n     }\n \n@@ -619,8 +622,7 @@ fn encode_parent_sort(rbml_w: &mut Encoder, sort: char) {\n fn encode_provided_source(rbml_w: &mut Encoder,\n                           source_opt: Option<DefId>) {\n     if let Some(source) = source_opt {\n-        rbml_w.wr_tagged_str(tag_item_method_provided_source,\n-                             &def_to_string(source));\n+        rbml_w.wr_tagged_u64(tag_item_method_provided_source, def_to_u64(source));\n     }\n }\n \n@@ -725,8 +727,8 @@ fn encode_generics<'a, 'tcx>(rbml_w: &mut Encoder,\n         encode_name(rbml_w, param.name);\n         rbml_w.end_tag();\n \n-        rbml_w.wr_tagged_str(tag_region_param_def_def_id,\n-                             &def_to_string(param.def_id));\n+        rbml_w.wr_tagged_u64(tag_region_param_def_def_id,\n+                             def_to_u64(param.def_id));\n \n         rbml_w.wr_tagged_u64(tag_region_param_def_space,\n                              param.space.to_uint() as u64);\n@@ -1089,8 +1091,8 @@ fn encode_info_for_item(ecx: &EncodeContext,\n \n         // Encode all the items in this module.\n         for foreign_item in &fm.items {\n-            rbml_w.wr_tagged_str(tag_mod_child,\n-                                 &def_to_string(local_def(foreign_item.id)));\n+            rbml_w.wr_tagged_u64(tag_mod_child,\n+                                 def_to_u64(local_def(foreign_item.id)));\n         }\n         encode_visibility(rbml_w, vis);\n         encode_stability(rbml_w, stab);\n@@ -1335,8 +1337,8 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             }\n             rbml_w.end_tag();\n \n-            rbml_w.wr_tagged_str(tag_mod_child,\n-                                 &def_to_string(method_def_id.def_id()));\n+            rbml_w.wr_tagged_u64(tag_mod_child,\n+                                 def_to_u64(method_def_id.def_id()));\n         }\n         encode_path(rbml_w, path.clone());\n \n@@ -1932,12 +1934,12 @@ fn encode_misc_info(ecx: &EncodeContext,\n     rbml_w.start_tag(tag_misc_info);\n     rbml_w.start_tag(tag_misc_info_crate_items);\n     for item in &krate.module.items {\n-        rbml_w.wr_tagged_str(tag_mod_child,\n-                             &def_to_string(local_def(item.id)));\n+        rbml_w.wr_tagged_u64(tag_mod_child,\n+                             def_to_u64(local_def(item.id)));\n \n         each_auxiliary_node_id(&**item, |auxiliary_node_id| {\n-            rbml_w.wr_tagged_str(tag_mod_child,\n-                                 &def_to_string(local_def(auxiliary_node_id)));\n+            rbml_w.wr_tagged_u64(tag_mod_child,\n+                                 def_to_u64(local_def(auxiliary_node_id)));\n             true\n         });\n     }"}]}