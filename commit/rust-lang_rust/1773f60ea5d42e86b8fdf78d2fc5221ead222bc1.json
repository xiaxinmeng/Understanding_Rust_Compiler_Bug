{"sha": "1773f60ea5d42e86b8fdf78d2fc5221ead222bc1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE3NzNmNjBlYTVkNDJlODZiOGZkZjc4ZDJmYzUyMjFlYWQyMjJiYzE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-11-08T20:00:51Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-11-08T20:00:51Z"}, "message": "Auto merge of #78712 - petrochenkov:visitok, r=Aaron1011\n\nrustc_ast: Visit tokens stored in AST nodes in mutable visitor\n\nAfter #77271 token visiting is enabled only for one visitor in `rustc_expand\\src\\mbe\\transcribe.rs` which applies hygiene marks to tokens produced by declarative macros (`macro_rules` or `macro`), so this change doesn't affect anything else.\n\nWhen a macro has some interpolated token from an outer macro in its output\n```rust\nmacro inner() {\n    $interpolated\n}\n```\nwe can use the usual interpretation of interpolated tokens in token-based model - a None-delimited group - to write this macro in an equivalent form\n```rust\nmacro inner() {\n    \u27ea a b c d \u27eb\n}\n```\n\nWhen we are expanding the macro `inner` we need to apply hygiene marks to all tokens produced by it, including the tokens inside the group.\n\nBefore this PR we did this by visiting the AST piece inside the interpolated token and applying marks to all spans in it.\nI'm not sure this is 100% correct (ideally we should apply the marks to tokens and then re-parse the AST from tokens), but it's a very good approximation at least.\nWe didn't however apply the marks to actual tokens stored in the nonterminal, so if we used the nonterminal as a token rather than as an AST piece (e.g. passed it to a proc macro), then we got hygiene bugs.\nThis PR applies the marks to tokens in addition to the AST pieces thus fixing the issue.\n\nr? `@Aaron1011`", "tree": {"sha": "95f828a7cdedd701b9b14299f6947cc1d5ff6956", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/95f828a7cdedd701b9b14299f6947cc1d5ff6956"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1773f60ea5d42e86b8fdf78d2fc5221ead222bc1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1773f60ea5d42e86b8fdf78d2fc5221ead222bc1", "html_url": "https://github.com/rust-lang/rust/commit/1773f60ea5d42e86b8fdf78d2fc5221ead222bc1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1773f60ea5d42e86b8fdf78d2fc5221ead222bc1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b1277d04db0dc8009037e872a1be7cdc2bd74a43", "url": "https://api.github.com/repos/rust-lang/rust/commits/b1277d04db0dc8009037e872a1be7cdc2bd74a43", "html_url": "https://github.com/rust-lang/rust/commit/b1277d04db0dc8009037e872a1be7cdc2bd74a43"}, {"sha": "8def2fc122a9f698914606c51a9e8c18aed168df", "url": "https://api.github.com/repos/rust-lang/rust/commits/8def2fc122a9f698914606c51a9e8c18aed168df", "html_url": "https://github.com/rust-lang/rust/commit/8def2fc122a9f698914606c51a9e8c18aed168df"}], "stats": {"total": 172, "additions": 156, "deletions": 16}, "files": [{"sha": "517717eebd9d056159989242dade28e2493c6421", "filename": "compiler/rustc_ast/src/mut_visit.rs", "status": "modified", "additions": 35, "deletions": 16, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/1773f60ea5d42e86b8fdf78d2fc5221ead222bc1/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1773f60ea5d42e86b8fdf78d2fc5221ead222bc1/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs?ref=1773f60ea5d42e86b8fdf78d2fc5221ead222bc1", "patch": "@@ -461,7 +461,7 @@ pub fn noop_visit_ty_constraint<T: MutVisitor>(\n }\n \n pub fn noop_visit_ty<T: MutVisitor>(ty: &mut P<Ty>, vis: &mut T) {\n-    let Ty { id, kind, span, tokens: _ } = ty.deref_mut();\n+    let Ty { id, kind, span, tokens } = ty.deref_mut();\n     vis.visit_id(id);\n     match kind {\n         TyKind::Infer | TyKind::ImplicitSelf | TyKind::Err | TyKind::Never | TyKind::CVarArgs => {}\n@@ -497,6 +497,7 @@ pub fn noop_visit_ty<T: MutVisitor>(ty: &mut P<Ty>, vis: &mut T) {\n         TyKind::MacCall(mac) => vis.visit_mac(mac),\n     }\n     vis.visit_span(span);\n+    visit_lazy_tts(tokens, vis);\n }\n \n pub fn noop_visit_foreign_mod<T: MutVisitor>(foreign_mod: &mut ForeignMod, vis: &mut T) {\n@@ -523,13 +524,14 @@ pub fn noop_visit_ident<T: MutVisitor>(Ident { name: _, span }: &mut Ident, vis:\n     vis.visit_span(span);\n }\n \n-pub fn noop_visit_path<T: MutVisitor>(Path { segments, span, tokens: _ }: &mut Path, vis: &mut T) {\n+pub fn noop_visit_path<T: MutVisitor>(Path { segments, span, tokens }: &mut Path, vis: &mut T) {\n     vis.visit_span(span);\n     for PathSegment { ident, id, args } in segments {\n         vis.visit_ident(ident);\n         vis.visit_id(id);\n         visit_opt(args, |args| vis.visit_generic_args(args));\n     }\n+    visit_lazy_tts(tokens, vis);\n }\n \n pub fn noop_visit_qself<T: MutVisitor>(qself: &mut Option<QSelf>, vis: &mut T) {\n@@ -587,15 +589,17 @@ pub fn noop_visit_local<T: MutVisitor>(local: &mut P<Local>, vis: &mut T) {\n }\n \n pub fn noop_visit_attribute<T: MutVisitor>(attr: &mut Attribute, vis: &mut T) {\n-    let Attribute { kind, id: _, style: _, span, tokens: _ } = attr;\n+    let Attribute { kind, id: _, style: _, span, tokens } = attr;\n     match kind {\n-        AttrKind::Normal(AttrItem { path, args, tokens: _ }) => {\n+        AttrKind::Normal(AttrItem { path, args, tokens }) => {\n             vis.visit_path(path);\n             visit_mac_args(args, vis);\n+            visit_lazy_tts(tokens, vis);\n         }\n         AttrKind::DocComment(..) => {}\n     }\n     vis.visit_span(span);\n+    visit_lazy_tts(tokens, vis);\n }\n \n pub fn noop_visit_mac<T: MutVisitor>(mac: &mut MacCall, vis: &mut T) {\n@@ -652,12 +656,22 @@ pub fn visit_tt<T: MutVisitor>(tt: &mut TokenTree, vis: &mut T) {\n \n // No `noop_` prefix because there isn't a corresponding method in `MutVisitor`.\n pub fn visit_tts<T: MutVisitor>(TokenStream(tts): &mut TokenStream, vis: &mut T) {\n-    if vis.token_visiting_enabled() {\n+    if vis.token_visiting_enabled() && !tts.is_empty() {\n         let tts = Lrc::make_mut(tts);\n         visit_vec(tts, |(tree, _is_joint)| visit_tt(tree, vis));\n     }\n }\n \n+pub fn visit_lazy_tts<T: MutVisitor>(lazy_tts: &mut Option<LazyTokenStream>, vis: &mut T) {\n+    if vis.token_visiting_enabled() {\n+        visit_opt(lazy_tts, |lazy_tts| {\n+            let mut tts = lazy_tts.create_token_stream();\n+            visit_tts(&mut tts, vis);\n+            *lazy_tts = LazyTokenStream::new(tts);\n+        })\n+    }\n+}\n+\n // No `noop_` prefix because there isn't a corresponding method in `MutVisitor`.\n // Applies ident visitor if it's an ident; applies other visits to interpolated nodes.\n // In practice the ident part is not actually used by specific visitors right now,\n@@ -725,9 +739,10 @@ pub fn visit_interpolated<T: MutVisitor>(nt: &mut token::Nonterminal, vis: &mut\n         token::NtLifetime(ident) => vis.visit_ident(ident),\n         token::NtLiteral(expr) => vis.visit_expr(expr),\n         token::NtMeta(item) => {\n-            let AttrItem { path, args, tokens: _ } = item.deref_mut();\n+            let AttrItem { path, args, tokens } = item.deref_mut();\n             vis.visit_path(path);\n             visit_mac_args(args, vis);\n+            visit_lazy_tts(tokens, vis);\n         }\n         token::NtPath(path) => vis.visit_path(path),\n         token::NtTT(tt) => visit_tt(tt, vis),\n@@ -887,10 +902,11 @@ pub fn noop_visit_mt<T: MutVisitor>(MutTy { ty, mutbl: _ }: &mut MutTy, vis: &mu\n }\n \n pub fn noop_visit_block<T: MutVisitor>(block: &mut P<Block>, vis: &mut T) {\n-    let Block { id, stmts, rules: _, span, tokens: _ } = block.deref_mut();\n+    let Block { id, stmts, rules: _, span, tokens } = block.deref_mut();\n     vis.visit_id(id);\n     stmts.flat_map_in_place(|stmt| vis.flat_map_stmt(stmt));\n     vis.visit_span(span);\n+    visit_lazy_tts(tokens, vis);\n }\n \n pub fn noop_visit_item_kind<T: MutVisitor>(kind: &mut ItemKind, vis: &mut T) {\n@@ -955,7 +971,7 @@ pub fn noop_flat_map_assoc_item<T: MutVisitor>(\n     mut item: P<AssocItem>,\n     visitor: &mut T,\n ) -> SmallVec<[P<AssocItem>; 1]> {\n-    let Item { id, ident, vis, attrs, kind, span, tokens: _ } = item.deref_mut();\n+    let Item { id, ident, vis, attrs, kind, span, tokens } = item.deref_mut();\n     visitor.visit_id(id);\n     visitor.visit_ident(ident);\n     visitor.visit_vis(vis);\n@@ -978,6 +994,7 @@ pub fn noop_flat_map_assoc_item<T: MutVisitor>(\n         AssocItemKind::MacCall(mac) => visitor.visit_mac(mac),\n     }\n     visitor.visit_span(span);\n+    visit_lazy_tts(tokens, visitor);\n     smallvec![item]\n }\n \n@@ -1028,16 +1045,14 @@ pub fn noop_flat_map_item<T: MutVisitor>(\n     mut item: P<Item>,\n     visitor: &mut T,\n ) -> SmallVec<[P<Item>; 1]> {\n-    let Item { ident, attrs, id, kind, vis, span, tokens: _ } = item.deref_mut();\n+    let Item { ident, attrs, id, kind, vis, span, tokens } = item.deref_mut();\n     visitor.visit_ident(ident);\n     visit_attrs(attrs, visitor);\n     visitor.visit_id(id);\n     visitor.visit_item_kind(kind);\n     visitor.visit_vis(vis);\n     visitor.visit_span(span);\n-\n-    // FIXME: if `tokens` is modified with a call to `vis.visit_tts` it causes\n-    //        an ICE during resolve... odd!\n+    visit_lazy_tts(tokens, visitor);\n \n     smallvec![item]\n }\n@@ -1046,7 +1061,7 @@ pub fn noop_flat_map_foreign_item<T: MutVisitor>(\n     mut item: P<ForeignItem>,\n     visitor: &mut T,\n ) -> SmallVec<[P<ForeignItem>; 1]> {\n-    let Item { ident, attrs, id, kind, vis, span, tokens: _ } = item.deref_mut();\n+    let Item { ident, attrs, id, kind, vis, span, tokens } = item.deref_mut();\n     visitor.visit_id(id);\n     visitor.visit_ident(ident);\n     visitor.visit_vis(vis);\n@@ -1069,11 +1084,12 @@ pub fn noop_flat_map_foreign_item<T: MutVisitor>(\n         ForeignItemKind::MacCall(mac) => visitor.visit_mac(mac),\n     }\n     visitor.visit_span(span);\n+    visit_lazy_tts(tokens, visitor);\n     smallvec![item]\n }\n \n pub fn noop_visit_pat<T: MutVisitor>(pat: &mut P<Pat>, vis: &mut T) {\n-    let Pat { id, kind, span, tokens: _ } = pat.deref_mut();\n+    let Pat { id, kind, span, tokens } = pat.deref_mut();\n     vis.visit_id(id);\n     match kind {\n         PatKind::Wild | PatKind::Rest => {}\n@@ -1108,6 +1124,7 @@ pub fn noop_visit_pat<T: MutVisitor>(pat: &mut P<Pat>, vis: &mut T) {\n         PatKind::MacCall(mac) => vis.visit_mac(mac),\n     }\n     vis.visit_span(span);\n+    visit_lazy_tts(tokens, vis);\n }\n \n pub fn noop_visit_anon_const<T: MutVisitor>(AnonConst { id, value }: &mut AnonConst, vis: &mut T) {\n@@ -1116,7 +1133,7 @@ pub fn noop_visit_anon_const<T: MutVisitor>(AnonConst { id, value }: &mut AnonCo\n }\n \n pub fn noop_visit_expr<T: MutVisitor>(\n-    Expr { kind, id, span, attrs, tokens: _ }: &mut Expr,\n+    Expr { kind, id, span, attrs, tokens }: &mut Expr,\n     vis: &mut T,\n ) {\n     match kind {\n@@ -1295,6 +1312,7 @@ pub fn noop_visit_expr<T: MutVisitor>(\n     vis.visit_id(id);\n     vis.visit_span(span);\n     visit_thin_attrs(attrs, vis);\n+    visit_lazy_tts(tokens, vis);\n }\n \n pub fn noop_filter_map_expr<T: MutVisitor>(mut e: P<Expr>, vis: &mut T) -> Option<P<Expr>> {\n@@ -1305,11 +1323,12 @@ pub fn noop_filter_map_expr<T: MutVisitor>(mut e: P<Expr>, vis: &mut T) -> Optio\n }\n \n pub fn noop_flat_map_stmt<T: MutVisitor>(\n-    Stmt { kind, mut span, mut id, tokens }: Stmt,\n+    Stmt { kind, mut span, mut id, mut tokens }: Stmt,\n     vis: &mut T,\n ) -> SmallVec<[Stmt; 1]> {\n     vis.visit_id(&mut id);\n     vis.visit_span(&mut span);\n+    visit_lazy_tts(&mut tokens, vis);\n     noop_flat_map_stmt_kind(kind, vis)\n         .into_iter()\n         .map(|kind| Stmt { id, kind, span, tokens: tokens.clone() })"}, {"sha": "98fd4306004e8089ff61de11b5aef9fc6646326d", "filename": "src/test/ui/proc-macro/nonterminal-token-hygiene.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/1773f60ea5d42e86b8fdf78d2fc5221ead222bc1/src%2Ftest%2Fui%2Fproc-macro%2Fnonterminal-token-hygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1773f60ea5d42e86b8fdf78d2fc5221ead222bc1/src%2Ftest%2Fui%2Fproc-macro%2Fnonterminal-token-hygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fnonterminal-token-hygiene.rs?ref=1773f60ea5d42e86b8fdf78d2fc5221ead222bc1", "patch": "@@ -0,0 +1,33 @@\n+// Make sure that marks from declarative macros are applied to tokens in nonterminal.\n+\n+// check-pass\n+// compile-flags: -Z span-debug -Z macro-backtrace -Z unpretty=expanded,hygiene\n+// compile-flags: -Z trim-diagnostic-paths=no\n+// normalize-stdout-test \"\\d+#\" -> \"0#\"\n+// aux-build:test-macros.rs\n+\n+#![feature(decl_macro)]\n+\n+#![no_std] // Don't load unnecessary hygiene information from std\n+extern crate std;\n+\n+#[macro_use]\n+extern crate test_macros;\n+\n+macro_rules! outer {\n+    ($item:item) => {\n+        macro inner() {\n+            print_bang! { $item }\n+        }\n+\n+        inner!();\n+    };\n+}\n+\n+struct S;\n+\n+outer! {\n+    struct S; // OK, not a duplicate definition of `S`\n+}\n+\n+fn main() {}"}, {"sha": "1623d6777263991c7bccc02d4ed81f27b63ef38a", "filename": "src/test/ui/proc-macro/nonterminal-token-hygiene.stdout", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/1773f60ea5d42e86b8fdf78d2fc5221ead222bc1/src%2Ftest%2Fui%2Fproc-macro%2Fnonterminal-token-hygiene.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/1773f60ea5d42e86b8fdf78d2fc5221ead222bc1/src%2Ftest%2Fui%2Fproc-macro%2Fnonterminal-token-hygiene.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fnonterminal-token-hygiene.stdout?ref=1773f60ea5d42e86b8fdf78d2fc5221ead222bc1", "patch": "@@ -0,0 +1,88 @@\n+PRINT-BANG INPUT (DISPLAY): struct S;\n+PRINT-BANG RE-COLLECTED (DISPLAY): struct S ;\n+PRINT-BANG INPUT (DEBUG): TokenStream [\n+    Group {\n+        delimiter: None,\n+        stream: TokenStream [\n+            Ident {\n+                ident: \"struct\",\n+                span: $DIR/nonterminal-token-hygiene.rs:30:5: 30:11 (#5),\n+            },\n+            Ident {\n+                ident: \"S\",\n+                span: $DIR/nonterminal-token-hygiene.rs:30:12: 30:13 (#5),\n+            },\n+            Punct {\n+                ch: ';',\n+                spacing: Alone,\n+                span: $DIR/nonterminal-token-hygiene.rs:30:13: 30:14 (#5),\n+            },\n+        ],\n+        span: $DIR/nonterminal-token-hygiene.rs:20:27: 20:32 (#6),\n+    },\n+]\n+#![feature /* 0#0 */(prelude_import)]\n+#![no_std /* 0#0 */]\n+// Make sure that marks from declarative macros are applied to tokens in nonterminal.\n+\n+// check-pass\n+// compile-flags: -Z span-debug -Z macro-backtrace -Z unpretty=expanded,hygiene\n+// compile-flags: -Z trim-diagnostic-paths=no\n+// normalize-stdout-test \"\\d+#\" -> \"0#\"\n+// aux-build:test-macros.rs\n+\n+#![feature /* 0#0 */(decl_macro)]\n+\n+#![no_std /* 0#0 */]\n+#[prelude_import /* 0#1 */]\n+use ::core /* 0#1 */::prelude /* 0#1 */::v1 /* 0#1 */::*;\n+#[macro_use /* 0#1 */]\n+extern crate core /* 0#2 */;\n+#[macro_use /* 0#1 */]\n+extern crate compiler_builtins /* 0#2 */;\n+// Don't load unnecessary hygiene information from std\n+extern crate std /* 0#0 */;\n+\n+#[macro_use /* 0#0 */]\n+extern crate test_macros /* 0#0 */;\n+\n+macro_rules! outer\n+    /*\n+    0#0\n+    */ {\n+    ($ item : item) =>\n+    {\n+        macro inner() { print_bang ! { $ item } } inner ! () ;\n+\n+    } ;\n+}\n+\n+struct S /* 0#0 */;\n+macro inner /* 0#4 */ { () => { print_bang ! { struct S; } } }\n+\n+struct S /* 0#5 */;\n+// OK, not a duplicate definition of `S`\n+\n+fn main /* 0#0 */() { }\n+\n+/*\n+Expansions:\n+0: parent: ExpnId(0), call_site_ctxt: #0, def_site_ctxt: #0, kind: Root\n+1: parent: ExpnId(0), call_site_ctxt: #0, def_site_ctxt: #0, kind: AstPass(StdImports)\n+2: parent: ExpnId(0), call_site_ctxt: #0, def_site_ctxt: #0, kind: Macro(Bang, \"outer\")\n+3: parent: ExpnId(0), call_site_ctxt: #0, def_site_ctxt: #0, kind: AstPass(StdImports)\n+4: parent: ExpnId(2), call_site_ctxt: #4, def_site_ctxt: #4, kind: Macro(Bang, \"inner\")\n+5: parent: ExpnId(4), call_site_ctxt: #6, def_site_ctxt: #0, kind: Macro(Bang, \"print_bang\")\n+\n+SyntaxContexts:\n+#0: parent: #0, outer_mark: (ExpnId(0), Opaque)\n+#1: parent: #0, outer_mark: (ExpnId(1), Opaque)\n+#2: parent: #0, outer_mark: (ExpnId(1), Transparent)\n+#3: parent: #0, outer_mark: (ExpnId(3), Opaque)\n+#4: parent: #0, outer_mark: (ExpnId(2), SemiTransparent)\n+#5: parent: #0, outer_mark: (ExpnId(4), Opaque)\n+#6: parent: #4, outer_mark: (ExpnId(4), Opaque)\n+#7: parent: #0, outer_mark: (ExpnId(5), Opaque)\n+#8: parent: #6, outer_mark: (ExpnId(5), Transparent)\n+#9: parent: #5, outer_mark: (ExpnId(5), SemiTransparent)\n+*/"}]}