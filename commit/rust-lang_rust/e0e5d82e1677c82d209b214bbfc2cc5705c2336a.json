{"sha": "e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUwZTVkODJlMTY3N2M4MmQyMDliMjE0YmJmYzJjYzU3MDVjMjMzNmE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-18T22:29:06Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-18T22:29:06Z"}, "message": "Auto merge of #69271 - Centril:rollup-iupsol6, r=Centril\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #69146 (Always const qualify literals by type)\n - #69159 (Select an appropriate unused lifetime name in suggestion)\n - #69194 (parse: fuse associated and extern items up to defaultness)\n - #69211 (parser: Simplify treatment of macro variables in `Parser::bump`)\n - #69217 (Do not emit note suggesting to implement operation trait to foreign type)\n - #69236 (parse: recover `mut (x @ y)` as `(mut x @ mut y)`.)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "39649c075dab42df78c94de2fafa81466fc7694d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/39649c075dab42df78c94de2fafa81466fc7694d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "html_url": "https://github.com/rust-lang/rust/commit/e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e620d0f337d0643c757bab791fc7d88d63217704", "url": "https://api.github.com/repos/rust-lang/rust/commits/e620d0f337d0643c757bab791fc7d88d63217704", "html_url": "https://github.com/rust-lang/rust/commit/e620d0f337d0643c757bab791fc7d88d63217704"}, {"sha": "6c6d45c6e7ca1e7685e2556d9f58b6f3109c13bf", "url": "https://api.github.com/repos/rust-lang/rust/commits/6c6d45c6e7ca1e7685e2556d9f58b6f3109c13bf", "html_url": "https://github.com/rust-lang/rust/commit/6c6d45c6e7ca1e7685e2556d9f58b6f3109c13bf"}], "stats": {"total": 2512, "additions": 1576, "deletions": 936}, "files": [{"sha": "cb43f7475b89a513edfdcf22409dd7f82ddcfb62", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 38, "deletions": 2, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -697,7 +697,7 @@ impl<'tcx> ty::TyS<'tcx> {\n     /// strange rules like `<T as Foo<'static>>::Bar: Sized` that\n     /// actually carry lifetime requirements.\n     pub fn is_sized(&'tcx self, tcx_at: TyCtxtAt<'tcx>, param_env: ty::ParamEnv<'tcx>) -> bool {\n-        tcx_at.is_sized_raw(param_env.and(self))\n+        self.is_trivially_sized(tcx_at.tcx) || tcx_at.is_sized_raw(param_env.and(self))\n     }\n \n     /// Checks whether values of this type `T` implement the `Freeze`\n@@ -713,7 +713,43 @@ impl<'tcx> ty::TyS<'tcx> {\n         param_env: ty::ParamEnv<'tcx>,\n         span: Span,\n     ) -> bool {\n-        tcx.at(span).is_freeze_raw(param_env.and(self))\n+        self.is_trivially_freeze() || tcx.at(span).is_freeze_raw(param_env.and(self))\n+    }\n+\n+    /// Fast path helper for testing if a type is `Freeze`.\n+    ///\n+    /// Returning true means the type is known to be `Freeze`. Returning\n+    /// `false` means nothing -- could be `Freeze`, might not be.\n+    fn is_trivially_freeze(&self) -> bool {\n+        match self.kind {\n+            ty::Int(_)\n+            | ty::Uint(_)\n+            | ty::Float(_)\n+            | ty::Bool\n+            | ty::Char\n+            | ty::Str\n+            | ty::Never\n+            | ty::Ref(..)\n+            | ty::RawPtr(_)\n+            | ty::FnDef(..)\n+            | ty::Error\n+            | ty::FnPtr(_) => true,\n+            ty::Tuple(_) => self.tuple_fields().all(Self::is_trivially_freeze),\n+            ty::Slice(elem_ty) | ty::Array(elem_ty, _) => elem_ty.is_trivially_freeze(),\n+            ty::Adt(..)\n+            | ty::Bound(..)\n+            | ty::Closure(..)\n+            | ty::Dynamic(..)\n+            | ty::Foreign(_)\n+            | ty::Generator(..)\n+            | ty::GeneratorWitness(_)\n+            | ty::Infer(_)\n+            | ty::Opaque(..)\n+            | ty::Param(_)\n+            | ty::Placeholder(_)\n+            | ty::Projection(_)\n+            | ty::UnnormalizedProjection(_) => false,\n+        }\n     }\n \n     /// If `ty.needs_drop(...)` returns `true`, then `ty` is definitely"}, {"sha": "e0db8606bc203148b37dcaa5d5814e729cfaf34e", "filename": "src/librustc_ast_lowering/item.rs", "status": "modified", "additions": 53, "deletions": 49, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Flibrustc_ast_lowering%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Flibrustc_ast_lowering%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Fitem.rs?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -269,26 +269,12 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 self.lower_use_tree(use_tree, &prefix, id, vis, ident, attrs)\n             }\n             ItemKind::Static(ref t, m, ref e) => {\n-                let ty = self.lower_ty(\n-                    t,\n-                    if self.sess.features_untracked().impl_trait_in_bindings {\n-                        ImplTraitContext::OpaqueTy(None, hir::OpaqueTyOrigin::Misc)\n-                    } else {\n-                        ImplTraitContext::Disallowed(ImplTraitPosition::Binding)\n-                    },\n-                );\n-                hir::ItemKind::Static(ty, m, self.lower_const_body(span, Some(e)))\n+                let (ty, body_id) = self.lower_const_item(t, span, e.as_deref());\n+                hir::ItemKind::Static(ty, m, body_id)\n             }\n             ItemKind::Const(ref t, ref e) => {\n-                let ty = self.lower_ty(\n-                    t,\n-                    if self.sess.features_untracked().impl_trait_in_bindings {\n-                        ImplTraitContext::OpaqueTy(None, hir::OpaqueTyOrigin::Misc)\n-                    } else {\n-                        ImplTraitContext::Disallowed(ImplTraitPosition::Binding)\n-                    },\n-                );\n-                hir::ItemKind::Const(ty, self.lower_const_body(span, Some(e)))\n+                let (ty, body_id) = self.lower_const_item(t, span, e.as_deref());\n+                hir::ItemKind::Const(ty, body_id)\n             }\n             ItemKind::Fn(FnSig { ref decl, header }, ref generics, ref body) => {\n                 let fn_def_id = self.resolver.definitions().local_def_id(id);\n@@ -457,6 +443,21 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         //     not cause an assertion failure inside the `lower_defaultness` function.\n     }\n \n+    fn lower_const_item(\n+        &mut self,\n+        ty: &Ty,\n+        span: Span,\n+        body: Option<&Expr>,\n+    ) -> (&'hir hir::Ty<'hir>, hir::BodyId) {\n+        let itctx = if self.sess.features_untracked().impl_trait_in_bindings {\n+            ImplTraitContext::OpaqueTy(None, hir::OpaqueTyOrigin::Misc)\n+        } else {\n+            ImplTraitContext::Disallowed(ImplTraitPosition::Binding)\n+        };\n+        let ty = self.lower_ty(ty, itctx);\n+        (ty, self.lower_const_body(span, body))\n+    }\n+\n     fn lower_use_tree(\n         &mut self,\n         tree: &UseTree,\n@@ -678,11 +679,16 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n                     hir::ForeignItemKind::Fn(fn_dec, fn_args, generics)\n                 }\n-                ForeignItemKind::Static(ref t, m) => {\n+                ForeignItemKind::Static(ref t, m, _) => {\n                     let ty = self.lower_ty(t, ImplTraitContext::disallowed());\n                     hir::ForeignItemKind::Static(ty, m)\n                 }\n-                ForeignItemKind::Ty => hir::ForeignItemKind::Type,\n+                ForeignItemKind::Const(ref t, _) => {\n+                    // For recovery purposes.\n+                    let ty = self.lower_ty(t, ImplTraitContext::disallowed());\n+                    hir::ForeignItemKind::Static(ty, Mutability::Not)\n+                }\n+                ForeignItemKind::TyAlias(..) => hir::ForeignItemKind::Type,\n                 ForeignItemKind::Macro(_) => panic!(\"macro shouldn't exist here\"),\n             },\n             vis: self.lower_visibility(&i.vis, None),\n@@ -759,32 +765,27 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         let trait_item_def_id = self.resolver.definitions().local_def_id(i.id);\n \n         let (generics, kind) = match i.kind {\n-            AssocItemKind::Const(ref ty, ref default) => {\n-                let generics = self.lower_generics(&i.generics, ImplTraitContext::disallowed());\n+            AssocItemKind::Static(ref ty, _, ref default) // Let's pretend this is a `const`.\n+            | AssocItemKind::Const(ref ty, ref default) => {\n                 let ty = self.lower_ty(ty, ImplTraitContext::disallowed());\n-                (\n-                    generics,\n-                    hir::TraitItemKind::Const(\n-                        ty,\n-                        default.as_ref().map(|x| self.lower_const_body(i.span, Some(x))),\n-                    ),\n-                )\n+                let body = default.as_ref().map(|x| self.lower_const_body(i.span, Some(x)));\n+                (hir::Generics::empty(), hir::TraitItemKind::Const(ty, body))\n             }\n-            AssocItemKind::Fn(ref sig, None) => {\n+            AssocItemKind::Fn(ref sig, ref generics, None) => {\n                 let names = self.lower_fn_params_to_names(&sig.decl);\n                 let (generics, sig) =\n-                    self.lower_method_sig(&i.generics, sig, trait_item_def_id, false, None);\n+                    self.lower_method_sig(generics, sig, trait_item_def_id, false, None);\n                 (generics, hir::TraitItemKind::Method(sig, hir::TraitMethod::Required(names)))\n             }\n-            AssocItemKind::Fn(ref sig, Some(ref body)) => {\n+            AssocItemKind::Fn(ref sig, ref generics, Some(ref body)) => {\n                 let body_id = self.lower_fn_body_block(i.span, &sig.decl, Some(body));\n                 let (generics, sig) =\n-                    self.lower_method_sig(&i.generics, sig, trait_item_def_id, false, None);\n+                    self.lower_method_sig(generics, sig, trait_item_def_id, false, None);\n                 (generics, hir::TraitItemKind::Method(sig, hir::TraitMethod::Provided(body_id)))\n             }\n-            AssocItemKind::TyAlias(ref bounds, ref default) => {\n+            AssocItemKind::TyAlias(ref generics, ref bounds, ref default) => {\n                 let ty = default.as_ref().map(|x| self.lower_ty(x, ImplTraitContext::disallowed()));\n-                let generics = self.lower_generics(&i.generics, ImplTraitContext::disallowed());\n+                let generics = self.lower_generics(generics, ImplTraitContext::disallowed());\n                 let kind = hir::TraitItemKind::Type(\n                     self.lower_param_bounds(bounds, ImplTraitContext::disallowed()),\n                     ty,\n@@ -806,10 +807,13 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     }\n \n     fn lower_trait_item_ref(&mut self, i: &AssocItem) -> hir::TraitItemRef {\n-        let (kind, has_default) = match i.kind {\n-            AssocItemKind::Const(_, ref default) => (hir::AssocItemKind::Const, default.is_some()),\n-            AssocItemKind::TyAlias(_, ref default) => (hir::AssocItemKind::Type, default.is_some()),\n-            AssocItemKind::Fn(ref sig, ref default) => {\n+        let (kind, has_default) = match &i.kind {\n+            AssocItemKind::Static(_, _, default) // Let's pretend this is a `const` for recovery.\n+            | AssocItemKind::Const(_, default) => {\n+                (hir::AssocItemKind::Const, default.is_some())\n+            }\n+            AssocItemKind::TyAlias(_, _, default) => (hir::AssocItemKind::Type, default.is_some()),\n+            AssocItemKind::Fn(sig, _, default) => {\n                 (hir::AssocItemKind::Method { has_self: sig.decl.has_self() }, default.is_some())\n             }\n             AssocItemKind::Macro(..) => unimplemented!(),\n@@ -832,22 +836,21 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         let impl_item_def_id = self.resolver.definitions().local_def_id(i.id);\n \n         let (generics, kind) = match i.kind {\n-            AssocItemKind::Const(ref ty, ref expr) => {\n-                let generics = self.lower_generics(&i.generics, ImplTraitContext::disallowed());\n+            AssocItemKind::Static(ref ty, _, ref expr) | AssocItemKind::Const(ref ty, ref expr) => {\n                 let ty = self.lower_ty(ty, ImplTraitContext::disallowed());\n                 (\n-                    generics,\n+                    hir::Generics::empty(),\n                     hir::ImplItemKind::Const(ty, self.lower_const_body(i.span, expr.as_deref())),\n                 )\n             }\n-            AssocItemKind::Fn(ref sig, ref body) => {\n+            AssocItemKind::Fn(ref sig, ref generics, ref body) => {\n                 self.current_item = Some(i.span);\n                 let asyncness = sig.header.asyncness;\n                 let body_id =\n                     self.lower_maybe_async_body(i.span, &sig.decl, asyncness, body.as_deref());\n                 let impl_trait_return_allow = !self.is_in_trait_impl;\n                 let (generics, sig) = self.lower_method_sig(\n-                    &i.generics,\n+                    generics,\n                     sig,\n                     impl_item_def_id,\n                     impl_trait_return_allow,\n@@ -856,8 +859,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n                 (generics, hir::ImplItemKind::Method(sig, body_id))\n             }\n-            AssocItemKind::TyAlias(_, ref ty) => {\n-                let generics = self.lower_generics(&i.generics, ImplTraitContext::disallowed());\n+            AssocItemKind::TyAlias(ref generics, _, ref ty) => {\n+                let generics = self.lower_generics(generics, ImplTraitContext::disallowed());\n                 let kind = match ty {\n                     None => {\n                         let ty = self.arena.alloc(self.ty(i.span, hir::TyKind::Err));\n@@ -901,14 +904,15 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             vis: self.lower_visibility(&i.vis, Some(i.id)),\n             defaultness: self.lower_defaultness(i.defaultness, true /* [1] */),\n             kind: match &i.kind {\n-                AssocItemKind::Const(..) => hir::AssocItemKind::Const,\n-                AssocItemKind::TyAlias(_, ty) => {\n+                AssocItemKind::Static(..) // Let's pretend this is a `const` for recovery.\n+                | AssocItemKind::Const(..) => hir::AssocItemKind::Const,\n+                AssocItemKind::TyAlias(_, _, ty) => {\n                     match ty.as_deref().and_then(|ty| ty.kind.opaque_top_hack()) {\n                         None => hir::AssocItemKind::Type,\n                         Some(_) => hir::AssocItemKind::OpaqueTy,\n                     }\n                 }\n-                AssocItemKind::Fn(sig, _) => {\n+                AssocItemKind::Fn(sig, _, _) => {\n                     hir::AssocItemKind::Method { has_self: sig.decl.has_self() }\n                 }\n                 AssocItemKind::Macro(..) => unimplemented!(),"}, {"sha": "ac4ca30382fee6746773bdfd4a2e8852788edcbf", "filename": "src/librustc_ast_lowering/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Flibrustc_ast_lowering%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Flibrustc_ast_lowering%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Flib.rs?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -490,7 +490,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 self.lctx.allocate_hir_id_counter(item.id);\n                 let owner = match (&item.kind, ctxt) {\n                     // Ignore patterns in trait methods without bodies.\n-                    (AssocItemKind::Fn(_, None), AssocCtxt::Trait) => None,\n+                    (AssocItemKind::Fn(_, _, None), AssocCtxt::Trait) => None,\n                     _ => Some(item.id),\n                 };\n                 self.with_hir_id_owner(owner, |this| visit::walk_assoc_item(this, item, ctxt));"}, {"sha": "1194269e0ee9638af9cda5276852d70d6f744f26", "filename": "src/librustc_ast_passes/ast_validation.rs", "status": "modified", "additions": 89, "deletions": 8, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Flibrustc_ast_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Flibrustc_ast_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_passes%2Fast_validation.rs?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -22,6 +22,9 @@ use syntax::expand::is_proc_macro_attr;\n use syntax::visit::{self, AssocCtxt, FnCtxt, FnKind, Visitor};\n use syntax::walk_list;\n \n+const MORE_EXTERN: &str =\n+    \"for more information, visit https://doc.rust-lang.org/std/keyword.extern.html\";\n+\n /// Is `self` allowed semantically as the first parameter in an `FnDecl`?\n enum SelfSemantic {\n     Yes,\n@@ -423,14 +426,62 @@ impl<'a> AstValidator<'a> {\n         }\n     }\n \n-    fn check_impl_assoc_type_no_bounds(&self, bounds: &[GenericBound]) {\n+    fn check_type_no_bounds(&self, bounds: &[GenericBound], ctx: &str) {\n         let span = match bounds {\n             [] => return,\n             [b0] => b0.span(),\n             [b0, .., bl] => b0.span().to(bl.span()),\n         };\n         self.err_handler()\n-            .struct_span_err(span, \"bounds on associated `type`s in `impl`s have no effect\")\n+            .struct_span_err(span, &format!(\"bounds on `type`s in {} have no effect\", ctx))\n+            .emit();\n+    }\n+\n+    fn check_foreign_ty_genericless(&self, generics: &Generics) {\n+        let cannot_have = |span, descr, remove_descr| {\n+            self.err_handler()\n+                .struct_span_err(\n+                    span,\n+                    &format!(\"`type`s inside `extern` blocks cannot have {}\", descr),\n+                )\n+                .span_suggestion(\n+                    span,\n+                    &format!(\"remove the {}\", remove_descr),\n+                    String::new(),\n+                    Applicability::MaybeIncorrect,\n+                )\n+                .span_label(self.current_extern_span(), \"`extern` block begins here\")\n+                .note(MORE_EXTERN)\n+                .emit();\n+        };\n+\n+        if !generics.params.is_empty() {\n+            cannot_have(generics.span, \"generic parameters\", \"generic parameters\");\n+        }\n+\n+        if !generics.where_clause.predicates.is_empty() {\n+            cannot_have(generics.where_clause.span, \"`where` clauses\", \"`where` clause\");\n+        }\n+    }\n+\n+    fn check_foreign_kind_bodyless(&self, ident: Ident, kind: &str, body: Option<Span>) {\n+        let body = match body {\n+            None => return,\n+            Some(body) => body,\n+        };\n+        self.err_handler()\n+            .struct_span_err(ident.span, &format!(\"incorrect `{}` inside `extern` block\", kind))\n+            .span_label(ident.span, \"cannot have a body\")\n+            .span_label(body, \"the invalid body\")\n+            .span_label(\n+                self.current_extern_span(),\n+                format!(\n+                    \"`extern` blocks define existing foreign {0}s and {0}s \\\n+                    inside of them cannot have a body\",\n+                    kind\n+                ),\n+            )\n+            .note(MORE_EXTERN)\n             .emit();\n     }\n \n@@ -458,7 +509,7 @@ impl<'a> AstValidator<'a> {\n                 \"`extern` blocks define existing foreign functions and functions \\\n                 inside of them cannot have a body\",\n             )\n-            .note(\"for more information, visit https://doc.rust-lang.org/std/keyword.extern.html\")\n+            .note(MORE_EXTERN)\n             .emit();\n     }\n \n@@ -531,6 +582,16 @@ impl<'a> AstValidator<'a> {\n             }\n         }\n     }\n+\n+    fn check_item_named(&self, ident: Ident, kind: &str) {\n+        if ident.name != kw::Underscore {\n+            return;\n+        }\n+        self.err_handler()\n+            .struct_span_err(ident.span, &format!(\"`{}` items in this context need a name\", kind))\n+            .span_label(ident.span, format!(\"`_` is not a valid name for this `{}` item\", kind))\n+            .emit();\n+    }\n }\n \n enum GenericPosition {\n@@ -900,6 +961,14 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                     self.err_handler().span_err(item.span, \"unions cannot have zero fields\");\n                 }\n             }\n+            ItemKind::Const(.., None) => {\n+                let msg = \"free constant item without body\";\n+                self.error_item_without_body(item.span, \"constant\", msg, \" = <expr>;\");\n+            }\n+            ItemKind::Static(.., None) => {\n+                let msg = \"free static item without body\";\n+                self.error_item_without_body(item.span, \"static\", msg, \" = <expr>;\");\n+            }\n             _ => {}\n         }\n \n@@ -912,7 +981,15 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 self.check_foreign_fn_bodyless(fi.ident, body.as_deref());\n                 self.check_foreign_fn_headerless(fi.ident, fi.span, sig.header);\n             }\n-            ForeignItemKind::Static(..) | ForeignItemKind::Ty | ForeignItemKind::Macro(..) => {}\n+            ForeignItemKind::TyAlias(generics, bounds, body) => {\n+                self.check_foreign_kind_bodyless(fi.ident, \"type\", body.as_ref().map(|b| b.span));\n+                self.check_type_no_bounds(bounds, \"`extern` blocks\");\n+                self.check_foreign_ty_genericless(generics);\n+            }\n+            ForeignItemKind::Static(_, _, body) => {\n+                self.check_foreign_kind_bodyless(fi.ident, \"static\", body.as_ref().map(|b| b.span));\n+            }\n+            ForeignItemKind::Const(..) | ForeignItemKind::Macro(..) => {}\n         }\n \n         visit::walk_foreign_item(self, fi)\n@@ -1154,25 +1231,29 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 AssocItemKind::Const(_, body) => {\n                     self.check_impl_item_provided(item.span, body, \"constant\", \" = <expr>;\");\n                 }\n-                AssocItemKind::Fn(_, body) => {\n+                AssocItemKind::Fn(_, _, body) => {\n                     self.check_impl_item_provided(item.span, body, \"function\", \" { <body> }\");\n                 }\n-                AssocItemKind::TyAlias(bounds, body) => {\n+                AssocItemKind::TyAlias(_, bounds, body) => {\n                     self.check_impl_item_provided(item.span, body, \"type\", \" = <type>;\");\n-                    self.check_impl_assoc_type_no_bounds(bounds);\n+                    self.check_type_no_bounds(bounds, \"`impl`s\");\n                 }\n                 _ => {}\n             }\n         }\n \n         if ctxt == AssocCtxt::Trait || self.in_trait_impl {\n             self.invalid_visibility(&item.vis, None);\n-            if let AssocItemKind::Fn(sig, _) = &item.kind {\n+            if let AssocItemKind::Fn(sig, _, _) = &item.kind {\n                 self.check_trait_fn_not_const(sig.header.constness);\n                 self.check_trait_fn_not_async(item.span, sig.header.asyncness);\n             }\n         }\n \n+        if let AssocItemKind::Const(..) = item.kind {\n+            self.check_item_named(item.ident, \"const\");\n+        }\n+\n         self.with_in_trait_impl(false, |this| visit::walk_assoc_item(this, item, ctxt));\n     }\n }"}, {"sha": "3c924847a7364c75c28e4c08397b52036e7e677a", "filename": "src/librustc_ast_passes/feature_gate.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Flibrustc_ast_passes%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Flibrustc_ast_passes%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_passes%2Ffeature_gate.rs?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -397,10 +397,10 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n                     );\n                 }\n             }\n-            ast::ForeignItemKind::Ty => {\n+            ast::ForeignItemKind::TyAlias(..) => {\n                 gate_feature_post!(&self, extern_types, i.span, \"extern types are experimental\");\n             }\n-            ast::ForeignItemKind::Macro(..) => {}\n+            ast::ForeignItemKind::Macro(..) | ast::ForeignItemKind::Const(..) => {}\n         }\n \n         visit::walk_foreign_item(self, i)\n@@ -548,12 +548,12 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n         }\n \n         match i.kind {\n-            ast::AssocItemKind::Fn(ref sig, _) => {\n+            ast::AssocItemKind::Fn(ref sig, _, _) => {\n                 if let (ast::Const::Yes(_), AssocCtxt::Trait) = (sig.header.constness, ctxt) {\n                     gate_feature_post!(&self, const_fn, i.span, \"const fn is unstable\");\n                 }\n             }\n-            ast::AssocItemKind::TyAlias(_, ref ty) => {\n+            ast::AssocItemKind::TyAlias(ref generics, _, ref ty) => {\n                 if let (Some(_), AssocCtxt::Trait) = (ty, ctxt) {\n                     gate_feature_post!(\n                         &self,\n@@ -565,7 +565,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n                 if let Some(ty) = ty {\n                     self.check_impl_trait(ty);\n                 }\n-                self.check_gat(&i.generics, i.span);\n+                self.check_gat(generics, i.span);\n             }\n             _ => {}\n         }"}, {"sha": "6e1567ce34eba7795caeab0a7266f4b36dccb128", "filename": "src/librustc_ast_pretty/pprust.rs", "status": "modified", "additions": 52, "deletions": 83, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Flibrustc_ast_pretty%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Flibrustc_ast_pretty%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_pretty%2Fpprust.rs?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -912,7 +912,7 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    crate fn print_foreign_mod(&mut self, nmod: &ast::ForeignMod, attrs: &[ast::Attribute]) {\n+    crate fn print_foreign_mod(&mut self, nmod: &ast::ForeignMod, attrs: &[Attribute]) {\n         self.print_inner_attributes(attrs);\n         for item in &nmod.items {\n             self.print_foreign_item(item);\n@@ -1016,59 +1016,73 @@ impl<'a> State<'a> {\n     }\n \n     crate fn print_foreign_item(&mut self, item: &ast::ForeignItem) {\n+        let ast::ForeignItem { id, span, ident, attrs, kind, vis, tokens: _ } = item;\n+        self.print_nested_item_kind(*id, *span, *ident, attrs, ast::Defaultness::Final, kind, vis);\n+    }\n+\n+    fn print_nested_item_kind(\n+        &mut self,\n+        id: ast::NodeId,\n+        span: Span,\n+        ident: ast::Ident,\n+        attrs: &[Attribute],\n+        defaultness: ast::Defaultness,\n+        kind: &ast::AssocItemKind,\n+        vis: &ast::Visibility,\n+    ) {\n+        self.ann.pre(self, AnnNode::SubItem(id));\n         self.hardbreak_if_not_bol();\n-        self.maybe_print_comment(item.span.lo());\n-        self.print_outer_attributes(&item.attrs);\n-        match item.kind {\n-            ast::ForeignItemKind::Fn(ref sig, ref gen, ref body) => {\n-                self.print_fn_full(sig, item.ident, gen, &item.vis, body.as_deref(), &item.attrs);\n+        self.maybe_print_comment(span.lo());\n+        self.print_outer_attributes(attrs);\n+        self.print_defaultness(defaultness);\n+        match kind {\n+            ast::ForeignItemKind::Fn(sig, gen, body) => {\n+                self.print_fn_full(sig, ident, gen, vis, body.as_deref(), attrs);\n             }\n-            ast::ForeignItemKind::Static(ref t, m) => {\n-                self.head(visibility_qualified(&item.vis, \"static\"));\n-                if m == ast::Mutability::Mut {\n-                    self.word_space(\"mut\");\n-                }\n-                self.print_ident(item.ident);\n-                self.word_space(\":\");\n-                self.print_type(t);\n-                self.s.word(\";\");\n-                self.end(); // end the head-ibox\n-                self.end(); // end the outer cbox\n+            ast::ForeignItemKind::Const(ty, body) => {\n+                self.print_item_const(ident, None, ty, body.as_deref(), vis);\n             }\n-            ast::ForeignItemKind::Ty => {\n-                self.head(visibility_qualified(&item.vis, \"type\"));\n-                self.print_ident(item.ident);\n-                self.s.word(\";\");\n-                self.end(); // end the head-ibox\n-                self.end(); // end the outer cbox\n+            ast::ForeignItemKind::Static(ty, mutbl, body) => {\n+                self.print_item_const(ident, Some(*mutbl), ty, body.as_deref(), vis);\n+            }\n+            ast::ForeignItemKind::TyAlias(generics, bounds, ty) => {\n+                self.print_associated_type(ident, generics, bounds, ty.as_deref());\n             }\n-            ast::ForeignItemKind::Macro(ref m) => {\n+            ast::ForeignItemKind::Macro(m) => {\n                 self.print_mac(m);\n                 if m.args.need_semicolon() {\n                     self.s.word(\";\");\n                 }\n             }\n         }\n+        self.ann.post(self, AnnNode::SubItem(id))\n     }\n \n-    fn print_associated_const(\n+    fn print_item_const(\n         &mut self,\n         ident: ast::Ident,\n+        mutbl: Option<ast::Mutability>,\n         ty: &ast::Ty,\n-        default: Option<&ast::Expr>,\n+        body: Option<&ast::Expr>,\n         vis: &ast::Visibility,\n     ) {\n-        self.s.word(visibility_qualified(vis, \"\"));\n-        self.word_space(\"const\");\n+        let leading = match mutbl {\n+            None => \"const\",\n+            Some(ast::Mutability::Not) => \"static\",\n+            Some(ast::Mutability::Mut) => \"static mut\",\n+        };\n+        self.head(visibility_qualified(vis, leading));\n         self.print_ident(ident);\n         self.word_space(\":\");\n         self.print_type(ty);\n-        if let Some(expr) = default {\n-            self.s.space();\n+        self.s.space();\n+        self.end(); // end the head-ibox\n+        if let Some(body) = body {\n             self.word_space(\"=\");\n-            self.print_expr(expr);\n+            self.print_expr(body);\n         }\n-        self.s.word(\";\")\n+        self.s.word(\";\");\n+        self.end(); // end the outer cbox\n     }\n \n     fn print_associated_type(\n@@ -1118,34 +1132,11 @@ impl<'a> State<'a> {\n                 self.end(); // end inner head-block\n                 self.end(); // end outer head-block\n             }\n-            ast::ItemKind::Static(ref ty, m, ref expr) => {\n-                self.head(visibility_qualified(&item.vis, \"static\"));\n-                if m == ast::Mutability::Mut {\n-                    self.word_space(\"mut\");\n-                }\n-                self.print_ident(item.ident);\n-                self.word_space(\":\");\n-                self.print_type(ty);\n-                self.s.space();\n-                self.end(); // end the head-ibox\n-\n-                self.word_space(\"=\");\n-                self.print_expr(expr);\n-                self.s.word(\";\");\n-                self.end(); // end the outer cbox\n+            ast::ItemKind::Static(ref ty, mutbl, ref body) => {\n+                self.print_item_const(item.ident, Some(mutbl), ty, body.as_deref(), &item.vis);\n             }\n-            ast::ItemKind::Const(ref ty, ref expr) => {\n-                self.head(visibility_qualified(&item.vis, \"const\"));\n-                self.print_ident(item.ident);\n-                self.word_space(\":\");\n-                self.print_type(ty);\n-                self.s.space();\n-                self.end(); // end the head-ibox\n-\n-                self.word_space(\"=\");\n-                self.print_expr(expr);\n-                self.s.word(\";\");\n-                self.end(); // end the outer cbox\n+            ast::ItemKind::Const(ref ty, ref body) => {\n+                self.print_item_const(item.ident, None, ty, body.as_deref(), &item.vis);\n             }\n             ast::ItemKind::Fn(ref sig, ref gen, ref body) => {\n                 self.print_fn_full(sig, item.ident, gen, &item.vis, body.as_deref(), &item.attrs);\n@@ -1464,30 +1455,8 @@ impl<'a> State<'a> {\n     }\n \n     crate fn print_assoc_item(&mut self, item: &ast::AssocItem) {\n-        self.ann.pre(self, AnnNode::SubItem(item.id));\n-        self.hardbreak_if_not_bol();\n-        self.maybe_print_comment(item.span.lo());\n-        self.print_outer_attributes(&item.attrs);\n-        self.print_defaultness(item.defaultness);\n-        match &item.kind {\n-            ast::AssocItemKind::Const(ty, expr) => {\n-                self.print_associated_const(item.ident, ty, expr.as_deref(), &item.vis);\n-            }\n-            ast::AssocItemKind::Fn(sig, body) => {\n-                let body = body.as_deref();\n-                self.print_fn_full(sig, item.ident, &item.generics, &item.vis, body, &item.attrs);\n-            }\n-            ast::AssocItemKind::TyAlias(bounds, ty) => {\n-                self.print_associated_type(item.ident, &item.generics, bounds, ty.as_deref());\n-            }\n-            ast::AssocItemKind::Macro(mac) => {\n-                self.print_mac(mac);\n-                if mac.args.need_semicolon() {\n-                    self.s.word(\";\");\n-                }\n-            }\n-        }\n-        self.ann.post(self, AnnNode::SubItem(item.id))\n+        let ast::AssocItem { id, span, ident, attrs, defaultness, kind, vis, tokens: _ } = item;\n+        self.print_nested_item_kind(*id, *span, *ident, attrs, *defaultness, kind, vis);\n     }\n \n     crate fn print_stmt(&mut self, st: &ast::Stmt) {"}, {"sha": "294b7463916b89d9d18137dfe0ea7503d79816ea", "filename": "src/librustc_builtin_macros/deriving/generic/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Flibrustc_builtin_macros%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Flibrustc_builtin_macros%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fderiving%2Fgeneric%2Fmod.rs?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -544,8 +544,8 @@ impl<'a> TraitDef<'a> {\n                 vis: respan(self.span.shrink_to_lo(), ast::VisibilityKind::Inherited),\n                 defaultness: ast::Defaultness::Final,\n                 attrs: Vec::new(),\n-                generics: Generics::default(),\n                 kind: ast::AssocItemKind::TyAlias(\n+                    Generics::default(),\n                     Vec::new(),\n                     Some(type_def.to_ty(cx, self.span, type_ident, generics)),\n                 ),\n@@ -973,12 +973,11 @@ impl<'a> MethodDef<'a> {\n         P(ast::AssocItem {\n             id: ast::DUMMY_NODE_ID,\n             attrs: self.attributes.clone(),\n-            generics: fn_generics,\n             span: trait_.span,\n             vis: respan(trait_lo_sp, ast::VisibilityKind::Inherited),\n             defaultness: ast::Defaultness::Final,\n             ident: method_ident,\n-            kind: ast::AssocItemKind::Fn(sig, Some(body_block)),\n+            kind: ast::AssocItemKind::Fn(sig, fn_generics, Some(body_block)),\n             tokens: None,\n         })\n     }"}, {"sha": "e15405e1f0dfc8955192d17133cc6d4b429d09a3", "filename": "src/librustc_builtin_macros/test.rs", "status": "modified", "additions": 76, "deletions": 72, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Flibrustc_builtin_macros%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Flibrustc_builtin_macros%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Ftest.rs?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -186,81 +186,85 @@ pub fn expand_test_or_bench(\n         ast::ItemKind::Const(\n             cx.ty(sp, ast::TyKind::Path(None, test_path(\"TestDescAndFn\"))),\n             // test::TestDescAndFn {\n-            cx.expr_struct(\n-                sp,\n-                test_path(\"TestDescAndFn\"),\n-                vec![\n-                    // desc: test::TestDesc {\n-                    field(\n-                        \"desc\",\n-                        cx.expr_struct(\n-                            sp,\n-                            test_path(\"TestDesc\"),\n-                            vec![\n-                                // name: \"path::to::test\"\n-                                field(\n-                                    \"name\",\n-                                    cx.expr_call(\n-                                        sp,\n-                                        cx.expr_path(test_path(\"StaticTestName\")),\n-                                        vec![cx.expr_str(\n-                                            sp,\n-                                            Symbol::intern(&item_path(\n-                                                // skip the name of the root module\n-                                                &cx.current_expansion.module.mod_path[1..],\n-                                                &item.ident,\n-                                            )),\n-                                        )],\n-                                    ),\n-                                ),\n-                                // ignore: true | false\n-                                field(\"ignore\", cx.expr_bool(sp, should_ignore(&item))),\n-                                // allow_fail: true | false\n-                                field(\"allow_fail\", cx.expr_bool(sp, should_fail(&item))),\n-                                // should_panic: ...\n-                                field(\n-                                    \"should_panic\",\n-                                    match should_panic(cx, &item) {\n-                                        // test::ShouldPanic::No\n-                                        ShouldPanic::No => cx.expr_path(should_panic_path(\"No\")),\n-                                        // test::ShouldPanic::Yes\n-                                        ShouldPanic::Yes(None) => {\n-                                            cx.expr_path(should_panic_path(\"Yes\"))\n-                                        }\n-                                        // test::ShouldPanic::YesWithMessage(\"...\")\n-                                        ShouldPanic::Yes(Some(sym)) => cx.expr_call(\n+            Some(\n+                cx.expr_struct(\n+                    sp,\n+                    test_path(\"TestDescAndFn\"),\n+                    vec![\n+                        // desc: test::TestDesc {\n+                        field(\n+                            \"desc\",\n+                            cx.expr_struct(\n+                                sp,\n+                                test_path(\"TestDesc\"),\n+                                vec![\n+                                    // name: \"path::to::test\"\n+                                    field(\n+                                        \"name\",\n+                                        cx.expr_call(\n                                             sp,\n-                                            cx.expr_path(should_panic_path(\"YesWithMessage\")),\n-                                            vec![cx.expr_str(sp, sym)],\n+                                            cx.expr_path(test_path(\"StaticTestName\")),\n+                                            vec![cx.expr_str(\n+                                                sp,\n+                                                Symbol::intern(&item_path(\n+                                                    // skip the name of the root module\n+                                                    &cx.current_expansion.module.mod_path[1..],\n+                                                    &item.ident,\n+                                                )),\n+                                            )],\n                                         ),\n-                                    },\n-                                ),\n-                                // test_type: ...\n-                                field(\n-                                    \"test_type\",\n-                                    match test_type(cx) {\n-                                        // test::TestType::UnitTest\n-                                        TestType::UnitTest => {\n-                                            cx.expr_path(test_type_path(\"UnitTest\"))\n-                                        }\n-                                        // test::TestType::IntegrationTest\n-                                        TestType::IntegrationTest => {\n-                                            cx.expr_path(test_type_path(\"IntegrationTest\"))\n-                                        }\n-                                        // test::TestPath::Unknown\n-                                        TestType::Unknown => {\n-                                            cx.expr_path(test_type_path(\"Unknown\"))\n-                                        }\n-                                    },\n-                                ),\n-                                // },\n-                            ],\n+                                    ),\n+                                    // ignore: true | false\n+                                    field(\"ignore\", cx.expr_bool(sp, should_ignore(&item))),\n+                                    // allow_fail: true | false\n+                                    field(\"allow_fail\", cx.expr_bool(sp, should_fail(&item))),\n+                                    // should_panic: ...\n+                                    field(\n+                                        \"should_panic\",\n+                                        match should_panic(cx, &item) {\n+                                            // test::ShouldPanic::No\n+                                            ShouldPanic::No => {\n+                                                cx.expr_path(should_panic_path(\"No\"))\n+                                            }\n+                                            // test::ShouldPanic::Yes\n+                                            ShouldPanic::Yes(None) => {\n+                                                cx.expr_path(should_panic_path(\"Yes\"))\n+                                            }\n+                                            // test::ShouldPanic::YesWithMessage(\"...\")\n+                                            ShouldPanic::Yes(Some(sym)) => cx.expr_call(\n+                                                sp,\n+                                                cx.expr_path(should_panic_path(\"YesWithMessage\")),\n+                                                vec![cx.expr_str(sp, sym)],\n+                                            ),\n+                                        },\n+                                    ),\n+                                    // test_type: ...\n+                                    field(\n+                                        \"test_type\",\n+                                        match test_type(cx) {\n+                                            // test::TestType::UnitTest\n+                                            TestType::UnitTest => {\n+                                                cx.expr_path(test_type_path(\"UnitTest\"))\n+                                            }\n+                                            // test::TestType::IntegrationTest\n+                                            TestType::IntegrationTest => {\n+                                                cx.expr_path(test_type_path(\"IntegrationTest\"))\n+                                            }\n+                                            // test::TestPath::Unknown\n+                                            TestType::Unknown => {\n+                                                cx.expr_path(test_type_path(\"Unknown\"))\n+                                            }\n+                                        },\n+                                    ),\n+                                    // },\n+                                ],\n+                            ),\n                         ),\n-                    ),\n-                    // testfn: test::StaticTestFn(...) | test::StaticBenchFn(...)\n-                    field(\"testfn\", test_fn), // }\n-                ],\n-            ), // }\n+                        // testfn: test::StaticTestFn(...) | test::StaticBenchFn(...)\n+                        field(\"testfn\", test_fn), // }\n+                    ],\n+                ), // }\n+            ),\n         ),\n     );\n     test_const = test_const.map(|mut tc| {"}, {"sha": "8a53e1d1861aafcff3c19598bbdc75fceda786bd", "filename": "src/librustc_expand/build.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Flibrustc_expand%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Flibrustc_expand%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fbuild.rs?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -634,7 +634,7 @@ impl<'a> ExtCtxt<'a> {\n         mutbl: ast::Mutability,\n         expr: P<ast::Expr>,\n     ) -> P<ast::Item> {\n-        self.item(span, name, Vec::new(), ast::ItemKind::Static(ty, mutbl, expr))\n+        self.item(span, name, Vec::new(), ast::ItemKind::Static(ty, mutbl, Some(expr)))\n     }\n \n     pub fn item_const(\n@@ -644,7 +644,7 @@ impl<'a> ExtCtxt<'a> {\n         ty: P<ast::Ty>,\n         expr: P<ast::Expr>,\n     ) -> P<ast::Item> {\n-        self.item(span, name, Vec::new(), ast::ItemKind::Const(ty, expr))\n+        self.item(span, name, Vec::new(), ast::ItemKind::Const(ty, Some(expr)))\n     }\n \n     pub fn attribute(&self, mi: ast::MetaItem) -> ast::Attribute {"}, {"sha": "6599e92222c75da0e453862eec407fdfd686e212", "filename": "src/librustc_expand/mbe/macro_parser.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Flibrustc_expand%2Fmbe%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Flibrustc_expand%2Fmbe%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmbe%2Fmacro_parser.rs?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -856,8 +856,6 @@ fn parse_nt(p: &mut Parser<'_>, sp: Span, name: Symbol) -> Nonterminal {\n     if name == sym::tt {\n         return token::NtTT(p.parse_token_tree());\n     }\n-    // check at the beginning and the parser checks after each bump\n-    p.process_potential_macro_variable();\n     match parse_nt_inner(p, sp, name) {\n         Ok(nt) => nt,\n         Err(mut err) => {"}, {"sha": "52e581e30f5378d403fb225ebe8c6ae87215427b", "filename": "src/librustc_expand/mbe/macro_rules.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -267,7 +267,6 @@ fn generic_extension<'cx>(\n                     cx.current_expansion.module.mod_path.last().map(|id| id.to_string());\n                 p.last_type_ascription = cx.current_expansion.prior_type_ascription;\n \n-                p.process_potential_macro_variable();\n                 // Let the context choose how to interpret the result.\n                 // Weird, but useful for X-macros.\n                 return Box::new(ParserAnyMacro {"}, {"sha": "c96b394c7b5e2b959fd4d3453d312488678cb996", "filename": "src/librustc_expand/placeholders.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Flibrustc_expand%2Fplaceholders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Flibrustc_expand%2Fplaceholders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fplaceholders.rs?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -25,7 +25,6 @@ pub fn placeholder(\n \n     let ident = ast::Ident::invalid();\n     let attrs = Vec::new();\n-    let generics = ast::Generics::default();\n     let vis = vis.unwrap_or_else(|| dummy_spanned(ast::VisibilityKind::Inherited));\n     let span = DUMMY_SP;\n     let expr_placeholder = || {\n@@ -57,7 +56,6 @@ pub fn placeholder(\n             ident,\n             vis,\n             attrs,\n-            generics,\n             kind: ast::AssocItemKind::Macro(mac_placeholder()),\n             defaultness: ast::Defaultness::Final,\n             tokens: None,\n@@ -68,7 +66,6 @@ pub fn placeholder(\n             ident,\n             vis,\n             attrs,\n-            generics,\n             kind: ast::AssocItemKind::Macro(mac_placeholder()),\n             defaultness: ast::Defaultness::Final,\n             tokens: None,"}, {"sha": "99e9878bfd8bb76e6bac2406d09f6c0e6ba94e68", "filename": "src/librustc_interface/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Flibrustc_interface%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Flibrustc_interface%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Futil.rs?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -686,7 +686,7 @@ impl<'a> MutVisitor for ReplaceBodyWithLoop<'a, '_> {\n     fn flat_map_trait_item(&mut self, i: P<ast::AssocItem>) -> SmallVec<[P<ast::AssocItem>; 1]> {\n         let is_const = match i.kind {\n             ast::AssocItemKind::Const(..) => true,\n-            ast::AssocItemKind::Fn(ref sig, _) => Self::is_sig_const(sig),\n+            ast::AssocItemKind::Fn(ref sig, _, _) => Self::is_sig_const(sig),\n             _ => false,\n         };\n         self.run(is_const, |s| noop_flat_map_assoc_item(i, s))"}, {"sha": "73c5f386e65d61063ff059e30de6ebce24609492", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -640,7 +640,7 @@ declare_lint_pass!(\n impl EarlyLintPass for AnonymousParameters {\n     fn check_trait_item(&mut self, cx: &EarlyContext<'_>, it: &ast::AssocItem) {\n         match it.kind {\n-            ast::AssocItemKind::Fn(ref sig, _) => {\n+            ast::AssocItemKind::Fn(ref sig, _, _) => {\n                 for arg in sig.decl.inputs.iter() {\n                     match arg.pat.kind {\n                         ast::PatKind::Ident(_, ident, None) => {"}, {"sha": "7870b9da4cb701a5da01f93c20dda500c0fa84ce", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -603,7 +603,7 @@ impl EarlyLintPass for UnusedParens {\n     fn check_item(&mut self, cx: &EarlyContext<'_>, item: &ast::Item) {\n         use ast::ItemKind::*;\n \n-        if let Const(.., ref expr) | Static(.., ref expr) = item.kind {\n+        if let Const(.., Some(expr)) | Static(.., Some(expr)) = &item.kind {\n             self.check_unused_parens_expr(cx, expr, \"assigned value\", false, None, None);\n         }\n     }"}, {"sha": "215496e4d03cb7b108d4a3502a0d426072d642c7", "filename": "src/librustc_mir/transform/check_consts/qualifs.rs", "status": "modified", "additions": 8, "deletions": 17, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -94,32 +94,23 @@ pub trait Qualif {\n             }\n \n             Operand::Constant(ref constant) => {\n-                if constant.check_static_ptr(cx.tcx).is_some() {\n-                    // `mir_const_qualif` does return the qualifs in the final value of a `static`,\n-                    // so we could use value-based qualification here, but we shouldn't do this\n-                    // without a good reason.\n-                    //\n-                    // Note: this uses `constant.literal.ty` which is a reference or pointer to the\n-                    // type of the actual `static` item.\n-                    Self::in_any_value_of_ty(cx, constant.literal.ty)\n-                } else if let ty::ConstKind::Unevaluated(def_id, _, promoted) = constant.literal.val\n-                {\n+                // Check the qualifs of the value of `const` items.\n+                if let ty::ConstKind::Unevaluated(def_id, _, promoted) = constant.literal.val {\n                     assert!(promoted.is_none());\n                     // Don't peek inside trait associated constants.\n-                    if cx.tcx.trait_of_item(def_id).is_some() {\n-                        Self::in_any_value_of_ty(cx, constant.literal.ty)\n-                    } else {\n+                    if cx.tcx.trait_of_item(def_id).is_none() {\n                         let qualifs = cx.tcx.at(constant.span).mir_const_qualif(def_id);\n-                        let qualif = Self::in_qualifs(&qualifs);\n+                        if !Self::in_qualifs(&qualifs) {\n+                            return false;\n+                        }\n \n                         // Just in case the type is more specific than\n                         // the definition, e.g., impl associated const\n                         // with type parameters, take it into account.\n-                        qualif && Self::in_any_value_of_ty(cx, constant.literal.ty)\n                     }\n-                } else {\n-                    false\n                 }\n+                // Otherwise use the qualifs of the type.\n+                Self::in_any_value_of_ty(cx, constant.literal.ty)\n             }\n         }\n     }"}, {"sha": "a0b8415b3e17e5f9e66767ca87ae7886ff554ac2", "filename": "src/librustc_parse/lib.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Flibrustc_parse%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Flibrustc_parse%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Flib.rs?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -9,7 +9,7 @@ use rustc_errors::{Diagnostic, FatalError, Level, PResult};\n use rustc_session::parse::ParseSess;\n use rustc_span::{FileName, SourceFile, Span};\n use syntax::ast;\n-use syntax::token::{self, Nonterminal};\n+use syntax::token::{self, Nonterminal, Token};\n use syntax::tokenstream::{self, TokenStream, TokenTree};\n \n use std::path::{Path, PathBuf};\n@@ -170,8 +170,9 @@ fn maybe_source_file_to_parser(\n     let (stream, unclosed_delims) = maybe_file_to_stream(sess, source_file, None)?;\n     let mut parser = stream_to_parser(sess, stream, None);\n     parser.unclosed_delims = unclosed_delims;\n-    if parser.token == token::Eof && parser.token.span.is_dummy() {\n-        parser.token.span = Span::new(end_pos, end_pos, parser.token.span.ctxt());\n+    if parser.token == token::Eof {\n+        let span = Span::new(end_pos, end_pos, parser.token.span.ctxt());\n+        parser.set_token(Token::new(token::Eof, span));\n     }\n \n     Ok(parser)"}, {"sha": "97daa91eed196ee08c351b18f3a632908b3ae473", "filename": "src/librustc_parse/parser/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fexpr.rs?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -166,7 +166,7 @@ impl<'a> Parser<'a> {\n         while let Some(op) = self.check_assoc_op() {\n             // Adjust the span for interpolated LHS to point to the `$lhs` token\n             // and not to what it refers to.\n-            let lhs_span = match self.unnormalized_prev_token().kind {\n+            let lhs_span = match self.unnormalized_prev_token.kind {\n                 TokenKind::Interpolated(..) => self.prev_span,\n                 _ => lhs.span,\n             };\n@@ -527,7 +527,7 @@ impl<'a> Parser<'a> {\n     ) -> PResult<'a, (Span, P<Expr>)> {\n         expr.map(|e| {\n             (\n-                match self.unnormalized_prev_token().kind {\n+                match self.unnormalized_prev_token.kind {\n                     TokenKind::Interpolated(..) => self.prev_span,\n                     _ => e.span,\n                 },"}, {"sha": "4dcde2f92db6eba9aed8aca179e6e40a0b23cd8e", "filename": "src/librustc_parse/parser/item.rs", "status": "modified", "additions": 95, "deletions": 120, "changes": 215, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fitem.rs?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -13,7 +13,7 @@ use syntax::ast::{AssocItem, AssocItemKind, Item, ItemKind, UseTree, UseTreeKind\n use syntax::ast::{Async, Const, Defaultness, IsAuto, PathSegment, Unsafe};\n use syntax::ast::{BindingMode, Block, FnDecl, FnSig, Mac, MacArgs, MacDelimiter, Param, SelfKind};\n use syntax::ast::{EnumDef, Generics, StructField, TraitRef, Ty, TyKind, Variant, VariantData};\n-use syntax::ast::{FnHeader, ForeignItem, ForeignItemKind, Mutability, Visibility, VisibilityKind};\n+use syntax::ast::{FnHeader, ForeignItem, Mutability, Visibility, VisibilityKind};\n use syntax::ptr::P;\n use syntax::token;\n use syntax::tokenstream::{DelimSpan, TokenStream, TokenTree};\n@@ -333,29 +333,19 @@ impl<'a> Parser<'a> {\n         self.token.is_keyword(kw::Async) && self.is_keyword_ahead(1, &[kw::Fn])\n     }\n \n-    fn missing_assoc_item_kind_err(\n-        &self,\n-        item_type: &str,\n-        prev_span: Span,\n-    ) -> DiagnosticBuilder<'a> {\n-        let expected_kinds = if item_type == \"extern\" {\n-            \"missing `fn`, `type`, or `static`\"\n-        } else {\n-            \"missing `fn`, `type`, or `const`\"\n-        };\n-\n-        // Given this code `path(`, it seems like this is not\n-        // setting the visibility of a macro invocation, but rather\n-        // a mistyped method declaration.\n-        // Create a diagnostic pointing out that `fn` is missing.\n-        //\n-        // x |     pub path(&self) {\n-        //   |        ^ missing `fn`, `type`, or `const`\n-        //     pub  path(\n-        //        ^^ `sp` below will point to this\n+    /// Given this code `path(`, it seems like this is not\n+    /// setting the visibility of a macro invocation,\n+    /// but rather a mistyped method declaration.\n+    /// Create a diagnostic pointing out that `fn` is missing.\n+    ///\n+    /// ```\n+    /// x |     pub   path(&self) {\n+    ///   |         ^ missing `fn`, `type`, `const`, or `static`\n+    /// ```\n+    fn missing_nested_item_kind_err(&self, prev_span: Span) -> DiagnosticBuilder<'a> {\n         let sp = prev_span.between(self.token.span);\n-        let mut err = self\n-            .struct_span_err(sp, &format!(\"{} for {}-item declaration\", expected_kinds, item_type));\n+        let expected_kinds = \"missing `fn`, `type`, `const`, or `static`\";\n+        let mut err = self.struct_span_err(sp, &format!(\"{} for item declaration\", expected_kinds));\n         err.span_label(sp, expected_kinds);\n         err\n     }\n@@ -546,6 +536,7 @@ impl<'a> Parser<'a> {\n                 1,\n                 &[\n                     kw::Impl,\n+                    kw::Static,\n                     kw::Const,\n                     kw::Async,\n                     kw::Fn,\n@@ -638,7 +629,7 @@ impl<'a> Parser<'a> {\n     fn parse_assoc_item(\n         &mut self,\n         at_end: &mut bool,\n-        req_name: fn(&token::Token) -> bool,\n+        req_name: ReqName,\n     ) -> PResult<'a, P<AssocItem>> {\n         let attrs = self.parse_outer_attributes()?;\n         let mut unclosed_delims = vec![];\n@@ -652,59 +643,67 @@ impl<'a> Parser<'a> {\n         if !item.attrs.iter().any(|attr| attr.style == AttrStyle::Inner) {\n             item.tokens = Some(tokens);\n         }\n+        self.error_on_assoc_static(&item);\n         Ok(P(item))\n     }\n \n+    fn error_on_assoc_static(&self, item: &AssocItem) {\n+        if let AssocItemKind::Static(..) = item.kind {\n+            self.struct_span_err(item.span, \"associated `static` items are not allowed\").emit();\n+        }\n+    }\n+\n     fn parse_assoc_item_(\n         &mut self,\n         at_end: &mut bool,\n         mut attrs: Vec<Attribute>,\n-        req_name: fn(&token::Token) -> bool,\n+        req_name: ReqName,\n     ) -> PResult<'a, AssocItem> {\n         let lo = self.token.span;\n         let vis = self.parse_visibility(FollowedByType::No)?;\n         let defaultness = self.parse_defaultness();\n+        let (ident, kind) = self.parse_assoc_item_kind(at_end, &mut attrs, req_name, &vis)?;\n+        let span = lo.to(self.prev_span);\n+        let id = DUMMY_NODE_ID;\n+        Ok(AssocItem { id, span, ident, attrs, vis, defaultness, kind, tokens: None })\n+    }\n \n-        let (ident, kind, generics) = if self.eat_keyword(kw::Type) {\n-            self.parse_assoc_ty()?\n+    fn parse_assoc_item_kind(\n+        &mut self,\n+        at_end: &mut bool,\n+        attrs: &mut Vec<Attribute>,\n+        req_name: ReqName,\n+        vis: &Visibility,\n+    ) -> PResult<'a, (Ident, AssocItemKind)> {\n+        if self.eat_keyword(kw::Type) {\n+            self.parse_assoc_ty()\n         } else if self.check_fn_front_matter() {\n-            let (ident, sig, generics, body) = self.parse_fn(at_end, &mut attrs, req_name)?;\n-            (ident, AssocItemKind::Fn(sig, body), generics)\n-        } else if self.check_keyword(kw::Const) {\n-            self.parse_assoc_const()?\n+            let (ident, sig, generics, body) = self.parse_fn(at_end, attrs, req_name)?;\n+            Ok((ident, AssocItemKind::Fn(sig, generics, body)))\n+        } else if self.is_static_global() {\n+            self.bump(); // `static`\n+            let mutbl = self.parse_mutability();\n+            let (ident, ty, expr) = self.parse_item_const_common(Some(mutbl))?;\n+            Ok((ident, AssocItemKind::Static(ty, mutbl, expr)))\n+        } else if self.eat_keyword(kw::Const) {\n+            let (ident, ty, expr) = self.parse_item_const_common(None)?;\n+            Ok((ident, AssocItemKind::Const(ty, expr)))\n         } else if self.isnt_macro_invocation() {\n-            return Err(self.missing_assoc_item_kind_err(\"associated\", self.prev_span));\n+            Err(self.missing_nested_item_kind_err(self.prev_span))\n         } else if self.token.is_path_start() {\n             let mac = self.parse_item_macro(&vis)?;\n             *at_end = true;\n-            (Ident::invalid(), AssocItemKind::Macro(mac), Generics::default())\n+            Ok((Ident::invalid(), AssocItemKind::Macro(mac)))\n         } else {\n-            self.recover_attrs_no_item(&attrs)?;\n-            self.unexpected()?\n-        };\n-\n-        let span = lo.to(self.prev_span);\n-        let id = DUMMY_NODE_ID;\n-        Ok(AssocItem { id, span, ident, attrs, vis, defaultness, generics, kind, tokens: None })\n-    }\n-\n-    /// This parses the grammar:\n-    ///\n-    ///     AssocConst = \"const\" Ident \":\" Ty \"=\" Expr \";\"\n-    fn parse_assoc_const(&mut self) -> PResult<'a, (Ident, AssocItemKind, Generics)> {\n-        self.expect_keyword(kw::Const)?;\n-        let ident = self.parse_ident()?;\n-        self.expect(&token::Colon)?;\n-        let ty = self.parse_ty()?;\n-        let expr = if self.eat(&token::Eq) { Some(self.parse_expr()?) } else { None };\n-        self.expect_semi()?;\n-        Ok((ident, AssocItemKind::Const(ty, expr), Generics::default()))\n+            self.recover_attrs_no_item(attrs)?;\n+            self.unexpected()\n+        }\n     }\n \n     /// Parses the following grammar:\n     ///\n     ///     AssocTy = Ident [\"<\"...\">\"] [\":\" [GenericBounds]] [\"where\" ...] [\"=\" Ty]\n-    fn parse_assoc_ty(&mut self) -> PResult<'a, (Ident, AssocItemKind, Generics)> {\n+    fn parse_assoc_ty(&mut self) -> PResult<'a, (Ident, AssocItemKind)> {\n         let ident = self.parse_ident()?;\n         let mut generics = self.parse_generics()?;\n \n@@ -716,7 +715,7 @@ impl<'a> Parser<'a> {\n         let default = if self.eat(&token::Eq) { Some(self.parse_ty()?) } else { None };\n         self.expect_semi()?;\n \n-        Ok((ident, AssocItemKind::TyAlias(bounds, default), generics))\n+        Ok((ident, AssocItemKind::TyAlias(generics, bounds, default)))\n     }\n \n     /// Parses a `UseTree`.\n@@ -875,60 +874,26 @@ impl<'a> Parser<'a> {\n         let mut attrs = self.parse_outer_attributes()?;\n         let lo = self.token.span;\n         let vis = self.parse_visibility(FollowedByType::No)?;\n+        let (ident, kind) = self.parse_assoc_item_kind(at_end, &mut attrs, |_| true, &vis)?;\n+        let item = self.mk_item(lo, ident, kind, vis, attrs);\n+        self.error_on_foreign_const(&item);\n+        Ok(P(item))\n+    }\n \n-        let (ident, kind) = if self.check_keyword(kw::Type) {\n-            // FOREIGN TYPE ITEM\n-            self.parse_item_foreign_type()?\n-        } else if self.check_fn_front_matter() {\n-            // FOREIGN FUNCTION ITEM\n-            let (ident, sig, generics, body) = self.parse_fn(at_end, &mut attrs, |_| true)?;\n-            (ident, ForeignItemKind::Fn(sig, generics, body))\n-        } else if self.is_static_global() {\n-            // FOREIGN STATIC ITEM\n-            self.bump(); // `static`\n-            self.parse_item_foreign_static()?\n-        } else if self.token.is_keyword(kw::Const) {\n-            // Treat `const` as `static` for error recovery, but don't add it to expected tokens.\n-            self.bump(); // `const`\n-            self.struct_span_err(self.prev_span, \"extern items cannot be `const`\")\n+    fn error_on_foreign_const(&self, item: &ForeignItem) {\n+        if let AssocItemKind::Const(..) = item.kind {\n+            self.struct_span_err(item.ident.span, \"extern items cannot be `const`\")\n                 .span_suggestion(\n-                    self.prev_span,\n+                    item.span.with_hi(item.ident.span.lo()),\n                     \"try using a static value\",\n-                    \"static\".to_owned(),\n+                    \"static \".to_string(),\n                     Applicability::MachineApplicable,\n                 )\n+                .note(\n+                    \"for more information, visit https://doc.rust-lang.org/std/keyword.extern.html\",\n+                )\n                 .emit();\n-            self.parse_item_foreign_static()?\n-        } else if self.isnt_macro_invocation() {\n-            return Err(self.missing_assoc_item_kind_err(\"extern\", self.prev_span));\n-        } else if self.token.is_path_start() {\n-            let mac = self.parse_item_macro(&vis)?;\n-            *at_end = true;\n-            (Ident::invalid(), ForeignItemKind::Macro(mac))\n-        } else {\n-            self.recover_attrs_no_item(&attrs)?;\n-            self.unexpected()?\n-        };\n-        Ok(P(self.mk_item(lo, ident, kind, vis, attrs)))\n-    }\n-\n-    /// Parses a static item from a foreign module.\n-    /// Assumes that the `static` keyword is already parsed.\n-    fn parse_item_foreign_static(&mut self) -> PResult<'a, (Ident, ForeignItemKind)> {\n-        let mutbl = self.parse_mutability();\n-        let ident = self.parse_ident()?;\n-        self.expect(&token::Colon)?;\n-        let ty = self.parse_ty()?;\n-        self.expect_semi()?;\n-        Ok((ident, ForeignItemKind::Static(ty, mutbl)))\n-    }\n-\n-    /// Parses a type from a foreign module.\n-    fn parse_item_foreign_type(&mut self) -> PResult<'a, (Ident, ForeignItemKind)> {\n-        self.expect_keyword(kw::Type)?;\n-        let ident = self.parse_ident()?;\n-        self.expect_semi()?;\n-        Ok((ident, ForeignItemKind::Ty))\n+        }\n     }\n \n     fn is_static_global(&mut self) -> bool {\n@@ -964,34 +929,43 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    /// Parse `[\"const\" | (\"static\" \"mut\"?)] $ident \":\" $ty = $expr` with\n+    /// Parse `[\"const\" | (\"static\" \"mut\"?)] $ident \":\" $ty (= $expr)?` with\n     /// `[\"const\" | (\"static\" \"mut\"?)]` already parsed and stored in `m`.\n     ///\n     /// When `m` is `\"const\"`, `$ident` may also be `\"_\"`.\n     fn parse_item_const(&mut self, m: Option<Mutability>) -> PResult<'a, ItemInfo> {\n+        let (id, ty, expr) = self.parse_item_const_common(m)?;\n+        let item = match m {\n+            Some(m) => ItemKind::Static(ty, m, expr),\n+            None => ItemKind::Const(ty, expr),\n+        };\n+        Ok((id, item))\n+    }\n+\n+    /// Parse `[\"const\" | (\"static\" \"mut\"?)] $ident \":\" $ty (= $expr)?` with\n+    /// `[\"const\" | (\"static\" \"mut\"?)]` already parsed and stored in `m`.\n+    ///\n+    /// When `m` is `\"const\"`, `$ident` may also be `\"_\"`.\n+    fn parse_item_const_common(\n+        &mut self,\n+        m: Option<Mutability>,\n+    ) -> PResult<'a, (Ident, P<Ty>, Option<P<ast::Expr>>)> {\n         let id = if m.is_none() { self.parse_ident_or_underscore() } else { self.parse_ident() }?;\n \n         // Parse the type of a `const` or `static mut?` item.\n         // That is, the `\":\" $ty` fragment.\n-        let ty = if self.token == token::Eq {\n-            self.recover_missing_const_type(id, m)\n-        } else {\n-            // Not `=` so expect `\":\"\" $ty` as usual.\n-            self.expect(&token::Colon)?;\n+        let ty = if self.eat(&token::Colon) {\n             self.parse_ty()?\n+        } else {\n+            self.recover_missing_const_type(id, m)\n         };\n \n-        self.expect(&token::Eq)?;\n-        let e = self.parse_expr()?;\n+        let expr = if self.eat(&token::Eq) { Some(self.parse_expr()?) } else { None };\n         self.expect_semi()?;\n-        let item = match m {\n-            Some(m) => ItemKind::Static(ty, m, e),\n-            None => ItemKind::Const(ty, e),\n-        };\n-        Ok((id, item))\n+        Ok((id, ty, expr))\n     }\n \n-    /// We were supposed to parse `:` but instead, we're already at `=`.\n+    /// We were supposed to parse `:` but the `:` was missing.\n     /// This means that the type is missing.\n     fn recover_missing_const_type(&mut self, id: Ident, m: Option<Mutability>) -> P<Ty> {\n         // Construct the error and stash it away with the hope\n@@ -1400,8 +1374,9 @@ impl<'a> Parser<'a> {\n     }\n \n     fn report_invalid_macro_expansion_item(&self, args: &MacArgs) {\n+        let span = args.span().expect(\"undelimited macro call\");\n         let mut err = self.struct_span_err(\n-            self.prev_span,\n+            span,\n             \"macros that expand to items must be delimited with braces or followed by a semicolon\",\n         );\n         if self.unclosed_delims.is_empty() {\n@@ -1416,14 +1391,14 @@ impl<'a> Parser<'a> {\n             );\n         } else {\n             err.span_suggestion(\n-                self.prev_span,\n+                span,\n                 \"change the delimiters to curly braces\",\n                 \" { /* items */ }\".to_string(),\n                 Applicability::HasPlaceholders,\n             );\n         }\n         err.span_suggestion(\n-            self.prev_span.shrink_to_hi(),\n+            span.shrink_to_hi(),\n             \"add a semicolon\",\n             ';'.to_string(),\n             Applicability::MaybeIncorrect,"}, {"sha": "937e5e3cd695b24670c1454ae8d9e97bfb34c9ea", "filename": "src/librustc_parse/parser/mod.rs", "status": "modified", "additions": 36, "deletions": 64, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fmod.rs?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -93,18 +93,16 @@ pub struct Parser<'a> {\n     /// Use span from this token if you need an isolated span.\n     pub token: Token,\n     /// The current non-normalized token if it's different from `token`.\n-    /// Preferable use is through the `unnormalized_token()` getter.\n     /// Use span from this token if you need to concatenate it with some neighbouring spans.\n-    unnormalized_token: Option<Token>,\n+    unnormalized_token: Token,\n     /// The previous normalized token.\n     /// Use span from this token if you need an isolated span.\n     prev_token: Token,\n     /// The previous non-normalized token if it's different from `prev_token`.\n-    /// Preferable use is through the `unnormalized_prev_token()` getter.\n     /// Use span from this token if you need to concatenate it with some neighbouring spans.\n-    unnormalized_prev_token: Option<Token>,\n-    /// Equivalent to `unnormalized_prev_token().span`.\n-    /// FIXME: Remove in favor of `(unnormalized_)prev_token().span`.\n+    unnormalized_prev_token: Token,\n+    /// Equivalent to `unnormalized_prev_token.span`.\n+    /// FIXME: Remove in favor of `(unnormalized_)prev_token.span`.\n     pub prev_span: Span,\n     restrictions: Restrictions,\n     /// Used to determine the path to externally loaded source files.\n@@ -378,9 +376,9 @@ impl<'a> Parser<'a> {\n         let mut parser = Parser {\n             sess,\n             token: Token::dummy(),\n-            unnormalized_token: None,\n+            unnormalized_token: Token::dummy(),\n             prev_token: Token::dummy(),\n-            unnormalized_prev_token: None,\n+            unnormalized_prev_token: Token::dummy(),\n             prev_span: DUMMY_SP,\n             restrictions: Restrictions::empty(),\n             recurse_into_file_modules,\n@@ -404,7 +402,8 @@ impl<'a> Parser<'a> {\n             subparser_name,\n         };\n \n-        parser.token = parser.next_tok();\n+        // Make parser point to the first token.\n+        parser.bump();\n \n         if let Some(directory) = directory {\n             parser.directory = directory;\n@@ -418,27 +417,18 @@ impl<'a> Parser<'a> {\n             }\n         }\n \n-        parser.process_potential_macro_variable();\n         parser\n     }\n \n-    fn unnormalized_token(&self) -> &Token {\n-        self.unnormalized_token.as_ref().unwrap_or(&self.token)\n-    }\n-\n-    fn unnormalized_prev_token(&self) -> &Token {\n-        self.unnormalized_prev_token.as_ref().unwrap_or(&self.prev_token)\n-    }\n-\n-    fn next_tok(&mut self) -> Token {\n+    fn next_tok(&mut self, fallback_span: Span) -> Token {\n         let mut next = if self.desugar_doc_comments {\n             self.token_cursor.next_desugared()\n         } else {\n             self.token_cursor.next()\n         };\n         if next.span.is_dummy() {\n             // Tweak the location for better diagnostics, but keep syntactic context intact.\n-            next.span = self.unnormalized_token().span.with_ctxt(next.span.ctxt());\n+            next.span = fallback_span.with_ctxt(next.span.ctxt());\n         }\n         next\n     }\n@@ -896,6 +886,23 @@ impl<'a> Parser<'a> {\n         self.parse_delim_comma_seq(token::Paren, f)\n     }\n \n+    // Interpolated identifier (`$i: ident`) and lifetime (`$l: lifetime`)\n+    // tokens are replaced with usual identifier and lifetime tokens,\n+    // so the former are never encountered during normal parsing.\n+    crate fn set_token(&mut self, token: Token) {\n+        self.unnormalized_token = token;\n+        self.token = match &self.unnormalized_token.kind {\n+            token::Interpolated(nt) => match **nt {\n+                token::NtIdent(ident, is_raw) => {\n+                    Token::new(token::Ident(ident.name, is_raw), ident.span)\n+                }\n+                token::NtLifetime(ident) => Token::new(token::Lifetime(ident.name), ident.span),\n+                _ => self.unnormalized_token.clone(),\n+            },\n+            _ => self.unnormalized_token.clone(),\n+        }\n+    }\n+\n     /// Advance the parser by one token.\n     pub fn bump(&mut self) {\n         if self.prev_token.kind == TokenKind::Eof {\n@@ -905,16 +912,15 @@ impl<'a> Parser<'a> {\n         }\n \n         // Update the current and previous tokens.\n-        let next_token = self.next_tok();\n-        self.prev_token = mem::replace(&mut self.token, next_token);\n+        self.prev_token = self.token.take();\n         self.unnormalized_prev_token = self.unnormalized_token.take();\n+        let next_token = self.next_tok(self.unnormalized_prev_token.span);\n+        self.set_token(next_token);\n \n         // Update fields derived from the previous token.\n-        self.prev_span = self.unnormalized_prev_token().span;\n+        self.prev_span = self.unnormalized_prev_token.span;\n \n         self.expected_tokens.clear();\n-        // Check after each token.\n-        self.process_potential_macro_variable();\n     }\n \n     /// Advances the parser using provided token as a next one. Use this when\n@@ -924,12 +930,12 @@ impl<'a> Parser<'a> {\n     /// Correct token kinds and spans need to be calculated instead.\n     fn bump_with(&mut self, next: TokenKind, span: Span) {\n         // Update the current and previous tokens.\n-        let next_token = Token::new(next, span);\n-        self.prev_token = mem::replace(&mut self.token, next_token);\n+        self.prev_token = self.token.take();\n         self.unnormalized_prev_token = self.unnormalized_token.take();\n+        self.set_token(Token::new(next, span));\n \n         // Update fields derived from the previous token.\n-        self.prev_span = self.unnormalized_prev_token().span.with_hi(span.lo());\n+        self.prev_span = self.unnormalized_prev_token.span.with_hi(span.lo());\n \n         self.expected_tokens.clear();\n     }\n@@ -1066,39 +1072,6 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    pub fn process_potential_macro_variable(&mut self) {\n-        let normalized_token = match self.token.kind {\n-            token::Dollar\n-                if self.token.span.from_expansion() && self.look_ahead(1, |t| t.is_ident()) =>\n-            {\n-                self.bump();\n-                let name = match self.token.kind {\n-                    token::Ident(name, _) => name,\n-                    _ => unreachable!(),\n-                };\n-                let span = self.prev_span.to(self.token.span);\n-                self.struct_span_err(span, &format!(\"unknown macro variable `{}`\", name))\n-                    .span_label(span, \"unknown macro variable\")\n-                    .emit();\n-                self.bump();\n-                return;\n-            }\n-            token::Interpolated(ref nt) => {\n-                // Interpolated identifier and lifetime tokens are replaced with usual identifier\n-                // and lifetime tokens, so the former are never encountered during normal parsing.\n-                match **nt {\n-                    token::NtIdent(ident, is_raw) => {\n-                        Token::new(token::Ident(ident.name, is_raw), ident.span)\n-                    }\n-                    token::NtLifetime(ident) => Token::new(token::Lifetime(ident.name), ident.span),\n-                    _ => return,\n-                }\n-            }\n-            _ => return,\n-        };\n-        self.unnormalized_token = Some(mem::replace(&mut self.token, normalized_token));\n-    }\n-\n     /// Parses a single token tree from the input.\n     pub fn parse_token_tree(&mut self) -> TokenTree {\n         match self.token.kind {\n@@ -1107,15 +1080,14 @@ impl<'a> Parser<'a> {\n                     &mut self.token_cursor.frame,\n                     self.token_cursor.stack.pop().unwrap(),\n                 );\n-                self.token.span = frame.span.entire();\n+                self.set_token(Token::new(TokenKind::CloseDelim(frame.delim), frame.span.close));\n                 self.bump();\n                 TokenTree::Delimited(frame.span, frame.delim, frame.tree_cursor.stream.into())\n             }\n             token::CloseDelim(_) | token::Eof => unreachable!(),\n             _ => {\n-                let token = self.token.clone();\n                 self.bump();\n-                TokenTree::Token(token)\n+                TokenTree::Token(self.prev_token.clone())\n             }\n         }\n     }"}, {"sha": "520d325f16b61fbc6b5dc0f2d5e71fa966409290", "filename": "src/librustc_parse/parser/pat.rs", "status": "modified", "additions": 13, "deletions": 16, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Flibrustc_parse%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Flibrustc_parse%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fpat.rs?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -503,17 +503,18 @@ impl<'a> Parser<'a> {\n         // Parse the pattern we hope to be an identifier.\n         let mut pat = self.parse_pat(Some(\"identifier\"))?;\n \n-        // Add `mut` to any binding in the parsed pattern.\n-        let changed_any_binding = Self::make_all_value_bindings_mutable(&mut pat);\n-\n-        // Unwrap; If we don't have `mut $ident`, error.\n-        let pat = pat.into_inner();\n-        match &pat.kind {\n-            PatKind::Ident(..) => {}\n-            _ => self.ban_mut_general_pat(mut_span, &pat, changed_any_binding),\n+        // If we don't have `mut $ident (@ pat)?`, error.\n+        if let PatKind::Ident(BindingMode::ByValue(m @ Mutability::Not), ..) = &mut pat.kind {\n+            // Don't recurse into the subpattern.\n+            // `mut` on the outer binding doesn't affect the inner bindings.\n+            *m = Mutability::Mut;\n+        } else {\n+            // Add `mut` to any binding in the parsed pattern.\n+            let changed_any_binding = Self::make_all_value_bindings_mutable(&mut pat);\n+            self.ban_mut_general_pat(mut_span, &pat, changed_any_binding);\n         }\n \n-        Ok(pat.kind)\n+        Ok(pat.into_inner().kind)\n     }\n \n     /// Recover on `mut ref? ident @ pat` and suggest\n@@ -542,14 +543,10 @@ impl<'a> Parser<'a> {\n             }\n \n             fn visit_pat(&mut self, pat: &mut P<Pat>) {\n-                if let PatKind::Ident(ref mut bm, ..) = pat.kind {\n-                    if let BindingMode::ByValue(ref mut m @ Mutability::Not) = bm {\n-                        *m = Mutability::Mut;\n-                    }\n+                if let PatKind::Ident(BindingMode::ByValue(m @ Mutability::Not), ..) = &mut pat.kind\n+                {\n                     self.0 = true;\n-                    // Don't recurse into the subpattern, mut on the outer\n-                    // binding doesn't affect the inner bindings.\n-                    return;\n+                    *m = Mutability::Mut;\n                 }\n                 noop_visit_pat(pat, self);\n             }"}, {"sha": "18e57c6a5d49fd7039e96fcce8b4089cd537b911", "filename": "src/librustc_parse/parser/path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Flibrustc_parse%2Fparser%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Flibrustc_parse%2Fparser%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fpath.rs?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -134,7 +134,7 @@ impl<'a> Parser<'a> {\n             path\n         });\n \n-        let lo = self.unnormalized_token().span;\n+        let lo = self.unnormalized_token.span;\n         let mut segments = Vec::new();\n         let mod_sep_ctxt = self.token.span.ctxt();\n         if self.eat(&token::ModSep) {"}, {"sha": "1f622b80e8e2ec3c33fb13f6e4708fe114a5da0c", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -826,10 +826,10 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n             ForeignItemKind::Fn(..) => {\n                 (Res::Def(DefKind::Fn, self.r.definitions.local_def_id(item.id)), ValueNS)\n             }\n-            ForeignItemKind::Static(..) => {\n+            ForeignItemKind::Static(..) | ForeignItemKind::Const(..) => {\n                 (Res::Def(DefKind::Static, self.r.definitions.local_def_id(item.id)), ValueNS)\n             }\n-            ForeignItemKind::Ty => {\n+            ForeignItemKind::TyAlias(..) => {\n                 (Res::Def(DefKind::ForeignTy, self.r.definitions.local_def_id(item.id)), TypeNS)\n             }\n             ForeignItemKind::Macro(_) => unreachable!(),\n@@ -1251,8 +1251,9 @@ impl<'a, 'b> Visitor<'b> for BuildReducedGraphVisitor<'a, 'b> {\n         // Add the item to the trait info.\n         let item_def_id = self.r.definitions.local_def_id(item.id);\n         let (res, ns) = match item.kind {\n-            AssocItemKind::Const(..) => (Res::Def(DefKind::AssocConst, item_def_id), ValueNS),\n-            AssocItemKind::Fn(ref sig, _) => {\n+            AssocItemKind::Static(..) // Let's pretend it's a `const` for recovery.\n+            | AssocItemKind::Const(..) => (Res::Def(DefKind::AssocConst, item_def_id), ValueNS),\n+            AssocItemKind::Fn(ref sig, _, _) => {\n                 if sig.decl.has_self() {\n                     self.r.has_self.insert(item_def_id);\n                 }"}, {"sha": "60cba55512193f781c4ceefdc9e47986d894fc61", "filename": "src/librustc_resolve/def_collector.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Flibrustc_resolve%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Flibrustc_resolve%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdef_collector.rs?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -215,18 +215,22 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n \n     fn visit_assoc_item(&mut self, i: &'a AssocItem, ctxt: visit::AssocCtxt) {\n         let def_data = match &i.kind {\n-            AssocItemKind::Fn(FnSig { header, decl }, body) if header.asyncness.is_async() => {\n+            AssocItemKind::Fn(FnSig { header, decl }, generics, body)\n+                if header.asyncness.is_async() =>\n+            {\n                 return self.visit_async_fn(\n                     i.id,\n                     i.ident.name,\n                     i.span,\n                     header,\n-                    &i.generics,\n+                    generics,\n                     decl,\n                     body.as_deref(),\n                 );\n             }\n-            AssocItemKind::Fn(..) | AssocItemKind::Const(..) => DefPathData::ValueNs(i.ident.name),\n+            AssocItemKind::Fn(..) | AssocItemKind::Const(..) | AssocItemKind::Static(..) => {\n+                DefPathData::ValueNs(i.ident.name)\n+            }\n             AssocItemKind::TyAlias(..) => DefPathData::TypeNs(i.ident.name),\n             AssocItemKind::Macro(..) => return self.visit_macro_invoc(i.id),\n         };"}, {"sha": "73601cd2ee711f1ad87a896a8e65a03806c6b880", "filename": "src/librustc_resolve/late.rs", "status": "modified", "additions": 98, "deletions": 96, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Flibrustc_resolve%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Flibrustc_resolve%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate.rs?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -437,17 +437,18 @@ impl<'a, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n     }\n     fn visit_foreign_item(&mut self, foreign_item: &'ast ForeignItem) {\n         match foreign_item.kind {\n-            ForeignItemKind::Fn(_, ref generics, _) => {\n+            ForeignItemKind::Fn(_, ref generics, _)\n+            | ForeignItemKind::TyAlias(ref generics, ..) => {\n                 self.with_generic_param_rib(generics, ItemRibKind(HasGenericParams::Yes), |this| {\n                     visit::walk_foreign_item(this, foreign_item);\n                 });\n             }\n-            ForeignItemKind::Static(..) => {\n+            ForeignItemKind::Const(..) | ForeignItemKind::Static(..) => {\n                 self.with_item_rib(HasGenericParams::No, |this| {\n                     visit::walk_foreign_item(this, foreign_item);\n                 });\n             }\n-            ForeignItemKind::Ty | ForeignItemKind::Macro(..) => {\n+            ForeignItemKind::Macro(..) => {\n                 visit::walk_foreign_item(self, foreign_item);\n             }\n         }\n@@ -826,41 +827,34 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                         this.visit_generics(generics);\n                         walk_list!(this, visit_param_bound, bounds);\n \n-                        for trait_item in trait_items {\n+                        let walk_assoc_item = |this: &mut Self, generics, item| {\n+                            this.with_generic_param_rib(generics, AssocItemRibKind, |this| {\n+                                visit::walk_assoc_item(this, item, AssocCtxt::Trait)\n+                            });\n+                        };\n+\n+                        for item in trait_items {\n                             this.with_trait_items(trait_items, |this| {\n-                                this.with_generic_param_rib(\n-                                    &trait_item.generics,\n-                                    AssocItemRibKind,\n-                                    |this| {\n-                                        match trait_item.kind {\n-                                            AssocItemKind::Const(ref ty, ref default) => {\n-                                                this.visit_ty(ty);\n-\n-                                                // Only impose the restrictions of\n-                                                // ConstRibKind for an actual constant\n-                                                // expression in a provided default.\n-                                                if let Some(ref expr) = *default {\n-                                                    this.with_constant_rib(|this| {\n-                                                        this.visit_expr(expr);\n-                                                    });\n-                                                }\n-                                            }\n-                                            AssocItemKind::Fn(_, _) => visit::walk_assoc_item(\n-                                                this,\n-                                                trait_item,\n-                                                AssocCtxt::Trait,\n-                                            ),\n-                                            AssocItemKind::TyAlias(..) => visit::walk_assoc_item(\n-                                                this,\n-                                                trait_item,\n-                                                AssocCtxt::Trait,\n-                                            ),\n-                                            AssocItemKind::Macro(_) => {\n-                                                panic!(\"unexpanded macro in resolve!\")\n-                                            }\n-                                        };\n-                                    },\n-                                );\n+                                match &item.kind {\n+                                    AssocItemKind::Static(ty, _, default)\n+                                    | AssocItemKind::Const(ty, default) => {\n+                                        this.visit_ty(ty);\n+                                        // Only impose the restrictions of `ConstRibKind` for an\n+                                        // actual constant expression in a provided default.\n+                                        if let Some(expr) = default {\n+                                            this.with_constant_rib(|this| this.visit_expr(expr));\n+                                        }\n+                                    }\n+                                    AssocItemKind::Fn(_, generics, _) => {\n+                                        walk_assoc_item(this, generics, item);\n+                                    }\n+                                    AssocItemKind::TyAlias(generics, _, _) => {\n+                                        walk_assoc_item(this, generics, item);\n+                                    }\n+                                    AssocItemKind::Macro(_) => {\n+                                        panic!(\"unexpanded macro in resolve!\")\n+                                    }\n+                                };\n                             });\n                         }\n                     });\n@@ -888,9 +882,9 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 debug!(\"resolve_item ItemKind::Const\");\n                 self.with_item_rib(HasGenericParams::No, |this| {\n                     this.visit_ty(ty);\n-                    this.with_constant_rib(|this| {\n-                        this.visit_expr(expr);\n-                    });\n+                    if let Some(expr) = expr {\n+                        this.with_constant_rib(|this| this.visit_expr(expr));\n+                    }\n                 });\n             }\n \n@@ -1021,7 +1015,7 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             trait_items\n                 .iter()\n                 .filter_map(|item| match &item.kind {\n-                    AssocItemKind::TyAlias(bounds, _) if bounds.len() == 0 => Some(item.ident),\n+                    AssocItemKind::TyAlias(_, bounds, _) if bounds.len() == 0 => Some(item.ident),\n                     _ => None,\n                 })\n                 .collect(),\n@@ -1113,66 +1107,74 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                         this.with_current_self_type(self_type, |this| {\n                             this.with_self_rib_ns(ValueNS, Res::SelfCtor(item_def_id), |this| {\n                                 debug!(\"resolve_implementation with_self_rib_ns(ValueNS, ...)\");\n-                                for impl_item in impl_items {\n-                                    // We also need a new scope for the impl item type parameters.\n-                                    this.with_generic_param_rib(&impl_item.generics,\n-                                                                AssocItemRibKind,\n-                                                                |this| {\n-                                        use crate::ResolutionError::*;\n-                                        match impl_item.kind {\n-                                            AssocItemKind::Const(..) => {\n-                                                debug!(\n-                                                    \"resolve_implementation AssocItemKind::Const\",\n-                                                );\n-                                                // If this is a trait impl, ensure the const\n-                                                // exists in trait\n-                                                this.check_trait_item(\n-                                                    impl_item.ident,\n-                                                    ValueNS,\n-                                                    impl_item.span,\n-                                                    |n, s| ConstNotMemberOfTrait(n, s),\n-                                                );\n-\n-                                                this.with_constant_rib(|this| {\n+                                for item in impl_items {\n+                                    use crate::ResolutionError::*;\n+                                    match &item.kind {\n+                                        AssocItemKind::Static(..) | AssocItemKind::Const(..) => {\n+                                            debug!(\"resolve_implementation AssocItemKind::Const\",);\n+                                            // If this is a trait impl, ensure the const\n+                                            // exists in trait\n+                                            this.check_trait_item(\n+                                                item.ident,\n+                                                ValueNS,\n+                                                item.span,\n+                                                |n, s| ConstNotMemberOfTrait(n, s),\n+                                            );\n+\n+                                            this.with_constant_rib(|this| {\n+                                                visit::walk_assoc_item(this, item, AssocCtxt::Impl)\n+                                            });\n+                                        }\n+                                        AssocItemKind::Fn(_, generics, _) => {\n+                                            // We also need a new scope for the impl item type parameters.\n+                                            this.with_generic_param_rib(\n+                                                generics,\n+                                                AssocItemRibKind,\n+                                                |this| {\n+                                                    // If this is a trait impl, ensure the method\n+                                                    // exists in trait\n+                                                    this.check_trait_item(\n+                                                        item.ident,\n+                                                        ValueNS,\n+                                                        item.span,\n+                                                        |n, s| MethodNotMemberOfTrait(n, s),\n+                                                    );\n+\n+                                                    visit::walk_assoc_item(\n+                                                        this,\n+                                                        item,\n+                                                        AssocCtxt::Impl,\n+                                                    )\n+                                                },\n+                                            );\n+                                        }\n+                                        AssocItemKind::TyAlias(generics, _, _) => {\n+                                            // We also need a new scope for the impl item type parameters.\n+                                            this.with_generic_param_rib(\n+                                                generics,\n+                                                AssocItemRibKind,\n+                                                |this| {\n+                                                    // If this is a trait impl, ensure the type\n+                                                    // exists in trait\n+                                                    this.check_trait_item(\n+                                                        item.ident,\n+                                                        TypeNS,\n+                                                        item.span,\n+                                                        |n, s| TypeNotMemberOfTrait(n, s),\n+                                                    );\n+\n                                                     visit::walk_assoc_item(\n                                                         this,\n-                                                        impl_item,\n+                                                        item,\n                                                         AssocCtxt::Impl,\n                                                     )\n-                                                });\n-                                            }\n-                                            AssocItemKind::Fn(..) => {\n-                                                // If this is a trait impl, ensure the method\n-                                                // exists in trait\n-                                                this.check_trait_item(impl_item.ident,\n-                                                                      ValueNS,\n-                                                                      impl_item.span,\n-                                                    |n, s| MethodNotMemberOfTrait(n, s));\n-\n-                                                visit::walk_assoc_item(\n-                                                    this,\n-                                                    impl_item,\n-                                                    AssocCtxt::Impl,\n-                                                )\n-                                            }\n-                                            AssocItemKind::TyAlias(_, _) => {\n-                                                // If this is a trait impl, ensure the type\n-                                                // exists in trait\n-                                                this.check_trait_item(impl_item.ident,\n-                                                                      TypeNS,\n-                                                                      impl_item.span,\n-                                                    |n, s| TypeNotMemberOfTrait(n, s));\n-\n-                                                visit::walk_assoc_item(\n-                                                    this,\n-                                                    impl_item,\n-                                                    AssocCtxt::Impl,\n-                                                )\n-                                            }\n-                                            AssocItemKind::Macro(_) =>\n-                                                panic!(\"unexpanded macro in resolve!\"),\n+                                                },\n+                                            );\n+                                        }\n+                                        AssocItemKind::Macro(_) => {\n+                                            panic!(\"unexpanded macro in resolve!\")\n                                         }\n-                                    });\n+                                    }\n                                 }\n                             });\n                         });"}, {"sha": "db7733e72416ad56ea1ba9e05f704f82281fcb92", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -400,7 +400,7 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n         &mut self,\n         item: &'l ast::Item,\n         typ: &'l ast::Ty,\n-        expr: &'l ast::Expr,\n+        expr: Option<&'l ast::Expr>,\n     ) {\n         let hir_id = self.tcx.hir().node_to_hir_id(item.id);\n         self.nest_tables(item.id, |v| {\n@@ -409,7 +409,7 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n                 v.dumper.dump_def(&access_from!(v.save_ctxt, item, hir_id), var_data);\n             }\n             v.visit_ty(&typ);\n-            v.visit_expr(expr);\n+            walk_list!(v, visit_expr, expr);\n         });\n     }\n \n@@ -1004,7 +1004,8 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n         self.process_macro_use(trait_item.span);\n         let vis_span = trait_item.span.shrink_to_lo();\n         match trait_item.kind {\n-            ast::AssocItemKind::Const(ref ty, ref expr) => {\n+            ast::AssocItemKind::Static(ref ty, _, ref expr)\n+            | ast::AssocItemKind::Const(ref ty, ref expr) => {\n                 self.process_assoc_const(\n                     trait_item.id,\n                     trait_item.ident,\n@@ -1015,18 +1016,18 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n                     &trait_item.attrs,\n                 );\n             }\n-            ast::AssocItemKind::Fn(ref sig, ref body) => {\n+            ast::AssocItemKind::Fn(ref sig, ref generics, ref body) => {\n                 self.process_method(\n                     sig,\n                     body.as_ref().map(|x| &**x),\n                     trait_item.id,\n                     trait_item.ident,\n-                    &trait_item.generics,\n+                    generics,\n                     respan(vis_span, ast::VisibilityKind::Public),\n                     trait_item.span,\n                 );\n             }\n-            ast::AssocItemKind::TyAlias(ref bounds, ref default_ty) => {\n+            ast::AssocItemKind::TyAlias(_, ref bounds, ref default_ty) => {\n                 // FIXME do something with _bounds (for type refs)\n                 let name = trait_item.ident.name.to_string();\n                 let qualname = format!(\n@@ -1074,7 +1075,8 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n     fn process_impl_item(&mut self, impl_item: &'l ast::AssocItem, impl_id: DefId) {\n         self.process_macro_use(impl_item.span);\n         match impl_item.kind {\n-            ast::AssocItemKind::Const(ref ty, ref expr) => {\n+            ast::AssocItemKind::Static(ref ty, _, ref expr)\n+            | ast::AssocItemKind::Const(ref ty, ref expr) => {\n                 self.process_assoc_const(\n                     impl_item.id,\n                     impl_item.ident,\n@@ -1085,19 +1087,19 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n                     &impl_item.attrs,\n                 );\n             }\n-            ast::AssocItemKind::Fn(ref sig, ref body) => {\n+            ast::AssocItemKind::Fn(ref sig, ref generics, ref body) => {\n                 self.process_method(\n                     sig,\n                     body.as_deref(),\n                     impl_item.id,\n                     impl_item.ident,\n-                    &impl_item.generics,\n+                    generics,\n                     impl_item.vis.clone(),\n                     impl_item.span,\n                 );\n             }\n-            ast::AssocItemKind::TyAlias(_, None) => {}\n-            ast::AssocItemKind::TyAlias(_, Some(ref ty)) => {\n+            ast::AssocItemKind::TyAlias(_, _, None) => {}\n+            ast::AssocItemKind::TyAlias(_, _, Some(ref ty)) => {\n                 // FIXME: uses of the assoc type should ideally point to this\n                 // 'def' and the name here should be a ref to the def in the\n                 // trait.\n@@ -1293,8 +1295,8 @@ impl<'l, 'tcx> Visitor<'l> for DumpVisitor<'l, 'tcx> {\n             Fn(ref sig, ref ty_params, ref body) => {\n                 self.process_fn(item, &sig.decl, &sig.header, ty_params, body.as_deref())\n             }\n-            Static(ref typ, _, ref expr) => self.process_static_or_const_item(item, typ, expr),\n-            Const(ref typ, ref expr) => self.process_static_or_const_item(item, &typ, &expr),\n+            Static(ref typ, _, ref e) => self.process_static_or_const_item(item, typ, e.as_deref()),\n+            Const(ref typ, ref e) => self.process_static_or_const_item(item, typ, e.as_deref()),\n             Struct(ref def, ref ty_params) | Union(ref def, ref ty_params) => {\n                 self.process_struct(item, def, ty_params)\n             }\n@@ -1532,15 +1534,15 @@ impl<'l, 'tcx> Visitor<'l> for DumpVisitor<'l, 'tcx> {\n                     self.visit_ty(&ret_ty);\n                 }\n             }\n-            ast::ForeignItemKind::Static(ref ty, _) => {\n+            ast::ForeignItemKind::Const(ref ty, _) | ast::ForeignItemKind::Static(ref ty, _, _) => {\n                 if let Some(var_data) = self.save_ctxt.get_extern_item_data(item) {\n                     down_cast_data!(var_data, DefData, item.span);\n                     self.dumper.dump_def(&access, var_data);\n                 }\n \n                 self.visit_ty(ty);\n             }\n-            ast::ForeignItemKind::Ty => {\n+            ast::ForeignItemKind::TyAlias(..) => {\n                 if let Some(var_data) = self.save_ctxt.get_extern_item_data(item) {\n                     down_cast_data!(var_data, DefData, item.span);\n                     self.dumper.dump_def(&access, var_data);"}, {"sha": "6a34e47130f18258c64b02b3b996cd52d28140b1", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -151,7 +151,7 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n                     attributes: lower_attributes(item.attrs.clone(), self),\n                 }))\n             }\n-            ast::ForeignItemKind::Static(ref ty, _) => {\n+            ast::ForeignItemKind::Const(ref ty, _) | ast::ForeignItemKind::Static(ref ty, _, _) => {\n                 filter!(self.span_utils, item.ident.span);\n \n                 let id = id_from_node_id(item.id, self);\n@@ -173,7 +173,7 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n                 }))\n             }\n             // FIXME(plietar): needs a new DefKind in rls-data\n-            ast::ForeignItemKind::Ty => None,\n+            ast::ForeignItemKind::TyAlias(..) => None,\n             ast::ForeignItemKind::Macro(..) => None,\n         }\n     }"}, {"sha": "a2c61db4b7c0b61cd72a30b5df42d03d8dbfdd54", "filename": "src/librustc_save_analysis/sig.rs", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Flibrustc_save_analysis%2Fsig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Flibrustc_save_analysis%2Fsig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fsig.rs?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -334,10 +334,13 @@ impl Sig for ast::Item {\n \n                 let ty = ty.make(offset + text.len(), id, scx)?;\n                 text.push_str(&ty.text);\n-                text.push_str(\" = \");\n \n-                let expr = pprust::expr_to_string(expr).replace('\\n', \" \");\n-                text.push_str(&expr);\n+                if let Some(expr) = expr {\n+                    text.push_str(\" = \");\n+                    let expr = pprust::expr_to_string(expr).replace('\\n', \" \");\n+                    text.push_str(&expr);\n+                }\n+\n                 text.push(';');\n \n                 Ok(extend_sig(ty, text, defs, vec![]))\n@@ -355,10 +358,13 @@ impl Sig for ast::Item {\n \n                 let ty = ty.make(offset + text.len(), id, scx)?;\n                 text.push_str(&ty.text);\n-                text.push_str(\" = \");\n \n-                let expr = pprust::expr_to_string(expr).replace('\\n', \" \");\n-                text.push_str(&expr);\n+                if let Some(expr) = expr {\n+                    text.push_str(\" = \");\n+                    let expr = pprust::expr_to_string(expr).replace('\\n', \" \");\n+                    text.push_str(&expr);\n+                }\n+\n                 text.push(';');\n \n                 Ok(extend_sig(ty, text, defs, vec![]))\n@@ -754,7 +760,7 @@ impl Sig for ast::ForeignItem {\n \n                 Ok(sig)\n             }\n-            ast::ForeignItemKind::Static(ref ty, m) => {\n+            ast::ForeignItemKind::Static(ref ty, m, _) => {\n                 let mut text = \"static \".to_owned();\n                 if m == ast::Mutability::Mut {\n                     text.push_str(\"mut \");\n@@ -773,7 +779,7 @@ impl Sig for ast::ForeignItem {\n \n                 Ok(extend_sig(ty_sig, text, defs, vec![]))\n             }\n-            ast::ForeignItemKind::Ty => {\n+            ast::ForeignItemKind::TyAlias(..) => {\n                 let mut text = \"type \".to_owned();\n                 let name = self.ident.to_string();\n                 let defs = vec![SigElement {\n@@ -786,6 +792,7 @@ impl Sig for ast::ForeignItem {\n \n                 Ok(Signature { text: text, defs: defs, refs: vec![] })\n             }\n+            ast::ForeignItemKind::Const(..) => Err(\"foreign const\"),\n             ast::ForeignItemKind::Macro(..) => Err(\"macro\"),\n         }\n     }"}, {"sha": "bb31e979b733fdae6017ade7e8a402a6683d2f4b", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -5,7 +5,7 @@ use super::{FnCtxt, Needs};\n use rustc::ty::adjustment::{Adjust, Adjustment, AllowTwoPhase, AutoBorrow, AutoBorrowMutability};\n use rustc::ty::TyKind::{Adt, Array, Char, FnDef, Never, Ref, Str, Tuple, Uint};\n use rustc::ty::{self, Ty, TypeFoldable};\n-use rustc_errors::{self, struct_span_err, Applicability};\n+use rustc_errors::{self, struct_span_err, Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_span::Span;\n@@ -321,11 +321,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                         lhs_ty, missing_trait\n                                     ));\n                                 } else if !suggested_deref {\n-                                    err.note(&format!(\n-                                        \"an implementation of `{}` might \\\n-                                         be missing for `{}`\",\n-                                        missing_trait, lhs_ty\n-                                    ));\n+                                    suggest_impl_missing(&mut err, lhs_ty, &missing_trait);\n                                 }\n                             }\n                             err.emit();\n@@ -467,11 +463,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                         lhs_ty, missing_trait\n                                     ));\n                                 } else if !suggested_deref && !involves_fn {\n-                                    err.note(&format!(\n-                                        \"an implementation of `{}` might \\\n-                                         be missing for `{}`\",\n-                                        missing_trait, lhs_ty\n-                                    ));\n+                                    suggest_impl_missing(&mut err, lhs_ty, &missing_trait);\n                                 }\n                             }\n                             err.emit();\n@@ -707,11 +699,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 hir::UnOp::UnNot => \"std::ops::Not\",\n                                 hir::UnOp::UnDeref => \"std::ops::UnDerf\",\n                             };\n-                            err.note(&format!(\n-                                \"an implementation of `{}` might \\\n-                                                be missing for `{}`\",\n-                                missing_trait, operand_ty\n-                            ));\n+                            suggest_impl_missing(&mut err, operand_ty, &missing_trait);\n                         }\n                     }\n                     err.emit();\n@@ -929,3 +917,16 @@ fn is_builtin_binop<'tcx>(lhs: Ty<'tcx>, rhs: Ty<'tcx>, op: hir::BinOp) -> bool\n         }\n     }\n }\n+\n+/// If applicable, note that an implementation of `trait` for `ty` may fix the error.\n+fn suggest_impl_missing(err: &mut DiagnosticBuilder<'_>, ty: Ty<'_>, missing_trait: &str) {\n+    if let Adt(def, _) = ty.peel_refs().kind {\n+        if def.did.is_local() {\n+            err.note(&format!(\n+                \"an implementation of `{}` might \\\n+                be missing for `{}`\",\n+                missing_trait, ty\n+            ));\n+        }\n+    }\n+}"}, {"sha": "70586be0d04336964f9d6f49ddda10a43cb54d4c", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 44, "deletions": 6, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -33,7 +33,7 @@ use rustc::ty::{self, AdtKind, Const, ToPolyTraitRef, Ty, TyCtxt};\n use rustc::ty::{ReprOptions, ToPredicate, WithConstness};\n use rustc_attr::{list_contains_name, mark_used, InlineAttr, OptimizeAttr};\n use rustc_data_structures::captures::Captures;\n-use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::{struct_span_err, Applicability};\n use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, DefKind, Res};\n@@ -369,10 +369,12 @@ impl AstConv<'tcx> for ItemCtxt<'tcx> {\n                         hir::ItemKind::Enum(_, generics)\n                         | hir::ItemKind::Struct(_, generics)\n                         | hir::ItemKind::Union(_, generics) => {\n-                            // FIXME: look for an appropriate lt name if `'a` is already used\n+                            let lt_name = get_new_lifetime_name(self.tcx, poly_trait_ref, generics);\n                             let (lt_sp, sugg) = match &generics.params[..] {\n-                                [] => (generics.span, \"<'a>\".to_string()),\n-                                [bound, ..] => (bound.span.shrink_to_lo(), \"'a, \".to_string()),\n+                                [] => (generics.span, format!(\"<{}>\", lt_name)),\n+                                [bound, ..] => {\n+                                    (bound.span.shrink_to_lo(), format!(\"{}, \", lt_name))\n+                                }\n                             };\n                             let suggestions = vec![\n                                 (lt_sp, sugg),\n@@ -387,7 +389,7 @@ impl AstConv<'tcx> for ItemCtxt<'tcx> {\n                                                     ty::EarlyBoundRegion {\n                                                         def_id: item_def_id,\n                                                         index: 0,\n-                                                        name: Symbol::intern(\"'a\"),\n+                                                        name: Symbol::intern(&lt_name),\n                                                     },\n                                                 ))\n                                             })\n@@ -445,6 +447,43 @@ impl AstConv<'tcx> for ItemCtxt<'tcx> {\n     }\n }\n \n+/// Synthesize a new lifetime name that doesn't clash with any of the lifetimes already present.\n+fn get_new_lifetime_name<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    poly_trait_ref: ty::PolyTraitRef<'tcx>,\n+    generics: &hir::Generics<'tcx>,\n+) -> String {\n+    let existing_lifetimes = tcx\n+        .collect_referenced_late_bound_regions(&poly_trait_ref)\n+        .into_iter()\n+        .filter_map(|lt| {\n+            if let ty::BoundRegion::BrNamed(_, name) = lt {\n+                Some(name.as_str().to_string())\n+            } else {\n+                None\n+            }\n+        })\n+        .chain(generics.params.iter().filter_map(|param| {\n+            if let hir::GenericParamKind::Lifetime { .. } = &param.kind {\n+                Some(param.name.ident().as_str().to_string())\n+            } else {\n+                None\n+            }\n+        }))\n+        .collect::<FxHashSet<String>>();\n+\n+    let a_to_z_repeat_n = |n| {\n+        (b'a'..=b'z').map(move |c| {\n+            let mut s = format!(\"'\");\n+            s.extend(std::iter::repeat(char::from(c)).take(n));\n+            s\n+        })\n+    };\n+\n+    // If all single char lifetime names are present, we wrap around and double the chars.\n+    (1..).flat_map(a_to_z_repeat_n).find(|lt| !existing_lifetimes.contains(lt.as_str())).unwrap()\n+}\n+\n /// Returns the predicates defined on `item_def_id` of the form\n /// `X: Foo` where `X` is the type parameter `def_id`.\n fn type_param_predicates(\n@@ -1588,7 +1627,6 @@ fn predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicates<'_> {\n /// Returns a list of user-specified type predicates for the definition with ID `def_id`.\n /// N.B., this does not include any implied/inferred constraints.\n fn explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicates<'_> {\n-    use rustc_data_structures::fx::FxHashSet;\n     use rustc_hir::*;\n \n     debug!(\"explicit_predicates_of(def_id={:?})\", def_id);"}, {"sha": "9ae3010a0f6561e59b3891442d358c77ca0c2bca", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 39, "deletions": 62, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -1612,46 +1612,6 @@ pub struct FnSig {\n     pub decl: P<FnDecl>,\n }\n \n-/// Represents associated items.\n-/// These include items in `impl` and `trait` definitions.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n-pub struct AssocItem {\n-    pub attrs: Vec<Attribute>,\n-    pub id: NodeId,\n-    pub span: Span,\n-    pub vis: Visibility,\n-    pub ident: Ident,\n-\n-    pub defaultness: Defaultness,\n-    pub generics: Generics,\n-    pub kind: AssocItemKind,\n-    /// See `Item::tokens` for what this is.\n-    pub tokens: Option<TokenStream>,\n-}\n-\n-/// Represents various kinds of content within an `impl`.\n-///\n-/// The term \"provided\" in the variants below refers to the item having a default\n-/// definition / body. Meanwhile, a \"required\" item lacks a definition / body.\n-/// In an implementation, all items must be provided.\n-/// The `Option`s below denote the bodies, where `Some(_)`\n-/// means \"provided\" and conversely `None` means \"required\".\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n-pub enum AssocItemKind {\n-    /// An associated constant, `const $ident: $ty $def?;` where `def ::= \"=\" $expr? ;`.\n-    /// If `def` is parsed, then the associated constant is provided, and otherwise required.\n-    Const(P<Ty>, Option<P<Expr>>),\n-\n-    /// An associated function.\n-    Fn(FnSig, Option<P<Block>>),\n-\n-    /// An associated type.\n-    TyAlias(GenericBounds, Option<P<Ty>>),\n-\n-    /// A macro expanding to an associated item.\n-    Macro(Mac),\n-}\n-\n #[derive(\n     Clone,\n     Copy,\n@@ -2542,11 +2502,11 @@ pub enum ItemKind {\n     /// A static item (`static`).\n     ///\n     /// E.g., `static FOO: i32 = 42;` or `static FOO: &'static str = \"bar\";`.\n-    Static(P<Ty>, Mutability, P<Expr>),\n+    Static(P<Ty>, Mutability, Option<P<Expr>>),\n     /// A constant item (`const`).\n     ///\n     /// E.g., `const FOO: i32 = 42;`.\n-    Const(P<Ty>, P<Expr>),\n+    Const(P<Ty>, Option<P<Expr>>),\n     /// A function declaration (`fn`).\n     ///\n     /// E.g., `fn foo(bar: usize) -> usize { .. }`.\n@@ -2646,28 +2606,45 @@ impl ItemKind {\n     }\n }\n \n-pub type ForeignItem = Item<ForeignItemKind>;\n+// FIXME(Centril): These definitions should be unmerged;\n+// see https://github.com/rust-lang/rust/pull/69194#discussion_r379899975\n+pub type ForeignItem = Item<AssocItemKind>;\n+pub type ForeignItemKind = AssocItemKind;\n \n-/// An item within an `extern` block.\n+/// Represents associated items.\n+/// These include items in `impl` and `trait` definitions.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n-pub enum ForeignItemKind {\n-    /// A foreign function.\n-    Fn(FnSig, Generics, Option<P<Block>>),\n-    /// A foreign static item (`static ext: u8`).\n-    Static(P<Ty>, Mutability),\n-    /// A foreign type.\n-    Ty,\n-    /// A macro invocation.\n-    Macro(Mac),\n+pub struct AssocItem {\n+    pub attrs: Vec<Attribute>,\n+    pub id: NodeId,\n+    pub span: Span,\n+    pub vis: Visibility,\n+    pub ident: Ident,\n+\n+    pub defaultness: Defaultness,\n+    pub kind: AssocItemKind,\n+    /// See `Item::tokens` for what this is.\n+    pub tokens: Option<TokenStream>,\n }\n \n-impl ForeignItemKind {\n-    pub fn descriptive_variant(&self) -> &str {\n-        match *self {\n-            ForeignItemKind::Fn(..) => \"foreign function\",\n-            ForeignItemKind::Static(..) => \"foreign static item\",\n-            ForeignItemKind::Ty => \"foreign type\",\n-            ForeignItemKind::Macro(..) => \"macro in foreign module\",\n-        }\n-    }\n+/// Represents non-free item kinds.\n+///\n+/// The term \"provided\" in the variants below refers to the item having a default\n+/// definition / body. Meanwhile, a \"required\" item lacks a definition / body.\n+/// In an implementation, all items must be provided.\n+/// The `Option`s below denote the bodies, where `Some(_)`\n+/// means \"provided\" and conversely `None` means \"required\".\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+pub enum AssocItemKind {\n+    /// A constant, `const $ident: $ty $def?;` where `def ::= \"=\" $expr? ;`.\n+    /// If `def` is parsed, then the constant is provided, and otherwise required.\n+    Const(P<Ty>, Option<P<Expr>>),\n+    /// A static item (`static FOO: u8`).\n+    Static(P<Ty>, Mutability, Option<P<Expr>>),\n+    /// A function.\n+    Fn(FnSig, Generics, Option<P<Block>>),\n+    /// A type.\n+    TyAlias(Generics, GenericBounds, Option<P<Ty>>),\n+    /// A macro expanding to items.\n+    Macro(Mac),\n }"}, {"sha": "92f20b719f80e4d4b0492c3e106d6cec1d8b2c6a", "filename": "src/libsyntax/mut_visit.rs", "status": "modified", "additions": 22, "deletions": 29, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Flibsyntax%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Flibsyntax%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fmut_visit.rs?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -890,13 +890,9 @@ pub fn noop_visit_item_kind<T: MutVisitor>(kind: &mut ItemKind, vis: &mut T) {\n     match kind {\n         ItemKind::ExternCrate(_orig_name) => {}\n         ItemKind::Use(use_tree) => vis.visit_use_tree(use_tree),\n-        ItemKind::Static(ty, _mut, expr) => {\n+        ItemKind::Static(ty, _, expr) | ItemKind::Const(ty, expr) => {\n             vis.visit_ty(ty);\n-            vis.visit_expr(expr);\n-        }\n-        ItemKind::Const(ty, expr) => {\n-            vis.visit_ty(ty);\n-            vis.visit_expr(expr);\n+            visit_opt(expr, |expr| vis.visit_expr(expr));\n         }\n         ItemKind::Fn(sig, generics, body) => {\n             visit_fn_sig(sig, vis);\n@@ -951,31 +947,43 @@ pub fn noop_flat_map_assoc_item<T: MutVisitor>(\n     mut item: P<AssocItem>,\n     visitor: &mut T,\n ) -> SmallVec<[P<AssocItem>; 1]> {\n-    let AssocItem { id, ident, vis, defaultness: _, attrs, generics, kind, span, tokens: _ } =\n+    let AssocItem { id, ident, vis, defaultness: _, attrs, kind, span, tokens: _ } =\n         item.deref_mut();\n+    walk_nested_item(visitor, id, span, ident, vis, attrs, kind);\n+    smallvec![item]\n+}\n+\n+pub fn walk_nested_item(\n+    visitor: &mut impl MutVisitor,\n+    id: &mut NodeId,\n+    span: &mut Span,\n+    ident: &mut Ident,\n+    vis: &mut Visibility,\n+    attrs: &mut Vec<Attribute>,\n+    kind: &mut AssocItemKind,\n+) {\n     visitor.visit_id(id);\n     visitor.visit_ident(ident);\n     visitor.visit_vis(vis);\n     visit_attrs(attrs, visitor);\n-    visitor.visit_generics(generics);\n     match kind {\n-        AssocItemKind::Const(ty, expr) => {\n+        AssocItemKind::Const(ty, expr) | AssocItemKind::Static(ty, _, expr) => {\n             visitor.visit_ty(ty);\n             visit_opt(expr, |expr| visitor.visit_expr(expr));\n         }\n-        AssocItemKind::Fn(sig, body) => {\n+        AssocItemKind::Fn(sig, generics, body) => {\n+            visitor.visit_generics(generics);\n             visit_fn_sig(sig, visitor);\n             visit_opt(body, |body| visitor.visit_block(body));\n         }\n-        AssocItemKind::TyAlias(bounds, ty) => {\n+        AssocItemKind::TyAlias(generics, bounds, ty) => {\n+            visitor.visit_generics(generics);\n             visit_bounds(bounds, visitor);\n             visit_opt(ty, |ty| visitor.visit_ty(ty));\n         }\n         AssocItemKind::Macro(mac) => visitor.visit_mac(mac),\n     }\n     visitor.visit_span(span);\n-\n-    smallvec![item]\n }\n \n pub fn noop_visit_fn_header<T: MutVisitor>(header: &mut FnHeader, vis: &mut T) {\n@@ -1041,22 +1049,7 @@ pub fn noop_flat_map_foreign_item<T: MutVisitor>(\n     visitor: &mut T,\n ) -> SmallVec<[P<ForeignItem>; 1]> {\n     let ForeignItem { ident, attrs, id, kind, vis, span, tokens: _ } = item.deref_mut();\n-    visitor.visit_ident(ident);\n-    visit_attrs(attrs, visitor);\n-    match kind {\n-        ForeignItemKind::Fn(sig, generics, body) => {\n-            visit_fn_sig(sig, visitor);\n-            visitor.visit_generics(generics);\n-            visit_opt(body, |body| visitor.visit_block(body));\n-        }\n-        ForeignItemKind::Static(t, _m) => visitor.visit_ty(t),\n-        ForeignItemKind::Ty => {}\n-        ForeignItemKind::Macro(mac) => visitor.visit_mac(mac),\n-    }\n-    visitor.visit_id(id);\n-    visitor.visit_span(span);\n-    visitor.visit_vis(vis);\n-\n+    walk_nested_item(visitor, id, span, ident, vis, attrs, kind);\n     smallvec![item]\n }\n "}, {"sha": "dedd42fe0f6875a9b88df8a458b723e4285ed0ff", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 29, "deletions": 27, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -300,7 +300,7 @@ pub fn walk_item<'a, V: Visitor<'a>>(visitor: &mut V, item: &'a Item) {\n         ItemKind::Use(ref use_tree) => visitor.visit_use_tree(use_tree, item.id, false),\n         ItemKind::Static(ref typ, _, ref expr) | ItemKind::Const(ref typ, ref expr) => {\n             visitor.visit_ty(typ);\n-            visitor.visit_expr(expr);\n+            walk_list!(visitor, visit_expr, expr);\n         }\n         ItemKind::Fn(ref sig, ref generics, ref body) => {\n             visitor.visit_generics(generics);\n@@ -525,21 +525,8 @@ pub fn walk_pat<'a, V: Visitor<'a>>(visitor: &mut V, pattern: &'a Pat) {\n }\n \n pub fn walk_foreign_item<'a, V: Visitor<'a>>(visitor: &mut V, item: &'a ForeignItem) {\n-    visitor.visit_vis(&item.vis);\n-    visitor.visit_ident(item.ident);\n-\n-    match item.kind {\n-        ForeignItemKind::Fn(ref sig, ref generics, ref body) => {\n-            visitor.visit_generics(generics);\n-            let kind = FnKind::Fn(FnCtxt::Foreign, item.ident, sig, &item.vis, body.as_deref());\n-            visitor.visit_fn(kind, item.span, item.id);\n-        }\n-        ForeignItemKind::Static(ref typ, _) => visitor.visit_ty(typ),\n-        ForeignItemKind::Ty => (),\n-        ForeignItemKind::Macro(ref mac) => visitor.visit_mac(mac),\n-    }\n-\n-    walk_list!(visitor, visit_attribute, &item.attrs);\n+    let ForeignItem { id, span, ident, vis, attrs, kind, tokens: _ } = item;\n+    walk_nested_item(visitor, *id, *span, *ident, vis, attrs, kind, FnCtxt::Foreign);\n }\n \n pub fn walk_global_asm<'a, V: Visitor<'a>>(_: &mut V, _: &'a GlobalAsm) {\n@@ -622,24 +609,39 @@ pub fn walk_fn<'a, V: Visitor<'a>>(visitor: &mut V, kind: FnKind<'a>, _span: Spa\n }\n \n pub fn walk_assoc_item<'a, V: Visitor<'a>>(visitor: &mut V, item: &'a AssocItem, ctxt: AssocCtxt) {\n-    visitor.visit_vis(&item.vis);\n-    visitor.visit_ident(item.ident);\n-    walk_list!(visitor, visit_attribute, &item.attrs);\n-    visitor.visit_generics(&item.generics);\n-    match item.kind {\n-        AssocItemKind::Const(ref ty, ref expr) => {\n+    let AssocItem { id, span, ident, vis, attrs, kind, tokens: _, defaultness: _ } = item;\n+    walk_nested_item(visitor, *id, *span, *ident, vis, attrs, kind, FnCtxt::Assoc(ctxt));\n+}\n+\n+fn walk_nested_item<'a, V: Visitor<'a>>(\n+    visitor: &mut V,\n+    id: NodeId,\n+    span: Span,\n+    ident: Ident,\n+    vis: &'a Visibility,\n+    attrs: &'a [Attribute],\n+    kind: &'a AssocItemKind,\n+    ctxt: FnCtxt,\n+) {\n+    visitor.visit_vis(vis);\n+    visitor.visit_ident(ident);\n+    walk_list!(visitor, visit_attribute, attrs);\n+    match kind {\n+        AssocItemKind::Const(ty, expr) | AssocItemKind::Static(ty, _, expr) => {\n             visitor.visit_ty(ty);\n             walk_list!(visitor, visit_expr, expr);\n         }\n-        AssocItemKind::Fn(ref sig, ref body) => {\n-            let kind = FnKind::Fn(FnCtxt::Assoc(ctxt), item.ident, sig, &item.vis, body.as_deref());\n-            visitor.visit_fn(kind, item.span, item.id);\n+        AssocItemKind::Fn(sig, generics, body) => {\n+            visitor.visit_generics(generics);\n+            let kind = FnKind::Fn(ctxt, ident, sig, vis, body.as_deref());\n+            visitor.visit_fn(kind, span, id);\n         }\n-        AssocItemKind::TyAlias(ref bounds, ref ty) => {\n+        AssocItemKind::TyAlias(generics, bounds, ty) => {\n+            visitor.visit_generics(generics);\n             walk_list!(visitor, visit_param_bound, bounds);\n             walk_list!(visitor, visit_ty, ty);\n         }\n-        AssocItemKind::Macro(ref mac) => {\n+        AssocItemKind::Macro(mac) => {\n             visitor.visit_mac(mac);\n         }\n     }"}, {"sha": "d9851a2f7942248a26cbaae65e19b3af11472935", "filename": "src/test/run-make-fulldeps/min-global-align/min_global_align.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Frun-make-fulldeps%2Fmin-global-align%2Fmin_global_align.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Frun-make-fulldeps%2Fmin-global-align%2Fmin_global_align.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fmin-global-align%2Fmin_global_align.rs?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -1,5 +1,5 @@\n #![feature(no_core, lang_items)]\n-#![crate_type=\"rlib\"]\n+#![crate_type = \"rlib\"]\n #![no_core]\n \n pub static STATIC_BOOL: bool = true;\n@@ -9,7 +9,6 @@ pub static mut STATIC_MUT_BOOL: bool = true;\n const CONST_BOOL: bool = true;\n pub static CONST_BOOL_REF: &'static bool = &CONST_BOOL;\n \n-\n #[lang = \"sized\"]\n trait Sized {}\n \n@@ -19,10 +18,13 @@ trait Copy {}\n #[lang = \"freeze\"]\n trait Freeze {}\n \n+// No `UnsafeCell`, so everything is `Freeze`.\n+impl<T: ?Sized> Freeze for T {}\n+\n #[lang = \"sync\"]\n trait Sync {}\n impl Sync for bool {}\n impl Sync for &'static bool {}\n \n-#[lang=\"drop_in_place\"]\n-pub unsafe fn drop_in_place<T: ?Sized>(_: *mut T) { }\n+#[lang = \"drop_in_place\"]\n+pub unsafe fn drop_in_place<T: ?Sized>(_: *mut T) {}"}, {"sha": "58f186d7775ea6d4b844594bea3465847c1fb9d8", "filename": "src/test/ui/associated-types/associated-types-project-from-hrtb-in-struct.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-project-from-hrtb-in-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-project-from-hrtb-in-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-project-from-hrtb-in-struct.rs?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -12,11 +12,12 @@ struct SomeStruct<I: for<'x> Foo<&'x isize>> {\n     //~^ ERROR cannot extract an associated type from a higher-ranked trait bound in this context\n }\n \n-enum SomeEnum<I: for<'x> Foo<&'x isize>> {\n+enum SomeEnum<'b, I: for<'a> Foo<&'a isize>> {\n     TupleVariant(I::A),\n     //~^ ERROR cannot extract an associated type from a higher-ranked trait bound in this context\n     StructVariant { field: I::A },\n     //~^ ERROR cannot extract an associated type from a higher-ranked trait bound in this context\n+    OkVariant(&'b usize),\n }\n \n // FIXME(eddyb) This one doesn't even compile because of the unsupported syntax.\n@@ -26,7 +27,13 @@ enum SomeEnum<I: for<'x> Foo<&'x isize>> {\n // }\n \n struct YetAnotherStruct<'a, I: for<'x> Foo<&'x isize>> {\n-    field: <I as Foo<&'a isize>>::A\n+    field: <I as Foo<&'a isize>>::A,\n+}\n+\n+struct Why<'a, 'b, 'c, 'd, 'e, 'f, 'g, 'h, 'i, 'j, 'k, 'n, 'o, 'p, 'q, 'r, 's, 't, 'u, 'v, 'w, 'x,\n+    'y, 'z, 'aa, I: for<'l, 'm> Foo<&'l &'m isize>> {\n+    field: I::A,\n+    //~^ ERROR cannot extract an associated type from a higher-ranked trait bound in this context\n }\n \n pub fn main() {}"}, {"sha": "e3fd2860ebcf38efcd13187322220dcf03fbea19", "filename": "src/test/ui/associated-types/associated-types-project-from-hrtb-in-struct.stderr", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-project-from-hrtb-in-struct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-project-from-hrtb-in-struct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-project-from-hrtb-in-struct.stderr?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -18,8 +18,8 @@ LL |     TupleVariant(I::A),\n    |\n help: use a fully qualified path with explicit lifetimes\n    |\n-LL | enum SomeEnum<'a, I: for<'x> Foo<&'x isize>> {\n-LL |     TupleVariant(<I as Foo<&'a isize>>::A),\n+LL | enum SomeEnum<'c, 'b, I: for<'a> Foo<&'a isize>> {\n+LL |     TupleVariant(<I as Foo<&'c isize>>::A),\n    |\n \n error[E0212]: cannot extract an associated type from a higher-ranked trait bound in this context\n@@ -30,11 +30,24 @@ LL |     StructVariant { field: I::A },\n    |\n help: use a fully qualified path with explicit lifetimes\n    |\n-LL | enum SomeEnum<'a, I: for<'x> Foo<&'x isize>> {\n+LL | enum SomeEnum<'c, 'b, I: for<'a> Foo<&'a isize>> {\n LL |     TupleVariant(I::A),\n LL |\n-LL |     StructVariant { field: <I as Foo<&'a isize>>::A },\n+LL |     StructVariant { field: <I as Foo<&'c isize>>::A },\n    |\n \n-error: aborting due to 3 previous errors\n+error[E0212]: cannot extract an associated type from a higher-ranked trait bound in this context\n+  --> $DIR/associated-types-project-from-hrtb-in-struct.rs:35:12\n+   |\n+LL |     field: I::A,\n+   |            ^^^^\n+   |\n+help: use a fully qualified path with explicit lifetimes\n+   |\n+LL | struct Why<'bb, 'a, 'b, 'c, 'd, 'e, 'f, 'g, 'h, 'i, 'j, 'k, 'n, 'o, 'p, 'q, 'r, 's, 't, 'u, 'v, 'w, 'x,\n+LL |     'y, 'z, 'aa, I: for<'l, 'm> Foo<&'l &'m isize>> {\n+LL |     field: <I as Foo<&'bb &'bb isize>>::A,\n+   |\n+\n+error: aborting due to 4 previous errors\n "}, {"sha": "f094388794edaf42057c05edb7d777330d9d3218", "filename": "src/test/ui/autoderef-full-lval.stderr", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fautoderef-full-lval.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fautoderef-full-lval.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fautoderef-full-lval.stderr?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -5,8 +5,6 @@ LL |     let z: isize = a.x + b.y;\n    |                    --- ^ --- std::boxed::Box<isize>\n    |                    |\n    |                    std::boxed::Box<isize>\n-   |\n-   = note: an implementation of `std::ops::Add` might be missing for `std::boxed::Box<isize>`\n \n error[E0369]: cannot add `std::boxed::Box<isize>` to `std::boxed::Box<isize>`\n   --> $DIR/autoderef-full-lval.rs:21:33\n@@ -15,8 +13,6 @@ LL |     let answer: isize = forty.a + two.a;\n    |                         ------- ^ ----- std::boxed::Box<isize>\n    |                         |\n    |                         std::boxed::Box<isize>\n-   |\n-   = note: an implementation of `std::ops::Add` might be missing for `std::boxed::Box<isize>`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "18c1ce0ff02e14361f9fb88b299b048277ed157a", "filename": "src/test/ui/binop/binop-bitxor-str.stderr", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fbinop%2Fbinop-bitxor-str.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fbinop%2Fbinop-bitxor-str.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbinop%2Fbinop-bitxor-str.stderr?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -5,8 +5,6 @@ LL | fn main() { let x = \"a\".to_string() ^ \"b\".to_string(); }\n    |                     --------------- ^ --------------- std::string::String\n    |                     |\n    |                     std::string::String\n-   |\n-   = note: an implementation of `std::ops::BitXor` might be missing for `std::string::String`\n \n error: aborting due to previous error\n "}, {"sha": "859c44a859e85125263abda99646aa9d8558b2b2", "filename": "src/test/ui/binop/binop-mul-bool.stderr", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fbinop%2Fbinop-mul-bool.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fbinop%2Fbinop-mul-bool.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbinop%2Fbinop-mul-bool.stderr?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -5,8 +5,6 @@ LL | fn main() { let x = true * false; }\n    |                     ---- ^ ----- bool\n    |                     |\n    |                     bool\n-   |\n-   = note: an implementation of `std::ops::Mul` might be missing for `bool`\n \n error: aborting due to previous error\n "}, {"sha": "42d910819995a67afb8242972024a1df358ff0c5", "filename": "src/test/ui/binop/binop-typeck.stderr", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fbinop%2Fbinop-typeck.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fbinop%2Fbinop-typeck.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbinop%2Fbinop-typeck.stderr?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -5,8 +5,6 @@ LL |     let z = x + y;\n    |             - ^ - {integer}\n    |             |\n    |             bool\n-   |\n-   = note: an implementation of `std::ops::Add` might be missing for `bool`\n \n error: aborting due to previous error\n "}, {"sha": "c03377d74e9b79f1ac2014841002002661ae5ede", "filename": "src/test/ui/const-generics/array-impls/core-traits-no-impls-length-33.stderr", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fconst-generics%2Farray-impls%2Fcore-traits-no-impls-length-33.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fconst-generics%2Farray-impls%2Fcore-traits-no-impls-length-33.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Farray-impls%2Fcore-traits-no-impls-length-33.stderr?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -23,8 +23,6 @@ LL |     [0_usize; 33] == [1_usize; 33]\n    |     ------------- ^^ ------------- [usize; 33]\n    |     |\n    |     [usize; 33]\n-   |\n-   = note: an implementation of `std::cmp::PartialEq` might be missing for `[usize; 33]`\n \n error[E0369]: binary operation `<` cannot be applied to type `[usize; 33]`\n   --> $DIR/core-traits-no-impls-length-33.rs:19:19\n@@ -33,8 +31,6 @@ LL |     [0_usize; 33] < [1_usize; 33]\n    |     ------------- ^ ------------- [usize; 33]\n    |     |\n    |     [usize; 33]\n-   |\n-   = note: an implementation of `std::cmp::PartialOrd` might be missing for `[usize; 33]`\n \n error[E0277]: the trait bound `&[usize; 33]: std::iter::IntoIterator` is not satisfied\n   --> $DIR/core-traits-no-impls-length-33.rs:24:14"}, {"sha": "d4e25930d22d74541d09874423ea394cd4937070", "filename": "src/test/ui/destructuring-assignment/note-unsupported.stderr", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fnote-unsupported.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fnote-unsupported.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fnote-unsupported.stderr?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -16,8 +16,6 @@ LL |     (a, b) += (3, 4);\n    |     ------^^^^^^^^^^\n    |     |\n    |     cannot use `+=` on type `({integer}, {integer})`\n-   |\n-   = note: an implementation of `std::ops::AddAssign` might be missing for `({integer}, {integer})`\n \n error[E0067]: invalid left-hand side of assignment\n   --> $DIR/note-unsupported.rs:7:12\n@@ -48,8 +46,6 @@ LL |     [a, b] += [3, 4];\n    |     ------^^^^^^^^^^\n    |     |\n    |     cannot use `+=` on type `[{integer}; 2]`\n-   |\n-   = note: an implementation of `std::ops::AddAssign` might be missing for `[{integer}; 2]`\n \n error[E0067]: invalid left-hand side of assignment\n   --> $DIR/note-unsupported.rs:11:12"}, {"sha": "2ed682cea9503ac592d86cc257560d04f8d4ae1f", "filename": "src/test/ui/did_you_mean/issue-40006.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-40006.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-40006.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-40006.rs?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -18,10 +18,10 @@ trait A { //~ ERROR missing\n trait B {\n     fn xxx() { ### } //~ ERROR expected\n }\n-trait C { //~ ERROR missing `fn`, `type`, or `const` for associated-item declaration\n+trait C { //~ ERROR missing `fn`, `type`, `const`, or `static` for item declaration\n     L = M;\n }\n-trait D { //~ ERROR missing `fn`, `type`, or `const` for associated-item declaration\n+trait D { //~ ERROR missing `fn`, `type`, `const`, or `static` for item declaration\n     Z = { 2 + 3 };\n }\n trait E {"}, {"sha": "119e30a3e0f57fcdbaea075cacce6d6ae2155a1f", "filename": "src/test/ui/did_you_mean/issue-40006.stderr", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-40006.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-40006.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-40006.stderr?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -1,60 +1,60 @@\n-error: missing `fn`, `type`, or `const` for associated-item declaration\n+error: missing `fn`, `type`, `const`, or `static` for item declaration\n   --> $DIR/issue-40006.rs:1:13\n    |\n LL |   impl dyn A {\n    |  _____________^\n LL | |     Y\n-   | |____^ missing `fn`, `type`, or `const`\n+   | |____^ missing `fn`, `type`, `const`, or `static`\n \n-error: missing `fn`, `type`, or `const` for associated-item declaration\n+error: missing `fn`, `type`, `const`, or `static` for item declaration\n   --> $DIR/issue-40006.rs:7:10\n    |\n LL |   trait X {\n    |  __________^\n LL | |     X() {}\n-   | |____^ missing `fn`, `type`, or `const`\n+   | |____^ missing `fn`, `type`, `const`, or `static`\n \n-error: missing `fn`, `type`, or `const` for associated-item declaration\n+error: missing `fn`, `type`, `const`, or `static` for item declaration\n   --> $DIR/issue-40006.rs:15:10\n    |\n LL |   trait A {\n    |  __________^\n LL | |     X() {}\n-   | |____^ missing `fn`, `type`, or `const`\n+   | |____^ missing `fn`, `type`, `const`, or `static`\n \n error: expected `[`, found `#`\n   --> $DIR/issue-40006.rs:19:17\n    |\n LL |     fn xxx() { ### }\n    |                 ^ expected `[`\n \n-error: missing `fn`, `type`, or `const` for associated-item declaration\n+error: missing `fn`, `type`, `const`, or `static` for item declaration\n   --> $DIR/issue-40006.rs:21:10\n    |\n LL |   trait C {\n    |  __________^\n LL | |     L = M;\n-   | |____^ missing `fn`, `type`, or `const`\n+   | |____^ missing `fn`, `type`, `const`, or `static`\n \n-error: missing `fn`, `type`, or `const` for associated-item declaration\n+error: missing `fn`, `type`, `const`, or `static` for item declaration\n   --> $DIR/issue-40006.rs:24:10\n    |\n LL |   trait D {\n    |  __________^\n LL | |     Z = { 2 + 3 };\n-   | |____^ missing `fn`, `type`, or `const`\n+   | |____^ missing `fn`, `type`, `const`, or `static`\n \n error: expected one of `!` or `::`, found `(`\n   --> $DIR/issue-40006.rs:28:9\n    |\n LL |     ::Y ();\n    |         ^ expected one of `!` or `::`\n \n-error: missing `fn`, `type`, or `const` for associated-item declaration\n+error: missing `fn`, `type`, `const`, or `static` for item declaration\n   --> $DIR/issue-40006.rs:32:8\n    |\n LL |     pub hello_method(&self) {\n-   |        ^ missing `fn`, `type`, or `const`\n+   |        ^ missing `fn`, `type`, `const`, or `static`\n \n error[E0599]: no method named `hello_method` found for struct `S` in the current scope\n   --> $DIR/issue-40006.rs:38:7"}, {"sha": "fad8270fd5ad285f66b6449d236ce81ba52e7b95", "filename": "src/test/ui/error-codes/E0067.stderr", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Ferror-codes%2FE0067.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Ferror-codes%2FE0067.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0067.stderr?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -5,8 +5,6 @@ LL |     LinkedList::new() += 1;\n    |     -----------------^^^^^\n    |     |\n    |     cannot use `+=` on type `std::collections::LinkedList<_>`\n-   |\n-   = note: an implementation of `std::ops::AddAssign` might be missing for `std::collections::LinkedList<_>`\n \n error[E0067]: invalid left-hand side of assignment\n   --> $DIR/E0067.rs:4:23"}, {"sha": "fb5290bf64eb484a77812ca054579142dc1e1a97", "filename": "src/test/ui/error-festival.stderr", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Ferror-festival.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Ferror-festival.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-festival.stderr?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -23,8 +23,6 @@ LL |     x += 2;\n    |     -^^^^^\n    |     |\n    |     cannot use `+=` on type `&str`\n-   |\n-   = note: an implementation of `std::ops::AddAssign` might be missing for `&str`\n \n error[E0599]: no method named `z` found for reference `&str` in the current scope\n   --> $DIR/error-festival.rs:16:7"}, {"sha": "7f67adbdb19c718061798bd3d9010dd4b0cea5a1", "filename": "src/test/ui/extern/extern-const.stderr", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fextern%2Fextern-const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fextern%2Fextern-const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fextern%2Fextern-const.stderr?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -1,8 +1,12 @@\n error: extern items cannot be `const`\n-  --> $DIR/extern-const.rs:16:5\n+  --> $DIR/extern-const.rs:16:11\n    |\n LL |     const rust_dbg_static_mut: libc::c_int;\n-   |     ^^^^^ help: try using a static value: `static`\n+   |     ------^^^^^^^^^^^^^^^^^^^\n+   |     |\n+   |     help: try using a static value: `static`\n+   |\n+   = note: for more information, visit https://doc.rust-lang.org/std/keyword.extern.html\n \n error: aborting due to previous error\n "}, {"sha": "c93a3b9b25c15ba56aa23cf7798ab8f50ccde8a6", "filename": "src/test/ui/for/for-loop-type-error.stderr", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Ffor%2Ffor-loop-type-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Ffor%2Ffor-loop-type-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffor%2Ffor-loop-type-error.stderr?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -5,8 +5,6 @@ LL |     let x = () + ();\n    |             -- ^ -- ()\n    |             |\n    |             ()\n-   |\n-   = note: an implementation of `std::ops::Add` might be missing for `()`\n \n error: aborting due to previous error\n "}, {"sha": "3c34a8a34673e04b318346b7c7187a06f00ef5a2", "filename": "src/test/ui/issues/issue-14915.stderr", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fissues%2Fissue-14915.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fissues%2Fissue-14915.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-14915.stderr?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -5,8 +5,6 @@ LL |     println!(\"{}\", x + 1);\n    |                    - ^ - {integer}\n    |                    |\n    |                    std::boxed::Box<isize>\n-   |\n-   = note: an implementation of `std::ops::Add` might be missing for `std::boxed::Box<isize>`\n \n error: aborting due to previous error\n "}, {"sha": "16537e21ae08c7cb1cc52a007c0d72dcb6c1bc48", "filename": "src/test/ui/issues/issue-24363.stderr", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fissues%2Fissue-24363.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fissues%2Fissue-24363.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-24363.stderr?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -11,8 +11,6 @@ LL |         ()+()\n    |         --^-- ()\n    |         |\n    |         ()\n-   |\n-   = note: an implementation of `std::ops::Add` might be missing for `()`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "4c0e1cf7ebb0bfd873f1d50dddcb72e1b4b29518", "filename": "src/test/ui/issues/issue-31076.stderr", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fissues%2Fissue-31076.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fissues%2Fissue-31076.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-31076.stderr?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -5,8 +5,6 @@ LL |     let x = 5 + 6;\n    |             - ^ - {integer}\n    |             |\n    |             {integer}\n-   |\n-   = note: an implementation of `std::ops::Add` might be missing for `{integer}`\n \n error[E0369]: cannot add `i32` to `i32`\n   --> $DIR/issue-31076.rs:15:18\n@@ -15,8 +13,6 @@ LL |     let y = 5i32 + 6i32;\n    |             ---- ^ ---- i32\n    |             |\n    |             i32\n-   |\n-   = note: an implementation of `std::ops::Add` might be missing for `i32`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "98e8e6366b99b0e00d553a758fc09a50ddd747dd", "filename": "src/test/ui/issues/issue-35668.stderr", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fissues%2Fissue-35668.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fissues%2Fissue-35668.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-35668.stderr?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -5,8 +5,6 @@ LL |     a.iter().map(|a| a*a)\n    |                      -^- &T\n    |                      |\n    |                      &T\n-   |\n-   = note: an implementation of `std::ops::Mul` might be missing for `&T`\n \n error: aborting due to previous error\n "}, {"sha": "b4e302dfffc7a7b257d46ceb706368d2688f1115", "filename": "src/test/ui/issues/issue-40610.stderr", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fissues%2Fissue-40610.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fissues%2Fissue-40610.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-40610.stderr?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -5,8 +5,6 @@ LL |     () + f(&[1.0]);\n    |     -- ^ --------- ()\n    |     |\n    |     ()\n-   |\n-   = note: an implementation of `std::ops::Add` might be missing for `()`\n \n error: aborting due to previous error\n "}, {"sha": "47a24547d4533dcf333588d10315f2c42f942f7c", "filename": "src/test/ui/issues/issue-41394.stderr", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fissues%2Fissue-41394.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fissues%2Fissue-41394.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-41394.stderr?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -5,8 +5,6 @@ LL |     A = \"\" + 1\n    |         -- ^ - {integer}\n    |         |\n    |         &str\n-   |\n-   = note: an implementation of `std::ops::Add` might be missing for `&str`\n \n error[E0080]: evaluation of constant value failed\n   --> $DIR/issue-41394.rs:7:9"}, {"sha": "f4ca3c46ea28ab0fabdae71e2d083210583c710c", "filename": "src/test/ui/issues/issue-58856-2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fissues%2Fissue-58856-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fissues%2Fissue-58856-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-58856-2.stderr?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -7,11 +7,11 @@ LL |     fn how_are_you(&self -> Empty {\n    |                   |     help: `)` may belong here\n    |                   unclosed delimiter\n \n-error: expected one of `async`, `const`, `crate`, `default`, `extern`, `fn`, `pub`, `type`, `unsafe`, `}`, or identifier, found `)`\n+error: expected one of `async`, `const`, `crate`, `default`, `extern`, `fn`, `pub`, `static`, `type`, `unsafe`, `}`, or identifier, found `)`\n   --> $DIR/issue-58856-2.rs:11:1\n    |\n LL |     }\n-   |      - expected one of 11 possible tokens\n+   |      - expected one of 12 possible tokens\n LL | }\n    | ^ unexpected token\n "}, {"sha": "58f1376b19ddf4419777715095b56ec142783aab", "filename": "src/test/ui/issues/issue-59488.stderr", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fissues%2Fissue-59488.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fissues%2Fissue-59488.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-59488.stderr?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -58,8 +58,6 @@ LL |     foo > bar;\n    |     --- ^ --- fn(i64) -> i64 {bar}\n    |     |\n    |     fn() -> i32 {foo}\n-   |\n-   = note: an implementation of `std::cmp::PartialOrd` might be missing for `fn() -> i32 {foo}`\n \n error[E0308]: mismatched types\n   --> $DIR/issue-59488.rs:25:11\n@@ -79,7 +77,6 @@ LL |     assert_eq!(Foo::Bar, i);\n    |     fn(usize) -> Foo {Foo::Bar}\n    |     fn(usize) -> Foo {Foo::Bar}\n    |\n-   = note: an implementation of `std::cmp::PartialEq` might be missing for `fn(usize) -> Foo {Foo::Bar}`\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0277]: `fn(usize) -> Foo {Foo::Bar}` doesn't implement `std::fmt::Debug`"}, {"sha": "bab50a53b1ae486e0d9e879d7d6336ff477a78d7", "filename": "src/test/ui/issues/issue-60075.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fissues%2Fissue-60075.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fissues%2Fissue-60075.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-60075.stderr?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -4,7 +4,7 @@ error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n LL |         });\n    |          ^ expected one of `.`, `;`, `?`, `else`, or an operator\n \n-error: expected one of `async`, `const`, `crate`, `default`, `extern`, `fn`, `pub`, `type`, `unsafe`, `}`, or identifier, found `;`\n+error: expected one of `async`, `const`, `crate`, `default`, `extern`, `fn`, `pub`, `static`, `type`, `unsafe`, `}`, or identifier, found `;`\n   --> $DIR/issue-60075.rs:6:11\n    |\n LL |     fn qux() -> Option<usize> {"}, {"sha": "25f1d6500726ee7b962d1312f2e575061b180eb6", "filename": "src/test/ui/issues/issue-6596-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fissues%2Fissue-6596-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fissues%2Fissue-6596-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-6596-1.rs?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -1,7 +1,7 @@\n macro_rules! e {\n     ($inp:ident) => (\n         $nonexistent\n-        //~^ ERROR unknown macro variable `nonexistent`\n+        //~^ ERROR expected expression, found `$`\n     );\n }\n "}, {"sha": "216fe6472a5033187e793bb4f92067544ed6475c", "filename": "src/test/ui/issues/issue-6596-1.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fissues%2Fissue-6596-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fissues%2Fissue-6596-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-6596-1.stderr?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -1,8 +1,8 @@\n-error: unknown macro variable `nonexistent`\n+error: expected expression, found `$`\n   --> $DIR/issue-6596-1.rs:3:9\n    |\n LL |         $nonexistent\n-   |         ^^^^^^^^^^^^ unknown macro variable\n+   |         ^^^^^^^^^^^^ expected expression\n ...\n LL |     e!(foo);\n    |     -------- in this macro invocation"}, {"sha": "8f7c98d9a67a77baaee8f3f6332d56869631439c", "filename": "src/test/ui/issues/issue-6596-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fissues%2Fissue-6596-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fissues%2Fissue-6596-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-6596-2.rs?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -3,7 +3,7 @@\n macro_rules! g {\n     ($inp:ident) => (\n         { $inp $nonexistent }\n-        //~^ ERROR unknown macro variable `nonexistent`\n+        //~^ ERROR expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator, found `$`\n     );\n }\n "}, {"sha": "3d13c64f762ea5e6885fd16ffb52d0a2d08d8e27", "filename": "src/test/ui/issues/issue-6596-2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fissues%2Fissue-6596-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fissues%2Fissue-6596-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-6596-2.stderr?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -1,8 +1,8 @@\n-error: unknown macro variable `nonexistent`\n+error: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator, found `$`\n   --> $DIR/issue-6596-2.rs:5:16\n    |\n LL |         { $inp $nonexistent }\n-   |                ^^^^^^^^^^^^ unknown macro variable\n+   |                ^^^^^^^^^^^^ expected one of 8 possible tokens\n ...\n LL |     g!(foo);\n    |     -------- in this macro invocation"}, {"sha": "5570f081b157dd58867f0426781809e177b1a455", "filename": "src/test/ui/macros/issue-54441.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fmacros%2Fissue-54441.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fmacros%2Fissue-54441.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fissue-54441.rs?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -1,5 +1,5 @@\n macro_rules! m {\n-    //~^ ERROR missing `fn`, `type`, or `static` for extern-item declaration\n+    //~^ ERROR missing `fn`, `type`, `const`, or `static` for item declaration\n     () => {\n         let\n     };"}, {"sha": "5857aacb431769af35ad7aa7c6716b407d45ea56", "filename": "src/test/ui/macros/issue-54441.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fmacros%2Fissue-54441.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fmacros%2Fissue-54441.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fissue-54441.stderr?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -1,11 +1,11 @@\n-error: missing `fn`, `type`, or `static` for extern-item declaration\n+error: missing `fn`, `type`, `const`, or `static` for item declaration\n   --> $DIR/issue-54441.rs:1:1\n    |\n LL | / macro_rules! m {\n LL | |\n LL | |     () => {\n LL | |         let\n-   | |________^ missing `fn`, `type`, or `static`\n+   | |________^ missing `fn`, `type`, `const`, or `static`\n \n error: aborting due to previous error\n "}, {"sha": "3fbec7c89c9a2a96a78d9c2331feac6fe1cf5437", "filename": "src/test/ui/minus-string.stderr", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fminus-string.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fminus-string.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fminus-string.stderr?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -3,8 +3,6 @@ error[E0600]: cannot apply unary operator `-` to type `std::string::String`\n    |\n LL | fn main() { -\"foo\".to_string(); }\n    |             ^^^^^^^^^^^^^^^^^^ cannot apply unary operator `-`\n-   |\n-   = note: an implementation of `std::ops::Neg` might be missing for `std::string::String`\n \n error: aborting due to previous error\n "}, {"sha": "d37ce06c555bf6defa8e2667295c9277696d9bc9", "filename": "src/test/ui/parser/assoc-const-underscore-semantic-fail.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fparser%2Fassoc-const-underscore-semantic-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fparser%2Fassoc-const-underscore-semantic-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fassoc-const-underscore-semantic-fail.rs?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -0,0 +1,17 @@\n+// Semantically, an associated constant cannot use `_` as a name.\n+\n+fn main() {}\n+\n+const _: () = {\n+    pub trait A {\n+        const _: () = (); //~ ERROR `const` items in this context need a name\n+    }\n+    impl A for () {\n+        const _: () = (); //~ ERROR `const` items in this context need a name\n+        //~^ ERROR const `_` is not a member of trait `A`\n+    }\n+    struct B;\n+    impl B {\n+        const _: () = (); //~ ERROR `const` items in this context need a name\n+    }\n+};"}, {"sha": "538bf0ec100dc6ad26e4b5fbfc7a12eb221e9f40", "filename": "src/test/ui/parser/assoc-const-underscore-semantic-fail.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fparser%2Fassoc-const-underscore-semantic-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fparser%2Fassoc-const-underscore-semantic-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fassoc-const-underscore-semantic-fail.stderr?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -0,0 +1,27 @@\n+error: `const` items in this context need a name\n+  --> $DIR/assoc-const-underscore-semantic-fail.rs:7:15\n+   |\n+LL |         const _: () = ();\n+   |               ^ `_` is not a valid name for this `const` item\n+\n+error: `const` items in this context need a name\n+  --> $DIR/assoc-const-underscore-semantic-fail.rs:10:15\n+   |\n+LL |         const _: () = ();\n+   |               ^ `_` is not a valid name for this `const` item\n+\n+error: `const` items in this context need a name\n+  --> $DIR/assoc-const-underscore-semantic-fail.rs:15:15\n+   |\n+LL |         const _: () = ();\n+   |               ^ `_` is not a valid name for this `const` item\n+\n+error[E0438]: const `_` is not a member of trait `A`\n+  --> $DIR/assoc-const-underscore-semantic-fail.rs:10:9\n+   |\n+LL |         const _: () = ();\n+   |         ^^^^^^^^^^^^^^^^^ not a member of trait `A`\n+\n+error: aborting due to 4 previous errors\n+\n+For more information about this error, try `rustc --explain E0438`."}, {"sha": "60da408c8115351859b9bf2bcd113882a0927a93", "filename": "src/test/ui/parser/assoc-const-underscore-syntactic-pass.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fparser%2Fassoc-const-underscore-syntactic-pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fparser%2Fassoc-const-underscore-syntactic-pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fassoc-const-underscore-syntactic-pass.rs?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -0,0 +1,18 @@\n+// All constant items (associated or otherwise) may syntactically use `_` as a name.\n+\n+// check-pass\n+\n+fn main() {}\n+\n+#[cfg(FALSE)]\n+const _: () = {\n+    pub trait A {\n+        const _: () = ();\n+    }\n+    impl A for () {\n+        const _: () = ();\n+    }\n+    impl dyn A {\n+        const _: () = ();\n+    }\n+};"}, {"sha": "cf3debd77cbfdc631a36b2c598886cb129f60cf0", "filename": "src/test/ui/parser/assoc-static-semantic-fail.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fparser%2Fassoc-static-semantic-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fparser%2Fassoc-static-semantic-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fassoc-static-semantic-fail.rs?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -0,0 +1,43 @@\n+// Semantically, we do not allow e.g., `static X: u8 = 0;` as an associated item.\n+\n+#![feature(specialization)]\n+\n+fn main() {}\n+\n+struct S;\n+impl S {\n+    static IA: u8 = 0;\n+    //~^ ERROR associated `static` items are not allowed\n+    static IB: u8;\n+    //~^ ERROR associated `static` items are not allowed\n+    default static IC: u8 = 0;\n+    //~^ ERROR associated `static` items are not allowed\n+    pub(crate) default static ID: u8;\n+    //~^ ERROR associated `static` items are not allowed\n+}\n+\n+trait T {\n+    static TA: u8 = 0;\n+    //~^ ERROR associated `static` items are not allowed\n+    static TB: u8;\n+    //~^ ERROR associated `static` items are not allowed\n+    default static TC: u8 = 0;\n+    //~^ ERROR associated `static` items are not allowed\n+    //~| ERROR `default` is only allowed on items in\n+    pub(crate) default static TD: u8;\n+    //~^ ERROR associated `static` items are not allowed\n+    //~| ERROR `default` is only allowed on items in\n+    //~| ERROR unnecessary visibility qualifier\n+}\n+\n+impl T for S {\n+    static TA: u8 = 0;\n+    //~^ ERROR associated `static` items are not allowed\n+    static TB: u8;\n+    //~^ ERROR associated `static` items are not allowed\n+    default static TC: u8 = 0;\n+    //~^ ERROR associated `static` items are not allowed\n+    pub default static TD: u8;\n+    //~^ ERROR associated `static` items are not allowed\n+    //~| ERROR unnecessary visibility qualifier\n+}"}, {"sha": "d02e2855c7e62f1cf4e560231ad816c203628f00", "filename": "src/test/ui/parser/assoc-static-semantic-fail.stderr", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fparser%2Fassoc-static-semantic-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fparser%2Fassoc-static-semantic-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fassoc-static-semantic-fail.stderr?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -0,0 +1,99 @@\n+error: associated `static` items are not allowed\n+  --> $DIR/assoc-static-semantic-fail.rs:9:5\n+   |\n+LL |     static IA: u8 = 0;\n+   |     ^^^^^^^^^^^^^^^^^^\n+\n+error: associated `static` items are not allowed\n+  --> $DIR/assoc-static-semantic-fail.rs:11:5\n+   |\n+LL |     static IB: u8;\n+   |     ^^^^^^^^^^^^^^\n+\n+error: associated `static` items are not allowed\n+  --> $DIR/assoc-static-semantic-fail.rs:13:5\n+   |\n+LL |     default static IC: u8 = 0;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: associated `static` items are not allowed\n+  --> $DIR/assoc-static-semantic-fail.rs:15:5\n+   |\n+LL |     pub(crate) default static ID: u8;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: associated `static` items are not allowed\n+  --> $DIR/assoc-static-semantic-fail.rs:20:5\n+   |\n+LL |     static TA: u8 = 0;\n+   |     ^^^^^^^^^^^^^^^^^^\n+\n+error: associated `static` items are not allowed\n+  --> $DIR/assoc-static-semantic-fail.rs:22:5\n+   |\n+LL |     static TB: u8;\n+   |     ^^^^^^^^^^^^^^\n+\n+error: associated `static` items are not allowed\n+  --> $DIR/assoc-static-semantic-fail.rs:24:5\n+   |\n+LL |     default static TC: u8 = 0;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: associated `static` items are not allowed\n+  --> $DIR/assoc-static-semantic-fail.rs:27:5\n+   |\n+LL |     pub(crate) default static TD: u8;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: associated `static` items are not allowed\n+  --> $DIR/assoc-static-semantic-fail.rs:34:5\n+   |\n+LL |     static TA: u8 = 0;\n+   |     ^^^^^^^^^^^^^^^^^^\n+\n+error: associated `static` items are not allowed\n+  --> $DIR/assoc-static-semantic-fail.rs:36:5\n+   |\n+LL |     static TB: u8;\n+   |     ^^^^^^^^^^^^^^\n+\n+error: associated `static` items are not allowed\n+  --> $DIR/assoc-static-semantic-fail.rs:38:5\n+   |\n+LL |     default static TC: u8 = 0;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: associated `static` items are not allowed\n+  --> $DIR/assoc-static-semantic-fail.rs:40:5\n+   |\n+LL |     pub default static TD: u8;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: `default` is only allowed on items in `impl` definitions\n+  --> $DIR/assoc-static-semantic-fail.rs:24:5\n+   |\n+LL |     default static TC: u8 = 0;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: `default` is only allowed on items in `impl` definitions\n+  --> $DIR/assoc-static-semantic-fail.rs:27:5\n+   |\n+LL |     pub(crate) default static TD: u8;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0449]: unnecessary visibility qualifier\n+  --> $DIR/assoc-static-semantic-fail.rs:27:5\n+   |\n+LL |     pub(crate) default static TD: u8;\n+   |     ^^^^^^^^^^\n+\n+error[E0449]: unnecessary visibility qualifier\n+  --> $DIR/assoc-static-semantic-fail.rs:40:5\n+   |\n+LL |     pub default static TD: u8;\n+   |     ^^^ `pub` not permitted here because it's implied\n+\n+error: aborting due to 16 previous errors\n+\n+For more information about this error, try `rustc --explain E0449`."}, {"sha": "8f042767e5503101352c43ff9b05c7a2679da877", "filename": "src/test/ui/parser/assoc-static-syntactic-fail.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fparser%2Fassoc-static-syntactic-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fparser%2Fassoc-static-syntactic-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fassoc-static-syntactic-fail.rs?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -0,0 +1,27 @@\n+// Syntactically, we do allow e.g., `static X: u8 = 0;` as an associated item.\n+\n+fn main() {}\n+\n+#[cfg(FALSE)]\n+impl S {\n+    static IA: u8 = 0; //~ ERROR associated `static` items are not allowed\n+    static IB: u8; //~ ERROR associated `static` items are not allowed\n+    default static IC: u8 = 0; //~ ERROR associated `static` items are not allowed\n+    pub(crate) default static ID: u8; //~ ERROR associated `static` items are not allowed\n+}\n+\n+#[cfg(FALSE)]\n+trait T {\n+    static TA: u8 = 0; //~ ERROR associated `static` items are not allowed\n+    static TB: u8; //~ ERROR associated `static` items are not allowed\n+    default static TC: u8 = 0; //~ ERROR associated `static` items are not allowed\n+    pub(crate) default static TD: u8; //~ ERROR associated `static` items are not allowed\n+}\n+\n+#[cfg(FALSE)]\n+impl T for S {\n+    static TA: u8 = 0; //~ ERROR associated `static` items are not allowed\n+    static TB: u8; //~ ERROR associated `static` items are not allowed\n+    default static TC: u8 = 0; //~ ERROR associated `static` items are not allowed\n+    pub default static TD: u8; //~ ERROR associated `static` items are not allowed\n+}"}, {"sha": "bb1e5c4be2e9c5f20bcee3e02fcd0a4f4a9f2577", "filename": "src/test/ui/parser/assoc-static-syntactic-fail.stderr", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fparser%2Fassoc-static-syntactic-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fparser%2Fassoc-static-syntactic-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fassoc-static-syntactic-fail.stderr?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -0,0 +1,74 @@\n+error: associated `static` items are not allowed\n+  --> $DIR/assoc-static-syntactic-fail.rs:7:5\n+   |\n+LL |     static IA: u8 = 0;\n+   |     ^^^^^^^^^^^^^^^^^^\n+\n+error: associated `static` items are not allowed\n+  --> $DIR/assoc-static-syntactic-fail.rs:8:5\n+   |\n+LL |     static IB: u8;\n+   |     ^^^^^^^^^^^^^^\n+\n+error: associated `static` items are not allowed\n+  --> $DIR/assoc-static-syntactic-fail.rs:9:5\n+   |\n+LL |     default static IC: u8 = 0;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: associated `static` items are not allowed\n+  --> $DIR/assoc-static-syntactic-fail.rs:10:5\n+   |\n+LL |     pub(crate) default static ID: u8;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: associated `static` items are not allowed\n+  --> $DIR/assoc-static-syntactic-fail.rs:15:5\n+   |\n+LL |     static TA: u8 = 0;\n+   |     ^^^^^^^^^^^^^^^^^^\n+\n+error: associated `static` items are not allowed\n+  --> $DIR/assoc-static-syntactic-fail.rs:16:5\n+   |\n+LL |     static TB: u8;\n+   |     ^^^^^^^^^^^^^^\n+\n+error: associated `static` items are not allowed\n+  --> $DIR/assoc-static-syntactic-fail.rs:17:5\n+   |\n+LL |     default static TC: u8 = 0;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: associated `static` items are not allowed\n+  --> $DIR/assoc-static-syntactic-fail.rs:18:5\n+   |\n+LL |     pub(crate) default static TD: u8;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: associated `static` items are not allowed\n+  --> $DIR/assoc-static-syntactic-fail.rs:23:5\n+   |\n+LL |     static TA: u8 = 0;\n+   |     ^^^^^^^^^^^^^^^^^^\n+\n+error: associated `static` items are not allowed\n+  --> $DIR/assoc-static-syntactic-fail.rs:24:5\n+   |\n+LL |     static TB: u8;\n+   |     ^^^^^^^^^^^^^^\n+\n+error: associated `static` items are not allowed\n+  --> $DIR/assoc-static-syntactic-fail.rs:25:5\n+   |\n+LL |     default static TC: u8 = 0;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: associated `static` items are not allowed\n+  --> $DIR/assoc-static-syntactic-fail.rs:26:5\n+   |\n+LL |     pub default static TD: u8;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 12 previous errors\n+"}, {"sha": "50952eef22f5c0df259a6393792b41a6c4877949", "filename": "src/test/ui/parser/default.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fparser%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fparser%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fdefault.rs?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -20,7 +20,7 @@ impl Foo for u16 {\n \n impl Foo for u32 { //~ ERROR not all trait items implemented, missing: `foo`\n     default pub fn foo<T: Default>() -> T { T::default() }\n-    //~^ ERROR missing `fn`, `type`, or `const` for associated-item declaration\n+    //~^ ERROR missing `fn`, `type`, `const`, or `static` for item declaration\n }\n \n fn main() {}"}, {"sha": "07b051ece2b5de8d87e34c784b0499195ef8c880", "filename": "src/test/ui/parser/default.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fparser%2Fdefault.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fparser%2Fdefault.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fdefault.stderr?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -1,8 +1,8 @@\n-error: missing `fn`, `type`, or `const` for associated-item declaration\n+error: missing `fn`, `type`, `const`, or `static` for item declaration\n   --> $DIR/default.rs:22:12\n    |\n LL |     default pub fn foo<T: Default>() -> T { T::default() }\n-   |            ^ missing `fn`, `type`, or `const`\n+   |            ^ missing `fn`, `type`, `const`, or `static`\n \n error[E0449]: unnecessary visibility qualifier\n   --> $DIR/default.rs:16:5"}, {"sha": "f6e7f7e6abe8f98c3d71ad3cdf467583db98684e", "filename": "src/test/ui/parser/duplicate-visibility.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fparser%2Fduplicate-visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fparser%2Fduplicate-visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fduplicate-visibility.rs?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -2,5 +2,5 @@ fn main() {}\n \n extern {\n     pub pub fn foo();\n-    //~^ ERROR missing `fn`, `type`, or `static` for extern-item declaration\n+    //~^ ERROR missing `fn`, `type`, `const`, or `static` for item declaration\n }"}, {"sha": "398ba65c9e1d89de4ca22ae073fab751b2059040", "filename": "src/test/ui/parser/duplicate-visibility.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fparser%2Fduplicate-visibility.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fparser%2Fduplicate-visibility.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fduplicate-visibility.stderr?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -1,8 +1,8 @@\n-error: missing `fn`, `type`, or `static` for extern-item declaration\n+error: missing `fn`, `type`, `const`, or `static` for item declaration\n   --> $DIR/duplicate-visibility.rs:4:8\n    |\n LL |     pub pub fn foo();\n-   |        ^ missing `fn`, `type`, or `static`\n+   |        ^ missing `fn`, `type`, `const`, or `static`\n \n error: aborting due to previous error\n "}, {"sha": "dc47f7410730c5c61c85c6f9d1534fee3733f7bb", "filename": "src/test/ui/parser/extern-no-fn.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fparser%2Fextern-no-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fparser%2Fextern-no-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fextern-no-fn.rs?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -1,4 +1,5 @@\n-extern { //~ ERROR missing `fn`, `type`, or `static` for extern-item declaration\n+extern {\n+//~^ ERROR missing `fn`, `type`, `const`, or `static` for item declaration\n     f();\n }\n "}, {"sha": "8d55eefc8d0ecab06db34026229a733a6d86692a", "filename": "src/test/ui/parser/extern-no-fn.stderr", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fparser%2Fextern-no-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fparser%2Fextern-no-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fextern-no-fn.stderr?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -1,10 +1,11 @@\n-error: missing `fn`, `type`, or `static` for extern-item declaration\n+error: missing `fn`, `type`, `const`, or `static` for item declaration\n   --> $DIR/extern-no-fn.rs:1:9\n    |\n LL |   extern {\n    |  _________^\n+LL | |\n LL | |     f();\n-   | |____^ missing `fn`, `type`, or `static`\n+   | |____^ missing `fn`, `type`, `const`, or `static`\n \n error: aborting due to previous error\n "}, {"sha": "d28b64142826cfffe6fea6f3481f6e3d98cef384", "filename": "src/test/ui/parser/foreign-const-semantic-fail.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fparser%2Fforeign-const-semantic-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fparser%2Fforeign-const-semantic-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fforeign-const-semantic-fail.rs?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -0,0 +1,8 @@\n+fn main() {}\n+\n+extern {\n+    const A: isize;\n+    //~^ ERROR extern items cannot be `const`\n+    const B: isize = 42;\n+    //~^ ERROR extern items cannot be `const`\n+}"}, {"sha": "f364f11bb038db393239b9773eddf9fbd17131d9", "filename": "src/test/ui/parser/foreign-const-semantic-fail.stderr", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fparser%2Fforeign-const-semantic-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fparser%2Fforeign-const-semantic-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fforeign-const-semantic-fail.stderr?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -0,0 +1,22 @@\n+error: extern items cannot be `const`\n+  --> $DIR/foreign-const-semantic-fail.rs:4:11\n+   |\n+LL |     const A: isize;\n+   |     ------^\n+   |     |\n+   |     help: try using a static value: `static`\n+   |\n+   = note: for more information, visit https://doc.rust-lang.org/std/keyword.extern.html\n+\n+error: extern items cannot be `const`\n+  --> $DIR/foreign-const-semantic-fail.rs:6:11\n+   |\n+LL |     const B: isize = 42;\n+   |     ------^\n+   |     |\n+   |     help: try using a static value: `static`\n+   |\n+   = note: for more information, visit https://doc.rust-lang.org/std/keyword.extern.html\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "a78f8b1623a80120a2a0eb98b17d4c7d7f7fe56d", "filename": "src/test/ui/parser/foreign-const-syntactic-fail.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fparser%2Fforeign-const-syntactic-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fparser%2Fforeign-const-syntactic-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fforeign-const-syntactic-fail.rs?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -0,0 +1,9 @@\n+// Syntactically, a `const` item inside an `extern { ... }` block is not allowed.\n+\n+fn main() {}\n+\n+#[cfg(FALSE)]\n+extern {\n+    const A: isize; //~ ERROR extern items cannot be `const`\n+    const B: isize = 42; //~ ERROR extern items cannot be `const`\n+}"}, {"sha": "9cf58fa95fb2dc1af38ea57019135e01dc251ac8", "filename": "src/test/ui/parser/foreign-const-syntactic-fail.stderr", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fparser%2Fforeign-const-syntactic-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fparser%2Fforeign-const-syntactic-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fforeign-const-syntactic-fail.stderr?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -0,0 +1,22 @@\n+error: extern items cannot be `const`\n+  --> $DIR/foreign-const-syntactic-fail.rs:7:11\n+   |\n+LL |     const A: isize;\n+   |     ------^\n+   |     |\n+   |     help: try using a static value: `static`\n+   |\n+   = note: for more information, visit https://doc.rust-lang.org/std/keyword.extern.html\n+\n+error: extern items cannot be `const`\n+  --> $DIR/foreign-const-syntactic-fail.rs:8:11\n+   |\n+LL |     const B: isize = 42;\n+   |     ------^\n+   |     |\n+   |     help: try using a static value: `static`\n+   |\n+   = note: for more information, visit https://doc.rust-lang.org/std/keyword.extern.html\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "9abdf33df9c46a468673061f11b0bfdaabb95198", "filename": "src/test/ui/parser/foreign-static-semantic-fail.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fparser%2Fforeign-static-semantic-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fparser%2Fforeign-static-semantic-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fforeign-static-semantic-fail.rs?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -0,0 +1,8 @@\n+// Syntactically, a foreign static may not have a body.\n+\n+fn main() {}\n+\n+extern {\n+    static X: u8 = 0; //~ ERROR incorrect `static` inside `extern` block\n+    static mut Y: u8 = 0; //~ ERROR incorrect `static` inside `extern` block\n+}"}, {"sha": "5942e3a94497b21e4394e1ac1fb3d16b89e6732b", "filename": "src/test/ui/parser/foreign-static-semantic-fail.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fparser%2Fforeign-static-semantic-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fparser%2Fforeign-static-semantic-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fforeign-static-semantic-fail.stderr?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -0,0 +1,27 @@\n+error: incorrect `static` inside `extern` block\n+  --> $DIR/foreign-static-semantic-fail.rs:6:12\n+   |\n+LL | extern {\n+   | ------ `extern` blocks define existing foreign statics and statics inside of them cannot have a body\n+LL |     static X: u8 = 0;\n+   |            ^       - the invalid body\n+   |            |\n+   |            cannot have a body\n+   |\n+   = note: for more information, visit https://doc.rust-lang.org/std/keyword.extern.html\n+\n+error: incorrect `static` inside `extern` block\n+  --> $DIR/foreign-static-semantic-fail.rs:7:16\n+   |\n+LL | extern {\n+   | ------ `extern` blocks define existing foreign statics and statics inside of them cannot have a body\n+LL |     static X: u8 = 0;\n+LL |     static mut Y: u8 = 0;\n+   |                ^       - the invalid body\n+   |                |\n+   |                cannot have a body\n+   |\n+   = note: for more information, visit https://doc.rust-lang.org/std/keyword.extern.html\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "2c805e8a0b700b189063ca899900354ead93d346", "filename": "src/test/ui/parser/foreign-static-syntactic-pass.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fparser%2Fforeign-static-syntactic-pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fparser%2Fforeign-static-syntactic-pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fforeign-static-syntactic-pass.rs?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -0,0 +1,11 @@\n+// Syntactically, a foreign static may have a body.\n+\n+// check-pass\n+\n+fn main() {}\n+\n+#[cfg(FALSE)]\n+extern {\n+    static X: u8 = 0;\n+    static mut Y: u8 = 0;\n+}"}, {"sha": "96b15232b10d0e7b601baed9a36043c99cd253e5", "filename": "src/test/ui/parser/foreign-ty-semantic-fail.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fparser%2Fforeign-ty-semantic-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fparser%2Fforeign-ty-semantic-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fforeign-ty-semantic-fail.rs?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -0,0 +1,18 @@\n+#![feature(extern_types)]\n+\n+fn main() {}\n+\n+extern \"C\" {\n+    type A: Ord;\n+    //~^ ERROR bounds on `type`s in `extern` blocks have no effect\n+    type B<'a> where 'a: 'static;\n+    //~^ ERROR `type`s inside `extern` blocks cannot have generic parameters\n+    //~| ERROR `type`s inside `extern` blocks cannot have `where` clauses\n+    type C<T: Ord> where T: 'static;\n+    //~^ ERROR `type`s inside `extern` blocks cannot have generic parameters\n+    //~| ERROR `type`s inside `extern` blocks cannot have `where` clauses\n+    type D = u8;\n+    //~^ ERROR incorrect `type` inside `extern` block\n+\n+    type E: where;\n+}"}, {"sha": "588e4966aaeb567d824873131bbefda212a89088", "filename": "src/test/ui/parser/foreign-ty-semantic-fail.stderr", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fparser%2Fforeign-ty-semantic-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fparser%2Fforeign-ty-semantic-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fforeign-ty-semantic-fail.stderr?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -0,0 +1,65 @@\n+error: bounds on `type`s in `extern` blocks have no effect\n+  --> $DIR/foreign-ty-semantic-fail.rs:6:13\n+   |\n+LL |     type A: Ord;\n+   |             ^^^\n+\n+error: `type`s inside `extern` blocks cannot have generic parameters\n+  --> $DIR/foreign-ty-semantic-fail.rs:8:11\n+   |\n+LL | extern \"C\" {\n+   | ---------- `extern` block begins here\n+...\n+LL |     type B<'a> where 'a: 'static;\n+   |           ^^^^ help: remove the generic parameters\n+   |\n+   = note: for more information, visit https://doc.rust-lang.org/std/keyword.extern.html\n+\n+error: `type`s inside `extern` blocks cannot have `where` clauses\n+  --> $DIR/foreign-ty-semantic-fail.rs:8:16\n+   |\n+LL | extern \"C\" {\n+   | ---------- `extern` block begins here\n+...\n+LL |     type B<'a> where 'a: 'static;\n+   |                ^^^^^^^^^^^^^^^^^ help: remove the `where` clause\n+   |\n+   = note: for more information, visit https://doc.rust-lang.org/std/keyword.extern.html\n+\n+error: `type`s inside `extern` blocks cannot have generic parameters\n+  --> $DIR/foreign-ty-semantic-fail.rs:11:11\n+   |\n+LL | extern \"C\" {\n+   | ---------- `extern` block begins here\n+...\n+LL |     type C<T: Ord> where T: 'static;\n+   |           ^^^^^^^^ help: remove the generic parameters\n+   |\n+   = note: for more information, visit https://doc.rust-lang.org/std/keyword.extern.html\n+\n+error: `type`s inside `extern` blocks cannot have `where` clauses\n+  --> $DIR/foreign-ty-semantic-fail.rs:11:20\n+   |\n+LL | extern \"C\" {\n+   | ---------- `extern` block begins here\n+...\n+LL |     type C<T: Ord> where T: 'static;\n+   |                    ^^^^^^^^^^^^^^^^ help: remove the `where` clause\n+   |\n+   = note: for more information, visit https://doc.rust-lang.org/std/keyword.extern.html\n+\n+error: incorrect `type` inside `extern` block\n+  --> $DIR/foreign-ty-semantic-fail.rs:14:10\n+   |\n+LL | extern \"C\" {\n+   | ---------- `extern` blocks define existing foreign types and types inside of them cannot have a body\n+...\n+LL |     type D = u8;\n+   |          ^   -- the invalid body\n+   |          |\n+   |          cannot have a body\n+   |\n+   = note: for more information, visit https://doc.rust-lang.org/std/keyword.extern.html\n+\n+error: aborting due to 6 previous errors\n+"}, {"sha": "a746de1f14f4da082df949c3c361cbb7fe6a9216", "filename": "src/test/ui/parser/foreign-ty-syntactic-pass.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fparser%2Fforeign-ty-syntactic-pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fparser%2Fforeign-ty-syntactic-pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fforeign-ty-syntactic-pass.rs?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -0,0 +1,12 @@\n+// check-pass\n+\n+fn main() {}\n+\n+#[cfg(FALSE)]\n+extern \"C\" {\n+    type A: Ord;\n+    type A<'a> where 'a: 'static;\n+    type A<T: Ord> where T: 'static;\n+    type A = u8;\n+    type A<'a: 'static, T: Ord + 'static>: Eq + PartialEq where T: 'static + Copy = Vec<u8>;\n+}"}, {"sha": "fa9c7ababcf9eb1a2d1fc3966a94e46364f31f1f", "filename": "src/test/ui/parser/impl-item-type-no-body-semantic-fail.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fparser%2Fimpl-item-type-no-body-semantic-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fparser%2Fimpl-item-type-no-body-semantic-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fimpl-item-type-no-body-semantic-fail.rs?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -11,11 +11,11 @@ impl X {\n     //~| ERROR associated types are not yet supported in inherent impls\n     type Z: Ord;\n     //~^ ERROR associated type in `impl` without body\n-    //~| ERROR bounds on associated `type`s in `impl`s have no effect\n+    //~| ERROR bounds on `type`s in `impl`s have no effect\n     //~| ERROR associated types are not yet supported in inherent impls\n     type W: Ord where Self: Eq;\n     //~^ ERROR associated type in `impl` without body\n-    //~| ERROR bounds on associated `type`s in `impl`s have no effect\n+    //~| ERROR bounds on `type`s in `impl`s have no effect\n     //~| ERROR associated types are not yet supported in inherent impls\n     type W where Self: Eq;\n     //~^ ERROR associated type in `impl` without body"}, {"sha": "541d9317c79d08eb3abbbbf0e15317a6554e9ed4", "filename": "src/test/ui/parser/impl-item-type-no-body-semantic-fail.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fparser%2Fimpl-item-type-no-body-semantic-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fparser%2Fimpl-item-type-no-body-semantic-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fimpl-item-type-no-body-semantic-fail.stderr?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -14,7 +14,7 @@ LL |     type Z: Ord;\n    |                |\n    |                help: provide a definition for the type: `= <type>;`\n \n-error: bounds on associated `type`s in `impl`s have no effect\n+error: bounds on `type`s in `impl`s have no effect\n   --> $DIR/impl-item-type-no-body-semantic-fail.rs:12:13\n    |\n LL |     type Z: Ord;\n@@ -28,7 +28,7 @@ LL |     type W: Ord where Self: Eq;\n    |                               |\n    |                               help: provide a definition for the type: `= <type>;`\n \n-error: bounds on associated `type`s in `impl`s have no effect\n+error: bounds on `type`s in `impl`s have no effect\n   --> $DIR/impl-item-type-no-body-semantic-fail.rs:16:13\n    |\n LL |     type W: Ord where Self: Eq;"}, {"sha": "014c930ef82053290f49ead17de30754cdf76c24", "filename": "src/test/ui/parser/issue-19398.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fparser%2Fissue-19398.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fparser%2Fissue-19398.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-19398.rs?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -1,5 +1,5 @@\n trait T {\n-    //~^ ERROR missing `fn`, `type`, or `const` for associated-item declaration\n+    //~^ ERROR missing `fn`, `type`, `const`, or `static` for item declaration\n     extern \"Rust\" unsafe fn foo();\n }\n "}, {"sha": "b38b39f9bd99f21a311d64b34df77d56a07699be", "filename": "src/test/ui/parser/issue-19398.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fparser%2Fissue-19398.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fparser%2Fissue-19398.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-19398.stderr?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -1,11 +1,11 @@\n-error: missing `fn`, `type`, or `const` for associated-item declaration\n+error: missing `fn`, `type`, `const`, or `static` for item declaration\n   --> $DIR/issue-19398.rs:1:10\n    |\n LL |   trait T {\n    |  __________^\n LL | |\n LL | |     extern \"Rust\" unsafe fn foo();\n-   | |____^ missing `fn`, `type`, or `const`\n+   | |____^ missing `fn`, `type`, `const`, or `static`\n \n error: aborting due to previous error\n "}, {"sha": "4fe05e6f041550d7d905f0516529f82610c1a80d", "filename": "src/test/ui/parser/issue-21153.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fparser%2Fissue-21153.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fparser%2Fissue-21153.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-21153.rs?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -1,4 +1,5 @@\n-trait MyTrait<T>: Iterator { //~ ERROR missing `fn`, `type`, or `const`\n+trait MyTrait<T>: Iterator {\n+    //~^ ERROR missing `fn`, `type`, `const`, or `static` for item declaration\n     Item = T;\n }\n "}, {"sha": "e9824bd72908189437e8114325e40597e5fcf3aa", "filename": "src/test/ui/parser/issue-21153.stderr", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fparser%2Fissue-21153.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fparser%2Fissue-21153.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-21153.stderr?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -1,10 +1,11 @@\n-error: missing `fn`, `type`, or `const` for associated-item declaration\n+error: missing `fn`, `type`, `const`, or `static` for item declaration\n   --> $DIR/issue-21153.rs:1:29\n    |\n LL |   trait MyTrait<T>: Iterator {\n    |  _____________________________^\n+LL | |\n LL | |     Item = T;\n-   | |____^ missing `fn`, `type`, or `const`\n+   | |____^ missing `fn`, `type`, `const`, or `static`\n \n error: aborting due to previous error\n "}, {"sha": "d25828da0b97986cea15eba61550428cad93cd29", "filename": "src/test/ui/parser/issue-32446.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fparser%2Fissue-32446.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fparser%2Fissue-32446.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-32446.stderr?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -1,8 +1,8 @@\n-error: expected one of `async`, `const`, `crate`, `default`, `extern`, `fn`, `pub`, `type`, `unsafe`, `}`, or identifier, found `...`\n+error: expected one of `async`, `const`, `crate`, `default`, `extern`, `fn`, `pub`, `static`, `type`, `unsafe`, `}`, or identifier, found `...`\n   --> $DIR/issue-32446.rs:4:11\n    |\n LL | trait T { ... }\n-   |           ^^^ expected one of 11 possible tokens\n+   |           ^^^ expected one of 12 possible tokens\n \n error: aborting due to previous error\n "}, {"sha": "a91ef6c67e89ee1b521eb86a5fb0caff0b2e2b03", "filename": "src/test/ui/parser/issue-41155.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fparser%2Fissue-41155.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fparser%2Fissue-41155.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-41155.stderr?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -1,8 +1,8 @@\n-error: expected one of `(`, `async`, `const`, `default`, `extern`, `fn`, `type`, `unsafe`, or identifier, found `}`\n+error: expected one of `(`, `async`, `const`, `default`, `extern`, `fn`, `static`, `type`, `unsafe`, or identifier, found `}`\n   --> $DIR/issue-41155.rs:5:1\n    |\n LL |     pub\n-   |        - expected one of 9 possible tokens\n+   |        - expected one of 10 possible tokens\n LL | }\n    | ^ unexpected token\n "}, {"sha": "613b3c9856171a28f10cfdd856d7aaf8f15ba693", "filename": "src/test/ui/parser/item-free-const-no-body-semantic-fail.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fparser%2Fitem-free-const-no-body-semantic-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fparser%2Fitem-free-const-no-body-semantic-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fitem-free-const-no-body-semantic-fail.rs?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -0,0 +1,7 @@\n+// Semantically, a free `const` item cannot omit its body.\n+\n+fn main() {}\n+\n+const A: u8; //~ ERROR free constant item without body\n+const B; //~ ERROR free constant item without body\n+//~^ ERROR missing type for `const` item"}, {"sha": "4e97229fa1a411b331643243a20c699297729de0", "filename": "src/test/ui/parser/item-free-const-no-body-semantic-fail.stderr", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fparser%2Fitem-free-const-no-body-semantic-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fparser%2Fitem-free-const-no-body-semantic-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fitem-free-const-no-body-semantic-fail.stderr?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -0,0 +1,24 @@\n+error: free constant item without body\n+  --> $DIR/item-free-const-no-body-semantic-fail.rs:5:1\n+   |\n+LL | const A: u8;\n+   | ^^^^^^^^^^^-\n+   |            |\n+   |            help: provide a definition for the constant: `= <expr>;`\n+\n+error: free constant item without body\n+  --> $DIR/item-free-const-no-body-semantic-fail.rs:6:1\n+   |\n+LL | const B;\n+   | ^^^^^^^-\n+   |        |\n+   |        help: provide a definition for the constant: `= <expr>;`\n+\n+error: missing type for `const` item\n+  --> $DIR/item-free-const-no-body-semantic-fail.rs:6:7\n+   |\n+LL | const B;\n+   |       ^ help: provide a type for the item: `B: [type error]`\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "acfdd3c363f2542eeb81cd4bdeef36db8ecda516", "filename": "src/test/ui/parser/item-free-const-no-body-syntactic-pass.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fparser%2Fitem-free-const-no-body-syntactic-pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fparser%2Fitem-free-const-no-body-syntactic-pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fitem-free-const-no-body-syntactic-pass.rs?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -0,0 +1,8 @@\n+// Syntactically, a free `const` item can omit its body.\n+\n+// check-pass\n+\n+fn main() {}\n+\n+#[cfg(FALSE)]\n+const X: u8;"}, {"sha": "780479e3d26ac6eb4a76cb6e45155ce05fadf066", "filename": "src/test/ui/parser/item-free-static-no-body-semantic-fail.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fparser%2Fitem-free-static-no-body-semantic-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fparser%2Fitem-free-static-no-body-semantic-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fitem-free-static-no-body-semantic-fail.rs?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -0,0 +1,11 @@\n+// Semantically, a free `static` item cannot omit its body.\n+\n+fn main() {}\n+\n+static A: u8; //~ ERROR free static item without body\n+static B; //~ ERROR free static item without body\n+//~^ ERROR missing type for `static` item\n+\n+static mut C: u8; //~ ERROR free static item without body\n+static mut D; //~ ERROR free static item without body\n+//~^ ERROR missing type for `static mut` item"}, {"sha": "60b7bb34c698b3a33ac5bfe1b12319a98219e63e", "filename": "src/test/ui/parser/item-free-static-no-body-semantic-fail.stderr", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fparser%2Fitem-free-static-no-body-semantic-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fparser%2Fitem-free-static-no-body-semantic-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fitem-free-static-no-body-semantic-fail.stderr?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -0,0 +1,46 @@\n+error: free static item without body\n+  --> $DIR/item-free-static-no-body-semantic-fail.rs:5:1\n+   |\n+LL | static A: u8;\n+   | ^^^^^^^^^^^^-\n+   |             |\n+   |             help: provide a definition for the static: `= <expr>;`\n+\n+error: free static item without body\n+  --> $DIR/item-free-static-no-body-semantic-fail.rs:6:1\n+   |\n+LL | static B;\n+   | ^^^^^^^^-\n+   |         |\n+   |         help: provide a definition for the static: `= <expr>;`\n+\n+error: free static item without body\n+  --> $DIR/item-free-static-no-body-semantic-fail.rs:9:1\n+   |\n+LL | static mut C: u8;\n+   | ^^^^^^^^^^^^^^^^-\n+   |                 |\n+   |                 help: provide a definition for the static: `= <expr>;`\n+\n+error: free static item without body\n+  --> $DIR/item-free-static-no-body-semantic-fail.rs:10:1\n+   |\n+LL | static mut D;\n+   | ^^^^^^^^^^^^-\n+   |             |\n+   |             help: provide a definition for the static: `= <expr>;`\n+\n+error: missing type for `static` item\n+  --> $DIR/item-free-static-no-body-semantic-fail.rs:6:8\n+   |\n+LL | static B;\n+   |        ^ help: provide a type for the item: `B: [type error]`\n+\n+error: missing type for `static mut` item\n+  --> $DIR/item-free-static-no-body-semantic-fail.rs:10:12\n+   |\n+LL | static mut D;\n+   |            ^ help: provide a type for the item: `D: [type error]`\n+\n+error: aborting due to 6 previous errors\n+"}, {"sha": "db0039204d870f82089ea989c9be93abe775469e", "filename": "src/test/ui/parser/item-free-static-no-body-syntactic-pass.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fparser%2Fitem-free-static-no-body-syntactic-pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fparser%2Fitem-free-static-no-body-syntactic-pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fitem-free-static-no-body-syntactic-pass.rs?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -0,0 +1,8 @@\n+// Syntactically, a free `const` item can omit its body.\n+\n+// check-pass\n+\n+fn main() {}\n+\n+#[cfg(FALSE)]\n+static X: u8;"}, {"sha": "c76b096a1ebf402af6e2bf1b1c9eb2fe78268605", "filename": "src/test/ui/parser/macro/trait-non-item-macros.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fparser%2Fmacro%2Ftrait-non-item-macros.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fparser%2Fmacro%2Ftrait-non-item-macros.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fmacro%2Ftrait-non-item-macros.stderr?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -1,8 +1,8 @@\n-error: expected one of `async`, `const`, `crate`, `default`, `extern`, `fn`, `pub`, `type`, `unsafe`, or identifier, found `2`\n+error: expected one of `async`, `const`, `crate`, `default`, `extern`, `fn`, `pub`, `static`, `type`, `unsafe`, or identifier, found `2`\n   --> $DIR/trait-non-item-macros.rs:2:19\n    |\n LL |     ($a:expr) => ($a)\n-   |                   ^^ expected one of 10 possible tokens\n+   |                   ^^ expected one of 11 possible tokens\n ...\n LL |     bah!(2);\n    |     -------- in this macro invocation"}, {"sha": "748db8983b59573286eab122d89d0e85775e4ef6", "filename": "src/test/ui/parser/mismatched-braces/missing-close-brace-in-impl-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fparser%2Fmismatched-braces%2Fmissing-close-brace-in-impl-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fparser%2Fmismatched-braces%2Fmissing-close-brace-in-impl-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fmismatched-braces%2Fmissing-close-brace-in-impl-trait.rs?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -3,7 +3,7 @@ fn main() {}\n impl T for () { //~ ERROR cannot find trait `T` in this scope\n \n fn foo(&self) {}\n-//~^ ERROR missing `fn`, `type`, or `const`\n+//~^ ERROR missing `fn`, `type`, `const`, or `static` for item declaration\n \n trait T {\n     fn foo(&self);"}, {"sha": "240be39eacef423e897d0f6f1dc98246e1697eb2", "filename": "src/test/ui/parser/mismatched-braces/missing-close-brace-in-impl-trait.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fparser%2Fmismatched-braces%2Fmissing-close-brace-in-impl-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fparser%2Fmismatched-braces%2Fmissing-close-brace-in-impl-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fmismatched-braces%2Fmissing-close-brace-in-impl-trait.stderr?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -7,15 +7,15 @@ LL | impl T for () {\n LL |\n    |                                                    ^\n \n-error: missing `fn`, `type`, or `const` for associated-item declaration\n+error: missing `fn`, `type`, `const`, or `static` for item declaration\n   --> $DIR/missing-close-brace-in-impl-trait.rs:5:17\n    |\n LL |   fn foo(&self) {}\n    |  _________________^\n LL | |\n LL | |\n LL | | trait T {\n-   | |_ missing `fn`, `type`, or `const`\n+   | |_ missing `fn`, `type`, `const`, or `static`\n \n error[E0405]: cannot find trait `T` in this scope\n   --> $DIR/missing-close-brace-in-impl-trait.rs:3:6"}, {"sha": "4e8cc6489bc64c276a4fc08e1333a8d76a325af7", "filename": "src/test/ui/parser/mismatched-braces/missing-close-brace-in-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fparser%2Fmismatched-braces%2Fmissing-close-brace-in-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fparser%2Fmismatched-braces%2Fmissing-close-brace-in-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fmismatched-braces%2Fmissing-close-brace-in-trait.rs?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -3,7 +3,7 @@ trait T {\n     fn foo(&self);\n \n pub(crate) struct Bar<T>();\n-//~^ ERROR missing `fn`, `type`, or `const`\n+//~^ ERROR missing `fn`, `type`, `const`, or `static` for item declaration\n \n impl T for Bar<usize> {\n fn foo(&self) {}"}, {"sha": "54afad5755b1587ed6643d55a4be78fbb3643c4b", "filename": "src/test/ui/parser/mismatched-braces/missing-close-brace-in-trait.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fparser%2Fmismatched-braces%2Fmissing-close-brace-in-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fparser%2Fmismatched-braces%2Fmissing-close-brace-in-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fmismatched-braces%2Fmissing-close-brace-in-trait.stderr?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -7,11 +7,11 @@ LL | trait T {\n LL | fn main() {}\n    |                                                                 ^\n \n-error: missing `fn`, `type`, or `const` for associated-item declaration\n+error: missing `fn`, `type`, `const`, or `static` for item declaration\n   --> $DIR/missing-close-brace-in-trait.rs:5:11\n    |\n LL | pub(crate) struct Bar<T>();\n-   |           ^ missing `fn`, `type`, or `const`\n+   |           ^ missing `fn`, `type`, `const`, or `static`\n \n error[E0601]: `main` function not found in crate `missing_close_brace_in_trait`\n   --> $DIR/missing-close-brace-in-trait.rs:1:1"}, {"sha": "8b83d6ab2f8c841f1615629e94bd0a151905b3d5", "filename": "src/test/ui/parser/mut-patterns.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fparser%2Fmut-patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fparser%2Fmut-patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fmut-patterns.rs?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -9,6 +9,8 @@ pub fn main() {\n     let mut _ = 0; //~ ERROR `mut` must be followed by a named binding\n     let mut (_, _) = (0, 0); //~ ERROR `mut` must be followed by a named binding\n \n+    let mut (x @ y) = 0; //~ ERROR `mut` must be attached to each individual binding\n+\n     let mut mut x = 0;\n     //~^ ERROR `mut` on a binding may not be repeated\n     //~| remove the additional `mut`s"}, {"sha": "9a6af7394bf4a41a71e5ba2ca400ca81ddcf0702", "filename": "src/test/ui/parser/mut-patterns.stderr", "status": "modified", "additions": 19, "deletions": 11, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fparser%2Fmut-patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fparser%2Fmut-patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fmut-patterns.stderr?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -14,36 +14,44 @@ LL |     let mut (_, _) = (0, 0);\n    |\n    = note: `mut` may be followed by `variable` and `variable @ pattern`\n \n+error: `mut` must be attached to each individual binding\n+  --> $DIR/mut-patterns.rs:12:9\n+   |\n+LL |     let mut (x @ y) = 0;\n+   |         ^^^^^^^^^^^ help: add `mut` to each binding: `(mut x @ mut y)`\n+   |\n+   = note: `mut` may be followed by `variable` and `variable @ pattern`\n+\n error: `mut` on a binding may not be repeated\n-  --> $DIR/mut-patterns.rs:12:13\n+  --> $DIR/mut-patterns.rs:14:13\n    |\n LL |     let mut mut x = 0;\n    |             ^^^ help: remove the additional `mut`s\n \n error: `mut` must be attached to each individual binding\n-  --> $DIR/mut-patterns.rs:17:9\n+  --> $DIR/mut-patterns.rs:19:9\n    |\n LL |     let mut Foo { x: x } = Foo { x: 3 };\n    |         ^^^^^^^^^^^^^^^^ help: add `mut` to each binding: `Foo { x: mut x }`\n    |\n    = note: `mut` may be followed by `variable` and `variable @ pattern`\n \n error: `mut` must be attached to each individual binding\n-  --> $DIR/mut-patterns.rs:21:9\n+  --> $DIR/mut-patterns.rs:23:9\n    |\n LL |     let mut Foo { x } = Foo { x: 3 };\n    |         ^^^^^^^^^^^^^ help: add `mut` to each binding: `Foo { mut x }`\n    |\n    = note: `mut` may be followed by `variable` and `variable @ pattern`\n \n error: `mut` on a binding may not be repeated\n-  --> $DIR/mut-patterns.rs:26:13\n+  --> $DIR/mut-patterns.rs:28:13\n    |\n LL |     let mut mut yield(become, await) = r#yield(0, 0);\n    |             ^^^ help: remove the additional `mut`s\n \n error: expected identifier, found reserved keyword `yield`\n-  --> $DIR/mut-patterns.rs:26:17\n+  --> $DIR/mut-patterns.rs:28:17\n    |\n LL |     let mut mut yield(become, await) = r#yield(0, 0);\n    |                 ^^^^^ expected identifier, found reserved keyword\n@@ -54,7 +62,7 @@ LL |     let mut mut r#yield(become, await) = r#yield(0, 0);\n    |                 ^^^^^^^\n \n error: expected identifier, found reserved keyword `become`\n-  --> $DIR/mut-patterns.rs:26:23\n+  --> $DIR/mut-patterns.rs:28:23\n    |\n LL |     let mut mut yield(become, await) = r#yield(0, 0);\n    |                       ^^^^^^ expected identifier, found reserved keyword\n@@ -65,7 +73,7 @@ LL |     let mut mut yield(r#become, await) = r#yield(0, 0);\n    |                       ^^^^^^^^\n \n error: expected identifier, found keyword `await`\n-  --> $DIR/mut-patterns.rs:26:31\n+  --> $DIR/mut-patterns.rs:28:31\n    |\n LL |     let mut mut yield(become, await) = r#yield(0, 0);\n    |                               ^^^^^ expected identifier, found keyword\n@@ -76,23 +84,23 @@ LL |     let mut mut yield(become, r#await) = r#yield(0, 0);\n    |                               ^^^^^^^\n \n error: `mut` must be attached to each individual binding\n-  --> $DIR/mut-patterns.rs:26:9\n+  --> $DIR/mut-patterns.rs:28:9\n    |\n LL |     let mut mut yield(become, await) = r#yield(0, 0);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: add `mut` to each binding: `r#yield(mut r#become, mut r#await)`\n    |\n    = note: `mut` may be followed by `variable` and `variable @ pattern`\n \n error: `mut` must be attached to each individual binding\n-  --> $DIR/mut-patterns.rs:35:9\n+  --> $DIR/mut-patterns.rs:37:9\n    |\n LL |     let mut W(mut a, W(b, W(ref c, W(d, B { box f }))))\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: add `mut` to each binding: `W(mut a, W(mut b, W(ref c, W(mut d, B { box mut f }))))`\n    |\n    = note: `mut` may be followed by `variable` and `variable @ pattern`\n \n error: expected identifier, found `x`\n-  --> $DIR/mut-patterns.rs:42:21\n+  --> $DIR/mut-patterns.rs:44:21\n    |\n LL |             let mut $p = 0;\n    |                     ^^ expected identifier\n@@ -102,5 +110,5 @@ LL |     foo!(x);\n    |\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: aborting due to 12 previous errors\n+error: aborting due to 13 previous errors\n "}, {"sha": "71c22e62f8e4bd25bfadd34881106fec6033848b", "filename": "src/test/ui/parser/removed-syntax-extern-const.rs", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e620d0f337d0643c757bab791fc7d88d63217704/src%2Ftest%2Fui%2Fparser%2Fremoved-syntax-extern-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e620d0f337d0643c757bab791fc7d88d63217704/src%2Ftest%2Fui%2Fparser%2Fremoved-syntax-extern-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fremoved-syntax-extern-const.rs?ref=e620d0f337d0643c757bab791fc7d88d63217704", "patch": "@@ -1,6 +0,0 @@\n-extern {\n-    const i: isize;\n-    //~^ ERROR extern items cannot be `const`\n-}\n-\n-fn main() {}"}, {"sha": "2bccbd91452f62a7276305f9b3c7fbfdceb57533", "filename": "src/test/ui/parser/removed-syntax-extern-const.stderr", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e620d0f337d0643c757bab791fc7d88d63217704/src%2Ftest%2Fui%2Fparser%2Fremoved-syntax-extern-const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e620d0f337d0643c757bab791fc7d88d63217704/src%2Ftest%2Fui%2Fparser%2Fremoved-syntax-extern-const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fremoved-syntax-extern-const.stderr?ref=e620d0f337d0643c757bab791fc7d88d63217704", "patch": "@@ -1,8 +0,0 @@\n-error: extern items cannot be `const`\n-  --> $DIR/removed-syntax-extern-const.rs:2:5\n-   |\n-LL |     const i: isize;\n-   |     ^^^^^ help: try using a static value: `static`\n-\n-error: aborting due to previous error\n-"}, {"sha": "cd643b874dbda108a22c18bf7a53b67f52ddb470", "filename": "src/test/ui/parser/removed-syntax-static-fn.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fparser%2Fremoved-syntax-static-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fparser%2Fremoved-syntax-static-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fremoved-syntax-static-fn.rs?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -1,8 +1,10 @@\n struct S;\n \n impl S {\n-    //~^ ERROR missing `fn`, `type`, or `const` for associated-item declaration\n     static fn f() {}\n+    //~^ ERROR expected identifier, found keyword `fn`\n+    //~| ERROR expected one of `:`, `;`, or `=`\n+    //~| ERROR missing type for `static` item\n }\n \n fn main() {}"}, {"sha": "dc5625bdadea3395b416bf7381bd5518b211b128", "filename": "src/test/ui/parser/removed-syntax-static-fn.stderr", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fparser%2Fremoved-syntax-static-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fparser%2Fremoved-syntax-static-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fremoved-syntax-static-fn.stderr?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -1,11 +1,20 @@\n-error: missing `fn`, `type`, or `const` for associated-item declaration\n-  --> $DIR/removed-syntax-static-fn.rs:3:9\n+error: expected identifier, found keyword `fn`\n+  --> $DIR/removed-syntax-static-fn.rs:4:12\n    |\n-LL |   impl S {\n-   |  _________^\n-LL | |\n-LL | |     static fn f() {}\n-   | |____^ missing `fn`, `type`, or `const`\n+LL |     static fn f() {}\n+   |            ^^ expected identifier, found keyword\n \n-error: aborting due to previous error\n+error: expected one of `:`, `;`, or `=`, found `f`\n+  --> $DIR/removed-syntax-static-fn.rs:4:15\n+   |\n+LL |     static fn f() {}\n+   |               ^ expected one of `:`, `;`, or `=`\n+\n+error: missing type for `static` item\n+  --> $DIR/removed-syntax-static-fn.rs:4:12\n+   |\n+LL |     static fn f() {}\n+   |            ^^ help: provide a type for the item: `r#fn: <type>`\n+\n+error: aborting due to 3 previous errors\n "}, {"sha": "c01ac4752e07561f0aa6de5f8e42784faa1e2007", "filename": "src/test/ui/parser/underscore_item_not_const.rs", "status": "modified", "additions": 1, "deletions": 15, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fparser%2Funderscore_item_not_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fparser%2Funderscore_item_not_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Funderscore_item_not_const.rs?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -1,18 +1,4 @@\n-// Test that various non-const items and associated consts do not permit `_` as a name.\n-\n-// Associated `const`s:\n-\n-pub trait A {\n-    const _: () = (); //~ ERROR expected identifier, found reserved identifier `_`\n-}\n-impl A for () {\n-    const _: () = (); //~ ERROR expected identifier, found reserved identifier `_`\n-}\n-impl dyn A {\n-    const _: () = (); //~ ERROR expected identifier, found reserved identifier `_`\n-}\n-\n-// Other kinds of items:\n+// Test that various non-const items do not syntactically permit `_` as a name.\n \n static _: () = (); //~ ERROR expected identifier, found reserved identifier `_`\n struct _(); //~ ERROR expected identifier, found reserved identifier `_`"}, {"sha": "0bc7642dd196471fe0bf6459c848cc31fc6c6eb2", "filename": "src/test/ui/parser/underscore_item_not_const.stderr", "status": "modified", "additions": 13, "deletions": 31, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fparser%2Funderscore_item_not_const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fparser%2Funderscore_item_not_const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Funderscore_item_not_const.stderr?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -1,92 +1,74 @@\n error: expected identifier, found reserved identifier `_`\n-  --> $DIR/underscore_item_not_const.rs:6:11\n-   |\n-LL |     const _: () = ();\n-   |           ^ expected identifier, found reserved identifier\n-\n-error: expected identifier, found reserved identifier `_`\n-  --> $DIR/underscore_item_not_const.rs:9:11\n-   |\n-LL |     const _: () = ();\n-   |           ^ expected identifier, found reserved identifier\n-\n-error: expected identifier, found reserved identifier `_`\n-  --> $DIR/underscore_item_not_const.rs:12:11\n-   |\n-LL |     const _: () = ();\n-   |           ^ expected identifier, found reserved identifier\n-\n-error: expected identifier, found reserved identifier `_`\n-  --> $DIR/underscore_item_not_const.rs:17:8\n+  --> $DIR/underscore_item_not_const.rs:3:8\n    |\n LL | static _: () = ();\n    |        ^ expected identifier, found reserved identifier\n \n error: expected identifier, found reserved identifier `_`\n-  --> $DIR/underscore_item_not_const.rs:18:8\n+  --> $DIR/underscore_item_not_const.rs:4:8\n    |\n LL | struct _();\n    |        ^ expected identifier, found reserved identifier\n \n error: expected identifier, found reserved identifier `_`\n-  --> $DIR/underscore_item_not_const.rs:19:6\n+  --> $DIR/underscore_item_not_const.rs:5:6\n    |\n LL | enum _ {}\n    |      ^ expected identifier, found reserved identifier\n \n error: expected identifier, found reserved identifier `_`\n-  --> $DIR/underscore_item_not_const.rs:20:4\n+  --> $DIR/underscore_item_not_const.rs:6:4\n    |\n LL | fn _() {}\n    |    ^ expected identifier, found reserved identifier\n \n error: expected identifier, found reserved identifier `_`\n-  --> $DIR/underscore_item_not_const.rs:21:5\n+  --> $DIR/underscore_item_not_const.rs:7:5\n    |\n LL | mod _ {}\n    |     ^ expected identifier, found reserved identifier\n \n error: expected identifier, found reserved identifier `_`\n-  --> $DIR/underscore_item_not_const.rs:22:6\n+  --> $DIR/underscore_item_not_const.rs:8:6\n    |\n LL | type _ = ();\n    |      ^ expected identifier, found reserved identifier\n \n error: expected identifier, found reserved identifier `_`\n-  --> $DIR/underscore_item_not_const.rs:23:5\n+  --> $DIR/underscore_item_not_const.rs:9:5\n    |\n LL | use _;\n    |     ^ expected identifier, found reserved identifier\n \n error: expected identifier, found reserved identifier `_`\n-  --> $DIR/underscore_item_not_const.rs:24:5\n+  --> $DIR/underscore_item_not_const.rs:10:5\n    |\n LL | use _ as g;\n    |     ^ expected identifier, found reserved identifier\n \n error: expected identifier, found reserved identifier `_`\n-  --> $DIR/underscore_item_not_const.rs:25:7\n+  --> $DIR/underscore_item_not_const.rs:11:7\n    |\n LL | trait _ {}\n    |       ^ expected identifier, found reserved identifier\n \n error: expected identifier, found reserved identifier `_`\n-  --> $DIR/underscore_item_not_const.rs:26:7\n+  --> $DIR/underscore_item_not_const.rs:12:7\n    |\n LL | trait _ = Copy;\n    |       ^ expected identifier, found reserved identifier\n \n error: expected identifier, found reserved identifier `_`\n-  --> $DIR/underscore_item_not_const.rs:27:14\n+  --> $DIR/underscore_item_not_const.rs:13:14\n    |\n LL | macro_rules! _ { () => {} }\n    |              ^ expected identifier, found reserved identifier\n \n error: expected one of `!` or `::`, found reserved identifier `_`\n-  --> $DIR/underscore_item_not_const.rs:28:7\n+  --> $DIR/underscore_item_not_const.rs:14:7\n    |\n LL | union _ { f: u8 }\n    |       ^ expected one of `!` or `::`\n \n-error: aborting due to 15 previous errors\n+error: aborting due to 12 previous errors\n "}, {"sha": "9566244464081fc222b098c0fc3e6d2c3e002a04", "filename": "src/test/ui/pattern/pattern-tyvar-2.stderr", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fpattern%2Fpattern-tyvar-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fpattern%2Fpattern-tyvar-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fpattern-tyvar-2.stderr?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -5,8 +5,6 @@ LL | fn foo(t: Bar) -> isize { match t { Bar::T1(_, Some(x)) => { return x * 3;\n    |                                                                     - ^ - {integer}\n    |                                                                     |\n    |                                                                     std::vec::Vec<isize>\n-   |\n-   = note: an implementation of `std::ops::Mul` might be missing for `std::vec::Vec<isize>`\n \n error: aborting due to previous error\n "}, {"sha": "c9f0664c3a3ac3c8d27d1b386a70e50d4b4f1826", "filename": "src/test/ui/proc-macro/auxiliary/generate-dollar-ident.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fgenerate-dollar-ident.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fgenerate-dollar-ident.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fgenerate-dollar-ident.rs?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -0,0 +1,17 @@\n+// force-host\n+// no-prefer-dynamic\n+\n+#![feature(proc_macro_hygiene)]\n+#![feature(proc_macro_quote)]\n+#![crate_type = \"proc-macro\"]\n+\n+extern crate proc_macro;\n+use proc_macro::*;\n+\n+#[proc_macro]\n+pub fn dollar_ident(input: TokenStream) -> TokenStream {\n+    let black_hole = input.into_iter().next().unwrap();\n+    quote! {\n+        $black_hole!($$var);\n+    }\n+}"}, {"sha": "b838be9fb9f2c5121b607455fbd86ce7e750b21f", "filename": "src/test/ui/proc-macro/generate-dollar-ident.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fproc-macro%2Fgenerate-dollar-ident.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fproc-macro%2Fgenerate-dollar-ident.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fgenerate-dollar-ident.rs?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -0,0 +1,18 @@\n+// Proc macros can generate token sequence `$ IDENT`\n+// without it being recognized as an unknown macro variable.\n+\n+// check-pass\n+// aux-build:generate-dollar-ident.rs\n+\n+extern crate generate_dollar_ident;\n+use generate_dollar_ident::*;\n+\n+macro_rules! black_hole {\n+    ($($tt:tt)*) => {};\n+}\n+\n+black_hole!($var);\n+\n+dollar_ident!(black_hole);\n+\n+fn main() {}"}, {"sha": "39874a6c680cd773f10e39618e4459b9758a8694", "filename": "src/test/ui/rfc-2497-if-let-chains/disallowed-positions.stderr", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fdisallowed-positions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fdisallowed-positions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fdisallowed-positions.stderr?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -560,8 +560,6 @@ error[E0600]: cannot apply unary operator `-` to type `bool`\n    |\n LL |     if -let 0 = 0 {}\n    |        ^^^^^^^^^^ cannot apply unary operator `-`\n-   |\n-   = note: an implementation of `std::ops::Neg` might be missing for `bool`\n \n error[E0277]: the `?` operator can only be applied to values that implement `std::ops::Try`\n   --> $DIR/disallowed-positions.rs:46:8\n@@ -748,8 +746,6 @@ error[E0600]: cannot apply unary operator `-` to type `bool`\n    |\n LL |     while -let 0 = 0 {}\n    |           ^^^^^^^^^^ cannot apply unary operator `-`\n-   |\n-   = note: an implementation of `std::ops::Neg` might be missing for `bool`\n \n error[E0277]: the `?` operator can only be applied to values that implement `std::ops::Try`\n   --> $DIR/disallowed-positions.rs:110:11\n@@ -927,8 +923,6 @@ error[E0600]: cannot apply unary operator `-` to type `bool`\n    |\n LL |     -let 0 = 0;\n    |     ^^^^^^^^^^ cannot apply unary operator `-`\n-   |\n-   = note: an implementation of `std::ops::Neg` might be missing for `bool`\n \n error[E0277]: the `?` operator can only be applied to values that implement `std::ops::Try`\n   --> $DIR/disallowed-positions.rs:183:5"}, {"sha": "8caa5bea4ac1e15d981175bc8ed62cebbbe5d71f", "filename": "src/test/ui/span/issue-39018.stderr", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fspan%2Fissue-39018.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fspan%2Fissue-39018.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-39018.stderr?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -136,8 +136,6 @@ LL |     let _ = &c + &d;\n    |             -- ^ -- &&str\n    |             |\n    |             &&str\n-   |\n-   = note: an implementation of `std::ops::Add` might be missing for `&&str`\n \n error[E0369]: cannot add `&str` to `&&str`\n   --> $DIR/issue-39018.rs:35:16\n@@ -146,8 +144,6 @@ LL |     let _ = &c + d;\n    |             -- ^ - &str\n    |             |\n    |             &&str\n-   |\n-   = note: an implementation of `std::ops::Add` might be missing for `&&str`\n \n error[E0369]: cannot add `&&str` to `&str`\n   --> $DIR/issue-39018.rs:36:15"}, {"sha": "29216f36f5f313aa4484b5c89df975fa52a24d51", "filename": "src/test/ui/traits/trait-resolution-in-overloaded-op.stderr", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Ftraits%2Ftrait-resolution-in-overloaded-op.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Ftraits%2Ftrait-resolution-in-overloaded-op.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-resolution-in-overloaded-op.stderr?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -5,8 +5,6 @@ LL |     a * b\n    |     - ^ - f64\n    |     |\n    |     &T\n-   |\n-   = note: an implementation of `std::ops::Mul` might be missing for `&T`\n \n error: aborting due to previous error\n "}, {"sha": "9913747b88ee9b81e5f70962da05f7c18b6336fd", "filename": "src/test/ui/unop-neg-bool.stderr", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Funop-neg-bool.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Funop-neg-bool.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funop-neg-bool.stderr?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -3,8 +3,6 @@ error[E0600]: cannot apply unary operator `-` to type `bool`\n    |\n LL |     -true;\n    |     ^^^^^ cannot apply unary operator `-`\n-   |\n-   = note: an implementation of `std::ops::Neg` might be missing for `bool`\n \n error: aborting due to previous error\n "}, {"sha": "2d41583268c4efaaa3257140d24079ae3ab229b4", "filename": "src/test/ui/vec/vec-res-add.stderr", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fvec%2Fvec-res-add.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e0e5d82e1677c82d209b214bbfc2cc5705c2336a/src%2Ftest%2Fui%2Fvec%2Fvec-res-add.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fvec%2Fvec-res-add.stderr?ref=e0e5d82e1677c82d209b214bbfc2cc5705c2336a", "patch": "@@ -5,8 +5,6 @@ LL |     let k = i + j;\n    |             - ^ - std::vec::Vec<R>\n    |             |\n    |             std::vec::Vec<R>\n-   |\n-   = note: an implementation of `std::ops::Add` might be missing for `std::vec::Vec<R>`\n \n error: aborting due to previous error\n "}]}