{"sha": "e3662b188041b50c732896ded3de823144ae6556", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUzNjYyYjE4ODA0MWI1MGM3MzI4OTZkZWQzZGU4MjMxNDRhZTY1NTY=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-08-09T05:22:52Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-08-28T06:22:52Z"}, "message": "Remove offset_inbounds for an unsafe offset function", "tree": {"sha": "ac34ea3fa87e2e884d01f3666b6be141c9fd2bb9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ac34ea3fa87e2e884d01f3666b6be141c9fd2bb9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e3662b188041b50c732896ded3de823144ae6556", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e3662b188041b50c732896ded3de823144ae6556", "html_url": "https://github.com/rust-lang/rust/commit/e3662b188041b50c732896ded3de823144ae6556", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e3662b188041b50c732896ded3de823144ae6556/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "578e68047736167239c52fa1aba0347011ff1bc3", "url": "https://api.github.com/repos/rust-lang/rust/commits/578e68047736167239c52fa1aba0347011ff1bc3", "html_url": "https://github.com/rust-lang/rust/commit/578e68047736167239c52fa1aba0347011ff1bc3"}], "stats": {"total": 146, "additions": 37, "deletions": 109}, "files": [{"sha": "bf65986b5ba9bd60ba4f9a3f0b60edd0bd8bd77f", "filename": "src/librustc/middle/trans/type_use.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e3662b188041b50c732896ded3de823144ae6556/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3662b188041b50c732896ded3de823144ae6556/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=e3662b188041b50c732896ded3de823144ae6556", "patch": "@@ -149,7 +149,7 @@ pub fn type_uses_for(ccx: @mut CrateContext, fn_id: def_id, n_tps: uint)\n                     \"visit_tydesc\"  | \"forget\" | \"frame_address\" |\n                     \"morestack_addr\" => 0,\n \n-                    \"offset\" | \"offset_inbounds\" |\n+                    \"offset\" |\n                     \"memcpy32\" | \"memcpy64\" | \"memmove32\" | \"memmove64\" |\n                     \"memset32\" | \"memset64\" => use_repr,\n "}, {"sha": "0b27a581a2aa4bc6cb4fc5bf041c147574b99964", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e3662b188041b50c732896ded3de823144ae6556/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3662b188041b50c732896ded3de823144ae6556/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=e3662b188041b50c732896ded3de823144ae6556", "patch": "@@ -3663,20 +3663,6 @@ pub fn check_intrinsic_type(ccx: @mut CrateCtxt, it: @ast::foreign_item) {\n                    mutbl: ast::m_imm\n                }))\n             }\n-            \"offset_inbounds\" => {\n-              (1,\n-               ~[\n-                  ty::mk_ptr(tcx, ty::mt {\n-                      ty: param(ccx, 0),\n-                      mutbl: ast::m_imm\n-                  }),\n-                  ty::mk_int()\n-               ],\n-               ty::mk_ptr(tcx, ty::mt {\n-                   ty: param(ccx, 0),\n-                   mutbl: ast::m_imm\n-               }))\n-            }\n             \"memcpy32\" => {\n               (1,\n                ~["}, {"sha": "70b04e37ee1ff3785de55096c1f9c56fb773073a", "filename": "src/libstd/c_str.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e3662b188041b50c732896ded3de823144ae6556/src%2Flibstd%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3662b188041b50c732896ded3de823144ae6556/src%2Flibstd%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_str.rs?ref=e3662b188041b50c732896ded3de823144ae6556", "patch": "@@ -179,7 +179,7 @@ impl<'self> ToCStr for &'self [u8] {\n         do cs.with_mut_ref |buf| {\n             for i in range(0, self.len()) {\n                 unsafe {\n-                    let p = buf.offset_inbounds(i as int);\n+                    let p = buf.offset(i as int);\n                     if *p == 0 {\n                         match null_byte::cond.raise(self.to_owned()) {\n                             Truncate => break,\n@@ -222,7 +222,7 @@ impl<'self> Iterator<libc::c_char> for CStringIterator<'self> {\n         if ch == 0 {\n             None\n         } else {\n-            self.ptr = ptr::offset(self.ptr, 1);\n+            self.ptr = unsafe { ptr::offset(self.ptr, 1) };\n             Some(ch)\n         }\n     }"}, {"sha": "02469527b7af66a741181950c9e85c7ab0ec4ec6", "filename": "src/libstd/ptr.rs", "status": "modified", "additions": 22, "deletions": 76, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/e3662b188041b50c732896ded3de823144ae6556/src%2Flibstd%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3662b188041b50c732896ded3de823144ae6556/src%2Flibstd%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fptr.rs?ref=e3662b188041b50c732896ded3de823144ae6556", "patch": "@@ -20,37 +20,36 @@ use sys;\n use unstable::intrinsics;\n use util::swap;\n \n-#[cfg(not(test))] use ops::{Add,Sub};\n-#[cfg(not(test))] use num::Int;\n-\n #[cfg(not(test))] use cmp::{Eq, Ord};\n \n-/// Calculate the offset from a pointer\n+/// Calculate the offset from a pointer. The count *must* be in bounds or\n+/// otherwise the loads of this address are undefined.\n #[inline]\n #[cfg(stage0)]\n-pub fn offset<T>(ptr: *T, count: int) -> *T {\n+pub unsafe fn offset<T>(ptr: *T, count: int) -> *T {\n     (ptr as uint + (count as uint) * sys::size_of::<T>()) as *T\n }\n \n /// Calculate the offset from a mut pointer\n #[inline]\n #[cfg(stage0)]\n-pub fn mut_offset<T>(ptr: *mut T, count: int) -> *mut T {\n+pub unsafe fn mut_offset<T>(ptr: *mut T, count: int) -> *mut T {\n     (ptr as uint + (count as uint) * sys::size_of::<T>()) as *mut T\n }\n \n /// Calculate the offset from a pointer\n #[inline]\n #[cfg(not(stage0))]\n-pub fn offset<T>(ptr: *T, count: int) -> *T {\n-    unsafe { intrinsics::offset(ptr, count) }\n+pub unsafe fn offset<T>(ptr: *T, count: int) -> *T {\n+    intrinsics::offset(ptr, count)\n }\n \n-/// Calculate the offset from a mut pointer\n+/// Calculate the offset from a mut pointer. The count *must* be in bounds or\n+/// otherwise the loads of this address are undefined.\n #[inline]\n #[cfg(not(stage0))]\n-pub fn mut_offset<T>(ptr: *mut T, count: int) -> *mut T {\n-    unsafe { intrinsics::offset(ptr as *T, count) as *mut T }\n+pub unsafe fn mut_offset<T>(ptr: *mut T, count: int) -> *mut T {\n+    intrinsics::offset(ptr as *T, count) as *mut T\n }\n \n /// Return the offset of the first null pointer in `buf`.\n@@ -293,8 +292,7 @@ pub trait RawPtr<T> {\n     fn is_not_null(&self) -> bool;\n     fn to_uint(&self) -> uint;\n     unsafe fn to_option(&self) -> Option<&T>;\n-    fn offset(&self, count: int) -> Self;\n-    unsafe fn offset_inbounds(self, count: int) -> Self;\n+    unsafe fn offset(self, count: int) -> Self;\n }\n \n /// Extension methods for immutable pointers\n@@ -332,16 +330,10 @@ impl<T> RawPtr<T> for *T {\n         }\n     }\n \n-    /// Calculates the offset from a pointer.\n-    #[inline]\n-    fn offset(&self, count: int) -> *T { offset(*self, count) }\n-\n     /// Calculates the offset from a pointer. The offset *must* be in-bounds of\n     /// the object, or one-byte-past-the-end.\n     #[inline]\n-    unsafe fn offset_inbounds(self, count: int) -> *T {\n-        intrinsics::offset_inbounds(self, count)\n-    }\n+    unsafe fn offset(self, count: int) -> *T { offset(self, count) }\n }\n \n /// Extension methods for mutable pointers\n@@ -379,20 +371,14 @@ impl<T> RawPtr<T> for *mut T {\n         }\n     }\n \n-    /// Calculates the offset from a mutable pointer.\n-    #[inline]\n-    fn offset(&self, count: int) -> *mut T { mut_offset(*self, count) }\n-\n     /// Calculates the offset from a pointer. The offset *must* be in-bounds of\n     /// the object, or one-byte-past-the-end. An arithmetic overflow is also\n     /// undefined behaviour.\n     ///\n     /// This method should be preferred over `offset` when the guarantee can be\n     /// satisfied, to enable better optimization.\n     #[inline]\n-    unsafe fn offset_inbounds(self, count: int) -> *mut T {\n-        intrinsics::offset_inbounds(self as *T, count) as *mut T\n-    }\n+    unsafe fn offset(self, count: int) -> *mut T { mut_offset(self, count) }\n }\n \n // Equality for pointers\n@@ -513,46 +499,6 @@ impl<T> Ord for *mut T {\n     }\n }\n \n-#[cfg(not(test))]\n-impl<T, I: Int> Add<I, *T> for *T {\n-    /// Add an integer value to a pointer to get an offset pointer.\n-    /// Is calculated according to the size of the type pointed to.\n-    #[inline]\n-    fn add(&self, rhs: &I) -> *T {\n-        self.offset(rhs.to_int() as int)\n-    }\n-}\n-\n-#[cfg(not(test))]\n-impl<T, I: Int> Sub<I, *T> for *T {\n-    /// Subtract an integer value from a pointer to get an offset pointer.\n-    /// Is calculated according to the size of the type pointed to.\n-    #[inline]\n-    fn sub(&self, rhs: &I) -> *T {\n-        self.offset(-rhs.to_int() as int)\n-    }\n-}\n-\n-#[cfg(not(test))]\n-impl<T, I: Int> Add<I, *mut T> for *mut T {\n-    /// Add an integer value to a pointer to get an offset pointer.\n-    /// Is calculated according to the size of the type pointed to.\n-    #[inline]\n-    fn add(&self, rhs: &I) -> *mut T {\n-        self.offset(rhs.to_int() as int)\n-    }\n-}\n-\n-#[cfg(not(test))]\n-impl<T, I: Int> Sub<I, *mut T> for *mut T {\n-    /// Subtract an integer value from a pointer to get an offset pointer.\n-    /// Is calculated according to the size of the type pointed to.\n-    #[inline]\n-    fn sub(&self, rhs: &I) -> *mut T {\n-        self.offset(-rhs.to_int() as int)\n-    }\n-}\n-\n #[cfg(test)]\n pub mod ptr_tests {\n     use super::*;\n@@ -635,15 +581,15 @@ pub mod ptr_tests {\n         assert!(p.is_null());\n         assert!(!p.is_not_null());\n \n-        let q = offset(p, 1);\n+        let q = unsafe { offset(p, 1) };\n         assert!(!q.is_null());\n         assert!(q.is_not_null());\n \n         let mp: *mut int = mut_null();\n         assert!(mp.is_null());\n         assert!(!mp.is_not_null());\n \n-        let mq = mp.offset(1);\n+        let mq = unsafe { mp.offset(1) };\n         assert!(!mq.is_null());\n         assert!(mq.is_not_null());\n     }\n@@ -672,20 +618,20 @@ pub mod ptr_tests {\n         unsafe {\n             let xs = ~[5, ..16];\n             let mut ptr = to_ptr(xs);\n-            let end = ptr + 16;\n+            let end = ptr.offset(16);\n \n             while ptr < end {\n                 assert_eq!(*ptr, 5);\n-                ptr = ptr + 1u;\n+                ptr = ptr.offset(1);\n             }\n \n             let mut xs_mut = xs.clone();\n             let mut m_ptr = to_mut_ptr(xs_mut);\n-            let m_end = m_ptr + 16i16;\n+            let m_end = m_ptr.offset(16);\n \n             while m_ptr < m_end {\n                 *m_ptr += 5;\n-                m_ptr = m_ptr + 1u8;\n+                m_ptr = m_ptr.offset(1);\n             }\n \n             assert_eq!(xs_mut, ~[10, ..16]);\n@@ -702,17 +648,17 @@ pub mod ptr_tests {\n             let ptr = to_ptr(xs);\n \n             while idx >= 0i8 {\n-                assert_eq!(*(ptr + idx), idx as int);\n+                assert_eq!(*(ptr.offset(idx as int)), idx as int);\n                 idx = idx - 1i8;\n             }\n \n             let mut xs_mut = xs.clone();\n             let m_start = to_mut_ptr(xs_mut);\n-            let mut m_ptr = m_start + 9u32;\n+            let mut m_ptr = m_start.offset(9);\n \n             while m_ptr >= m_start {\n                 *m_ptr += *m_ptr;\n-                m_ptr = m_ptr - 1i8;\n+                m_ptr = m_ptr.offset(-1);\n             }\n \n             assert_eq!(xs_mut, ~[0,2,4,6,8,10,12,14,16,18]);"}, {"sha": "588010bd5b179f14a41a825d46090d055671568a", "filename": "src/libstd/repr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e3662b188041b50c732896ded3de823144ae6556/src%2Flibstd%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3662b188041b50c732896ded3de823144ae6556/src%2Flibstd%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frepr.rs?ref=e3662b188041b50c732896ded3de823144ae6556", "patch": "@@ -228,7 +228,7 @@ impl ReprVisitor {\n                 self.writer.write_str(\", \");\n             }\n             self.visit_ptr_inner(p as *c_void, inner);\n-            p = align(ptr::offset(p, sz as int) as uint, al) as *u8;\n+            p = align(unsafe { ptr::offset(p, sz as int) as uint }, al) as *u8;\n             left -= dec;\n         }\n         self.writer.write_char(']');"}, {"sha": "da70659acec2edfe577607b7a54b1fa1152cad27", "filename": "src/libstd/rt/stack.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e3662b188041b50c732896ded3de823144ae6556/src%2Flibstd%2Frt%2Fstack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3662b188041b50c732896ded3de823144ae6556/src%2Flibstd%2Frt%2Fstack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fstack.rs?ref=e3662b188041b50c732896ded3de823144ae6556", "patch": "@@ -46,7 +46,9 @@ impl StackSegment {\n \n     /// Point one word beyond the high end of the allocated stack\n     pub fn end(&self) -> *uint {\n-        vec::raw::to_ptr(self.buf).offset(self.buf.len() as int) as *uint\n+        unsafe {\n+            vec::raw::to_ptr(self.buf).offset(self.buf.len() as int) as *uint\n+        }\n     }\n }\n "}, {"sha": "9ca6e8ad0899238bd568bc07d8e00faab7c71b60", "filename": "src/libstd/str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e3662b188041b50c732896ded3de823144ae6556/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3662b188041b50c732896ded3de823144ae6556/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=e3662b188041b50c732896ded3de823144ae6556", "patch": "@@ -1092,7 +1092,7 @@ pub mod raw {\n     pub unsafe fn slice_unchecked<'a>(s: &'a str, begin: uint, end: uint) -> &'a str {\n         do s.as_imm_buf |sbuf, _n| {\n              cast::transmute(Slice {\n-                 data: sbuf.offset_inbounds(begin as int),\n+                 data: sbuf.offset(begin as int),\n                  len: end - begin,\n              })\n         }"}, {"sha": "cdd93ce87c35bbdfb14944571782e07cd71a1d06", "filename": "src/libstd/unstable/intrinsics.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e3662b188041b50c732896ded3de823144ae6556/src%2Flibstd%2Funstable%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3662b188041b50c732896ded3de823144ae6556/src%2Flibstd%2Funstable%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fintrinsics.rs?ref=e3662b188041b50c732896ded3de823144ae6556", "patch": "@@ -332,19 +332,13 @@ extern \"rust-intrinsic\" {\n     /// Get the address of the `__morestack` stack growth function.\n     pub fn morestack_addr() -> *();\n \n-    /// Calculates the offset from a pointer.\n-    ///\n-    /// This is implemented as an intrinsic to avoid converting to and from an\n-    /// integer, since the conversion would throw away aliasing information.\n-    pub fn offset<T>(dst: *T, offset: int) -> *T;\n-\n     /// Calculates the offset from a pointer. The offset *must* be in-bounds of\n     /// the object, or one-byte-past-the-end. An arithmetic overflow is also\n     /// undefined behaviour.\n     ///\n-    /// This intrinsic should be preferred over `offset` when the guarantee can\n-    /// be satisfied, to enable better optimization.\n-    pub fn offset_inbounds<T>(dst: *T, offset: int) -> *T;\n+    /// This is implemented as an intrinsic to avoid converting to and from an\n+    /// integer, since the conversion would throw away aliasing information.\n+    pub fn offset<T>(dst: *T, offset: int) -> *T;\n \n     /// Equivalent to the `llvm.memcpy.p0i8.0i8.i32` intrinsic, with a size of\n     /// `count` * `size_of::<T>()` and an alignment of `min_align_of::<T>()`"}, {"sha": "12aebe20161a03f337c7a6a677984d17de73e300", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e3662b188041b50c732896ded3de823144ae6556/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3662b188041b50c732896ded3de823144ae6556/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=e3662b188041b50c732896ded3de823144ae6556", "patch": "@@ -896,7 +896,7 @@ impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n                             lifetime: cast::transmute(p)}\n             } else {\n                 VecIterator{ptr: p,\n-                            end: p.offset_inbounds(self.len() as int),\n+                            end: p.offset(self.len() as int),\n                             lifetime: cast::transmute(p)}\n             }\n         }\n@@ -1884,7 +1884,7 @@ impl<'self,T> MutableVector<'self, T> for &'self mut [T] {\n                                lifetime: cast::transmute(p)}\n             } else {\n                 VecMutIterator{ptr: p,\n-                               end: p.offset_inbounds(self.len() as int),\n+                               end: p.offset(self.len() as int),\n                                lifetime: cast::transmute(p)}\n             }\n         }\n@@ -2247,7 +2247,7 @@ macro_rules! iterator {\n                             // same pointer.\n                             cast::transmute(self.ptr as uint + 1)\n                         } else {\n-                            self.ptr.offset_inbounds(1)\n+                            self.ptr.offset(1)\n                         };\n \n                         Some(cast::transmute(old))\n@@ -2279,7 +2279,7 @@ macro_rules! double_ended_iterator {\n                             // See above for why 'ptr.offset' isn't used\n                             cast::transmute(self.end as uint - 1)\n                         } else {\n-                            self.end.offset_inbounds(-1)\n+                            self.end.offset(-1)\n                         };\n                         Some(cast::transmute(self.end))\n                     }"}]}