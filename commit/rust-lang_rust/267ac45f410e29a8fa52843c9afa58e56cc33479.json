{"sha": "267ac45f410e29a8fa52843c9afa58e56cc33479", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI2N2FjNDVmNDEwZTI5YThmYTUyODQzYzlhZmE1OGU1NmNjMzM0Nzk=", "commit": {"author": {"name": "Chris Morgan", "email": "me@chrismorgan.info", "date": "2013-12-10T06:08:48Z"}, "committer": {"name": "Chris Morgan", "email": "me@chrismorgan.info", "date": "2013-12-10T22:52:05Z"}, "message": "Deduplicate in syntax::parse::token with a macro.\n\nI also renumbered things at the same time; ``in`` was shifted into its\nalphabetical position and the reserved keywords were reordered (a couple\nof them were out of order).", "tree": {"sha": "c0910278ccaf1e7cc1f7bd719e84f8d3c1eeba6f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c0910278ccaf1e7cc1f7bd719e84f8d3c1eeba6f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/267ac45f410e29a8fa52843c9afa58e56cc33479", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/267ac45f410e29a8fa52843c9afa58e56cc33479", "html_url": "https://github.com/rust-lang/rust/commit/267ac45f410e29a8fa52843c9afa58e56cc33479", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/267ac45f410e29a8fa52843c9afa58e56cc33479/comments", "author": {"login": "chris-morgan", "id": 392868, "node_id": "MDQ6VXNlcjM5Mjg2OA==", "avatar_url": "https://avatars.githubusercontent.com/u/392868?v=4", "gravatar_id": "", "url": "https://api.github.com/users/chris-morgan", "html_url": "https://github.com/chris-morgan", "followers_url": "https://api.github.com/users/chris-morgan/followers", "following_url": "https://api.github.com/users/chris-morgan/following{/other_user}", "gists_url": "https://api.github.com/users/chris-morgan/gists{/gist_id}", "starred_url": "https://api.github.com/users/chris-morgan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/chris-morgan/subscriptions", "organizations_url": "https://api.github.com/users/chris-morgan/orgs", "repos_url": "https://api.github.com/users/chris-morgan/repos", "events_url": "https://api.github.com/users/chris-morgan/events{/privacy}", "received_events_url": "https://api.github.com/users/chris-morgan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "chris-morgan", "id": 392868, "node_id": "MDQ6VXNlcjM5Mjg2OA==", "avatar_url": "https://avatars.githubusercontent.com/u/392868?v=4", "gravatar_id": "", "url": "https://api.github.com/users/chris-morgan", "html_url": "https://github.com/chris-morgan", "followers_url": "https://api.github.com/users/chris-morgan/followers", "following_url": "https://api.github.com/users/chris-morgan/following{/other_user}", "gists_url": "https://api.github.com/users/chris-morgan/gists{/gist_id}", "starred_url": "https://api.github.com/users/chris-morgan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/chris-morgan/subscriptions", "organizations_url": "https://api.github.com/users/chris-morgan/orgs", "repos_url": "https://api.github.com/users/chris-morgan/repos", "events_url": "https://api.github.com/users/chris-morgan/events{/privacy}", "received_events_url": "https://api.github.com/users/chris-morgan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "29ca4350c8d64facb39311660e8ee919766f481a", "url": "https://api.github.com/repos/rust-lang/rust/commits/29ca4350c8d64facb39311660e8ee919766f481a", "html_url": "https://github.com/rust-lang/rust/commit/29ca4350c8d64facb39311660e8ee919766f481a"}], "stats": {"total": 454, "additions": 183, "deletions": 271}, "files": [{"sha": "83ae92ff5ada5e50a6c984073429ba15a610e5a7", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 183, "deletions": 271, "changes": 454, "blob_url": "https://github.com/rust-lang/rust/blob/267ac45f410e29a8fa52843c9afa58e56cc33479/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/267ac45f410e29a8fa52843c9afa58e56cc33479/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=267ac45f410e29a8fa52843c9afa58e56cc33479", "patch": "@@ -316,72 +316,188 @@ pub fn is_bar(t: &Token) -> bool {\n     match *t { BINOP(OR) | OROR => true, _ => false }\n }\n \n-pub mod special_idents {\n-    use ast::Ident;\n-\n-    pub static underscore : Ident = Ident { name: 0, ctxt: 0}; // apparently unused?\n-    pub static anon : Ident = Ident { name: 1, ctxt: 0};\n-    pub static invalid : Ident = Ident { name: 2, ctxt: 0}; // ''\n-    pub static unary : Ident = Ident { name: 3, ctxt: 0}; // apparently unused?\n-    pub static not_fn : Ident = Ident { name: 4, ctxt: 0}; // apparently unused?\n-    pub static idx_fn : Ident = Ident { name: 5, ctxt: 0}; // apparently unused?\n-    pub static unary_minus_fn : Ident = Ident { name: 6, ctxt: 0}; // apparently unused?\n-    pub static clownshoes_extensions : Ident = Ident { name: 7, ctxt: 0};\n-\n-    pub static self_ : Ident = Ident { name: super::SELF_KEYWORD_NAME, ctxt: 0}; // 'self'\n-\n-    /* for matcher NTs */\n-    // none of these appear to be used, but perhaps references to\n-    // these are artificially fabricated by the macro system....\n-    pub static item : Ident = Ident { name: 9, ctxt: 0};\n-    pub static block : Ident = Ident { name: 10, ctxt: 0};\n-    pub static stmt : Ident = Ident { name: 11, ctxt: 0};\n-    pub static pat : Ident = Ident { name: 12, ctxt: 0};\n-    pub static expr : Ident = Ident { name: 13, ctxt: 0};\n-    pub static ty : Ident = Ident { name: 14, ctxt: 0};\n-    pub static ident : Ident = Ident { name: 15, ctxt: 0};\n-    pub static path : Ident = Ident { name: 16, ctxt: 0};\n-    pub static tt : Ident = Ident { name: 17, ctxt: 0};\n-    pub static matchers : Ident = Ident { name: 18, ctxt: 0};\n-\n-    pub static str : Ident = Ident { name: 19, ctxt: 0}; // for the type // apparently unused?\n-\n-    /* outside of libsyntax */\n-    pub static arg : Ident = Ident { name: 20, ctxt: 0};\n-    pub static descrim : Ident = Ident { name: 21, ctxt: 0};\n-    pub static clownshoe_abi : Ident = Ident { name: 22, ctxt: 0};\n-    pub static clownshoe_stack_shim : Ident = Ident { name: 23, ctxt: 0};\n-    pub static main : Ident = Ident { name: 24, ctxt: 0};\n-    pub static opaque : Ident = Ident { name: 25, ctxt: 0};\n-    pub static blk : Ident = Ident { name: 26, ctxt: 0};\n-    pub static statik : Ident = Ident { name: super::STATIC_KEYWORD_NAME, ctxt: 0};\n-    pub static clownshoes_foreign_mod: Ident = Ident { name: 28, ctxt: 0};\n-    pub static unnamed_field: Ident = Ident { name: 29, ctxt: 0};\n-    pub static c_abi: Ident = Ident { name: 30, ctxt: 0}; // apparently unused?\n-    pub static type_self: Ident = Ident { name: 31, ctxt: 0};    // `Self`\n-}\n-\n-// here are the ones that actually occur in the source. Maybe the rest\n-// should be removed?\n-/*\n-special_idents::anon\n-special_idents::arg\n-special_idents::blk\n-special_idents::clownshoe_abi\n-special_idents::clownshoe_stack_shim\n-special_idents::clownshoes_extensions\n-special_idents::clownshoes_foreign_mod\n-special_idents::descrim\n-special_idents::invalid\n-special_idents::main\n-special_idents::matchers\n-special_idents::opaque\n-special_idents::self_\n-special_idents::statik\n-special_idents::tt\n-special_idents::type_self\n-special_idents::unnamed_field\n-*/\n+// In this macro, there is the requirement that the name (the number) must be monotonically\n+// increasing by one in the special identifiers, starting at 0; the same holds for the keywords,\n+// except starting from the next number instead of zero, and with the additional exception that\n+// special identifiers are *also* allowed (they are deduplicated in the important place, the\n+// interner), an exception which is demonstrated by \"static\" and \"self\".\n+macro_rules! declare_special_idents_and_keywords {(\n+    // So now, in these rules, why is each definition parenthesised?\n+    // Answer: otherwise we get a spurious local ambiguity bug on the \"}\"\n+    pub mod special_idents {\n+        $( ($si_name:expr, $si_static:ident, $si_str:expr); )*\n+    }\n+\n+    pub mod keywords {\n+        $( ($k_name:expr, $k_variant:ident, $k_str:expr); )*\n+    }\n+) => {\n+    pub mod special_idents {\n+        use ast::Ident;\n+        $( pub static $si_static: Ident = Ident { name: $si_name, ctxt: 0 }; )*\n+    }\n+\n+    /**\n+     * All the valid words that have meaning in the Rust language.\n+     *\n+     * Rust keywords are either 'strict' or 'reserved'.  Strict keywords may not\n+     * appear as identifiers at all. Reserved keywords are not used anywhere in\n+     * the language and may not appear as identifiers.\n+     */\n+    pub mod keywords {\n+        use ast::Ident;\n+\n+        pub enum Keyword {\n+            $( $k_variant, )*\n+        }\n+\n+        impl Keyword {\n+            pub fn to_ident(&self) -> Ident {\n+                match *self {\n+                    $( $k_variant => Ident { name: $k_name, ctxt: 0 }, )*\n+                }\n+            }\n+        }\n+    }\n+\n+    fn mk_fresh_ident_interner() -> @ident_interner {\n+        // The indices here must correspond to the numbers in\n+        // special_idents, in Keyword to_ident(), and in static\n+        // constants below.\n+        let init_vec = ~[\n+            $( $si_str, )*\n+            $( $k_str, )*\n+        ];\n+\n+        @interner::StrInterner::prefill(init_vec)\n+    }\n+}}\n+\n+// If modifying the numbers below, remember to modify these as appropriate\n+static SELF_KEYWORD_NAME: Name = 8;\n+static STATIC_KEYWORD_NAME: Name = 27;\n+static STRICT_KEYWORD_START: Name = 32;\n+static STRICT_KEYWORD_FINAL: Name = 65;\n+static RESERVED_KEYWORD_START: Name = 66;\n+static RESERVED_KEYWORD_FINAL: Name = 72;\n+\n+declare_special_idents_and_keywords! {\n+    pub mod special_idents {\n+        // These ones are statics\n+        (0,                          underscore,             \"_\");      // apparently unused?\n+        (1,                          anon,                   \"anon\");\n+        (2,                          invalid,                \"\");       // ''\n+        (3,                          unary,                  \"unary\");  // apparently unused?\n+        (4,                          not_fn,                 \"!\");      // apparently unused?\n+        (5,                          idx_fn,                 \"[]\");     // apparently unused?\n+        (6,                          unary_minus_fn,         \"unary-\"); // apparently unused?\n+        (7,                          clownshoes_extensions,  \"__extensions__\");\n+\n+        (super::SELF_KEYWORD_NAME,   self_,                  \"self\"); // 'self'\n+\n+        /* for matcher NTs */\n+        // none of these appear to be used, but perhaps references to\n+        // these are artificially fabricated by the macro system....\n+        (9,                          item,                   \"item\");\n+        (10,                         block,                  \"block\");\n+        (11,                         stmt,                   \"stmt\");\n+        (12,                         pat,                    \"pat\");\n+        (13,                         expr,                   \"expr\");\n+        (14,                         ty,                     \"ty\");\n+        (15,                         ident,                  \"ident\");\n+        (16,                         path,                   \"path\");\n+        (17,                         tt,                     \"tt\");\n+        (18,                         matchers,               \"matchers\");\n+\n+        // for the type // apparently unused?\n+        (19,                         str,                    \"str\");\n+\n+        /* outside of libsyntax */\n+        (20,                         arg,                    \"arg\");\n+        (21,                         descrim,                \"descrim\");\n+        (22,                         clownshoe_abi,          \"__rust_abi\");\n+        (23,                         clownshoe_stack_shim,   \"__rust_stack_shim\");\n+        (24,                         main,                   \"main\");\n+        (25,                         opaque,                 \"<opaque>\");\n+        (26,                         blk,                    \"blk\");\n+        (super::STATIC_KEYWORD_NAME, statik,                 \"static\");\n+        (28,                         clownshoes_foreign_mod, \"__foreign_mod__\");\n+        (29,                         unnamed_field,          \"<unnamed_field>\");\n+        (30,                         c_abi,                  \"C\"); // apparently unused?\n+        (31,                         type_self,              \"Self\"); // `Self`\n+\n+        // here are the ones that actually occur in the source. Maybe the rest\n+        // should be removed?\n+        /*\n+        special_idents::anon\n+        special_idents::arg\n+        special_idents::blk\n+        special_idents::clownshoe_abi\n+        special_idents::clownshoe_stack_shim\n+        special_idents::clownshoes_extensions\n+        special_idents::clownshoes_foreign_mod\n+        special_idents::descrim\n+        special_idents::invalid\n+        special_idents::main\n+        special_idents::matchers\n+        special_idents::opaque\n+        special_idents::self_\n+        special_idents::statik\n+        special_idents::tt\n+        special_idents::type_self\n+        special_idents::unnamed_field\n+        */\n+    }\n+\n+    pub mod keywords {\n+        // These ones are variants of the Keyword enum\n+        (32,                         As,         \"as\");\n+        (33,                         Break,      \"break\");\n+        (34,                         Const,      \"const\");\n+        (35,                         Do,         \"do\");\n+        (36,                         Else,       \"else\");\n+        (37,                         Enum,       \"enum\");\n+        (38,                         Extern,     \"extern\");\n+        (39,                         False,      \"false\");\n+        (40,                         Fn,         \"fn\");\n+        (41,                         For,        \"for\");\n+        (42,                         If,         \"if\");\n+        (43,                         Impl,       \"impl\");\n+        (44,                         In,         \"in\");\n+        (45,                         Let,        \"let\");\n+        (46,                         __LogLevel, \"__log_level\");\n+        (47,                         Loop,       \"loop\");\n+        (48,                         Match,      \"match\");\n+        (49,                         Mod,        \"mod\");\n+        (50,                         Mut,        \"mut\");\n+        (51,                         Once,       \"once\");\n+        (52,                         Priv,       \"priv\");\n+        (53,                         Pub,        \"pub\");\n+        (54,                         Ref,        \"ref\");\n+        (55,                         Return,     \"return\");\n+        // Static and Self are also special idents (prefill de-dupes)\n+        (super::STATIC_KEYWORD_NAME, Static,     \"static\");\n+        (super::SELF_KEYWORD_NAME,   Self,       \"self\");\n+        (56,                         Struct,     \"struct\");\n+        (57,                         Super,      \"super\");\n+        (58,                         True,       \"true\");\n+        (59,                         Trait,      \"trait\");\n+        (60,                         Type,       \"type\");\n+        (61,                         Unsafe,     \"unsafe\");\n+        (62,                         Use,        \"use\");\n+        (63,                         While,      \"while\");\n+        (64,                         Continue,   \"continue\");\n+        (65,                         Proc,       \"proc\");\n+\n+        (66,                         Alignof,    \"alignof\");\n+        (67,                         Be,         \"be\");\n+        (68,                         Offsetof,   \"offsetof\");\n+        (69,                         Pure,       \"pure\");\n+        (70,                         Sizeof,     \"sizeof\");\n+        (71,                         Typeof,     \"typeof\");\n+        (72,                         Yield,      \"yield\");\n+    }\n+}\n \n /**\n  * Maps a token to a record specifying the corresponding binary\n@@ -414,101 +530,6 @@ pub fn token_to_binop(tok: &Token) -> Option<ast::BinOp> {\n // looks like we can get rid of this completely...\n pub type ident_interner = StrInterner;\n \n-// return a fresh interner, preloaded with special identifiers.\n-fn mk_fresh_ident_interner() -> @ident_interner {\n-    // The indices here must correspond to the numbers in\n-    // special_idents, in Keyword to_ident(), and in static\n-    // constants below.\n-    let init_vec = ~[\n-        \"_\",                  // 0\n-        \"anon\",               // 1\n-        \"\",                   // 2\n-        \"unary\",              // 3\n-        \"!\",                  // 4\n-        \"[]\",                 // 5\n-        \"unary-\",             // 6\n-        \"__extensions__\",     // 7\n-        \"self\",               // 8\n-        \"item\",               // 9\n-        \"block\",              // 10\n-        \"stmt\",               // 11\n-        \"pat\",                // 12\n-        \"expr\",               // 13\n-        \"ty\",                 // 14\n-        \"ident\",              // 15\n-        \"path\",               // 16\n-        \"tt\",                 // 17\n-        \"matchers\",           // 18\n-        \"str\",                // 19\n-        \"arg\",                // 20\n-        \"descrim\",            // 21\n-        \"__rust_abi\",         // 22\n-        \"__rust_stack_shim\",  // 23\n-        \"main\",               // 24\n-        \"<opaque>\",           // 25\n-        \"blk\",                // 26\n-        \"static\",             // 27\n-        \"__foreign_mod__\",    // 28\n-        \"<unnamed_field>\",    // 29\n-        \"C\",                  // 30\n-        \"Self\",               // 31\n-\n-        \"as\",                 // 32\n-        \"break\",              // 33\n-        \"const\",              // 34\n-        \"do\",                 // 35\n-        \"else\",               // 36\n-        \"enum\",               // 37\n-        \"extern\",             // 38\n-        \"false\",              // 39\n-        \"fn\",                 // 40\n-        \"for\",                // 41\n-        \"if\",                 // 42\n-        \"impl\",               // 43\n-        \"let\",                // 44\n-        \"__log_level\",        // 45\n-        \"loop\",               // 46\n-        \"match\",              // 47\n-        \"mod\",                // 48\n-        \"mut\",                // 49\n-        \"once\",               // 50\n-        \"priv\",               // 51\n-        \"pub\",                // 52\n-        \"ref\",                // 53\n-        \"return\",             // 54\n-        \"static\",             // 27 -- also a special ident (prefill de-dupes)\n-        \"self\",               //  8 -- also a special ident (prefill de-dupes)\n-        \"struct\",             // 55\n-        \"super\",              // 56\n-        \"true\",               // 57\n-        \"trait\",              // 58\n-        \"type\",               // 59\n-        \"unsafe\",             // 60\n-        \"use\",                // 61\n-        \"while\",              // 62\n-        \"in\",                 // 63\n-        \"continue\",           // 64\n-        \"proc\",               // 65\n-\n-        \"be\",                 // 66\n-        \"pure\",               // 67\n-        \"yield\",              // 68\n-        \"typeof\",             // 69\n-        \"alignof\",            // 70\n-        \"offsetof\",           // 71\n-        \"sizeof\",             // 72\n-    ];\n-\n-    @interner::StrInterner::prefill(init_vec)\n-}\n-\n-static SELF_KEYWORD_NAME: Name = 8;\n-static STATIC_KEYWORD_NAME: Name = 27;\n-static STRICT_KEYWORD_START: Name = 32;\n-static STRICT_KEYWORD_FINAL: Name = 65;\n-static RESERVED_KEYWORD_START: Name = 66;\n-static RESERVED_KEYWORD_FINAL: Name = 72;\n-\n // if an interner exists in TLS, return it. Otherwise, prepare a\n // fresh one.\n pub fn get_ident_interner() -> @ident_interner {\n@@ -601,116 +622,7 @@ pub fn fresh_mark() -> Mrk {\n     gensym(\"mark\")\n }\n \n-/**\n- * All the valid words that have meaning in the Rust language.\n- *\n- * Rust keywords are either 'strict' or 'reserved'.  Strict keywords may not\n- * appear as identifiers at all. Reserved keywords are not used anywhere in\n- * the language and may not appear as identifiers.\n- */\n-pub mod keywords {\n-    use ast::Ident;\n-\n-    pub enum Keyword {\n-        // Strict keywords\n-        As,\n-        Break,\n-        Const,\n-        Do,\n-        Else,\n-        Enum,\n-        Extern,\n-        False,\n-        Fn,\n-        For,\n-        If,\n-        Impl,\n-        In,\n-        Let,\n-        __LogLevel,\n-        Loop,\n-        Match,\n-        Mod,\n-        Mut,\n-        Once,\n-        Priv,\n-        Pub,\n-        Ref,\n-        Return,\n-        Static,\n-        Self,\n-        Struct,\n-        Super,\n-        True,\n-        Trait,\n-        Type,\n-        Unsafe,\n-        Use,\n-        While,\n-        Continue,\n-        Proc,\n-\n-        // Reserved keywords\n-        Alignof,\n-        Be,\n-        Offsetof,\n-        Pure,\n-        Sizeof,\n-        Typeof,\n-        Yield,\n-    }\n-\n-    impl Keyword {\n-        pub fn to_ident(&self) -> Ident {\n-            match *self {\n-                As => Ident { name: 32, ctxt: 0 },\n-                Break => Ident { name: 33, ctxt: 0 },\n-                Const => Ident { name: 34, ctxt: 0 },\n-                Do => Ident { name: 35, ctxt: 0 },\n-                Else => Ident { name: 36, ctxt: 0 },\n-                Enum => Ident { name: 37, ctxt: 0 },\n-                Extern => Ident { name: 38, ctxt: 0 },\n-                False => Ident { name: 39, ctxt: 0 },\n-                Fn => Ident { name: 40, ctxt: 0 },\n-                For => Ident { name: 41, ctxt: 0 },\n-                If => Ident { name: 42, ctxt: 0 },\n-                Impl => Ident { name: 43, ctxt: 0 },\n-                In => Ident { name: 63, ctxt: 0 },\n-                Let => Ident { name: 44, ctxt: 0 },\n-                __LogLevel => Ident { name: 45, ctxt: 0 },\n-                Loop => Ident { name: 46, ctxt: 0 },\n-                Match => Ident { name: 47, ctxt: 0 },\n-                Mod => Ident { name: 48, ctxt: 0 },\n-                Mut => Ident { name: 49, ctxt: 0 },\n-                Once => Ident { name: 50, ctxt: 0 },\n-                Priv => Ident { name: 51, ctxt: 0 },\n-                Pub => Ident { name: 52, ctxt: 0 },\n-                Ref => Ident { name: 53, ctxt: 0 },\n-                Return => Ident { name: 54, ctxt: 0 },\n-                Static => Ident { name: super::STATIC_KEYWORD_NAME, ctxt: 0 },\n-                Self => Ident { name: super::SELF_KEYWORD_NAME, ctxt: 0 },\n-                Struct => Ident { name: 55, ctxt: 0 },\n-                Super => Ident { name: 56, ctxt: 0 },\n-                True => Ident { name: 57, ctxt: 0 },\n-                Trait => Ident { name: 58, ctxt: 0 },\n-                Type => Ident { name: 59, ctxt: 0 },\n-                Unsafe => Ident { name: 60, ctxt: 0 },\n-                Use => Ident { name: 61, ctxt: 0 },\n-                While => Ident { name: 62, ctxt: 0 },\n-                Continue => Ident { name: 64, ctxt: 0 },\n-                Proc => Ident { name: 65, ctxt: 0 },\n-\n-                Alignof => Ident { name: 70, ctxt: 0 },\n-                Be => Ident { name: 66, ctxt: 0 },\n-                Offsetof => Ident { name: 71, ctxt: 0 },\n-                Pure => Ident { name: 67, ctxt: 0 },\n-                Sizeof => Ident { name: 72, ctxt: 0 },\n-                Typeof => Ident { name: 69, ctxt: 0 },\n-                Yield => Ident { name: 68, ctxt: 0 },\n-            }\n-        }\n-    }\n-}\n+// See the macro above about the types of keywords\n \n pub fn is_keyword(kw: keywords::Keyword, tok: &Token) -> bool {\n     match *tok {"}]}