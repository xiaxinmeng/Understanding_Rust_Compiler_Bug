{"sha": "5f87ee0ab1bcbf708d27e928296cb44ce9ba9c5f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVmODdlZTBhYjFiY2JmNzA4ZDI3ZTkyODI5NmNiNDRjZTliYTljNWY=", "commit": {"author": {"name": "Yuki Okushi", "email": "huyuumi.dev@gmail.com", "date": "2020-08-05T02:40:10Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-08-05T02:40:10Z"}, "message": "Rollup merge of #75152 - TimDiekmann:replace_memblock, r=Amanieu\n\nReplace `Memoryblock` with `NonNull<[u8]>`\n\nCloses rust-lang/wg-allocators#61\n\nr? @Amanieu", "tree": {"sha": "083a7688350f0954df58f645179b23f0ee033f64", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/083a7688350f0954df58f645179b23f0ee033f64"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5f87ee0ab1bcbf708d27e928296cb44ce9ba9c5f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfKhwKCRBK7hj4Ov3rIwAAdHIIAJQFOQvBEKqT4SzwO3++RsgC\npMOaTSDtpJs0RQ/xl13ZMJu9ZX63zsYKcLgRu8rn8mNu7WNW5CQWp1jkkNA3qVSp\nlZNTw0GnkaNCfgfRBSAec27yvwULo0NLOWbcsbJFmWAuW3pS9vIpGYB2j0GRe+Ln\nc261rLTuyzinpOkVFoBcJuWSpADOYoUSDRd4k4ucF1De6Y9KCcjOAD5AQNPJ85is\n6twqz9uoOpB0PfUi2vkqx7WVw1+8fU7mQyJEoKQ/sxlQe4Nwj7lmpumSJUgOvD/y\nrvy4MJ0rh8H+K1wQizYPZqPJPYUZLShEwCXnko0D+bY1f5c+lTP1BOw5oVp8tQQ=\n=0Ymj\n-----END PGP SIGNATURE-----\n", "payload": "tree 083a7688350f0954df58f645179b23f0ee033f64\nparent 7123daff5359dc3ebabcf4d1e00b085c27455877\nparent 93d98328d161bcdf002f9d2f7f916f01c6fce3b1\nauthor Yuki Okushi <huyuumi.dev@gmail.com> 1596595210 +0900\ncommitter GitHub <noreply@github.com> 1596595210 +0900\n\nRollup merge of #75152 - TimDiekmann:replace_memblock, r=Amanieu\n\nReplace `Memoryblock` with `NonNull<[u8]>`\n\nCloses rust-lang/wg-allocators#61\n\nr? @Amanieu\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5f87ee0ab1bcbf708d27e928296cb44ce9ba9c5f", "html_url": "https://github.com/rust-lang/rust/commit/5f87ee0ab1bcbf708d27e928296cb44ce9ba9c5f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5f87ee0ab1bcbf708d27e928296cb44ce9ba9c5f/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7123daff5359dc3ebabcf4d1e00b085c27455877", "url": "https://api.github.com/repos/rust-lang/rust/commits/7123daff5359dc3ebabcf4d1e00b085c27455877", "html_url": "https://github.com/rust-lang/rust/commit/7123daff5359dc3ebabcf4d1e00b085c27455877"}, {"sha": "93d98328d161bcdf002f9d2f7f916f01c6fce3b1", "url": "https://api.github.com/repos/rust-lang/rust/commits/93d98328d161bcdf002f9d2f7f916f01c6fce3b1", "html_url": "https://github.com/rust-lang/rust/commit/93d98328d161bcdf002f9d2f7f916f01c6fce3b1"}], "stats": {"total": 255, "additions": 135, "deletions": 120}, "files": [{"sha": "518ac11b5a009850d07869b8d182ba4b483680ee", "filename": "library/alloc/src/alloc.rs", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/5f87ee0ab1bcbf708d27e928296cb44ce9ba9c5f/library%2Falloc%2Fsrc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f87ee0ab1bcbf708d27e928296cb44ce9ba9c5f/library%2Falloc%2Fsrc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Falloc.rs?ref=5f87ee0ab1bcbf708d27e928296cb44ce9ba9c5f", "patch": "@@ -164,27 +164,27 @@ pub unsafe fn alloc_zeroed(layout: Layout) -> *mut u8 {\n #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n unsafe impl AllocRef for Global {\n     #[inline]\n-    fn alloc(&mut self, layout: Layout) -> Result<MemoryBlock, AllocErr> {\n+    fn alloc(&mut self, layout: Layout) -> Result<NonNull<[u8]>, AllocErr> {\n         let size = layout.size();\n         let ptr = if size == 0 {\n             layout.dangling()\n         } else {\n             // SAFETY: `layout` is non-zero in size,\n             unsafe { NonNull::new(alloc(layout)).ok_or(AllocErr)? }\n         };\n-        Ok(MemoryBlock { ptr, size })\n+        Ok(NonNull::slice_from_raw_parts(ptr, size))\n     }\n \n     #[inline]\n-    fn alloc_zeroed(&mut self, layout: Layout) -> Result<MemoryBlock, AllocErr> {\n+    fn alloc_zeroed(&mut self, layout: Layout) -> Result<NonNull<[u8]>, AllocErr> {\n         let size = layout.size();\n         let ptr = if size == 0 {\n             layout.dangling()\n         } else {\n             // SAFETY: `layout` is non-zero in size,\n             unsafe { NonNull::new(alloc_zeroed(layout)).ok_or(AllocErr)? }\n         };\n-        Ok(MemoryBlock { ptr, size })\n+        Ok(NonNull::slice_from_raw_parts(ptr, size))\n     }\n \n     #[inline]\n@@ -202,7 +202,7 @@ unsafe impl AllocRef for Global {\n         ptr: NonNull<u8>,\n         layout: Layout,\n         new_size: usize,\n-    ) -> Result<MemoryBlock, AllocErr> {\n+    ) -> Result<NonNull<[u8]>, AllocErr> {\n         debug_assert!(\n             new_size >= layout.size(),\n             \"`new_size` must be greater than or equal to `layout.size()`\"\n@@ -212,14 +212,16 @@ unsafe impl AllocRef for Global {\n         // Other conditions must be upheld by the caller\n         unsafe {\n             match layout.size() {\n-                old_size if old_size == new_size => Ok(MemoryBlock { ptr, size: new_size }),\n+                old_size if old_size == new_size => {\n+                    Ok(NonNull::slice_from_raw_parts(ptr, new_size))\n+                }\n                 0 => self.alloc(Layout::from_size_align_unchecked(new_size, layout.align())),\n                 old_size => {\n                     // `realloc` probably checks for `new_size > size` or something similar.\n                     intrinsics::assume(new_size > old_size);\n                     let raw_ptr = realloc(ptr.as_ptr(), layout, new_size);\n                     let ptr = NonNull::new(raw_ptr).ok_or(AllocErr)?;\n-                    Ok(MemoryBlock { ptr, size: new_size })\n+                    Ok(NonNull::slice_from_raw_parts(ptr, new_size))\n                 }\n             }\n         }\n@@ -231,7 +233,7 @@ unsafe impl AllocRef for Global {\n         ptr: NonNull<u8>,\n         layout: Layout,\n         new_size: usize,\n-    ) -> Result<MemoryBlock, AllocErr> {\n+    ) -> Result<NonNull<[u8]>, AllocErr> {\n         debug_assert!(\n             new_size >= layout.size(),\n             \"`new_size` must be greater than or equal to `layout.size()`\"\n@@ -241,15 +243,17 @@ unsafe impl AllocRef for Global {\n         // Other conditions must be upheld by the caller\n         unsafe {\n             match layout.size() {\n-                old_size if old_size == new_size => Ok(MemoryBlock { ptr, size: new_size }),\n+                old_size if old_size == new_size => {\n+                    Ok(NonNull::slice_from_raw_parts(ptr, new_size))\n+                }\n                 0 => self.alloc_zeroed(Layout::from_size_align_unchecked(new_size, layout.align())),\n                 old_size => {\n                     // `realloc` probably checks for `new_size > size` or something similar.\n                     intrinsics::assume(new_size > old_size);\n                     let raw_ptr = realloc(ptr.as_ptr(), layout, new_size);\n                     raw_ptr.add(old_size).write_bytes(0, new_size - old_size);\n                     let ptr = NonNull::new(raw_ptr).ok_or(AllocErr)?;\n-                    Ok(MemoryBlock { ptr, size: new_size })\n+                    Ok(NonNull::slice_from_raw_parts(ptr, new_size))\n                 }\n             }\n         }\n@@ -261,7 +265,7 @@ unsafe impl AllocRef for Global {\n         ptr: NonNull<u8>,\n         layout: Layout,\n         new_size: usize,\n-    ) -> Result<MemoryBlock, AllocErr> {\n+    ) -> Result<NonNull<[u8]>, AllocErr> {\n         let old_size = layout.size();\n         debug_assert!(\n             new_size <= old_size,\n@@ -288,7 +292,7 @@ unsafe impl AllocRef for Global {\n             NonNull::new(raw_ptr).ok_or(AllocErr)?\n         };\n \n-        Ok(MemoryBlock { ptr, size: new_size })\n+        Ok(NonNull::slice_from_raw_parts(ptr, new_size))\n     }\n }\n \n@@ -300,7 +304,7 @@ unsafe impl AllocRef for Global {\n unsafe fn exchange_malloc(size: usize, align: usize) -> *mut u8 {\n     let layout = unsafe { Layout::from_size_align_unchecked(size, align) };\n     match Global.alloc(layout) {\n-        Ok(memory) => memory.ptr.as_ptr(),\n+        Ok(ptr) => ptr.as_non_null_ptr().as_ptr(),\n         Err(_) => handle_alloc_error(layout),\n     }\n }"}, {"sha": "f7463d0daac93ad9fb9876c3e286c5ccd38d682e", "filename": "library/alloc/src/alloc/tests.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5f87ee0ab1bcbf708d27e928296cb44ce9ba9c5f/library%2Falloc%2Fsrc%2Falloc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f87ee0ab1bcbf708d27e928296cb44ce9ba9c5f/library%2Falloc%2Fsrc%2Falloc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Falloc%2Ftests.rs?ref=5f87ee0ab1bcbf708d27e928296cb44ce9ba9c5f", "patch": "@@ -8,16 +8,16 @@ use test::Bencher;\n fn allocate_zeroed() {\n     unsafe {\n         let layout = Layout::from_size_align(1024, 1).unwrap();\n-        let memory =\n+        let ptr =\n             Global.alloc_zeroed(layout.clone()).unwrap_or_else(|_| handle_alloc_error(layout));\n \n-        let mut i = memory.ptr.cast::<u8>().as_ptr();\n+        let mut i = ptr.as_non_null_ptr().as_ptr();\n         let end = i.add(layout.size());\n         while i < end {\n             assert_eq!(*i, 0);\n             i = i.offset(1);\n         }\n-        Global.dealloc(memory.ptr, layout);\n+        Global.dealloc(ptr.as_non_null_ptr(), layout);\n     }\n }\n "}, {"sha": "5e304beff78ab1cb469ce5bdab2e24a2004e4407", "filename": "library/alloc/src/boxed.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f87ee0ab1bcbf708d27e928296cb44ce9ba9c5f/library%2Falloc%2Fsrc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f87ee0ab1bcbf708d27e928296cb44ce9ba9c5f/library%2Falloc%2Fsrc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fboxed.rs?ref=5f87ee0ab1bcbf708d27e928296cb44ce9ba9c5f", "patch": "@@ -197,8 +197,7 @@ impl<T> Box<T> {\n     #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n     pub fn new_uninit() -> Box<mem::MaybeUninit<T>> {\n         let layout = alloc::Layout::new::<mem::MaybeUninit<T>>();\n-        let ptr =\n-            Global.alloc(layout).unwrap_or_else(|_| alloc::handle_alloc_error(layout)).ptr.cast();\n+        let ptr = Global.alloc(layout).unwrap_or_else(|_| alloc::handle_alloc_error(layout)).cast();\n         unsafe { Box::from_raw(ptr.as_ptr()) }\n     }\n \n@@ -226,7 +225,6 @@ impl<T> Box<T> {\n         let ptr = Global\n             .alloc_zeroed(layout)\n             .unwrap_or_else(|_| alloc::handle_alloc_error(layout))\n-            .ptr\n             .cast();\n         unsafe { Box::from_raw(ptr.as_ptr()) }\n     }"}, {"sha": "9ac23886d4e15666c6b871f3e9fe1263784d91fe", "filename": "library/alloc/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5f87ee0ab1bcbf708d27e928296cb44ce9ba9c5f/library%2Falloc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f87ee0ab1bcbf708d27e928296cb44ce9ba9c5f/library%2Falloc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Flib.rs?ref=5f87ee0ab1bcbf708d27e928296cb44ce9ba9c5f", "patch": "@@ -104,6 +104,7 @@\n #![feature(negative_impls)]\n #![feature(new_uninit)]\n #![feature(nll)]\n+#![feature(nonnull_slice_from_raw_parts)]\n #![feature(optin_builtin_traits)]\n #![feature(or_patterns)]\n #![feature(pattern)]\n@@ -113,6 +114,8 @@\n #![feature(rustc_attrs)]\n #![feature(receiver_trait)]\n #![feature(min_specialization)]\n+#![feature(slice_ptr_get)]\n+#![feature(slice_ptr_len)]\n #![feature(staged_api)]\n #![feature(std_internals)]\n #![feature(str_internals)]"}, {"sha": "2abd7231711f3c4ebfeec9c53d78c8d444f809bd", "filename": "library/alloc/src/raw_vec.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/5f87ee0ab1bcbf708d27e928296cb44ce9ba9c5f/library%2Falloc%2Fsrc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f87ee0ab1bcbf708d27e928296cb44ce9ba9c5f/library%2Falloc%2Fsrc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fraw_vec.rs?ref=5f87ee0ab1bcbf708d27e928296cb44ce9ba9c5f", "patch": "@@ -1,7 +1,7 @@\n #![unstable(feature = \"raw_vec_internals\", reason = \"implementation detail\", issue = \"none\")]\n #![doc(hidden)]\n \n-use core::alloc::{LayoutErr, MemoryBlock};\n+use core::alloc::LayoutErr;\n use core::cmp;\n use core::mem::{self, ManuallyDrop, MaybeUninit};\n use core::ops::Drop;\n@@ -186,14 +186,14 @@ impl<T, A: AllocRef> RawVec<T, A> {\n                 AllocInit::Uninitialized => alloc.alloc(layout),\n                 AllocInit::Zeroed => alloc.alloc_zeroed(layout),\n             };\n-            let memory = match result {\n-                Ok(memory) => memory,\n+            let ptr = match result {\n+                Ok(ptr) => ptr,\n                 Err(_) => handle_alloc_error(layout),\n             };\n \n             Self {\n-                ptr: unsafe { Unique::new_unchecked(memory.ptr.cast().as_ptr()) },\n-                cap: Self::capacity_from_bytes(memory.size),\n+                ptr: unsafe { Unique::new_unchecked(ptr.cast().as_ptr()) },\n+                cap: Self::capacity_from_bytes(ptr.len()),\n                 alloc,\n             }\n         }\n@@ -384,9 +384,9 @@ impl<T, A: AllocRef> RawVec<T, A> {\n         excess / mem::size_of::<T>()\n     }\n \n-    fn set_memory(&mut self, memory: MemoryBlock) {\n-        self.ptr = unsafe { Unique::new_unchecked(memory.ptr.cast().as_ptr()) };\n-        self.cap = Self::capacity_from_bytes(memory.size);\n+    fn set_ptr(&mut self, ptr: NonNull<[u8]>) {\n+        self.ptr = unsafe { Unique::new_unchecked(ptr.cast().as_ptr()) };\n+        self.cap = Self::capacity_from_bytes(ptr.len());\n     }\n \n     // This method is usually instantiated many times. So we want it to be as\n@@ -432,8 +432,8 @@ impl<T, A: AllocRef> RawVec<T, A> {\n         let new_layout = Layout::array::<T>(cap);\n \n         // `finish_grow` is non-generic over `T`.\n-        let memory = finish_grow(new_layout, self.current_memory(), &mut self.alloc)?;\n-        self.set_memory(memory);\n+        let ptr = finish_grow(new_layout, self.current_memory(), &mut self.alloc)?;\n+        self.set_ptr(ptr);\n         Ok(())\n     }\n \n@@ -451,8 +451,8 @@ impl<T, A: AllocRef> RawVec<T, A> {\n         let new_layout = Layout::array::<T>(cap);\n \n         // `finish_grow` is non-generic over `T`.\n-        let memory = finish_grow(new_layout, self.current_memory(), &mut self.alloc)?;\n-        self.set_memory(memory);\n+        let ptr = finish_grow(new_layout, self.current_memory(), &mut self.alloc)?;\n+        self.set_ptr(ptr);\n         Ok(())\n     }\n \n@@ -462,13 +462,13 @@ impl<T, A: AllocRef> RawVec<T, A> {\n         let (ptr, layout) = if let Some(mem) = self.current_memory() { mem } else { return Ok(()) };\n         let new_size = amount * mem::size_of::<T>();\n \n-        let memory = unsafe {\n+        let ptr = unsafe {\n             self.alloc.shrink(ptr, layout, new_size).map_err(|_| TryReserveError::AllocError {\n                 layout: Layout::from_size_align_unchecked(new_size, layout.align()),\n                 non_exhaustive: (),\n             })?\n         };\n-        self.set_memory(memory);\n+        self.set_ptr(ptr);\n         Ok(())\n     }\n }\n@@ -481,7 +481,7 @@ fn finish_grow<A>(\n     new_layout: Result<Layout, LayoutErr>,\n     current_memory: Option<(NonNull<u8>, Layout)>,\n     alloc: &mut A,\n-) -> Result<MemoryBlock, TryReserveError>\n+) -> Result<NonNull<[u8]>, TryReserveError>\n where\n     A: AllocRef,\n {"}, {"sha": "cadd913aa6bf244f1f6e9bc530dd069dcc002a36", "filename": "library/alloc/src/raw_vec/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f87ee0ab1bcbf708d27e928296cb44ce9ba9c5f/library%2Falloc%2Fsrc%2Fraw_vec%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f87ee0ab1bcbf708d27e928296cb44ce9ba9c5f/library%2Falloc%2Fsrc%2Fraw_vec%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fraw_vec%2Ftests.rs?ref=5f87ee0ab1bcbf708d27e928296cb44ce9ba9c5f", "patch": "@@ -20,7 +20,7 @@ fn allocator_param() {\n         fuel: usize,\n     }\n     unsafe impl AllocRef for BoundedAlloc {\n-        fn alloc(&mut self, layout: Layout) -> Result<MemoryBlock, AllocErr> {\n+        fn alloc(&mut self, layout: Layout) -> Result<NonNull<[u8]>, AllocErr> {\n             let size = layout.size();\n             if size > self.fuel {\n                 return Err(AllocErr);"}, {"sha": "d0a47ccea0a76f96fabc05773bb226bd74d69a37", "filename": "library/alloc/src/rc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f87ee0ab1bcbf708d27e928296cb44ce9ba9c5f/library%2Falloc%2Fsrc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f87ee0ab1bcbf708d27e928296cb44ce9ba9c5f/library%2Falloc%2Fsrc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Frc.rs?ref=5f87ee0ab1bcbf708d27e928296cb44ce9ba9c5f", "patch": "@@ -928,10 +928,10 @@ impl<T: ?Sized> Rc<T> {\n         let layout = Layout::new::<RcBox<()>>().extend(value_layout).unwrap().0.pad_to_align();\n \n         // Allocate for the layout.\n-        let mem = Global.alloc(layout).unwrap_or_else(|_| handle_alloc_error(layout));\n+        let ptr = Global.alloc(layout).unwrap_or_else(|_| handle_alloc_error(layout));\n \n         // Initialize the RcBox\n-        let inner = mem_to_rcbox(mem.ptr.as_ptr());\n+        let inner = mem_to_rcbox(ptr.as_non_null_ptr().as_ptr());\n         unsafe {\n             debug_assert_eq!(Layout::for_value(&*inner), layout);\n "}, {"sha": "b37633031375883844506603a0e2c2872c699a09", "filename": "library/alloc/src/sync.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5f87ee0ab1bcbf708d27e928296cb44ce9ba9c5f/library%2Falloc%2Fsrc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f87ee0ab1bcbf708d27e928296cb44ce9ba9c5f/library%2Falloc%2Fsrc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fsync.rs?ref=5f87ee0ab1bcbf708d27e928296cb44ce9ba9c5f", "patch": "@@ -883,10 +883,10 @@ impl<T: ?Sized> Arc<T> {\n         // reference (see #54908).\n         let layout = Layout::new::<ArcInner<()>>().extend(value_layout).unwrap().0.pad_to_align();\n \n-        let mem = Global.alloc(layout).unwrap_or_else(|_| handle_alloc_error(layout));\n+        let ptr = Global.alloc(layout).unwrap_or_else(|_| handle_alloc_error(layout));\n \n         // Initialize the ArcInner\n-        let inner = mem_to_arcinner(mem.ptr.as_ptr());\n+        let inner = mem_to_arcinner(ptr.as_non_null_ptr().as_ptr());\n         debug_assert_eq!(unsafe { Layout::for_value(&*inner) }, layout);\n \n         unsafe {\n@@ -986,7 +986,7 @@ impl<T> Arc<[T]> {\n                     let slice = from_raw_parts_mut(self.elems, self.n_elems);\n                     ptr::drop_in_place(slice);\n \n-                    Global.dealloc(self.mem.cast(), self.layout);\n+                    Global.dealloc(self.mem, self.layout);\n                 }\n             }\n         }"}, {"sha": "cbde2a7e28e8f134004678ecd8b64478c27f4943", "filename": "library/alloc/tests/heap.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5f87ee0ab1bcbf708d27e928296cb44ce9ba9c5f/library%2Falloc%2Ftests%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f87ee0ab1bcbf708d27e928296cb44ce9ba9c5f/library%2Falloc%2Ftests%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fheap.rs?ref=5f87ee0ab1bcbf708d27e928296cb44ce9ba9c5f", "patch": "@@ -20,20 +20,23 @@ fn check_overalign_requests<T: AllocRef>(mut allocator: T) {\n             unsafe {\n                 let pointers: Vec<_> = (0..iterations)\n                     .map(|_| {\n-                        allocator.alloc(Layout::from_size_align(size, align).unwrap()).unwrap().ptr\n+                        allocator.alloc(Layout::from_size_align(size, align).unwrap()).unwrap()\n                     })\n                     .collect();\n                 for &ptr in &pointers {\n                     assert_eq!(\n-                        (ptr.as_ptr() as usize) % align,\n+                        (ptr.as_non_null_ptr().as_ptr() as usize) % align,\n                         0,\n                         \"Got a pointer less aligned than requested\"\n                     )\n                 }\n \n                 // Clean up\n                 for &ptr in &pointers {\n-                    allocator.dealloc(ptr, Layout::from_size_align(size, align).unwrap())\n+                    allocator.dealloc(\n+                        ptr.as_non_null_ptr(),\n+                        Layout::from_size_align(size, align).unwrap(),\n+                    )\n                 }\n             }\n         }"}, {"sha": "c680a3fc25bd40b84a656d7983903b0c23f7dcb6", "filename": "library/alloc/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5f87ee0ab1bcbf708d27e928296cb44ce9ba9c5f/library%2Falloc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f87ee0ab1bcbf708d27e928296cb44ce9ba9c5f/library%2Falloc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Flib.rs?ref=5f87ee0ab1bcbf708d27e928296cb44ce9ba9c5f", "patch": "@@ -13,6 +13,7 @@\n #![feature(associated_type_bounds)]\n #![feature(binary_heap_into_iter_sorted)]\n #![feature(binary_heap_drain_sorted)]\n+#![feature(slice_ptr_get)]\n #![feature(split_inclusive)]\n #![feature(binary_heap_retain)]\n "}, {"sha": "2833768f213bfc8ae95e2a7f03a819930c8790ce", "filename": "library/core/src/alloc/mod.rs", "status": "modified", "additions": 45, "deletions": 49, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/5f87ee0ab1bcbf708d27e928296cb44ce9ba9c5f/library%2Fcore%2Fsrc%2Falloc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f87ee0ab1bcbf708d27e928296cb44ce9ba9c5f/library%2Fcore%2Fsrc%2Falloc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Falloc%2Fmod.rs?ref=5f87ee0ab1bcbf708d27e928296cb44ce9ba9c5f", "patch": "@@ -29,14 +29,6 @@ impl fmt::Display for AllocErr {\n     }\n }\n \n-/// Represents a block of allocated memory returned by an allocator.\n-#[derive(Debug, Copy, Clone)]\n-#[unstable(feature = \"allocator_api\", issue = \"32838\")]\n-pub struct MemoryBlock {\n-    pub ptr: NonNull<u8>,\n-    pub size: usize,\n-}\n-\n /// An implementation of `AllocRef` can allocate, grow, shrink, and deallocate arbitrary blocks of\n /// data described via [`Layout`][].\n ///\n@@ -97,11 +89,13 @@ pub struct MemoryBlock {\n pub unsafe trait AllocRef {\n     /// Attempts to allocate a block of memory.\n     ///\n-    /// On success, returns a [`MemoryBlock`][] meeting the size and alignment guarantees of `layout`.\n+    /// On success, returns a [`NonNull<[u8]>`] meeting the size and alignment guarantees of `layout`.\n     ///\n     /// The returned block may have a larger size than specified by `layout.size()`, and may or may\n     /// not have its contents initialized.\n     ///\n+    /// [`NonNull<[u8]>`]: NonNull\n+    ///\n     /// # Errors\n     ///\n     /// Returning `Err` indicates that either memory is exhausted or `layout` does not meet\n@@ -115,7 +109,7 @@ pub unsafe trait AllocRef {\n     /// call the [`handle_alloc_error`] function, rather than directly invoking `panic!` or similar.\n     ///\n     /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n-    fn alloc(&mut self, layout: Layout) -> Result<MemoryBlock, AllocErr>;\n+    fn alloc(&mut self, layout: Layout) -> Result<NonNull<[u8]>, AllocErr>;\n \n     /// Behaves like `alloc`, but also ensures that the returned memory is zero-initialized.\n     ///\n@@ -132,11 +126,11 @@ pub unsafe trait AllocRef {\n     /// call the [`handle_alloc_error`] function, rather than directly invoking `panic!` or similar.\n     ///\n     /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n-    fn alloc_zeroed(&mut self, layout: Layout) -> Result<MemoryBlock, AllocErr> {\n-        let memory = self.alloc(layout)?;\n+    fn alloc_zeroed(&mut self, layout: Layout) -> Result<NonNull<[u8]>, AllocErr> {\n+        let ptr = self.alloc(layout)?;\n         // SAFETY: `alloc` returns a valid memory block\n-        unsafe { memory.ptr.as_ptr().write_bytes(0, memory.size) }\n-        Ok(memory)\n+        unsafe { ptr.as_non_null_ptr().as_ptr().write_bytes(0, ptr.len()) }\n+        Ok(ptr)\n     }\n \n     /// Deallocates the memory referenced by `ptr`.\n@@ -152,14 +146,16 @@ pub unsafe trait AllocRef {\n \n     /// Attempts to extend the memory block.\n     ///\n-    /// Returns a new [`MemoryBlock`][] containing a pointer and the actual size of the allocated\n+    /// Returns a new [`NonNull<[u8]>`] containing a pointer and the actual size of the allocated\n     /// memory. The pointer is suitable for holding data described by a new layout with `layout`\u2019s\n     /// alignment and a size given by `new_size`. To accomplish this, the allocator may extend the\n     /// allocation referenced by `ptr` to fit the new layout.\n     ///\n     /// If this method returns `Err`, then ownership of the memory block has not been transferred to\n     /// this allocator, and the contents of the memory block are unaltered.\n     ///\n+    /// [`NonNull<[u8]>`]: NonNull\n+    ///\n     /// # Safety\n     ///\n     /// * `ptr` must denote a block of memory [*currently allocated*] via this allocator,\n@@ -168,7 +164,7 @@ pub unsafe trait AllocRef {\n     /// * `new_size`, when rounded up to the nearest multiple of `layout.align()`, must not overflow\n     ///   (i.e., the rounded value must be less than or equal to `usize::MAX`).\n     // Note: We can't require that `new_size` is strictly greater than `layout.size()` because of ZSTs.\n-    // alternative: `new_size must be strictly greater than `layout.size()` or both are zero\n+    // alternative: `new_size` must be strictly greater than `layout.size()` or both are zero\n     ///\n     /// [*currently allocated*]: #currently-allocated-memory\n     /// [*fit*]: #memory-fitting\n@@ -191,15 +187,15 @@ pub unsafe trait AllocRef {\n         ptr: NonNull<u8>,\n         layout: Layout,\n         new_size: usize,\n-    ) -> Result<MemoryBlock, AllocErr> {\n+    ) -> Result<NonNull<[u8]>, AllocErr> {\n         let size = layout.size();\n         debug_assert!(\n             new_size >= size,\n             \"`new_size` must be greater than or equal to `layout.size()`\"\n         );\n \n-        if new_size == size {\n-            return Ok(MemoryBlock { ptr, size });\n+        if size == new_size {\n+            return Ok(NonNull::slice_from_raw_parts(ptr, size));\n         }\n \n         let new_layout =\n@@ -208,17 +204,17 @@ pub unsafe trait AllocRef {\n             // The caller must ensure that `new_size` is greater than or equal to zero. If it's equal\n             // to zero, it's catched beforehand.\n             unsafe { Layout::from_size_align_unchecked(new_size, layout.align()) };\n-        let new_memory = self.alloc(new_layout)?;\n+        let new_ptr = self.alloc(new_layout)?;\n \n         // SAFETY: because `new_size` must be greater than or equal to `size`, both the old and new\n         // memory allocation are valid for reads and writes for `size` bytes. Also, because the old\n-        // allocation wasn't yet deallocated, it cannot overlap `new_memory`. Thus, the call to\n+        // allocation wasn't yet deallocated, it cannot overlap `new_ptr`. Thus, the call to\n         // `copy_nonoverlapping` is safe.\n         // The safety contract for `dealloc` must be upheld by the caller.\n         unsafe {\n-            ptr::copy_nonoverlapping(ptr.as_ptr(), new_memory.ptr.as_ptr(), size);\n+            ptr::copy_nonoverlapping(ptr.as_ptr(), new_ptr.as_non_null_ptr().as_ptr(), size);\n             self.dealloc(ptr, layout);\n-            Ok(new_memory)\n+            Ok(new_ptr)\n         }\n     }\n \n@@ -239,12 +235,11 @@ pub unsafe trait AllocRef {\n     ///\n     /// * `ptr` must denote a block of memory [*currently allocated*] via this allocator,\n     /// * `layout` must [*fit*] that block of memory (The `new_size` argument need not fit it.),\n-    // We can't require that `new_size` is strictly greater than `memory.size` because of ZSTs.\n-    // An alternative would be\n-    // * `new_size must be strictly greater than `memory.size` or both are zero\n     /// * `new_size` must be greater than or equal to `layout.size()`, and\n     /// * `new_size`, when rounded up to the nearest multiple of `layout.align()`, must not overflow\n     ///   (i.e., the rounded value must be less than or equal to `usize::MAX`).\n+    // Note: We can't require that `new_size` is strictly greater than `layout.size()` because of ZSTs.\n+    // alternative: `new_size` must be strictly greater than `layout.size()` or both are zero\n     ///\n     /// [*currently allocated*]: #currently-allocated-memory\n     /// [*fit*]: #memory-fitting\n@@ -267,15 +262,15 @@ pub unsafe trait AllocRef {\n         ptr: NonNull<u8>,\n         layout: Layout,\n         new_size: usize,\n-    ) -> Result<MemoryBlock, AllocErr> {\n+    ) -> Result<NonNull<[u8]>, AllocErr> {\n         let size = layout.size();\n         debug_assert!(\n             new_size >= size,\n             \"`new_size` must be greater than or equal to `layout.size()`\"\n         );\n \n-        if new_size == size {\n-            return Ok(MemoryBlock { ptr, size });\n+        if size == new_size {\n+            return Ok(NonNull::slice_from_raw_parts(ptr, size));\n         }\n \n         let new_layout =\n@@ -284,23 +279,23 @@ pub unsafe trait AllocRef {\n             // The caller must ensure that `new_size` is greater than or equal to zero. If it's equal\n             // to zero, it's caught beforehand.\n             unsafe { Layout::from_size_align_unchecked(new_size, layout.align()) };\n-        let new_memory = self.alloc_zeroed(new_layout)?;\n+        let new_ptr = self.alloc_zeroed(new_layout)?;\n \n         // SAFETY: because `new_size` must be greater than or equal to `size`, both the old and new\n         // memory allocation are valid for reads and writes for `size` bytes. Also, because the old\n-        // allocation wasn't yet deallocated, it cannot overlap `new_memory`. Thus, the call to\n+        // allocation wasn't yet deallocated, it cannot overlap `new_ptr`. Thus, the call to\n         // `copy_nonoverlapping` is safe.\n         // The safety contract for `dealloc` must be upheld by the caller.\n         unsafe {\n-            ptr::copy_nonoverlapping(ptr.as_ptr(), new_memory.ptr.as_ptr(), size);\n+            ptr::copy_nonoverlapping(ptr.as_ptr(), new_ptr.as_non_null_ptr().as_ptr(), size);\n             self.dealloc(ptr, layout);\n-            Ok(new_memory)\n+            Ok(new_ptr)\n         }\n     }\n \n     /// Attempts to shrink the memory block.\n     ///\n-    /// Returns a new [`MemoryBlock`][] containing a pointer and the actual size of the allocated\n+    /// Returns a new [`NonNull<[u8]>`] containing a pointer and the actual size of the allocated\n     /// memory. The pointer is suitable for holding data described by a new layout with `layout`\u2019s\n     /// alignment and a size given by `new_size`. To accomplish this, the allocator may shrink the\n     /// allocation referenced by `ptr` to fit the new layout.\n@@ -313,14 +308,15 @@ pub unsafe trait AllocRef {\n     /// If this method returns `Err`, then ownership of the memory block has not been transferred to\n     /// this allocator, and the contents of the memory block are unaltered.\n     ///\n+    /// [`NonNull<[u8]>`]: NonNull\n+    ///\n     /// # Safety\n     ///\n     /// * `ptr` must denote a block of memory [*currently allocated*] via this allocator,\n     /// * `layout` must [*fit*] that block of memory (The `new_size` argument need not fit it.), and\n-    // We can't require that `new_size` is strictly smaller than `memory.size` because of ZSTs.\n-    // An alternative would be\n-    // * `new_size must be strictly smaller than `memory.size` or both are zero\n     /// * `new_size` must be smaller than or equal to `layout.size()`.\n+    // Note: We can't require that `new_size` is strictly smaller than `layout.size()` because of ZSTs.\n+    // alternative: `new_size` must be smaller than `layout.size()` or both are zero\n     ///\n     /// [*currently allocated*]: #currently-allocated-memory\n     /// [*fit*]: #memory-fitting\n@@ -343,33 +339,33 @@ pub unsafe trait AllocRef {\n         ptr: NonNull<u8>,\n         layout: Layout,\n         new_size: usize,\n-    ) -> Result<MemoryBlock, AllocErr> {\n+    ) -> Result<NonNull<[u8]>, AllocErr> {\n         let size = layout.size();\n         debug_assert!(\n             new_size <= size,\n             \"`new_size` must be smaller than or equal to `layout.size()`\"\n         );\n \n-        if new_size == size {\n-            return Ok(MemoryBlock { ptr, size });\n+        if size == new_size {\n+            return Ok(NonNull::slice_from_raw_parts(ptr, size));\n         }\n \n         let new_layout =\n         // SAFETY: the caller must ensure that the `new_size` does not overflow.\n         // `layout.align()` comes from a `Layout` and is thus guaranteed to be valid for a Layout.\n         // The caller must ensure that `new_size` is greater than zero.\n             unsafe { Layout::from_size_align_unchecked(new_size, layout.align()) };\n-        let new_memory = self.alloc(new_layout)?;\n+        let new_ptr = self.alloc(new_layout)?;\n \n         // SAFETY: because `new_size` must be lower than or equal to `size`, both the old and new\n         // memory allocation are valid for reads and writes for `new_size` bytes. Also, because the\n-        // old allocation wasn't yet deallocated, it cannot overlap `new_memory`. Thus, the call to\n+        // old allocation wasn't yet deallocated, it cannot overlap `new_ptr`. Thus, the call to\n         // `copy_nonoverlapping` is safe.\n         // The safety contract for `dealloc` must be upheld by the caller.\n         unsafe {\n-            ptr::copy_nonoverlapping(ptr.as_ptr(), new_memory.ptr.as_ptr(), new_size);\n+            ptr::copy_nonoverlapping(ptr.as_ptr(), new_ptr.as_non_null_ptr().as_ptr(), size);\n             self.dealloc(ptr, layout);\n-            Ok(new_memory)\n+            Ok(new_ptr)\n         }\n     }\n \n@@ -388,12 +384,12 @@ where\n     A: AllocRef + ?Sized,\n {\n     #[inline]\n-    fn alloc(&mut self, layout: Layout) -> Result<MemoryBlock, AllocErr> {\n+    fn alloc(&mut self, layout: Layout) -> Result<NonNull<[u8]>, AllocErr> {\n         (**self).alloc(layout)\n     }\n \n     #[inline]\n-    fn alloc_zeroed(&mut self, layout: Layout) -> Result<MemoryBlock, AllocErr> {\n+    fn alloc_zeroed(&mut self, layout: Layout) -> Result<NonNull<[u8]>, AllocErr> {\n         (**self).alloc_zeroed(layout)\n     }\n \n@@ -409,7 +405,7 @@ where\n         ptr: NonNull<u8>,\n         layout: Layout,\n         new_size: usize,\n-    ) -> Result<MemoryBlock, AllocErr> {\n+    ) -> Result<NonNull<[u8]>, AllocErr> {\n         // SAFETY: the safety contract must be upheld by the caller\n         unsafe { (**self).grow(ptr, layout, new_size) }\n     }\n@@ -420,7 +416,7 @@ where\n         ptr: NonNull<u8>,\n         layout: Layout,\n         new_size: usize,\n-    ) -> Result<MemoryBlock, AllocErr> {\n+    ) -> Result<NonNull<[u8]>, AllocErr> {\n         // SAFETY: the safety contract must be upheld by the caller\n         unsafe { (**self).grow_zeroed(ptr, layout, new_size) }\n     }\n@@ -431,7 +427,7 @@ where\n         ptr: NonNull<u8>,\n         layout: Layout,\n         new_size: usize,\n-    ) -> Result<MemoryBlock, AllocErr> {\n+    ) -> Result<NonNull<[u8]>, AllocErr> {\n         // SAFETY: the safety contract must be upheld by the caller\n         unsafe { (**self).shrink(ptr, layout, new_size) }\n     }"}, {"sha": "4712cc95b4ab744fd11e655c546c11bd9b0dc897", "filename": "library/std/src/alloc.rs", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/5f87ee0ab1bcbf708d27e928296cb44ce9ba9c5f/library%2Fstd%2Fsrc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f87ee0ab1bcbf708d27e928296cb44ce9ba9c5f/library%2Fstd%2Fsrc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Falloc.rs?ref=5f87ee0ab1bcbf708d27e928296cb44ce9ba9c5f", "patch": "@@ -140,27 +140,27 @@ pub struct System;\n #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n unsafe impl AllocRef for System {\n     #[inline]\n-    fn alloc(&mut self, layout: Layout) -> Result<MemoryBlock, AllocErr> {\n+    fn alloc(&mut self, layout: Layout) -> Result<NonNull<[u8]>, AllocErr> {\n         let size = layout.size();\n         let ptr = if size == 0 {\n             layout.dangling()\n         } else {\n             // SAFETY: `layout` is non-zero in size,\n             unsafe { NonNull::new(GlobalAlloc::alloc(&System, layout)).ok_or(AllocErr)? }\n         };\n-        Ok(MemoryBlock { ptr, size })\n+        Ok(NonNull::slice_from_raw_parts(ptr, size))\n     }\n \n     #[inline]\n-    fn alloc_zeroed(&mut self, layout: Layout) -> Result<MemoryBlock, AllocErr> {\n+    fn alloc_zeroed(&mut self, layout: Layout) -> Result<NonNull<[u8]>, AllocErr> {\n         let size = layout.size();\n         let ptr = if size == 0 {\n             layout.dangling()\n         } else {\n             // SAFETY: `layout` is non-zero in size,\n             unsafe { NonNull::new(GlobalAlloc::alloc_zeroed(&System, layout)).ok_or(AllocErr)? }\n         };\n-        Ok(MemoryBlock { ptr, size })\n+        Ok(NonNull::slice_from_raw_parts(ptr, size))\n     }\n \n     #[inline]\n@@ -178,7 +178,7 @@ unsafe impl AllocRef for System {\n         ptr: NonNull<u8>,\n         layout: Layout,\n         new_size: usize,\n-    ) -> Result<MemoryBlock, AllocErr> {\n+    ) -> Result<NonNull<[u8]>, AllocErr> {\n         debug_assert!(\n             new_size >= layout.size(),\n             \"`new_size` must be greater than or equal to `layout.size()`\"\n@@ -188,14 +188,16 @@ unsafe impl AllocRef for System {\n         // Other conditions must be upheld by the caller\n         unsafe {\n             match layout.size() {\n-                old_size if old_size == new_size => Ok(MemoryBlock { ptr, size: new_size }),\n+                old_size if old_size == new_size => {\n+                    Ok(NonNull::slice_from_raw_parts(ptr, new_size))\n+                }\n                 0 => self.alloc(Layout::from_size_align_unchecked(new_size, layout.align())),\n                 old_size => {\n                     // `realloc` probably checks for `new_size > size` or something similar.\n                     intrinsics::assume(new_size > old_size);\n                     let raw_ptr = GlobalAlloc::realloc(&System, ptr.as_ptr(), layout, new_size);\n                     let ptr = NonNull::new(raw_ptr).ok_or(AllocErr)?;\n-                    Ok(MemoryBlock { ptr, size: new_size })\n+                    Ok(NonNull::slice_from_raw_parts(ptr, new_size))\n                 }\n             }\n         }\n@@ -207,7 +209,7 @@ unsafe impl AllocRef for System {\n         ptr: NonNull<u8>,\n         layout: Layout,\n         new_size: usize,\n-    ) -> Result<MemoryBlock, AllocErr> {\n+    ) -> Result<NonNull<[u8]>, AllocErr> {\n         debug_assert!(\n             new_size >= layout.size(),\n             \"`new_size` must be greater than or equal to `layout.size()`\"\n@@ -217,15 +219,17 @@ unsafe impl AllocRef for System {\n         // Other conditions must be upheld by the caller\n         unsafe {\n             match layout.size() {\n-                old_size if old_size == new_size => Ok(MemoryBlock { ptr, size: new_size }),\n+                old_size if old_size == new_size => {\n+                    Ok(NonNull::slice_from_raw_parts(ptr, new_size))\n+                }\n                 0 => self.alloc_zeroed(Layout::from_size_align_unchecked(new_size, layout.align())),\n                 old_size => {\n                     // `realloc` probably checks for `new_size > size` or something similar.\n                     intrinsics::assume(new_size > old_size);\n                     let raw_ptr = GlobalAlloc::realloc(&System, ptr.as_ptr(), layout, new_size);\n                     raw_ptr.add(old_size).write_bytes(0, new_size - old_size);\n                     let ptr = NonNull::new(raw_ptr).ok_or(AllocErr)?;\n-                    Ok(MemoryBlock { ptr, size: new_size })\n+                    Ok(NonNull::slice_from_raw_parts(ptr, new_size))\n                 }\n             }\n         }\n@@ -237,7 +241,7 @@ unsafe impl AllocRef for System {\n         ptr: NonNull<u8>,\n         layout: Layout,\n         new_size: usize,\n-    ) -> Result<MemoryBlock, AllocErr> {\n+    ) -> Result<NonNull<[u8]>, AllocErr> {\n         let old_size = layout.size();\n         debug_assert!(\n             new_size <= old_size,\n@@ -264,7 +268,7 @@ unsafe impl AllocRef for System {\n             NonNull::new(raw_ptr).ok_or(AllocErr)?\n         };\n \n-        Ok(MemoryBlock { ptr, size: new_size })\n+        Ok(NonNull::slice_from_raw_parts(ptr, new_size))\n     }\n }\n static HOOK: AtomicPtr<()> = AtomicPtr::new(ptr::null_mut());"}, {"sha": "0569e46241a8075622e76c247e5b990b80b372a9", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5f87ee0ab1bcbf708d27e928296cb44ce9ba9c5f/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f87ee0ab1bcbf708d27e928296cb44ce9ba9c5f/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=5f87ee0ab1bcbf708d27e928296cb44ce9ba9c5f", "patch": "@@ -291,6 +291,7 @@\n #![feature(negative_impls)]\n #![feature(never_type)]\n #![feature(nll)]\n+#![feature(nonnull_slice_from_raw_parts)]\n #![feature(once_cell)]\n #![feature(optin_builtin_traits)]\n #![feature(or_patterns)]\n@@ -308,6 +309,8 @@\n #![feature(shrink_to)]\n #![feature(slice_concat_ext)]\n #![feature(slice_internals)]\n+#![feature(slice_ptr_get)]\n+#![feature(slice_ptr_len)]\n #![feature(slice_strip)]\n #![feature(staged_api)]\n #![feature(std_internals)]"}, {"sha": "a6c2317c73669efeee0467bc1ad91cfcf1070e1d", "filename": "src/test/ui/allocator/custom.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5f87ee0ab1bcbf708d27e928296cb44ce9ba9c5f/src%2Ftest%2Fui%2Fallocator%2Fcustom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f87ee0ab1bcbf708d27e928296cb44ce9ba9c5f/src%2Ftest%2Fui%2Fallocator%2Fcustom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fallocator%2Fcustom.rs?ref=5f87ee0ab1bcbf708d27e928296cb44ce9ba9c5f", "patch": "@@ -4,6 +4,7 @@\n // no-prefer-dynamic\n \n #![feature(allocator_api)]\n+#![feature(slice_ptr_get)]\n \n extern crate helper;\n \n@@ -38,9 +39,9 @@ fn main() {\n         let layout = Layout::from_size_align(4, 2).unwrap();\n \n         let memory = Global.alloc(layout.clone()).unwrap();\n-        helper::work_with(&memory.ptr);\n+        helper::work_with(&memory);\n         assert_eq!(HITS.load(Ordering::SeqCst), n + 1);\n-        Global.dealloc(memory.ptr, layout);\n+        Global.dealloc(memory.as_non_null_ptr(), layout);\n         assert_eq!(HITS.load(Ordering::SeqCst), n + 2);\n \n         let s = String::with_capacity(10);\n@@ -51,8 +52,8 @@ fn main() {\n \n         let memory = System.alloc(layout.clone()).unwrap();\n         assert_eq!(HITS.load(Ordering::SeqCst), n + 4);\n-        helper::work_with(&memory.ptr);\n-        System.dealloc(memory.ptr, layout);\n+        helper::work_with(&memory);\n+        System.dealloc(memory.as_non_null_ptr(), layout);\n         assert_eq!(HITS.load(Ordering::SeqCst), n + 4);\n     }\n }"}, {"sha": "a1446b3664d4b3c442ceed2771381203a0e22406", "filename": "src/test/ui/allocator/xcrate-use.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5f87ee0ab1bcbf708d27e928296cb44ce9ba9c5f/src%2Ftest%2Fui%2Fallocator%2Fxcrate-use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f87ee0ab1bcbf708d27e928296cb44ce9ba9c5f/src%2Ftest%2Fui%2Fallocator%2Fxcrate-use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fallocator%2Fxcrate-use.rs?ref=5f87ee0ab1bcbf708d27e928296cb44ce9ba9c5f", "patch": "@@ -5,6 +5,7 @@\n // no-prefer-dynamic\n \n #![feature(allocator_api)]\n+#![feature(slice_ptr_get)]\n \n extern crate custom;\n extern crate helper;\n@@ -21,15 +22,15 @@ fn main() {\n         let layout = Layout::from_size_align(4, 2).unwrap();\n \n         let memory = Global.alloc(layout.clone()).unwrap();\n-        helper::work_with(&memory.ptr);\n+        helper::work_with(&memory);\n         assert_eq!(GLOBAL.0.load(Ordering::SeqCst), n + 1);\n-        Global.dealloc(memory.ptr, layout);\n+        Global.dealloc(memory.as_non_null_ptr(), layout);\n         assert_eq!(GLOBAL.0.load(Ordering::SeqCst), n + 2);\n \n         let memory = System.alloc(layout.clone()).unwrap();\n         assert_eq!(GLOBAL.0.load(Ordering::SeqCst), n + 2);\n-        helper::work_with(&memory.ptr);\n-        System.dealloc(memory.ptr, layout);\n+        helper::work_with(&memory);\n+        System.dealloc(memory.as_non_null_ptr(), layout);\n         assert_eq!(GLOBAL.0.load(Ordering::SeqCst), n + 2);\n     }\n }"}, {"sha": "bdcd47a7260d30f22664b0ba720117a9bea2110b", "filename": "src/test/ui/realloc-16687.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5f87ee0ab1bcbf708d27e928296cb44ce9ba9c5f/src%2Ftest%2Fui%2Frealloc-16687.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f87ee0ab1bcbf708d27e928296cb44ce9ba9c5f/src%2Ftest%2Fui%2Frealloc-16687.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frealloc-16687.rs?ref=5f87ee0ab1bcbf708d27e928296cb44ce9ba9c5f", "patch": "@@ -5,6 +5,7 @@\n // well enough to reproduce (and illustrate) the bug from #16687.\n \n #![feature(allocator_api)]\n+#![feature(slice_ptr_get)]\n \n use std::alloc::{handle_alloc_error, AllocRef, Global, Layout};\n use std::ptr::{self, NonNull};\n@@ -41,13 +42,13 @@ unsafe fn test_triangle() -> bool {\n             println!(\"allocate({:?})\", layout);\n         }\n \n-        let memory = Global.alloc(layout).unwrap_or_else(|_| handle_alloc_error(layout));\n+        let ptr = Global.alloc(layout).unwrap_or_else(|_| handle_alloc_error(layout));\n \n         if PRINT {\n-            println!(\"allocate({:?}) = {:?}\", layout, memory.ptr);\n+            println!(\"allocate({:?}) = {:?}\", layout, ptr);\n         }\n \n-        memory.ptr.cast().as_ptr()\n+        ptr.as_non_null_ptr().as_ptr()\n     }\n \n     unsafe fn deallocate(ptr: *mut u8, layout: Layout) {\n@@ -73,14 +74,14 @@ unsafe fn test_triangle() -> bool {\n             Global.shrink(NonNull::new_unchecked(ptr), old, new.size())\n         };\n \n-        let memory = memory.unwrap_or_else(|_| {\n+        let ptr = memory.unwrap_or_else(|_| {\n             handle_alloc_error(Layout::from_size_align_unchecked(new.size(), old.align()))\n         });\n \n         if PRINT {\n-            println!(\"reallocate({:?}, old={:?}, new={:?}) = {:?}\", ptr, old, new, memory.ptr);\n+            println!(\"reallocate({:?}, old={:?}, new={:?}) = {:?}\", ptr, old, new, ptr);\n         }\n-        memory.ptr.cast().as_ptr()\n+        ptr.as_non_null_ptr().as_ptr()\n     }\n \n     fn idx_to_size(i: usize) -> usize {"}, {"sha": "ad4b9c352aefd278e8f3ec97664261b8b9f3a26c", "filename": "src/test/ui/regions/regions-mock-codegen.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f87ee0ab1bcbf708d27e928296cb44ce9ba9c5f/src%2Ftest%2Fui%2Fregions%2Fregions-mock-codegen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f87ee0ab1bcbf708d27e928296cb44ce9ba9c5f/src%2Ftest%2Fui%2Fregions%2Fregions-mock-codegen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-mock-codegen.rs?ref=5f87ee0ab1bcbf708d27e928296cb44ce9ba9c5f", "patch": "@@ -25,8 +25,8 @@ struct Ccx {\n fn alloc(_bcx: &arena) -> &Bcx<'_> {\n     unsafe {\n         let layout = Layout::new::<Bcx>();\n-        let memory = Global.alloc(layout).unwrap_or_else(|_| handle_alloc_error(layout));\n-        &*(memory.ptr.as_ptr() as *const _)\n+        let ptr = Global.alloc(layout).unwrap_or_else(|_| handle_alloc_error(layout));\n+        &*(ptr.as_ptr() as *const _)\n     }\n }\n "}]}