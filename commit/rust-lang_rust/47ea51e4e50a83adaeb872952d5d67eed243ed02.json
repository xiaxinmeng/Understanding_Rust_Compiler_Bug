{"sha": "47ea51e4e50a83adaeb872952d5d67eed243ed02", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ3ZWE1MWU0ZTUwYTgzYWRhZWI4NzI5NTJkNWQ2N2VlZDI0M2VkMDI=", "commit": {"author": {"name": "Jacob Wahlgren", "email": "jacob.wahlgren@gmail.com", "date": "2017-10-14T19:27:41Z"}, "committer": {"name": "Jacob Wahlgren", "email": "jacob.wahlgren@gmail.com", "date": "2017-10-14T19:27:41Z"}, "message": "Improve E0382 extended help message\n\nMention Clone and refererences, and use more realistic examples (within\nthe constraints of a few lines :).", "tree": {"sha": "c9467a0f292fc423e7eaf91c6cdab2f06bb61b49", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c9467a0f292fc423e7eaf91c6cdab2f06bb61b49"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/47ea51e4e50a83adaeb872952d5d67eed243ed02", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/47ea51e4e50a83adaeb872952d5d67eed243ed02", "html_url": "https://github.com/rust-lang/rust/commit/47ea51e4e50a83adaeb872952d5d67eed243ed02", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/47ea51e4e50a83adaeb872952d5d67eed243ed02/comments", "author": {"login": "jacwah", "id": 3816754, "node_id": "MDQ6VXNlcjM4MTY3NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3816754?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jacwah", "html_url": "https://github.com/jacwah", "followers_url": "https://api.github.com/users/jacwah/followers", "following_url": "https://api.github.com/users/jacwah/following{/other_user}", "gists_url": "https://api.github.com/users/jacwah/gists{/gist_id}", "starred_url": "https://api.github.com/users/jacwah/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jacwah/subscriptions", "organizations_url": "https://api.github.com/users/jacwah/orgs", "repos_url": "https://api.github.com/users/jacwah/repos", "events_url": "https://api.github.com/users/jacwah/events{/privacy}", "received_events_url": "https://api.github.com/users/jacwah/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jacwah", "id": 3816754, "node_id": "MDQ6VXNlcjM4MTY3NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3816754?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jacwah", "html_url": "https://github.com/jacwah", "followers_url": "https://api.github.com/users/jacwah/followers", "following_url": "https://api.github.com/users/jacwah/following{/other_user}", "gists_url": "https://api.github.com/users/jacwah/gists{/gist_id}", "starred_url": "https://api.github.com/users/jacwah/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jacwah/subscriptions", "organizations_url": "https://api.github.com/users/jacwah/orgs", "repos_url": "https://api.github.com/users/jacwah/repos", "events_url": "https://api.github.com/users/jacwah/events{/privacy}", "received_events_url": "https://api.github.com/users/jacwah/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7920a7cc74bb2a2a80d90e32386e6194bb9a05dc", "url": "https://api.github.com/repos/rust-lang/rust/commits/7920a7cc74bb2a2a80d90e32386e6194bb9a05dc", "html_url": "https://github.com/rust-lang/rust/commit/7920a7cc74bb2a2a80d90e32386e6194bb9a05dc"}], "stats": {"total": 66, "additions": 57, "deletions": 9}, "files": [{"sha": "0f67f7bf6deb47fe14cdd2881b5d085703036ff0", "filename": "src/librustc_mir/diagnostics.rs", "status": "modified", "additions": 57, "deletions": 9, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/47ea51e4e50a83adaeb872952d5d67eed243ed02/src%2Flibrustc_mir%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47ea51e4e50a83adaeb872952d5d67eed243ed02/src%2Flibrustc_mir%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdiagnostics.rs?ref=47ea51e4e50a83adaeb872952d5d67eed243ed02", "patch": "@@ -320,20 +320,68 @@ Since `MyStruct` is a type that is not marked `Copy`, the data gets moved out\n of `x` when we set `y`. This is fundamental to Rust's ownership system: outside\n of workarounds like `Rc`, a value cannot be owned by more than one variable.\n \n-If we own the type, the easiest way to address this problem is to implement\n-`Copy` and `Clone` on it, as shown below. This allows `y` to copy the\n-information in `x`, while leaving the original version owned by `x`. Subsequent\n-changes to `x` will not be reflected when accessing `y`.\n+Sometimes we don't need to move the value. Using a reference, we can let another\n+function borrow the value without changing its ownership. In the example below,\n+we don't actually have to move our string to `calculate_length`, we can give it\n+a reference to it with `&` instead.\n+\n+```\n+fn main() {\n+    let s1 = String::from(\"hello\");\n+\n+    let len = calculate_length(&s1);\n+\n+    println!(\"The length of '{}' is {}.\", s1, len);\n+}\n+\n+fn calculate_length(s: &String) -> usize {\n+    s.len()\n+}\n+```\n+\n+A mutable reference can be created with `&mut`.\n+\n+Sometimes we don't want a reference, but a duplicate. All types marked `Clone`\n+can be duplicated by calling `.clone()`. Subsequent changes to a clone do not\n+affect the original variable.\n+\n+Most types in the standard library are marked `Clone`. The example below\n+demonstrates using `clone()` on a string. `s1` is first set to \"many\", and then\n+copied to `s2`. Then the first character of `s1` is removed, without affecting\n+`s2`. \"any many\" is printed to the console.\n+\n+```\n+fn main() {\n+    let mut s1 = String::from(\"many\");\n+    let s2 = s1.clone();\n+    s1.remove(0);\n+    println!(\"{} {}\", s1, s2);\n+}\n+```\n+\n+If we control the definition of a type, we can implement `Clone` on it ourselves\n+with `#[derive(Clone)]`.\n+\n+Some types have no ownership semantics at all and are trivial to duplicate. An\n+example is `i32` and the other number types. We don't have to call `.clone()` to\n+clone them, because they are marked `Copy` in addition to `Clone`.  Implicit\n+cloning is more convienient in this case. We can mark our own types `Copy` if\n+all their members also are marked `Copy`.\n+\n+In the example below, we implement a `Point` type. Because it only stores two\n+integers, we opt-out of ownership semantics with `Copy`. Then we can\n+`let p2 = p1` without `p1` being moved.\n \n ```\n #[derive(Copy, Clone)]\n-struct MyStruct { s: u32 }\n+struct Point { x: i32, y: i32 }\n \n fn main() {\n-    let mut x = MyStruct{ s: 5u32 };\n-    let y = x;\n-    x.s = 6;\n-    println!(\"{}\", x.s);\n+    let mut p1 = Point{ x: -1, y: 2 };\n+    let p2 = p1;\n+    p1.x = 1;\n+    println!(\"p1: {}, {}\", p1.x, p1.y);\n+    println!(\"p2: {}, {}\", p2.x, p2.y);\n }\n ```\n "}]}