{"sha": "7bd86cee49c5643ccc0556ffe019c9711c9fff95", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdiZDg2Y2VlNDljNTY0M2NjYzA1NTZmZmUwMTljOTcxMWM5ZmZmOTU=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-03-24T06:13:37Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-03-24T06:13:37Z"}, "message": "Rollup merge of #70213 - eddyb:stalled-on-ty-or-const, r=nikomatsakis\n\ntraits/fulfill: allow `stalled_on` to track `ty::Const::Infer(_)` (unused yet).\n\nThis PR addresses the representation side of #70180, but only *actually collects* `ty::Infer`s via `Ty::walk` into `stalled_on` (collecting `ty::ConstKind::Infer`s requires #70164).\n\nHowever, it should be enough to handle #70107's needs (WF obligations are stalled only on the outermost type/const being an inference variable, no `walk`-ing is involved).\n\nThis is my second attempt, see #70181 for the previous one, which unacceptably regressed perf.\n\nr? @nikomatsakis cc @nnethercote", "tree": {"sha": "054ed48def3f54a386ceeb7ab37cfc9e12bb0820", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/054ed48def3f54a386ceeb7ab37cfc9e12bb0820"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7bd86cee49c5643ccc0556ffe019c9711c9fff95", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeeaURCRBK7hj4Ov3rIwAAdHIIAIvUZ6drsaxekfAxHjs9ax/m\n8kA/UoBvazAWzFL2JUAJq9AENTj5mY/AmnkqEK4z/6crKMJvZzPe9Tim8ypGRjY+\n+YPfdfZzzD8Csq1Sq/NBvEIv6JirmyrGt/jxXYtJ3iICwFguJLHLLS/srjQXV2fX\nl/hXj50c73YRjBtFURhl5g5nHHhRY2uiJcCbZrZPuehAm64qlDmdWGeURqq/tV5W\nsc0mPoVhuR7mdcpbXbGCuS8umMDqdVJRrT4b2+ihSd5KYlTm3mKBggp/IKocGQ6A\n57S5MclBkzpdx/ByG9nDGYHRkK1KDHfgdtenT7Nnrq29xzrE/Bein2pu9IYuDiI=\n=M/us\n-----END PGP SIGNATURE-----\n", "payload": "tree 054ed48def3f54a386ceeb7ab37cfc9e12bb0820\nparent d626f5bc6631b1f694ab972c53316aebdae22842\nparent 78c178bcda3589affb0f4ffa248398cfca08c98f\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1585030417 +0100\ncommitter GitHub <noreply@github.com> 1585030417 +0100\n\nRollup merge of #70213 - eddyb:stalled-on-ty-or-const, r=nikomatsakis\n\ntraits/fulfill: allow `stalled_on` to track `ty::Const::Infer(_)` (unused yet).\n\nThis PR addresses the representation side of #70180, but only *actually collects* `ty::Infer`s via `Ty::walk` into `stalled_on` (collecting `ty::ConstKind::Infer`s requires #70164).\n\nHowever, it should be enough to handle #70107's needs (WF obligations are stalled only on the outermost type/const being an inference variable, no `walk`-ing is involved).\n\nThis is my second attempt, see #70181 for the previous one, which unacceptably regressed perf.\n\nr? @nikomatsakis cc @nnethercote\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7bd86cee49c5643ccc0556ffe019c9711c9fff95", "html_url": "https://github.com/rust-lang/rust/commit/7bd86cee49c5643ccc0556ffe019c9711c9fff95", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7bd86cee49c5643ccc0556ffe019c9711c9fff95/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d626f5bc6631b1f694ab972c53316aebdae22842", "url": "https://api.github.com/repos/rust-lang/rust/commits/d626f5bc6631b1f694ab972c53316aebdae22842", "html_url": "https://github.com/rust-lang/rust/commit/d626f5bc6631b1f694ab972c53316aebdae22842"}, {"sha": "78c178bcda3589affb0f4ffa248398cfca08c98f", "url": "https://api.github.com/repos/rust-lang/rust/commits/78c178bcda3589affb0f4ffa248398cfca08c98f", "html_url": "https://github.com/rust-lang/rust/commit/78c178bcda3589affb0f4ffa248398cfca08c98f"}], "stats": {"total": 188, "additions": 121, "deletions": 67}, "files": [{"sha": "dc494b8e413700dbb0c2a5ca493ebfc24e0b6501", "filename": "src/librustc_infer/infer/mod.rs", "status": "modified", "additions": 94, "deletions": 40, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/7bd86cee49c5643ccc0556ffe019c9711c9fff95/src%2Flibrustc_infer%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bd86cee49c5643ccc0556ffe019c9711c9fff95/src%2Flibrustc_infer%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fmod.rs?ref=7bd86cee49c5643ccc0556ffe019c9711c9fff95", "patch": "@@ -19,7 +19,7 @@ use rustc::traits::select;\n use rustc::ty::error::{ExpectedFound, TypeError, UnconstrainedNumeric};\n use rustc::ty::fold::{TypeFoldable, TypeFolder};\n use rustc::ty::relate::RelateResult;\n-use rustc::ty::subst::{GenericArg, InternalSubsts, SubstsRef};\n+use rustc::ty::subst::{GenericArg, GenericArgKind, InternalSubsts, SubstsRef};\n pub use rustc::ty::IntVarValue;\n use rustc::ty::{self, GenericParamDefKind, InferConst, Ty, TyCtxt};\n use rustc::ty::{ConstVid, FloatVid, IntVid, TyVid};\n@@ -501,6 +501,7 @@ impl NLLRegionVariableOrigin {\n     }\n }\n \n+// FIXME(eddyb) investigate overlap between this and `TyOrConstInferVar`.\n #[derive(Copy, Clone, Debug)]\n pub enum FixupError<'tcx> {\n     UnresolvedIntTy(IntVid),\n@@ -1347,8 +1348,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     where\n         T: TypeFoldable<'tcx>,\n     {\n-        let mut r = ShallowResolver::new(self);\n-        value.fold_with(&mut r)\n+        value.fold_with(&mut ShallowResolver { infcx: self })\n     }\n \n     pub fn root_var(&self, var: ty::TyVid) -> ty::TyVid {\n@@ -1551,22 +1551,12 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         // variables, thus we don't need to substitute back the original values.\n         self.tcx.const_eval_resolve(param_env, def_id, substs, promoted, span)\n     }\n-}\n-\n-pub struct ShallowResolver<'a, 'tcx> {\n-    infcx: &'a InferCtxt<'a, 'tcx>,\n-}\n-\n-impl<'a, 'tcx> ShallowResolver<'a, 'tcx> {\n-    #[inline(always)]\n-    pub fn new(infcx: &'a InferCtxt<'a, 'tcx>) -> Self {\n-        ShallowResolver { infcx }\n-    }\n \n     /// If `typ` is a type variable of some kind, resolve it one level\n     /// (but do not resolve types found in the result). If `typ` is\n     /// not a type variable, just return it unmodified.\n-    pub fn shallow_resolve(&mut self, typ: Ty<'tcx>) -> Ty<'tcx> {\n+    // FIXME(eddyb) inline into `ShallowResolver::visit_ty`.\n+    fn shallow_resolve_ty(&self, typ: Ty<'tcx>) -> Ty<'tcx> {\n         match typ.kind {\n             ty::Infer(ty::TyVar(v)) => {\n                 // Not entirely obvious: if `typ` is a type variable,\n@@ -1580,69 +1570,133 @@ impl<'a, 'tcx> ShallowResolver<'a, 'tcx> {\n                 // depth.\n                 //\n                 // Note: if these two lines are combined into one we get\n-                // dynamic borrow errors on `self.infcx.inner`.\n-                let known = self.infcx.inner.borrow_mut().type_variables.probe(v).known();\n-                known.map(|t| self.fold_ty(t)).unwrap_or(typ)\n+                // dynamic borrow errors on `self.inner`.\n+                let known = self.inner.borrow_mut().type_variables.probe(v).known();\n+                known.map(|t| self.shallow_resolve_ty(t)).unwrap_or(typ)\n             }\n \n             ty::Infer(ty::IntVar(v)) => self\n-                .infcx\n                 .inner\n                 .borrow_mut()\n                 .int_unification_table\n                 .probe_value(v)\n-                .map(|v| v.to_type(self.infcx.tcx))\n+                .map(|v| v.to_type(self.tcx))\n                 .unwrap_or(typ),\n \n             ty::Infer(ty::FloatVar(v)) => self\n-                .infcx\n                 .inner\n                 .borrow_mut()\n                 .float_unification_table\n                 .probe_value(v)\n-                .map(|v| v.to_type(self.infcx.tcx))\n+                .map(|v| v.to_type(self.tcx))\n                 .unwrap_or(typ),\n \n             _ => typ,\n         }\n     }\n \n-    // `resolver.shallow_resolve_changed(ty)` is equivalent to\n-    // `resolver.shallow_resolve(ty) != ty`, but more efficient. It's always\n-    // inlined, despite being large, because it has only two call sites that\n-    // are extremely hot.\n+    /// `ty_or_const_infer_var_changed` is equivalent to one of these two:\n+    ///   * `shallow_resolve(ty) != ty` (where `ty.kind = ty::Infer(_)`)\n+    ///   * `shallow_resolve(ct) != ct` (where `ct.kind = ty::ConstKind::Infer(_)`)\n+    ///\n+    /// However, `ty_or_const_infer_var_changed` is more efficient. It's always\n+    /// inlined, despite being large, because it has only two call sites that\n+    /// are extremely hot (both in `traits::fulfill`'s checking of `stalled_on`\n+    /// inference variables), and it handles both `Ty` and `ty::Const` without\n+    /// having to resort to storing full `GenericArg`s in `stalled_on`.\n     #[inline(always)]\n-    pub fn shallow_resolve_changed(&self, infer: ty::InferTy) -> bool {\n-        match infer {\n-            ty::TyVar(v) => {\n+    pub fn ty_or_const_infer_var_changed(&self, infer_var: TyOrConstInferVar<'tcx>) -> bool {\n+        match infer_var {\n+            TyOrConstInferVar::Ty(v) => {\n                 use self::type_variable::TypeVariableValue;\n \n-                // If `inlined_probe` returns a `Known` value its `kind` never\n-                // matches `infer`.\n-                match self.infcx.inner.borrow_mut().type_variables.inlined_probe(v) {\n+                // If `inlined_probe` returns a `Known` value, it never equals\n+                // `ty::Infer(ty::TyVar(v))`.\n+                match self.inner.borrow_mut().type_variables.inlined_probe(v) {\n                     TypeVariableValue::Unknown { .. } => false,\n                     TypeVariableValue::Known { .. } => true,\n                 }\n             }\n \n-            ty::IntVar(v) => {\n-                // If inlined_probe_value returns a value it's always a\n+            TyOrConstInferVar::TyInt(v) => {\n+                // If `inlined_probe_value` returns a value it's always a\n                 // `ty::Int(_)` or `ty::UInt(_)`, which never matches a\n                 // `ty::Infer(_)`.\n-                self.infcx.inner.borrow_mut().int_unification_table.inlined_probe_value(v).is_some()\n+                self.inner.borrow_mut().int_unification_table.inlined_probe_value(v).is_some()\n             }\n \n-            ty::FloatVar(v) => {\n-                // If inlined_probe_value returns a value it's always a\n+            TyOrConstInferVar::TyFloat(v) => {\n+                // If `probe_value` returns a value it's always a\n                 // `ty::Float(_)`, which never matches a `ty::Infer(_)`.\n                 //\n                 // Not `inlined_probe_value(v)` because this call site is colder.\n-                self.infcx.inner.borrow_mut().float_unification_table.probe_value(v).is_some()\n+                self.inner.borrow_mut().float_unification_table.probe_value(v).is_some()\n             }\n \n-            _ => unreachable!(),\n+            TyOrConstInferVar::Const(v) => {\n+                // If `probe_value` returns a `Known` value, it never equals\n+                // `ty::ConstKind::Infer(ty::InferConst::Var(v))`.\n+                //\n+                // Not `inlined_probe_value(v)` because this call site is colder.\n+                match self.inner.borrow_mut().const_unification_table.probe_value(v).val {\n+                    ConstVariableValue::Unknown { .. } => false,\n+                    ConstVariableValue::Known { .. } => true,\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+/// Helper for `ty_or_const_infer_var_changed` (see comment on that), currently\n+/// used only for `traits::fulfill`'s list of `stalled_on` inference variables.\n+#[derive(Copy, Clone, Debug)]\n+pub enum TyOrConstInferVar<'tcx> {\n+    /// Equivalent to `ty::Infer(ty::TyVar(_))`.\n+    Ty(TyVid),\n+    /// Equivalent to `ty::Infer(ty::IntVar(_))`.\n+    TyInt(IntVid),\n+    /// Equivalent to `ty::Infer(ty::FloatVar(_))`.\n+    TyFloat(FloatVid),\n+\n+    /// Equivalent to `ty::ConstKind::Infer(ty::InferConst::Var(_))`.\n+    Const(ConstVid<'tcx>),\n+}\n+\n+impl TyOrConstInferVar<'tcx> {\n+    /// Tries to extract an inference variable from a type or a constant, returns `None`\n+    /// for types other than `ty::Infer(_)` (or `InferTy::Fresh*`) and\n+    /// for constants other than `ty::ConstKind::Infer(_)` (or `InferConst::Fresh`).\n+    pub fn maybe_from_generic_arg(arg: GenericArg<'tcx>) -> Option<Self> {\n+        match arg.unpack() {\n+            GenericArgKind::Type(ty) => Self::maybe_from_ty(ty),\n+            GenericArgKind::Const(ct) => Self::maybe_from_const(ct),\n+            GenericArgKind::Lifetime(_) => None,\n         }\n     }\n+\n+    /// Tries to extract an inference variable from a type, returns `None`\n+    /// for types other than `ty::Infer(_)` (or `InferTy::Fresh*`).\n+    pub fn maybe_from_ty(ty: Ty<'tcx>) -> Option<Self> {\n+        match ty.kind {\n+            ty::Infer(ty::TyVar(v)) => Some(TyOrConstInferVar::Ty(v)),\n+            ty::Infer(ty::IntVar(v)) => Some(TyOrConstInferVar::TyInt(v)),\n+            ty::Infer(ty::FloatVar(v)) => Some(TyOrConstInferVar::TyFloat(v)),\n+            _ => None,\n+        }\n+    }\n+\n+    /// Tries to extract an inference variable from a constant, returns `None`\n+    /// for constants other than `ty::ConstKind::Infer(_)` (or `InferConst::Fresh`).\n+    pub fn maybe_from_const(ct: &'tcx ty::Const<'tcx>) -> Option<Self> {\n+        match ct.val {\n+            ty::ConstKind::Infer(InferConst::Var(v)) => Some(TyOrConstInferVar::Const(v)),\n+            _ => None,\n+        }\n+    }\n+}\n+\n+struct ShallowResolver<'a, 'tcx> {\n+    infcx: &'a InferCtxt<'a, 'tcx>,\n }\n \n impl<'a, 'tcx> TypeFolder<'tcx> for ShallowResolver<'a, 'tcx> {\n@@ -1651,7 +1705,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for ShallowResolver<'a, 'tcx> {\n     }\n \n     fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        self.shallow_resolve(ty)\n+        self.infcx.shallow_resolve_ty(ty)\n     }\n \n     fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {"}, {"sha": "0578c00fefb17e3f8e9100fc963e7cc390a74182", "filename": "src/librustc_trait_selection/traits/fulfill.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/7bd86cee49c5643ccc0556ffe019c9711c9fff95/src%2Flibrustc_trait_selection%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bd86cee49c5643ccc0556ffe019c9711c9fff95/src%2Flibrustc_trait_selection%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ffulfill.rs?ref=7bd86cee49c5643ccc0556ffe019c9711c9fff95", "patch": "@@ -1,4 +1,4 @@\n-use crate::infer::{InferCtxt, ShallowResolver};\n+use crate::infer::{InferCtxt, TyOrConstInferVar};\n use rustc::ty::error::ExpectedFound;\n use rustc::ty::{self, ToPolyTraitRef, Ty, TypeFoldable};\n use rustc_data_structures::obligation_forest::ProcessResult;\n@@ -73,7 +73,10 @@ pub struct FulfillmentContext<'tcx> {\n #[derive(Clone, Debug)]\n pub struct PendingPredicateObligation<'tcx> {\n     pub obligation: PredicateObligation<'tcx>,\n-    pub stalled_on: Vec<ty::InferTy>,\n+    // FIXME(eddyb) look into whether this could be a `SmallVec`.\n+    // Judging by the comment in `process_obligation`, the 1-element case\n+    // is common so this could be a `SmallVec<[TyOrConstInferVar<'tcx>; 1]>`.\n+    pub stalled_on: Vec<TyOrConstInferVar<'tcx>>,\n }\n \n // `PendingPredicateObligation` is used a lot. Make sure it doesn't unintentionally get bigger.\n@@ -266,8 +269,8 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n             // Match arms are in order of frequency, which matters because this\n             // code is so hot. 1 and 0 dominate; 2+ is fairly rare.\n             1 => {\n-                let infer = pending_obligation.stalled_on[0];\n-                ShallowResolver::new(self.selcx.infcx()).shallow_resolve_changed(infer)\n+                let infer_var = pending_obligation.stalled_on[0];\n+                self.selcx.infcx().ty_or_const_infer_var_changed(infer_var)\n             }\n             0 => {\n                 // In this case we haven't changed, but wish to make a change.\n@@ -277,8 +280,8 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n                 // This `for` loop was once a call to `all()`, but this lower-level\n                 // form was a perf win. See #64545 for details.\n                 (|| {\n-                    for &infer in &pending_obligation.stalled_on {\n-                        if ShallowResolver::new(self.selcx.infcx()).shallow_resolve_changed(infer) {\n+                    for &infer_var in &pending_obligation.stalled_on {\n+                        if self.selcx.infcx().ty_or_const_infer_var_changed(infer_var) {\n                             return true;\n                         }\n                     }\n@@ -309,13 +312,6 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n \n         debug!(\"process_obligation: obligation = {:?} cause = {:?}\", obligation, obligation.cause);\n \n-        fn infer_ty(ty: Ty<'tcx>) -> ty::InferTy {\n-            match ty.kind {\n-                ty::Infer(infer) => infer,\n-                _ => panic!(),\n-            }\n-        }\n-\n         match obligation.predicate {\n             ty::Predicate::Trait(ref data, _) => {\n                 let trait_obligation = obligation.with(data.clone());\n@@ -467,7 +463,8 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n                     obligation.cause.span,\n                 ) {\n                     None => {\n-                        pending_obligation.stalled_on = vec![infer_ty(ty)];\n+                        pending_obligation.stalled_on =\n+                            vec![TyOrConstInferVar::maybe_from_ty(ty).unwrap()];\n                         ProcessResult::Unchanged\n                     }\n                     Some(os) => ProcessResult::Changed(mk_pending(os)),\n@@ -483,8 +480,8 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n                     None => {\n                         // None means that both are unresolved.\n                         pending_obligation.stalled_on = vec![\n-                            infer_ty(subtype.skip_binder().a),\n-                            infer_ty(subtype.skip_binder().b),\n+                            TyOrConstInferVar::maybe_from_ty(subtype.skip_binder().a).unwrap(),\n+                            TyOrConstInferVar::maybe_from_ty(subtype.skip_binder().b).unwrap(),\n                         ];\n                         ProcessResult::Unchanged\n                     }\n@@ -534,20 +531,23 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n     }\n }\n \n-/// Returns the set of type variables contained in a trait ref\n+/// Returns the set of type inference variables contained in a trait ref.\n fn trait_ref_type_vars<'a, 'tcx>(\n     selcx: &mut SelectionContext<'a, 'tcx>,\n-    t: ty::PolyTraitRef<'tcx>,\n-) -> Vec<ty::InferTy> {\n-    t.skip_binder() // ok b/c this check doesn't care about regions\n+    trait_ref: ty::PolyTraitRef<'tcx>,\n+) -> Vec<TyOrConstInferVar<'tcx>> {\n+    trait_ref\n+        .skip_binder() // ok b/c this check doesn't care about regions\n+        // FIXME(eddyb) walk over `GenericArg` to support const infer vars.\n         .input_types()\n-        .map(|t| selcx.infcx().resolve_vars_if_possible(&t))\n-        .filter(|t| t.has_infer_types())\n-        .flat_map(|t| t.walk())\n-        .filter_map(|t| match t.kind {\n-            ty::Infer(infer) => Some(infer),\n-            _ => None,\n-        })\n+        .map(|ty| selcx.infcx().resolve_vars_if_possible(&ty))\n+        // FIXME(eddyb) try using `maybe_walk` to skip *all* subtrees that\n+        // don't contain inference variables, not just the outermost level.\n+        // FIXME(eddyb) use `has_infer_types_or_const`.\n+        .filter(|ty| ty.has_infer_types())\n+        .flat_map(|ty| ty.walk())\n+        // FIXME(eddyb) use `TyOrConstInferVar::maybe_from_generic_arg`.\n+        .filter_map(TyOrConstInferVar::maybe_from_ty)\n         .collect()\n }\n "}]}