{"sha": "b58f77e234ef40c4f19f9dc44c2be2c21163f851", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI1OGY3N2UyMzRlZjQwYzRmMTlmOWRjNDRjMmJlMmMyMTE2M2Y4NTE=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-10-02T21:49:26Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-10-02T21:49:26Z"}, "message": "rollup merge of #17715 : aturon/revert-slice-ops-libs", "tree": {"sha": "d39de6be5866c0f0f37f9f3219b8217c873d8b52", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d39de6be5866c0f0f37f9f3219b8217c873d8b52"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b58f77e234ef40c4f19f9dc44c2be2c21163f851", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b58f77e234ef40c4f19f9dc44c2be2c21163f851", "html_url": "https://github.com/rust-lang/rust/commit/b58f77e234ef40c4f19f9dc44c2be2c21163f851", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b58f77e234ef40c4f19f9dc44c2be2c21163f851/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b2d4eb186e99b66051be9089f836c66a558dd995", "url": "https://api.github.com/repos/rust-lang/rust/commits/b2d4eb186e99b66051be9089f836c66a558dd995", "html_url": "https://github.com/rust-lang/rust/commit/b2d4eb186e99b66051be9089f836c66a558dd995"}, {"sha": "d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7", "url": "https://api.github.com/repos/rust-lang/rust/commits/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7", "html_url": "https://github.com/rust-lang/rust/commit/d2ea0315e09cbd495a67c9e3d5053b57e2b5a8b7"}], "stats": {"total": 1172, "additions": 495, "deletions": 677}, "files": [{"sha": "0a486ef03055606620796c1317764a08dec24cfe", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n #![crate_type = \"bin\"]\n-#![feature(phase, slicing_syntax)]\n+#![feature(phase)]\n \n #![deny(warnings)]\n "}, {"sha": "b48ccfc43742d51e839152a9cdea7b7ded08a5a7", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -874,7 +874,7 @@ fn check_error_patterns(props: &TestProps,\n     if done { return; }\n \n     let missing_patterns =\n-        props.error_patterns[next_err_idx..];\n+        props.error_patterns.slice(next_err_idx, props.error_patterns.len());\n     if missing_patterns.len() == 1u {\n         fatal_proc_rec(format!(\"error pattern '{}' not found!\",\n                               missing_patterns[0]).as_slice(),"}, {"sha": "3da3d4c580755e6a0fb0a2bbb434ff169b355366", "filename": "src/doc/reference.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -3828,7 +3828,7 @@ type signature of `print`, and the cast expression in `main`.\n Within the body of an item that has type parameter declarations, the names of\n its type parameters are types:\n \n-```ignore\n+```\n fn map<A: Clone, B: Clone>(f: |A| -> B, xs: &[A]) -> Vec<B> {\n     if xs.len() == 0 {\n        return vec![];"}, {"sha": "60c9dfcff187c1c03882d8e224130658286af35e", "filename": "src/libcollections/bitv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibcollections%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibcollections%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbitv.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -194,7 +194,7 @@ impl Bitv {\n         if start > self.storage.len() {\n             start = self.storage.len();\n         }\n-        let mut iter = self.storage[start..].iter();\n+        let mut iter = self.storage.slice_from(start).iter();\n         MaskWords {\n           next_word: iter.next(),\n           iter: iter,"}, {"sha": "8b9a0ec796e27eba11ba9bd161a72cfdc7a35cdd", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -19,9 +19,8 @@\n        html_root_url = \"http://doc.rust-lang.org/master/\",\n        html_playground_url = \"http://play.rust-lang.org/\")]\n \n-#![allow(unknown_features)]\n #![feature(macro_rules, managed_boxes, default_type_params, phase, globs)]\n-#![feature(unsafe_destructor, import_shadowing, slicing_syntax)]\n+#![feature(unsafe_destructor, import_shadowing)]\n #![no_std]\n \n #[phase(plugin, link)] extern crate core;"}, {"sha": "02c8af2c470f3f3cb5c7905c2dfa234f03d80ea4", "filename": "src/libcollections/ringbuf.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibcollections%2Fringbuf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibcollections%2Fringbuf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fringbuf.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -271,7 +271,7 @@ impl<T> RingBuf<T> {\n     ///     *num = *num - 2;\n     /// }\n     /// let b: &[_] = &[&mut 3, &mut 1, &mut 2];\n-    /// assert_eq!(buf.iter_mut().collect::<Vec<&mut int>>()[], b);\n+    /// assert_eq!(buf.iter_mut().collect::<Vec<&mut int>>().as_slice(), b);\n     /// ```\n     pub fn iter_mut<'a>(&'a mut self) -> MutItems<'a, T> {\n         let start_index = raw_index(self.lo, self.elts.len(), 0);\n@@ -291,7 +291,7 @@ impl<T> RingBuf<T> {\n         } else {\n             // Items to iterate goes from start_index to end_index:\n             let (empty, elts) = self.elts.split_at_mut(0);\n-            let remaining1 = elts[mut start_index..end_index];\n+            let remaining1 = elts.slice_mut(start_index, end_index);\n             MutItems { remaining1: remaining1,\n                                  remaining2: empty,\n                                  nelts: self.nelts }"}, {"sha": "45489bbf84eb4059f93649e6194b24b7de620dc6", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 26, "deletions": 37, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -44,20 +44,15 @@\n //!\n //! A number of traits add methods that allow you to accomplish tasks with slices.\n //! These traits include `ImmutableSlice`, which is defined for `&[T]` types,\n-//! `MutableSlice`, defined for `&mut [T]` types, and `Slice` and `SliceMut`\n-//! which are defined for `[T]`.\n+//! and `MutableSlice`, defined for `&mut [T]` types.\n //!\n-//! An example is the `slice` method which enables slicing syntax `[a..b]` that\n-//! returns an immutable \"view\" into a `Vec` or another slice from the index\n-//! interval `[a, b)`:\n+//! An example is the method `.slice(a, b)` that returns an immutable \"view\" into\n+//! a `Vec` or another slice from the index interval `[a, b)`:\n //!\n //! ```rust\n-//! #![feature(slicing_syntax)]\n-//! fn main() {\n-//!     let numbers = [0i, 1i, 2i];\n-//!     let last_numbers = numbers[1..3];\n-//!     // last_numbers is now &[1i, 2i]\n-//! }\n+//! let numbers = [0i, 1i, 2i];\n+//! let last_numbers = numbers.slice(1, 3);\n+//! // last_numbers is now &[1i, 2i]\n //! ```\n //!\n //! ## Implementations of other traits\n@@ -615,7 +610,7 @@ impl<'a,T> MutableSliceAllocating<'a, T> for &'a mut [T] {\n \n     #[inline]\n     fn move_from(self, mut src: Vec<T>, start: uint, end: uint) -> uint {\n-        for (a, b) in self.iter_mut().zip(src[mut start..end].iter_mut()) {\n+        for (a, b) in self.iter_mut().zip(src.slice_mut(start, end).iter_mut()) {\n             mem::swap(a, b);\n         }\n         cmp::min(self.len(), end-start)\n@@ -707,7 +702,7 @@ impl<'a, T: Ord> MutableOrdSlice<T> for &'a mut [T] {\n         self.swap(j, i-1);\n \n         // Step 4: Reverse the (previously) weakly decreasing part\n-        self[mut i..].reverse();\n+        self.slice_from_mut(i).reverse();\n \n         true\n     }\n@@ -728,7 +723,7 @@ impl<'a, T: Ord> MutableOrdSlice<T> for &'a mut [T] {\n         }\n \n         // Step 2: Reverse the weakly increasing part\n-        self[mut i..].reverse();\n+        self.slice_from_mut(i).reverse();\n \n         // Step 3: Find the rightmost element equal to or bigger than the pivot (i-1)\n         let mut j = self.len() - 1;\n@@ -995,24 +990,24 @@ mod tests {\n     fn test_slice() {\n         // Test fixed length vector.\n         let vec_fixed = [1i, 2, 3, 4];\n-        let v_a = vec_fixed[1u..vec_fixed.len()].to_vec();\n+        let v_a = vec_fixed.slice(1u, vec_fixed.len()).to_vec();\n         assert_eq!(v_a.len(), 3u);\n         let v_a = v_a.as_slice();\n         assert_eq!(v_a[0], 2);\n         assert_eq!(v_a[1], 3);\n         assert_eq!(v_a[2], 4);\n \n         // Test on stack.\n-        let vec_stack: &[_] = &[1i, 2, 3];\n-        let v_b = vec_stack[1u..3u].to_vec();\n+        let vec_stack = &[1i, 2, 3];\n+        let v_b = vec_stack.slice(1u, 3u).to_vec();\n         assert_eq!(v_b.len(), 2u);\n         let v_b = v_b.as_slice();\n         assert_eq!(v_b[0], 2);\n         assert_eq!(v_b[1], 3);\n \n         // Test `Box<[T]>`\n         let vec_unique = vec![1i, 2, 3, 4, 5, 6];\n-        let v_d = vec_unique[1u..6u].to_vec();\n+        let v_d = vec_unique.slice(1u, 6u).to_vec();\n         assert_eq!(v_d.len(), 5u);\n         let v_d = v_d.as_slice();\n         assert_eq!(v_d[0], 2);\n@@ -1025,21 +1020,21 @@ mod tests {\n     #[test]\n     fn test_slice_from() {\n         let vec: &[int] = &[1, 2, 3, 4];\n-        assert_eq!(vec[0..], vec);\n+        assert_eq!(vec.slice_from(0), vec);\n         let b: &[int] = &[3, 4];\n-        assert_eq!(vec[2..], b);\n+        assert_eq!(vec.slice_from(2), b);\n         let b: &[int] = &[];\n-        assert_eq!(vec[4..], b);\n+        assert_eq!(vec.slice_from(4), b);\n     }\n \n     #[test]\n     fn test_slice_to() {\n         let vec: &[int] = &[1, 2, 3, 4];\n-        assert_eq!(vec[..4], vec);\n+        assert_eq!(vec.slice_to(4), vec);\n         let b: &[int] = &[1, 2];\n-        assert_eq!(vec[..2], b);\n+        assert_eq!(vec.slice_to(2), b);\n         let b: &[int] = &[];\n-        assert_eq!(vec[..0], b);\n+        assert_eq!(vec.slice_to(0), b);\n     }\n \n \n@@ -1980,7 +1975,7 @@ mod tests {\n         assert!(a == [7i,2,3,4]);\n         let mut a = [1i,2,3,4,5];\n         let b = vec![5i,6,7,8,9,0];\n-        assert_eq!(a[mut 2..4].move_from(b,1,6), 2);\n+        assert_eq!(a.slice_mut(2,4).move_from(b,1,6), 2);\n         assert!(a == [1i,2,6,7,5]);\n     }\n \n@@ -2000,7 +1995,7 @@ mod tests {\n     #[test]\n     fn test_reverse_part() {\n         let mut values = [1i,2,3,4,5];\n-        values[mut 1..4].reverse();\n+        values.slice_mut(1, 4).reverse();\n         assert!(values == [1,4,3,2,5]);\n     }\n \n@@ -2047,9 +2042,9 @@ mod tests {\n     fn test_bytes_set_memory() {\n         use slice::bytes::MutableByteVector;\n         let mut values = [1u8,2,3,4,5];\n-        values[mut 0..5].set_memory(0xAB);\n+        values.slice_mut(0,5).set_memory(0xAB);\n         assert!(values == [0xAB, 0xAB, 0xAB, 0xAB, 0xAB]);\n-        values[mut 2..4].set_memory(0xFF);\n+        values.slice_mut(2,4).set_memory(0xFF);\n         assert!(values == [0xAB, 0xAB, 0xFF, 0xFF, 0xAB]);\n     }\n \n@@ -2075,18 +2070,12 @@ mod tests {\n         let mut values = [1u8,2,3,4,5];\n         {\n             let (left, right) = values.split_at_mut(2);\n-            {\n-                let left: &[_] = left;\n-                assert!(left[0..left.len()] == [1, 2]);\n-            }\n+            assert!(left.slice(0, left.len()) == [1, 2]);\n             for p in left.iter_mut() {\n                 *p += 1;\n             }\n \n-            {\n-                let right: &[_] = right;\n-                assert!(right[0..right.len()] == [3, 4, 5]);\n-            }\n+            assert!(right.slice(0, right.len()) == [3, 4, 5]);\n             for p in right.iter_mut() {\n                 *p += 2;\n             }\n@@ -2110,7 +2099,7 @@ mod tests {\n         }\n         assert_eq!(cnt, 3);\n \n-        for f in v[1..3].iter() {\n+        for f in v.slice(1, 3).iter() {\n             assert!(*f == Foo);\n             cnt += 1;\n         }"}, {"sha": "d198e948ac83845837f2f04450714c371397f092", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -1680,7 +1680,7 @@ mod tests {\n         let mut bytes = [0u8, ..4];\n         for c in range(0u32, 0x110000).filter_map(|c| ::core::char::from_u32(c)) {\n             let len = c.encode_utf8(bytes).unwrap_or(0);\n-            let s = ::core::str::from_utf8(bytes[..len]).unwrap();\n+            let s = ::core::str::from_utf8(bytes.slice_to(len)).unwrap();\n             if Some(c) != s.chars().next() {\n                 fail!(\"character {:x}={} does not decode correctly\", c as u32, c);\n             }\n@@ -1692,7 +1692,7 @@ mod tests {\n         let mut bytes = [0u8, ..4];\n         for c in range(0u32, 0x110000).filter_map(|c| ::core::char::from_u32(c)) {\n             let len = c.encode_utf8(bytes).unwrap_or(0);\n-            let s = ::core::str::from_utf8(bytes[..len]).unwrap();\n+            let s = ::core::str::from_utf8(bytes.slice_to(len)).unwrap();\n             if Some(c) != s.chars().rev().next() {\n                 fail!(\"character {:x}={} does not decode correctly\", c as u32, c);\n             }"}, {"sha": "d6adbd302645a0ba7777242b2e3c2792e69091ca", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 3, "deletions": 32, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -160,7 +160,7 @@ impl String {\n \n         if i > 0 {\n             unsafe {\n-                res.as_mut_vec().push_all(v[..i])\n+                res.as_mut_vec().push_all(v.slice_to(i))\n             };\n         }\n \n@@ -177,7 +177,7 @@ impl String {\n             macro_rules! error(() => ({\n                 unsafe {\n                     if subseqidx != i_ {\n-                        res.as_mut_vec().push_all(v[subseqidx..i_]);\n+                        res.as_mut_vec().push_all(v.slice(subseqidx, i_));\n                     }\n                     subseqidx = i;\n                     res.as_mut_vec().push_all(REPLACEMENT);\n@@ -246,7 +246,7 @@ impl String {\n         }\n         if subseqidx < total {\n             unsafe {\n-                res.as_mut_vec().push_all(v[subseqidx..total])\n+                res.as_mut_vec().push_all(v.slice(subseqidx, total))\n             };\n         }\n         Owned(res.into_string())\n@@ -927,7 +927,6 @@ impl<S: Str> Add<S, String> for String {\n     }\n }\n \n-#[cfg(stage0)]\n impl ops::Slice<uint, str> for String {\n     #[inline]\n     fn as_slice_<'a>(&'a self) -> &'a str {\n@@ -950,34 +949,6 @@ impl ops::Slice<uint, str> for String {\n     }\n }\n \n-#[cfg(not(stage0))]\n-#[inline]\n-fn str_to_slice<'a, U: Str>(this: &'a U) -> &'a str {\n-    this.as_slice()\n-}\n-#[cfg(not(stage0))]\n-impl ops::Slice<uint, str> for String {\n-    #[inline]\n-    fn as_slice<'a>(&'a self) -> &'a str {\n-        str_to_slice(self)\n-    }\n-\n-    #[inline]\n-    fn slice_from<'a>(&'a self, from: &uint) -> &'a str {\n-        self[][*from..]\n-    }\n-\n-    #[inline]\n-    fn slice_to<'a>(&'a self, to: &uint) -> &'a str {\n-        self[][..*to]\n-    }\n-\n-    #[inline]\n-    fn slice<'a>(&'a self, from: &uint, to: &uint) -> &'a str {\n-        self[][*from..*to]\n-    }\n-}\n-\n /// Unsafe operations\n #[unstable = \"waiting on raw module conventions\"]\n pub mod raw {"}, {"sha": "e9981790f7dc08689b7e4c13f1ceba4499df7725", "filename": "src/libcollections/trie.rs", "status": "modified", "additions": 1, "deletions": 20, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibcollections%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibcollections%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftrie.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -24,7 +24,6 @@ use core::fmt;\n use core::fmt::Show;\n use core::mem::zeroed;\n use core::mem;\n-use core::ops::{Slice,SliceMut};\n use core::uint;\n use core::iter;\n use std::hash::{Writer, Hash};\n@@ -379,7 +378,7 @@ macro_rules! bound {\n                         }\n                     };\n                     // push to the stack.\n-                    it.stack[it.length] = children.$slice_from(&slice_idx).$iter();\n+                    it.stack[it.length] = children.$slice_from(slice_idx).$iter();\n                     it.length += 1;\n                     if ret { return it }\n                 })\n@@ -389,15 +388,6 @@ macro_rules! bound {\n \n impl<T> TrieMap<T> {\n     // If `upper` is true then returns upper_bound else returns lower_bound.\n-    #[cfg(stage0)]\n-    #[inline]\n-    fn bound<'a>(&'a self, key: uint, upper: bool) -> Entries<'a, T> {\n-        bound!(Entries, self = self,\n-               key = key, is_upper = upper,\n-               slice_from = slice_from_, iter = iter,\n-               mutability = )\n-    }\n-    #[cfg(not(stage0))]\n     #[inline]\n     fn bound<'a>(&'a self, key: uint, upper: bool) -> Entries<'a, T> {\n         bound!(Entries, self = self,\n@@ -440,15 +430,6 @@ impl<T> TrieMap<T> {\n         self.bound(key, true)\n     }\n     // If `upper` is true then returns upper_bound else returns lower_bound.\n-    #[cfg(stage0)]\n-    #[inline]\n-    fn bound_mut<'a>(&'a mut self, key: uint, upper: bool) -> MutEntries<'a, T> {\n-        bound!(MutEntries, self = self,\n-               key = key, is_upper = upper,\n-               slice_from = slice_from_mut_, iter = iter_mut,\n-               mutability = mut)\n-    }\n-    #[cfg(not(stage0))]\n     #[inline]\n     fn bound_mut<'a>(&'a mut self, key: uint, upper: bool) -> MutEntries<'a, T> {\n         bound!(MutEntries, self = self,"}, {"sha": "280fbdeffa23dfc2644904162a856dc33e318b56", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 25, "deletions": 85, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -24,7 +24,6 @@ use core::num;\n use core::ops;\n use core::ptr;\n use core::raw::Slice as RawSlice;\n-use core::slice::Slice as SliceSlice;\n use core::uint;\n \n use {Mutable, MutableSeq};\n@@ -439,7 +438,7 @@ impl<T:Clone> Clone for Vec<T> {\n \n         // self.len <= other.len due to the truncate above, so the\n         // slice here is always in-bounds.\n-        let slice = other[self.len()..];\n+        let slice = other.slice_from(self.len());\n         self.push_all(slice);\n     }\n }\n@@ -461,37 +460,6 @@ impl<T> Index<uint,T> for Vec<T> {\n     }\n }*/\n \n-// Annoying helper function because there are two Slice::as_slice functions in\n-// scope.\n-#[cfg(not(stage0))]\n-#[inline]\n-fn slice_to_slice<'a, T, U: Slice<T>>(this: &'a U) -> &'a [T] {\n-    this.as_slice()\n-}\n-\n-\n-#[cfg(not(stage0))]\n-impl<T> ops::Slice<uint, [T]> for Vec<T> {\n-    #[inline]\n-    fn as_slice<'a>(&'a self) -> &'a [T] {\n-        slice_to_slice(self)\n-    }\n-\n-    #[inline]\n-    fn slice_from<'a>(&'a self, start: &uint) -> &'a [T] {\n-        slice_to_slice(self).slice_from(start)\n-    }\n-\n-    #[inline]\n-    fn slice_to<'a>(&'a self, end: &uint) -> &'a [T] {\n-        slice_to_slice(self).slice_to(end)\n-    }\n-    #[inline]\n-    fn slice<'a>(&'a self, start: &uint, end: &uint) -> &'a [T] {\n-        slice_to_slice(self).slice(start, end)\n-    }\n-}\n-#[cfg(stage0)]\n impl<T> ops::Slice<uint, [T]> for Vec<T> {\n     #[inline]\n     fn as_slice_<'a>(&'a self) -> &'a [T] {\n@@ -513,28 +481,6 @@ impl<T> ops::Slice<uint, [T]> for Vec<T> {\n     }\n }\n \n-#[cfg(not(stage0))]\n-impl<T> ops::SliceMut<uint, [T]> for Vec<T> {\n-    #[inline]\n-    fn as_mut_slice<'a>(&'a mut self) -> &'a mut [T] {\n-        self.as_mut_slice()\n-    }\n-\n-    #[inline]\n-    fn slice_from_mut<'a>(&'a mut self, start: &uint) -> &'a mut [T] {\n-        self.as_mut_slice().slice_from_mut(start)\n-    }\n-\n-    #[inline]\n-    fn slice_to_mut<'a>(&'a mut self, end: &uint) -> &'a mut [T] {\n-        self.as_mut_slice().slice_to_mut(end)\n-    }\n-    #[inline]\n-    fn slice_mut<'a>(&'a mut self, start: &uint, end: &uint) -> &'a mut [T] {\n-        self.as_mut_slice().slice_mut(start, end)\n-    }\n-}\n-#[cfg(stage0)]\n impl<T> ops::SliceMut<uint, [T]> for Vec<T> {\n     #[inline]\n     fn as_mut_slice_<'a>(&'a mut self) -> &'a mut [T] {\n@@ -982,11 +928,11 @@ impl<T> Vec<T> {\n     ///\n     /// ```\n     /// let vec = vec![1i, 2, 3, 4];\n-    /// assert!(vec[0..2] == [1, 2]);\n+    /// assert!(vec.slice(0, 2) == [1, 2]);\n     /// ```\n     #[inline]\n     pub fn slice<'a>(&'a self, start: uint, end: uint) -> &'a [T] {\n-        self[start..end]\n+        self.as_slice().slice(start, end)\n     }\n \n     /// Returns a slice containing all but the first element of the vector.\n@@ -1003,7 +949,7 @@ impl<T> Vec<T> {\n     /// ```\n     #[inline]\n     pub fn tail<'a>(&'a self) -> &'a [T] {\n-        self[].tail()\n+        self.as_slice().tail()\n     }\n \n     /// Returns all but the first `n' elements of a vector.\n@@ -1022,7 +968,7 @@ impl<T> Vec<T> {\n     #[inline]\n     #[deprecated = \"use slice_from\"]\n     pub fn tailn<'a>(&'a self, n: uint) -> &'a [T] {\n-        self[n..]\n+        self.as_slice().slice_from(n)\n     }\n \n     /// Returns a reference to the last element of a vector, or `None` if it is\n@@ -1036,7 +982,7 @@ impl<T> Vec<T> {\n     /// ```\n     #[inline]\n     pub fn last<'a>(&'a self) -> Option<&'a T> {\n-        self[].last()\n+        self.as_slice().last()\n     }\n \n     /// Deprecated: use `last_mut`.\n@@ -1230,10 +1176,10 @@ impl<T> Vec<T> {\n     }\n \n     /// Deprecated: use `slice_mut`.\n-    #[deprecated = \"use slice_from\"]\n+    #[deprecated = \"use slice_mut\"]\n     pub fn mut_slice<'a>(&'a mut self, start: uint, end: uint)\n                          -> &'a mut [T] {\n-        self[mut start..end]\n+        self.slice_mut(start, end)\n     }\n \n     /// Returns a mutable slice of `self` between `start` and `end`.\n@@ -1247,18 +1193,18 @@ impl<T> Vec<T> {\n     ///\n     /// ```\n     /// let mut vec = vec![1i, 2, 3, 4];\n-    /// assert!(vec[mut 0..2] == [1, 2]);\n+    /// assert!(vec.slice_mut(0, 2) == [1, 2]);\n     /// ```\n     #[inline]\n     pub fn slice_mut<'a>(&'a mut self, start: uint, end: uint)\n                          -> &'a mut [T] {\n-        self[mut start..end]\n+        self.as_mut_slice().slice_mut(start, end)\n     }\n \n     /// Deprecated: use \"slice_from_mut\".\n     #[deprecated = \"use slice_from_mut\"]\n     pub fn mut_slice_from<'a>(&'a mut self, start: uint) -> &'a mut [T] {\n-        self[mut start..]\n+        self.slice_from_mut(start)\n     }\n \n     /// Returns a mutable slice of `self` from `start` to the end of the `Vec`.\n@@ -1271,17 +1217,17 @@ impl<T> Vec<T> {\n     ///\n     /// ```\n     /// let mut vec = vec![1i, 2, 3, 4];\n-    /// assert!(vec[mut 2..] == [3, 4]);\n+    /// assert!(vec.slice_from_mut(2) == [3, 4]);\n     /// ```\n     #[inline]\n     pub fn slice_from_mut<'a>(&'a mut self, start: uint) -> &'a mut [T] {\n-        self[mut start..]\n+        self.as_mut_slice().slice_from_mut(start)\n     }\n \n     /// Deprecated: use `slice_to_mut`.\n     #[deprecated = \"use slice_to_mut\"]\n     pub fn mut_slice_to<'a>(&'a mut self, end: uint) -> &'a mut [T] {\n-        self[mut ..end]\n+        self.slice_to_mut(end)\n     }\n \n     /// Returns a mutable slice of `self` from the start of the `Vec` to `end`.\n@@ -1294,11 +1240,11 @@ impl<T> Vec<T> {\n     ///\n     /// ```\n     /// let mut vec = vec![1i, 2, 3, 4];\n-    /// assert!(vec[mut ..2] == [1, 2]);\n+    /// assert!(vec.slice_to_mut(2) == [1, 2]);\n     /// ```\n     #[inline]\n     pub fn slice_to_mut<'a>(&'a mut self, end: uint) -> &'a mut [T] {\n-        self[mut ..end]\n+        self.as_mut_slice().slice_to_mut(end)\n     }\n \n     /// Deprecated: use `split_at_mut`.\n@@ -1343,7 +1289,7 @@ impl<T> Vec<T> {\n     /// ```\n     #[inline]\n     pub fn split_at_mut<'a>(&'a mut self, mid: uint) -> (&'a mut [T], &'a mut [T]) {\n-        self[mut].split_at_mut(mid)\n+        self.as_mut_slice().split_at_mut(mid)\n     }\n \n     /// Reverses the order of elements in a vector, in place.\n@@ -1357,7 +1303,7 @@ impl<T> Vec<T> {\n     /// ```\n     #[inline]\n     pub fn reverse(&mut self) {\n-        self[mut].reverse()\n+        self.as_mut_slice().reverse()\n     }\n \n     /// Returns a slice of `self` from `start` to the end of the vec.\n@@ -1370,11 +1316,11 @@ impl<T> Vec<T> {\n     ///\n     /// ```\n     /// let vec = vec![1i, 2, 3];\n-    /// assert!(vec[1..] == [2, 3]);\n+    /// assert!(vec.slice_from(1) == [2, 3]);\n     /// ```\n     #[inline]\n     pub fn slice_from<'a>(&'a self, start: uint) -> &'a [T] {\n-        self[start..]\n+        self.as_slice().slice_from(start)\n     }\n \n     /// Returns a slice of self from the start of the vec to `end`.\n@@ -1387,11 +1333,11 @@ impl<T> Vec<T> {\n     ///\n     /// ```\n     /// let vec = vec![1i, 2, 3, 4];\n-    /// assert!(vec[..2] == [1, 2]);\n+    /// assert!(vec.slice_to(2) == [1, 2]);\n     /// ```\n     #[inline]\n     pub fn slice_to<'a>(&'a self, end: uint) -> &'a [T] {\n-        self[..end]\n+        self.as_slice().slice_to(end)\n     }\n \n     /// Returns a slice containing all but the last element of the vector.\n@@ -1408,7 +1354,7 @@ impl<T> Vec<T> {\n     /// ```\n     #[inline]\n     pub fn init<'a>(&'a self) -> &'a [T] {\n-        self[0..self.len() - 1]\n+        self.slice(0, self.len() - 1)\n     }\n \n \n@@ -2266,18 +2212,12 @@ mod tests {\n         let mut values = Vec::from_slice([1u8,2,3,4,5]);\n         {\n             let (left, right) = values.split_at_mut(2);\n-            {\n-                let left: &[_] = left;\n-                assert!(left[0..left.len()] == [1, 2]);\n-            }\n+            assert!(left.slice(0, left.len()) == [1, 2]);\n             for p in left.iter_mut() {\n                 *p += 1;\n             }\n \n-            {\n-                let right: &[_] = right;\n-                assert!(right[0..right.len()] == [3, 4, 5]);\n-            }\n+            assert!(right.slice(0, right.len()) == [3, 4, 5]);\n             for p in right.iter_mut() {\n                 *p += 2;\n             }"}, {"sha": "92ef0c281f282eecc5095b4a9d226925e4fc02b5", "filename": "src/libcore/fmt/float.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibcore%2Ffmt%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibcore%2Ffmt%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Ffloat.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -17,7 +17,7 @@ use iter::{range, DoubleEndedIterator};\n use num::{Float, FPNaN, FPInfinite, ToPrimitive, Primitive};\n use num::{Zero, One, cast};\n use result::Ok;\n-use slice::MutableSlice;\n+use slice::{ImmutableSlice, MutableSlice};\n use slice;\n use str::StrSlice;\n \n@@ -173,7 +173,7 @@ pub fn float_to_str_bytes_common<T: Primitive + Float, U>(\n         _ => ()\n     }\n \n-    buf[mut ..end].reverse();\n+    buf.slice_to_mut(end).reverse();\n \n     // Remember start of the fractional digits.\n     // Points one beyond end of buf if none get generated,\n@@ -310,7 +310,7 @@ pub fn float_to_str_bytes_common<T: Primitive + Float, U>(\n \n             impl<'a> fmt::FormatWriter for Filler<'a> {\n                 fn write(&mut self, bytes: &[u8]) -> fmt::Result {\n-                    slice::bytes::copy_memory(self.buf[mut *self.end..],\n+                    slice::bytes::copy_memory(self.buf.slice_from_mut(*self.end),\n                                               bytes);\n                     *self.end += bytes.len();\n                     Ok(())\n@@ -328,5 +328,5 @@ pub fn float_to_str_bytes_common<T: Primitive + Float, U>(\n         }\n     }\n \n-    f(buf[..end])\n+    f(buf.slice_to(end))\n }"}, {"sha": "7bab59960b0fea938d1f633a7bbba580ca8f3423", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -423,7 +423,7 @@ impl<'a> Formatter<'a> {\n             for c in sign.into_iter() {\n                 let mut b = [0, ..4];\n                 let n = c.encode_utf8(b).unwrap_or(0);\n-                try!(f.buf.write(b[..n]));\n+                try!(f.buf.write(b.slice_to(n)));\n             }\n             if prefixed { f.buf.write(prefix.as_bytes()) }\n             else { Ok(()) }\n@@ -530,13 +530,13 @@ impl<'a> Formatter<'a> {\n         let len = self.fill.encode_utf8(fill).unwrap_or(0);\n \n         for _ in range(0, pre_pad) {\n-            try!(self.buf.write(fill[..len]));\n+            try!(self.buf.write(fill.slice_to(len)));\n         }\n \n         try!(f(self));\n \n         for _ in range(0, post_pad) {\n-            try!(self.buf.write(fill[..len]));\n+            try!(self.buf.write(fill.slice_to(len)));\n         }\n \n         Ok(())\n@@ -611,7 +611,7 @@ impl Char for char {\n \n         let mut utf8 = [0u8, ..4];\n         let amt = self.encode_utf8(utf8).unwrap_or(0);\n-        let s: &str = unsafe { mem::transmute(utf8[..amt]) };\n+        let s: &str = unsafe { mem::transmute(utf8.slice_to(amt)) };\n         secret_string(&s, f)\n     }\n }"}, {"sha": "afcd0d1d645e6d9e38cf87e626ada16c1b094923", "filename": "src/libcore/fmt/num.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibcore%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibcore%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fnum.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -18,7 +18,7 @@ use collections::Collection;\n use fmt;\n use iter::DoubleEndedIterator;\n use num::{Int, cast, zero};\n-use slice::{MutableSlice};\n+use slice::{ImmutableSlice, MutableSlice};\n \n /// A type that represents a specific radix\n #[doc(hidden)]\n@@ -60,7 +60,7 @@ trait GenericRadix {\n                 if x == zero() { break; }                 // No more digits left to accumulate.\n             }\n         }\n-        f.pad_integral(is_positive, self.prefix(), buf[curr..])\n+        f.pad_integral(is_positive, self.prefix(), buf.slice_from(curr))\n     }\n }\n "}, {"sha": "7e2ea492d4ccfc77e1506374adae623b38809270", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -57,9 +57,8 @@\n        html_playground_url = \"http://play.rust-lang.org/\")]\n \n #![no_std]\n-#![allow(unknown_features)]\n #![feature(globs, intrinsics, lang_items, macro_rules, managed_boxes, phase)]\n-#![feature(simd, unsafe_destructor, slicing_syntax)]\n+#![feature(simd, unsafe_destructor)]\n #![deny(missing_doc)]\n \n mod macros;"}, {"sha": "ad0f128a02e783a39bc48dd5ceaae7ce34e961f4", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 13, "deletions": 44, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -684,23 +684,23 @@ pub trait IndexMut<Index, Result> {\n  * A trivial implementation of `Slice`. When `Foo[..Foo]` happens, it ends up\n  * calling `slice_to`, and therefore, `main` prints `Slicing!`.\n  *\n- * ```ignore\n+ * ```\n  * struct Foo;\n  *\n  * impl ::core::ops::Slice<Foo, Foo> for Foo {\n- *     fn as_slice<'a>(&'a self) -> &'a Foo {\n+ *     fn as_slice_<'a>(&'a self) -> &'a Foo {\n  *         println!(\"Slicing!\");\n  *         self\n  *     }\n- *     fn slice_from<'a>(&'a self, from: &Foo) -> &'a Foo {\n+ *     fn slice_from_<'a>(&'a self, from: &Foo) -> &'a Foo {\n  *         println!(\"Slicing!\");\n  *         self\n  *     }\n- *     fn slice_to<'a>(&'a self, to: &Foo) -> &'a Foo {\n+ *     fn slice_to_<'a>(&'a self, to: &Foo) -> &'a Foo {\n  *         println!(\"Slicing!\");\n  *         self\n  *     }\n- *     fn slice<'a>(&'a self, from: &Foo, to: &Foo) -> &'a Foo {\n+ *     fn slice_<'a>(&'a self, from: &Foo, to: &Foo) -> &'a Foo {\n  *         println!(\"Slicing!\");\n  *         self\n  *     }\n@@ -711,22 +711,7 @@ pub trait IndexMut<Index, Result> {\n  * }\n  * ```\n  */\n-#[cfg(not(stage0))]\n-#[lang=\"slice\"]\n-pub trait Slice<Idx, Sized? Result> for Sized? {\n-    /// The method for the slicing operation foo[]\n-    fn as_slice<'a>(&'a self) -> &'a Result;\n-    /// The method for the slicing operation foo[from..]\n-    fn slice_from<'a>(&'a self, from: &Idx) -> &'a Result;\n-    /// The method for the slicing operation foo[..to]\n-    fn slice_to<'a>(&'a self, to: &Idx) -> &'a Result;\n-    /// The method for the slicing operation foo[from..to]\n-    fn slice<'a>(&'a self, from: &Idx, to: &Idx) -> &'a Result;\n-}\n-/**\n- *\n- */\n-#[cfg(stage0)]\n+// FIXME(#17273) remove the postscript _s\n #[lang=\"slice\"]\n pub trait Slice<Idx, Sized? Result> for Sized? {\n     /// The method for the slicing operation foo[]\n@@ -749,49 +734,34 @@ pub trait Slice<Idx, Sized? Result> for Sized? {\n  * A trivial implementation of `SliceMut`. When `Foo[Foo..]` happens, it ends up\n  * calling `slice_from_mut`, and therefore, `main` prints `Slicing!`.\n  *\n- * ```ignore\n+ * ```\n  * struct Foo;\n  *\n  * impl ::core::ops::SliceMut<Foo, Foo> for Foo {\n- *     fn as_mut_slice<'a>(&'a mut self) -> &'a mut Foo {\n+ *     fn as_mut_slice_<'a>(&'a mut self) -> &'a mut Foo {\n  *         println!(\"Slicing!\");\n  *         self\n  *     }\n- *     fn slice_from_mut<'a>(&'a mut self, from: &Foo) -> &'a mut Foo {\n+ *     fn slice_from_mut_<'a>(&'a mut self, from: &Foo) -> &'a mut Foo {\n  *         println!(\"Slicing!\");\n  *         self\n  *     }\n- *     fn slice_to_mut<'a>(&'a mut self, to: &Foo) -> &'a mut Foo {\n+ *     fn slice_to_mut_<'a>(&'a mut self, to: &Foo) -> &'a mut Foo {\n  *         println!(\"Slicing!\");\n  *         self\n  *     }\n- *     fn slice_mut<'a>(&'a mut self, from: &Foo, to: &Foo) -> &'a mut Foo {\n+ *     fn slice_mut_<'a>(&'a mut self, from: &Foo, to: &Foo) -> &'a mut Foo {\n  *         println!(\"Slicing!\");\n  *         self\n  *     }\n  * }\n  *\n- * pub fn main() {\n+ * fn main() {\n  *     Foo[mut Foo..];\n  * }\n  * ```\n  */\n-#[cfg(not(stage0))]\n-#[lang=\"slice_mut\"]\n-pub trait SliceMut<Idx, Sized? Result> for Sized? {\n-    /// The method for the slicing operation foo[]\n-    fn as_mut_slice<'a>(&'a mut self) -> &'a mut Result;\n-    /// The method for the slicing operation foo[from..]\n-    fn slice_from_mut<'a>(&'a mut self, from: &Idx) -> &'a mut Result;\n-    /// The method for the slicing operation foo[..to]\n-    fn slice_to_mut<'a>(&'a mut self, to: &Idx) -> &'a mut Result;\n-    /// The method for the slicing operation foo[from..to]\n-    fn slice_mut<'a>(&'a mut self, from: &Idx, to: &Idx) -> &'a mut Result;\n-}\n-/**\n- *\n- */\n-#[cfg(stage0)]\n+// FIXME(#17273) remove the postscript _s\n #[lang=\"slice_mut\"]\n pub trait SliceMut<Idx, Sized? Result> for Sized? {\n     /// The method for the slicing operation foo[mut]\n@@ -803,7 +773,6 @@ pub trait SliceMut<Idx, Sized? Result> for Sized? {\n     /// The method for the slicing operation foo[mut from..to]\n     fn slice_mut_<'a>(&'a mut self, from: &Idx, to: &Idx) -> &'a mut Result;\n }\n-\n /**\n  *\n  * The `Deref` trait is used to specify the functionality of dereferencing"}, {"sha": "1a00107a216321cbfb369038c4d6330da01cea61", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 136, "deletions": 81, "changes": 217, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -61,6 +61,31 @@ use raw::Slice as RawSlice;\n /// Extension methods for immutable slices.\n #[unstable = \"may merge with other traits; region parameter may disappear\"]\n pub trait ImmutableSlice<'a, T> {\n+    /// Returns a subslice spanning the interval [`start`, `end`).\n+    ///\n+    /// Fails when the end of the new slice lies beyond the end of the\n+    /// original slice (i.e. when `end > self.len()`) or when `start > end`.\n+    ///\n+    /// Slicing with `start` equal to `end` yields an empty slice.\n+    #[unstable = \"waiting on final error conventions\"]\n+    fn slice(&self, start: uint, end: uint) -> &'a [T];\n+\n+    /// Returns a subslice from `start` to the end of the slice.\n+    ///\n+    /// Fails when `start` is strictly greater than the length of the original slice.\n+    ///\n+    /// Slicing from `self.len()` yields an empty slice.\n+    #[unstable = \"waiting on final error conventions\"]\n+    fn slice_from(&self, start: uint) -> &'a [T];\n+\n+    /// Returns a subslice from the start of the slice to `end`.\n+    ///\n+    /// Fails when `end` is strictly greater than the length of the original slice.\n+    ///\n+    /// Slicing to `0` yields an empty slice.\n+    #[unstable = \"waiting on final error conventions\"]\n+    fn slice_to(&self, end: uint) -> &'a [T];\n+\n     /// Divides one slice into two at an index.\n     ///\n     /// The first will contain all indices from `[0, mid)` (excluding\n@@ -215,7 +240,7 @@ pub trait ImmutableSlice<'a, T> {\n      * ```ignore\n      *     if self.len() == 0 { return None }\n      *     let head = &self[0];\n-     *     *self = self[1..];\n+     *     *self = self.slice_from(1);\n      *     Some(head)\n      * ```\n      *\n@@ -234,7 +259,7 @@ pub trait ImmutableSlice<'a, T> {\n      * ```ignore\n      *     if self.len() == 0 { return None; }\n      *     let tail = &self[self.len() - 1];\n-     *     *self = self[..self.len() - 1];\n+     *     *self = self.slice_to(self.len() - 1);\n      *     Some(tail)\n      * ```\n      *\n@@ -246,9 +271,31 @@ pub trait ImmutableSlice<'a, T> {\n \n #[unstable]\n impl<'a,T> ImmutableSlice<'a, T> for &'a [T] {\n+    #[inline]\n+    fn slice(&self, start: uint, end: uint) -> &'a [T] {\n+        assert!(start <= end);\n+        assert!(end <= self.len());\n+        unsafe {\n+            transmute(RawSlice {\n+                    data: self.as_ptr().offset(start as int),\n+                    len: (end - start)\n+                })\n+        }\n+    }\n+\n+    #[inline]\n+    fn slice_from(&self, start: uint) -> &'a [T] {\n+        self.slice(start, self.len())\n+    }\n+\n+    #[inline]\n+    fn slice_to(&self, end: uint) -> &'a [T] {\n+        self.slice(0, end)\n+    }\n+\n     #[inline]\n     fn split_at(&self, mid: uint) -> (&'a [T], &'a [T]) {\n-        ((*self)[..mid], (*self)[mid..])\n+        (self.slice(0, mid), self.slice(mid, self.len()))\n     }\n \n     #[inline]\n@@ -317,21 +364,21 @@ impl<'a,T> ImmutableSlice<'a, T> for &'a [T] {\n     }\n \n     #[inline]\n-    fn tail(&self) -> &'a [T] { (*self)[1..] }\n+    fn tail(&self) -> &'a [T] { self.slice(1, self.len()) }\n \n     #[inline]\n     #[deprecated = \"use slice_from\"]\n-    fn tailn(&self, n: uint) -> &'a [T] { (*self)[n..] }\n+    fn tailn(&self, n: uint) -> &'a [T] { self.slice(n, self.len()) }\n \n     #[inline]\n     fn init(&self) -> &'a [T] {\n-        (*self)[..self.len() - 1]\n+        self.slice(0, self.len() - 1)\n     }\n \n     #[inline]\n     #[deprecated = \"use slice_to but note the arguments are different\"]\n     fn initn(&self, n: uint) -> &'a [T] {\n-        (*self)[..self.len() - n]\n+        self.slice(0, self.len() - n)\n     }\n \n     #[inline]\n@@ -417,35 +464,6 @@ impl<'a,T> ImmutableSlice<'a, T> for &'a [T] {\n     }\n }\n \n-#[cfg(not(stage0))]\n-impl<T> ops::Slice<uint, [T]> for [T] {\n-    #[inline]\n-    fn as_slice<'a>(&'a self) -> &'a [T] {\n-        self\n-    }\n-\n-    #[inline]\n-    fn slice_from<'a>(&'a self, start: &uint) -> &'a [T] {\n-        self.slice(start, &self.len())\n-    }\n-\n-    #[inline]\n-    fn slice_to<'a>(&'a self, end: &uint) -> &'a [T] {\n-        self.slice(&0, end)\n-    }\n-    #[inline]\n-    fn slice<'a>(&'a self, start: &uint, end: &uint) -> &'a [T] {\n-        assert!(*start <= *end);\n-        assert!(*end <= self.len());\n-        unsafe {\n-            transmute(RawSlice {\n-                    data: self.as_ptr().offset(*start as int),\n-                    len: (*end - *start)\n-                })\n-        }\n-    }\n-}\n-#[cfg(stage0)]\n impl<T> ops::Slice<uint, [T]> for [T] {\n     #[inline]\n     fn as_slice_<'a>(&'a self) -> &'a [T] {\n@@ -473,36 +491,7 @@ impl<T> ops::Slice<uint, [T]> for [T] {\n         }\n     }\n }\n-#[cfg(not(stage0))]\n-impl<T> ops::SliceMut<uint, [T]> for [T] {\n-    #[inline]\n-    fn as_mut_slice<'a>(&'a mut self) -> &'a mut [T] {\n-        self\n-    }\n \n-    #[inline]\n-    fn slice_from_mut<'a>(&'a mut self, start: &uint) -> &'a mut [T] {\n-        let len = &self.len();\n-        self.slice_mut(start, len)\n-    }\n-\n-    #[inline]\n-    fn slice_to_mut<'a>(&'a mut self, end: &uint) -> &'a mut [T] {\n-        self.slice_mut(&0, end)\n-    }\n-    #[inline]\n-    fn slice_mut<'a>(&'a mut self, start: &uint, end: &uint) -> &'a mut [T] {\n-        assert!(*start <= *end);\n-        assert!(*end <= self.len());\n-        unsafe {\n-            transmute(RawSlice {\n-                    data: self.as_ptr().offset(*start as int),\n-                    len: (*end - *start)\n-                })\n-        }\n-    }\n-}\n-#[cfg(stage0)]\n impl<T> ops::SliceMut<uint, [T]> for [T] {\n     #[inline]\n     fn as_mut_slice_<'a>(&'a mut self) -> &'a mut [T] {\n@@ -544,6 +533,49 @@ pub trait MutableSlice<'a, T> {\n     /// Primarily intended for getting a &mut [T] from a [T, ..N].\n     fn as_mut_slice(self) -> &'a mut [T];\n \n+    /// Deprecated: use `slice_mut`.\n+    #[deprecated = \"use slice_mut\"]\n+    fn mut_slice(self, start: uint, end: uint) -> &'a mut [T] {\n+        self.slice_mut(start, end)\n+    }\n+\n+    /// Returns a mutable subslice spanning the interval [`start`, `end`).\n+    ///\n+    /// Fails when the end of the new slice lies beyond the end of the\n+    /// original slice (i.e. when `end > self.len()`) or when `start > end`.\n+    ///\n+    /// Slicing with `start` equal to `end` yields an empty slice.\n+    #[unstable = \"waiting on final error conventions\"]\n+    fn slice_mut(self, start: uint, end: uint) -> &'a mut [T];\n+\n+    /// Deprecated: use `slice_from_mut`.\n+    #[deprecated = \"use slice_from_mut\"]\n+    fn mut_slice_from(self, start: uint) -> &'a mut [T] {\n+        self.slice_from_mut(start)\n+    }\n+\n+    /// Returns a mutable subslice from `start` to the end of the slice.\n+    ///\n+    /// Fails when `start` is strictly greater than the length of the original slice.\n+    ///\n+    /// Slicing from `self.len()` yields an empty slice.\n+    #[unstable = \"waiting on final error conventions\"]\n+    fn slice_from_mut(self, start: uint) -> &'a mut [T];\n+\n+    /// Deprecated: use `slice_to_mut`.\n+    #[deprecated = \"use slice_to_mut\"]\n+    fn mut_slice_to(self, end: uint) -> &'a mut [T] {\n+        self.slice_to_mut(end)\n+    }\n+\n+    /// Returns a mutable subslice from the start of the slice to `end`.\n+    ///\n+    /// Fails when `end` is strictly greater than the length of the original slice.\n+    ///\n+    /// Slicing to `0` yields an empty slice.\n+    #[unstable = \"waiting on final error conventions\"]\n+    fn slice_to_mut(self, end: uint) -> &'a mut [T];\n+\n     /// Deprecated: use `iter_mut`.\n     #[deprecated = \"use iter_mut\"]\n     fn mut_iter(self) -> MutItems<'a, T> {\n@@ -627,7 +659,7 @@ pub trait MutableSlice<'a, T> {\n      * ```ignore\n      *     if self.len() == 0 { return None; }\n      *     let head = &mut self[0];\n-     *     *self = self[mut 1..];\n+     *     *self = self.slice_from_mut(1);\n      *     Some(head)\n      * ```\n      *\n@@ -646,7 +678,7 @@ pub trait MutableSlice<'a, T> {\n      * ```ignore\n      *     if self.len() == 0 { return None; }\n      *     let tail = &mut self[self.len() - 1];\n-     *     *self = self[mut ..self.len() - 1];\n+     *     *self = self.slice_to_mut(self.len() - 1);\n      *     Some(tail)\n      * ```\n      *\n@@ -771,11 +803,34 @@ impl<'a,T> MutableSlice<'a, T> for &'a mut [T] {\n     #[inline]\n     fn as_mut_slice(self) -> &'a mut [T] { self }\n \n+    fn slice_mut(self, start: uint, end: uint) -> &'a mut [T] {\n+        assert!(start <= end);\n+        assert!(end <= self.len());\n+        unsafe {\n+            transmute(RawSlice {\n+                    data: self.as_mut_ptr().offset(start as int) as *const T,\n+                    len: (end - start)\n+                })\n+        }\n+    }\n+\n+    #[inline]\n+    fn slice_from_mut(self, start: uint) -> &'a mut [T] {\n+        let len = self.len();\n+        self.slice_mut(start, len)\n+    }\n+\n+    #[inline]\n+    fn slice_to_mut(self, end: uint) -> &'a mut [T] {\n+        self.slice_mut(0, end)\n+    }\n+\n     #[inline]\n     fn split_at_mut(self, mid: uint) -> (&'a mut [T], &'a mut [T]) {\n         unsafe {\n+            let len = self.len();\n             let self2: &'a mut [T] = mem::transmute_copy(&self);\n-            (self[mut ..mid], self2[mut mid..])\n+            (self.slice_mut(0, mid), self2.slice_mut(mid, len))\n         }\n     }\n \n@@ -812,13 +867,13 @@ impl<'a,T> MutableSlice<'a, T> for &'a mut [T] {\n     #[inline]\n     fn tail_mut(self) -> &'a mut [T] {\n         let len = self.len();\n-        self[mut 1..len]\n+        self.slice_mut(1, len)\n     }\n \n     #[inline]\n     fn init_mut(self) -> &'a mut [T] {\n         let len = self.len();\n-        self[mut 0..len - 1]\n+        self.slice_mut(0, len - 1)\n     }\n \n     #[inline]\n@@ -965,13 +1020,13 @@ impl<'a,T:PartialEq> ImmutablePartialEqSlice<T> for &'a [T] {\n     #[inline]\n     fn starts_with(&self, needle: &[T]) -> bool {\n         let n = needle.len();\n-        self.len() >= n && needle == (*self)[..n]\n+        self.len() >= n && needle == self.slice_to(n)\n     }\n \n     #[inline]\n     fn ends_with(&self, needle: &[T]) -> bool {\n         let (m, n) = (self.len(), needle.len());\n-        m >= n && needle == (*self)[m-n..]\n+        m >= n && needle == self.slice_from(m - n)\n     }\n }\n \n@@ -1244,8 +1299,8 @@ impl<'a, T> Iterator<&'a [T]> for Splits<'a, T> {\n         match self.v.iter().position(|x| (self.pred)(x)) {\n             None => self.finish(),\n             Some(idx) => {\n-                let ret = Some(self.v[..idx]);\n-                self.v = self.v[idx + 1..];\n+                let ret = Some(self.v.slice(0, idx));\n+                self.v = self.v.slice(idx + 1, self.v.len());\n                 ret\n             }\n         }\n@@ -1270,8 +1325,8 @@ impl<'a, T> DoubleEndedIterator<&'a [T]> for Splits<'a, T> {\n         match self.v.iter().rposition(|x| (self.pred)(x)) {\n             None => self.finish(),\n             Some(idx) => {\n-                let ret = Some(self.v[idx + 1..]);\n-                self.v = self.v[..idx];\n+                let ret = Some(self.v.slice(idx + 1, self.v.len()));\n+                self.v = self.v.slice(0, idx);\n                 ret\n             }\n         }\n@@ -1321,7 +1376,7 @@ impl<'a, T> Iterator<&'a mut [T]> for MutSplits<'a, T> {\n             Some(idx) => {\n                 let tmp = mem::replace(&mut self.v, &mut []);\n                 let (head, tail) = tmp.split_at_mut(idx);\n-                self.v = tail[mut 1..];\n+                self.v = tail.slice_from_mut(1);\n                 Some(head)\n             }\n         }\n@@ -1355,7 +1410,7 @@ impl<'a, T> DoubleEndedIterator<&'a mut [T]> for MutSplits<'a, T> {\n                 let tmp = mem::replace(&mut self.v, &mut []);\n                 let (head, tail) = tmp.split_at_mut(idx);\n                 self.v = head;\n-                Some(tail[mut 1..])\n+                Some(tail.slice_from_mut(1))\n             }\n         }\n     }\n@@ -1403,8 +1458,8 @@ impl<'a, T> Iterator<&'a [T]> for Windows<'a, T> {\n         if self.size > self.v.len() {\n             None\n         } else {\n-            let ret = Some(self.v[..self.size]);\n-            self.v = self.v[1..];\n+            let ret = Some(self.v.slice(0, self.size));\n+            self.v = self.v.slice(1, self.v.len());\n             ret\n         }\n     }\n@@ -1488,7 +1543,7 @@ impl<'a, T> RandomAccessIterator<&'a [T]> for Chunks<'a, T> {\n             let mut hi = lo + self.size;\n             if hi < lo || hi > self.v.len() { hi = self.v.len(); }\n \n-            Some(self.v[lo..hi])\n+            Some(self.v.slice(lo, hi))\n         } else {\n             None\n         }"}, {"sha": "fd7c63a6b3262c353f0e4b618c35a0d489cc24b9", "filename": "src/libcore/str.rs", "status": "modified", "additions": 31, "deletions": 69, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -30,7 +30,7 @@ use iter::range;\n use num::{CheckedMul, Saturating};\n use option::{Option, None, Some};\n use raw::Repr;\n-use slice::ImmutableSlice;\n+use slice::{ImmutableSlice, MutableSlice};\n use slice;\n use uint;\n \n@@ -393,7 +393,7 @@ impl NaiveSearcher {\n \n     fn next(&mut self, haystack: &[u8], needle: &[u8]) -> Option<(uint, uint)> {\n         while self.position + needle.len() <= haystack.len() {\n-            if haystack[self.position .. self.position + needle.len()] == needle {\n+            if haystack.slice(self.position, self.position + needle.len()) == needle {\n                 let match_pos = self.position;\n                 self.position += needle.len(); // add 1 for all matches\n                 return Some((match_pos, match_pos + needle.len()));\n@@ -514,10 +514,10 @@ impl TwoWaySearcher {\n         //\n         // What's going on is we have some critical factorization (u, v) of the\n         // needle, and we want to determine whether u is a suffix of\n-        // v[..period]. If it is, we use \"Algorithm CP1\". Otherwise we use\n+        // v.slice_to(period). If it is, we use \"Algorithm CP1\". Otherwise we use\n         // \"Algorithm CP2\", which is optimized for when the period of the needle\n         // is large.\n-        if needle[..crit_pos] == needle[period.. period + crit_pos] {\n+        if needle.slice_to(crit_pos) == needle.slice(period, period + crit_pos) {\n             TwoWaySearcher {\n                 crit_pos: crit_pos,\n                 period: period,\n@@ -741,7 +741,7 @@ impl<'a> Iterator<u16> for Utf16CodeUnits<'a> {\n \n         let mut buf = [0u16, ..2];\n         self.chars.next().map(|ch| {\n-            let n = ch.encode_utf16(buf[mut]).unwrap_or(0);\n+            let n = ch.encode_utf16(buf.as_mut_slice()).unwrap_or(0);\n             if n == 2 { self.extra = buf[1]; }\n             buf[0]\n         })\n@@ -1007,7 +1007,7 @@ pub fn utf16_items<'a>(v: &'a [u16]) -> Utf16Items<'a> {\n pub fn truncate_utf16_at_nul<'a>(v: &'a [u16]) -> &'a [u16] {\n     match v.iter().position(|c| *c == 0) {\n         // don't include the 0\n-        Some(i) => v[..i],\n+        Some(i) => v.slice_to(i),\n         None => v\n     }\n }\n@@ -1164,7 +1164,6 @@ pub mod traits {\n         fn equiv(&self, other: &S) -> bool { eq_slice(*self, other.as_slice()) }\n     }\n \n-    #[cfg(stage0)]\n     impl ops::Slice<uint, str> for str {\n         #[inline]\n         fn as_slice_<'a>(&'a self) -> &'a str {\n@@ -1173,39 +1172,17 @@ pub mod traits {\n \n         #[inline]\n         fn slice_from_<'a>(&'a self, from: &uint) -> &'a str {\n-            super::slice_from_impl(&self, *from)\n+            self.slice_from(*from)\n         }\n \n         #[inline]\n         fn slice_to_<'a>(&'a self, to: &uint) -> &'a str {\n-            super::slice_to_impl(&self, *to)\n+            self.slice_to(*to)\n         }\n \n         #[inline]\n         fn slice_<'a>(&'a self, from: &uint, to: &uint) -> &'a str {\n-            super::slice_impl(&self, *from, *to)\n-        }\n-    }\n-    #[cfg(not(stage0))]\n-    impl ops::Slice<uint, str> for str {\n-        #[inline]\n-        fn as_slice<'a>(&'a self) -> &'a str {\n-            self\n-        }\n-\n-        #[inline]\n-        fn slice_from<'a>(&'a self, from: &uint) -> &'a str {\n-            super::slice_from_impl(&self, *from)\n-        }\n-\n-        #[inline]\n-        fn slice_to<'a>(&'a self, to: &uint) -> &'a str {\n-            super::slice_to_impl(&self, *to)\n-        }\n-\n-        #[inline]\n-        fn slice<'a>(&'a self, from: &uint, to: &uint) -> &'a str {\n-            super::slice_impl(&self, *from, *to)\n+            self.slice(*from, *to)\n         }\n     }\n }\n@@ -1858,38 +1835,6 @@ fn slice_error_fail(s: &str, begin: uint, end: uint) -> ! {\n           begin, end, s);\n }\n \n-#[inline]\n-fn slice_impl<'a>(this: &&'a str, begin: uint, end: uint) -> &'a str {\n-    // is_char_boundary checks that the index is in [0, .len()]\n-    if begin <= end &&\n-       this.is_char_boundary(begin) &&\n-       this.is_char_boundary(end) {\n-        unsafe { raw::slice_unchecked(*this, begin, end) }\n-    } else {\n-        slice_error_fail(*this, begin, end)\n-    }\n-}\n-\n-#[inline]\n-fn slice_from_impl<'a>(this: &&'a str, begin: uint) -> &'a str {\n-    // is_char_boundary checks that the index is in [0, .len()]\n-    if this.is_char_boundary(begin) {\n-        unsafe { raw::slice_unchecked(*this, begin, this.len()) }\n-    } else {\n-        slice_error_fail(*this, begin, this.len())\n-    }\n-}\n-\n-#[inline]\n-fn slice_to_impl<'a>(this: &&'a str, end: uint) -> &'a str {\n-    // is_char_boundary checks that the index is in [0, .len()]\n-    if this.is_char_boundary(end) {\n-        unsafe { raw::slice_unchecked(*this, 0, end) }\n-    } else {\n-        slice_error_fail(*this, 0, end)\n-    }\n-}\n-\n impl<'a> StrSlice<'a> for &'a str {\n     #[inline]\n     fn contains<'a>(&self, needle: &'a str) -> bool {\n@@ -1993,17 +1938,34 @@ impl<'a> StrSlice<'a> for &'a str {\n \n     #[inline]\n     fn slice(&self, begin: uint, end: uint) -> &'a str {\n-        slice_impl(self, begin, end)\n+        // is_char_boundary checks that the index is in [0, .len()]\n+        if begin <= end &&\n+           self.is_char_boundary(begin) &&\n+           self.is_char_boundary(end) {\n+            unsafe { raw::slice_unchecked(*self, begin, end) }\n+        } else {\n+            slice_error_fail(*self, begin, end)\n+        }\n     }\n \n     #[inline]\n     fn slice_from(&self, begin: uint) -> &'a str {\n-        slice_from_impl(self, begin)\n+        // is_char_boundary checks that the index is in [0, .len()]\n+        if self.is_char_boundary(begin) {\n+            unsafe { raw::slice_unchecked(*self, begin, self.len()) }\n+        } else {\n+            slice_error_fail(*self, begin, self.len())\n+        }\n     }\n \n     #[inline]\n     fn slice_to(&self, end: uint) -> &'a str {\n-        slice_to_impl(self, end)\n+        // is_char_boundary checks that the index is in [0, .len()]\n+        if self.is_char_boundary(end) {\n+            unsafe { raw::slice_unchecked(*self, 0, end) }\n+        } else {\n+            slice_error_fail(*self, 0, end)\n+        }\n     }\n \n     fn slice_chars(&self, begin: uint, end: uint) -> &'a str {\n@@ -2032,13 +1994,13 @@ impl<'a> StrSlice<'a> for &'a str {\n     #[inline]\n     fn starts_with<'a>(&self, needle: &'a str) -> bool {\n         let n = needle.len();\n-        self.len() >= n && needle.as_bytes() == self.as_bytes()[..n]\n+        self.len() >= n && needle.as_bytes() == self.as_bytes().slice_to(n)\n     }\n \n     #[inline]\n     fn ends_with(&self, needle: &str) -> bool {\n         let (m, n) = (self.len(), needle.len());\n-        m >= n && needle.as_bytes() == self.as_bytes()[m-n..]\n+        m >= n && needle.as_bytes() == self.as_bytes().slice_from(m - n)\n     }\n \n     #[inline]"}, {"sha": "8c3f4706a3cc57109484f0fce7ad6e85e9c70b6a", "filename": "src/libcoretest/char.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibcoretest%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibcoretest%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fchar.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -174,7 +174,7 @@ fn test_encode_utf8() {\n     fn check(input: char, expect: &[u8]) {\n         let mut buf = [0u8, ..4];\n         let n = input.encode_utf8(buf.as_mut_slice()).unwrap_or(0);\n-        assert_eq!(buf[..n], expect);\n+        assert_eq!(buf.slice_to(n), expect);\n     }\n \n     check('x', [0x78]);\n@@ -188,7 +188,7 @@ fn test_encode_utf16() {\n     fn check(input: char, expect: &[u16]) {\n         let mut buf = [0u16, ..2];\n         let n = input.encode_utf16(buf.as_mut_slice()).unwrap_or(0);\n-        assert_eq!(buf[..n], expect);\n+        assert_eq!(buf.slice_to(n), expect);\n     }\n \n     check('x', [0x0078]);"}, {"sha": "1aaea19216264709b4cfe450edc9f58718e1a543", "filename": "src/libcoretest/iter.rs", "status": "modified", "additions": 25, "deletions": 26, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibcoretest%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibcoretest%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fiter.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -13,7 +13,6 @@ use core::iter::order::*;\n use core::uint;\n use core::cmp;\n use core::num;\n-use core::ops::Slice;\n \n use test::Bencher;\n \n@@ -229,7 +228,7 @@ fn test_inspect() {\n                .collect::<Vec<uint>>();\n \n     assert_eq!(n, xs.len());\n-    assert_eq!(xs[], ys[]);\n+    assert_eq!(xs.as_slice(), ys.as_slice());\n }\n \n #[test]\n@@ -269,7 +268,7 @@ fn test_cycle() {\n \n #[test]\n fn test_iterator_nth() {\n-    let v: &[_] = &[0i, 1, 2, 3, 4];\n+    let v = &[0i, 1, 2, 3, 4];\n     for i in range(0u, v.len()) {\n         assert_eq!(v.iter().nth(i).unwrap(), &v[i]);\n     }\n@@ -278,55 +277,55 @@ fn test_iterator_nth() {\n \n #[test]\n fn test_iterator_last() {\n-    let v: &[_] = &[0i, 1, 2, 3, 4];\n+    let v = &[0i, 1, 2, 3, 4];\n     assert_eq!(v.iter().last().unwrap(), &4);\n-    assert_eq!(v[0..1].iter().last().unwrap(), &0);\n+    assert_eq!(v.slice(0, 1).iter().last().unwrap(), &0);\n }\n \n #[test]\n fn test_iterator_len() {\n-    let v: &[_] = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n-    assert_eq!(v[0..4].iter().count(), 4);\n-    assert_eq!(v[0..10].iter().count(), 10);\n-    assert_eq!(v[0..0].iter().count(), 0);\n+    let v = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n+    assert_eq!(v.slice(0, 4).iter().count(), 4);\n+    assert_eq!(v.slice(0, 10).iter().count(), 10);\n+    assert_eq!(v.slice(0, 0).iter().count(), 0);\n }\n \n #[test]\n fn test_iterator_sum() {\n-    let v: &[_] = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n-    assert_eq!(v[0..4].iter().map(|&x| x).sum(), 6);\n+    let v = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n+    assert_eq!(v.slice(0, 4).iter().map(|&x| x).sum(), 6);\n     assert_eq!(v.iter().map(|&x| x).sum(), 55);\n-    assert_eq!(v[0..0].iter().map(|&x| x).sum(), 0);\n+    assert_eq!(v.slice(0, 0).iter().map(|&x| x).sum(), 0);\n }\n \n #[test]\n fn test_iterator_product() {\n-    let v: &[_] = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n-    assert_eq!(v[0..4].iter().map(|&x| x).product(), 0);\n-    assert_eq!(v[1..5].iter().map(|&x| x).product(), 24);\n-    assert_eq!(v[0..0].iter().map(|&x| x).product(), 1);\n+    let v = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n+    assert_eq!(v.slice(0, 4).iter().map(|&x| x).product(), 0);\n+    assert_eq!(v.slice(1, 5).iter().map(|&x| x).product(), 24);\n+    assert_eq!(v.slice(0, 0).iter().map(|&x| x).product(), 1);\n }\n \n #[test]\n fn test_iterator_max() {\n-    let v: &[_] = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n-    assert_eq!(v[0..4].iter().map(|&x| x).max(), Some(3));\n+    let v = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n+    assert_eq!(v.slice(0, 4).iter().map(|&x| x).max(), Some(3));\n     assert_eq!(v.iter().map(|&x| x).max(), Some(10));\n-    assert_eq!(v[0..0].iter().map(|&x| x).max(), None);\n+    assert_eq!(v.slice(0, 0).iter().map(|&x| x).max(), None);\n }\n \n #[test]\n fn test_iterator_min() {\n-    let v: &[_] = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n-    assert_eq!(v[0..4].iter().map(|&x| x).min(), Some(0));\n+    let v = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n+    assert_eq!(v.slice(0, 4).iter().map(|&x| x).min(), Some(0));\n     assert_eq!(v.iter().map(|&x| x).min(), Some(0));\n-    assert_eq!(v[0..0].iter().map(|&x| x).min(), None);\n+    assert_eq!(v.slice(0, 0).iter().map(|&x| x).min(), None);\n }\n \n #[test]\n fn test_iterator_size_hint() {\n     let c = count(0i, 1);\n-    let v: &[_] = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n+    let v = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n     let v2 = &[10i, 11, 12];\n     let vi = v.iter();\n \n@@ -373,7 +372,7 @@ fn test_all() {\n     assert!(v.iter().all(|&x| x < 10));\n     assert!(!v.iter().all(|&x| x % 2 == 0));\n     assert!(!v.iter().all(|&x| x > 100));\n-    assert!(v.slice(&0, &0).iter().all(|_| fail!()));\n+    assert!(v.slice(0, 0).iter().all(|_| fail!()));\n }\n \n #[test]\n@@ -382,7 +381,7 @@ fn test_any() {\n     assert!(v.iter().any(|&x| x < 10));\n     assert!(v.iter().any(|&x| x % 2 == 0));\n     assert!(!v.iter().any(|&x| x > 100));\n-    assert!(!v.slice(&0, &0).iter().any(|_| fail!()));\n+    assert!(!v.slice(0, 0).iter().any(|_| fail!()));\n }\n \n #[test]\n@@ -567,7 +566,7 @@ fn check_randacc_iter<A: PartialEq, T: Clone + RandomAccessIterator<A>>(a: T, le\n fn test_double_ended_flat_map() {\n     let u = [0u,1];\n     let v = [5u,6,7,8];\n-    let mut it = u.iter().flat_map(|x| v[*x..v.len()].iter());\n+    let mut it = u.iter().flat_map(|x| v.slice(*x, v.len()).iter());\n     assert_eq!(it.next_back().unwrap(), &8);\n     assert_eq!(it.next().unwrap(),      &5);\n     assert_eq!(it.next_back().unwrap(), &7);"}, {"sha": "7866d2f4a111ca75ad997df8d978ace23650ecef", "filename": "src/libcoretest/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibcoretest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibcoretest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Flib.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -7,7 +7,7 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n-#![feature(globs, unsafe_destructor, macro_rules, slicing_syntax)]\n+#![feature(globs, unsafe_destructor, macro_rules)]\n \n extern crate core;\n extern crate test;"}, {"sha": "419748b75c324c56f47a736ce2942ca035f8a4d4", "filename": "src/libnative/io/net.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibnative%2Fio%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibnative%2Fio%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fnet.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -1012,7 +1012,7 @@ pub fn write<T>(fd: sock_t,\n             // Also as with read(), we use MSG_DONTWAIT to guard ourselves\n             // against unforeseen circumstances.\n             let _guard = lock();\n-            let ptr = buf[written..].as_ptr();\n+            let ptr = buf.slice_from(written).as_ptr();\n             let len = buf.len() - written;\n             match retry(|| write(deadline.is_some(), ptr, len)) {\n                 -1 if util::wouldblock() => {}"}, {"sha": "2de9cd9a41c4b9a5fac2d341c46cd0ee8aaa35c6", "filename": "src/libnative/io/pipe_windows.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibnative%2Fio%2Fpipe_windows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibnative%2Fio%2Fpipe_windows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fpipe_windows.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -448,7 +448,7 @@ impl rtio::RtioPipe for UnixStream {\n             }\n             let ret = unsafe {\n                 libc::WriteFile(self.handle(),\n-                                buf[offset..].as_ptr() as libc::LPVOID,\n+                                buf.slice_from(offset).as_ptr() as libc::LPVOID,\n                                 (buf.len() - offset) as libc::DWORD,\n                                 &mut bytes_written,\n                                 &mut overlapped)"}, {"sha": "267ff3d2a81742542cd3ee61c5538d6635042b35", "filename": "src/libnative/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibnative%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibnative%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Flib.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -57,8 +57,7 @@\n \n #![deny(unused_result, unused_must_use)]\n #![allow(non_camel_case_types, deprecated)]\n-#![allow(unknown_features)]\n-#![feature(default_type_params, lang_items, slicing_syntax)]\n+#![feature(default_type_params, lang_items)]\n \n // NB this crate explicitly does *not* allow glob imports, please seriously\n //    consider whether they're needed before adding that feature here (the"}, {"sha": "efa3402073f2eff827a091aae9f24487b3f50a8e", "filename": "src/libnum/bigint.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Fbigint.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -735,7 +735,7 @@ impl BigUint {\n         let mut power: BigUint  = One::one();\n         loop {\n             let start = cmp::max(end, unit_len) - unit_len;\n-            match uint::parse_bytes(buf[start..end], radix) {\n+            match uint::parse_bytes(buf.slice(start, end), radix) {\n                 Some(d) => {\n                     let d: Option<BigUint> = FromPrimitive::from_uint(d);\n                     match d {\n@@ -1406,7 +1406,7 @@ impl BigInt {\n             sign  = Minus;\n             start = 1;\n         }\n-        return BigUint::parse_bytes(buf[start..], radix)\n+        return BigUint::parse_bytes(buf.slice(start, buf.len()), radix)\n             .map(|bu| BigInt::from_biguint(sign, bu));\n     }\n "}, {"sha": "17071d22deed82d555045324c4ee01e2c285c158", "filename": "src/libnum/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibnum%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibnum%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Flib.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -43,8 +43,7 @@\n //!\n //! [newt]: https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method\n \n-#![allow(unknown_features)]\n-#![feature(macro_rules, slicing_syntax)]\n+#![feature(macro_rules)]\n #![feature(default_type_params)]\n \n #![crate_name = \"num\"]"}, {"sha": "f8a775478f1f85b88b63454322a5559dd4f2fff9", "filename": "src/librand/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -228,7 +228,7 @@ pub trait Rng {\n     /// let choices = [1i, 2, 4, 8, 16, 32];\n     /// let mut rng = task_rng();\n     /// println!(\"{}\", rng.choose(choices));\n-    /// assert_eq!(rng.choose(choices[..0]), None);\n+    /// assert_eq!(rng.choose(choices.slice_to(0)), None);\n     /// ```\n     fn choose<'a, T>(&mut self, values: &'a [T]) -> Option<&'a T> {\n         if values.is_empty() {"}, {"sha": "648aa8668144b22610d082ff0d81545c5a769ce8", "filename": "src/librbml/io.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibrbml%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibrbml%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Fio.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -94,15 +94,15 @@ impl Writer for SeekableMemWriter {\n             // there (left), and what will be appended on the end (right)\n             let cap = self.buf.len() - self.pos;\n             let (left, right) = if cap <= buf.len() {\n-                (buf[..cap], buf[cap..])\n+                (buf.slice_to(cap), buf.slice_from(cap))\n             } else {\n                 let result: (_, &[_]) = (buf, &[]);\n                 result\n             };\n \n             // Do the necessary writes\n             if left.len() > 0 {\n-                slice::bytes::copy_memory(self.buf[mut self.pos..], left);\n+                slice::bytes::copy_memory(self.buf.slice_from_mut(self.pos), left);\n             }\n             if right.len() > 0 {\n                 self.buf.push_all(right);"}, {"sha": "6171a9946b6085702a0328a00074b91c0bdf0660", "filename": "src/librbml/lib.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibrbml%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibrbml%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Flib.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -24,8 +24,7 @@\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/master/\",\n        html_playground_url = \"http://play.rust-lang.org/\")]\n-#![allow(unknown_features)]\n-#![feature(macro_rules, phase, slicing_syntax)]\n+#![feature(macro_rules, phase)]\n #![allow(missing_doc)]\n \n extern crate serialize;\n@@ -55,7 +54,7 @@ impl<'doc> Doc<'doc> {\n     }\n \n     pub fn as_str_slice<'a>(&'a self) -> &'a str {\n-        str::from_utf8(self.data[self.start..self.end]).unwrap()\n+        str::from_utf8(self.data.slice(self.start, self.end)).unwrap()\n     }\n \n     pub fn as_str(&self) -> String {\n@@ -281,7 +280,7 @@ pub mod reader {\n     }\n \n     pub fn with_doc_data<'a, T>(d: Doc<'a>, f: |x: &'a [u8]| -> T) -> T {\n-        f(d.data[d.start..d.end])\n+        f(d.data.slice(d.start, d.end))\n     }\n \n "}, {"sha": "c3e195af6f90ff896db5997271f90e1f6171fbca", "filename": "src/libregex/compile.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibregex%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibregex%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fcompile.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -102,7 +102,7 @@ impl Program {\n         // This is a bit hacky since we have to skip over the initial\n         // 'Save' instruction.\n         let mut pre = String::with_capacity(5);\n-        for inst in c.insts[1..].iter() {\n+        for inst in c.insts.slice_from(1).iter() {\n             match *inst {\n                 OneChar(c, FLAG_EMPTY) => pre.push(c),\n                 _ => break"}, {"sha": "9ff65fe3e2ad79a1b9a6fe31ee50b5d09a8c4c1e", "filename": "src/libregex/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibregex%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibregex%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Flib.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -368,8 +368,7 @@\n        html_root_url = \"http://doc.rust-lang.org/master/\",\n        html_playground_url = \"http://play.rust-lang.org/\")]\n \n-#![allow(unknown_features)]\n-#![feature(macro_rules, phase, slicing_syntax)]\n+#![feature(macro_rules, phase)]\n #![deny(missing_doc)]\n \n #[cfg(test)]"}, {"sha": "7f4289b128afeac769bd047362fef6bd2d72a0d2", "filename": "src/libregex/parse.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibregex%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibregex%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fparse.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -511,7 +511,7 @@ impl<'a> Parser<'a> {\n         self.chari = closer;\n         let greed = try!(self.get_next_greedy());\n         let inner = String::from_chars(\n-            self.chars[start+1..closer]);\n+            self.chars.as_slice().slice(start + 1, closer));\n \n         // Parse the min and max values from the regex.\n         let (mut min, mut max): (uint, Option<uint>);\n@@ -944,7 +944,7 @@ impl<'a> Parser<'a> {\n     }\n \n     fn slice(&self, start: uint, end: uint) -> String {\n-        String::from_chars(self.chars[start..end])\n+        String::from_chars(self.chars.as_slice().slice(start, end))\n     }\n }\n "}, {"sha": "48065992bb050f525dd7133f54402f23d8546f5c", "filename": "src/libregex/test/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibregex%2Ftest%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibregex%2Ftest%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Ftest%2Ftests.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -130,7 +130,7 @@ macro_rules! mat(\n             // actual capture groups to match test set.\n             let (sexpect, mut sgot) = (expected.as_slice(), got.as_slice());\n             if sgot.len() > sexpect.len() {\n-                sgot = sgot[0..sexpect.len()]\n+                sgot = sgot.slice(0, sexpect.len())\n             }\n             if sexpect != sgot {\n                 fail!(\"For RE '{}' against '{}', expected '{}' but got '{}'\","}, {"sha": "085975580b7579865164037b03294c385419114f", "filename": "src/libregex/vm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibregex%2Fvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibregex%2Fvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fvm.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -145,7 +145,7 @@ impl<'r, 't> Nfa<'r, 't> {\n                 // out early.\n                 if self.prog.prefix.len() > 0 && clist.size == 0 {\n                     let needle = self.prog.prefix.as_slice().as_bytes();\n-                    let haystack = self.input.as_bytes()[self.ic..];\n+                    let haystack = self.input.as_bytes().slice_from(self.ic);\n                     match find_prefix(needle, haystack) {\n                         None => break,\n                         Some(i) => {"}, {"sha": "cc6a8e27cda4aa727bd02e922682958c69549c8a", "filename": "src/libregex_macros/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibregex_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibregex_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex_macros%2Flib.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -550,7 +550,7 @@ fn exec<'t>(which: ::regex::native::MatchKind, input: &'t str,\n         } else {\n             quote_expr!(self.cx,\n                 if clist.size == 0 {\n-                    let haystack = self.input.as_bytes()[self.ic..];\n+                    let haystack = self.input.as_bytes().slice_from(self.ic);\n                     match find_prefix(prefix_bytes, haystack) {\n                         None => break,\n                         Some(i) => {"}, {"sha": "cd425b5fec170fafad637280fd6c4ffe5c23faed", "filename": "src/librustc/back/lto.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibrustc%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibrustc%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flto.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -89,9 +89,9 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n                     if version == 1 {\n                         // The only version existing so far\n                         let data_size = extract_compressed_bytecode_size_v1(bc_encoded);\n-                        let compressed_data = bc_encoded[\n-                            link::RLIB_BYTECODE_OBJECT_V1_DATA_OFFSET..\n-                            link::RLIB_BYTECODE_OBJECT_V1_DATA_OFFSET + data_size as uint];\n+                        let compressed_data = bc_encoded.slice(\n+                            link::RLIB_BYTECODE_OBJECT_V1_DATA_OFFSET,\n+                            link::RLIB_BYTECODE_OBJECT_V1_DATA_OFFSET + data_size as uint);\n \n                         match flate::inflate_bytes(compressed_data) {\n                             Some(inflated) => inflated,\n@@ -188,7 +188,7 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n fn is_versioned_bytecode_format(bc: &[u8]) -> bool {\n     let magic_id_byte_count = link::RLIB_BYTECODE_OBJECT_MAGIC.len();\n     return bc.len() > magic_id_byte_count &&\n-           bc[..magic_id_byte_count] == link::RLIB_BYTECODE_OBJECT_MAGIC;\n+           bc.slice(0, magic_id_byte_count) == link::RLIB_BYTECODE_OBJECT_MAGIC;\n }\n \n fn extract_bytecode_format_version(bc: &[u8]) -> u32 {\n@@ -200,8 +200,8 @@ fn extract_compressed_bytecode_size_v1(bc: &[u8]) -> u64 {\n }\n \n fn read_from_le_bytes<T: Int>(bytes: &[u8], position_in_bytes: uint) -> T {\n-    let byte_data = bytes[position_in_bytes..\n-                          position_in_bytes + mem::size_of::<T>()];\n+    let byte_data = bytes.slice(position_in_bytes,\n+                                position_in_bytes + mem::size_of::<T>());\n     let data = unsafe {\n         *(byte_data.as_ptr() as *const T)\n     };"}, {"sha": "b807be422be99a014e216b93657136fbfe8e66d5", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -29,9 +29,8 @@ This API is completely unstable and subject to change.\n       html_root_url = \"http://doc.rust-lang.org/master/\")]\n \n #![allow(deprecated)]\n-#![allow(unknown_features)]\n #![feature(macro_rules, globs, struct_variant, quote)]\n-#![feature(default_type_params, phase, unsafe_destructor, slicing_syntax)]\n+#![feature(default_type_params, phase, unsafe_destructor)]\n \n #![feature(rustc_diagnostic_macros)]\n #![feature(import_shadowing)]"}, {"sha": "6d4407f96a7a444bc4c7fd6867e864b3bf59c9c1", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -70,7 +70,7 @@ fn lookup_hash<'a>(d: rbml::Doc<'a>, eq_fn: |&[u8]| -> bool,\n     let mut ret = None;\n     reader::tagged_docs(tagged_doc.doc, belt, |elt| {\n         let pos = u64_from_be_bytes(elt.data, elt.start, 4) as uint;\n-        if eq_fn(elt.data[elt.start + 4 .. elt.end]) {\n+        if eq_fn(elt.data.slice(elt.start + 4, elt.end)) {\n             ret = Some(reader::doc_at(d.data, pos).unwrap().doc);\n             false\n         } else {\n@@ -84,7 +84,7 @@ pub fn maybe_find_item<'a>(item_id: ast::NodeId,\n                            items: rbml::Doc<'a>) -> Option<rbml::Doc<'a>> {\n     fn eq_item(bytes: &[u8], item_id: ast::NodeId) -> bool {\n         return u64_from_be_bytes(\n-            bytes[0u..4u], 0u, 4u) as ast::NodeId\n+            bytes.slice(0u, 4u), 0u, 4u) as ast::NodeId\n             == item_id;\n     }\n     lookup_hash(items,"}, {"sha": "d319559044c4c171e9766142442a4371a2832114", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -91,7 +91,7 @@ fn scan<R>(st: &mut PState, is_last: |char| -> bool, op: |&[u8]| -> R) -> R {\n     }\n     let end_pos = st.pos;\n     st.pos += 1;\n-    return op(st.data[start_pos..end_pos]);\n+    return op(st.data.slice(start_pos, end_pos));\n }\n \n pub fn parse_ident(st: &mut PState, last: char) -> ast::Ident {\n@@ -599,8 +599,8 @@ pub fn parse_def_id(buf: &[u8]) -> ast::DefId {\n         fail!();\n     }\n \n-    let crate_part = buf[0u..colon_idx];\n-    let def_part = buf[colon_idx + 1u..len];\n+    let crate_part = buf.slice(0u, colon_idx);\n+    let def_part = buf.slice(colon_idx + 1u, len);\n \n     let crate_num = match uint::parse_bytes(crate_part, 10u) {\n        Some(cn) => cn as ast::CrateNum,"}, {"sha": "de9125ec44918419319650d7fac240e9a0c44f74", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -870,7 +870,7 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n             None\n         }\n     };\n-    head.map(|head| head.append(r[..col]).append(r[col + 1..]))\n+    head.map(|head| head.append(r.slice_to(col)).append(r.slice_from(col + 1)))\n }\n \n fn check_local(cx: &mut MatchCheckCtxt, loc: &Local) {"}, {"sha": "42a98be0fb84e1a93db2f5d78c88128b3bd42133", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -4014,7 +4014,7 @@ impl<'a> Resolver<'a> {\n         for (i, rib) in ribs.iter().enumerate().rev() {\n             match rib.bindings.find_copy(&name) {\n                 Some(def_like) => {\n-                    return self.upvarify(ribs[i + 1..], def_like, span);\n+                    return self.upvarify(ribs.slice_from(i + 1), def_like, span);\n                 }\n                 None => {\n                     // Continue."}, {"sha": "c956c2d2b006b9bd6a26a0ec72e8a9dcd454ebec", "filename": "src/librustc/middle/save/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -193,7 +193,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         if len <= 2 {\n             return;\n         }\n-        let sub_paths = sub_paths[..len-2];\n+        let sub_paths = sub_paths.slice(0, len-2);\n         for &(ref span, ref qualname) in sub_paths.iter() {\n             self.fmt.sub_mod_ref_str(path.span,\n                                      *span,"}, {"sha": "68d0bb2d8b49805220a6e796172a7d989c31eed6", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -473,7 +473,7 @@ fn enter_default<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     // Collect all of the matches that can match against anything.\n     enter_match(bcx, dm, m, col, val, |pats| {\n         if pat_is_binding_or_wild(dm, &*pats[col]) {\n-            Some(Vec::from_slice(pats[..col]).append(pats[col + 1..]))\n+            Some(Vec::from_slice(pats.slice_to(col)).append(pats.slice_from(col + 1)))\n         } else {\n             None\n         }\n@@ -949,7 +949,7 @@ fn compile_submatch<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 bcx = compile_guard(bcx,\n                                     &**guard_expr,\n                                     m[0].data,\n-                                    m[1..m.len()],\n+                                    m.slice(1, m.len()),\n                                     vals,\n                                     chk,\n                                     has_genuine_default);\n@@ -988,7 +988,7 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     let tcx = bcx.tcx();\n     let dm = &tcx.def_map;\n \n-    let vals_left = Vec::from_slice(vals[0u..col]).append(vals[col + 1u..vals.len()]);\n+    let vals_left = Vec::from_slice(vals.slice(0u, col)).append(vals.slice(col + 1u, vals.len()));\n     let ccx = bcx.fcx.ccx;\n \n     // Find a real id (we're adding placeholder wildcard patterns, but"}, {"sha": "e95f640b4486949a9259d07038c8fa19e51ff680", "filename": "src/librustc/middle/trans/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -550,7 +550,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             for (small_vec_e, &ix) in small_vec.iter_mut().zip(ixs.iter()) {\n                 *small_vec_e = C_i32(self.ccx, ix as i32);\n             }\n-            self.inbounds_gep(base, small_vec[..ixs.len()])\n+            self.inbounds_gep(base, small_vec.slice(0, ixs.len()))\n         } else {\n             let v = ixs.iter().map(|i| C_i32(self.ccx, *i as i32)).collect::<Vec<ValueRef>>();\n             self.count_insn(\"gepi\");"}, {"sha": "aada90d260e8f2f2b283d44907a78ef714b73235", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -931,7 +931,7 @@ pub fn create_captured_var_metadata(bcx: Block,\n \n     let variable_access = IndirectVariable {\n         alloca: env_pointer,\n-        address_operations: address_operations[..address_op_count]\n+        address_operations: address_operations.slice_to(address_op_count)\n     };\n \n     declare_local(bcx,"}, {"sha": "fa68814ea16fce997370a66af50fa7bd47e438cd", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -330,7 +330,7 @@ fn ast_path_substs<'tcx,AC,RS>(\n         }\n     }\n \n-    for param in ty_param_defs[supplied_ty_param_count..].iter() {\n+    for param in ty_param_defs.slice_from(supplied_ty_param_count).iter() {\n         match param.default {\n             Some(default) => {\n                 // This is a default type parameter."}, {"sha": "c0bb6bb3c6096bfeb580f4f4df8c0f23efc3155a", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -2271,10 +2271,10 @@ fn try_overloaded_slice(fcx: &FnCtxt,\n         match fcx.tcx().lang_items.slice_mut_trait() {\n             Some(trait_did) => {\n                 let method_name = match (start_expr, end_expr) {\n-                    (&Some(_), &Some(_)) => \"slice_mut\",\n-                    (&Some(_), &None) => \"slice_from_mut\",\n-                    (&None, &Some(_)) => \"slice_to_mut\",\n-                    (&None, &None) => \"as_mut_slice\",\n+                    (&Some(_), &Some(_)) => \"slice_mut_\",\n+                    (&Some(_), &None) => \"slice_from_mut_\",\n+                    (&None, &Some(_)) => \"slice_to_mut_\",\n+                    (&None, &None) => \"as_mut_slice_\",\n                 };\n \n                 method::lookup_in_trait(fcx,\n@@ -2296,10 +2296,10 @@ fn try_overloaded_slice(fcx: &FnCtxt,\n         match fcx.tcx().lang_items.slice_trait() {\n             Some(trait_did) => {\n                 let method_name = match (start_expr, end_expr) {\n-                    (&Some(_), &Some(_)) => \"slice\",\n-                    (&Some(_), &None) => \"slice_from\",\n-                    (&None, &Some(_)) => \"slice_to\",\n-                    (&None, &None) => \"as_slice\",\n+                    (&Some(_), &Some(_)) => \"slice_\",\n+                    (&Some(_), &None) => \"slice_from_\",\n+                    (&None, &Some(_)) => \"slice_to_\",\n+                    (&None, &None) => \"as_slice_\",\n                 };\n \n                 method::lookup_in_trait(fcx,\n@@ -3032,7 +3032,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         };\n \n         // Call the generic checker.\n-        let args: Vec<_> = args[1..].iter().map(|x| x).collect();\n+        let args: Vec<_> = args.slice_from(1).iter().map(|x| x).collect();\n         let ret_ty = check_method_argument_types(fcx,\n                                                  method_name.span,\n                                                  fn_ty,"}, {"sha": "638aea10e37952fa1bc9306ffce827e83d27b6db", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -490,7 +490,7 @@ pub fn parameterized(cx: &ctxt,\n         0\n     };\n \n-    for t in tps[..tps.len() - num_defaults].iter() {\n+    for t in tps.slice_to(tps.len() - num_defaults).iter() {\n         strs.push(ty_to_string(cx, *t))\n     }\n "}, {"sha": "e48f9df75648f75fab9f982c68825d5a8bb2c29d", "filename": "src/librustc_back/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibrustc_back%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibrustc_back%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Flib.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -31,8 +31,7 @@\n       html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n       html_root_url = \"http://doc.rust-lang.org/\")]\n \n-#![allow(unknown_features)]\n-#![feature(globs, phase, macro_rules, slicing_syntax)]\n+#![feature(globs, phase, macro_rules)]\n \n #[phase(plugin, link)]\n extern crate log;"}, {"sha": "8f3dd18c69c59c03a1ab33bdb43efc656da9311d", "filename": "src/librustc_back/sha2.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibrustc_back%2Fsha2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibrustc_back%2Fsha2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsha2.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -136,14 +136,14 @@ impl FixedBuffer for FixedBuffer64 {\n             let buffer_remaining = size - self.buffer_idx;\n             if input.len() >= buffer_remaining {\n                     copy_memory(\n-                        self.buffer[mut self.buffer_idx..size],\n-                        input[..buffer_remaining]);\n+                        self.buffer.slice_mut(self.buffer_idx, size),\n+                        input.slice_to(buffer_remaining));\n                 self.buffer_idx = 0;\n                 func(self.buffer);\n                 i += buffer_remaining;\n             } else {\n                 copy_memory(\n-                    self.buffer[mut self.buffer_idx..self.buffer_idx + input.len()],\n+                    self.buffer.slice_mut(self.buffer_idx, self.buffer_idx + input.len()),\n                     input);\n                 self.buffer_idx += input.len();\n                 return;\n@@ -153,7 +153,7 @@ impl FixedBuffer for FixedBuffer64 {\n         // While we have at least a full buffer size chunk's worth of data, process that data\n         // without copying it into the buffer\n         while input.len() - i >= size {\n-            func(input[i..i + size]);\n+            func(input.slice(i, i + size));\n             i += size;\n         }\n \n@@ -162,8 +162,8 @@ impl FixedBuffer for FixedBuffer64 {\n         // be empty.\n         let input_remaining = input.len() - i;\n         copy_memory(\n-            self.buffer[mut ..input_remaining],\n-            input[i..]);\n+            self.buffer.slice_mut(0, input_remaining),\n+            input.slice_from(i));\n         self.buffer_idx += input_remaining;\n     }\n \n@@ -173,19 +173,19 @@ impl FixedBuffer for FixedBuffer64 {\n \n     fn zero_until(&mut self, idx: uint) {\n         assert!(idx >= self.buffer_idx);\n-        self.buffer[mut self.buffer_idx..idx].set_memory(0);\n+        self.buffer.slice_mut(self.buffer_idx, idx).set_memory(0);\n         self.buffer_idx = idx;\n     }\n \n     fn next<'s>(&'s mut self, len: uint) -> &'s mut [u8] {\n         self.buffer_idx += len;\n-        return self.buffer[mut self.buffer_idx - len..self.buffer_idx];\n+        return self.buffer.slice_mut(self.buffer_idx - len, self.buffer_idx);\n     }\n \n     fn full_buffer<'s>(&'s mut self) -> &'s [u8] {\n         assert!(self.buffer_idx == 64);\n         self.buffer_idx = 0;\n-        return self.buffer[..64];\n+        return self.buffer.slice_to(64);\n     }\n \n     fn position(&self) -> uint { self.buffer_idx }\n@@ -359,7 +359,7 @@ impl Engine256State {\n              )\n         )\n \n-        read_u32v_be(w[mut 0..16], data);\n+        read_u32v_be(w.slice_mut(0, 16), data);\n \n         // Putting the message schedule inside the same loop as the round calculations allows for\n         // the compiler to generate better code.\n@@ -495,14 +495,14 @@ impl Digest for Sha256 {\n     fn result(&mut self, out: &mut [u8]) {\n         self.engine.finish();\n \n-        write_u32_be(out[mut 0..4], self.engine.state.h0);\n-        write_u32_be(out[mut 4..8], self.engine.state.h1);\n-        write_u32_be(out[mut 8..12], self.engine.state.h2);\n-        write_u32_be(out[mut 12..16], self.engine.state.h3);\n-        write_u32_be(out[mut 16..20], self.engine.state.h4);\n-        write_u32_be(out[mut 20..24], self.engine.state.h5);\n-        write_u32_be(out[mut 24..28], self.engine.state.h6);\n-        write_u32_be(out[mut 28..32], self.engine.state.h7);\n+        write_u32_be(out.slice_mut(0, 4), self.engine.state.h0);\n+        write_u32_be(out.slice_mut(4, 8), self.engine.state.h1);\n+        write_u32_be(out.slice_mut(8, 12), self.engine.state.h2);\n+        write_u32_be(out.slice_mut(12, 16), self.engine.state.h3);\n+        write_u32_be(out.slice_mut(16, 20), self.engine.state.h4);\n+        write_u32_be(out.slice_mut(20, 24), self.engine.state.h5);\n+        write_u32_be(out.slice_mut(24, 28), self.engine.state.h6);\n+        write_u32_be(out.slice_mut(28, 32), self.engine.state.h7);\n     }\n \n     fn reset(&mut self) {"}, {"sha": "054fbda73379c2b7c9bc421eeb8c62aafa4cf716", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -698,7 +698,7 @@ impl Clean<Item> for ast::Method {\n         let all_inputs = &self.pe_fn_decl().inputs;\n         let inputs = match self.pe_explicit_self().node {\n             ast::SelfStatic => all_inputs.as_slice(),\n-            _ => all_inputs[1..]\n+            _ => all_inputs.slice_from(1)\n         };\n         let decl = FnDecl {\n             inputs: Arguments {\n@@ -737,7 +737,7 @@ impl Clean<Item> for ast::TypeMethod {\n     fn clean(&self, cx: &DocContext) -> Item {\n         let inputs = match self.explicit_self.node {\n             ast::SelfStatic => self.decl.inputs.as_slice(),\n-            _ => self.decl.inputs[1..]\n+            _ => self.decl.inputs.slice_from(1)\n         };\n         let decl = FnDecl {\n             inputs: Arguments {\n@@ -1009,7 +1009,7 @@ impl Clean<Item> for ty::Method {\n                                                self.fty.sig.clone()),\n             s => {\n                 let sig = ty::FnSig {\n-                    inputs: self.fty.sig.inputs[1..].to_vec(),\n+                    inputs: self.fty.sig.inputs.slice_from(1).to_vec(),\n                     ..self.fty.sig.clone()\n                 };\n                 let s = match s {"}, {"sha": "947d9f05ae2bba0cdc0915b0547ffd36cf809488", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -249,7 +249,7 @@ fn path(w: &mut fmt::Formatter, path: &clean::Path, print_all: bool,\n         match rel_root {\n             Some(root) => {\n                 let mut root = String::from_str(root.as_slice());\n-                for seg in path.segments[..amt].iter() {\n+                for seg in path.segments.slice_to(amt).iter() {\n                     if \"super\" == seg.name.as_slice() ||\n                             \"self\" == seg.name.as_slice() {\n                         try!(write!(w, \"{}::\", seg.name));\n@@ -264,7 +264,7 @@ fn path(w: &mut fmt::Formatter, path: &clean::Path, print_all: bool,\n                 }\n             }\n             None => {\n-                for seg in path.segments[..amt].iter() {\n+                for seg in path.segments.slice_to(amt).iter() {\n                     try!(write!(w, \"{}::\", seg.name));\n                 }\n             }\n@@ -275,7 +275,7 @@ fn path(w: &mut fmt::Formatter, path: &clean::Path, print_all: bool,\n         // This is a documented path, link to it!\n         Some((ref fqp, shortty)) if abs_root.is_some() => {\n             let mut url = String::from_str(abs_root.unwrap().as_slice());\n-            let to_link = fqp[..fqp.len() - 1];\n+            let to_link = fqp.slice_to(fqp.len() - 1);\n             for component in to_link.iter() {\n                 url.push_str(component.as_slice());\n                 url.push_str(\"/\");"}, {"sha": "8668e684c2d643bf01105798478398338a4af720", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -394,7 +394,7 @@ fn build_index(krate: &clean::Crate, cache: &mut Cache) -> io::IoResult<String>\n                     search_index.push(IndexItem {\n                         ty: shortty(item),\n                         name: item.name.clone().unwrap(),\n-                        path: fqp[..fqp.len() - 1].connect(\"::\"),\n+                        path: fqp.slice_to(fqp.len() - 1).connect(\"::\"),\n                         desc: shorter(item.doc_value()).to_string(),\n                         parent: Some(did),\n                     });\n@@ -549,7 +549,7 @@ fn write_shared(cx: &Context,\n         };\n \n         let mut mydst = dst.clone();\n-        for part in remote_path[..remote_path.len() - 1].iter() {\n+        for part in remote_path.slice_to(remote_path.len() - 1).iter() {\n             mydst.push(part.as_slice());\n             try!(mkdir(&mydst));\n         }\n@@ -829,7 +829,7 @@ impl DocFolder for Cache {\n                     clean::StructFieldItem(..) |\n                     clean::VariantItem(..) => {\n                         ((Some(*self.parent_stack.last().unwrap()),\n-                          Some(self.stack[..self.stack.len() - 1])),\n+                          Some(self.stack.slice_to(self.stack.len() - 1))),\n                           false)\n                     }\n                     clean::MethodItem(..) => {\n@@ -840,13 +840,13 @@ impl DocFolder for Cache {\n                             let did = *last;\n                             let path = match self.paths.find(&did) {\n                                 Some(&(_, item_type::Trait)) =>\n-                                    Some(self.stack[..self.stack.len() - 1]),\n+                                    Some(self.stack.slice_to(self.stack.len() - 1)),\n                                 // The current stack not necessarily has correlation for\n                                 // where the type was defined. On the other hand,\n                                 // `paths` always has the right information if present.\n                                 Some(&(ref fqp, item_type::Struct)) |\n                                 Some(&(ref fqp, item_type::Enum)) =>\n-                                    Some(fqp[..fqp.len() - 1]),\n+                                    Some(fqp.slice_to(fqp.len() - 1)),\n                                 Some(..) => Some(self.stack.as_slice()),\n                                 None => None\n                             };\n@@ -1172,7 +1172,7 @@ impl Context {\n                 let mut url = \"../\".repeat(cx.current.len());\n                 match cache_key.get().unwrap().paths.find(&it.def_id) {\n                     Some(&(ref names, _)) => {\n-                        for name in names[..names.len() - 1].iter() {\n+                        for name in names.slice_to(names.len() - 1).iter() {\n                             url.push_str(name.as_slice());\n                             url.push_str(\"/\");\n                         }"}, {"sha": "71d00e50af83d20ab900305b78741fb5955c8988", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -15,8 +15,7 @@\n #![crate_type = \"dylib\"]\n #![crate_type = \"rlib\"]\n \n-#![allow(unknown_features)]\n-#![feature(globs, struct_variant, managed_boxes, macro_rules, phase, slicing_syntax)]\n+#![feature(globs, struct_variant, managed_boxes, macro_rules, phase)]\n \n extern crate arena;\n extern crate debug;"}, {"sha": "72c7d89a3b98b701c007b106436e088bc8ce6d9c", "filename": "src/librustrt/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibrustrt%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibrustrt%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Flib.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -16,10 +16,9 @@\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/master/\")]\n \n-#![allow(unknown_features)]\n #![feature(macro_rules, phase, globs, thread_local, managed_boxes, asm)]\n #![feature(linkage, lang_items, unsafe_destructor, default_type_params)]\n-#![feature(import_shadowing, slicing_syntax)]\n+#![feature(import_shadowing)]\n #![no_std]\n #![experimental]\n "}, {"sha": "1561f428ce5484f84a13ebee6b7ead3c5e5b7c04", "filename": "src/librustrt/unwind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibrustrt%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibrustrt%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Funwind.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -562,7 +562,7 @@ fn begin_unwind_inner(msg: Box<Any + Send>, file_line: &(&'static str, uint)) ->\n     // MAX_CALLBACKS, so we're sure to clamp it as necessary.\n     let callbacks = unsafe {\n         let amt = CALLBACK_CNT.load(atomic::SeqCst);\n-        CALLBACKS[..cmp::min(amt, MAX_CALLBACKS)]\n+        CALLBACKS.slice_to(cmp::min(amt, MAX_CALLBACKS))\n     };\n     for cb in callbacks.iter() {\n         match cb.load(atomic::SeqCst) {"}, {"sha": "77e3e25eb0e7e9e60d310f6e6bf943f46cd6460c", "filename": "src/librustrt/util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibrustrt%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibrustrt%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Futil.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -62,8 +62,8 @@ pub fn abort(args: &fmt::Arguments) -> ! {\n     }\n     impl<'a> FormatWriter for BufWriter<'a> {\n         fn write(&mut self, bytes: &[u8]) -> fmt::Result {\n-            let left = self.buf[mut self.pos..];\n-            let to_write = bytes[..cmp::min(bytes.len(), left.len())];\n+            let left = self.buf.slice_from_mut(self.pos);\n+            let to_write = bytes.slice_to(cmp::min(bytes.len(), left.len()));\n             slice::bytes::copy_memory(left, to_write);\n             self.pos += to_write.len();\n             Ok(())\n@@ -74,7 +74,7 @@ pub fn abort(args: &fmt::Arguments) -> ! {\n     let mut msg = [0u8, ..512];\n     let mut w = BufWriter { buf: msg, pos: 0 };\n     let _ = write!(&mut w, \"{}\", args);\n-    let msg = str::from_utf8(w.buf[mut ..w.pos]).unwrap_or(\"aborted\");\n+    let msg = str::from_utf8(w.buf.slice_to(w.pos)).unwrap_or(\"aborted\");\n     let msg = if msg.is_empty() {\"aborted\"} else {msg};\n \n     // Give some context to the message"}, {"sha": "3007e160bf8ae536078e643e20078dfb273901d0", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -334,7 +334,7 @@ pub fn escape_bytes(wr: &mut io::Writer, bytes: &[u8]) -> Result<(), io::IoError\n         };\n \n         if start < i {\n-            try!(wr.write(bytes[start..i]));\n+            try!(wr.write(bytes.slice(start, i)));\n         }\n \n         try!(wr.write_str(escaped));\n@@ -343,7 +343,7 @@ pub fn escape_bytes(wr: &mut io::Writer, bytes: &[u8]) -> Result<(), io::IoError\n     }\n \n     if start != bytes.len() {\n-        try!(wr.write(bytes[start..]));\n+        try!(wr.write(bytes.slice_from(start)));\n     }\n \n     wr.write_str(\"\\\"\")\n@@ -369,7 +369,7 @@ fn spaces(wr: &mut io::Writer, mut n: uint) -> Result<(), io::IoError> {\n     }\n \n     if n > 0 {\n-        wr.write(buf[..n])\n+        wr.write(buf.slice_to(n))\n     } else {\n         Ok(())\n     }\n@@ -1149,7 +1149,7 @@ impl Stack {\n             InternalIndex(i) => { Index(i) }\n             InternalKey(start, size) => {\n                 Key(str::from_utf8(\n-                    self.str_buffer[start as uint .. start as uint + size as uint]).unwrap())\n+                    self.str_buffer.slice(start as uint, start as uint + size as uint)).unwrap())\n             }\n         }\n     }\n@@ -1191,7 +1191,7 @@ impl Stack {\n             Some(&InternalIndex(i)) => Some(Index(i)),\n             Some(&InternalKey(start, size)) => {\n                 Some(Key(str::from_utf8(\n-                    self.str_buffer[start as uint .. (start+size) as uint]\n+                    self.str_buffer.slice(start as uint, (start+size) as uint)\n                 ).unwrap()))\n             }\n         }"}, {"sha": "5c35ad8523382cef363099662becabdac6c3a677", "filename": "src/libserialize/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibserialize%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibserialize%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Flib.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -23,8 +23,7 @@ Core encoding and decoding interfaces.\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/master/\",\n        html_playground_url = \"http://play.rust-lang.org/\")]\n-#![allow(unknown_features)]\n-#![feature(macro_rules, managed_boxes, default_type_params, phase, slicing_syntax)]\n+#![feature(macro_rules, managed_boxes, default_type_params, phase)]\n \n // test harness access\n #[cfg(test)]"}, {"sha": "d9543a06b350c83e385fa91401cff37c8ea571ac", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -90,10 +90,10 @@ impl<R: Reader> BufferedReader<R> {\n impl<R: Reader> Buffer for BufferedReader<R> {\n     fn fill_buf<'a>(&'a mut self) -> IoResult<&'a [u8]> {\n         if self.pos == self.cap {\n-            self.cap = try!(self.inner.read(self.buf[mut]));\n+            self.cap = try!(self.inner.read(self.buf.as_mut_slice()));\n             self.pos = 0;\n         }\n-        Ok(self.buf[self.pos..self.cap])\n+        Ok(self.buf.slice(self.pos, self.cap))\n     }\n \n     fn consume(&mut self, amt: uint) {\n@@ -107,7 +107,7 @@ impl<R: Reader> Reader for BufferedReader<R> {\n         let nread = {\n             let available = try!(self.fill_buf());\n             let nread = cmp::min(available.len(), buf.len());\n-            slice::bytes::copy_memory(buf, available[..nread]);\n+            slice::bytes::copy_memory(buf, available.slice_to(nread));\n             nread\n         };\n         self.pos += nread;\n@@ -162,7 +162,7 @@ impl<W: Writer> BufferedWriter<W> {\n \n     fn flush_buf(&mut self) -> IoResult<()> {\n         if self.pos != 0 {\n-            let ret = self.inner.as_mut().unwrap().write(self.buf[..self.pos]);\n+            let ret = self.inner.as_mut().unwrap().write(self.buf.slice_to(self.pos));\n             self.pos = 0;\n             ret\n         } else {\n@@ -195,7 +195,7 @@ impl<W: Writer> Writer for BufferedWriter<W> {\n         if buf.len() > self.buf.len() {\n             self.inner.as_mut().unwrap().write(buf)\n         } else {\n-            let dst = self.buf[mut self.pos..];\n+            let dst = self.buf.slice_from_mut(self.pos);\n             slice::bytes::copy_memory(dst, buf);\n             self.pos += buf.len();\n             Ok(())\n@@ -250,9 +250,9 @@ impl<W: Writer> Writer for LineBufferedWriter<W> {\n     fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n         match buf.iter().rposition(|&b| b == b'\\n') {\n             Some(i) => {\n-                try!(self.inner.write(buf[..i + 1]));\n+                try!(self.inner.write(buf.slice_to(i + 1)));\n                 try!(self.inner.flush());\n-                try!(self.inner.write(buf[i + 1..]));\n+                try!(self.inner.write(buf.slice_from(i + 1)));\n                 Ok(())\n             }\n             None => self.inner.write(buf),"}, {"sha": "0a969fc37c924aa6dc01c82ce0f4f39f47ad8d27", "filename": "src/libstd/io/comm_adapters.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fcomm_adapters.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -15,7 +15,8 @@ use comm::{Sender, Receiver};\n use io;\n use option::{None, Option, Some};\n use result::{Ok, Err};\n-use slice::{bytes, CloneableVector};\n+use slice::{bytes, MutableSlice, ImmutableSlice, CloneableVector};\n+use str::StrSlice;\n use super::{Reader, Writer, IoResult};\n use vec::Vec;\n \n@@ -61,10 +62,10 @@ impl Reader for ChanReader {\n         loop {\n             match self.buf {\n                 Some(ref prev) => {\n-                    let dst = buf[mut num_read..];\n-                    let src = prev[self.pos..];\n+                    let dst = buf.slice_from_mut(num_read);\n+                    let src = prev.slice_from(self.pos);\n                     let count = cmp::min(dst.len(), src.len());\n-                    bytes::copy_memory(dst, src[..count]);\n+                    bytes::copy_memory(dst, src.slice_to(count));\n                     num_read += count;\n                     self.pos += count;\n                 },"}, {"sha": "f777460e66a4538dca42541e3d238ae7314481d5", "filename": "src/libstd/io/fs.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibstd%2Fio%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibstd%2Fio%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ffs.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -485,7 +485,7 @@ pub fn copy(from: &Path, to: &Path) -> IoResult<()> {\n             Err(ref e) if e.kind == io::EndOfFile => { break }\n             Err(e) => return update_err(Err(e), from, to)\n         };\n-        try!(writer.write(buf[..amt]));\n+        try!(writer.write(buf.slice_to(amt)));\n     }\n \n     chmod(to, try!(update_err(from.stat(), from, to)).perm)\n@@ -1014,7 +1014,7 @@ mod test {\n             let mut read_buf = [0, .. 1028];\n             let read_str = match check!(read_stream.read(read_buf)) {\n                 -1|0 => fail!(\"shouldn't happen\"),\n-                n => str::from_utf8(read_buf[..n]).unwrap().to_string()\n+                n => str::from_utf8(read_buf.slice_to(n)).unwrap().to_string()\n             };\n             assert_eq!(read_str.as_slice(), message);\n         }\n@@ -1061,11 +1061,11 @@ mod test {\n         {\n             let mut read_stream = File::open_mode(filename, Open, Read);\n             {\n-                let read_buf = read_mem[mut 0..4];\n+                let read_buf = read_mem.slice_mut(0, 4);\n                 check!(read_stream.read(read_buf));\n             }\n             {\n-                let read_buf = read_mem[mut 4..8];\n+                let read_buf = read_mem.slice_mut(4, 8);\n                 check!(read_stream.read(read_buf));\n             }\n         }"}, {"sha": "c826bd16715d6618f3c6f6d422702c676d563278", "filename": "src/libstd/io/mem.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibstd%2Fio%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibstd%2Fio%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmem.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -19,7 +19,7 @@ use result::{Err, Ok};\n use io;\n use io::{Reader, Writer, Seek, Buffer, IoError, SeekStyle, IoResult};\n use slice;\n-use slice::Slice;\n+use slice::{Slice, ImmutableSlice, MutableSlice};\n use vec::Vec;\n \n static BUF_CAPACITY: uint = 128;\n@@ -146,8 +146,8 @@ impl Reader for MemReader {\n \n         let write_len = min(buf.len(), self.buf.len() - self.pos);\n         {\n-            let input = self.buf[self.pos.. self.pos + write_len];\n-            let output = buf[mut ..write_len];\n+            let input = self.buf.slice(self.pos, self.pos + write_len);\n+            let output = buf.slice_mut(0, write_len);\n             assert_eq!(input.len(), output.len());\n             slice::bytes::copy_memory(output, input);\n         }\n@@ -174,7 +174,7 @@ impl Buffer for MemReader {\n     #[inline]\n     fn fill_buf<'a>(&'a mut self) -> IoResult<&'a [u8]> {\n         if self.pos < self.buf.len() {\n-            Ok(self.buf[self.pos..])\n+            Ok(self.buf.slice_from(self.pos))\n         } else {\n             Err(io::standard_error(io::EndOfFile))\n         }\n@@ -232,7 +232,7 @@ impl<'a> Writer for BufWriter<'a> {\n             })\n         }\n \n-        slice::bytes::copy_memory(self.buf[mut self.pos..], buf);\n+        slice::bytes::copy_memory(self.buf.slice_from_mut(self.pos), buf);\n         self.pos += buf.len();\n         Ok(())\n     }\n@@ -292,8 +292,8 @@ impl<'a> Reader for BufReader<'a> {\n \n         let write_len = min(buf.len(), self.buf.len() - self.pos);\n         {\n-            let input = self.buf[self.pos.. self.pos + write_len];\n-            let output = buf[mut ..write_len];\n+            let input = self.buf.slice(self.pos, self.pos + write_len);\n+            let output = buf.slice_mut(0, write_len);\n             assert_eq!(input.len(), output.len());\n             slice::bytes::copy_memory(output, input);\n         }\n@@ -320,7 +320,7 @@ impl<'a> Buffer for BufReader<'a> {\n     #[inline]\n     fn fill_buf<'a>(&'a mut self) -> IoResult<&'a [u8]> {\n         if self.pos < self.buf.len() {\n-            Ok(self.buf[self.pos..])\n+            Ok(self.buf.slice_from(self.pos))\n         } else {\n             Err(io::standard_error(io::EndOfFile))\n         }\n@@ -427,7 +427,7 @@ mod test {\n         assert_eq!(buf.as_slice(), b);\n         assert_eq!(reader.read(buf), Ok(3));\n         let b: &[_] = &[5, 6, 7];\n-        assert_eq!(buf[0..3], b);\n+        assert_eq!(buf.slice(0, 3), b);\n         assert!(reader.read(buf).is_err());\n         let mut reader = MemReader::new(vec!(0, 1, 2, 3, 4, 5, 6, 7));\n         assert_eq!(reader.read_until(3).unwrap(), vec!(0, 1, 2, 3));\n@@ -454,7 +454,7 @@ mod test {\n         assert_eq!(buf.as_slice(), b);\n         assert_eq!(reader.read(buf), Ok(3));\n         let b: &[_] = &[5, 6, 7];\n-        assert_eq!(buf[0..3], b);\n+        assert_eq!(buf.slice(0, 3), b);\n         assert!(reader.read(buf).is_err());\n         let mut reader = BufReader::new(in_buf.as_slice());\n         assert_eq!(reader.read_until(3).unwrap(), vec!(0, 1, 2, 3));\n@@ -548,7 +548,7 @@ mod test {\n         assert!(r.read_at_least(buf.len(), buf).is_ok());\n         let b: &[_] = &[1, 2, 3];\n         assert_eq!(buf.as_slice(), b);\n-        assert!(r.read_at_least(0, buf[mut ..0]).is_ok());\n+        assert!(r.read_at_least(0, buf.slice_to_mut(0)).is_ok());\n         assert_eq!(buf.as_slice(), b);\n         assert!(r.read_at_least(buf.len(), buf).is_ok());\n         let b: &[_] = &[4, 5, 6];"}, {"sha": "b929e7c464df02f0f2e83a09728011ad9353fa0d", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -235,7 +235,7 @@ use os;\n use boxed::Box;\n use result::{Ok, Err, Result};\n use rt::rtio;\n-use slice::{Slice, ImmutableSlice};\n+use slice::{Slice, MutableSlice, ImmutableSlice};\n use str::{Str, StrSlice};\n use str;\n use string::String;\n@@ -575,7 +575,7 @@ pub trait Reader {\n         while read < min {\n             let mut zeroes = 0;\n             loop {\n-                match self.read(buf[mut read..]) {\n+                match self.read(buf.slice_from_mut(read)) {\n                     Ok(0) => {\n                         zeroes += 1;\n                         if zeroes >= NO_PROGRESS_LIMIT {\n@@ -1111,8 +1111,8 @@ pub trait Writer {\n     #[inline]\n     fn write_char(&mut self, c: char) -> IoResult<()> {\n         let mut buf = [0u8, ..4];\n-        let n = c.encode_utf8(buf[mut]).unwrap_or(0);\n-        self.write(buf[..n])\n+        let n = c.encode_utf8(buf.as_mut_slice()).unwrap_or(0);\n+        self.write(buf.slice_to(n))\n     }\n \n     /// Write the result of passing n through `int::to_str_bytes`.\n@@ -1496,7 +1496,7 @@ pub trait Buffer: Reader {\n                 };\n                 match available.iter().position(|&b| b == byte) {\n                     Some(i) => {\n-                        res.push_all(available[..i + 1]);\n+                        res.push_all(available.slice_to(i + 1));\n                         used = i + 1;\n                         break\n                     }\n@@ -1528,14 +1528,14 @@ pub trait Buffer: Reader {\n         {\n             let mut start = 1;\n             while start < width {\n-                match try!(self.read(buf[mut start..width])) {\n+                match try!(self.read(buf.slice_mut(start, width))) {\n                     n if n == width - start => break,\n                     n if n < width - start => { start += n; }\n                     _ => return Err(standard_error(InvalidInput)),\n                 }\n             }\n         }\n-        match str::from_utf8(buf[..width]) {\n+        match str::from_utf8(buf.slice_to(width)) {\n             Some(s) => Ok(s.char_at(0)),\n             None => Err(standard_error(InvalidInput))\n         }"}, {"sha": "6eb7d1c02fbc7b47942a4fdcd90ce8b4fd11900f", "filename": "src/libstd/io/net/ip.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fip.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -21,7 +21,7 @@ use from_str::FromStr;\n use iter::Iterator;\n use option::{Option, None, Some};\n use str::StrSlice;\n-use slice::{MutableCloneableSlice, MutableSlice};\n+use slice::{MutableCloneableSlice, ImmutableSlice, MutableSlice};\n \n pub type Port = u16;\n \n@@ -241,7 +241,7 @@ impl<'a> Parser<'a> {\n             assert!(head.len() + tail.len() <= 8);\n             let mut gs = [0u16, ..8];\n             gs.clone_from_slice(head);\n-            gs[mut 8 - tail.len() .. 8].clone_from_slice(tail);\n+            gs.slice_mut(8 - tail.len(), 8).clone_from_slice(tail);\n             Ipv6Addr(gs[0], gs[1], gs[2], gs[3], gs[4], gs[5], gs[6], gs[7])\n         }\n \n@@ -303,7 +303,7 @@ impl<'a> Parser<'a> {\n \n         let mut tail = [0u16, ..8];\n         let (tail_size, _) = read_groups(self, &mut tail, 8 - head_size);\n-        Some(ipv6_addr_from_head_tail(head[..head_size], tail[..tail_size]))\n+        Some(ipv6_addr_from_head_tail(head.slice(0, head_size), tail.slice(0, tail_size)))\n     }\n \n     fn read_ipv6_addr(&mut self) -> Option<IpAddr> {"}, {"sha": "3ba8765fc3e215cf7797fc0b544c88eff32e2a8c", "filename": "src/libstd/io/net/udp.rs", "status": "modified", "additions": 15, "deletions": 18, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fudp.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -35,29 +35,26 @@ use rt::rtio;\n ///\n /// ```rust,no_run\n /// # #![allow(unused_must_use)]\n-/// #![feature(slicing_syntax)]\n-///\n /// use std::io::net::udp::UdpSocket;\n /// use std::io::net::ip::{Ipv4Addr, SocketAddr};\n-/// fn main() {\n-///     let addr = SocketAddr { ip: Ipv4Addr(127, 0, 0, 1), port: 34254 };\n-///     let mut socket = match UdpSocket::bind(addr) {\n-///         Ok(s) => s,\n-///         Err(e) => fail!(\"couldn't bind socket: {}\", e),\n-///     };\n ///\n-///     let mut buf = [0, ..10];\n-///     match socket.recv_from(buf) {\n-///         Ok((amt, src)) => {\n-///             // Send a reply to the socket we received data from\n-///             let buf = buf[mut ..amt];\n-///             buf.reverse();\n-///             socket.send_to(buf, src);\n-///         }\n-///         Err(e) => println!(\"couldn't receive a datagram: {}\", e)\n+/// let addr = SocketAddr { ip: Ipv4Addr(127, 0, 0, 1), port: 34254 };\n+/// let mut socket = match UdpSocket::bind(addr) {\n+///     Ok(s) => s,\n+///     Err(e) => fail!(\"couldn't bind socket: {}\", e),\n+/// };\n+///\n+/// let mut buf = [0, ..10];\n+/// match socket.recv_from(buf) {\n+///     Ok((amt, src)) => {\n+///         // Send a reply to the socket we received data from\n+///         let buf = buf.slice_to_mut(amt);\n+///         buf.reverse();\n+///         socket.send_to(buf, src);\n ///     }\n-///     drop(socket); // close the socket\n+///     Err(e) => println!(\"couldn't receive a datagram: {}\", e)\n /// }\n+/// drop(socket); // close the socket\n /// ```\n pub struct UdpSocket {\n     obj: Box<RtioUdpSocket + Send>,"}, {"sha": "16ac8c4c265fe09ce7c2edc16de233bd85bd63c5", "filename": "src/libstd/io/util.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibstd%2Fio%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibstd%2Fio%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Futil.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -47,7 +47,7 @@ impl<R: Reader> Reader for LimitReader<R> {\n         }\n \n         let len = cmp::min(self.limit, buf.len());\n-        let res = self.inner.read(buf[mut ..len]);\n+        let res = self.inner.read(buf.slice_to_mut(len));\n         match res {\n             Ok(len) => self.limit -= len,\n             _ => {}\n@@ -59,7 +59,7 @@ impl<R: Reader> Reader for LimitReader<R> {\n impl<R: Buffer> Buffer for LimitReader<R> {\n     fn fill_buf<'a>(&'a mut self) -> io::IoResult<&'a [u8]> {\n         let amt = try!(self.inner.fill_buf());\n-        let buf = amt[..cmp::min(amt.len(), self.limit)];\n+        let buf = amt.slice_to(cmp::min(amt.len(), self.limit));\n         if buf.len() == 0 {\n             Err(io::standard_error(io::EndOfFile))\n         } else {\n@@ -216,7 +216,7 @@ impl<R: Reader, W: Writer> TeeReader<R, W> {\n impl<R: Reader, W: Writer> Reader for TeeReader<R, W> {\n     fn read(&mut self, buf: &mut [u8]) -> io::IoResult<uint> {\n         self.reader.read(buf).and_then(|len| {\n-            self.writer.write(buf[mut ..len]).map(|()| len)\n+            self.writer.write(buf.slice_to(len)).map(|()| len)\n         })\n     }\n }\n@@ -230,7 +230,7 @@ pub fn copy<R: Reader, W: Writer>(r: &mut R, w: &mut W) -> io::IoResult<()> {\n             Err(ref e) if e.kind == io::EndOfFile => return Ok(()),\n             Err(e) => return Err(e),\n         };\n-        try!(w.write(buf[..len]));\n+        try!(w.write(buf.slice_to(len)));\n     }\n }\n "}, {"sha": "7304871cf214c5447389c1166c4015f5a788de90", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -105,10 +105,9 @@\n        html_root_url = \"http://doc.rust-lang.org/master/\",\n        html_playground_url = \"http://play.rust-lang.org/\")]\n \n-#![allow(unknown_features)]\n #![feature(macro_rules, globs, managed_boxes, linkage)]\n #![feature(default_type_params, phase, lang_items, unsafe_destructor)]\n-#![feature(import_shadowing, slicing_syntax)]\n+#![feature(import_shadowing)]\n \n // Don't link to std. We are std.\n #![no_std]"}, {"sha": "f5b2f31a127d603f25fc09ea5d8513e885d3380a", "filename": "src/libstd/num/i16.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibstd%2Fnum%2Fi16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibstd%2Fnum%2Fi16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi16.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -17,6 +17,7 @@ use from_str::FromStr;\n use num::{ToStrRadix, FromStrRadix};\n use num::strconv;\n use option::Option;\n+use slice::ImmutableSlice;\n use string::String;\n \n pub use core::i16::{BITS, BYTES, MIN, MAX};"}, {"sha": "623a10725c826387d8c942b9c0f79efd3e416658", "filename": "src/libstd/num/i32.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibstd%2Fnum%2Fi32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibstd%2Fnum%2Fi32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi32.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -17,6 +17,7 @@ use from_str::FromStr;\n use num::{ToStrRadix, FromStrRadix};\n use num::strconv;\n use option::Option;\n+use slice::ImmutableSlice;\n use string::String;\n \n pub use core::i32::{BITS, BYTES, MIN, MAX};"}, {"sha": "ffb1307908c90821941ee8721d7a7ed8c20989f2", "filename": "src/libstd/num/i64.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibstd%2Fnum%2Fi64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibstd%2Fnum%2Fi64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi64.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -17,6 +17,7 @@ use from_str::FromStr;\n use num::{ToStrRadix, FromStrRadix};\n use num::strconv;\n use option::Option;\n+use slice::ImmutableSlice;\n use string::String;\n \n pub use core::i64::{BITS, BYTES, MIN, MAX};"}, {"sha": "4fbb7381238dc77569a6a05aafd84e20d1f9ac45", "filename": "src/libstd/num/i8.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibstd%2Fnum%2Fi8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibstd%2Fnum%2Fi8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi8.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -17,6 +17,7 @@ use from_str::FromStr;\n use num::{ToStrRadix, FromStrRadix};\n use num::strconv;\n use option::Option;\n+use slice::ImmutableSlice;\n use string::String;\n \n pub use core::i8::{BITS, BYTES, MIN, MAX};"}, {"sha": "7821306f5fc3da122ee4d2f4d027a6920272b1c8", "filename": "src/libstd/num/int.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibstd%2Fnum%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibstd%2Fnum%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -17,6 +17,7 @@ use from_str::FromStr;\n use num::{ToStrRadix, FromStrRadix};\n use num::strconv;\n use option::Option;\n+use slice::ImmutableSlice;\n use string::String;\n \n pub use core::int::{BITS, BYTES, MIN, MAX};"}, {"sha": "3c01edf233925986005a4803c3dd1148191fd4e3", "filename": "src/libstd/num/int_macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibstd%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibstd%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint_macros.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -78,7 +78,7 @@ pub fn to_str_bytes<U>(n: $T, radix: uint, f: |v: &[u8]| -> U) -> U {\n         (write!(&mut wr, \"{}\", ::fmt::radix(n, radix as u8))).unwrap();\n         wr.tell().unwrap() as uint\n     };\n-    f(buf[..amt])\n+    f(buf.slice(0, amt))\n }\n \n #[deprecated = \"use fmt::radix\"]"}, {"sha": "b15f334e233e82197863e80b27ea2421146eed89", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -730,7 +730,7 @@ pub fn from_str_bytes_common<T:NumCast+Zero+One+PartialEq+PartialOrd+Div<T,T>+\n         // parse remaining bytes as decimal integer,\n         // skipping the exponent char\n         let exp: Option<int> = from_str_bytes_common(\n-            buf[i+1..len], 10, true, false, false, ExpNone, false,\n+            buf.slice(i+1, len), 10, true, false, false, ExpNone, false,\n             ignore_underscores);\n \n         match exp {"}, {"sha": "0f00f99e980a2a6c387555fd8ca36bbb7b3cdd33", "filename": "src/libstd/num/u16.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibstd%2Fnum%2Fu16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibstd%2Fnum%2Fu16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fu16.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -17,6 +17,7 @@ use from_str::FromStr;\n use num::{ToStrRadix, FromStrRadix};\n use num::strconv;\n use option::Option;\n+use slice::ImmutableSlice;\n use string::String;\n \n pub use core::u16::{BITS, BYTES, MIN, MAX};"}, {"sha": "e6c6bc377b7aa304d51cb468c93f06ac091b6768", "filename": "src/libstd/num/u32.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibstd%2Fnum%2Fu32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibstd%2Fnum%2Fu32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fu32.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -17,6 +17,7 @@ use from_str::FromStr;\n use num::{ToStrRadix, FromStrRadix};\n use num::strconv;\n use option::Option;\n+use slice::ImmutableSlice;\n use string::String;\n \n pub use core::u32::{BITS, BYTES, MIN, MAX};"}, {"sha": "7eb9e1a082fe872abb009e326cc94657d7048a41", "filename": "src/libstd/num/u64.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibstd%2Fnum%2Fu64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibstd%2Fnum%2Fu64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fu64.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -17,6 +17,7 @@ use from_str::FromStr;\n use num::{ToStrRadix, FromStrRadix};\n use num::strconv;\n use option::Option;\n+use slice::ImmutableSlice;\n use string::String;\n \n pub use core::u64::{BITS, BYTES, MIN, MAX};"}, {"sha": "300dd3bcc01a4cfc69f2f7965bb0f614a024f7ec", "filename": "src/libstd/num/u8.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibstd%2Fnum%2Fu8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibstd%2Fnum%2Fu8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fu8.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -17,6 +17,7 @@ use from_str::FromStr;\n use num::{ToStrRadix, FromStrRadix};\n use num::strconv;\n use option::Option;\n+use slice::ImmutableSlice;\n use string::String;\n \n pub use core::u8::{BITS, BYTES, MIN, MAX};"}, {"sha": "0adc22e321406ebdce3ef58c05d77dec808c8521", "filename": "src/libstd/num/uint.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibstd%2Fnum%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibstd%2Fnum%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -17,6 +17,7 @@ use from_str::FromStr;\n use num::{ToStrRadix, FromStrRadix};\n use num::strconv;\n use option::Option;\n+use slice::ImmutableSlice;\n use string::String;\n \n pub use core::uint::{BITS, BYTES, MIN, MAX};"}, {"sha": "cfcaf0fa8daa35d61ebaa203ecaf86446964fa0e", "filename": "src/libstd/num/uint_macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibstd%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibstd%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint_macros.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -79,7 +79,7 @@ pub fn to_str_bytes<U>(n: $T, radix: uint, f: |v: &[u8]| -> U) -> U {\n         (write!(&mut wr, \"{}\", ::fmt::radix(n, radix as u8))).unwrap();\n         wr.tell().unwrap() as uint\n     };\n-    f(buf[..amt])\n+    f(buf.slice(0, amt))\n }\n \n #[deprecated = \"use fmt::radix\"]"}, {"sha": "d904e657e403b082e61110c71af92c7b60732ca6", "filename": "src/libstd/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -144,7 +144,7 @@ pub mod windows {\n     use option::{None, Option};\n     use option;\n     use os::TMPBUF_SZ;\n-    use slice::MutableSlice;\n+    use slice::{MutableSlice, ImmutableSlice};\n     use string::String;\n     use str::StrSlice;\n     use vec::Vec;"}, {"sha": "16552daae36b7526b0e109f30c88bc8ae52f187c", "filename": "src/libstd/path/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibstd%2Fpath%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibstd%2Fpath%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fmod.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -357,7 +357,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n                 match name.rposition_elem(&dot) {\n                     None | Some(0) => name,\n                     Some(1) if name == b\"..\" => name,\n-                    Some(pos) => name[..pos]\n+                    Some(pos) => name.slice_to(pos)\n                 }\n             })\n         }\n@@ -404,7 +404,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n                 match name.rposition_elem(&dot) {\n                     None | Some(0) => None,\n                     Some(1) if name == b\"..\" => None,\n-                    Some(pos) => Some(name[pos+1..])\n+                    Some(pos) => Some(name.slice_from(pos+1))\n                 }\n             }\n         }\n@@ -480,7 +480,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n             let extlen = extension.container_as_bytes().len();\n             match (name.rposition_elem(&dot), extlen) {\n                 (None, 0) | (Some(0), 0) => None,\n-                (Some(idx), 0) => Some(name[..idx].to_vec()),\n+                (Some(idx), 0) => Some(name.slice_to(idx).to_vec()),\n                 (idx, extlen) => {\n                     let idx = match idx {\n                         None | Some(0) => name.len(),\n@@ -489,7 +489,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n \n                     let mut v;\n                     v = Vec::with_capacity(idx + extlen + 1);\n-                    v.push_all(name[..idx]);\n+                    v.push_all(name.slice_to(idx));\n                     v.push(dot);\n                     v.push_all(extension.container_as_bytes());\n                     Some(v)"}, {"sha": "9c4139853c540b275b44d91f59c7f7a39ad3c51e", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -165,7 +165,7 @@ impl GenericPathUnsafe for Path {\n             None => {\n                 self.repr = Path::normalize(filename);\n             }\n-            Some(idx) if self.repr[idx+1..] == b\"..\" => {\n+            Some(idx) if self.repr.slice_from(idx+1) == b\"..\" => {\n                 let mut v = Vec::with_capacity(self.repr.len() + 1 + filename.len());\n                 v.push_all(self.repr.as_slice());\n                 v.push(SEP_BYTE);\n@@ -175,7 +175,7 @@ impl GenericPathUnsafe for Path {\n             }\n             Some(idx) => {\n                 let mut v = Vec::with_capacity(idx + 1 + filename.len());\n-                v.push_all(self.repr[..idx+1]);\n+                v.push_all(self.repr.slice_to(idx+1));\n                 v.push_all(filename);\n                 // FIXME: this is slow\n                 self.repr = Path::normalize(v.as_slice());\n@@ -216,9 +216,9 @@ impl GenericPath for Path {\n         match self.sepidx {\n             None if b\"..\" == self.repr.as_slice() => self.repr.as_slice(),\n             None => dot_static,\n-            Some(0) => self.repr[..1],\n-            Some(idx) if self.repr[idx+1..] == b\"..\" => self.repr.as_slice(),\n-            Some(idx) => self.repr[..idx]\n+            Some(0) => self.repr.slice_to(1),\n+            Some(idx) if self.repr.slice_from(idx+1) == b\"..\" => self.repr.as_slice(),\n+            Some(idx) => self.repr.slice_to(idx)\n         }\n     }\n \n@@ -227,9 +227,9 @@ impl GenericPath for Path {\n             None if b\".\" == self.repr.as_slice() ||\n                 b\"..\" == self.repr.as_slice() => None,\n             None => Some(self.repr.as_slice()),\n-            Some(idx) if self.repr[idx+1..] == b\"..\" => None,\n-            Some(0) if self.repr[1..].is_empty() => None,\n-            Some(idx) => Some(self.repr[idx+1..])\n+            Some(idx) if self.repr.slice_from(idx+1) == b\"..\" => None,\n+            Some(0) if self.repr.slice_from(1).is_empty() => None,\n+            Some(idx) => Some(self.repr.slice_from(idx+1))\n         }\n     }\n \n@@ -371,7 +371,7 @@ impl Path {\n         // borrowck is being very picky\n         let val = {\n             let is_abs = !v.as_slice().is_empty() && v.as_slice()[0] == SEP_BYTE;\n-            let v_ = if is_abs { v.as_slice()[1..] } else { v.as_slice() };\n+            let v_ = if is_abs { v.as_slice().slice_from(1) } else { v.as_slice() };\n             let comps = normalize_helper(v_, is_abs);\n             match comps {\n                 None => None,\n@@ -410,7 +410,7 @@ impl Path {\n     /// A path of \"/\" yields no components. A path of \".\" yields one component.\n     pub fn components<'a>(&'a self) -> Components<'a> {\n         let v = if self.repr[0] == SEP_BYTE {\n-            self.repr[1..]\n+            self.repr.slice_from(1)\n         } else { self.repr.as_slice() };\n         let mut ret = v.split(is_sep_byte);\n         if v.is_empty() {"}, {"sha": "33f8713e1a13c9f61fa67856ec89997f4f268cd6", "filename": "src/libstd/rt/backtrace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibstd%2Frt%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibstd%2Frt%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fbacktrace.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -999,7 +999,7 @@ mod imp {\n                 let bytes = cstr.as_bytes();\n                 match cstr.as_str() {\n                     Some(s) => try!(super::demangle(w, s)),\n-                    None => try!(w.write(bytes[..bytes.len()-1])),\n+                    None => try!(w.write(bytes.slice_to(bytes.len() - 1))),\n                 }\n             }\n             try!(w.write(['\\n' as u8]));"}, {"sha": "a5458461a8b2562bb9975719491d623a686109b3", "filename": "src/libsyntax/ast_map/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibsyntax%2Fast_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibsyntax%2Fast_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map%2Fmod.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -496,7 +496,7 @@ impl<'ast> Map<'ast> {\n         NodesMatchingSuffix {\n             map: self,\n             item_name: parts.last().unwrap(),\n-            in_which: parts[..parts.len() - 1],\n+            in_which: parts.slice_to(parts.len() - 1),\n             idx: 0,\n         }\n     }"}, {"sha": "f33c768d647575607a821aad4a6dc364604558bc", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -414,7 +414,7 @@ fn highlight_lines(err: &mut EmitterWriter,\n     let mut elided = false;\n     let mut display_lines = lines.lines.as_slice();\n     if display_lines.len() > MAX_LINES {\n-        display_lines = display_lines[0u..MAX_LINES];\n+        display_lines = display_lines.slice(0u, MAX_LINES);\n         elided = true;\n     }\n     // Print the offending lines"}, {"sha": "ca6d488772c613b520e641fb0f7887c63250c577", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -70,7 +70,6 @@ static KNOWN_FEATURES: &'static [(&'static str, Status)] = &[\n     (\"tuple_indexing\", Active),\n     (\"associated_types\", Active),\n     (\"visible_private_types\", Active),\n-    (\"slicing_syntax\", Active),\n \n     (\"if_let\", Active),\n \n@@ -363,11 +362,6 @@ impl<'a, 'v> Visitor<'v> for Context<'a> {\n                 self.gate_feature(\"if_let\", e.span,\n                                   \"`if let` syntax is experimental\");\n             }\n-            ast::ExprSlice(..) => {\n-                self.gate_feature(\"slicing_syntax\",\n-                                  e.span,\n-                                  \"slicing syntax is experimental\");\n-            }\n             _ => {}\n         }\n         visit::walk_expr(self, e);"}, {"sha": "a42715441465470b6516b5392e10f0e8bd31bd0a", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -23,8 +23,7 @@\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/master/\")]\n \n-#![allow(unknown_features)]\n-#![feature(macro_rules, globs, default_type_params, phase, slicing_syntax)]\n+#![feature(macro_rules, globs, default_type_params, phase)]\n #![feature(quote, struct_variant, unsafe_destructor, import_shadowing)]\n #![allow(deprecated)]\n "}, {"sha": "3fc631422d5f3a3e78cba2a5400ca0119f83c635", "filename": "src/libterm/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibterm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibterm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Flib.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -49,8 +49,7 @@\n        html_root_url = \"http://doc.rust-lang.org/master/\",\n        html_playground_url = \"http://play.rust-lang.org/\")]\n \n-#![allow(unknown_features)]\n-#![feature(macro_rules, phase, slicing_syntax)]\n+#![feature(macro_rules, phase)]\n \n #![deny(missing_doc)]\n "}, {"sha": "f59a4465e1da4b4ad092e07c23cde8ed826ded95", "filename": "src/libterm/terminfo/parser/compiled.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -285,13 +285,13 @@ pub fn parse(file: &mut io::Reader, longnames: bool)\n \n \n             // Find the offset of the NUL we want to go to\n-            let nulpos = string_table[offset as uint .. string_table_bytes as uint]\n+            let nulpos = string_table.slice(offset as uint, string_table_bytes as uint)\n                 .iter().position(|&b| b == 0);\n             match nulpos {\n                 Some(len) => {\n                     string_map.insert(name.to_string(),\n-                                      string_table[offset as uint ..\n-                                          offset as uint + len].to_vec())\n+                                      string_table.slice(offset as uint,\n+                                          offset as uint + len).to_vec())\n                 },\n                 None => {\n                     return Err(\"invalid file: missing NUL in \\"}, {"sha": "5e812e500d6e81c6457db93de35e0e8725d73a76", "filename": "src/test/bench/shootout-fannkuch-redux.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -38,8 +38,6 @@\n // ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n // OF THE POSSIBILITY OF SUCH DAMAGE.\n \n-#![feature(slicing_syntax)]\n-\n use std::{cmp, iter, mem};\n use std::sync::Future;\n \n@@ -52,7 +50,7 @@ fn rotate(x: &mut [i32]) {\n \n fn next_permutation(perm: &mut [i32], count: &mut [i32]) {\n     for i in range(1, perm.len()) {\n-        rotate(perm[mut ..i + 1]);\n+        rotate(perm.slice_to_mut(i + 1));\n         let count_i = &mut count[i];\n         if *count_i >= i as i32 {\n             *count_i = 0;\n@@ -101,7 +99,7 @@ impl Perm {\n             let d = idx / self.fact[i] as i32;\n             self.cnt[i] = d;\n             idx %= self.fact[i] as i32;\n-            for (place, val) in pp.iter_mut().zip(self.perm.p[..i+1].iter()) {\n+            for (place, val) in pp.iter_mut().zip(self.perm.p.slice_to(i + 1).iter()) {\n                 *place = (*val) as u8\n             }\n \n@@ -127,7 +125,7 @@ impl Perm {\n \n \n fn reverse(tperm: &mut [i32], mut k: uint) {\n-    tperm[mut ..k].reverse()\n+    tperm.slice_to_mut(k).reverse()\n }\n \n fn work(mut perm: Perm, n: uint, max: uint) -> (i32, i32) {"}, {"sha": "b68404bdd72387e96a908155f5792afba469679c", "filename": "src/test/bench/shootout-fasta-redux.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -38,8 +38,6 @@\n // ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n // OF THE POSSIBILITY OF SUCH DAMAGE.\n \n-#![feature(slicing_syntax)]\n-\n use std::cmp::min;\n use std::io::{stdout, IoResult};\n use std::os;\n@@ -126,8 +124,8 @@ impl<'a, W: Writer> RepeatFasta<'a, W> {\n \n         copy_memory(buf.as_mut_slice(), alu);\n         let buf_len = buf.len();\n-        copy_memory(buf[mut alu_len..buf_len],\n-                    alu[..LINE_LEN]);\n+        copy_memory(buf.slice_mut(alu_len, buf_len),\n+                    alu.slice_to(LINE_LEN));\n \n         let mut pos = 0;\n         let mut bytes;\n@@ -203,7 +201,7 @@ impl<'a, W: Writer> RandomFasta<'a, W> {\n         for i in range(0u, chars_left) {\n             buf[i] = self.nextc();\n         }\n-        self.out.write(buf[..chars_left])\n+        self.out.write(buf.slice_to(chars_left))\n     }\n }\n "}, {"sha": "e5ddcac1e8fcd1e730523237247de73db5456cc6", "filename": "src/test/bench/shootout-fasta.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -38,8 +38,6 @@\n // ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n // OF THE POSSIBILITY OF SUCH DAMAGE.\n \n-#![feature(slicing_syntax)]\n-\n use std::io;\n use std::io::{BufferedWriter, File};\n use std::cmp::min;\n@@ -95,7 +93,7 @@ fn make_fasta<W: Writer, I: Iterator<u8>>(\n         }\n         n -= nb;\n         line[nb] = '\\n' as u8;\n-        wr.write(line[..nb+1]);\n+        wr.write(line.slice_to(nb + 1));\n     }\n }\n "}, {"sha": "f4d1cee5fb4ca11434a1378e3e555e334aeaf161", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -13,8 +13,6 @@\n \n // multi tasking k-nucleotide\n \n-#![feature(slicing_syntax)]\n-\n extern crate collections;\n \n use std::collections::HashMap;\n@@ -99,11 +97,11 @@ fn windows_with_carry(bb: &[u8], nn: uint, it: |window: &[u8]|) -> Vec<u8> {\n \n    let len = bb.len();\n    while ii < len - (nn - 1u) {\n-      it(bb[ii..ii+nn]);\n+      it(bb.slice(ii, ii+nn));\n       ii += 1u;\n    }\n \n-   return Vec::from_slice(bb[len - (nn - 1u)..len]);\n+   return Vec::from_slice(bb.slice(len - (nn - 1u), len));\n }\n \n fn make_sequence_processor(sz: uint,"}, {"sha": "cecc95354afefece8445db9bfd3940562acc58c4", "filename": "src/test/bench/shootout-k-nucleotide.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -40,8 +40,6 @@\n \n // ignore-android see #10393 #13206\n \n-#![feature(slicing_syntax)]\n-\n use std::string::String;\n use std::slice;\n use std::sync::{Arc, Future};\n@@ -242,14 +240,14 @@ fn generate_frequencies(mut input: &[u8], frame: uint) -> Table {\n     // Pull first frame.\n     for _ in range(0, frame) {\n         code = code.push_char(input[0]);\n-        input = input[1..];\n+        input = input.slice_from(1);\n     }\n     frequencies.lookup(code, BumpCallback);\n \n     while input.len() != 0 && input[0] != ('>' as u8) {\n         code = code.rotate(input[0], frame);\n         frequencies.lookup(code, BumpCallback);\n-        input = input[1..];\n+        input = input.slice_from(1);\n     }\n     frequencies\n }"}, {"sha": "0adb80c2689ba64a360700768729bb8738bfdbf6", "filename": "src/test/bench/shootout-regex-dna.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Ftest%2Fbench%2Fshootout-regex-dna.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Ftest%2Fbench%2Fshootout-regex-dna.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-regex-dna.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -41,7 +41,7 @@\n // ignore-stage1\n // ignore-cross-compile #12102\n \n-#![feature(macro_rules, phase, slicing_syntax)]\n+#![feature(macro_rules, phase)]\n \n extern crate regex;\n #[phase(plugin)]extern crate regex_macros;"}, {"sha": "e522bcaf4db7b6e286cdc7d1c925d1fbdfc78ef2", "filename": "src/test/bench/shootout-reverse-complement.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -41,8 +41,6 @@\n // ignore-pretty very bad with line comments\n // ignore-android doesn't terminate?\n \n-#![feature(slicing_syntax)]\n-\n use std::iter::range_step;\n use std::io::{stdin, stdout, File};\n \n@@ -83,7 +81,7 @@ fn main() {\n             Some(c) => c\n         };\n         let len = seq.len();\n-        let seq = seq[mut begin+1..len-1];\n+        let seq = seq.slice_mut(begin + 1, len - 1);\n \n         // arrange line breaks\n         let len = seq.len();"}, {"sha": "6cddd8ee9397bc4880c803f9f5cb90ea13b0402f", "filename": "src/test/compile-fail/issue-15730.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Ftest%2Fcompile-fail%2Fissue-15730.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Ftest%2Fcompile-fail%2Fissue-15730.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-15730.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -8,10 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(slicing_syntax)]\n-\n fn main() {\n     let mut array = [1, 2, 3];\n //~^ ERROR cannot determine a type for this local variable: cannot determine the type of this integ\n-    let pie_slice = array[1..2];\n+    let pie_slice = array.slice(1, 2);\n }"}, {"sha": "fbfc438321c8e4ab22dea549b83bc52af85cb958", "filename": "src/test/compile-fail/slice-2.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Ftest%2Fcompile-fail%2Fslice-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Ftest%2Fcompile-fail%2Fslice-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fslice-2.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -10,8 +10,6 @@\n \n // Test that slicing syntax gives errors if we have not implemented the trait.\n \n-#![feature(slicing_syntax)]\n-\n struct Foo;\n \n fn main() {"}, {"sha": "3d12511134fa003d869babf982460a1a79ff9ea3", "filename": "src/test/compile-fail/slice-borrow.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Ftest%2Fcompile-fail%2Fslice-borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Ftest%2Fcompile-fail%2Fslice-borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fslice-borrow.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -10,8 +10,6 @@\n \n // Test slicing expressions doesn't defeat the borrow checker.\n \n-#![feature(slicing_syntax)]\n-\n fn main() {\n     let y;\n     {"}, {"sha": "1176b637cece091337be1faa8eceef0644442c63", "filename": "src/test/compile-fail/slice-mut-2.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Ftest%2Fcompile-fail%2Fslice-mut-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Ftest%2Fcompile-fail%2Fslice-mut-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fslice-mut-2.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -10,8 +10,6 @@\n \n // Test mutability and slicing syntax.\n \n-#![feature(slicing_syntax)]\n-\n fn main() {\n     let x: &[int] = &[1, 2, 3, 4, 5];\n     // Can't mutably slice an immutable slice"}, {"sha": "8cd7c4ed0bb077d4808c382fa5c3df76807fe454", "filename": "src/test/compile-fail/slice-mut.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Ftest%2Fcompile-fail%2Fslice-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Ftest%2Fcompile-fail%2Fslice-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fslice-mut.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -10,8 +10,6 @@\n \n // Test mutability and slicing syntax.\n \n-#![feature(slicing_syntax)]\n-\n fn main() {\n     let x: &[int] = &[1, 2, 3, 4, 5];\n     // Immutable slices are not mutable."}, {"sha": "ba8c4d249ce7f4d381354677f543c6ffd0fc79ed", "filename": "src/test/debuginfo/vec-slices.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Ftest%2Fdebuginfo%2Fvec-slices.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Ftest%2Fdebuginfo%2Fvec-slices.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fvec-slices.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -80,7 +80,6 @@\n // lldb-check:[...]$5 = &[AStruct { x: 10, y: 11, z: 12 }, AStruct { x: 13, y: 14, z: 15 }]\n \n #![allow(unused_variable)]\n-#![feature(slicing_syntax)]\n \n struct AStruct {\n     x: i16,\n@@ -95,7 +94,7 @@ fn main() {\n     let empty: &[i64] = &[];\n     let singleton: &[i64] = &[1];\n     let multiple: &[i64] = &[2, 3, 4, 5];\n-    let slice_of_slice = multiple[1..3];\n+    let slice_of_slice = multiple.slice(1,3);\n \n     let padded_tuple: &[(i32, i16)] = &[(6, 7), (8, 9)];\n "}, {"sha": "c9f6733fa2587afdf6f0adb686d6cc44d4fc7d2b", "filename": "src/test/run-pass/issue-3888-2.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Ftest%2Frun-pass%2Fissue-3888-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Ftest%2Frun-pass%2Fissue-3888-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3888-2.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -8,10 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(slicing_syntax)]\n-\n fn vec_peek<'r, T>(v: &'r [T]) -> &'r [T] {\n-    v[1..5]\n+    v.slice(1, 5)\n }\n \n pub fn main() {}"}, {"sha": "822fda8a18ec825c3f93ca39d6379fe5d99e0305", "filename": "src/test/run-pass/issue-4464.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Ftest%2Frun-pass%2Fissue-4464.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Ftest%2Frun-pass%2Fissue-4464.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-4464.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(slicing_syntax)]\n-\n-fn broken(v: &[u8], i: uint, j: uint) -> &[u8] { v[i..j] }\n+fn broken(v: &[u8], i: uint, j: uint) -> &[u8] { v.slice(i, j) }\n \n pub fn main() {}"}, {"sha": "dea352833f0edffeb3612967e6cf52e5f9aaf826", "filename": "src/test/run-pass/issue-8898.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Ftest%2Frun-pass%2Fissue-8898.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Ftest%2Frun-pass%2Fissue-8898.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-8898.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(slicing_syntax)]\n \n extern crate debug;\n \n@@ -22,7 +21,7 @@ pub fn main() {\n     let abc = [1i, 2, 3];\n     let tf = [true, false];\n     let x  = [(), ()];\n-    let slice = x[0..1];\n+    let slice = x.slice(0,1);\n     let z = box(GC) x;\n \n     assert_repr_eq(abc, \"[1, 2, 3]\".to_string());"}, {"sha": "3c0933a055cba7e788d85cadfecbb85327f43da4", "filename": "src/test/run-pass/slice-2.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Ftest%2Frun-pass%2Fslice-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Ftest%2Frun-pass%2Fslice-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fslice-2.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -10,8 +10,6 @@\n \n // Test slicing expressions on slices and Vecs.\n \n-#![feature(slicing_syntax)]\n-\n fn main() {\n     let x: &[int] = &[1, 2, 3, 4, 5];\n     let cmp: &[int] = &[1, 2, 3, 4, 5];"}, {"sha": "f6972023a72a5830653b58c5adf5d429951fce83", "filename": "src/test/run-pass/slice-fail-1.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Ftest%2Frun-pass%2Fslice-fail-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Ftest%2Frun-pass%2Fslice-fail-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fslice-fail-1.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -10,8 +10,6 @@\n \n // Test that is a slicing expr[..] fails, the correct cleanups happen.\n \n-#![feature(slicing_syntax)]\n-\n use std::task;\n \n struct Foo;"}, {"sha": "cbe65fcd83d2dcaa1c44c4fd487e5b5e52049e11", "filename": "src/test/run-pass/slice-fail-2.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Ftest%2Frun-pass%2Fslice-fail-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Ftest%2Frun-pass%2Fslice-fail-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fslice-fail-2.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -10,8 +10,6 @@\n \n // Test that is a slicing expr[..] fails, the correct cleanups happen.\n \n-#![feature(slicing_syntax)]\n-\n use std::task;\n \n struct Foo;"}, {"sha": "39feb075add55ff87fa3e46dd50a275c724a9c49", "filename": "src/test/run-pass/slice.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Ftest%2Frun-pass%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58f77e234ef40c4f19f9dc44c2be2c21163f851/src%2Ftest%2Frun-pass%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fslice.rs?ref=b58f77e234ef40c4f19f9dc44c2be2c21163f851", "patch": "@@ -10,8 +10,6 @@\n \n // Test slicing sugar.\n \n-#![feature(slicing_syntax)]\n-\n extern crate core;\n use core::ops::{Slice,SliceMut};\n \n@@ -20,38 +18,38 @@ static mut COUNT: uint = 0;\n struct Foo;\n \n impl Slice<Foo, Foo> for Foo {\n-    fn as_slice<'a>(&'a self) -> &'a Foo {\n+    fn as_slice_<'a>(&'a self) -> &'a Foo {\n         unsafe { COUNT += 1; }\n         self\n     }\n-    fn slice_from<'a>(&'a self, _from: &Foo) -> &'a Foo {\n+    fn slice_from_<'a>(&'a self, _from: &Foo) -> &'a Foo {\n         unsafe { COUNT += 1; }\n         self\n     }\n-    fn slice_to<'a>(&'a self, _to: &Foo) -> &'a Foo {\n+    fn slice_to_<'a>(&'a self, _to: &Foo) -> &'a Foo {\n         unsafe { COUNT += 1; }\n         self\n     }\n-    fn slice<'a>(&'a self, _from: &Foo, _to: &Foo) -> &'a Foo {\n+    fn slice_<'a>(&'a self, _from: &Foo, _to: &Foo) -> &'a Foo {\n         unsafe { COUNT += 1; }\n         self\n     }\n }\n \n impl SliceMut<Foo, Foo> for Foo {\n-    fn as_mut_slice<'a>(&'a mut self) -> &'a mut Foo {\n+    fn as_mut_slice_<'a>(&'a mut self) -> &'a mut Foo {\n         unsafe { COUNT += 1; }\n         self\n     }\n-    fn slice_from_mut<'a>(&'a mut self, _from: &Foo) -> &'a mut Foo {\n+    fn slice_from_mut_<'a>(&'a mut self, _from: &Foo) -> &'a mut Foo {\n         unsafe { COUNT += 1; }\n         self\n     }\n-    fn slice_to_mut<'a>(&'a mut self, _to: &Foo) -> &'a mut Foo {\n+    fn slice_to_mut_<'a>(&'a mut self, _to: &Foo) -> &'a mut Foo {\n         unsafe { COUNT += 1; }\n         self\n     }\n-    fn slice_mut<'a>(&'a mut self, _from: &Foo, _to: &Foo) -> &'a mut Foo {\n+    fn slice_mut_<'a>(&'a mut self, _from: &Foo, _to: &Foo) -> &'a mut Foo {\n         unsafe { COUNT += 1; }\n         self\n     }"}]}