{"sha": "ca42dd67167575daa95a9f3c0d084d44f6c2ad2a", "node_id": "C_kwDOAAsO6NoAKGNhNDJkZDY3MTY3NTc1ZGFhOTVhOWYzYzBkMDg0ZDQ0ZjZjMmFkMmE", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-05-08T12:42:12Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-11-29T18:39:03Z"}, "message": "Sanity check fingerprints in the dep-graph.", "tree": {"sha": "1ff08267c7aedbb0451cc15d3f69ab276a535682", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1ff08267c7aedbb0451cc15d3f69ab276a535682"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ca42dd67167575daa95a9f3c0d084d44f6c2ad2a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ca42dd67167575daa95a9f3c0d084d44f6c2ad2a", "html_url": "https://github.com/rust-lang/rust/commit/ca42dd67167575daa95a9f3c0d084d44f6c2ad2a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ca42dd67167575daa95a9f3c0d084d44f6c2ad2a/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7c45772bc996cac15c090cdeb13ac14f713486d0", "url": "https://api.github.com/repos/rust-lang/rust/commits/7c45772bc996cac15c090cdeb13ac14f713486d0", "html_url": "https://github.com/rust-lang/rust/commit/7c45772bc996cac15c090cdeb13ac14f713486d0"}], "stats": {"total": 58, "additions": 39, "deletions": 19}, "files": [{"sha": "e4f2b87e78f128548d3b7e7d695c31b7732a7a93", "filename": "compiler/rustc_query_system/src/dep_graph/graph.rs", "status": "modified", "additions": 35, "deletions": 19, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/ca42dd67167575daa95a9f3c0d084d44f6c2ad2a/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca42dd67167575daa95a9f3c0d084d44f6c2ad2a/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs?ref=ca42dd67167575daa95a9f3c0d084d44f6c2ad2a", "patch": "@@ -916,6 +916,11 @@ pub(super) struct CurrentDepGraph<K: DepKind> {\n     new_node_to_index: Sharded<FxHashMap<DepNode<K>, DepNodeIndex>>,\n     prev_index_to_index: Lock<IndexVec<SerializedDepNodeIndex, Option<DepNodeIndex>>>,\n \n+    /// This is used to verify that fingerprints do not change between the creation of a node\n+    /// and its recomputation.\n+    #[cfg(debug_assertions)]\n+    fingerprints: Lock<FxHashMap<DepNode<K>, Fingerprint>>,\n+\n     /// Used to trap when a specific edge is added to the graph.\n     /// This is used for debug purposes and is only active with `debug_assertions`.\n     #[cfg(debug_assertions)]\n@@ -999,17 +1004,27 @@ impl<K: DepKind> CurrentDepGraph<K> {\n             anon_id_seed,\n             #[cfg(debug_assertions)]\n             forbidden_edge,\n+            #[cfg(debug_assertions)]\n+            fingerprints: Lock::new(Default::default()),\n             total_read_count: AtomicU64::new(0),\n             total_duplicate_read_count: AtomicU64::new(0),\n             node_intern_event_id,\n         }\n     }\n \n     #[cfg(debug_assertions)]\n-    fn record_edge(&self, dep_node_index: DepNodeIndex, key: DepNode<K>) {\n+    fn record_edge(&self, dep_node_index: DepNodeIndex, key: DepNode<K>, fingerprint: Fingerprint) {\n         if let Some(forbidden_edge) = &self.forbidden_edge {\n             forbidden_edge.index_to_node.lock().insert(dep_node_index, key);\n         }\n+        match self.fingerprints.lock().entry(key) {\n+            Entry::Vacant(v) => {\n+                v.insert(fingerprint);\n+            }\n+            Entry::Occupied(o) => {\n+                assert_eq!(*o.get(), fingerprint, \"Unstable fingerprints for {:?}\", key);\n+            }\n+        }\n     }\n \n     /// Writes the node to the current dep-graph and allocates a `DepNodeIndex` for it.\n@@ -1021,17 +1036,21 @@ impl<K: DepKind> CurrentDepGraph<K> {\n         edges: EdgesVec,\n         current_fingerprint: Fingerprint,\n     ) -> DepNodeIndex {\n-        match self.new_node_to_index.get_shard_by_value(&key).lock().entry(key) {\n+        let dep_node_index = match self.new_node_to_index.get_shard_by_value(&key).lock().entry(key)\n+        {\n             Entry::Occupied(entry) => *entry.get(),\n             Entry::Vacant(entry) => {\n                 let dep_node_index =\n                     self.encoder.borrow().send(profiler, key, current_fingerprint, edges);\n                 entry.insert(dep_node_index);\n-                #[cfg(debug_assertions)]\n-                self.record_edge(dep_node_index, key);\n                 dep_node_index\n             }\n-        }\n+        };\n+\n+        #[cfg(debug_assertions)]\n+        self.record_edge(dep_node_index, key, current_fingerprint);\n+\n+        dep_node_index\n     }\n \n     fn intern_node(\n@@ -1072,7 +1091,7 @@ impl<K: DepKind> CurrentDepGraph<K> {\n                     };\n \n                     #[cfg(debug_assertions)]\n-                    self.record_edge(dep_node_index, key);\n+                    self.record_edge(dep_node_index, key, fingerprint);\n                     (dep_node_index, Some((prev_index, DepNodeColor::Green(dep_node_index))))\n                 } else {\n                     if print_status {\n@@ -1094,7 +1113,7 @@ impl<K: DepKind> CurrentDepGraph<K> {\n                     };\n \n                     #[cfg(debug_assertions)]\n-                    self.record_edge(dep_node_index, key);\n+                    self.record_edge(dep_node_index, key, fingerprint);\n                     (dep_node_index, Some((prev_index, DepNodeColor::Red)))\n                 }\n             } else {\n@@ -1119,7 +1138,7 @@ impl<K: DepKind> CurrentDepGraph<K> {\n                 };\n \n                 #[cfg(debug_assertions)]\n-                self.record_edge(dep_node_index, key);\n+                self.record_edge(dep_node_index, key, Fingerprint::ZERO);\n                 (dep_node_index, Some((prev_index, DepNodeColor::Red)))\n             }\n         } else {\n@@ -1150,19 +1169,16 @@ impl<K: DepKind> CurrentDepGraph<K> {\n             Some(dep_node_index) => dep_node_index,\n             None => {\n                 let key = prev_graph.index_to_node(prev_index);\n-                let dep_node_index = self.encoder.borrow().send(\n-                    profiler,\n-                    key,\n-                    prev_graph.fingerprint_by_index(prev_index),\n-                    prev_graph\n-                        .edge_targets_from(prev_index)\n-                        .iter()\n-                        .map(|i| prev_index_to_index[*i].unwrap())\n-                        .collect(),\n-                );\n+                let edges = prev_graph\n+                    .edge_targets_from(prev_index)\n+                    .iter()\n+                    .map(|i| prev_index_to_index[*i].unwrap())\n+                    .collect();\n+                let fingerprint = prev_graph.fingerprint_by_index(prev_index);\n+                let dep_node_index = self.encoder.borrow().send(profiler, key, fingerprint, edges);\n                 prev_index_to_index[prev_index] = Some(dep_node_index);\n                 #[cfg(debug_assertions)]\n-                self.record_edge(dep_node_index, key);\n+                self.record_edge(dep_node_index, key, fingerprint);\n                 dep_node_index\n             }\n         }"}, {"sha": "4c4680b5d8ea89b7d241e548a0e386da06e998df", "filename": "compiler/rustc_query_system/src/query/caches.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ca42dd67167575daa95a9f3c0d084d44f6c2ad2a/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fcaches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca42dd67167575daa95a9f3c0d084d44f6c2ad2a/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fcaches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fcaches.rs?ref=ca42dd67167575daa95a9f3c0d084d44f6c2ad2a", "patch": "@@ -117,6 +117,8 @@ where\n         let mut lock = self.cache.get_shard_by_value(&key).lock();\n         #[cfg(not(parallel_compiler))]\n         let mut lock = self.cache.lock();\n+        // We may be overwriting another value.  This is all right, since the dep-graph\n+        // will check that the fingerprint matches.\n         lock.insert(key, (value.clone(), index));\n         value\n     }\n@@ -202,6 +204,8 @@ where\n         let mut lock = self.cache.get_shard_by_value(&key).lock();\n         #[cfg(not(parallel_compiler))]\n         let mut lock = self.cache.lock();\n+        // We may be overwriting another value.  This is all right, since the dep-graph\n+        // will check that the fingerprint matches.\n         lock.insert(key, value);\n         &value.0\n     }"}]}