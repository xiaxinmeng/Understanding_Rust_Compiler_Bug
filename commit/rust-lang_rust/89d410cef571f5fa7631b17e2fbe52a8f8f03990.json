{"sha": "89d410cef571f5fa7631b17e2fbe52a8f8f03990", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg5ZDQxMGNlZjU3MWY1ZmE3NjMxYjE3ZTJmYmU1MmE4ZjhmMDM5OTA=", "commit": {"author": {"name": "Kirill Bulatov", "email": "mail4score@gmail.com", "date": "2021-02-28T08:32:15Z"}, "committer": {"name": "Kirill Bulatov", "email": "mail4score@gmail.com", "date": "2021-03-08T21:59:20Z"}, "message": "Do not propose already imported imports", "tree": {"sha": "6c40354741dda2072ef08f1bab9920547277bdd0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6c40354741dda2072ef08f1bab9920547277bdd0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/89d410cef571f5fa7631b17e2fbe52a8f8f03990", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/89d410cef571f5fa7631b17e2fbe52a8f8f03990", "html_url": "https://github.com/rust-lang/rust/commit/89d410cef571f5fa7631b17e2fbe52a8f8f03990", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/89d410cef571f5fa7631b17e2fbe52a8f8f03990/comments", "author": {"login": "SomeoneToIgnore", "id": 2690773, "node_id": "MDQ6VXNlcjI2OTA3NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/2690773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SomeoneToIgnore", "html_url": "https://github.com/SomeoneToIgnore", "followers_url": "https://api.github.com/users/SomeoneToIgnore/followers", "following_url": "https://api.github.com/users/SomeoneToIgnore/following{/other_user}", "gists_url": "https://api.github.com/users/SomeoneToIgnore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SomeoneToIgnore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SomeoneToIgnore/subscriptions", "organizations_url": "https://api.github.com/users/SomeoneToIgnore/orgs", "repos_url": "https://api.github.com/users/SomeoneToIgnore/repos", "events_url": "https://api.github.com/users/SomeoneToIgnore/events{/privacy}", "received_events_url": "https://api.github.com/users/SomeoneToIgnore/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SomeoneToIgnore", "id": 2690773, "node_id": "MDQ6VXNlcjI2OTA3NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/2690773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SomeoneToIgnore", "html_url": "https://github.com/SomeoneToIgnore", "followers_url": "https://api.github.com/users/SomeoneToIgnore/followers", "following_url": "https://api.github.com/users/SomeoneToIgnore/following{/other_user}", "gists_url": "https://api.github.com/users/SomeoneToIgnore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SomeoneToIgnore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SomeoneToIgnore/subscriptions", "organizations_url": "https://api.github.com/users/SomeoneToIgnore/orgs", "repos_url": "https://api.github.com/users/SomeoneToIgnore/repos", "events_url": "https://api.github.com/users/SomeoneToIgnore/events{/privacy}", "received_events_url": "https://api.github.com/users/SomeoneToIgnore/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9482353fa8e1e88cb720a029b9bb6304819c7399", "url": "https://api.github.com/repos/rust-lang/rust/commits/9482353fa8e1e88cb720a029b9bb6304819c7399", "html_url": "https://github.com/rust-lang/rust/commit/9482353fa8e1e88cb720a029b9bb6304819c7399"}], "stats": {"total": 72, "additions": 45, "deletions": 27}, "files": [{"sha": "69370ef3d86542c28a2fa7b50b7d02ff05edaf13", "filename": "crates/hir/src/semantics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89d410cef571f5fa7631b17e2fbe52a8f8f03990/crates%2Fhir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89d410cef571f5fa7631b17e2fbe52a8f8f03990/crates%2Fhir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics.rs?ref=89d410cef571f5fa7631b17e2fbe52a8f8f03990", "patch": "@@ -774,7 +774,7 @@ fn find_root(node: &SyntaxNode) -> SyntaxNode {\n ///\n /// Note that if you are wondering \"what does this specific existing name mean?\",\n /// you'd better use the `resolve_` family of methods.\n-#[derive(Debug)]\n+#[derive(Debug, Clone)]\n pub struct SemanticsScope<'a> {\n     pub db: &'a dyn HirDatabase,\n     file_id: HirFileId,"}, {"sha": "18254758932eec64bcca492e0701a7fae3b05110", "filename": "crates/ide_assists/src/handlers/auto_import.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89d410cef571f5fa7631b17e2fbe52a8f8f03990/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fauto_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89d410cef571f5fa7631b17e2fbe52a8f8f03990/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fauto_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fauto_import.rs?ref=89d410cef571f5fa7631b17e2fbe52a8f8f03990", "patch": "@@ -111,7 +111,9 @@ pub(crate) fn auto_import(acc: &mut Assists, ctx: &AssistContext) -> Option<()>\n     Some(())\n }\n \n-pub(super) fn find_importable_node(ctx: &AssistContext) -> Option<(ImportAssets, SyntaxNode)> {\n+pub(super) fn find_importable_node<'a>(\n+    ctx: &'a AssistContext,\n+) -> Option<(ImportAssets<'a>, SyntaxNode)> {\n     if let Some(path_under_caret) = ctx.find_node_at_offset_with_descend::<ast::Path>() {\n         ImportAssets::for_exact_path(&path_under_caret, &ctx.sema)\n             .zip(Some(path_under_caret.syntax().clone()))"}, {"sha": "d6adf70b1389da6914572aa0ccd601372767eb27", "filename": "crates/ide_completion/src/completions/flyimport.rs", "status": "modified", "additions": 7, "deletions": 16, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/89d410cef571f5fa7631b17e2fbe52a8f8f03990/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fflyimport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89d410cef571f5fa7631b17e2fbe52a8f8f03990/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fflyimport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fflyimport.rs?ref=89d410cef571f5fa7631b17e2fbe52a8f8f03990", "patch": "@@ -48,12 +48,11 @@\n //! Note that having this flag set to `true` does not guarantee that the feature is enabled: your client needs to have the corredponding\n //! capability enabled.\n \n-use hir::{AsAssocItem, ModPath, ScopeDef};\n+use hir::{AsAssocItem, ItemInNs, ModPath, ScopeDef};\n use ide_db::helpers::{\n     import_assets::{ImportAssets, ImportCandidate},\n     insert_use::ImportScope,\n };\n-use rustc_hash::FxHashSet;\n use syntax::{AstNode, SyntaxNode, T};\n \n use crate::{\n@@ -92,19 +91,17 @@ pub(crate) fn import_on_the_fly(acc: &mut Completions, ctx: &CompletionContext)\n         &ctx.sema,\n     )?;\n \n-    let scope_definitions = scope_definitions(ctx);\n     let mut all_mod_paths = import_assets\n         .search_for_imports(&ctx.sema, ctx.config.insert_use.prefix_kind)\n         .into_iter()\n         .map(|import| {\n             let proposed_def = match import.item_to_display() {\n-                hir::ItemInNs::Types(id) => ScopeDef::ModuleDef(id.into()),\n-                hir::ItemInNs::Values(id) => ScopeDef::ModuleDef(id.into()),\n-                hir::ItemInNs::Macros(id) => ScopeDef::MacroDef(id.into()),\n+                ItemInNs::Types(id) => ScopeDef::ModuleDef(id.into()),\n+                ItemInNs::Values(id) => ScopeDef::ModuleDef(id.into()),\n+                ItemInNs::Macros(id) => ScopeDef::MacroDef(id.into()),\n             };\n             (import, proposed_def)\n         })\n-        .filter(|(_, proposed_def)| !scope_definitions.contains(proposed_def))\n         .collect::<Vec<_>>();\n     all_mod_paths.sort_by_cached_key(|(import, _)| {\n         compute_fuzzy_completion_order_key(import.display_path(), &user_input_lowercased)\n@@ -125,14 +122,6 @@ pub(crate) fn import_on_the_fly(acc: &mut Completions, ctx: &CompletionContext)\n     Some(())\n }\n \n-fn scope_definitions(ctx: &CompletionContext) -> FxHashSet<ScopeDef> {\n-    let mut scope_definitions = FxHashSet::default();\n-    ctx.scope.process_all_names(&mut |_, scope_def| {\n-        scope_definitions.insert(scope_def);\n-    });\n-    scope_definitions\n-}\n-\n pub(crate) fn position_for_import<'a>(\n     ctx: &'a CompletionContext,\n     import_candidate: Option<&ImportCandidate>,\n@@ -150,13 +139,14 @@ pub(crate) fn position_for_import<'a>(\n     })\n }\n \n-fn import_assets(ctx: &CompletionContext, fuzzy_name: String) -> Option<ImportAssets> {\n+fn import_assets<'a>(ctx: &'a CompletionContext, fuzzy_name: String) -> Option<ImportAssets<'a>> {\n     let current_module = ctx.scope.module()?;\n     if let Some(dot_receiver) = &ctx.dot_receiver {\n         ImportAssets::for_fuzzy_method_call(\n             current_module,\n             ctx.sema.type_of_expr(dot_receiver)?,\n             fuzzy_name,\n+            ctx.scope.clone(),\n         )\n     } else {\n         let fuzzy_name_length = fuzzy_name.len();\n@@ -165,6 +155,7 @@ fn import_assets(ctx: &CompletionContext, fuzzy_name: String) -> Option<ImportAs\n             ctx.path_qual.clone(),\n             fuzzy_name,\n             &ctx.sema,\n+            ctx.scope.clone(),\n         )?;\n \n         if matches!(assets_for_path.import_candidate(), ImportCandidate::Path(_))"}, {"sha": "b25786928e1d817b55077d9db4b228fb94f88347", "filename": "crates/ide_db/src/helpers/import_assets.rs", "status": "modified", "additions": 34, "deletions": 9, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/89d410cef571f5fa7631b17e2fbe52a8f8f03990/crates%2Fide_db%2Fsrc%2Fhelpers%2Fimport_assets.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89d410cef571f5fa7631b17e2fbe52a8f8f03990/crates%2Fide_db%2Fsrc%2Fhelpers%2Fimport_assets.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fhelpers%2Fimport_assets.rs?ref=89d410cef571f5fa7631b17e2fbe52a8f8f03990", "patch": "@@ -2,7 +2,7 @@\n use either::Either;\n use hir::{\n     AsAssocItem, AssocItem, AssocItemContainer, Crate, ItemInNs, MacroDef, ModPath, Module,\n-    ModuleDef, PathResolution, PrefixKind, Semantics, Type,\n+    ModuleDef, PathResolution, PrefixKind, ScopeDef, Semantics, SemanticsScope, Type,\n };\n use rustc_hash::FxHashSet;\n use syntax::{ast, AstNode};\n@@ -62,33 +62,38 @@ impl NameToImport {\n }\n \n #[derive(Debug)]\n-pub struct ImportAssets {\n+pub struct ImportAssets<'a> {\n     import_candidate: ImportCandidate,\n     module_with_candidate: Module,\n+    scope: SemanticsScope<'a>,\n }\n \n-impl ImportAssets {\n+impl<'a> ImportAssets<'a> {\n     pub fn for_method_call(\n         method_call: &ast::MethodCallExpr,\n-        sema: &Semantics<RootDatabase>,\n+        sema: &'a Semantics<RootDatabase>,\n     ) -> Option<Self> {\n+        let scope = sema.scope(method_call.syntax());\n         Some(Self {\n             import_candidate: ImportCandidate::for_method_call(sema, method_call)?,\n-            module_with_candidate: sema.scope(method_call.syntax()).module()?,\n+            module_with_candidate: scope.module()?,\n+            scope,\n         })\n     }\n \n     pub fn for_exact_path(\n         fully_qualified_path: &ast::Path,\n-        sema: &Semantics<RootDatabase>,\n+        sema: &'a Semantics<RootDatabase>,\n     ) -> Option<Self> {\n         let syntax_under_caret = fully_qualified_path.syntax();\n         if syntax_under_caret.ancestors().find_map(ast::Use::cast).is_some() {\n             return None;\n         }\n+        let scope = sema.scope(syntax_under_caret);\n         Some(Self {\n             import_candidate: ImportCandidate::for_regular_path(sema, fully_qualified_path)?,\n-            module_with_candidate: sema.scope(syntax_under_caret).module()?,\n+            module_with_candidate: scope.module()?,\n+            scope,\n         })\n     }\n \n@@ -97,24 +102,28 @@ impl ImportAssets {\n         qualifier: Option<ast::Path>,\n         fuzzy_name: String,\n         sema: &Semantics<RootDatabase>,\n+        scope: SemanticsScope<'a>,\n     ) -> Option<Self> {\n         Some(Self {\n             import_candidate: ImportCandidate::for_fuzzy_path(qualifier, fuzzy_name, sema)?,\n             module_with_candidate,\n+            scope,\n         })\n     }\n \n     pub fn for_fuzzy_method_call(\n         module_with_method_call: Module,\n         receiver_ty: Type,\n         fuzzy_method_name: String,\n+        scope: SemanticsScope<'a>,\n     ) -> Option<Self> {\n         Some(Self {\n             import_candidate: ImportCandidate::TraitMethod(TraitImportCandidate {\n                 receiver_ty,\n                 name: NameToImport::Fuzzy(fuzzy_method_name),\n             }),\n             module_with_candidate: module_with_method_call,\n+            scope,\n         })\n     }\n }\n@@ -155,7 +164,7 @@ impl LocatedImport {\n     }\n }\n \n-impl ImportAssets {\n+impl<'a> ImportAssets<'a> {\n     pub fn import_candidate(&self) -> &ImportCandidate {\n         &self.import_candidate\n     }\n@@ -189,6 +198,7 @@ impl ImportAssets {\n         prefixed: Option<PrefixKind>,\n     ) -> Vec<LocatedImport> {\n         let current_crate = self.module_with_candidate.krate();\n+        let scope_definitions = self.scope_definitions();\n \n         let imports_for_candidate_name = match self.name_to_import() {\n             NameToImport::Exact(exact_name) => {\n@@ -219,9 +229,25 @@ impl ImportAssets {\n         self.applicable_defs(sema.db, prefixed, imports_for_candidate_name)\n             .into_iter()\n             .filter(|import| import.import_path().len() > 1)\n+            .filter(|import| {\n+                let proposed_def = match import.item_to_import() {\n+                    ItemInNs::Types(id) => ScopeDef::ModuleDef(id.into()),\n+                    ItemInNs::Values(id) => ScopeDef::ModuleDef(id.into()),\n+                    ItemInNs::Macros(id) => ScopeDef::MacroDef(id.into()),\n+                };\n+                !scope_definitions.contains(&proposed_def)\n+            })\n             .collect()\n     }\n \n+    fn scope_definitions(&self) -> FxHashSet<ScopeDef> {\n+        let mut scope_definitions = FxHashSet::default();\n+        self.scope.process_all_names(&mut |_, scope_def| {\n+            scope_definitions.insert(scope_def);\n+        });\n+        scope_definitions\n+    }\n+\n     fn applicable_defs(\n         &self,\n         db: &RootDatabase,\n@@ -297,7 +323,6 @@ fn path_applicable_imports(\n         Qualifier::FirstSegmentUnresolved(first_segment, qualifier) => (first_segment, qualifier),\n     };\n \n-    // TODO kb zz.syntax().ast_node() <- two options are now proposed despite the trait being imported\n     let unresolved_qualifier_string = unresolved_qualifier.to_string();\n     let unresolved_first_segment_string = unresolved_first_segment.to_string();\n "}]}