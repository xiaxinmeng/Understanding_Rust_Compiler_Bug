{"sha": "d5d5c5064b3f27918432484d27b88204df940209", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ1ZDVjNTA2NGIzZjI3OTE4NDMyNDg0ZDI3Yjg4MjA0ZGY5NDAyMDk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-12-20T20:41:33Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-12-20T20:41:33Z"}, "message": "auto merge of #10986 : adridu59/rust/patch-new, r=alexcrichton\n\nThanks to @huonw for some mentoring. :cake:", "tree": {"sha": "abab5412fffcbab50ecfd68d2b645a74bbe1d789", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/abab5412fffcbab50ecfd68d2b645a74bbe1d789"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d5d5c5064b3f27918432484d27b88204df940209", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d5d5c5064b3f27918432484d27b88204df940209", "html_url": "https://github.com/rust-lang/rust/commit/d5d5c5064b3f27918432484d27b88204df940209", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d5d5c5064b3f27918432484d27b88204df940209/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "810c4de6a4065163662aa21c50d5ed500550c8d0", "url": "https://api.github.com/repos/rust-lang/rust/commits/810c4de6a4065163662aa21c50d5ed500550c8d0", "html_url": "https://github.com/rust-lang/rust/commit/810c4de6a4065163662aa21c50d5ed500550c8d0"}, {"sha": "bf5f2f26314ba96752fef4718e5f211fe3f3923d", "url": "https://api.github.com/repos/rust-lang/rust/commits/bf5f2f26314ba96752fef4718e5f211fe3f3923d", "html_url": "https://github.com/rust-lang/rust/commit/bf5f2f26314ba96752fef4718e5f211fe3f3923d"}], "stats": {"total": 326, "additions": 153, "deletions": 173}, "files": [{"sha": "bcde838ab4d868a2dd5607eebddedf73b46dfb82", "filename": "doc/rust.css", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d5d5c5064b3f27918432484d27b88204df940209/doc%2Frust.css", "raw_url": "https://github.com/rust-lang/rust/raw/d5d5c5064b3f27918432484d27b88204df940209/doc%2Frust.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.css?ref=d5d5c5064b3f27918432484d27b88204df940209", "patch": "@@ -216,6 +216,10 @@ dd {\n     list-style-type: none;\n     padding-left: 0px;\n }\n+/* Only display one level of hierarchy in the TOC */\n+#TOC ul ul {\n+    display: none;\n+}\n \n sub,\n sup {"}, {"sha": "6782a05fbf9c2e67eeb772be6c08b5db3292c895", "filename": "doc/tutorial-conditions.md", "status": "modified", "additions": 146, "deletions": 170, "changes": 316, "blob_url": "https://github.com/rust-lang/rust/blob/d5d5c5064b3f27918432484d27b88204df940209/doc%2Ftutorial-conditions.md", "raw_url": "https://github.com/rust-lang/rust/raw/d5d5c5064b3f27918432484d27b88204df940209/doc%2Ftutorial-conditions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-conditions.md?ref=d5d5c5064b3f27918432484d27b88204df940209", "patch": "@@ -45,22 +45,20 @@ An example program that does this task reads like this:\n \n ~~~~{.xfail-test}\n # #[allow(unused_imports)];\n-extern mod extra;\n-use extra::fileinput::FileInput;\n-use std::int;\n-# mod FileInput {\n-#    use std::io::{Reader, BytesReader};\n-#    static s : &'static [u8] = bytes!(\"1 2\\n\\\n-#                                       34 56\\n\\\n-#                                       789 123\\n\\\n-#                                       45 67\\n\\\n-#                                       \");\n-#    pub fn from_args() -> @Reader{\n-#        @BytesReader {\n-#            bytes: s,\n-#            pos: @mut 0\n-#        } as @Reader\n-#    }\n+use std::io::buffered::BufferedReader;\n+use std::io::fs::File;\n+# mod BufferedReader {\n+#     use std::io::fs::File;\n+#     use std::io::mem::MemReader;\n+#     use std::io::buffered::BufferedReader;\n+#     static s : &'static [u8] = bytes!(\"1 2\\n\\\n+#                                        34 56\\n\\\n+#                                        789 123\\n\\\n+#                                        45 67\\n\\\n+#                                        \");\n+#     pub fn new(_inner: Option<File>) -> BufferedReader<MemReader> {\n+#           BufferedReader::new(MemReader::new(s.to_owned()))\n+#     }\n # }\n \n fn main() {\n@@ -70,42 +68,37 @@ fn main() {\n     }\n }\n \n-\n fn read_int_pairs() -> ~[(int,int)] {\n-\n     let mut pairs = ~[];\n \n-    let fi = FileInput::from_args();\n-    while ! fi.eof() {\n+    let args = std::os::args();\n \n-        // 1. Read a line of input.\n-        let line = fi.read_line();\n+    // Path takes a generic by-value, rather than by reference\n+    let path = Path::new(args.get_opt(1).expect(\"No input file parameter!\").as_slice());\n+    let mut reader = BufferedReader::new(File::open(&path));\n \n+    // 1. Iterate over the lines of our file.\n+    for line in reader.lines() {\n         // 2. Split the line into fields (\"words\").\n         let fields = line.words().to_owned_vec();\n-\n         // 3. Match the vector of fields against a vector pattern.\n         match fields {\n \n             // 4. When the line had two fields:\n             [a, b] => {\n-\n                 // 5. Try parsing both fields as ints.\n                 match (from_str::<int>(a), from_str::<int>(b)) {\n \n                     // 6. If parsing succeeded for both, push both.\n                     (Some(a), Some(b)) => pairs.push((a,b)),\n-\n                     // 7. Ignore non-int fields.\n                     _ => ()\n                 }\n             }\n-\n             // 8. Ignore lines that don't have 2 fields.\n             _ => ()\n         }\n     }\n-\n     pairs\n }\n ~~~~\n@@ -115,7 +108,6 @@ along with some other forms of error-handling (and non-handling).\n We will look at these mechanisms\n and then modify parts of the example to perform \"better\" error handling.\n \n-\n # Options\n \n The simplest and most lightweight mechanism in Rust for indicating an error is the type `std::option::Option<T>`.\n@@ -152,7 +144,6 @@ several unwanted cases are silently ignored:\n lines that do not contain two fields, as well as fields that do not parse as ints.\n To propagate these cases to the caller using `Option` would require even more verbose code.\n \n-\n # Results\n \n Before getting into _trapping_ the error,\n@@ -181,7 +172,7 @@ This would give the caller more information for both handling and reporting the\n but would otherwise retain the verbosity problems of using `Option`.\n In particular, it would still be necessary for the caller to return a further `Result` to _its_ caller if it did not want to handle the error.\n Manually propagating result values this way can be attractive in certain circumstances\n--- for example when processing must halt on the very first error, or backtrack --\n+&mdash; for example when processing must halt on the very first error, or backtrack &mdash;\n but as we will see later, many cases have simpler options available.\n \n # Failure\n@@ -251,26 +242,23 @@ If the example is rewritten to use failure, these error cases can be trapped.\n In this rewriting, failures are trapped by placing the I/O logic in a sub-task,\n and trapping its exit status using `task::try`:\n \n-~~~~ {.xfail-test}\n-# #[allowed(unused_imports)];\n-extern mod extra;\n-use extra::fileinput::FileInput;\n-use std::int;\n+~~~~{.xfail-test}\n+# #[allow(unused_imports)];\n+use std::io::buffered::BufferedReader;\n+use std::io::fs::File;\n use std::task;\n-# mod FileInput {\n-#    use std::io::{Reader, BytesReader};\n-#    static s : &'static [u8] = bytes!(\"1 2\\n\\\n-#                                       34 56\\n\\\n-#                                       ostrich\\n\\\n-#                                       789 123\\n\\\n-#                                       45 67\\n\\\n-#                                       \");\n-#    pub fn from_args() -> @Reader{\n-#        @BytesReader {\n-#            bytes: s,\n-#            pos: @mut 0\n-#        } as @Reader\n-#    }\n+# mod BufferedReader {\n+#     use std::io::fs::File;\n+#     use std::io::mem::MemReader;\n+#     use std::io::buffered::BufferedReader;\n+#     static s : &'static [u8] = bytes!(\"1 2\\n\\\n+#                                        34 56\\n\\\n+#                                        789 123\\n\\\n+#                                        45 67\\n\\\n+#                                        \");\n+#     pub fn new(_inner: Option<File>) -> BufferedReader<MemReader> {\n+#           BufferedReader::new(MemReader::new(s.to_owned()))\n+#     }\n # }\n \n fn main() {\n@@ -292,11 +280,12 @@ fn main() {\n \n fn read_int_pairs() -> ~[(int,int)] {\n     let mut pairs = ~[];\n-    let fi = FileInput::from_args();\n-    while ! fi.eof() {\n-        let line = fi.read_line();\n-        let fields = line.words().to_owned_vec();\n-        match fields {\n+    let args = std::os::args();\n+    let path = Path::new(args.get_opt(1).expect(\"No input file parameter!\").as_slice());\n+\n+    let mut reader = BufferedReader::new(File::open(&path));\n+    for line in reader.lines() {\n+        match line.words().to_owned_vec() {\n             [a, b] => pairs.push((from_str::<int>(a).unwrap(),\n                                   from_str::<int>(b).unwrap())),\n \n@@ -324,7 +313,6 @@ all the state of a sub-task is cleanly discarded on exit,\n and a supervisor task can take appropriate action\n without worrying about its own state having been corrupted.\n \n-\n # Conditions\n \n The final mechanism for handling errors is called a \"condition\".\n@@ -358,25 +346,22 @@ If no handler is found, `Condition::raise` will fail the task with an appropriat\n Rewriting the example to use a condition in place of ignoring malformed lines makes it slightly longer,\n but similarly clear as the version that used `fail!` in the logic where the error occurs:\n \n-~~~~ {.xfail-test}\n+~~~~{.xfail-test}\n # #[allow(unused_imports)];\n-extern mod extra;\n-use extra::fileinput::FileInput;\n-use std::int;\n-# mod FileInput {\n-#    use std::io::{Reader, BytesReader};\n-#    static s : &'static [u8] = bytes!(\"1 2\\n\\\n-#                                       34 56\\n\\\n-#                                       ostrich\\n\\\n-#                                       789 123\\n\\\n-#                                       45 67\\n\\\n-#                                       \");\n-#    pub fn from_args() -> @Reader{\n-#        @BytesReader {\n-#            bytes: s,\n-#            pos: @mut 0\n-#        } as @Reader\n-#    }\n+use std::io::buffered::BufferedReader;\n+use std::io::fs::File;\n+# mod BufferedReader {\n+#     use std::io::fs::File;\n+#     use std::io::mem::MemReader;\n+#     use std::io::buffered::BufferedReader;\n+#     static s : &'static [u8] = bytes!(\"1 2\\n\\\n+#                                        34 56\\n\\\n+#                                        789 123\\n\\\n+#                                        45 67\\n\\\n+#                                        \");\n+#     pub fn new(_inner: Option<File>) -> BufferedReader<MemReader> {\n+#           BufferedReader::new(MemReader::new(s.to_owned()))\n+#     }\n # }\n \n // Introduce a new condition.\n@@ -393,14 +378,14 @@ fn main() {\n \n fn read_int_pairs() -> ~[(int,int)] {\n     let mut pairs = ~[];\n-    let fi = FileInput::from_args();\n-    while ! fi.eof() {\n-        let line = fi.read_line();\n-        let fields = line.words().to_owned_vec();\n-        match fields {\n+    let args = std::os::args();\n+    let path = Path::new(args.get_opt(1).expect(\"No input file parameter!\").as_slice());\n+\n+    let mut reader = BufferedReader::new(File::open(&path));\n+    for line in reader.lines() {\n+        match line.words().to_owned_vec() {\n             [a, b] => pairs.push((from_str::<int>(a).unwrap(),\n                                   from_str::<int>(b).unwrap())),\n-\n             // On malformed lines, call the condition handler and\n             // push whatever the condition handler returns.\n             _ => pairs.push(malformed_line::cond.raise(line.clone()))\n@@ -432,23 +417,20 @@ and replaces bad input lines with the pair `(-1,-1)`:\n \n ~~~~{.xfail-test}\n # #[allow(unused_imports)];\n-extern mod extra;\n-use extra::fileinput::FileInput;\n-use std::int;\n-# mod FileInput {\n-#    use std::io::{Reader, BytesReader};\n-#    static s : &'static [u8] = bytes!(\"1 2\\n\\\n-#                                       34 56\\n\\\n-#                                       ostrich\\n\\\n-#                                       789 123\\n\\\n-#                                       45 67\\n\\\n-#                                       \");\n-#    pub fn from_args() -> @Reader{\n-#        @BytesReader {\n-#            bytes: s,\n-#            pos: @mut 0\n-#        } as @Reader\n-#    }\n+use std::io::buffered::BufferedReader;\n+use std::io::fs::File;\n+# mod BufferedReader {\n+#     use std::io::fs::File;\n+#     use std::io::mem::MemReader;\n+#     use std::io::buffered::BufferedReader;\n+#     static s : &'static [u8] = bytes!(\"1 2\\n\\\n+#                                        34 56\\n\\\n+#                                        789 123\\n\\\n+#                                        45 67\\n\\\n+#                                        \");\n+#     pub fn new(_inner: Option<File>) -> BufferedReader<MemReader> {\n+#           BufferedReader::new(MemReader::new(s.to_owned()))\n+#     }\n # }\n \n condition! {\n@@ -470,11 +452,12 @@ fn main() {\n \n fn read_int_pairs() -> ~[(int,int)] {\n     let mut pairs = ~[];\n-    let fi = FileInput::from_args();\n-    while ! fi.eof() {\n-        let line = fi.read_line();\n-        let fields = line.words().to_owned_vec();\n-        match fields {\n+    let args = std::os::args();\n+    let path = Path::new(args.get_opt(1).expect(\"No input file parameter!\").as_slice());\n+\n+    let mut reader = BufferedReader::new(File::open(&path));\n+    for line in reader.lines() {\n+        match line.words().to_owned_vec() {\n             [a, b] => pairs.push((from_str::<int>(a).unwrap(),\n                                   from_str::<int>(b).unwrap())),\n             _ => pairs.push(malformed_line::cond.raise(line.clone()))\n@@ -509,23 +492,20 @@ Changing the condition's return type from `(int,int)` to `Option<(int,int)>` wil\n \n ~~~~{.xfail-test}\n # #[allow(unused_imports)];\n-extern mod extra;\n-use extra::fileinput::FileInput;\n-use std::int;\n-# mod FileInput {\n-#    use std::io::{Reader, BytesReader};\n-#    static s : &'static [u8] = bytes!(\"1 2\\n\\\n-#                                       34 56\\n\\\n-#                                       ostrich\\n\\\n-#                                       789 123\\n\\\n-#                                       45 67\\n\\\n-#                                       \");\n-#    pub fn from_args() -> @Reader{\n-#        @BytesReader {\n-#            bytes: s,\n-#            pos: @mut 0\n-#        } as @Reader\n-#    }\n+use std::io::buffered::BufferedReader;\n+use std::io::fs::File;\n+# mod BufferedReader {\n+#     use std::io::fs::File;\n+#     use std::io::mem::MemReader;\n+#     use std::io::buffered::BufferedReader;\n+#     static s : &'static [u8] = bytes!(\"1 2\\n\\\n+#                                        34 56\\n\\\n+#                                        789 123\\n\\\n+#                                        45 67\\n\\\n+#                                        \");\n+#     pub fn new(_inner: Option<File>) -> BufferedReader<MemReader> {\n+#           BufferedReader::new(MemReader::new(s.to_owned()))\n+#     }\n # }\n \n // Modify the condition signature to return an Option.\n@@ -548,11 +528,12 @@ fn main() {\n \n fn read_int_pairs() -> ~[(int,int)] {\n     let mut pairs = ~[];\n-    let fi = FileInput::from_args();\n-    while ! fi.eof() {\n-        let line = fi.read_line();\n-        let fields = line.words().to_owned_vec();\n-        match fields {\n+    let args = std::os::args();\n+    let path = Path::new(args.get_opt(1).expect(\"No input file parameter!\").as_slice());\n+\n+    let mut reader = BufferedReader::new(File::open(&path));\n+    for line in reader.lines() {\n+        match line.words().to_owned_vec() {\n             [a, b] => pairs.push((from_str::<int>(a).unwrap(),\n                                   from_str::<int>(b).unwrap())),\n \n@@ -596,23 +577,20 @@ This can be encoded in the handler API by introducing a helper type: `enum Malfo\n \n ~~~~{.xfail-test}\n # #[allow(unused_imports)];\n-extern mod extra;\n-use extra::fileinput::FileInput;\n-use std::int;\n-# mod FileInput {\n-#    use std::io::{Reader, BytesReader};\n-#    static s : &'static [u8] = bytes!(\"1 2\\n\\\n-#                                       34 56\\n\\\n-#                                       ostrich\\n\\\n-#                                       789 123\\n\\\n-#                                       45 67\\n\\\n-#                                       \");\n-#    pub fn from_args() -> @Reader{\n-#        @BytesReader {\n-#            bytes: s,\n-#            pos: @mut 0\n-#        } as @Reader\n-#    }\n+use std::io::buffered::BufferedReader;\n+use std::io::fs::File;\n+# mod BufferedReader {\n+#     use std::io::fs::File;\n+#     use std::io::mem::MemReader;\n+#     use std::io::buffered::BufferedReader;\n+#     static s : &'static [u8] = bytes!(\"1 2\\n\\\n+#                                        34 56\\n\\\n+#                                        789 123\\n\\\n+#                                        45 67\\n\\\n+#                                        \");\n+#     pub fn new(_inner: Option<File>) -> BufferedReader<MemReader> {\n+#           BufferedReader::new(MemReader::new(s.to_owned()))\n+#     }\n # }\n \n // Introduce a new enum to convey condition-handling strategy to error site.\n@@ -644,11 +622,12 @@ fn main() {\n \n fn read_int_pairs() -> ~[(int,int)] {\n     let mut pairs = ~[];\n-    let fi = FileInput::from_args();\n-    while ! fi.eof() {\n-        let line = fi.read_line();\n-        let fields = line.words().to_owned_vec();\n-        match fields {\n+    let args = std::os::args();\n+    let path = Path::new(args.get_opt(1).expect(\"No input file parameter!\").as_slice());\n+\n+    let mut reader = BufferedReader::new(File::open(&path));\n+    for line in reader.lines() {\n+        match line.words().to_owned_vec() {\n             [a, b] => pairs.push((from_str::<int>(a).unwrap(),\n                                   from_str::<int>(b).unwrap())),\n \n@@ -717,28 +696,25 @@ $ ./example bad.txt\n task <unnamed> failed at 'called `Option::unwrap()` on a `None` value', .../libstd/option.rs:314\n ~~~~\n \n-To make the program robust -- or at least flexible -- in the face of this potential failure,\n+To make the program robust &mdash; or at least flexible &mdash; in the face of this potential failure,\n a second condition and a helper function will suffice:\n \n ~~~~{.xfail-test}\n # #[allow(unused_imports)];\n-extern mod extra;\n-use extra::fileinput::FileInput;\n-use std::int;\n-# mod FileInput {\n-#    use std::io::{Reader, BytesReader};\n-#    static s : &'static [u8] = bytes!(\"1 2\\n\\\n-#                                       34 56\\n\\\n-#                                       7 marmot\\n\\\n-#                                       789 123\\n\\\n-#                                       45 67\\n\\\n-#                                       \");\n-#    pub fn from_args() -> @Reader{\n-#        @BytesReader {\n-#            bytes: s,\n-#            pos: @mut 0\n-#        } as @Reader\n-#    }\n+use std::io::buffered::BufferedReader;\n+use std::io::fs::File;\n+# mod BufferedReader {\n+#     use std::io::fs::File;\n+#     use std::io::mem::MemReader;\n+#     use std::io::buffered::BufferedReader;\n+#     static s : &'static [u8] = bytes!(\"1 2\\n\\\n+#                                        34 56\\n\\\n+#                                        789 123\\n\\\n+#                                        45 67\\n\\\n+#                                        \");\n+#     pub fn new(_inner: Option<File>) -> BufferedReader<MemReader> {\n+#           BufferedReader::new(MemReader::new(s.to_owned()))\n+#     }\n # }\n \n pub enum MalformedLineFix {\n@@ -784,12 +760,12 @@ fn parse_int(x: &str) -> int {\n \n fn read_int_pairs() -> ~[(int,int)] {\n     let mut pairs = ~[];\n-    let fi = FileInput::from_args();\n-    while ! fi.eof() {\n-        let line = fi.read_line();\n-        let fields = line.words().to_owned_vec();\n-        match fields {\n+    let args = std::os::args();\n+    let path = Path::new(args.get_opt(1).expect(\"No input file parameter!\").as_slice());\n \n+    let mut reader = BufferedReader::new(File::open(&path));\n+    for line in reader.lines() {\n+        match line.words().to_owned_vec() {\n             // Delegate parsing ints to helper function that will\n             // handle parse errors by calling `malformed_int`.\n             [a, b] => pairs.push((parse_int(a), parse_int(b))),\n@@ -850,7 +826,7 @@ Each is appropriate to different circumstances:\n     Between `Option` and `Result`: use an `Option` when there is only one kind of error,\n     otherwise make an `enum FooErr` to represent the possible error codes and use `Result<T,FooErr>`.\n \n-  - If an error can reasonably be handled at the site it occurs by one of a few strategies -- possibly including failure --\n+  - If an error can reasonably be handled at the site it occurs by one of a few strategies &mdash; possibly including failure &mdash;\n     and it is not clear which strategy a caller would want to use, a condition is best.\n     For many errors, the only reasonable \"non-stop\" recovery strategies are to retry some number of times,\n     create or substitute an empty or sentinel value, ignore the error, or fail.\n@@ -869,7 +845,7 @@ but with the option to halt unwinding partway through the process and continue e\n This behavior unfortunately means that the _heap_ may be left in an inconsistent but accessible state,\n if an exception is thrown part way through the process of initializing or modifying memory.\n To compensate for this risk, correct C++ and Java code must program in an extremely elaborate and difficult \"exception-safe\" style\n--- effectively transactional style against heap structures --\n+&mdash; effectively transactional style against heap structures &mdash;\n or else risk introducing silent and very difficult-to-debug errors due to control resuming in a corrupted heap after a caught exception.\n These errors are frequently memory-safety errors, which Rust strives to eliminate,\n and so Rust unwinding is unrecoverable within a single task:"}, {"sha": "537b5de1b4a1389355a08668af1fdfa82b781184", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d5d5c5064b3f27918432484d27b88204df940209/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5d5c5064b3f27918432484d27b88204df940209/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=d5d5c5064b3f27918432484d27b88204df940209", "patch": "@@ -476,9 +476,9 @@ pub trait Reader {\n     ///\n     /// # Example\n     ///\n-    ///     let reader = File::open(&Path::new(\"foo.txt\"))\n-    ///     while !reader.eof() {\n-    ///         println(reader.read_line());\n+    ///     let mut reader = BufferedReader::new(File::open(&Path::new(\"foo.txt\")));\n+    ///     for line in reader.lines() {\n+    ///         println(line);\n     ///     }\n     ///\n     /// # Failure"}]}