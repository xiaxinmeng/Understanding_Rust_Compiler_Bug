{"sha": "5e1f92cd841b8c925f5149cb362f550c354d36bf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVlMWY5MmNkODQxYjhjOTI1ZjUxNDljYjM2MmY1NTBjMzU0ZDM2YmY=", "commit": {"author": {"name": "Inokentiy Babushkin", "email": "twk@twki.de", "date": "2018-04-05T18:10:15Z"}, "committer": {"name": "Inokentiy Babushkin", "email": "twk@twki.de", "date": "2018-04-26T20:13:10Z"}, "message": "Reworked auto trait functionality in rustdoc.", "tree": {"sha": "2f2f3dafeeed4e9ec81579cd5abd550b1710b7ab", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2f2f3dafeeed4e9ec81579cd5abd550b1710b7ab"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5e1f92cd841b8c925f5149cb362f550c354d36bf", "comment_count": 0, "verification": {"verified": false, "reason": "unverified_email", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEXezFNCHL3+3lgSPSfvyOxSJN6OwFAlriMtYACgkQfvyOxSJN\n6OwrrhAAnaPAhPKuys5P6N9gAybPBJB9l+tumsqYRrUnYe5na/DtDA4B/zZClJs7\nUu4WbJbka0/cC18HSaz8Ebrgu1RfoCw4Xr4l0JWcm4h6gpEJp2ex/tML/Lw5rtUZ\n3eVC8Z164OSHsVAD7RwujhUyDo7g8QrGZlc68wNKPiV0Qc/o2vtUBUsc8QwEUU3v\nOGyQCYAUJbn7zB/h9OW2he4+6zuo6rOk1uwN45o3VJwadoyOWXLhQBv6ZqEIBV0O\nHzi3F98F5yJDh+DcM65m+OhSIrpgT1OyBKzDWzztdkx8A+PEuL+JQ0fbE/7kAvxu\nf88QruK0vv5cqVKjXHyWt5T50ANLJIh8I52sAwJKbnb04TXZLN79DxhnpNwm/wO8\nwSNkT4Dc4Uzc+smuaqlWbjpvP4DmY2aqW4QWINi9MY2sEhUbjt8+zf749yG65N5Z\nS7H1gUOHwwJFdHWq7+K0IYnwUQHnYHetVIzS/Mt4aimNybn6Zmt59eg/ap+/X2B8\nmrpqitDKsF1F2+ujbCZLluFtKDZjb+gLv/4xwyntfQXQdefaRgcSOnbzMQAOBx7l\nGS5IiTrrUM9/VXfOuQPybwL28WTUjaEiOyt2ReTNqb/T19ZC5snipBQ/dfgDE3nN\n5V0Ky27W5oWRl4SXcvDgszTjSpuFQo5dbq3s04kqkC7qH6l3FNE=\n=zUWp\n-----END PGP SIGNATURE-----", "payload": "tree 2f2f3dafeeed4e9ec81579cd5abd550b1710b7ab\nparent 136abb9fb5ec89f0958602ea8d1fb4058a2d3461\nauthor Inokentiy Babushkin <twk@twki.de> 1522951815 +0200\ncommitter Inokentiy Babushkin <twk@twki.de> 1524773590 +0200\n\nReworked auto trait functionality in rustdoc.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5e1f92cd841b8c925f5149cb362f550c354d36bf", "html_url": "https://github.com/rust-lang/rust/commit/5e1f92cd841b8c925f5149cb362f550c354d36bf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5e1f92cd841b8c925f5149cb362f550c354d36bf/comments", "author": {"login": "ibabushkin", "id": 10811417, "node_id": "MDQ6VXNlcjEwODExNDE3", "avatar_url": "https://avatars.githubusercontent.com/u/10811417?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibabushkin", "html_url": "https://github.com/ibabushkin", "followers_url": "https://api.github.com/users/ibabushkin/followers", "following_url": "https://api.github.com/users/ibabushkin/following{/other_user}", "gists_url": "https://api.github.com/users/ibabushkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibabushkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibabushkin/subscriptions", "organizations_url": "https://api.github.com/users/ibabushkin/orgs", "repos_url": "https://api.github.com/users/ibabushkin/repos", "events_url": "https://api.github.com/users/ibabushkin/events{/privacy}", "received_events_url": "https://api.github.com/users/ibabushkin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ibabushkin", "id": 10811417, "node_id": "MDQ6VXNlcjEwODExNDE3", "avatar_url": "https://avatars.githubusercontent.com/u/10811417?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibabushkin", "html_url": "https://github.com/ibabushkin", "followers_url": "https://api.github.com/users/ibabushkin/followers", "following_url": "https://api.github.com/users/ibabushkin/following{/other_user}", "gists_url": "https://api.github.com/users/ibabushkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibabushkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibabushkin/subscriptions", "organizations_url": "https://api.github.com/users/ibabushkin/orgs", "repos_url": "https://api.github.com/users/ibabushkin/repos", "events_url": "https://api.github.com/users/ibabushkin/events{/privacy}", "received_events_url": "https://api.github.com/users/ibabushkin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "136abb9fb5ec89f0958602ea8d1fb4058a2d3461", "url": "https://api.github.com/repos/rust-lang/rust/commits/136abb9fb5ec89f0958602ea8d1fb4058a2d3461", "html_url": "https://github.com/rust-lang/rust/commit/136abb9fb5ec89f0958602ea8d1fb4058a2d3461"}], "stats": {"total": 796, "additions": 62, "deletions": 734}, "files": [{"sha": "62148a8e2bfa896594b3ffb1d72ea3077ec0007b", "filename": "src/librustc/traits/auto_trait.rs", "status": "modified", "additions": 27, "deletions": 193, "changes": 220, "blob_url": "https://github.com/rust-lang/rust/blob/5e1f92cd841b8c925f5149cb362f550c354d36bf/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e1f92cd841b8c925f5149cb362f550c354d36bf/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fauto_trait.rs?ref=5e1f92cd841b8c925f5149cb362f550c354d36bf", "patch": "@@ -15,8 +15,6 @@ use std::collections::hash_map::Entry;\n \n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n \n-use hir::WherePredicate;\n-\n use infer::{InferCtxt, RegionObligation};\n use infer::region_constraints::{Constraint, RegionConstraintData};\n \n@@ -36,32 +34,42 @@ pub struct RegionDeps<'tcx> {\n     smaller: FxHashSet<RegionTarget<'tcx>>\n }\n \n-pub enum AutoTraitResult {\n+pub enum AutoTraitResult<A> {\n     ExplicitImpl,\n-    PositiveImpl, /*(ty::Generics), TODO(twk)*/\n+    PositiveImpl(A),\n     NegativeImpl,\n }\n \n-impl AutoTraitResult {\n+impl<A> AutoTraitResult<A> {\n     fn is_auto(&self) -> bool {\n         match *self {\n-            AutoTraitResult::PositiveImpl | AutoTraitResult::NegativeImpl => true,\n+            AutoTraitResult::PositiveImpl(_) | AutoTraitResult::NegativeImpl => true,\n             _ => false,\n         }\n     }\n }\n \n+pub struct AutoTraitInfo<'cx> {\n+    pub full_user_env: ty::ParamEnv<'cx>,\n+    pub region_data: RegionConstraintData<'cx>,\n+    pub names_map: FxHashMap<String, String>,\n+    pub vid_to_region: FxHashMap<ty::RegionVid, ty::Region<'cx>>,\n+}\n+\n pub struct AutoTraitFinder<'a, 'tcx: 'a> {\n     pub tcx: &'a TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n-    pub fn find_auto_trait_generics(\n+    pub fn find_auto_trait_generics<A, F>(\n         &self,\n         did: DefId,\n         trait_did: DefId,\n         generics: &ty::Generics,\n-    ) -> AutoTraitResult {\n+        auto_trait_callback: F)\n+        -> AutoTraitResult<A>\n+        where F: for<'b, 'cx, 'cx2> Fn(&InferCtxt<'b, 'cx, 'cx2>, AutoTraitInfo<'cx2>) -> A\n+    {\n         let tcx = self.tcx;\n         let ty = self.tcx.type_of(did);\n \n@@ -72,7 +80,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n             substs: tcx.mk_substs_trait(ty, &[]),\n         };\n \n-        let trait_pred = ty::Binder(trait_ref);\n+        let trait_pred = ty::Binder::bind(trait_ref);\n \n         let bail_out = tcx.infer_ctxt().enter(|infcx| {\n             let mut selcx = SelectionContext::with_negative(&infcx, true);\n@@ -149,7 +157,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                 None => return AutoTraitResult::NegativeImpl,\n             };\n \n-            let (full_env, _full_user_env) = self.evaluate_predicates(\n+            let (full_env, full_user_env) = self.evaluate_predicates(\n                 &mut infcx,\n                 did,\n                 trait_did,\n@@ -193,8 +201,9 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n             let names_map: FxHashMap<String, String> = generics\n                 .regions\n                 .iter()\n-                .map(|l| (l.name.as_str().to_string(), l.name.to_string()))\n-                // TODO(twk): Lifetime branding\n+                .map(|l| (l.name.to_string(), l.name.to_string()))\n+                // TODO(twk): Lifetime branding and why is this map a set?!\n+                //     l.clean(self.cx) was present in the original code\n                 .collect();\n \n             let body_ids: FxHashSet<_> = infcx\n@@ -213,33 +222,16 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                 .region_constraint_data()\n                 .clone();\n \n-            let lifetime_predicates = self.handle_lifetimes(&region_data, &names_map);\n             let vid_to_region = self.map_vid_to_region(&region_data);\n \n-            debug!(\n-                \"find_auto_trait_generics(did={:?}, trait_did={:?}, generics={:?}): computed \\\n-                 lifetime information '{:?}' '{:?}'\",\n-                did, trait_did, generics, lifetime_predicates, vid_to_region\n-            );\n+            let info = AutoTraitInfo { full_user_env, region_data, names_map, vid_to_region };\n \n-            /* let new_generics = self.param_env_to_generics(\n-                infcx.tcx,\n-                did,\n-                full_user_env,\n-                generics.clone(),\n-                lifetime_predicates,\n-                vid_to_region,\n-            ); */\n-\n-            debug!(\n-                \"find_auto_trait_generics(did={:?}, trait_did={:?}, generics={:?}): finished with \\\n-                 <generics placeholder here>\",\n-                did, trait_did, generics /* , new_generics */\n-            );\n-            return AutoTraitResult::PositiveImpl;\n+            return AutoTraitResult::PositiveImpl(auto_trait_callback(&infcx, info));\n         });\n     }\n+}\n \n+impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n     // The core logic responsible for computing the bounds for our synthesized impl.\n     //\n     // To calculate the bounds, we call SelectionContext.select in a loop. Like FulfillmentContext,\n@@ -294,7 +286,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n \n         let mut already_visited = FxHashSet();\n         let mut predicates = VecDeque::new();\n-        predicates.push_back(ty::Binder(ty::TraitPredicate {\n+        predicates.push_back(ty::Binder::bind(ty::TraitPredicate {\n             trait_ref: ty::TraitRef {\n                 def_id: trait_did,\n                 substs: infcx.tcx.mk_substs_trait(ty, &[]),\n@@ -359,14 +351,12 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n             new_env = ty::ParamEnv::new(\n                 tcx.mk_predicates(normalized_preds),\n                 param_env.reveal,\n-                ty::UniverseIndex::ROOT,\n             );\n         }\n \n         let final_user_env = ty::ParamEnv::new(\n             tcx.mk_predicates(user_computed_preds.into_iter()),\n             user_env.reveal,\n-            ty::UniverseIndex::ROOT,\n         );\n         debug!(\n             \"evaluate_nested_obligations(ty_did={:?}, trait_did={:?}): succeeded with '{:?}' \\\n@@ -377,165 +367,9 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n         return Some((new_env, final_user_env));\n     }\n \n-    // This method calculates two things: Lifetime constraints of the form 'a: 'b,\n-    // and region constraints of the form ReVar: 'a\n-    //\n-    // This is essentially a simplified version of lexical_region_resolve. However,\n-    // handle_lifetimes determines what *needs be* true in order for an impl to hold.\n-    // lexical_region_resolve, along with much of the rest of the compiler, is concerned\n-    // with determining if a given set up constraints/predicates *are* met, given some\n-    // starting conditions (e.g. user-provided code). For this reason, it's easier\n-    // to perform the calculations we need on our own, rather than trying to make\n-    // existing inference/solver code do what we want.\n-    pub fn handle_lifetimes<'cx>(\n-        &self,\n-        regions: &RegionConstraintData<'cx>,\n-        names_map: &FxHashMap<String, String>, // TODO(twk): lifetime branding\n-    ) -> Vec<WherePredicate> {\n-        // Our goal is to 'flatten' the list of constraints by eliminating\n-        // all intermediate RegionVids. At the end, all constraints should\n-        // be between Regions (aka region variables). This gives us the information\n-        // we need to create the Generics.\n-        let mut finished = FxHashMap();\n-\n-        let mut vid_map: FxHashMap<RegionTarget, RegionDeps> = FxHashMap();\n-\n-        // Flattening is done in two parts. First, we insert all of the constraints\n-        // into a map. Each RegionTarget (either a RegionVid or a Region) maps\n-        // to its smaller and larger regions. Note that 'larger' regions correspond\n-        // to sub-regions in Rust code (e.g. in 'a: 'b, 'a is the larger region).\n-        for constraint in regions.constraints.keys() {\n-            match constraint {\n-                &Constraint::VarSubVar(r1, r2) => {\n-                    {\n-                        let deps1 = vid_map\n-                            .entry(RegionTarget::RegionVid(r1))\n-                            .or_insert_with(|| Default::default());\n-                        deps1.larger.insert(RegionTarget::RegionVid(r2));\n-                    }\n-\n-                    let deps2 = vid_map\n-                        .entry(RegionTarget::RegionVid(r2))\n-                        .or_insert_with(|| Default::default());\n-                    deps2.smaller.insert(RegionTarget::RegionVid(r1));\n-                }\n-                &Constraint::RegSubVar(region, vid) => {\n-                    let deps = vid_map\n-                        .entry(RegionTarget::RegionVid(vid))\n-                        .or_insert_with(|| Default::default());\n-                    deps.smaller.insert(RegionTarget::Region(region));\n-                }\n-                &Constraint::VarSubReg(vid, region) => {\n-                    let deps = vid_map\n-                        .entry(RegionTarget::RegionVid(vid))\n-                        .or_insert_with(|| Default::default());\n-                    deps.larger.insert(RegionTarget::Region(region));\n-                }\n-                &Constraint::RegSubReg(r1, r2) => {\n-                    // The constraint is already in the form that we want, so we're done with it\n-                    // Desired order is 'larger, smaller', so flip then\n-                    if self.region_name(r1) != self.region_name(r2) {\n-                        finished\n-                            .entry(self.region_name(r2).unwrap())\n-                            .or_insert_with(|| Vec::new())\n-                            .push(r1);\n-                    }\n-                }\n-            }\n-        }\n-\n-        // Here, we 'flatten' the map one element at a time.\n-        // All of the element's sub and super regions are connected\n-        // to each other. For example, if we have a graph that looks like this:\n-        //\n-        // (A, B) - C - (D, E)\n-        // Where (A, B) are subregions, and (D,E) are super-regions\n-        //\n-        // then after deleting 'C', the graph will look like this:\n-        //  ... - A - (D, E ...)\n-        //  ... - B - (D, E, ...)\n-        //  (A, B, ...) - D - ...\n-        //  (A, B, ...) - E - ...\n-        //\n-        //  where '...' signifies the existing sub and super regions of an entry\n-        //  When two adjacent ty::Regions are encountered, we've computed a final\n-        //  constraint, and add it to our list. Since we make sure to never re-add\n-        //  deleted items, this process will always finish.\n-        while !vid_map.is_empty() {\n-            let target = vid_map.keys().next().expect(\"Keys somehow empty\").clone();\n-            let deps = vid_map.remove(&target).expect(\"Entry somehow missing\");\n-\n-            for smaller in deps.smaller.iter() {\n-                for larger in deps.larger.iter() {\n-                    match (smaller, larger) {\n-                        (&RegionTarget::Region(r1), &RegionTarget::Region(r2)) => {\n-                            if self.region_name(r1) != self.region_name(r2) {\n-                                finished\n-                                    .entry(self.region_name(r2).unwrap())\n-                                    .or_insert_with(|| Vec::new())\n-                                    .push(r1) // Larger, smaller\n-                            }\n-                        }\n-                        (&RegionTarget::RegionVid(_), &RegionTarget::Region(_)) => {\n-                            if let Entry::Occupied(v) = vid_map.entry(*smaller) {\n-                                let smaller_deps = v.into_mut();\n-                                smaller_deps.larger.insert(*larger);\n-                                smaller_deps.larger.remove(&target);\n-                            }\n-                        }\n-                        (&RegionTarget::Region(_), &RegionTarget::RegionVid(_)) => {\n-                            if let Entry::Occupied(v) = vid_map.entry(*larger) {\n-                                let deps = v.into_mut();\n-                                deps.smaller.insert(*smaller);\n-                                deps.smaller.remove(&target);\n-                            }\n-                        }\n-                        (&RegionTarget::RegionVid(_), &RegionTarget::RegionVid(_)) => {\n-                            if let Entry::Occupied(v) = vid_map.entry(*smaller) {\n-                                let smaller_deps = v.into_mut();\n-                                smaller_deps.larger.insert(*larger);\n-                                smaller_deps.larger.remove(&target);\n-                            }\n-\n-                            if let Entry::Occupied(v) = vid_map.entry(*larger) {\n-                                let larger_deps = v.into_mut();\n-                                larger_deps.smaller.insert(*smaller);\n-                                larger_deps.smaller.remove(&target);\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-\n-        let lifetime_predicates = names_map\n-            .iter()\n-            .flat_map(|(name, _lifetime)| {\n-                let empty = Vec::new();\n-                let bounds: FxHashSet<String> = finished // TODO(twk): lifetime branding\n-                    .get(name)\n-                    .unwrap_or(&empty)\n-                    .iter()\n-                    .map(|region| self.get_lifetime(region, names_map))\n-                    .collect();\n-\n-                if bounds.is_empty() {\n-                    return None;\n-                }\n-                /* Some(WherePredicate::RegionPredicate {\n-                    lifetime: lifetime.clone(),\n-                    bounds: bounds.into_iter().collect(),\n-                }) */\n-                None // TODO(twk): use the correct WherePredicate and rebuild the code above\n-            })\n-            .collect();\n-\n-        lifetime_predicates\n-    }\n-\n     pub fn region_name(&self, region: Region) -> Option<String> {\n         match region {\n-            &ty::ReEarlyBound(r) => Some(r.name.as_str().to_string()),\n+            &ty::ReEarlyBound(r) => Some(r.name.to_string()),\n             _ => None,\n         }\n     }"}, {"sha": "d3e2dac72ee33750c8443aa63adda34b8096a98f", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 33, "deletions": 533, "changes": 566, "blob_url": "https://github.com/rust-lang/rust/blob/5e1f92cd841b8c925f5149cb362f550c354d36bf/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e1f92cd841b8c925f5149cb362f550c354d36bf/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=5e1f92cd841b8c925f5149cb362f550c354d36bf", "patch": "@@ -8,16 +8,24 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use rustc::traits::auto_trait as auto;\n use rustc::ty::TypeFoldable;\n use std::fmt::Debug;\n \n use super::*;\n \n pub struct AutoTraitFinder<'a, 'tcx: 'a, 'rcx: 'a> {\n     pub cx: &'a core::DocContext<'a, 'tcx, 'rcx>,\n+    pub f: auto::AutoTraitFinder<'a, 'tcx>,\n }\n \n impl<'a, 'tcx, 'rcx> AutoTraitFinder<'a, 'tcx, 'rcx> {\n+    pub fn new(cx: &'a core::DocContext<'a, 'tcx, 'rcx>) -> Self {\n+        let f = auto::AutoTraitFinder { tcx: &cx.tcx };\n+\n+        AutoTraitFinder { cx, f }\n+    }\n+\n     pub fn get_with_def_id(&self, def_id: DefId) -> Vec<Item> {\n         let ty = self.cx.tcx.type_of(def_id);\n \n@@ -276,443 +284,37 @@ impl<'a, 'tcx, 'rcx> AutoTraitFinder<'a, 'tcx, 'rcx> {\n         trait_did: DefId,\n         generics: &ty::Generics,\n     ) -> AutoTraitResult {\n-        let tcx = self.cx.tcx;\n-        let ty = self.cx.tcx.type_of(did);\n-\n-        let orig_params = tcx.param_env(did);\n-\n-        let trait_ref = ty::TraitRef {\n-            def_id: trait_did,\n-            substs: tcx.mk_substs_trait(ty, &[]),\n-        };\n-\n-        let trait_pred = ty::Binder::bind(trait_ref);\n+        match self.f.find_auto_trait_generics(did, trait_did, generics,\n+                |infcx, mut info| {\n+                    let region_data = info.region_data;\n+                    let names_map =\n+                        info.names_map\n+                            .drain()\n+                            .map(|(name, lifetime)| (name, Lifetime(lifetime)))\n+                            .collect();\n+                    let lifetime_predicates =\n+                        self.handle_lifetimes(&region_data, &names_map);\n+                    let new_generics = self.param_env_to_generics(\n+                        infcx.tcx,\n+                        did,\n+                        info.full_user_env,\n+                        generics.clone(),\n+                        lifetime_predicates,\n+                        info.vid_to_region,\n+                    );\n \n-        let bail_out = tcx.infer_ctxt().enter(|infcx| {\n-            let mut selcx = SelectionContext::with_negative(&infcx, true);\n-            let result = selcx.select(&Obligation::new(\n-                ObligationCause::dummy(),\n-                orig_params,\n-                trait_pred.to_poly_trait_predicate(),\n-            ));\n-            match result {\n-                Ok(Some(Vtable::VtableImpl(_))) => {\n                     debug!(\n                         \"find_auto_trait_generics(did={:?}, trait_did={:?}, generics={:?}): \\\n-                         manual impl found, bailing out\",\n-                        did, trait_did, generics\n+                         finished with {:?}\",\n+                        did, trait_did, generics, new_generics\n                     );\n-                    return true;\n-                }\n-                _ => return false,\n-            };\n-        });\n-\n-        // If an explicit impl exists, it always takes priority over an auto impl\n-        if bail_out {\n-            return AutoTraitResult::ExplicitImpl;\n-        }\n-\n-        return tcx.infer_ctxt().enter(|mut infcx| {\n-            let mut fresh_preds = FxHashSet();\n-\n-            // Due to the way projections are handled by SelectionContext, we need to run\n-            // evaluate_predicates twice: once on the original param env, and once on the result of\n-            // the first evaluate_predicates call.\n-            //\n-            // The problem is this: most of rustc, including SelectionContext and traits::project,\n-            // are designed to work with a concrete usage of a type (e.g. Vec<u8>\n-            // fn<T>() { Vec<T> }. This information will generally never change - given\n-            // the 'T' in fn<T>() { ... }, we'll never know anything else about 'T'.\n-            // If we're unable to prove that 'T' implements a particular trait, we're done -\n-            // there's nothing left to do but error out.\n-            //\n-            // However, synthesizing an auto trait impl works differently. Here, we start out with\n-            // a set of initial conditions - the ParamEnv of the struct/enum/union we're dealing\n-            // with - and progressively discover the conditions we need to fulfill for it to\n-            // implement a certain auto trait. This ends up breaking two assumptions made by trait\n-            // selection and projection:\n-            //\n-            // * We can always cache the result of a particular trait selection for the lifetime of\n-            // an InfCtxt\n-            // * Given a projection bound such as '<T as SomeTrait>::SomeItem = K', if 'T:\n-            // SomeTrait' doesn't hold, then we don't need to care about the 'SomeItem = K'\n-            //\n-            // We fix the first assumption by manually clearing out all of the InferCtxt's caches\n-            // in between calls to SelectionContext.select. This allows us to keep all of the\n-            // intermediate types we create bound to the 'tcx lifetime, rather than needing to lift\n-            // them between calls.\n-            //\n-            // We fix the second assumption by reprocessing the result of our first call to\n-            // evaluate_predicates. Using the example of '<T as SomeTrait>::SomeItem = K', our first\n-            // pass will pick up 'T: SomeTrait', but not 'SomeItem = K'. On our second pass,\n-            // traits::project will see that 'T: SomeTrait' is in our ParamEnv, allowing\n-            // SelectionContext to return it back to us.\n-\n-            let (new_env, user_env) = match self.evaluate_predicates(\n-                &mut infcx,\n-                did,\n-                trait_did,\n-                ty,\n-                orig_params.clone(),\n-                orig_params,\n-                &mut fresh_preds,\n-                false,\n-            ) {\n-                Some(e) => e,\n-                None => return AutoTraitResult::NegativeImpl,\n-            };\n-\n-            let (full_env, full_user_env) = self.evaluate_predicates(\n-                &mut infcx,\n-                did,\n-                trait_did,\n-                ty,\n-                new_env.clone(),\n-                user_env,\n-                &mut fresh_preds,\n-                true,\n-            ).unwrap_or_else(|| {\n-                panic!(\n-                    \"Failed to fully process: {:?} {:?} {:?}\",\n-                    ty, trait_did, orig_params\n-                )\n-            });\n-\n-            debug!(\n-                \"find_auto_trait_generics(did={:?}, trait_did={:?}, generics={:?}): fulfilling \\\n-                 with {:?}\",\n-                did, trait_did, generics, full_env\n-            );\n-            infcx.clear_caches();\n-\n-            // At this point, we already have all of the bounds we need. FulfillmentContext is used\n-            // to store all of the necessary region/lifetime bounds in the InferContext, as well as\n-            // an additional sanity check.\n-            let mut fulfill = FulfillmentContext::new();\n-            fulfill.register_bound(\n-                &infcx,\n-                full_env,\n-                ty,\n-                trait_did,\n-                ObligationCause::misc(DUMMY_SP, ast::DUMMY_NODE_ID),\n-            );\n-            fulfill.select_all_or_error(&infcx).unwrap_or_else(|e| {\n-                panic!(\n-                    \"Unable to fulfill trait {:?} for '{:?}': {:?}\",\n-                    trait_did, ty, e\n-                )\n-            });\n-\n-            let names_map: FxHashMap<String, Lifetime> = generics\n-                .regions\n-                .iter()\n-                .map(|l| (l.name.to_string(), l.clean(self.cx)))\n-                .collect();\n-\n-            let body_ids: FxHashSet<_> = infcx\n-                .region_obligations\n-                .borrow()\n-                .iter()\n-                .map(|&(id, _)| id)\n-                .collect();\n-\n-            for id in body_ids {\n-                infcx.process_registered_region_obligations(&[], None, full_env.clone(), id);\n-            }\n-\n-            let region_data = infcx\n-                .borrow_region_constraints()\n-                .region_constraint_data()\n-                .clone();\n-\n-            let lifetime_predicates = self.handle_lifetimes(&region_data, &names_map);\n-            let vid_to_region = self.map_vid_to_region(&region_data);\n-\n-            debug!(\n-                \"find_auto_trait_generics(did={:?}, trait_did={:?}, generics={:?}): computed \\\n-                 lifetime information '{:?}' '{:?}'\",\n-                did, trait_did, generics, lifetime_predicates, vid_to_region\n-            );\n-\n-            let new_generics = self.param_env_to_generics(\n-                infcx.tcx,\n-                did,\n-                full_user_env,\n-                generics.clone(),\n-                lifetime_predicates,\n-                vid_to_region,\n-            );\n-            debug!(\n-                \"find_auto_trait_generics(did={:?}, trait_did={:?}, generics={:?}): finished with \\\n-                 {:?}\",\n-                did, trait_did, generics, new_generics\n-            );\n-            return AutoTraitResult::PositiveImpl(new_generics);\n-        });\n-    }\n-\n-    fn clean_pred<'c, 'd, 'cx>(\n-        &self,\n-        infcx: &InferCtxt<'c, 'd, 'cx>,\n-        p: ty::Predicate<'cx>,\n-    ) -> ty::Predicate<'cx> {\n-        infcx.freshen(p)\n-    }\n-\n-    fn evaluate_nested_obligations<'b, 'c, 'd, 'cx,\n-                                    T: Iterator<Item = Obligation<'cx, ty::Predicate<'cx>>>>(\n-        &self,\n-        ty: ty::Ty,\n-        nested: T,\n-        computed_preds: &'b mut FxHashSet<ty::Predicate<'cx>>,\n-        fresh_preds: &'b mut FxHashSet<ty::Predicate<'cx>>,\n-        predicates: &'b mut VecDeque<ty::PolyTraitPredicate<'cx>>,\n-        select: &mut traits::SelectionContext<'c, 'd, 'cx>,\n-        only_projections: bool,\n-    ) -> bool {\n-        let dummy_cause = ObligationCause::misc(DUMMY_SP, ast::DUMMY_NODE_ID);\n-\n-        for (obligation, predicate) in nested\n-            .filter(|o| o.recursion_depth == 1)\n-            .map(|o| (o.clone(), o.predicate.clone()))\n-        {\n-            let is_new_pred =\n-                fresh_preds.insert(self.clean_pred(select.infcx(), predicate.clone()));\n-\n-            match &predicate {\n-                &ty::Predicate::Trait(ref p) => {\n-                    let substs = &p.skip_binder().trait_ref.substs;\n-\n-                    if self.is_of_param(substs) && !only_projections && is_new_pred {\n-                        computed_preds.insert(predicate);\n-                    }\n-                    predicates.push_back(p.clone());\n-                }\n-                &ty::Predicate::Projection(p) => {\n-                    // If the projection isn't all type vars, then\n-                    // we don't want to add it as a bound\n-                    if self.is_of_param(p.skip_binder().projection_ty.substs) && is_new_pred {\n-                        computed_preds.insert(predicate);\n-                    } else {\n-                        match traits::poly_project_and_unify_type(\n-                            select,\n-                            &obligation.with(p.clone()),\n-                        ) {\n-                            Err(e) => {\n-                                debug!(\n-                                    \"evaluate_nested_obligations: Unable to unify predicate \\\n-                                     '{:?}' '{:?}', bailing out\",\n-                                    ty, e\n-                                );\n-                                return false;\n-                            }\n-                            Ok(Some(v)) => {\n-                                if !self.evaluate_nested_obligations(\n-                                    ty,\n-                                    v.clone().iter().cloned(),\n-                                    computed_preds,\n-                                    fresh_preds,\n-                                    predicates,\n-                                    select,\n-                                    only_projections,\n-                                ) {\n-                                    return false;\n-                                }\n-                            }\n-                            Ok(None) => {\n-                                panic!(\"Unexpected result when selecting {:?} {:?}\", ty, obligation)\n-                            }\n-                        }\n-                    }\n-                }\n-                &ty::Predicate::RegionOutlives(ref binder) => {\n-                    if let Err(_) = select\n-                        .infcx()\n-                        .region_outlives_predicate(&dummy_cause, binder)\n-                    {\n-                        return false;\n-                    }\n-                }\n-                &ty::Predicate::TypeOutlives(ref binder) => {\n-                    match (\n-                        binder.no_late_bound_regions(),\n-                        binder.map_bound_ref(|pred| pred.0).no_late_bound_regions(),\n-                    ) {\n-                        (None, Some(t_a)) => {\n-                            select.infcx().register_region_obligation(\n-                                ast::DUMMY_NODE_ID,\n-                                RegionObligation {\n-                                    sup_type: t_a,\n-                                    sub_region: select.infcx().tcx.types.re_static,\n-                                    cause: dummy_cause.clone(),\n-                                },\n-                            );\n-                        }\n-                        (Some(ty::OutlivesPredicate(t_a, r_b)), _) => {\n-                            select.infcx().register_region_obligation(\n-                                ast::DUMMY_NODE_ID,\n-                                RegionObligation {\n-                                    sup_type: t_a,\n-                                    sub_region: r_b,\n-                                    cause: dummy_cause.clone(),\n-                                },\n-                            );\n-                        }\n-                        _ => {}\n-                    };\n-                }\n-                _ => panic!(\"Unexpected predicate {:?} {:?}\", ty, predicate),\n-            };\n-        }\n-        return true;\n-    }\n-\n-    // The core logic responsible for computing the bounds for our synthesized impl.\n-    //\n-    // To calculate the bounds, we call SelectionContext.select in a loop. Like FulfillmentContext,\n-    // we recursively select the nested obligations of predicates we encounter. However, whenver we\n-    // encounter an UnimplementedError involving a type parameter, we add it to our ParamEnv. Since\n-    // our goal is to determine when a particular type implements an auto trait, Unimplemented\n-    // errors tell us what conditions need to be met.\n-    //\n-    // This method ends up working somewhat similary to FulfillmentContext, but with a few key\n-    // differences. FulfillmentContext works under the assumption that it's dealing with concrete\n-    // user code. According, it considers all possible ways that a Predicate could be met - which\n-    // isn't always what we want for a synthesized impl. For example, given the predicate 'T:\n-    // Iterator', FulfillmentContext can end up reporting an Unimplemented error for T:\n-    // IntoIterator - since there's an implementation of Iteratpr where T: IntoIterator,\n-    // FulfillmentContext will drive SelectionContext to consider that impl before giving up. If we\n-    // were to rely on FulfillmentContext's decision, we might end up synthesizing an impl like\n-    // this:\n-    // 'impl<T> Send for Foo<T> where T: IntoIterator'\n-    //\n-    // While it might be technically true that Foo implements Send where T: IntoIterator,\n-    // the bound is overly restrictive - it's really only necessary that T: Iterator.\n-    //\n-    // For this reason, evaluate_predicates handles predicates with type variables specially. When\n-    // we encounter an Unimplemented error for a bound such as 'T: Iterator', we immediately add it\n-    // to our ParamEnv, and add it to our stack for recursive evaluation. When we later select it,\n-    // we'll pick up any nested bounds, without ever inferring that 'T: IntoIterator' needs to\n-    // hold.\n-    //\n-    // One additonal consideration is supertrait bounds. Normally, a ParamEnv is only ever\n-    // consutrcted once for a given type. As part of the construction process, the ParamEnv will\n-    // have any supertrait bounds normalized - e.g. if we have a type 'struct Foo<T: Copy>', the\n-    // ParamEnv will contain 'T: Copy' and 'T: Clone', since 'Copy: Clone'. When we construct our\n-    // own ParamEnv, we need to do this outselves, through traits::elaborate_predicates, or else\n-    // SelectionContext will choke on the missing predicates. However, this should never show up in\n-    // the final synthesized generics: we don't want our generated docs page to contain something\n-    // like 'T: Copy + Clone', as that's redundant. Therefore, we keep track of a separate\n-    // 'user_env', which only holds the predicates that will actually be displayed to the user.\n-    fn evaluate_predicates<'b, 'gcx, 'c>(\n-        &self,\n-        infcx: &mut InferCtxt<'b, 'tcx, 'c>,\n-        ty_did: DefId,\n-        trait_did: DefId,\n-        ty: ty::Ty<'c>,\n-        param_env: ty::ParamEnv<'c>,\n-        user_env: ty::ParamEnv<'c>,\n-        fresh_preds: &mut FxHashSet<ty::Predicate<'c>>,\n-        only_projections: bool,\n-    ) -> Option<(ty::ParamEnv<'c>, ty::ParamEnv<'c>)> {\n-        let tcx = infcx.tcx;\n-\n-        let mut select = traits::SelectionContext::new(&infcx);\n-\n-        let mut already_visited = FxHashSet();\n-        let mut predicates = VecDeque::new();\n-        predicates.push_back(ty::Binder::bind(ty::TraitPredicate {\n-            trait_ref: ty::TraitRef {\n-                def_id: trait_did,\n-                substs: infcx.tcx.mk_substs_trait(ty, &[]),\n-            },\n-        }));\n-\n-        let mut computed_preds: FxHashSet<_> = param_env.caller_bounds.iter().cloned().collect();\n-        let mut user_computed_preds: FxHashSet<_> =\n-            user_env.caller_bounds.iter().cloned().collect();\n-\n-        let mut new_env = param_env.clone();\n-        let dummy_cause = ObligationCause::misc(DUMMY_SP, ast::DUMMY_NODE_ID);\n-\n-        while let Some(pred) = predicates.pop_front() {\n-            infcx.clear_caches();\n-\n-            if !already_visited.insert(pred.clone()) {\n-                continue;\n-            }\n-\n-            let result = select.select(&Obligation::new(dummy_cause.clone(), new_env, pred));\n-\n-            match &result {\n-                &Ok(Some(ref vtable)) => {\n-                    let obligations = vtable.clone().nested_obligations().into_iter();\n-\n-                    if !self.evaluate_nested_obligations(\n-                        ty,\n-                        obligations,\n-                        &mut user_computed_preds,\n-                        fresh_preds,\n-                        &mut predicates,\n-                        &mut select,\n-                        only_projections,\n-                    ) {\n-                        return None;\n-                    }\n-                }\n-                &Ok(None) => {}\n-                &Err(SelectionError::Unimplemented) => {\n-                    if self.is_of_param(pred.skip_binder().trait_ref.substs) {\n-                        already_visited.remove(&pred);\n-                        user_computed_preds.insert(ty::Predicate::Trait(pred.clone()));\n-                        predicates.push_back(pred);\n-                    } else {\n-                        debug!(\n-                            \"evaluate_nested_obligations: Unimplemented found, bailing: {:?} {:?} \\\n-                             {:?}\",\n-                            ty,\n-                            pred,\n-                            pred.skip_binder().trait_ref.substs\n-                        );\n-                        return None;\n-                    }\n-                }\n-                _ => panic!(\"Unexpected error for '{:?}': {:?}\", ty, result),\n-            };\n \n-            computed_preds.extend(user_computed_preds.iter().cloned());\n-            let normalized_preds =\n-                traits::elaborate_predicates(tcx, computed_preds.clone().into_iter().collect());\n-            new_env = ty::ParamEnv::new(\n-                tcx.mk_predicates(normalized_preds),\n-                param_env.reveal,\n-            );\n-        }\n-\n-        let final_user_env = ty::ParamEnv::new(\n-            tcx.mk_predicates(user_computed_preds.into_iter()),\n-            user_env.reveal,\n-        );\n-        debug!(\n-            \"evaluate_nested_obligations(ty_did={:?}, trait_did={:?}): succeeded with '{:?}' \\\n-             '{:?}'\",\n-            ty_did, trait_did, new_env, final_user_env\n-        );\n-\n-        return Some((new_env, final_user_env));\n-    }\n-\n-    fn is_of_param(&self, substs: &Substs) -> bool {\n-        if substs.is_noop() {\n-            return false;\n+                    new_generics\n+                }) {\n+            auto::AutoTraitResult::ExplicitImpl => AutoTraitResult::ExplicitImpl,\n+            auto::AutoTraitResult::NegativeImpl => AutoTraitResult::NegativeImpl,\n+            auto::AutoTraitResult::PositiveImpl(res) => AutoTraitResult::PositiveImpl(res),\n         }\n-\n-        return match substs.type_at(0).sty {\n-            ty::TyParam(_) => true,\n-            ty::TyProjection(p) => self.is_of_param(p.substs),\n-            _ => false,\n-        };\n     }\n \n     fn get_lifetime(&self, region: Region, names_map: &FxHashMap<String, Lifetime>) -> Lifetime {\n@@ -733,108 +335,6 @@ impl<'a, 'tcx, 'rcx> AutoTraitFinder<'a, 'tcx, 'rcx> {\n         }\n     }\n \n-    // This is very similar to handle_lifetimes. However, instead of matching ty::Region's\n-    // to each other, we match ty::RegionVid's to ty::Region's\n-    fn map_vid_to_region<'cx>(\n-        &self,\n-        regions: &RegionConstraintData<'cx>,\n-    ) -> FxHashMap<ty::RegionVid, ty::Region<'cx>> {\n-        let mut vid_map: FxHashMap<RegionTarget<'cx>, RegionDeps<'cx>> = FxHashMap();\n-        let mut finished_map = FxHashMap();\n-\n-        for constraint in regions.constraints.keys() {\n-            match constraint {\n-                &Constraint::VarSubVar(r1, r2) => {\n-                    {\n-                        let deps1 = vid_map\n-                            .entry(RegionTarget::RegionVid(r1))\n-                            .or_insert_with(|| Default::default());\n-                        deps1.larger.insert(RegionTarget::RegionVid(r2));\n-                    }\n-\n-                    let deps2 = vid_map\n-                        .entry(RegionTarget::RegionVid(r2))\n-                        .or_insert_with(|| Default::default());\n-                    deps2.smaller.insert(RegionTarget::RegionVid(r1));\n-                }\n-                &Constraint::RegSubVar(region, vid) => {\n-                    {\n-                        let deps1 = vid_map\n-                            .entry(RegionTarget::Region(region))\n-                            .or_insert_with(|| Default::default());\n-                        deps1.larger.insert(RegionTarget::RegionVid(vid));\n-                    }\n-\n-                    let deps2 = vid_map\n-                        .entry(RegionTarget::RegionVid(vid))\n-                        .or_insert_with(|| Default::default());\n-                    deps2.smaller.insert(RegionTarget::Region(region));\n-                }\n-                &Constraint::VarSubReg(vid, region) => {\n-                    finished_map.insert(vid, region);\n-                }\n-                &Constraint::RegSubReg(r1, r2) => {\n-                    {\n-                        let deps1 = vid_map\n-                            .entry(RegionTarget::Region(r1))\n-                            .or_insert_with(|| Default::default());\n-                        deps1.larger.insert(RegionTarget::Region(r2));\n-                    }\n-\n-                    let deps2 = vid_map\n-                        .entry(RegionTarget::Region(r2))\n-                        .or_insert_with(|| Default::default());\n-                    deps2.smaller.insert(RegionTarget::Region(r1));\n-                }\n-            }\n-        }\n-\n-        while !vid_map.is_empty() {\n-            let target = vid_map.keys().next().expect(\"Keys somehow empty\").clone();\n-            let deps = vid_map.remove(&target).expect(\"Entry somehow missing\");\n-\n-            for smaller in deps.smaller.iter() {\n-                for larger in deps.larger.iter() {\n-                    match (smaller, larger) {\n-                        (&RegionTarget::Region(_), &RegionTarget::Region(_)) => {\n-                            if let Entry::Occupied(v) = vid_map.entry(*smaller) {\n-                                let smaller_deps = v.into_mut();\n-                                smaller_deps.larger.insert(*larger);\n-                                smaller_deps.larger.remove(&target);\n-                            }\n-\n-                            if let Entry::Occupied(v) = vid_map.entry(*larger) {\n-                                let larger_deps = v.into_mut();\n-                                larger_deps.smaller.insert(*smaller);\n-                                larger_deps.smaller.remove(&target);\n-                            }\n-                        }\n-                        (&RegionTarget::RegionVid(v1), &RegionTarget::Region(r1)) => {\n-                            finished_map.insert(v1, r1);\n-                        }\n-                        (&RegionTarget::Region(_), &RegionTarget::RegionVid(_)) => {\n-                            // Do nothing - we don't care about regions that are smaller than vids\n-                        }\n-                        (&RegionTarget::RegionVid(_), &RegionTarget::RegionVid(_)) => {\n-                            if let Entry::Occupied(v) = vid_map.entry(*smaller) {\n-                                let smaller_deps = v.into_mut();\n-                                smaller_deps.larger.insert(*larger);\n-                                smaller_deps.larger.remove(&target);\n-                            }\n-\n-                            if let Entry::Occupied(v) = vid_map.entry(*larger) {\n-                                let larger_deps = v.into_mut();\n-                                larger_deps.smaller.insert(*smaller);\n-                                larger_deps.smaller.remove(&target);\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-        finished_map\n-    }\n-\n     // This method calculates two things: Lifetime constraints of the form 'a: 'b,\n     // and region constraints of the form ReVar: 'a\n     //"}, {"sha": "9b067abd1af6ba7a688d9bf75e1cd480ad336cce", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5e1f92cd841b8c925f5149cb362f550c354d36bf/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e1f92cd841b8c925f5149cb362f550c354d36bf/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=5e1f92cd841b8c925f5149cb362f550c354d36bf", "patch": "@@ -40,17 +40,13 @@ use rustc::hir::{self, HirVec};\n use rustc::hir::def::{self, Def, CtorKind};\n use rustc::hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc::hir::def_id::DefIndexAddressSpace;\n-use rustc::traits;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, TyCtxt, Region, RegionVid, Ty, AdtKind};\n use rustc::middle::stability;\n use rustc::util::nodemap::{FxHashMap, FxHashSet};\n use rustc_typeck::hir_ty_to_ty;\n-use rustc::infer::{InferCtxt, RegionObligation};\n use rustc::infer::region_constraints::{RegionConstraintData, Constraint};\n-use rustc::traits::*;\n use std::collections::hash_map::Entry;\n-use std::collections::VecDeque;\n use std::fmt;\n \n use std::default::Default;\n@@ -3524,14 +3520,12 @@ pub struct Impl {\n }\n \n pub fn get_auto_traits_with_node_id(cx: &DocContext, id: ast::NodeId, name: String) -> Vec<Item> {\n-    let finder = AutoTraitFinder { cx };\n+    let finder = AutoTraitFinder::new(cx);\n     finder.get_with_node_id(id, name)\n }\n \n pub fn get_auto_traits_with_def_id(cx: &DocContext, id: DefId) -> Vec<Item> {\n-    let finder = AutoTraitFinder {\n-        cx,\n-    };\n+    let finder = AutoTraitFinder::new(cx);\n \n     finder.get_with_def_id(id)\n }"}]}