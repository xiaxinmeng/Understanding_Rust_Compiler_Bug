{"sha": "bb58dc84c11c7699b1289f802c548d6a156a6eb7", "node_id": "C_kwDOAAsO6NoAKGJiNThkYzg0YzExYzc2OTliMTI4OWY4MDJjNTQ4ZDZhMTU2YTZlYjc", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-11-17T16:20:04Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-11-17T16:20:04Z"}, "message": "Auto merge of #7968 - Jarcho:manual_map_unsafe, r=xFrednet\n\nFix `manual_map` with unsafe functions\n\nfixes: #7820\nchangelog: Fix `manual_map` suggestion when used with unsafe functions and unsafe blocks", "tree": {"sha": "95958b5d4b8d04608a70f76815520c6031a5b55d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/95958b5d4b8d04608a70f76815520c6031a5b55d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bb58dc84c11c7699b1289f802c548d6a156a6eb7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bb58dc84c11c7699b1289f802c548d6a156a6eb7", "html_url": "https://github.com/rust-lang/rust/commit/bb58dc84c11c7699b1289f802c548d6a156a6eb7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bb58dc84c11c7699b1289f802c548d6a156a6eb7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6ac42fe6fa049fd41a3e2cb9435c6e086262de0c", "url": "https://api.github.com/repos/rust-lang/rust/commits/6ac42fe6fa049fd41a3e2cb9435c6e086262de0c", "html_url": "https://github.com/rust-lang/rust/commit/6ac42fe6fa049fd41a3e2cb9435c6e086262de0c"}, {"sha": "5f861ee1ae9dffe29cdd177e0bf2a067ea9b8ca9", "url": "https://api.github.com/repos/rust-lang/rust/commits/5f861ee1ae9dffe29cdd177e0bf2a067ea9b8ca9", "html_url": "https://github.com/rust-lang/rust/commit/5f861ee1ae9dffe29cdd177e0bf2a067ea9b8ca9"}], "stats": {"total": 141, "additions": 113, "deletions": 28}, "files": [{"sha": "4d8ad566e6b1d84f6131560c29ead691ec55b99b", "filename": "clippy_lints/src/manual_map.rs", "status": "modified", "additions": 53, "deletions": 27, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/bb58dc84c11c7699b1289f802c548d6a156a6eb7/clippy_lints%2Fsrc%2Fmanual_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb58dc84c11c7699b1289f802c548d6a156a6eb7/clippy_lints%2Fsrc%2Fmanual_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_map.rs?ref=bb58dc84c11c7699b1289f802c548d6a156a6eb7", "patch": "@@ -2,7 +2,7 @@ use crate::{map_unit_fn::OPTION_MAP_UNIT_FN, matches::MATCH_AS_REF};\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::higher::IfLetOrMatch;\n use clippy_utils::source::{snippet_with_applicability, snippet_with_context};\n-use clippy_utils::ty::{is_type_diagnostic_item, peel_mid_ty_refs_is_mutable};\n+use clippy_utils::ty::{is_type_diagnostic_item, peel_mid_ty_refs_is_mutable, type_is_unsafe_function};\n use clippy_utils::{\n     can_move_expr_to_closure, in_constant, is_else_clause, is_lang_ctor, is_lint_allowed, path_to_local_id,\n     peel_hir_expr_refs, peel_hir_expr_while, CaptureKind,\n@@ -11,7 +11,8 @@ use rustc_ast::util::parser::PREC_POSTFIX;\n use rustc_errors::Applicability;\n use rustc_hir::LangItem::{OptionNone, OptionSome};\n use rustc_hir::{\n-    def::Res, Arm, BindingAnnotation, Block, Expr, ExprKind, HirId, Mutability, Pat, PatKind, Path, QPath,\n+    def::Res, Arm, BindingAnnotation, Block, BlockCheckMode, Expr, ExprKind, HirId, Mutability, Pat, PatKind, Path,\n+    QPath, UnsafeSource,\n };\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n@@ -93,20 +94,20 @@ impl LateLintPass<'_> for ManualMap {\n             return;\n         }\n \n-        let some_expr = match get_some_expr(cx, some_expr, expr_ctxt) {\n+        let some_expr = match get_some_expr(cx, some_expr, false, expr_ctxt) {\n             Some(expr) => expr,\n             None => return,\n         };\n \n         // These two lints will go back and forth with each other.\n-        if cx.typeck_results().expr_ty(some_expr) == cx.tcx.types.unit\n+        if cx.typeck_results().expr_ty(some_expr.expr) == cx.tcx.types.unit\n             && !is_lint_allowed(cx, OPTION_MAP_UNIT_FN, expr.hir_id)\n         {\n             return;\n         }\n \n         // `map` won't perform any adjustments.\n-        if !cx.typeck_results().expr_adjustments(some_expr).is_empty() {\n+        if !cx.typeck_results().expr_adjustments(some_expr.expr).is_empty() {\n             return;\n         }\n \n@@ -120,7 +121,7 @@ impl LateLintPass<'_> for ManualMap {\n             None => \"\",\n         };\n \n-        match can_move_expr_to_closure(cx, some_expr) {\n+        match can_move_expr_to_closure(cx, some_expr.expr) {\n             Some(captures) => {\n                 // Check if captures the closure will need conflict with borrows made in the scrutinee.\n                 // TODO: check all the references made in the scrutinee expression. This will require interacting\n@@ -158,12 +159,14 @@ impl LateLintPass<'_> for ManualMap {\n             };\n \n         let body_str = if let PatKind::Binding(annotation, id, some_binding, None) = some_pat.kind {\n-            match can_pass_as_func(cx, id, some_expr) {\n-                Some(func) if func.span.ctxt() == some_expr.span.ctxt() => {\n+            if_chain! {\n+                if !some_expr.needs_unsafe_block;\n+                if let Some(func) = can_pass_as_func(cx, id, some_expr.expr);\n+                if func.span.ctxt() == some_expr.expr.span.ctxt();\n+                then {\n                     snippet_with_applicability(cx, func.span, \"..\", &mut app).into_owned()\n-                },\n-                _ => {\n-                    if path_to_local_id(some_expr, id)\n+                } else {\n+                    if path_to_local_id(some_expr.expr, id)\n                         && !is_lint_allowed(cx, MATCH_AS_REF, expr.hir_id)\n                         && binding_ref.is_some()\n                     {\n@@ -176,21 +179,23 @@ impl LateLintPass<'_> for ManualMap {\n                     } else {\n                         \"\"\n                     };\n-                    format!(\n-                        \"|{}{}| {}\",\n-                        annotation,\n-                        some_binding,\n-                        snippet_with_context(cx, some_expr.span, expr_ctxt, \"..\", &mut app).0\n-                    )\n-                },\n+                    let expr_snip = snippet_with_context(cx, some_expr.expr.span, expr_ctxt, \"..\", &mut app).0;\n+                    if some_expr.needs_unsafe_block {\n+                        format!(\"|{}{}| unsafe {{ {} }}\", annotation, some_binding, expr_snip)\n+                    } else {\n+                        format!(\"|{}{}| {}\", annotation, some_binding, expr_snip)\n+                    }\n+                }\n             }\n         } else if !is_wild_none && explicit_ref.is_none() {\n             // TODO: handle explicit reference annotations.\n-            format!(\n-                \"|{}| {}\",\n-                snippet_with_context(cx, some_pat.span, expr_ctxt, \"..\", &mut app).0,\n-                snippet_with_context(cx, some_expr.span, expr_ctxt, \"..\", &mut app).0\n-            )\n+            let pat_snip = snippet_with_context(cx, some_pat.span, expr_ctxt, \"..\", &mut app).0;\n+            let expr_snip = snippet_with_context(cx, some_expr.expr.span, expr_ctxt, \"..\", &mut app).0;\n+            if some_expr.needs_unsafe_block {\n+                format!(\"|{}| unsafe {{ {} }}\", pat_snip, expr_snip)\n+            } else {\n+                format!(\"|{}| {}\", pat_snip, expr_snip)\n+            }\n         } else {\n             // Refutable bindings and mixed reference annotations can't be handled by `map`.\n             return;\n@@ -217,7 +222,9 @@ impl LateLintPass<'_> for ManualMap {\n fn can_pass_as_func(cx: &LateContext<'tcx>, binding: HirId, expr: &'tcx Expr<'_>) -> Option<&'tcx Expr<'tcx>> {\n     match expr.kind {\n         ExprKind::Call(func, [arg])\n-            if path_to_local_id(arg, binding) && cx.typeck_results().expr_adjustments(arg).is_empty() =>\n+            if path_to_local_id(arg, binding)\n+                && cx.typeck_results().expr_adjustments(arg).is_empty()\n+                && !type_is_unsafe_function(cx, cx.typeck_results().expr_ty(func).peel_refs()) =>\n         {\n             Some(func)\n         },\n@@ -237,6 +244,11 @@ enum OptionPat<'a> {\n     },\n }\n \n+struct SomeExpr<'tcx> {\n+    expr: &'tcx Expr<'tcx>,\n+    needs_unsafe_block: bool,\n+}\n+\n // Try to parse into a recognized `Option` pattern.\n // i.e. `_`, `None`, `Some(..)`, or a reference to any of those.\n fn try_parse_pattern(cx: &LateContext<'tcx>, pat: &'tcx Pat<'_>, ctxt: SyntaxContext) -> Option<OptionPat<'tcx>> {\n@@ -257,7 +269,12 @@ fn try_parse_pattern(cx: &LateContext<'tcx>, pat: &'tcx Pat<'_>, ctxt: SyntaxCon\n }\n \n // Checks for an expression wrapped by the `Some` constructor. Returns the contained expression.\n-fn get_some_expr(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, ctxt: SyntaxContext) -> Option<&'tcx Expr<'tcx>> {\n+fn get_some_expr(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'_>,\n+    needs_unsafe_block: bool,\n+    ctxt: SyntaxContext,\n+) -> Option<SomeExpr<'tcx>> {\n     // TODO: Allow more complex expressions.\n     match expr.kind {\n         ExprKind::Call(\n@@ -266,15 +283,24 @@ fn get_some_expr(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, ctxt: SyntaxConte\n                 ..\n             },\n             [arg],\n-        ) if ctxt == expr.span.ctxt() && is_lang_ctor(cx, qpath, OptionSome) => Some(arg),\n+        ) if ctxt == expr.span.ctxt() && is_lang_ctor(cx, qpath, OptionSome) => Some(SomeExpr {\n+            expr: arg,\n+            needs_unsafe_block,\n+        }),\n         ExprKind::Block(\n             Block {\n                 stmts: [],\n                 expr: Some(expr),\n+                rules,\n                 ..\n             },\n             _,\n-        ) => get_some_expr(cx, expr, ctxt),\n+        ) => get_some_expr(\n+            cx,\n+            expr,\n+            needs_unsafe_block || *rules == BlockCheckMode::UnsafeBlock(UnsafeSource::UserProvided),\n+            ctxt,\n+        ),\n         _ => None,\n     }\n }"}, {"sha": "ebf3f8cabd4706b3da545355708d039f0f693a4f", "filename": "tests/ui/manual_map_option_2.fixed", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bb58dc84c11c7699b1289f802c548d6a156a6eb7/tests%2Fui%2Fmanual_map_option_2.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/bb58dc84c11c7699b1289f802c548d6a156a6eb7/tests%2Fui%2Fmanual_map_option_2.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_map_option_2.fixed?ref=bb58dc84c11c7699b1289f802c548d6a156a6eb7", "patch": "@@ -47,4 +47,14 @@ fn main() {\n     let _ = s.as_ref().map(|x| {\n             if let Some(ref s) = s { (x.clone(), s) } else { panic!() }\n         });\n+\n+    // Issue #7820\n+    unsafe fn f(x: u32) -> u32 {\n+        x\n+    }\n+    unsafe {\n+        let _ = Some(0).map(|x| f(x));\n+    }\n+    let _ = Some(0).map(|x| unsafe { f(x) });\n+    let _ = Some(0).map(|x| unsafe { f(x) });\n }"}, {"sha": "1382d9af0aa085d5c77c4429aa0f459ba7fecb16", "filename": "tests/ui/manual_map_option_2.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/bb58dc84c11c7699b1289f802c548d6a156a6eb7/tests%2Fui%2Fmanual_map_option_2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb58dc84c11c7699b1289f802c548d6a156a6eb7/tests%2Fui%2Fmanual_map_option_2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_map_option_2.rs?ref=bb58dc84c11c7699b1289f802c548d6a156a6eb7", "patch": "@@ -53,4 +53,23 @@ fn main() {\n         }),\n         None => None,\n     };\n+\n+    // Issue #7820\n+    unsafe fn f(x: u32) -> u32 {\n+        x\n+    }\n+    unsafe {\n+        let _ = match Some(0) {\n+            Some(x) => Some(f(x)),\n+            None => None,\n+        };\n+    }\n+    let _ = match Some(0) {\n+        Some(x) => unsafe { Some(f(x)) },\n+        None => None,\n+    };\n+    let _ = match Some(0) {\n+        Some(x) => Some(unsafe { f(x) }),\n+        None => None,\n+    };\n }"}, {"sha": "d35b6252fb8704fc377666eb5d0197006db7ef59", "filename": "tests/ui/manual_map_option_2.stderr", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/bb58dc84c11c7699b1289f802c548d6a156a6eb7/tests%2Fui%2Fmanual_map_option_2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bb58dc84c11c7699b1289f802c548d6a156a6eb7/tests%2Fui%2Fmanual_map_option_2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_map_option_2.stderr?ref=bb58dc84c11c7699b1289f802c548d6a156a6eb7", "patch": "@@ -39,5 +39,35 @@ LL +             if let Some(ref s) = s { (x.clone(), s) } else { panic!() }\n LL ~         });\n    |\n \n-error: aborting due to 2 previous errors\n+error: manual implementation of `Option::map`\n+  --> $DIR/manual_map_option_2.rs:62:17\n+   |\n+LL |           let _ = match Some(0) {\n+   |  _________________^\n+LL | |             Some(x) => Some(f(x)),\n+LL | |             None => None,\n+LL | |         };\n+   | |_________^ help: try this: `Some(0).map(|x| f(x))`\n+\n+error: manual implementation of `Option::map`\n+  --> $DIR/manual_map_option_2.rs:67:13\n+   |\n+LL |       let _ = match Some(0) {\n+   |  _____________^\n+LL | |         Some(x) => unsafe { Some(f(x)) },\n+LL | |         None => None,\n+LL | |     };\n+   | |_____^ help: try this: `Some(0).map(|x| unsafe { f(x) })`\n+\n+error: manual implementation of `Option::map`\n+  --> $DIR/manual_map_option_2.rs:71:13\n+   |\n+LL |       let _ = match Some(0) {\n+   |  _____________^\n+LL | |         Some(x) => Some(unsafe { f(x) }),\n+LL | |         None => None,\n+LL | |     };\n+   | |_____^ help: try this: `Some(0).map(|x| unsafe { f(x) })`\n+\n+error: aborting due to 5 previous errors\n "}]}