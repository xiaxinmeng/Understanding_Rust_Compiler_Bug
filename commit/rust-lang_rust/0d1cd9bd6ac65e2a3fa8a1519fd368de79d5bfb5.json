{"sha": "0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBkMWNkOWJkNmFjNjVlMmEzZmE4YTE1MTlmZDM2OGRlNzlkNWJmYjU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-02-17T06:01:49Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-02-17T06:01:49Z"}, "message": "Auto merge of #31685 - petrochenkov:patrefact2, r=eddyb\n\nAnd split `PatKind::Enum` into `PatKind::TupleStruct` and `PatKind::Path`.\nThis is the HIR part of https://github.com/rust-lang/rust/pull/31581.\nThis is also kind of a preparation for https://github.com/rust-lang/rfcs/pull/1492.\n\nr? @eddyb", "tree": {"sha": "3c9093e56a17d097bd3b3c9722caa52de9c30d79", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3c9093e56a17d097bd3b3c9722caa52de9c30d79"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5", "html_url": "https://github.com/rust-lang/rust/commit/0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "82f30d2a361cd8e5621f4906c61e16bbe61ebad6", "url": "https://api.github.com/repos/rust-lang/rust/commits/82f30d2a361cd8e5621f4906c61e16bbe61ebad6", "html_url": "https://github.com/rust-lang/rust/commit/82f30d2a361cd8e5621f4906c61e16bbe61ebad6"}, {"sha": "06755d90ce3bf9694060e579439ee4e8345e4512", "url": "https://api.github.com/repos/rust-lang/rust/commits/06755d90ce3bf9694060e579439ee4e8345e4512", "html_url": "https://github.com/rust-lang/rust/commit/06755d90ce3bf9694060e579439ee4e8345e4512"}], "stats": {"total": 839, "additions": 416, "deletions": 423}, "files": [{"sha": "3c4f682ad952386139cc7ed44abd321e76c6977d", "filename": "src/librustc/front/map/collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5/src%2Flibrustc%2Ffront%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5/src%2Flibrustc%2Ffront%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fmap%2Fcollector.rs?ref=0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5", "patch": "@@ -262,7 +262,7 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n \n     fn visit_pat(&mut self, pat: &'ast Pat) {\n         let maybe_binding = match pat.node {\n-            PatIdent(_, id, _) => Some(id.node),\n+            PatKind::Ident(_, id, _) => Some(id.node),\n             _ => None\n         };\n "}, {"sha": "53a311f95dae34a10f4ee484e6a396b666e14905", "filename": "src/librustc/front/map/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5/src%2Flibrustc%2Ffront%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5/src%2Flibrustc%2Ffront%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fmap%2Fmod.rs?ref=0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5", "patch": "@@ -615,7 +615,7 @@ impl<'ast> Map<'ast> {\n             NodeVariant(v) => PathName(v.node.name),\n             NodeLifetime(lt) => PathName(lt.name),\n             NodeTyParam(tp) => PathName(tp.name),\n-            NodeLocal(&Pat { node: PatIdent(_,l,_), .. }) => {\n+            NodeLocal(&Pat { node: PatKind::Ident(_,l,_), .. }) => {\n                 PathName(l.node.name)\n             },\n             _ => panic!(\"no path elem for {:?}\", node)"}, {"sha": "701a459690889388847e0e9a23a592496f05891f", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5", "patch": "@@ -16,7 +16,7 @@ use middle::ty;\n use syntax::ast;\n use syntax::ptr::P;\n \n-use rustc_front::hir;\n+use rustc_front::hir::{self, PatKind};\n \n struct CFGBuilder<'a, 'tcx: 'a> {\n     tcx: &'a ty::ctxt<'tcx>,\n@@ -99,35 +99,36 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n \n     fn pat(&mut self, pat: &hir::Pat, pred: CFGIndex) -> CFGIndex {\n         match pat.node {\n-            hir::PatIdent(_, _, None) |\n-            hir::PatEnum(_, None) |\n-            hir::PatQPath(..) |\n-            hir::PatLit(..) |\n-            hir::PatRange(..) |\n-            hir::PatWild => {\n+            PatKind::Ident(_, _, None) |\n+            PatKind::TupleStruct(_, None) |\n+            PatKind::Path(..) |\n+            PatKind::QPath(..) |\n+            PatKind::Lit(..) |\n+            PatKind::Range(..) |\n+            PatKind::Wild => {\n                 self.add_ast_node(pat.id, &[pred])\n             }\n \n-            hir::PatBox(ref subpat) |\n-            hir::PatRegion(ref subpat, _) |\n-            hir::PatIdent(_, _, Some(ref subpat)) => {\n+            PatKind::Box(ref subpat) |\n+            PatKind::Ref(ref subpat, _) |\n+            PatKind::Ident(_, _, Some(ref subpat)) => {\n                 let subpat_exit = self.pat(&subpat, pred);\n                 self.add_ast_node(pat.id, &[subpat_exit])\n             }\n \n-            hir::PatEnum(_, Some(ref subpats)) |\n-            hir::PatTup(ref subpats) => {\n+            PatKind::TupleStruct(_, Some(ref subpats)) |\n+            PatKind::Tup(ref subpats) => {\n                 let pats_exit = self.pats_all(subpats.iter(), pred);\n                 self.add_ast_node(pat.id, &[pats_exit])\n             }\n \n-            hir::PatStruct(_, ref subpats, _) => {\n+            PatKind::Struct(_, ref subpats, _) => {\n                 let pats_exit =\n                     self.pats_all(subpats.iter().map(|f| &f.node.pat), pred);\n                 self.add_ast_node(pat.id, &[pats_exit])\n             }\n \n-            hir::PatVec(ref pre, ref vec, ref post) => {\n+            PatKind::Vec(ref pre, ref vec, ref post) => {\n                 let pre_exit = self.pats_all(pre.iter(), pred);\n                 let vec_exit = self.pats_all(vec.iter(), pre_exit);\n                 let post_exit = self.pats_all(post.iter(), vec_exit);"}, {"sha": "246a4e9f28f6b31082005d87666e1232e64d76be", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 74, "deletions": 83, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5", "patch": "@@ -32,7 +32,7 @@ use std::fmt;\n use std::iter::{FromIterator, IntoIterator, repeat};\n \n use rustc_front::hir;\n-use rustc_front::hir::Pat;\n+use rustc_front::hir::{Pat, PatKind};\n use rustc_front::intravisit::{self, Visitor, FnKind};\n use rustc_front::util as front_util;\n use rustc_back::slice;\n@@ -47,7 +47,7 @@ use util::nodemap::FnvHashMap;\n \n pub const DUMMY_WILD_PAT: &'static Pat = &Pat {\n     id: DUMMY_NODE_ID,\n-    node: hir::PatWild,\n+    node: PatKind::Wild,\n     span: DUMMY_SP\n };\n \n@@ -242,7 +242,7 @@ fn check_expr(cx: &mut MatchCheckCtxt, ex: &hir::Expr) {\n fn check_for_bindings_named_the_same_as_variants(cx: &MatchCheckCtxt, pat: &Pat) {\n     front_util::walk_pat(pat, |p| {\n         match p.node {\n-            hir::PatIdent(hir::BindByValue(hir::MutImmutable), ident, None) => {\n+            PatKind::Ident(hir::BindByValue(hir::MutImmutable), ident, None) => {\n                 let pat_ty = cx.tcx.pat_ty(p);\n                 if let ty::TyEnum(edef, _) = pat_ty.sty {\n                     let def = cx.tcx.def_map.borrow().get(&p.id).map(|d| d.full_def());\n@@ -274,7 +274,7 @@ fn check_for_bindings_named_the_same_as_variants(cx: &MatchCheckCtxt, pat: &Pat)\n // Check that we do not match against a static NaN (#6804)\n fn check_for_static_nan(cx: &MatchCheckCtxt, pat: &Pat) {\n     front_util::walk_pat(pat, |p| {\n-        if let hir::PatLit(ref expr) = p.node {\n+        if let PatKind::Lit(ref expr) = p.node {\n             match eval_const_expr_partial(cx.tcx, &expr, ExprTypeChecked, None) {\n                 Ok(ConstVal::Float(f)) if f.is_nan() => {\n                     span_warn!(cx.tcx.sess, p.span, E0003,\n@@ -360,7 +360,7 @@ fn check_arms(cx: &MatchCheckCtxt,\n \n fn raw_pat<'a>(p: &'a Pat) -> &'a Pat {\n     match p.node {\n-        hir::PatIdent(_, _, Some(ref s)) => raw_pat(&s),\n+        PatKind::Ident(_, _, Some(ref s)) => raw_pat(&s),\n         _ => p\n     }\n }\n@@ -377,7 +377,7 @@ fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, matrix: &Matrix, source: hir:\n                 hir::MatchSource::ForLoopDesugar => {\n                     // `witnesses[0]` has the form `Some(<head>)`, peel off the `Some`\n                     let witness = match witnesses[0].node {\n-                        hir::PatEnum(_, Some(ref pats)) => match &pats[..] {\n+                        PatKind::TupleStruct(_, Some(ref pats)) => match &pats[..] {\n                             [ref pat] => &**pat,\n                             _ => unreachable!(),\n                         },\n@@ -466,7 +466,7 @@ impl<'map> ast_util::IdVisitingOperation for RenamingRecorder<'map> {\n impl<'a, 'tcx> Folder for StaticInliner<'a, 'tcx> {\n     fn fold_pat(&mut self, pat: P<Pat>) -> P<Pat> {\n         return match pat.node {\n-            hir::PatIdent(..) | hir::PatEnum(..) | hir::PatQPath(..) => {\n+            PatKind::Ident(..) | PatKind::Path(..) | PatKind::QPath(..) => {\n                 let def = self.tcx.def_map.borrow().get(&pat.id).map(|d| d.full_def());\n                 match def {\n                     Some(Def::AssociatedConst(did)) |\n@@ -530,26 +530,32 @@ fn construct_witness<'a,'tcx>(cx: &MatchCheckCtxt<'a,'tcx>, ctor: &Constructor,\n     let pats_len = pats.len();\n     let mut pats = pats.into_iter().map(|p| P((*p).clone()));\n     let pat = match left_ty.sty {\n-        ty::TyTuple(_) => hir::PatTup(pats.collect()),\n+        ty::TyTuple(_) => PatKind::Tup(pats.collect()),\n \n         ty::TyEnum(adt, _) | ty::TyStruct(adt, _)  => {\n             let v = adt.variant_of_ctor(ctor);\n-            if let VariantKind::Struct = v.kind() {\n-                let field_pats: hir::HirVec<_> = v.fields.iter()\n-                    .zip(pats)\n-                    .filter(|&(_, ref pat)| pat.node != hir::PatWild)\n-                    .map(|(field, pat)| Spanned {\n-                        span: DUMMY_SP,\n-                        node: hir::FieldPat {\n-                            name: field.name,\n-                            pat: pat,\n-                            is_shorthand: false,\n-                        }\n-                    }).collect();\n-                let has_more_fields = field_pats.len() < pats_len;\n-                hir::PatStruct(def_to_path(cx.tcx, v.did), field_pats, has_more_fields)\n-            } else {\n-                hir::PatEnum(def_to_path(cx.tcx, v.did), Some(pats.collect()))\n+            match v.kind() {\n+                VariantKind::Struct => {\n+                    let field_pats: hir::HirVec<_> = v.fields.iter()\n+                        .zip(pats)\n+                        .filter(|&(_, ref pat)| pat.node != PatKind::Wild)\n+                        .map(|(field, pat)| Spanned {\n+                            span: DUMMY_SP,\n+                            node: hir::FieldPat {\n+                                name: field.name,\n+                                pat: pat,\n+                                is_shorthand: false,\n+                            }\n+                        }).collect();\n+                    let has_more_fields = field_pats.len() < pats_len;\n+                    PatKind::Struct(def_to_path(cx.tcx, v.did), field_pats, has_more_fields)\n+                }\n+                VariantKind::Tuple => {\n+                    PatKind::TupleStruct(def_to_path(cx.tcx, v.did), Some(pats.collect()))\n+                }\n+                VariantKind::Unit => {\n+                    PatKind::Path(def_to_path(cx.tcx, v.did))\n+                }\n             }\n         }\n \n@@ -558,35 +564,35 @@ fn construct_witness<'a,'tcx>(cx: &MatchCheckCtxt<'a,'tcx>, ctor: &Constructor,\n                ty::TyArray(_, n) => match ctor {\n                     &Single => {\n                         assert_eq!(pats_len, n);\n-                        hir::PatVec(pats.collect(), None, hir::HirVec::new())\n+                        PatKind::Vec(pats.collect(), None, hir::HirVec::new())\n                     },\n                     _ => unreachable!()\n                 },\n                 ty::TySlice(_) => match ctor {\n                     &Slice(n) => {\n                         assert_eq!(pats_len, n);\n-                        hir::PatVec(pats.collect(), None, hir::HirVec::new())\n+                        PatKind::Vec(pats.collect(), None, hir::HirVec::new())\n                     },\n                     _ => unreachable!()\n                 },\n-                ty::TyStr => hir::PatWild,\n+                ty::TyStr => PatKind::Wild,\n \n                 _ => {\n                     assert_eq!(pats_len, 1);\n-                    hir::PatRegion(pats.nth(0).unwrap(), mutbl)\n+                    PatKind::Ref(pats.nth(0).unwrap(), mutbl)\n                 }\n             }\n         }\n \n         ty::TyArray(_, len) => {\n             assert_eq!(pats_len, len);\n-            hir::PatVec(pats.collect(), None, hir::HirVec::new())\n+            PatKind::Vec(pats.collect(), None, hir::HirVec::new())\n         }\n \n         _ => {\n             match *ctor {\n-                ConstantValue(ref v) => hir::PatLit(const_val_to_expr(v)),\n-                _ => hir::PatWild,\n+                ConstantValue(ref v) => PatKind::Lit(const_val_to_expr(v)),\n+                _ => PatKind::Wild,\n             }\n         }\n     };\n@@ -682,15 +688,15 @@ fn is_useful(cx: &MatchCheckCtxt,\n         let left_ty = cx.tcx.pat_ty(&real_pat);\n \n         match real_pat.node {\n-            hir::PatIdent(hir::BindByRef(..), _, _) => {\n+            PatKind::Ident(hir::BindByRef(..), _, _) => {\n                 left_ty.builtin_deref(false, NoPreference).unwrap().ty\n             }\n             _ => left_ty,\n         }\n     };\n \n     let max_slice_length = rows.iter().filter_map(|row| match row[0].node {\n-        hir::PatVec(ref before, _, ref after) => Some(before.len() + after.len()),\n+        PatKind::Vec(ref before, _, ref after) => Some(before.len() + after.len()),\n         _ => None\n     }).max().map_or(0, |v| v + 1);\n \n@@ -769,39 +775,25 @@ fn pat_constructors(cx: &MatchCheckCtxt, p: &Pat,\n                     left_ty: Ty, max_slice_length: usize) -> Vec<Constructor> {\n     let pat = raw_pat(p);\n     match pat.node {\n-        hir::PatIdent(..) =>\n-            match cx.tcx.def_map.borrow().get(&pat.id).map(|d| d.full_def()) {\n-                Some(Def::Const(..)) | Some(Def::AssociatedConst(..)) =>\n-                    cx.tcx.sess.span_bug(pat.span, \"const pattern should've \\\n-                                                    been rewritten\"),\n-                Some(Def::Struct(..)) => vec!(Single),\n-                Some(Def::Variant(_, id)) => vec!(Variant(id)),\n-                _ => vec!()\n-            },\n-        hir::PatEnum(..) =>\n-            match cx.tcx.def_map.borrow().get(&pat.id).map(|d| d.full_def()) {\n-                Some(Def::Const(..)) | Some(Def::AssociatedConst(..)) =>\n+        PatKind::Struct(..) | PatKind::TupleStruct(..) | PatKind::Path(..) | PatKind::Ident(..) =>\n+            match cx.tcx.def_map.borrow().get(&pat.id).unwrap().full_def() {\n+                Def::Const(..) | Def::AssociatedConst(..) =>\n                     cx.tcx.sess.span_bug(pat.span, \"const pattern should've \\\n                                                     been rewritten\"),\n-                Some(Def::Variant(_, id)) => vec!(Variant(id)),\n-                _ => vec!(Single)\n+                Def::Struct(..) | Def::TyAlias(..) => vec![Single],\n+                Def::Variant(_, id) => vec![Variant(id)],\n+                Def::Local(..) => vec![],\n+                def => cx.tcx.sess.span_bug(pat.span, &format!(\"pat_constructors: unexpected \\\n+                                                                definition {:?}\", def)),\n             },\n-        hir::PatQPath(..) =>\n+        PatKind::QPath(..) =>\n             cx.tcx.sess.span_bug(pat.span, \"const pattern should've \\\n                                             been rewritten\"),\n-        hir::PatStruct(..) =>\n-            match cx.tcx.def_map.borrow().get(&pat.id).map(|d| d.full_def()) {\n-                Some(Def::Const(..)) | Some(Def::AssociatedConst(..)) =>\n-                    cx.tcx.sess.span_bug(pat.span, \"const pattern should've \\\n-                                                    been rewritten\"),\n-                Some(Def::Variant(_, id)) => vec!(Variant(id)),\n-                _ => vec!(Single)\n-            },\n-        hir::PatLit(ref expr) =>\n+        PatKind::Lit(ref expr) =>\n             vec!(ConstantValue(eval_const_expr(cx.tcx, &expr))),\n-        hir::PatRange(ref lo, ref hi) =>\n+        PatKind::Range(ref lo, ref hi) =>\n             vec!(ConstantRange(eval_const_expr(cx.tcx, &lo), eval_const_expr(cx.tcx, &hi))),\n-        hir::PatVec(ref before, ref slice, ref after) =>\n+        PatKind::Vec(ref before, ref slice, ref after) =>\n             match left_ty.sty {\n                 ty::TyArray(_, _) => vec!(Single),\n                 _                      => if slice.is_some() {\n@@ -812,9 +804,9 @@ fn pat_constructors(cx: &MatchCheckCtxt, p: &Pat,\n                     vec!(Slice(before.len() + after.len()))\n                 }\n             },\n-        hir::PatBox(_) | hir::PatTup(_) | hir::PatRegion(..) =>\n+        PatKind::Box(_) | PatKind::Tup(_) | PatKind::Ref(..) =>\n             vec!(Single),\n-        hir::PatWild =>\n+        PatKind::Wild =>\n             vec!(),\n     }\n }\n@@ -877,25 +869,24 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n         id: pat_id, ref node, span: pat_span\n     } = raw_pat(r[col]);\n     let head: Option<Vec<&Pat>> = match *node {\n-        hir::PatWild =>\n+        PatKind::Wild =>\n             Some(vec![DUMMY_WILD_PAT; arity]),\n \n-        hir::PatIdent(_, _, _) => {\n-            let opt_def = cx.tcx.def_map.borrow().get(&pat_id).map(|d| d.full_def());\n-            match opt_def {\n-                Some(Def::Const(..)) | Some(Def::AssociatedConst(..)) =>\n+        PatKind::Path(..) | PatKind::Ident(..) => {\n+            let def = cx.tcx.def_map.borrow().get(&pat_id).unwrap().full_def();\n+            match def {\n+                Def::Const(..) | Def::AssociatedConst(..) =>\n                     cx.tcx.sess.span_bug(pat_span, \"const pattern should've \\\n                                                     been rewritten\"),\n-                Some(Def::Variant(_, id)) => if *constructor == Variant(id) {\n-                    Some(vec!())\n-                } else {\n-                    None\n-                },\n-                _ => Some(vec![DUMMY_WILD_PAT; arity])\n+                Def::Variant(_, id) if *constructor != Variant(id) => None,\n+                Def::Variant(..) | Def::Struct(..) => Some(Vec::new()),\n+                Def::Local(..) => Some(vec![DUMMY_WILD_PAT; arity]),\n+                _ => cx.tcx.sess.span_bug(pat_span, &format!(\"specialize: unexpected \\\n+                                                              definition {:?}\", def)),\n             }\n         }\n \n-        hir::PatEnum(_, ref args) => {\n+        PatKind::TupleStruct(_, ref args) => {\n             let def = cx.tcx.def_map.borrow().get(&pat_id).unwrap().full_def();\n             match def {\n                 Def::Const(..) | Def::AssociatedConst(..) =>\n@@ -912,12 +903,12 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n             }\n         }\n \n-        hir::PatQPath(_, _) => {\n+        PatKind::QPath(_, _) => {\n             cx.tcx.sess.span_bug(pat_span, \"const pattern should've \\\n                                             been rewritten\")\n         }\n \n-        hir::PatStruct(_, ref pattern_fields, _) => {\n+        PatKind::Struct(_, ref pattern_fields, _) => {\n             let def = cx.tcx.def_map.borrow().get(&pat_id).unwrap().full_def();\n             let adt = cx.tcx.node_id_to_type(pat_id).ty_adt_def().unwrap();\n             let variant = adt.variant_of_ctor(constructor);\n@@ -934,13 +925,13 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n             }\n         }\n \n-        hir::PatTup(ref args) =>\n+        PatKind::Tup(ref args) =>\n             Some(args.iter().map(|p| &**p).collect()),\n \n-        hir::PatBox(ref inner) | hir::PatRegion(ref inner, _) =>\n+        PatKind::Box(ref inner) | PatKind::Ref(ref inner, _) =>\n             Some(vec![&**inner]),\n \n-        hir::PatLit(ref expr) => {\n+        PatKind::Lit(ref expr) => {\n             let expr_value = eval_const_expr(cx.tcx, &expr);\n             match range_covered_by_constructor(constructor, &expr_value, &expr_value) {\n                 Some(true) => Some(vec![]),\n@@ -952,7 +943,7 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n             }\n         }\n \n-        hir::PatRange(ref from, ref to) => {\n+        PatKind::Range(ref from, ref to) => {\n             let from_value = eval_const_expr(cx.tcx, &from);\n             let to_value = eval_const_expr(cx.tcx, &to);\n             match range_covered_by_constructor(constructor, &from_value, &to_value) {\n@@ -965,7 +956,7 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n             }\n         }\n \n-        hir::PatVec(ref before, ref slice, ref after) => {\n+        PatKind::Vec(ref before, ref slice, ref after) => {\n             match *constructor {\n                 // Fixed-length vectors.\n                 Single => {\n@@ -1104,7 +1095,7 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n         front_util::walk_pat(&pat, |p| {\n             if pat_is_binding(&def_map.borrow(), &p) {\n                 match p.node {\n-                    hir::PatIdent(hir::BindByValue(_), _, ref sub) => {\n+                    PatKind::Ident(hir::BindByValue(_), _, ref sub) => {\n                         let pat_ty = tcx.node_id_to_type(p.id);\n                         //FIXME: (@jroesch) this code should be floated up as well\n                         let infcx = infer::new_infer_ctxt(cx.tcx,\n@@ -1114,7 +1105,7 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n                             check_move(p, sub.as_ref().map(|p| &**p));\n                         }\n                     }\n-                    hir::PatIdent(hir::BindByRef(_), _, _) => {\n+                    PatKind::Ident(hir::BindByRef(_), _, _) => {\n                     }\n                     _ => {\n                         cx.tcx.sess.span_bug(\n@@ -1202,7 +1193,7 @@ impl<'a, 'b, 'tcx, 'v> Visitor<'v> for AtBindingPatternVisitor<'a, 'b, 'tcx> {\n         }\n \n         match pat.node {\n-            hir::PatIdent(_, _, Some(_)) => {\n+            PatKind::Ident(_, _, Some(_)) => {\n                 let bindings_were_allowed = self.bindings_allowed;\n                 self.bindings_allowed = false;\n                 intravisit::walk_pat(self, pat);"}, {"sha": "9ec79c84afb30b6d61ee132fceaec0060321af0d", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5", "patch": "@@ -30,7 +30,7 @@ use session::Session;\n \n use graphviz::IntoCow;\n use syntax::ast;\n-use rustc_front::hir::Expr;\n+use rustc_front::hir::{Expr, PatKind};\n use rustc_front::hir;\n use rustc_front::intravisit::FnKind;\n use syntax::codemap::Span;\n@@ -325,7 +325,7 @@ impl ConstVal {\n pub fn const_expr_to_pat(tcx: &ty::ctxt, expr: &Expr, span: Span) -> P<hir::Pat> {\n     let pat = match expr.node {\n         hir::ExprTup(ref exprs) =>\n-            hir::PatTup(exprs.iter().map(|expr| const_expr_to_pat(tcx, &expr, span)).collect()),\n+            PatKind::Tup(exprs.iter().map(|expr| const_expr_to_pat(tcx, &expr, span)).collect()),\n \n         hir::ExprCall(ref callee, ref args) => {\n             let def = *tcx.def_map.borrow().get(&callee.id).unwrap();\n@@ -337,13 +337,13 @@ pub fn const_expr_to_pat(tcx: &ty::ctxt, expr: &Expr, span: Span) -> P<hir::Pat>\n                 Def::Variant(_, variant_did) => def_to_path(tcx, variant_did),\n                 Def::Fn(..) => return P(hir::Pat {\n                     id: expr.id,\n-                    node: hir::PatLit(P(expr.clone())),\n+                    node: PatKind::Lit(P(expr.clone())),\n                     span: span,\n                 }),\n                 _ => unreachable!()\n             };\n             let pats = args.iter().map(|expr| const_expr_to_pat(tcx, &expr, span)).collect();\n-            hir::PatEnum(path, Some(pats))\n+            PatKind::TupleStruct(path, Some(pats))\n         }\n \n         hir::ExprStruct(ref path, ref fields, None) => {\n@@ -355,21 +355,19 @@ pub fn const_expr_to_pat(tcx: &ty::ctxt, expr: &Expr, span: Span) -> P<hir::Pat>\n                     is_shorthand: false,\n                 },\n             }).collect();\n-            hir::PatStruct(path.clone(), field_pats, false)\n+            PatKind::Struct(path.clone(), field_pats, false)\n         }\n \n         hir::ExprVec(ref exprs) => {\n             let pats = exprs.iter().map(|expr| const_expr_to_pat(tcx, &expr, span)).collect();\n-            hir::PatVec(pats, None, hir::HirVec::new())\n+            PatKind::Vec(pats, None, hir::HirVec::new())\n         }\n \n         hir::ExprPath(_, ref path) => {\n             let opt_def = tcx.def_map.borrow().get(&expr.id).map(|d| d.full_def());\n             match opt_def {\n-                Some(Def::Struct(..)) =>\n-                    hir::PatStruct(path.clone(), hir::HirVec::new(), false),\n-                Some(Def::Variant(..)) =>\n-                    hir::PatEnum(path.clone(), None),\n+                Some(Def::Struct(..)) | Some(Def::Variant(..)) =>\n+                    PatKind::Path(path.clone()),\n                 Some(Def::Const(def_id)) |\n                 Some(Def::AssociatedConst(def_id)) => {\n                     let expr = lookup_const_by_id(tcx, def_id, Some(expr.id), None).unwrap();\n@@ -379,7 +377,7 @@ pub fn const_expr_to_pat(tcx: &ty::ctxt, expr: &Expr, span: Span) -> P<hir::Pat>\n             }\n         }\n \n-        _ => hir::PatLit(P(expr.clone()))\n+        _ => PatKind::Lit(P(expr.clone()))\n     };\n     P(hir::Pat { id: expr.id, node: pat, span: span })\n }"}, {"sha": "92372870cd16e0d2f8ae7b4df59b4f6ae3355eb7", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5", "patch": "@@ -14,7 +14,7 @@\n \n use dep_graph::DepNode;\n use front::map as ast_map;\n-use rustc_front::hir;\n+use rustc_front::hir::{self, PatKind};\n use rustc_front::intravisit::{self, Visitor};\n \n use middle::{pat_util, privacy, ty};\n@@ -143,7 +143,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n             _ => self.tcx.sess.span_bug(lhs.span, \"non-ADT in struct pattern\")\n         };\n         for pat in pats {\n-            if let hir::PatWild = pat.node.pat.node {\n+            if let PatKind::Wild = pat.node.pat.node {\n                 continue;\n             }\n             self.insert_def_id(variant.field_named(pat.node.name).did);\n@@ -268,7 +268,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for MarkSymbolVisitor<'a, 'tcx> {\n     fn visit_pat(&mut self, pat: &hir::Pat) {\n         let def_map = &self.tcx.def_map;\n         match pat.node {\n-            hir::PatStruct(_, ref fields, _) => {\n+            PatKind::Struct(_, ref fields, _) => {\n                 self.handle_field_pattern_match(pat, fields);\n             }\n             _ if pat_util::pat_is_const(&def_map.borrow(), pat) => {"}, {"sha": "9b315aa46e5d372d9ab250a0be6c71f5d2fa8bea", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5", "patch": "@@ -27,7 +27,7 @@ use middle::mem_categorization as mc;\n use middle::ty;\n use middle::ty::adjustment;\n \n-use rustc_front::hir;\n+use rustc_front::hir::{self, PatKind};\n \n use syntax::ast;\n use syntax::ptr::P;\n@@ -946,9 +946,9 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n             let def_map = &self.tcx().def_map;\n             if pat_util::pat_is_binding(&def_map.borrow(), pat) {\n                 match pat.node {\n-                    hir::PatIdent(hir::BindByRef(_), _, _) =>\n+                    PatKind::Ident(hir::BindByRef(_), _, _) =>\n                         mode.lub(BorrowingMatch),\n-                    hir::PatIdent(hir::BindByValue(_), _, _) => {\n+                    PatKind::Ident(hir::BindByValue(_), _, _) => {\n                         match copy_or_move(self.typer, &cmt_pat, PatBindingMove) {\n                             Copy => mode.lub(CopyingMatch),\n                             Move(_) => mode.lub(MovingMatch),\n@@ -1002,14 +1002,14 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n \n                 // It is also a borrow or copy/move of the value being matched.\n                 match pat.node {\n-                    hir::PatIdent(hir::BindByRef(m), _, _) => {\n+                    PatKind::Ident(hir::BindByRef(m), _, _) => {\n                         if let ty::TyRef(&r, _) = pat_ty.sty {\n                             let bk = ty::BorrowKind::from_mutbl(m);\n                             delegate.borrow(pat.id, pat.span, cmt_pat,\n                                             r, bk, RefBinding);\n                         }\n                     }\n-                    hir::PatIdent(hir::BindByValue(_), _, _) => {\n+                    PatKind::Ident(hir::BindByValue(_), _, _) => {\n                         let mode = copy_or_move(typer, &cmt_pat, PatBindingMove);\n                         debug!(\"walk_pat binding consuming pat\");\n                         delegate.consume_pat(pat, cmt_pat, mode);\n@@ -1022,7 +1022,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n                 }\n             } else {\n                 match pat.node {\n-                    hir::PatVec(_, Some(ref slice_pat), _) => {\n+                    PatKind::Vec(_, Some(ref slice_pat), _) => {\n                         // The `slice_pat` here creates a slice into\n                         // the original vector.  This is effectively a\n                         // borrow of the elements of the vector being\n@@ -1070,8 +1070,8 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n             let tcx = typer.tcx;\n \n             match pat.node {\n-                hir::PatEnum(_, _) | hir::PatQPath(..) |\n-                hir::PatIdent(_, _, None) | hir::PatStruct(..) => {\n+                PatKind::TupleStruct(..) | PatKind::Path(..) | PatKind::QPath(..) |\n+                PatKind::Ident(_, _, None) | PatKind::Struct(..) => {\n                     match def_map.get(&pat.id).map(|d| d.full_def()) {\n                         None => {\n                             // no definition found: pat is not a\n@@ -1134,15 +1134,15 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n                     }\n                 }\n \n-                hir::PatIdent(_, _, Some(_)) => {\n+                PatKind::Ident(_, _, Some(_)) => {\n                     // Do nothing; this is a binding (not an enum\n                     // variant or struct), and the cat_pattern call\n                     // will visit the substructure recursively.\n                 }\n \n-                hir::PatWild | hir::PatTup(..) | hir::PatBox(..) |\n-                hir::PatRegion(..) | hir::PatLit(..) | hir::PatRange(..) |\n-                hir::PatVec(..) => {\n+                PatKind::Wild | PatKind::Tup(..) | PatKind::Box(..) |\n+                PatKind::Ref(..) | PatKind::Lit(..) | PatKind::Range(..) |\n+                PatKind::Vec(..) => {\n                     // Similarly, each of these cases does not\n                     // correspond to an enum variant or struct, so we\n                     // do not do any `matched_pat` calls for these"}, {"sha": "c16997157bd9fb9268eeaf9a2f42e6c2ba018ca9", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 16, "deletions": 20, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5", "patch": "@@ -79,7 +79,7 @@ use middle::def::Def;\n use middle::ty::adjustment;\n use middle::ty::{self, Ty};\n \n-use rustc_front::hir::{MutImmutable, MutMutable};\n+use rustc_front::hir::{MutImmutable, MutMutable, PatKind};\n use rustc_front::hir;\n use syntax::ast;\n use syntax::codemap::Span;\n@@ -305,7 +305,7 @@ impl MutabilityCategory {\n     fn from_local(tcx: &ty::ctxt, id: ast::NodeId) -> MutabilityCategory {\n         let ret = match tcx.map.get(id) {\n             ast_map::NodeLocal(p) => match p.node {\n-                hir::PatIdent(bind_mode, _, _) => {\n+                PatKind::Ident(bind_mode, _, _) => {\n                     if bind_mode == hir::BindByValue(hir::MutMutable) {\n                         McDeclared\n                     } else {\n@@ -396,7 +396,7 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n         // *being borrowed* is.  But ideally we would put in a more\n         // fundamental fix to this conflated use of the node id.\n         let ret_ty = match pat.node {\n-            hir::PatIdent(hir::BindByRef(_), _, _) => {\n+            PatKind::Ident(hir::BindByRef(_), _, _) => {\n                 // a bind-by-ref means that the base_ty will be the type of the ident itself,\n                 // but what we want here is the type of the underlying value being borrowed.\n                 // So peel off one-level, turning the &T into T.\n@@ -1209,7 +1209,7 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n             None\n         };\n \n-        // Note: This goes up here (rather than within the PatEnum arm\n+        // Note: This goes up here (rather than within the PatKind::TupleStruct arm\n         // alone) because struct patterns can refer to struct types or\n         // to struct variants within enums.\n         let cmt = match opt_def {\n@@ -1222,14 +1222,14 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n         };\n \n         match pat.node {\n-          hir::PatWild => {\n+          PatKind::Wild => {\n             // _\n           }\n \n-          hir::PatEnum(_, None) => {\n+          PatKind::TupleStruct(_, None) => {\n             // variant(..)\n           }\n-          hir::PatEnum(_, Some(ref subpats)) => {\n+          PatKind::TupleStruct(_, Some(ref subpats)) => {\n             match opt_def {\n                 Some(Def::Variant(..)) => {\n                     // variant(x, y, z)\n@@ -1267,19 +1267,15 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n             }\n           }\n \n-          hir::PatQPath(..) => {\n-              // Lone constant: ignore\n+          PatKind::Path(..) | PatKind::QPath(..) | PatKind::Ident(_, _, None) => {\n+              // Lone constant, or unit variant or identifier: ignore\n           }\n \n-          hir::PatIdent(_, _, Some(ref subpat)) => {\n+          PatKind::Ident(_, _, Some(ref subpat)) => {\n               try!(self.cat_pattern_(cmt, &subpat, op));\n           }\n \n-          hir::PatIdent(_, _, None) => {\n-              // nullary variant or identifier: ignore\n-          }\n-\n-          hir::PatStruct(_, ref field_pats, _) => {\n+          PatKind::Struct(_, ref field_pats, _) => {\n             // {f1: p1, ..., fN: pN}\n             for fp in field_pats {\n                 let field_ty = try!(self.pat_ty(&fp.node.pat)); // see (*2)\n@@ -1288,7 +1284,7 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n             }\n           }\n \n-          hir::PatTup(ref subpats) => {\n+          PatKind::Tup(ref subpats) => {\n             // (p1, ..., pN)\n             for (i, subpat) in subpats.iter().enumerate() {\n                 let subpat_ty = try!(self.pat_ty(&subpat)); // see (*2)\n@@ -1300,15 +1296,15 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n             }\n           }\n \n-          hir::PatBox(ref subpat) | hir::PatRegion(ref subpat, _) => {\n+          PatKind::Box(ref subpat) | PatKind::Ref(ref subpat, _) => {\n             // box p1, &p1, &mut p1.  we can ignore the mutability of\n-            // PatRegion since that information is already contained\n+            // PatKind::Ref since that information is already contained\n             // in the type.\n             let subcmt = try!(self.cat_deref(pat, cmt, 0, None));\n               try!(self.cat_pattern_(subcmt, &subpat, op));\n           }\n \n-          hir::PatVec(ref before, ref slice, ref after) => {\n+          PatKind::Vec(ref before, ref slice, ref after) => {\n               let context = InteriorOffsetKind::Pattern;\n               let vec_cmt = try!(self.deref_vec(pat, cmt, context));\n               let elt_cmt = try!(self.cat_index(pat, vec_cmt, context));\n@@ -1325,7 +1321,7 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n               }\n           }\n \n-          hir::PatLit(_) | hir::PatRange(_, _) => {\n+          PatKind::Lit(_) | PatKind::Range(_, _) => {\n               /*always ok*/\n           }\n         }"}, {"sha": "a1a3c194efe078d20b82b5885daa2d2027cea60c", "filename": "src/librustc/middle/pat_util.rs", "status": "modified", "additions": 24, "deletions": 21, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fpat_util.rs?ref=0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5", "patch": "@@ -14,7 +14,7 @@ use middle::ty;\n use util::nodemap::FnvHashMap;\n \n use syntax::ast;\n-use rustc_front::hir;\n+use rustc_front::hir::{self, PatKind};\n use rustc_front::util::walk_pat;\n use syntax::codemap::{respan, Span, Spanned, DUMMY_SP};\n \n@@ -34,27 +34,29 @@ pub fn pat_id_map(dm: &RefCell<DefMap>, pat: &hir::Pat) -> PatIdMap {\n \n pub fn pat_is_refutable(dm: &DefMap, pat: &hir::Pat) -> bool {\n     match pat.node {\n-        hir::PatLit(_) | hir::PatRange(_, _) | hir::PatQPath(..) => true,\n-        hir::PatEnum(_, _) |\n-        hir::PatIdent(_, _, None) |\n-        hir::PatStruct(..) => {\n+        PatKind::Lit(_) | PatKind::Range(_, _) | PatKind::QPath(..) => true,\n+        PatKind::TupleStruct(..) |\n+        PatKind::Path(..) |\n+        PatKind::Ident(_, _, None) |\n+        PatKind::Struct(..) => {\n             match dm.get(&pat.id).map(|d| d.full_def()) {\n                 Some(Def::Variant(..)) => true,\n                 _ => false\n             }\n         }\n-        hir::PatVec(_, _, _) => true,\n+        PatKind::Vec(_, _, _) => true,\n         _ => false\n     }\n }\n \n pub fn pat_is_variant_or_struct(dm: &DefMap, pat: &hir::Pat) -> bool {\n     match pat.node {\n-        hir::PatEnum(_, _) |\n-        hir::PatIdent(_, _, None) |\n-        hir::PatStruct(..) => {\n+        PatKind::TupleStruct(..) |\n+        PatKind::Path(..) |\n+        PatKind::Ident(_, _, None) |\n+        PatKind::Struct(..) => {\n             match dm.get(&pat.id).map(|d| d.full_def()) {\n-                Some(Def::Variant(..)) | Some(Def::Struct(..)) => true,\n+                Some(Def::Variant(..)) | Some(Def::Struct(..)) | Some(Def::TyAlias(..)) => true,\n                 _ => false\n             }\n         }\n@@ -64,7 +66,7 @@ pub fn pat_is_variant_or_struct(dm: &DefMap, pat: &hir::Pat) -> bool {\n \n pub fn pat_is_const(dm: &DefMap, pat: &hir::Pat) -> bool {\n     match pat.node {\n-        hir::PatIdent(_, _, None) | hir::PatEnum(..) | hir::PatQPath(..) => {\n+        PatKind::Ident(_, _, None) | PatKind::Path(..) | PatKind::QPath(..) => {\n             match dm.get(&pat.id).map(|d| d.full_def()) {\n                 Some(Def::Const(..)) | Some(Def::AssociatedConst(..)) => true,\n                 _ => false\n@@ -78,7 +80,7 @@ pub fn pat_is_const(dm: &DefMap, pat: &hir::Pat) -> bool {\n // returned instead of a panic.\n pub fn pat_is_resolved_const(dm: &DefMap, pat: &hir::Pat) -> bool {\n     match pat.node {\n-        hir::PatIdent(_, _, None) | hir::PatEnum(..) | hir::PatQPath(..) => {\n+        PatKind::Ident(_, _, None) | PatKind::Path(..) | PatKind::QPath(..) => {\n             match dm.get(&pat.id)\n                     .and_then(|d| if d.depth == 0 { Some(d.base_def) }\n                                   else { None } ) {\n@@ -92,7 +94,7 @@ pub fn pat_is_resolved_const(dm: &DefMap, pat: &hir::Pat) -> bool {\n \n pub fn pat_is_binding(dm: &DefMap, pat: &hir::Pat) -> bool {\n     match pat.node {\n-        hir::PatIdent(..) => {\n+        PatKind::Ident(..) => {\n             !pat_is_variant_or_struct(dm, pat) &&\n             !pat_is_const(dm, pat)\n         }\n@@ -102,8 +104,8 @@ pub fn pat_is_binding(dm: &DefMap, pat: &hir::Pat) -> bool {\n \n pub fn pat_is_binding_or_wild(dm: &DefMap, pat: &hir::Pat) -> bool {\n     match pat.node {\n-        hir::PatIdent(..) => pat_is_binding(dm, pat),\n-        hir::PatWild => true,\n+        PatKind::Ident(..) => pat_is_binding(dm, pat),\n+        PatKind::Wild => true,\n         _ => false\n     }\n }\n@@ -115,7 +117,7 @@ pub fn pat_bindings<I>(dm: &RefCell<DefMap>, pat: &hir::Pat, mut it: I) where\n {\n     walk_pat(pat, |p| {\n         match p.node {\n-          hir::PatIdent(binding_mode, ref pth, _) if pat_is_binding(&dm.borrow(), p) => {\n+          PatKind::Ident(binding_mode, ref pth, _) if pat_is_binding(&dm.borrow(), p) => {\n             it(binding_mode, p.id, p.span, &respan(pth.span, pth.node.name));\n           }\n           _ => {}\n@@ -128,7 +130,7 @@ pub fn pat_bindings_ident<I>(dm: &RefCell<DefMap>, pat: &hir::Pat, mut it: I) wh\n {\n     walk_pat(pat, |p| {\n         match p.node {\n-          hir::PatIdent(binding_mode, ref pth, _) if pat_is_binding(&dm.borrow(), p) => {\n+          PatKind::Ident(binding_mode, ref pth, _) if pat_is_binding(&dm.borrow(), p) => {\n             it(binding_mode, p.id, p.span, &respan(pth.span, pth.node));\n           }\n           _ => {}\n@@ -199,7 +201,7 @@ pub fn pat_contains_bindings_or_wild(dm: &DefMap, pat: &hir::Pat) -> bool {\n \n pub fn simple_name<'a>(pat: &'a hir::Pat) -> Option<ast::Name> {\n     match pat.node {\n-        hir::PatIdent(hir::BindByValue(_), ref path1, None) => {\n+        PatKind::Ident(hir::BindByValue(_), ref path1, None) => {\n             Some(path1.node.name)\n         }\n         _ => {\n@@ -224,9 +226,10 @@ pub fn necessary_variants(dm: &DefMap, pat: &hir::Pat) -> Vec<DefId> {\n     let mut variants = vec![];\n     walk_pat(pat, |p| {\n         match p.node {\n-            hir::PatEnum(_, _) |\n-            hir::PatIdent(_, _, None) |\n-            hir::PatStruct(..) => {\n+            PatKind::TupleStruct(..) |\n+            PatKind::Path(..) |\n+            PatKind::Ident(_, _, None) |\n+            PatKind::Struct(..) => {\n                 match dm.get(&p.id) {\n                     Some(&PathResolution { base_def: Def::Variant(_, id), .. }) => {\n                         variants.push(id);"}, {"sha": "b39964e2861e33a60bef8c985da8efe405de0bd5", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5", "patch": "@@ -32,7 +32,7 @@ use syntax::ast::{self, NodeId};\n \n use rustc_front::hir;\n use rustc_front::intravisit::{self, Visitor, FnKind};\n-use rustc_front::hir::{Block, Item, FnDecl, Arm, Pat, Stmt, Expr, Local};\n+use rustc_front::hir::{Block, Item, FnDecl, Arm, Pat, PatKind, Stmt, Expr, Local};\n use rustc_front::util::stmt_id;\n \n #[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash, RustcEncodable,\n@@ -755,7 +755,7 @@ fn resolve_pat(visitor: &mut RegionResolutionVisitor, pat: &hir::Pat) {\n     // If this is a binding (or maybe a binding, I'm too lazy to check\n     // the def map) then record the lifetime of that binding.\n     match pat.node {\n-        hir::PatIdent(..) => {\n+        PatKind::Ident(..) => {\n             record_var_lifetime(visitor, pat.id, pat.span);\n         }\n         _ => { }\n@@ -958,24 +958,24 @@ fn resolve_local(visitor: &mut RegionResolutionVisitor, local: &hir::Local) {\n     ///        | box P&\n     fn is_binding_pat(pat: &hir::Pat) -> bool {\n         match pat.node {\n-            hir::PatIdent(hir::BindByRef(_), _, _) => true,\n+            PatKind::Ident(hir::BindByRef(_), _, _) => true,\n \n-            hir::PatStruct(_, ref field_pats, _) => {\n+            PatKind::Struct(_, ref field_pats, _) => {\n                 field_pats.iter().any(|fp| is_binding_pat(&fp.node.pat))\n             }\n \n-            hir::PatVec(ref pats1, ref pats2, ref pats3) => {\n+            PatKind::Vec(ref pats1, ref pats2, ref pats3) => {\n                 pats1.iter().any(|p| is_binding_pat(&p)) ||\n                 pats2.iter().any(|p| is_binding_pat(&p)) ||\n                 pats3.iter().any(|p| is_binding_pat(&p))\n             }\n \n-            hir::PatEnum(_, Some(ref subpats)) |\n-            hir::PatTup(ref subpats) => {\n+            PatKind::TupleStruct(_, Some(ref subpats)) |\n+            PatKind::Tup(ref subpats) => {\n                 subpats.iter().any(|p| is_binding_pat(&p))\n             }\n \n-            hir::PatBox(ref subpat) => {\n+            PatKind::Box(ref subpat) => {\n                 is_binding_pat(&subpat)\n             }\n "}, {"sha": "fbb84c3cd7ec8858c2a2dcf0842836a11812d03b", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5", "patch": "@@ -31,7 +31,7 @@ use syntax::attr::{self, Stability, Deprecation, AttrMetaMethods};\n use util::nodemap::{DefIdMap, FnvHashSet, FnvHashMap};\n \n use rustc_front::hir;\n-use rustc_front::hir::{Item, Generics, StructField, Variant};\n+use rustc_front::hir::{Item, Generics, StructField, Variant, PatKind};\n use rustc_front::intravisit::{self, Visitor};\n \n use std::mem::replace;\n@@ -598,14 +598,14 @@ pub fn check_pat(tcx: &ty::ctxt, pat: &hir::Pat,\n     };\n     match pat.node {\n         // Foo(a, b, c)\n-        // A Variant(..) pattern `hir::PatEnum(_, None)` doesn't have to be recursed into.\n-        hir::PatEnum(_, Some(ref pat_fields)) => {\n+        // A Variant(..) pattern `PatKind::TupleStruct(_, None)` doesn't have to be recursed into.\n+        PatKind::TupleStruct(_, Some(ref pat_fields)) => {\n             for (field, struct_field) in pat_fields.iter().zip(&v.fields) {\n                 maybe_do_stability_check(tcx, struct_field.did, field.span, cb)\n             }\n         }\n         // Foo { a, b, c }\n-        hir::PatStruct(_, ref pat_fields, _) => {\n+        PatKind::Struct(_, ref pat_fields, _) => {\n             for field in pat_fields {\n                 let did = v.field_named(field.node.name).did;\n                 maybe_do_stability_check(tcx, did, field.span, cb);"}, {"sha": "00a011c6b5d6ac9f2bf8b3ef599a8f0a85808728", "filename": "src/librustc/middle/ty/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs?ref=0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5", "patch": "@@ -52,7 +52,7 @@ use syntax::codemap::{DUMMY_SP, Span};\n use syntax::parse::token::InternedString;\n \n use rustc_front::hir;\n-use rustc_front::hir::{ItemImpl, ItemTrait};\n+use rustc_front::hir::{ItemImpl, ItemTrait, PatKind};\n use rustc_front::intravisit::Visitor;\n \n pub use self::sty::{Binder, DebruijnIndex};\n@@ -1945,7 +1945,7 @@ impl<'tcx> ctxt<'tcx> {\n         match self.map.find(id) {\n             Some(ast_map::NodeLocal(pat)) => {\n                 match pat.node {\n-                    hir::PatIdent(_, ref path1, _) => path1.node.name.as_str(),\n+                    PatKind::Ident(_, ref path1, _) => path1.node.name.as_str(),\n                     _ => {\n                         self.sess.bug(&format!(\"Variable id {} maps to {:?}, not local\", id, pat));\n                     },"}, {"sha": "4e507284a1b46bb130f00110d160835d9cd987ae", "filename": "src/librustc_borrowck/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5", "patch": "@@ -23,7 +23,7 @@ use rustc::middle::ty;\n use std::rc::Rc;\n use syntax::ast;\n use syntax::codemap::Span;\n-use rustc_front::hir;\n+use rustc_front::hir::{self, PatKind};\n \n struct GatherMoveInfo<'tcx> {\n     id: ast::NodeId,\n@@ -98,7 +98,7 @@ pub fn gather_move_from_pat<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                       move_pat: &hir::Pat,\n                                       cmt: mc::cmt<'tcx>) {\n     let pat_span_path_opt = match move_pat.node {\n-        hir::PatIdent(_, ref path1, _) => {\n+        PatKind::Ident(_, ref path1, _) => {\n             Some(MoveSpanAndPath{span: move_pat.span,\n                                  name: path1.node.name})\n         },"}, {"sha": "b5e56edb6e47c1e3be06da70f8a393d90b846f18", "filename": "src/librustc_front/fold.rs", "status": "modified", "additions": 20, "deletions": 17, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5/src%2Flibrustc_front%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5/src%2Flibrustc_front%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Ffold.rs?ref=0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5", "patch": "@@ -962,25 +962,28 @@ pub fn noop_fold_pat<T: Folder>(p: P<Pat>, folder: &mut T) -> P<Pat> {\n         Pat {\n             id: folder.new_id(id),\n             node: match node {\n-                PatWild => PatWild,\n-                PatIdent(binding_mode, pth1, sub) => {\n-                    PatIdent(binding_mode,\n+                PatKind::Wild => PatKind::Wild,\n+                PatKind::Ident(binding_mode, pth1, sub) => {\n+                    PatKind::Ident(binding_mode,\n                              Spanned {\n                                  span: folder.new_span(pth1.span),\n                                  node: folder.fold_ident(pth1.node),\n                              },\n                              sub.map(|x| folder.fold_pat(x)))\n                 }\n-                PatLit(e) => PatLit(folder.fold_expr(e)),\n-                PatEnum(pth, pats) => {\n-                    PatEnum(folder.fold_path(pth),\n+                PatKind::Lit(e) => PatKind::Lit(folder.fold_expr(e)),\n+                PatKind::TupleStruct(pth, pats) => {\n+                    PatKind::TupleStruct(folder.fold_path(pth),\n                             pats.map(|pats| pats.move_map(|x| folder.fold_pat(x))))\n                 }\n-                PatQPath(qself, pth) => {\n+                PatKind::Path(pth) => {\n+                    PatKind::Path(folder.fold_path(pth))\n+                }\n+                PatKind::QPath(qself, pth) => {\n                     let qself = QSelf { ty: folder.fold_ty(qself.ty), ..qself };\n-                    PatQPath(qself, folder.fold_path(pth))\n+                    PatKind::QPath(qself, folder.fold_path(pth))\n                 }\n-                PatStruct(pth, fields, etc) => {\n+                PatKind::Struct(pth, fields, etc) => {\n                     let pth = folder.fold_path(pth);\n                     let fs = fields.move_map(|f| {\n                         Spanned {\n@@ -992,16 +995,16 @@ pub fn noop_fold_pat<T: Folder>(p: P<Pat>, folder: &mut T) -> P<Pat> {\n                             },\n                         }\n                     });\n-                    PatStruct(pth, fs, etc)\n+                    PatKind::Struct(pth, fs, etc)\n                 }\n-                PatTup(elts) => PatTup(elts.move_map(|x| folder.fold_pat(x))),\n-                PatBox(inner) => PatBox(folder.fold_pat(inner)),\n-                PatRegion(inner, mutbl) => PatRegion(folder.fold_pat(inner), mutbl),\n-                PatRange(e1, e2) => {\n-                    PatRange(folder.fold_expr(e1), folder.fold_expr(e2))\n+                PatKind::Tup(elts) => PatKind::Tup(elts.move_map(|x| folder.fold_pat(x))),\n+                PatKind::Box(inner) => PatKind::Box(folder.fold_pat(inner)),\n+                PatKind::Ref(inner, mutbl) => PatKind::Ref(folder.fold_pat(inner), mutbl),\n+                PatKind::Range(e1, e2) => {\n+                    PatKind::Range(folder.fold_expr(e1), folder.fold_expr(e2))\n                 }\n-                PatVec(before, slice, after) => {\n-                    PatVec(before.move_map(|x| folder.fold_pat(x)),\n+                PatKind::Vec(before, slice, after) => {\n+                    PatKind::Vec(before.move_map(|x| folder.fold_pat(x)),\n                            slice.map(|x| folder.fold_pat(x)),\n                            after.move_map(|x| folder.fold_pat(x)))\n                 }"}, {"sha": "dbc1d71517b75b45c4de90abd2dedd2669fd31c4", "filename": "src/librustc_front/hir.rs", "status": "modified", "additions": 30, "deletions": 25, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5/src%2Flibrustc_front%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5/src%2Flibrustc_front%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Fhir.rs?ref=0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5", "patch": "@@ -21,7 +21,6 @@ pub use self::FunctionRetTy::*;\n pub use self::ForeignItem_::*;\n pub use self::Item_::*;\n pub use self::Mutability::*;\n-pub use self::Pat_::*;\n pub use self::PathListItem_::*;\n pub use self::PrimTy::*;\n pub use self::Stmt_::*;\n@@ -475,7 +474,7 @@ pub struct Block {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash)]\n pub struct Pat {\n     pub id: NodeId,\n-    pub node: Pat_,\n+    pub node: PatKind,\n     pub span: Span,\n }\n \n@@ -506,45 +505,51 @@ pub enum BindingMode {\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub enum Pat_ {\n+pub enum PatKind {\n     /// Represents a wildcard pattern (`_`)\n-    PatWild,\n+    Wild,\n \n-    /// A PatIdent may either be a new bound variable,\n-    /// or a nullary enum (in which case the third field\n-    /// is None).\n+    /// A `PatKind::Ident` may either be a new bound variable,\n+    /// or a unit struct/variant pattern, or a const pattern (in the last two cases\n+    /// the third field must be `None`).\n     ///\n-    /// In the nullary enum case, the parser can't determine\n+    /// In the unit or const pattern case, the parser can't determine\n     /// which it is. The resolver determines this, and\n-    /// records this pattern's NodeId in an auxiliary\n-    /// set (of \"PatIdents that refer to nullary enums\")\n-    PatIdent(BindingMode, Spanned<Ident>, Option<P<Pat>>),\n+    /// records this pattern's `NodeId` in an auxiliary\n+    /// set (of \"PatIdents that refer to unit patterns or constants\").\n+    Ident(BindingMode, Spanned<Ident>, Option<P<Pat>>),\n \n+    /// A struct or struct variant pattern, e.g. `Variant {x, y, ..}`.\n+    /// The `bool` is `true` in the presence of a `..`.\n+    Struct(Path, HirVec<Spanned<FieldPat>>, bool),\n+\n+    /// A tuple struct/variant pattern `Variant(x, y, z)`.\n     /// \"None\" means a `Variant(..)` pattern where we don't bind the fields to names.\n-    PatEnum(Path, Option<HirVec<P<Pat>>>),\n+    TupleStruct(Path, Option<HirVec<P<Pat>>>),\n+\n+    /// A path pattern.\n+    /// Such pattern can be resolved to a unit struct/variant or a constant.\n+    Path(Path),\n \n     /// An associated const named using the qualified path `<T>::CONST` or\n     /// `<T as Trait>::CONST`. Associated consts from inherent impls can be\n     /// referred to as simply `T::CONST`, in which case they will end up as\n-    /// PatEnum, and the resolver will have to sort that out.\n-    PatQPath(QSelf, Path),\n+    /// PatKind::Path, and the resolver will have to sort that out.\n+    QPath(QSelf, Path),\n \n-    /// Destructuring of a struct, e.g. `Foo {x, y, ..}`\n-    /// The `bool` is `true` in the presence of a `..`\n-    PatStruct(Path, HirVec<Spanned<FieldPat>>, bool),\n     /// A tuple pattern `(a, b)`\n-    PatTup(HirVec<P<Pat>>),\n+    Tup(HirVec<P<Pat>>),\n     /// A `box` pattern\n-    PatBox(P<Pat>),\n+    Box(P<Pat>),\n     /// A reference pattern, e.g. `&mut (a, b)`\n-    PatRegion(P<Pat>, Mutability),\n+    Ref(P<Pat>, Mutability),\n     /// A literal\n-    PatLit(P<Expr>),\n+    Lit(P<Expr>),\n     /// A range pattern, e.g. `1...2`\n-    PatRange(P<Expr>, P<Expr>),\n+    Range(P<Expr>, P<Expr>),\n     /// `[a, b, ..i, y, z]` is represented as:\n-    ///     `PatVec(box [a, b], Some(i), box [y, z])`\n-    PatVec(HirVec<P<Pat>>, Option<P<Pat>>, HirVec<P<Pat>>),\n+    ///     `PatKind::Vec(box [a, b], Some(i), box [y, z])`\n+    Vec(HirVec<P<Pat>>, Option<P<Pat>>, HirVec<P<Pat>>),\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n@@ -1015,7 +1020,7 @@ impl Arg {\n             }),\n             pat: P(Pat {\n                 id: DUMMY_NODE_ID,\n-                node: PatIdent(BindByValue(mutability), path, None),\n+                node: PatKind::Ident(BindByValue(mutability), path, None),\n                 span: span,\n             }),\n             id: DUMMY_NODE_ID,"}, {"sha": "c1bcaab9d6819721914099417aadeb974dc180ec", "filename": "src/librustc_front/intravisit.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5/src%2Flibrustc_front%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5/src%2Flibrustc_front%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Fintravisit.rs?ref=0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5", "patch": "@@ -468,41 +468,44 @@ pub fn walk_assoc_type_binding<'v, V: Visitor<'v>>(visitor: &mut V,\n \n pub fn walk_pat<'v, V: Visitor<'v>>(visitor: &mut V, pattern: &'v Pat) {\n     match pattern.node {\n-        PatEnum(ref path, ref opt_children) => {\n+        PatKind::TupleStruct(ref path, ref opt_children) => {\n             visitor.visit_path(path, pattern.id);\n             if let Some(ref children) = *opt_children {\n                 walk_list!(visitor, visit_pat, children);\n             }\n         }\n-        PatQPath(ref qself, ref path) => {\n+        PatKind::Path(ref path) => {\n+            visitor.visit_path(path, pattern.id);\n+        }\n+        PatKind::QPath(ref qself, ref path) => {\n             visitor.visit_ty(&qself.ty);\n             visitor.visit_path(path, pattern.id)\n         }\n-        PatStruct(ref path, ref fields, _) => {\n+        PatKind::Struct(ref path, ref fields, _) => {\n             visitor.visit_path(path, pattern.id);\n             for field in fields {\n                 visitor.visit_name(field.span, field.node.name);\n                 visitor.visit_pat(&field.node.pat)\n             }\n         }\n-        PatTup(ref tuple_elements) => {\n+        PatKind::Tup(ref tuple_elements) => {\n             walk_list!(visitor, visit_pat, tuple_elements);\n         }\n-        PatBox(ref subpattern) |\n-        PatRegion(ref subpattern, _) => {\n+        PatKind::Box(ref subpattern) |\n+        PatKind::Ref(ref subpattern, _) => {\n             visitor.visit_pat(subpattern)\n         }\n-        PatIdent(_, ref pth1, ref optional_subpattern) => {\n+        PatKind::Ident(_, ref pth1, ref optional_subpattern) => {\n             visitor.visit_ident(pth1.span, pth1.node);\n             walk_list!(visitor, visit_pat, optional_subpattern);\n         }\n-        PatLit(ref expression) => visitor.visit_expr(expression),\n-        PatRange(ref lower_bound, ref upper_bound) => {\n+        PatKind::Lit(ref expression) => visitor.visit_expr(expression),\n+        PatKind::Range(ref lower_bound, ref upper_bound) => {\n             visitor.visit_expr(lower_bound);\n             visitor.visit_expr(upper_bound)\n         }\n-        PatWild => (),\n-        PatVec(ref prepatterns, ref slice_pattern, ref postpatterns) => {\n+        PatKind::Wild => (),\n+        PatKind::Vec(ref prepatterns, ref slice_pattern, ref postpatterns) => {\n             walk_list!(visitor, visit_pat, prepatterns);\n             walk_list!(visitor, visit_pat, slice_pattern);\n             walk_list!(visitor, visit_pat, postpatterns);"}, {"sha": "0e7d9db37fdb8fd663b76ccd62bf1302cfda77cf", "filename": "src/librustc_front/lowering.rs", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5/src%2Flibrustc_front%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5/src%2Flibrustc_front%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Flowering.rs?ref=0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5", "patch": "@@ -913,27 +913,27 @@ pub fn lower_pat(lctx: &LoweringContext, p: &Pat) -> P<hir::Pat> {\n     P(hir::Pat {\n         id: p.id,\n         node: match p.node {\n-            PatKind::Wild => hir::PatWild,\n+            PatKind::Wild => hir::PatKind::Wild,\n             PatKind::Ident(ref binding_mode, pth1, ref sub) => {\n-                hir::PatIdent(lower_binding_mode(lctx, binding_mode),\n+                hir::PatKind::Ident(lower_binding_mode(lctx, binding_mode),\n                               respan(pth1.span, lower_ident(lctx, pth1.node)),\n                               sub.as_ref().map(|x| lower_pat(lctx, x)))\n             }\n-            PatKind::Lit(ref e) => hir::PatLit(lower_expr(lctx, e)),\n+            PatKind::Lit(ref e) => hir::PatKind::Lit(lower_expr(lctx, e)),\n             PatKind::TupleStruct(ref pth, ref pats) => {\n-                hir::PatEnum(lower_path(lctx, pth),\n+                hir::PatKind::TupleStruct(lower_path(lctx, pth),\n                              pats.as_ref()\n                                  .map(|pats| pats.iter().map(|x| lower_pat(lctx, x)).collect()))\n             }\n             PatKind::Path(ref pth) => {\n-                hir::PatEnum(lower_path(lctx, pth), Some(hir::HirVec::new()))\n+                hir::PatKind::Path(lower_path(lctx, pth))\n             }\n             PatKind::QPath(ref qself, ref pth) => {\n                 let qself = hir::QSelf {\n                     ty: lower_ty(lctx, &qself.ty),\n                     position: qself.position,\n                 };\n-                hir::PatQPath(qself, lower_path(lctx, pth))\n+                hir::PatKind::QPath(qself, lower_path(lctx, pth))\n             }\n             PatKind::Struct(ref pth, ref fields, etc) => {\n                 let pth = lower_path(lctx, pth);\n@@ -949,20 +949,20 @@ pub fn lower_pat(lctx: &LoweringContext, p: &Pat) -> P<hir::Pat> {\n                                    }\n                                })\n                                .collect();\n-                hir::PatStruct(pth, fs, etc)\n+                hir::PatKind::Struct(pth, fs, etc)\n             }\n             PatKind::Tup(ref elts) => {\n-                hir::PatTup(elts.iter().map(|x| lower_pat(lctx, x)).collect())\n+                hir::PatKind::Tup(elts.iter().map(|x| lower_pat(lctx, x)).collect())\n             }\n-            PatKind::Box(ref inner) => hir::PatBox(lower_pat(lctx, inner)),\n+            PatKind::Box(ref inner) => hir::PatKind::Box(lower_pat(lctx, inner)),\n             PatKind::Ref(ref inner, mutbl) => {\n-                hir::PatRegion(lower_pat(lctx, inner), lower_mutability(lctx, mutbl))\n+                hir::PatKind::Ref(lower_pat(lctx, inner), lower_mutability(lctx, mutbl))\n             }\n             PatKind::Range(ref e1, ref e2) => {\n-                hir::PatRange(lower_expr(lctx, e1), lower_expr(lctx, e2))\n+                hir::PatKind::Range(lower_expr(lctx, e1), lower_expr(lctx, e2))\n             }\n             PatKind::Vec(ref before, ref slice, ref after) => {\n-                hir::PatVec(before.iter().map(|x| lower_pat(lctx, x)).collect(),\n+                hir::PatKind::Vec(before.iter().map(|x| lower_pat(lctx, x)).collect(),\n                             slice.as_ref().map(|x| lower_pat(lctx, x)),\n                             after.iter().map(|x| lower_pat(lctx, x)).collect())\n             }\n@@ -1750,7 +1750,11 @@ fn pat_enum(lctx: &LoweringContext,\n             path: hir::Path,\n             subpats: hir::HirVec<P<hir::Pat>>)\n             -> P<hir::Pat> {\n-    let pt = hir::PatEnum(path, Some(subpats));\n+    let pt = if subpats.is_empty() {\n+        hir::PatKind::Path(path)\n+    } else {\n+        hir::PatKind::TupleStruct(path, Some(subpats))\n+    };\n     pat(lctx, span, pt)\n }\n \n@@ -1763,7 +1767,7 @@ fn pat_ident_binding_mode(lctx: &LoweringContext,\n                           ident: hir::Ident,\n                           bm: hir::BindingMode)\n                           -> P<hir::Pat> {\n-    let pat_ident = hir::PatIdent(bm,\n+    let pat_ident = hir::PatKind::Ident(bm,\n                                   Spanned {\n                                       span: span,\n                                       node: ident,\n@@ -1773,10 +1777,10 @@ fn pat_ident_binding_mode(lctx: &LoweringContext,\n }\n \n fn pat_wild(lctx: &LoweringContext, span: Span) -> P<hir::Pat> {\n-    pat(lctx, span, hir::PatWild)\n+    pat(lctx, span, hir::PatKind::Wild)\n }\n \n-fn pat(lctx: &LoweringContext, span: Span, pat: hir::Pat_) -> P<hir::Pat> {\n+fn pat(lctx: &LoweringContext, span: Span, pat: hir::PatKind) -> P<hir::Pat> {\n     P(hir::Pat {\n         id: lctx.next_id(),\n         node: pat,"}, {"sha": "d837ab0f8f6cbb89a73123381b09c3daa54ba04a", "filename": "src/librustc_front/print/pprust.rs", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5/src%2Flibrustc_front%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5/src%2Flibrustc_front%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Fprint%2Fpprust.rs?ref=0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5", "patch": "@@ -24,7 +24,7 @@ use syntax::print::pprust::{self as ast_pp, PrintState};\n use syntax::ptr::P;\n \n use hir;\n-use hir::{Crate, RegionTyParamBound, TraitTyParamBound, TraitBoundModifier};\n+use hir::{Crate, PatKind, RegionTyParamBound, TraitTyParamBound, TraitBoundModifier};\n \n use std::io::{self, Write, Read};\n \n@@ -1727,8 +1727,8 @@ impl<'a> State<'a> {\n         // Pat isn't normalized, but the beauty of it\n         // is that it doesn't matter\n         match pat.node {\n-            hir::PatWild => try!(word(&mut self.s, \"_\")),\n-            hir::PatIdent(binding_mode, ref path1, ref sub) => {\n+            PatKind::Wild => try!(word(&mut self.s, \"_\")),\n+            PatKind::Ident(binding_mode, ref path1, ref sub) => {\n                 match binding_mode {\n                     hir::BindByRef(mutbl) => {\n                         try!(self.word_nbsp(\"ref\"));\n@@ -1748,23 +1748,24 @@ impl<'a> State<'a> {\n                     None => (),\n                 }\n             }\n-            hir::PatEnum(ref path, ref args_) => {\n+            PatKind::TupleStruct(ref path, ref args_) => {\n                 try!(self.print_path(path, true, 0));\n                 match *args_ {\n                     None => try!(word(&mut self.s, \"(..)\")),\n                     Some(ref args) => {\n-                        if !args.is_empty() {\n-                            try!(self.popen());\n-                            try!(self.commasep(Inconsistent, &args[..], |s, p| s.print_pat(&p)));\n-                            try!(self.pclose());\n-                        }\n+                        try!(self.popen());\n+                        try!(self.commasep(Inconsistent, &args[..], |s, p| s.print_pat(&p)));\n+                        try!(self.pclose());\n                     }\n                 }\n             }\n-            hir::PatQPath(ref qself, ref path) => {\n+            PatKind::Path(ref path) => {\n+                try!(self.print_path(path, true, 0));\n+            }\n+            PatKind::QPath(ref qself, ref path) => {\n                 try!(self.print_qpath(path, qself, false));\n             }\n-            hir::PatStruct(ref path, ref fields, etc) => {\n+            PatKind::Struct(ref path, ref fields, etc) => {\n                 try!(self.print_path(path, true, 0));\n                 try!(self.nbsp());\n                 try!(self.word_space(\"{\"));\n@@ -1789,40 +1790,40 @@ impl<'a> State<'a> {\n                 try!(space(&mut self.s));\n                 try!(word(&mut self.s, \"}\"));\n             }\n-            hir::PatTup(ref elts) => {\n+            PatKind::Tup(ref elts) => {\n                 try!(self.popen());\n                 try!(self.commasep(Inconsistent, &elts[..], |s, p| s.print_pat(&p)));\n                 if elts.len() == 1 {\n                     try!(word(&mut self.s, \",\"));\n                 }\n                 try!(self.pclose());\n             }\n-            hir::PatBox(ref inner) => {\n+            PatKind::Box(ref inner) => {\n                 try!(word(&mut self.s, \"box \"));\n                 try!(self.print_pat(&inner));\n             }\n-            hir::PatRegion(ref inner, mutbl) => {\n+            PatKind::Ref(ref inner, mutbl) => {\n                 try!(word(&mut self.s, \"&\"));\n                 if mutbl == hir::MutMutable {\n                     try!(word(&mut self.s, \"mut \"));\n                 }\n                 try!(self.print_pat(&inner));\n             }\n-            hir::PatLit(ref e) => try!(self.print_expr(&e)),\n-            hir::PatRange(ref begin, ref end) => {\n+            PatKind::Lit(ref e) => try!(self.print_expr(&e)),\n+            PatKind::Range(ref begin, ref end) => {\n                 try!(self.print_expr(&begin));\n                 try!(space(&mut self.s));\n                 try!(word(&mut self.s, \"...\"));\n                 try!(self.print_expr(&end));\n             }\n-            hir::PatVec(ref before, ref slice, ref after) => {\n+            PatKind::Vec(ref before, ref slice, ref after) => {\n                 try!(word(&mut self.s, \"[\"));\n                 try!(self.commasep(Inconsistent, &before[..], |s, p| s.print_pat(&p)));\n                 if let Some(ref p) = *slice {\n                     if !before.is_empty() {\n                         try!(self.word_space(\",\"));\n                     }\n-                    if p.node != hir::PatWild {\n+                    if p.node != PatKind::Wild {\n                         try!(self.print_pat(&p));\n                     }\n                     try!(word(&mut self.s, \"..\"));\n@@ -1945,7 +1946,7 @@ impl<'a> State<'a> {\n             let m = match explicit_self {\n                 &hir::SelfStatic => hir::MutImmutable,\n                 _ => match decl.inputs[0].pat.node {\n-                    hir::PatIdent(hir::BindByValue(m), _, _) => m,\n+                    PatKind::Ident(hir::BindByValue(m), _, _) => m,\n                     _ => hir::MutImmutable,\n                 },\n             };\n@@ -2210,7 +2211,7 @@ impl<'a> State<'a> {\n             hir::TyInfer if is_closure => try!(self.print_pat(&input.pat)),\n             _ => {\n                 match input.pat.node {\n-                    hir::PatIdent(_, ref path1, _) if\n+                    PatKind::Ident(_, ref path1, _) if\n                         path1.node.name ==\n                             parse::token::special_idents::invalid.name => {\n                         // Do nothing."}, {"sha": "8140ea1f167d851d0782c5977cdc65f315daa6bc", "filename": "src/librustc_front/util.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5/src%2Flibrustc_front%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5/src%2Flibrustc_front%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Futil.rs?ref=0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5", "patch": "@@ -28,27 +28,28 @@ pub fn walk_pat<F>(pat: &Pat, mut it: F) -> bool\n         }\n \n         match pat.node {\n-            PatIdent(_, _, Some(ref p)) => walk_pat_(&p, it),\n-            PatStruct(_, ref fields, _) => {\n+            PatKind::Ident(_, _, Some(ref p)) => walk_pat_(&p, it),\n+            PatKind::Struct(_, ref fields, _) => {\n                 fields.iter().all(|field| walk_pat_(&field.node.pat, it))\n             }\n-            PatEnum(_, Some(ref s)) | PatTup(ref s) => {\n+            PatKind::TupleStruct(_, Some(ref s)) | PatKind::Tup(ref s) => {\n                 s.iter().all(|p| walk_pat_(&p, it))\n             }\n-            PatBox(ref s) | PatRegion(ref s, _) => {\n+            PatKind::Box(ref s) | PatKind::Ref(ref s, _) => {\n                 walk_pat_(&s, it)\n             }\n-            PatVec(ref before, ref slice, ref after) => {\n+            PatKind::Vec(ref before, ref slice, ref after) => {\n                 before.iter().all(|p| walk_pat_(&p, it)) &&\n                 slice.iter().all(|p| walk_pat_(&p, it)) &&\n                 after.iter().all(|p| walk_pat_(&p, it))\n             }\n-            PatWild |\n-            PatLit(_) |\n-            PatRange(_, _) |\n-            PatIdent(_, _, _) |\n-            PatEnum(_, _) |\n-            PatQPath(_, _) => {\n+            PatKind::Wild |\n+            PatKind::Lit(_) |\n+            PatKind::Range(_, _) |\n+            PatKind::Ident(_, _, _) |\n+            PatKind::TupleStruct(..) |\n+            PatKind::Path(..) |\n+            PatKind::QPath(_, _) => {\n                 true\n             }\n         }"}, {"sha": "16ef6e001ddbd867c4ae6c7d75762d2729fd47b2", "filename": "src/librustc_lint/bad_style.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5/src%2Flibrustc_lint%2Fbad_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5/src%2Flibrustc_lint%2Fbad_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbad_style.rs?ref=0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5", "patch": "@@ -17,7 +17,7 @@ use syntax::ast;\n use syntax::attr::{self, AttrMetaMethods};\n use syntax::codemap::Span;\n \n-use rustc_front::hir;\n+use rustc_front::hir::{self, PatKind};\n use rustc_front::intravisit::FnKind;\n \n #[derive(PartialEq)]\n@@ -272,7 +272,7 @@ impl LateLintPass for NonSnakeCase {\n     }\n \n     fn check_pat(&mut self, cx: &LateContext, p: &hir::Pat) {\n-        if let &hir::PatIdent(_, ref path1, _) = &p.node {\n+        if let &PatKind::Ident(_, ref path1, _) = &p.node {\n             let def = cx.tcx.def_map.borrow().get(&p.id).map(|d| d.full_def());\n             if let Some(Def::Local(..)) = def {\n                 self.check_snake_case(cx, \"variable\", &path1.node.name.as_str(), Some(p.span));\n@@ -362,7 +362,7 @@ impl LateLintPass for NonUpperCaseGlobals {\n     fn check_pat(&mut self, cx: &LateContext, p: &hir::Pat) {\n         // Lint for constants that look like binding identifiers (#7526)\n         match (&p.node, cx.tcx.def_map.borrow().get(&p.id).map(|d| d.full_def())) {\n-            (&hir::PatIdent(_, ref path1, _), Some(Def::Const(..))) => {\n+            (&PatKind::Ident(_, ref path1, _), Some(Def::Const(..))) => {\n                 NonUpperCaseGlobals::check_upper_case(cx, \"constant in pattern\",\n                                                       path1.node.name, p.span);\n             }"}, {"sha": "2780baa6de3fd72109adcb7a28aaa410ee030284", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5", "patch": "@@ -46,7 +46,7 @@ use syntax::{ast};\n use syntax::attr::{self, AttrMetaMethods};\n use syntax::codemap::{self, Span};\n \n-use rustc_front::hir;\n+use rustc_front::hir::{self, PatKind};\n use rustc_front::intravisit::FnKind;\n \n use bad_style::{MethodLateContext, method_context};\n@@ -157,7 +157,7 @@ impl LintPass for NonShorthandFieldPatterns {\n impl LateLintPass for NonShorthandFieldPatterns {\n     fn check_pat(&mut self, cx: &LateContext, pat: &hir::Pat) {\n         let def_map = cx.tcx.def_map.borrow();\n-        if let hir::PatStruct(_, ref v, _) = pat.node {\n+        if let PatKind::Struct(_, ref v, _) = pat.node {\n             let field_pats = v.iter().filter(|fieldpat| {\n                 if fieldpat.node.is_shorthand {\n                     return false;\n@@ -170,7 +170,7 @@ impl LateLintPass for NonShorthandFieldPatterns {\n                 }\n             });\n             for fieldpat in field_pats {\n-                if let hir::PatIdent(_, ident, None) = fieldpat.node.pat.node {\n+                if let PatKind::Ident(_, ident, None) = fieldpat.node.pat.node {\n                     if ident.node.unhygienic_name == fieldpat.node.name {\n                         cx.span_lint(NON_SHORTHAND_FIELD_PATTERNS, fieldpat.span,\n                                      &format!(\"the `{}:` in this pattern is redundant and can \\"}, {"sha": "d707c61cbb44079257859a40da4f1789d5896598", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5", "patch": "@@ -50,7 +50,7 @@ use syntax::parse::token::special_idents;\n use syntax;\n use rbml::writer::Encoder;\n \n-use rustc_front::hir;\n+use rustc_front::hir::{self, PatKind};\n use rustc_front::intravisit::Visitor;\n use rustc_front::intravisit;\n \n@@ -783,7 +783,7 @@ fn encode_method_argument_names(rbml_w: &mut Encoder,\n     rbml_w.start_tag(tag_method_argument_names);\n     for arg in &decl.inputs {\n         let tag = tag_method_argument_name;\n-        if let hir::PatIdent(_, ref path1, _) = arg.pat.node {\n+        if let PatKind::Ident(_, ref path1, _) = arg.pat.node {\n             let name = path1.node.name.as_str();\n             rbml_w.wr_tagged_bytes(tag, name.as_bytes());\n         } else {"}, {"sha": "c5b34d9246694a3ac30e0a321e4d2f6a313bdbbd", "filename": "src/librustc_mir/hair/cx/pattern.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs?ref=0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5", "patch": "@@ -16,7 +16,7 @@ use rustc::middle::def::Def;\n use rustc::middle::pat_util::{pat_is_resolved_const, pat_is_binding};\n use rustc::middle::ty::{self, Ty};\n use rustc::mir::repr::*;\n-use rustc_front::hir;\n+use rustc_front::hir::{self, PatKind};\n use syntax::ast;\n use syntax::codemap::Span;\n use syntax::ptr::P;\n@@ -64,22 +64,22 @@ impl<'patcx, 'cx, 'tcx> PatCx<'patcx, 'cx, 'tcx> {\n \n     fn to_pattern(&mut self, pat: &hir::Pat) -> Pattern<'tcx> {\n         let kind = match pat.node {\n-            hir::PatWild => PatternKind::Wild,\n+            PatKind::Wild => PatternKind::Wild,\n \n-            hir::PatLit(ref value) => {\n+            PatKind::Lit(ref value) => {\n                 let value = const_eval::eval_const_expr(self.cx.tcx, value);\n                 PatternKind::Constant { value: value }\n             }\n \n-            hir::PatRange(ref lo, ref hi) => {\n+            PatKind::Range(ref lo, ref hi) => {\n                 let lo = const_eval::eval_const_expr(self.cx.tcx, lo);\n                 let lo = Literal::Value { value: lo };\n                 let hi = const_eval::eval_const_expr(self.cx.tcx, hi);\n                 let hi = Literal::Value { value: hi };\n                 PatternKind::Range { lo: lo, hi: hi }\n             },\n \n-            hir::PatEnum(..) | hir::PatIdent(..) | hir::PatQPath(..)\n+            PatKind::Path(..) | PatKind::Ident(..) | PatKind::QPath(..)\n                 if pat_is_resolved_const(&self.cx.tcx.def_map.borrow(), pat) =>\n             {\n                 let def = self.cx.tcx.def_map.borrow().get(&pat.id).unwrap().full_def();\n@@ -105,12 +105,12 @@ impl<'patcx, 'cx, 'tcx> PatCx<'patcx, 'cx, 'tcx> {\n                 }\n             }\n \n-            hir::PatRegion(ref subpattern, _) |\n-            hir::PatBox(ref subpattern) => {\n+            PatKind::Ref(ref subpattern, _) |\n+            PatKind::Box(ref subpattern) => {\n                 PatternKind::Deref { subpattern: self.to_pattern(subpattern) }\n             }\n \n-            hir::PatVec(ref prefix, ref slice, ref suffix) => {\n+            PatKind::Vec(ref prefix, ref slice, ref suffix) => {\n                 let ty = self.cx.tcx.node_id_to_type(pat.id);\n                 match ty.sty {\n                     ty::TyRef(_, mt) =>\n@@ -134,7 +134,7 @@ impl<'patcx, 'cx, 'tcx> PatCx<'patcx, 'cx, 'tcx> {\n                 }\n             }\n \n-            hir::PatTup(ref subpatterns) => {\n+            PatKind::Tup(ref subpatterns) => {\n                 let subpatterns =\n                     subpatterns.iter()\n                                .enumerate()\n@@ -147,7 +147,7 @@ impl<'patcx, 'cx, 'tcx> PatCx<'patcx, 'cx, 'tcx> {\n                 PatternKind::Leaf { subpatterns: subpatterns }\n             }\n \n-            hir::PatIdent(bm, ref ident, ref sub)\n+            PatKind::Ident(bm, ref ident, ref sub)\n                 if pat_is_binding(&self.cx.tcx.def_map.borrow(), pat) =>\n             {\n                 let id = match self.binding_map {\n@@ -179,11 +179,11 @@ impl<'patcx, 'cx, 'tcx> PatCx<'patcx, 'cx, 'tcx> {\n                 }\n             }\n \n-            hir::PatIdent(..) => {\n+            PatKind::Ident(..) | PatKind::Path(..) => {\n                 self.variant_or_leaf(pat, vec![])\n             }\n \n-            hir::PatEnum(_, ref opt_subpatterns) => {\n+            PatKind::TupleStruct(_, ref opt_subpatterns) => {\n                 let subpatterns =\n                     opt_subpatterns.iter()\n                                    .flat_map(|v| v.iter())\n@@ -196,7 +196,7 @@ impl<'patcx, 'cx, 'tcx> PatCx<'patcx, 'cx, 'tcx> {\n                 self.variant_or_leaf(pat, subpatterns)\n             }\n \n-            hir::PatStruct(_, ref fields, _) => {\n+            PatKind::Struct(_, ref fields, _) => {\n                 let pat_ty = self.cx.tcx.node_id_to_type(pat.id);\n                 let adt_def = match pat_ty.sty {\n                     ty::TyStruct(adt_def, _) | ty::TyEnum(adt_def, _) => adt_def,\n@@ -229,7 +229,7 @@ impl<'patcx, 'cx, 'tcx> PatCx<'patcx, 'cx, 'tcx> {\n                 self.variant_or_leaf(pat, subpatterns)\n             }\n \n-            hir::PatQPath(..) => {\n+            PatKind::QPath(..) => {\n                 self.cx.tcx.sess.span_bug(pat.span, \"unexpanded macro or bad constant etc\");\n             }\n         };"}, {"sha": "ee6003f713e7b814b3806af1a3f4b0b7e9916b00", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5", "patch": "@@ -41,7 +41,7 @@ use rustc::util::nodemap::NodeMap;\n use rustc::middle::const_qualif::ConstQualif;\n use rustc::lint::builtin::CONST_ERR;\n \n-use rustc_front::hir;\n+use rustc_front::hir::{self, PatKind};\n use syntax::ast;\n use syntax::codemap::Span;\n use syntax::feature_gate::UnstableFeatures;\n@@ -322,10 +322,10 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n \n     fn visit_pat(&mut self, p: &hir::Pat) {\n         match p.node {\n-            hir::PatLit(ref lit) => {\n+            PatKind::Lit(ref lit) => {\n                 self.global_expr(Mode::Const, &lit);\n             }\n-            hir::PatRange(ref start, ref end) => {\n+            PatKind::Range(ref start, ref end) => {\n                 self.global_expr(Mode::Const, &start);\n                 self.global_expr(Mode::Const, &end);\n "}, {"sha": "1424616e792f64ddaa732d7bd09696e938967d10", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5", "patch": "@@ -33,7 +33,7 @@ use self::FieldName::*;\n use std::cmp;\n use std::mem::replace;\n \n-use rustc_front::hir;\n+use rustc_front::hir::{self, PatKind};\n use rustc_front::intravisit::{self, Visitor};\n \n use rustc::dep_graph::DepNode;\n@@ -920,7 +920,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n         if self.in_foreign { return }\n \n         match pattern.node {\n-            hir::PatStruct(_, ref fields, _) => {\n+            PatKind::Struct(_, ref fields, _) => {\n                 let adt = self.tcx.pat_ty(pattern).ty_adt_def().unwrap();\n                 let def = self.tcx.def_map.borrow().get(&pattern.id).unwrap().full_def();\n                 let variant = adt.variant_of_def(def);\n@@ -932,11 +932,11 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n \n             // Patterns which bind no fields are allowable (the path is check\n             // elsewhere).\n-            hir::PatEnum(_, Some(ref fields)) => {\n+            PatKind::TupleStruct(_, Some(ref fields)) => {\n                 match self.tcx.pat_ty(pattern).sty {\n                     ty::TyStruct(def, _) => {\n                         for (i, field) in fields.iter().enumerate() {\n-                            if let hir::PatWild = field.node {\n+                            if let PatKind::Wild = field.node {\n                                 continue\n                             }\n                             self.check_field(field.span,"}, {"sha": "49040a4c732e79c1c0c0b43345a46905e337e90d", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 12, "deletions": 16, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5", "patch": "@@ -80,8 +80,7 @@ use rustc_front::hir::{ImplItem, Item, ItemConst, ItemEnum, ItemExternCrate};\n use rustc_front::hir::{ItemFn, ItemForeignMod, ItemImpl, ItemMod, ItemStatic, ItemDefaultImpl};\n use rustc_front::hir::{ItemStruct, ItemTrait, ItemTy, ItemUse};\n use rustc_front::hir::Local;\n-use rustc_front::hir::{Pat, PatEnum, PatIdent, PatLit, PatQPath};\n-use rustc_front::hir::{PatRange, PatStruct, Path, PrimTy};\n+use rustc_front::hir::{Pat, PatKind, Path, PrimTy};\n use rustc_front::hir::{TraitRef, Ty, TyBool, TyChar, TyFloat, TyInt};\n use rustc_front::hir::{TyRptr, TyStr, TyUint, TyPath, TyPtr};\n use rustc_front::util::walk_pat;\n@@ -2323,8 +2322,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let pat_id = pattern.id;\n         walk_pat(pattern, |pattern| {\n             match pattern.node {\n-                PatIdent(binding_mode, ref path1, ref at_rhs) => {\n-                    // The meaning of PatIdent with no type parameters\n+                PatKind::Ident(binding_mode, ref path1, ref at_rhs) => {\n+                    // The meaning of PatKind::Ident with no type parameters\n                     // depends on whether an enum variant or unit-like struct\n                     // with that name is in scope. The probing lookup has to\n                     // be careful not to emit spurious errors. Only matching\n@@ -2435,24 +2434,21 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     }\n                 }\n \n-                PatEnum(ref path, _) => {\n+                PatKind::TupleStruct(ref path, _) | PatKind::Path(ref path) => {\n                     // This must be an enum variant, struct or const.\n                     let resolution = match self.resolve_possibly_assoc_item(pat_id,\n                                                                             None,\n                                                                             path,\n                                                                             ValueNS,\n                                                                             false) {\n                         // The below shouldn't happen because all\n-                        // qualified paths should be in PatQPath.\n+                        // qualified paths should be in PatKind::QPath.\n                         TypecheckRequired =>\n                             self.session.span_bug(path.span,\n-                                                  \"resolve_possibly_assoc_item claimed\n-                                     \\\n-                                                   that a path in PatEnum requires typecheck\n-                                     \\\n-                                                   to resolve, but qualified paths should be\n-                                     \\\n-                                                   PatQPath\"),\n+                                                  \"resolve_possibly_assoc_item claimed that a path \\\n+                                                   in PatKind::Path or PatKind::TupleStruct \\\n+                                                   requires typecheck to resolve, but qualified \\\n+                                                   paths should be PatKind::QPath\"),\n                         ResolveAttempt(resolution) => resolution,\n                     };\n                     if let Some(path_res) = resolution {\n@@ -2511,7 +2507,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     intravisit::walk_path(self, path);\n                 }\n \n-                PatQPath(ref qself, ref path) => {\n+                PatKind::QPath(ref qself, ref path) => {\n                     // Associated constants only.\n                     let resolution = match self.resolve_possibly_assoc_item(pat_id,\n                                                                             Some(qself),\n@@ -2566,7 +2562,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     intravisit::walk_pat(self, pattern);\n                 }\n \n-                PatStruct(ref path, _, _) => {\n+                PatKind::Struct(ref path, _, _) => {\n                     match self.resolve_path(pat_id, path, 0, TypeNS, false) {\n                         Some(definition) => {\n                             self.record_def(pattern.id, definition);\n@@ -2585,7 +2581,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     intravisit::walk_path(self, path);\n                 }\n \n-                PatLit(_) | PatRange(..) => {\n+                PatKind::Lit(_) | PatKind::Range(..) => {\n                     intravisit::walk_pat(self, pattern);\n                 }\n "}, {"sha": "c5efc9b7e228646dde4dcfbc9a1e24af451f5810", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 34, "deletions": 38, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5", "patch": "@@ -227,7 +227,7 @@ use std::cell::RefCell;\n use std::cmp::Ordering;\n use std::fmt;\n use std::rc::Rc;\n-use rustc_front::hir;\n+use rustc_front::hir::{self, PatKind};\n use syntax::ast::{self, DUMMY_NODE_ID, NodeId};\n use syntax::codemap::Span;\n use rustc_front::fold::Folder;\n@@ -424,7 +424,7 @@ impl<'a, 'p, 'blk, 'tcx> fmt::Debug for Match<'a, 'p, 'blk, 'tcx> {\n fn has_nested_bindings(m: &[Match], col: usize) -> bool {\n     for br in m {\n         match br.pats[col].node {\n-            hir::PatIdent(_, _, Some(_)) => return true,\n+            PatKind::Ident(_, _, Some(_)) => return true,\n             _ => ()\n         }\n     }\n@@ -477,7 +477,7 @@ fn expand_nested_bindings<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         let mut pat = br.pats[col];\n         loop {\n             pat = match pat.node {\n-                hir::PatIdent(_, ref path, Some(ref inner)) => {\n+                PatKind::Ident(_, ref path, Some(ref inner)) => {\n                     bound_ptrs.push((path.node.name, val.val));\n                     &inner\n                 },\n@@ -517,13 +517,13 @@ fn enter_match<'a, 'b, 'p, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n             let this = br.pats[col];\n             let mut bound_ptrs = br.bound_ptrs.clone();\n             match this.node {\n-                hir::PatIdent(_, ref path, None) => {\n+                PatKind::Ident(_, ref path, None) => {\n                     if pat_is_binding(&dm.borrow(), &this) {\n                         bound_ptrs.push((path.node.name, val.val));\n                     }\n                 }\n-                hir::PatVec(ref before, Some(ref slice), ref after) => {\n-                    if let hir::PatIdent(_, ref path, None) = slice.node {\n+                PatKind::Vec(ref before, Some(ref slice), ref after) => {\n+                    if let PatKind::Ident(_, ref path, None) = slice.node {\n                         let subslice_val = bind_subslice_pat(\n                             bcx, this.id, val,\n                             before.len(), after.len());\n@@ -662,10 +662,11 @@ fn get_branches<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         };\n \n         let opt = match cur.node {\n-            hir::PatLit(ref l) => {\n+            PatKind::Lit(ref l) => {\n                 ConstantValue(ConstantExpr(&l), debug_loc)\n             }\n-            hir::PatIdent(..) | hir::PatEnum(..) | hir::PatStruct(..) => {\n+            PatKind::Ident(..) | PatKind::Path(..) |\n+            PatKind::TupleStruct(..) | PatKind::Struct(..) => {\n                 // This is either an enum variant or a variable binding.\n                 let opt_def = tcx.def_map.borrow().get(&cur.id).map(|d| d.full_def());\n                 match opt_def {\n@@ -679,13 +680,13 @@ fn get_branches<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                     _ => continue\n                 }\n             }\n-            hir::PatRange(ref l1, ref l2) => {\n+            PatKind::Range(ref l1, ref l2) => {\n                 ConstantRange(ConstantExpr(&l1), ConstantExpr(&l2), debug_loc)\n             }\n-            hir::PatVec(ref before, None, ref after) => {\n+            PatKind::Vec(ref before, None, ref after) => {\n                 SliceLengthEqual(before.len() + after.len(), debug_loc)\n             }\n-            hir::PatVec(ref before, Some(_), ref after) => {\n+            PatKind::Vec(ref before, Some(_), ref after) => {\n                 SliceLengthGreaterOrEqual(before.len(), after.len(), debug_loc)\n             }\n             _ => continue\n@@ -786,28 +787,23 @@ macro_rules! any_pat {\n }\n \n fn any_uniq_pat(m: &[Match], col: usize) -> bool {\n-    any_pat!(m, col, hir::PatBox(_))\n+    any_pat!(m, col, PatKind::Box(_))\n }\n \n fn any_region_pat(m: &[Match], col: usize) -> bool {\n-    any_pat!(m, col, hir::PatRegion(..))\n+    any_pat!(m, col, PatKind::Ref(..))\n }\n \n fn any_irrefutable_adt_pat(tcx: &ty::ctxt, m: &[Match], col: usize) -> bool {\n     m.iter().any(|br| {\n         let pat = br.pats[col];\n         match pat.node {\n-            hir::PatTup(_) => true,\n-            hir::PatStruct(..) => {\n-                match tcx.def_map.borrow().get(&pat.id).map(|d| d.full_def()) {\n-                    Some(Def::Variant(..)) => false,\n-                    _ => true,\n-                }\n-            }\n-            hir::PatEnum(..) | hir::PatIdent(_, _, None) => {\n-                match tcx.def_map.borrow().get(&pat.id).map(|d| d.full_def()) {\n-                    Some(Def::Struct(..)) => true,\n-                    _ => false\n+            PatKind::Tup(_) => true,\n+            PatKind::Struct(..) | PatKind::TupleStruct(..) |\n+            PatKind::Path(..) | PatKind::Ident(_, _, None) => {\n+                match tcx.def_map.borrow().get(&pat.id).unwrap().full_def() {\n+                    Def::Struct(..) | Def::TyAlias(..) => true,\n+                    _ => false,\n                 }\n             }\n             _ => false\n@@ -849,7 +845,7 @@ impl FailureHandler {\n fn pick_column_to_specialize(def_map: &RefCell<DefMap>, m: &[Match]) -> Option<usize> {\n     fn pat_score(def_map: &RefCell<DefMap>, pat: &hir::Pat) -> usize {\n         match pat.node {\n-            hir::PatIdent(_, _, Some(ref inner)) => pat_score(def_map, &inner),\n+            PatKind::Ident(_, _, Some(ref inner)) => pat_score(def_map, &inner),\n             _ if pat_is_refutable(&def_map.borrow(), pat) => 1,\n             _ => 0\n         }\n@@ -871,7 +867,7 @@ fn pick_column_to_specialize(def_map: &RefCell<DefMap>, m: &[Match]) -> Option<u\n \n     let column_contains_any_nonwild_patterns = |&col: &usize| -> bool {\n         m.iter().any(|row| match row.pats[col].node {\n-            hir::PatWild => false,\n+            PatKind::Wild => false,\n             _ => true\n         })\n     };\n@@ -1639,7 +1635,7 @@ fn trans_match_inner<'blk, 'tcx>(scope_cx: Block<'blk, 'tcx>,\n     // to the default arm.\n     let has_default = arms.last().map_or(false, |arm| {\n         arm.pats.len() == 1\n-        && arm.pats.last().unwrap().node == hir::PatWild\n+        && arm.pats.last().unwrap().node == PatKind::Wild\n     });\n \n     compile_submatch(bcx, &matches[..], &[discr_datum.match_input()], &chk, has_default);\n@@ -1812,7 +1808,7 @@ pub fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let tcx = bcx.tcx();\n     let ccx = bcx.ccx();\n     match pat.node {\n-        hir::PatIdent(pat_binding_mode, ref path1, ref inner) => {\n+        PatKind::Ident(pat_binding_mode, ref path1, ref inner) => {\n             if pat_is_binding(&tcx.def_map.borrow(), &pat) {\n                 // Allocate the stack slot where the value of this\n                 // binding will live and place it into the appropriate\n@@ -1849,7 +1845,7 @@ pub fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 bcx = bind_irrefutable_pat(bcx, &inner_pat, val, cleanup_scope);\n             }\n         }\n-        hir::PatEnum(_, ref sub_pats) => {\n+        PatKind::TupleStruct(_, ref sub_pats) => {\n             let opt_def = bcx.tcx().def_map.borrow().get(&pat.id).map(|d| d.full_def());\n             match opt_def {\n                 Some(Def::Variant(enum_id, var_id)) => {\n@@ -1895,7 +1891,7 @@ pub fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 }\n             }\n         }\n-        hir::PatStruct(_, ref fields, _) => {\n+        PatKind::Struct(_, ref fields, _) => {\n             let tcx = bcx.tcx();\n             let pat_ty = node_id_type(bcx, pat.id);\n             let pat_repr = adt::represent_type(bcx.ccx(), pat_ty);\n@@ -1935,7 +1931,7 @@ pub fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                            cleanup_scope);\n             }\n         }\n-        hir::PatTup(ref elems) => {\n+        PatKind::Tup(ref elems) => {\n             let repr = adt::represent_node(bcx, pat.id);\n             let val = adt::MaybeSizedValue::sized(val.val);\n             for (i, elem) in elems.iter().enumerate() {\n@@ -1947,13 +1943,13 @@ pub fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                     cleanup_scope);\n             }\n         }\n-        hir::PatBox(ref inner) => {\n+        PatKind::Box(ref inner) => {\n             let pat_ty = node_id_type(bcx, inner.id);\n             // Pass along DSTs as fat pointers.\n             let val = if type_is_fat_ptr(tcx, pat_ty) {\n                 // We need to check for this, as the pattern could be binding\n                 // a fat pointer by-value.\n-                if let hir::PatIdent(hir::BindByRef(_),_,_) = inner.node {\n+                if let PatKind::Ident(hir::BindByRef(_),_,_) = inner.node {\n                     val.val\n                 } else {\n                     Load(bcx, val.val)\n@@ -1966,13 +1962,13 @@ pub fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             bcx = bind_irrefutable_pat(\n                 bcx, &inner, MatchInput::from_val(val), cleanup_scope);\n         }\n-        hir::PatRegion(ref inner, _) => {\n+        PatKind::Ref(ref inner, _) => {\n             let pat_ty = node_id_type(bcx, inner.id);\n             // Pass along DSTs as fat pointers.\n             let val = if type_is_fat_ptr(tcx, pat_ty) {\n                 // We need to check for this, as the pattern could be binding\n                 // a fat pointer by-value.\n-                if let hir::PatIdent(hir::BindByRef(_),_,_) = inner.node {\n+                if let PatKind::Ident(hir::BindByRef(_),_,_) = inner.node {\n                     val.val\n                 } else {\n                     Load(bcx, val.val)\n@@ -1988,7 +1984,7 @@ pub fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 MatchInput::from_val(val),\n                 cleanup_scope);\n         }\n-        hir::PatVec(ref before, ref slice, ref after) => {\n+        PatKind::Vec(ref before, ref slice, ref after) => {\n             let pat_ty = node_id_type(bcx, pat.id);\n             let mut extracted = extract_vec_elems(bcx, pat_ty, before.len(), after.len(), val);\n             match slice {\n@@ -2013,8 +2009,8 @@ pub fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                         cleanup_scope)\n                 });\n         }\n-        hir::PatQPath(..) | hir::PatWild | hir::PatLit(_) |\n-        hir::PatRange(_, _) => ()\n+        PatKind::Path(..) | PatKind::QPath(..) | PatKind::Wild | PatKind::Lit(_) |\n+        PatKind::Range(_, _) => ()\n     }\n     return bcx;\n }"}, {"sha": "73fdbd54b29d086b7c36eb7b5678e9910a24dbac", "filename": "src/librustc_trans/trans/debuginfo/create_scope_map.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fcreate_scope_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fcreate_scope_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fcreate_scope_map.rs?ref=0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5", "patch": "@@ -22,7 +22,7 @@ use syntax::codemap::{Span, Pos};\n use syntax::{ast, codemap};\n \n use rustc_front;\n-use rustc_front::hir;\n+use rustc_front::hir::{self, PatKind};\n \n // This procedure builds the *scope map* for a given function, which maps any\n // given ast::NodeId in the function's AST to the correct DIScope metadata instance.\n@@ -163,7 +163,7 @@ fn walk_pattern(cx: &CrateContext,\n     // ast_util::walk_pat() here because we have to visit *all* nodes in\n     // order to put them into the scope map. The above functions don't do that.\n     match pat.node {\n-        hir::PatIdent(_, ref path1, ref sub_pat_opt) => {\n+        PatKind::Ident(_, ref path1, ref sub_pat_opt) => {\n \n             // Check if this is a binding. If so we need to put it on the\n             // scope stack and maybe introduce an artificial scope\n@@ -235,11 +235,11 @@ fn walk_pattern(cx: &CrateContext,\n             }\n         }\n \n-        hir::PatWild => {\n+        PatKind::Wild => {\n             scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n         }\n \n-        hir::PatEnum(_, ref sub_pats_opt) => {\n+        PatKind::TupleStruct(_, ref sub_pats_opt) => {\n             scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n \n             if let Some(ref sub_pats) = *sub_pats_opt {\n@@ -249,11 +249,11 @@ fn walk_pattern(cx: &CrateContext,\n             }\n         }\n \n-        hir::PatQPath(..) => {\n+        PatKind::Path(..) | PatKind::QPath(..) => {\n             scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n         }\n \n-        hir::PatStruct(_, ref field_pats, _) => {\n+        PatKind::Struct(_, ref field_pats, _) => {\n             scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n \n             for &codemap::Spanned {\n@@ -264,31 +264,31 @@ fn walk_pattern(cx: &CrateContext,\n             }\n         }\n \n-        hir::PatTup(ref sub_pats) => {\n+        PatKind::Tup(ref sub_pats) => {\n             scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n \n             for sub_pat in sub_pats {\n                 walk_pattern(cx, &sub_pat, scope_stack, scope_map);\n             }\n         }\n \n-        hir::PatBox(ref sub_pat) | hir::PatRegion(ref sub_pat, _) => {\n+        PatKind::Box(ref sub_pat) | PatKind::Ref(ref sub_pat, _) => {\n             scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n             walk_pattern(cx, &sub_pat, scope_stack, scope_map);\n         }\n \n-        hir::PatLit(ref exp) => {\n+        PatKind::Lit(ref exp) => {\n             scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n             walk_expr(cx, &exp, scope_stack, scope_map);\n         }\n \n-        hir::PatRange(ref exp1, ref exp2) => {\n+        PatKind::Range(ref exp1, ref exp2) => {\n             scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n             walk_expr(cx, &exp1, scope_stack, scope_map);\n             walk_expr(cx, &exp2, scope_stack, scope_map);\n         }\n \n-        hir::PatVec(ref front_sub_pats, ref middle_sub_pats, ref back_sub_pats) => {\n+        PatKind::Vec(ref front_sub_pats, ref middle_sub_pats, ref back_sub_pats) => {\n             scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n \n             for sub_pat in front_sub_pats {"}, {"sha": "330d4077c4101ec78cbe82b3fb14e02c64a78cde", "filename": "src/librustc_trans/trans/debuginfo/metadata.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs?ref=0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5", "patch": "@@ -28,7 +28,7 @@ use middle::infer;\n use middle::pat_util;\n use middle::subst;\n use rustc::front::map as hir_map;\n-use rustc_front::hir;\n+use rustc_front::hir::{self, PatKind};\n use trans::{type_of, adt, machine, monomorphize};\n use trans::common::{self, CrateContext, FunctionContext, Block};\n use trans::_match::{BindingInfo, TransBindingMode};\n@@ -1971,7 +1971,7 @@ pub fn create_captured_var_metadata<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         }\n         Some(hir_map::NodeLocal(pat)) => {\n             match pat.node {\n-                hir::PatIdent(_, ref path1, _) => {\n+                PatKind::Ident(_, ref path1, _) => {\n                     path1.node.name\n                 }\n                 _ => {"}, {"sha": "bd2c7b3915363130009cab6580e037081a992ff7", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 19, "deletions": 24, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5", "patch": "@@ -30,7 +30,7 @@ use syntax::ast;\n use syntax::codemap::{Span, Spanned};\n use syntax::ptr::P;\n \n-use rustc_front::hir;\n+use rustc_front::hir::{self, PatKind};\n use rustc_front::print::pprust;\n use rustc_front::util as hir_util;\n \n@@ -46,10 +46,10 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n            expected);\n \n     match pat.node {\n-        hir::PatWild => {\n+        PatKind::Wild => {\n             fcx.write_ty(pat.id, expected);\n         }\n-        hir::PatLit(ref lt) => {\n+        PatKind::Lit(ref lt) => {\n             check_expr(fcx, &lt);\n             let expr_ty = fcx.expr_ty(&lt);\n \n@@ -84,7 +84,7 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n             // that's equivalent to there existing a LUB.\n             demand::suptype(fcx, pat.span, expected, pat_ty);\n         }\n-        hir::PatRange(ref begin, ref end) => {\n+        PatKind::Range(ref begin, ref end) => {\n             check_expr(fcx, begin);\n             check_expr(fcx, end);\n \n@@ -135,14 +135,8 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n             // subtyping doesn't matter here, as the value is some kind of scalar\n             demand::eqtype(fcx, pat.span, expected, lhs_ty);\n         }\n-        hir::PatEnum(..) | hir::PatIdent(..)\n+        PatKind::Path(..) | PatKind::Ident(..)\n                 if pat_is_resolved_const(&tcx.def_map.borrow(), pat) => {\n-            if let hir::PatEnum(ref path, ref subpats) = pat.node {\n-                if !(subpats.is_some() && subpats.as_ref().unwrap().is_empty()) {\n-                    bad_struct_kind_err(tcx.sess, pat, path, false);\n-                    return;\n-                }\n-            }\n             if let Some(pat_def) = tcx.def_map.borrow().get(&pat.id) {\n                 let const_did = pat_def.def_id();\n                 let const_scheme = tcx.lookup_item_type(const_did);\n@@ -154,15 +148,15 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n \n                 // FIXME(#20489) -- we should limit the types here to scalars or something!\n \n-                // As with PatLit, what we really want here is that there\n+                // As with PatKind::Lit, what we really want here is that there\n                 // exist a LUB, but for the cases that can occur, subtype\n                 // is good enough.\n                 demand::suptype(fcx, pat.span, expected, const_ty);\n             } else {\n                 fcx.write_error(pat.id);\n             }\n         }\n-        hir::PatIdent(bm, ref path, ref sub) if pat_is_binding(&tcx.def_map.borrow(), pat) => {\n+        PatKind::Ident(bm, ref path, ref sub) if pat_is_binding(&tcx.def_map.borrow(), pat) => {\n             let typ = fcx.local_ty(pat.span, pat.id);\n             match bm {\n                 hir::BindByRef(mutbl) => {\n@@ -202,16 +196,17 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n                 }\n             }\n         }\n-        hir::PatIdent(_, ref path, _) => {\n+        PatKind::Ident(_, ref path, _) => {\n             let path = hir_util::ident_to_path(path.span, path.node);\n             check_pat_enum(pcx, pat, &path, Some(&[]), expected, false);\n         }\n-        hir::PatEnum(ref path, ref subpats) => {\n-            let subpats = subpats.as_ref().map(|v| &v[..]);\n-            let is_tuple_struct_pat = !(subpats.is_some() && subpats.unwrap().is_empty());\n-            check_pat_enum(pcx, pat, path, subpats, expected, is_tuple_struct_pat);\n+        PatKind::TupleStruct(ref path, ref subpats) => {\n+            check_pat_enum(pcx, pat, path, subpats.as_ref().map(|v| &v[..]), expected, true);\n+        }\n+        PatKind::Path(ref path) => {\n+            check_pat_enum(pcx, pat, path, None, expected, false);\n         }\n-        hir::PatQPath(ref qself, ref path) => {\n+        PatKind::QPath(ref qself, ref path) => {\n             let self_ty = fcx.to_ty(&qself.ty);\n             let path_res = if let Some(&d) = tcx.def_map.borrow().get(&pat.id) {\n                 if d.base_def == Def::Err {\n@@ -248,10 +243,10 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n                 }\n             }\n         }\n-        hir::PatStruct(ref path, ref fields, etc) => {\n+        PatKind::Struct(ref path, ref fields, etc) => {\n             check_pat_struct(pcx, pat, path, fields, etc, expected);\n         }\n-        hir::PatTup(ref elements) => {\n+        PatKind::Tup(ref elements) => {\n             let element_tys: Vec<_> =\n                 (0..elements.len()).map(|_| fcx.infcx().next_ty_var())\n                                         .collect();\n@@ -262,7 +257,7 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n                 check_pat(pcx, &element_pat, element_ty);\n             }\n         }\n-        hir::PatBox(ref inner) => {\n+        PatKind::Box(ref inner) => {\n             let inner_ty = fcx.infcx().next_ty_var();\n             let uniq_ty = tcx.mk_box(inner_ty);\n \n@@ -278,7 +273,7 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n                 check_pat(pcx, &inner, tcx.types.err);\n             }\n         }\n-        hir::PatRegion(ref inner, mutbl) => {\n+        PatKind::Ref(ref inner, mutbl) => {\n             let expected = fcx.infcx().shallow_resolve(expected);\n             if check_dereferencable(pcx, pat.span, expected, &inner) {\n                 // `demand::subtype` would be good enough, but using\n@@ -310,7 +305,7 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n                 check_pat(pcx, &inner, tcx.types.err);\n             }\n         }\n-        hir::PatVec(ref before, ref slice, ref after) => {\n+        PatKind::Vec(ref before, ref slice, ref after) => {\n             let expected_ty = structurally_resolved_type(fcx, pat.span, expected);\n             let inner_ty = fcx.infcx().next_ty_var();\n             let pat_ty = match expected_ty.sty {"}, {"sha": "3768a2e30337e6f70b1003c756ec3479722bce38", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5", "patch": "@@ -127,7 +127,7 @@ use syntax::util::lev_distance::find_best_match_for_name;\n \n use rustc_front::intravisit::{self, Visitor};\n use rustc_front::hir;\n-use rustc_front::hir::Visibility;\n+use rustc_front::hir::{Visibility, PatKind};\n use rustc_front::print::pprust;\n use rustc_back::slice;\n \n@@ -506,7 +506,7 @@ impl<'a, 'tcx> Visitor<'tcx> for GatherLocalsVisitor<'a, 'tcx> {\n \n     // Add pattern bindings.\n     fn visit_pat(&mut self, p: &'tcx hir::Pat) {\n-        if let hir::PatIdent(_, ref path1, _) = p.node {\n+        if let PatKind::Ident(_, ref path1, _) = p.node {\n             if pat_util::pat_is_binding(&self.fcx.ccx.tcx.def_map.borrow(), p) {\n                 let var_ty = self.assign(p.span, p.id, None);\n "}, {"sha": "e399818779ecf60dff659d59e07a2177aa752e4f", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5", "patch": "@@ -101,7 +101,7 @@ use std::mem;\n use syntax::ast;\n use syntax::codemap::Span;\n use rustc_front::intravisit::{self, Visitor};\n-use rustc_front::hir;\n+use rustc_front::hir::{self, PatKind};\n use rustc_front::util as hir_util;\n \n use self::SubjectNode::Subject;\n@@ -1190,14 +1190,14 @@ fn link_pattern<'t, 'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n     let _ = mc.cat_pattern(discr_cmt, root_pat, |mc, sub_cmt, sub_pat| {\n             match sub_pat.node {\n                 // `ref x` pattern\n-                hir::PatIdent(hir::BindByRef(mutbl), _, _) => {\n+                PatKind::Ident(hir::BindByRef(mutbl), _, _) => {\n                     link_region_from_node_type(\n                         rcx, sub_pat.span, sub_pat.id,\n                         mutbl, sub_cmt);\n                 }\n \n                 // `[_, ..slice, _]` pattern\n-                hir::PatVec(_, Some(ref slice_pat), _) => {\n+                PatKind::Vec(_, Some(ref slice_pat), _) => {\n                     match mc.cat_slice_pattern(sub_cmt, &slice_pat) {\n                         Ok((slice_cmt, slice_mutbl, slice_r)) => {\n                             link_region(rcx, sub_pat.span, &slice_r,"}, {"sha": "026881927cb21e5678f230aa4d283b9d771a7fdd", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5", "patch": "@@ -90,7 +90,7 @@ use syntax::attr;\n use syntax::codemap::Span;\n use syntax::parse::token::special_idents;\n use syntax::ptr::P;\n-use rustc_front::hir;\n+use rustc_front::hir::{self, PatKind};\n use rustc_front::intravisit;\n use rustc_front::print::pprust;\n \n@@ -2121,8 +2121,8 @@ fn compute_type_scheme_of_foreign_fn_decl<'a, 'tcx>(\n {\n     for i in &decl.inputs {\n         match i.pat.node {\n-            hir::PatIdent(_, _, _) => (),\n-            hir::PatWild => (),\n+            PatKind::Ident(_, _, _) => (),\n+            PatKind::Wild => (),\n             _ => {\n                 span_err!(ccx.tcx.sess, i.pat.span, E0130,\n                           \"patterns aren't allowed in foreign function declarations\");"}, {"sha": "7072f1b498bb91f6bee167e2bb17035f4a9c34d3", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5", "patch": "@@ -2552,31 +2552,31 @@ fn name_from_pat(p: &hir::Pat) -> String {\n     debug!(\"Trying to get a name from pattern: {:?}\", p);\n \n     match p.node {\n-        PatWild => \"_\".to_string(),\n-        PatIdent(_, ref p, _) => p.node.to_string(),\n-        PatEnum(ref p, _) => path_to_string(p),\n-        PatQPath(..) => panic!(\"tried to get argument name from PatQPath, \\\n+        PatKind::Wild => \"_\".to_string(),\n+        PatKind::Ident(_, ref p, _) => p.node.to_string(),\n+        PatKind::TupleStruct(ref p, _) | PatKind::Path(ref p) => path_to_string(p),\n+        PatKind::QPath(..) => panic!(\"tried to get argument name from PatKind::QPath, \\\n                                 which is not allowed in function arguments\"),\n-        PatStruct(ref name, ref fields, etc) => {\n+        PatKind::Struct(ref name, ref fields, etc) => {\n             format!(\"{} {{ {}{} }}\", path_to_string(name),\n                 fields.iter().map(|&Spanned { node: ref fp, .. }|\n                                   format!(\"{}: {}\", fp.name, name_from_pat(&*fp.pat)))\n                              .collect::<Vec<String>>().join(\", \"),\n                 if etc { \", ...\" } else { \"\" }\n             )\n         },\n-        PatTup(ref elts) => format!(\"({})\", elts.iter().map(|p| name_from_pat(&**p))\n+        PatKind::Tup(ref elts) => format!(\"({})\", elts.iter().map(|p| name_from_pat(&**p))\n                                             .collect::<Vec<String>>().join(\", \")),\n-        PatBox(ref p) => name_from_pat(&**p),\n-        PatRegion(ref p, _) => name_from_pat(&**p),\n-        PatLit(..) => {\n-            warn!(\"tried to get argument name from PatLit, \\\n+        PatKind::Box(ref p) => name_from_pat(&**p),\n+        PatKind::Ref(ref p, _) => name_from_pat(&**p),\n+        PatKind::Lit(..) => {\n+            warn!(\"tried to get argument name from PatKind::Lit, \\\n                   which is silly in function arguments\");\n             \"()\".to_string()\n         },\n-        PatRange(..) => panic!(\"tried to get argument name from PatRange, \\\n+        PatKind::Range(..) => panic!(\"tried to get argument name from PatKind::Range, \\\n                               which is not allowed in function arguments\"),\n-        PatVec(ref begin, ref mid, ref end) => {\n+        PatKind::Vec(ref begin, ref mid, ref end) => {\n             let begin = begin.iter().map(|p| name_from_pat(&**p));\n             let mid = mid.as_ref().map(|p| format!(\"..{}\", name_from_pat(&**p))).into_iter();\n             let end = end.iter().map(|p| name_from_pat(&**p));"}, {"sha": "23bb6fd141a4ed22112dafd8655e705cc50ded19", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=0d1cd9bd6ac65e2a3fa8a1519fd368de79d5bfb5", "patch": "@@ -580,7 +580,7 @@ pub enum PatKind {\n     /// An associated const named using the qualified path `<T>::CONST` or\n     /// `<T as Trait>::CONST`. Associated consts from inherent impls can be\n     /// referred to as simply `T::CONST`, in which case they will end up as\n-    /// PatKind::Enum, and the resolver will have to sort that out.\n+    /// PatKind::Path, and the resolver will have to sort that out.\n     QPath(QSelf, Path),\n \n     /// A tuple pattern `(a, b)`"}]}