{"sha": "68fd28c2c139109bac3372c5fe6d05b228d6a579", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY4ZmQyOGMyYzEzOTEwOWJhYzMzNzJjNWZlNmQwNWIyMjhkNmE1Nzk=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-08-23T20:22:44Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-08-23T20:22:44Z"}, "message": "Cleanup formatting in std::sha1\n\nThis file has suffered a lot of reformats and was looking pretty ragged", "tree": {"sha": "d770efeb15612e180ab2ceb9b16721b9164240bc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d770efeb15612e180ab2ceb9b16721b9164240bc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/68fd28c2c139109bac3372c5fe6d05b228d6a579", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/68fd28c2c139109bac3372c5fe6d05b228d6a579", "html_url": "https://github.com/rust-lang/rust/commit/68fd28c2c139109bac3372c5fe6d05b228d6a579", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/68fd28c2c139109bac3372c5fe6d05b228d6a579/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7b12924813912b4f8ca196ae3cd0c87985d6961e", "url": "https://api.github.com/repos/rust-lang/rust/commits/7b12924813912b4f8ca196ae3cd0c87985d6961e", "html_url": "https://github.com/rust-lang/rust/commit/7b12924813912b4f8ca196ae3cd0c87985d6961e"}], "stats": {"total": 50, "additions": 15, "deletions": 35}, "files": [{"sha": "bb35640aab3723e19b2424262353e2313ea54fd8", "filename": "src/lib/sha1.rs", "status": "modified", "additions": 15, "deletions": 35, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/68fd28c2c139109bac3372c5fe6d05b228d6a579/src%2Flib%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68fd28c2c139109bac3372c5fe6d05b228d6a579/src%2Flib%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fsha1.rs?ref=68fd28c2c139109bac3372c5fe6d05b228d6a579", "patch": "@@ -1,5 +1,3 @@\n-\n-\n /*\n  * A SHA-1 implementation derived from Paul E. Jones's reference\n  * implementation, which is written for clarity, not speed. At some\n@@ -8,43 +6,29 @@\n export sha1;\n export mk_sha1;\n \n-type sha1 =\n+type sha1 = obj {\n     // Provide message input as bytes\n-\n-\n+    fn input(&[u8]);\n     // Provide message input as string\n-\n-    // Read the digest as a vector of 20 bytes. After\n-    // calling this no further input may provided\n-    // until reset is called\n-\n-\n+    fn input_str(&str);\n+    // Read the digest as a vector of 20 bytes. After calling this no further\n+    // input may provided until reset is called\n+    fn result() -> [u8];\n     // Same as above, just a hex-string version.\n-\n+    fn result_str() -> str;\n     // Reset the sha1 state for reuse. This is called\n     // automatically during construction\n-    obj {\n-        fn input(&[u8]);\n-        fn input_str(&str);\n-        fn result() -> [u8];\n-        fn result_str() -> str;\n-        fn reset();\n-    };\n+    fn reset();\n+};\n \n \n // Some unexported constants\n const digest_buf_len: uint = 5u;\n-\n const msg_block_len: uint = 64u;\n-\n const work_buf_len: uint = 80u;\n-\n const k0: u32 = 0x5A827999u32;\n-\n const k1: u32 = 0x6ED9EBA1u32;\n-\n const k2: u32 = 0x8F1BBCDCu32;\n-\n const k3: u32 = 0xCA62C1D6u32;\n \n \n@@ -61,7 +45,6 @@ fn mk_sha1() -> sha1 {\n \n     fn add_input(st: &sha1state, msg: &[u8]) {\n         // FIXME: Should be typestate precondition\n-\n         assert (!st.computed);\n         for element: u8 in msg {\n             st.msg_block[st.msg_block_idx] = element;\n@@ -80,14 +63,12 @@ fn mk_sha1() -> sha1 {\n     }\n     fn process_msg_block(st: &sha1state) {\n         // FIXME: Make precondition\n-\n         assert (vec::len(st.h) == digest_buf_len);\n         assert (vec::len(st.work_buf) == work_buf_len);\n         let t: int; // Loop counter\n-\n         let w = st.work_buf;\n-        // Initialize the first 16 words of the vector w\n \n+        // Initialize the first 16 words of the vector w\n         t = 0;\n         while t < 16 {\n             let tmp;\n@@ -98,8 +79,8 @@ fn mk_sha1() -> sha1 {\n             w[t] = tmp;\n             t += 1;\n         }\n-        // Initialize the rest of vector w\n \n+        // Initialize the rest of vector w\n         while t < 80 {\n             let val = w[t - 3] ^ w[t - 8] ^ w[t - 14] ^ w[t - 16];\n             w[t] = circular_shift(1u32, val);\n@@ -172,6 +153,7 @@ fn mk_sha1() -> sha1 {\n         }\n         ret rs;\n     }\n+\n     /*\n      * According to the standard, the message must be padded to an even\n      * 512 bits.  The first padding bit must be a '1'.  The last 64 bits\n@@ -181,17 +163,15 @@ fn mk_sha1() -> sha1 {\n      * call process_msg_block() appropriately.  When it returns, it\n      * can be assumed that the message digest has been computed.\n      */\n-\n     fn pad_msg(st: &sha1state) {\n         // FIXME: Should be a precondition\n-\n         assert (vec::len(st.msg_block) == msg_block_len);\n+\n         /*\n          * Check to see if the current message block is too small to hold\n          * the initial padding bits and length.  If so, we will pad the\n          * block, process it, and then continue padding into a second block.\n          */\n-\n         if st.msg_block_idx > 55u {\n             st.msg_block[st.msg_block_idx] = 0x80u8;\n             st.msg_block_idx += 1u;\n@@ -208,8 +188,8 @@ fn mk_sha1() -> sha1 {\n             st.msg_block[st.msg_block_idx] = 0u8;\n             st.msg_block_idx += 1u;\n         }\n-        // Store the message length as the last 8 octets\n \n+        // Store the message length as the last 8 octets\n         st.msg_block[56] = st.len_high >> 24u32 & 0xFFu32 as u8;\n         st.msg_block[57] = st.len_high >> 16u32 & 0xFFu32 as u8;\n         st.msg_block[58] = st.len_high >> 8u32 & 0xFFu32 as u8;\n@@ -223,7 +203,6 @@ fn mk_sha1() -> sha1 {\n     obj sha1(st: sha1state) {\n         fn reset() {\n             // FIXME: Should be typestate precondition\n-\n             assert (vec::len(st.h) == digest_buf_len);\n             st.len_low = 0u32;\n             st.len_high = 0u32;\n@@ -257,6 +236,7 @@ fn mk_sha1() -> sha1 {\n     sh.reset();\n     ret sh;\n }\n+\n // Local Variables:\n // mode: rust;\n // fill-column: 78;"}]}