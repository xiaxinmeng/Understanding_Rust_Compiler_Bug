{"sha": "3a8b0144c82197a70e919ad371d56f82c2282833", "node_id": "C_kwDOAAsO6NoAKDNhOGIwMTQ0YzgyMTk3YTcwZTkxOWFkMzcxZDU2ZjgyYzIyODI4MzM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-17T10:00:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-17T10:00:11Z"}, "message": "Auto merge of #98106 - cjgillot:split-definitions, r=michaelwoerister\n\nSplit up `Definitions` and `ResolverAstLowering`.\n\nSplit off https://github.com/rust-lang/rust/pull/95573\n\nr? `@michaelwoerister`", "tree": {"sha": "eb71135beb73c3b9e597c2de8f5aff8e35939eae", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eb71135beb73c3b9e597c2de8f5aff8e35939eae"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3a8b0144c82197a70e919ad371d56f82c2282833", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3a8b0144c82197a70e919ad371d56f82c2282833", "html_url": "https://github.com/rust-lang/rust/commit/3a8b0144c82197a70e919ad371d56f82c2282833", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3a8b0144c82197a70e919ad371d56f82c2282833/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ecdd374e6123d79b89c3ecea618d827c931b81cd", "url": "https://api.github.com/repos/rust-lang/rust/commits/ecdd374e6123d79b89c3ecea618d827c931b81cd", "html_url": "https://github.com/rust-lang/rust/commit/ecdd374e6123d79b89c3ecea618d827c931b81cd"}, {"sha": "ae5959f4bab2d48e909cc5af6b906526ab83cc3d", "url": "https://api.github.com/repos/rust-lang/rust/commits/ae5959f4bab2d48e909cc5af6b906526ab83cc3d", "html_url": "https://github.com/rust-lang/rust/commit/ae5959f4bab2d48e909cc5af6b906526ab83cc3d"}], "stats": {"total": 1087, "additions": 600, "deletions": 487}, "files": [{"sha": "acda64172b10a5639331ea2f874ec3d5f7a79e59", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a8b0144c82197a70e919ad371d56f82c2282833/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/3a8b0144c82197a70e919ad371d56f82c2282833/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=3a8b0144c82197a70e919ad371d56f82c2282833", "patch": "@@ -3571,6 +3571,7 @@ dependencies = [\n  \"rustc_errors\",\n  \"rustc_hir\",\n  \"rustc_index\",\n+ \"rustc_middle\",\n  \"rustc_query_system\",\n  \"rustc_session\",\n  \"rustc_span\",\n@@ -4376,7 +4377,6 @@ dependencies = [\n  \"bitflags\",\n  \"rustc_arena\",\n  \"rustc_ast\",\n- \"rustc_ast_lowering\",\n  \"rustc_ast_pretty\",\n  \"rustc_attr\",\n  \"rustc_data_structures\","}, {"sha": "e344d8a7637c483cd67f0845e866f0576af051c0", "filename": "compiler/rustc_ast_lowering/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3a8b0144c82197a70e919ad371d56f82c2282833/compiler%2Frustc_ast_lowering%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3a8b0144c82197a70e919ad371d56f82c2282833/compiler%2Frustc_ast_lowering%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2FCargo.toml?ref=3a8b0144c82197a70e919ad371d56f82c2282833", "patch": "@@ -14,6 +14,7 @@ rustc_hir = { path = \"../rustc_hir\" }\n rustc_target = { path = \"../rustc_target\" }\n rustc_data_structures = { path = \"../rustc_data_structures\" }\n rustc_index = { path = \"../rustc_index\" }\n+rustc_middle = { path = \"../rustc_middle\" }\n rustc_query_system = { path = \"../rustc_query_system\" }\n rustc_span = { path = \"../rustc_span\" }\n rustc_errors = { path = \"../rustc_errors\" }"}, {"sha": "aab9b90e4b7e567bc85abd466139c39a055fbd98", "filename": "compiler/rustc_ast_lowering/src/asm.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3a8b0144c82197a70e919ad371d56f82c2282833/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a8b0144c82197a70e919ad371d56f82c2282833/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs?ref=3a8b0144c82197a70e919ad371d56f82c2282833", "patch": "@@ -1,4 +1,4 @@\n-use crate::{ImplTraitContext, ImplTraitPosition, ParamMode};\n+use crate::{ImplTraitContext, ImplTraitPosition, ParamMode, ResolverAstLoweringExt};\n \n use super::LoweringContext;\n \n@@ -11,7 +11,7 @@ use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::definitions::DefPathData;\n use rustc_session::parse::feature_err;\n-use rustc_span::{sym, ExpnId, Span};\n+use rustc_span::{sym, Span};\n use rustc_target::asm;\n use std::collections::hash_map::Entry;\n use std::fmt::Write;\n@@ -242,14 +242,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n                             // Wrap the expression in an AnonConst.\n                             let parent_def_id = self.current_hir_id_owner;\n-                            let node_id = self.resolver.next_node_id();\n-                            self.resolver.create_def(\n-                                parent_def_id,\n-                                node_id,\n-                                DefPathData::AnonConst,\n-                                ExpnId::root(),\n-                                *op_sp,\n-                            );\n+                            let node_id = self.next_node_id();\n+                            self.create_def(parent_def_id, node_id, DefPathData::AnonConst);\n                             let anon_const = AnonConst { id: node_id, value: P(expr) };\n                             hir::InlineAsmOperand::SymFn {\n                                 anon_const: self.lower_anon_const(&anon_const),"}, {"sha": "095a4b26a860fc92f4b143fb96e84e6a3bf53769", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3a8b0144c82197a70e919ad371d56f82c2282833/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a8b0144c82197a70e919ad371d56f82c2282833/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=3a8b0144c82197a70e919ad371d56f82c2282833", "patch": "@@ -1,6 +1,6 @@\n-use crate::{FnDeclKind, ImplTraitPosition};\n-\n+use super::ResolverAstLoweringExt;\n use super::{ImplTraitContext, LoweringContext, ParamMode, ParenthesizedGenericArgs};\n+use crate::{FnDeclKind, ImplTraitPosition};\n \n use rustc_ast::attr;\n use rustc_ast::ptr::P as AstP;\n@@ -11,7 +11,6 @@ use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def::Res;\n use rustc_hir::definitions::DefPathData;\n-use rustc_span::hygiene::ExpnId;\n use rustc_span::source_map::{respan, DesugaringKind, Span, Spanned};\n use rustc_span::symbol::{sym, Ident};\n use rustc_span::DUMMY_SP;\n@@ -355,16 +354,10 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         for (idx, arg) in args.into_iter().enumerate() {\n             if legacy_args_idx.contains(&idx) {\n                 let parent_def_id = self.current_hir_id_owner;\n-                let node_id = self.resolver.next_node_id();\n+                let node_id = self.next_node_id();\n \n                 // Add a definition for the in-band const def.\n-                self.resolver.create_def(\n-                    parent_def_id,\n-                    node_id,\n-                    DefPathData::AnonConst,\n-                    ExpnId::root(),\n-                    arg.span,\n-                );\n+                self.create_def(parent_def_id, node_id, DefPathData::AnonConst);\n \n                 let anon_const = AnonConst { id: node_id, value: arg };\n                 generic_args.push(AngleBracketedArg::Arg(GenericArg::Const(anon_const)));\n@@ -724,7 +717,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         };\n \n         // `::std::task::Poll::Ready(result) => break result`\n-        let loop_node_id = self.resolver.next_node_id();\n+        let loop_node_id = self.next_node_id();\n         let loop_hir_id = self.lower_node_id(loop_node_id);\n         let ready_arm = {\n             let x_ident = Ident::with_dummy_span(sym::result);"}, {"sha": "4be22020ba15357ded0d85fb647e3d5eb3e7e7b9", "filename": "compiler/rustc_ast_lowering/src/index.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3a8b0144c82197a70e919ad371d56f82c2282833/compiler%2Frustc_ast_lowering%2Fsrc%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a8b0144c82197a70e919ad371d56f82c2282833/compiler%2Frustc_ast_lowering%2Fsrc%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Findex.rs?ref=3a8b0144c82197a70e919ad371d56f82c2282833", "patch": "@@ -6,6 +6,7 @@ use rustc_hir::definitions;\n use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::*;\n use rustc_index::vec::{Idx, IndexVec};\n+use rustc_middle::span_bug;\n use rustc_session::Session;\n use rustc_span::source_map::SourceMap;\n use rustc_span::{Span, DUMMY_SP};\n@@ -75,7 +76,8 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n         // owner of that node.\n         if cfg!(debug_assertions) {\n             if hir_id.owner != self.owner {\n-                panic!(\n+                span_bug!(\n+                    span,\n                     \"inconsistent DepNode at `{:?}` for `{:?}`: \\\n                      current_dep_node_owner={} ({:?}), hir_id.owner={} ({:?})\",\n                     self.source_map.span_to_diagnostic_string(span),"}, {"sha": "717918116e595b4f694ae58ece54bc448842e18a", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 29, "deletions": 20, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/3a8b0144c82197a70e919ad371d56f82c2282833/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a8b0144c82197a70e919ad371d56f82c2282833/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=3a8b0144c82197a70e919ad371d56f82c2282833", "patch": "@@ -1,4 +1,5 @@\n-use super::{AstOwner, ImplTraitContext, ImplTraitPosition, ResolverAstLowering};\n+use super::ResolverAstLoweringExt;\n+use super::{AstOwner, ImplTraitContext, ImplTraitPosition};\n use super::{LoweringContext, ParamMode};\n use crate::{Arena, FnDeclKind};\n \n@@ -11,8 +12,11 @@ use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{LocalDefId, CRATE_DEF_ID};\n+use rustc_hir::definitions::Definitions;\n use rustc_hir::PredicateOrigin;\n use rustc_index::vec::{Idx, IndexVec};\n+use rustc_middle::ty::{ResolverAstLowering, ResolverOutputs};\n+use rustc_session::cstore::CrateStoreDyn;\n use rustc_session::Session;\n use rustc_span::source_map::DesugaringKind;\n use rustc_span::symbol::{kw, sym, Ident};\n@@ -24,7 +28,10 @@ use std::iter;\n \n pub(super) struct ItemLowerer<'a, 'hir> {\n     pub(super) sess: &'a Session,\n-    pub(super) resolver: &'a mut dyn ResolverAstLowering,\n+    pub(super) definitions: &'a mut Definitions,\n+    pub(super) cstore: &'a CrateStoreDyn,\n+    pub(super) resolutions: &'a ResolverOutputs,\n+    pub(super) resolver: &'a mut ResolverAstLowering,\n     pub(super) arena: &'hir Arena<'hir>,\n     pub(super) ast_index: &'a IndexVec<LocalDefId, AstOwner<'a>>,\n     pub(super) owners: &'a mut IndexVec<LocalDefId, hir::MaybeOwner<&'hir hir::OwnerInfo<'hir>>>,\n@@ -59,6 +66,9 @@ impl<'a, 'hir> ItemLowerer<'a, 'hir> {\n         let mut lctx = LoweringContext {\n             // Pseudo-globals.\n             sess: &self.sess,\n+            definitions: self.definitions,\n+            cstore: self.cstore,\n+            resolutions: self.resolutions,\n             resolver: self.resolver,\n             arena: self.arena,\n \n@@ -118,8 +128,7 @@ impl<'a, 'hir> ItemLowerer<'a, 'hir> {\n \n     #[instrument(level = \"debug\", skip(self, c))]\n     fn lower_crate(&mut self, c: &Crate) {\n-        debug_assert_eq!(self.resolver.local_def_id(CRATE_NODE_ID), CRATE_DEF_ID);\n-\n+        debug_assert_eq!(self.resolver.node_id_to_def_id[&CRATE_NODE_ID], CRATE_DEF_ID);\n         self.with_lctx(CRATE_NODE_ID, |lctx| {\n             let module = lctx.lower_mod(&c.items, &c.spans);\n             lctx.lower_attrs(hir::CRATE_HIR_ID, &c.attrs);\n@@ -133,10 +142,10 @@ impl<'a, 'hir> ItemLowerer<'a, 'hir> {\n     }\n \n     fn lower_assoc_item(&mut self, item: &AssocItem, ctxt: AssocCtxt) {\n-        let def_id = self.resolver.local_def_id(item.id);\n+        let def_id = self.resolver.node_id_to_def_id[&item.id];\n \n         let parent_id = {\n-            let parent = self.resolver.definitions().def_key(def_id).parent;\n+            let parent = self.definitions.def_key(def_id).parent;\n             let local_def_index = parent.unwrap();\n             LocalDefId { local_def_index }\n         };\n@@ -177,7 +186,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     }\n \n     pub(super) fn lower_item_ref(&mut self, i: &Item) -> SmallVec<[hir::ItemId; 1]> {\n-        let mut node_ids = smallvec![hir::ItemId { def_id: self.resolver.local_def_id(i.id) }];\n+        let mut node_ids = smallvec![hir::ItemId { def_id: self.local_def_id(i.id) }];\n         if let ItemKind::Use(ref use_tree) = &i.kind {\n             self.lower_item_id_use_tree(use_tree, i.id, &mut node_ids);\n         }\n@@ -193,7 +202,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         match tree.kind {\n             UseTreeKind::Nested(ref nested_vec) => {\n                 for &(ref nested, id) in nested_vec {\n-                    vec.push(hir::ItemId { def_id: self.resolver.local_def_id(id) });\n+                    vec.push(hir::ItemId { def_id: self.local_def_id(id) });\n                     self.lower_item_id_use_tree(nested, id, vec);\n                 }\n             }\n@@ -202,7 +211,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 for (_, &id) in\n                     iter::zip(self.expect_full_res_from_use(base_id).skip(1), &[id1, id2])\n                 {\n-                    vec.push(hir::ItemId { def_id: self.resolver.local_def_id(id) });\n+                    vec.push(hir::ItemId { def_id: self.local_def_id(id) });\n                 }\n             }\n         }\n@@ -467,7 +476,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             }\n             ItemKind::MacroDef(MacroDef { ref body, macro_rules }) => {\n                 let body = P(self.lower_mac_args(body));\n-                let macro_kind = self.resolver.decl_macro_kind(self.resolver.local_def_id(id));\n+                let macro_kind = self.resolver.decl_macro_kind(self.local_def_id(id));\n                 hir::ItemKind::Macro(ast::MacroDef { body, macro_rules }, macro_kind)\n             }\n             ItemKind::MacCall(..) => {\n@@ -527,7 +536,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 // Essentially a single `use` which imports two names is desugared into\n                 // two imports.\n                 for new_node_id in [id1, id2] {\n-                    let new_id = self.resolver.local_def_id(new_node_id);\n+                    let new_id = self.local_def_id(new_node_id);\n                     let Some(res) = resolutions.next() else {\n                         // Associate an HirId to both ids even if there is no resolution.\n                         let _old = self.children.insert(\n@@ -540,7 +549,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     let ident = *ident;\n                     let mut path = path.clone();\n                     for seg in &mut path.segments {\n-                        seg.id = self.resolver.next_node_id();\n+                        seg.id = self.next_node_id();\n                     }\n                     let span = path.span;\n \n@@ -603,13 +612,13 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n                 // Add all the nested `PathListItem`s to the HIR.\n                 for &(ref use_tree, id) in trees {\n-                    let new_hir_id = self.resolver.local_def_id(id);\n+                    let new_hir_id = self.local_def_id(id);\n \n                     let mut prefix = prefix.clone();\n \n                     // Give the segments new node-ids since they are being cloned.\n                     for seg in &mut prefix.segments {\n-                        seg.id = self.resolver.next_node_id();\n+                        seg.id = self.next_node_id();\n                     }\n \n                     // Each `use` import is an item and thus are owners of the\n@@ -683,7 +692,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n     fn lower_foreign_item_ref(&mut self, i: &ForeignItem) -> hir::ForeignItemRef {\n         hir::ForeignItemRef {\n-            id: hir::ForeignItemId { def_id: self.resolver.local_def_id(i.id) },\n+            id: hir::ForeignItemId { def_id: self.local_def_id(i.id) },\n             ident: self.lower_ident(i.ident),\n             span: self.lower_span(i.span),\n         }\n@@ -839,7 +848,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             }\n             AssocItemKind::MacCall(..) => unimplemented!(),\n         };\n-        let id = hir::TraitItemId { def_id: self.resolver.local_def_id(i.id) };\n+        let id = hir::TraitItemId { def_id: self.local_def_id(i.id) };\n         let defaultness = hir::Defaultness::Default { has_value: has_default };\n         hir::TraitItemRef {\n             id,\n@@ -919,7 +928,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         let has_value = true;\n         let (defaultness, _) = self.lower_defaultness(i.kind.defaultness(), has_value);\n         hir::ImplItemRef {\n-            id: hir::ImplItemId { def_id: self.resolver.local_def_id(i.id) },\n+            id: hir::ImplItemId { def_id: self.local_def_id(i.id) },\n             ident: self.lower_ident(i.ident),\n             span: self.lower_span(i.span),\n             defaultness,\n@@ -1331,7 +1340,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                         generics\n                             .params\n                             .iter()\n-                            .any(|p| def_id == self.resolver.local_def_id(p.id).to_def_id())\n+                            .any(|p| def_id == self.local_def_id(p.id).to_def_id())\n                     }\n                     // Either the `bounded_ty` is not a plain type parameter, or\n                     // it's not found in the generic type parameters list.\n@@ -1435,7 +1444,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         match kind {\n             GenericParamKind::Const { .. } => None,\n             GenericParamKind::Type { .. } => {\n-                let def_id = self.resolver.local_def_id(id).to_def_id();\n+                let def_id = self.local_def_id(id).to_def_id();\n                 let ty_path = self.arena.alloc(hir::Path {\n                     span: param_span,\n                     res: Res::Def(DefKind::TyParam, def_id),\n@@ -1458,7 +1467,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 let res = self.resolver.get_lifetime_res(id).unwrap_or_else(|| {\n                     panic!(\"Missing resolution for lifetime {:?} at {:?}\", id, ident.span)\n                 });\n-                let lt_id = self.resolver.next_node_id();\n+                let lt_id = self.next_node_id();\n                 let lifetime = self.new_named_lifetime_with_res(lt_id, ident_span, ident, res);\n                 Some(hir::WherePredicate::RegionPredicate(hir::WhereRegionPredicate {\n                     lifetime,"}, {"sha": "4fa2cd5e23bd3723af1115fb753ac88f1a9c3930", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 229, "deletions": 194, "changes": 423, "blob_url": "https://github.com/rust-lang/rust/blob/3a8b0144c82197a70e919ad371d56f82c2282833/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a8b0144c82197a70e919ad371d56f82c2282833/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=3a8b0144c82197a70e919ad371d56f82c2282833", "patch": "@@ -51,15 +51,17 @@ use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::{struct_span_err, Applicability};\n use rustc_hir as hir;\n-use rustc_hir::def::{DefKind, Namespace, PartialRes, PerNS, Res};\n-use rustc_hir::def_id::{DefId, DefPathHash, LocalDefId, CRATE_DEF_ID};\n-use rustc_hir::definitions::{DefKey, DefPathData, Definitions};\n+use rustc_hir::def::{DefKind, LifetimeRes, Namespace, PartialRes, PerNS, Res};\n+use rustc_hir::def_id::{LocalDefId, CRATE_DEF_ID};\n+use rustc_hir::definitions::{DefPathData, Definitions};\n use rustc_hir::{ConstArg, GenericArg, ItemLocalId, ParamName, TraitCandidate};\n use rustc_index::vec::{Idx, IndexVec};\n+use rustc_middle::ty::{ResolverAstLowering, ResolverOutputs};\n use rustc_query_system::ich::StableHashingContext;\n+use rustc_session::cstore::CrateStoreDyn;\n use rustc_session::parse::feature_err;\n use rustc_session::Session;\n-use rustc_span::hygiene::{ExpnId, MacroKind};\n+use rustc_span::hygiene::MacroKind;\n use rustc_span::source_map::DesugaringKind;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n@@ -87,7 +89,10 @@ struct LoweringContext<'a, 'hir: 'a> {\n     /// Used to assign IDs to HIR nodes that do not directly correspond to AST nodes.\n     sess: &'a Session,\n \n-    resolver: &'a mut dyn ResolverAstLowering,\n+    definitions: &'a mut Definitions,\n+    cstore: &'a CrateStoreDyn,\n+    resolutions: &'a ResolverOutputs,\n+    resolver: &'a mut ResolverAstLowering,\n \n     /// Used to allocate HIR nodes.\n     arena: &'hir Arena<'hir>,\n@@ -134,46 +139,6 @@ struct LoweringContext<'a, 'hir: 'a> {\n     allow_into_future: Option<Lrc<[Symbol]>>,\n }\n \n-/// Resolution for a lifetime appearing in a type.\n-#[derive(Copy, Clone, Debug)]\n-pub enum LifetimeRes {\n-    /// Successfully linked the lifetime to a generic parameter.\n-    Param {\n-        /// Id of the generic parameter that introduced it.\n-        param: LocalDefId,\n-        /// Id of the introducing place. That can be:\n-        /// - an item's id, for the item's generic parameters;\n-        /// - a TraitRef's ref_id, identifying the `for<...>` binder;\n-        /// - a BareFn type's id;\n-        /// - a Path's id when this path has parenthesized generic args.\n-        ///\n-        /// This information is used for impl-trait lifetime captures, to know when to or not to\n-        /// capture any given lifetime.\n-        binder: NodeId,\n-    },\n-    /// Created a generic parameter for an anonymous lifetime.\n-    Fresh {\n-        /// Id of the generic parameter that introduced it.\n-        param: LocalDefId,\n-        /// Id of the introducing place. See `Param`.\n-        binder: NodeId,\n-    },\n-    /// This variant is used for anonymous lifetimes that we did not resolve during\n-    /// late resolution.  Shifting the work to the HIR lifetime resolver.\n-    Anonymous {\n-        /// Id of the introducing place. See `Param`.\n-        binder: NodeId,\n-        /// Whether this lifetime was spelled or elided.\n-        elided: bool,\n-    },\n-    /// Explicit `'static` lifetime.\n-    Static,\n-    /// Resolution failure.\n-    Error,\n-    /// HACK: This is used to recover the NodeId of an elided lifetime.\n-    ElidedAnchor { start: NodeId, end: NodeId },\n-}\n-\n /// When we lower a lifetime, it is inserted in `captures`, and the resolution is modified so\n /// to point to the lifetime parameter impl-trait will generate.\n /// When traversing `for<...>` binders, they are inserted in `binders_to_ignore` so we know *not*\n@@ -196,54 +161,75 @@ struct LifetimeCaptureContext {\n     binders_to_ignore: FxHashSet<NodeId>,\n }\n \n-pub trait ResolverAstLowering {\n-    fn def_key(&self, id: DefId) -> DefKey;\n-\n-    fn def_span(&self, id: LocalDefId) -> Span;\n-\n-    fn item_generics_num_lifetimes(&self, def: DefId) -> usize;\n-\n-    fn legacy_const_generic_args(&mut self, expr: &Expr) -> Option<Vec<usize>>;\n-\n-    /// Obtains resolution for a `NodeId` with a single resolution.\n+trait ResolverAstLoweringExt {\n+    fn legacy_const_generic_args(&self, expr: &Expr) -> Option<Vec<usize>>;\n     fn get_partial_res(&self, id: NodeId) -> Option<PartialRes>;\n-\n-    /// Obtains per-namespace resolutions for `use` statement with the given `NodeId`.\n     fn get_import_res(&self, id: NodeId) -> PerNS<Option<Res<NodeId>>>;\n-\n-    /// Obtains resolution for a label with the given `NodeId`.\n     fn get_label_res(&self, id: NodeId) -> Option<NodeId>;\n-\n-    /// Obtains resolution for a lifetime with the given `NodeId`.\n     fn get_lifetime_res(&self, id: NodeId) -> Option<LifetimeRes>;\n-\n-    /// Obtain the list of lifetimes parameters to add to an item.\n     fn take_extra_lifetime_params(&mut self, id: NodeId) -> Vec<(Ident, NodeId, LifetimeRes)>;\n+    fn decl_macro_kind(&self, def_id: LocalDefId) -> MacroKind;\n+}\n \n-    fn create_stable_hashing_context(&self) -> StableHashingContext<'_>;\n+impl ResolverAstLoweringExt for ResolverAstLowering {\n+    fn legacy_const_generic_args(&self, expr: &Expr) -> Option<Vec<usize>> {\n+        if let ExprKind::Path(None, path) = &expr.kind {\n+            // Don't perform legacy const generics rewriting if the path already\n+            // has generic arguments.\n+            if path.segments.last().unwrap().args.is_some() {\n+                return None;\n+            }\n \n-    fn definitions(&self) -> &Definitions;\n+            let partial_res = self.partial_res_map.get(&expr.id)?;\n+            if partial_res.unresolved_segments() != 0 {\n+                return None;\n+            }\n \n-    fn next_node_id(&mut self) -> NodeId;\n+            if let Res::Def(DefKind::Fn, def_id) = partial_res.base_res() {\n+                // We only support cross-crate argument rewriting. Uses\n+                // within the same crate should be updated to use the new\n+                // const generics style.\n+                if def_id.is_local() {\n+                    return None;\n+                }\n \n-    fn take_trait_map(&mut self, node: NodeId) -> Option<Vec<hir::TraitCandidate>>;\n+                if let Some(v) = self.legacy_const_generic_args.get(&def_id) {\n+                    return v.clone();\n+                }\n+            }\n+        }\n \n-    fn opt_local_def_id(&self, node: NodeId) -> Option<LocalDefId>;\n+        None\n+    }\n \n-    fn local_def_id(&self, node: NodeId) -> LocalDefId;\n+    /// Obtains resolution for a `NodeId` with a single resolution.\n+    fn get_partial_res(&self, id: NodeId) -> Option<PartialRes> {\n+        self.partial_res_map.get(&id).copied()\n+    }\n \n-    fn def_path_hash(&self, def_id: DefId) -> DefPathHash;\n+    /// Obtains per-namespace resolutions for `use` statement with the given `NodeId`.\n+    fn get_import_res(&self, id: NodeId) -> PerNS<Option<Res<NodeId>>> {\n+        self.import_res_map.get(&id).copied().unwrap_or_default()\n+    }\n \n-    fn create_def(\n-        &mut self,\n-        parent: LocalDefId,\n-        node_id: ast::NodeId,\n-        data: DefPathData,\n-        expn_id: ExpnId,\n-        span: Span,\n-    ) -> LocalDefId;\n+    /// Obtains resolution for a label with the given `NodeId`.\n+    fn get_label_res(&self, id: NodeId) -> Option<NodeId> {\n+        self.label_res_map.get(&id).copied()\n+    }\n \n-    fn decl_macro_kind(&self, def_id: LocalDefId) -> MacroKind;\n+    /// Obtains resolution for a lifetime with the given `NodeId`.\n+    fn get_lifetime_res(&self, id: NodeId) -> Option<LifetimeRes> {\n+        self.lifetimes_res_map.get(&id).copied()\n+    }\n+\n+    /// Obtain the list of lifetimes parameters to add to an item.\n+    fn take_extra_lifetime_params(&mut self, id: NodeId) -> Vec<(Ident, NodeId, LifetimeRes)> {\n+        self.extra_lifetime_params_map.remove(&id).unwrap_or_default()\n+    }\n+\n+    fn decl_macro_kind(&self, def_id: LocalDefId) -> MacroKind {\n+        self.builtin_macro_kinds.get(&def_id).copied().unwrap_or(MacroKind::Bang)\n+    }\n }\n \n /// Context of `impl Trait` in code, which determines whether it is allowed in an HIR subtree,\n@@ -353,17 +339,17 @@ enum AstOwner<'a> {\n }\n \n fn index_crate<'a>(\n-    resolver: &dyn ResolverAstLowering,\n+    node_id_to_def_id: &FxHashMap<NodeId, LocalDefId>,\n     krate: &'a Crate,\n ) -> IndexVec<LocalDefId, AstOwner<'a>> {\n-    let mut indexer = Indexer { resolver, index: IndexVec::new() };\n+    let mut indexer = Indexer { node_id_to_def_id, index: IndexVec::new() };\n     indexer.index.ensure_contains_elem(CRATE_DEF_ID, || AstOwner::NonOwner);\n     indexer.index[CRATE_DEF_ID] = AstOwner::Crate(krate);\n     visit::walk_crate(&mut indexer, krate);\n     return indexer.index;\n \n     struct Indexer<'s, 'a> {\n-        resolver: &'s dyn ResolverAstLowering,\n+        node_id_to_def_id: &'s FxHashMap<NodeId, LocalDefId>,\n         index: IndexVec<LocalDefId, AstOwner<'a>>,\n     }\n \n@@ -374,21 +360,21 @@ fn index_crate<'a>(\n         }\n \n         fn visit_item(&mut self, item: &'a ast::Item) {\n-            let def_id = self.resolver.local_def_id(item.id);\n+            let def_id = self.node_id_to_def_id[&item.id];\n             self.index.ensure_contains_elem(def_id, || AstOwner::NonOwner);\n             self.index[def_id] = AstOwner::Item(item);\n             visit::walk_item(self, item)\n         }\n \n         fn visit_assoc_item(&mut self, item: &'a ast::AssocItem, ctxt: visit::AssocCtxt) {\n-            let def_id = self.resolver.local_def_id(item.id);\n+            let def_id = self.node_id_to_def_id[&item.id];\n             self.index.ensure_contains_elem(def_id, || AstOwner::NonOwner);\n             self.index[def_id] = AstOwner::AssocItem(item, ctxt);\n             visit::walk_assoc_item(self, item, ctxt);\n         }\n \n         fn visit_foreign_item(&mut self, item: &'a ast::ForeignItem) {\n-            let def_id = self.resolver.local_def_id(item.id);\n+            let def_id = self.node_id_to_def_id[&item.id];\n             self.index.ensure_contains_elem(def_id, || AstOwner::NonOwner);\n             self.index[def_id] = AstOwner::ForeignItem(item);\n             visit::walk_foreign_item(self, item);\n@@ -399,44 +385,59 @@ fn index_crate<'a>(\n /// Compute the hash for the HIR of the full crate.\n /// This hash will then be part of the crate_hash which is stored in the metadata.\n fn compute_hir_hash(\n-    resolver: &mut dyn ResolverAstLowering,\n+    sess: &Session,\n+    definitions: &Definitions,\n+    cstore: &CrateStoreDyn,\n+    resolver: &ResolverOutputs,\n     owners: &IndexVec<LocalDefId, hir::MaybeOwner<&hir::OwnerInfo<'_>>>,\n ) -> Fingerprint {\n     let mut hir_body_nodes: Vec<_> = owners\n         .iter_enumerated()\n         .filter_map(|(def_id, info)| {\n             let info = info.as_owner()?;\n-            let def_path_hash = resolver.definitions().def_path_hash(def_id);\n+            let def_path_hash = definitions.def_path_hash(def_id);\n             Some((def_path_hash, info))\n         })\n         .collect();\n     hir_body_nodes.sort_unstable_by_key(|bn| bn.0);\n \n     let mut stable_hasher = StableHasher::new();\n-    let mut hcx = resolver.create_stable_hashing_context();\n+    let mut hcx = StableHashingContext::new(sess, definitions, cstore, &resolver.source_span);\n     hir_body_nodes.hash_stable(&mut hcx, &mut stable_hasher);\n     stable_hasher.finish()\n }\n \n-pub fn lower_crate<'a, 'hir>(\n-    sess: &'a Session,\n-    krate: &'a Crate,\n-    resolver: &'a mut dyn ResolverAstLowering,\n+pub fn lower_crate<'hir>(\n+    sess: &Session,\n+    krate: &Crate,\n+    definitions: &mut Definitions,\n+    cstore: &CrateStoreDyn,\n+    resolutions: &ResolverOutputs,\n+    mut resolver: ResolverAstLowering,\n     arena: &'hir Arena<'hir>,\n ) -> &'hir hir::Crate<'hir> {\n     let _prof_timer = sess.prof.verbose_generic_activity(\"hir_lowering\");\n \n-    let ast_index = index_crate(resolver, krate);\n+    let ast_index = index_crate(&resolver.node_id_to_def_id, krate);\n \n     let mut owners =\n-        IndexVec::from_fn_n(|_| hir::MaybeOwner::Phantom, resolver.definitions().def_index_count());\n+        IndexVec::from_fn_n(|_| hir::MaybeOwner::Phantom, definitions.def_index_count());\n \n     for def_id in ast_index.indices() {\n-        item::ItemLowerer { sess, resolver, arena, ast_index: &ast_index, owners: &mut owners }\n-            .lower_node(def_id);\n+        item::ItemLowerer {\n+            sess,\n+            definitions,\n+            cstore,\n+            resolutions,\n+            resolver: &mut resolver,\n+            arena,\n+            ast_index: &ast_index,\n+            owners: &mut owners,\n+        }\n+        .lower_node(def_id);\n     }\n \n-    let hir_hash = compute_hir_hash(resolver, &owners);\n+    let hir_hash = compute_hir_hash(sess, definitions, cstore, resolutions, &owners);\n     let krate = hir::Crate { owners, hir_hash };\n     arena.alloc(krate)\n }\n@@ -457,13 +458,64 @@ enum ParenthesizedGenericArgs {\n }\n \n impl<'a, 'hir> LoweringContext<'a, 'hir> {\n+    fn create_stable_hashing_context(&self) -> StableHashingContext<'_> {\n+        StableHashingContext::new(\n+            self.sess,\n+            self.definitions,\n+            self.cstore,\n+            &self.resolutions.source_span,\n+        )\n+    }\n+\n+    fn create_def(\n+        &mut self,\n+        parent: LocalDefId,\n+        node_id: ast::NodeId,\n+        data: DefPathData,\n+    ) -> LocalDefId {\n+        assert!(\n+            self.opt_local_def_id(node_id).is_none(),\n+            \"adding a def'n for node-id {:?} and data {:?} but a previous def'n exists: {:?}\",\n+            node_id,\n+            data,\n+            self.definitions.def_key(self.local_def_id(node_id)),\n+        );\n+\n+        let def_id = self.definitions.create_def(parent, data);\n+\n+        // Some things for which we allocate `LocalDefId`s don't correspond to\n+        // anything in the AST, so they don't have a `NodeId`. For these cases\n+        // we don't need a mapping from `NodeId` to `LocalDefId`.\n+        if node_id != ast::DUMMY_NODE_ID {\n+            debug!(\"create_def: def_id_to_node_id[{:?}] <-> {:?}\", def_id, node_id);\n+            self.resolver.node_id_to_def_id.insert(node_id, def_id);\n+        }\n+\n+        def_id\n+    }\n+\n+    fn next_node_id(&mut self) -> NodeId {\n+        let start = self.resolver.next_node_id;\n+        let next = start.as_u32().checked_add(1).expect(\"input too large; ran out of NodeIds\");\n+        self.resolver.next_node_id = ast::NodeId::from_u32(next);\n+        start\n+    }\n+\n+    fn opt_local_def_id(&self, node: NodeId) -> Option<LocalDefId> {\n+        self.resolver.node_id_to_def_id.get(&node).copied()\n+    }\n+\n+    fn local_def_id(&self, node: NodeId) -> LocalDefId {\n+        self.opt_local_def_id(node).unwrap_or_else(|| panic!(\"no entry for node id: `{:?}`\", node))\n+    }\n+\n     #[instrument(level = \"debug\", skip(self, f))]\n     fn with_hir_id_owner(\n         &mut self,\n         owner: NodeId,\n         f: impl FnOnce(&mut Self) -> hir::OwnerNode<'hir>,\n     ) {\n-        let def_id = self.resolver.local_def_id(owner);\n+        let def_id = self.local_def_id(owner);\n \n         let current_attrs = std::mem::take(&mut self.attrs);\n         let current_bodies = std::mem::take(&mut self.bodies);\n@@ -475,6 +527,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             std::mem::replace(&mut self.item_local_id_counter, hir::ItemLocalId::new(1));\n         let current_impl_trait_defs = std::mem::take(&mut self.impl_trait_defs);\n         let current_impl_trait_bounds = std::mem::take(&mut self.impl_trait_bounds);\n+        // Do not reset `next_node_id` and `node_id_to_def_id` as we want to refer to the\n+        // subdefinitions' nodes.\n \n         // Always allocate the first `HirId` for the owner itself.\n         let _old = self.node_id_to_local_id.insert(owner, hir::ItemLocalId::new(0));\n@@ -518,8 +572,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         bodies.sort_by_key(|(k, _)| *k);\n         let bodies = SortedMap::from_presorted_elements(bodies);\n         let (hash_including_bodies, hash_without_bodies) = self.hash_owner(node, &bodies);\n-        let (nodes, parenting) =\n-            index::index_hir(self.sess, self.resolver.definitions(), node, &bodies);\n+        let (nodes, parenting) = index::index_hir(self.sess, self.definitions, node, &bodies);\n         let nodes = hir::OwnerNodes {\n             hash_including_bodies,\n             hash_without_bodies,\n@@ -528,7 +581,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             local_id_to_def_id,\n         };\n         let attrs = {\n-            let mut hcx = self.resolver.create_stable_hashing_context();\n+            let mut hcx = self.create_stable_hashing_context();\n             let mut stable_hasher = StableHasher::new();\n             attrs.hash_stable(&mut hcx, &mut stable_hasher);\n             let hash = stable_hasher.finish();\n@@ -545,7 +598,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         node: hir::OwnerNode<'hir>,\n         bodies: &SortedMap<hir::ItemLocalId, &'hir hir::Body<'hir>>,\n     ) -> (Fingerprint, Fingerprint) {\n-        let mut hcx = self.resolver.create_stable_hashing_context();\n+        let mut hcx = self.create_stable_hashing_context();\n         let mut stable_hasher = StableHasher::new();\n         hcx.with_hir_bodies(true, node.def_id(), bodies, |hcx| {\n             node.hash_stable(hcx, &mut stable_hasher)\n@@ -582,13 +635,13 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 self.item_local_id_counter.increment_by(1);\n \n                 assert_ne!(local_id, hir::ItemLocalId::new(0));\n-                if let Some(def_id) = self.resolver.opt_local_def_id(ast_node_id) {\n+                if let Some(def_id) = self.opt_local_def_id(ast_node_id) {\n                     // Do not override a `MaybeOwner::Owner` that may already here.\n                     self.children.entry(def_id).or_insert(hir::MaybeOwner::NonOwner(hir_id));\n                     self.local_id_to_def_id.insert(local_id, def_id);\n                 }\n \n-                if let Some(traits) = self.resolver.take_trait_map(ast_node_id) {\n+                if let Some(traits) = self.resolver.trait_map.remove(&ast_node_id) {\n                     self.trait_map.insert(hir_id.local_id, traits.into_boxed_slice());\n                 }\n \n@@ -598,7 +651,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     }\n \n     fn next_id(&mut self) -> hir::HirId {\n-        let node_id = self.resolver.next_node_id();\n+        let node_id = self.next_node_id();\n         self.lower_node_id(node_id)\n     }\n \n@@ -648,7 +701,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             allow_internal_unstable,\n             reason,\n             self.sess.edition(),\n-            self.resolver.create_stable_hashing_context(),\n+            self.create_stable_hashing_context(),\n         )\n     }\n \n@@ -940,17 +993,11 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     // constructing the HIR for `impl bounds...` and then lowering that.\n \n                     let parent_def_id = self.current_hir_id_owner;\n-                    let impl_trait_node_id = self.resolver.next_node_id();\n-                    self.resolver.create_def(\n-                        parent_def_id,\n-                        impl_trait_node_id,\n-                        DefPathData::ImplTrait,\n-                        ExpnId::root(),\n-                        constraint.span,\n-                    );\n+                    let impl_trait_node_id = self.next_node_id();\n+                    self.create_def(parent_def_id, impl_trait_node_id, DefPathData::ImplTrait);\n \n                     self.with_dyn_type_scope(false, |this| {\n-                        let node_id = this.resolver.next_node_id();\n+                        let node_id = this.next_node_id();\n                         let ty = this.lower_ty(\n                             &Ty {\n                                 id: node_id,\n@@ -1050,16 +1097,10 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                                 // Construct an AnonConst where the expr is the \"ty\"'s path.\n \n                                 let parent_def_id = self.current_hir_id_owner;\n-                                let node_id = self.resolver.next_node_id();\n+                                let node_id = self.next_node_id();\n \n                                 // Add a definition for the in-band const def.\n-                                self.resolver.create_def(\n-                                    parent_def_id,\n-                                    node_id,\n-                                    DefPathData::AnonConst,\n-                                    ExpnId::root(),\n-                                    ty.span,\n-                                );\n+                                self.create_def(parent_def_id, node_id, DefPathData::AnonConst);\n \n                                 let span = self.lower_span(ty.span);\n                                 let path_expr = Expr {\n@@ -1129,7 +1170,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         debug_assert_eq!(start.plus(1), end);\n                         start\n                     } else {\n-                        self.resolver.next_node_id()\n+                        self.next_node_id()\n                     };\n                     let span = self.sess.source_map().next_point(t.span.shrink_to_lo());\n                     Lifetime { ident: Ident::new(kw::UnderscoreLifetime, span), id }\n@@ -1272,7 +1313,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         // frequently opened issues show.\n         let opaque_ty_span = self.mark_span_with_reason(DesugaringKind::OpaqueTy, span, None);\n \n-        let opaque_ty_def_id = self.resolver.local_def_id(opaque_ty_node_id);\n+        let opaque_ty_def_id = self.local_def_id(opaque_ty_node_id);\n \n         let mut collected_lifetimes = FxHashMap::default();\n         self.with_hir_id_owner(opaque_ty_node_id, |lctx| {\n@@ -1290,7 +1331,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             let lifetime_defs = lctx.arena.alloc_from_iter(collected_lifetimes.iter().map(\n                 |(_, &(span, p_id, p_name, _))| {\n                     let hir_id = lctx.lower_node_id(p_id);\n-                    debug_assert_ne!(lctx.resolver.opt_local_def_id(p_id), None);\n+                    debug_assert_ne!(lctx.opt_local_def_id(p_id), None);\n \n                     let kind = if p_name.ident().name == kw::UnderscoreLifetime {\n                         hir::LifetimeParamKind::Elided\n@@ -1329,7 +1370,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n         let lifetimes = self.arena.alloc_from_iter(collected_lifetimes.into_iter().map(\n             |(_, (span, _, p_name, res))| {\n-                let id = self.resolver.next_node_id();\n+                let id = self.next_node_id();\n                 let ident = Ident::new(p_name.ident().name, span);\n                 let l = self.new_named_lifetime_with_res(id, span, ident, res);\n                 hir::GenericArg::Lifetime(l)\n@@ -1438,7 +1479,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 FnRetTy::Ty(ref ty) => {\n                     let context = match fn_node_id {\n                         Some(fn_node_id) if kind.impl_trait_return_allowed() => {\n-                            let fn_def_id = self.resolver.local_def_id(fn_node_id);\n+                            let fn_def_id = self.local_def_id(fn_node_id);\n                             ImplTraitContext::ReturnPositionOpaqueTy {\n                                 origin: hir::OpaqueTyOrigin::FnReturn(fn_def_id),\n                             }\n@@ -1512,8 +1553,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n         let opaque_ty_span = self.mark_span_with_reason(DesugaringKind::Async, span, None);\n \n-        let opaque_ty_def_id = self.resolver.local_def_id(opaque_ty_node_id);\n-        let fn_def_id = self.resolver.local_def_id(fn_node_id);\n+        let opaque_ty_def_id = self.local_def_id(opaque_ty_node_id);\n+        let fn_def_id = self.local_def_id(fn_node_id);\n \n         // When we create the opaque type for this async fn, it is going to have\n         // to capture all the lifetimes involved in the signature (including in the\n@@ -1563,17 +1604,11 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         debug!(?extra_lifetime_params);\n         for (ident, outer_node_id, outer_res) in extra_lifetime_params {\n             let Ident { name, span } = ident;\n-            let outer_def_id = self.resolver.local_def_id(outer_node_id);\n-            let inner_node_id = self.resolver.next_node_id();\n+            let outer_def_id = self.local_def_id(outer_node_id);\n+            let inner_node_id = self.next_node_id();\n \n             // Add a definition for the in scope lifetime def.\n-            self.resolver.create_def(\n-                opaque_ty_def_id,\n-                inner_node_id,\n-                DefPathData::LifetimeNs(name),\n-                ExpnId::root(),\n-                span.with_parent(None),\n-            );\n+            self.create_def(opaque_ty_def_id, inner_node_id, DefPathData::LifetimeNs(name));\n \n             let (p_name, inner_res) = match outer_res {\n                 // Input lifetime like `'a`:\n@@ -1614,7 +1649,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             let generic_params =\n                 this.arena.alloc_from_iter(captures.iter().map(|(_, &(span, p_id, p_name, _))| {\n                     let hir_id = this.lower_node_id(p_id);\n-                    debug_assert_ne!(this.resolver.opt_local_def_id(p_id), None);\n+                    debug_assert_ne!(this.opt_local_def_id(p_id), None);\n \n                     let kind = if p_name.ident().name == kw::UnderscoreLifetime {\n                         hir::LifetimeParamKind::Elided\n@@ -1666,7 +1701,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         // generate `'_`.\n         let generic_args =\n             self.arena.alloc_from_iter(captures.into_iter().map(|(_, (span, _, p_name, res))| {\n-                let id = self.resolver.next_node_id();\n+                let id = self.next_node_id();\n                 let ident = Ident::new(p_name.ident().name, span);\n                 let l = self.new_named_lifetime_with_res(id, span, ident, res);\n                 hir::GenericArg::Lifetime(l)\n@@ -1757,74 +1792,74 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             LifetimeRes::Param { mut param, binder } => {\n                 debug_assert_ne!(ident.name, kw::UnderscoreLifetime);\n                 let p_name = ParamName::Plain(ident);\n-                if let Some(LifetimeCaptureContext { parent_def_id, captures, binders_to_ignore }) =\n-                    &mut self.captured_lifetimes\n-                    && !binders_to_ignore.contains(&binder)\n-                {\n-                    match captures.entry(param) {\n-                        Entry::Occupied(o) => param = self.resolver.local_def_id(o.get().1),\n-                        Entry::Vacant(v) => {\n-                            let p_id = self.resolver.next_node_id();\n-                            let p_def_id = self.resolver.create_def(\n-                                *parent_def_id,\n-                                p_id,\n-                                DefPathData::LifetimeNs(p_name.ident().name),\n-                                ExpnId::root(),\n-                                span.with_parent(None),\n-                            );\n-\n-                            v.insert((span, p_id, p_name, res));\n-                            param = p_def_id;\n+                if let Some(mut captured_lifetimes) = self.captured_lifetimes.take() {\n+                    if !captured_lifetimes.binders_to_ignore.contains(&binder) {\n+                        match captured_lifetimes.captures.entry(param) {\n+                            Entry::Occupied(o) => param = self.local_def_id(o.get().1),\n+                            Entry::Vacant(v) => {\n+                                let p_id = self.next_node_id();\n+                                let p_def_id = self.create_def(\n+                                    captured_lifetimes.parent_def_id,\n+                                    p_id,\n+                                    DefPathData::LifetimeNs(p_name.ident().name),\n+                                );\n+\n+                                v.insert((span, p_id, p_name, res));\n+                                param = p_def_id;\n+                            }\n                         }\n                     }\n+\n+                    self.captured_lifetimes = Some(captured_lifetimes);\n                 }\n                 hir::LifetimeName::Param(param, p_name)\n             }\n             LifetimeRes::Fresh { mut param, binder } => {\n                 debug_assert_eq!(ident.name, kw::UnderscoreLifetime);\n-                if let Some(LifetimeCaptureContext { parent_def_id, captures, binders_to_ignore }) =\n-                    &mut self.captured_lifetimes\n-                    && !binders_to_ignore.contains(&binder)\n-                {\n-                    match captures.entry(param) {\n-                        Entry::Occupied(o) => param = self.resolver.local_def_id(o.get().1),\n-                        Entry::Vacant(v) => {\n-                            let p_id = self.resolver.next_node_id();\n-                            let p_def_id = self.resolver.create_def(\n-                                *parent_def_id,\n-                                p_id,\n-                                DefPathData::LifetimeNs(kw::UnderscoreLifetime),\n-                                ExpnId::root(),\n-                                span.with_parent(None),\n-                            );\n-\n-                            v.insert((span, p_id, ParamName::Fresh, res));\n-                            param = p_def_id;\n+                if let Some(mut captured_lifetimes) = self.captured_lifetimes.take() {\n+                    if !captured_lifetimes.binders_to_ignore.contains(&binder) {\n+                        match captured_lifetimes.captures.entry(param) {\n+                            Entry::Occupied(o) => param = self.local_def_id(o.get().1),\n+                            Entry::Vacant(v) => {\n+                                let p_id = self.next_node_id();\n+                                let p_def_id = self.create_def(\n+                                    captured_lifetimes.parent_def_id,\n+                                    p_id,\n+                                    DefPathData::LifetimeNs(kw::UnderscoreLifetime),\n+                                );\n+\n+                                v.insert((span, p_id, ParamName::Fresh, res));\n+                                param = p_def_id;\n+                            }\n                         }\n                     }\n+\n+                    self.captured_lifetimes = Some(captured_lifetimes);\n                 }\n                 hir::LifetimeName::Param(param, ParamName::Fresh)\n             }\n             LifetimeRes::Anonymous { binder, elided } => {\n-                if let Some(LifetimeCaptureContext { parent_def_id, captures, binders_to_ignore }) =\n-                    &mut self.captured_lifetimes\n-                    && !binders_to_ignore.contains(&binder)\n-                {\n-                    let p_id = self.resolver.next_node_id();\n-                    let p_def_id = self.resolver.create_def(\n-                        *parent_def_id,\n-                        p_id,\n-                        DefPathData::LifetimeNs(kw::UnderscoreLifetime),\n-                        ExpnId::root(),\n-                        span.with_parent(None),\n-                    );\n-                    captures.insert(p_def_id, (span, p_id, ParamName::Fresh, res));\n-                    hir::LifetimeName::Param(p_def_id, ParamName::Fresh)\n-                } else if elided {\n+                let mut l_name = None;\n+                if let Some(mut captured_lifetimes) = self.captured_lifetimes.take() {\n+                    if !captured_lifetimes.binders_to_ignore.contains(&binder) {\n+                        let p_id = self.next_node_id();\n+                        let p_def_id = self.create_def(\n+                            captured_lifetimes.parent_def_id,\n+                            p_id,\n+                            DefPathData::LifetimeNs(kw::UnderscoreLifetime),\n+                        );\n+                        captured_lifetimes\n+                            .captures\n+                            .insert(p_def_id, (span, p_id, ParamName::Fresh, res));\n+                        l_name = Some(hir::LifetimeName::Param(p_def_id, ParamName::Fresh));\n+                    }\n+                    self.captured_lifetimes = Some(captured_lifetimes);\n+                };\n+                l_name.unwrap_or(if elided {\n                     hir::LifetimeName::Implicit\n                 } else {\n                     hir::LifetimeName::Underscore\n-                }\n+                })\n             }\n             LifetimeRes::Static => hir::LifetimeName::Static,\n             LifetimeRes::Error => hir::LifetimeName::Error,\n@@ -1954,7 +1989,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         bounds: &[GenericBound],\n     ) -> (hir::GenericParam<'hir>, Option<hir::WherePredicate<'hir>>, hir::TyKind<'hir>) {\n         // Add a definition for the in-band `Param`.\n-        let def_id = self.resolver.local_def_id(node_id);\n+        let def_id = self.local_def_id(node_id);\n \n         let hir_bounds = self.lower_param_bounds(bounds, ImplTraitContext::Universal);\n         // Set the name to `impl Bound1 + Bound2`."}, {"sha": "bd2e76e5528dab08b8a07e00353bc7bdbfb1e906", "filename": "compiler/rustc_ast_lowering/src/pat.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3a8b0144c82197a70e919ad371d56f82c2282833/compiler%2Frustc_ast_lowering%2Fsrc%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a8b0144c82197a70e919ad371d56f82c2282833/compiler%2Frustc_ast_lowering%2Fsrc%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fpat.rs?ref=3a8b0144c82197a70e919ad371d56f82c2282833", "patch": "@@ -1,6 +1,6 @@\n-use crate::ImplTraitPosition;\n-\n+use super::ResolverAstLoweringExt;\n use super::{ImplTraitContext, LoweringContext, ParamMode};\n+use crate::ImplTraitPosition;\n \n use rustc_ast::ptr::P;\n use rustc_ast::*;"}, {"sha": "bd95b5850df750527fc6b6a803b288b536c31607", "filename": "compiler/rustc_ast_lowering/src/path.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3a8b0144c82197a70e919ad371d56f82c2282833/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a8b0144c82197a70e919ad371d56f82c2282833/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs?ref=3a8b0144c82197a70e919ad371d56f82c2282833", "patch": "@@ -1,5 +1,6 @@\n use crate::ImplTraitPosition;\n \n+use super::ResolverAstLoweringExt;\n use super::{GenericArgsCtor, LifetimeRes, ParenthesizedGenericArgs};\n use super::{ImplTraitContext, LoweringContext, ParamMode};\n "}, {"sha": "3927523f4c6ab6cd4375da23bbf02fb0efccf1c7", "filename": "compiler/rustc_hir/src/def.rs", "status": "modified", "additions": 41, "deletions": 1, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/3a8b0144c82197a70e919ad371d56f82c2282833/compiler%2Frustc_hir%2Fsrc%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a8b0144c82197a70e919ad371d56f82c2282833/compiler%2Frustc_hir%2Fsrc%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fdef.rs?ref=3a8b0144c82197a70e919ad371d56f82c2282833", "patch": "@@ -1,9 +1,9 @@\n-use crate::def_id::DefId;\n use crate::hir;\n \n use rustc_ast as ast;\n use rustc_ast::NodeId;\n use rustc_macros::HashStable_Generic;\n+use rustc_span::def_id::{DefId, LocalDefId};\n use rustc_span::hygiene::MacroKind;\n use rustc_span::Symbol;\n \n@@ -711,3 +711,43 @@ impl<Id> Res<Id> {\n         matches!(self, Res::Def(DefKind::Ctor(_, CtorKind::Const), _) | Res::SelfCtor(..))\n     }\n }\n+\n+/// Resolution for a lifetime appearing in a type.\n+#[derive(Copy, Clone, Debug)]\n+pub enum LifetimeRes {\n+    /// Successfully linked the lifetime to a generic parameter.\n+    Param {\n+        /// Id of the generic parameter that introduced it.\n+        param: LocalDefId,\n+        /// Id of the introducing place. That can be:\n+        /// - an item's id, for the item's generic parameters;\n+        /// - a TraitRef's ref_id, identifying the `for<...>` binder;\n+        /// - a BareFn type's id;\n+        /// - a Path's id when this path has parenthesized generic args.\n+        ///\n+        /// This information is used for impl-trait lifetime captures, to know when to or not to\n+        /// capture any given lifetime.\n+        binder: NodeId,\n+    },\n+    /// Created a generic parameter for an anonymous lifetime.\n+    Fresh {\n+        /// Id of the generic parameter that introduced it.\n+        param: LocalDefId,\n+        /// Id of the introducing place. See `Param`.\n+        binder: NodeId,\n+    },\n+    /// This variant is used for anonymous lifetimes that we did not resolve during\n+    /// late resolution.  Shifting the work to the HIR lifetime resolver.\n+    Anonymous {\n+        /// Id of the introducing place. See `Param`.\n+        binder: NodeId,\n+        /// Whether this lifetime was spelled or elided.\n+        elided: bool,\n+    },\n+    /// Explicit `'static` lifetime.\n+    Static,\n+    /// Resolution failure.\n+    Error,\n+    /// HACK: This is used to recover the NodeId of an elided lifetime.\n+    ElidedAnchor { start: NodeId, end: NodeId },\n+}"}, {"sha": "5f8801cc4e20d67cc180edc5af4b049e81520be8", "filename": "compiler/rustc_hir/src/definitions.rs", "status": "modified", "additions": 5, "deletions": 51, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/3a8b0144c82197a70e919ad371d56f82c2282833/compiler%2Frustc_hir%2Fsrc%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a8b0144c82197a70e919ad371d56f82c2282833/compiler%2Frustc_hir%2Fsrc%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fdefinitions.rs?ref=3a8b0144c82197a70e919ad371d56f82c2282833", "patch": "@@ -11,9 +11,7 @@ use crate::def_path_hash_map::DefPathHashMap;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::StableHasher;\n use rustc_index::vec::IndexVec;\n-use rustc_span::hygiene::ExpnId;\n use rustc_span::symbol::{kw, sym, Symbol};\n-use rustc_span::Span;\n \n use std::fmt::{self, Write};\n use std::hash::Hash;\n@@ -101,11 +99,6 @@ pub struct Definitions {\n     table: DefPathTable,\n     next_disambiguator: FxHashMap<(LocalDefId, DefPathData), u32>,\n \n-    /// Item with a given `LocalDefId` was defined during macro expansion with ID `ExpnId`.\n-    expansions_that_defined: FxHashMap<LocalDefId, ExpnId>,\n-\n-    def_id_to_span: IndexVec<LocalDefId, Span>,\n-\n     /// The [StableCrateId] of the local crate.\n     stable_crate_id: StableCrateId,\n }\n@@ -323,7 +316,7 @@ impl Definitions {\n     }\n \n     /// Adds a root definition (no parent) and a few other reserved definitions.\n-    pub fn new(stable_crate_id: StableCrateId, crate_span: Span) -> Definitions {\n+    pub fn new(stable_crate_id: StableCrateId) -> Definitions {\n         let key = DefKey {\n             parent: None,\n             disambiguated_data: DisambiguatedDefPathData {\n@@ -340,30 +333,12 @@ impl Definitions {\n         let root = LocalDefId { local_def_index: table.allocate(key, def_path_hash) };\n         assert_eq!(root.local_def_index, CRATE_DEF_INDEX);\n \n-        let mut def_id_to_span = IndexVec::new();\n-        // A relative span's parent must be an absolute span.\n-        debug_assert_eq!(crate_span.data_untracked().parent, None);\n-        let _root = def_id_to_span.push(crate_span);\n-        debug_assert_eq!(_root, root);\n-\n-        Definitions {\n-            table,\n-            next_disambiguator: Default::default(),\n-            expansions_that_defined: Default::default(),\n-            def_id_to_span,\n-            stable_crate_id,\n-        }\n+        Definitions { table, next_disambiguator: Default::default(), stable_crate_id }\n     }\n \n     /// Adds a definition with a parent definition.\n-    pub fn create_def(\n-        &mut self,\n-        parent: LocalDefId,\n-        data: DefPathData,\n-        expn_id: ExpnId,\n-        span: Span,\n-    ) -> LocalDefId {\n-        debug!(\"create_def(parent={:?}, data={:?}, expn_id={:?})\", parent, data, expn_id);\n+    pub fn create_def(&mut self, parent: LocalDefId, data: DefPathData) -> LocalDefId {\n+        debug!(\"create_def(parent={:?}, data={:?})\", parent, data);\n \n         // The root node must be created with `create_root_def()`.\n         assert!(data != DefPathData::CrateRoot);\n@@ -386,28 +361,7 @@ impl Definitions {\n         debug!(\"create_def: after disambiguation, key = {:?}\", key);\n \n         // Create the definition.\n-        let def_id = LocalDefId { local_def_index: self.table.allocate(key, def_path_hash) };\n-\n-        if expn_id != ExpnId::root() {\n-            self.expansions_that_defined.insert(def_id, expn_id);\n-        }\n-\n-        // A relative span's parent must be an absolute span.\n-        debug_assert_eq!(span.data_untracked().parent, None);\n-        let _id = self.def_id_to_span.push(span);\n-        debug_assert_eq!(_id, def_id);\n-\n-        def_id\n-    }\n-\n-    pub fn expansion_that_defined(&self, id: LocalDefId) -> ExpnId {\n-        self.expansions_that_defined.get(&id).copied().unwrap_or_else(ExpnId::root)\n-    }\n-\n-    /// Retrieves the span of the given `DefId` if `DefId` is in the local crate.\n-    #[inline]\n-    pub fn def_span(&self, def_id: LocalDefId) -> Span {\n-        self.def_id_to_span[def_id]\n+        LocalDefId { local_def_index: self.table.allocate(key, def_path_hash) }\n     }\n \n     pub fn iter_local_def_id(&self) -> impl Iterator<Item = LocalDefId> + '_ {"}, {"sha": "19f086b3a4426244f946f544528ca7fd109a7781", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 38, "deletions": 10, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/3a8b0144c82197a70e919ad371d56f82c2282833/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a8b0144c82197a70e919ad371d56f82c2282833/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=3a8b0144c82197a70e919ad371d56f82c2282833", "patch": "@@ -13,22 +13,23 @@ use rustc_data_structures::temp_dir::MaybeTempDir;\n use rustc_errors::{Applicability, ErrorGuaranteed, MultiSpan, PResult};\n use rustc_expand::base::{ExtCtxt, LintStoreExpand, ResolverExpand};\n use rustc_hir::def_id::{StableCrateId, LOCAL_CRATE};\n+use rustc_hir::definitions::Definitions;\n use rustc_hir::Crate;\n use rustc_lint::{EarlyCheckNode, LintStore};\n use rustc_metadata::creader::CStore;\n use rustc_metadata::{encode_metadata, EncodedMetadata};\n use rustc_middle::arena::Arena;\n use rustc_middle::dep_graph::DepGraph;\n use rustc_middle::ty::query::{ExternProviders, Providers};\n-use rustc_middle::ty::{self, GlobalCtxt, RegisteredTools, ResolverOutputs, TyCtxt};\n+use rustc_middle::ty::{self, GlobalCtxt, RegisteredTools, TyCtxt};\n use rustc_mir_build as mir_build;\n use rustc_parse::{parse_crate_from_file, parse_crate_from_source_str, validate_attr};\n use rustc_passes::{self, hir_stats, layout_test};\n use rustc_plugin_impl as plugin;\n use rustc_query_impl::{OnDiskCache, Queries as TcxQueries};\n use rustc_resolve::{Resolver, ResolverArenas};\n use rustc_session::config::{CrateType, Input, OutputFilenames, OutputType};\n-use rustc_session::cstore::{MetadataLoader, MetadataLoaderDyn};\n+use rustc_session::cstore::{CrateStoreDyn, MetadataLoader, MetadataLoaderDyn};\n use rustc_session::output::{filename_for_input, filename_for_metadata};\n use rustc_session::search_paths::PathKind;\n use rustc_session::{Limit, Session};\n@@ -136,7 +137,10 @@ mod boxed_resolver {\n             f((&mut *resolver).as_mut().unwrap())\n         }\n \n-        pub fn to_resolver_outputs(resolver: Rc<RefCell<BoxedResolver>>) -> ResolverOutputs {\n+        pub fn to_resolver_outputs(\n+            resolver: Rc<RefCell<BoxedResolver>>,\n+        ) -> (Definitions, Box<CrateStoreDyn>, ty::ResolverOutputs, ty::ResolverAstLowering)\n+        {\n             match Rc::try_unwrap(resolver) {\n                 Ok(resolver) => {\n                     let mut resolver = resolver.into_inner();\n@@ -478,14 +482,25 @@ pub fn configure_and_expand(\n     Ok(krate)\n }\n \n-pub fn lower_to_hir<'res, 'tcx>(\n-    sess: &'tcx Session,\n-    resolver: &'res mut Resolver<'_>,\n+fn lower_to_hir<'tcx>(\n+    sess: &Session,\n+    definitions: &mut Definitions,\n+    cstore: &CrateStoreDyn,\n+    resolutions: &ty::ResolverOutputs,\n+    resolver: ty::ResolverAstLowering,\n     krate: Rc<ast::Crate>,\n     arena: &'tcx rustc_ast_lowering::Arena<'tcx>,\n ) -> &'tcx Crate<'tcx> {\n     // Lower AST to HIR.\n-    let hir_crate = rustc_ast_lowering::lower_crate(sess, &*krate, resolver, arena);\n+    let hir_crate = rustc_ast_lowering::lower_crate(\n+        sess,\n+        &krate,\n+        definitions,\n+        cstore,\n+        resolutions,\n+        resolver,\n+        arena,\n+    );\n \n     // Drop AST to free memory\n     sess.time(\"drop_ast\", || std::mem::drop(krate));\n@@ -823,10 +838,21 @@ pub fn create_global_ctxt<'tcx>(\n     // incr. comp. yet.\n     dep_graph.assert_ignored();\n \n+    let (mut definitions, cstore, resolver_outputs, resolver_for_lowering) =\n+        BoxedResolver::to_resolver_outputs(resolver);\n+\n     let sess = &compiler.session();\n-    let krate =\n-        resolver.borrow_mut().access(|resolver| lower_to_hir(sess, resolver, krate, hir_arena));\n-    let resolver_outputs = BoxedResolver::to_resolver_outputs(resolver);\n+\n+    // Lower AST to HIR.\n+    let krate = lower_to_hir(\n+        sess,\n+        &mut definitions,\n+        &*cstore,\n+        &resolver_outputs,\n+        resolver_for_lowering,\n+        krate,\n+        hir_arena,\n+    );\n \n     let query_result_on_disk_cache = rustc_incremental::load_query_result_cache(sess);\n \n@@ -851,6 +877,8 @@ pub fn create_global_ctxt<'tcx>(\n                 sess,\n                 lint_store,\n                 arena,\n+                definitions,\n+                cstore,\n                 resolver_outputs,\n                 krate,\n                 dep_graph,"}, {"sha": "463af64a2a4eb03af45aa297dd612b00e1173470", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3a8b0144c82197a70e919ad371d56f82c2282833/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a8b0144c82197a70e919ad371d56f82c2282833/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=3a8b0144c82197a70e919ad371d56f82c2282833", "patch": "@@ -423,7 +423,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     }\n \n     fn encode_def_path_table(&mut self) {\n-        let table = self.tcx.resolutions(()).definitions.def_path_table();\n+        let table = self.tcx.definitions_untracked().def_path_table();\n         if self.is_proc_macro {\n             for def_index in std::iter::once(CRATE_DEF_INDEX)\n                 .chain(self.tcx.resolutions(()).proc_macros.iter().map(|p| p.local_def_index))\n@@ -444,7 +444,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n     fn encode_def_path_hash_map(&mut self) -> LazyValue<DefPathHashMapRef<'static>> {\n         self.lazy(DefPathHashMapRef::BorrowedFromTcx(\n-            self.tcx.resolutions(()).definitions.def_path_hash_to_def_index_map(),\n+            self.tcx.definitions_untracked().def_path_hash_to_def_index_map(),\n         ))\n     }\n "}, {"sha": "729790aee804433e27427898cc27bd171cd4fe25", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3a8b0144c82197a70e919ad371d56f82c2282833/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a8b0144c82197a70e919ad371d56f82c2282833/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=3a8b0144c82197a70e919ad371d56f82c2282833", "patch": "@@ -170,7 +170,7 @@ impl<'hir> Map<'hir> {\n \n     pub fn def_key(self, def_id: LocalDefId) -> DefKey {\n         // Accessing the DefKey is ok, since it is part of DefPathHash.\n-        self.tcx.untracked_resolutions.definitions.def_key(def_id)\n+        self.tcx.definitions_untracked().def_key(def_id)\n     }\n \n     pub fn def_path_from_hir_id(self, id: HirId) -> Option<DefPath> {\n@@ -179,13 +179,13 @@ impl<'hir> Map<'hir> {\n \n     pub fn def_path(self, def_id: LocalDefId) -> DefPath {\n         // Accessing the DefPath is ok, since it is part of DefPathHash.\n-        self.tcx.untracked_resolutions.definitions.def_path(def_id)\n+        self.tcx.definitions_untracked().def_path(def_id)\n     }\n \n     #[inline]\n     pub fn def_path_hash(self, def_id: LocalDefId) -> DefPathHash {\n         // Accessing the DefPathHash is ok, it is incr. comp. stable.\n-        self.tcx.untracked_resolutions.definitions.def_path_hash(def_id)\n+        self.tcx.definitions_untracked().def_path_hash(def_id)\n     }\n \n     #[inline]\n@@ -222,7 +222,7 @@ impl<'hir> Map<'hir> {\n         // Create a dependency to the crate to be sure we re-execute this when the amount of\n         // definitions change.\n         self.tcx.ensure().hir_crate(());\n-        self.tcx.untracked_resolutions.definitions.iter_local_def_id()\n+        self.tcx.definitions_untracked().iter_local_def_id()\n     }\n \n     pub fn opt_def_kind(self, local_def_id: LocalDefId) -> Option<DefKind> {\n@@ -1078,6 +1078,8 @@ pub(super) fn crate_hash(tcx: TyCtxt<'_>, crate_num: CrateNum) -> Svh {\n \n     let upstream_crates = upstream_crates(tcx);\n \n+    let resolutions = tcx.resolutions(());\n+\n     // We hash the final, remapped names of all local source files so we\n     // don't have to include the path prefix remapping commandline args.\n     // If we included the full mapping in the SVH, we could only have\n@@ -1100,14 +1102,14 @@ pub(super) fn crate_hash(tcx: TyCtxt<'_>, crate_num: CrateNum) -> Svh {\n     upstream_crates.hash_stable(&mut hcx, &mut stable_hasher);\n     source_file_names.hash_stable(&mut hcx, &mut stable_hasher);\n     if tcx.sess.opts.debugging_opts.incremental_relative_spans {\n-        let definitions = &tcx.untracked_resolutions.definitions;\n+        let definitions = &tcx.definitions_untracked();\n         let mut owner_spans: Vec<_> = krate\n             .owners\n             .iter_enumerated()\n             .filter_map(|(def_id, info)| {\n                 let _ = info.as_owner()?;\n                 let def_path_hash = definitions.def_path_hash(def_id);\n-                let span = definitions.def_span(def_id);\n+                let span = resolutions.source_span[def_id];\n                 debug_assert_eq!(span.parent(), None);\n                 Some((def_path_hash, span))\n             })\n@@ -1118,7 +1120,6 @@ pub(super) fn crate_hash(tcx: TyCtxt<'_>, crate_num: CrateNum) -> Svh {\n     tcx.sess.opts.dep_tracking_hash(true).hash_stable(&mut hcx, &mut stable_hasher);\n     tcx.sess.local_stable_crate_id().hash_stable(&mut hcx, &mut stable_hasher);\n     // Hash visibility information since it does not appear in HIR.\n-    let resolutions = tcx.resolutions(());\n     resolutions.visibilities.hash_stable(&mut hcx, &mut stable_hasher);\n     resolutions.has_pub_restricted.hash_stable(&mut hcx, &mut stable_hasher);\n \n@@ -1131,7 +1132,7 @@ fn upstream_crates(tcx: TyCtxt<'_>) -> Vec<(StableCrateId, Svh)> {\n         .crates(())\n         .iter()\n         .map(|&cnum| {\n-            let stable_crate_id = tcx.resolutions(()).cstore.stable_crate_id(cnum);\n+            let stable_crate_id = tcx.stable_crate_id(cnum);\n             let hash = tcx.crate_hash(cnum);\n             (stable_crate_id, hash)\n         })"}, {"sha": "09b142e0c415d6fdc7d5a8e77cbd27810f51e1c0", "filename": "compiler/rustc_middle/src/hir/mod.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3a8b0144c82197a70e919ad371d56f82c2282833/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a8b0144c82197a70e919ad371d56f82c2282833/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs?ref=3a8b0144c82197a70e919ad371d56f82c2282833", "patch": "@@ -7,13 +7,13 @@ pub mod nested_filter;\n pub mod place;\n \n use crate::ty::query::Providers;\n-use crate::ty::{ImplSubject, TyCtxt};\n+use crate::ty::{DefIdTree, ImplSubject, TyCtxt};\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::*;\n use rustc_query_system::ich::StableHashingContext;\n-use rustc_span::DUMMY_SP;\n+use rustc_span::{ExpnId, DUMMY_SP};\n \n /// Top-level HIR node for current owner. This only contains the node for which\n /// `HirId::local_id == 0`, and excludes bodies.\n@@ -104,23 +104,21 @@ pub fn provide(providers: &mut Providers) {\n     };\n     providers.hir_owner_nodes = |tcx, id| tcx.hir_crate(()).owners[id].map(|i| &i.nodes);\n     providers.hir_owner_parent = |tcx, id| {\n-        // Accessing the def_key is ok since its value is hashed as part of `id`'s DefPathHash.\n-        let parent = tcx.untracked_resolutions.definitions.def_key(id).parent;\n-        let parent = parent.map_or(CRATE_HIR_ID, |local_def_index| {\n-            let def_id = LocalDefId { local_def_index };\n-            let mut parent_hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n+        // Accessing the local_parent is ok since its value is hashed as part of `id`'s DefPathHash.\n+        tcx.opt_local_parent(id).map_or(CRATE_HIR_ID, |parent| {\n+            let mut parent_hir_id = tcx.hir().local_def_id_to_hir_id(parent);\n             if let Some(local_id) =\n                 tcx.hir_crate(()).owners[parent_hir_id.owner].unwrap().parenting.get(&id)\n             {\n                 parent_hir_id.local_id = *local_id;\n             }\n             parent_hir_id\n-        });\n-        parent\n+        })\n     };\n     providers.hir_attrs =\n         |tcx, id| tcx.hir_crate(()).owners[id].as_owner().map_or(AttributeMap::EMPTY, |o| &o.attrs);\n-    providers.source_span = |tcx, def_id| tcx.resolutions(()).definitions.def_span(def_id);\n+    providers.source_span =\n+        |tcx, def_id| tcx.resolutions(()).source_span.get(def_id).copied().unwrap_or(DUMMY_SP);\n     providers.def_span = |tcx, def_id| {\n         let def_id = def_id.expect_local();\n         let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n@@ -150,7 +148,7 @@ pub fn provide(providers: &mut Providers) {\n     providers.all_local_trait_impls = |tcx, ()| &tcx.resolutions(()).trait_impls;\n     providers.expn_that_defined = |tcx, id| {\n         let id = id.expect_local();\n-        tcx.resolutions(()).definitions.expansion_that_defined(id)\n+        tcx.resolutions(()).expn_that_defined.get(&id).copied().unwrap_or(ExpnId::root())\n     };\n     providers.in_scope_traits_map =\n         |tcx, id| tcx.hir_crate(()).owners[id].as_owner().map(|owner_info| &owner_info.trait_map);"}, {"sha": "e0b4eced075e9e42697da026a800de85d82c9c29", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a8b0144c82197a70e919ad371d56f82c2282833/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a8b0144c82197a70e919ad371d56f82c2282833/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=3a8b0144c82197a70e919ad371d56f82c2282833", "patch": "@@ -271,8 +271,6 @@ rustc_queries! {\n     }\n \n     query expn_that_defined(key: DefId) -> rustc_span::ExpnId {\n-        // This query reads from untracked data in definitions.\n-        eval_always\n         desc { |tcx| \"expansion that defined `{}`\", tcx.def_path_str(key) }\n         separate_provide_extern\n     }"}, {"sha": "c43cf07b3ad0a04cd7b95abf262a90f460e27306", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 67, "deletions": 33, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/3a8b0144c82197a70e919ad371d56f82c2282833/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a8b0144c82197a70e919ad371d56f82c2282833/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=3a8b0144c82197a70e919ad371d56f82c2282833", "patch": "@@ -50,6 +50,7 @@ use rustc_middle::mir::FakeReadCause;\n use rustc_query_system::ich::StableHashingContext;\n use rustc_serialize::opaque::{FileEncodeResult, FileEncoder};\n use rustc_session::config::{CrateType, OutputFilenames};\n+use rustc_session::cstore::CrateStoreDyn;\n use rustc_session::lint::{Level, Lint};\n use rustc_session::Limit;\n use rustc_session::Session;\n@@ -177,7 +178,9 @@ impl<'tcx> CtxtInterners<'tcx> {\n         &self,\n         kind: TyKind<'tcx>,\n         sess: &Session,\n-        resolutions: &ty::ResolverOutputs,\n+        definitions: &rustc_hir::definitions::Definitions,\n+        cstore: &CrateStoreDyn,\n+        source_span: &IndexVec<LocalDefId, Span>,\n     ) -> Ty<'tcx> {\n         Ty(Interned::new_unchecked(\n             self.type_\n@@ -194,8 +197,9 @@ impl<'tcx> CtxtInterners<'tcx> {\n                         let mut hasher = StableHasher::new();\n                         let mut hcx = StableHashingContext::ignore_spans(\n                             sess,\n-                            &resolutions.definitions,\n-                            &*resolutions.cstore,\n+                            definitions,\n+                            cstore,\n+                            source_span,\n                         );\n                         kind.hash_stable(&mut hcx, &mut hasher);\n                         hasher.finish()\n@@ -934,9 +938,11 @@ impl<'tcx> CommonTypes<'tcx> {\n     fn new(\n         interners: &CtxtInterners<'tcx>,\n         sess: &Session,\n-        resolutions: &ty::ResolverOutputs,\n+        definitions: &rustc_hir::definitions::Definitions,\n+        cstore: &CrateStoreDyn,\n+        source_span: &IndexVec<LocalDefId, Span>,\n     ) -> CommonTypes<'tcx> {\n-        let mk = |ty| interners.intern_ty(ty, sess, resolutions);\n+        let mk = |ty| interners.intern_ty(ty, sess, definitions, cstore, source_span);\n \n         CommonTypes {\n             unit: mk(Tuple(List::empty())),\n@@ -1057,6 +1063,9 @@ pub struct GlobalCtxt<'tcx> {\n     /// Common consts, pre-interned for your convenience.\n     pub consts: CommonConsts<'tcx>,\n \n+    definitions: rustc_hir::definitions::Definitions,\n+    cstore: Box<CrateStoreDyn>,\n+\n     /// Output of the resolver.\n     pub(crate) untracked_resolutions: ty::ResolverOutputs,\n \n@@ -1218,7 +1227,9 @@ impl<'tcx> TyCtxt<'tcx> {\n         s: &'tcx Session,\n         lint_store: Lrc<dyn Any + sync::Send + sync::Sync>,\n         arena: &'tcx WorkerLocal<Arena<'tcx>>,\n-        resolutions: ty::ResolverOutputs,\n+        definitions: rustc_hir::definitions::Definitions,\n+        cstore: Box<CrateStoreDyn>,\n+        untracked_resolutions: ty::ResolverOutputs,\n         krate: &'tcx hir::Crate<'tcx>,\n         dep_graph: DepGraph,\n         on_disk_cache: Option<&'tcx dyn OnDiskCache<'tcx>>,\n@@ -1231,7 +1242,14 @@ impl<'tcx> TyCtxt<'tcx> {\n             s.fatal(&err);\n         });\n         let interners = CtxtInterners::new(arena);\n-        let common_types = CommonTypes::new(&interners, s, &resolutions);\n+        let common_types = CommonTypes::new(\n+            &interners,\n+            s,\n+            &definitions,\n+            &*cstore,\n+            // This is only used to create a stable hashing context.\n+            &untracked_resolutions.source_span,\n+        );\n         let common_lifetimes = CommonLifetimes::new(&interners);\n         let common_consts = CommonConsts::new(&interners, &common_types);\n \n@@ -1241,7 +1259,9 @@ impl<'tcx> TyCtxt<'tcx> {\n             arena,\n             interners,\n             dep_graph,\n-            untracked_resolutions: resolutions,\n+            definitions,\n+            cstore,\n+            untracked_resolutions,\n             prof: s.prof.clone(),\n             types: common_types,\n             lifetimes: common_lifetimes,\n@@ -1342,9 +1362,9 @@ impl<'tcx> TyCtxt<'tcx> {\n     pub fn def_key(self, id: DefId) -> rustc_hir::definitions::DefKey {\n         // Accessing the DefKey is ok, since it is part of DefPathHash.\n         if let Some(id) = id.as_local() {\n-            self.untracked_resolutions.definitions.def_key(id)\n+            self.definitions.def_key(id)\n         } else {\n-            self.untracked_resolutions.cstore.def_key(id)\n+            self.cstore.def_key(id)\n         }\n     }\n \n@@ -1356,19 +1376,19 @@ impl<'tcx> TyCtxt<'tcx> {\n     pub fn def_path(self, id: DefId) -> rustc_hir::definitions::DefPath {\n         // Accessing the DefPath is ok, since it is part of DefPathHash.\n         if let Some(id) = id.as_local() {\n-            self.untracked_resolutions.definitions.def_path(id)\n+            self.definitions.def_path(id)\n         } else {\n-            self.untracked_resolutions.cstore.def_path(id)\n+            self.cstore.def_path(id)\n         }\n     }\n \n     #[inline]\n     pub fn def_path_hash(self, def_id: DefId) -> rustc_hir::definitions::DefPathHash {\n         // Accessing the DefPathHash is ok, it is incr. comp. stable.\n         if let Some(def_id) = def_id.as_local() {\n-            self.untracked_resolutions.definitions.def_path_hash(def_id)\n+            self.definitions.def_path_hash(def_id)\n         } else {\n-            self.untracked_resolutions.cstore.def_path_hash(def_id)\n+            self.cstore.def_path_hash(def_id)\n         }\n     }\n \n@@ -1377,7 +1397,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         if crate_num == LOCAL_CRATE {\n             self.sess.local_stable_crate_id()\n         } else {\n-            self.untracked_resolutions.cstore.stable_crate_id(crate_num)\n+            self.cstore.stable_crate_id(crate_num)\n         }\n     }\n \n@@ -1388,7 +1408,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         if stable_crate_id == self.sess.local_stable_crate_id() {\n             LOCAL_CRATE\n         } else {\n-            self.untracked_resolutions.cstore.stable_crate_id_to_crate_num(stable_crate_id)\n+            self.cstore.stable_crate_id_to_crate_num(stable_crate_id)\n         }\n     }\n \n@@ -1403,16 +1423,12 @@ impl<'tcx> TyCtxt<'tcx> {\n         // If this is a DefPathHash from the local crate, we can look up the\n         // DefId in the tcx's `Definitions`.\n         if stable_crate_id == self.sess.local_stable_crate_id() {\n-            self.untracked_resolutions\n-                .definitions\n-                .local_def_path_hash_to_def_id(hash, err)\n-                .to_def_id()\n+            self.definitions.local_def_path_hash_to_def_id(hash, err).to_def_id()\n         } else {\n             // If this is a DefPathHash from an upstream crate, let the CrateStore map\n             // it to a DefId.\n-            let cstore = &self.untracked_resolutions.cstore;\n-            let cnum = cstore.stable_crate_id_to_crate_num(stable_crate_id);\n-            cstore.def_path_hash_to_def_id(cnum, hash)\n+            let cnum = self.cstore.stable_crate_id_to_crate_num(stable_crate_id);\n+            self.cstore.def_path_hash_to_def_id(cnum, hash)\n         }\n     }\n \n@@ -1424,7 +1440,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         let (crate_name, stable_crate_id) = if def_id.is_local() {\n             (self.crate_name, self.sess.local_stable_crate_id())\n         } else {\n-            let cstore = &self.untracked_resolutions.cstore;\n+            let cstore = &self.cstore;\n             (cstore.crate_name(def_id.krate), cstore.stable_crate_id(def_id.krate))\n         };\n \n@@ -1440,29 +1456,40 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     /// Note that this is *untracked* and should only be used within the query\n     /// system if the result is otherwise tracked through queries\n-    pub fn cstore_untracked(self) -> &'tcx ty::CrateStoreDyn {\n-        &*self.untracked_resolutions.cstore\n+    pub fn cstore_untracked(self) -> &'tcx CrateStoreDyn {\n+        &*self.cstore\n     }\n \n     /// Note that this is *untracked* and should only be used within the query\n     /// system if the result is otherwise tracked through queries\n     pub fn definitions_untracked(self) -> &'tcx hir::definitions::Definitions {\n-        &self.untracked_resolutions.definitions\n+        &self.definitions\n+    }\n+\n+    /// Note that this is *untracked* and should only be used within the query\n+    /// system if the result is otherwise tracked through queries\n+    #[inline]\n+    pub fn source_span_untracked(self, def_id: LocalDefId) -> Span {\n+        self.untracked_resolutions.source_span.get(def_id).copied().unwrap_or(DUMMY_SP)\n     }\n \n     #[inline(always)]\n     pub fn create_stable_hashing_context(self) -> StableHashingContext<'tcx> {\n-        let resolutions = &self.gcx.untracked_resolutions;\n-        StableHashingContext::new(self.sess, &resolutions.definitions, &*resolutions.cstore)\n+        StableHashingContext::new(\n+            self.sess,\n+            &self.definitions,\n+            &*self.cstore,\n+            &self.untracked_resolutions.source_span,\n+        )\n     }\n \n     #[inline(always)]\n     pub fn create_no_span_stable_hashing_context(self) -> StableHashingContext<'tcx> {\n-        let resolutions = &self.gcx.untracked_resolutions;\n         StableHashingContext::ignore_spans(\n             self.sess,\n-            &resolutions.definitions,\n-            &*resolutions.cstore,\n+            &self.definitions,\n+            &*self.cstore,\n+            &self.untracked_resolutions.source_span,\n         )\n     }\n \n@@ -2254,7 +2281,14 @@ impl<'tcx> TyCtxt<'tcx> {\n     #[allow(rustc::usage_of_ty_tykind)]\n     #[inline]\n     pub fn mk_ty(self, st: TyKind<'tcx>) -> Ty<'tcx> {\n-        self.interners.intern_ty(st, self.sess, &self.gcx.untracked_resolutions)\n+        self.interners.intern_ty(\n+            st,\n+            self.sess,\n+            &self.definitions,\n+            &*self.cstore,\n+            // This is only used to create a stable hashing context.\n+            &self.untracked_resolutions.source_span,\n+        )\n     }\n \n     #[inline]"}, {"sha": "749feb850b0982dca798a6634fdec3f1e075e49d", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 37, "deletions": 5, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/3a8b0144c82197a70e919ad371d56f82c2282833/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a8b0144c82197a70e919ad371d56f82c2282833/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=3a8b0144c82197a70e919ad371d56f82c2282833", "patch": "@@ -27,21 +27,23 @@ pub use adt::*;\n pub use assoc::*;\n pub use generics::*;\n use rustc_ast as ast;\n+use rustc_ast::node_id::NodeMap;\n use rustc_attr as attr;\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap, FxIndexSet};\n use rustc_data_structures::intern::{Interned, WithStableHash};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::tagged_ptr::CopyTaggedPtr;\n use rustc_hir as hir;\n-use rustc_hir::def::{CtorKind, CtorOf, DefKind, Res};\n+use rustc_hir::def::{CtorKind, CtorOf, DefKind, LifetimeRes, Res};\n use rustc_hir::def_id::{CrateNum, DefId, LocalDefId, LocalDefIdMap};\n use rustc_hir::Node;\n+use rustc_index::vec::IndexVec;\n use rustc_macros::HashStable;\n use rustc_query_system::ich::StableHashingContext;\n-use rustc_session::cstore::CrateStoreDyn;\n+use rustc_span::hygiene::MacroKind;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n-use rustc_span::Span;\n+use rustc_span::{ExpnId, Span};\n use rustc_target::abi::{Align, VariantIdx};\n pub use subst::*;\n pub use vtable::*;\n@@ -133,11 +135,13 @@ pub type RegisteredTools = FxHashSet<Ident>;\n \n #[derive(Debug)]\n pub struct ResolverOutputs {\n-    pub definitions: rustc_hir::definitions::Definitions,\n-    pub cstore: Box<CrateStoreDyn>,\n     pub visibilities: FxHashMap<LocalDefId, Visibility>,\n     /// This field is used to decide whether we should make `PRIVATE_IN_PUBLIC` a hard error.\n     pub has_pub_restricted: bool,\n+    /// Item with a given `LocalDefId` was defined during macro expansion with ID `ExpnId`.\n+    pub expn_that_defined: FxHashMap<LocalDefId, ExpnId>,\n+    /// Reference span for definitions.\n+    pub source_span: IndexVec<LocalDefId, Span>,\n     pub access_levels: AccessLevels,\n     pub extern_crate_map: FxHashMap<LocalDefId, CrateNum>,\n     pub maybe_unused_trait_imports: FxIndexSet<LocalDefId>,\n@@ -158,6 +162,34 @@ pub struct ResolverOutputs {\n     pub registered_tools: RegisteredTools,\n }\n \n+/// Resolutions that should only be used for lowering.\n+/// This struct is meant to be consumed by lowering.\n+#[derive(Debug)]\n+pub struct ResolverAstLowering {\n+    pub legacy_const_generic_args: FxHashMap<DefId, Option<Vec<usize>>>,\n+\n+    /// Resolutions for nodes that have a single resolution.\n+    pub partial_res_map: NodeMap<hir::def::PartialRes>,\n+    /// Resolutions for import nodes, which have multiple resolutions in different namespaces.\n+    pub import_res_map: NodeMap<hir::def::PerNS<Option<Res<ast::NodeId>>>>,\n+    /// Resolutions for labels (node IDs of their corresponding blocks or loops).\n+    pub label_res_map: NodeMap<ast::NodeId>,\n+    /// Resolutions for lifetimes.\n+    pub lifetimes_res_map: NodeMap<LifetimeRes>,\n+    /// Lifetime parameters that lowering will have to introduce.\n+    pub extra_lifetime_params_map: NodeMap<Vec<(Ident, ast::NodeId, LifetimeRes)>>,\n+\n+    pub next_node_id: ast::NodeId,\n+\n+    pub node_id_to_def_id: FxHashMap<ast::NodeId, LocalDefId>,\n+    pub def_id_to_node_id: IndexVec<LocalDefId, ast::NodeId>,\n+\n+    pub trait_map: NodeMap<Vec<hir::TraitCandidate>>,\n+    /// A small map keeping true kinds of built-in macros that appear to be fn-like on\n+    /// the surface (`macro` items in libcore), but are actually attributes or derives.\n+    pub builtin_macro_kinds: FxHashMap<LocalDefId, MacroKind>,\n+}\n+\n #[derive(Clone, Copy, Debug)]\n pub struct MainDefinition {\n     pub res: Res<ast::NodeId>,"}, {"sha": "b01c512a3b439d2fd75ff923079b7f09ba4e54f7", "filename": "compiler/rustc_query_impl/src/on_disk_cache.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3a8b0144c82197a70e919ad371d56f82c2282833/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a8b0144c82197a70e919ad371d56f82c2282833/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs?ref=3a8b0144c82197a70e919ad371d56f82c2282833", "patch": "@@ -690,8 +690,7 @@ impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for Span {\n             let dlo = u32::decode(decoder);\n             let dto = u32::decode(decoder);\n \n-            let enclosing =\n-                decoder.tcx.definitions_untracked().def_span(parent.unwrap()).data_untracked();\n+            let enclosing = decoder.tcx.source_span_untracked(parent.unwrap()).data_untracked();\n             let span = Span::new(\n                 enclosing.lo + BytePos::from_u32(dlo),\n                 enclosing.lo + BytePos::from_u32(dto),\n@@ -869,7 +868,7 @@ impl<'a, 'tcx> Encodable<CacheEncoder<'a, 'tcx>> for Span {\n         }\n \n         if let Some(parent) = span_data.parent {\n-            let enclosing = s.tcx.definitions_untracked().def_span(parent).data_untracked();\n+            let enclosing = s.tcx.source_span(parent).data_untracked();\n             if enclosing.contains(span_data) {\n                 TAG_RELATIVE_SPAN.encode(s);\n                 (span_data.lo - enclosing.lo).to_u32().encode(s);"}, {"sha": "62a1f776fb352c63e5875a1dc2ba354ca762d97a", "filename": "compiler/rustc_query_system/src/ich/hcx.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3a8b0144c82197a70e919ad371d56f82c2282833/compiler%2Frustc_query_system%2Fsrc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a8b0144c82197a70e919ad371d56f82c2282833/compiler%2Frustc_query_system%2Fsrc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fich%2Fhcx.rs?ref=3a8b0144c82197a70e919ad371d56f82c2282833", "patch": "@@ -6,6 +6,7 @@ use rustc_data_structures::sync::Lrc;\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::definitions::{DefPathHash, Definitions};\n+use rustc_index::vec::IndexVec;\n use rustc_session::cstore::CrateStore;\n use rustc_session::Session;\n use rustc_span::source_map::SourceMap;\n@@ -20,6 +21,7 @@ use rustc_span::{BytePos, CachingSourceMapView, SourceFile, Span, SpanData};\n pub struct StableHashingContext<'a> {\n     definitions: &'a Definitions,\n     cstore: &'a dyn CrateStore,\n+    source_span: &'a IndexVec<LocalDefId, Span>,\n     // The value of `-Z incremental-ignore-spans`.\n     // This field should only be used by `debug_opts_incremental_ignore_span`\n     incremental_ignore_spans: bool,\n@@ -50,6 +52,7 @@ impl<'a> StableHashingContext<'a> {\n         sess: &'a Session,\n         definitions: &'a Definitions,\n         cstore: &'a dyn CrateStore,\n+        source_span: &'a IndexVec<LocalDefId, Span>,\n         always_ignore_spans: bool,\n     ) -> Self {\n         let hash_spans_initial =\n@@ -59,6 +62,7 @@ impl<'a> StableHashingContext<'a> {\n             body_resolver: BodyResolver::Forbidden,\n             definitions,\n             cstore,\n+            source_span,\n             incremental_ignore_spans: sess.opts.debugging_opts.incremental_ignore_spans,\n             caching_source_map: None,\n             raw_source_map: sess.source_map(),\n@@ -71,11 +75,13 @@ impl<'a> StableHashingContext<'a> {\n         sess: &'a Session,\n         definitions: &'a Definitions,\n         cstore: &'a dyn CrateStore,\n+        source_span: &'a IndexVec<LocalDefId, Span>,\n     ) -> Self {\n         Self::new_with_or_without_spans(\n             sess,\n             definitions,\n             cstore,\n+            source_span,\n             /*always_ignore_spans=*/ false,\n         )\n     }\n@@ -85,9 +91,10 @@ impl<'a> StableHashingContext<'a> {\n         sess: &'a Session,\n         definitions: &'a Definitions,\n         cstore: &'a dyn CrateStore,\n+        source_span: &'a IndexVec<LocalDefId, Span>,\n     ) -> Self {\n         let always_ignore_spans = true;\n-        Self::new_with_or_without_spans(sess, definitions, cstore, always_ignore_spans)\n+        Self::new_with_or_without_spans(sess, definitions, cstore, source_span, always_ignore_spans)\n     }\n \n     /// Allow hashing\n@@ -189,7 +196,7 @@ impl<'a> rustc_span::HashStableContext for StableHashingContext<'a> {\n \n     #[inline]\n     fn def_span(&self, def_id: LocalDefId) -> Span {\n-        self.definitions.def_span(def_id)\n+        self.source_span[def_id]\n     }\n \n     #[inline]"}, {"sha": "8bd8eb488b70721af7e381701a7671edafe369bc", "filename": "compiler/rustc_resolve/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3a8b0144c82197a70e919ad371d56f82c2282833/compiler%2Frustc_resolve%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3a8b0144c82197a70e919ad371d56f82c2282833/compiler%2Frustc_resolve%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2FCargo.toml?ref=3a8b0144c82197a70e919ad371d56f82c2282833", "patch": "@@ -12,7 +12,6 @@ tracing = \"0.1\"\n rustc_ast = { path = \"../rustc_ast\" }\n rustc_arena = { path = \"../rustc_arena\" }\n rustc_middle = { path = \"../rustc_middle\" }\n-rustc_ast_lowering = { path = \"../rustc_ast_lowering\" }\n rustc_ast_pretty = { path = \"../rustc_ast_pretty\" }\n rustc_attr = { path = \"../rustc_attr\" }\n rustc_data_structures = { path = \"../rustc_data_structures\" }"}, {"sha": "3fba923d9fdf425c443300fb15eed97ba6ffdfd8", "filename": "compiler/rustc_resolve/src/access_levels.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3a8b0144c82197a70e919ad371d56f82c2282833/compiler%2Frustc_resolve%2Fsrc%2Faccess_levels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a8b0144c82197a70e919ad371d56f82c2282833/compiler%2Frustc_resolve%2Fsrc%2Faccess_levels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Faccess_levels.rs?ref=3a8b0144c82197a70e919ad371d56f82c2282833", "patch": "@@ -5,7 +5,6 @@ use rustc_ast::Crate;\n use rustc_ast::EnumDef;\n use rustc_ast::ForeignMod;\n use rustc_ast::NodeId;\n-use rustc_ast_lowering::ResolverAstLowering;\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::def_id::CRATE_DEF_ID;\n use rustc_middle::middle::privacy::AccessLevel;"}, {"sha": "6631470f2191ba27ed8be21956310bb642a2c9b0", "filename": "compiler/rustc_resolve/src/build_reduced_graph.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3a8b0144c82197a70e919ad371d56f82c2282833/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a8b0144c82197a70e919ad371d56f82c2282833/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs?ref=3a8b0144c82197a70e919ad371d56f82c2282833", "patch": "@@ -18,7 +18,6 @@ use crate::{Resolver, ResolverArenas, Segment, ToNameBinding, VisResolutionError\n use rustc_ast::visit::{self, AssocCtxt, Visitor};\n use rustc_ast::{self as ast, AssocItem, AssocItemKind, MetaItemKind, StmtKind};\n use rustc_ast::{Block, Fn, ForeignItem, ForeignItemKind, Impl, Item, ItemKind, NodeId};\n-use rustc_ast_lowering::ResolverAstLowering;\n use rustc_attr as attr;\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::{struct_span_err, Applicability};\n@@ -28,7 +27,7 @@ use rustc_hir::def_id::{DefId, LocalDefId, CRATE_DEF_ID};\n use rustc_metadata::creader::LoadedMacro;\n use rustc_middle::bug;\n use rustc_middle::metadata::ModChild;\n-use rustc_middle::ty;\n+use rustc_middle::ty::{self, DefIdTree};\n use rustc_session::cstore::CrateStore;\n use rustc_span::hygiene::{ExpnId, LocalExpnId, MacroKind};\n use rustc_span::source_map::{respan, Spanned};\n@@ -113,10 +112,7 @@ impl<'a> Resolver<'a> {\n         loop {\n             match self.get_module(def_id) {\n                 Some(module) => return module,\n-                None => {\n-                    def_id.index =\n-                        self.def_key(def_id).parent.expect(\"non-root `DefId` without parent\")\n-                }\n+                None => def_id = self.parent(def_id),\n             }\n         }\n     }"}, {"sha": "f2f6f1d895e32ff4cb139f735cba8582e75015f3", "filename": "compiler/rustc_resolve/src/check_unused.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3a8b0144c82197a70e919ad371d56f82c2282833/compiler%2Frustc_resolve%2Fsrc%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a8b0144c82197a70e919ad371d56f82c2282833/compiler%2Frustc_resolve%2Fsrc%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fcheck_unused.rs?ref=3a8b0144c82197a70e919ad371d56f82c2282833", "patch": "@@ -30,7 +30,6 @@ use crate::Resolver;\n use rustc_ast as ast;\n use rustc_ast::node_id::NodeMap;\n use rustc_ast::visit::{self, Visitor};\n-use rustc_ast_lowering::ResolverAstLowering;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{pluralize, MultiSpan};\n use rustc_session::lint::builtin::{MACRO_USE_EXTERN_CRATE, UNUSED_IMPORTS};"}, {"sha": "52706fbb9e6ec63bd77fb7401f8609e9b8b70688", "filename": "compiler/rustc_resolve/src/def_collector.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3a8b0144c82197a70e919ad371d56f82c2282833/compiler%2Frustc_resolve%2Fsrc%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a8b0144c82197a70e919ad371d56f82c2282833/compiler%2Frustc_resolve%2Fsrc%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdef_collector.rs?ref=3a8b0144c82197a70e919ad371d56f82c2282833", "patch": "@@ -2,7 +2,6 @@ use crate::{ImplTraitContext, Resolver};\n use rustc_ast::visit::{self, FnKind};\n use rustc_ast::walk_list;\n use rustc_ast::*;\n-use rustc_ast_lowering::ResolverAstLowering;\n use rustc_expand::expand::AstFragment;\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::definitions::*;"}, {"sha": "e7c8886f0544ad18e5014540fecbba90e2c2987d", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3a8b0144c82197a70e919ad371d56f82c2282833/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a8b0144c82197a70e919ad371d56f82c2282833/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=3a8b0144c82197a70e919ad371d56f82c2282833", "patch": "@@ -10,8 +10,9 @@ use rustc_errors::{Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed\n use rustc_feature::BUILTIN_ATTRIBUTES;\n use rustc_hir::def::Namespace::{self, *};\n use rustc_hir::def::{self, CtorKind, CtorOf, DefKind, NonMacroAttrKind, PerNS};\n-use rustc_hir::def_id::{DefId, CRATE_DEF_ID, LOCAL_CRATE};\n+use rustc_hir::def_id::{DefId, LocalDefId, CRATE_DEF_ID, LOCAL_CRATE};\n use rustc_hir::PrimTy;\n+use rustc_index::vec::IndexVec;\n use rustc_middle::bug;\n use rustc_middle::ty::DefIdTree;\n use rustc_session::lint::builtin::ABSOLUTE_PATHS_NOT_STARTING_WITH_CRATE;\n@@ -130,8 +131,8 @@ impl<'a> Resolver<'a> {\n             };\n             if !candidates.is_empty() {\n                 show_candidates(\n-                    &self.definitions,\n-                    self.session,\n+                    &self.session,\n+                    &self.source_span,\n                     &mut err,\n                     span,\n                     &candidates,\n@@ -693,8 +694,8 @@ impl<'a> Resolver<'a> {\n                         err.span_help(span, &help_msg);\n                     }\n                     show_candidates(\n-                        &self.definitions,\n-                        self.session,\n+                        &self.session,\n+                        &self.source_span,\n                         &mut err,\n                         Some(span),\n                         &import_suggestions,\n@@ -1474,8 +1475,8 @@ impl<'a> Resolver<'a> {\n         let import_suggestions =\n             self.lookup_import_candidates(ident, Namespace::MacroNS, parent_scope, is_expected);\n         show_candidates(\n-            &self.definitions,\n-            self.session,\n+            &self.session,\n+            &self.source_span,\n             err,\n             None,\n             &import_suggestions,\n@@ -2444,8 +2445,8 @@ enum IsPattern {\n /// entities with that name in all crates. This method allows outputting the\n /// results of this search in a programmer-friendly way\n fn show_candidates(\n-    definitions: &rustc_hir::definitions::Definitions,\n     session: &Session,\n+    source_span: &IndexVec<LocalDefId, Span>,\n     err: &mut Diagnostic,\n     // This is `None` if all placement locations are inside expansions\n     use_placement_span: Option<Span>,\n@@ -2555,7 +2556,7 @@ fn show_candidates(\n             );\n \n             if let Some(local_def_id) = def_id.and_then(|did| did.as_local()) {\n-                let span = definitions.def_span(local_def_id);\n+                let span = source_span[local_def_id];\n                 let span = session.source_map().guess_head_span(span);\n                 let mut multi_span = MultiSpan::from_span(span);\n                 multi_span.push_span_label(span, \"not accessible\".to_string());\n@@ -2584,7 +2585,7 @@ fn show_candidates(\n             let mut spans = Vec::new();\n             for (name, _, def_id, _) in &inaccessible_path_strings {\n                 if let Some(local_def_id) = def_id.and_then(|did| did.as_local()) {\n-                    let span = definitions.def_span(local_def_id);\n+                    let span = source_span[local_def_id];\n                     let span = session.source_map().guess_head_span(span);\n                     spans.push((name, span));\n                 } else {"}, {"sha": "381073a3f666359cb966ce83f8bb417e4fc33a64", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3a8b0144c82197a70e919ad371d56f82c2282833/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a8b0144c82197a70e919ad371d56f82c2282833/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=3a8b0144c82197a70e919ad371d56f82c2282833", "patch": "@@ -15,11 +15,10 @@ use crate::{ResolutionError, Resolver, Segment, UseError};\n use rustc_ast::ptr::P;\n use rustc_ast::visit::{self, AssocCtxt, BoundKind, FnCtxt, FnKind, Visitor};\n use rustc_ast::*;\n-use rustc_ast_lowering::{LifetimeRes, ResolverAstLowering};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap};\n use rustc_errors::DiagnosticId;\n use rustc_hir::def::Namespace::{self, *};\n-use rustc_hir::def::{self, CtorKind, DefKind, PartialRes, PerNS};\n+use rustc_hir::def::{self, CtorKind, DefKind, LifetimeRes, PartialRes, PerNS};\n use rustc_hir::def_id::{DefId, LocalDefId, CRATE_DEF_ID};\n use rustc_hir::definitions::DefPathData;\n use rustc_hir::{PrimTy, TraitCandidate};"}, {"sha": "1a99bff610a0257dba1f142cee57acf275f55f37", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3a8b0144c82197a70e919ad371d56f82c2282833/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a8b0144c82197a70e919ad371d56f82c2282833/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=3a8b0144c82197a70e919ad371d56f82c2282833", "patch": "@@ -11,7 +11,6 @@ use rustc_ast::{\n     self as ast, AssocItemKind, Expr, ExprKind, GenericParam, GenericParamKind, Item, ItemKind,\n     NodeId, Path, Ty, TyKind,\n };\n-use rustc_ast_lowering::ResolverAstLowering;\n use rustc_ast_pretty::pprust::path_segment_to_string;\n use rustc_data_structures::fx::{FxHashSet, FxIndexSet};\n use rustc_errors::{"}, {"sha": "57384877da550d22e242ac0b7f114aa533fe1290", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 92, "deletions": 93, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/3a8b0144c82197a70e919ad371d56f82c2282833/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a8b0144c82197a70e919ad371d56f82c2282833/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=3a8b0144c82197a70e919ad371d56f82c2282833", "patch": "@@ -27,17 +27,16 @@ use rustc_arena::{DroplessArena, TypedArena};\n use rustc_ast::node_id::NodeMap;\n use rustc_ast::{self as ast, NodeId, CRATE_NODE_ID};\n use rustc_ast::{AngleBracketedArg, Crate, Expr, ExprKind, GenericArg, GenericArgs, LitKind, Path};\n-use rustc_ast_lowering::{LifetimeRes, ResolverAstLowering};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap, FxIndexSet};\n use rustc_data_structures::intern::Interned;\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::{Applicability, DiagnosticBuilder, ErrorGuaranteed};\n use rustc_expand::base::{DeriveResolutions, SyntaxExtension, SyntaxExtensionKind};\n use rustc_hir::def::Namespace::*;\n-use rustc_hir::def::{self, CtorOf, DefKind, PartialRes};\n-use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, DefPathHash, LocalDefId};\n+use rustc_hir::def::{self, CtorOf, DefKind, LifetimeRes, PartialRes};\n+use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, LocalDefId};\n use rustc_hir::def_id::{CRATE_DEF_ID, LOCAL_CRATE};\n-use rustc_hir::definitions::{DefKey, DefPathData, Definitions};\n+use rustc_hir::definitions::{DefPathData, Definitions};\n use rustc_hir::TraitCandidate;\n use rustc_index::vec::IndexVec;\n use rustc_metadata::creader::{CStore, CrateLoader};\n@@ -47,7 +46,7 @@ use rustc_middle::span_bug;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, DefIdTree, MainDefinition, RegisteredTools, ResolverOutputs};\n use rustc_query_system::ich::StableHashingContext;\n-use rustc_session::cstore::{CrateStore, MetadataLoaderDyn};\n+use rustc_session::cstore::{CrateStore, CrateStoreDyn, MetadataLoaderDyn};\n use rustc_session::lint::LintBuffer;\n use rustc_session::Session;\n use rustc_span::hygiene::{ExpnId, LocalExpnId, MacroKind, SyntaxContext, Transparency};\n@@ -879,6 +878,10 @@ pub struct Resolver<'a> {\n     session: &'a Session,\n \n     definitions: Definitions,\n+    /// Item with a given `LocalDefId` was defined during macro expansion with ID `ExpnId`.\n+    expn_that_defined: FxHashMap<LocalDefId, ExpnId>,\n+    /// Reference span for definitions.\n+    source_span: IndexVec<LocalDefId, Span>,\n \n     graph_root: Module<'a>,\n \n@@ -1127,85 +1130,15 @@ impl<'a, 'b> DefIdTree for &'a Resolver<'b> {\n     }\n }\n \n-/// This interface is used through the AST\u2192HIR step, to embed full paths into the HIR. After that\n-/// the resolver is no longer needed as all the relevant information is inline.\n-impl ResolverAstLowering for Resolver<'_> {\n-    fn def_key(&self, id: DefId) -> DefKey {\n-        if let Some(id) = id.as_local() {\n-            self.definitions.def_key(id)\n-        } else {\n-            self.cstore().def_key(id)\n-        }\n-    }\n-\n-    #[inline]\n-    fn def_span(&self, id: LocalDefId) -> Span {\n-        self.definitions.def_span(id)\n-    }\n-\n-    fn item_generics_num_lifetimes(&self, def_id: DefId) -> usize {\n-        if let Some(def_id) = def_id.as_local() {\n-            self.item_generics_num_lifetimes[&def_id]\n-        } else {\n-            self.cstore().item_generics_num_lifetimes(def_id, self.session)\n-        }\n-    }\n-\n-    fn legacy_const_generic_args(&mut self, expr: &Expr) -> Option<Vec<usize>> {\n-        self.legacy_const_generic_args(expr)\n-    }\n-\n-    fn get_partial_res(&self, id: NodeId) -> Option<PartialRes> {\n-        self.partial_res_map.get(&id).cloned()\n-    }\n-\n-    fn get_import_res(&self, id: NodeId) -> PerNS<Option<Res>> {\n-        self.import_res_map.get(&id).cloned().unwrap_or_default()\n-    }\n-\n-    fn get_label_res(&self, id: NodeId) -> Option<NodeId> {\n-        self.label_res_map.get(&id).cloned()\n-    }\n-\n-    fn get_lifetime_res(&self, id: NodeId) -> Option<LifetimeRes> {\n-        self.lifetimes_res_map.get(&id).copied()\n-    }\n-\n-    fn take_extra_lifetime_params(&mut self, id: NodeId) -> Vec<(Ident, NodeId, LifetimeRes)> {\n-        self.extra_lifetime_params_map.remove(&id).unwrap_or_default()\n-    }\n-\n-    fn create_stable_hashing_context(&self) -> StableHashingContext<'_> {\n-        StableHashingContext::new(self.session, &self.definitions, self.crate_loader.cstore())\n-    }\n-\n-    fn definitions(&self) -> &Definitions {\n-        &self.definitions\n-    }\n-\n-    fn next_node_id(&mut self) -> NodeId {\n-        self.next_node_id()\n-    }\n-\n-    fn take_trait_map(&mut self, node: NodeId) -> Option<Vec<TraitCandidate>> {\n-        self.trait_map.remove(&node)\n-    }\n-\n+impl Resolver<'_> {\n     fn opt_local_def_id(&self, node: NodeId) -> Option<LocalDefId> {\n         self.node_id_to_def_id.get(&node).copied()\n     }\n \n-    fn local_def_id(&self, node: NodeId) -> LocalDefId {\n+    pub fn local_def_id(&self, node: NodeId) -> LocalDefId {\n         self.opt_local_def_id(node).unwrap_or_else(|| panic!(\"no entry for node id: `{:?}`\", node))\n     }\n \n-    fn def_path_hash(&self, def_id: DefId) -> DefPathHash {\n-        match def_id.as_local() {\n-            Some(def_id) => self.definitions.def_path_hash(def_id),\n-            None => self.cstore().def_path_hash(def_id),\n-        }\n-    }\n-\n     /// Adds a definition with a parent definition.\n     fn create_def(\n         &mut self,\n@@ -1223,7 +1156,17 @@ impl ResolverAstLowering for Resolver<'_> {\n             self.definitions.def_key(self.node_id_to_def_id[&node_id]),\n         );\n \n-        let def_id = self.definitions.create_def(parent, data, expn_id, span);\n+        let def_id = self.definitions.create_def(parent, data);\n+\n+        // Create the definition.\n+        if expn_id != ExpnId::root() {\n+            self.expn_that_defined.insert(def_id, expn_id);\n+        }\n+\n+        // A relative span's parent must be an absolute span.\n+        debug_assert_eq!(span.data_untracked().parent, None);\n+        let _id = self.source_span.push(span);\n+        debug_assert_eq!(_id, def_id);\n \n         // Some things for which we allocate `LocalDefId`s don't correspond to\n         // anything in the AST, so they don't have a `NodeId`. For these cases\n@@ -1237,8 +1180,12 @@ impl ResolverAstLowering for Resolver<'_> {\n         def_id\n     }\n \n-    fn decl_macro_kind(&self, def_id: LocalDefId) -> MacroKind {\n-        self.builtin_macro_kinds.get(&def_id).copied().unwrap_or(MacroKind::Bang)\n+    fn item_generics_num_lifetimes(&self, def_id: DefId) -> usize {\n+        if let Some(def_id) = def_id.as_local() {\n+            self.item_generics_num_lifetimes[&def_id]\n+        } else {\n+            self.cstore().item_generics_num_lifetimes(def_id, self.session)\n+        }\n     }\n }\n \n@@ -1269,7 +1216,7 @@ impl<'a> Resolver<'a> {\n             &mut FxHashMap::default(),\n         );\n \n-        let definitions = Definitions::new(session.local_stable_crate_id(), krate.spans.inner_span);\n+        let definitions = Definitions::new(session.local_stable_crate_id());\n \n         let mut visibilities = FxHashMap::default();\n         visibilities.insert(CRATE_DEF_ID, ty::Visibility::Public);\n@@ -1282,6 +1229,10 @@ impl<'a> Resolver<'a> {\n         let mut invocation_parents = FxHashMap::default();\n         invocation_parents.insert(LocalExpnId::ROOT, (CRATE_DEF_ID, ImplTraitContext::Existential));\n \n+        let mut source_span = IndexVec::default();\n+        let _id = source_span.push(krate.spans.inner_span);\n+        debug_assert_eq!(_id, CRATE_DEF_ID);\n+\n         let mut extern_prelude: FxHashMap<Ident, ExternPreludeEntry<'_>> = session\n             .opts\n             .externs\n@@ -1306,6 +1257,8 @@ impl<'a> Resolver<'a> {\n             session,\n \n             definitions,\n+            expn_that_defined: Default::default(),\n+            source_span,\n \n             // The outermost module has def ID 0; this is not reflected in the\n             // AST.\n@@ -1445,9 +1398,14 @@ impl<'a> Resolver<'a> {\n         Default::default()\n     }\n \n-    pub fn into_outputs(self) -> ResolverOutputs {\n+    pub fn into_outputs(\n+        self,\n+    ) -> (Definitions, Box<CrateStoreDyn>, ResolverOutputs, ty::ResolverAstLowering) {\n         let proc_macros = self.proc_macros.iter().map(|id| self.local_def_id(*id)).collect();\n         let definitions = self.definitions;\n+        let cstore = Box::new(self.crate_loader.into_cstore());\n+        let source_span = self.source_span;\n+        let expn_that_defined = self.expn_that_defined;\n         let visibilities = self.visibilities;\n         let has_pub_restricted = self.has_pub_restricted;\n         let extern_crate_map = self.extern_crate_map;\n@@ -1458,9 +1416,9 @@ impl<'a> Resolver<'a> {\n         let main_def = self.main_def;\n         let confused_type_with_std_module = self.confused_type_with_std_module;\n         let access_levels = self.access_levels;\n-        ResolverOutputs {\n-            definitions,\n-            cstore: Box::new(self.crate_loader.into_cstore()),\n+        let resolutions = ResolverOutputs {\n+            source_span,\n+            expn_that_defined,\n             visibilities,\n             has_pub_restricted,\n             access_levels,\n@@ -1479,15 +1437,32 @@ impl<'a> Resolver<'a> {\n             proc_macros,\n             confused_type_with_std_module,\n             registered_tools: self.registered_tools,\n-        }\n+        };\n+        let resolutions_lowering = ty::ResolverAstLowering {\n+            legacy_const_generic_args: self.legacy_const_generic_args,\n+            partial_res_map: self.partial_res_map,\n+            import_res_map: self.import_res_map,\n+            label_res_map: self.label_res_map,\n+            lifetimes_res_map: self.lifetimes_res_map,\n+            extra_lifetime_params_map: self.extra_lifetime_params_map,\n+            next_node_id: self.next_node_id,\n+            node_id_to_def_id: self.node_id_to_def_id,\n+            def_id_to_node_id: self.def_id_to_node_id,\n+            trait_map: self.trait_map,\n+            builtin_macro_kinds: self.builtin_macro_kinds,\n+        };\n+        (definitions, cstore, resolutions, resolutions_lowering)\n     }\n \n-    pub fn clone_outputs(&self) -> ResolverOutputs {\n+    pub fn clone_outputs(\n+        &self,\n+    ) -> (Definitions, Box<CrateStoreDyn>, ResolverOutputs, ty::ResolverAstLowering) {\n         let proc_macros = self.proc_macros.iter().map(|id| self.local_def_id(*id)).collect();\n-        ResolverOutputs {\n-            definitions: self.definitions.clone(),\n-            access_levels: self.access_levels.clone(),\n-            cstore: Box::new(self.cstore().clone()),\n+        let definitions = self.definitions.clone();\n+        let cstore = Box::new(self.cstore().clone());\n+        let resolutions = ResolverOutputs {\n+            source_span: self.source_span.clone(),\n+            expn_that_defined: self.expn_that_defined.clone(),\n             visibilities: self.visibilities.clone(),\n             has_pub_restricted: self.has_pub_restricted,\n             extern_crate_map: self.extern_crate_map.clone(),\n@@ -1505,7 +1480,31 @@ impl<'a> Resolver<'a> {\n             proc_macros,\n             confused_type_with_std_module: self.confused_type_with_std_module.clone(),\n             registered_tools: self.registered_tools.clone(),\n-        }\n+            access_levels: self.access_levels.clone(),\n+        };\n+        let resolutions_lowering = ty::ResolverAstLowering {\n+            legacy_const_generic_args: self.legacy_const_generic_args.clone(),\n+            partial_res_map: self.partial_res_map.clone(),\n+            import_res_map: self.import_res_map.clone(),\n+            label_res_map: self.label_res_map.clone(),\n+            lifetimes_res_map: self.lifetimes_res_map.clone(),\n+            extra_lifetime_params_map: self.extra_lifetime_params_map.clone(),\n+            next_node_id: self.next_node_id.clone(),\n+            node_id_to_def_id: self.node_id_to_def_id.clone(),\n+            def_id_to_node_id: self.def_id_to_node_id.clone(),\n+            trait_map: self.trait_map.clone(),\n+            builtin_macro_kinds: self.builtin_macro_kinds.clone(),\n+        };\n+        (definitions, cstore, resolutions, resolutions_lowering)\n+    }\n+\n+    fn create_stable_hashing_context(&self) -> StableHashingContext<'_> {\n+        StableHashingContext::new(\n+            self.session,\n+            &self.definitions,\n+            self.crate_loader.cstore(),\n+            &self.source_span,\n+        )\n     }\n \n     pub fn cstore(&self) -> &CStore {\n@@ -1936,7 +1935,7 @@ impl<'a> Resolver<'a> {\n     /// Retrieves the span of the given `DefId` if `DefId` is in the local crate.\n     #[inline]\n     pub fn opt_span(&self, def_id: DefId) -> Option<Span> {\n-        def_id.as_local().map(|def_id| self.definitions.def_span(def_id))\n+        def_id.as_local().map(|def_id| self.source_span[def_id])\n     }\n \n     /// Checks if an expression refers to a function marked with"}, {"sha": "4210560f5312b189e70b28b3c3d71cc1b4802950", "filename": "compiler/rustc_resolve/src/macros.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3a8b0144c82197a70e919ad371d56f82c2282833/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a8b0144c82197a70e919ad371d56f82c2282833/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs?ref=3a8b0144c82197a70e919ad371d56f82c2282833", "patch": "@@ -7,7 +7,6 @@ use crate::{BuiltinMacroState, Determinacy};\n use crate::{DeriveData, Finalize, ParentScope, ResolutionError, Resolver, ScopeSet};\n use crate::{ModuleKind, ModuleOrUniformRoot, NameBinding, PathResult, Segment};\n use rustc_ast::{self as ast, Inline, ItemKind, ModKind, NodeId};\n-use rustc_ast_lowering::ResolverAstLowering;\n use rustc_ast_pretty::pprust;\n use rustc_attr::StabilityLevel;\n use rustc_data_structures::fx::FxHashSet;"}, {"sha": "54b851660416ac93cbc4d0c48a0f3564b452caa7", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3a8b0144c82197a70e919ad371d56f82c2282833/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a8b0144c82197a70e919ad371d56f82c2282833/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=3a8b0144c82197a70e919ad371d56f82c2282833", "patch": "@@ -36,7 +36,6 @@ extern crate tracing;\n // Dependencies listed in Cargo.toml do not need `extern crate`.\n \n extern crate rustc_ast;\n-extern crate rustc_ast_lowering;\n extern crate rustc_ast_pretty;\n extern crate rustc_attr;\n extern crate rustc_const_eval;"}, {"sha": "38cfd7a27ddb48cdcf590aeb4330b103afb31708", "filename": "src/librustdoc/passes/collect_intra_doc_links/early.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3a8b0144c82197a70e919ad371d56f82c2282833/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links%2Fearly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a8b0144c82197a70e919ad371d56f82c2282833/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links%2Fearly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links%2Fearly.rs?ref=3a8b0144c82197a70e919ad371d56f82c2282833", "patch": "@@ -5,7 +5,6 @@ use crate::passes::collect_intra_doc_links::{Disambiguator, PreprocessedMarkdown\n \n use rustc_ast::visit::{self, AssocCtxt, Visitor};\n use rustc_ast::{self as ast, ItemKind};\n-use rustc_ast_lowering::ResolverAstLowering;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir::def::Namespace::*;\n use rustc_hir::def::{DefKind, Namespace, Res};"}]}