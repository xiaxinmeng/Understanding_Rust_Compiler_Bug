{"sha": "71efd950d17faabc4025acb460c4000bf97978f7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcxZWZkOTUwZDE3ZmFhYmM0MDI1YWNiNDYwYzQwMDBiZjk3OTc4Zjc=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2021-07-25T12:08:12Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2021-07-25T12:21:06Z"}, "message": "also ignore 'thread leaks' with -Zmiri-ignore-leaks", "tree": {"sha": "3e10cbb22bce2d01232e6f7004e9a0d3f42c3450", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3e10cbb22bce2d01232e6f7004e9a0d3f42c3450"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/71efd950d17faabc4025acb460c4000bf97978f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/71efd950d17faabc4025acb460c4000bf97978f7", "html_url": "https://github.com/rust-lang/rust/commit/71efd950d17faabc4025acb460c4000bf97978f7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/71efd950d17faabc4025acb460c4000bf97978f7/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e2872a3f2a26154b91a6a6085d56016509803c61", "url": "https://api.github.com/repos/rust-lang/rust/commits/e2872a3f2a26154b91a6a6085d56016509803c61", "html_url": "https://github.com/rust-lang/rust/commit/e2872a3f2a26154b91a6a6085d56016509803c61"}], "stats": {"total": 61, "additions": 49, "deletions": 12}, "files": [{"sha": "7cd802762bff27c153d354ee529bab48834ff825", "filename": "README.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/71efd950d17faabc4025acb460c4000bf97978f7/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/71efd950d17faabc4025acb460c4000bf97978f7/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=71efd950d17faabc4025acb460c4000bf97978f7", "patch": "@@ -230,7 +230,8 @@ environment variable:\n   the host so that it cannot be accessed by the program.  Can be used multiple\n   times to exclude several variables.  On Windows, the `TERM` environment\n   variable is excluded by default.\n-* `-Zmiri-ignore-leaks` disables the memory leak checker.\n+* `-Zmiri-ignore-leaks` disables the memory leak checker, and also allows some\n+  remaining threads to exist when the main thread exits.\n * `-Zmiri-measureme=<name>` enables `measureme` profiling for the interpreted program.\n    This can be used to find which parts of your program are executing slowly under Miri.\n    The profile is written out to a file with the prefix `<name>`, and can be processed"}, {"sha": "9531a2d78aba60d1512594e4380f8e05499655b6", "filename": "src/eval.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/71efd950d17faabc4025acb460c4000bf97978f7/src%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71efd950d17faabc4025acb460c4000bf97978f7/src%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval.rs?ref=71efd950d17faabc4025acb460c4000bf97978f7", "patch": "@@ -300,6 +300,12 @@ pub fn eval_main<'tcx>(tcx: TyCtxt<'tcx>, main_id: DefId, config: MiriConfig) ->\n     match res {\n         Ok(return_code) => {\n             if !ignore_leaks {\n+                // Check for thread leaks.\n+                if !ecx.have_all_terminated() {\n+                    tcx.sess.err(\"the main thread terminated without waiting for all remaining threads\");\n+                    return None;\n+                }\n+                // Check for memory leaks.\n                 info!(\"Additonal static roots: {:?}\", ecx.machine.static_roots);\n                 let leaks = ecx.memory.leak_report(&ecx.machine.static_roots);\n                 if leaks != 0 {"}, {"sha": "a5deceb6e71dce95588a2540eea28136e1d38ce5", "filename": "src/thread.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/71efd950d17faabc4025acb460c4000bf97978f7/src%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71efd950d17faabc4025acb460c4000bf97978f7/src%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fthread.rs?ref=71efd950d17faabc4025acb460c4000bf97978f7", "patch": "@@ -302,6 +302,11 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n         self.threads[thread_id].state == ThreadState::Terminated\n     }\n \n+    /// Have all threads terminated?\n+    fn have_all_terminated(&self) -> bool {\n+        self.threads.iter().all(|thread| thread.state == ThreadState::Terminated)\n+    }\n+\n     /// Enable the thread for execution. The thread must be terminated.\n     fn enable_thread(&mut self, thread_id: ThreadId) {\n         assert!(self.has_terminated(thread_id));\n@@ -491,15 +496,7 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n         // If we get here again and the thread is *still* terminated, there are no more dtors to run.\n         if self.threads[MAIN_THREAD].state == ThreadState::Terminated {\n             // The main thread terminated; stop the program.\n-            if self.threads.iter().any(|thread| thread.state != ThreadState::Terminated) {\n-                // FIXME: This check should be either configurable or just emit\n-                // a warning. For example, it seems normal for a program to\n-                // terminate without waiting for its detached threads to\n-                // terminate. However, this case is not trivial to support\n-                // because we also probably do not want to consider the memory\n-                // owned by these threads as leaked.\n-                throw_unsup_format!(\"the main thread terminated without waiting for other threads\");\n-            }\n+            // We do *not* run TLS dtors of remaining threads, which seems to match rustc behavior.\n             return Ok(SchedulingAction::Stop);\n         }\n         // This thread and the program can keep going.\n@@ -645,6 +642,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         this.machine.threads.has_terminated(thread_id)\n     }\n \n+    #[inline]\n+    fn have_all_terminated(&self) -> bool {\n+        let this = self.eval_context_ref();\n+        this.machine.threads.have_all_terminated()\n+    }\n+\n     #[inline]\n     fn enable_thread(&mut self, thread_id: ThreadId) {\n         let this = self.eval_context_mut();"}, {"sha": "9b576bbb0868d2b2d8eb59072de5744cd05e591e", "filename": "tests/compile-fail/concurrency/libc_pthread_create_main_terminate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/71efd950d17faabc4025acb460c4000bf97978f7/tests%2Fcompile-fail%2Fconcurrency%2Flibc_pthread_create_main_terminate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71efd950d17faabc4025acb460c4000bf97978f7/tests%2Fcompile-fail%2Fconcurrency%2Flibc_pthread_create_main_terminate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fconcurrency%2Flibc_pthread_create_main_terminate.rs?ref=71efd950d17faabc4025acb460c4000bf97978f7", "patch": "@@ -1,5 +1,5 @@\n // ignore-windows: No libc on Windows\n-// error-pattern: unsupported operation: the main thread terminated without waiting for other threads\n+// error-pattern: the main thread terminated without waiting for all remaining threads\n \n // Check that we terminate the program when the main thread terminates.\n \n@@ -10,7 +10,7 @@ extern crate libc;\n use std::{mem, ptr};\n \n extern \"C\" fn thread_start(_null: *mut libc::c_void) -> *mut libc::c_void {\n-    ptr::null_mut()\n+    loop {}\n }\n \n fn main() {"}, {"sha": "14a7449f3392ae462ae478f275bb1e73c9a9488a", "filename": "tests/run-pass/threadleak_ignored.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/71efd950d17faabc4025acb460c4000bf97978f7/tests%2Frun-pass%2Fthreadleak_ignored.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71efd950d17faabc4025acb460c4000bf97978f7/tests%2Frun-pass%2Fthreadleak_ignored.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fthreadleak_ignored.rs?ref=71efd950d17faabc4025acb460c4000bf97978f7", "patch": "@@ -0,0 +1,24 @@\n+// compile-flags: -Zmiri-ignore-leaks\n+\n+//! Test that leaking threads works, and that their destructors are not executed.\n+\n+use std::cell::RefCell;\n+\n+struct LoudDrop(i32);\n+impl Drop for LoudDrop {\n+    fn drop(&mut self) {\n+        eprintln!(\"Dropping {}\", self.0);\n+    }\n+}\n+\n+thread_local! {\n+    static X: RefCell<Option<LoudDrop>> = RefCell::new(None);\n+}\n+\n+fn main() {\n+    X.with(|x| *x.borrow_mut() = Some(LoudDrop(0)));\n+    \n+    let _detached = std::thread::spawn(|| {\n+        X.with(|x| *x.borrow_mut() = Some(LoudDrop(1)));\n+    });\n+}"}, {"sha": "aa037511853b28feca5b8b942a1f47832fb81610", "filename": "tests/run-pass/threadleak_ignored.stderr", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/71efd950d17faabc4025acb460c4000bf97978f7/tests%2Frun-pass%2Fthreadleak_ignored.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/71efd950d17faabc4025acb460c4000bf97978f7/tests%2Frun-pass%2Fthreadleak_ignored.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fthreadleak_ignored.stderr?ref=71efd950d17faabc4025acb460c4000bf97978f7", "patch": "@@ -0,0 +1,3 @@\n+warning: thread support is experimental and incomplete: weak memory effects are not emulated.\n+\n+Dropping 0"}]}