{"sha": "74ae2dd3039cd80fc77e4ed0c0a206be6660dd9a", "node_id": "C_kwDOAAsO6NoAKDc0YWUyZGQzMDM5Y2Q4MGZjNzdlNGVkMGMwYTIwNmJlNjY2MGRkOWE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-25T14:53:16Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-25T14:53:16Z"}, "message": "Auto merge of #13840 - lowr:fix/hir-callable-sig-escaping-boundvars, r=lowr\n\nfix: handle lifetime variables in `CallableSig` query\n\nFixes #13838\n\nThe problem is similar to #13223: we've been skipping non-empty binders, letting lifetime bound variables escape.\n\nI ended up refactoring `hir_ty::callable_sig_from_fnonce()`. Like #13223, I chose to make use of `InferenceTable` which is capable of handling variables (I feel we should always use it when we solve trait-related stuff instead of manually building obligations/queries).\n\nI couldn't make up a test that crashes without this patch (since the function I'm fixing is only used *outside* `hir-ty`, simple `hir-ty` test wouldn't cause crash), but at least I tested with my local build and made sure it doesn't crash with the code in the original issue. I'd appreciate any help to find a regression test.", "tree": {"sha": "0fdb766c3330fee976d49ec5dcdf5c7bc954cc9f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0fdb766c3330fee976d49ec5dcdf5c7bc954cc9f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/74ae2dd3039cd80fc77e4ed0c0a206be6660dd9a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/74ae2dd3039cd80fc77e4ed0c0a206be6660dd9a", "html_url": "https://github.com/rust-lang/rust/commit/74ae2dd3039cd80fc77e4ed0c0a206be6660dd9a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/74ae2dd3039cd80fc77e4ed0c0a206be6660dd9a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2872e0558982360d499bdba79cf1a3ed06f1ae82", "url": "https://api.github.com/repos/rust-lang/rust/commits/2872e0558982360d499bdba79cf1a3ed06f1ae82", "html_url": "https://github.com/rust-lang/rust/commit/2872e0558982360d499bdba79cf1a3ed06f1ae82"}, {"sha": "a1a408367e5c4d8b4a323d5e65d8df4d3d9c44cc", "url": "https://api.github.com/repos/rust-lang/rust/commits/a1a408367e5c4d8b4a323d5e65d8df4d3d9c44cc", "html_url": "https://github.com/rust-lang/rust/commit/a1a408367e5c4d8b4a323d5e65d8df4d3d9c44cc"}], "stats": {"total": 86, "additions": 43, "deletions": 43}, "files": [{"sha": "cbe6873c7d5f54e575ede00acae6db8e6c9987bd", "filename": "crates/hir-ty/src/lib.rs", "status": "modified", "additions": 23, "deletions": 43, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/74ae2dd3039cd80fc77e4ed0c0a206be6660dd9a/crates%2Fhir-ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74ae2dd3039cd80fc77e4ed0c0a206be6660dd9a/crates%2Fhir-ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Flib.rs?ref=74ae2dd3039cd80fc77e4ed0c0a206be6660dd9a", "patch": "@@ -40,15 +40,17 @@ use std::sync::Arc;\n use chalk_ir::{\n     fold::{Shift, TypeFoldable},\n     interner::HasInterner,\n-    NoSolution, UniverseIndex,\n+    NoSolution,\n };\n use hir_def::{expr::ExprId, type_ref::Rawness, TypeOrConstParamId};\n use hir_expand::name;\n use itertools::Either;\n use traits::FnTrait;\n use utils::Generics;\n \n-use crate::{consteval::unknown_const, db::HirDatabase, utils::generics};\n+use crate::{\n+    consteval::unknown_const, db::HirDatabase, infer::unify::InferenceTable, utils::generics,\n+};\n \n pub use autoderef::autoderef;\n pub use builder::{ParamKind, TyBuilder};\n@@ -533,53 +535,31 @@ pub fn callable_sig_from_fnonce(\n     let fn_once_trait = FnTrait::FnOnce.get_id(db, krate)?;\n     let output_assoc_type = db.trait_data(fn_once_trait).associated_type_by_name(&name![Output])?;\n \n+    let mut table = InferenceTable::new(db, env.clone());\n     let b = TyBuilder::trait_ref(db, fn_once_trait);\n     if b.remaining() != 2 {\n         return None;\n     }\n-    let fn_once = b.push(self_ty.clone()).fill_with_bound_vars(DebruijnIndex::INNERMOST, 0).build();\n-    let kinds = fn_once\n-        .substitution\n-        .iter(Interner)\n-        .skip(1)\n-        .map(|x| {\n-            let vk = match x.data(Interner) {\n-                chalk_ir::GenericArgData::Ty(_) => {\n-                    chalk_ir::VariableKind::Ty(chalk_ir::TyVariableKind::General)\n-                }\n-                chalk_ir::GenericArgData::Lifetime(_) => chalk_ir::VariableKind::Lifetime,\n-                chalk_ir::GenericArgData::Const(c) => {\n-                    chalk_ir::VariableKind::Const(c.data(Interner).ty.clone())\n-                }\n-            };\n-            chalk_ir::WithKind::new(vk, UniverseIndex::ROOT)\n-        })\n-        .collect::<Vec<_>>();\n-\n-    // FIXME: chalk refuses to solve `<Self as FnOnce<^0.0>>::Output == ^0.1`, so we first solve\n-    // `<Self as FnOnce<^0.0>>` and then replace `^0.0` with the concrete argument tuple.\n-    let trait_env = env.env.clone();\n-    let obligation = InEnvironment { goal: fn_once.cast(Interner), environment: trait_env };\n-    let canonical =\n-        Canonical { binders: CanonicalVarKinds::from_iter(Interner, kinds), value: obligation };\n-    let subst = match db.trait_solve(krate, canonical) {\n-        Some(Solution::Unique(vars)) => vars.value.subst,\n-        _ => return None,\n-    };\n-    let args = subst.at(Interner, 0).ty(Interner)?;\n-    let params = match args.kind(Interner) {\n-        chalk_ir::TyKind::Tuple(_, subst) => {\n-            subst.iter(Interner).filter_map(|arg| arg.ty(Interner).cloned()).collect::<Vec<_>>()\n-        }\n-        _ => return None,\n-    };\n \n-    let fn_once =\n-        TyBuilder::trait_ref(db, fn_once_trait).push(self_ty.clone()).push(args.clone()).build();\n-    let projection =\n-        TyBuilder::assoc_type_projection(db, output_assoc_type, Some(fn_once.substitution)).build();\n+    // Register two obligations:\n+    // - Self: FnOnce<?args_ty>\n+    // - <Self as FnOnce<?args_ty>>::Output == ?ret_ty\n+    let args_ty = table.new_type_var();\n+    let trait_ref = b.push(self_ty.clone()).push(args_ty.clone()).build();\n+    let projection = TyBuilder::assoc_type_projection(\n+        db,\n+        output_assoc_type,\n+        Some(trait_ref.substitution.clone()),\n+    )\n+    .build();\n+    table.register_obligation(trait_ref.cast(Interner));\n+    let ret_ty = table.normalize_projection_ty(projection);\n+\n+    let ret_ty = table.resolve_completely(ret_ty);\n+    let args_ty = table.resolve_completely(args_ty);\n \n-    let ret_ty = db.normalize_projection(projection, env);\n+    let params =\n+        args_ty.as_tuple()?.iter(Interner).map(|it| it.assert_ty_ref(Interner)).cloned().collect();\n \n     Some(CallableSig::from_params_and_return(params, ret_ty, false, Safety::Safe))\n }"}, {"sha": "2f870d769c0fb8609b5ebf216037884ba760489d", "filename": "crates/ide/src/syntax_highlighting/tests.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/74ae2dd3039cd80fc77e4ed0c0a206be6660dd9a/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74ae2dd3039cd80fc77e4ed0c0a206be6660dd9a/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs?ref=74ae2dd3039cd80fc77e4ed0c0a206be6660dd9a", "patch": "@@ -1028,6 +1028,26 @@ macro_rules! test {}\n     let _ = analysis.highlight(HL_CONFIG, file_id).unwrap();\n }\n \n+#[test]\n+fn highlight_callable_no_crash() {\n+    // regression test for #13838.\n+    let (analysis, file_id) = fixture::file(\n+        r#\"\n+//- minicore: fn, sized\n+impl<A, F: ?Sized> FnOnce<A> for &F\n+where\n+    F: Fn<A>,\n+{\n+    type Output = F::Output;\n+}\n+\n+trait Trait {}\n+fn foo(x: &fn(&dyn Trait)) {}\n+\"#,\n+    );\n+    let _ = analysis.highlight(HL_CONFIG, file_id).unwrap();\n+}\n+\n /// Highlights the code given by the `ra_fixture` argument, renders the\n /// result as HTML, and compares it with the HTML file given as `snapshot`.\n /// Note that the `snapshot` file is overwritten by the rendered HTML."}]}