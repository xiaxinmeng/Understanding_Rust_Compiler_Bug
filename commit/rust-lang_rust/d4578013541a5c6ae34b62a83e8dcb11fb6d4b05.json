{"sha": "d4578013541a5c6ae34b62a83e8dcb11fb6d4b05", "node_id": "C_kwDOAAsO6NoAKGQ0NTc4MDEzNTQxYTVjNmFlMzRiNjJhODNlOGRjYjExZmI2ZDRiMDU", "commit": {"author": {"name": "joboet", "email": "jonasboettiger@icloud.com", "date": "2022-10-08T18:19:21Z"}, "committer": {"name": "joboet", "email": "jonasboettiger@icloud.com", "date": "2022-10-08T18:19:21Z"}, "message": "std: optimize TLS on Windows", "tree": {"sha": "df5b4b863f1ec8996dfcecd8ce357fe0af47c3aa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/df5b4b863f1ec8996dfcecd8ce357fe0af47c3aa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d4578013541a5c6ae34b62a83e8dcb11fb6d4b05", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEVuz3PwcqDyifNyYbcE4BSbAZSzwFAmNBvykACgkQcE4BSbAZ\nSzyjChAAi6A6PT8MUIKoERs5uEX0CAZBTKpQrJ1ONN41vyCQoCEBoYAjhdwHouY4\nFPQMCpMbJfCGCXEs21Vvibxtif74ma/OpS1O/zq0C+THPHhTKUIq7NtpnVYfuUt6\nuQ59n3qu4wZyG7cgJG6gvqeQDTcHomKIkw8VlqE1zfXks1G/iJEphCyWxnz/S83y\nXHV+okkSGvIZIVKdhAcMtuxs3M4DsnUh0QkMvzst3L+5JWS5GXzhqVwTTOsjNHfB\nISvNdfMLor9JKd6OVn2xSC+c8k17npGzuZtzg0+G7AAuJXrUS3fnH89PNj8jWO8r\nI0cw8IvC+X6/ZPxDrtJe7qtL9RVql6a5YCSWC/sEbUcHmDvuGgQruEHNMOXrHZRz\ntyvnsSvEYwDYSYrgFWkn3mMTALD/+E4VBEmKQFEZ+V92/ZXDfMgXwAlOpElMwidj\nghZmNqTPWkQCihgOPQs2ER6mYi1GQzM7E4Ylh8fFpeQC6bkq+eu4rvyhYvmQ2PxA\nl//BA2BJdJ9pnZUCogzLvXEs7SEVaFJoGUASZVRCVKtnkmweWuQc+EbBIJ5kZ8sO\nRgktoqoJ5XFDcWaeFDWR/zI1Xjca4XDvOLMLSHm5WavnApL9hUZpr//+zHdF+EnX\nCimFptPFugLT1MHf2CUYKogZngxuzNHp2AoSnfmR1keqhvTDSNo=\n=XL1O\n-----END PGP SIGNATURE-----", "payload": "tree df5b4b863f1ec8996dfcecd8ce357fe0af47c3aa\nparent cba4a389b3961a2fd72e01bd6cb0b0e065edaf3d\nauthor joboet <jonasboettiger@icloud.com> 1665253161 +0200\ncommitter joboet <jonasboettiger@icloud.com> 1665253161 +0200\n\nstd: optimize TLS on Windows\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d4578013541a5c6ae34b62a83e8dcb11fb6d4b05", "html_url": "https://github.com/rust-lang/rust/commit/d4578013541a5c6ae34b62a83e8dcb11fb6d4b05", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d4578013541a5c6ae34b62a83e8dcb11fb6d4b05/comments", "author": {"login": "joboet", "id": 25721079, "node_id": "MDQ6VXNlcjI1NzIxMDc5", "avatar_url": "https://avatars.githubusercontent.com/u/25721079?v=4", "gravatar_id": "", "url": "https://api.github.com/users/joboet", "html_url": "https://github.com/joboet", "followers_url": "https://api.github.com/users/joboet/followers", "following_url": "https://api.github.com/users/joboet/following{/other_user}", "gists_url": "https://api.github.com/users/joboet/gists{/gist_id}", "starred_url": "https://api.github.com/users/joboet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/joboet/subscriptions", "organizations_url": "https://api.github.com/users/joboet/orgs", "repos_url": "https://api.github.com/users/joboet/repos", "events_url": "https://api.github.com/users/joboet/events{/privacy}", "received_events_url": "https://api.github.com/users/joboet/received_events", "type": "User", "site_admin": false}, "committer": {"login": "joboet", "id": 25721079, "node_id": "MDQ6VXNlcjI1NzIxMDc5", "avatar_url": "https://avatars.githubusercontent.com/u/25721079?v=4", "gravatar_id": "", "url": "https://api.github.com/users/joboet", "html_url": "https://github.com/joboet", "followers_url": "https://api.github.com/users/joboet/followers", "following_url": "https://api.github.com/users/joboet/following{/other_user}", "gists_url": "https://api.github.com/users/joboet/gists{/gist_id}", "starred_url": "https://api.github.com/users/joboet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/joboet/subscriptions", "organizations_url": "https://api.github.com/users/joboet/orgs", "repos_url": "https://api.github.com/users/joboet/repos", "events_url": "https://api.github.com/users/joboet/events{/privacy}", "received_events_url": "https://api.github.com/users/joboet/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cba4a389b3961a2fd72e01bd6cb0b0e065edaf3d", "url": "https://api.github.com/repos/rust-lang/rust/commits/cba4a389b3961a2fd72e01bd6cb0b0e065edaf3d", "html_url": "https://github.com/rust-lang/rust/commit/cba4a389b3961a2fd72e01bd6cb0b0e065edaf3d"}], "stats": {"total": 319, "additions": 202, "deletions": 117}, "files": [{"sha": "c7a57d3a3d47e3fe290944f6fe9c23277a2ee84e", "filename": "library/std/src/sys/sgx/thread_local_key.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d4578013541a5c6ae34b62a83e8dcb11fb6d4b05/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fthread_local_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4578013541a5c6ae34b62a83e8dcb11fb6d4b05/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fthread_local_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fthread_local_key.rs?ref=d4578013541a5c6ae34b62a83e8dcb11fb6d4b05", "patch": "@@ -21,8 +21,3 @@ pub unsafe fn get(key: Key) -> *mut u8 {\n pub unsafe fn destroy(key: Key) {\n     Tls::destroy(AbiKey::from_usize(key))\n }\n-\n-#[inline]\n-pub fn requires_synchronized_create() -> bool {\n-    false\n-}"}, {"sha": "b37bf999698873fe1b159c8e0ecc7985b198fa46", "filename": "library/std/src/sys/solid/thread_local_key.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d4578013541a5c6ae34b62a83e8dcb11fb6d4b05/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fthread_local_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4578013541a5c6ae34b62a83e8dcb11fb6d4b05/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fthread_local_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fthread_local_key.rs?ref=d4578013541a5c6ae34b62a83e8dcb11fb6d4b05", "patch": "@@ -19,8 +19,3 @@ pub unsafe fn get(_key: Key) -> *mut u8 {\n pub unsafe fn destroy(_key: Key) {\n     panic!(\"should not be used on the solid target\");\n }\n-\n-#[inline]\n-pub fn requires_synchronized_create() -> bool {\n-    panic!(\"should not be used on the solid target\");\n-}"}, {"sha": "2b2d079ee4d012730b8324561c78beab7191fda7", "filename": "library/std/src/sys/unix/thread_local_key.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d4578013541a5c6ae34b62a83e8dcb11fb6d4b05/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_local_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4578013541a5c6ae34b62a83e8dcb11fb6d4b05/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_local_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_local_key.rs?ref=d4578013541a5c6ae34b62a83e8dcb11fb6d4b05", "patch": "@@ -27,8 +27,3 @@ pub unsafe fn destroy(key: Key) {\n     let r = libc::pthread_key_delete(key);\n     debug_assert_eq!(r, 0);\n }\n-\n-#[inline]\n-pub fn requires_synchronized_create() -> bool {\n-    false\n-}"}, {"sha": "b6e5e4cd2e197872f23b17e2101e129021029ce8", "filename": "library/std/src/sys/unsupported/thread_local_key.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d4578013541a5c6ae34b62a83e8dcb11fb6d4b05/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fthread_local_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4578013541a5c6ae34b62a83e8dcb11fb6d4b05/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fthread_local_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fthread_local_key.rs?ref=d4578013541a5c6ae34b62a83e8dcb11fb6d4b05", "patch": "@@ -19,8 +19,3 @@ pub unsafe fn get(_key: Key) -> *mut u8 {\n pub unsafe fn destroy(_key: Key) {\n     panic!(\"should not be used on this target\");\n }\n-\n-#[inline]\n-pub fn requires_synchronized_create() -> bool {\n-    panic!(\"should not be used on this target\");\n-}"}, {"sha": "e43229588f888304c2772afbc5a2bc5f650aa9fc", "filename": "library/std/src/sys/windows/c.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d4578013541a5c6ae34b62a83e8dcb11fb6d4b05/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4578013541a5c6ae34b62a83e8dcb11fb6d4b05/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs?ref=d4578013541a5c6ae34b62a83e8dcb11fb6d4b05", "patch": "@@ -71,6 +71,7 @@ pub type BCRYPT_ALG_HANDLE = LPVOID;\n pub type PCONDITION_VARIABLE = *mut CONDITION_VARIABLE;\n pub type PLARGE_INTEGER = *mut c_longlong;\n pub type PSRWLOCK = *mut SRWLOCK;\n+pub type LPINIT_ONCE = *mut INIT_ONCE;\n \n pub type SOCKET = crate::os::windows::raw::SOCKET;\n pub type socklen_t = c_int;\n@@ -194,6 +195,9 @@ pub const DUPLICATE_SAME_ACCESS: DWORD = 0x00000002;\n \n pub const CONDITION_VARIABLE_INIT: CONDITION_VARIABLE = CONDITION_VARIABLE { ptr: ptr::null_mut() };\n pub const SRWLOCK_INIT: SRWLOCK = SRWLOCK { ptr: ptr::null_mut() };\n+pub const INIT_ONCE_STATIC_INIT: INIT_ONCE = INIT_ONCE { ptr: ptr::null_mut() };\n+\n+pub const INIT_ONCE_INIT_FAILED: DWORD = 0x00000004;\n \n pub const DETACHED_PROCESS: DWORD = 0x00000008;\n pub const CREATE_NEW_PROCESS_GROUP: DWORD = 0x00000200;\n@@ -565,6 +569,10 @@ pub struct CONDITION_VARIABLE {\n pub struct SRWLOCK {\n     pub ptr: LPVOID,\n }\n+#[repr(C)]\n+pub struct INIT_ONCE {\n+    pub ptr: LPVOID,\n+}\n \n #[repr(C)]\n pub struct REPARSE_MOUNTPOINT_DATA_BUFFER {\n@@ -959,6 +967,7 @@ extern \"system\" {\n     pub fn TlsAlloc() -> DWORD;\n     pub fn TlsGetValue(dwTlsIndex: DWORD) -> LPVOID;\n     pub fn TlsSetValue(dwTlsIndex: DWORD, lpTlsvalue: LPVOID) -> BOOL;\n+    pub fn TlsFree(dwTlsIndex: DWORD) -> BOOL;\n     pub fn GetLastError() -> DWORD;\n     pub fn QueryPerformanceFrequency(lpFrequency: *mut LARGE_INTEGER) -> BOOL;\n     pub fn QueryPerformanceCounter(lpPerformanceCount: *mut LARGE_INTEGER) -> BOOL;\n@@ -1118,6 +1127,14 @@ extern \"system\" {\n     pub fn TryAcquireSRWLockExclusive(SRWLock: PSRWLOCK) -> BOOLEAN;\n     pub fn TryAcquireSRWLockShared(SRWLock: PSRWLOCK) -> BOOLEAN;\n \n+    pub fn InitOnceBeginInitialize(\n+        lpInitOnce: LPINIT_ONCE,\n+        dwFlags: DWORD,\n+        fPending: LPBOOL,\n+        lpContext: *mut LPVOID,\n+    ) -> BOOL;\n+    pub fn InitOnceComplete(lpInitOnce: LPINIT_ONCE, dwFlags: DWORD, lpContext: LPVOID) -> BOOL;\n+\n     pub fn CompareStringOrdinal(\n         lpString1: LPCWSTR,\n         cchCount1: c_int,"}, {"sha": "17628b7579b8db3ac2a8eaa89e4fc20b1ce81af7", "filename": "library/std/src/sys/windows/thread_local_key.rs", "status": "modified", "additions": 123, "deletions": 73, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/d4578013541a5c6ae34b62a83e8dcb11fb6d4b05/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fthread_local_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4578013541a5c6ae34b62a83e8dcb11fb6d4b05/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fthread_local_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fthread_local_key.rs?ref=d4578013541a5c6ae34b62a83e8dcb11fb6d4b05", "patch": "@@ -1,11 +1,16 @@\n-use crate::mem::ManuallyDrop;\n+use crate::cell::UnsafeCell;\n use crate::ptr;\n-use crate::sync::atomic::AtomicPtr;\n-use crate::sync::atomic::Ordering::SeqCst;\n+use crate::sync::atomic::{\n+    AtomicPtr, AtomicU32,\n+    Ordering::{AcqRel, Acquire, Relaxed, Release},\n+};\n use crate::sys::c;\n \n-pub type Key = c::DWORD;\n-pub type Dtor = unsafe extern \"C\" fn(*mut u8);\n+#[cfg(test)]\n+mod tests;\n+\n+type Key = c::DWORD;\n+type Dtor = unsafe extern \"C\" fn(*mut u8);\n \n // Turns out, like pretty much everything, Windows is pretty close the\n // functionality that Unix provides, but slightly different! In the case of\n@@ -22,60 +27,109 @@ pub type Dtor = unsafe extern \"C\" fn(*mut u8);\n // To accomplish this feat, we perform a number of threads, all contained\n // within this module:\n //\n-// * All TLS destructors are tracked by *us*, not the windows runtime. This\n+// * All TLS destructors are tracked by *us*, not the Windows runtime. This\n //   means that we have a global list of destructors for each TLS key that\n //   we know about.\n // * When a thread exits, we run over the entire list and run dtors for all\n //   non-null keys. This attempts to match Unix semantics in this regard.\n //\n-// This ends up having the overhead of using a global list, having some\n-// locks here and there, and in general just adding some more code bloat. We\n-// attempt to optimize runtime by forgetting keys that don't have\n-// destructors, but this only gets us so far.\n-//\n // For more details and nitty-gritty, see the code sections below!\n //\n // [1]: https://www.codeproject.com/Articles/8113/Thread-Local-Storage-The-C-Way\n-// [2]: https://github.com/ChromiumWebApps/chromium/blob/master/base\n-//                        /threading/thread_local_storage_win.cc#L42\n+// [2]: https://github.com/ChromiumWebApps/chromium/blob/master/base/threading/thread_local_storage_win.cc#L42\n \n-// -------------------------------------------------------------------------\n-// Native bindings\n-//\n-// This section is just raw bindings to the native functions that Windows\n-// provides, There's a few extra calls to deal with destructors.\n+pub struct StaticKey {\n+    /// The key value shifted up by one. Since TLS_OUT_OF_INDEXES == DWORD::MAX\n+    /// is not a valid key value, this allows us to use zero as sentinel value\n+    /// without risking overflow.\n+    key: AtomicU32,\n+    dtor: Option<Dtor>,\n+    next: AtomicPtr<StaticKey>,\n+    /// Currently, destructors cannot be unregistered, so we cannot use racy\n+    /// initialization for keys. Instead, we need synchronize initialization.\n+    /// Use the Windows-provided `Once` since it does not require TLS.\n+    once: UnsafeCell<c::INIT_ONCE>,\n+}\n \n-#[inline]\n-pub unsafe fn create(dtor: Option<Dtor>) -> Key {\n-    let key = c::TlsAlloc();\n-    assert!(key != c::TLS_OUT_OF_INDEXES);\n-    if let Some(f) = dtor {\n-        register_dtor(key, f);\n+impl StaticKey {\n+    #[inline]\n+    pub const fn new(dtor: Option<Dtor>) -> StaticKey {\n+        StaticKey {\n+            key: AtomicU32::new(0),\n+            dtor,\n+            next: AtomicPtr::new(ptr::null_mut()),\n+            once: UnsafeCell::new(c::INIT_ONCE_STATIC_INIT),\n+        }\n     }\n-    key\n-}\n \n-#[inline]\n-pub unsafe fn set(key: Key, value: *mut u8) {\n-    let r = c::TlsSetValue(key, value as c::LPVOID);\n-    debug_assert!(r != 0);\n-}\n+    #[inline]\n+    pub unsafe fn set(&'static self, val: *mut u8) {\n+        let r = c::TlsSetValue(self.key(), val.cast());\n+        debug_assert_eq!(r, c::TRUE);\n+    }\n \n-#[inline]\n-pub unsafe fn get(key: Key) -> *mut u8 {\n-    c::TlsGetValue(key) as *mut u8\n-}\n+    #[inline]\n+    pub unsafe fn get(&'static self) -> *mut u8 {\n+        c::TlsGetValue(self.key()).cast()\n+    }\n \n-#[inline]\n-pub unsafe fn destroy(_key: Key) {\n-    rtabort!(\"can't destroy tls keys on windows\")\n-}\n+    #[inline]\n+    unsafe fn key(&'static self) -> Key {\n+        match self.key.load(Acquire) {\n+            0 => self.init(),\n+            key => key - 1,\n+        }\n+    }\n+\n+    #[cold]\n+    unsafe fn init(&'static self) -> Key {\n+        if self.dtor.is_some() {\n+            let mut pending = c::FALSE;\n+            let r = c::InitOnceBeginInitialize(self.once.get(), 0, &mut pending, ptr::null_mut());\n+            assert_eq!(r, c::TRUE);\n \n-#[inline]\n-pub fn requires_synchronized_create() -> bool {\n-    true\n+            if pending == c::FALSE {\n+                // Some other thread initialized the key, load it.\n+                self.key.load(Relaxed) - 1\n+            } else {\n+                let key = c::TlsAlloc();\n+                if key == c::TLS_OUT_OF_INDEXES {\n+                    // Wakeup the waiting threads before panicking to avoid deadlock.\n+                    c::InitOnceComplete(self.once.get(), c::INIT_ONCE_INIT_FAILED, ptr::null_mut());\n+                    panic!(\"out of TLS indexes\");\n+                }\n+\n+                self.key.store(key + 1, Release);\n+                register_dtor(self);\n+\n+                let r = c::InitOnceComplete(self.once.get(), 0, ptr::null_mut());\n+                debug_assert_eq!(r, c::TRUE);\n+\n+                key\n+            }\n+        } else {\n+            // If there is no destructor to clean up, we can use racy initialization.\n+\n+            let key = c::TlsAlloc();\n+            assert_ne!(key, c::TLS_OUT_OF_INDEXES, \"out of TLS indexes\");\n+\n+            match self.key.compare_exchange(0, key + 1, AcqRel, Acquire) {\n+                Ok(_) => key,\n+                Err(new) => {\n+                    // Some other thread completed initialization first, so destroy\n+                    // our key and use theirs.\n+                    let r = c::TlsFree(key);\n+                    debug_assert_eq!(r, c::TRUE);\n+                    new - 1\n+                }\n+            }\n+        }\n+    }\n }\n \n+unsafe impl Send for StaticKey {}\n+unsafe impl Sync for StaticKey {}\n+\n // -------------------------------------------------------------------------\n // Dtor registration\n //\n@@ -96,29 +150,21 @@ pub fn requires_synchronized_create() -> bool {\n // Typically processes have a statically known set of TLS keys which is pretty\n // small, and we'd want to keep this memory alive for the whole process anyway\n // really.\n-//\n-// Perhaps one day we can fold the `Box` here into a static allocation,\n-// expanding the `StaticKey` structure to contain not only a slot for the TLS\n-// key but also a slot for the destructor queue on windows. An optimization for\n-// another day!\n-\n-static DTORS: AtomicPtr<Node> = AtomicPtr::new(ptr::null_mut());\n-\n-struct Node {\n-    dtor: Dtor,\n-    key: Key,\n-    next: *mut Node,\n-}\n \n-unsafe fn register_dtor(key: Key, dtor: Dtor) {\n-    let mut node = ManuallyDrop::new(Box::new(Node { key, dtor, next: ptr::null_mut() }));\n+static DTORS: AtomicPtr<StaticKey> = AtomicPtr::new(ptr::null_mut());\n \n-    let mut head = DTORS.load(SeqCst);\n+/// Should only be called once per key, otherwise loops or breaks may occur in\n+/// the linked list.\n+unsafe fn register_dtor(key: &'static StaticKey) {\n+    let this = <*const StaticKey>::cast_mut(key);\n+    // Use acquire ordering to pass along the changes done by the previously\n+    // registered keys when we store the new head with release ordering.\n+    let mut head = DTORS.load(Acquire);\n     loop {\n-        node.next = head;\n-        match DTORS.compare_exchange(head, &mut **node, SeqCst, SeqCst) {\n-            Ok(_) => return, // nothing to drop, we successfully added the node to the list\n-            Err(cur) => head = cur,\n+        key.next.store(head, Relaxed);\n+        match DTORS.compare_exchange_weak(head, this, Release, Acquire) {\n+            Ok(_) => break,\n+            Err(new) => head = new,\n         }\n     }\n }\n@@ -214,25 +260,29 @@ unsafe extern \"system\" fn on_tls_callback(h: c::LPVOID, dwReason: c::DWORD, pv:\n     unsafe fn reference_tls_used() {}\n }\n \n-#[allow(dead_code)] // actually called above\n+#[allow(dead_code)] // actually called below\n unsafe fn run_dtors() {\n-    let mut any_run = true;\n     for _ in 0..5 {\n-        if !any_run {\n-            break;\n-        }\n-        any_run = false;\n-        let mut cur = DTORS.load(SeqCst);\n+        let mut any_run = false;\n+\n+        // Use acquire ordering to observe key initialization.\n+        let mut cur = DTORS.load(Acquire);\n         while !cur.is_null() {\n-            let ptr = c::TlsGetValue((*cur).key);\n+            let key = (*cur).key.load(Relaxed) - 1;\n+            let dtor = (*cur).dtor.unwrap();\n \n+            let ptr = c::TlsGetValue(key);\n             if !ptr.is_null() {\n-                c::TlsSetValue((*cur).key, ptr::null_mut());\n-                ((*cur).dtor)(ptr as *mut _);\n+                c::TlsSetValue(key, ptr::null_mut());\n+                dtor(ptr as *mut _);\n                 any_run = true;\n             }\n \n-            cur = (*cur).next;\n+            cur = (*cur).next.load(Relaxed);\n+        }\n+\n+        if !any_run {\n+            break;\n         }\n     }\n }"}, {"sha": "c95f383fb90e3cbc88a0567c779852c289c7a876", "filename": "library/std/src/sys/windows/thread_local_key/tests.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/d4578013541a5c6ae34b62a83e8dcb11fb6d4b05/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fthread_local_key%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4578013541a5c6ae34b62a83e8dcb11fb6d4b05/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fthread_local_key%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fthread_local_key%2Ftests.rs?ref=d4578013541a5c6ae34b62a83e8dcb11fb6d4b05", "patch": "@@ -0,0 +1,53 @@\n+use super::StaticKey;\n+use crate::ptr;\n+\n+#[test]\n+fn smoke() {\n+    static K1: StaticKey = StaticKey::new(None);\n+    static K2: StaticKey = StaticKey::new(None);\n+\n+    unsafe {\n+        assert!(K1.get().is_null());\n+        assert!(K2.get().is_null());\n+        K1.set(ptr::invalid_mut(1));\n+        K2.set(ptr::invalid_mut(2));\n+        assert_eq!(K1.get() as usize, 1);\n+        assert_eq!(K2.get() as usize, 2);\n+    }\n+}\n+\n+#[test]\n+fn destructors() {\n+    use crate::mem::ManuallyDrop;\n+    use crate::sync::Arc;\n+    use crate::thread;\n+\n+    unsafe extern \"C\" fn destruct(ptr: *mut u8) {\n+        drop(Arc::from_raw(ptr as *const ()));\n+    }\n+\n+    static KEY: StaticKey = StaticKey::new(Some(destruct));\n+\n+    let shared1 = Arc::new(());\n+    let shared2 = Arc::clone(&shared1);\n+\n+    unsafe {\n+        assert!(KEY.get().is_null());\n+        KEY.set(Arc::into_raw(shared1) as *mut u8);\n+    }\n+\n+    thread::spawn(move || unsafe {\n+        assert!(KEY.get().is_null());\n+        KEY.set(Arc::into_raw(shared2) as *mut u8);\n+    })\n+    .join()\n+    .unwrap();\n+\n+    // Leak the Arc, let the TLS destructor clean it up.\n+    let shared1 = unsafe { ManuallyDrop::new(Arc::from_raw(KEY.get() as *const ())) };\n+    assert_eq!(\n+        Arc::strong_count(&shared1),\n+        1,\n+        \"destructor should have dropped the other reference on thread exit\"\n+    );\n+}"}, {"sha": "9ea3c52fa6d713580d34053caafbed6d79bf34d1", "filename": "library/std/src/sys_common/mod.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d4578013541a5c6ae34b62a83e8dcb11fb6d4b05/library%2Fstd%2Fsrc%2Fsys_common%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4578013541a5c6ae34b62a83e8dcb11fb6d4b05/library%2Fstd%2Fsrc%2Fsys_common%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fmod.rs?ref=d4578013541a5c6ae34b62a83e8dcb11fb6d4b05", "patch": "@@ -33,10 +33,17 @@ pub mod rwlock;\n pub mod thread;\n pub mod thread_info;\n pub mod thread_local_dtor;\n-pub mod thread_local_key;\n pub mod thread_parker;\n pub mod wtf8;\n \n+cfg_if::cfg_if! {\n+    if #[cfg(target_os = \"windows\")] {\n+        pub use crate::sys::thread_local_key;\n+    } else {\n+        pub mod thread_local_key;\n+    }\n+}\n+\n cfg_if::cfg_if! {\n     if #[cfg(any(target_os = \"l4re\",\n                  target_os = \"hermit\","}, {"sha": "747579f178127c2897268a6df906f49dc7cd2601", "filename": "library/std/src/sys_common/thread_local_key.rs", "status": "modified", "additions": 1, "deletions": 23, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d4578013541a5c6ae34b62a83e8dcb11fb6d4b05/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_local_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4578013541a5c6ae34b62a83e8dcb11fb6d4b05/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_local_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_local_key.rs?ref=d4578013541a5c6ae34b62a83e8dcb11fb6d4b05", "patch": "@@ -53,7 +53,6 @@ mod tests;\n \n use crate::sync::atomic::{self, AtomicUsize, Ordering};\n use crate::sys::thread_local_key as imp;\n-use crate::sys_common::mutex::StaticMutex;\n \n /// A type for TLS keys that are statically allocated.\n ///\n@@ -151,25 +150,6 @@ impl StaticKey {\n     }\n \n     unsafe fn lazy_init(&self) -> usize {\n-        // Currently the Windows implementation of TLS is pretty hairy, and\n-        // it greatly simplifies creation if we just synchronize everything.\n-        //\n-        // Additionally a 0-index of a tls key hasn't been seen on windows, so\n-        // we just simplify the whole branch.\n-        if imp::requires_synchronized_create() {\n-            // We never call `INIT_LOCK.init()`, so it is UB to attempt to\n-            // acquire this mutex reentrantly!\n-            static INIT_LOCK: StaticMutex = StaticMutex::new();\n-            let _guard = INIT_LOCK.lock();\n-            let mut key = self.key.load(Ordering::SeqCst);\n-            if key == 0 {\n-                key = imp::create(self.dtor) as usize;\n-                self.key.store(key, Ordering::SeqCst);\n-            }\n-            rtassert!(key != 0);\n-            return key;\n-        }\n-\n         // POSIX allows the key created here to be 0, but the compare_exchange\n         // below relies on using 0 as a sentinel value to check who won the\n         // race to set the shared TLS key. As far as I know, there is no\n@@ -232,8 +212,6 @@ impl Key {\n \n impl Drop for Key {\n     fn drop(&mut self) {\n-        // Right now Windows doesn't support TLS key destruction, but this also\n-        // isn't used anywhere other than tests, so just leak the TLS key.\n-        // unsafe { imp::destroy(self.key) }\n+        unsafe { imp::destroy(self.key) }\n     }\n }"}]}