{"sha": "a679f41fa3eb6d460ccf4a2914dabaf84c702a87", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE2NzlmNDFmYTNlYjZkNDYwY2NmNGEyOTE0ZGFiYWY4NGM3MDJhODc=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-no-reply-9879165716479413131@oli-obk.de", "date": "2017-04-06T14:49:13Z"}, "committer": {"name": "Oliver Schneider", "email": "git-no-reply-9879165716479413131@oli-obk.de", "date": "2017-04-06T14:49:13Z"}, "message": "Fix fallout", "tree": {"sha": "2ae0178cbcb9af9cab541782ad437ad0576f784d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2ae0178cbcb9af9cab541782ad437ad0576f784d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a679f41fa3eb6d460ccf4a2914dabaf84c702a87", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a679f41fa3eb6d460ccf4a2914dabaf84c702a87", "html_url": "https://github.com/rust-lang/rust/commit/a679f41fa3eb6d460ccf4a2914dabaf84c702a87", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a679f41fa3eb6d460ccf4a2914dabaf84c702a87/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f32fab1c8fe71e654f60f9cf367e58faac5565ea", "url": "https://api.github.com/repos/rust-lang/rust/commits/f32fab1c8fe71e654f60f9cf367e58faac5565ea", "html_url": "https://github.com/rust-lang/rust/commit/f32fab1c8fe71e654f60f9cf367e58faac5565ea"}], "stats": {"total": 39, "additions": 19, "deletions": 20}, "files": [{"sha": "06db5319d214df3ce04871e763b4565426e350a2", "filename": "clippy_lints/src/collapsible_if.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a679f41fa3eb6d460ccf4a2914dabaf84c702a87/clippy_lints%2Fsrc%2Fcollapsible_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a679f41fa3eb6d460ccf4a2914dabaf84c702a87/clippy_lints%2Fsrc%2Fcollapsible_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcollapsible_if.rs?ref=a679f41fa3eb6d460ccf4a2914dabaf84c702a87", "patch": "@@ -103,7 +103,7 @@ fn check_if(cx: &EarlyContext, expr: &ast::Expr) {\n fn check_collapsible_maybe_if_let(cx: &EarlyContext, else_: &ast::Expr) {\n     if_let_chain! {[\n         let ast::ExprKind::Block(ref block) = else_.node,\n-        let Some(ref else_) = expr_block(block),\n+        let Some(else_) = expr_block(block),\n         !in_macro(else_.span),\n     ], {\n         match else_.node {"}, {"sha": "ea7bbfe81e02b4c6ebc83fb24dca5bba2c75389c", "filename": "clippy_lints/src/copies.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a679f41fa3eb6d460ccf4a2914dabaf84c702a87/clippy_lints%2Fsrc%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a679f41fa3eb6d460ccf4a2914dabaf84c702a87/clippy_lints%2Fsrc%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcopies.rs?ref=a679f41fa3eb6d460ccf4a2914dabaf84c702a87", "patch": "@@ -228,7 +228,7 @@ fn if_sequence(mut expr: &Expr) -> (SmallVector<&Expr>, SmallVector<&Block>) {\n     while let ExprIf(ref cond, ref then_expr, ref else_expr) = expr.node {\n         conds.push(&**cond);\n         if let ExprBlock(ref block) = then_expr.node {\n-            blocks.push(&block);\n+            blocks.push(block);\n         } else {\n             panic!(\"ExprIf node is not an ExprBlock\");\n         }"}, {"sha": "d7760a30622df839dbbe26cdaab90c80d089ae76", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a679f41fa3eb6d460ccf4a2914dabaf84c702a87/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a679f41fa3eb6d460ccf4a2914dabaf84c702a87/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=a679f41fa3eb6d460ccf4a2914dabaf84c702a87", "patch": "@@ -894,7 +894,7 @@ impl<'a, 'tcx> Visitor<'tcx> for VarVisitor<'a, 'tcx> {\n                         match def {\n                             Def::Local(..) | Def::Upvar(..) => {\n                                 let def_id = def.def_id();\n-                                let node_id = self.cx.tcx.hir.as_local_node_id(def_id).unwrap();\n+                                let node_id = self.cx.tcx.hir.as_local_node_id(def_id).expect(\"local/upvar are local nodes\");\n \n                                 let extent = self.cx.tcx.region_maps.var_scope(node_id);\n                                 self.indexed.insert(seqvar.segments[0].name, Some(extent));"}, {"sha": "84897da7412271d7756fd44b7a328093241ad719", "filename": "clippy_lints/src/methods.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a679f41fa3eb6d460ccf4a2914dabaf84c702a87/clippy_lints%2Fsrc%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a679f41fa3eb6d460ccf4a2914dabaf84c702a87/clippy_lints%2Fsrc%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods.rs?ref=a679f41fa3eb6d460ccf4a2914dabaf84c702a87", "patch": "@@ -649,7 +649,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                 if name == method_name &&\n                    sig.decl.inputs.len() == n_args &&\n                    out_type.matches(&sig.decl.output) &&\n-                   self_kind.matches(&first_arg_ty, &first_arg, &self_ty, false) {\n+                   self_kind.matches(first_arg_ty, first_arg, self_ty, false) {\n                     span_lint(cx, SHOULD_IMPLEMENT_TRAIT, implitem.span, &format!(\n                         \"defining a method called `{}` on this type; consider implementing \\\n                          the `{}` trait or choosing a less ambiguous name\", name, trait_name));\n@@ -662,7 +662,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             for &(ref conv, self_kinds) in &CONVENTIONS {\n                 if_let_chain! {[\n                     conv.check(&name.as_str()),\n-                    !self_kinds.iter().any(|k| k.matches(&first_arg_ty, &first_arg, &self_ty, is_copy)),\n+                    !self_kinds.iter().any(|k| k.matches(first_arg_ty, first_arg, self_ty, is_copy)),\n                 ], {\n                     let lint = if item.vis == hir::Visibility::Public {\n                         WRONG_PUB_SELF_CONVENTION"}, {"sha": "e84fd196874c50d623ead3482b836aadb22c133d", "filename": "clippy_lints/src/misc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a679f41fa3eb6d460ccf4a2914dabaf84c702a87/clippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a679f41fa3eb6d460ccf4a2914dabaf84c702a87/clippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc.rs?ref=a679f41fa3eb6d460ccf4a2914dabaf84c702a87", "patch": "@@ -499,9 +499,9 @@ fn is_used(cx: &LateContext, expr: &Expr) -> bool {\n /// Test whether an expression is in a macro expansion (e.g. something generated by\n /// `#[derive(...)`] or the like).\n fn in_attributes_expansion(expr: &Expr) -> bool {\n-    expr.span.ctxt.outer().expn_info().map(|info| {\n+    expr.span.ctxt.outer().expn_info().map_or(false, |info| {\n         matches!(info.callee.format, ExpnFormat::MacroAttribute(_))\n-    }).unwrap_or(false)\n+    })\n }\n \n /// Test whether `def` is a variable defined outside a macro."}, {"sha": "5fee08a0c498ddf4cfd6fdee981d87edfee509ab", "filename": "clippy_lints/src/partialeq_ne_impl.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a679f41fa3eb6d460ccf4a2914dabaf84c702a87/clippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a679f41fa3eb6d460ccf4a2914dabaf84c702a87/clippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs?ref=a679f41fa3eb6d460ccf4a2914dabaf84c702a87", "patch": "@@ -40,7 +40,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         if_let_chain! {[\n             let ItemImpl(_, _, _, Some(ref trait_ref), _, ref impl_items) = item.node,\n             !is_automatically_derived(&*item.attrs),\n-            trait_ref.path.def.def_id() == cx.tcx.lang_items.eq_trait().unwrap(),\n+            let Some(eq_trait) = cx.tcx.lang_items.eq_trait(),\n+            trait_ref.path.def.def_id() == eq_trait\n         ], {\n             for impl_item in impl_items {\n                 if impl_item.name == \"ne\" {"}, {"sha": "5b7cb9aa86fa11d28521757e5ec8478accbee007", "filename": "clippy_lints/src/ranges.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a679f41fa3eb6d460ccf4a2914dabaf84c702a87/clippy_lints%2Fsrc%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a679f41fa3eb6d460ccf4a2914dabaf84c702a87/clippy_lints%2Fsrc%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Franges.rs?ref=a679f41fa3eb6d460ccf4a2914dabaf84c702a87", "patch": "@@ -66,7 +66,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for StepByZero {\n                     let ExprMethodCall( Spanned { node: iter_name, .. }, _, ref iter_args ) = *iter,\n                     iter_name == \"iter\",\n                     // range expression in .zip() call: 0..x.len()\n-                    let Some(higher::Range { start: Some(ref start), end: Some(ref end), .. }) = higher::range(zip_arg),\n+                    let Some(higher::Range { start: Some(start), end: Some(end), .. }) = higher::range(zip_arg),\n                     is_integer_literal(start, 0),\n                     // .len() call\n                     let ExprMethodCall(Spanned { node: len_name, .. }, _, ref len_args) = end.node,"}, {"sha": "16f582c77c97fe7a880b546e327868513d067630", "filename": "clippy_lints/src/returns.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a679f41fa3eb6d460ccf4a2914dabaf84c702a87/clippy_lints%2Fsrc%2Freturns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a679f41fa3eb6d460ccf4a2914dabaf84c702a87/clippy_lints%2Fsrc%2Freturns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Freturns.rs?ref=a679f41fa3eb6d460ccf4a2914dabaf84c702a87", "patch": "@@ -107,7 +107,7 @@ impl ReturnPass {\n \n         // we need both a let-binding stmt and an expr\n         if_let_chain! {[\n-            let Some(ref retexpr) = it.next_back(),\n+            let Some(retexpr) = it.next_back(),\n             let ast::StmtKind::Expr(ref retexpr) = retexpr.node,\n             let Some(stmt) = it.next_back(),\n             let ast::StmtKind::Local(ref local) = stmt.node,"}, {"sha": "b2c56fe8bf31614914f9035374227a3d081b0e2d", "filename": "clippy_lints/src/swap.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a679f41fa3eb6d460ccf4a2914dabaf84c702a87/clippy_lints%2Fsrc%2Fswap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a679f41fa3eb6d460ccf4a2914dabaf84c702a87/clippy_lints%2Fsrc%2Fswap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fswap.rs?ref=a679f41fa3eb6d460ccf4a2914dabaf84c702a87", "patch": "@@ -115,13 +115,11 @@ fn check_manual_swap(cx: &LateContext, block: &Block) {\n                 } else {\n                     (false, \"\".to_owned(), \"\".to_owned())\n                 }\n+            } else if let (Some(first), Some(second)) = (Sugg::hir_opt(cx, lhs1), Sugg::hir_opt(cx, rhs1)) {\n+                (true, format!(\" `{}` and `{}`\", first, second),\n+                    format!(\"std::mem::swap({}, {})\", first.mut_addr(), second.mut_addr()))\n             } else {\n-                 if let (Some(first), Some(second)) = (Sugg::hir_opt(cx, lhs1), Sugg::hir_opt(cx, rhs1)) {\n-                    (true, format!(\" `{}` and `{}`\", first, second),\n-                     format!(\"std::mem::swap({}, {})\", first.mut_addr(), second.mut_addr()))\n-                } else {\n-                    (true, \"\".to_owned(), \"\".to_owned())\n-                }\n+                (true, \"\".to_owned(), \"\".to_owned())\n             };\n \n             let span = Span { lo: w[0].span.lo, hi: second.span.hi, ctxt: NO_EXPANSION};"}, {"sha": "005c508f123e5595d7388547bf6eca4991e0224f", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a679f41fa3eb6d460ccf4a2914dabaf84c702a87/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a679f41fa3eb6d460ccf4a2914dabaf84c702a87/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=a679f41fa3eb6d460ccf4a2914dabaf84c702a87", "patch": "@@ -118,7 +118,7 @@ fn check_ty(cx: &LateContext, ast_ty: &Ty) {\n                     let last = last_path_segment(qpath);\n                     if_let_chain! {[\n                         let PathParameters::AngleBracketedParameters(ref ag) = last.parameters,\n-                        let Some(ref vec) = ag.types.get(0),\n+                        let Some(vec) = ag.types.get(0),\n                         let TyPath(ref qpath) = vec.node,\n                         let def::Def::Struct(..) = cx.tables.qpath_def(qpath, vec.id),\n                         let Some(did) = opt_def_id(cx.tables.qpath_def(qpath, vec.id)),"}, {"sha": "db595b079699396eb744c039aa8f9e42f4d590be", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a679f41fa3eb6d460ccf4a2914dabaf84c702a87/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a679f41fa3eb6d460ccf4a2914dabaf84c702a87/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=a679f41fa3eb6d460ccf4a2914dabaf84c702a87", "patch": "@@ -112,12 +112,12 @@ pub fn in_constant(cx: &LateContext, id: NodeId) -> bool {\n \n /// Returns true if this `expn_info` was expanded by any macro.\n pub fn in_macro(span: Span) -> bool {\n-    span.ctxt.outer().expn_info().map(|info| {\n+    span.ctxt.outer().expn_info().map_or(false, |info| {\n         match info.callee.format {// don't treat range expressions desugared to structs as \"in_macro\"\n             ExpnFormat::CompilerDesugaring(name) => name != \"...\",\n             _ => true,\n         }\n-    }).unwrap_or(false)\n+    })\n }\n \n /// Returns true if the macro that expanded the crate was outside of the current crate or was a\n@@ -138,7 +138,7 @@ pub fn in_external_macro<'a, T: LintContext<'a>>(cx: &T, span: Span) -> bool {\n         })\n     }\n \n-    span.ctxt.outer().expn_info().map(|info| in_macro_ext(cx, &info)).unwrap_or(false)\n+    span.ctxt.outer().expn_info().map_or(false, |info| in_macro_ext(cx, &info))\n }\n \n /// Check if a `DefId`'s path matches the given absolute type path usage."}]}