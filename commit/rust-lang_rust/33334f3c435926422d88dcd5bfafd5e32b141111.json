{"sha": "33334f3c435926422d88dcd5bfafd5e32b141111", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMzMzM0ZjNjNDM1OTI2NDIyZDg4ZGNkNWJmYWZkNWUzMmIxNDExMTE=", "commit": {"author": {"name": "Lindsey Kuper", "email": "lindsey@rockstargirl.org", "date": "2012-07-03T23:30:42Z"}, "committer": {"name": "Lindsey Kuper", "email": "lindsey@rockstargirl.org", "date": "2012-07-05T18:01:43Z"}, "message": "Change 'iface' to 'trait' internally; parse `trait` as `iface` synonym", "tree": {"sha": "7ab702e7bd5565be7419e853e312c8a277b69528", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7ab702e7bd5565be7419e853e312c8a277b69528"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/33334f3c435926422d88dcd5bfafd5e32b141111", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/33334f3c435926422d88dcd5bfafd5e32b141111", "html_url": "https://github.com/rust-lang/rust/commit/33334f3c435926422d88dcd5bfafd5e32b141111", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/33334f3c435926422d88dcd5bfafd5e32b141111/comments", "author": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d93f3c5d835f12614f07c2d840799dd02f4780bc", "url": "https://api.github.com/repos/rust-lang/rust/commits/d93f3c5d835f12614f07c2d840799dd02f4780bc", "html_url": "https://github.com/rust-lang/rust/commit/d93f3c5d835f12614f07c2d840799dd02f4780bc"}], "stats": {"total": 904, "additions": 453, "deletions": 451}, "files": [{"sha": "676c713f8e5245f1926ce7b27eb59ab091d323cd", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/33334f3c435926422d88dcd5bfafd5e32b141111/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33334f3c435926422d88dcd5bfafd5e32b141111/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=33334f3c435926422d88dcd5bfafd5e32b141111", "patch": "@@ -62,7 +62,7 @@ enum ty_param_bound {\n     bound_copy,\n     bound_send,\n     bound_const,\n-    bound_iface(@ty),\n+    bound_trait(@ty),\n }\n \n #[auto_serialize]\n@@ -657,11 +657,11 @@ enum attr_style { attr_outer, attr_inner, }\n type attribute_ = {style: attr_style, value: meta_item, is_sugared_doc: bool};\n \n /*\n-  iface_refs appear in both impls and in classes that implement ifaces.\n-  resolve maps each iface_ref's id to its defining iface.\n+  trait_refs appear in both impls and in classes that implement traits.\n+  resolve maps each trait_ref's id to its defining trait.\n  */\n #[auto_serialize]\n-type iface_ref = {path: @path, id: node_id};\n+type trait_ref = {path: @path, id: node_id};\n \n #[auto_serialize]\n enum visibility { public, private }\n@@ -686,16 +686,16 @@ enum item_ {\n     item_ty(@ty, ~[ty_param], region_param),\n     item_enum(~[variant], ~[ty_param], region_param),\n     item_class(~[ty_param], /* ty params for class */\n-               ~[@iface_ref],   /* ifaces this class implements */\n+               ~[@trait_ref],   /* traits this class implements */\n                ~[@class_member], /* methods, etc. */\n                                /* (not including ctor or dtor) */\n                class_ctor,\n                /* dtor is optional */\n                option<class_dtor>,\n                region_param\n                ),\n-    item_iface(~[ty_param], region_param, ~[ty_method]),\n-    item_impl(~[ty_param], region_param, option<@iface_ref> /* iface */,\n+    item_trait(~[ty_param], region_param, ~[ty_method]),\n+    item_impl(~[ty_param], region_param, option<@trait_ref> /* trait */,\n               @ty /* self */, ~[@method]),\n }\n "}, {"sha": "79d6691caf1ecae0a47bb7ae7ed4b48cda382c72", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/33334f3c435926422d88dcd5bfafd5e32b141111/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33334f3c435926422d88dcd5bfafd5e32b141111/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=33334f3c435926422d88dcd5bfafd5e32b141111", "patch": "@@ -214,11 +214,11 @@ fn map_item(i: @item, cx: ctx, v: vt) {\n                                            extend(cx, i.ident)));\n         }\n       }\n-      item_class(tps, ifces, items, ctor, dtor, _) {\n+      item_class(tps, traits, items, ctor, dtor, _) {\n           let (_, ms) = ast_util::split_class_items(items);\n-          // Map iface refs to their parent classes. This is\n+          // Map trait refs to their parent classes. This is\n           // so we can find the self_ty\n-          do vec::iter(ifces) |p| { cx.map.insert(p.id,\n+          do vec::iter(traits) |p| { cx.map.insert(p.id,\n                                   node_item(i, item_path)); };\n           let d_id = ast_util::local_def(i.id);\n           let p = extend(cx, i.ident);"}, {"sha": "a1e6aa06d59b2d314cb6285dfa56a4b1ab75b310", "filename": "src/libsyntax/ext/auto_serialize.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/33334f3c435926422d88dcd5bfafd5e32b141111/src%2Flibsyntax%2Fext%2Fauto_serialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33334f3c435926422d88dcd5bfafd5e32b141111/src%2Flibsyntax%2Fext%2Fauto_serialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_serialize.rs?ref=33334f3c435926422d88dcd5bfafd5e32b141111", "patch": "@@ -530,7 +530,7 @@ fn mk_ser_fn(cx: ext_ctxt, span: span, name: ast::ident,\n     }\n \n     let ser_bnds = @~[\n-        ast::bound_iface(cx.ty_path(span,\n+        ast::bound_trait(cx.ty_path(span,\n                                     ~[@\"std\", @\"serialization\",\n                                      @\"serializer\"],\n                                     ~[]))];\n@@ -736,7 +736,7 @@ fn mk_deser_fn(cx: ext_ctxt, span: span,\n     }\n \n     let deser_bnds = @~[\n-        ast::bound_iface(cx.ty_path(\n+        ast::bound_trait(cx.ty_path(\n             span,\n             ~[@\"std\", @\"serialization\", @\"deserializer\"],\n             ~[]))];"}, {"sha": "ad55c85496b3a6f6423272211df909ac15dfb2e6", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/33334f3c435926422d88dcd5bfafd5e32b141111/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33334f3c435926422d88dcd5bfafd5e32b141111/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=33334f3c435926422d88dcd5bfafd5e32b141111", "patch": "@@ -142,7 +142,7 @@ fn fold_fn_decl(decl: ast::fn_decl, fld: ast_fold) -> ast::fn_decl {\n fn fold_ty_param_bound(tpb: ty_param_bound, fld: ast_fold) -> ty_param_bound {\n     alt tpb {\n       bound_copy | bound_send | bound_const { tpb }\n-      bound_iface(ty) { bound_iface(fld.fold_ty(ty)) }\n+      bound_trait(ty) { bound_trait(fld.fold_ty(ty)) }\n     }\n }\n \n@@ -252,7 +252,7 @@ fn noop_fold_item_underscore(i: item_, fld: ast_fold) -> item_ {\n                       fold_ty_params(typms, fld),\n                       r)\n           }\n-          item_class(typms, ifaces, items, ctor, m_dtor, rp) {\n+          item_class(typms, traits, items, ctor, m_dtor, rp) {\n               let ctor_body = fld.fold_block(ctor.node.body);\n               let ctor_decl = fold_fn_decl(ctor.node.dec, fld);\n               let ctor_id   = fld.new_id(ctor.node.id);\n@@ -264,7 +264,7 @@ fn noop_fold_item_underscore(i: item_, fld: ast_fold) -> item_ {\n                     with dtor}};\n               item_class(\n                   /* FIXME (#2543) */ copy typms,\n-                  vec::map(ifaces, |p| fold_iface_ref(p, fld)),\n+                  vec::map(traits, |p| fold_trait_ref(p, fld)),\n                   vec::map(items, fld.fold_class_item),\n                   {node: {body: ctor_body,\n                           dec: ctor_decl,\n@@ -274,19 +274,19 @@ fn noop_fold_item_underscore(i: item_, fld: ast_fold) -> item_ {\n           item_impl(tps, rp, ifce, ty, methods) {\n               item_impl(fold_ty_params(tps, fld),\n                         rp,\n-                        ifce.map(|p| fold_iface_ref(p, fld)),\n+                        ifce.map(|p| fold_trait_ref(p, fld)),\n                         fld.fold_ty(ty),\n                         vec::map(methods, fld.fold_method))\n           }\n-          item_iface(tps, rp, methods) {\n-            item_iface(fold_ty_params(tps, fld),\n+          item_trait(tps, rp, methods) {\n+            item_trait(fold_ty_params(tps, fld),\n                        rp,\n                        /* FIXME (#2543) */ copy methods)\n           }\n         };\n }\n \n-fn fold_iface_ref(&&p: @iface_ref, fld: ast_fold) -> @iface_ref {\n+fn fold_trait_ref(&&p: @trait_ref, fld: ast_fold) -> @trait_ref {\n     @{path: fld.fold_path(p.path), id: fld.new_id(p.id)}\n }\n "}, {"sha": "bec5835413784b6da6e02d8d799a32b437e01402", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/33334f3c435926422d88dcd5bfafd5e32b141111/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33334f3c435926422d88dcd5bfafd5e32b141111/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=33334f3c435926422d88dcd5bfafd5e32b141111", "patch": "@@ -1892,7 +1892,7 @@ class parser {\n                 else if self.eat_keyword(\"const\") {\n                     push(bounds, bound_const)\n                 }\n-                else { push(bounds, bound_iface(self.parse_ty(false))); }\n+                else { push(bounds, bound_trait(self.parse_ty(false))); }\n             }\n         }\n         ret {ident: ident, id: self.get_id(), bounds: @bounds};\n@@ -2008,12 +2008,12 @@ class parser {\n           self_id: self.get_id(), vis: pr}\n     }\n \n-    fn parse_item_iface() -> item_info {\n+    fn parse_item_trait() -> item_info {\n         let ident = self.parse_ident();\n         let rp = self.parse_region_param();\n         let tps = self.parse_ty_params();\n         let meths = self.parse_ty_methods();\n-        (ident, item_iface(tps, rp, meths), none)\n+        (ident, item_trait(tps, rp, meths), none)\n     }\n \n     // Parses three variants (with the region/type params always optional):\n@@ -2082,24 +2082,24 @@ class parser {\n          }\n     }\n \n-    fn parse_iface_ref() -> @iface_ref {\n+    fn parse_trait_ref() -> @trait_ref {\n         @{path: self.parse_path_with_tps(false),\n           id: self.get_id()}\n     }\n \n-    fn parse_iface_ref_list() -> ~[@iface_ref] {\n+    fn parse_trait_ref_list() -> ~[@trait_ref] {\n         self.parse_seq_to_before_end(\n             token::LBRACE, seq_sep_trailing_disallowed(token::COMMA),\n-            |p| p.parse_iface_ref())\n+            |p| p.parse_trait_ref())\n     }\n \n     fn parse_item_class() -> item_info {\n         let class_name = self.parse_value_ident();\n         let rp = self.parse_region_param();\n         let ty_params = self.parse_ty_params();\n         let class_path = self.ident_to_path_tys(class_name, rp, ty_params);\n-        let ifaces : ~[@iface_ref] = if self.eat(token::COLON)\n-            { self.parse_iface_ref_list() }\n+        let traits : ~[@trait_ref] = if self.eat(token::COLON)\n+            { self.parse_trait_ref_list() }\n         else { ~[] };\n         self.expect(token::LBRACE);\n         let mut ms: ~[@class_member] = ~[];\n@@ -2127,7 +2127,7 @@ class parser {\n         alt the_ctor {\n           some((ct_d, ct_b, ct_s)) {\n             (class_name,\n-             item_class(ty_params, ifaces, ms, {\n+             item_class(ty_params, traits, ms, {\n                  node: {id: ctor_id,\n                         self_id: self.get_id(),\n                         dec: ct_d,\n@@ -2462,7 +2462,9 @@ class parser {\n         } else if self.eat_keyword(\"enum\") {\n             self.parse_item_enum(vis)\n         } else if self.eat_keyword(\"iface\") {\n-            self.parse_item_iface()\n+            self.parse_item_trait()\n+        } else if self.eat_keyword(\"trait\") {\n+            self.parse_item_trait()\n         } else if self.eat_keyword(\"impl\") {\n             self.parse_item_impl()\n         } else if self.eat_keyword(\"class\") {"}, {"sha": "8e85de17613c473b8634da51eb5a333c02a7a641", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/33334f3c435926422d88dcd5bfafd5e32b141111/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33334f3c435926422d88dcd5bfafd5e32b141111/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=33334f3c435926422d88dcd5bfafd5e32b141111", "patch": "@@ -494,14 +494,14 @@ fn print_item(s: ps, &&item: @ast::item) {\n             bclose(s, item.span);\n         }\n       }\n-      ast::item_class(tps, ifaces, items, ctor, m_dtor, rp) {\n+      ast::item_class(tps, traits, items, ctor, m_dtor, rp) {\n           head(s, \"class\");\n           word_nbsp(s, *item.ident);\n           print_region_param(s, rp);\n           print_type_params(s, tps);\n-          if vec::len(ifaces) != 0u {\n+          if vec::len(traits) != 0u {\n               word_space(s, \":\");\n-              commasep(s, inconsistent, ifaces, |s, p|\n+              commasep(s, inconsistent, traits, |s, p|\n                   print_path(s, p.path, false));\n           }\n           bopen(s);\n@@ -579,7 +579,7 @@ fn print_item(s: ps, &&item: @ast::item) {\n         }\n         bclose(s, item.span);\n       }\n-      ast::item_iface(tps, rp, methods) {\n+      ast::item_trait(tps, rp, methods) {\n         head(s, \"iface\");\n         word(s.s, *item.ident);\n         print_region_param(s, rp);\n@@ -1350,7 +1350,7 @@ fn print_bounds(s: ps, bounds: @~[ast::ty_param_bound]) {\n               ast::bound_copy { word(s.s, \"copy\"); }\n               ast::bound_send { word(s.s, \"send\"); }\n               ast::bound_const { word(s.s, \"const\"); }\n-              ast::bound_iface(t) { print_type(s, t); }\n+              ast::bound_trait(t) { print_type(s, t); }\n             }\n         }\n     }"}, {"sha": "25c61535fcf8b566a6de27e0df2e45b4376808bb", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/33334f3c435926422d88dcd5bfafd5e32b141111/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33334f3c435926422d88dcd5bfafd5e32b141111/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=33334f3c435926422d88dcd5bfafd5e32b141111", "patch": "@@ -143,19 +143,19 @@ fn visit_item<E>(i: @item, e: E, v: vt<E>) {\n             visit_method_helper(m, e, v)\n         }\n       }\n-      item_class(tps, ifaces, members, ctor, m_dtor, _) {\n+      item_class(tps, traits, members, ctor, m_dtor, _) {\n           v.visit_ty_params(tps, e, v);\n           for members.each |m| {\n              v.visit_class_item(m, e, v);\n           }\n-          for ifaces.each |p| { visit_path(p.path, e, v); }\n+          for traits.each |p| { visit_path(p.path, e, v); }\n           visit_class_ctor_helper(ctor, i.ident, tps,\n                                   ast_util::local_def(i.id), e, v);\n           do option::iter(m_dtor) |dtor| {\n                   visit_class_dtor_helper(dtor, tps,\n                      ast_util::local_def(i.id), e, v)};\n       }\n-      item_iface(tps, _rp, methods) {\n+      item_trait(tps, _rp, methods) {\n         v.visit_ty_params(tps, e, v);\n         for methods.each |m| {\n             for m.decl.inputs.each |a| { v.visit_ty(a.ty, e, v); }\n@@ -260,7 +260,7 @@ fn visit_ty_params<E>(tps: ~[ty_param], e: E, v: vt<E>) {\n     for tps.each |tp| {\n         for vec::each(*tp.bounds) |bound| {\n             alt bound {\n-              bound_iface(t) { v.visit_ty(t, e, v); }\n+              bound_trait(t) { v.visit_ty(t, e, v); }\n               bound_copy | bound_send | bound_const { }\n             }\n         }"}, {"sha": "214d0aa0beededa790b76cb841688be726ba3ae0", "filename": "src/rustc/front/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/33334f3c435926422d88dcd5bfafd5e32b141111/src%2Frustc%2Ffront%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33334f3c435926422d88dcd5bfafd5e32b141111/src%2Frustc%2Ffront%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Ffront%2Fintrinsic.rs?ref=33334f3c435926422d88dcd5bfafd5e32b141111", "patch": "@@ -106,7 +106,7 @@ mod intrinsic {\n         fn visit_leave_fn(purity: uint, proto: uint,\n                           n_inputs: uint, retstyle: uint) -> bool;\n \n-        fn visit_iface() -> bool;\n+        fn visit_trait() -> bool;\n         fn visit_enter_res() -> bool;\n         fn visit_leave_res() -> bool;\n         fn visit_var() -> bool;"}, {"sha": "8d2bfad04c9a506afaaf921a275616d823c48407", "filename": "src/rustc/metadata/astencode.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/33334f3c435926422d88dcd5bfafd5e32b141111/src%2Frustc%2Fmetadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33334f3c435926422d88dcd5bfafd5e32b141111/src%2Frustc%2Fmetadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fastencode.rs?ref=33334f3c435926422d88dcd5bfafd5e32b141111", "patch": "@@ -380,8 +380,8 @@ impl of tr for method_origin {\n           typeck::method_param(did, m, p, b) {\n             typeck::method_param(did.tr(xcx), m, p, b)\n           }\n-          typeck::method_iface(did, m) {\n-            typeck::method_iface(did.tr(xcx), m)\n+          typeck::method_trait(did, m) {\n+            typeck::method_trait(did.tr(xcx), m)\n           }\n         }\n     }\n@@ -441,8 +441,8 @@ fn encode_vtable_origin(ecx: @e::encode_ctxt,\n                 }\n             }\n           }\n-          typeck::vtable_iface(def_id, tys) {\n-            ebml_w.emit_enum_variant(\"vtable_iface\", 1u, 3u) {||\n+          typeck::vtable_trait(def_id, tys) {\n+            ebml_w.emit_enum_variant(\"vtable_trait\", 1u, 3u) {||\n                 ebml_w.emit_enum_variant_arg(0u) {||\n                     ebml_w.emit_def_id(def_id)\n                 }\n@@ -490,7 +490,7 @@ impl helpers for ebml::ebml_deserializer {\n                     )\n                   }\n                   2u {\n-                    typeck::vtable_iface(\n+                    typeck::vtable_trait(\n                         self.read_enum_variant_arg(0u) {||\n                             self.read_def_id(xcx)\n                         },"}, {"sha": "f8280494138f43a9d4bf70e5fc8fbdecd1293012", "filename": "src/rustc/metadata/common.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/33334f3c435926422d88dcd5bfafd5e32b141111/src%2Frustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33334f3c435926422d88dcd5bfafd5e32b141111/src%2Frustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcommon.rs?ref=33334f3c435926422d88dcd5bfafd5e32b141111", "patch": "@@ -70,8 +70,8 @@ const tag_crate_dep_vers: uint = 0x2cu;\n \n const tag_mod_impl: uint = 0x30u;\n \n-const tag_item_iface_method: uint = 0x31u;\n-const tag_impl_iface: uint = 0x32u;\n+const tag_item_trait_method: uint = 0x31u;\n+const tag_impl_trait: uint = 0x32u;\n \n // discriminator value for variants\n const tag_disr_val: uint = 0x34u;\n@@ -85,13 +85,13 @@ const tag_item_field: uint = 0x44u;\n const tag_class_mut: uint = 0x45u;\n \n const tag_region_param: uint = 0x46u;\n-const tag_mod_impl_iface: uint = 0x47u;\n+const tag_mod_impl_trait: uint = 0x47u;\n /*\n-  iface items contain tag_item_iface_method elements,\n+  trait items contain tag_item_trait_method elements,\n   impl items contain tag_item_impl_method elements, and classes\n-  have both. That's because some code treats classes like ifaces,\n+  have both. That's because some code treats classes like traits,\n   and other code treats them like impls. Because classes can contain\n-  both, tag_item_iface_method and tag_item_impl_method have to be two\n+  both, tag_item_trait_method and tag_item_impl_method have to be two\n   different tags.\n  */\n const tag_item_impl_method: uint = 0x48u;"}, {"sha": "03b3fdcba86fb43187b44eadb8b1e234d2309b03", "filename": "src/rustc/metadata/csearch.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/33334f3c435926422d88dcd5bfafd5e32b141111/src%2Frustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33334f3c435926422d88dcd5bfafd5e32b141111/src%2Frustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcsearch.rs?ref=33334f3c435926422d88dcd5bfafd5e32b141111", "patch": "@@ -21,10 +21,10 @@ export lookup_defs;\n export lookup_method_purity;\n export get_enum_variants;\n export get_impls_for_mod;\n-export get_iface_methods;\n+export get_trait_methods;\n export each_path;\n export get_type;\n-export get_impl_iface;\n+export get_impl_trait;\n export get_impl_method;\n export get_item_path;\n export maybe_get_item_ast, found_ast, found, found_parent, not_found;\n@@ -133,10 +133,10 @@ fn get_impls_for_mod(cstore: cstore::cstore, def: ast::def_id,\n     }\n }\n \n-fn get_iface_methods(tcx: ty::ctxt, def: ast::def_id) -> @~[ty::method] {\n+fn get_trait_methods(tcx: ty::ctxt, def: ast::def_id) -> @~[ty::method] {\n     let cstore = tcx.cstore;\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n-    decoder::get_iface_methods(cdata, def.node, tcx)\n+    decoder::get_trait_methods(cdata, def.node, tcx)\n }\n \n fn get_class_fields(tcx: ty::ctxt, def: ast::def_id) -> ~[ty::field_ty] {\n@@ -171,12 +171,12 @@ fn get_field_type(tcx: ty::ctxt, class_id: ast::def_id,\n     ret {bounds: @~[], rp: ast::rp_none, ty: ty};\n }\n \n-// Given a def_id for an impl or class, return the iface it implements,\n-// or none if it's not for an impl or for a class that implements ifaces\n-fn get_impl_iface(tcx: ty::ctxt, def: ast::def_id) -> option<ty::t> {\n+// Given a def_id for an impl or class, return the trait it implements,\n+// or none if it's not for an impl or for a class that implements traits\n+fn get_impl_trait(tcx: ty::ctxt, def: ast::def_id) -> option<ty::t> {\n     let cstore = tcx.cstore;\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n-    decoder::get_impl_iface(cdata, def.node, tcx)\n+    decoder::get_impl_trait(cdata, def.node, tcx)\n }\n \n fn get_impl_method(cstore: cstore::cstore,\n@@ -186,8 +186,8 @@ fn get_impl_method(cstore: cstore::cstore,\n     decoder::get_impl_method(cdata, def.node, mname)\n }\n \n-/* Because classes use the iface format rather than the impl format\n-   for their methods (so that get_iface_methods can be reused to get\n+/* Because classes use the trait format rather than the impl format\n+   for their methods (so that get_trait_methods can be reused to get\n    class methods), classes require a slightly different version of\n    get_impl_method. Sigh. */\n fn get_class_method(cstore: cstore::cstore,"}, {"sha": "3380540786010daab517dab4611595d6d381f675", "filename": "src/rustc/metadata/decoder.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/33334f3c435926422d88dcd5bfafd5e32b141111/src%2Frustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33334f3c435926422d88dcd5bfafd5e32b141111/src%2Frustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fdecoder.rs?ref=33334f3c435926422d88dcd5bfafd5e32b141111", "patch": "@@ -22,7 +22,7 @@ export get_symbol;\n export get_enum_variants;\n export get_type;\n export get_type_param_count;\n-export get_impl_iface;\n+export get_impl_trait;\n export get_class_method;\n export get_impl_method;\n export lookup_def;\n@@ -35,7 +35,7 @@ export get_crate_deps;\n export get_crate_hash;\n export get_crate_vers;\n export get_impls_for_mod;\n-export get_iface_methods;\n+export get_trait_methods;\n export get_crate_module_paths;\n export def_like;\n export dl_def;\n@@ -164,10 +164,10 @@ fn item_type(item_id: ast::def_id, item: ebml::doc,\n     } else { t }\n }\n \n-fn item_impl_iface(item: ebml::doc, tcx: ty::ctxt, cdata: cmd)\n+fn item_impl_trait(item: ebml::doc, tcx: ty::ctxt, cdata: cmd)\n     -> option<ty::t> {\n     let mut result = none;\n-    do ebml::tagged_docs(item, tag_impl_iface) |ity| {\n+    do ebml::tagged_docs(item, tag_impl_trait) |ity| {\n         result = some(doc_type(ity, tcx, cdata));\n     };\n     result\n@@ -328,9 +328,9 @@ fn get_type_param_count(data: @~[u8], id: ast::node_id) -> uint {\n     item_ty_param_count(lookup_item(id, data))\n }\n \n-fn get_impl_iface(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n+fn get_impl_trait(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n     -> option<ty::t> {\n-    item_impl_iface(lookup_item(id, cdata.data), tcx, cdata)\n+    item_impl_trait(lookup_item(id, cdata.data), tcx, cdata)\n }\n \n fn get_impl_method(cdata: cmd, id: ast::node_id,\n@@ -354,7 +354,7 @@ fn get_class_method(cdata: cmd, id: ast::node_id,\n             some(it) { it }\n             none { fail (#fmt(\"get_class_method: class id not found \\\n              when looking up method %s\", *name)) }};\n-    do ebml::tagged_docs(cls_items, tag_item_iface_method) |mid| {\n+    do ebml::tagged_docs(cls_items, tag_item_trait_method) |mid| {\n         let m_did = class_member_id(mid, cdata);\n         if item_name(mid) == name {\n             found = some(m_did);\n@@ -601,20 +601,20 @@ fn get_impls_for_mod(cdata: cmd,\n     @result\n }\n \n-/* Works for both classes and ifaces */\n-fn get_iface_methods(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n+/* Works for both classes and traits */\n+fn get_trait_methods(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n     -> @~[ty::method] {\n     let data = cdata.data;\n     let item = lookup_item(id, data);\n     let mut result = ~[];\n-    do ebml::tagged_docs(item, tag_item_iface_method) |mth| {\n+    do ebml::tagged_docs(item, tag_item_trait_method) |mth| {\n         let bounds = item_ty_param_bounds(mth, tcx, cdata);\n         let name = item_name(mth);\n         let ty = doc_type(mth, tcx, cdata);\n         let fty = alt ty::get(ty).struct { ty::ty_fn(f) { f }\n           _ {\n             tcx.diag.handler().bug(\n-                \"get_iface_methods: id has non-function type\");\n+                \"get_trait_methods: id has non-function type\");\n         } };\n         vec::push(result, {ident: name, tps: bounds, fty: fty,\n                     purity: alt check item_family(mth) {\n@@ -703,7 +703,7 @@ fn item_family_to_str(fam: char) -> str {\n       'n' { ret \"foreign mod\"; }\n       'v' { ret \"enum\"; }\n       'i' { ret \"impl\"; }\n-      'I' { ret \"iface\"; }\n+      'I' { ret \"trait\"; }\n       'C' { ret \"class\"; }\n       'g' { ret \"public field\"; }\n       'j' { ret \"private field\"; }"}, {"sha": "8da5ac9420fe13baab6737fbade793ef9e0c9524", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/33334f3c435926422d88dcd5bfafd5e32b141111/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33334f3c435926422d88dcd5bfafd5e32b141111/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=33334f3c435926422d88dcd5bfafd5e32b141111", "patch": "@@ -211,7 +211,7 @@ fn encode_module_item_paths(ebml_w: ebml::writer, ecx: @encode_ctxt,\n               }\n               encode_enum_variant_paths(ebml_w, variants, path, index);\n           }\n-          item_iface(*) {\n+          item_trait(*) {\n             do ebml_w.wr_tag(tag_paths_data_item) {\n                   encode_name_and_def_id(ebml_w, it.ident, it.id);\n               }\n@@ -221,8 +221,8 @@ fn encode_module_item_paths(ebml_w: ebml::writer, ecx: @encode_ctxt,\n     }\n }\n \n-fn encode_iface_ref(ebml_w: ebml::writer, ecx: @encode_ctxt, t: @iface_ref) {\n-    ebml_w.start_tag(tag_impl_iface);\n+fn encode_trait_ref(ebml_w: ebml::writer, ecx: @encode_ctxt, t: @trait_ref) {\n+    ebml_w.start_tag(tag_impl_trait);\n     encode_type(ecx, ebml_w, node_id_to_type(ecx.tcx, t.id));\n     ebml_w.end_tag();\n }\n@@ -396,7 +396,7 @@ fn encode_info_for_mod(ecx: @encode_ctxt, ebml_w: ebml::writer, md: _mod,\n             ebml_w.start_tag(tag_mod_impl);\n             alt ecx.tcx.items.find(did.node) {\n               some(ast_map::node_item(it@@{node: cl@item_class(*),_},_)) {\n-            /* If did stands for an iface\n+            /* If did stands for a trait\n             ref, we need to map it to its parent class */\n                 ebml_w.wr_str(def_to_str(local_def(it.id)));\n               }\n@@ -622,7 +622,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         encode_enum_variant_info(ecx, ebml_w, item.id, variants,\n                                  path, index, tps);\n       }\n-      item_class(tps, ifaces, items, ctor, m_dtor, rp) {\n+      item_class(tps, traits, items, ctor, m_dtor, rp) {\n         /* First, encode the fields and methods\n            These come first because we need to write them to make\n            the index, and the index needs to be in the item for the\n@@ -650,8 +650,8 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         encode_name(ebml_w, item.ident);\n         encode_path(ebml_w, path, ast_map::path_name(item.ident));\n         encode_region_param(ebml_w, rp);\n-        for ifaces.each |t| {\n-           encode_iface_ref(ebml_w, ecx, t);\n+        for traits.each |t| {\n+           encode_trait_ref(ebml_w, ecx, t);\n         }\n         /* Encode the dtor */\n         /* Encode id for dtor */\n@@ -662,7 +662,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         };\n \n         /* Encode def_ids for each field and method\n-         for methods, write all the stuff get_iface_method\n+         for methods, write all the stuff get_trait_method\n         needs to know*/\n         let (fs,ms) = ast_util::split_class_items(items);\n         for fs.each |f| {\n@@ -677,8 +677,8 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n               private { /* do nothing */ }\n               public {\n                 /* Write the info that's needed when viewing this class\n-                   as an iface */\n-                ebml_w.start_tag(tag_item_iface_method);\n+                   as a trait */\n+                ebml_w.start_tag(tag_item_trait_method);\n                 encode_family(ebml_w, purity_fn_family(m.decl.purity));\n                 encode_name(ebml_w, m.ident);\n                 encode_type_param_bounds(ebml_w, ecx, m.tps);\n@@ -713,7 +713,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n             ebml_w.end_tag();\n         }\n         do option::iter(ifce) |t| {\n-           encode_iface_ref(ebml_w, ecx, t)\n+           encode_trait_ref(ebml_w, ecx, t)\n         };\n         encode_path(ebml_w, path, ast_map::path_name(item.ident));\n         ebml_w.end_tag();\n@@ -727,7 +727,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n                                    vec::append(tps, m.tps));\n         }\n       }\n-      item_iface(tps, rp, ms) {\n+      item_trait(tps, rp, ms) {\n         add_to_index();\n         ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));\n@@ -737,8 +737,8 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n         encode_name(ebml_w, item.ident);\n         let mut i = 0u;\n-        for vec::each(*ty::iface_methods(tcx, local_def(item.id))) |mty| {\n-            ebml_w.start_tag(tag_item_iface_method);\n+        for vec::each(*ty::trait_methods(tcx, local_def(item.id))) |mty| {\n+            ebml_w.start_tag(tag_item_trait_method);\n             encode_name(ebml_w, mty.ident);\n             encode_type_param_bounds(ebml_w, ecx, ms[i].tps);\n             encode_type(ecx, ebml_w, ty::mk_fn(tcx, mty.fty));"}, {"sha": "31a92b72f979d5bdfe6d35308874a1bdeeb11a45", "filename": "src/rustc/metadata/tydecode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/33334f3c435926422d88dcd5bfafd5e32b141111/src%2Frustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33334f3c435926422d88dcd5bfafd5e32b141111/src%2Frustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ftydecode.rs?ref=33334f3c435926422d88dcd5bfafd5e32b141111", "patch": "@@ -290,7 +290,7 @@ fn parse_ty(st: @pstate, conv: conv_did) -> ty::t {\n         let def = parse_def(st, conv);\n         let substs = parse_substs(st, conv);\n         assert next(st) == ']';\n-        ret ty::mk_iface(st.tcx, def, substs);\n+        ret ty::mk_trait(st.tcx, def, substs);\n       }\n       'p' {\n         let did = parse_def(st, conv);\n@@ -505,7 +505,7 @@ fn parse_bounds(st: @pstate, conv: conv_did) -> @~[ty::param_bound] {\n           'S' { ty::bound_send }\n           'C' { ty::bound_copy }\n           'K' { ty::bound_const }\n-          'I' { ty::bound_iface(parse_ty(st, conv)) }\n+          'I' { ty::bound_trait(parse_ty(st, conv)) }\n           '.' { break; }\n         });\n     }"}, {"sha": "57a696094e8520ef6cc6d2989689024c7bcfa094", "filename": "src/rustc/metadata/tyencode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/33334f3c435926422d88dcd5bfafd5e32b141111/src%2Frustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33334f3c435926422d88dcd5bfafd5e32b141111/src%2Frustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ftyencode.rs?ref=33334f3c435926422d88dcd5bfafd5e32b141111", "patch": "@@ -222,7 +222,7 @@ fn enc_sty(w: io::writer, cx: @ctxt, st: ty::sty) {\n         enc_substs(w, cx, substs);\n         w.write_char(']');\n       }\n-      ty::ty_iface(def, substs) {\n+      ty::ty_trait(def, substs) {\n         w.write_str(\"x[\"/&);\n         w.write_str(cx.ds(def));\n         w.write_char('|');\n@@ -401,7 +401,7 @@ fn enc_bounds(w: io::writer, cx: @ctxt, bs: @~[ty::param_bound]) {\n           ty::bound_send { w.write_char('S'); }\n           ty::bound_copy { w.write_char('C'); }\n           ty::bound_const { w.write_char('K'); }\n-          ty::bound_iface(tp) {\n+          ty::bound_trait(tp) {\n             w.write_char('I');\n             enc_ty(w, cx, tp);\n           }"}, {"sha": "ced44551a7f95bd0d84e0d798da83f5e99c4865f", "filename": "src/rustc/middle/astencode.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/33334f3c435926422d88dcd5bfafd5e32b141111/src%2Frustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33334f3c435926422d88dcd5bfafd5e32b141111/src%2Frustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fastencode.rs?ref=33334f3c435926422d88dcd5bfafd5e32b141111", "patch": "@@ -395,10 +395,10 @@ impl of tr for method_origin {\n             typeck::method_static(did.tr(xcx))\n           }\n           typeck::method_param(mp) {\n-            typeck::method_param({iface_id:mp.iface_id.tr(xcx) with mp})\n+            typeck::method_param({trait_id:mp.trait_id.tr(xcx) with mp})\n           }\n-          typeck::method_iface(did, m) {\n-            typeck::method_iface(did.tr(xcx), m)\n+          typeck::method_trait(did, m) {\n+            typeck::method_trait(did.tr(xcx), m)\n           }\n         }\n     }\n@@ -458,8 +458,8 @@ fn encode_vtable_origin(ecx: @e::encode_ctxt,\n                 }\n             }\n           }\n-          typeck::vtable_iface(def_id, tys) {\n-            do ebml_w.emit_enum_variant(\"vtable_iface\", 1u, 3u) {\n+          typeck::vtable_trait(def_id, tys) {\n+            do ebml_w.emit_enum_variant(\"vtable_trait\", 1u, 3u) {\n                 do ebml_w.emit_enum_variant_arg(0u) {\n                     ebml_w.emit_def_id(def_id)\n                 }\n@@ -507,7 +507,7 @@ impl helpers for ebml::ebml_deserializer {\n                     )\n                   }\n                   2u {\n-                    typeck::vtable_iface(\n+                    typeck::vtable_trait(\n                         do self.read_enum_variant_arg(0u) {\n                             self.read_def_id(xcx)\n                         },"}, {"sha": "f84dd4b0652821c40daf0c69bdb3f072909cab61", "filename": "src/rustc/middle/kind.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/33334f3c435926422d88dcd5bfafd5e32b141111/src%2Frustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33334f3c435926422d88dcd5bfafd5e32b141111/src%2Frustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fkind.rs?ref=33334f3c435926422d88dcd5bfafd5e32b141111", "patch": "@@ -265,16 +265,16 @@ fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n                     // and then the method bounds themselves...\n                     ty::lookup_item_type(cx.tcx, did).bounds\n                   }\n-                  typeck::method_param({iface_id:ifce_id,\n+                  typeck::method_param({trait_id:trt_id,\n                                         method_num:n_mth, _}) |\n-                  typeck::method_iface(ifce_id, n_mth) {\n-                    // ...iface methods bounds, in contrast, include only the\n+                  typeck::method_trait(trt_id, n_mth) {\n+                    // ...trait methods bounds, in contrast, include only the\n                     // method bounds, so we must preprend the tps from the\n-                    // iface itself.  This ought to be harmonized.\n-                    let ifce_bounds =\n-                        ty::lookup_item_type(cx.tcx, ifce_id).bounds;\n-                    let mth = ty::iface_methods(cx.tcx, ifce_id)[n_mth];\n-                    @(vec::append(*ifce_bounds, *mth.tps))\n+                    // trait itself.  This ought to be harmonized.\n+                    let trt_bounds =\n+                        ty::lookup_item_type(cx.tcx, trt_id).bounds;\n+                    let mth = ty::trait_methods(cx.tcx, trt_id)[n_mth];\n+                    @(vec::append(*trt_bounds, *mth.tps))\n                   }\n                 }\n               }"}, {"sha": "51c48f6a64c04aca175e67aec25ffe828c379a12", "filename": "src/rustc/middle/resolve.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/33334f3c435926422d88dcd5bfafd5e32b141111/src%2Frustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33334f3c435926422d88dcd5bfafd5e32b141111/src%2Frustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve.rs?ref=33334f3c435926422d88dcd5bfafd5e32b141111", "patch": "@@ -406,7 +406,7 @@ fn maybe_insert(e: @env, id: node_id, def: option<def>) {\n     }\n }\n \n-fn resolve_iface_ref(p: @iface_ref, sc: scopes, e: @env) {\n+fn resolve_trait_ref(p: @trait_ref, sc: scopes, e: @env) {\n     maybe_insert(e, p.id,\n        lookup_path_strict(*e, sc, p.path.span, p.path, ns_type));\n }\n@@ -436,15 +436,15 @@ fn resolve_names(e: @env, c: @ast::crate) {\n     fn walk_item(e: @env, i: @ast::item, &&sc: scopes, v: vt<scopes>) {\n         visit_item_with_scope(e, i, sc, v);\n         alt i.node {\n-          /* At this point, the code knows what ifaces the iface refs\n+          /* At this point, the code knows what traits the trait refs\n              refer to, so it's possible to resolve them.\n            */\n           ast::item_impl(_, _, ifce, _, _) {\n-            ifce.iter(|p| resolve_iface_ref(p, sc, e))\n+            ifce.iter(|p| resolve_trait_ref(p, sc, e))\n           }\n-          ast::item_class(_, ifaces, _, _, _, _) {\n-            for ifaces.each |p| {\n-               resolve_iface_ref(p, sc, e);\n+          ast::item_class(_, traits, _, _, _, _) {\n+            for traits.each |p| {\n+               resolve_trait_ref(p, sc, e);\n             }\n           }\n           _ {}\n@@ -485,7 +485,7 @@ fn resolve_names(e: @env, c: @ast::crate) {\n             e.current_tp = some(current);\n             for vec::each(*tp.bounds) |bound| {\n                 alt bound {\n-                  bound_iface(t) { v.visit_ty(t, sc, v); }\n+                  bound_trait(t) { v.visit_ty(t, sc, v); }\n                   _ {}\n                 }\n             }\n@@ -564,7 +564,7 @@ fn visit_item_with_scope(e: @env, i: @ast::item,\n                        m.decl, m.body, m.span, m.id, msc, v);\n         }\n       }\n-      ast::item_iface(tps, _, methods) {\n+      ast::item_trait(tps, _, methods) {\n         v.visit_ty_params(tps, sc, v);\n         let isc = @cons(scope_method(i.id, tps), sc);\n         for methods.each |m| {\n@@ -574,14 +574,14 @@ fn visit_item_with_scope(e: @env, i: @ast::item,\n             v.visit_ty(m.decl.output, msc, v);\n         }\n       }\n-      ast::item_class(tps, ifaces, members, ctor, m_dtor, _) {\n+      ast::item_class(tps, traits, members, ctor, m_dtor, _) {\n         v.visit_ty_params(tps, sc, v);\n         let class_scope = @cons(scope_item(i), sc);\n         /* visit the constructor... */\n         let ctor_scope = @cons(scope_method(ctor.node.self_id, tps),\n                                class_scope);\n-        /* visit the iface refs in the class scope */\n-        for ifaces.each |p| {\n+        /* visit the trait refs in the class scope */\n+        for traits.each |p| {\n             visit::visit_path(p.path, class_scope, v);\n         }\n         visit_fn_with_scope(e, visit::fk_ctor(i.ident, tps, ctor.node.self_id,\n@@ -1048,7 +1048,7 @@ fn lookup_in_scope(e: env, &&sc: scopes, sp: span, name: ident, ns: namespace,\n               ast::item_enum(_, tps, _) | ast::item_ty(_, tps, _) {\n                 if ns == ns_type { ret lookup_in_ty_params(e, name, tps); }\n               }\n-              ast::item_iface(tps, _, _) {\n+              ast::item_trait(tps, _, _) {\n                 if ns == ns_type {\n                     if *name == \"self\" {\n                         ret some(def_self(it.id));\n@@ -1336,7 +1336,7 @@ fn found_def_item(i: @ast::item, ns: namespace) -> option<def> {\n             ret some(ast::def_foreign_mod(local_def(i.id)));\n         }\n       }\n-      ast::item_ty(*) | item_iface(*) | item_enum(*) {\n+      ast::item_ty(*) | item_trait(*) | item_enum(*) {\n         if ns == ns_type { ret some(ast::def_ty(local_def(i.id))); }\n       }\n       ast::item_class(_, _, _members, ct, _, _) {\n@@ -1641,7 +1641,7 @@ fn index_mod(md: ast::_mod) -> mod_index {\n         alt it.node {\n           ast::item_const(_, _) | ast::item_fn(_, _, _) | ast::item_mod(_) |\n           ast::item_foreign_mod(_) | ast::item_ty(_, _, _) |\n-          ast::item_impl(*) | ast::item_iface(*) {\n+          ast::item_impl(*) | ast::item_trait(*) {\n             add_to_index(index, it.ident, mie_item(it));\n           }\n           ast::item_enum(variants, _, _) {\n@@ -1780,7 +1780,7 @@ fn check_item(e: @env, i: @ast::item, &&x: (), v: vt<()>) {\n         ensure_unique(*e, i.span, ty_params, |tp| tp.ident,\n                       \"type parameter\");\n       }\n-      ast::item_iface(_, _, methods) {\n+      ast::item_trait(_, _, methods) {\n         ensure_unique(*e, i.span, methods, |m| m.ident,\n                       \"method\");\n       }\n@@ -1862,7 +1862,7 @@ fn check_block(e: @env, b: ast::blk, &&x: (), v: vt<()>) {\n                   ast::item_const(_, _) | ast::item_fn(*) {\n                     add_name(values, it.span, it.ident);\n                   }\n-                  ast::item_ty(*) | ast::item_iface(*) {\n+                  ast::item_ty(*) | ast::item_trait(*) {\n                     add_name(types, it.span, it.ident);\n                   }\n                   _ { }\n@@ -2146,7 +2146,7 @@ type method_info = {did: def_id, n_tps: uint, ident: ast::ident};\n    * did: the def id of the class or impl item\n    * ident: the name of the impl, unless it has no name (as in\n    \"impl of X\") in which case the ident\n-   is the ident of the iface that's being implemented\n+   is the ident of the trait that's being implemented\n    * methods: the item's methods\n */\n type _impl = {did: def_id, ident: ast::ident, methods: ~[@method_info]};\n@@ -2258,7 +2258,7 @@ fn find_impls_in_item(e: env, i: @ast::item, &impls: ~[@_impl],\n           let n_tps = tps.len();\n         do vec::iter(ifces) |p| {\n             // The def_id, in this case, identifies the combination of\n-            // class and iface\n+            // class and trait\n             vec::push(impls, @{did: local_def(p.id),\n                                ident: i.ident,\n                                methods: vec::map(mthds, |m| {"}, {"sha": "b7dc314c801c17dc6520011edc078dcc12241864", "filename": "src/rustc/middle/resolve3.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/33334f3c435926422d88dcd5bfafd5e32b141111/src%2Frustc%2Fmiddle%2Fresolve3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33334f3c435926422d88dcd5bfafd5e32b141111/src%2Frustc%2Fmiddle%2Fresolve3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve3.rs?ref=33334f3c435926422d88dcd5bfafd5e32b141111", "patch": "@@ -2,7 +2,7 @@ import driver::session::session;\n import metadata::csearch::{each_path, get_impls_for_mod, lookup_defs};\n import metadata::cstore::find_use_stmt_cnum;\n import metadata::decoder::{def_like, dl_def, dl_field, dl_impl};\n-import syntax::ast::{_mod, arm, blk, bound_const, bound_copy, bound_iface};\n+import syntax::ast::{_mod, arm, blk, bound_const, bound_copy, bound_trait};\n import syntax::ast::{bound_send, capture_clause, class_ctor, class_dtor};\n import syntax::ast::{class_member, class_method, crate, crate_num, decl_item};\n import syntax::ast::{def, def_arg, def_binding, def_class, def_const, def_fn};\n@@ -12,9 +12,9 @@ import syntax::ast::{def_upvar, def_use, def_variant, expr, expr_assign_op};\n import syntax::ast::{expr_binary, expr_cast, expr_field, expr_fn};\n import syntax::ast::{expr_fn_block, expr_index, expr_new, expr_path};\n import syntax::ast::{expr_unary, fn_decl, foreign_item, foreign_item_fn};\n-import syntax::ast::{ident, iface_ref, impure_fn, instance_var, item};\n+import syntax::ast::{ident, trait_ref, impure_fn, instance_var, item};\n import syntax::ast::{item_class, item_const, item_enum, item_fn};\n-import syntax::ast::{item_foreign_mod, item_iface, item_impl, item_mod};\n+import syntax::ast::{item_foreign_mod, item_trait, item_impl, item_mod};\n import syntax::ast::{item_ty, local, local_crate, method, node_id, pat};\n import syntax::ast::{pat_enum, pat_ident, path, prim_ty, stmt_decl, ty};\n import syntax::ast::{ty_bool, ty_char, ty_constr, ty_f, ty_f32, ty_f64};\n@@ -867,7 +867,7 @@ class Resolver {\n                 visit_item(item, new_parent, visitor);\n             }\n \n-            item_iface(*) {\n+            item_trait(*) {\n                 (*name_bindings).define_type(def_ty(local_def(item.id)));\n                 visit_item(item, new_parent, visitor);\n             }\n@@ -1233,7 +1233,7 @@ class Resolver {\n \n     fn build_reduced_graph_for_impls_in_external_module(module: @Module) {\n         // XXX: This is really unfortunate. decoder::each_path can produce\n-        // false positives, since, in the crate metadata, an iface named 'bar'\n+        // false positives, since, in the crate metadata, a trait named 'bar'\n         // in module 'foo' defining a method named 'baz' will result in the\n         // creation of a (bogus) path entry named 'foo::bar::baz', and we will\n         // create a module node for \"bar\". We can identify these fake modules\n@@ -2747,7 +2747,7 @@ class Resolver {\n                                             visitor);\n             }\n \n-            item_iface(type_parameters, _, methods) {\n+            item_trait(type_parameters, _, methods) {\n                 // Create a new rib for the self type.\n                 let self_type_rib = @Rib(NormalRibKind);\n                 (*self.type_ribs).push(self_type_rib);\n@@ -3013,7 +3013,7 @@ class Resolver {\n                     bound_copy | bound_send | bound_const {\n                         // Nothing to do.\n                     }\n-                    bound_iface(interface_type) {\n+                    bound_trait(interface_type) {\n                         self.resolve_type(interface_type, visitor);\n                     }\n                 }\n@@ -3023,14 +3023,14 @@ class Resolver {\n \n     fn resolve_class(id: node_id,\n                      type_parameters: @~[ty_param],\n-                     interfaces: ~[@iface_ref],\n+                     interfaces: ~[@trait_ref],\n                      class_members: ~[@class_member],\n                      constructor: class_ctor,\n                      optional_destructor: option<class_dtor>,\n                      visitor: ResolveVisitor) {\n \n         // Add a type into the def map. This is needed to prevent an ICE in\n-        // ty::impl_iface.\n+        // ty::impl_trait.\n \n         // If applicable, create a rib for the type parameters.\n         let outer_type_parameter_count = (*type_parameters).len();\n@@ -3055,7 +3055,7 @@ class Resolver {\n                         // definition of the interface into the definition\n                         // map.\n \n-                        #debug(\"(resolving class) found iface def: %?\", def);\n+                        #debug(\"(resolving class) found trait def: %?\", def);\n \n                         self.record_def(interface.id, def);\n \n@@ -3122,7 +3122,7 @@ class Resolver {\n     fn resolve_implementation(id: node_id,\n                               span: span,\n                               type_parameters: ~[ty_param],\n-                              interface_reference: option<@iface_ref>,\n+                              interface_reference: option<@trait_ref>,\n                               self_type: @ty,\n                               methods: ~[@method],\n                               visitor: ResolveVisitor) {"}, {"sha": "dcbb4aa0fd92d30073f7bf253537cb44ac944e6e", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/33334f3c435926422d88dcd5bfafd5e32b141111/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33334f3c435926422d88dcd5bfafd5e32b141111/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=33334f3c435926422d88dcd5bfafd5e32b141111", "patch": "@@ -652,7 +652,7 @@ fn make_take_glue(bcx: block, v: ValueRef, t: ty::t) {\n       ty::ty_fn(_) {\n         closure::make_fn_glue(bcx, v, t, take_ty)\n       }\n-      ty::ty_iface(_, _) {\n+      ty::ty_trait(_, _) {\n         let llbox = Load(bcx, GEPi(bcx, v, ~[0u, 1u]));\n         incr_refcnt_of_boxed(bcx, llbox);\n         bcx\n@@ -682,10 +682,10 @@ fn incr_refcnt_of_boxed(cx: block, box_ptr: ValueRef) {\n fn make_visit_glue(bcx: block, v: ValueRef, t: ty::t) {\n     let _icx = bcx.insn_ctxt(\"make_visit_glue\");\n     let mut bcx = bcx;\n-    assert bcx.ccx().tcx.intrinsic_ifaces.contains_key(@\"ty_visitor\");\n-    let (iid, ty) = bcx.ccx().tcx.intrinsic_ifaces.get(@\"ty_visitor\");\n+    assert bcx.ccx().tcx.intrinsic_traits.contains_key(@\"ty_visitor\");\n+    let (iid, ty) = bcx.ccx().tcx.intrinsic_traits.get(@\"ty_visitor\");\n     let v = PointerCast(bcx, v, T_ptr(type_of::type_of(bcx.ccx(), ty)));\n-    bcx = reflect::emit_calls_to_iface_visit_ty(bcx, t, v, iid);\n+    bcx = reflect::emit_calls_to_trait_visit_ty(bcx, t, v, iid);\n     build_return(bcx);\n }\n \n@@ -808,7 +808,7 @@ fn make_drop_glue(bcx: block, v0: ValueRef, t: ty::t) {\n       ty::ty_fn(_) {\n         closure::make_fn_glue(bcx, v0, t, drop_ty)\n       }\n-      ty::ty_iface(_, _) {\n+      ty::ty_trait(_, _) {\n         let llbox = Load(bcx, GEPi(bcx, v0, ~[0u, 1u]));\n         decr_refcnt_maybe_free(bcx, llbox, ty::mk_opaque_box(ccx.tcx))\n       }\n@@ -2063,7 +2063,7 @@ fn normalize_for_monomorphization(tcx: ty::ctxt, ty: ty::t) -> option<ty::t> {\n                                             output: ty::mk_nil(tcx),\n                                             ret_style: ast::return_val,\n                                             constraints: ~[]})) }\n-      ty::ty_iface(_, _) { some(ty::mk_fn(tcx, {purity: ast::impure_fn,\n+      ty::ty_trait(_, _) { some(ty::mk_fn(tcx, {purity: ast::impure_fn,\n                                                 proto: ast::proto_box,\n                                                 inputs: ~[],\n                                                 output: ty::mk_nil(tcx),\n@@ -2085,7 +2085,7 @@ fn make_mono_id(ccx: @crate_ctxt, item: ast::def_id, substs: ~[ty::t],\n             let mut v = ~[];\n             for vec::each(*bounds) |bound| {\n                 alt bound {\n-                  ty::bound_iface(_) {\n+                  ty::bound_trait(_) {\n                     vec::push(v, impl::vtable_id(ccx, vts[i]));\n                     i += 1u;\n                   }\n@@ -2822,7 +2822,7 @@ fn trans_cast(cx: block, e: @ast::expr, id: ast::node_id,\n     let ccx = cx.ccx();\n     let t_out = node_id_type(cx, id);\n     alt ty::get(t_out).struct {\n-      ty::ty_iface(_, _) { ret impl::trans_cast(cx, e, id, dest); }\n+      ty::ty_trait(_, _) { ret impl::trans_cast(cx, e, id, dest); }\n       _ {}\n     }\n     let e_res = trans_temp_expr(cx, e);\n@@ -4964,7 +4964,7 @@ fn trans_item(ccx: @crate_ctxt, item: ast::item) {\n         };\n         foreign::trans_foreign_mod(ccx, foreign_mod, abi);\n       }\n-      ast::item_class(tps, _ifaces, items, ctor, m_dtor, _) {\n+      ast::item_class(tps, _traits, items, ctor, m_dtor, _) {\n         if tps.len() == 0u {\n           let psubsts = {tys: ty::ty_params_to_tys(ccx.tcx, tps),\n                          vtables: none,"}, {"sha": "cd1161e055c9e5583134d72524afbec8e9b58588", "filename": "src/rustc/middle/trans/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/33334f3c435926422d88dcd5bfafd5e32b141111/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33334f3c435926422d88dcd5bfafd5e32b141111/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=33334f3c435926422d88dcd5bfafd5e32b141111", "patch": "@@ -783,7 +783,7 @@ fn T_captured_tydescs(cx: @crate_ctxt, n: uint) -> TypeRef {\n     ret T_struct(vec::from_elem::<TypeRef>(n, T_ptr(cx.tydesc_type)));\n }\n \n-fn T_opaque_iface(cx: @crate_ctxt) -> TypeRef {\n+fn T_opaque_trait(cx: @crate_ctxt) -> TypeRef {\n     T_struct(~[T_ptr(cx.tydesc_type), T_opaque_box_ptr(cx)])\n }\n "}, {"sha": "b95864f51326adab1ee90f3b64c580d211faac47", "filename": "src/rustc/middle/trans/impl.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/33334f3c435926422d88dcd5bfafd5e32b141111/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33334f3c435926422d88dcd5bfafd5e32b141111/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs?ref=33334f3c435926422d88dcd5bfafd5e32b141111", "patch": "@@ -58,7 +58,7 @@ fn trans_method_callee(bcx: block, callee_id: ast::node_id,\n         {env: self_env(val, node_id_type(bcx, self.id), none)\n          with lval_static_fn(bcx, did, callee_id)}\n       }\n-      typeck::method_param({iface_id:iid, method_num:off,\n+      typeck::method_param({trait_id:iid, method_num:off,\n                             param_num:p, bound_num:b}) {\n         alt check bcx.fcx.param_substs {\n           some(substs) {\n@@ -67,10 +67,10 @@ fn trans_method_callee(bcx: block, callee_id: ast::node_id,\n           }\n         }\n       }\n-      typeck::method_iface(_, off) {\n+      typeck::method_trait(_, off) {\n         let {bcx, val} = trans_temp_expr(bcx, self);\n         let fty = node_id_type(bcx, callee_id);\n-        trans_iface_callee(bcx, val, fty, off)\n+        trans_trait_callee(bcx, val, fty, off)\n       }\n     }\n }\n@@ -112,14 +112,14 @@ fn method_ty_param_count(ccx: @crate_ctxt, m_id: ast::def_id,\n \n fn trans_monomorphized_callee(bcx: block, callee_id: ast::node_id,\n                               base: @ast::expr, derefs: uint,\n-                              iface_id: ast::def_id, n_method: uint,\n+                              trait_id: ast::def_id, n_method: uint,\n                               n_param: uint, n_bound: uint,\n                               substs: param_substs) -> lval_maybe_callee {\n     let _icx = bcx.insn_ctxt(\"impl::trans_monomorphized_callee\");\n     alt find_vtable_in_fn_ctxt(substs, n_param, n_bound) {\n       typeck::vtable_static(impl_did, impl_substs, sub_origins) {\n         let ccx = bcx.ccx();\n-        let mname = ty::iface_methods(ccx.tcx, iface_id)[n_method].ident;\n+        let mname = ty::trait_methods(ccx.tcx, trait_id)[n_method].ident;\n         let mth_id = method_with_name(bcx.ccx(), impl_did, mname);\n         let n_m_tps = method_ty_param_count(ccx, mth_id, impl_did);\n         let node_substs = node_id_type_params(bcx, callee_id);\n@@ -135,22 +135,22 @@ fn trans_monomorphized_callee(bcx: block, callee_id: ast::node_id,\n              ccx, node_id_type(bcx, callee_id))))\n          with lval}\n       }\n-      typeck::vtable_iface(iid, tps) {\n+      typeck::vtable_trait(iid, tps) {\n         let {bcx, val} = trans_temp_expr(bcx, base);\n         let fty = node_id_type(bcx, callee_id);\n-        trans_iface_callee(bcx, val, fty, n_method)\n+        trans_trait_callee(bcx, val, fty, n_method)\n       }\n       typeck::vtable_param(n_param, n_bound) {\n         fail \"vtable_param left in monomorphized function's vtable substs\";\n       }\n     }\n }\n \n-// Method callee where the vtable comes from a boxed iface\n-fn trans_iface_callee(bcx: block, val: ValueRef,\n+// Method callee where the vtable comes from a boxed trait\n+fn trans_trait_callee(bcx: block, val: ValueRef,\n                       callee_ty: ty::t, n_method: uint)\n     -> lval_maybe_callee {\n-    let _icx = bcx.insn_ctxt(\"impl::trans_iface_callee\");\n+    let _icx = bcx.insn_ctxt(\"impl::trans_trait_callee\");\n     let ccx = bcx.ccx();\n     let vtable = Load(bcx, PointerCast(bcx, GEPi(bcx, val, ~[0u, 0u]),\n                                        T_ptr(T_ptr(T_vtable()))));\n@@ -173,7 +173,7 @@ fn find_vtable_in_fn_ctxt(ps: param_substs, n_param: uint, n_bound: uint)\n     for vec::each(*ps.bounds) |bounds| {\n         if i >= n_param { break; }\n         for vec::each(*bounds) |bound| {\n-            alt bound { ty::bound_iface(_) { vtable_off += 1u; } _ {} }\n+            alt bound { ty::bound_trait(_) { vtable_off += 1u; } _ {} }\n         }\n         i += 1u;\n     }\n@@ -215,8 +215,8 @@ fn vtable_id(ccx: @crate_ctxt, origin: typeck::vtable_origin) -> mono_id {\n                      if (*sub_vtables).len() == 0u { none }\n                      else { some(sub_vtables) }, none)\n       }\n-      typeck::vtable_iface(iface_id, substs) {\n-        @{def: iface_id,\n+      typeck::vtable_trait(trait_id, substs) {\n+        @{def: trait_id,\n           params: vec::map(substs, |t| mono_precise(t, none))}\n       }\n     }\n@@ -254,11 +254,11 @@ fn make_impl_vtable(ccx: @crate_ctxt, impl_id: ast::def_id, substs: ~[ty::t],\n     let _icx = ccx.insn_ctxt(\"impl::make_impl_vtable\");\n     let tcx = ccx.tcx;\n     let ifce_id = expect(ccx.sess,\n-                         ty::ty_to_def_id(option::get(ty::impl_iface(tcx,\n+                         ty::ty_to_def_id(option::get(ty::impl_trait(tcx,\n                                                              impl_id))),\n-                         || \"make_impl_vtable: non-iface-type implemented\");\n+                         || \"make_impl_vtable: non-trait-type implemented\");\n     let has_tps = (*ty::lookup_item_type(ccx.tcx, impl_id).bounds).len() > 0u;\n-    make_vtable(ccx, vec::map(*ty::iface_methods(tcx, ifce_id), |im| {\n+    make_vtable(ccx, vec::map(*ty::trait_methods(tcx, ifce_id), |im| {\n         let fty = ty::subst_tps(tcx, substs, ty::mk_fn(tcx, im.fty));\n         if (*im.tps).len() > 0u || ty::type_has_self(fty) {\n             C_null(T_ptr(T_nil()))"}, {"sha": "edf76f4230396d100d3a204700ac4f78453e5f4d", "filename": "src/rustc/middle/trans/reachable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/33334f3c435926422d88dcd5bfafd5e32b141111/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33334f3c435926422d88dcd5bfafd5e32b141111/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs?ref=33334f3c435926422d88dcd5bfafd5e32b141111", "patch": "@@ -121,7 +121,7 @@ fn traverse_public_item(cx: ctx, item: @item) {\n             }\n         }\n       }\n-      item_class(tps, _ifaces, items, ctor, m_dtor, _) {\n+      item_class(tps, _traits, items, ctor, m_dtor, _) {\n         cx.rmap.insert(ctor.node.id, ());\n         do option::iter(m_dtor) |dtor| {\n             cx.rmap.insert(dtor.node.id, ());\n@@ -147,7 +147,7 @@ fn traverse_public_item(cx: ctx, item: @item) {\n         traverse_ty(t, cx, mk_ty_visitor());\n       }\n       item_const(*) |\n-      item_enum(*) | item_iface(*) {}\n+      item_enum(*) | item_trait(*) {}\n     }\n }\n "}, {"sha": "3d5304f5f5ceeac37c317955e5b75356522a6e69", "filename": "src/rustc/middle/trans/reflect.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/33334f3c435926422d88dcd5bfafd5e32b141111/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33334f3c435926422d88dcd5bfafd5e32b141111/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=33334f3c435926422d88dcd5bfafd5e32b141111", "patch": "@@ -47,7 +47,7 @@ impl methods for reflector {\n         let v = self.visitor_val;\n         let get_lval = |bcx| {\n             let callee =\n-                impl::trans_iface_callee(bcx, v, mth_ty, mth_idx);\n+                impl::trans_trait_callee(bcx, v, mth_ty, mth_idx);\n             #debug(\"calling mth ty %s, lltype %s\",\n                    ty_to_str(bcx.ccx().tcx, mth_ty),\n                    val_str(bcx.ccx().tn, callee.val));\n@@ -256,7 +256,7 @@ impl methods for reflector {\n           }\n \n           // Miscallaneous extra types\n-          ty::ty_iface(_, _) { self.leaf(\"iface\") }\n+          ty::ty_trait(_, _) { self.leaf(\"trait\") }\n           ty::ty_var(_) { self.leaf(\"var\") }\n           ty::ty_var_integral(_) { self.leaf(\"var_integral\") }\n           ty::ty_param(n, _) { self.visit(\"param\", ~[self.c_uint(n)]) }\n@@ -278,13 +278,13 @@ impl methods for reflector {\n }\n \n // Emit a sequence of calls to visit_ty::visit_foo\n-fn emit_calls_to_iface_visit_ty(bcx: block, t: ty::t,\n+fn emit_calls_to_trait_visit_ty(bcx: block, t: ty::t,\n                                 visitor_val: ValueRef,\n                                 visitor_iid: def_id) -> block {\n \n     let r = reflector({\n         visitor_val: visitor_val,\n-        visitor_methods: ty::iface_methods(bcx.tcx(), visitor_iid),\n+        visitor_methods: ty::trait_methods(bcx.tcx(), visitor_iid),\n         mut bcx: bcx\n     });\n "}, {"sha": "da37a59dc09305d364cd7f929ceb2fb7b13ad024", "filename": "src/rustc/middle/trans/shape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/33334f3c435926422d88dcd5bfafd5e32b141111/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33334f3c435926422d88dcd5bfafd5e32b141111/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs?ref=33334f3c435926422d88dcd5bfafd5e32b141111", "patch": "@@ -329,7 +329,7 @@ fn shape_of(ccx: @crate_ctxt, t: ty::t) -> ~[u8] {\n         add_substr(s, sub);\n         s\n       }\n-      ty::ty_iface(_, _) { ~[shape_box_fn] }\n+      ty::ty_trait(_, _) { ~[shape_box_fn] }\n       ty::ty_class(did, substs) {\n         // same as records, unless there's a dtor\n         let tps = substs.tps;"}, {"sha": "cfc1f621efdd18235adf0f0c52c6fe174c835cb9", "filename": "src/rustc/middle/trans/type_of.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/33334f3c435926422d88dcd5bfafd5e32b141111/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33334f3c435926422d88dcd5bfafd5e32b141111/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=33334f3c435926422d88dcd5bfafd5e32b141111", "patch": "@@ -140,7 +140,7 @@ fn type_of(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n             T_struct(tys)\n           }\n           ty::ty_fn(_) { T_fn_pair(cx, type_of_fn_from_ty(cx, t)) }\n-          ty::ty_iface(_, _) { T_opaque_iface(cx) }\n+          ty::ty_trait(_, _) { T_opaque_trait(cx) }\n           ty::ty_type { T_ptr(cx.tydesc_type) }\n           ty::ty_tup(elts) {\n             let mut tys = ~[];"}, {"sha": "c8ff5ef4c16492d0d17de4b396fcabe4538a68a6", "filename": "src/rustc/middle/trans/type_use.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/33334f3c435926422d88dcd5bfafd5e32b141111/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33334f3c435926422d88dcd5bfafd5e32b141111/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=33334f3c435926422d88dcd5bfafd5e32b141111", "patch": "@@ -119,12 +119,12 @@ fn type_needs_inner(cx: ctx, use: uint, ty: ty::t,\n             alt ty::get(ty).struct {\n                 /*\n                  This previously included ty_box -- that was wrong\n-                 because if we cast an @T to an iface (for example) and return\n+                 because if we cast an @T to an trait (for example) and return\n                  it, we depend on the drop glue for T (we have to write the\n                  right tydesc into the result)\n                  */\n               ty::ty_fn(_) | ty::ty_ptr(_) | ty::ty_rptr(_, _)\n-               | ty::ty_iface(_, _) { false }\n+               | ty::ty_trait(_, _) { false }\n               ty::ty_enum(did, substs) {\n                 if option::is_none(list::find(enums_seen, |id| id == did)) {\n                     let seen = @cons(did, enums_seen);\n@@ -164,8 +164,8 @@ fn mark_for_expr(cx: ctx, e: @expr) {\n       expr_cast(base, _) {\n         let result_t = ty::node_id_to_type(cx.ccx.tcx, e.id);\n         alt ty::get(result_t).struct {\n-            ty::ty_iface(*) {\n-              // When we're casting to an iface, we need the\n+            ty::ty_trait(*) {\n+              // When we're casting to an trait, we need the\n               // tydesc for the expr that's being cast.\n               node_type_needs(cx, use_tydesc, base.id);\n             }\n@@ -221,7 +221,7 @@ fn mark_for_expr(cx: ctx, e: @expr) {\n               typeck::method_param({param_num: param, _}) {\n                 cx.uses[param] |= use_tydesc;\n               }\n-              typeck::method_iface(_, _) {}\n+              typeck::method_trait(_, _) {}\n             }\n         }\n       }"}, {"sha": "0561a04544a6e82bbaae5ffb4623e0fd53259d98", "filename": "src/rustc/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/33334f3c435926422d88dcd5bfafd5e32b141111/src%2Frustc%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33334f3c435926422d88dcd5bfafd5e32b141111/src%2Frustc%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=33334f3c435926422d88dcd5bfafd5e32b141111", "patch": "@@ -48,7 +48,7 @@ fn find_pre_post_item(ccx: crate_ctxt, i: item) {\n       }\n       item_mod(m) { find_pre_post_mod(m); }\n       item_foreign_mod(nm) { find_pre_post_foreign_mod(nm); }\n-      item_ty(*) | item_enum(*) | item_iface(*) { ret; }\n+      item_ty(*) | item_enum(*) | item_trait(*) { ret; }\n       item_class(*) {\n           fail \"find_pre_post_item: shouldn't be called on item_class\";\n       }"}, {"sha": "bdb7cb4d4729b29629c3494aa928cbb03fa6f516", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/33334f3c435926422d88dcd5bfafd5e32b141111/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33334f3c435926422d88dcd5bfafd5e32b141111/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=33334f3c435926422d88dcd5bfafd5e32b141111", "patch": "@@ -69,7 +69,7 @@ export subst, subst_tps, substs_is_noop, substs_to_str, substs;\n export t;\n export new_ty_hash;\n export enum_variants, substd_enum_variants, enum_is_univariant;\n-export iface_methods, store_iface_methods, impl_iface;\n+export trait_methods, store_trait_methods, impl_trait;\n export enum_variant_with_id;\n export ty_dtor;\n export ty_param_bounds_and_ty;\n@@ -92,7 +92,7 @@ export ty_evec, mk_evec;\n export ty_unboxed_vec, mk_unboxed_vec, mk_mut_unboxed_vec;\n export vstore, vstore_fixed, vstore_uniq, vstore_box, vstore_slice;\n export ty_nil, mk_nil, type_is_nil;\n-export ty_iface, mk_iface;\n+export ty_trait, mk_trait;\n export ty_param, mk_param, ty_params_to_tys;\n export ty_ptr, mk_ptr, mk_mut_ptr, mk_imm_ptr, mk_nil_ptr, type_is_unsafe_ptr;\n export ty_rptr, mk_rptr;\n@@ -154,7 +154,7 @@ export closure_kind;\n export ck_block;\n export ck_box;\n export ck_uniq;\n-export param_bound, param_bounds, bound_copy, bound_send, bound_iface;\n+export param_bound, param_bounds, bound_copy, bound_send, bound_trait;\n export param_bounds_to_kind;\n export default_arg_mode_for_ty;\n export item_path;\n@@ -240,7 +240,7 @@ type ctxt =\n       node_type_substs: hashmap<node_id, ~[t]>,\n \n       items: ast_map::map,\n-      intrinsic_ifaces: hashmap<ast::ident, (ast::def_id, t)>,\n+      intrinsic_traits: hashmap<ast::ident, (ast::def_id, t)>,\n       freevars: freevars::freevar_map,\n       tcache: type_cache,\n       rcache: creader_cache,\n@@ -250,7 +250,7 @@ type ctxt =\n       kind_cache: hashmap<t, kind>,\n       ast_ty_to_ty_cache: hashmap<@ast::ty, ast_ty_to_ty_cache_entry>,\n       enum_var_cache: hashmap<def_id, @~[variant_info]>,\n-      iface_method_cache: hashmap<def_id, @~[method]>,\n+      trait_method_cache: hashmap<def_id, @~[method]>,\n       ty_param_bounds: hashmap<ast::node_id, param_bounds>,\n       inferred_modes: hashmap<ast::node_id, ast::mode>,\n       // maps the id of borrowed expr to scope of borrowed ptr\n@@ -366,7 +366,7 @@ enum sty {\n     ty_rptr(region, mt),\n     ty_rec(~[field]),\n     ty_fn(fn_ty),\n-    ty_iface(def_id, substs),\n+    ty_trait(def_id, substs),\n     ty_class(def_id, substs),\n     ty_tup(~[t]),\n \n@@ -426,7 +426,7 @@ enum param_bound {\n     bound_copy,\n     bound_send,\n     bound_const,\n-    bound_iface(t),\n+    bound_trait(t),\n }\n \n enum tv_vid = uint;\n@@ -468,7 +468,7 @@ fn param_bounds_to_kind(bounds: param_bounds) -> kind {\n           }\n           bound_send { kind = raise_kind(kind, kind_send_only()); }\n           bound_const { kind = raise_kind(kind, kind_const()); }\n-          bound_iface(_) {}\n+          bound_trait(_) {}\n         }\n     }\n     kind\n@@ -519,7 +519,7 @@ fn mk_ctxt(s: session::session, dm: resolve::def_map, amap: ast_map::map,\n       node_types: @smallintmap::mk(),\n       node_type_substs: map::int_hash(),\n       items: amap,\n-      intrinsic_ifaces: map::box_str_hash(),\n+      intrinsic_traits: map::box_str_hash(),\n       freevars: freevars,\n       tcache: ast_util::new_def_hash(),\n       rcache: mk_rcache(),\n@@ -530,7 +530,7 @@ fn mk_ctxt(s: session::session, dm: resolve::def_map, amap: ast_map::map,\n       ast_ty_to_ty_cache: map::hashmap(\n           ast_util::hash_ty, ast_util::eq_ty),\n       enum_var_cache: new_def_hash(),\n-      iface_method_cache: new_def_hash(),\n+      trait_method_cache: new_def_hash(),\n       ty_param_bounds: map::int_hash(),\n       inferred_modes: map::int_hash(),\n       borrowings: map::int_hash(),\n@@ -578,7 +578,7 @@ fn mk_t_with_id(cx: ctxt, st: sty, o_def_id: option<ast::def_id>) -> t {\n       ty_param(_, _) { flags |= has_params as uint; }\n       ty_var(_) | ty_var_integral(_) { flags |= needs_infer as uint; }\n       ty_self { flags |= has_self as uint; }\n-      ty_enum(_, substs) | ty_class(_, substs) | ty_iface(_, substs) {\n+      ty_enum(_, substs) | ty_class(_, substs) | ty_trait(_, substs) {\n         flags |= sflags(substs);\n       }\n       ty_box(m) | ty_uniq(m) | ty_vec(m) | ty_evec(m, _) |\n@@ -704,8 +704,8 @@ fn mk_tup(cx: ctxt, ts: ~[t]) -> t { mk_t(cx, ty_tup(ts)) }\n \n fn mk_fn(cx: ctxt, fty: fn_ty) -> t { mk_t(cx, ty_fn(fty)) }\n \n-fn mk_iface(cx: ctxt, did: ast::def_id, substs: substs) -> t {\n-    mk_t(cx, ty_iface(did, substs))\n+fn mk_trait(cx: ctxt, did: ast::def_id, substs: substs) -> t {\n+    mk_t(cx, ty_trait(did, substs))\n }\n \n fn mk_class(cx: ctxt, class_id: ast::def_id, substs: substs) -> t {\n@@ -775,7 +775,7 @@ fn maybe_walk_ty(ty: t, f: fn(t) -> bool) {\n         maybe_walk_ty(tm.ty, f);\n       }\n       ty_enum(_, substs) | ty_class(_, substs) |\n-      ty_iface(_, substs) {\n+      ty_trait(_, substs) {\n         for substs.tps.each |subty| { maybe_walk_ty(subty, f); }\n       }\n       ty_rec(fields) {\n@@ -824,8 +824,8 @@ fn fold_sty(sty: sty, fldop: fn(t) -> t) -> sty {\n       ty_enum(tid, substs) {\n         ty_enum(tid, fold_substs(substs, fldop))\n       }\n-      ty_iface(did, substs) {\n-        ty_iface(did, fold_substs(substs, fldop))\n+      ty_trait(did, substs) {\n+        ty_trait(did, fold_substs(substs, fldop))\n       }\n       ty_rec(fields) {\n         let new_fields = do vec::map(fields) |fl| {\n@@ -924,8 +924,8 @@ fn fold_regions_and_ty(\n       ty_class(def_id, substs) {\n         ty::mk_class(cx, def_id, fold_substs(substs, fldr, fldt))\n       }\n-      ty_iface(def_id, substs) {\n-        ty::mk_iface(cx, def_id, fold_substs(substs, fldr, fldt))\n+      ty_trait(def_id, substs) {\n+        ty::mk_trait(cx, def_id, fold_substs(substs, fldr, fldt))\n       }\n       sty @ ty_fn(_) {\n         fold_sty_to_ty(cx, sty, |t| fldfnt(t))\n@@ -1074,7 +1074,7 @@ fn type_is_bool(ty: t) -> bool { get(ty).struct == ty_bool }\n fn type_is_structural(ty: t) -> bool {\n     alt get(ty).struct {\n       ty_rec(_) | ty_class(*) | ty_tup(_) | ty_enum(*) | ty_fn(_) |\n-      ty_iface(*) | ty_evec(_, vstore_fixed(_))\n+      ty_trait(*) | ty_evec(_, vstore_fixed(_))\n       | ty_estr(vstore_fixed(_)) { true }\n       _ { false }\n     }\n@@ -1497,7 +1497,7 @@ fn type_kind(cx: ctxt, ty: t) -> kind {\n             else { kind_implicitly_copyable() }\n         }\n       }\n-      ty_iface(_, _) { kind_implicitly_copyable() }\n+      ty_trait(_, _) { kind_implicitly_copyable() }\n       ty_rptr(_, _) { kind_implicitly_copyable() }\n \n       // Unique boxes and vecs have the kind of their contained type,\n@@ -1669,7 +1669,7 @@ fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n             }\n           }\n \n-          ty_iface(_, _) {\n+          ty_trait(_, _) {\n             false\n           }\n \n@@ -1834,7 +1834,7 @@ fn type_is_pod(cx: ctxt, ty: t) -> bool {\n       ty_str | ty_box(_) | ty_uniq(_) | ty_vec(_) | ty_fn(_) |\n       ty_estr(vstore_uniq) | ty_estr(vstore_box) |\n       ty_evec(_, vstore_uniq) | ty_evec(_, vstore_box) |\n-      ty_iface(_, _) | ty_rptr(_,_) | ty_opaque_box { result = false; }\n+      ty_trait(_, _) | ty_rptr(_,_) | ty_opaque_box { result = false; }\n       // Structural types\n       ty_enum(did, substs) {\n         let variants = enum_variants(cx, did);\n@@ -2066,7 +2066,7 @@ fn hash_type_structure(st: sty) -> uint {\n         h\n       }\n       ty_uniq(mt) { hash_subty(37u, mt.ty) }\n-      ty_iface(did, substs) {\n+      ty_trait(did, substs) {\n         let mut h = hash_def(40u, did);\n         hash_substs(h, substs)\n       }\n@@ -2402,7 +2402,7 @@ fn ty_sort_str(cx: ctxt, t: t) -> str {\n       ty_rptr(_, _) { \"&-ptr\" }\n       ty_rec(_) { \"record\" }\n       ty_fn(_) { \"fn\" }\n-      ty_iface(id, _) { #fmt[\"iface %s\", item_path_str(cx, id)] }\n+      ty_trait(id, _) { #fmt[\"trait %s\", item_path_str(cx, id)] }\n       ty_class(id, _) { #fmt[\"class %s\", item_path_str(cx, id)] }\n       ty_tup(_) { \"tuple\" }\n       ty_var(_) { \"variable\" }\n@@ -2513,25 +2513,25 @@ fn def_has_ty_params(def: ast::def) -> bool {\n     }\n }\n \n-fn store_iface_methods(cx: ctxt, id: ast::node_id, ms: @~[method]) {\n-    cx.iface_method_cache.insert(ast_util::local_def(id), ms);\n+fn store_trait_methods(cx: ctxt, id: ast::node_id, ms: @~[method]) {\n+    cx.trait_method_cache.insert(ast_util::local_def(id), ms);\n }\n \n-fn iface_methods(cx: ctxt, id: ast::def_id) -> @~[method] {\n-    alt cx.iface_method_cache.find(id) {\n+fn trait_methods(cx: ctxt, id: ast::def_id) -> @~[method] {\n+    alt cx.trait_method_cache.find(id) {\n       some(ms) { ret ms; }\n       _ {}\n     }\n     // Local interfaces are supposed to have been added explicitly.\n     assert id.crate != ast::local_crate;\n-    let result = csearch::get_iface_methods(cx, id);\n-    cx.iface_method_cache.insert(id, result);\n+    let result = csearch::get_trait_methods(cx, id);\n+    cx.trait_method_cache.insert(id, result);\n     result\n }\n \n-fn impl_iface(cx: ctxt, id: ast::def_id) -> option<t> {\n+fn impl_trait(cx: ctxt, id: ast::def_id) -> option<t> {\n     if id.crate == ast::local_crate {\n-        #debug(\"(impl_iface) searching for iface impl %?\", id);\n+        #debug(\"(impl_trait) searching for trait impl %?\", id);\n         alt cx.items.find(id.node) {\n            some(ast_map::node_item(@{node: ast::item_impl(\n               _, _, some(@{id: id, _}), _, _), _}, _)) {\n@@ -2540,13 +2540,13 @@ fn impl_iface(cx: ctxt, id: ast::def_id) -> option<t> {\n            some(ast_map::node_item(@{node: ast::item_class(_, _, _, _, _, _),\n                            _},_)) {\n              alt cx.def_map.find(id.node) {\n-               some(def_ty(iface_id)) {\n+               some(def_ty(trait_id)) {\n                    // XXX: Doesn't work cross-crate.\n-                   #debug(\"(impl_iface) found iface id %?\", iface_id);\n-                   some(node_id_to_type(cx, iface_id.node))\n+                   #debug(\"(impl_trait) found trait id %?\", trait_id);\n+                   some(node_id_to_type(cx, trait_id.node))\n                }\n                some(x) {\n-                 cx.sess.bug(#fmt(\"impl_iface: iface ref is in iface map \\\n+                 cx.sess.bug(#fmt(\"impl_trait: trait ref is in trait map \\\n                                    but is bound to %?\", x));\n                }\n                none {\n@@ -2557,13 +2557,13 @@ fn impl_iface(cx: ctxt, id: ast::def_id) -> option<t> {\n            _ { none }\n         }\n     } else {\n-        csearch::get_impl_iface(cx, id)\n+        csearch::get_impl_trait(cx, id)\n     }\n }\n \n fn ty_to_def_id(ty: t) -> option<ast::def_id> {\n     alt get(ty).struct {\n-      ty_iface(id, _) | ty_class(id, _) | ty_enum(id, _) {\n+      ty_trait(id, _) | ty_class(id, _) | ty_enum(id, _) {\n         some(id)\n       }\n       _ { none }"}, {"sha": "aaad7841d4c0c79027035f102c00eef55c74b9c0", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/33334f3c435926422d88dcd5bfafd5e32b141111/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33334f3c435926422d88dcd5bfafd5e32b141111/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=33334f3c435926422d88dcd5bfafd5e32b141111", "patch": "@@ -5,7 +5,7 @@ typeck.rs, an introduction\n The type checker is responsible for:\n \n 1. Determining the type of each expression\n-2. Resolving methods and ifaces\n+2. Resolving methods and traits\n 3. Guaranteeing that most type rules are met (\"most?\", you say, \"why most?\"\n    Well, dear reader, read on)\n \n@@ -81,28 +81,28 @@ enum method_origin {\n     // fully statically resolved method\n     method_static(ast::def_id),\n \n-    // method invoked on a type parameter with a bounded iface\n+    // method invoked on a type parameter with a bounded trait\n     method_param(method_param),\n \n-    // method invoked on a boxed iface\n-    method_iface(ast::def_id, uint),\n+    // method invoked on a boxed trait\n+    method_trait(ast::def_id, uint),\n }\n \n // details for a method invoked with a receiver whose type is a type parameter\n-// with a bounded iface.\n+// with a bounded trait.\n #[auto_serialize]\n type method_param = {\n-    // the iface containing the method to be invoked\n-    iface_id: ast::def_id,\n+    // the trait containing the method to be invoked\n+    trait_id: ast::def_id,\n \n-    // index of the method to be invoked amongst the iface's methods\n+    // index of the method to be invoked amongst the trait's methods\n     method_num: uint,\n \n     // index of the type parameter (from those that are in scope) that is\n     // the type of the receiver\n     param_num: uint,\n \n-    // index of the bound for this type parameter which specifies the iface\n+    // index of the bound for this type parameter which specifies the trait\n     bound_num: uint\n };\n \n@@ -140,9 +140,9 @@ enum vtable_origin {\n     vtable_param(uint, uint),\n     /*\n       Dynamic vtable, comes from something known to have an interface\n-      type. def_id refers to the iface item, tys are the substs\n+      type. def_id refers to the trait item, tys are the substs\n      */\n-    vtable_iface(ast::def_id, ~[ty::t]),\n+    vtable_trait(ast::def_id, ~[ty::t]),\n }\n \n type vtable_map = hashmap<ast::node_id, vtable_res>;"}, {"sha": "2561c66940a904473c61dbe974cabd53e744e679", "filename": "src/rustc/middle/typeck/astconv.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/33334f3c435926422d88dcd5bfafd5e32b141111/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33334f3c435926422d88dcd5bfafd5e32b141111/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=33334f3c435926422d88dcd5bfafd5e32b141111", "patch": "@@ -21,7 +21,7 @@\n  * region, or `type_rscope`, which permits the self region if the type in\n  * question is parameterized by a region.\n  *\n- * Unlike the `ast_conv` iface, the region scope can change as we descend\n+ * Unlike the `ast_conv` trait, the region scope can change as we descend\n  * the type.  This is to accommodate the fact that (a) fn types are binding\n  * scopes and (b) the default region may change.  To understand case (a),\n  * consider something like:\n@@ -304,8 +304,8 @@ fn ast_ty_to_ty<AC: ast_conv, RS: region_scope copy>(\n             ty::mk_param(tcx, n, id)\n           }\n           ast::def_self(_) {\n-            // n.b.: resolve guarantees that the self type only appears in an\n-            // iface, which we rely upon in various places when creating\n+            // n.b.: resolve guarantees that the self type only appears in a\n+            // trait, which we rely upon in various places when creating\n             // substs\n             check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n             ty::mk_self(tcx)"}, {"sha": "647498a97e1d3d9caf40eddec3c7214453ff0346", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/33334f3c435926422d88dcd5bfafd5e32b141111/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33334f3c435926422d88dcd5bfafd5e32b141111/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=33334f3c435926422d88dcd5bfafd5e32b141111", "patch": "@@ -30,7 +30,7 @@ can be broken down into several distinct phases:\n   final assignments of the various region variables if there is some\n   flexibility.\n \n-- vtable: find and records the impls to use for each iface bound that\n+- vtable: find and records the impls to use for each trait bound that\n   appears on a type parameter.\n \n - writeback: writes the final types within a function body, replacing\n@@ -358,7 +358,7 @@ fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n         let self_ty = ccx.to_ty(rscope::type_rscope(rp), ty);\n         for ms.each |m| { check_method(ccx, m, self_ty);}\n       }\n-      ast::item_class(tps, ifaces, members, ctor, m_dtor, rp) {\n+      ast::item_class(tps, traits, members, ctor, m_dtor, rp) {\n           let tcx = ccx.tcx;\n           let class_t = ty::node_id_to_type(tcx, it.id);\n           // typecheck the ctor\n@@ -1090,8 +1090,8 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n       // Something of a hack: special rules for comparison operators that\n       // simply unify LHS and RHS.  This helps with inference as LHS and RHS\n       // do not need to be \"resolvable\".  Some tests, particularly those with\n-      // complicated iface requirements, fail without this---I think this code\n-      // can be removed if we improve iface resolution to be more eager when\n+      // complicated trait requirements, fail without this---I think this code\n+      // can be removed if we improve trait resolution to be more eager when\n       // possible.\n       ast::expr_binary(ast::eq, lhs, rhs) |\n       ast::expr_binary(ast::ne, lhs, rhs) |\n@@ -1392,7 +1392,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n \n         alt ty::get(t_1).struct {\n           // This will be looked up later on\n-          ty::ty_iface(*) {}\n+          ty::ty_trait(*) {}\n \n           _ {\n             if ty::type_is_nil(t_e) {\n@@ -1518,7 +1518,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n           }\n           ty::ty_class(base_id, substs) {\n               // This is just for fields -- the same code handles\n-              // methods in both classes and ifaces\n+              // methods in both classes and traits\n \n               // (1) verify that the class id actually has a field called\n               // field\n@@ -2259,9 +2259,9 @@ fn check_intrinsic_type(ccx: @crate_ctxt, it: @ast::foreign_item) {\n       }\n \n       \"visit_ty\" {\n-        assert ccx.tcx.intrinsic_ifaces.contains_key(@\"ty_visitor\");\n-        let (_, visitor_iface) = ccx.tcx.intrinsic_ifaces.get(@\"ty_visitor\");\n-        (1u, ~[arg(ast::by_ref, visitor_iface)], ty::mk_nil(tcx))\n+        assert ccx.tcx.intrinsic_traits.contains_key(@\"ty_visitor\");\n+        let (_, visitor_trait) = ccx.tcx.intrinsic_traits.get(@\"ty_visitor\");\n+        (1u, ~[arg(ast::by_ref, visitor_trait)], ty::mk_nil(tcx))\n       }\n       \"frame_address\" {\n         let fty = ty::mk_fn(ccx.tcx, {"}, {"sha": "709db8733d5849a54444f3a44310f8ae806b4205", "filename": "src/rustc/middle/typeck/check/method.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/33334f3c435926422d88dcd5bfafd5e32b141111/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33334f3c435926422d88dcd5bfafd5e32b141111/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=33334f3c435926422d88dcd5bfafd5e32b141111", "patch": "@@ -64,8 +64,8 @@ class lookup {\n               ty::ty_param(n, did) {\n                 self.add_candidates_from_param(n, did);\n               }\n-              ty::ty_iface(did, substs) {\n-                self.add_candidates_from_iface(did, substs);\n+              ty::ty_trait(did, substs) {\n+                self.add_candidates_from_trait(did, substs);\n               }\n               ty::ty_class(did, substs) {\n                 self.add_candidates_from_class(did, substs);\n@@ -111,10 +111,10 @@ class lookup {\n                     self.report_static_candidate(i, did);\n                   }\n                   method_param(p) {\n-                    self.report_param_candidate(i, p.iface_id);\n+                    self.report_param_candidate(i, p.trait_id);\n                   }\n-                  method_iface(did, _) {\n-                    self.report_iface_candidate(i, did);\n+                  method_trait(did, _) {\n+                    self.report_trait_candidate(i, did);\n                   }\n                 }\n             }\n@@ -148,11 +148,11 @@ class lookup {\n                  ty::item_path_str(self.tcx(), did)]);\n     }\n \n-    fn report_iface_candidate(idx: uint, did: ast::def_id) {\n+    fn report_trait_candidate(idx: uint, did: ast::def_id) {\n         self.tcx().sess.span_note(\n             self.expr.span,\n             #fmt[\"candidate #%u derives from the type of the receiver, \\\n-                  which is the iface `%s`\",\n+                  which is the trait `%s`\",\n                  (idx+1u),\n                  ty::item_path_str(self.tcx(), did)]);\n     }\n@@ -161,55 +161,55 @@ class lookup {\n         #debug[\"candidates_from_param\"];\n \n         let tcx = self.tcx();\n-        let mut iface_bnd_idx = 0u; // count only iface bounds\n+        let mut trait_bnd_idx = 0u; // count only trait bounds\n         let bounds = tcx.ty_param_bounds.get(did.node);\n         for vec::each(*bounds) |bound| {\n             let (iid, bound_substs) = alt bound {\n               ty::bound_copy | ty::bound_send | ty::bound_const {\n                 cont; /* ok */\n               }\n-              ty::bound_iface(bound_t) {\n+              ty::bound_trait(bound_t) {\n                 alt check ty::get(bound_t).struct {\n-                  ty::ty_iface(i, substs) { (i, substs) }\n+                  ty::ty_trait(i, substs) { (i, substs) }\n                 }\n               }\n             };\n \n-            let ifce_methods = ty::iface_methods(tcx, iid);\n+            let ifce_methods = ty::trait_methods(tcx, iid);\n             alt vec::position(*ifce_methods, |m| m.ident == self.m_name) {\n               none {\n                 /* check next bound */\n-                iface_bnd_idx += 1u;\n+                trait_bnd_idx += 1u;\n               }\n \n               some(pos) {\n                 // Replace any appearance of `self` with the type of the\n                 // generic parameter itself.  Note that this is the only case\n                 // where this replacement is necessary: in all other cases, we\n                 // are either invoking a method directly from an impl or class\n-                // (where the self type is not permitted), or from a iface\n+                // (where the self type is not permitted), or from a trait\n                 // type (in which case methods that refer to self are not\n                 // permitted).\n                 let substs = {self_ty: some(self.self_ty)\n                               with bound_substs};\n \n                 self.add_candidates_from_m(\n                     substs, ifce_methods[pos],\n-                    method_param({iface_id:iid,\n+                    method_param({trait_id:iid,\n                                   method_num:pos,\n                                   param_num:n,\n-                                  bound_num:iface_bnd_idx}));\n+                                  bound_num:trait_bnd_idx}));\n               }\n             }\n         }\n \n     }\n \n-    fn add_candidates_from_iface(did: ast::def_id, iface_substs: ty::substs) {\n+    fn add_candidates_from_trait(did: ast::def_id, trait_substs: ty::substs) {\n \n-        #debug[\"method_from_iface\"];\n+        #debug[\"method_from_trait\"];\n \n-        let ms = *ty::iface_methods(self.tcx(), did);\n+        let ms = *ty::trait_methods(self.tcx(), did);\n         for ms.eachi |i, m| {\n             if m.ident != self.m_name { cont; }\n \n@@ -226,25 +226,25 @@ class lookup {\n                 self.tcx().sess.span_err(\n                     self.expr.span,\n                     \"can not call a generic method through a \\\n-                     boxed iface\");\n+                     boxed trait\");\n             }\n \n             // Note: although it is illegal to invoke a method that uses self\n-            // through a iface instance, we use a dummy subst here so that we\n+            // through a trait instance, we use a dummy subst here so that we\n             // can soldier on with the compilation.\n             let substs = {self_ty: some(self.self_ty)\n-                          with iface_substs};\n+                          with trait_substs};\n \n             self.add_candidates_from_m(\n-                substs, m, method_iface(did, i));\n+                substs, m, method_trait(did, i));\n         }\n     }\n \n     fn add_candidates_from_class(did: ast::def_id, class_substs: ty::substs) {\n \n         #debug[\"method_from_class\"];\n \n-        let ms = *ty::iface_methods(self.tcx(), did);\n+        let ms = *ty::trait_methods(self.tcx(), did);\n \n         for ms.each |m| {\n             if m.ident != self.m_name { cont; }\n@@ -275,7 +275,7 @@ class lookup {\n         if did.crate == ast::local_crate {\n             alt check self.tcx().items.get(did.node) {\n               ast_map::node_method(m, _, _) {\n-                // NDM iface/impl regions\n+                // NDM trait/impl regions\n                 let mt = ty_of_method(self.fcx.ccx, m, ast::rp_none);\n                 ty::mk_fn(self.tcx(), {proto: ast::proto_box with mt.fty})\n               }"}, {"sha": "0c273808001b87903b18b104f0f78f586d4ce5a8", "filename": "src/rustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 48, "deletions": 48, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/33334f3c435926422d88dcd5bfafd5e32b141111/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33334f3c435926422d88dcd5bfafd5e32b141111/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=33334f3c435926422d88dcd5bfafd5e32b141111", "patch": "@@ -1,9 +1,9 @@\n import check::{fn_ctxt, impl_self_ty, methods};\n \n-fn has_iface_bounds(tps: ~[ty::param_bounds]) -> bool {\n+fn has_trait_bounds(tps: ~[ty::param_bounds]) -> bool {\n     vec::any(tps, |bs| {\n         vec::any(*bs, |b| {\n-            alt b { ty::bound_iface(_) { true } _ { false } }\n+            alt b { ty::bound_trait(_) { true } _ { false } }\n         })\n     })\n }\n@@ -16,7 +16,7 @@ fn lookup_vtables(fcx: @fn_ctxt, isc: resolve::iscopes, sp: span,\n     for substs.tps.each |ty| {\n         for vec::each(*bounds[i]) |bound| {\n             alt bound {\n-              ty::bound_iface(i_ty) {\n+              ty::bound_trait(i_ty) {\n                 let i_ty = ty::subst(tcx, substs, i_ty);\n                 vec::push(result, lookup_vtable(fcx, isc, sp, ty, i_ty,\n                                          allow_unsafe));\n@@ -33,33 +33,33 @@ fn fixup_substs(fcx: @fn_ctxt, sp: span,\n                 id: ast::def_id, substs: ty::substs) -> ty::substs {\n     let tcx = fcx.ccx.tcx;\n     // use a dummy type just to package up the substs that need fixing up\n-    let t = ty::mk_iface(tcx, id, substs);\n+    let t = ty::mk_trait(tcx, id, substs);\n     let t_f = fixup_ty(fcx, sp, t);\n     alt check ty::get(t_f).struct {\n-      ty::ty_iface(_, substs_f) { substs_f }\n+      ty::ty_trait(_, substs_f) { substs_f }\n     }\n }\n \n-fn relate_iface_tys(fcx: @fn_ctxt, sp: span,\n-                    exp_iface_ty: ty::t, act_iface_ty: ty::t) {\n-    demand::suptype(fcx, sp, exp_iface_ty, act_iface_ty)\n+fn relate_trait_tys(fcx: @fn_ctxt, sp: span,\n+                    exp_trait_ty: ty::t, act_trait_ty: ty::t) {\n+    demand::suptype(fcx, sp, exp_trait_ty, act_trait_ty)\n }\n \n /*\n Look up the vtable to use when treating an item of type <t>\n-as if it has type <iface_ty>\n+as if it has type <trait_ty>\n */\n fn lookup_vtable(fcx: @fn_ctxt, isc: resolve::iscopes, sp: span,\n-                 ty: ty::t, iface_ty: ty::t, allow_unsafe: bool)\n+                 ty: ty::t, trait_ty: ty::t, allow_unsafe: bool)\n     -> vtable_origin {\n \n-    #debug[\"lookup_vtable(ty=%s, iface_ty=%s)\",\n-           fcx.infcx.ty_to_str(ty), fcx.infcx.ty_to_str(iface_ty)];\n+    #debug[\"lookup_vtable(ty=%s, trait_ty=%s)\",\n+           fcx.infcx.ty_to_str(ty), fcx.infcx.ty_to_str(trait_ty)];\n     let _i = indenter();\n \n     let tcx = fcx.ccx.tcx;\n-    let (iface_id, iface_substs) = alt check ty::get(iface_ty).struct {\n-      ty::ty_iface(did, substs) { (did, substs) }\n+    let (trait_id, trait_substs) = alt check ty::get(trait_ty).struct {\n+      ty::ty_trait(did, substs) { (did, substs) }\n     };\n     let ty = fixup_ty(fcx, sp, ty);\n     alt ty::get(ty).struct {\n@@ -70,13 +70,13 @@ fn lookup_vtable(fcx: @fn_ctxt, isc: resolve::iscopes, sp: span,\n               ty::bound_send | ty::bound_copy | ty::bound_const {\n                 /* ignore */\n               }\n-              ty::bound_iface(ity) {\n+              ty::bound_trait(ity) {\n                 alt check ty::get(ity).struct {\n-                  ty::ty_iface(idid, substs) {\n-                    if iface_id == idid {\n-                        #debug(\"(checking vtable) @0 relating ty to iface ty\n+                  ty::ty_trait(idid, substs) {\n+                    if trait_id == idid {\n+                        #debug(\"(checking vtable) @0 relating ty to trait ty\n                                 with did %?\", idid);\n-                        relate_iface_tys(fcx, sp, iface_ty, ity);\n+                        relate_trait_tys(fcx, sp, trait_ty, ity);\n                         ret vtable_param(n, n_bound);\n                     }\n                   }\n@@ -87,13 +87,13 @@ fn lookup_vtable(fcx: @fn_ctxt, isc: resolve::iscopes, sp: span,\n         }\n       }\n \n-      ty::ty_iface(did, substs) if iface_id == did {\n-        #debug(\"(checking vtable) @1 relating ty to iface ty with did %?\",\n+      ty::ty_trait(did, substs) if trait_id == did {\n+        #debug(\"(checking vtable) @1 relating ty to trait ty with did %?\",\n                did);\n \n-        relate_iface_tys(fcx, sp, iface_ty, ty);\n+        relate_trait_tys(fcx, sp, trait_ty, ty);\n         if !allow_unsafe {\n-            for vec::each(*ty::iface_methods(tcx, did)) |m| {\n+            for vec::each(*ty::trait_methods(tcx, did)) |m| {\n                 if ty::type_has_self(ty::mk_fn(tcx, m.fty)) {\n                     tcx.sess.span_err(\n                         sp, \"a boxed iface with self types may not be \\\n@@ -106,7 +106,7 @@ fn lookup_vtable(fcx: @fn_ctxt, isc: resolve::iscopes, sp: span,\n                 }\n             }\n         }\n-        ret vtable_iface(did, substs.tps);\n+        ret vtable_trait(did, substs.tps);\n       }\n \n       _ {\n@@ -116,15 +116,15 @@ fn lookup_vtable(fcx: @fn_ctxt, isc: resolve::iscopes, sp: span,\n             /* For each impl in scope... */\n             for vec::each(*impls) |im| {\n                 // im = one specific impl\n-                // find the iface that im implements (if any)\n-                let of_ty = alt ty::impl_iface(tcx, im.did) {\n+                // find the trait that im implements (if any)\n+                let of_ty = alt ty::impl_trait(tcx, im.did) {\n                   some(of_ty) { of_ty }\n                   _ { cont; }\n                 };\n \n                 // it must have the same id as the expected one\n                 alt ty::get(of_ty).struct {\n-                  ty::ty_iface(id, _) if id != iface_id { cont; }\n+                  ty::ty_trait(id, _) if id != trait_id { cont; }\n                   _ { /* ok */ }\n                 }\n \n@@ -138,19 +138,19 @@ fn lookup_vtable(fcx: @fn_ctxt, isc: resolve::iscopes, sp: span,\n                   result::ok(()) { }\n                 }\n \n-                // check that desired iface type unifies\n-                #debug(\"(checking vtable) @2 relating iface ty %s to \\\n+                // check that desired trait type unifies\n+                #debug(\"(checking vtable) @2 relating trait ty %s to \\\n                         of_ty %s\",\n-                       fcx.infcx.ty_to_str(iface_ty),\n+                       fcx.infcx.ty_to_str(trait_ty),\n                        fcx.infcx.ty_to_str(of_ty));\n                 let of_ty = ty::subst(tcx, substs, of_ty);\n-                relate_iface_tys(fcx, sp, iface_ty, of_ty);\n+                relate_trait_tys(fcx, sp, trait_ty, of_ty);\n \n                 // recursively process the bounds\n-                let iface_tps = iface_substs.tps;\n-                let substs_f = fixup_substs(fcx, sp, iface_id, substs);\n-                connect_iface_tps(fcx, sp, substs_f.tps,\n-                                  iface_tps, im.did);\n+                let trait_tps = trait_substs.tps;\n+                let substs_f = fixup_substs(fcx, sp, trait_id, substs);\n+                connect_trait_tps(fcx, sp, substs_f.tps,\n+                                  trait_tps, im.did);\n                 let subres = lookup_vtables(fcx, isc, sp,\n                                             im_bs, substs_f, false);\n                 vec::push(found,\n@@ -172,7 +172,7 @@ fn lookup_vtable(fcx: @fn_ctxt, isc: resolve::iscopes, sp: span,\n \n     tcx.sess.span_fatal(\n         sp, \"failed to find an implementation of interface \" +\n-        ty_to_str(tcx, iface_ty) + \" for \" +\n+        ty_to_str(tcx, trait_ty) + \" for \" +\n         ty_to_str(tcx, ty));\n }\n \n@@ -190,16 +190,16 @@ fn fixup_ty(fcx: @fn_ctxt, sp: span, ty: ty::t) -> ty::t {\n     }\n }\n \n-fn connect_iface_tps(fcx: @fn_ctxt, sp: span, impl_tys: ~[ty::t],\n-                     iface_tys: ~[ty::t], impl_did: ast::def_id) {\n+fn connect_trait_tps(fcx: @fn_ctxt, sp: span, impl_tys: ~[ty::t],\n+                     trait_tys: ~[ty::t], impl_did: ast::def_id) {\n     let tcx = fcx.ccx.tcx;\n-    let ity = option::get(ty::impl_iface(tcx, impl_did));\n-    let iface_ty = ty::subst_tps(tcx, impl_tys, ity);\n-    #debug(\"(connect iface tps) iface type is %?, impl did is %?\",\n-           ty::get(iface_ty).struct, impl_did);\n-    alt check ty::get(iface_ty).struct {\n-      ty::ty_iface(_, substs) {\n-        vec::iter2(substs.tps, iface_tys,\n+    let ity = option::get(ty::impl_trait(tcx, impl_did));\n+    let trait_ty = ty::subst_tps(tcx, impl_tys, ity);\n+    #debug(\"(connect trait tps) trait type is %?, impl did is %?\",\n+           ty::get(trait_ty).struct, impl_did);\n+    alt check ty::get(trait_ty).struct {\n+      ty::ty_trait(_, substs) {\n+        vec::iter2(substs.tps, trait_tys,\n                    |a, b| demand::suptype(fcx, sp, a, b));\n       }\n     }\n@@ -213,7 +213,7 @@ fn resolve_expr(ex: @ast::expr, &&fcx: @fn_ctxt, v: visit::vt<@fn_ctxt>) {\n           some(substs) {\n             let did = ast_util::def_id_of_def(cx.tcx.def_map.get(ex.id));\n             let item_ty = ty::lookup_item_type(cx.tcx, did);\n-            if has_iface_bounds(*item_ty.bounds) {\n+            if has_trait_bounds(*item_ty.bounds) {\n                 let impls = cx.impl_map.get(ex.id);\n                 cx.vtable_map.insert(ex.id, lookup_vtables(\n                     fcx, impls, ex.span,\n@@ -230,7 +230,7 @@ fn resolve_expr(ex: @ast::expr, &&fcx: @fn_ctxt, v: visit::vt<@fn_ctxt>) {\n         alt cx.method_map.find(ex.id) {\n           some({origin: method_static(did), _}) {\n             let bounds = ty::lookup_item_type(cx.tcx, did).bounds;\n-            if has_iface_bounds(*bounds) {\n+            if has_trait_bounds(*bounds) {\n                 let callee_id = alt ex.node {\n                   ast::expr_field(_, _, _) { ex.id }\n                   _ { ast_util::op_expr_callee_id(ex) }\n@@ -247,7 +247,7 @@ fn resolve_expr(ex: @ast::expr, &&fcx: @fn_ctxt, v: visit::vt<@fn_ctxt>) {\n       ast::expr_cast(src, _) {\n         let target_ty = fcx.expr_ty(ex);\n         alt ty::get(target_ty).struct {\n-          ty::ty_iface(*) {\n+          ty::ty_trait(*) {\n             /* Casting to an interface type.\n             Look up all impls for the cast expr...\n             */"}, {"sha": "16423bbd8d8f725876edd42be55a4eb889a64737", "filename": "src/rustc/middle/typeck/collect.rs", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/33334f3c435926422d88dcd5bfafd5e32b141111/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33334f3c435926422d88dcd5bfafd5e32b141111/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=33334f3c435926422d88dcd5bfafd5e32b141111", "patch": "@@ -34,12 +34,12 @@ fn collect_item_types(ccx: @crate_ctxt, crate: @ast::crate) {\n               ast::item_mod(m) {\n                 for m.items.each |intrinsic_item| {\n                     alt intrinsic_item.node {\n-                      ast::item_iface(_, _, _) {\n+                      ast::item_trait(_, _, _) {\n                         let def_id = { crate: ast::local_crate,\n                                       node: intrinsic_item.id };\n                         let substs = {self_r: none, self_ty: none, tps: ~[]};\n-                        let ty = ty::mk_iface(ccx.tcx, def_id, substs);\n-                        ccx.tcx.intrinsic_ifaces.insert\n+                        let ty = ty::mk_trait(ccx.tcx, def_id, substs);\n+                        ccx.tcx.intrinsic_traits.insert\n                             (intrinsic_item.ident, (def_id, ty));\n                       }\n                       _ { }\n@@ -128,15 +128,15 @@ fn get_enum_variant_types(ccx: @crate_ctxt,\n     }\n }\n \n-fn ensure_iface_methods(ccx: @crate_ctxt, id: ast::node_id) {\n+fn ensure_trait_methods(ccx: @crate_ctxt, id: ast::node_id) {\n     fn store_methods<T>(ccx: @crate_ctxt, id: ast::node_id,\n                         stuff: ~[T], f: fn@(T) -> ty::method) {\n-        ty::store_iface_methods(ccx.tcx, id, @vec::map(stuff, f));\n+        ty::store_trait_methods(ccx.tcx, id, @vec::map(stuff, f));\n     }\n \n     let tcx = ccx.tcx;\n     alt check tcx.items.get(id) {\n-      ast_map::node_item(@{node: ast::item_iface(_, rp, ms), _}, _) {\n+      ast_map::node_item(@{node: ast::item_trait(_, rp, ms), _}, _) {\n         store_methods::<ast::ty_method>(ccx, id, ms, |m| {\n             ty_of_ty_method(ccx, m, rp)\n         });\n@@ -154,14 +154,14 @@ fn ensure_iface_methods(ccx: @crate_ctxt, id: ast::node_id) {\n \n /**\n  * Checks that a method from an impl/class conforms to the signature of\n- * the same method as declared in the iface.\n+ * the same method as declared in the trait.\n  *\n  * # Parameters\n  *\n  * - impl_m: the method in the impl\n  * - impl_tps: the type params declared on the impl itself (not the method!)\n- * - if_m: the method in the iface\n- * - if_substs: the substitutions used on the type of the iface\n+ * - if_m: the method in the trait\n+ * - if_substs: the substitutions used on the type of the trait\n  * - self_ty: the self type of the impl\n  */\n fn compare_impl_method(tcx: ty::ctxt, sp: span,\n@@ -184,10 +184,10 @@ fn compare_impl_method(tcx: ty::ctxt, sp: span,\n         ret;\n     }\n \n-    // Perform substitutions so that the iface/impl methods are expressed\n+    // Perform substitutions so that the trait/impl methods are expressed\n     // in terms of the same set of type/region parameters:\n-    // - replace iface type parameters with those from `if_substs`\n-    // - replace method parameters on the iface with fresh, dummy parameters\n+    // - replace trait type parameters with those from `if_substs`\n+    // - replace method parameters on the trait with fresh, dummy parameters\n     //   that correspond to the parameters we will find on the impl\n     // - replace self region with a fresh, dummy region\n     let dummy_self_r = ty::re_free(0, ty::br_self);\n@@ -223,25 +223,25 @@ fn compare_impl_method(tcx: ty::ctxt, sp: span,\n     }\n }\n \n-fn check_methods_against_iface(ccx: @crate_ctxt,\n+fn check_methods_against_trait(ccx: @crate_ctxt,\n                                tps: ~[ast::ty_param],\n                                rp: ast::region_param,\n                                selfty: ty::t,\n-                               a_ifacety: @ast::iface_ref,\n+                               a_trait_ty: @ast::trait_ref,\n                                ms: ~[converted_method]) {\n \n     let tcx = ccx.tcx;\n-    let (did, tpt) = instantiate_iface_ref(ccx, a_ifacety, rp);\n+    let (did, tpt) = instantiate_trait_ref(ccx, a_trait_ty, rp);\n     if did.crate == ast::local_crate {\n-        ensure_iface_methods(ccx, did.node);\n+        ensure_trait_methods(ccx, did.node);\n     }\n-    for vec::each(*ty::iface_methods(tcx, did)) |if_m| {\n+    for vec::each(*ty::trait_methods(tcx, did)) |if_m| {\n         alt vec::find(ms, |m| if_m.ident == m.mty.ident) {\n           some({mty: m, id, span}) {\n             if m.purity != if_m.purity {\n                 ccx.tcx.sess.span_err(\n                     span, #fmt[\"method `%s`'s purity \\\n-                                not match the iface method's \\\n+                                not match the trait method's \\\n                                 purity\", *m.ident]);\n             }\n             compare_impl_method(\n@@ -250,7 +250,7 @@ fn check_methods_against_iface(ccx: @crate_ctxt,\n           }\n           none {\n             tcx.sess.span_err(\n-                a_ifacety.path.span,\n+                a_trait_ty.path.span,\n                 #fmt[\"missing method `%s`\", *if_m.ident]);\n           }\n         } // alt\n@@ -314,17 +314,17 @@ fn convert(ccx: @crate_ctxt, it: @ast::item) {\n \n         let cms = convert_methods(ccx, ms, rp, i_bounds, selfty);\n         for ifce.each |t| {\n-            check_methods_against_iface(ccx, tps, rp, selfty, t, cms);\n+            check_methods_against_trait(ccx, tps, rp, selfty, t, cms);\n         }\n       }\n-      ast::item_iface(*) {\n+      ast::item_trait(*) {\n         let tpt = ty_of_item(ccx, it);\n-        #debug[\"item_iface(it.id=%d, tpt.ty=%s)\",\n+        #debug[\"item_trait(it.id=%d, tpt.ty=%s)\",\n                it.id, ty_to_str(tcx, tpt.ty)];\n         write_ty_to_tcx(tcx, it.id, tpt.ty);\n-        ensure_iface_methods(ccx, it.id);\n+        ensure_trait_methods(ccx, it.id);\n       }\n-      ast::item_class(tps, ifaces, members, ctor, m_dtor, rp) {\n+      ast::item_class(tps, traits, members, ctor, m_dtor, rp) {\n         // Write the class type\n         let tpt = ty_of_item(ccx, it);\n         write_ty_to_tcx(tcx, it.id, tpt.ty);\n@@ -362,7 +362,7 @@ fn convert(ccx: @crate_ctxt, it: @ast::item) {\n                                rp: rp,\n                                ty: t_dtor});\n         };\n-        ensure_iface_methods(ccx, it.id);\n+        ensure_trait_methods(ccx, it.id);\n \n         // Write the type of each of the members\n         let (fields, methods) = split_class_items(members);\n@@ -372,16 +372,16 @@ fn convert(ccx: @crate_ctxt, it: @ast::item) {\n         let {bounds, substs} = mk_substs(ccx, tps, rp);\n         let selfty = ty::mk_class(tcx, local_def(it.id), substs);\n         let cms = convert_methods(ccx, methods, rp, bounds, selfty);\n-        for ifaces.each |ifce| {\n-            check_methods_against_iface(ccx, tps, rp, selfty, ifce, cms);\n+        for traits.each |ifce| {\n+            check_methods_against_trait(ccx, tps, rp, selfty, ifce, cms);\n \n             // FIXME #2434---this is somewhat bogus, but it seems that\n-            // the id of iface_ref is also the id of the impl, and so\n+            // the id of trait_ref is also the id of the impl, and so\n             // we want to store the \"self type\" of the impl---in this\n             // case, the class.  The reason I say this is somewhat\n             // bogus (and should be refactored) is that the tcache\n             // stores the class type for ifce.id but the node_type\n-            // table stores the iface type. Weird. Probably just\n+            // table stores the trait type. Weird. Probably just\n             // adding a \"self type\" table rather than overloading the\n             // tcache would be ok, or else adding more than one id.\n             tcx.tcache.insert(local_def(ifce.id), tpt);\n@@ -427,16 +427,16 @@ fn ty_of_ty_method(self: @crate_ctxt,\n      tps: ty_param_bounds(self, m.tps),\n      fty: ty_of_fn_decl(self, type_rscope(rp), ast::proto_bare,\n                                  m.decl, none),\n-     // assume public, because this is only invoked on iface methods\n+     // assume public, because this is only invoked on trait methods\n      purity: m.decl.purity, vis: ast::public}\n }\n \n /*\n-  Instantiates the path for the given iface reference, assuming that\n-  it's bound to a valid iface type. Returns the def_id for the defining\n-  iface. Fails if the type is a type other than an iface type.\n+  Instantiates the path for the given trait reference, assuming that\n+  it's bound to a valid trait type. Returns the def_id for the defining\n+  trait. Fails if the type is a type other than an trait type.\n  */\n-fn instantiate_iface_ref(ccx: @crate_ctxt, t: @ast::iface_ref,\n+fn instantiate_trait_ref(ccx: @crate_ctxt, t: @ast::trait_ref,\n                          rp: ast::region_param)\n     -> (ast::def_id, ty_param_substs_and_ty) {\n \n@@ -449,7 +449,7 @@ fn instantiate_iface_ref(ccx: @crate_ctxt, t: @ast::iface_ref,\n       ast::def_ty(t_id) {\n         let tpt = astconv::ast_path_to_ty(ccx, rscope, t_id, t.path, t.id);\n         alt ty::get(tpt.ty).struct {\n-           ty::ty_iface(*) {\n+           ty::ty_trait(*) {\n               (t_id, tpt)\n            }\n            _ { sess.span_fatal(sp, err); }\n@@ -520,9 +520,9 @@ fn ty_of_item(ccx: @crate_ctxt, it: @ast::item)\n         tcx.tcache.insert(local_def(it.id), tpt);\n         ret tpt;\n       }\n-      ast::item_iface(tps, rp, ms) {\n+      ast::item_trait(tps, rp, ms) {\n         let {bounds, substs} = mk_substs(ccx, tps, rp);\n-        let t = ty::mk_iface(tcx, local_def(it.id), substs);\n+        let t = ty::mk_trait(tcx, local_def(it.id), substs);\n         let tpt = {bounds: bounds, rp: rp, ty: t};\n         tcx.tcache.insert(local_def(it.id), tpt);\n         ret tpt;\n@@ -558,11 +558,11 @@ fn ty_param_bounds(ccx: @crate_ctxt,\n               ast::bound_send { ~[ty::bound_send] }\n               ast::bound_copy { ~[ty::bound_copy] }\n               ast::bound_const { ~[ty::bound_const] }\n-              ast::bound_iface(t) {\n+              ast::bound_trait(t) {\n                 let ity = ast_ty_to_ty(ccx, empty_rscope, t);\n                 alt ty::get(ity).struct {\n-                  ty::ty_iface(*) {\n-                    ~[ty::bound_iface(ity)]\n+                  ty::ty_trait(*) {\n+                    ~[ty::bound_trait(ity)]\n                   }\n                   _ {\n                     ccx.tcx.sess.span_err("}, {"sha": "bdcc3dea7fb76dee856a0f6b9bb1c21af0219461", "filename": "src/rustc/middle/typeck/infer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/33334f3c435926422d88dcd5bfafd5e32b141111/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33334f3c435926422d88dcd5bfafd5e32b141111/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs?ref=33334f3c435926422d88dcd5bfafd5e32b141111", "patch": "@@ -1781,10 +1781,10 @@ fn super_tys<C:combine>(\n         }\n       }\n \n-      (ty::ty_iface(a_id, a_substs), ty::ty_iface(b_id, b_substs))\n+      (ty::ty_trait(a_id, a_substs), ty::ty_trait(b_id, b_substs))\n       if a_id == b_id {\n         do self.substs(a_substs, b_substs).chain |substs| {\n-            ok(ty::mk_iface(tcx, a_id, substs))\n+            ok(ty::mk_trait(tcx, a_id, substs))\n         }\n       }\n "}, {"sha": "c8238d6b05704775f05ab3309df711ea798d8b12", "filename": "src/rustc/util/ppaux.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/33334f3c435926422d88dcd5bfafd5e32b141111/src%2Frustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33334f3c435926422d88dcd5bfafd5e32b141111/src%2Frustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Futil%2Fppaux.rs?ref=33334f3c435926422d88dcd5bfafd5e32b141111", "patch": "@@ -4,7 +4,7 @@ import middle::ty::{arg, bound_region, br_anon, br_named, canon_mode};\n import middle::ty::{ck_block, ck_box, ck_uniq, constr, ctxt, field, method};\n import middle::ty::{mt, re_bound, re_free, re_scope, re_var, region, t};\n import middle::ty::{ty_bool, ty_bot, ty_box, ty_class, ty_constr, ty_enum};\n-import middle::ty::{ty_estr, ty_evec, ty_float, ty_fn, ty_iface, ty_int};\n+import middle::ty::{ty_estr, ty_evec, ty_float, ty_fn, ty_trait, ty_int};\n import middle::ty::{ty_nil, ty_opaque_box, ty_opaque_closure_ptr, ty_param};\n import middle::ty::{ty_ptr, ty_rec, ty_rptr, ty_self, ty_str, ty_tup};\n import middle::ty::{ty_type, ty_uniq, ty_uint, ty_var, ty_var_integral};\n@@ -213,7 +213,7 @@ fn ty_to_str(cx: ctxt, typ: t) -> str {\n         let base = ast_map::path_to_str(path);\n         parameterized(cx, base, substs.self_r, substs.tps)\n       }\n-      ty_iface(did, substs) {\n+      ty_trait(did, substs) {\n         let path = ty::item_path(cx, did);\n         let base = ast_map::path_to_str(path);\n         parameterized(cx, base, substs.self_r, substs.tps)"}, {"sha": "00124bcc2a408cf73060dd7bb8168a99274510e5", "filename": "src/rustdoc/attr_pass.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/33334f3c435926422d88dcd5bfafd5e32b141111/src%2Frustdoc%2Fattr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33334f3c435926422d88dcd5bfafd5e32b141111/src%2Frustdoc%2Fattr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fattr_pass.rs?ref=33334f3c435926422d88dcd5bfafd5e32b141111", "patch": "@@ -27,7 +27,7 @@ fn run(\n         fold_crate: fold_crate,\n         fold_item: fold_item,\n         fold_enum: fold_enum,\n-        fold_iface: fold_iface,\n+        fold_trait: fold_trait,\n         fold_impl: fold_impl\n         with *fold::default_any_fold(srv)\n     });\n@@ -181,12 +181,12 @@ fn should_extract_variant_docs() {\n     assert doc.cratemod().enums()[0].variants[0].desc == some(\"c\");\n }\n \n-fn fold_iface(\n+fn fold_trait(\n     fold: fold::fold<astsrv::srv>,\n-    doc: doc::ifacedoc\n-) -> doc::ifacedoc {\n+    doc: doc::traitdoc\n+) -> doc::traitdoc {\n     let srv = fold.ctxt;\n-    let doc = fold::default_seq_fold_iface(fold, doc);\n+    let doc = fold::default_seq_fold_trait(fold, doc);\n \n     {\n         methods: merge_method_attrs(srv, doc.id(), doc.methods)\n@@ -204,7 +204,7 @@ fn merge_method_attrs(\n     let attrs: ~[(str, option<str>)] = do astsrv::exec(srv) |ctxt| {\n         alt ctxt.ast_map.get(item_id) {\n           ast_map::node_item(@{\n-            node: ast::item_iface(_, _, methods), _\n+            node: ast::item_trait(_, _, methods), _\n           }, _) {\n             par::seqmap(methods, |method| {\n                 (*method.ident, attr_parser::parse_desc(method.attrs))\n@@ -233,19 +233,19 @@ fn merge_method_attrs(\n }\n \n #[test]\n-fn should_extract_iface_docs() {\n+fn should_extract_trait_docs() {\n     let doc = test::mk_doc(\"#[doc = \\\"whatever\\\"] iface i { fn a(); }\");\n-    assert doc.cratemod().ifaces()[0].desc() == some(\"whatever\");\n+    assert doc.cratemod().traits()[0].desc() == some(\"whatever\");\n }\n \n #[test]\n-fn should_extract_iface_method_docs() {\n+fn should_extract_trait_method_docs() {\n     let doc = test::mk_doc(\n         \"iface i {\\\n          #[doc = \\\"desc\\\"]\\\n          fn f(a: bool) -> bool;\\\n          }\");\n-    assert doc.cratemod().ifaces()[0].methods[0].desc == some(\"desc\");\n+    assert doc.cratemod().traits()[0].methods[0].desc == some(\"desc\");\n }\n \n "}, {"sha": "e70cdb4187262025669be9f8bfdbf322ca7a25e7", "filename": "src/rustdoc/desc_to_brief_pass.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/33334f3c435926422d88dcd5bfafd5e32b141111/src%2Frustdoc%2Fdesc_to_brief_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33334f3c435926422d88dcd5bfafd5e32b141111/src%2Frustdoc%2Fdesc_to_brief_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fdesc_to_brief_pass.rs?ref=33334f3c435926422d88dcd5bfafd5e32b141111", "patch": "@@ -20,7 +20,7 @@ fn run(\n ) -> doc::doc {\n     let fold = fold::fold({\n         fold_item: fold_item,\n-        fold_iface: fold_iface,\n+        fold_trait: fold_trait,\n         fold_impl: fold_impl\n         with *fold::default_any_fold(())\n     });\n@@ -36,8 +36,8 @@ fn fold_item(fold: fold::fold<()>, doc: doc::itemdoc) -> doc::itemdoc {\n     }\n }\n \n-fn fold_iface(fold: fold::fold<()>, doc: doc::ifacedoc) -> doc::ifacedoc {\n-    let doc =fold::default_seq_fold_iface(fold, doc);\n+fn fold_trait(fold: fold::fold<()>, doc: doc::traitdoc) -> doc::traitdoc {\n+    let doc =fold::default_seq_fold_trait(fold, doc);\n \n     {\n         methods: par::anymap(doc.methods, |doc| {\n@@ -67,9 +67,9 @@ fn should_promote_desc() {\n }\n \n #[test]\n-fn should_promote_iface_method_desc() {\n+fn should_promote_trait_method_desc() {\n     let doc = test::mk_doc(\"iface i { #[doc = \\\"desc\\\"] fn a(); }\");\n-    assert doc.cratemod().ifaces()[0].methods[0].brief == some(\"desc\");\n+    assert doc.cratemod().traits()[0].methods[0].brief == some(\"desc\");\n }\n \n #[test]"}, {"sha": "facd84c7a310f6b033677b7538c0c0e8487a4869", "filename": "src/rustdoc/doc.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/33334f3c435926422d88dcd5bfafd5e32b141111/src%2Frustdoc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33334f3c435926422d88dcd5bfafd5e32b141111/src%2Frustdoc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fdoc.rs?ref=33334f3c435926422d88dcd5bfafd5e32b141111", "patch": "@@ -33,7 +33,7 @@ enum itemtag {\n     consttag(constdoc),\n     fntag(fndoc),\n     enumtag(enumdoc),\n-    ifacetag(ifacedoc),\n+    traittag(traitdoc),\n     impltag(impldoc),\n     tytag(tydoc)\n }\n@@ -81,7 +81,7 @@ type variantdoc = {\n     sig: option<str>\n };\n \n-type ifacedoc = {\n+type traitdoc = {\n     item: itemdoc,\n     methods: ~[methoddoc]\n };\n@@ -96,7 +96,7 @@ type methoddoc = {\n \n type impldoc = {\n     item: itemdoc,\n-    iface_ty: option<str>,\n+    trait_ty: option<str>,\n     self_ty: option<str>,\n     methods: ~[methoddoc]\n };\n@@ -187,10 +187,10 @@ impl util for moddoc {\n         }\n     }\n \n-    fn ifaces() -> ~[ifacedoc] {\n+    fn traits() -> ~[traitdoc] {\n         do vec::filter_map(self.items) |itemtag| {\n             alt itemtag {\n-              ifacetag(ifacedoc) { some(ifacedoc) }\n+              traittag(traitdoc) { some(traitdoc) }\n               _ { none }\n             }\n         }\n@@ -262,10 +262,10 @@ impl util for ~[page] {\n         }\n     }\n \n-    fn ifaces() -> ~[ifacedoc] {\n+    fn traits() -> ~[traitdoc] {\n         do vec::filter_map(self) |page| {\n             alt page {\n-              itempage(ifacetag(ifacedoc)) { some(ifacedoc) }\n+              itempage(traittag(traitdoc)) { some(traitdoc) }\n               _ { none }\n             }\n         }\n@@ -302,7 +302,7 @@ impl of item for itemtag {\n           doc::fntag(doc) { doc.item }\n           doc::consttag(doc) { doc.item }\n           doc::enumtag(doc) { doc.item }\n-          doc::ifacetag(doc) { doc.item }\n+          doc::traittag(doc) { doc.item }\n           doc::impltag(doc) { doc.item }\n           doc::tytag(doc) { doc.item }\n         }\n@@ -325,7 +325,7 @@ impl of item for enumdoc {\n     fn item() -> itemdoc { self.item }\n }\n \n-impl of item for ifacedoc {\n+impl of item for traitdoc {\n     fn item() -> itemdoc { self.item }\n }\n "}, {"sha": "60402288ecf9d00814896c877e44362116ad4676", "filename": "src/rustdoc/extract.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/33334f3c435926422d88dcd5bfafd5e32b141111/src%2Frustdoc%2Fextract.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33334f3c435926422d88dcd5bfafd5e32b141111/src%2Frustdoc%2Fextract.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fextract.rs?ref=33334f3c435926422d88dcd5bfafd5e32b141111", "patch": "@@ -83,9 +83,9 @@ fn moddoc_from_mod(\n                     enumdoc_from_enum(itemdoc, variants)\n                 ))\n               }\n-              ast::item_iface(_, _, methods) {\n-                some(doc::ifacetag(\n-                    ifacedoc_from_iface(itemdoc, methods)\n+              ast::item_trait(_, _, methods) {\n+                some(doc::traittag(\n+                    traitdoc_from_trait(itemdoc, methods)\n                 ))\n               }\n               ast::item_impl(_, _, _, _, methods) {\n@@ -183,10 +183,10 @@ fn should_extract_enum_variants() {\n     assert doc.cratemod().enums()[0].variants[0].name == \"v\";\n }\n \n-fn ifacedoc_from_iface(\n+fn traitdoc_from_trait(\n     itemdoc: doc::itemdoc,\n     methods: ~[ast::ty_method]\n-) -> doc::ifacedoc {\n+) -> doc::traitdoc {\n     {\n         item: itemdoc,\n         methods: do par::seqmap(methods) |method| {\n@@ -202,15 +202,15 @@ fn ifacedoc_from_iface(\n }\n \n #[test]\n-fn should_extract_ifaces() {\n-    let doc = test::mk_doc(\"iface i { fn f(); }\");\n-    assert doc.cratemod().ifaces()[0].name() == \"i\";\n+fn should_extract_traits() {\n+    let doc = test::mk_doc(\"trait i { fn f(); }\");\n+    assert doc.cratemod().traits()[0].name() == \"i\";\n }\n \n #[test]\n-fn should_extract_iface_methods() {\n-    let doc = test::mk_doc(\"iface i { fn f(); }\");\n-    assert doc.cratemod().ifaces()[0].methods[0].name == \"f\";\n+fn should_extract_trait_methods() {\n+    let doc = test::mk_doc(\"trait i { fn f(); }\");\n+    assert doc.cratemod().traits()[0].methods[0].name == \"f\";\n }\n \n fn impldoc_from_impl(\n@@ -219,7 +219,7 @@ fn impldoc_from_impl(\n ) -> doc::impldoc {\n     {\n         item: itemdoc,\n-        iface_ty: none,\n+        trait_ty: none,\n         self_ty: none,\n         methods: do par::seqmap(methods) |method| {\n             {"}, {"sha": "be24edf22b65aba20d8adc6951f1e7a64259202d", "filename": "src/rustdoc/fold.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/33334f3c435926422d88dcd5bfafd5e32b141111/src%2Frustdoc%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33334f3c435926422d88dcd5bfafd5e32b141111/src%2Frustdoc%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Ffold.rs?ref=33334f3c435926422d88dcd5bfafd5e32b141111", "patch": "@@ -8,7 +8,7 @@ export default_seq_fold_nmod;\n export default_seq_fold_fn;\n export default_seq_fold_const;\n export default_seq_fold_enum;\n-export default_seq_fold_iface;\n+export default_seq_fold_trait;\n export default_seq_fold_impl;\n export default_seq_fold_type;\n export default_par_fold;\n@@ -28,7 +28,7 @@ type fold_nmod<T> = fn~(fold: fold<T>, doc: doc::nmoddoc) -> doc::nmoddoc;\n type fold_fn<T> = fn~(fold: fold<T>, doc: doc::fndoc) -> doc::fndoc;\n type fold_const<T> = fn~(fold: fold<T>, doc: doc::constdoc) -> doc::constdoc;\n type fold_enum<T> = fn~(fold: fold<T>, doc: doc::enumdoc) -> doc::enumdoc;\n-type fold_iface<T> = fn~(fold: fold<T>, doc: doc::ifacedoc) -> doc::ifacedoc;\n+type fold_trait<T> = fn~(fold: fold<T>, doc: doc::traitdoc) -> doc::traitdoc;\n type fold_impl<T> = fn~(fold: fold<T>, doc: doc::impldoc) -> doc::impldoc;\n type fold_type<T> = fn~(fold: fold<T>, doc: doc::tydoc) -> doc::tydoc;\n \n@@ -42,7 +42,7 @@ type t<T> = {\n     fold_fn: fold_fn<T>,\n     fold_const: fold_const<T>,\n     fold_enum: fold_enum<T>,\n-    fold_iface: fold_iface<T>,\n+    fold_trait: fold_trait<T>,\n     fold_impl: fold_impl<T>,\n     fold_type: fold_type<T>\n };\n@@ -60,7 +60,7 @@ fn mk_fold<T:copy>(\n     +fold_fn: fold_fn<T>,\n     +fold_const: fold_const<T>,\n     +fold_enum: fold_enum<T>,\n-    +fold_iface: fold_iface<T>,\n+    +fold_trait: fold_trait<T>,\n     +fold_impl: fold_impl<T>,\n     +fold_type: fold_type<T>\n ) -> fold<T> {\n@@ -74,7 +74,7 @@ fn mk_fold<T:copy>(\n         fold_fn: fold_fn,\n         fold_const: fold_const,\n         fold_enum: fold_enum,\n-        fold_iface: fold_iface,\n+        fold_trait: fold_trait,\n         fold_impl: fold_impl,\n         fold_type: fold_type\n     })\n@@ -91,7 +91,7 @@ fn default_any_fold<T:send copy>(ctxt: T) -> fold<T> {\n         |f, d| default_seq_fold_fn(f, d),\n         |f, d| default_seq_fold_const(f, d),\n         |f, d| default_seq_fold_enum(f, d),\n-        |f, d| default_seq_fold_iface(f, d),\n+        |f, d| default_seq_fold_trait(f, d),\n         |f, d| default_seq_fold_impl(f, d),\n         |f, d| default_seq_fold_type(f, d)\n     )\n@@ -108,7 +108,7 @@ fn default_seq_fold<T:copy>(ctxt: T) -> fold<T> {\n         |f, d| default_seq_fold_fn(f, d),\n         |f, d| default_seq_fold_const(f, d),\n         |f, d| default_seq_fold_enum(f, d),\n-        |f, d| default_seq_fold_iface(f, d),\n+        |f, d| default_seq_fold_trait(f, d),\n         |f, d| default_seq_fold_impl(f, d),\n         |f, d| default_seq_fold_type(f, d)\n     )\n@@ -125,7 +125,7 @@ fn default_par_fold<T:send copy>(ctxt: T) -> fold<T> {\n         |f, d| default_seq_fold_fn(f, d),\n         |f, d| default_seq_fold_const(f, d),\n         |f, d| default_seq_fold_enum(f, d),\n-        |f, d| default_seq_fold_iface(f, d),\n+        |f, d| default_seq_fold_trait(f, d),\n         |f, d| default_seq_fold_impl(f, d),\n         |f, d| default_seq_fold_type(f, d)\n     )\n@@ -258,8 +258,8 @@ fn fold_itemtag<T>(fold: fold<T>, doc: doc::itemtag) -> doc::itemtag {\n       doc::enumtag(enumdoc) {\n         doc::enumtag(fold.fold_enum(fold, enumdoc))\n       }\n-      doc::ifacetag(ifacedoc) {\n-        doc::ifacetag(fold.fold_iface(fold, ifacedoc))\n+      doc::traittag(traitdoc) {\n+        doc::traittag(fold.fold_trait(fold, traitdoc))\n       }\n       doc::impltag(impldoc) {\n         doc::impltag(fold.fold_impl(fold, impldoc))\n@@ -300,10 +300,10 @@ fn default_seq_fold_enum<T>(\n     }\n }\n \n-fn default_seq_fold_iface<T>(\n+fn default_seq_fold_trait<T>(\n     fold: fold<T>,\n-    doc: doc::ifacedoc\n-) -> doc::ifacedoc {\n+    doc: doc::traitdoc\n+) -> doc::traitdoc {\n     {\n         item: fold.fold_item(fold, doc.item)\n         with doc"}, {"sha": "10869161e8a29b28f9bcb6bce5385d24d9efcce0", "filename": "src/rustdoc/markdown_pass.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/33334f3c435926422d88dcd5bfafd5e32b141111/src%2Frustdoc%2Fmarkdown_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33334f3c435926422d88dcd5bfafd5e32b141111/src%2Frustdoc%2Fmarkdown_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fmarkdown_pass.rs?ref=33334f3c435926422d88dcd5bfafd5e32b141111", "patch": "@@ -198,7 +198,7 @@ fn header_kind(doc: doc::itemtag) -> str {\n       doc::enumtag(_) {\n         \"Enum\"\n       }\n-      doc::ifacetag(_) {\n+      doc::traittag(_) {\n         \"Interface\"\n       }\n       doc::impltag(doc) {\n@@ -222,9 +222,9 @@ fn header_name(doc: doc::itemtag) -> str {\n       doc::impltag(doc) {\n         assert option::is_some(doc.self_ty);\n         let self_ty = option::get(doc.self_ty);\n-        alt doc.iface_ty {\n-          some(iface_ty) {\n-            #fmt(\"%s of %s for %s\", doc.name(), iface_ty, self_ty)\n+        alt doc.trait_ty {\n+          some(trait_ty) {\n+            #fmt(\"%s of %s for %s\", doc.name(), trait_ty, self_ty)\n           }\n           none {\n             #fmt(\"%s for %s\", doc.name(), self_ty)\n@@ -349,7 +349,7 @@ fn write_item_(ctxt: ctxt, doc: doc::itemtag, write_header: bool) {\n       doc::fntag(fndoc) { write_fn(ctxt, fndoc) }\n       doc::consttag(constdoc) { write_const(ctxt, constdoc) }\n       doc::enumtag(enumdoc) { write_enum(ctxt, enumdoc) }\n-      doc::ifacetag(ifacedoc) { write_iface(ctxt, ifacedoc) }\n+      doc::traittag(traitdoc) { write_trait(ctxt, traitdoc) }\n       doc::impltag(impldoc) { write_impl(ctxt, impldoc) }\n       doc::tytag(tydoc) { write_type(ctxt, tydoc) }\n     }\n@@ -639,7 +639,7 @@ fn should_write_variant_list_with_signatures() {\n          \\n* `c(int)` - a\\n\\n\");\n }\n \n-fn write_iface(ctxt: ctxt, doc: doc::ifacedoc) {\n+fn write_trait(ctxt: ctxt, doc: doc::traitdoc) {\n     write_common(ctxt, doc.desc(), doc.sections());\n     write_methods(ctxt, doc.methods);\n }\n@@ -659,27 +659,27 @@ fn write_method(ctxt: ctxt, doc: doc::methoddoc) {\n }\n \n #[test]\n-fn should_write_iface_header() {\n+fn should_write_trait_header() {\n     let markdown = test::render(\"iface i { fn a(); }\");\n     assert str::contains(markdown, \"## Interface `i`\");\n }\n \n #[test]\n-fn should_write_iface_desc() {\n+fn should_write_trait_desc() {\n     let markdown = test::render(\n         \"#[doc = \\\"desc\\\"] iface i { fn a(); }\");\n     assert str::contains(markdown, \"desc\");\n }\n \n #[test]\n-fn should_write_iface_method_header() {\n+fn should_write_trait_method_header() {\n     let markdown = test::render(\n         \"iface i { fn a(); }\");\n     assert str::contains(markdown, \"### Method `a`\");\n }\n \n #[test]\n-fn should_write_iface_method_signature() {\n+fn should_write_trait_method_signature() {\n     let markdown = test::render(\n         \"iface i { fn a(); }\");\n     assert str::contains(markdown, \"\\n    fn a()\");\n@@ -697,7 +697,7 @@ fn should_write_impl_header() {\n }\n \n #[test]\n-fn should_write_impl_header_with_iface() {\n+fn should_write_impl_header_with_trait() {\n     let markdown = test::render(\"impl i of j for int { fn a() { } }\");\n     assert str::contains(markdown, \"## Implementation `i of j for int`\");\n }"}, {"sha": "b6cafbd0adeb45bbc3e7333a9d7c9b2e87411d52", "filename": "src/rustdoc/prune_unexported_pass.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/33334f3c435926422d88dcd5bfafd5e32b141111/src%2Frustdoc%2Fprune_unexported_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33334f3c435926422d88dcd5bfafd5e32b141111/src%2Frustdoc%2Fprune_unexported_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fprune_unexported_pass.rs?ref=33334f3c435926422d88dcd5bfafd5e32b141111", "patch": "@@ -202,9 +202,9 @@ fn should_prune_unexported_variants() {\n }\n \n #[test]\n-fn should_prune_unexported_ifaces_from_top_mod() {\n+fn should_prune_unexported_traits_from_top_mod() {\n     let doc = test::mk_doc(\"export a; mod a { } iface b { fn c(); }\");\n-    assert vec::is_empty(doc.cratemod().ifaces());\n+    assert vec::is_empty(doc.cratemod().traits());\n }\n \n #[test]"}, {"sha": "354035b6f56fbb0cc23af5a099187d546c1b82fc", "filename": "src/rustdoc/reexport_pass.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/33334f3c435926422d88dcd5bfafd5e32b141111/src%2Frustdoc%2Freexport_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33334f3c435926422d88dcd5bfafd5e32b141111/src%2Frustdoc%2Freexport_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Freexport_pass.rs?ref=33334f3c435926422d88dcd5bfafd5e32b141111", "patch": "@@ -374,8 +374,8 @@ fn merge_reexports(\n                 with doc\n             })\n           }\n-          doc::ifacetag(doc @ {item, _}) {\n-            doc::ifacetag({\n+          doc::traittag(doc @ {item, _}) {\n+            doc::traittag({\n                 item: reexport(item, name)\n                 with doc\n             })"}, {"sha": "0974e5da85051b74beef1ceb84e1e5ef001f243e", "filename": "src/rustdoc/sectionalize_pass.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/33334f3c435926422d88dcd5bfafd5e32b141111/src%2Frustdoc%2Fsectionalize_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33334f3c435926422d88dcd5bfafd5e32b141111/src%2Frustdoc%2Fsectionalize_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fsectionalize_pass.rs?ref=33334f3c435926422d88dcd5bfafd5e32b141111", "patch": "@@ -12,7 +12,7 @@ fn mk_pass() -> pass {\n fn run(_srv: astsrv::srv, doc: doc::doc) -> doc::doc {\n     let fold = fold::fold({\n         fold_item: fold_item,\n-        fold_iface: fold_iface,\n+        fold_trait: fold_trait,\n         fold_impl: fold_impl\n         with *fold::default_any_fold(())\n     });\n@@ -30,8 +30,8 @@ fn fold_item(fold: fold::fold<()>, doc: doc::itemdoc) -> doc::itemdoc {\n     }\n }\n \n-fn fold_iface(fold: fold::fold<()>, doc: doc::ifacedoc) -> doc::ifacedoc {\n-    let doc = fold::default_seq_fold_iface(fold, doc);\n+fn fold_trait(fold: fold::fold<()>, doc: doc::traitdoc) -> doc::traitdoc {\n+    let doc = fold::default_seq_fold_trait(fold, doc);\n \n     {\n         methods: do par::anymap(doc.methods) |method| {\n@@ -202,14 +202,14 @@ fn should_eliminate_desc_if_it_is_just_whitespace() {\n }\n \n #[test]\n-fn should_sectionalize_iface_methods() {\n+fn should_sectionalize_trait_methods() {\n     let doc = test::mk_doc(\n         \"iface i {\n          #[doc = \\\"\\\n          # Header\\n\\\n          Body\\\"]\\\n          fn a(); }\");\n-    assert doc.cratemod().ifaces()[0].methods[0].sections.len() == 1u;\n+    assert doc.cratemod().traits()[0].methods[0].sections.len() == 1u;\n }\n \n #[test]"}, {"sha": "d8e566d040037671211c7896c2ef36bf3d770533", "filename": "src/rustdoc/sort_item_type_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/33334f3c435926422d88dcd5bfafd5e32b141111/src%2Frustdoc%2Fsort_item_type_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33334f3c435926422d88dcd5bfafd5e32b141111/src%2Frustdoc%2Fsort_item_type_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fsort_item_type_pass.rs?ref=33334f3c435926422d88dcd5bfafd5e32b141111", "patch": "@@ -9,7 +9,7 @@ fn mk_pass() -> pass {\n               doc::consttag(_) { 0 }\n               doc::tytag(_) { 1 }\n               doc::enumtag(_) { 2 }\n-              doc::ifacetag(_) { 3 }\n+              doc::traittag(_) { 3 }\n               doc::impltag(_) { 4 }\n               doc::fntag(_) { 5 }\n               doc::modtag(_) { 6 }"}, {"sha": "cd001e69f2116417710a1403b73f2d0a9b35b785", "filename": "src/rustdoc/text_pass.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/33334f3c435926422d88dcd5bfafd5e32b141111/src%2Frustdoc%2Ftext_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33334f3c435926422d88dcd5bfafd5e32b141111/src%2Frustdoc%2Ftext_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Ftext_pass.rs?ref=33334f3c435926422d88dcd5bfafd5e32b141111", "patch": "@@ -22,7 +22,7 @@ fn run(\n     let fold = fold::fold({\n         fold_item: fold_item,\n         fold_enum: fold_enum,\n-        fold_iface: fold_iface,\n+        fold_trait: fold_trait,\n         fold_impl: fold_impl\n         with *fold::default_any_fold(op)\n     });\n@@ -65,8 +65,8 @@ fn fold_enum(fold: fold::fold<op>, doc: doc::enumdoc) -> doc::enumdoc {\n     }\n }\n \n-fn fold_iface(fold: fold::fold<op>, doc: doc::ifacedoc) -> doc::ifacedoc {\n-    let doc = fold::default_seq_fold_iface(fold, doc);\n+fn fold_trait(fold: fold::fold<op>, doc: doc::traitdoc) -> doc::traitdoc {\n+    let doc = fold::default_seq_fold_trait(fold, doc);\n \n     {\n         methods: apply_to_methods(fold.ctxt, doc.methods)\n@@ -113,31 +113,31 @@ fn should_execute_op_on_variant_desc() {\n }\n \n #[test]\n-fn should_execute_op_on_iface_brief() {\n+fn should_execute_op_on_trait_brief() {\n     let doc = test::mk_doc(\n         \"#[doc = \\\" a \\\"] iface i { fn a(); }\");\n-    assert doc.cratemod().ifaces()[0].brief() == some(\"a\");\n+    assert doc.cratemod().traits()[0].brief() == some(\"a\");\n }\n \n #[test]\n-fn should_execute_op_on_iface_desc() {\n+fn should_execute_op_on_trait_desc() {\n     let doc = test::mk_doc(\n         \"#[doc = \\\" a \\\"] iface i { fn a(); }\");\n-    assert doc.cratemod().ifaces()[0].desc() == some(\"a\");\n+    assert doc.cratemod().traits()[0].desc() == some(\"a\");\n }\n \n #[test]\n-fn should_execute_op_on_iface_method_brief() {\n+fn should_execute_op_on_trait_method_brief() {\n     let doc = test::mk_doc(\n         \"iface i { #[doc = \\\" a \\\"] fn a(); }\");\n-    assert doc.cratemod().ifaces()[0].methods[0].brief == some(\"a\");\n+    assert doc.cratemod().traits()[0].methods[0].brief == some(\"a\");\n }\n \n #[test]\n-fn should_execute_op_on_iface_method_desc() {\n+fn should_execute_op_on_trait_method_desc() {\n     let doc = test::mk_doc(\n         \"iface i { #[doc = \\\" a \\\"] fn a(); }\");\n-    assert doc.cratemod().ifaces()[0].methods[0].desc == some(\"a\");\n+    assert doc.cratemod().traits()[0].methods[0].desc == some(\"a\");\n }\n \n #[test]\n@@ -203,26 +203,26 @@ fn should_execute_on_item_section_bodies() {\n }\n \n #[test]\n-fn should_execute_on_iface_method_section_headers() {\n+fn should_execute_on_trait_method_section_headers() {\n     let doc = test::mk_doc(\n         \"iface i {\n          #[doc = \\\"\\\n          # Header    \\n\\\n          Body\\\"]\\\n          fn a(); }\");\n-    assert doc.cratemod().ifaces()[0].methods[0].sections[0].header\n+    assert doc.cratemod().traits()[0].methods[0].sections[0].header\n         == \"Header\";\n }\n \n #[test]\n-fn should_execute_on_iface_method_section_bodies() {\n+fn should_execute_on_trait_method_section_bodies() {\n     let doc = test::mk_doc(\n         \"iface i {\n          #[doc = \\\"\\\n          # Header\\n\\\n          Body     \\\"]\\\n          fn a(); }\");\n-    assert doc.cratemod().ifaces()[0].methods[0].sections[0].body == \"Body\";\n+    assert doc.cratemod().traits()[0].methods[0].sections[0].body == \"Body\";\n }\n \n #[test]"}, {"sha": "cd4683a43567b471ce70c7d73ee14d97e473419a", "filename": "src/rustdoc/tystr_pass.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/33334f3c435926422d88dcd5bfafd5e32b141111/src%2Frustdoc%2Ftystr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33334f3c435926422d88dcd5bfafd5e32b141111/src%2Frustdoc%2Ftystr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Ftystr_pass.rs?ref=33334f3c435926422d88dcd5bfafd5e32b141111", "patch": "@@ -22,7 +22,7 @@ fn run(\n         fold_fn: fold_fn,\n         fold_const: fold_const,\n         fold_enum: fold_enum,\n-        fold_iface: fold_iface,\n+        fold_trait: fold_trait,\n         fold_impl: fold_impl,\n         fold_type: fold_type\n         with *fold::default_any_fold(srv)\n@@ -137,10 +137,10 @@ fn should_add_variant_sigs() {\n     assert doc.cratemod().enums()[0].variants[0].sig == some(\"b(int)\");\n }\n \n-fn fold_iface(\n+fn fold_trait(\n     fold: fold::fold<astsrv::srv>,\n-    doc: doc::ifacedoc\n-) -> doc::ifacedoc {\n+    doc: doc::traitdoc\n+) -> doc::traitdoc {\n     {\n         methods: merge_methods(fold.ctxt, doc.id(), doc.methods)\n         with doc\n@@ -168,7 +168,7 @@ fn get_method_sig(\n     do astsrv::exec(srv) |ctxt| {\n         alt check ctxt.ast_map.get(item_id) {\n           ast_map::node_item(@{\n-            node: ast::item_iface(_, _, methods), _\n+            node: ast::item_trait(_, _, methods), _\n           }, _) {\n             alt check vec::find(methods, |method| {\n                 *method.ident == method_name\n@@ -202,9 +202,9 @@ fn get_method_sig(\n }\n \n #[test]\n-fn should_add_iface_method_sigs() {\n+fn should_add_trait_method_sigs() {\n     let doc = test::mk_doc(\"iface i { fn a<T>() -> int; }\");\n-    assert doc.cratemod().ifaces()[0].methods[0].sig\n+    assert doc.cratemod().traits()[0].methods[0].sig\n         == some(\"fn a<T>() -> int\");\n }\n \n@@ -215,38 +215,38 @@ fn fold_impl(\n \n     let srv = fold.ctxt;\n \n-    let (iface_ty, self_ty) = do astsrv::exec(srv) |ctxt| {\n+    let (trait_ty, self_ty) = do astsrv::exec(srv) |ctxt| {\n         alt ctxt.ast_map.get(doc.id()) {\n           ast_map::node_item(@{\n-            node: ast::item_impl(_, _, iface_ty, self_ty, _), _\n+            node: ast::item_impl(_, _, trait_ty, self_ty, _), _\n           }, _) {\n-            let iface_ty = option::map(iface_ty, |p| {\n+            let trait_ty = option::map(trait_ty, |p| {\n                 pprust::path_to_str(p.path)\n             });\n-            (iface_ty, some(pprust::ty_to_str(self_ty)))\n+            (trait_ty, some(pprust::ty_to_str(self_ty)))\n           }\n           _ { fail \"expected impl\" }\n         }\n     };\n \n     {\n-        iface_ty: iface_ty,\n+        trait_ty: trait_ty,\n         self_ty: self_ty,\n         methods: merge_methods(fold.ctxt, doc.id(), doc.methods)\n         with doc\n     }\n }\n \n #[test]\n-fn should_add_impl_iface_ty() {\n+fn should_add_impl_trait_ty() {\n     let doc = test::mk_doc(\"impl i of j for int { fn a<T>() { } }\");\n-    assert doc.cratemod().impls()[0].iface_ty == some(\"j\");\n+    assert doc.cratemod().impls()[0].trait_ty == some(\"j\");\n }\n \n #[test]\n-fn should_not_add_impl_iface_ty_if_none() {\n+fn should_not_add_impl_trait_ty_if_none() {\n     let doc = test::mk_doc(\"impl i for int { fn a() { } }\");\n-    assert doc.cratemod().impls()[0].iface_ty == none;\n+    assert doc.cratemod().impls()[0].trait_ty == none;\n }\n \n #[test]"}]}