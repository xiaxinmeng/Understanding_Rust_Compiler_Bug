{"sha": "5b32211e620a47b2c14dd313f0c3aa91e78f7361", "node_id": "MDY6Q29tbWl0NzI0NzEyOjViMzIyMTFlNjIwYTQ3YjJjMTRkZDMxM2YwYzNhYTkxZTc4ZjczNjE=", "commit": {"author": {"name": "Andrew Cann", "email": "shum@canndrew.org", "date": "2018-03-12T04:15:06Z"}, "committer": {"name": "Andrew Cann", "email": "shum@canndrew.org", "date": "2018-03-14T04:44:52Z"}, "message": "Add note about fallback to `!: !Trait` error", "tree": {"sha": "07728cd784e55b7275ce748d7479e2fded783da0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/07728cd784e55b7275ce748d7479e2fded783da0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5b32211e620a47b2c14dd313f0c3aa91e78f7361", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5b32211e620a47b2c14dd313f0c3aa91e78f7361", "html_url": "https://github.com/rust-lang/rust/commit/5b32211e620a47b2c14dd313f0c3aa91e78f7361", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5b32211e620a47b2c14dd313f0c3aa91e78f7361/comments", "author": {"login": "canndrew", "id": 5555066, "node_id": "MDQ6VXNlcjU1NTUwNjY=", "avatar_url": "https://avatars.githubusercontent.com/u/5555066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/canndrew", "html_url": "https://github.com/canndrew", "followers_url": "https://api.github.com/users/canndrew/followers", "following_url": "https://api.github.com/users/canndrew/following{/other_user}", "gists_url": "https://api.github.com/users/canndrew/gists{/gist_id}", "starred_url": "https://api.github.com/users/canndrew/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/canndrew/subscriptions", "organizations_url": "https://api.github.com/users/canndrew/orgs", "repos_url": "https://api.github.com/users/canndrew/repos", "events_url": "https://api.github.com/users/canndrew/events{/privacy}", "received_events_url": "https://api.github.com/users/canndrew/received_events", "type": "User", "site_admin": false}, "committer": {"login": "canndrew", "id": 5555066, "node_id": "MDQ6VXNlcjU1NTUwNjY=", "avatar_url": "https://avatars.githubusercontent.com/u/5555066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/canndrew", "html_url": "https://github.com/canndrew", "followers_url": "https://api.github.com/users/canndrew/followers", "following_url": "https://api.github.com/users/canndrew/following{/other_user}", "gists_url": "https://api.github.com/users/canndrew/gists{/gist_id}", "starred_url": "https://api.github.com/users/canndrew/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/canndrew/subscriptions", "organizations_url": "https://api.github.com/users/canndrew/orgs", "repos_url": "https://api.github.com/users/canndrew/repos", "events_url": "https://api.github.com/users/canndrew/events{/privacy}", "received_events_url": "https://api.github.com/users/canndrew/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5a6b7812665f26e2483075ce2cbde92af822b2e4", "url": "https://api.github.com/repos/rust-lang/rust/commits/5a6b7812665f26e2483075ce2cbde92af822b2e4", "html_url": "https://github.com/rust-lang/rust/commit/5a6b7812665f26e2483075ce2cbde92af822b2e4"}], "stats": {"total": 133, "additions": 107, "deletions": 26}, "files": [{"sha": "8bb3f4158ff5b8a56ec833bfbc3cc6135d61464a", "filename": "src/librustc/infer/outlives/bounds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b32211e620a47b2c14dd313f0c3aa91e78f7361/src%2Flibrustc%2Finfer%2Foutlives%2Fbounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b32211e620a47b2c14dd313f0c3aa91e78f7361/src%2Flibrustc%2Finfer%2Foutlives%2Fbounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fbounds.rs?ref=5b32211e620a47b2c14dd313f0c3aa91e78f7361", "patch": "@@ -151,7 +151,7 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n         // get solved *here*.\n         match fulfill_cx.select_all_or_error(self) {\n             Ok(()) => (),\n-            Err(errors) => self.report_fulfillment_errors(&errors, None),\n+            Err(errors) => self.report_fulfillment_errors(&errors, None, false),\n         }\n \n         implied_bounds"}, {"sha": "b19935b8c4fbd7f7e9684e114c8b690a7501baaf", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 40, "deletions": 5, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/5b32211e620a47b2c14dd313f0c3aa91e78f7361/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b32211e620a47b2c14dd313f0c3aa91e78f7361/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=5b32211e620a47b2c14dd313f0c3aa91e78f7361", "patch": "@@ -47,7 +47,8 @@ use syntax_pos::{DUMMY_SP, Span};\n impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     pub fn report_fulfillment_errors(&self,\n                                      errors: &Vec<FulfillmentError<'tcx>>,\n-                                     body_id: Option<hir::BodyId>) {\n+                                     body_id: Option<hir::BodyId>,\n+                                     fallback_has_occurred: bool) {\n         #[derive(Debug)]\n         struct ErrorDescriptor<'tcx> {\n             predicate: ty::Predicate<'tcx>,\n@@ -107,7 +108,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n         for (error, suppressed) in errors.iter().zip(is_suppressed) {\n             if !suppressed {\n-                self.report_fulfillment_error(error, body_id);\n+                self.report_fulfillment_error(error, body_id, fallback_has_occurred);\n             }\n         }\n     }\n@@ -151,11 +152,12 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     fn report_fulfillment_error(&self, error: &FulfillmentError<'tcx>,\n-                                body_id: Option<hir::BodyId>) {\n+                                body_id: Option<hir::BodyId>,\n+                                fallback_has_occurred: bool) {\n         debug!(\"report_fulfillment_errors({:?})\", error);\n         match error.code {\n             FulfillmentErrorCode::CodeSelectionError(ref e) => {\n-                self.report_selection_error(&error.obligation, e);\n+                self.report_selection_error(&error.obligation, e, fallback_has_occurred);\n             }\n             FulfillmentErrorCode::CodeProjectionError(ref e) => {\n                 self.report_projection_error(&error.obligation, e);\n@@ -533,9 +535,11 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn report_selection_error(&self,\n                                   obligation: &PredicateObligation<'tcx>,\n-                                  error: &SelectionError<'tcx>)\n+                                  error: &SelectionError<'tcx>,\n+                                  fallback_has_occurred: bool)\n     {\n         let span = obligation.cause.span;\n+        let _ = fallback_has_occurred;\n \n         let mut err = match *error {\n             SelectionError::Unimplemented => {\n@@ -619,6 +623,37 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                             self.report_similar_impl_candidates(impl_candidates, &mut err);\n                         }\n \n+                        // If this error is due to `!: !Trait` but `(): Trait` then add a note\n+                        // about the fallback behaviour change.\n+                        if trait_predicate.skip_binder().self_ty().is_never() {\n+                            let predicate = trait_predicate.map_bound(|mut trait_pred| {\n+                                {\n+                                    let trait_ref = &mut trait_pred.trait_ref;\n+                                    let never_substs = trait_ref.substs;\n+                                    let mut unit_substs = Vec::with_capacity(never_substs.len());\n+                                    unit_substs.push(self.tcx.mk_nil().into());\n+                                    unit_substs.extend(&never_substs[1..]);\n+                                    trait_ref.substs = self.tcx.intern_substs(&unit_substs);\n+                                }\n+                                trait_pred\n+                            });\n+                            let unit_obligation = Obligation {\n+                                cause: obligation.cause.clone(),\n+                                param_env: obligation.param_env,\n+                                recursion_depth: obligation.recursion_depth,\n+                                predicate,\n+                            };\n+                            let mut selcx = SelectionContext::new(self);\n+                            if let Ok(Some(..)) = selcx.select(&unit_obligation) {\n+                                err.note(\"the trait is implemented for `()`. \\\n+                                         Possibly this error has been caused by changes to \\\n+                                         Rust's type-inference algorithm \\\n+                                         (see: https://github.com/rust-lang/rust/issues/48950 \\\n+                                         for more info). Consider whether you meant to use the \\\n+                                         type `()` here instead.\");\n+                            }\n+                        }\n+\n                         err\n                     }\n "}, {"sha": "bd8f99780f9f12c8913f615d933a3fbeeee5a3f6", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b32211e620a47b2c14dd313f0c3aa91e78f7361/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b32211e620a47b2c14dd313f0c3aa91e78f7361/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=5b32211e620a47b2c14dd313f0c3aa91e78f7361", "patch": "@@ -580,7 +580,7 @@ pub fn normalize_param_env_or_error<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         ) {\n             Ok(predicates) => predicates,\n             Err(errors) => {\n-                infcx.report_fulfillment_errors(&errors, None);\n+                infcx.report_fulfillment_errors(&errors, None, false);\n                 // An unnormalized env is better than nothing.\n                 return elaborated_env;\n             }"}, {"sha": "59a872a23b060f15d979665f51e2f4ebdd166da5", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b32211e620a47b2c14dd313f0c3aa91e78f7361/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b32211e620a47b2c14dd313f0c3aa91e78f7361/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=5b32211e620a47b2c14dd313f0c3aa91e78f7361", "patch": "@@ -1246,7 +1246,7 @@ impl MirPass for QualifyAndPromoteConstants {\n                                               tcx.require_lang_item(lang_items::SyncTraitLangItem),\n                                               cause);\n                 if let Err(err) = fulfillment_cx.select_all_or_error(&infcx) {\n-                    infcx.report_fulfillment_errors(&err, None);\n+                    infcx.report_fulfillment_errors(&err, None, false);\n                 }\n             });\n         }"}, {"sha": "269ee49f38e70e5bdda4601772ee1fc0d0431624", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b32211e620a47b2c14dd313f0c3aa91e78f7361/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b32211e620a47b2c14dd313f0c3aa91e78f7361/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=5b32211e620a47b2c14dd313f0c3aa91e78f7361", "patch": "@@ -571,7 +571,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n \n                 // Object safety violations or miscellaneous.\n                 Err(err) => {\n-                    self.report_selection_error(&obligation, &err);\n+                    self.report_selection_error(&obligation, &err, false);\n                     // Treat this like an obligation and follow through\n                     // with the unsizing - the lack of a coercion should\n                     // be silent, as it causes a type mismatch later."}, {"sha": "60ac31ac8eba8f5029b2d7c46d51b5325d2f1ca7", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5b32211e620a47b2c14dd313f0c3aa91e78f7361/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b32211e620a47b2c14dd313f0c3aa91e78f7361/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=5b32211e620a47b2c14dd313f0c3aa91e78f7361", "patch": "@@ -334,7 +334,7 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         // Check that all obligations are satisfied by the implementation's\n         // version.\n         if let Err(ref errors) = inh.fulfillment_cx.borrow_mut().select_all_or_error(&infcx) {\n-            infcx.report_fulfillment_errors(errors, None);\n+            infcx.report_fulfillment_errors(errors, None, false);\n             return Err(ErrorReported);\n         }\n \n@@ -839,7 +839,7 @@ pub fn compare_const_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         // Check that all obligations are satisfied by the implementation's\n         // version.\n         if let Err(ref errors) = inh.fulfillment_cx.borrow_mut().select_all_or_error(&infcx) {\n-            infcx.report_fulfillment_errors(errors, None);\n+            infcx.report_fulfillment_errors(errors, None, false);\n             return;\n         }\n "}, {"sha": "596381d7ea676612081e8310a67b2f083367201f", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b32211e620a47b2c14dd313f0c3aa91e78f7361/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b32211e620a47b2c14dd313f0c3aa91e78f7361/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=5b32211e620a47b2c14dd313f0c3aa91e78f7361", "patch": "@@ -112,7 +112,7 @@ fn ensure_drop_params_and_item_params_correspond<'a, 'tcx>(\n \n         if let Err(ref errors) = fulfillment_cx.select_all_or_error(&infcx) {\n             // this could be reached when we get lazy normalization\n-            infcx.report_fulfillment_errors(errors, None);\n+            infcx.report_fulfillment_errors(errors, None, false);\n             return Err(ErrorReported);\n         }\n "}, {"sha": "18de8d1bee74ee95e619c6afcf959e22440a784b", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/5b32211e620a47b2c14dd313f0c3aa91e78f7361/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b32211e620a47b2c14dd313f0c3aa91e78f7361/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=5b32211e620a47b2c14dd313f0c3aa91e78f7361", "patch": "@@ -873,11 +873,12 @@ fn typeck_tables_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         };\n \n         // All type checking constraints were added, try to fallback unsolved variables.\n-        fcx.select_obligations_where_possible();\n+        fcx.select_obligations_where_possible(false);\n+        let mut fallback_has_occurred = false;\n         for ty in &fcx.unsolved_variables() {\n-            fcx.fallback_if_possible(ty);\n+            fallback_has_occurred |= fcx.fallback_if_possible(ty);\n         }\n-        fcx.select_obligations_where_possible();\n+        fcx.select_obligations_where_possible(fallback_has_occurred);\n \n         // Even though coercion casts provide type hints, we check casts after fallback for\n         // backwards compatibility. This makes fallback a stronger type hint than a cast coercion.\n@@ -1837,7 +1838,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // possible. This can help substantially when there are\n         // indirect dependencies that don't seem worth tracking\n         // precisely.\n-        self.select_obligations_where_possible();\n+        self.select_obligations_where_possible(false);\n         ty = self.resolve_type_vars_if_possible(&ty);\n \n         debug!(\"resolve_type_vars_with_obligations: ty={:?}\", ty);\n@@ -2154,7 +2155,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     fn resolve_generator_interiors(&self, def_id: DefId) {\n         let mut generators = self.deferred_generator_interiors.borrow_mut();\n         for (body_id, interior) in generators.drain(..) {\n-            self.select_obligations_where_possible();\n+            self.select_obligations_where_possible(false);\n             generator_interior::resolve_interior(self, def_id, body_id, interior);\n         }\n     }\n@@ -2164,7 +2165,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     // unconstrained floats with f64.\n     // Fallback becomes very dubious if we have encountered type-checking errors.\n     // In that case, fallback to TyError.\n-    fn fallback_if_possible(&self, ty: Ty<'tcx>) {\n+    // The return value indicates whether fallback has occured.\n+    fn fallback_if_possible(&self, ty: Ty<'tcx>) -> bool {\n         use rustc::ty::error::UnconstrainedNumeric::Neither;\n         use rustc::ty::error::UnconstrainedNumeric::{UnconstrainedInt, UnconstrainedFloat};\n \n@@ -2174,24 +2176,27 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             UnconstrainedInt => self.tcx.types.i32,\n             UnconstrainedFloat => self.tcx.types.f64,\n             Neither if self.type_var_diverges(ty) => self.tcx.types.never,\n-            Neither => return\n+            Neither => return false,\n         };\n         debug!(\"default_type_parameters: defaulting `{:?}` to `{:?}`\", ty, fallback);\n         self.demand_eqtype(syntax_pos::DUMMY_SP, ty, fallback);\n+        true\n     }\n \n     fn select_all_obligations_or_error(&self) {\n         debug!(\"select_all_obligations_or_error\");\n         if let Err(errors) = self.fulfillment_cx.borrow_mut().select_all_or_error(&self) {\n-            self.report_fulfillment_errors(&errors, self.inh.body_id);\n+            self.report_fulfillment_errors(&errors, self.inh.body_id, false);\n         }\n     }\n \n     /// Select as many obligations as we can at present.\n-    fn select_obligations_where_possible(&self) {\n+    fn select_obligations_where_possible(&self, fallback_has_occurred: bool) {\n         match self.fulfillment_cx.borrow_mut().select_where_possible(self) {\n             Ok(()) => { }\n-            Err(errors) => { self.report_fulfillment_errors(&errors, self.inh.body_id); }\n+            Err(errors) => {\n+                self.report_fulfillment_errors(&errors, self.inh.body_id, fallback_has_occurred);\n+            },\n         }\n     }\n \n@@ -2595,7 +2600,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             // an \"opportunistic\" vtable resolution of any trait bounds on\n             // the call. This helps coercions.\n             if check_closures {\n-                self.select_obligations_where_possible();\n+                self.select_obligations_where_possible(false);\n             }\n \n             // For variadic functions, we don't have a declared type for all of"}, {"sha": "eae692f4cdad9c8b8b7d196ea067dc5315483d5e", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b32211e620a47b2c14dd313f0c3aa91e78f7361/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b32211e620a47b2c14dd313f0c3aa91e78f7361/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=5b32211e620a47b2c14dd313f0c3aa91e78f7361", "patch": "@@ -479,7 +479,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         match method {\n             Some(ok) => {\n                 let method = self.register_infer_ok_obligations(ok);\n-                self.select_obligations_where_possible();\n+                self.select_obligations_where_possible(false);\n \n                 Ok(method)\n             }"}, {"sha": "9493c36fe95a50a57ccfc7ba1ecd198f31758c25", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b32211e620a47b2c14dd313f0c3aa91e78f7361/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b32211e620a47b2c14dd313f0c3aa91e78f7361/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=5b32211e620a47b2c14dd313f0c3aa91e78f7361", "patch": "@@ -386,7 +386,7 @@ pub fn coerce_unsized_info<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n         // Check that all transitive obligations are satisfied.\n         if let Err(errors) = fulfill_cx.select_all_or_error(&infcx) {\n-            infcx.report_fulfillment_errors(&errors, None);\n+            infcx.report_fulfillment_errors(&errors, None, false);\n         }\n \n         // Finally, resolve all regions."}, {"sha": "964c0021133aae5100f55ac49de349abf7934948", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b32211e620a47b2c14dd313f0c3aa91e78f7361/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b32211e620a47b2c14dd313f0c3aa91e78f7361/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=5b32211e620a47b2c14dd313f0c3aa91e78f7361", "patch": "@@ -174,7 +174,7 @@ fn require_same_types<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         match fulfill_cx.select_all_or_error(infcx) {\n             Ok(()) => true,\n             Err(errors) => {\n-                infcx.report_fulfillment_errors(&errors, None);\n+                infcx.report_fulfillment_errors(&errors, None, false);\n                 false\n             }\n         }"}, {"sha": "798544f164932a59f84baab5e8ee6fb21c8f39a1", "filename": "src/test/compile-fail/defaulted-never-note.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/5b32211e620a47b2c14dd313f0c3aa91e78f7361/src%2Ftest%2Fcompile-fail%2Fdefaulted-never-note.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b32211e620a47b2c14dd313f0c3aa91e78f7361/src%2Ftest%2Fcompile-fail%2Fdefaulted-never-note.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdefaulted-never-note.rs?ref=5b32211e620a47b2c14dd313f0c3aa91e78f7361", "patch": "@@ -0,0 +1,41 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(unused)]\n+\n+trait Deserialize: Sized {\n+    fn deserialize() -> Result<Self, String>;\n+}\n+\n+impl Deserialize for () {\n+    fn deserialize() -> Result<(), String> {\n+        Ok(())\n+    }\n+}\n+\n+trait ImplementedForUnitButNotNever {}\n+\n+impl ImplementedForUnitButNotNever for () {}\n+\n+fn foo<T: ImplementedForUnitButNotNever>(_t: T) {}\n+//~^ NOTE required by `foo`\n+\n+fn smeg() {\n+    let _x = return;\n+    foo(_x);\n+    //~^ ERROR the trait bound\n+    //~| NOTE the trait `ImplementedForUnitButNotNever` is not implemented\n+    //~| NOTE the trait is implemented for `()`\n+}\n+\n+fn main() {\n+    smeg();\n+}\n+"}]}