{"sha": "7a3b29024548e1dcb13590002d5cf4dd94ddd4d4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdhM2IyOTAyNDU0OGUxZGNiMTM1OTAwMDJkNWNmNGRkOTRkZGQ0ZDQ=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-04-10T00:32:49Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-04-11T18:08:40Z"}, "message": "Add vstore/evec/estr to compiler.", "tree": {"sha": "a0cc34e4635bb317347ca1b5424e494ec68e9909", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a0cc34e4635bb317347ca1b5424e494ec68e9909"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7a3b29024548e1dcb13590002d5cf4dd94ddd4d4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7a3b29024548e1dcb13590002d5cf4dd94ddd4d4", "html_url": "https://github.com/rust-lang/rust/commit/7a3b29024548e1dcb13590002d5cf4dd94ddd4d4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7a3b29024548e1dcb13590002d5cf4dd94ddd4d4/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0c94cd5d431816c68825a08bcb24754d09b8dc31", "url": "https://api.github.com/repos/rust-lang/rust/commits/0c94cd5d431816c68825a08bcb24754d09b8dc31", "html_url": "https://github.com/rust-lang/rust/commit/0c94cd5d431816c68825a08bcb24754d09b8dc31"}], "stats": {"total": 712, "additions": 605, "deletions": 107}, "files": [{"sha": "885e0943b9b45af504e65e267afe01c6d1f2b31b", "filename": "src/librustsyntax/ast.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7a3b29024548e1dcb13590002d5cf4dd94ddd4d4/src%2Flibrustsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a3b29024548e1dcb13590002d5cf4dd94ddd4d4/src%2Flibrustsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fast.rs?ref=7a3b29024548e1dcb13590002d5cf4dd94ddd4d4", "patch": "@@ -169,6 +169,14 @@ enum proto {\n     proto_block,   // fn&\n }\n \n+#[auto_serialize]\n+enum vstore {\n+    vstore_fixed(option<uint>),   // [1,2,3,4]/_ or 4   FIXME: uint -> @expr\n+    vstore_uniq,                  // [1,2,3,4]/~\n+    vstore_box,                   // [1,2,3,4]/@\n+    vstore_slice(region)          // [1,2,3,4]/&(foo)?\n+}\n+\n pure fn is_blockish(p: ast::proto) -> bool {\n     alt p {\n       proto_any | proto_block { true }\n@@ -278,6 +286,7 @@ enum alt_mode { alt_check, alt_exhaustive, }\n \n #[auto_serialize]\n enum expr_ {\n+    expr_vstore(@expr, vstore),\n     expr_vec([@expr], mutability),\n     expr_rec([field], option<@expr>),\n     expr_call(@expr, [@expr], bool),\n@@ -459,6 +468,7 @@ enum ty_ {\n     ty_tup([@ty]),\n     ty_path(@path, node_id),\n     ty_constr(@ty, [@ty_constr]),\n+    ty_vstore(@ty, vstore),\n     ty_mac(mac),\n     // ty_infer means the type should be inferred instead of it having been\n     // specified. This should only appear at the \"top level\" of a type and not"}, {"sha": "c834692b5b080c3f0d8a383c6a72aaf770913c5a", "filename": "src/librustsyntax/ext/auto_serialize.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7a3b29024548e1dcb13590002d5cf4dd94ddd4d4/src%2Flibrustsyntax%2Fext%2Fauto_serialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a3b29024548e1dcb13590002d5cf4dd94ddd4d4/src%2Flibrustsyntax%2Fext%2Fauto_serialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fext%2Fauto_serialize.rs?ref=7a3b29024548e1dcb13590002d5cf4dd94ddd4d4", "patch": "@@ -367,8 +367,7 @@ fn ser_ty(cx: ext_ctxt, tps: ser_tps_map,\n       }\n \n       ast::ty_ptr(_) | ast::ty_rptr(_, _) {\n-        cx.span_err(\n-            ty.span, #fmt[\"Cannot serialize pointer types\"]);\n+        cx.span_err(ty.span, \"cannot serialize pointer types\");\n         []\n       }\n \n@@ -390,8 +389,7 @@ fn ser_ty(cx: ext_ctxt, tps: ser_tps_map,\n       }\n \n       ast::ty_fn(_, _) {\n-        cx.span_err(\n-            ty.span, #fmt[\"Cannot serialize function types\"]);\n+        cx.span_err(ty.span, \"cannot serialize function types\");\n         []\n       }\n \n@@ -448,17 +446,19 @@ fn ser_ty(cx: ext_ctxt, tps: ser_tps_map,\n       }\n \n       ast::ty_mac(_) {\n-        cx.span_err(\n-            ty.span, #fmt[\"Cannot serialize macro types\"]);\n+        cx.span_err(ty.span, \"cannot serialize macro types\");\n         []\n       }\n \n       ast::ty_infer {\n-        cx.span_err(\n-            ty.span, #fmt[\"Cannot serialize inferred types\"]);\n+        cx.span_err(ty.span, \"cannot serialize inferred types\");\n         []\n       }\n \n+      ast::ty_vstore(_, _) {\n+        cx.span_unimpl(ty.span, \"serialization for vstore types\");\n+      }\n+\n       ast::ty_vec(mt) {\n         let ser_e =\n             cx.expr(\n@@ -675,6 +675,10 @@ fn deser_ty(cx: ext_ctxt, tps: deser_tps_map,\n         #ast{ fail }\n       }\n \n+      ast::ty_vstore(_, _) {\n+        cx.span_unimpl(ty.span, \"deserialization for vstore types\");\n+      }\n+\n       ast::ty_vec(mt) {\n         let l = deser_lambda(cx, tps, mt.ty, cx.clone(d));\n         #ast{ std::serialization::read_to_vec($(d), $(l)) }"}, {"sha": "afde21d2965b3d9a5861239b226c32922f53a0fa", "filename": "src/librustsyntax/fold.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a3b29024548e1dcb13590002d5cf4dd94ddd4d4/src%2Flibrustsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a3b29024548e1dcb13590002d5cf4dd94ddd4d4/src%2Flibrustsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Ffold.rs?ref=7a3b29024548e1dcb13590002d5cf4dd94ddd4d4", "patch": "@@ -389,6 +389,9 @@ fn noop_fold_expr(e: expr_, fld: ast_fold) -> expr_ {\n                      fld.new_id(i),\n                      fld.fold_expr(v))\n           }\n+          expr_vstore(e, v) {\n+            expr_vstore(fld.fold_expr(e), v)\n+          }\n           expr_vec(exprs, mutt) {\n             expr_vec(fld.map_exprs(fld.fold_expr, exprs), mutt)\n           }\n@@ -497,6 +500,7 @@ fn noop_fold_ty(t: ty_, fld: ast_fold) -> ty_ {\n       ty_path(path, id) {ty_path(fld.fold_path(path), fld.new_id(id))}\n       // FIXME: constrs likely needs to be folded...\n       ty_constr(ty, constrs) {ty_constr(fld.fold_ty(ty), constrs)}\n+      ty_vstore(t, vs) {ty_vstore(fld.fold_ty(t), vs)}\n       ty_mac(mac) {ty_mac(fold_mac(mac))}\n       ty_infer {t}\n     }"}, {"sha": "05669e1f5f071d51f35f7d4dc3cf8019917eaf2c", "filename": "src/librustsyntax/parse/parser.rs", "status": "modified", "additions": 113, "deletions": 30, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/7a3b29024548e1dcb13590002d5cf4dd94ddd4d4/src%2Flibrustsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a3b29024548e1dcb13590002d5cf4dd94ddd4d4/src%2Flibrustsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fparse%2Fparser.rs?ref=7a3b29024548e1dcb13590002d5cf4dd94ddd4d4", "patch": "@@ -382,15 +382,32 @@ fn parse_type_constraints(p: parser) -> [@ast::ty_constr] {\n \n fn parse_ty_postfix(orig_t: ast::ty_, p: parser, colons_before_params: bool,\n                     lo: uint) -> @ast::ty {\n+\n+\n+    fn mk_ty(p: parser, t: ast::ty_, lo: uint, hi: uint) -> @ast::ty {\n+        @{id: p.get_id(),\n+          node: t,\n+          span: ast_util::mk_sp(lo, hi)}\n+    }\n+\n+    if p.token == token::BINOP(token::SLASH) {\n+        let orig_hi = p.last_span.hi;\n+        alt parse_maybe_vstore(p) {\n+          none { }\n+          some(v) {\n+            let t = ast::ty_vstore(mk_ty(p, orig_t, lo, orig_hi), v);\n+            ret mk_ty(p, t, lo, p.last_span.hi);\n+          }\n+        }\n+    }\n+\n     if colons_before_params && p.token == token::MOD_SEP {\n         p.bump();\n         expect(p, token::LT);\n     } else if !colons_before_params && p.token == token::LT {\n         p.bump();\n     } else {\n-        ret @{id: p.get_id(),\n-              node: orig_t,\n-              span: ast_util::mk_sp(lo, p.last_span.hi)};\n+        ret mk_ty(p, orig_t, lo, p.last_span.hi);\n     }\n \n     // If we're here, we have explicit type parameter instantiation.\n@@ -399,12 +416,11 @@ fn parse_ty_postfix(orig_t: ast::ty_, p: parser, colons_before_params: bool,\n \n     alt orig_t {\n       ast::ty_path(pth, ann) {\n-        ret @{id: p.get_id(),\n-              node: ast::ty_path(@spanned(lo, p.last_span.hi,\n-                                          {global: pth.node.global,\n-                                           idents: pth.node.idents,\n-                                           types: seq}), ann),\n-              span: ast_util::mk_sp(lo, p.last_span.hi)};\n+        ret mk_ty(p, ast::ty_path(@spanned(lo, p.last_span.hi,\n+                                           {global: pth.node.global,\n+                                            idents: pth.node.idents,\n+                                            types: seq}), ann),\n+                  lo, p.last_span.hi);\n       }\n       _ { p.fatal(\"type parameter instantiation only allowed for paths\"); }\n     }\n@@ -428,22 +444,33 @@ fn parse_ret_ty(p: parser) -> (ast::ret_style, @ast::ty) {\n     }\n }\n \n-fn parse_region(p: parser) -> ast::region {\n-    let region_ = alt p.token {\n-        token::IDENT(sid, _) if p.look_ahead(1u) == token::DOT {\n-            let string = p.get_str(sid);\n-            p.bump(); p.bump();\n-            if string == \"self\" {\n-                ast::re_self\n-            } else if string == \"static\" {\n-                ast::re_static\n-            } else {\n-                ast::re_named(string)\n-            }\n+fn region_from_name(p: parser, s: option<str>) -> ast::region {\n+    let r = alt s {\n+      some (string) {\n+        if string == \"self\" {\n+            ast::re_self\n+        } else if string == \"static\" {\n+            ast::re_static\n+        } else {\n+            ast::re_named(string)\n         }\n-        _ { ast::re_inferred }\n+      }\n+      none { ast::re_inferred }\n     };\n-    ret {id: p.get_id(), node: region_};\n+\n+    {id: p.get_id(), node: r}\n+}\n+\n+fn parse_region(p: parser) -> ast::region {\n+    let name =\n+        alt p.token {\n+          token::IDENT(sid, _) if p.look_ahead(1u) == token::DOT {\n+            p.bump(); p.bump();\n+            some(p.get_str(sid))\n+          }\n+          _ { none }\n+        };\n+    region_from_name(p, name)\n }\n \n fn parse_ty(p: parser, colons_before_params: bool) -> @ast::ty {\n@@ -666,6 +693,44 @@ fn have_dollar(p: parser) -> option<ast::mac_> {\n     }\n }\n \n+fn parse_maybe_vstore(p: parser) -> option<ast::vstore> {\n+    if p.token == token::BINOP(token::SLASH) {\n+        p.bump();\n+        alt p.token {\n+          token::AT {\n+            p.bump(); some(ast::vstore_box)\n+          }\n+          token::TILDE {\n+            p.bump(); some(ast::vstore_uniq)\n+          }\n+          token::UNDERSCORE {\n+            p.bump(); some(ast::vstore_fixed(none))\n+          }\n+          token::LIT_INT(i, ast::ty_i) if i >= 0 {\n+            p.bump(); some(ast::vstore_fixed(some(i as uint)))\n+          }\n+          token::BINOP(token::AND) {\n+            p.bump();\n+            alt p.token {\n+              token::IDENT(sid, _) {\n+                p.bump();\n+                let n = p.get_str(sid);\n+                some(ast::vstore_slice(region_from_name(p, some(n))))\n+              }\n+              _ {\n+                some(ast::vstore_slice(region_from_name(p, none)))\n+              }\n+            }\n+          }\n+          _ {\n+            none\n+          }\n+        }\n+    } else {\n+        none\n+    }\n+}\n+\n fn lit_from_token(p: parser, tok: token::token) -> ast::lit_ {\n     alt tok {\n       token::LIT_INT(i, it) { ast::lit_int(i, it) }\n@@ -678,7 +743,7 @@ fn lit_from_token(p: parser, tok: token::token) -> ast::lit_ {\n }\n \n fn parse_lit(p: parser) -> ast::lit {\n-    let sp = p.span;\n+    let lo = p.span.lo;\n     let lit = if eat_word(p, \"true\") {\n         ast::lit_bool(true)\n     } else if eat_word(p, \"false\") {\n@@ -688,7 +753,7 @@ fn parse_lit(p: parser) -> ast::lit {\n         p.bump();\n         lit_from_token(p, tok)\n     };\n-    ret {node: lit, span: sp};\n+    ret {node: lit, span: ast_util::mk_sp(lo, p.last_span.hi)};\n }\n \n fn is_ident(t: token::token) -> bool {\n@@ -891,6 +956,7 @@ fn parse_bottom_expr(p: parser) -> pexpr {\n         let es =\n             parse_seq_to_end(token::RBRACKET, seq_sep(token::COMMA),\n                              parse_expr, p);\n+        hi = p.span.hi;\n         ex = ast::expr_vec(es, mutbl);\n     } else if p.token == token::POUND_LT {\n         p.bump();\n@@ -988,6 +1054,23 @@ fn parse_bottom_expr(p: parser) -> pexpr {\n         hi = lit.span.hi;\n         ex = ast::expr_lit(@lit);\n     }\n+\n+    // Vstore is legal following expr_lit(lit_str(...)) and expr_vec(...)\n+    // only.\n+    alt ex {\n+      ast::expr_lit(@{node: ast::lit_str(_), span: _}) |\n+      ast::expr_vec(_, _)  {\n+        alt parse_maybe_vstore(p) {\n+          none { }\n+          some(v) {\n+            hi = p.span.hi;\n+            ex = ast::expr_vstore(mk_expr(p, lo, hi, ex), v);\n+          }\n+        }\n+      }\n+      _ { }\n+    }\n+\n     ret mk_pexpr(p, lo, hi, ex);\n }\n \n@@ -1194,10 +1277,10 @@ type op_spec = {tok: token::token, op: ast::binop, prec: int};\n \n // FIXME make this a const, don't store it in parser state\n fn prec_table() -> @[op_spec] {\n-    ret @[// 'as' sits between here with 12\n-          {tok: token::BINOP(token::STAR), op: ast::mul, prec: 11},\n-          {tok: token::BINOP(token::SLASH), op: ast::div, prec: 11},\n-          {tok: token::BINOP(token::PERCENT), op: ast::rem, prec: 11},\n+    ret @[{tok: token::BINOP(token::STAR), op: ast::mul, prec: 12},\n+          {tok: token::BINOP(token::SLASH), op: ast::div, prec: 12},\n+          {tok: token::BINOP(token::PERCENT), op: ast::rem, prec: 12},\n+          // 'as' sits between here with 11\n           {tok: token::BINOP(token::PLUS), op: ast::add, prec: 10},\n           {tok: token::BINOP(token::MINUS), op: ast::subtract, prec: 10},\n           {tok: token::BINOP(token::LSL), op: ast::lsl, prec: 9},\n@@ -1222,7 +1305,7 @@ fn parse_binops(p: parser) -> @ast::expr {\n \n const unop_prec: int = 100;\n \n-const as_prec: int = 12;\n+const as_prec: int = 11;\n \n fn parse_more_binops(p: parser, plhs: pexpr, min_prec: int) ->\n    @ast::expr {"}, {"sha": "1d2094762f19b634f7af42819f9056bd8d0a4d58", "filename": "src/librustsyntax/print/pprust.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/7a3b29024548e1dcb13590002d5cf4dd94ddd4d4/src%2Flibrustsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a3b29024548e1dcb13590002d5cf4dd94ddd4d4/src%2Flibrustsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fprint%2Fpprust.rs?ref=7a3b29024548e1dcb13590002d5cf4dd94ddd4d4", "patch": "@@ -378,6 +378,10 @@ fn print_type(s: ps, &&ty: @ast::ty) {\n         space(s.s);\n         word(s.s, constrs_str(cs, ty_constr_to_str));\n       }\n+      ast::ty_vstore(t, v) {\n+        print_type(s, t);\n+        print_vstore(s, v);\n+      }\n       ast::ty_mac(_) {\n           fail \"print_type doesn't know how to print a ty_mac\";\n       }\n@@ -810,12 +814,36 @@ fn print_mac(s: ps, m: ast::mac) {\n     }\n }\n \n+fn print_vstore(s: ps, t: ast::vstore) {\n+    alt t {\n+      ast::vstore_fixed(some(i)) { word_space(s, #fmt(\"/%u\", i)); }\n+      ast::vstore_fixed(none) { word_space(s, \"/_\"); }\n+      ast::vstore_uniq { word_space(s, \"/~\"); }\n+      ast::vstore_box { word_space(s, \"/@\"); }\n+      ast::vstore_slice(r) {\n+        alt r.node {\n+          ast::re_inferred { word_space(s, \"/&\"); }\n+          ast::re_self { word_space(s, \"/&self\"); }\n+          ast::re_static { word_space(s, \"/&static\"); }\n+          ast::re_named(name) {\n+            word(s.s, \"/&\");\n+            word_space(s, name);\n+          }\n+        }\n+      }\n+    }\n+}\n+\n fn print_expr(s: ps, &&expr: @ast::expr) {\n     maybe_print_comment(s, expr.span.lo);\n     ibox(s, indent_unit);\n     let ann_node = node_expr(s, expr);\n     s.ann.pre(ann_node);\n     alt expr.node {\n+      ast::expr_vstore(e, v) {\n+        print_expr(s, e);\n+        print_vstore(s, v);\n+      }\n       ast::expr_vec(exprs, mutbl) {\n         ibox(s, indent_unit);\n         word(s.s, \"[\");"}, {"sha": "33af7fe366119ee1de571eb40c2b5b58b6eb4fc4", "filename": "src/librustsyntax/visit.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7a3b29024548e1dcb13590002d5cf4dd94ddd4d4/src%2Flibrustsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a3b29024548e1dcb13590002d5cf4dd94ddd4d4/src%2Flibrustsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fvisit.rs?ref=7a3b29024548e1dcb13590002d5cf4dd94ddd4d4", "patch": "@@ -170,11 +170,10 @@ fn skip_ty<E>(_t: @ty, _e: E, _v: vt<E>) {}\n \n fn visit_ty<E>(t: @ty, e: E, v: vt<E>) {\n     alt t.node {\n-      ty_box(mt) { v.visit_ty(mt.ty, e, v); }\n-      ty_uniq(mt) { v.visit_ty(mt.ty, e, v); }\n-      ty_vec(mt) { v.visit_ty(mt.ty, e, v); }\n-      ty_ptr(mt) { v.visit_ty(mt.ty, e, v); }\n-      ty_rptr(_, mt) { v.visit_ty(mt.ty, e, v); }\n+      ty_box(mt) | ty_uniq(mt) |\n+      ty_vec(mt) | ty_ptr(mt) | ty_rptr(_, mt) {\n+        v.visit_ty(mt.ty, e, v);\n+      }\n       ty_rec(flds) {\n         for flds.each {|f| v.visit_ty(f.node.mt.ty, e, v); }\n       }\n@@ -187,6 +186,9 @@ fn visit_ty<E>(t: @ty, e: E, v: vt<E>) {\n         v.visit_ty(decl.output, e, v);\n       }\n       ty_path(p, _) { visit_path(p, e, v); }\n+      ty_vstore(t, _) {\n+        v.visit_ty(t, e, v);\n+      }\n       ty_constr(t, cs) {\n         v.visit_ty(t, e, v);\n         for cs.each {|tc|\n@@ -335,6 +337,7 @@ fn visit_expr<E>(ex: @expr, e: E, v: vt<E>) {\n         v.visit_expr(pool, e, v);\n         v.visit_expr(val, e, v);\n       }\n+      expr_vstore(x, _) { v.visit_expr(x, e, v); }\n       expr_vec(es, _) { visit_exprs(es, e, v); }\n       expr_rec(flds, base) {\n         for flds.each {|f| v.visit_expr(f.node.expr, e, v); }"}, {"sha": "0739764b08b9571312d83f78d9410edaef99215e", "filename": "src/rustc/metadata/tyencode.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a3b29024548e1dcb13590002d5cf4dd94ddd4d4/src%2Frustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a3b29024548e1dcb13590002d5cf4dd94ddd4d4/src%2Frustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ftyencode.rs?ref=7a3b29024548e1dcb13590002d5cf4dd94ddd4d4", "patch": "@@ -176,6 +176,7 @@ fn enc_sty(w: io::writer, cx: @ctxt, st: ty::sty) {\n           ty_f64 { w.write_str(\"MF\"); }\n         }\n       }\n+      ty::ty_estr(_) { cx.tcx.sess.unimpl(\"tyencode::enc_sty on estr\"); }\n       ty::ty_str { w.write_char('S'); }\n       ty::ty_enum(def, tys) {\n         w.write_str(\"t[\");\n@@ -204,6 +205,7 @@ fn enc_sty(w: io::writer, cx: @ctxt, st: ty::sty) {\n         enc_region(w, r);\n         enc_mt(w, cx, mt);\n       }\n+      ty::ty_evec(_, _) { cx.tcx.sess.unimpl(\"tyencode::enc_sty on evec\"); }\n       ty::ty_vec(mt) { w.write_char('I'); enc_mt(w, cx, mt); }\n       ty::ty_rec(fields) {\n         w.write_str(\"R[\");"}, {"sha": "fa2e8ddb0d7c364bf690244f9ddd337f337ac8ef", "filename": "src/rustc/middle/mutbl.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a3b29024548e1dcb13590002d5cf4dd94ddd4d4/src%2Frustc%2Fmiddle%2Fmutbl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a3b29024548e1dcb13590002d5cf4dd94ddd4d4/src%2Frustc%2Fmiddle%2Fmutbl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fmutbl.rs?ref=7a3b29024548e1dcb13590002d5cf4dd94ddd4d4", "patch": "@@ -92,12 +92,14 @@ fn expr_root_(tcx: ty::ctxt, ctor_self: option<node_id>,\n           expr_index(base, _) {\n             let auto_unbox = maybe_auto_unbox(tcx, ty::expr_ty(tcx, base));\n             alt ty::get(auto_unbox.t).struct {\n+              ty::ty_evec(mt, _) |\n               ty::ty_vec(mt) {\n                 ds +=\n                     [@{mutbl: mt.mutbl == m_mutbl,\n                        kind: index,\n                        outer_t: auto_unbox.t}];\n               }\n+              ty::ty_estr(_) |\n               ty::ty_str {\n                 ds += [@{mutbl: false, kind: index, outer_t: auto_unbox.t}];\n               }"}, {"sha": "39f08983b4b9640a2e76013e68c99eaed17abd2e", "filename": "src/rustc/middle/region.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7a3b29024548e1dcb13590002d5cf4dd94ddd4d4/src%2Frustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a3b29024548e1dcb13590002d5cf4dd94ddd4d4/src%2Frustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fregion.rs?ref=7a3b29024548e1dcb13590002d5cf4dd94ddd4d4", "patch": "@@ -414,6 +414,7 @@ fn resolve_ty(ty: @ast::ty, cx: ctxt, visitor: visit::vt<ctxt>) {\n     cx.region_map.ast_type_to_inferred_region.insert(ty.id, inferred_region);\n \n     alt ty.node {\n+      ast::ty_vstore(_, ast::vstore_slice(r)) |\n       ast::ty_rptr(r, _) {\n         resolve_region_binding(cx, ty.span, r);\n       }"}, {"sha": "dbf3ca841ba0271634e5e5bfa67211d128cc2579", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 62, "deletions": 11, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/7a3b29024548e1dcb13590002d5cf4dd94ddd4d4/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a3b29024548e1dcb13590002d5cf4dd94ddd4d4/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=7a3b29024548e1dcb13590002d5cf4dd94ddd4d4", "patch": "@@ -573,15 +573,17 @@ fn make_take_glue(bcx: block, v: ValueRef, t: ty::t) {\n     let _icx = bcx.insn_ctxt(\"make_take_glue\");\n     // NB: v is a *pointer* to type t here, not a direct value.\n     let bcx = alt ty::get(t).struct {\n-      ty::ty_box(_) | ty::ty_opaque_box {\n+      ty::ty_box(_) | ty::ty_opaque_box |\n+      ty::ty_evec(_, ty::vstore_box) | ty::ty_estr(ty::vstore_box) {\n         incr_refcnt_of_boxed(bcx, Load(bcx, v)); bcx\n       }\n       ty::ty_uniq(_) {\n         let {bcx, val} = uniq::duplicate(bcx, Load(bcx, v), t);\n         Store(bcx, val, v);\n         bcx\n       }\n-      ty::ty_vec(_) | ty::ty_str {\n+      ty::ty_vec(_) | ty::ty_str |\n+      ty::ty_evec(_, ty::vstore_uniq) | ty::ty_estr(ty::vstore_uniq) {\n         let {bcx, val} = tvec::duplicate(bcx, Load(bcx, v), t);\n         Store(bcx, val, v);\n         bcx\n@@ -629,6 +631,12 @@ fn make_free_glue(bcx: block, v: ValueRef, t: ty::t) {\n         let bcx = drop_ty(bcx, body, body_mt.ty);\n         trans_free(bcx, v)\n       }\n+\n+      ty::ty_estr(ty::vstore_box) {\n+        let v = PointerCast(bcx, v, type_of(ccx, t));\n+        trans_free(bcx, v)\n+      }\n+\n       ty::ty_opaque_box {\n         let v = PointerCast(bcx, v, type_of(ccx, t));\n         let td = Load(bcx, GEPi(bcx, v, [0, abi::box_field_tydesc]));\n@@ -641,9 +649,13 @@ fn make_free_glue(bcx: block, v: ValueRef, t: ty::t) {\n         let v = PointerCast(bcx, v, type_of(ccx, t));\n         uniq::make_free_glue(bcx, v, t)\n       }\n+      ty::ty_evec(_, ty::vstore_uniq) | ty::ty_estr(ty::vstore_uniq) |\n       ty::ty_vec(_) | ty::ty_str {\n         tvec::make_free_glue(bcx, PointerCast(bcx, v, type_of(ccx, t)), t)\n       }\n+      ty::ty_evec(_, _) {\n+          bcx.sess().unimpl(\"trans::base::make_free_glue on other evec\");\n+      }\n       ty::ty_fn(_) {\n         closure::make_fn_glue(bcx, v, t, free_ty)\n       }\n@@ -660,7 +672,8 @@ fn make_drop_glue(bcx: block, v0: ValueRef, t: ty::t) {\n     let _icx = bcx.insn_ctxt(\"make_drop_glue\");\n     let ccx = bcx.ccx();\n     let bcx = alt ty::get(t).struct {\n-      ty::ty_box(_) | ty::ty_opaque_box {\n+      ty::ty_box(_) | ty::ty_opaque_box |\n+      ty::ty_estr(ty::vstore_box) {\n         decr_refcnt_maybe_free(bcx, Load(bcx, v0), t)\n       }\n       ty::ty_uniq(_) | ty::ty_vec(_) | ty::ty_str {\n@@ -900,6 +913,10 @@ fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n             cx = f(cx, llfld_a, fld.mt.ty);\n         }\n       }\n+      ty::ty_estr(ty::vstore_fixed(n)) |\n+      ty::ty_evec(_, ty::vstore_fixed(n)) {\n+        cx = tvec::iter_vec_raw(cx, av, t, C_uint(cx.ccx(), n), f);\n+      }\n       ty::ty_tup(args) {\n         for vec::eachi(args) {|i, arg|\n             let llfld_a = GEPi(cx, av, [0, i as int]);\n@@ -1111,8 +1128,14 @@ fn drop_ty(cx: block, v: ValueRef, t: ty::t) -> block {\n fn drop_ty_immediate(bcx: block, v: ValueRef, t: ty::t) -> block {\n     let _icx = bcx.insn_ctxt(\"drop_ty_immediate\");\n     alt ty::get(t).struct {\n-      ty::ty_uniq(_) | ty::ty_vec(_) | ty::ty_str { free_ty(bcx, v, t) }\n-      ty::ty_box(_) | ty::ty_opaque_box {\n+      ty::ty_uniq(_) | ty::ty_vec(_) | ty::ty_str |\n+      ty::ty_evec(_, ty::vstore_uniq) |\n+      ty::ty_estr(ty::vstore_uniq) {\n+        free_ty(bcx, v, t)\n+      }\n+      ty::ty_box(_) | ty::ty_opaque_box |\n+      ty::ty_evec(_, ty::vstore_box) |\n+      ty::ty_estr(ty::vstore_box) {\n         decr_refcnt_maybe_free(bcx, v, t)\n       }\n       _ { bcx.tcx().sess.bug(\"drop_ty_immediate: non-box ty\"); }\n@@ -1122,14 +1145,20 @@ fn drop_ty_immediate(bcx: block, v: ValueRef, t: ty::t) -> block {\n fn take_ty_immediate(bcx: block, v: ValueRef, t: ty::t) -> result {\n     let _icx = bcx.insn_ctxt(\"take_ty_immediate\");\n     alt ty::get(t).struct {\n-      ty::ty_box(_) | ty::ty_opaque_box {\n+      ty::ty_box(_) | ty::ty_opaque_box |\n+      ty::ty_evec(_, ty::vstore_box) |\n+      ty::ty_estr(ty::vstore_box) {\n         incr_refcnt_of_boxed(bcx, v);\n         rslt(bcx, v)\n       }\n       ty::ty_uniq(_) {\n         uniq::duplicate(bcx, v, t)\n       }\n-      ty::ty_str | ty::ty_vec(_) { tvec::duplicate(bcx, v, t) }\n+      ty::ty_str | ty::ty_vec(_) |\n+      ty::ty_evec(_, ty::vstore_uniq) |\n+      ty::ty_estr(ty::vstore_uniq) {\n+        tvec::duplicate(bcx, v, t)\n+      }\n       _ { rslt(bcx, v) }\n     }\n }\n@@ -1299,9 +1328,9 @@ fn trans_lit(cx: block, lit: ast::lit, dest: dest) -> block {\n     let _icx = cx.insn_ctxt(\"trans_lit\");\n     if dest == ignore { ret cx; }\n     alt lit.node {\n-      ast::lit_str(s) { ret tvec::trans_str(cx, s, dest); }\n+      ast::lit_str(s) { tvec::trans_str(cx, s, dest) }\n       _ {\n-        ret store_in_dest(cx, trans_crate_lit(cx.ccx(), lit), dest);\n+        store_in_dest(cx, trans_crate_lit(cx.ccx(), lit), dest)\n       }\n     }\n }\n@@ -2255,8 +2284,29 @@ fn trans_index(cx: block, ex: @ast::expr, base: @ast::expr,\n     maybe_name_value(cx.ccx(), unit_sz, \"unit_sz\");\n     let scaled_ix = Mul(bcx, ix_val, unit_sz);\n     maybe_name_value(cx.ccx(), scaled_ix, \"scaled_ix\");\n-    let lim = tvec::get_fill(bcx, v);\n-    let body = tvec::get_dataptr(bcx, v, type_of(ccx, unit_ty));\n+\n+    let (lim,  body) = alt ty::get(base_ty).struct {\n+      ty::ty_estr(ty::vstore_fixed(n)) |\n+      ty::ty_evec(_, ty::vstore_fixed(n)) {\n+        // FIXME: support static bounds-check elimination\n+        // and/or error checking here.\n+        let lim = C_uint(bcx.ccx(), n);\n+        let body = GEPi(bcx, v, [0, 0]);\n+        (lim, body)\n+      }\n+      ty::ty_estr(_) | ty::ty_evec(_, _) {\n+        bcx.sess().unimpl(#fmt(\"unsupported evec/estr type trans_index\"));\n+      }\n+      _ {\n+        let lim = tvec::get_fill(bcx, v);\n+        let body = tvec::get_dataptr(bcx, v, type_of(ccx, unit_ty));\n+        (lim, body)\n+      }\n+    };\n+\n+    #debug(\"trans_index: lim %s\", val_str(bcx.ccx().tn, lim));\n+    #debug(\"trans_index: body %s\", val_str(bcx.ccx().tn, body));\n+\n     let bounds_check = ICmp(bcx, lib::llvm::IntUGE, scaled_ix, lim);\n     let bcx = with_cond(bcx, bounds_check) {|bcx|\n         // fail: bad bounds check.\n@@ -3017,6 +3067,7 @@ fn trans_expr(bcx: block, e: @ast::expr, dest: dest) -> block {\n         ret trans_rec(bcx, args, base, e.id, dest);\n       }\n       ast::expr_tup(args) { ret trans_tup(bcx, args, dest); }\n+      ast::expr_vstore(e, v) { ret tvec::trans_vstore(bcx, e, v, dest); }\n       ast::expr_lit(lit) { ret trans_lit(bcx, *lit, dest); }\n       ast::expr_vec(args, _) { ret tvec::trans_vec(bcx, args, e.id, dest); }\n       ast::expr_binary(op, lhs, rhs) {"}, {"sha": "f79a77ce1d6bc1200092dac3630de21089720354", "filename": "src/rustc/middle/trans/shape.rs", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/7a3b29024548e1dcb13590002d5cf4dd94ddd4d4/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a3b29024548e1dcb13590002d5cf4dd94ddd4d4/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs?ref=7a3b29024548e1dcb13590002d5cf4dd94ddd4d4", "patch": "@@ -58,6 +58,8 @@ const shape_bare_fn: u8 = 27u8;\n const shape_tydesc: u8 = 28u8;\n const shape_send_tydesc: u8 = 29u8;\n const shape_rptr: u8 = 31u8;\n+const shape_fixedvec: u8 = 32u8;\n+const shape_slice: u8 = 33u8;\n \n fn hash_res_info(ri: res_info) -> uint {\n     let mut h = 5381u;\n@@ -305,6 +307,7 @@ fn shape_of(ccx: @crate_ctxt, t: ty::t, ty_param_map: [uint]) -> [u8] {\n       ty::ty_int(ast::ty_i64) { [shape_i64] }\n       ty::ty_float(ast::ty_f32) { [shape_f32] }\n       ty::ty_float(ast::ty_f64) { [shape_f64] }\n+      ty::ty_estr(ty::vstore_uniq) |\n       ty::ty_str {\n         let mut s = [shape_vec];\n         add_bool(s, true); // type is POD\n@@ -340,18 +343,67 @@ fn shape_of(ccx: @crate_ctxt, t: ty::t, ty_param_map: [uint]) -> [u8] {\n           }\n         }\n       }\n+      ty::ty_estr(ty::vstore_box) |\n+      ty::ty_evec(_, ty::vstore_box) |\n       ty::ty_box(_) | ty::ty_opaque_box { [shape_box] }\n       ty::ty_uniq(mt) {\n         let mut s = [shape_uniq];\n         add_substr(s, shape_of(ccx, mt.ty, ty_param_map));\n         s\n       }\n+      ty::ty_evec(mt, ty::vstore_uniq) |\n       ty::ty_vec(mt) {\n         let mut s = [shape_vec];\n         add_bool(s, ty::type_is_pod(ccx.tcx, mt.ty));\n         add_substr(s, shape_of(ccx, mt.ty, ty_param_map));\n         s\n       }\n+\n+      // FIXME: grotesque hacks for encoding fixed-size evecs and estrs.\n+\n+      ty::ty_estr(ty::vstore_fixed(n)) {\n+        let mut s = [shape_struct], sub = [];\n+        let mut i = 0u;\n+        let u8_t = ty::mk_mach_uint(ccx.tcx, ast::ty_u8);\n+        while i < n {\n+            sub += shape_of(ccx, u8_t, ty_param_map);\n+        }\n+        add_substr(s, sub);\n+        s\n+      }\n+\n+      ty::ty_evec(mt, ty::vstore_fixed(n)) {\n+        let mut s = [shape_struct], sub = [];\n+        let mut i = 0u;\n+        while i < n {\n+            sub += shape_of(ccx, mt.ty, ty_param_map);\n+        }\n+        add_substr(s, sub);\n+        s\n+      }\n+\n+\n+      // FIXME: slightly-less-grotesque hack for encoding slic,e evecs and\n+      // estrs.\n+\n+      ty::ty_estr(ty::vstore_slice(r)) {\n+        let mut s = [shape_struct], sub = [];\n+        let u8_mt = {ty: ty::mk_mach_uint(ccx.tcx, ast::ty_u8),\n+                     mutbl: ast::m_imm };\n+        sub += shape_of(ccx, ty::mk_rptr(ccx.tcx, r, u8_mt), ty_param_map);\n+        sub += shape_of(ccx, ty::mk_uint(ccx.tcx), ty_param_map);\n+        add_substr(s, sub);\n+        s\n+      }\n+\n+      ty::ty_evec(mt, ty::vstore_slice(r)) {\n+        let mut s = [shape_struct], sub = [];\n+        sub += shape_of(ccx, ty::mk_rptr(ccx.tcx, r, mt), ty_param_map);\n+        sub += shape_of(ccx, ty::mk_uint(ccx.tcx), ty_param_map);\n+        add_substr(s, sub);\n+        s\n+      }\n+\n       ty::ty_rec(fields) {\n         let mut s = [shape_struct], sub = [];\n         for vec::each(fields) {|f|\n@@ -632,12 +684,18 @@ fn simplify_type(tcx: ty::ctxt, typ: ty::t) -> ty::t {\n     fn simplifier(tcx: ty::ctxt, typ: ty::t) -> ty::t {\n         alt ty::get(typ).struct {\n           ty::ty_box(_) | ty::ty_opaque_box | ty::ty_uniq(_) | ty::ty_vec(_) |\n+          ty::ty_evec(_, ty::vstore_uniq) | ty::ty_evec(_, ty::vstore_box) |\n+          ty::ty_estr(ty::vstore_uniq) | ty::ty_estr(ty::vstore_box) |\n           ty::ty_ptr(_) | ty::ty_rptr(_,_) { nilptr(tcx) }\n           ty::ty_fn(_) { ty::mk_tup(tcx, [nilptr(tcx), nilptr(tcx)]) }\n           ty::ty_res(_, sub, tps) {\n             let sub1 = ty::substitute_type_params(tcx, tps, sub);\n             ty::mk_tup(tcx, [ty::mk_int(tcx), simplify_type(tcx, sub1)])\n           }\n+          ty::ty_evec(_, ty::vstore_slice(_)) |\n+          ty::ty_estr(ty::vstore_slice(_)) {\n+            ty::mk_tup(tcx, [nilptr(tcx), ty::mk_int(tcx)])\n+          }\n           _ { typ }\n         }\n     }"}, {"sha": "bce423e37e4c9eb4ee508c36ec5d8f857c0ec589", "filename": "src/rustc/middle/trans/tvec.rs", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/7a3b29024548e1dcb13590002d5cf4dd94ddd4d4/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a3b29024548e1dcb13590002d5cf4dd94ddd4d4/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=7a3b29024548e1dcb13590002d5cf4dd94ddd4d4", "patch": "@@ -6,6 +6,7 @@ import base::{call_memmove, shared_malloc,\n                INIT, copy_val, load_if_immediate, get_tydesc,\n                sub_block, do_spill_noroot,\n                dest, bcx_icx};\n+import syntax::codemap::span;\n import shape::llsize_of;\n import build::*;\n import common::*;\n@@ -129,6 +130,48 @@ fn trans_vec(bcx: block, args: [@ast::expr], id: ast::node_id,\n     ret base::store_in_dest(bcx, vptr, dest);\n }\n \n+fn trans_vstore(bcx: block, e: @ast::expr,\n+                v: ast::vstore, dest: dest) -> block {\n+    alt e.node {\n+      ast::expr_lit(@{node: ast::lit_str(s), span: _}) {\n+        ret trans_estr(bcx, s, v, e.span, dest);\n+      }\n+      ast::expr_vec(es, mutbl) {\n+        bcx.ccx().sess.span_unimpl(e.span, \"unhandled tvec::trans_vstore\");\n+      }\n+      _ {\n+        bcx.sess().span_bug(e.span, \"vstore on non-sequence type\");\n+      }\n+    }\n+}\n+\n+fn trans_estr(bcx: block, s: str, vstore: ast::vstore,\n+              sp: span, dest: dest) -> block {\n+    let _icx = bcx.insn_ctxt(\"tvec::trans_estr\");\n+    alt vstore {\n+      ast::vstore_fixed(_)\n+      {\n+        let c = str::as_bytes(s) {|bytes|\n+            // NB: The byte vector we have here includes the trailing \\0,\n+            // but we are doing a fixed-size str, meaning we _exclude_\n+            // the trailing \\0. And we don't let LLVM null-terminate\n+            // either.\n+            unsafe {\n+                lib::llvm::llvm::LLVMConstString(\n+                    unsafe::reinterpret_cast(vec::unsafe::to_ptr(bytes)),\n+                    (bytes.len() - 1u) as libc::c_uint, lib::llvm::True)\n+            }\n+        };\n+\n+        #debug(\"trans_estr: src %s\",val_str(bcx.ccx().tn, c));\n+        ret base::store_in_dest(bcx, c, dest);\n+      }\n+      _ {\n+        bcx.ccx().sess.span_unimpl(sp, \"unhandled tvec::trans_estr\");\n+      }\n+    }\n+}\n+\n fn trans_str(bcx: block, s: str, dest: dest) -> block {\n     let _icx = bcx.insn_ctxt(\"tvec::trans_str\");\n     let ccx = bcx.ccx();"}, {"sha": "6e24b4c72a17dd01737875f7a6cdc2854c48816f", "filename": "src/rustc/middle/trans/type_of.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7a3b29024548e1dcb13590002d5cf4dd94ddd4d4/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a3b29024548e1dcb13590002d5cf4dd94ddd4d4/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=7a3b29024548e1dcb13590002d5cf4dd94ddd4d4", "patch": "@@ -48,14 +48,37 @@ fn type_of(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n       ty::ty_int(t) { T_int_ty(cx, t) }\n       ty::ty_uint(t) { T_uint_ty(cx, t) }\n       ty::ty_float(t) { T_float_ty(cx, t) }\n+      ty::ty_estr(ty::vstore_uniq) |\n       ty::ty_str { T_ptr(T_vec(cx, T_i8())) }\n       ty::ty_enum(did, _) { type_of_enum(cx, did, t) }\n+      ty::ty_estr(ty::vstore_box) { T_ptr(T_box(cx, T_i8())) }\n+      ty::ty_evec(mt, ty::vstore_box) |\n       ty::ty_box(mt) { T_ptr(T_box(cx, type_of(cx, mt.ty))) }\n       ty::ty_opaque_box { T_ptr(T_box(cx, T_i8())) }\n       ty::ty_uniq(mt) { T_ptr(type_of(cx, mt.ty)) }\n+      ty::ty_evec(mt, ty::vstore_uniq) |\n       ty::ty_vec(mt) { T_ptr(T_vec(cx, type_of(cx, mt.ty))) }\n       ty::ty_ptr(mt) { T_ptr(type_of(cx, mt.ty)) }\n       ty::ty_rptr(_, mt) { T_ptr(type_of(cx, mt.ty)) }\n+\n+      ty::ty_evec(mt, ty::vstore_slice(_)) {\n+        T_struct([T_ptr(type_of(cx, mt.ty)),\n+                  T_uint_ty(cx, ast::ty_u)])\n+      }\n+\n+      ty::ty_estr(ty::vstore_slice(_)) {\n+        T_struct([T_ptr(T_i8()),\n+                  T_uint_ty(cx, ast::ty_u)])\n+      }\n+\n+      ty::ty_estr(ty::vstore_fixed(n)) {\n+        T_array(T_i8(), n)\n+      }\n+\n+      ty::ty_evec(mt, ty::vstore_fixed(n)) {\n+        T_array(type_of(cx, mt.ty), n)\n+      }\n+\n       ty::ty_rec(fields) {\n         let mut tys: [TypeRef] = [];\n         for vec::each(fields) {|f|"}, {"sha": "4b993f8224cb4c166ec963cd9f9dc39e7bf736ae", "filename": "src/rustc/middle/trans/type_use.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a3b29024548e1dcb13590002d5cf4dd94ddd4d4/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a3b29024548e1dcb13590002d5cf4dd94ddd4d4/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=7a3b29024548e1dcb13590002d5cf4dd94ddd4d4", "patch": "@@ -136,7 +136,9 @@ fn node_type_needs(cx: ctx, use: uint, id: node_id) {\n \n fn mark_for_expr(cx: ctx, e: @expr) {\n     alt e.node {\n-      expr_vec(_, _) | expr_rec(_, _) | expr_tup(_) |\n+      expr_vstore(_, _) |\n+      expr_vec(_, _) |\n+      expr_rec(_, _) | expr_tup(_) |\n       expr_unary(box(_), _) | expr_unary(uniq(_), _) |\n       expr_cast(_, _) | expr_binary(add, _, _) |\n       expr_copy(_) | expr_move(_, _) {"}, {"sha": "fc74db67b37976fbddad86b32b2d875751af9ae5", "filename": "src/rustc/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7a3b29024548e1dcb13590002d5cf4dd94ddd4d4/src%2Frustc%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a3b29024548e1dcb13590002d5cf4dd94ddd4d4/src%2Frustc%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=7a3b29024548e1dcb13590002d5cf4dd94ddd4d4", "patch": "@@ -321,7 +321,14 @@ fn find_pre_post_expr(fcx: fn_ctxt, e: @expr) {\n           _ { }\n         }\n       }\n-      expr_vec(args, _) { find_pre_post_exprs(fcx, args, e.id); }\n+      expr_vstore(ee, _) {\n+        find_pre_post_expr(fcx, ee);\n+        let p = expr_pp(fcx.ccx, ee);\n+        set_pre_and_post(fcx.ccx, e.id, p.precondition, p.postcondition);\n+      }\n+      expr_vec(args, _) {\n+        find_pre_post_exprs(fcx, args, e.id);\n+      }\n       expr_path(p) {\n         let rslt = expr_pp(fcx.ccx, e);\n         clear_pp(rslt);"}, {"sha": "7d3016a663610e201110de4ab22102cd73057f69", "filename": "src/rustc/middle/tstate/states.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7a3b29024548e1dcb13590002d5cf4dd94ddd4d4/src%2Frustc%2Fmiddle%2Ftstate%2Fstates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a3b29024548e1dcb13590002d5cf4dd94ddd4d4/src%2Frustc%2Fmiddle%2Ftstate%2Fstates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fstates.rs?ref=7a3b29024548e1dcb13590002d5cf4dd94ddd4d4", "patch": "@@ -358,6 +358,12 @@ fn find_pre_post_state_expr(fcx: fn_ctxt, pres: prestate, e: @expr) -> bool {\n       expr_new(p, _, v) {\n         ret find_pre_post_state_two(fcx, pres, p, v, e.id, oper_pure);\n       }\n+      expr_vstore(ee, _) {\n+        let mut changed = find_pre_post_state_expr(fcx, pres, ee);\n+        set_prestate_ann(fcx.ccx, e.id, expr_prestate(fcx.ccx, ee));\n+        set_poststate_ann(fcx.ccx, e.id, expr_poststate(fcx.ccx, ee));\n+        ret changed;\n+      }\n       expr_vec(elts, _) {\n         ret find_pre_post_state_exprs(fcx, pres, e.id,\n                                       vec::from_elem(vec::len(elts),"}, {"sha": "4994fe24ed303e4eb3ca5931da0d7946a600c5a8", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 131, "deletions": 34, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/7a3b29024548e1dcb13590002d5cf4dd94ddd4d4/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a3b29024548e1dcb13590002d5cf4dd94ddd4d4/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=7a3b29024548e1dcb13590002d5cf4dd94ddd4d4", "patch": "@@ -80,6 +80,9 @@ export ty_fn_proto, ty_fn_ret, ty_fn_ret_style;\n export ty_int, mk_int, mk_mach_int, mk_char;\n export ty_str, mk_str, type_is_str;\n export ty_vec, mk_vec, type_is_vec;\n+export ty_estr, mk_estr;\n+export ty_evec, mk_evec;\n+export vstore, vstore_fixed, vstore_uniq, vstore_box, vstore_slice;\n export ty_nil, mk_nil, type_is_nil;\n export ty_iface, mk_iface;\n export ty_res, mk_res;\n@@ -164,6 +167,13 @@ type constr_table = hashmap<ast::node_id, [constr]>;\n \n type mt = {ty: t, mutbl: ast::mutability};\n \n+enum vstore {\n+    vstore_fixed(uint),\n+    vstore_uniq,\n+    vstore_box,\n+    vstore_slice(region)\n+}\n+\n type field_ty = {\n   ident: ident,\n   id: def_id,\n@@ -293,10 +303,12 @@ enum sty {\n     ty_uint(ast::uint_ty),\n     ty_float(ast::float_ty),\n     ty_str,\n+    ty_estr(vstore),\n     ty_enum(def_id, [t]),\n     ty_box(mt),\n     ty_uniq(mt),\n     ty_vec(mt),\n+    ty_evec(mt, vstore),\n     ty_ptr(mt),\n     ty_rptr(region, mt),\n     ty_rec([field]),\n@@ -458,8 +470,15 @@ fn mk_t_with_id(cx: ctxt, st: sty, o_def_id: option<ast::def_id>) -> t {\n         has_rptrs |= t.has_rptrs;\n     }\n     alt st {\n+      ty_estr(vstore_slice(_)) {\n+        has_rptrs = true;\n+      }\n+      ty_evec(mt, vstore_slice(_)) {\n+        has_rptrs = true;\n+        derive_flags(has_params, has_vars, has_rptrs, mt.ty);\n+      }\n       ty_nil | ty_bot | ty_bool | ty_int(_) | ty_float(_) | ty_uint(_) |\n-      ty_str | ty_type | ty_opaque_closure_ptr(_) |\n+      ty_str | ty_estr(_) | ty_type | ty_opaque_closure_ptr(_) |\n       ty_opaque_box {}\n       ty_param(_, _) { has_params = true; }\n       ty_var(_) | ty_self(_) { has_vars = true; }\n@@ -468,7 +487,7 @@ fn mk_t_with_id(cx: ctxt, st: sty, o_def_id: option<ast::def_id>) -> t {\n             derive_flags(has_params, has_vars, has_rptrs, tt);\n         }\n       }\n-      ty_box(m) | ty_uniq(m) | ty_vec(m) | ty_ptr(m) {\n+      ty_box(m) | ty_uniq(m) | ty_vec(m) | ty_evec(m, _) | ty_ptr(m) {\n         derive_flags(has_params, has_vars, has_rptrs, m.ty);\n       }\n       ty_rptr(r, m) {\n@@ -536,6 +555,10 @@ fn mk_char(cx: ctxt) -> t { mk_t(cx, ty_int(ast::ty_char)) }\n \n fn mk_str(cx: ctxt) -> t { mk_t(cx, ty_str) }\n \n+fn mk_estr(cx: ctxt, t: vstore) -> t {\n+    mk_t(cx, ty_estr(t))\n+}\n+\n fn mk_enum(cx: ctxt, did: ast::def_id, tys: [t]) -> t {\n     mk_t(cx, ty_enum(did, tys))\n }\n@@ -567,6 +590,10 @@ fn mk_nil_ptr(cx: ctxt) -> t {\n \n fn mk_vec(cx: ctxt, tm: mt) -> t { mk_t(cx, ty_vec(tm)) }\n \n+fn mk_evec(cx: ctxt, tm: mt, t: vstore) -> t {\n+    mk_t(cx, ty_evec(tm, t))\n+}\n+\n fn mk_rec(cx: ctxt, fs: [field]) -> t { mk_t(cx, ty_rec(fs)) }\n \n fn mk_constr(cx: ctxt, t: t, cs: [@type_constr]) -> t {\n@@ -630,9 +657,10 @@ fn maybe_walk_ty(ty: t, f: fn(t) -> bool) {\n     if !f(ty) { ret; }\n     alt get(ty).struct {\n       ty_nil | ty_bot | ty_bool | ty_int(_) | ty_uint(_) | ty_float(_) |\n-      ty_str | ty_type | ty_opaque_box |\n+      ty_str | ty_estr(_) | ty_type | ty_opaque_box |\n       ty_opaque_closure_ptr(_) | ty_var(_) | ty_param(_, _) {}\n-      ty_box(tm) | ty_vec(tm) | ty_ptr(tm) | ty_rptr(_, tm) {\n+      ty_box(tm) | ty_vec(tm) | ty_evec(tm, _) |\n+      ty_ptr(tm) | ty_rptr(_, tm) {\n         maybe_walk_ty(tm.ty, f);\n       }\n       ty_enum(_, subtys) | ty_iface(_, subtys) | ty_class(_, subtys)\n@@ -674,6 +702,9 @@ fn fold_sty(sty: sty, fldop: fn(t) -> t) -> sty {\n       ty_vec(tm) {\n         ty_vec({ty: fldop(tm.ty), mutbl: tm.mutbl})\n       }\n+      ty_evec(tm, vst) {\n+        ty_evec({ty: fldop(tm.ty), mutbl: tm.mutbl}, vst)\n+      }\n       ty_enum(tid, subtys) {\n         ty_enum(tid, vec::map(subtys) {|t| fldop(t) })\n       }\n@@ -718,7 +749,7 @@ fn fold_sty(sty: sty, fldop: fn(t) -> t) -> sty {\n         ty_class(did, new_tps)\n       }\n       ty_nil | ty_bot | ty_bool | ty_int(_) | ty_uint(_) | ty_float(_) |\n-      ty_str | ty_type | ty_opaque_closure_ptr(_) |\n+      ty_str | ty_estr(_) | ty_type | ty_opaque_closure_ptr(_) |\n       ty_opaque_box | ty_var(_) | ty_param(_, _) {\n         sty\n       }\n@@ -751,6 +782,15 @@ fn fold_region(cx: ctxt, t0: t, fldop: fn(region, bool) -> region) -> t {\n             let m_t1 = do_fold(cx, t1, true, fldop);\n             ty::mk_rptr(cx, m_r, {ty: m_t1, mutbl: m})\n           }\n+          ty_estr(vstore_slice(r)) {\n+            let m_r = fldop(r, under_r);\n+            ty::mk_estr(cx, vstore_slice(m_r))\n+          }\n+          ty_evec({ty: t1, mutbl: m}, vstore_slice(r)) {\n+            let m_r = fldop(r, under_r);\n+            let m_t1 = do_fold(cx, t1, true, fldop);\n+            ty::mk_evec(cx, {ty: m_t1, mutbl: m}, vstore_slice(m_r))\n+          }\n           ty_fn(_) {\n             // do not recurse into functions, which introduce fresh bindings\n             t0\n@@ -786,7 +826,8 @@ fn type_is_bool(ty: t) -> bool { get(ty).struct == ty_bool }\n fn type_is_structural(ty: t) -> bool {\n     alt get(ty).struct {\n       ty_rec(_) | ty_class(_,_) | ty_tup(_) | ty_enum(_, _) | ty_fn(_) |\n-      ty_iface(_, _) | ty_res(_, _, _) { true }\n+      ty_iface(_, _) | ty_res(_, _, _) | ty_evec(_, vstore_fixed(_))\n+      | ty_estr(vstore_fixed(_)) { true }\n       _ { false }\n     }\n }\n@@ -797,18 +838,22 @@ fn type_is_copyable(cx: ctxt, ty: t) -> bool {\n \n fn type_is_sequence(ty: t) -> bool {\n     alt get(ty).struct {\n-      ty_str { ret true; }\n-      ty_vec(_) { ret true; }\n-      _ { ret false; }\n+      ty_str | ty_estr(_) | ty_vec(_) | ty_evec(_, _) { true }\n+      _ { false }\n     }\n }\n \n-fn type_is_str(ty: t) -> bool { get(ty).struct == ty_str }\n+fn type_is_str(ty: t) -> bool {\n+    alt get(ty).struct {\n+      ty_str | ty_estr(_) { true }\n+      _ { false }\n+    }\n+}\n \n fn sequence_element_type(cx: ctxt, ty: t) -> t {\n     alt get(ty).struct {\n-      ty_str { ret mk_mach_uint(cx, ast::ty_u8); }\n-      ty_vec(mt) { ret mt.ty; }\n+      ty_str | ty_estr(_) { ret mk_mach_uint(cx, ast::ty_u8); }\n+      ty_vec(mt) | ty_evec(mt, _) { ret mt.ty; }\n       _ { cx.sess.bug(\"sequence_element_type called on non-sequence value\"); }\n     }\n }\n@@ -858,17 +903,17 @@ pure fn type_is_unsafe_ptr(ty: t) -> bool {\n \n pure fn type_is_vec(ty: t) -> bool {\n     ret alt get(ty).struct {\n-          ty_vec(_) { true }\n-          ty_str { true }\n+          ty_vec(_) | ty_evec(_, _) { true }\n+          ty_str | ty_estr(_) { true }\n           _ { false }\n         };\n }\n \n pure fn type_is_unique(ty: t) -> bool {\n     alt get(ty).struct {\n       ty_uniq(_) { ret true; }\n-      ty_vec(_) { true }\n-      ty_str { true }\n+      ty_vec(_) | ty_evec(_, vstore_uniq) { true }\n+      ty_str | ty_estr(vstore_uniq) { true }\n       _ { ret false; }\n     }\n }\n@@ -897,7 +942,10 @@ fn type_needs_drop(cx: ctxt, ty: t) -> bool {\n     let result = alt get(ty).struct {\n       // scalar types\n       ty_nil | ty_bot | ty_bool | ty_int(_) | ty_float(_) | ty_uint(_) |\n-      ty_type | ty_ptr(_) | ty_rptr(_, _) { false }\n+      ty_type | ty_ptr(_) | ty_rptr(_, _) |\n+      ty_estr(vstore_fixed(_)) | ty_estr(vstore_slice(_)) |\n+      ty_evec(_, vstore_slice(_)) { false }\n+      ty_evec(mt, vstore_fixed(_)) { type_needs_drop(cx, mt.ty) }\n       ty_rec(flds) {\n         for flds.each {|f| if type_needs_drop(cx, f.mt.ty) { accum = true; } }\n         accum\n@@ -983,7 +1031,12 @@ fn type_needs_unwind_cleanup_(cx: ctxt, ty: t,\n             }\n             !needs_unwind_cleanup\n           }\n-          ty_uniq(_) | ty_str | ty_vec(_) | ty_res(_, _, _) {\n+          ty_uniq(_) | ty_str | ty_vec(_) | ty_res(_, _, _) |\n+          ty_estr(vstore_uniq) |\n+          ty_estr(vstore_box) |\n+          ty_evec(_, vstore_uniq) |\n+          ty_evec(_, vstore_box)\n+          {\n             // Once we're inside a box, the annihilator will find\n             // it and destroy it.\n             if !encountered_box {\n@@ -1046,6 +1099,17 @@ fn lower_kind(a: kind, b: kind) -> kind {\n     if kind_lteq(a, b) { a } else { b }\n }\n \n+#[test]\n+fn test_kinds() {\n+    // The kind \"lattice\" is nocopy <= copy <= send\n+    assert kind_lteq(kind_sendable, kind_sendable);\n+    assert kind_lteq(kind_copyable, kind_sendable);\n+    assert kind_lteq(kind_copyable, kind_copyable);\n+    assert kind_lteq(kind_noncopyable, kind_sendable);\n+    assert kind_lteq(kind_noncopyable, kind_copyable);\n+    assert kind_lteq(kind_noncopyable, kind_noncopyable);\n+}\n+\n fn type_kind(cx: ctxt, ty: t) -> kind {\n     alt cx.kind_cache.find(ty) {\n       some(result) { ret result; }\n@@ -1061,15 +1125,33 @@ fn type_kind(cx: ctxt, ty: t) -> kind {\n       ty_ptr(_) | ty_str { kind_sendable }\n       ty_type { kind_copyable }\n       ty_fn(f) { proto_kind(f.proto) }\n+\n+      // Closures have kind determined by capture mode\n       ty_opaque_closure_ptr(ck_block) { kind_noncopyable }\n       ty_opaque_closure_ptr(ck_box) { kind_copyable }\n       ty_opaque_closure_ptr(ck_uniq) { kind_sendable }\n-      // Those with refcounts-to-inner raise pinned to shared,\n-      // lower unique to shared. Therefore just set result to shared.\n+\n+      // Those with refcounts raise noncopyable to copyable,\n+      // lower sendable to copyable. Therefore just set result to copyable.\n       ty_box(_) | ty_iface(_, _) | ty_opaque_box { kind_copyable }\n       ty_rptr(_, _) { kind_copyable }\n-      // Boxes and unique pointers raise pinned to shared.\n+\n+      // Unique boxes and vecs have the kind of their contained type.\n       ty_vec(tm) | ty_uniq(tm) { type_kind(cx, tm.ty) }\n+\n+      // Slice and refcounted evecs are copyable; uniques and interiors\n+      // depend on the their contained type.\n+      ty_evec(_, vstore_box) |\n+      ty_evec(_, vstore_slice(_)) { kind_copyable }\n+      ty_evec(tm, vstore_uniq) |\n+      ty_evec(tm, vstore_fixed(_)) { type_kind(cx, tm.ty)  }\n+\n+      // All estrs are copyable; uniques and interiors are sendable.\n+      ty_estr(vstore_box) |\n+      ty_estr(vstore_slice(_)) { kind_copyable }\n+      ty_estr(vstore_uniq) |\n+      ty_estr(vstore_fixed(_)) { kind_sendable  }\n+\n       // Records lower to the lowest of their members.\n       ty_rec(flds) {\n         let mut lowest = kind_sendable;\n@@ -1152,13 +1234,15 @@ fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n           ty_uint(_) |\n           ty_float(_) |\n           ty_str |\n+          ty_estr(_) |\n           ty_fn(_) |\n           ty_var(_) |\n           ty_param(_, _) |\n           ty_self(_) |\n           ty_type |\n           ty_opaque_box |\n           ty_opaque_closure_ptr(_) |\n+          ty_evec(_, _) |\n           ty_vec(_) {\n             false\n           }\n@@ -1277,6 +1361,9 @@ fn type_structurally_contains(cx: ctxt, ty: t, test: fn(sty) -> bool) ->\n         let sty = substitute_type_params(cx, tps, sub);\n         ret type_structurally_contains(cx, sty, test);\n       }\n+      ty_evec(mt, vstore_fixed(_)) {\n+        ret type_structurally_contains(cx, mt.ty, test);\n+      }\n       _ { ret false; }\n     }\n }\n@@ -1288,6 +1375,11 @@ fn type_allows_implicit_copy(cx: ctxt, ty: t) -> bool {\n     ret !type_structurally_contains(cx, ty, {|sty|\n         alt sty {\n           ty_param(_, _) { true }\n+\n+          ty_evec(_, _) | ty_estr(_) {\n+            cx.sess.unimpl(\"estr/evec in type_allows_implicit_copy\");\n+          }\n+\n           ty_vec(mt) {\n             mt.mutbl != ast::m_imm\n           }\n@@ -1302,9 +1394,11 @@ fn type_allows_implicit_copy(cx: ctxt, ty: t) -> bool {\n fn type_structurally_contains_uniques(cx: ctxt, ty: t) -> bool {\n     ret type_structurally_contains(cx, ty, {|sty|\n         alt sty {\n-          ty_uniq(_) { true }\n-          ty_vec(_) { true }\n-          ty_str { true }\n+          ty_uniq(_) |\n+          ty_vec(_) |\n+          ty_evec(_, vstore_uniq) |\n+          ty_str |\n+          ty_estr(vstore_uniq) { true }\n           _ { false }\n         }\n     });\n@@ -1365,6 +1459,10 @@ fn type_is_pod(cx: ctxt, ty: t) -> bool {\n       ty_tup(elts) {\n         for elts.each {|elt| if !type_is_pod(cx, elt) { result = false; } }\n       }\n+      ty_estr(vstore_fixed(_)) { result = true; }\n+      ty_evec(mt, vstore_fixed(_)) {\n+        result = type_is_pod(cx, mt.ty);\n+      }\n       ty_res(_, inner, tps) {\n         result = type_is_pod(cx, substitute_type_params(cx, tps, inner));\n       }\n@@ -1503,13 +1601,15 @@ fn hash_type_structure(st: sty) -> uint {\n       ty_float(t) {\n         alt t { ast::ty_f { 13u } ast::ty_f32 { 14u } ast::ty_f64 { 15u } }\n       }\n+      ty_estr(_) { 16u }\n       ty_str { 17u }\n       ty_enum(did, tys) {\n         let mut h = hash_def(18u, did);\n         for tys.each {|typ| h = hash_subty(h, typ); }\n         h\n       }\n       ty_box(mt) { hash_subty(19u, mt.ty) }\n+      ty_evec(mt, _) { hash_subty(20u, mt.ty) }\n       ty_vec(mt) { hash_subty(21u, mt.ty) }\n       ty_rec(fields) {\n         let mut h = 26u;\n@@ -1849,15 +1949,15 @@ fn set_default_mode(cx: ctxt, m: ast::mode, m_def: ast::rmode) {\n fn ty_sort_str(cx: ctxt, t: t) -> str {\n     alt get(t).struct {\n       ty_nil | ty_bot | ty_bool | ty_int(_) |\n-      ty_uint(_) | ty_float(_) | ty_str | ty_type | ty_opaque_box |\n-      ty_opaque_closure_ptr(_) {\n+      ty_uint(_) | ty_float(_) | ty_estr(_) | ty_str |\n+      ty_type | ty_opaque_box | ty_opaque_closure_ptr(_) {\n         ty_to_str(cx, t)\n       }\n \n       ty_enum(_, _) { \"enum\" }\n       ty_box(_) { \"@-ptr\" }\n       ty_uniq(_) { \"~-ptr\" }\n-      ty_vec(_) { \"vector\" }\n+      ty_evec(_, _) | ty_vec(_) { \"vector\" }\n       ty_ptr(_) { \"*-ptr\" }\n       ty_rptr(_, _) { \"&-ptr\" }\n       ty_rec(_) { \"record\" }\n@@ -2312,14 +2412,11 @@ fn is_binopable(_cx: ctxt, ty: t, op: ast::binop) -> bool {\n     fn tycat(ty: t) -> int {\n         alt get(ty).struct {\n           ty_bool { tycat_bool }\n-          ty_int(_) { tycat_int }\n-          ty_uint(_) { tycat_int }\n+          ty_int(_) | ty_uint(_) { tycat_int }\n           ty_float(_) { tycat_float }\n-          ty_str { tycat_str }\n-          ty_vec(_) { tycat_vec }\n-          ty_rec(_) { tycat_struct }\n-          ty_tup(_) { tycat_struct }\n-          ty_enum(_, _) { tycat_struct }\n+          ty_estr(_) | ty_str { tycat_str }\n+          ty_evec(_, _) | ty_vec(_) { tycat_vec }\n+          ty_rec(_) | ty_tup(_) | ty_enum(_, _) { tycat_struct }\n           ty_bot { tycat_bot }\n           _ { tycat_other }\n         }"}, {"sha": "46e8a2ad096e49df0a67b8b1568c76cc44b9709b", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 88, "deletions": 13, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/7a3b29024548e1dcb13590002d5cf4dd94ddd4d4/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a3b29024548e1dcb13590002d5cf4dd94ddd4d4/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=7a3b29024548e1dcb13590002d5cf4dd94ddd4d4", "patch": "@@ -276,6 +276,53 @@ fn type_is_c_like_enum(fcx: @fn_ctxt, sp: span, typ: ty::t) -> bool {\n \n enum mode { m_collect, m_check, m_check_tyvar(@fn_ctxt), }\n \n+fn ast_region_to_region(tcx: ty::ctxt,\n+                        region: ast::region) -> ty::region {\n+    alt region.node {\n+      ast::re_inferred {\n+        // this must be replaced later by a fixup_regions() pass\n+        ty::re_default\n+      }\n+      ast::re_self | ast::re_named(_) {\n+        tcx.region_map.ast_type_to_region.get(region.id)\n+      }\n+      ast::re_static {\n+        ty::re_static\n+      }\n+    }\n+}\n+\n+fn ast_vstore_to_vstore(tcx: ty::ctxt, span: span, n: option<uint>,\n+                        v: ast::vstore) -> ty::vstore {\n+    alt v {\n+      ast::vstore_fixed(none) {\n+        alt n {\n+          some(n) { ty::vstore_fixed(n) }\n+          none {\n+            tcx.sess.bug(\"implied fixed length in ast_vstore_to_vstore with \\\n+                          no default length\")\n+          }\n+        }\n+      }\n+      ast::vstore_fixed(some(u)) {\n+        alt n {\n+          some(n) if n != u {\n+            tcx.sess.span_err(span,\n+                              #fmt(\"fixed-size sequence mismatch: %u vs. %u\",\n+                                   u, n));\n+          }\n+          _ { }\n+        }\n+        ty::vstore_fixed(u)\n+      }\n+      ast::vstore_uniq { ty::vstore_uniq }\n+      ast::vstore_box { ty::vstore_box }\n+      ast::vstore_slice(region) {\n+        ty::vstore_slice(ast_region_to_region(tcx, region))\n+      }\n+    }\n+}\n+\n // Parses the programmer's textual representation of a type into our\n // internal notion of a type. `getter` is a function that returns the type\n // corresponding to a definition ID:\n@@ -361,19 +408,8 @@ fn ast_ty_to_ty(tcx: ty::ctxt, mode: mode, &&ast_ty: @ast::ty) -> ty::t {\n             ty::mk_ptr(tcx, ast_mt_to_mt(tcx, mode, mt))\n           }\n           ast::ty_rptr(region, mt) {\n-            let r = alt region.node {\n-              ast::re_inferred {\n-                // this must be replaced later by a fixup_regions() pass\n-                ty::re_default\n-              }\n-              ast::re_self | ast::re_named(_) {\n-                tcx.region_map.ast_type_to_region.get(region.id)\n-              }\n-              ast::re_static {\n-                ty::re_static\n-              }\n-            };\n-            ty::mk_rptr(tcx, r, ast_mt_to_mt(tcx, mode, mt))\n+            let region = ast_region_to_region(tcx, region);\n+            ty::mk_rptr(tcx, region, ast_mt_to_mt(tcx, mode, mt))\n           }\n           ast::ty_tup(fields) {\n             let flds = vec::map(fields, bind do_ast_ty_to_ty(tcx, mode, _));\n@@ -436,6 +472,18 @@ fn ast_ty_to_ty(tcx: ty::ctxt, mode: mode, &&ast_ty: @ast::ty) -> ty::t {\n               }\n             }\n           }\n+          ast::ty_vstore(t, vst) {\n+            let vst = ast_vstore_to_vstore(tcx, ast_ty.span, none, vst);\n+            alt ty::get(do_ast_ty_to_ty(tcx, mode, t)).struct {\n+              ty::ty_vec(mt) { ty::mk_evec(tcx, mt, vst) }\n+              ty::ty_str { ty::mk_estr(tcx, vst) }\n+              _ {\n+                tcx.sess.span_fatal(ast_ty.span,\n+                                    \"found sequence storage modifier \\\n+                                     on non-sequence type\");\n+              }\n+            }\n+          }\n           ast::ty_constr(t, cs) {\n             let mut out_cs = [];\n             for cs.each {|constr|\n@@ -2799,6 +2847,31 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n     let id = expr.id;\n     let mut bot = false;\n     alt expr.node {\n+\n+      ast::expr_vstore(ev, vst) {\n+        alt ev.node {\n+          ast::expr_lit(@{node: ast::lit_str(s), span:_}) {\n+            let tt = ast_vstore_to_vstore(tcx, expr.span,\n+                                          some(str::len(s)), vst);\n+            let typ = ty::mk_estr(tcx, tt);\n+            fcx.write_ty(ev.id, typ);\n+            fcx.write_ty(id, typ);\n+          }\n+          ast::expr_vec(args, mutbl) {\n+            let tt = ast_vstore_to_vstore(tcx, expr.span,\n+                                          some(vec::len(args)), vst);\n+            let t: ty::t = next_ty_var(fcx);\n+            for args.each {|e| bot |= check_expr_with(fcx, e, t); }\n+            let typ = ty::mk_evec(tcx, {ty: t, mutbl: mutbl}, tt);\n+            fcx.write_ty(ev.id, typ);\n+            fcx.write_ty(id, typ);\n+          }\n+          _ {\n+            tcx.sess.span_err(expr.span, \"vstore modifier on non-sequence\");\n+          }\n+        }\n+      }\n+\n       ast::expr_lit(lit) {\n         let typ = check_lit(fcx.ccx, lit);\n         fcx.write_ty(id, typ);\n@@ -3319,10 +3392,12 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n         bot |= check_expr(fcx, idx);\n         let idx_t = fcx.expr_ty(idx);\n         alt structure_of(fcx, expr.span, base_t) {\n+          ty::ty_evec(mt, _) |\n           ty::ty_vec(mt) {\n             require_integral(fcx, idx.span, idx_t);\n             fcx.write_ty(id, mt.ty);\n           }\n+          ty::ty_estr(_) |\n           ty::ty_str {\n             require_integral(fcx, idx.span, idx_t);\n             let typ = ty::mk_mach_uint(tcx, ast::ty_u8);"}, {"sha": "d7f7fd6b41a4e0df307d8535d48e9cbbfd8403e6", "filename": "src/test/run-pass/estr-internal.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7a3b29024548e1dcb13590002d5cf4dd94ddd4d4/src%2Ftest%2Frun-pass%2Festr-internal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a3b29024548e1dcb13590002d5cf4dd94ddd4d4/src%2Ftest%2Frun-pass%2Festr-internal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Festr-internal.rs?ref=7a3b29024548e1dcb13590002d5cf4dd94ddd4d4", "patch": "@@ -1,9 +1,8 @@\n-// xfail-test\n fn main() {\n     let x : str/5 = \"hello\"/5;\n-    let y : str/5 = \"there\"/_;\n+    let _y : str/5 = \"there\"/_;\n     let mut z = \"thing\"/_;\n     z = x;\n-    assert z[1] == 'h' as u8;\n-    assert z[4] == 'g' as u8;\n+    assert z[0] == ('h' as u8);\n+    assert z[4] == ('o' as u8);\n }"}]}