{"sha": "ccbf2b76a6ca8ff3ca94e1ff9858089e67f79c04", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNjYmYyYjc2YTZjYThmZjNjYTk0ZTFmZjk4NTgwODllNjdmNzljMDQ=", "commit": {"author": {"name": "David Wood", "email": "david@davidtw.co", "date": "2019-10-05T15:55:58Z"}, "committer": {"name": "David Wood", "email": "david@davidtw.co", "date": "2019-10-08T17:46:24Z"}, "message": "resolve: prohibit foreign statics w/ generics\n\nThis commit modifies resolve to disallow foreign statics that use\nparent generics.\n\n`improper_ctypes` is not written to support type parameters, as these\nare normally disallowed before the lint is run. Thus, type parameters in\nforeign statics must be prohibited before the lint.\n\nThe only other case where this *could* have occured is in functions,\nbut typeck prohibits this with a \"foreign items may not have type\nparameters\" error - a similar error did not exist for statics, because\nstatics cannot have type parameters, but they can use any\ntype parameters that are in scope (which isn't the case for functions).\n\nSigned-off-by: David Wood <david@davidtw.co>", "tree": {"sha": "478bf47fa985e251e40447d86479ab0930d3ddd7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/478bf47fa985e251e40447d86479ab0930d3ddd7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ccbf2b76a6ca8ff3ca94e1ff9858089e67f79c04", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEfgm2/wUjk9OnjxlyJZLnbIc4H9kFAl2cy3EACgkQJZLnbIc4\nH9mq8xAAqhYwBbHO6+hpXOYwavaIW+RgmMOtz1f1kwgi73azkmehylxba1YJ/Ims\nCuPb/zv5/NYkMpbbGHrnNSUU6KPPu7Bll2VqF1fYBKGLLcP/dnTQWw9AFS8fk0ip\nxrnAaCzMis6CD1Wdbo+cdruw5BjnDAU+aak/usA8hj/vcW6CBVCQFK92gfHtx8iT\nUHYHng+U3/MEuL/e2R9s9uRrEBFDei0bqEBbliR2gVsGRrOcizqxvgUWkEgoEnrn\nPKPV5fSzNYwsrJpDpYs5Ps7zgbxzcSa0br/OUgOQDXgkewU/Q8/7s7IAq3vpneB3\nKWpDG29nWgbaE9wXwZbLV1lFZR0lCilFyO8n1SnruRJkTGnJUUdT67H47KXHuoP0\nPAdiSSzH/aTxzSXUtn2Ufh9tpWzKVtit7WzLw1Bn9A2bk1Yt42i1C2lRDnjIF+fP\nI73Crd3Qe02bpVyTpr2CnasZ7y2mdSUyI0HtM7ZytNHm1cxtVwltdcYWKrMOeKv6\n400ip6K1a66nVLnd2NCMOi9WvNy8zln6GhOa3aPpu/DYxxPtzreCaYlCXgg2oxQH\n1YjPp9LP2uyZa8YZh3448aUi1mddXU6IilYN6TC8WkgLcwh5Ynv8G4LzWgqWWNvp\nXlbqJ0Igfhx61pwmXk9hC1xaqAhu3s3Lkl0Tx0noaAsUbd4GnRs=\n=51fl\n-----END PGP SIGNATURE-----", "payload": "tree 478bf47fa985e251e40447d86479ab0930d3ddd7\nparent 7870050796e5904a0fc85ecbe6fa6dde1cfe0c91\nauthor David Wood <david@davidtw.co> 1570290958 +0100\ncommitter David Wood <david@davidtw.co> 1570556784 +0100\n\nresolve: prohibit foreign statics w/ generics\n\nThis commit modifies resolve to disallow foreign statics that use\nparent generics.\n\n`improper_ctypes` is not written to support type parameters, as these\nare normally disallowed before the lint is run. Thus, type parameters in\nforeign statics must be prohibited before the lint.\n\nThe only other case where this *could* have occured is in functions,\nbut typeck prohibits this with a \"foreign items may not have type\nparameters\" error - a similar error did not exist for statics, because\nstatics cannot have type parameters, but they can use any\ntype parameters that are in scope (which isn't the case for functions).\n\nSigned-off-by: David Wood <david@davidtw.co>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ccbf2b76a6ca8ff3ca94e1ff9858089e67f79c04", "html_url": "https://github.com/rust-lang/rust/commit/ccbf2b76a6ca8ff3ca94e1ff9858089e67f79c04", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ccbf2b76a6ca8ff3ca94e1ff9858089e67f79c04/comments", "author": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7870050796e5904a0fc85ecbe6fa6dde1cfe0c91", "url": "https://api.github.com/repos/rust-lang/rust/commits/7870050796e5904a0fc85ecbe6fa6dde1cfe0c91", "html_url": "https://github.com/rust-lang/rust/commit/7870050796e5904a0fc85ecbe6fa6dde1cfe0c91"}], "stats": {"total": 447, "additions": 266, "deletions": 181}, "files": [{"sha": "8aab2b97a00603e66420a779189ced4d0ad6f5ba", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 20, "deletions": 18, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/ccbf2b76a6ca8ff3ca94e1ff9858089e67f79c04/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccbf2b76a6ca8ff3ca94e1ff9858089e67f79c04/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=ccbf2b76a6ca8ff3ca94e1ff9858089e67f79c04", "patch": "@@ -20,7 +20,7 @@ use syntax_pos::{BytePos, Span, MultiSpan};\n \n use crate::resolve_imports::{ImportDirective, ImportDirectiveSubclass, ImportResolver};\n use crate::{path_names_to_string, KNOWN_TOOLS};\n-use crate::{BindingError, CrateLint, LegacyScope, Module, ModuleOrUniformRoot};\n+use crate::{BindingError, CrateLint, HasGenericParams, LegacyScope, Module, ModuleOrUniformRoot};\n use crate::{PathResult, ParentScope, ResolutionError, Resolver, Scope, ScopeSet, Segment};\n \n type Res = def::Res<ast::NodeId>;\n@@ -102,7 +102,7 @@ impl<'a> Resolver<'a> {\n         &self, span: Span, resolution_error: ResolutionError<'_>\n     ) -> DiagnosticBuilder<'_> {\n         match resolution_error {\n-            ResolutionError::GenericParamsFromOuterFunction(outer_res) => {\n+            ResolutionError::GenericParamsFromOuterFunction(outer_res, has_generic_params) => {\n                 let mut err = struct_span_err!(self.session,\n                     span,\n                     E0401,\n@@ -148,22 +148,24 @@ impl<'a> Resolver<'a> {\n                     }\n                 }\n \n-                // Try to retrieve the span of the function signature and generate a new message\n-                // with a local type or const parameter.\n-                let sugg_msg = &format!(\"try using a local generic parameter instead\");\n-                if let Some((sugg_span, new_snippet)) = cm.generate_local_type_param_snippet(span) {\n-                    // Suggest the modification to the user\n-                    err.span_suggestion(\n-                        sugg_span,\n-                        sugg_msg,\n-                        new_snippet,\n-                        Applicability::MachineApplicable,\n-                    );\n-                } else if let Some(sp) = cm.generate_fn_name_span(span) {\n-                    err.span_label(sp,\n-                        format!(\"try adding a local generic parameter in this method instead\"));\n-                } else {\n-                    err.help(&format!(\"try using a local generic parameter instead\"));\n+                if has_generic_params == HasGenericParams::Yes {\n+                    // Try to retrieve the span of the function signature and generate a new\n+                    // message with a local type or const parameter.\n+                    let sugg_msg = &format!(\"try using a local generic parameter instead\");\n+                    if let Some((sugg_span, snippet)) = cm.generate_local_type_param_snippet(span) {\n+                        // Suggest the modification to the user\n+                        err.span_suggestion(\n+                            sugg_span,\n+                            sugg_msg,\n+                            snippet,\n+                            Applicability::MachineApplicable,\n+                        );\n+                    } else if let Some(sp) = cm.generate_fn_name_span(span) {\n+                        err.span_label(sp,\n+                            format!(\"try adding a local generic parameter in this method instead\"));\n+                    } else {\n+                        err.help(&format!(\"try using a local generic parameter instead\"));\n+                    }\n                 }\n \n                 err"}, {"sha": "bb9f895c5f39b67aa0d89c2ab990da75c05b8fd6", "filename": "src/librustc_resolve/late.rs", "status": "modified", "additions": 116, "deletions": 139, "changes": 255, "blob_url": "https://github.com/rust-lang/rust/blob/ccbf2b76a6ca8ff3ca94e1ff9858089e67f79c04/src%2Flibrustc_resolve%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccbf2b76a6ca8ff3ca94e1ff9858089e67f79c04/src%2Flibrustc_resolve%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate.rs?ref=ccbf2b76a6ca8ff3ca94e1ff9858089e67f79c04", "patch": "@@ -5,7 +5,6 @@\n //! If you wonder why there's no `early.rs`, that's because it's split into three files -\n //! `build_reduced_graph.rs`, `macros.rs` and `resolve_imports.rs`.\n \n-use GenericParameters::*;\n use RibKind::*;\n \n use crate::{path_names_to_string, BindingError, CrateLint, LexicalScopeBinding};\n@@ -46,16 +45,6 @@ struct BindingInfo {\n     binding_mode: BindingMode,\n }\n \n-#[derive(Copy, Clone)]\n-enum GenericParameters<'a, 'b> {\n-    NoGenericParams,\n-    HasGenericParams(// Type parameters.\n-                      &'b Generics,\n-\n-                      // The kind of the rib used for type parameters.\n-                      RibKind<'a>),\n-}\n-\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n enum PatternSource {\n     Match,\n@@ -85,6 +74,10 @@ enum PatBoundCtx {\n     Or,\n }\n \n+/// Does this the item (from the item rib scope) allow generic parameters?\n+#[derive(Copy, Clone, Debug, Eq, PartialEq)]\n+crate enum HasGenericParams { Yes, No }\n+\n /// The rib kind restricts certain accesses,\n /// e.g. to a `Res::Local` of an outer item.\n #[derive(Copy, Clone, Debug)]\n@@ -103,7 +96,7 @@ crate enum RibKind<'a> {\n     FnItemRibKind,\n \n     /// We passed through an item scope. Disallow upvars.\n-    ItemRibKind,\n+    ItemRibKind(HasGenericParams),\n \n     /// We're in a constant item. Can't refer to dynamic stuff.\n     ConstantItemRibKind,\n@@ -134,7 +127,7 @@ impl RibKind<'_> {\n             | ModuleRibKind(_)\n             | MacroDefinition(_) => false,\n             AssocItemRibKind\n-            | ItemRibKind\n+            | ItemRibKind(_)\n             | ForwardTyParamBanRibKind\n             | TyParamAsConstParamTy => true,\n         }\n@@ -406,17 +399,21 @@ impl<'a, 'tcx> Visitor<'tcx> for LateResolutionVisitor<'a, '_> {\n         visit::walk_poly_trait_ref(self, tref, m);\n     }\n     fn visit_foreign_item(&mut self, foreign_item: &'tcx ForeignItem) {\n-        let generic_params = match foreign_item.kind {\n+        match foreign_item.kind {\n             ForeignItemKind::Fn(_, ref generics) => {\n-                HasGenericParams(generics, ItemRibKind)\n+                self.with_generic_param_rib(generics, ItemRibKind(HasGenericParams::Yes), |this| {\n+                    visit::walk_foreign_item(this, foreign_item);\n+                });\n             }\n-            ForeignItemKind::Static(..) => NoGenericParams,\n-            ForeignItemKind::Ty => NoGenericParams,\n-            ForeignItemKind::Macro(..) => NoGenericParams,\n-        };\n-        self.with_generic_param_rib(generic_params, |this| {\n-            visit::walk_foreign_item(this, foreign_item);\n-        });\n+            ForeignItemKind::Static(..) => {\n+                self.with_item_rib(HasGenericParams::No, |this| {\n+                    visit::walk_foreign_item(this, foreign_item);\n+                });\n+            }\n+            ForeignItemKind::Ty | ForeignItemKind::Macro(..) => {\n+                visit::walk_foreign_item(self, foreign_item);\n+            }\n+        }\n     }\n     fn visit_fn(&mut self, fn_kind: FnKind<'tcx>, declaration: &'tcx FnDecl, _: Span, _: NodeId) {\n         debug!(\"(resolving function) entering function\");\n@@ -660,7 +657,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n     fn resolve_adt(&mut self, item: &Item, generics: &Generics) {\n         debug!(\"resolve_adt\");\n         self.with_current_self_item(item, |this| {\n-            this.with_generic_param_rib(HasGenericParams(generics, ItemRibKind), |this| {\n+            this.with_generic_param_rib(generics, ItemRibKind(HasGenericParams::Yes), |this| {\n                 let item_def_id = this.r.definitions.local_def_id(item.id);\n                 this.with_self_rib(Res::SelfTy(None, Some(item_def_id)), |this| {\n                     visit::walk_item(this, item);\n@@ -719,10 +716,8 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n             ItemKind::TyAlias(_, ref generics) |\n             ItemKind::OpaqueTy(_, ref generics) |\n             ItemKind::Fn(_, _, ref generics, _) => {\n-                self.with_generic_param_rib(\n-                    HasGenericParams(generics, ItemRibKind),\n-                    |this| visit::walk_item(this, item)\n-                );\n+                self.with_generic_param_rib(generics, ItemRibKind(HasGenericParams::Yes),\n+                                            |this| visit::walk_item(this, item));\n             }\n \n             ItemKind::Enum(_, ref generics) |\n@@ -740,43 +735,40 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n \n             ItemKind::Trait(.., ref generics, ref bounds, ref trait_items) => {\n                 // Create a new rib for the trait-wide type parameters.\n-                self.with_generic_param_rib(HasGenericParams(generics, ItemRibKind), |this| {\n+                self.with_generic_param_rib(generics, ItemRibKind(HasGenericParams::Yes), |this| {\n                     let local_def_id = this.r.definitions.local_def_id(item.id);\n                     this.with_self_rib(Res::SelfTy(Some(local_def_id), None), |this| {\n                         this.visit_generics(generics);\n                         walk_list!(this, visit_param_bound, bounds);\n \n                         for trait_item in trait_items {\n                             this.with_trait_items(trait_items, |this| {\n-                                let generic_params = HasGenericParams(\n-                                    &trait_item.generics,\n-                                    AssocItemRibKind,\n-                                );\n-                                this.with_generic_param_rib(generic_params, |this| {\n-                                    match trait_item.kind {\n-                                        TraitItemKind::Const(ref ty, ref default) => {\n-                                            this.visit_ty(ty);\n-\n-                                            // Only impose the restrictions of\n-                                            // ConstRibKind for an actual constant\n-                                            // expression in a provided default.\n-                                            if let Some(ref expr) = *default{\n-                                                this.with_constant_rib(|this| {\n-                                                    this.visit_expr(expr);\n-                                                });\n+                                this.with_generic_param_rib(&trait_item.generics, AssocItemRibKind,\n+                                    |this| {\n+                                        match trait_item.kind {\n+                                            TraitItemKind::Const(ref ty, ref default) => {\n+                                                this.visit_ty(ty);\n+\n+                                                // Only impose the restrictions of\n+                                                // ConstRibKind for an actual constant\n+                                                // expression in a provided default.\n+                                                if let Some(ref expr) = *default{\n+                                                    this.with_constant_rib(|this| {\n+                                                        this.visit_expr(expr);\n+                                                    });\n+                                                }\n                                             }\n-                                        }\n-                                        TraitItemKind::Method(_, _) => {\n-                                            visit::walk_trait_item(this, trait_item)\n-                                        }\n-                                        TraitItemKind::Type(..) => {\n-                                            visit::walk_trait_item(this, trait_item)\n-                                        }\n-                                        TraitItemKind::Macro(_) => {\n-                                            panic!(\"unexpanded macro in resolve!\")\n-                                        }\n-                                    };\n-                                });\n+                                            TraitItemKind::Method(_, _) => {\n+                                                visit::walk_trait_item(this, trait_item)\n+                                            }\n+                                            TraitItemKind::Type(..) => {\n+                                                visit::walk_trait_item(this, trait_item)\n+                                            }\n+                                            TraitItemKind::Macro(_) => {\n+                                                panic!(\"unexpanded macro in resolve!\")\n+                                            }\n+                                        };\n+                                    });\n                             });\n                         }\n                     });\n@@ -785,7 +777,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n \n             ItemKind::TraitAlias(ref generics, ref bounds) => {\n                 // Create a new rib for the trait-wide type parameters.\n-                self.with_generic_param_rib(HasGenericParams(generics, ItemRibKind), |this| {\n+                self.with_generic_param_rib(generics, ItemRibKind(HasGenericParams::Yes), |this| {\n                     let local_def_id = this.r.definitions.local_def_id(item.id);\n                     this.with_self_rib(Res::SelfTy(Some(local_def_id), None), |this| {\n                         this.visit_generics(generics);\n@@ -803,7 +795,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n             ItemKind::Static(ref ty, _, ref expr) |\n             ItemKind::Const(ref ty, ref expr) => {\n                 debug!(\"resolve_item ItemKind::Const\");\n-                self.with_item_rib(|this| {\n+                self.with_item_rib(HasGenericParams::No, |this| {\n                     this.visit_ty(ty);\n                     this.with_constant_rib(|this| {\n                         this.visit_expr(expr);\n@@ -824,91 +816,75 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n         }\n     }\n \n-    fn with_generic_param_rib<'c, F>(&'c mut self, generic_params: GenericParameters<'a, 'c>, f: F)\n+    fn with_generic_param_rib<'c, F>(&'c mut self, generics: &'c Generics, kind: RibKind<'a>, f: F)\n         where F: FnOnce(&mut Self)\n     {\n         debug!(\"with_generic_param_rib\");\n-        match generic_params {\n-            HasGenericParams(generics, rib_kind) => {\n-                let mut function_type_rib = Rib::new(rib_kind);\n-                let mut function_value_rib = Rib::new(rib_kind);\n-                let mut seen_bindings = FxHashMap::default();\n-                // We also can't shadow bindings from the parent item\n-                if let AssocItemRibKind = rib_kind {\n-                    let mut add_bindings_for_ns = |ns| {\n-                        let parent_rib = self.ribs[ns].iter()\n-                            .rfind(|rib| if let ItemRibKind = rib.kind { true } else { false })\n-                            .expect(\"associated item outside of an item\");\n-                        seen_bindings.extend(\n-                            parent_rib.bindings.iter().map(|(ident, _)| (*ident, ident.span)),\n-                        );\n-                    };\n-                    add_bindings_for_ns(ValueNS);\n-                    add_bindings_for_ns(TypeNS);\n-                }\n-                for param in &generics.params {\n-                    match param.kind {\n-                        GenericParamKind::Lifetime { .. } => {}\n-                        GenericParamKind::Type { .. } => {\n-                            let ident = param.ident.modern();\n-                            debug!(\"with_generic_param_rib: {}\", param.id);\n-\n-                            if seen_bindings.contains_key(&ident) {\n-                                let span = seen_bindings.get(&ident).unwrap();\n-                                let err = ResolutionError::NameAlreadyUsedInParameterList(\n-                                    ident.name,\n-                                    *span,\n-                                );\n-                                self.r.report_error(param.ident.span, err);\n-                            }\n-                            seen_bindings.entry(ident).or_insert(param.ident.span);\n-\n-                            // Plain insert (no renaming).\n-                            let res = Res::Def(\n-                                DefKind::TyParam,\n-                                self.r.definitions.local_def_id(param.id),\n-                            );\n-                            function_type_rib.bindings.insert(ident, res);\n-                            self.r.record_partial_res(param.id, PartialRes::new(res));\n-                        }\n-                        GenericParamKind::Const { .. } => {\n-                            let ident = param.ident.modern();\n-                            debug!(\"with_generic_param_rib: {}\", param.id);\n-\n-                            if seen_bindings.contains_key(&ident) {\n-                                let span = seen_bindings.get(&ident).unwrap();\n-                                let err = ResolutionError::NameAlreadyUsedInParameterList(\n-                                    ident.name,\n-                                    *span,\n-                                );\n-                                self.r.report_error(param.ident.span, err);\n-                            }\n-                            seen_bindings.entry(ident).or_insert(param.ident.span);\n-\n-                            let res = Res::Def(\n-                                DefKind::ConstParam,\n-                                self.r.definitions.local_def_id(param.id),\n-                            );\n-                            function_value_rib.bindings.insert(ident, res);\n-                            self.r.record_partial_res(param.id, PartialRes::new(res));\n-                        }\n-                    }\n-                }\n-                self.ribs[ValueNS].push(function_value_rib);\n-                self.ribs[TypeNS].push(function_type_rib);\n+        let mut function_type_rib = Rib::new(kind);\n+        let mut function_value_rib = Rib::new(kind);\n+        let mut seen_bindings = FxHashMap::default();\n+\n+        // We also can't shadow bindings from the parent item\n+        if let AssocItemRibKind = kind {\n+            let mut add_bindings_for_ns = |ns| {\n+                let parent_rib = self.ribs[ns].iter()\n+                    .rfind(|r| if let ItemRibKind(_) = r.kind { true } else { false })\n+                    .expect(\"associated item outside of an item\");\n+                seen_bindings.extend(\n+                    parent_rib.bindings.iter().map(|(ident, _)| (*ident, ident.span)),\n+                );\n+            };\n+            add_bindings_for_ns(ValueNS);\n+            add_bindings_for_ns(TypeNS);\n+        }\n+\n+        for param in &generics.params {\n+            if let GenericParamKind::Lifetime { .. } = param.kind {\n+                continue;\n             }\n \n-            NoGenericParams => {\n-                // Nothing to do.\n+            let def_kind = match param.kind {\n+                GenericParamKind::Type { .. } => DefKind::TyParam,\n+                GenericParamKind::Const { .. } => DefKind::ConstParam,\n+                _ => unreachable!(),\n+            };\n+\n+            let ident = param.ident.modern();\n+            debug!(\"with_generic_param_rib: {}\", param.id);\n+\n+            if seen_bindings.contains_key(&ident) {\n+                let span = seen_bindings.get(&ident).unwrap();\n+                let err = ResolutionError::NameAlreadyUsedInParameterList(\n+                    ident.name,\n+                    *span,\n+                );\n+                self.r.report_error(param.ident.span, err);\n+            }\n+            seen_bindings.entry(ident).or_insert(param.ident.span);\n+\n+            // Plain insert (no renaming).\n+            let res = Res::Def(def_kind, self.r.definitions.local_def_id(param.id));\n+\n+            match param.kind {\n+                GenericParamKind::Type { .. } => {\n+                    function_type_rib.bindings.insert(ident, res);\n+                    self.r.record_partial_res(param.id, PartialRes::new(res));\n+                }\n+                GenericParamKind::Const { .. } => {\n+                    function_value_rib.bindings.insert(ident, res);\n+                    self.r.record_partial_res(param.id, PartialRes::new(res));\n+                }\n+                _ => unreachable!(),\n             }\n         }\n \n+        self.ribs[ValueNS].push(function_value_rib);\n+        self.ribs[TypeNS].push(function_type_rib);\n+\n         f(self);\n \n-        if let HasGenericParams(..) = generic_params {\n-            self.ribs[TypeNS].pop();\n-            self.ribs[ValueNS].pop();\n-        }\n+        self.ribs[TypeNS].pop();\n+        self.ribs[ValueNS].pop();\n     }\n \n     fn with_label_rib(&mut self, kind: RibKind<'a>, f: impl FnOnce(&mut Self)) {\n@@ -917,8 +893,9 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n         self.label_ribs.pop();\n     }\n \n-    fn with_item_rib(&mut self, f: impl FnOnce(&mut Self)) {\n-        self.with_rib(ValueNS, ItemRibKind, |this| this.with_rib(TypeNS, ItemRibKind, f))\n+    fn with_item_rib(&mut self, has_generic_params: HasGenericParams, f: impl FnOnce(&mut Self)) {\n+        let kind = ItemRibKind(has_generic_params);\n+        self.with_rib(ValueNS, kind, |this| this.with_rib(TypeNS, kind, f))\n     }\n \n     fn with_constant_rib(&mut self, f: impl FnOnce(&mut Self)) {\n@@ -1023,7 +1000,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n                               impl_items: &[ImplItem]) {\n         debug!(\"resolve_implementation\");\n         // If applicable, create a rib for the type parameters.\n-        self.with_generic_param_rib(HasGenericParams(generics, ItemRibKind), |this| {\n+        self.with_generic_param_rib(generics, ItemRibKind(HasGenericParams::Yes), |this| {\n             // Dummy self type for better errors if `Self` is used in the trait path.\n             this.with_self_rib(Res::SelfTy(None, None), |this| {\n                 // Resolve the trait reference, if necessary.\n@@ -1044,9 +1021,9 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n                                 debug!(\"resolve_implementation with_self_rib_ns(ValueNS, ...)\");\n                                 for impl_item in impl_items {\n                                     // We also need a new scope for the impl item type parameters.\n-                                    let generic_params = HasGenericParams(&impl_item.generics,\n-                                                                          AssocItemRibKind);\n-                                    this.with_generic_param_rib(generic_params, |this| {\n+                                    this.with_generic_param_rib(&impl_item.generics,\n+                                                                AssocItemRibKind,\n+                                                                |this| {\n                                         use crate::ResolutionError::*;\n                                         match impl_item.kind {\n                                             ImplItemKind::Const(..) => {"}, {"sha": "acad86c2de8013cc11b246b6745bd834a330bfb6", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 25, "deletions": 21, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/ccbf2b76a6ca8ff3ca94e1ff9858089e67f79c04/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccbf2b76a6ca8ff3ca94e1ff9858089e67f79c04/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=ccbf2b76a6ca8ff3ca94e1ff9858089e67f79c04", "patch": "@@ -61,7 +61,7 @@ use rustc_data_structures::sync::Lrc;\n \n use diagnostics::{Suggestion, ImportSuggestion};\n use diagnostics::{find_span_of_binding_until_next_binding, extend_span_to_previous_binding};\n-use late::{PathSource, Rib, RibKind::*};\n+use late::{HasGenericParams, PathSource, Rib, RibKind::*};\n use resolve_imports::{ImportDirective, ImportDirectiveSubclass, NameResolution, ImportResolver};\n use macros::{LegacyBinding, LegacyScope};\n \n@@ -178,7 +178,7 @@ impl Ord for BindingError {\n \n enum ResolutionError<'a> {\n     /// Error E0401: can't use type or const parameters from outer function.\n-    GenericParamsFromOuterFunction(Res),\n+    GenericParamsFromOuterFunction(Res, HasGenericParams),\n     /// Error E0403: the name is already used for a type or const parameter in this generic\n     /// parameter list.\n     NameAlreadyUsedInParameterList(Name, Span),\n@@ -2167,7 +2167,7 @@ impl<'a> Resolver<'a> {\n                         ForwardTyParamBanRibKind | TyParamAsConstParamTy => {\n                             // Nothing to do. Continue.\n                         }\n-                        ItemRibKind | FnItemRibKind | AssocItemRibKind => {\n+                        ItemRibKind(_) | FnItemRibKind | AssocItemRibKind => {\n                             // This was an attempt to access an upvar inside a\n                             // named function item. This is not allowed, so we\n                             // report an error.\n@@ -2195,22 +2195,23 @@ impl<'a> Resolver<'a> {\n             }\n             Res::Def(DefKind::TyParam, _) | Res::SelfTy(..) => {\n                 for rib in ribs {\n-                    match rib.kind {\n+                    let has_generic_params = match rib.kind {\n                         NormalRibKind | AssocItemRibKind |\n                         ModuleRibKind(..) | MacroDefinition(..) | ForwardTyParamBanRibKind |\n                         ConstantItemRibKind | TyParamAsConstParamTy => {\n                             // Nothing to do. Continue.\n+                            continue;\n                         }\n-                        ItemRibKind | FnItemRibKind => {\n-                            // This was an attempt to use a type parameter outside its scope.\n-                            if record_used {\n-                                self.report_error(\n-                                    span, ResolutionError::GenericParamsFromOuterFunction(res)\n-                                );\n-                            }\n-                            return Res::Err;\n-                        }\n+                        // This was an attempt to use a type parameter outside its scope.\n+                        ItemRibKind(has_generic_params) => has_generic_params,\n+                        FnItemRibKind => HasGenericParams::Yes,\n+                    };\n+\n+                    if record_used {\n+                        self.report_error(span, ResolutionError::GenericParamsFromOuterFunction(\n+                            res, has_generic_params));\n                     }\n+                    return Res::Err;\n                 }\n             }\n             Res::Def(DefKind::ConstParam, _) => {\n@@ -2222,15 +2223,18 @@ impl<'a> Resolver<'a> {\n                     ribs.next();\n                 }\n                 for rib in ribs {\n-                    if let ItemRibKind | FnItemRibKind = rib.kind {\n-                        // This was an attempt to use a const parameter outside its scope.\n-                        if record_used {\n-                            self.report_error(\n-                                span, ResolutionError::GenericParamsFromOuterFunction(res)\n-                            );\n-                        }\n-                        return Res::Err;\n+                    let has_generic_params = match rib.kind {\n+                        ItemRibKind(has_generic_params) => has_generic_params,\n+                        FnItemRibKind => HasGenericParams::Yes,\n+                        _ => continue,\n+                    };\n+\n+                    // This was an attempt to use a const parameter outside its scope.\n+                    if record_used {\n+                        self.report_error(span, ResolutionError::GenericParamsFromOuterFunction(\n+                            res, has_generic_params));\n                     }\n+                    return Res::Err;\n                 }\n             }\n             _ => {}"}, {"sha": "1e74445af55cb0327bb4facb4604e54d0212e01b", "filename": "src/test/ui/inner-static-type-parameter.stderr", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ccbf2b76a6ca8ff3ca94e1ff9858089e67f79c04/src%2Ftest%2Fui%2Finner-static-type-parameter.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ccbf2b76a6ca8ff3ca94e1ff9858089e67f79c04/src%2Ftest%2Fui%2Finner-static-type-parameter.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finner-static-type-parameter.stderr?ref=ccbf2b76a6ca8ff3ca94e1ff9858089e67f79c04", "patch": "@@ -2,9 +2,7 @@ error[E0401]: can't use generic parameters from outer function\n   --> $DIR/inner-static-type-parameter.rs:6:19\n    |\n LL | fn foo<T>() {\n-   |    --- - type parameter from outer function\n-   |    |\n-   |    try adding a local generic parameter in this method instead\n+   |        - type parameter from outer function\n LL |     static a: Bar<T> = Bar::What;\n    |                   ^ use of generic parameter from outer function\n "}, {"sha": "ce45f630e48a58da14702a26e97496b733f17a94", "filename": "src/test/ui/resolve/issue-65025-extern-static-parent-generics.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ccbf2b76a6ca8ff3ca94e1ff9858089e67f79c04/src%2Ftest%2Fui%2Fresolve%2Fissue-65025-extern-static-parent-generics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccbf2b76a6ca8ff3ca94e1ff9858089e67f79c04/src%2Ftest%2Fui%2Fresolve%2Fissue-65025-extern-static-parent-generics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-65025-extern-static-parent-generics.rs?ref=ccbf2b76a6ca8ff3ca94e1ff9858089e67f79c04", "patch": "@@ -0,0 +1,10 @@\n+unsafe fn foo<A>() {\n+    extern \"C\" {\n+        static baz: *const A;\n+        //~^ ERROR can't use generic parameters from outer function\n+    }\n+\n+    let bar: *const u64 = core::mem::transmute(&baz);\n+}\n+\n+fn main() { }"}, {"sha": "6bbf76dd1fbb2a2cafc55b46f2494485989ea044", "filename": "src/test/ui/resolve/issue-65025-extern-static-parent-generics.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ccbf2b76a6ca8ff3ca94e1ff9858089e67f79c04/src%2Ftest%2Fui%2Fresolve%2Fissue-65025-extern-static-parent-generics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ccbf2b76a6ca8ff3ca94e1ff9858089e67f79c04/src%2Ftest%2Fui%2Fresolve%2Fissue-65025-extern-static-parent-generics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-65025-extern-static-parent-generics.stderr?ref=ccbf2b76a6ca8ff3ca94e1ff9858089e67f79c04", "patch": "@@ -0,0 +1,12 @@\n+error[E0401]: can't use generic parameters from outer function\n+  --> $DIR/issue-65025-extern-static-parent-generics.rs:3:28\n+   |\n+LL | unsafe fn foo<A>() {\n+   |               - type parameter from outer function\n+LL |     extern \"C\" {\n+LL |         static baz: *const A;\n+   |                            ^ use of generic parameter from outer function\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0401`."}, {"sha": "63d3431ec9b2f7bb9a62163667bca421bdf8264d", "filename": "src/test/ui/resolve/issue-65035-static-with-parent-generics.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/ccbf2b76a6ca8ff3ca94e1ff9858089e67f79c04/src%2Ftest%2Fui%2Fresolve%2Fissue-65035-static-with-parent-generics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccbf2b76a6ca8ff3ca94e1ff9858089e67f79c04/src%2Ftest%2Fui%2Fresolve%2Fissue-65035-static-with-parent-generics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-65035-static-with-parent-generics.rs?ref=ccbf2b76a6ca8ff3ca94e1ff9858089e67f79c04", "patch": "@@ -0,0 +1,29 @@\n+#![feature(const_generics)]\n+//~^ WARN the feature `const_generics` is incomplete and may cause the compiler to crash\n+\n+fn f<T>() {\n+    extern \"C\" {\n+        static a: *const T;\n+        //~^ ERROR can't use generic parameters from outer function\n+    }\n+}\n+\n+fn g<T: Default>() {\n+    static a: *const T = Default::default();\n+    //~^ ERROR can't use generic parameters from outer function\n+}\n+\n+fn h<const N: usize>() {\n+    extern \"C\" {\n+        static a: [u8; N];\n+        //~^ ERROR can't use generic parameters from outer function\n+    }\n+}\n+\n+fn i<const N: usize>() {\n+    static a: [u8; N] = [0; N];\n+    //~^ ERROR can't use generic parameters from outer function\n+    //~^^ ERROR can't use generic parameters from outer function\n+}\n+\n+fn main() {}"}, {"sha": "82e2aa2db8e25efa6ce3338a2f38c36e91f09211", "filename": "src/test/ui/resolve/issue-65035-static-with-parent-generics.stderr", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/ccbf2b76a6ca8ff3ca94e1ff9858089e67f79c04/src%2Ftest%2Fui%2Fresolve%2Fissue-65035-static-with-parent-generics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ccbf2b76a6ca8ff3ca94e1ff9858089e67f79c04/src%2Ftest%2Fui%2Fresolve%2Fissue-65035-static-with-parent-generics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-65035-static-with-parent-generics.stderr?ref=ccbf2b76a6ca8ff3ca94e1ff9858089e67f79c04", "patch": "@@ -0,0 +1,53 @@\n+error[E0401]: can't use generic parameters from outer function\n+  --> $DIR/issue-65035-static-with-parent-generics.rs:6:26\n+   |\n+LL | fn f<T>() {\n+   |      - type parameter from outer function\n+LL |     extern \"C\" {\n+LL |         static a: *const T;\n+   |                          ^ use of generic parameter from outer function\n+\n+error[E0401]: can't use generic parameters from outer function\n+  --> $DIR/issue-65035-static-with-parent-generics.rs:12:22\n+   |\n+LL | fn g<T: Default>() {\n+   |      - type parameter from outer function\n+LL |     static a: *const T = Default::default();\n+   |                      ^ use of generic parameter from outer function\n+\n+error[E0401]: can't use generic parameters from outer function\n+  --> $DIR/issue-65035-static-with-parent-generics.rs:18:24\n+   |\n+LL | fn h<const N: usize>() {\n+   |            - const parameter from outer function\n+LL |     extern \"C\" {\n+LL |         static a: [u8; N];\n+   |                        ^ use of generic parameter from outer function\n+\n+error[E0401]: can't use generic parameters from outer function\n+  --> $DIR/issue-65035-static-with-parent-generics.rs:24:20\n+   |\n+LL | fn i<const N: usize>() {\n+   |            - const parameter from outer function\n+LL |     static a: [u8; N] = [0; N];\n+   |                    ^ use of generic parameter from outer function\n+\n+error[E0401]: can't use generic parameters from outer function\n+  --> $DIR/issue-65035-static-with-parent-generics.rs:24:29\n+   |\n+LL | fn i<const N: usize>() {\n+   |            - const parameter from outer function\n+LL |     static a: [u8; N] = [0; N];\n+   |                             ^ use of generic parameter from outer function\n+\n+warning: the feature `const_generics` is incomplete and may cause the compiler to crash\n+  --> $DIR/issue-65035-static-with-parent-generics.rs:1:12\n+   |\n+LL | #![feature(const_generics)]\n+   |            ^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+\n+error: aborting due to 5 previous errors\n+\n+For more information about this error, try `rustc --explain E0401`."}]}