{"sha": "b5a4fa9456683f40539f885d4e555b87384df09a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI1YTRmYTk0NTY2ODNmNDA1MzlmODg1ZDRlNTU1Yjg3Mzg0ZGYwOWE=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-03-27T13:14:12Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-03-27T13:46:33Z"}, "message": "Move some code over to iterator-for to see how it performs.", "tree": {"sha": "4e09242efdec937421421d1c2531974026c36144", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4e09242efdec937421421d1c2531974026c36144"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b5a4fa9456683f40539f885d4e555b87384df09a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b5a4fa9456683f40539f885d4e555b87384df09a", "html_url": "https://github.com/rust-lang/rust/commit/b5a4fa9456683f40539f885d4e555b87384df09a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b5a4fa9456683f40539f885d4e555b87384df09a/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cbad6925c1b18bd640ec7077ccd29c735c497972", "url": "https://api.github.com/repos/rust-lang/rust/commits/cbad6925c1b18bd640ec7077ccd29c735c497972", "html_url": "https://github.com/rust-lang/rust/commit/cbad6925c1b18bd640ec7077ccd29c735c497972"}], "stats": {"total": 374, "additions": 194, "deletions": 180}, "files": [{"sha": "00a394167487d27a5d9251a5f079121a229ed2f3", "filename": "src/libcore/either.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b5a4fa9456683f40539f885d4e555b87384df09a/src%2Flibcore%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5a4fa9456683f40539f885d4e555b87384df09a/src%2Flibcore%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Feither.rs?ref=b5a4fa9456683f40539f885d4e555b87384df09a", "patch": "@@ -25,7 +25,7 @@ fn lefts<T: copy, U>(eithers: [either<T, U>]) -> [T] {\n     #[doc = \"Extracts from a vector of either all the left values\"];\n \n     let mut result: [T] = [];\n-    for elt: either<T, U> in eithers {\n+    for vec::each(eithers) {|elt|\n         alt elt { left(l) { result += [l]; } _ {/* fallthrough */ } }\n     }\n     ret result;\n@@ -35,7 +35,7 @@ fn rights<T, U: copy>(eithers: [either<T, U>]) -> [U] {\n     #[doc = \"Extracts from a vector of either all the right values\"];\n \n     let mut result: [U] = [];\n-    for elt: either<T, U> in eithers {\n+    for vec::each(eithers) {|elt|\n         alt elt { right(r) { result += [r]; } _ {/* fallthrough */ } }\n     }\n     ret result;\n@@ -52,7 +52,7 @@ fn partition<T: copy, U: copy>(eithers: [either<T, U>])\n \n     let mut lefts: [T] = [];\n     let mut rights: [U] = [];\n-    for elt: either<T, U> in eithers {\n+    for vec::each(eithers) {|elt|\n         alt elt { left(l) { lefts += [l]; } right(r) { rights += [r]; } }\n     }\n     ret {lefts: lefts, rights: rights};"}, {"sha": "3b97e5e49e30ba8dd981e0fda64ae086083902f5", "filename": "src/libcore/extfmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5a4fa9456683f40539f885d4e555b87384df09a/src%2Flibcore%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5a4fa9456683f40539f885d4e555b87384df09a/src%2Flibcore%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fextfmt.rs?ref=b5a4fa9456683f40539f885d4e555b87384df09a", "patch": "@@ -429,7 +429,7 @@ mod rt {\n         ret padstr + s;\n     }\n     fn have_flag(flags: [flag], f: flag) -> bool {\n-        for candidate: flag in flags { if candidate == f { ret true; } }\n+        for vec::each(flags) {|candidate| if candidate == f { ret true; } }\n         ret false;\n     }\n }"}, {"sha": "5d42012dcce8593abbeea39c46c9808e283c22bf", "filename": "src/libcore/io.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b5a4fa9456683f40539f885d4e555b87384df09a/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5a4fa9456683f40539f885d4e555b87384df09a/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=b5a4fa9456683f40539f885d4e555b87384df09a", "patch": "@@ -389,7 +389,7 @@ fn mk_file_writer(path: str, flags: [fileflag])\n     fn wb() -> c_int { O_WRONLY as c_int }\n \n     let mut fflags: c_int = wb();\n-    for f: fileflag in flags {\n+    for vec::each(flags) {|f|\n         alt f {\n           append { fflags |= O_APPEND as c_int; }\n           create { fflags |= O_CREAT as c_int; }\n@@ -521,7 +521,7 @@ impl of writer for mem_buffer {\n     fn write(v: [const u8]) {\n         // Fast path.\n         if self.pos == vec::len(self.buf) {\n-            for b: u8 in v { self.buf += [mut b]; }\n+            for vec::each(v) {|b| self.buf += [mut b]; }\n             self.pos += vec::len(v);\n             ret;\n         }"}, {"sha": "8d9cd47fdf8bc52486b8f91e312e582a24858b4b", "filename": "src/libcore/os.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b5a4fa9456683f40539f885d4e555b87384df09a/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5a4fa9456683f40539f885d4e555b87384df09a/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=b5a4fa9456683f40539f885d4e555b87384df09a", "patch": "@@ -47,7 +47,7 @@ native mod rustrt {\n \n fn env() -> [(str,str)] {\n     let mut pairs = [];\n-    for p in rustrt::rust_env_pairs() {\n+    for vec::each(rustrt::rust_env_pairs()) {|p|\n         let vs = str::splitn_char(p, '=', 1u);\n         assert vec::len(vs) == 2u;\n         pairs += [(vs[0], vs[1])];\n@@ -464,7 +464,7 @@ fn list_dir(p: path) -> [str] {\n         p += path::path_sep();\n     }\n     let mut full_paths: [str] = [];\n-    for filename: str in rustrt::rust_list_files(p + star()) {\n+    for vec::each(rustrt::rust_list_files(p + star())) {|filename|\n         if !str::eq(filename, \".\") {\n             if !str::eq(filename, \"..\") {\n                 full_paths += [p + filename];\n@@ -645,7 +645,8 @@ mod tests {\n     fn test_env_getenv() {\n         let e = env();\n         assert vec::len(e) > 0u;\n-        for (n, v) in e {\n+        for vec::each(e) {|p|\n+            let (n, v) = p;\n             log(debug, n);\n             let v2 = getenv(n);\n             // MingW seems to set some funky environment variables like\n@@ -734,7 +735,7 @@ mod tests {\n         // Just assuming that we've got some contents in the current directory\n         assert (vec::len(dirs) > 0u);\n \n-        for dir in dirs { log(debug, dir); }\n+        for vec::each(dirs) {|dir| log(debug, dir); }\n     }\n \n     #[test]"}, {"sha": "a3f7cc3a4d8a2ee5dacdbf6344e71db904c50822", "filename": "src/libcore/result.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5a4fa9456683f40539f885d4e555b87384df09a/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5a4fa9456683f40539f885d4e555b87384df09a/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=b5a4fa9456683f40539f885d4e555b87384df09a", "patch": "@@ -139,7 +139,7 @@ checking for overflow:\n fn map<T,U:copy,V:copy>(ts: [T], op: fn(T) -> result<V,U>) -> result<[V],U> {\n     let mut vs: [V] = [];\n     vec::reserve(vs, vec::len(ts));\n-    for t in ts {\n+    for vec::each(ts) {|t|\n         alt op(t) {\n           ok(v) { vs += [v]; }\n           err(u) { ret err(u); }"}, {"sha": "0b82d79b3315d3e95dfa34f8e35907b52dd50e0c", "filename": "src/libcore/run.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b5a4fa9456683f40539f885d4e555b87384df09a/src%2Flibcore%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5a4fa9456683f40539f885d4e555b87384df09a/src%2Flibcore%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frun.rs?ref=b5a4fa9456683f40539f885d4e555b87384df09a", "patch": "@@ -81,7 +81,7 @@ fn with_argv<T>(prog: str, args: [str],\n                 cb: fn(**libc::c_char) -> T) -> T unsafe {\n     let mut argptrs = str::as_c_str(prog) {|b| [b] };\n     let mut tmps = [];\n-    for arg in args {\n+    for vec::each(args) {|arg|\n         let t = @arg;\n         tmps += [t];\n         argptrs += str::as_c_str(*t) {|b| [b] };\n@@ -102,7 +102,8 @@ fn with_envp<T>(env: option<[(str,str)]>,\n         let mut tmps = [];\n         let mut ptrs = [];\n \n-        for (k,v) in es {\n+        for vec::each(es) {|e|\n+            let (k,v) = e;\n             let t = @(#fmt(\"%s=%s\", k, v));\n             vec::push(tmps, t);\n             ptrs += str::as_c_str(*t) {|b| [b]};\n@@ -125,7 +126,8 @@ fn with_envp<T>(env: option<[(str,str)]>,\n     alt env {\n       some (es) {\n         let mut blk : [u8] = [];\n-        for (k,v) in es {\n+        for vec::each(es) {|e|\n+            let (k,v) = e;\n             let t = #fmt(\"%s=%s\", k, v);\n             let mut v : [u8] = ::unsafe::reinterpret_cast(t);\n             blk += v;"}, {"sha": "a19755ed06705feaca03900d298333ac0e258e4c", "filename": "src/libcore/str.rs", "status": "modified", "additions": 20, "deletions": 8, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b5a4fa9456683f40539f885d4e555b87384df09a/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5a4fa9456683f40539f885d4e555b87384df09a/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=b5a4fa9456683f40539f885d4e555b87384df09a", "patch": "@@ -55,6 +55,7 @@ export\n    all, any,\n    all_between, any_between,\n    map,\n+   each,\n    bytes_iter,\n    chars_iter,\n    split_char_iter,\n@@ -176,14 +177,14 @@ fn from_char(ch: char) -> str {\n fn from_chars(chs: [char]) -> str {\n     let mut buf = \"\";\n     reserve(buf, chs.len());\n-    for ch in chs { push_char(buf, ch); }\n+    for vec::each(chs) {|ch| push_char(buf, ch); }\n     ret buf;\n }\n \n #[doc = \"Concatenate a vector of strings\"]\n fn concat(v: [str]) -> str {\n     let mut s: str = \"\";\n-    for ss: str in v { s += ss; }\n+    for vec::each(v) {|ss| s += ss; }\n     ret s;\n }\n \n@@ -192,7 +193,7 @@ Concatenate a vector of strings, placing a given separator between each\n \"]\n fn connect(v: [str], sep: str) -> str {\n     let mut s = \"\", first = true;\n-    for ss: str in v {\n+    for vec::each(v) {|ss|\n         if first { first = false; } else { s += sep; }\n         s += ss;\n     }\n@@ -538,7 +539,7 @@ fn hash(&&s: str) -> uint {\n     // djb hash.\n     // FIXME: replace with murmur.\n     let mut u: uint = 5381u;\n-    for c: u8 in s { u *= 33u; u += c as uint; }\n+    for each(s) {|c| u *= 33u; u += c as uint; }\n     ret u;\n }\n \n@@ -581,6 +582,16 @@ fn bytes_iter(ss: str, it: fn(u8)) {\n     }\n }\n \n+#[doc = \"Iterate over the bytes in a string\"]\n+#[inline(always)]\n+fn each(s: str, it: fn(u8) -> bool) {\n+    let mut i = 0u, l = len(s);\n+    while (i < l) {\n+        if !it(s[i]) { break; }\n+        i += 1u;\n+    }\n+}\n+\n #[doc = \"Iterate over the characters in a string\"]\n fn chars_iter(s: str, it: fn(char)) {\n     let mut pos = 0u;\n@@ -938,7 +949,7 @@ fn rfind_between(s: str, start: uint, end: uint, f: fn(char) -> bool)\n // Utility used by various searching functions\n fn match_at(haystack: str, needle: str, at: uint) -> bool {\n     let mut i = at;\n-    for c in needle { if haystack[i] != c { ret false; } i += 1u; }\n+    for each(needle) {|c| if haystack[i] != c { ret false; } i += 1u; }\n     ret true;\n }\n \n@@ -1074,7 +1085,7 @@ fn is_ascii(s: str) -> bool {\n }\n \n #[doc = \"Returns true if the string has length 0\"]\n-pure fn is_empty(s: str) -> bool { for c: u8 in s { ret false; } ret true; }\n+pure fn is_empty(s: str) -> bool { len(s) == 0u }\n \n #[doc = \"Returns true if the string has length greater than 0\"]\n pure fn is_not_empty(s: str) -> bool { !is_empty(s) }\n@@ -1588,7 +1599,7 @@ mod unsafe {\n \n    #[doc = \"Appends a vector of bytes to a string. (Not UTF-8 safe).\"]\n    unsafe fn push_bytes(&s: str, bytes: [u8]) {\n-       for byte in bytes { rustrt::rust_str_push(s, byte); }\n+       for vec::each(bytes) {|byte| rustrt::rust_str_push(s, byte); }\n    }\n \n    #[doc = \"\n@@ -2472,7 +2483,8 @@ mod tests {\n                0xd801_u16, 0xdc95_u16, 0xd801_u16, 0xdc86_u16,\n                0x000a_u16 ]) ];\n \n-        for (s, u) in pairs {\n+        for vec::each(pairs) {|p|\n+            let (s, u) = p;\n             assert to_utf16(s) == u;\n             assert from_utf16(u) == s;\n             assert from_utf16(to_utf16(s)) == s;"}, {"sha": "db293647fc01a66ad82d88970a8772e8f4e7c638", "filename": "src/libcore/to_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5a4fa9456683f40539f885d4e555b87384df09a/src%2Flibcore%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5a4fa9456683f40539f885d4e555b87384df09a/src%2Flibcore%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fto_str.rs?ref=b5a4fa9456683f40539f885d4e555b87384df09a", "patch": "@@ -38,7 +38,7 @@ impl <A: to_str copy, B: to_str copy, C: to_str copy> of to_str for (A, B, C){\n impl <A: to_str> of to_str for [A] {\n     fn to_str() -> str {\n         let mut acc = \"[\", first = true;\n-        for elt in self {\n+        for vec::each(self) {|elt|\n             if first { first = false; }\n             else { acc += \", \"; }\n             acc += elt.to_str();"}, {"sha": "0ee68f18626a26ddc362143ecb7d8e474fcd0e6f", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b5a4fa9456683f40539f885d4e555b87384df09a/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5a4fa9456683f40539f885d4e555b87384df09a/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=b5a4fa9456683f40539f885d4e555b87384df09a", "patch": "@@ -410,7 +410,7 @@ Apply a function to each element of a vector and return the results\n fn map<T, U>(v: [T], f: fn(T) -> U) -> [U] {\n     let mut result = [];\n     reserve(result, len(v));\n-    for elem: T in v { result += [f(elem)]; }\n+    for each(v) {|elem| result += [f(elem)]; }\n     ret result;\n }\n \n@@ -420,7 +420,7 @@ of each result vector\n \"]\n fn flat_map<T, U>(v: [T], f: fn(T) -> [U]) -> [U] {\n     let mut result = [];\n-    for elem: T in v { result += f(elem); }\n+    for each(v) {|elem| result += f(elem); }\n     ret result;\n }\n \n@@ -446,7 +446,7 @@ the resulting vector.\n fn filter_map<T, U: copy>(v: [T], f: fn(T) -> option<U>)\n     -> [U] {\n     let mut result = [];\n-    for elem: T in v {\n+    for each(v) {|elem|\n         alt f(elem) {\n           none {/* no-op */ }\n           some(result_elem) { result += [result_elem]; }\n@@ -464,7 +464,7 @@ only those elements for which `f` returned true.\n \"]\n fn filter<T: copy>(v: [T], f: fn(T) -> bool) -> [T] {\n     let mut result = [];\n-    for elem: T in v {\n+    for each(v) {|elem|\n         if f(elem) { result += [elem]; }\n     }\n     ret result;\n@@ -477,7 +477,7 @@ Flattens a vector of vectors of T into a single vector of T.\n \"]\n fn concat<T: copy>(v: [const [const T]]) -> [T] {\n     let mut r = [];\n-    for inner in v { r += from_const(inner); }\n+    for each(v) {|inner| r += from_const(inner); }\n     ret r;\n }\n \n@@ -487,7 +487,7 @@ Concatenate a vector of vectors, placing a given separator between each\n fn connect<T: copy>(v: [const [const T]], sep: T) -> [T] {\n     let mut r: [T] = [];\n     let mut first = true;\n-    for inner in v {\n+    for each(v) {|inner|\n         if first { first = false; } else { push(r, sep); }\n         r += from_const(inner);\n     }\n@@ -518,7 +518,7 @@ Return true if a predicate matches any elements\n If the vector contains no elements then false is returned.\n \"]\n fn any<T>(v: [T], f: fn(T) -> bool) -> bool {\n-    for elem: T in v { if f(elem) { ret true; } }\n+    for each(v) {|elem| if f(elem) { ret true; } }\n     ret false;\n }\n \n@@ -544,7 +544,7 @@ Return true if a predicate matches all elements\n If the vector contains no elements then true is returned.\n \"]\n fn all<T>(v: [T], f: fn(T) -> bool) -> bool {\n-    for elem: T in v { if !f(elem) { ret false; } }\n+    for each(v) {|elem| if !f(elem) { ret false; } }\n     ret true;\n }\n \n@@ -563,14 +563,14 @@ fn all2<T, U>(v0: [const T], v1: [const U], f: fn(T, U) -> bool) -> bool {\n \n #[doc = \"Return true if a vector contains an element with the given value\"]\n fn contains<T>(v: [const T], x: T) -> bool {\n-    for elt: T in v { if x == elt { ret true; } }\n+    for each(v) {|elt| if x == elt { ret true; } }\n     ret false;\n }\n \n #[doc = \"Returns the number of elements that are equal to a given value\"]\n fn count<T>(v: [const T], x: T) -> uint {\n     let mut cnt = 0u;\n-    for elt: T in v { if x == elt { cnt += 1u; } }\n+    for each(v) {|elt| if x == elt { cnt += 1u; } }\n     ret cnt;\n }\n \n@@ -701,7 +701,7 @@ of the i-th tuple of the input vector.\n \"]\n fn unzip<T: copy, U: copy>(v: [const (T, U)]) -> ([T], [U]) {\n     let mut as = [], bs = [];\n-    for (a, b) in v { as += [a]; bs += [b]; }\n+    for each(v) {|p| let (a, b) = p; as += [a]; bs += [b]; }\n     ret (as, bs);\n }\n \n@@ -807,7 +807,7 @@ Iterates over a vector's elements and indices\n fn eachi<T>(v: [const T], f: fn(uint, T) -> bool) unsafe {\n     let mut i = 0u, l = len(v);\n     let mut p = ptr::offset(unsafe::to_ptr(v), 0u);\n-    while i > l {\n+    while i < l {\n         if !f(i, *p) { break; }\n         p = ptr::offset(p, 1u);\n         i += 1u;"}, {"sha": "5d100fa0623e7f3cad9adb095af93797184b87bf", "filename": "src/libstd/bitv.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b5a4fa9456683f40539f885d4e555b87384df09a/src%2Flibstd%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5a4fa9456683f40539f885d4e555b87384df09a/src%2Flibstd%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitv.rs?ref=b5a4fa9456683f40539f885d4e555b87384df09a", "patch": "@@ -173,14 +173,14 @@ fn set(v: bitv, i: uint, x: bool) {\n \n #[doc = \"Returns true if all bits are 1\"]\n fn is_true(v: bitv) -> bool {\n-    for i: uint in to_vec(v) { if i != 1u { ret false; } }\n+    for each(v) {|i| if !i { ret false; } }\n     ret true;\n }\n \n \n #[doc = \"Returns true if all bits are 0\"]\n fn is_false(v: bitv) -> bool {\n-    for i: uint in to_vec(v) { if i == 1u { ret false; } }\n+    for each(v) {|i| if i { ret false; } }\n     ret true;\n }\n \n@@ -198,6 +198,12 @@ fn to_vec(v: bitv) -> [uint] {\n     ret vec::from_fn::<uint>(v.nbits, sub);\n }\n \n+fn each(v: bitv, f: fn(bool) -> bool) {\n+    let mut i = 0u;\n+    while i < v.nbits {\n+        if !f(get(v, i)) { break; }\n+    }\n+}\n \n #[doc = \"\n Converts the bitvector to a string.\n@@ -207,7 +213,7 @@ is either '0' or '1'.\n \"]\n fn to_str(v: bitv) -> str {\n     let mut rs = \"\";\n-    for i: uint in to_vec(v) { if i == 1u { rs += \"1\"; } else { rs += \"0\"; } }\n+    for each(v) {|i| if i { rs += \"1\"; } else { rs += \"0\"; } }\n     ret rs;\n }\n "}, {"sha": "beec5638b84819ed32d330f38263089cd25c2435", "filename": "src/libstd/getopts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b5a4fa9456683f40539f885d4e555b87384df09a/src%2Flibstd%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5a4fa9456683f40539f885d4e555b87384df09a/src%2Flibstd%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgetopts.rs?ref=b5a4fa9456683f40539f885d4e555b87384df09a", "patch": "@@ -208,7 +208,7 @@ fn getopts(args: [str], opts: [opt]) -> result unsafe {\n                 }\n             }\n             let mut name_pos = 0u;\n-            for nm: name in names {\n+            for vec::each(names) {|nm|\n                 name_pos += 1u;\n                 let optid = alt find_opt(opts, nm) {\n                   some(id) { id }\n@@ -290,7 +290,7 @@ Used when an option accepts multiple values.\n \"]\n fn opt_strs(m: match, nm: str) -> [str] {\n     let mut acc: [str] = [];\n-    for v: optval in opt_vals(m, nm) {\n+    for vec::each(opt_vals(m, nm)) {|v|\n         alt v { val(s) { acc += [s]; } _ { } }\n     }\n     ret acc;"}, {"sha": "78a4aa91045b67f545aefa8a3b992211f8c9f074", "filename": "src/libstd/sha1.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b5a4fa9456683f40539f885d4e555b87384df09a/src%2Flibstd%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5a4fa9456683f40539f885d4e555b87384df09a/src%2Flibstd%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsha1.rs?ref=b5a4fa9456683f40539f885d4e555b87384df09a", "patch": "@@ -63,7 +63,7 @@ fn sha1() -> sha1 {\n     fn add_input(st: sha1state, msg: [u8]) {\n         // FIXME: Should be typestate precondition\n         assert (!st.computed);\n-        for element: u8 in msg {\n+        for vec::each(msg) {|element|\n             st.msg_block[st.msg_block_idx] = element;\n             st.msg_block_idx += 1u;\n             st.len_low += 8u32;\n@@ -161,7 +161,7 @@ fn sha1() -> sha1 {\n     fn mk_result(st: sha1state) -> [u8] {\n         if !st.computed { pad_msg(st); st.computed = true; }\n         let mut rs: [u8] = [];\n-        for hpart: u32 in st.h {\n+        for vec::each(st.h) {|hpart|\n             let a = (hpart >> 24u32 & 0xFFu32) as u8;\n             let b = (hpart >> 16u32 & 0xFFu32) as u8;\n             let c = (hpart >> 8u32 & 0xFFu32) as u8;\n@@ -238,7 +238,7 @@ fn sha1() -> sha1 {\n         fn result_str() -> str {\n             let r = mk_result(self);\n             let mut s = \"\";\n-            for b: u8 in r { s += uint::to_str(b as uint, 16u); }\n+            for vec::each(r) {|b| s += uint::to_str(b as uint, 16u); }\n             ret s;\n         }\n     }\n@@ -327,7 +327,7 @@ mod tests {\n         // Test that it works when accepting the message all at once\n \n         let sh = sha1::sha1();\n-        for t: test in tests {\n+        for vec::each(tests) {|t|\n             sh.input_str(t.input);\n             let out = sh.result();\n             check_vec_eq(t.output, out);\n@@ -336,7 +336,7 @@ mod tests {\n \n \n         // Test that it works when accepting the message in pieces\n-        for t: test in tests {\n+        for vec::each(tests) {|t|\n             let len = str::len(t.input);\n             let mut left = len;\n             while left > 0u {"}, {"sha": "e9228eae1bc8ead0f171c2b905d5e43750194f13", "filename": "src/libstd/sort.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b5a4fa9456683f40539f885d4e555b87384df09a/src%2Flibstd%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5a4fa9456683f40539f885d4e555b87384df09a/src%2Flibstd%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsort.rs?ref=b5a4fa9456683f40539f885d4e555b87384df09a", "patch": "@@ -254,7 +254,11 @@ mod test_qsort {\n         let immut_names = vec::from_mut(names);\n \n         let pairs = vec::zip(expected, immut_names);\n-        for (a, b) in pairs { #debug(\"%d %d\", a, b); assert (a == b); }\n+        for vec::each(pairs) {|p|\n+            let (a, b) = p;\n+            #debug(\"%d %d\", a, b);\n+            assert (a == b);\n+        }\n     }\n }\n "}, {"sha": "3bbde56693a90a97c66b57c82a4074ae553afba1", "filename": "src/libstd/term.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5a4fa9456683f40539f885d4e555b87384df09a/src%2Flibstd%2Fterm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5a4fa9456683f40539f885d4e555b87384df09a/src%2Flibstd%2Fterm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fterm.rs?ref=b5a4fa9456683f40539f885d4e555b87384df09a", "patch": "@@ -37,7 +37,7 @@ fn color_supported() -> bool {\n                            \"screen-bce\", \"xterm-256color\"];\n     ret alt os::getenv(\"TERM\") {\n           option::some(env) {\n-            for term: str in supported_terms {\n+            for vec::each(supported_terms) {|term|\n                 if str::eq(term, env) { ret true; }\n             }\n             false"}, {"sha": "d2138dc14d62167bf8c814ae36f4d51f6d51639d", "filename": "src/libstd/test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b5a4fa9456683f40539f885d4e555b87384df09a/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5a4fa9456683f40539f885d4e555b87384df09a/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=b5a4fa9456683f40539f885d4e555b87384df09a", "patch": "@@ -183,7 +183,7 @@ fn print_failures(st: console_test_state) {\n     st.out.write_line(\"\\nfailures:\");\n     let failures = vec::map(copy st.failures) {|test| test.name};\n     let failures = sort::merge_sort(str::le, failures);\n-    for name in failures {\n+    for vec::each(failures) {|name|\n         st.out.write_line(#fmt[\"    %s\", name]);\n     }\n }\n@@ -492,7 +492,7 @@ mod tests {\n         {\n         let testfn = fn~() { };\n         let mut tests = [];\n-        for name: str in names {\n+        for vec::each(names) {|name|\n             let test = {name: name, fn: testfn, ignore: false,\n                         should_fail: false};\n             tests += [test];\n@@ -510,7 +510,7 @@ mod tests {\n \n     let pairs = vec::zip(expected, filtered);\n \n-    for (a, b) in pairs { assert (a == b.name); }\n+    for vec::each(pairs) {|p| let (a, b) = p; assert (a == b.name); }\n }\n }\n "}, {"sha": "a92385268bb71174c8c4177a95662f7e02b52894", "filename": "src/rustc/middle/trans/alt.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/b5a4fa9456683f40539f885d4e555b87384df09a/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5a4fa9456683f40539f885d4e555b87384df09a/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs?ref=b5a4fa9456683f40539f885d4e555b87384df09a", "patch": "@@ -70,15 +70,15 @@ fn trans_opt(bcx: block, o: opt) -> opt_result {\n fn variant_opt(tcx: ty::ctxt, pat_id: ast::node_id) -> opt {\n     let vdef = ast_util::variant_def_ids(tcx.def_map.get(pat_id));\n     let variants = ty::enum_variants(tcx, vdef.enm);\n-    for v: ty::variant_info in *variants {\n+    for vec::each(*variants) {|v|\n         if vdef.var == v.id { ret var(v.disr_val, vdef); }\n     }\n     core::unreachable();\n }\n \n type bind_map = [{ident: ast::ident, val: ValueRef}];\n fn assoc(key: str, list: bind_map) -> option<ValueRef> {\n-    for elt: {ident: ast::ident, val: ValueRef} in list {\n+    for vec::each(list) {|elt|\n         if str::eq(elt.ident, key) { ret some(elt.val); }\n     }\n     ret none;\n@@ -93,7 +93,7 @@ type match_branch =\n type match = [match_branch];\n \n fn has_nested_bindings(m: match, col: uint) -> bool {\n-    for br in m {\n+    for vec::each(m) {|br|\n         alt br.pats[col].node {\n           ast::pat_ident(_, some(_)) { ret true; }\n           _ {}\n@@ -104,7 +104,7 @@ fn has_nested_bindings(m: match, col: uint) -> bool {\n \n fn expand_nested_bindings(m: match, col: uint, val: ValueRef) -> match {\n     let mut result = [];\n-    for br in m {\n+    for vec::each(m) {|br|\n       alt br.pats[col].node {\n           ast::pat_ident(name, some(inner)) {\n             let pats = vec::slice(br.pats, 0u, col) + [inner] +\n@@ -125,7 +125,7 @@ type enter_pat = fn(@ast::pat) -> option<[@ast::pat]>;\n fn enter_match(dm: def_map, m: match, col: uint, val: ValueRef,\n                e: enter_pat) -> match {\n     let mut result = [];\n-    for br: match_branch in m {\n+    for vec::each(m) {|br|\n         alt e(br.pats[col]) {\n           some(sub) {\n             let pats = sub + vec::slice(br.pats, 0u, col) +\n@@ -188,9 +188,9 @@ fn enter_rec(dm: def_map, m: match, col: uint, fields: [ast::ident],\n         alt p.node {\n           ast::pat_rec(fpats, _) {\n             let mut pats = [];\n-            for fname: ast::ident in fields {\n+            for vec::each(fields) {|fname|\n                 let mut pat = dummy;\n-                for fpat: ast::field_pat in fpats {\n+                for vec::each(fpats) {|fpat|\n                     if str::eq(fpat.ident, fname) { pat = fpat.pat; break; }\n                 }\n                 pats += [pat];\n@@ -235,12 +235,12 @@ fn enter_uniq(dm: def_map, m: match, col: uint, val: ValueRef) -> match {\n \n fn get_options(ccx: @crate_ctxt, m: match, col: uint) -> [opt] {\n     fn add_to_set(tcx: ty::ctxt, &set: [opt], val: opt) {\n-        for l in set { if opt_eq(tcx, l, val) { ret; } }\n+        for vec::each(set) {|l| if opt_eq(tcx, l, val) { ret; } }\n         set += [val];\n     }\n \n     let mut found = [];\n-    for br in m {\n+    for vec::each(m) {|br|\n         let cur = br.pats[col];\n         if pat_is_variant(ccx.tcx.def_map, cur) {\n             add_to_set(ccx.tcx, found, variant_opt(ccx.tcx, br.pats[col].id));\n@@ -288,10 +288,10 @@ fn extract_variant_args(bcx: block, pat_id: ast::node_id,\n \n fn collect_record_fields(m: match, col: uint) -> [ast::ident] {\n     let mut fields = [];\n-    for br: match_branch in m {\n+    for vec::each(m) {|br|\n         alt br.pats[col].node {\n           ast::pat_rec(fs, _) {\n-            for f: ast::field_pat in fs {\n+            for vec::each(fs) {|f|\n                 if !vec::any(fields, bind str::eq(f.ident, _)) {\n                     fields += [f.ident];\n                 }\n@@ -304,21 +304,21 @@ fn collect_record_fields(m: match, col: uint) -> [ast::ident] {\n }\n \n fn any_box_pat(m: match, col: uint) -> bool {\n-    for br: match_branch in m {\n+    for vec::each(m) {|br|\n         alt br.pats[col].node { ast::pat_box(_) { ret true; } _ { } }\n     }\n     ret false;\n }\n \n fn any_uniq_pat(m: match, col: uint) -> bool {\n-    for br: match_branch in m {\n+    for vec::each(m) {|br|\n         alt br.pats[col].node { ast::pat_uniq(_) { ret true; } _ { } }\n     }\n     ret false;\n }\n \n fn any_tup_pat(m: match, col: uint) -> bool {\n-    for br: match_branch in m {\n+    for vec::each(m) {|br|\n         alt br.pats[col].node { ast::pat_tup(_) { ret true; } _ { } }\n     }\n     ret false;\n@@ -336,14 +336,14 @@ fn pick_col(m: match) -> uint {\n         }\n     }\n     let scores = vec::to_mut(vec::from_elem(m[0].pats.len(), 0u));\n-    for br: match_branch in m {\n+    for vec::each(m) {|br|\n         let mut i = 0u;\n-        for p: @ast::pat in br.pats { scores[i] += score(p); i += 1u; }\n+        for vec::each(br.pats) {|p| scores[i] += score(p); i += 1u; }\n     }\n     let mut max_score = 0u;\n     let mut best_col = 0u;\n     let mut i = 0u;\n-    for score: uint in scores {\n+    for vec::each(scores) {|score|\n         // Irrefutable columns always go first, they'd only be duplicated in\n         // the branches.\n         if score == 0u { ret i; }\n@@ -398,7 +398,7 @@ fn compile_submatch(bcx: block, m: match, vals: [ValueRef],\n         vec::slice(vals, col + 1u, vals.len());\n     let ccx = bcx.fcx.ccx;\n     let mut pat_id = 0;\n-    for br: match_branch in m {\n+    for vec::each(m) {|br|\n         // Find a real id (we're adding placeholder wildcard patterns, but\n         // each column is guaranteed to have at least one real pattern)\n         if pat_id == 0 { pat_id = br.pats[col].id; }\n@@ -409,7 +409,7 @@ fn compile_submatch(bcx: block, m: match, vals: [ValueRef],\n     if rec_fields.len() > 0u {\n         let fields = ty::get_fields(node_id_type(bcx, pat_id));\n         let mut rec_vals = [];\n-        for field_name: ast::ident in rec_fields {\n+        for vec::each(rec_fields) {|field_name|\n             let ix = option::get(ty::field_idx(field_name, fields));\n             rec_vals += [GEPi(bcx, val, [0, ix as int])];\n         }\n@@ -480,7 +480,7 @@ fn compile_submatch(bcx: block, m: match, vals: [ValueRef],\n           }\n         }\n     }\n-    for o: opt in opts {\n+    for vec::each(opts) {|o|\n         alt o {\n           range(_, _) { kind = compare; break; }\n           _ { }\n@@ -499,7 +499,7 @@ fn compile_submatch(bcx: block, m: match, vals: [ValueRef],\n     let len = opts.len();\n     let mut i = 0u;\n     // Compile subtrees for each option\n-    for opt in opts {\n+    for vec::each(opts) {|opt|\n         i += 1u;\n         let mut opt_cx = else_cx;\n         if !exhaustive || i < len {\n@@ -570,7 +570,7 @@ fn make_phi_bindings(bcx: block, map: [exit_node],\n     ids.items {|name, node_id|\n         let mut llbbs = [];\n         let mut vals = [];\n-        for ex: exit_node in map {\n+        for vec::each(map) {|ex|\n             if ex.to as uint == our_block {\n                 alt assoc(name, ex.bound) {\n                   some(val) { llbbs += [ex.from]; vals += [val]; }\n@@ -624,12 +624,12 @@ fn trans_alt_inner(scope_cx: block, expr: @ast::expr, arms: [ast::arm],\n     let {bcx, val, _} = trans_temp_expr(bcx, expr);\n     if bcx.unreachable { ret bcx; }\n \n-    for a in arms {\n+    for vec::each(arms) {|a|\n         let body = scope_block(bcx, \"case_body\");\n         body.block_span = some(a.body.span);\n         let id_map = pat_util::pat_id_map(tcx.def_map, a.pats[0]);\n         bodies += [body];\n-        for p in a.pats {\n+        for vec::each(a.pats) {|p|\n             match += [@{pats: [p],\n                         bound: [],\n                         data: @{body: body.llbb, guard: a.guard,\n@@ -659,7 +659,7 @@ fn trans_alt_inner(scope_cx: block, expr: @ast::expr, arms: [ast::arm],\n     compile_submatch(bcx, match, [spilled], mk_fail, exit_map);\n \n     let mut arm_cxs = [], arm_dests = [], i = 0u;\n-    for a in arms {\n+    for vec::each(arms) {|a|\n         let body_cx = bodies[i];\n         let id_map = pat_util::pat_id_map(tcx.def_map, a.pats[0]);\n         if make_phi_bindings(body_cx, exit_map, id_map) {\n@@ -703,14 +703,14 @@ fn bind_irrefutable_pat(bcx: block, pat: @ast::pat, val: ValueRef,\n         let vdefs = ast_util::variant_def_ids(ccx.tcx.def_map.get(pat.id));\n         let args = extract_variant_args(bcx, pat.id, vdefs, val);\n         let mut i = 0;\n-        for argval: ValueRef in args.vals {\n+        for vec::each(args.vals) {|argval|\n             bcx = bind_irrefutable_pat(bcx, sub[i], argval, make_copy);\n             i += 1;\n         }\n       }\n       ast::pat_rec(fields, _) {\n         let rec_fields = ty::get_fields(node_id_type(bcx, pat.id));\n-        for f: ast::field_pat in fields {\n+        for vec::each(fields) {|f|\n             let ix = option::get(ty::field_idx(f.ident, rec_fields));\n             // how to get rid of this check?\n             let fldptr = GEPi(bcx, val, [0, ix as int]);\n@@ -719,7 +719,7 @@ fn bind_irrefutable_pat(bcx: block, pat: @ast::pat, val: ValueRef,\n       }\n       ast::pat_tup(elems) {\n         let mut i = 0u;\n-        for elem in elems {\n+        for vec::each(elems) {|elem|\n             let fldptr = GEPi(bcx, val, [0, i as int]);\n             bcx = bind_irrefutable_pat(bcx, elem, fldptr, make_copy);\n             i += 1u;"}, {"sha": "c03c5c756ac4d1208650e1694642fe9ef30ff2e2", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 41, "deletions": 52, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/b5a4fa9456683f40539f885d4e555b87384df09a/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5a4fa9456683f40539f885d4e555b87384df09a/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=b5a4fa9456683f40539f885d4e555b87384df09a", "patch": "@@ -111,7 +111,7 @@ fn join_returns(parent_cx: block, in_cxs: [block],\n                 in_ds: [dest], out_dest: dest) -> block {\n     let out = sub_block(parent_cx, \"join\");\n     let mut reachable = false, i = 0u, phi = none;\n-    for cx in in_cxs {\n+    for vec::each(in_cxs) {|cx|\n         if !cx.unreachable {\n             Br(cx, out.llbb);\n             reachable = true;\n@@ -222,7 +222,7 @@ fn trans_native_call(cx: block, externs: hashmap<str, ValueRef>,\n     let llnative: ValueRef =\n         get_simple_extern_fn(cx, externs, llmod, name, n);\n     let mut call_args: [ValueRef] = [];\n-    for a: ValueRef in args {\n+    for vec::each(args) {|a|\n         call_args += [ZExtOrBitCast(cx, a, cx.ccx().int_type)];\n     }\n     ret Call(cx, llnative, call_args);\n@@ -877,7 +877,7 @@ fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n           ty::ty_fn({inputs: args, _}) {\n             let mut j = 0u;\n             let v_id = variant.id;\n-            for a: ty::arg in args {\n+            for vec::each(args) {|a|\n                 let llfldp_a = GEP_enum(cx, a_tup, tid, v_id, tps, j);\n                 let ty_subst = ty::substitute_type_params(ccx.tcx, tps, a.ty);\n                 cx = f(cx, llfldp_a, ty_subst);\n@@ -895,19 +895,15 @@ fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n     let mut cx = cx;\n     alt ty::get(t).struct {\n       ty::ty_rec(fields) {\n-        let mut i: int = 0;\n-        for fld: ty::field in fields {\n-            let llfld_a = GEPi(cx, av, [0, i]);\n+        for vec::eachi(fields) {|i, fld|\n+            let llfld_a = GEPi(cx, av, [0, i as int]);\n             cx = f(cx, llfld_a, fld.mt.ty);\n-            i += 1;\n         }\n       }\n       ty::ty_tup(args) {\n-        let mut i = 0;\n-        for arg in args {\n-            let llfld_a = GEPi(cx, av, [0, i]);\n+        for vec::eachi(args) {|i, arg|\n+            let llfld_a = GEPi(cx, av, [0, i as int]);\n             cx = f(cx, llfld_a, arg);\n-            i += 1;\n         }\n       }\n       ty::ty_res(_, inner, tps) {\n@@ -939,7 +935,7 @@ fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n         Unreachable(unr_cx);\n         let llswitch = Switch(cx, lldiscrim_a, unr_cx.llbb, n_variants);\n         let next_cx = sub_block(cx, \"enum-iter-next\");\n-        for variant: ty::variant_info in *variants {\n+        for vec::each(*variants) {|variant|\n             let variant_cx =\n                 sub_block(cx,\n                                    \"enum-iter-variant-\" +\n@@ -954,7 +950,7 @@ fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n       ty::ty_class(did, tps) {\n           // a class is like a record type\n         let mut i: int = 0;\n-        for fld: ty::field in ty::class_items_as_fields(cx.tcx(), did) {\n+        for vec::each(ty::class_items_as_fields(cx.tcx(), did)) {|fld|\n             let llfld_a = GEPi(cx, av, [0, i]);\n             cx = f(cx, llfld_a, fld.mt.ty);\n             i += 1;\n@@ -1846,7 +1842,7 @@ fn make_mono_id(ccx: @crate_ctxt, item: ast::def_id, substs: [ty::t],\n         let mut i = 0u;\n         vec::map2(*bounds, substs, {|bounds, subst|\n             let mut v = [];\n-            for bound in *bounds {\n+            for vec::each(*bounds) {|bound|\n                 alt bound {\n                   ty::bound_iface(_) {\n                     v += [impl::vtable_id(ccx, vts[i])];\n@@ -2889,22 +2885,22 @@ fn trans_tup(bcx: block, elts: [@ast::expr], dest: dest) -> block {\n     let mut bcx = bcx;\n     let addr = alt dest {\n       ignore {\n-        for ex in elts { bcx = trans_expr(bcx, ex, ignore); }\n+        for vec::each(elts) {|ex| bcx = trans_expr(bcx, ex, ignore); }\n         ret bcx;\n       }\n       save_in(pos) { pos }\n       _ { bcx.tcx().sess.bug(\"trans_tup: weird dest\"); }\n     };\n     let mut temp_cleanups = [], i = 0;\n-    for e in elts {\n+    for vec::each(elts) {|e|\n         let dst = GEPi(bcx, addr, [0, i]);\n         let e_ty = expr_ty(bcx, e);\n         bcx = trans_expr_save_in(bcx, e, dst);\n         add_clean_temp_mem(bcx, dst, e_ty);\n         temp_cleanups += [dst];\n         i += 1;\n     }\n-    for cleanup in temp_cleanups { revoke_clean(bcx, cleanup); }\n+    for vec::each(temp_cleanups) {|cleanup| revoke_clean(bcx, cleanup); }\n     ret bcx;\n }\n \n@@ -2914,21 +2910,18 @@ fn trans_rec(bcx: block, fields: [ast::field],\n     let _icx = bcx.insn_ctxt(\"trans_rec\");\n     let t = node_id_type(bcx, id);\n     let mut bcx = bcx;\n-    let addr = alt dest {\n+    let addr = alt check dest {\n       ignore {\n-        for fld in fields {\n+        for vec::each(fields) {|fld|\n             bcx = trans_expr(bcx, fld.node.expr, ignore);\n         }\n         ret bcx;\n       }\n       save_in(pos) { pos }\n-      _ { bcx.tcx().sess.bug(\"trans_rec: weird dest\"); }\n     };\n \n-    let ty_fields = alt ty::get(t).struct {\n-      ty::ty_rec(f) { f }\n-      _ { bcx.tcx().sess.bug(\"trans_rec: id doesn't\\\n-           have a record type\") } };\n+    let ty_fields = alt check ty::get(t).struct { ty::ty_rec(f) { f } };\n+\n     let mut temp_cleanups = [];\n     for fld in fields {\n         let ix = option::get(vec::position(ty_fields, {|ft|\n@@ -3584,7 +3577,7 @@ fn trans_stmt(cx: block, s: ast::stmt) -> block {\n       ast::stmt_decl(d, _) {\n         alt d.node {\n           ast::decl_local(locals) {\n-            for local in locals {\n+            for vec::each(locals) {|local|\n                 bcx = init_local(bcx, local);\n                 if cx.sess().opts.extra_debuginfo {\n                     debuginfo::create_local_var(bcx, local);\n@@ -3702,9 +3695,9 @@ fn cleanup_and_leave(bcx: block, upto: option<BasicBlockRef>,\n     loop {\n         alt cur.kind {\n           block_scope(info) if info.cleanups.len() > 0u {\n-            for exists in info.cleanup_paths {\n-                if exists.target == leave {\n-                    Br(bcx, exists.dest);\n+            for cp in info.cleanup_paths {\n+                if cp.target == leave {\n+                    Br(bcx, cp.dest);\n                     ret;\n                 }\n             }\n@@ -3770,12 +3763,12 @@ fn with_cond(bcx: block, val: ValueRef, f: fn(block) -> block) -> block {\n }\n \n fn block_locals(b: ast::blk, it: fn(@ast::local)) {\n-    for s: @ast::stmt in b.node.stmts {\n+    for vec::each(b.node.stmts) {|s|\n         alt s.node {\n           ast::stmt_decl(d, _) {\n             alt d.node {\n               ast::decl_local(locals) {\n-                for local in locals { it(local); }\n+                for vec::each(locals) {|local| it(local); }\n               }\n               _ {/* fall through */ }\n             }\n@@ -3829,7 +3822,7 @@ fn trans_block(bcx: block, b: ast::blk, dest: dest)\n     let _icx = bcx.insn_ctxt(\"trans_block\");\n     let mut bcx = bcx;\n     block_locals(b) {|local| bcx = alloc_local(bcx, local); };\n-    for s: @ast::stmt in b.node.stmts {\n+    for vec::each(b.node.stmts) {|s|\n         debuginfo::update_source_pos(bcx, b.span);\n         bcx = trans_stmt(bcx, *s);\n     }\n@@ -3920,7 +3913,7 @@ fn create_llargs_for_fn_args(cx: fn_ctxt,\n \n     // Populate the llargs field of the function context with the ValueRefs\n     // that we get from llvm::LLVMGetParam for each argument.\n-    for arg: ast::arg in args {\n+    for vec::each(args) {|arg|\n         let llarg = llvm::LLVMGetParam(cx.llfn, arg_n as c_uint);\n         assert (llarg as int != 0);\n         // Note that this uses local_mem even for things passed by value.\n@@ -3940,7 +3933,7 @@ fn copy_args_to_allocas(fcx: fn_ctxt, bcx: block, args: [ast::arg],\n         tcx.sess.bug(\"someone forgot\\\n                 to document an invariant in copy_args_to_allocas!\");\n     };\n-    for arg in arg_tys {\n+    for vec::each(arg_tys) {|arg|\n         let id = args[arg_n].id;\n         let argval = alt fcx.llargs.get(id) { local_mem(v) { v }\n                                               _ { epic_fail() } };\n@@ -4096,13 +4089,12 @@ fn trans_enum_variant(ccx: @crate_ctxt, enum_id: ast::node_id,\n                       llfndecl: ValueRef) {\n     let _icx = ccx.insn_ctxt(\"trans_enum_variant\");\n     // Translate variant arguments to function arguments.\n-    let mut fn_args = [], i = 0u;\n-    for varg in variant.node.args {\n-        fn_args += [{mode: ast::expl(ast::by_copy),\n-                     ty: varg.ty,\n-                     ident: \"arg\" + uint::to_str(i, 10u),\n-                     id: varg.id}];\n-    }\n+    let fn_args = vec::map(variant.node.args, {|varg|\n+        {mode: ast::expl(ast::by_copy),\n+         ty: varg.ty,\n+         ident: \"arg\",\n+         id: varg.id}\n+    });\n     let fcx = new_fn_ctxt_w_id(ccx, [], llfndecl, variant.node.id,\n                                param_substs, none);\n     create_llargs_for_fn_args(fcx, no_self, fn_args);\n@@ -4127,7 +4119,7 @@ fn trans_enum_variant(ccx: @crate_ctxt, enum_id: ast::node_id,\n     let mut i = 0u;\n     let t_id = local_def(enum_id);\n     let v_id = local_def(variant.node.id);\n-    for va: ast::variant_arg in variant.node.args {\n+    for vec::each(variant.node.args) {|va|\n         let lldestptr = GEP_enum(bcx, llblobptr, t_id, v_id,\n                                  ty_param_substs, i);\n         // If this argument to this function is a enum, it'll have come in to\n@@ -4270,7 +4262,7 @@ fn trans_item(ccx: @crate_ctxt, item: ast::item) {\n             trans_fn(ccx, *path + [path_name(item.ident)], decl, body,\n                      llfndecl, no_self, none, item.id);\n         } else {\n-            for stmt in body.node.stmts {\n+            for vec::each(body.node.stmts) {|stmt|\n                 alt stmt.node {\n                   ast::stmt_decl(@{node: ast::decl_item(i), _}, _) {\n                     trans_item(ccx, *i);\n@@ -4301,7 +4293,7 @@ fn trans_item(ccx: @crate_ctxt, item: ast::item) {\n             let degen = variants.len() == 1u;\n             let vi = ty::enum_variants(ccx.tcx, local_def(item.id));\n             let mut i = 0;\n-            for variant: ast::variant in variants {\n+            for vec::each(variants) {|variant|\n                 if variant.node.args.len() > 0u {\n                     let llfn = get_item_val(ccx, variant.node.id);\n                     trans_enum_variant(ccx, item.id, variant,\n@@ -4331,12 +4323,9 @@ fn trans_item(ccx: @crate_ctxt, item: ast::item) {\n         // kludgy -- this wouldn't be necessary if the typechecker\n         // special-cased constructors, then we could just look up\n         // the ctor's return type.\n-        let mut ty_args = [], i = 0u;\n-        for tp in tps {\n-            ty_args += [ty::mk_param(ccx.tcx, i,\n-                                     local_def(tps[i].id))];\n-            i += 1u;\n-        }\n+        let ty_args = vec::from_fn(tps.len(), {|i|\n+            ty::mk_param(ccx.tcx, i, local_def(tps[i].id))\n+        });\n         let rslt_ty =  ty::mk_class(ccx.tcx,\n                                     local_def(item.id),\n                                     ty_args);\n@@ -4383,7 +4372,7 @@ fn trans_item(ccx: @crate_ctxt, item: ast::item) {\n // and control visibility.\n fn trans_mod(ccx: @crate_ctxt, m: ast::_mod) {\n     let _icx = ccx.insn_ctxt(\"trans_mod\");\n-    for item in m.items { trans_item(ccx, *item); }\n+    for vec::each(m.items) {|item| trans_item(ccx, *item); }\n }\n \n fn get_pair_fn_ty(llpairty: TypeRef) -> TypeRef {\n@@ -4620,7 +4609,7 @@ fn trans_constant(ccx: @crate_ctxt, it: @ast::item) {\n                                              node: it.id});\n         let mut i = 0;\n         let path = item_path(ccx, it);\n-        for variant in variants {\n+        for vec::each(variants) {|variant|\n             let p = path + [path_name(variant.node.name),\n                             path_name(\"discrim\")];\n             let s = mangle_exported_name(ccx, p, ty::mk_int(ccx.tcx));\n@@ -4933,7 +4922,7 @@ fn trans_crate(sess: session::session, crate: @ast::crate, tcx: ty::ctxt,\n         io::println(#fmt(\"n_null_glues: %u\", ccx.stats.n_null_glues));\n         io::println(#fmt(\"n_real_glues: %u\", ccx.stats.n_real_glues));\n \n-        for timing: {ident: str, time: int} in *ccx.stats.fn_times {\n+        for vec::each(copy *ccx.stats.fn_times) {|timing|\n             io::println(#fmt(\"time: %s took %d ms\", timing.ident,\n                              timing.time));\n         }"}, {"sha": "7b39f50777edb19e7912ed0b4c74846faccf3b79", "filename": "src/rustc/middle/trans/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5a4fa9456683f40539f885d4e555b87384df09a/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5a4fa9456683f40539f885d4e555b87384df09a/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=b5a4fa9456683f40539f885d4e555b87384df09a", "patch": "@@ -429,7 +429,7 @@ fn GEP(cx: block, Pointer: ValueRef, Indices: [ValueRef]) -> ValueRef {\n // in C_i32()\n fn GEPi(cx: block, base: ValueRef, ixs: [int]) -> ValueRef {\n     let mut v: [ValueRef] = [];\n-    for i: int in ixs { v += [C_i32(i as i32)]; }\n+    for vec::each(ixs) {|i| v += [C_i32(i as i32)]; }\n     count_insn(cx, \"gepi\");\n     ret InBoundsGEP(cx, base, v);\n }"}, {"sha": "0ef624c57ef388da905b57fcaeaadbea3241187f", "filename": "src/rustc/middle/trans/closure.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b5a4fa9456683f40539f885d4e555b87384df09a/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5a4fa9456683f40539f885d4e555b87384df09a/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=b5a4fa9456683f40539f885d4e555b87384df09a", "patch": "@@ -126,7 +126,7 @@ fn mk_closure_tys(tcx: ty::ctxt,\n     let mut bound_tys = [];\n \n     // Compute the closed over data\n-    for bv in bound_values {\n+    for vec::each(bound_values) {|bv|\n         bound_tys += [alt bv {\n             env_copy(_, t, _) { t }\n             env_move(_, t, _) { t }\n@@ -277,7 +277,7 @@ fn store_environment(bcx: block,\n           }\n         }\n     }\n-    for cleanup in temp_cleanups { revoke_clean(bcx, cleanup); }\n+    for vec::each(temp_cleanups) {|cleanup| revoke_clean(bcx, cleanup); }\n \n     ret {llbox: llbox, cdata_ty: cdata_ty, bcx: bcx};\n }\n@@ -445,12 +445,12 @@ fn trans_bind_1(cx: block, outgoing_fty: ty::t,\n     let _icx = cx.insn_ctxt(\"closure::trans_bind1\");\n     let ccx = cx.ccx();\n     let mut bound: [@ast::expr] = [];\n-    for argopt: option<@ast::expr> in args {\n+    for vec::each(args) {|argopt|\n         alt argopt { none { } some(e) { bound += [e]; } }\n     }\n     let mut bcx = f_res.bcx;\n     if dest == ignore {\n-        for ex in bound { bcx = trans_expr(bcx, ex, ignore); }\n+        for vec::each(bound) {|ex| bcx = trans_expr(bcx, ex, ignore); }\n         ret bcx;\n     }\n \n@@ -746,7 +746,7 @@ fn trans_bind_thunk(ccx: @crate_ctxt,\n     let mut a: uint = first_real_arg; // retptr, env come first\n     let mut b: int = starting_idx;\n     let mut outgoing_arg_index: uint = 0u;\n-    for arg: option<@ast::expr> in args {\n+    for vec::each(args) {|arg|\n         let out_arg = outgoing_args[outgoing_arg_index];\n         alt arg {\n           // Arg provided at binding time; thunk copies it from"}, {"sha": "5dd282c8df3b47c1b9461cfd39750c861177d449", "filename": "src/rustc/middle/trans/common.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b5a4fa9456683f40539f885d4e555b87384df09a/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5a4fa9456683f40539f885d4e555b87384df09a/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=b5a4fa9456683f40539f885d4e555b87384df09a", "patch": "@@ -818,12 +818,12 @@ enum mono_param_id {\n type mono_id = @{def: ast::def_id, params: [mono_param_id]};\n fn hash_mono_id(&&mi: mono_id) -> uint {\n     let mut h = syntax::ast_util::hash_def_id(mi.def);\n-    for param in mi.params {\n+    for vec::each(mi.params) {|param|\n         h = h * alt param {\n           mono_precise(ty, vts) {\n             let mut h = ty::type_id(ty);\n             option::may(vts) {|vts|\n-                for vt in vts { h += hash_mono_id(vt); }\n+                for vec::each(vts) {|vt| h += hash_mono_id(vt); }\n             }\n             h\n           }\n@@ -852,7 +852,7 @@ fn align_to(cx: block, off: ValueRef, align: ValueRef) -> ValueRef {\n \n fn path_str(p: path) -> str {\n     let mut r = \"\", first = true;\n-    for e in p {\n+    for vec::each(p) {|e|\n         alt e { ast_map::path_name(s) | ast_map::path_mod(s) {\n           if first { first = false; }\n           else { r += \"::\"; }"}, {"sha": "21cefac65a86089a416a832a9946e26fe557fcbc", "filename": "src/rustc/middle/trans/impl.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b5a4fa9456683f40539f885d4e555b87384df09a/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5a4fa9456683f40539f885d4e555b87384df09a/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs?ref=b5a4fa9456683f40539f885d4e555b87384df09a", "patch": "@@ -19,7 +19,7 @@ fn trans_impl(ccx: @crate_ctxt, path: path, name: ast::ident,\n     let _icx = ccx.insn_ctxt(\"impl::trans_impl\");\n     if tps.len() > 0u { ret; }\n     let sub_path = path + [path_name(name)];\n-    for m in methods {\n+    for vec::each(methods) {|m|\n         if m.tps.len() == 0u {\n             let llfn = get_item_val(ccx, m.id);\n             trans_fn(ccx, sub_path + [path_name(m.ident)], m.decl, m.body,\n@@ -156,9 +156,9 @@ fn find_vtable_in_fn_ctxt(ps: param_substs, n_param: uint, n_bound: uint)\n     let mut vtable_off = n_bound, i = 0u;\n     // Vtables are stored in a flat array, finding the right one is\n     // somewhat awkward\n-    for bounds in *ps.bounds {\n+    for vec::each(*ps.bounds) {|bounds|\n         if i >= n_param { break; }\n-        for bound in *bounds {\n+        for vec::each(*bounds) {|bound|\n             alt bound { ty::bound_iface(_) { vtable_off += 1u; } _ {} }\n         }\n         i += 1u;"}, {"sha": "696861a4e1f55a5dfb9e99488be522680345f259", "filename": "src/rustc/middle/trans/native.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b5a4fa9456683f40539f885d4e555b87384df09a/src%2Frustc%2Fmiddle%2Ftrans%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5a4fa9456683f40539f885d4e555b87384df09a/src%2Frustc%2Fmiddle%2Ftrans%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fnative.rs?ref=b5a4fa9456683f40539f885d4e555b87384df09a", "patch": "@@ -144,7 +144,7 @@ fn classify_ty(ty: TypeRef) -> [x86_64_reg_class] {\n             classify(T_i64(), cls, i, off);\n         } else {\n             let mut field_off = off;\n-            for ty in tys {\n+            for vec::each(tys) {|ty|\n                 field_off = align(field_off, ty);\n                 classify(ty, cls, i, field_off);\n                 field_off += ty_size(ty);\n@@ -252,7 +252,7 @@ fn classify_ty(ty: TypeRef) -> [x86_64_reg_class] {\n fn llreg_ty(cls: [x86_64_reg_class]) -> TypeRef {\n     fn llvec_len(cls: [x86_64_reg_class]) -> uint {\n         let mut len = 1u;\n-        for c in cls {\n+        for vec::each(cls) {|c|\n             if c != sseup_class {\n                 break;\n             }\n@@ -348,7 +348,7 @@ fn x86_64_tys(atys: [TypeRef],\n \n     let mut arg_tys = [];\n     let mut attrs = [];\n-    for t in atys {\n+    for vec::each(atys) {|t|\n         let (ty, attr) = x86_64_ty(t, is_pass_byval, ByValAttribute);\n         arg_tys += [ty];\n         attrs += [attr];\n@@ -735,7 +735,7 @@ fn trans_native_mod(ccx: @crate_ctxt,\n       ast::native_abi_stdcall { lib::llvm::X86StdcallCallConv }\n     };\n \n-    for native_item in native_mod.items {\n+    for vec::each(native_mod.items) {|native_item|\n       alt native_item.node {\n         ast::native_item_fn(fn_decl, _) {\n           let id = native_item.id;"}, {"sha": "db0b6f923b0b4dbcfdbb4ff95ec5c6cef2979ffa", "filename": "src/rustc/middle/trans/reachable.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b5a4fa9456683f40539f885d4e555b87384df09a/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5a4fa9456683f40539f885d4e555b87384df09a/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs?ref=b5a4fa9456683f40539f885d4e555b87384df09a", "patch": "@@ -31,11 +31,11 @@ fn find_reachable(crate_mod: _mod, exp_map: resolve::exp_map,\n \n fn traverse_exports(cx: ctx, vis: [@view_item]) -> bool {\n     let mut found_export = false;\n-    for vi in vis {\n+    for vec::each(vis) {|vi|\n         alt vi.node {\n           view_item_export(vps) {\n             found_export = true;\n-            for vp in vps {\n+            for vec::each(vps) {|vp|\n                 alt vp.node {\n                   view_path_simple(_, _, id) | view_path_glob(_, id) |\n                   view_path_list(_, _, id) {\n@@ -52,7 +52,7 @@ fn traverse_exports(cx: ctx, vis: [@view_item]) -> bool {\n \n fn traverse_export(cx: ctx, exp_id: node_id) {\n     option::may(cx.exp_map.find(exp_id)) {|defs|\n-        for def in defs { traverse_def_id(cx, def.id); }\n+        for vec::each(defs) {|def| traverse_def_id(cx, def.id); }\n     }\n }\n \n@@ -70,7 +70,7 @@ fn traverse_def_id(cx: ctx, did: def_id) {\n fn traverse_public_mod(cx: ctx, m: _mod) {\n     if !traverse_exports(cx, m.view_items) {\n         // No exports, so every local item is exported\n-        for item in m.items { traverse_public_item(cx, item); }\n+        for vec::each(m.items) {|item| traverse_public_item(cx, item); }\n     }\n }\n \n@@ -81,7 +81,7 @@ fn traverse_public_item(cx: ctx, item: @item) {\n       item_mod(m) { traverse_public_mod(cx, m); }\n       item_native_mod(nm) {\n           if !traverse_exports(cx, nm.view_items) {\n-              for item in nm.items { cx.rmap.insert(item.id, ()); }\n+              for vec::each(nm.items) {|item| cx.rmap.insert(item.id, ()); }\n           }\n       }\n       item_res(_, tps, blk, _, _) | item_fn(_, tps, blk) {\n@@ -91,7 +91,7 @@ fn traverse_public_item(cx: ctx, item: @item) {\n         }\n       }\n       item_impl(tps, _, _, ms) {\n-        for m in ms {\n+        for vec::each(ms) {|m|\n             if tps.len() > 0u || m.tps.len() > 0u ||\n                attr::find_inline_attr(m.attrs) != attr::ia_none {\n                 traverse_inline_body(cx, m.body);\n@@ -100,7 +100,7 @@ fn traverse_public_item(cx: ctx, item: @item) {\n       }\n       item_class(tps, items, ctor) {\n         cx.rmap.insert(ctor.node.id, ());\n-        for item in items {\n+        for vec::each(items) {|item|\n             alt item.node.decl {\n               class_method(m) {\n                 cx.rmap.insert(m.id, ());"}, {"sha": "9a90d1e8270889cb1f20287f94ba8a685c958e90", "filename": "src/rustc/middle/trans/shape.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b5a4fa9456683f40539f885d4e555b87384df09a/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5a4fa9456683f40539f885d4e555b87384df09a/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs?ref=b5a4fa9456683f40539f885d4e555b87384df09a", "patch": "@@ -66,7 +66,7 @@ fn hash_res_info(ri: res_info) -> uint {\n     h += ri.did.crate as uint;\n     h *= 33u;\n     h += ri.did.node as uint;\n-    for t in ri.tps {\n+    for vec::each(ri.tps) {|t|\n         h *= 33u;\n         h += ty::type_id(t);\n     }\n@@ -104,10 +104,10 @@ fn largest_variants(ccx: @crate_ctxt, tag_id: ast::def_id) -> [uint] {\n     // just T.\n     let mut ranges = [];\n     let variants = ty::enum_variants(ccx.tcx, tag_id);\n-    for variant: ty::variant_info in *variants {\n+    for vec::each(*variants) {|variant|\n         let mut bounded = true;\n         let mut min_size = 0u, min_align = 0u;\n-        for elem_t: ty::t in variant.args {\n+        for vec::each(variant.args) {|elem_t|\n             if ty::type_has_params(elem_t) {\n                 // FIXME: We could do better here; this causes us to\n                 // conservatively assume that (int, T) has minimum size 0,\n@@ -127,7 +127,7 @@ fn largest_variants(ccx: @crate_ctxt, tag_id: ast::def_id) -> [uint] {\n \n     // Initialize the candidate set to contain all variants.\n     let mut candidates = [mut];\n-    for variant in *variants { candidates += [mut true]; }\n+    for vec::each(*variants) {|_v| candidates += [mut true]; }\n \n     // Do a pairwise comparison among all variants still in the candidate set.\n     // Throw out any variant that we know has size and alignment at least as\n@@ -180,10 +180,10 @@ fn compute_static_enum_size(ccx: @crate_ctxt, largest_variants: [uint],\n     let mut max_size = 0u16;\n     let mut max_align = 1u8;\n     let variants = ty::enum_variants(ccx.tcx, did);\n-    for vid: uint in largest_variants {\n+    for vec::each(largest_variants) {|vid|\n         // We increment a \"virtual data pointer\" to compute the size.\n         let mut lltys = [];\n-        for typ: ty::t in variants[vid].args {\n+        for vec::each(variants[vid].args) {|typ|\n             lltys += [type_of::type_of(ccx, typ)];\n         }\n \n@@ -332,7 +332,7 @@ fn shape_of(ccx: @crate_ctxt, t: ty::t, ty_param_map: [uint]) -> [u8] {\n             add_u16(s, id as u16);\n \n             add_u16(s, vec::len(tps) as u16);\n-            for tp: ty::t in tps {\n+            for vec::each(tps) {|tp|\n                 let subshape = shape_of(ccx, tp, ty_param_map);\n                 add_u16(s, vec::len(subshape) as u16);\n                 s += subshape;\n@@ -355,15 +355,15 @@ fn shape_of(ccx: @crate_ctxt, t: ty::t, ty_param_map: [uint]) -> [u8] {\n       }\n       ty::ty_rec(fields) {\n         let mut s = [shape_struct], sub = [];\n-        for f: field in fields {\n+        for vec::each(fields) {|f|\n             sub += shape_of(ccx, f.mt.ty, ty_param_map);\n         }\n         add_substr(s, sub);\n         s\n       }\n       ty::ty_tup(elts) {\n         let mut s = [shape_struct], sub = [];\n-        for elt in elts {\n+        for vec::each(elts) {|elt|\n             sub += shape_of(ccx, elt, ty_param_map);\n         }\n         add_substr(s, sub);\n@@ -384,7 +384,7 @@ fn shape_of(ccx: @crate_ctxt, t: ty::t, ty_param_map: [uint]) -> [u8] {\n         let mut s = [shape_res];\n         add_u16(s, id as u16);\n         add_u16(s, vec::len(tps) as u16);\n-        for tp: ty::t in tps {\n+        for vec::each(tps) {|tp|\n             add_substr(s, shape_of(ccx, tp, ty_param_map));\n         }\n         add_substr(s, shape_of(ccx, subt, ty_param_map));\n@@ -418,7 +418,7 @@ fn shape_of_variant(ccx: @crate_ctxt, v: ty::variant_info,\n     while i < ty_param_count { ty_param_map += [i]; i += 1u; }\n \n     let mut s = [];\n-    for t: ty::t in v.args { s += shape_of(ccx, t, ty_param_map); }\n+    for vec::each(v.args) {|t| s += shape_of(ccx, t, ty_param_map); }\n     ret s;\n }\n \n@@ -458,7 +458,7 @@ fn gen_enum_shapes(ccx: @crate_ctxt) -> ValueRef {\n     let data_sz = vec::len(data) as u16;\n \n     let mut info_sz = 0u16;\n-    for did_: ast::def_id in ccx.shape_cx.tag_order {\n+    for did_ in ccx.shape_cx.tag_order {\n         let did = did_; // Satisfy alias checker.\n         let num_variants = vec::len(*ty::enum_variants(ccx.tcx, did)) as u16;\n         add_u16(header, header_sz + info_sz);\n@@ -471,7 +471,7 @@ fn gen_enum_shapes(ccx: @crate_ctxt) -> ValueRef {\n \n     let mut lv_table = [];\n     i = 0u;\n-    for did_: ast::def_id in ccx.shape_cx.tag_order {\n+    for did_ in ccx.shape_cx.tag_order {\n         let did = did_; // Satisfy alias checker.\n         let variants = ty::enum_variants(ccx.tcx, did);\n         add_u16(info, vec::len(*variants) as u16);\n@@ -482,7 +482,7 @@ fn gen_enum_shapes(ccx: @crate_ctxt) -> ValueRef {\n \n         let lv = largest_variants(ccx, did);\n         add_u16(lv_table, vec::len(lv) as u16);\n-        for v: uint in lv { add_u16(lv_table, v as u16); }\n+        for vec::each(lv) {|v| add_u16(lv_table, v as u16); }\n \n         // Determine whether the enum has dynamic size.\n         let dynamic = vec::any(*variants, {|v|\n@@ -498,7 +498,7 @@ fn gen_enum_shapes(ccx: @crate_ctxt) -> ValueRef {\n         info += [size_align.align];\n \n         // Now write in the offset of each variant.\n-        for v: ty::variant_info in *variants {\n+        for vec::each(*variants) {|_v|\n             add_u16(info, header_sz + info_sz + offsets[i]);\n             i += 1u;\n         }\n@@ -594,7 +594,7 @@ fn static_size_of_enum(cx: @crate_ctxt, t: ty::t) -> uint {\n         // Compute max(variant sizes).\n         let mut max_size = 0u;\n         let variants = ty::enum_variants(cx.tcx, tid);\n-        for variant: ty::variant_info in *variants {\n+        for vec::each(*variants) {|variant|\n             let tup_ty = simplify_type(cx.tcx,\n                                        ty::mk_tup(cx.tcx, variant.args));\n             // Perform any type parameter substitutions."}, {"sha": "12bfdb9fdfaddaa6ab0fcb03428830b1c7641c27", "filename": "src/rustc/middle/trans/tvec.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b5a4fa9456683f40539f885d4e555b87384df09a/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5a4fa9456683f40539f885d4e555b87384df09a/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=b5a4fa9456683f40539f885d4e555b87384df09a", "patch": "@@ -103,7 +103,7 @@ fn trans_vec(bcx: block, args: [@ast::expr], id: ast::node_id,\n     let ccx = bcx.ccx();\n     let mut bcx = bcx;\n     if dest == base::ignore {\n-        for arg in args {\n+        for vec::each(args) {|arg|\n             bcx = base::trans_expr(bcx, arg, base::ignore);\n         }\n         ret bcx;\n@@ -118,14 +118,14 @@ fn trans_vec(bcx: block, args: [@ast::expr], id: ast::node_id,\n     // Store the individual elements.\n     let dataptr = get_dataptr(bcx, vptr, llunitty);\n     let mut i = 0u, temp_cleanups = [vptr];\n-    for e in args {\n+    for vec::each(args) {|e|\n         let lleltptr = InBoundsGEP(bcx, dataptr, [C_uint(ccx, i)]);\n         bcx = base::trans_expr_save_in(bcx, e, lleltptr);\n         add_clean_temp_mem(bcx, lleltptr, unit_ty);\n         temp_cleanups += [lleltptr];\n         i += 1u;\n     }\n-    for cln in temp_cleanups { revoke_clean(bcx, cln); }\n+    for vec::each(temp_cleanups) {|cln| revoke_clean(bcx, cln); }\n     ret base::store_in_dest(bcx, vptr, dest);\n }\n \n@@ -192,7 +192,7 @@ fn trans_append_literal(bcx: block, vptrptr: ValueRef, vec_ty: ty::t,\n     let elt_llty = type_of::type_of(ccx, elt_ty);\n     let elt_sz = shape::llsize_of(ccx, elt_llty);\n     let scratch = base::alloca(bcx, elt_llty);\n-    for val in vals {\n+    for vec::each(vals) {|val|\n         bcx = base::trans_expr_save_in(bcx, val, scratch);\n         let vptr = Load(bcx, vptrptr);\n         let old_fill = get_fill(bcx, vptr);"}, {"sha": "0cbe832d4e0f6e9031ab38a5fcd5669b8e5b2a83", "filename": "src/rustc/middle/trans/type_of.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b5a4fa9456683f40539f885d4e555b87384df09a/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5a4fa9456683f40539f885d4e555b87384df09a/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=b5a4fa9456683f40539f885d4e555b87384df09a", "patch": "@@ -58,7 +58,7 @@ fn type_of(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n       ty::ty_rptr(_, mt) { T_ptr(type_of(cx, mt.ty)) }\n       ty::ty_rec(fields) {\n         let mut tys: [TypeRef] = [];\n-        for f: ty::field in fields {\n+        for vec::each(fields) {|f|\n             let mt_ty = f.mt.ty;\n             tys += [type_of(cx, mt_ty)];\n         }\n@@ -74,7 +74,7 @@ fn type_of(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n       ty::ty_type { T_ptr(cx.tydesc_type) }\n       ty::ty_tup(elts) {\n         let mut tys = [];\n-        for elt in elts {\n+        for vec::each(elts) {|elt|\n             tys += [type_of(cx, elt)];\n         }\n         T_struct(tys)"}, {"sha": "d407cb59e7f2d61947896258ce9076940170020d", "filename": "src/rustc/middle/trans/type_use.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b5a4fa9456683f40539f885d4e555b87384df09a/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5a4fa9456683f40539f885d4e555b87384df09a/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=b5a4fa9456683f40539f885d4e555b87384df09a", "patch": "@@ -45,7 +45,7 @@ fn type_uses_for(ccx: @crate_ctxt, fn_id: def_id, n_tps: uint)\n     let cx = {ccx: ccx, uses: vec::to_mut(vec::from_elem(n_tps, 0u))};\n     alt ty::get(ty::lookup_item_type(cx.ccx.tcx, fn_id).ty).struct {\n       ty::ty_fn({inputs, _}) {\n-        for arg in inputs {\n+        for vec::each(inputs) {|arg|\n             if arg.mode == expl(by_val) { type_needs(cx, use_repr, arg.ty); }\n         }\n       }\n@@ -90,7 +90,7 @@ fn type_uses_for(ccx: @crate_ctxt, fn_id: def_id, n_tps: uint)\n fn type_needs(cx: ctx, use: uint, ty: ty::t) {\n     let mut done = true;\n     // Optimization -- don't descend type if all params already have this use\n-    for u in cx.uses { if u & use != use { done = false } }\n+    for vec::each(cx.uses) {|u| if u & use != use { done = false } }\n     if !done { type_needs_inner(cx, use, ty); }\n }\n \n@@ -101,8 +101,8 @@ fn type_needs_inner(cx: ctx, use: uint, ty: ty::t) {\n               ty::ty_fn(_) | ty::ty_ptr(_) | ty::ty_rptr(_, _) |\n               ty::ty_box(_) | ty::ty_iface(_, _) { false }\n               ty::ty_enum(did, tps) {\n-                for v in *ty::enum_variants(cx.ccx.tcx, did) {\n-                    for aty in v.args {\n+                for vec::each(*ty::enum_variants(cx.ccx.tcx, did)) {|v|\n+                    for vec::each(v.args) {|aty|\n                         let t = ty::substitute_type_params(cx.ccx.tcx, tps,\n                                                            aty);\n                         type_needs_inner(cx, use, t);\n@@ -152,7 +152,7 @@ fn mark_for_expr(cx: ctx, e: @expr) {\n         alt ty::ty_fn_proto(ty::expr_ty(cx.ccx.tcx, e)) {\n           proto_bare | proto_any | proto_uniq {}\n           proto_box | proto_block {\n-            for fv in *freevars::get_freevars(cx.ccx.tcx, e.id) {\n+            for vec::each(*freevars::get_freevars(cx.ccx.tcx, e.id)) {|fv|\n                 let node_id = ast_util::def_id_of_def(fv.def).node;\n                 node_type_needs(cx, use_repr, node_id);\n             }"}]}