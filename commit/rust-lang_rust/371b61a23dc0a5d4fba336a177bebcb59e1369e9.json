{"sha": "371b61a23dc0a5d4fba336a177bebcb59e1369e9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM3MWI2MWEyM2RjMGE1ZDRmYmEzMzZhMTc3YmViY2I1OWUxMzY5ZTk=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-01-02T11:58:31Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-01-02T14:15:28Z"}, "message": "Drop two useless sub-passes from trans\n\nNeither collect_tag_ctors nor the second pass in collect_items needed\nto be separate passes.\n\nAlso remove obsolete obj_methods table kludge.", "tree": {"sha": "e2b1f3e1736068237d03abc4ebb05aa0a985a184", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e2b1f3e1736068237d03abc4ebb05aa0a985a184"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/371b61a23dc0a5d4fba336a177bebcb59e1369e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/371b61a23dc0a5d4fba336a177bebcb59e1369e9", "html_url": "https://github.com/rust-lang/rust/commit/371b61a23dc0a5d4fba336a177bebcb59e1369e9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/371b61a23dc0a5d4fba336a177bebcb59e1369e9/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a4694ce146f5a61d58fdffeb5443c395c32069fe", "url": "https://api.github.com/repos/rust-lang/rust/commits/a4694ce146f5a61d58fdffeb5443c395c32069fe", "html_url": "https://github.com/rust-lang/rust/commit/a4694ce146f5a61d58fdffeb5443c395c32069fe"}], "stats": {"total": 157, "additions": 59, "deletions": 98}, "files": [{"sha": "c38dc5763f6eac0c0322850bdd5e116aed2e806b", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 55, "deletions": 96, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/371b61a23dc0a5d4fba336a177bebcb59e1369e9/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/371b61a23dc0a5d4fba336a177bebcb59e1369e9/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=371b61a23dc0a5d4fba336a177bebcb59e1369e9", "patch": "@@ -5010,8 +5010,8 @@ fn trans_item(cx: @local_ctxt, item: ast::item) {\n                  with *extend_path(cx, item.ident)};\n         trans_obj(sub_cx, item.span, ob, ctor_id, tps);\n       }\n-      ast::item_impl(tps, _, _, ms) {\n-        trans_impl::trans_impl(cx, item.ident, ms, item.id, tps);\n+      ast::item_impl(tps, ifce, _, ms) {\n+        trans_impl::trans_impl(cx, item.ident, ms, item.id, tps, ifce);\n       }\n       ast::item_res(decl, tps, body, dtor_id, ctor_id) {\n         trans_res_ctor(cx, item.span, decl, ctor_id, tps);\n@@ -5249,56 +5249,55 @@ fn collect_native_item(ccx: @crate_ctxt,\n                        _v: vt<[str]>) {\n     alt i.node {\n       ast::native_item_fn(_, tps) {\n-        if !ccx.obj_methods.contains_key(i.id) {\n-            let sp = i.span;\n-            let id = i.id;\n-            let node_type = node_id_type(ccx, id);\n-            let fn_abi =\n-                alt attr::get_meta_item_value_str_by_name(i.attrs, \"abi\") {\n-              option::none. {\n+        let sp = i.span;\n+        let id = i.id;\n+        let node_type = node_id_type(ccx, id);\n+        let fn_abi =\n+            alt attr::get_meta_item_value_str_by_name(i.attrs, \"abi\") {\n+            option::none. {\n                 // if abi isn't specified for this function, inherit from\n-                // its enclosing native module\n-                option::get(*abi)\n+                  // its enclosing native module\n+                  option::get(*abi)\n               }\n-              _ {\n-                alt attr::native_abi(i.attrs) {\n-                  either::right(abi_) { abi_ }\n-                  either::left(msg) { ccx.sess.span_fatal(i.span, msg) }\n+                _ {\n+                    alt attr::native_abi(i.attrs) {\n+                      either::right(abi_) { abi_ }\n+                      either::left(msg) { ccx.sess.span_fatal(i.span, msg) }\n+                    }\n                 }\n-              }\n             };\n-            alt fn_abi {\n-              ast::native_abi_rust_intrinsic. {\n-                // For intrinsics: link the function directly to the intrinsic\n-                // function itself.\n-                check returns_non_ty_var(ccx, node_type);\n-                let fn_type = type_of_fn_from_ty(\n-                    ccx, sp, node_type,\n-                    vec::map(tps, {|p| param_bounds(ccx, p)}));\n-                let ri_name = \"rust_intrinsic_\" + link_name(i);\n-                let llnativefn = get_extern_fn(\n-                    ccx.externs, ccx.llmod, ri_name,\n-                    lib::llvm::LLVMCCallConv, fn_type);\n-                ccx.item_ids.insert(id, llnativefn);\n-                ccx.item_symbols.insert(id, ri_name);\n-              }\n+        alt fn_abi {\n+          ast::native_abi_rust_intrinsic. {\n+            // For intrinsics: link the function directly to the intrinsic\n+            // function itself.\n+            check returns_non_ty_var(ccx, node_type);\n+            let fn_type = type_of_fn_from_ty(\n+                ccx, sp, node_type,\n+                vec::map(tps, {|p| param_bounds(ccx, p)}));\n+            let ri_name = \"rust_intrinsic_\" + link_name(i);\n+            let llnativefn = get_extern_fn(\n+                ccx.externs, ccx.llmod, ri_name,\n+                lib::llvm::LLVMCCallConv, fn_type);\n+            ccx.item_ids.insert(id, llnativefn);\n+            ccx.item_symbols.insert(id, ri_name);\n+          }\n \n-              ast::native_abi_cdecl. | ast::native_abi_stdcall. {\n-                // For true external functions: create a rust wrapper\n-                // and link to that.  The rust wrapper will handle\n-                // switching to the C stack.\n-                let new_pt = pt + [i.ident];\n-                register_fn(ccx, i.span, new_pt, \"native fn\", tps, i.id);\n-              }\n-            }\n+          ast::native_abi_cdecl. | ast::native_abi_stdcall. {\n+            // For true external functions: create a rust wrapper\n+            // and link to that.  The rust wrapper will handle\n+            // switching to the C stack.\n+            let new_pt = pt + [i.ident];\n+            register_fn(ccx, i.span, new_pt, \"native fn\", tps, i.id);\n+          }\n         }\n       }\n       _ { }\n     }\n }\n \n-fn collect_item_1(ccx: @crate_ctxt, abi: @mutable option::t<ast::native_abi>,\n-                  i: @ast::item, &&pt: [str], v: vt<[str]>) {\n+fn collect_item(ccx: @crate_ctxt, abi: @mutable option::t<ast::native_abi>,\n+                i: @ast::item, &&pt: [str], v: vt<[str]>) {\n+    let new_pt = pt + [i.ident];\n     alt i.node {\n       ast::item_const(_, _) {\n         let typ = node_id_type(ccx, i.id);\n@@ -5323,26 +5322,11 @@ fn collect_item_1(ccx: @crate_ctxt, abi: @mutable option::t<ast::native_abi>,\n           }\n         }\n       }\n-      _ { }\n-    }\n-    visit::visit_item(i, pt + [i.ident], v);\n-}\n-\n-fn collect_item_2(ccx: @crate_ctxt, i: @ast::item, &&pt: [str],\n-                  v: vt<[str]>) {\n-    let new_pt = pt + [i.ident];\n-    visit::visit_item(i, new_pt, v);\n-    alt i.node {\n       ast::item_fn(_, tps, _) {\n-        if !ccx.obj_methods.contains_key(i.id) {\n-            register_fn(ccx, i.span, new_pt, \"fn\", tps, i.id);\n-        }\n+        register_fn(ccx, i.span, new_pt, \"fn\", tps, i.id);\n       }\n       ast::item_obj(ob, tps, ctor_id) {\n         register_fn(ccx, i.span, new_pt, \"obj_ctor\", tps, ctor_id);\n-        for m: @ast::method in ob.methods {\n-            ccx.obj_methods.insert(m.id, ());\n-        }\n       }\n       ast::item_impl(tps, _, _, methods) {\n         let name = ccx.names.next(i.ident);\n@@ -5362,47 +5346,28 @@ fn collect_item_2(ccx: @crate_ctxt, i: @ast::item, &&pt: [str],\n         check returns_non_ty_var(ccx, t);\n         register_fn_full(ccx, i.span, new_pt, \"res_dtor\", tps, i.id, t);\n       }\n-      _ { }\n-    }\n-}\n-\n-fn collect_items(ccx: @crate_ctxt, crate: @ast::crate) {\n-    let abi = @mutable none::<ast::native_abi>;\n-    let visitor0 = visit::default_visitor();\n-    let visitor1 =\n-        @{visit_native_item: bind collect_native_item(ccx, abi, _, _, _),\n-          visit_item: bind collect_item_1(ccx, abi, _, _, _) with *visitor0};\n-    let visitor2 =\n-        @{visit_item: bind collect_item_2(ccx, _, _, _) with *visitor0};\n-    visit::visit_crate(*crate, [], visit::mk_vt(visitor1));\n-    visit::visit_crate(*crate, [], visit::mk_vt(visitor2));\n-}\n-\n-fn collect_tag_ctor(ccx: @crate_ctxt, i: @ast::item, &&pt: [str],\n-                    v: vt<[str]>) {\n-    let new_pt = pt + [i.ident];\n-    visit::visit_item(i, new_pt, v);\n-    alt i.node {\n       ast::item_tag(variants, tps) {\n-        for variant: ast::variant in variants {\n+        for variant in variants {\n             if vec::len(variant.node.args) != 0u {\n                 register_fn(ccx, i.span, new_pt + [variant.node.name],\n                             \"tag\", tps, variant.node.id);\n             }\n         }\n       }\n-      _ {/* fall through */ }\n+      _ { }\n     }\n+    visit::visit_item(i, new_pt, v);\n }\n \n-fn collect_tag_ctors(ccx: @crate_ctxt, crate: @ast::crate) {\n-    let visitor =\n-        @{visit_item: bind collect_tag_ctor(ccx, _, _, _)\n-             with *visit::default_visitor()};\n-    visit::visit_crate(*crate, [], visit::mk_vt(visitor));\n+fn collect_items(ccx: @crate_ctxt, crate: @ast::crate) {\n+    let abi = @mutable none::<ast::native_abi>;\n+    visit::visit_crate(*crate, [], visit::mk_vt(@{\n+        visit_native_item: bind collect_native_item(ccx, abi, _, _, _),\n+        visit_item: bind collect_item(ccx, abi, _, _, _)\n+        with *visit::default_visitor()\n+    }));\n }\n \n-\n // The constant translation pass.\n fn trans_constant(ccx: @crate_ctxt, it: @ast::item, &&pt: [str],\n                   v: vt<[str]>) {\n@@ -5411,15 +5376,12 @@ fn trans_constant(ccx: @crate_ctxt, it: @ast::item, &&pt: [str],\n     alt it.node {\n       ast::item_tag(variants, _) {\n         let i = 0u;\n-        let n_variants = vec::len::<ast::variant>(variants);\n-        while i < n_variants {\n-            let variant = variants[i];\n+        for variant in variants {\n             let p = new_pt + [it.ident, variant.node.name, \"discrim\"];\n             let s = mangle_exported_name(ccx, p, ty::mk_int(ccx.tcx));\n-            let discrim_gvar =\n-                str::as_buf(s, {|buf|\n-                    llvm::LLVMAddGlobal(ccx.llmod, ccx.int_type, buf)\n-                });\n+            let discrim_gvar = str::as_buf(s, {|buf|\n+                llvm::LLVMAddGlobal(ccx.llmod, ccx.int_type, buf)\n+            });\n             llvm::LLVMSetInitializer(discrim_gvar, C_int(ccx, i as int));\n             llvm::LLVMSetGlobalConstant(discrim_gvar, True);\n             ccx.discrims.insert(\n@@ -5670,7 +5632,6 @@ fn trans_crate(sess: session::session, crate: @ast::crate, tcx: ty::ctxt,\n           discrims: ast_util::new_def_id_hash::<ValueRef>(),\n           discrim_symbols: new_int_hash::<str>(),\n           consts: new_int_hash::<ValueRef>(),\n-          obj_methods: new_int_hash::<()>(),\n           tydescs: ty::new_ty_hash(),\n           module_data: new_str_hash::<ValueRef>(),\n           lltypes: ty::new_ty_hash(),\n@@ -5706,7 +5667,6 @@ fn trans_crate(sess: session::session, crate: @ast::crate, tcx: ty::ctxt,\n           dbg_cx: dbg_cx};\n     let cx = new_local_ctxt(ccx);\n     collect_items(ccx, crate);\n-    collect_tag_ctors(ccx, crate);\n     trans_constants(ccx, crate);\n     trans_mod(cx, crate.node.module);\n     fill_crate_map(ccx, crate_map);\n@@ -5724,7 +5684,6 @@ fn trans_crate(sess: session::session, crate: @ast::crate, tcx: ty::ctxt,\n         #error(\"n_null_glues: %u\", ccx.stats.n_null_glues);\n         #error(\"n_real_glues: %u\", ccx.stats.n_real_glues);\n \n-\n         for timing: {ident: str, time: int} in *ccx.stats.fn_times {\n             #error(\"time: %s took %d ms\", timing.ident, timing.time);\n         }"}, {"sha": "95cddc2af6d6f0a58666e791d43be8b15fa315fe", "filename": "src/comp/middle/trans_common.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/371b61a23dc0a5d4fba336a177bebcb59e1369e9/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/371b61a23dc0a5d4fba336a177bebcb59e1369e9/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_common.rs?ref=371b61a23dc0a5d4fba336a177bebcb59e1369e9", "patch": "@@ -92,7 +92,6 @@ type crate_ctxt =\n      discrims: hashmap<ast::def_id, ValueRef>,\n      discrim_symbols: hashmap<ast::node_id, str>,\n      consts: hashmap<ast::node_id, ValueRef>,\n-     obj_methods: hashmap<ast::node_id, ()>,\n      tydescs: hashmap<ty::t, @tydesc_info>,\n      module_data: hashmap<str, ValueRef>,\n      lltypes: hashmap<ty::t, TypeRef>,"}, {"sha": "a393ebaf109fcc3b3223624bfdb32a177e1e7e56", "filename": "src/comp/middle/trans_impl.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/371b61a23dc0a5d4fba336a177bebcb59e1369e9/src%2Fcomp%2Fmiddle%2Ftrans_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/371b61a23dc0a5d4fba336a177bebcb59e1369e9/src%2Fcomp%2Fmiddle%2Ftrans_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_impl.rs?ref=371b61a23dc0a5d4fba336a177bebcb59e1369e9", "patch": "@@ -1,10 +1,13 @@\n import trans::*;\n import trans_common::*;\n+import trans_build::*;\n import option::{some, none};\n import syntax::ast;\n+import lib::llvm;\n \n fn trans_impl(cx: @local_ctxt, name: ast::ident, methods: [@ast::method],\n-              id: ast::node_id, tps: [ast::ty_param]) {\n+              id: ast::node_id, tps: [ast::ty_param],\n+              _ifce: option::t<@ast::ty>) {\n     let sub_cx = extend_path(cx, name);\n     for m in methods {\n         alt cx.ccx.item_ids.find(m.id) {"}]}