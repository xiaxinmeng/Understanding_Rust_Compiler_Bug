{"sha": "3029e0918de00162932132a7972e566f3a3372f5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMwMjllMDkxOGRlMDAxNjI5MzIxMzJhNzk3MmU1NjZmM2EzMzcyZjU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-03-05T20:11:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-03-05T20:11:37Z"}, "message": "Auto merge of #31726 - jseyfried:improve_import_resolution, r=nikomatsakis\n\nThis PR improves the import resolution algorithm.\n\nFirst, it records that an import succeeded or failed for one namespace (by calling `decrement_outstanding_references_for` and `try_define_child` if successful) even if it is still indeterminate in the other namespace, fixing #31444.\n\nSecond, it starts importing bindings from globs as soon as the glob path is determined.\nIt maintains links from imported modules to their importers so that when a resolution becomes successful in an imported module, a corresponding binding will be added to the importer module.\nIt also maintains links from importer modules to imported modules so that we can determine if an undefined name is indeterminate or failing by recursively checking this in the imported modules.\nThis allows, for example:\n```rust\nmod foo {\n    pub mod baz {}\n    pub use bar::baz::*;\n}\n\nmod bar {\n    pub use foo::*;\n}\n```\nIt also allows cycles of pub glob imports, although by to the current shadowing rules, the only way for such a cycle to compile is if each participating module defines no names. Incidentally, this PR lays the groundwork for more permissive feature-gated shadowing rules.\n\nFinally, this PR encapsulates almost all implementation details of import resolution in `resolve_imports` (some of which used to be in `lib.rs`) and refactors reexport recording, shadowed trait collecting, some duplicate checking, and the `private_in_public` lint out of the core import resolution algorithm and into a post-processing pass in `resolve_imports`.\n\nr? @nrc", "tree": {"sha": "699487dec6001d7a993929fcb77b44fa514673c0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/699487dec6001d7a993929fcb77b44fa514673c0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3029e0918de00162932132a7972e566f3a3372f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3029e0918de00162932132a7972e566f3a3372f5", "html_url": "https://github.com/rust-lang/rust/commit/3029e0918de00162932132a7972e566f3a3372f5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3029e0918de00162932132a7972e566f3a3372f5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "07a1803dd3ca02c16b9820d0102a9dfc9c5ab7a5", "url": "https://api.github.com/repos/rust-lang/rust/commits/07a1803dd3ca02c16b9820d0102a9dfc9c5ab7a5", "html_url": "https://github.com/rust-lang/rust/commit/07a1803dd3ca02c16b9820d0102a9dfc9c5ab7a5"}, {"sha": "b3572ae15a8e5d9a8a1cdc1055425a4c3e0cf5f9", "url": "https://api.github.com/repos/rust-lang/rust/commits/b3572ae15a8e5d9a8a1cdc1055425a4c3e0cf5f9", "html_url": "https://github.com/rust-lang/rust/commit/b3572ae15a8e5d9a8a1cdc1055425a4c3e0cf5f9"}], "stats": {"total": 693, "additions": 388, "deletions": 305}, "files": [{"sha": "b3d7be4775e42ae81d84549ed3ecd3161df4a075", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 13, "deletions": 28, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/3029e0918de00162932132a7972e566f3a3372f5/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3029e0918de00162932132a7972e566f3a3372f5/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=3029e0918de00162932132a7972e566f3a3372f5", "patch": "@@ -98,14 +98,14 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n     fn try_define<T>(&self, parent: Module<'b>, name: Name, ns: Namespace, def: T)\n         where T: ToNameBinding<'b>\n     {\n-        let _ = parent.try_define_child(name, ns, self.new_name_binding(def.to_name_binding()));\n+        let _ = parent.try_define_child(name, ns, def.to_name_binding());\n     }\n \n     /// Defines `name` in namespace `ns` of module `parent` to be `def` if it is not yet defined;\n     /// otherwise, reports an error.\n     fn define<T: ToNameBinding<'b>>(&self, parent: Module<'b>, name: Name, ns: Namespace, def: T) {\n-        let binding = self.new_name_binding(def.to_name_binding());\n-        let old_binding = match parent.try_define_child(name, ns, binding) {\n+        let binding = def.to_name_binding();\n+        let old_binding = match parent.try_define_child(name, ns, binding.clone()) {\n             Ok(()) => return,\n             Err(old_binding) => old_binding,\n         };\n@@ -207,7 +207,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                                           ResolutionError::SelfImportsOnlyAllowedWithin);\n                         }\n \n-                        let subclass = SingleImport(binding, source_name);\n+                        let subclass = ImportDirectiveSubclass::single(binding, source_name);\n                         self.build_import_directive(parent,\n                                                     module_path,\n                                                     subclass,\n@@ -258,9 +258,10 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                                     (module_path.to_vec(), name, rename)\n                                 }\n                             };\n+                            let subclass = ImportDirectiveSubclass::single(rename, name);\n                             self.build_import_directive(parent,\n                                                         module_path,\n-                                                        SingleImport(rename, name),\n+                                                        subclass,\n                                                         source_item.span,\n                                                         source_item.node.id(),\n                                                         is_public,\n@@ -294,14 +295,6 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                     let module = self.new_extern_crate_module(parent_link, def, is_public, item.id);\n                     self.define(parent, name, TypeNS, (module, sp));\n \n-                    if is_public {\n-                        let export = Export { name: name, def_id: def_id };\n-                        if let Some(def_id) = parent.def_id() {\n-                            let node_id = self.resolver.ast_map.as_local_node_id(def_id).unwrap();\n-                            self.export_map.entry(node_id).or_insert(Vec::new()).push(export);\n-                        }\n-                    }\n-\n                     self.build_reduced_graph_for_external_crate(module);\n                 }\n                 parent\n@@ -683,33 +676,25 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                               id: NodeId,\n                               is_public: bool,\n                               shadowable: Shadowable) {\n-        module_.unresolved_imports\n-               .borrow_mut()\n-               .push(ImportDirective::new(module_path, subclass, span, id, is_public, shadowable));\n-        self.unresolved_imports += 1;\n-\n-        if is_public {\n-            module_.inc_pub_count();\n-        }\n-\n         // Bump the reference count on the name. Or, if this is a glob, set\n         // the appropriate flag.\n \n         match subclass {\n-            SingleImport(target, _) => {\n+            SingleImport { target, .. } => {\n                 module_.increment_outstanding_references_for(target, ValueNS);\n                 module_.increment_outstanding_references_for(target, TypeNS);\n             }\n             GlobImport => {\n                 // Set the glob flag. This tells us that we don't know the\n                 // module's exports ahead of time.\n-\n-                module_.inc_glob_count();\n-                if is_public {\n-                    module_.inc_pub_glob_count();\n-                }\n+                module_.inc_glob_count(is_public)\n             }\n         }\n+\n+        let directive =\n+            ImportDirective::new(module_path, subclass, span, id, is_public, shadowable);\n+        module_.add_import_directive(directive);\n+        self.unresolved_imports += 1;\n     }\n }\n "}, {"sha": "a205bfb98acfefdd0e2f15eb05818eb14d1bf321", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 47, "deletions": 94, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/3029e0918de00162932132a7972e566f3a3372f5/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3029e0918de00162932132a7972e566f3a3372f5/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=3029e0918de00162932132a7972e566f3a3372f5", "patch": "@@ -18,6 +18,7 @@\n #![cfg_attr(not(stage0), deny(warnings))]\n \n #![feature(associated_consts)]\n+#![feature(borrow_state)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n@@ -812,7 +813,7 @@ pub struct ModuleS<'a> {\n     extern_crate_id: Option<NodeId>,\n \n     resolutions: RefCell<HashMap<(Name, Namespace), NameResolution<'a>>>,\n-    unresolved_imports: RefCell<Vec<ImportDirective>>,\n+    unresolved_imports: RefCell<Vec<&'a ImportDirective>>,\n \n     // The module children of this node, including normal modules and anonymous modules.\n     // Anonymous children are pseudo-modules that are implicitly created around items\n@@ -832,26 +833,31 @@ pub struct ModuleS<'a> {\n \n     shadowed_traits: RefCell<Vec<&'a NameBinding<'a>>>,\n \n-    // The number of unresolved globs that this module exports.\n-    glob_count: Cell<usize>,\n+    glob_importers: RefCell<Vec<(Module<'a>, &'a ImportDirective)>>,\n+    resolved_globs: RefCell<(Vec<Module<'a>> /* public */, Vec<Module<'a>> /* private */)>,\n \n-    // The number of unresolved pub imports (both regular and globs) in this module\n-    pub_count: Cell<usize>,\n+    // The number of public glob imports in this module.\n+    public_glob_count: Cell<usize>,\n \n-    // The number of unresolved pub glob imports in this module\n-    pub_glob_count: Cell<usize>,\n+    // The number of private glob imports in this module.\n+    private_glob_count: Cell<usize>,\n \n     // Whether this module is populated. If not populated, any attempt to\n     // access the children must be preceded with a\n     // `populate_module_if_necessary` call.\n     populated: Cell<bool>,\n+\n+    arenas: &'a ResolverArenas<'a>,\n }\n \n pub type Module<'a> = &'a ModuleS<'a>;\n \n impl<'a> ModuleS<'a> {\n-\n-    fn new(parent_link: ParentLink<'a>, def: Option<Def>, external: bool, is_public: bool) -> Self {\n+    fn new(parent_link: ParentLink<'a>,\n+           def: Option<Def>,\n+           external: bool,\n+           is_public: bool,\n+           arenas: &'a ResolverArenas<'a>) -> Self {\n         ModuleS {\n             parent_link: parent_link,\n             def: def,\n@@ -861,53 +867,18 @@ impl<'a> ModuleS<'a> {\n             unresolved_imports: RefCell::new(Vec::new()),\n             module_children: RefCell::new(NodeMap()),\n             shadowed_traits: RefCell::new(Vec::new()),\n-            glob_count: Cell::new(0),\n-            pub_count: Cell::new(0),\n-            pub_glob_count: Cell::new(0),\n+            glob_importers: RefCell::new(Vec::new()),\n+            resolved_globs: RefCell::new((Vec::new(), Vec::new())),\n+            public_glob_count: Cell::new(0),\n+            private_glob_count: Cell::new(0),\n             populated: Cell::new(!external),\n+            arenas: arenas\n         }\n     }\n \n-    fn resolve_name(&self, name: Name, ns: Namespace, allow_private_imports: bool)\n-                    -> ResolveResult<&'a NameBinding<'a>> {\n-        let glob_count =\n-            if allow_private_imports { self.glob_count.get() } else { self.pub_glob_count.get() };\n-\n-        self.resolutions.borrow().get(&(name, ns)).cloned().unwrap_or_default().result(glob_count)\n-            .and_then(|binding| {\n-                let allowed = allow_private_imports || !binding.is_import() || binding.is_public();\n-                if allowed { Success(binding) } else { Failed(None) }\n-            })\n-    }\n-\n-    // Define the name or return the existing binding if there is a collision.\n-    fn try_define_child(&self, name: Name, ns: Namespace, binding: &'a NameBinding<'a>)\n-                        -> Result<(), &'a NameBinding<'a>> {\n-        let mut children = self.resolutions.borrow_mut();\n-        let resolution = children.entry((name, ns)).or_insert_with(Default::default);\n-\n-        // FIXME #31379: We can use methods from imported traits shadowed by non-import items\n-        if let Some(old_binding) = resolution.binding {\n-            if !old_binding.is_import() && binding.is_import() {\n-                if let Some(Def::Trait(_)) = binding.def() {\n-                    self.shadowed_traits.borrow_mut().push(binding);\n-                }\n-            }\n-        }\n-\n-        resolution.try_define(binding)\n-    }\n-\n-    fn increment_outstanding_references_for(&self, name: Name, ns: Namespace) {\n-        let mut children = self.resolutions.borrow_mut();\n-        children.entry((name, ns)).or_insert_with(Default::default).outstanding_references += 1;\n-    }\n-\n-    fn decrement_outstanding_references_for(&self, name: Name, ns: Namespace) {\n-        match self.resolutions.borrow_mut().get_mut(&(name, ns)).unwrap().outstanding_references {\n-            0 => panic!(\"No more outstanding references!\"),\n-            ref mut outstanding_references => { *outstanding_references -= 1; }\n-        }\n+    fn add_import_directive(&self, import_directive: ImportDirective) {\n+        let import_directive = self.arenas.alloc_import_directive(import_directive);\n+        self.unresolved_imports.borrow_mut().push(import_directive);\n     }\n \n     fn for_each_child<F: FnMut(Name, Namespace, &'a NameBinding<'a>)>(&self, mut f: F) {\n@@ -943,26 +914,9 @@ impl<'a> ModuleS<'a> {\n         }\n     }\n \n-    pub fn inc_glob_count(&self) {\n-        self.glob_count.set(self.glob_count.get() + 1);\n-    }\n-    pub fn dec_glob_count(&self) {\n-        assert!(self.glob_count.get() > 0);\n-        self.glob_count.set(self.glob_count.get() - 1);\n-    }\n-    pub fn inc_pub_count(&self) {\n-        self.pub_count.set(self.pub_count.get() + 1);\n-    }\n-    pub fn dec_pub_count(&self) {\n-        assert!(self.pub_count.get() > 0);\n-        self.pub_count.set(self.pub_count.get() - 1);\n-    }\n-    pub fn inc_pub_glob_count(&self) {\n-        self.pub_glob_count.set(self.pub_glob_count.get() + 1);\n-    }\n-    pub fn dec_pub_glob_count(&self) {\n-        assert!(self.pub_glob_count.get() > 0);\n-        self.pub_glob_count.set(self.pub_glob_count.get() - 1);\n+    fn inc_glob_count(&self, is_public: bool) {\n+        let glob_count = if is_public { &self.public_glob_count } else { &self.private_glob_count };\n+        glob_count.set(glob_count.get() + 1);\n     }\n }\n \n@@ -995,14 +949,14 @@ bitflags! {\n }\n \n // Records a possibly-private value, type, or module definition.\n-#[derive(Debug)]\n+#[derive(Clone, Debug)]\n pub struct NameBinding<'a> {\n     modifiers: DefModifiers,\n     kind: NameBindingKind<'a>,\n     span: Option<Span>,\n }\n \n-#[derive(Debug)]\n+#[derive(Clone, Debug)]\n enum NameBindingKind<'a> {\n     Def(Def),\n     Module(Module<'a>),\n@@ -1167,6 +1121,19 @@ pub struct Resolver<'a, 'tcx: 'a> {\n pub struct ResolverArenas<'a> {\n     modules: arena::TypedArena<ModuleS<'a>>,\n     name_bindings: arena::TypedArena<NameBinding<'a>>,\n+    import_directives: arena::TypedArena<ImportDirective>,\n+}\n+\n+impl<'a> ResolverArenas<'a> {\n+    fn alloc_module(&'a self, module: ModuleS<'a>) -> Module<'a> {\n+        self.modules.alloc(module)\n+    }\n+    fn alloc_name_binding(&'a self, name_binding: NameBinding<'a>) -> &'a NameBinding<'a> {\n+        self.name_bindings.alloc(name_binding)\n+    }\n+    fn alloc_import_directive(&'a self, import_directive: ImportDirective) -> &'a ImportDirective {\n+        self.import_directives.alloc(import_directive)\n+    }\n }\n \n #[derive(PartialEq)]\n@@ -1182,8 +1149,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n            arenas: &'a ResolverArenas<'a>)\n            -> Resolver<'a, 'tcx> {\n         let root_def_id = ast_map.local_def_id(CRATE_NODE_ID);\n-        let graph_root = ModuleS::new(NoParentLink, Some(Def::Mod(root_def_id)), false, true);\n-        let graph_root = arenas.modules.alloc(graph_root);\n+        let graph_root =\n+            ModuleS::new(NoParentLink, Some(Def::Mod(root_def_id)), false, true, arenas);\n+        let graph_root = arenas.alloc_module(graph_root);\n \n         Resolver {\n             session: session,\n@@ -1234,6 +1202,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         ResolverArenas {\n             modules: arena::TypedArena::new(),\n             name_bindings: arena::TypedArena::new(),\n+            import_directives: arena::TypedArena::new(),\n         }\n     }\n \n@@ -1242,11 +1211,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                   def: Option<Def>,\n                   external: bool,\n                   is_public: bool) -> Module<'a> {\n-        self.arenas.modules.alloc(ModuleS::new(parent_link, def, external, is_public))\n-    }\n-\n-    fn new_name_binding(&self, name_binding: NameBinding<'a>) -> &'a NameBinding<'a> {\n-        self.arenas.name_bindings.alloc(name_binding)\n+        self.arenas.alloc_module(ModuleS::new(parent_link, def, external, is_public, self.arenas))\n     }\n \n     fn new_extern_crate_module(&self,\n@@ -1255,7 +1220,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                is_public: bool,\n                                local_node_id: NodeId)\n                                -> Module<'a> {\n-        let mut module = ModuleS::new(parent_link, Some(def), false, is_public);\n+        let mut module = ModuleS::new(parent_link, Some(def), false, is_public, self.arenas);\n         module.extern_crate_id = Some(local_node_id);\n         self.arenas.modules.alloc(module)\n     }\n@@ -1626,18 +1591,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         })\n     }\n \n-    fn report_unresolved_imports(&mut self, module_: Module<'a>) {\n-        for import in module_.unresolved_imports.borrow().iter() {\n-            resolve_error(self, import.span, ResolutionError::UnresolvedImport(None));\n-            break;\n-        }\n-\n-        // Descend into children and anonymous children.\n-        for (_, module_) in module_.module_children.borrow().iter() {\n-            self.report_unresolved_imports(module_);\n-        }\n-    }\n-\n     // AST resolution\n     //\n     // We maintain a list of value ribs and type ribs."}, {"sha": "f1f47381e4c810e755b5a9f8f609fa1b009ada15", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 328, "deletions": 183, "changes": 511, "blob_url": "https://github.com/rust-lang/rust/blob/3029e0918de00162932132a7972e566f3a3372f5/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3029e0918de00162932132a7972e566f3a3372f5/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=3029e0918de00162932132a7972e566f3a3372f5", "patch": "@@ -32,14 +32,31 @@ use syntax::codemap::Span;\n use syntax::util::lev_distance::find_best_match_for_name;\n \n use std::mem::replace;\n+use std::cell::Cell;\n \n /// Contains data for specific types of import directives.\n-#[derive(Copy, Clone,Debug)]\n+#[derive(Clone, Debug)]\n pub enum ImportDirectiveSubclass {\n-    SingleImport(Name /* target */, Name /* source */),\n+    SingleImport {\n+        target: Name,\n+        source: Name,\n+        type_determined: Cell<bool>,\n+        value_determined: Cell<bool>,\n+    },\n     GlobImport,\n }\n \n+impl ImportDirectiveSubclass {\n+    pub fn single(target: Name, source: Name) -> Self {\n+        SingleImport {\n+            target: target,\n+            source: source,\n+            type_determined: Cell::new(false),\n+            value_determined: Cell::new(false),\n+        }\n+    }\n+}\n+\n /// Whether an import can be shadowed by another import.\n #[derive(Debug,PartialEq,Clone,Copy)]\n pub enum Shadowable {\n@@ -108,54 +125,170 @@ impl ImportDirective {\n /// Records information about the resolution of a name in a module.\n pub struct NameResolution<'a> {\n     /// The number of unresolved single imports that could define the name.\n-    pub outstanding_references: usize,\n+    outstanding_references: usize,\n     /// The least shadowable known binding for this name, or None if there are no known bindings.\n     pub binding: Option<&'a NameBinding<'a>>,\n+    duplicate_globs: Vec<&'a NameBinding<'a>>,\n }\n \n impl<'a> NameResolution<'a> {\n-    pub fn result(&self, outstanding_globs: usize) -> ResolveResult<&'a NameBinding<'a>> {\n-        // If no unresolved imports (single or glob) can define the name, self.binding is final.\n-        if self.outstanding_references == 0 && outstanding_globs == 0 {\n-            return self.binding.map(Success).unwrap_or(Failed(None));\n-        }\n-\n-        if let Some(binding) = self.binding {\n-            // Single imports will never be shadowable by other single or glob imports.\n-            if !binding.defined_with(DefModifiers::GLOB_IMPORTED) { return Success(binding); }\n-            // Non-PRELUDE glob imports will never be shadowable by other glob imports.\n-            if self.outstanding_references == 0 && !binding.defined_with(DefModifiers::PRELUDE) {\n-                return Success(binding);\n+    fn try_define(&mut self, binding: &'a NameBinding<'a>) -> Result<(), &'a NameBinding<'a>> {\n+        match self.binding {\n+            Some(old_binding) if !old_binding.defined_with(DefModifiers::PRELUDE) => {\n+                if binding.defined_with(DefModifiers::GLOB_IMPORTED) {\n+                    self.duplicate_globs.push(binding);\n+                } else if old_binding.defined_with(DefModifiers::GLOB_IMPORTED) {\n+                    self.duplicate_globs.push(old_binding);\n+                    self.binding = Some(binding);\n+                } else {\n+                    return Err(old_binding);\n+                }\n             }\n+            _ => self.binding = Some(binding),\n         }\n \n-        Indeterminate\n+        Ok(())\n     }\n \n-    // Define the name or return the existing binding if there is a collision.\n-    pub fn try_define(&mut self, binding: &'a NameBinding<'a>) -> Result<(), &'a NameBinding<'a>> {\n-        let is_prelude = |binding: &NameBinding| binding.defined_with(DefModifiers::PRELUDE);\n-        let old_binding = match self.binding {\n-            Some(_) if is_prelude(binding) => return Ok(()),\n-            Some(old_binding) if !is_prelude(old_binding) => old_binding,\n-            _ => { self.binding = Some(binding); return Ok(()); }\n+    // Returns the resolution of the name assuming no more globs will define it.\n+    fn result(&self) -> ResolveResult<&'a NameBinding<'a>> {\n+        match self.binding {\n+            Some(binding) if !binding.defined_with(DefModifiers::GLOB_IMPORTED) => Success(binding),\n+            _ if self.outstanding_references > 0 => Indeterminate,\n+            Some(binding) => Success(binding),\n+            None => Failed(None),\n+        }\n+    }\n+\n+    // Returns Some(the resolution of the name), or None if the resolution depends\n+    // on whether more globs can define the name.\n+    fn try_result(&self) -> Option<ResolveResult<&'a NameBinding<'a>>> {\n+        match self.result() {\n+            Success(binding) if binding.defined_with(DefModifiers::PRELUDE) => None,\n+            Failed(_) => None,\n+            result @ _ => Some(result),\n+        }\n+    }\n+\n+    fn report_conflicts<F: FnMut(&NameBinding, &NameBinding)>(&self, mut report: F) {\n+        let binding = match self.binding {\n+            Some(binding) => binding,\n+            None => return,\n         };\n \n-        // FIXME #31337: We currently allow items to shadow glob-imported re-exports.\n-        if !old_binding.is_import() && binding.defined_with(DefModifiers::GLOB_IMPORTED) {\n-            if let NameBindingKind::Import { binding, .. } = binding.kind {\n-                if binding.is_import() { return Ok(()); }\n+        for duplicate_glob in self.duplicate_globs.iter() {\n+            if duplicate_glob.defined_with(DefModifiers::PRELUDE) { continue }\n+\n+            // FIXME #31337: We currently allow items to shadow glob-imported re-exports.\n+            if !binding.is_import() {\n+                if let NameBindingKind::Import { binding, .. } = duplicate_glob.kind {\n+                    if binding.is_import() { continue }\n+                }\n+            }\n+\n+            report(duplicate_glob, binding);\n+        }\n+    }\n+}\n+\n+impl<'a> ::ModuleS<'a> {\n+    pub fn resolve_name(&self, name: Name, ns: Namespace, allow_private_imports: bool)\n+                        -> ResolveResult<&'a NameBinding<'a>> {\n+        let resolutions = match self.resolutions.borrow_state() {\n+            ::std::cell::BorrowState::Unused => self.resolutions.borrow(),\n+            _ => return Failed(None), // This happens when there is a cycle of glob imports\n+        };\n+\n+        let resolution = resolutions.get(&(name, ns)).cloned().unwrap_or_default();\n+        if let Some(result) = resolution.try_result() {\n+            // If the resolution doesn't depend on glob definability, check privacy and return.\n+            return result.and_then(|binding| {\n+                let allowed = allow_private_imports || !binding.is_import() || binding.is_public();\n+                if allowed { Success(binding) } else { Failed(None) }\n+            });\n+        }\n+\n+        let (ref mut public_globs, ref mut private_globs) = *self.resolved_globs.borrow_mut();\n+\n+        // Check if the public globs are determined\n+        if public_globs.len() < self.public_glob_count.get() {\n+            return Indeterminate;\n+        }\n+        for module in public_globs.iter() {\n+            if let Indeterminate = module.resolve_name(name, ns, false) {\n+                return Indeterminate;\n+            }\n+        }\n+\n+        if !allow_private_imports {\n+            return Failed(None);\n+        }\n+\n+        // Check if the private globs are determined\n+        if private_globs.len() < self.private_glob_count.get() {\n+            return Indeterminate;\n+        }\n+        for module in private_globs.iter() {\n+            if let Indeterminate = module.resolve_name(name, ns, false) {\n+                return Indeterminate;\n             }\n         }\n \n-        Err(old_binding)\n+        resolution.result()\n+    }\n+\n+    // Define the name or return the existing binding if there is a collision.\n+    pub fn try_define_child(&self, name: Name, ns: Namespace, binding: NameBinding<'a>)\n+                            -> Result<(), &'a NameBinding<'a>> {\n+        if self.resolutions.borrow_state() != ::std::cell::BorrowState::Unused { return Ok(()); }\n+        self.update_resolution(name, ns, |resolution| {\n+            resolution.try_define(self.arenas.alloc_name_binding(binding))\n+        })\n+    }\n+\n+    pub fn increment_outstanding_references_for(&self, name: Name, ns: Namespace) {\n+        let mut resolutions = self.resolutions.borrow_mut();\n+        resolutions.entry((name, ns)).or_insert_with(Default::default).outstanding_references += 1;\n+    }\n+\n+    fn decrement_outstanding_references_for(&self, name: Name, ns: Namespace) {\n+        self.update_resolution(name, ns, |resolution| match resolution.outstanding_references {\n+            0 => panic!(\"No more outstanding references!\"),\n+            ref mut outstanding_references => *outstanding_references -= 1,\n+        })\n+    }\n+\n+    // Use `update` to mutate the resolution for the name.\n+    // If the resolution becomes a success, define it in the module's glob importers.\n+    fn update_resolution<T, F>(&self, name: Name, ns: Namespace, update: F) -> T\n+        where F: FnOnce(&mut NameResolution<'a>) -> T\n+    {\n+        let mut resolutions = self.resolutions.borrow_mut();\n+        let resolution = resolutions.entry((name, ns)).or_insert_with(Default::default);\n+        let was_success = resolution.try_result().and_then(ResolveResult::success).is_some();\n+\n+        let t = update(resolution);\n+        if !was_success {\n+            if let Some(Success(binding)) = resolution.try_result() {\n+                self.define_in_glob_importers(name, ns, binding);\n+            }\n+        }\n+        t\n+    }\n+\n+    fn define_in_glob_importers(&self, name: Name, ns: Namespace, binding: &'a NameBinding<'a>) {\n+        if !binding.defined_with(DefModifiers::PUBLIC | DefModifiers::IMPORTABLE) { return }\n+        if binding.is_extern_crate() { return }\n+        for &(importer, directive) in self.glob_importers.borrow_mut().iter() {\n+            let _ = importer.try_define_child(name, ns, directive.import(binding, None));\n+        }\n     }\n }\n \n struct ImportResolvingError<'a> {\n     /// Module where the error happened\n     source_module: Module<'a>,\n-    import_directive: ImportDirective,\n+    import_directive: &'a ImportDirective,\n     span: Span,\n     help: String,\n }\n@@ -189,21 +322,19 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n \n             if self.resolver.unresolved_imports == 0 {\n                 debug!(\"(resolving imports) success\");\n+                self.finalize_resolutions(self.resolver.graph_root, false);\n                 break;\n             }\n \n             if self.resolver.unresolved_imports == prev_unresolved_imports {\n                 // resolving failed\n-                if errors.len() > 0 {\n-                    for e in errors {\n-                        self.import_resolving_error(e)\n-                    }\n-                } else {\n-                    // Report unresolved imports only if no hard error was already reported\n-                    // to avoid generating multiple errors on the same import.\n-                    // Imports that are still indeterminate at this point are actually blocked\n-                    // by errored imports, so there is no point reporting them.\n-                    self.resolver.report_unresolved_imports(self.resolver.graph_root);\n+                // Report unresolved imports only if no hard error was already reported\n+                // to avoid generating multiple errors on the same import.\n+                // Imports that are still indeterminate at this point are actually blocked\n+                // by errored imports, so there is no point reporting them.\n+                self.finalize_resolutions(self.resolver.graph_root, errors.len() == 0);\n+                for e in errors {\n+                    self.import_resolving_error(e)\n                 }\n                 break;\n             }\n@@ -218,21 +349,20 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n     fn import_resolving_error(&self, e: ImportResolvingError<'b>) {\n         // If it's a single failed import then create a \"fake\" import\n         // resolution for it so that later resolve stages won't complain.\n-        if let SingleImport(target, _) = e.import_directive.subclass {\n-            let dummy_binding = self.resolver.new_name_binding(NameBinding {\n+        if let SingleImport { target, .. } = e.import_directive.subclass {\n+            let dummy_binding = self.resolver.arenas.alloc_name_binding(NameBinding {\n                 modifiers: DefModifiers::PRELUDE,\n                 kind: NameBindingKind::Def(Def::Err),\n                 span: None,\n             });\n-            let dummy_binding =\n-                self.resolver.new_name_binding(e.import_directive.import(dummy_binding, None));\n+            let dummy_binding = e.import_directive.import(dummy_binding, None);\n \n-            let _ = e.source_module.try_define_child(target, ValueNS, dummy_binding);\n+            let _ = e.source_module.try_define_child(target, ValueNS, dummy_binding.clone());\n             let _ = e.source_module.try_define_child(target, TypeNS, dummy_binding);\n         }\n \n         let path = import_path_to_string(&e.import_directive.module_path,\n-                                         e.import_directive.subclass);\n+                                         &e.import_directive.subclass);\n \n         resolve_error(self.resolver,\n                       e.span,\n@@ -290,7 +420,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n     /// If successful, the resolved bindings are written into the module.\n     fn resolve_import_for_module(&mut self,\n                                  module_: Module<'b>,\n-                                 import_directive: &ImportDirective)\n+                                 import_directive: &'b ImportDirective)\n                                  -> ResolveResult<()> {\n         debug!(\"(resolving import for module) resolving import `{}::...` in `{}`\",\n                names_to_string(&import_directive.module_path),\n@@ -304,64 +434,67 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n             .and_then(|containing_module| {\n                 // We found the module that the target is contained\n                 // within. Attempt to resolve the import within it.\n-                if let SingleImport(target, source) = import_directive.subclass {\n-                    self.resolve_single_import(module_,\n-                                               containing_module,\n-                                               target,\n-                                               source,\n-                                               import_directive)\n-                } else {\n-                    self.resolve_glob_import(module_, containing_module, import_directive)\n-                }\n+                self.resolve_import(module_, containing_module, import_directive)\n             })\n             .and_then(|()| {\n                 // Decrement the count of unresolved imports.\n                 assert!(self.resolver.unresolved_imports >= 1);\n                 self.resolver.unresolved_imports -= 1;\n-\n-                if let GlobImport = import_directive.subclass {\n-                    module_.dec_glob_count();\n-                    if import_directive.is_public {\n-                        module_.dec_pub_glob_count();\n-                    }\n-                }\n-                if import_directive.is_public {\n-                    module_.dec_pub_count();\n-                }\n                 Success(())\n             })\n     }\n \n-    fn resolve_single_import(&mut self,\n-                             module_: Module<'b>,\n-                             target_module: Module<'b>,\n-                             target: Name,\n-                             source: Name,\n-                             directive: &ImportDirective)\n-                             -> ResolveResult<()> {\n-        debug!(\"(resolving single import) resolving `{}` = `{}::{}` from `{}` id {}\",\n-               target,\n-               module_to_string(&target_module),\n-               source,\n-               module_to_string(module_),\n-               directive.id);\n-\n-        // If this is a circular import, we temporarily count it as determined so that\n-        // it fails (as opposed to being indeterminate) when nothing else can define it.\n-        if target_module.def_id() == module_.def_id() && source == target {\n-            module_.decrement_outstanding_references_for(target, ValueNS);\n-            module_.decrement_outstanding_references_for(target, TypeNS);\n-        }\n+    fn resolve_import(&mut self,\n+                      module_: Module<'b>,\n+                      target_module: Module<'b>,\n+                      directive: &'b ImportDirective)\n+                      -> ResolveResult<()> {\n+        let (source, target, value_determined, type_determined) = match directive.subclass {\n+            SingleImport { source, target, ref value_determined, ref type_determined } =>\n+                (source, target, value_determined, type_determined),\n+            GlobImport => return self.resolve_glob_import(module_, target_module, directive),\n+        };\n \n         // We need to resolve both namespaces for this to succeed.\n-        let value_result =\n-            self.resolver.resolve_name_in_module(target_module, source, ValueNS, false, true);\n-        let type_result =\n-            self.resolver.resolve_name_in_module(target_module, source, TypeNS, false, true);\n+        let (value_result, type_result) = {\n+            let mut resolve_in_ns = |ns, determined: bool| {\n+                // Temporarily count the directive as determined so that the resolution fails\n+                // (as opposed to being indeterminate) when it can only be defined by the directive.\n+                if !determined { module_.decrement_outstanding_references_for(target, ns) }\n+                let result =\n+                    self.resolver.resolve_name_in_module(target_module, source, ns, false, true);\n+                if !determined { module_.increment_outstanding_references_for(target, ns) }\n+                result\n+            };\n+            (resolve_in_ns(ValueNS, value_determined.get()),\n+             resolve_in_ns(TypeNS, type_determined.get()))\n+        };\n+\n+        for &(ns, result, determined) in &[(ValueNS, &value_result, value_determined),\n+                                           (TypeNS, &type_result, type_determined)] {\n+            if determined.get() { continue }\n+            if let Indeterminate = *result { continue }\n+\n+            determined.set(true);\n+            if let Success(binding) = *result {\n+                if !binding.defined_with(DefModifiers::IMPORTABLE) {\n+                    let msg = format!(\"`{}` is not directly importable\", target);\n+                    span_err!(self.resolver.session, directive.span, E0253, \"{}\", &msg);\n+                }\n \n-        if target_module.def_id() == module_.def_id() && source == target {\n-            module_.increment_outstanding_references_for(target, ValueNS);\n-            module_.increment_outstanding_references_for(target, TypeNS);\n+                let privacy_error = if !self.resolver.is_visible(binding, target_module) {\n+                    Some(Box::new(PrivacyError(directive.span, source, binding)))\n+                } else {\n+                    None\n+                };\n+\n+                let imported_binding = directive.import(binding, privacy_error);\n+                let conflict = module_.try_define_child(target, ns, imported_binding);\n+                if let Err(old_binding) = conflict {\n+                    self.report_conflict(target, ns, &directive.import(binding, None), old_binding);\n+                }\n+            }\n+            module_.decrement_outstanding_references_for(target, ns);\n         }\n \n         match (&value_result, &type_result) {\n@@ -393,69 +526,46 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                     .emit();\n             }\n \n-            (_, &Success(name_binding)) if !name_binding.is_import() && directive.is_public => {\n-                if !name_binding.is_public() {\n-                    if name_binding.is_extern_crate() {\n-                        let msg = format!(\"extern crate `{}` is private, and cannot be reexported \\\n-                                           (error E0364), consider declaring with `pub`\",\n-                                           source);\n-                        self.resolver.session.add_lint(lint::builtin::PRIVATE_IN_PUBLIC,\n-                                                       directive.id,\n-                                                       directive.span,\n-                                                       msg);\n-                    } else {\n-                        let msg = format!(\"`{}` is private, and cannot be reexported\", source);\n-                        let note_msg =\n-                            format!(\"consider declaring type or module `{}` with `pub`\", source);\n-                        struct_span_err!(self.resolver.session, directive.span, E0365, \"{}\", &msg)\n-                            .span_note(directive.span, &note_msg)\n-                            .emit();\n-                    }\n-                } else if name_binding.defined_with(DefModifiers::PRIVATE_VARIANT) {\n-                    let msg = format!(\"variant `{}` is private, and cannot be reexported \\\n-                                       (error E0364), consider declaring its enum as `pub`\",\n+            (_, &Success(name_binding)) if !name_binding.is_import() &&\n+                                           directive.is_public &&\n+                                           !name_binding.is_public() => {\n+                if name_binding.is_extern_crate() {\n+                    let msg = format!(\"extern crate `{}` is private, and cannot be reexported \\\n+                                       (error E0364), consider declaring with `pub`\",\n                                        source);\n                     self.resolver.session.add_lint(lint::builtin::PRIVATE_IN_PUBLIC,\n                                                    directive.id,\n                                                    directive.span,\n                                                    msg);\n+                } else {\n+                    let msg = format!(\"`{}` is private, and cannot be reexported\", source);\n+                    let note_msg =\n+                        format!(\"consider declaring type or module `{}` with `pub`\", source);\n+                    struct_span_err!(self.resolver.session, directive.span, E0365, \"{}\", &msg)\n+                        .span_note(directive.span, &note_msg)\n+                        .emit();\n                 }\n             }\n \n             _ => {}\n         }\n \n+        // Report a privacy error here if all successful namespaces are privacy errors.\n         let mut privacy_error = None;\n-        let mut report_privacy_error = true;\n-        for &(ns, result) in &[(ValueNS, &value_result), (TypeNS, &type_result)] {\n-            if let Success(binding) = *result {\n-                if !binding.defined_with(DefModifiers::IMPORTABLE) {\n-                    let msg = format!(\"`{}` is not directly importable\", target);\n-                    span_err!(self.resolver.session, directive.span, E0253, \"{}\", &msg);\n-                }\n-\n-                privacy_error = if !self.resolver.is_visible(binding, target_module) {\n-                    Some(Box::new(PrivacyError(directive.span, source, binding)))\n-                } else {\n-                    report_privacy_error = false;\n-                    None\n-                };\n-\n-                self.define(module_, target, ns, directive.import(binding, privacy_error.clone()));\n-            }\n-        }\n-\n-        if report_privacy_error { // then all successful namespaces are privacy errors\n-            // We report here so there is an error even if the imported name is not used\n-            self.resolver.privacy_errors.push(*privacy_error.unwrap());\n+        for &ns in &[ValueNS, TypeNS] {\n+            privacy_error = match module_.resolve_name(target, ns, true) {\n+                Success(&NameBinding {\n+                    kind: NameBindingKind::Import { ref privacy_error, .. }, ..\n+                }) => privacy_error.as_ref().map(|error| (**error).clone()),\n+                _ => continue,\n+            };\n+            if privacy_error.is_none() { break }\n         }\n+        privacy_error.map(|error| self.resolver.privacy_errors.push(error));\n \n         // Record what this import resolves to for later uses in documentation,\n         // this may resolve to either a value or a type, but for documentation\n         // purposes it's good enough to just favor one over the other.\n-        module_.decrement_outstanding_references_for(target, ValueNS);\n-        module_.decrement_outstanding_references_for(target, TypeNS);\n-\n         let def = match type_result.success().and_then(NameBinding::def) {\n             Some(def) => def,\n             None => value_result.success().and_then(NameBinding::def).unwrap(),\n@@ -474,36 +584,29 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n     fn resolve_glob_import(&mut self,\n                            module_: Module<'b>,\n                            target_module: Module<'b>,\n-                           directive: &ImportDirective)\n+                           directive: &'b ImportDirective)\n                            -> ResolveResult<()> {\n-        // We must bail out if the node has unresolved imports of any kind (including globs).\n-        if target_module.pub_count.get() > 0 {\n-            debug!(\"(resolving glob import) target module has unresolved pub imports; bailing out\");\n-            return Indeterminate;\n-        }\n-\n         if module_.def_id() == target_module.def_id() {\n             // This means we are trying to glob import a module into itself, and it is a no-go\n             let msg = \"Cannot glob-import a module into itself.\".into();\n             return Failed(Some((directive.span, msg)));\n         }\n-\n-        // Add all children from the containing module.\n         build_reduced_graph::populate_module_if_necessary(self.resolver, target_module);\n-        target_module.for_each_child(|name, ns, binding| {\n-            if !binding.defined_with(DefModifiers::IMPORTABLE | DefModifiers::PUBLIC) { return }\n-            self.define(module_, name, ns, directive.import(binding, None));\n-\n-            if ns == TypeNS && directive.is_public &&\n-               binding.defined_with(DefModifiers::PRIVATE_VARIANT) {\n-                let msg = format!(\"variant `{}` is private, and cannot be reexported (error \\\n-                                   E0364), consider declaring its enum as `pub`\", name);\n-                self.resolver.session.add_lint(lint::builtin::PRIVATE_IN_PUBLIC,\n-                                               directive.id,\n-                                               directive.span,\n-                                               msg);\n+\n+        // Add to target_module's glob_importers and module_'s resolved_globs\n+        target_module.glob_importers.borrow_mut().push((module_, directive));\n+        match *module_.resolved_globs.borrow_mut() {\n+            (ref mut public_globs, _) if directive.is_public => public_globs.push(target_module),\n+            (_, ref mut private_globs) => private_globs.push(target_module),\n+        }\n+\n+        for (&(name, ns), resolution) in target_module.resolutions.borrow().iter() {\n+            if let Some(Success(binding)) = resolution.try_result() {\n+                if binding.defined_with(DefModifiers::IMPORTABLE | DefModifiers::PUBLIC) {\n+                    let _ = module_.try_define_child(name, ns, directive.import(binding, None));\n+                }\n             }\n-        });\n+        }\n \n         // Record the destination of this import\n         if let Some(did) = target_module.def_id() {\n@@ -518,28 +621,11 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n         return Success(());\n     }\n \n-    fn define(&mut self,\n-              parent: Module<'b>,\n-              name: Name,\n-              ns: Namespace,\n-              binding: NameBinding<'b>) {\n-        let binding = self.resolver.new_name_binding(binding);\n-        if let Err(old_binding) = parent.try_define_child(name, ns, binding) {\n-            self.report_conflict(name, ns, binding, old_binding);\n-        } else if binding.is_public() { // Add to the export map\n-            if let (Some(parent_def_id), Some(def)) = (parent.def_id(), binding.def()) {\n-                let parent_node_id = self.resolver.ast_map.as_local_node_id(parent_def_id).unwrap();\n-                let export = Export { name: name, def_id: def.def_id() };\n-                self.resolver.export_map.entry(parent_node_id).or_insert(Vec::new()).push(export);\n-            }\n-        }\n-    }\n-\n     fn report_conflict(&mut self,\n                        name: Name,\n                        ns: Namespace,\n-                       binding: &'b NameBinding<'b>,\n-                       old_binding: &'b NameBinding<'b>) {\n+                       binding: &NameBinding,\n+                       old_binding: &NameBinding) {\n         // Error on the second of two conflicting imports\n         if old_binding.is_import() && binding.is_import() &&\n            old_binding.span.unwrap().lo > binding.span.unwrap().lo {\n@@ -595,9 +681,68 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n             err.emit();\n         }\n     }\n+\n+    // Miscellaneous post-processing, including recording reexports, recording shadowed traits,\n+    // reporting conflicts, reporting the PRIVATE_IN_PUBLIC lint, and reporting unresolved imports.\n+    fn finalize_resolutions(&mut self, module: Module<'b>, report_unresolved_imports: bool) {\n+        // Since import resolution is finished, globs will not define any more names.\n+        module.public_glob_count.set(0); module.private_glob_count.set(0);\n+        *module.resolved_globs.borrow_mut() = (Vec::new(), Vec::new());\n+\n+        let mut reexports = Vec::new();\n+        for (&(name, ns), resolution) in module.resolutions.borrow().iter() {\n+            resolution.report_conflicts(|b1, b2| self.report_conflict(name, ns, b1, b2));\n+            let binding = match resolution.binding {\n+                Some(binding) => binding,\n+                None => continue,\n+            };\n+\n+            if binding.is_public() && (binding.is_import() || binding.is_extern_crate()) {\n+                if let Some(def) = binding.def() {\n+                    reexports.push(Export { name: name, def_id: def.def_id() });\n+                }\n+            }\n+\n+            if let NameBindingKind::Import { binding: orig_binding, id, .. } = binding.kind {\n+                if ns == TypeNS && binding.is_public() &&\n+                   orig_binding.defined_with(DefModifiers::PRIVATE_VARIANT) {\n+                    let msg = format!(\"variant `{}` is private, and cannot be reexported \\\n+                                       (error E0364), consider declaring its enum as `pub`\",\n+                                      name);\n+                    let lint = lint::builtin::PRIVATE_IN_PUBLIC;\n+                    self.resolver.session.add_lint(lint, id, binding.span.unwrap(), msg);\n+                }\n+            }\n+\n+            // FIXME #31379: We can use methods from imported traits shadowed by non-import items\n+            if !binding.is_import() {\n+                for glob_binding in resolution.duplicate_globs.iter() {\n+                    module.shadowed_traits.borrow_mut().push(glob_binding);\n+                }\n+            }\n+        }\n+\n+        if reexports.len() > 0 {\n+            if let Some(def_id) = module.def_id() {\n+                let node_id = self.resolver.ast_map.as_local_node_id(def_id).unwrap();\n+                self.resolver.export_map.insert(node_id, reexports);\n+            }\n+        }\n+\n+        if report_unresolved_imports {\n+            for import in module.unresolved_imports.borrow().iter() {\n+                resolve_error(self.resolver, import.span, ResolutionError::UnresolvedImport(None));\n+                break;\n+            }\n+        }\n+\n+        for (_, child) in module.module_children.borrow().iter() {\n+            self.finalize_resolutions(child, report_unresolved_imports);\n+        }\n+    }\n }\n \n-fn import_path_to_string(names: &[Name], subclass: ImportDirectiveSubclass) -> String {\n+fn import_path_to_string(names: &[Name], subclass: &ImportDirectiveSubclass) -> String {\n     if names.is_empty() {\n         import_directive_subclass_to_string(subclass)\n     } else {\n@@ -608,9 +753,9 @@ fn import_path_to_string(names: &[Name], subclass: ImportDirectiveSubclass) -> S\n     }\n }\n \n-fn import_directive_subclass_to_string(subclass: ImportDirectiveSubclass) -> String {\n-    match subclass {\n-        SingleImport(_, source) => source.to_string(),\n+fn import_directive_subclass_to_string(subclass: &ImportDirectiveSubclass) -> String {\n+    match *subclass {\n+        SingleImport { source, .. } => source.to_string(),\n         GlobImport => \"*\".to_string(),\n     }\n }"}]}