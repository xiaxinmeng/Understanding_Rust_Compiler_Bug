{"sha": "89f5dcfb4316891fafb34d211b7bebc4cf8638d0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg5ZjVkY2ZiNDMxNjg5MWZhZmIzNGQyMTFiN2JlYmM0Y2Y4NjM4ZDA=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-02-13T20:27:58Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-02-13T20:27:58Z"}, "message": "Rollup merge of #68728 - Centril:towards-fn-merge, r=petrochenkov\n\nparse: merge `fn` syntax + cleanup item parsing\n\nHere we continue the work in https://github.com/rust-lang/rust/pull/67131 in particular to merge the grammars of `fn` items in various positions.\n\nA list of *language level* changes (as sanctioned by the language team in https://github.com/rust-lang/rust/issues/65041#issuecomment-538105286 and https://github.com/rust-lang/rust/pull/67131):\n\n- `self` parameters are now *syntactically* allowed as the first parameter irrespective of item context (and in function pointers). Instead, semantic validation (`ast_validation`) is used.\n\n- Syntactically, `fn` items in `extern { ... }` blocks can now have bodies (`fn foo() { ... }` as opposed to `fn foo();`). As above, we use semantic restrictions instead.\n\n- Syntactically, `fn` items in free contexts (directly in a file or a module) can now be without bodies (`fn foo();` as opposed to `fn foo() { ... }`. As above, we use semantic restrictions instead, including for non-ident parameter patterns.\n\n- `const extern fn` feature gating is now done post-expansion such that we do not have conditional compatibilities of function qualifiers *in parsing*.\n\n- The `FnFrontMatter` grammar becomes:\n   ```rust\n   Extern = \"extern\" StringLit ;\n   FnQual = \"const\"? \"async\"? \"unsafe\"? Extern? ;\n   FnFrontMatter = FnQual \"fn\" ;\n   ```\n\n   That is, all item contexts now *syntactically* allow `const async unsafe extern \"C\" fn` and use semantic restrictions to rule out combinations previously prevented syntactically. The semantic restrictions include in particular:\n\n   - `fn`s in `extern { ... }` can have no qualifiers.\n   - `const` and `async` cannot be combined.\n\n- To fuse the list-of-items parsing in the 4 contexts that items are allowed, we now must permit inner attributes (`#![attr]`) inside `trait Foo { ... }` definitions. That is, we now allow e.g. `trait Foo { #![attr] }`. This was probably an oversight due to not using a uniform parsing mechanism, which we now do have (`fn parse_item_list`). The semantic support (including e.g. for linting) falls out directly from the attributes infrastructure. To ensure this, we include a test for lints.\n\nPut together, these grammar changes allow us to substantially reduce the complexity of item parsing and its grammar. There are however some other non-language improvements that allow the compression to take place.\n\nA list of *compiler-internal* changes (in particular noting the parser-external data-structure changes):\n\n- We use `enum AllowPlus/RecoverQPath/AllowCVariadic { Yes, No }` in `parser/ty.rs` instead of passing around 3 different `bool`s. I felt this was necessary as it was becoming mentally taxing to track which-is-which.\n\n- `fn visit_trait_item` and `fn visit_impl_item` are merged into `fn visit_assoc_item` which now is passed an `AssocCtxt` to check which one it is.\n\n- We change `FnKind` to:\n\n  ```rust\n  pub enum FnKind<'a> {\n      Fn(FnCtxt, Ident, &'a FnSig, &'a Visibility, Option<&'a Block>),\n      Closure(&'a FnDecl, &'a Expr),\n  }\n  ```\n\n  with:\n\n  ```rust\n  pub enum FnCtxt {\n      Free,\n      Foreign,\n      Assoc(AssocCtxt),\n  }\n  ```\n\n  This is then taken advantage of in tweaking the various semantic restrictions as well as in pretty printing.\n\n- In `ItemKind::Fn`, we change `P<Block>` to `Option<P<Block>>`.\n\n- In `ForeignItemKind::Fn`, we change `P<FnDecl>` to `FnSig` and `P<Block>` to `Option<P<Block>>`.\n\n- We change `ast::{Unsafety, Spanned<Constness>}>` into `enum ast::{Unsafe, Const} { Yes(Span), No }` respectively. This change in formulation allow us to exclude `Span` in the case of `No`, which facilitates parsing. Moreover, we also add a `Span` to `IsAsync` which is renamed to `Async`. The new `Span`s in `Unsafety` and `Async` are then taken advantage of for better diagnostics. A reason this change was made is to have a more uniform and clear naming scheme.\n\n  The HIR keeps the structures in AST (with those definitions moved into HIR) for now to avoid regressing perf.\n\n- Various cleanups, bug fixes, and diagnostics improvements are made along the way. It is probably best to understand those via the diffs.\n\nI would recommend reviewing this commit-by-commit with whitespace changes hidden.\n\nr? @estebank @petrochenkov", "tree": {"sha": "b9bcfe583e62ed45f31defb8324ccfbb62ae442a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b9bcfe583e62ed45f31defb8324ccfbb62ae442a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/89f5dcfb4316891fafb34d211b7bebc4cf8638d0", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeRbFPCRBK7hj4Ov3rIwAAdHIIAJHBQ9n8iIZrKCb1v4xxn7q9\nOb+9fhP6f3G4mysNd/hSMlrqRnB9l0QPtk1U02QGeZGtnbRVJ/iwKrKyQjBSR4JM\n2lqyzF/aQf0cy6cFGjFSBqhOyM+Bvs15gdOUmFttiwWbGnvUEUplHEEexyxccD5J\nYjDJmHWICWI7UU2SLdGscq2J2WuYVrJ+n9Vs0mkvWut18VNnc5niF4QImDjLDZhl\n1DG7J3w84G0XlFYW3vlCxQZCb/bawFIBpArVH0LvZUmKEugq1GL3kEGMgkK+GR5c\nmrSNdUCRBzuYGhI+8OaM35pLywZtgV9MEQhvQkfvE0j6OmrYDio4b1wpqviweFw=\n=wXpB\n-----END PGP SIGNATURE-----\n", "payload": "tree b9bcfe583e62ed45f31defb8324ccfbb62ae442a\nparent d538b80ad77949e46989cd355cdec193b574f052\nparent ad72c3abb9a7f9746d6ccc381e69ba88fb15b5cd\nauthor Dylan DPC <dylan.dpc@gmail.com> 1581625678 +0100\ncommitter GitHub <noreply@github.com> 1581625678 +0100\n\nRollup merge of #68728 - Centril:towards-fn-merge, r=petrochenkov\n\nparse: merge `fn` syntax + cleanup item parsing\n\nHere we continue the work in https://github.com/rust-lang/rust/pull/67131 in particular to merge the grammars of `fn` items in various positions.\n\nA list of *language level* changes (as sanctioned by the language team in https://github.com/rust-lang/rust/issues/65041#issuecomment-538105286 and https://github.com/rust-lang/rust/pull/67131):\n\n- `self` parameters are now *syntactically* allowed as the first parameter irrespective of item context (and in function pointers). Instead, semantic validation (`ast_validation`) is used.\n\n- Syntactically, `fn` items in `extern { ... }` blocks can now have bodies (`fn foo() { ... }` as opposed to `fn foo();`). As above, we use semantic restrictions instead.\n\n- Syntactically, `fn` items in free contexts (directly in a file or a module) can now be without bodies (`fn foo();` as opposed to `fn foo() { ... }`. As above, we use semantic restrictions instead, including for non-ident parameter patterns.\n\n- `const extern fn` feature gating is now done post-expansion such that we do not have conditional compatibilities of function qualifiers *in parsing*.\n\n- The `FnFrontMatter` grammar becomes:\n   ```rust\n   Extern = \"extern\" StringLit ;\n   FnQual = \"const\"? \"async\"? \"unsafe\"? Extern? ;\n   FnFrontMatter = FnQual \"fn\" ;\n   ```\n\n   That is, all item contexts now *syntactically* allow `const async unsafe extern \"C\" fn` and use semantic restrictions to rule out combinations previously prevented syntactically. The semantic restrictions include in particular:\n\n   - `fn`s in `extern { ... }` can have no qualifiers.\n   - `const` and `async` cannot be combined.\n\n- To fuse the list-of-items parsing in the 4 contexts that items are allowed, we now must permit inner attributes (`#![attr]`) inside `trait Foo { ... }` definitions. That is, we now allow e.g. `trait Foo { #![attr] }`. This was probably an oversight due to not using a uniform parsing mechanism, which we now do have (`fn parse_item_list`). The semantic support (including e.g. for linting) falls out directly from the attributes infrastructure. To ensure this, we include a test for lints.\n\nPut together, these grammar changes allow us to substantially reduce the complexity of item parsing and its grammar. There are however some other non-language improvements that allow the compression to take place.\n\nA list of *compiler-internal* changes (in particular noting the parser-external data-structure changes):\n\n- We use `enum AllowPlus/RecoverQPath/AllowCVariadic { Yes, No }` in `parser/ty.rs` instead of passing around 3 different `bool`s. I felt this was necessary as it was becoming mentally taxing to track which-is-which.\n\n- `fn visit_trait_item` and `fn visit_impl_item` are merged into `fn visit_assoc_item` which now is passed an `AssocCtxt` to check which one it is.\n\n- We change `FnKind` to:\n\n  ```rust\n  pub enum FnKind<'a> {\n      Fn(FnCtxt, Ident, &'a FnSig, &'a Visibility, Option<&'a Block>),\n      Closure(&'a FnDecl, &'a Expr),\n  }\n  ```\n\n  with:\n\n  ```rust\n  pub enum FnCtxt {\n      Free,\n      Foreign,\n      Assoc(AssocCtxt),\n  }\n  ```\n\n  This is then taken advantage of in tweaking the various semantic restrictions as well as in pretty printing.\n\n- In `ItemKind::Fn`, we change `P<Block>` to `Option<P<Block>>`.\n\n- In `ForeignItemKind::Fn`, we change `P<FnDecl>` to `FnSig` and `P<Block>` to `Option<P<Block>>`.\n\n- We change `ast::{Unsafety, Spanned<Constness>}>` into `enum ast::{Unsafe, Const} { Yes(Span), No }` respectively. This change in formulation allow us to exclude `Span` in the case of `No`, which facilitates parsing. Moreover, we also add a `Span` to `IsAsync` which is renamed to `Async`. The new `Span`s in `Unsafety` and `Async` are then taken advantage of for better diagnostics. A reason this change was made is to have a more uniform and clear naming scheme.\n\n  The HIR keeps the structures in AST (with those definitions moved into HIR) for now to avoid regressing perf.\n\n- Various cleanups, bug fixes, and diagnostics improvements are made along the way. It is probably best to understand those via the diffs.\n\nI would recommend reviewing this commit-by-commit with whitespace changes hidden.\n\nr? @estebank @petrochenkov\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/89f5dcfb4316891fafb34d211b7bebc4cf8638d0", "html_url": "https://github.com/rust-lang/rust/commit/89f5dcfb4316891fafb34d211b7bebc4cf8638d0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/89f5dcfb4316891fafb34d211b7bebc4cf8638d0/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d538b80ad77949e46989cd355cdec193b574f052", "url": "https://api.github.com/repos/rust-lang/rust/commits/d538b80ad77949e46989cd355cdec193b574f052", "html_url": "https://github.com/rust-lang/rust/commit/d538b80ad77949e46989cd355cdec193b574f052"}, {"sha": "ad72c3abb9a7f9746d6ccc381e69ba88fb15b5cd", "url": "https://api.github.com/repos/rust-lang/rust/commits/ad72c3abb9a7f9746d6ccc381e69ba88fb15b5cd", "html_url": "https://github.com/rust-lang/rust/commit/ad72c3abb9a7f9746d6ccc381e69ba88fb15b5cd"}], "stats": {"total": 1319, "additions": 596, "deletions": 723}, "files": [{"sha": "75938470b6fca7b248eae93d4106e7b9897f32af", "filename": "src/librustc_ast_pretty/pprust.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/89f5dcfb4316891fafb34d211b7bebc4cf8638d0/src%2Flibrustc_ast_pretty%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89f5dcfb4316891fafb34d211b7bebc4cf8638d0/src%2Flibrustc_ast_pretty%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_pretty%2Fpprust.rs?ref=89f5dcfb4316891fafb34d211b7bebc4cf8638d0", "patch": "@@ -1269,6 +1269,7 @@ impl<'a> State<'a> {\n                 self.print_where_clause(&generics.where_clause);\n                 self.s.word(\" \");\n                 self.bopen();\n+                self.print_inner_attributes(&item.attrs);\n                 for trait_item in trait_items {\n                     self.print_assoc_item(trait_item);\n                 }"}, {"sha": "0968e92c20314aab68c90efcf45e77a03b27b9a7", "filename": "src/librustc_expand/expand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89f5dcfb4316891fafb34d211b7bebc4cf8638d0/src%2Flibrustc_expand%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89f5dcfb4316891fafb34d211b7bebc4cf8638d0/src%2Flibrustc_expand%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fexpand.rs?ref=89f5dcfb4316891fafb34d211b7bebc4cf8638d0", "patch": "@@ -867,7 +867,7 @@ pub fn parse_ast_fragment<'a>(\n         AstFragmentKind::ForeignItems => {\n             let mut items = SmallVec::new();\n             while this.token != token::Eof {\n-                items.push(this.parse_foreign_item()?);\n+                items.push(this.parse_foreign_item(&mut false)?);\n             }\n             AstFragment::ForeignItems(items)\n         }"}, {"sha": "1c479295af3ed0acc1519c20da334f6ee2ba8c1a", "filename": "src/librustc_parse/config.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/89f5dcfb4316891fafb34d211b7bebc4cf8638d0/src%2Flibrustc_parse%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89f5dcfb4316891fafb34d211b7bebc4cf8638d0/src%2Flibrustc_parse%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fconfig.rs?ref=89f5dcfb4316891fafb34d211b7bebc4cf8638d0", "patch": "@@ -562,14 +562,9 @@ fn is_cfg(attr: &Attribute) -> bool {\n \n /// Process the potential `cfg` attributes on a module.\n /// Also determine if the module should be included in this configuration.\n-pub fn process_configure_mod(\n-    sess: &ParseSess,\n-    cfg_mods: bool,\n-    attrs: &[Attribute],\n-) -> (bool, Vec<Attribute>) {\n+pub fn process_configure_mod(sess: &ParseSess, cfg_mods: bool, attrs: &mut Vec<Attribute>) -> bool {\n     // Don't perform gated feature checking.\n     let mut strip_unconfigured = StripUnconfigured { sess, features: None };\n-    let mut attrs = attrs.to_owned();\n-    strip_unconfigured.process_cfg_attrs(&mut attrs);\n-    (!cfg_mods || strip_unconfigured.in_cfg(&attrs), attrs)\n+    strip_unconfigured.process_cfg_attrs(attrs);\n+    !cfg_mods || strip_unconfigured.in_cfg(&attrs)\n }"}, {"sha": "500aaaf43b92a3ddc669bb75c005f145bf9cc14e", "filename": "src/librustc_parse/parser/item.rs", "status": "modified", "additions": 424, "deletions": 554, "changes": 978, "blob_url": "https://github.com/rust-lang/rust/blob/89f5dcfb4316891fafb34d211b7bebc4cf8638d0/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89f5dcfb4316891fafb34d211b7bebc4cf8638d0/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fitem.rs?ref=89f5dcfb4316891fafb34d211b7bebc4cf8638d0", "patch": "@@ -8,10 +8,9 @@ use rustc_ast_pretty::pprust;\n use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder, PResult, StashKey};\n use rustc_span::source_map::{self, Span};\n use rustc_span::symbol::{kw, sym, Symbol};\n-use rustc_span::BytePos;\n-use syntax::ast::{self, AttrKind, AttrStyle, AttrVec, Attribute, Ident, DUMMY_NODE_ID};\n+use syntax::ast::{self, AttrStyle, AttrVec, Attribute, Ident, DUMMY_NODE_ID};\n use syntax::ast::{AssocItem, AssocItemKind, Item, ItemKind, UseTree, UseTreeKind};\n-use syntax::ast::{Async, Const, Defaultness, IsAuto, PathSegment, StrLit, Unsafe};\n+use syntax::ast::{Async, Const, Defaultness, IsAuto, PathSegment, Unsafe};\n use syntax::ast::{BindingMode, Block, FnDecl, FnSig, Mac, MacArgs, MacDelimiter, Param, SelfKind};\n use syntax::ast::{EnumDef, Generics, StructField, TraitRef, Ty, TyKind, Variant, VariantData};\n use syntax::ast::{FnHeader, ForeignItem, ForeignItemKind, Mutability, Visibility, VisibilityKind};\n@@ -22,7 +21,7 @@ use syntax::tokenstream::{DelimSpan, TokenStream, TokenTree};\n use log::debug;\n use std::mem;\n \n-pub(super) type ItemInfo = (Ident, ItemKind, Option<Vec<Attribute>>);\n+pub(super) type ItemInfo = (Ident, ItemKind);\n \n impl<'a> Parser<'a> {\n     pub fn parse_item(&mut self) -> PResult<'a, Option<P<Item>>> {\n@@ -83,345 +82,257 @@ impl<'a> Parser<'a> {\n         });\n \n         let lo = self.token.span;\n-\n         let vis = self.parse_visibility(FollowedByType::No)?;\n \n-        if self.eat_keyword(kw::Use) {\n-            // USE ITEM\n-            let item_ = ItemKind::Use(P(self.parse_use_tree()?));\n-            self.expect_semi()?;\n+        if let Some((ident, kind)) = self.parse_item_kind(&mut attrs, macros_allowed, lo, &vis)? {\n+            return Ok(Some(P(self.mk_item(lo, ident, kind, vis, attrs))));\n+        }\n \n-            let span = lo.to(self.prev_span);\n-            let item = self.mk_item(span, Ident::invalid(), item_, vis, attrs);\n-            return Ok(Some(item));\n+        // FAILURE TO PARSE ITEM\n+        if let VisibilityKind::Inherited = vis.node {\n+        } else {\n+            let vs = pprust::vis_to_string(&vis);\n+            let vs = vs.trim_end();\n+            self.struct_span_err(vis.span, &format!(\"unmatched visibility `{}`\", vs))\n+                .span_label(vis.span, \"the unmatched visibility\")\n+                .help(&format!(\"you likely meant to define an item, e.g., `{} fn foo() {{}}`\", vs))\n+                .emit();\n         }\n \n-        if self.check_fn_front_matter() {\n-            // FUNCTION ITEM\n-            let (ident, sig, generics, body) = self.parse_fn(&mut false, &mut attrs, |_| true)?;\n-            let kind = ItemKind::Fn(sig, generics, body);\n-            return self.mk_item_with_info(attrs, lo, vis, (ident, kind, None));\n+        if !attributes_allowed {\n+            self.recover_attrs_no_item(&attrs)?;\n         }\n+        Ok(None)\n+    }\n \n-        if self.eat_keyword(kw::Extern) {\n+    /// Parses one of the items allowed by the flags.\n+    fn parse_item_kind(\n+        &mut self,\n+        attrs: &mut Vec<Attribute>,\n+        macros_allowed: bool,\n+        lo: Span,\n+        vis: &Visibility,\n+    ) -> PResult<'a, Option<ItemInfo>> {\n+        let info = if self.eat_keyword(kw::Use) {\n+            // USE ITEM\n+            let tree = self.parse_use_tree()?;\n+            self.expect_semi()?;\n+            (Ident::invalid(), ItemKind::Use(P(tree)))\n+        } else if self.check_fn_front_matter() {\n+            // FUNCTION ITEM\n+            let (ident, sig, generics, body) = self.parse_fn(&mut false, attrs, |_| true)?;\n+            (ident, ItemKind::Fn(sig, generics, body))\n+        } else if self.eat_keyword(kw::Extern) {\n             if self.eat_keyword(kw::Crate) {\n                 // EXTERN CRATE\n-                return Ok(Some(self.parse_item_extern_crate(lo, vis, attrs)?));\n+                self.parse_item_extern_crate()?\n+            } else {\n+                // EXTERN BLOCK\n+                self.parse_item_foreign_mod(attrs)?\n             }\n-            // EXTERN BLOCK\n-            let abi = self.parse_abi();\n-            return Ok(Some(self.parse_item_foreign_mod(lo, abi, vis, attrs)?));\n-        }\n-\n-        if self.is_static_global() {\n+        } else if self.is_static_global() {\n             // STATIC ITEM\n-            self.bump();\n+            self.bump(); // `static`\n             let m = self.parse_mutability();\n-            let info = self.parse_item_const(Some(m))?;\n-            return self.mk_item_with_info(attrs, lo, vis, info);\n-        }\n-\n-        if let Const::Yes(const_span) = self.parse_constness() {\n+            self.parse_item_const(Some(m))?\n+        } else if let Const::Yes(const_span) = self.parse_constness() {\n             // CONST ITEM\n-            if self.eat_keyword(kw::Mut) {\n-                let prev_span = self.prev_span;\n-                self.struct_span_err(prev_span, \"const globals cannot be mutable\")\n-                    .span_label(prev_span, \"cannot be mutable\")\n-                    .span_suggestion(\n-                        const_span,\n-                        \"you might want to declare a static instead\",\n-                        \"static\".to_owned(),\n-                        Applicability::MaybeIncorrect,\n-                    )\n-                    .emit();\n-            }\n-\n-            let info = self.parse_item_const(None)?;\n-            return self.mk_item_with_info(attrs, lo, vis, info);\n-        }\n-\n-        if self.check_keyword(kw::Unsafe) && self.is_keyword_ahead(1, &[kw::Trait, kw::Auto]) {\n-            // UNSAFE TRAIT ITEM\n-            let unsafety = self.parse_unsafety();\n-            let info = self.parse_item_trait(lo, unsafety)?;\n-            return self.mk_item_with_info(attrs, lo, vis, info);\n-        }\n-\n-        if self.check_keyword(kw::Impl)\n+            self.recover_const_mut(const_span);\n+            self.parse_item_const(None)?\n+        } else if self.check_keyword(kw::Trait) || self.check_auto_or_unsafe_trait_item() {\n+            // TRAIT ITEM\n+            self.parse_item_trait(attrs, lo)?\n+        } else if self.check_keyword(kw::Impl)\n             || self.check_keyword(kw::Unsafe) && self.is_keyword_ahead(1, &[kw::Impl])\n             || self.check_keyword(kw::Default) && self.is_keyword_ahead(1, &[kw::Impl, kw::Unsafe])\n         {\n             // IMPL ITEM\n             let defaultness = self.parse_defaultness();\n             let unsafety = self.parse_unsafety();\n             self.expect_keyword(kw::Impl)?;\n-            let info = self.parse_item_impl(unsafety, defaultness)?;\n-            return self.mk_item_with_info(attrs, lo, vis, info);\n-        }\n-\n-        if self.eat_keyword(kw::Mod) {\n+            self.parse_item_impl(attrs, unsafety, defaultness)?\n+        } else if self.eat_keyword(kw::Mod) {\n             // MODULE ITEM\n-            let info = self.parse_item_mod(&attrs[..])?;\n-            return self.mk_item_with_info(attrs, lo, vis, info);\n-        }\n-\n-        if self.eat_keyword(kw::Type) {\n+            self.parse_item_mod(attrs)?\n+        } else if self.eat_keyword(kw::Type) {\n             // TYPE ITEM\n             let (ident, ty, generics) = self.parse_type_alias()?;\n-            let kind = ItemKind::TyAlias(ty, generics);\n-            return self.mk_item_with_info(attrs, lo, vis, (ident, kind, None));\n-        }\n-\n-        if self.eat_keyword(kw::Enum) {\n+            (ident, ItemKind::TyAlias(ty, generics))\n+        } else if self.eat_keyword(kw::Enum) {\n             // ENUM ITEM\n-            let info = self.parse_item_enum()?;\n-            return self.mk_item_with_info(attrs, lo, vis, info);\n-        }\n-\n-        if self.check_keyword(kw::Trait)\n-            || (self.check_keyword(kw::Auto) && self.is_keyword_ahead(1, &[kw::Trait]))\n-        {\n-            // TRAIT ITEM\n-            let info = self.parse_item_trait(lo, Unsafe::No)?;\n-            return self.mk_item_with_info(attrs, lo, vis, info);\n-        }\n-\n-        if self.eat_keyword(kw::Struct) {\n+            self.parse_item_enum()?\n+        } else if self.eat_keyword(kw::Struct) {\n             // STRUCT ITEM\n-            let info = self.parse_item_struct()?;\n-            return self.mk_item_with_info(attrs, lo, vis, info);\n-        }\n-\n-        if self.is_union_item() {\n+            self.parse_item_struct()?\n+        } else if self.is_kw_followed_by_ident(kw::Union) {\n             // UNION ITEM\n-            self.bump();\n-            let info = self.parse_item_union()?;\n-            return self.mk_item_with_info(attrs, lo, vis, info);\n-        }\n+            self.bump(); // `union`\n+            self.parse_item_union()?\n+        } else if self.eat_keyword(kw::Macro) {\n+            // MACROS 2.0 ITEM\n+            self.parse_item_decl_macro(lo)?\n+        } else if self.is_macro_rules_item() {\n+            // MACRO_RULES ITEM\n+            self.parse_item_macro_rules(vis)?\n+        } else if vis.node.is_pub() && self.isnt_macro_invocation() {\n+            self.recover_missing_kw_before_item()?;\n+            return Ok(None);\n+        } else if macros_allowed && self.token.is_path_start() {\n+            // MACRO INVOCATION ITEM\n+            (Ident::invalid(), ItemKind::Mac(self.parse_item_macro(vis)?))\n+        } else {\n+            return Ok(None);\n+        };\n+        Ok(Some(info))\n+    }\n \n-        if let Some(macro_def) = self.eat_macro_def(&attrs, &vis, lo)? {\n-            return Ok(Some(macro_def));\n-        }\n+    /// When parsing a statement, would the start of a path be an item?\n+    pub(super) fn is_path_start_item(&mut self) -> bool {\n+        self.is_crate_vis() // no: `crate::b`, yes: `crate $item`\n+        || self.is_kw_followed_by_ident(kw::Union) // no: `union::b`, yes: `union U { .. }`\n+        || self.check_auto_or_unsafe_trait_item() // no: `auto::b`, yes: `auto trait X { .. }`\n+        || self.is_async_fn() // no(2015): `async::b`, yes: `async fn`\n+        || self.is_macro_rules_item() // no: `macro_rules::b`, yes: `macro_rules! mac`\n+    }\n \n-        // Verify whether we have encountered a struct or method definition where the user forgot to\n-        // add the `struct` or `fn` keyword after writing `pub`: `pub S {}`\n-        if vis.node.is_pub() && self.check_ident() && self.look_ahead(1, |t| *t != token::Not) {\n-            // Space between `pub` keyword and the identifier\n-            //\n-            //     pub   S {}\n-            //        ^^^ `sp` points here\n-            let sp = self.prev_span.between(self.token.span);\n-            let full_sp = self.prev_span.to(self.token.span);\n-            let ident_sp = self.token.span;\n-            if self.look_ahead(1, |t| *t == token::OpenDelim(token::Brace)) {\n-                // possible public struct definition where `struct` was forgotten\n-                let ident = self.parse_ident().unwrap();\n-                let msg = format!(\"add `struct` here to parse `{}` as a public struct\", ident);\n-                let mut err = self.struct_span_err(sp, \"missing `struct` for struct definition\");\n+    /// Are we sure this could not possibly be a macro invocation?\n+    fn isnt_macro_invocation(&mut self) -> bool {\n+        self.check_ident() && self.look_ahead(1, |t| *t != token::Not && *t != token::ModSep)\n+    }\n+\n+    /// Recover on encountering a struct or method definition where the user\n+    /// forgot to add the `struct` or `fn` keyword after writing `pub`: `pub S {}`.\n+    fn recover_missing_kw_before_item(&mut self) -> PResult<'a, ()> {\n+        // Space between `pub` keyword and the identifier\n+        //\n+        //     pub   S {}\n+        //        ^^^ `sp` points here\n+        let sp = self.prev_span.between(self.token.span);\n+        let full_sp = self.prev_span.to(self.token.span);\n+        let ident_sp = self.token.span;\n+        if self.look_ahead(1, |t| *t == token::OpenDelim(token::Brace)) {\n+            // possible public struct definition where `struct` was forgotten\n+            let ident = self.parse_ident().unwrap();\n+            let msg = format!(\"add `struct` here to parse `{}` as a public struct\", ident);\n+            let mut err = self.struct_span_err(sp, \"missing `struct` for struct definition\");\n+            err.span_suggestion_short(\n+                sp,\n+                &msg,\n+                \" struct \".into(),\n+                Applicability::MaybeIncorrect, // speculative\n+            );\n+            return Err(err);\n+        } else if self.look_ahead(1, |t| *t == token::OpenDelim(token::Paren)) {\n+            let ident = self.parse_ident().unwrap();\n+            self.bump(); // `(`\n+            let kw_name = self.recover_first_param();\n+            self.consume_block(token::Paren, ConsumeClosingDelim::Yes);\n+            let (kw, kw_name, ambiguous) = if self.check(&token::RArrow) {\n+                self.eat_to_tokens(&[&token::OpenDelim(token::Brace)]);\n+                self.bump(); // `{`\n+                (\"fn\", kw_name, false)\n+            } else if self.check(&token::OpenDelim(token::Brace)) {\n+                self.bump(); // `{`\n+                (\"fn\", kw_name, false)\n+            } else if self.check(&token::Colon) {\n+                let kw = \"struct\";\n+                (kw, kw, false)\n+            } else {\n+                (\"fn` or `struct\", \"function or struct\", true)\n+            };\n+\n+            let msg = format!(\"missing `{}` for {} definition\", kw, kw_name);\n+            let mut err = self.struct_span_err(sp, &msg);\n+            if !ambiguous {\n+                self.consume_block(token::Brace, ConsumeClosingDelim::Yes);\n+                let suggestion =\n+                    format!(\"add `{}` here to parse `{}` as a public {}\", kw, ident, kw_name);\n                 err.span_suggestion_short(\n                     sp,\n-                    &msg,\n-                    \" struct \".into(),\n-                    Applicability::MaybeIncorrect, // speculative\n+                    &suggestion,\n+                    format!(\" {} \", kw),\n+                    Applicability::MachineApplicable,\n                 );\n-                return Err(err);\n-            } else if self.look_ahead(1, |t| *t == token::OpenDelim(token::Paren)) {\n-                let ident = self.parse_ident().unwrap();\n-                self.bump(); // `(`\n-                let kw_name = self.recover_first_param();\n-                self.consume_block(token::Paren, ConsumeClosingDelim::Yes);\n-                let (kw, kw_name, ambiguous) = if self.check(&token::RArrow) {\n-                    self.eat_to_tokens(&[&token::OpenDelim(token::Brace)]);\n-                    self.bump(); // `{`\n-                    (\"fn\", kw_name, false)\n-                } else if self.check(&token::OpenDelim(token::Brace)) {\n-                    self.bump(); // `{`\n-                    (\"fn\", kw_name, false)\n-                } else if self.check(&token::Colon) {\n-                    let kw = \"struct\";\n-                    (kw, kw, false)\n-                } else {\n-                    (\"fn` or `struct\", \"function or struct\", true)\n-                };\n-\n-                let msg = format!(\"missing `{}` for {} definition\", kw, kw_name);\n-                let mut err = self.struct_span_err(sp, &msg);\n-                if !ambiguous {\n-                    self.consume_block(token::Brace, ConsumeClosingDelim::Yes);\n-                    let suggestion =\n-                        format!(\"add `{}` here to parse `{}` as a public {}\", kw, ident, kw_name);\n-                    err.span_suggestion_short(\n-                        sp,\n-                        &suggestion,\n-                        format!(\" {} \", kw),\n-                        Applicability::MachineApplicable,\n+            } else {\n+                if let Ok(snippet) = self.span_to_snippet(ident_sp) {\n+                    err.span_suggestion(\n+                        full_sp,\n+                        \"if you meant to call a macro, try\",\n+                        format!(\"{}!\", snippet),\n+                        // this is the `ambiguous` conditional branch\n+                        Applicability::MaybeIncorrect,\n                     );\n                 } else {\n-                    if let Ok(snippet) = self.span_to_snippet(ident_sp) {\n-                        err.span_suggestion(\n-                            full_sp,\n-                            \"if you meant to call a macro, try\",\n-                            format!(\"{}!\", snippet),\n-                            // this is the `ambiguous` conditional branch\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                    } else {\n-                        err.help(\n-                            \"if you meant to call a macro, remove the `pub` \\\n+                    err.help(\n+                        \"if you meant to call a macro, remove the `pub` \\\n                                   and add a trailing `!` after the identifier\",\n-                        );\n-                    }\n-                }\n-                return Err(err);\n-            } else if self.look_ahead(1, |t| *t == token::Lt) {\n-                let ident = self.parse_ident().unwrap();\n-                self.eat_to_tokens(&[&token::Gt]);\n-                self.bump(); // `>`\n-                let (kw, kw_name, ambiguous) = if self.eat(&token::OpenDelim(token::Paren)) {\n-                    (\"fn\", self.recover_first_param(), false)\n-                } else if self.check(&token::OpenDelim(token::Brace)) {\n-                    (\"struct\", \"struct\", false)\n-                } else {\n-                    (\"fn` or `struct\", \"function or struct\", true)\n-                };\n-                let msg = format!(\"missing `{}` for {} definition\", kw, kw_name);\n-                let mut err = self.struct_span_err(sp, &msg);\n-                if !ambiguous {\n-                    err.span_suggestion_short(\n-                        sp,\n-                        &format!(\"add `{}` here to parse `{}` as a public {}\", kw, ident, kw_name),\n-                        format!(\" {} \", kw),\n-                        Applicability::MachineApplicable,\n                     );\n                 }\n-                return Err(err);\n             }\n-        }\n-        self.parse_macro_use_or_failure(attrs, macros_allowed, attributes_allowed, lo, vis)\n-    }\n-\n-    pub(super) fn mk_item_with_info(\n-        &self,\n-        attrs: Vec<Attribute>,\n-        lo: Span,\n-        vis: Visibility,\n-        info: ItemInfo,\n-    ) -> PResult<'a, Option<P<Item>>> {\n-        let (ident, item, extra_attrs) = info;\n-        let span = lo.to(self.prev_span);\n-        let attrs = Self::maybe_append(attrs, extra_attrs);\n-        Ok(Some(self.mk_item(span, ident, item, vis, attrs)))\n-    }\n-\n-    fn maybe_append<T>(mut lhs: Vec<T>, mut rhs: Option<Vec<T>>) -> Vec<T> {\n-        if let Some(ref mut rhs) = rhs {\n-            lhs.append(rhs);\n-        }\n-        lhs\n-    }\n-\n-    /// This is the fall-through for parsing items.\n-    fn parse_macro_use_or_failure(\n-        &mut self,\n-        attrs: Vec<Attribute>,\n-        macros_allowed: bool,\n-        attributes_allowed: bool,\n-        lo: Span,\n-        visibility: Visibility,\n-    ) -> PResult<'a, Option<P<Item>>> {\n-        if macros_allowed\n-            && self.token.is_path_start()\n-            && !(self.is_async_fn() && self.token.span.rust_2015())\n-        {\n-            // MACRO INVOCATION ITEM\n-\n-            let prev_span = self.prev_span;\n-            self.complain_if_pub_macro(&visibility.node, prev_span);\n-\n-            // Item macro\n-            let path = self.parse_path(PathStyle::Mod)?;\n-            self.expect(&token::Not)?;\n-            let args = self.parse_mac_args()?;\n-            if args.need_semicolon() && !self.eat(&token::Semi) {\n-                self.report_invalid_macro_expansion_item();\n+            return Err(err);\n+        } else if self.look_ahead(1, |t| *t == token::Lt) {\n+            let ident = self.parse_ident().unwrap();\n+            self.eat_to_tokens(&[&token::Gt]);\n+            self.bump(); // `>`\n+            let (kw, kw_name, ambiguous) = if self.eat(&token::OpenDelim(token::Paren)) {\n+                (\"fn\", self.recover_first_param(), false)\n+            } else if self.check(&token::OpenDelim(token::Brace)) {\n+                (\"struct\", \"struct\", false)\n+            } else {\n+                (\"fn` or `struct\", \"function or struct\", true)\n+            };\n+            let msg = format!(\"missing `{}` for {} definition\", kw, kw_name);\n+            let mut err = self.struct_span_err(sp, &msg);\n+            if !ambiguous {\n+                err.span_suggestion_short(\n+                    sp,\n+                    &format!(\"add `{}` here to parse `{}` as a public {}\", kw, ident, kw_name),\n+                    format!(\" {} \", kw),\n+                    Applicability::MachineApplicable,\n+                );\n             }\n-\n-            let hi = self.prev_span;\n-            let mac = Mac { path, args, prior_type_ascription: self.last_type_ascription };\n-            let item =\n-                self.mk_item(lo.to(hi), Ident::invalid(), ItemKind::Mac(mac), visibility, attrs);\n-            return Ok(Some(item));\n-        }\n-\n-        // FAILURE TO PARSE ITEM\n-        match visibility.node {\n-            VisibilityKind::Inherited => {}\n-            _ => return Err(self.struct_span_err(self.prev_span, \"unmatched visibility `pub`\")),\n+            return Err(err);\n+        } else {\n+            Ok(())\n         }\n+    }\n \n-        if !attributes_allowed && !attrs.is_empty() {\n-            self.expected_item_err(&attrs)?;\n-        }\n-        Ok(None)\n+    /// Parses an item macro, e.g., `item!();`.\n+    fn parse_item_macro(&mut self, vis: &Visibility) -> PResult<'a, Mac> {\n+        let path = self.parse_path(PathStyle::Mod)?; // `foo::bar`\n+        self.expect(&token::Not)?; // `!`\n+        let args = self.parse_mac_args()?; // `( .. )` or `[ .. ]` (followed by `;`), or `{ .. }`.\n+        self.eat_semi_for_macro_if_needed(&args);\n+        self.complain_if_pub_macro(vis, false);\n+        Ok(Mac { path, args, prior_type_ascription: self.last_type_ascription })\n     }\n \n-    /// Emits an expected-item-after-attributes error.\n-    fn expected_item_err(&mut self, attrs: &[Attribute]) -> PResult<'a, ()> {\n-        let message = match attrs.last() {\n-            Some(&Attribute { kind: AttrKind::DocComment(_), .. }) => {\n-                \"expected item after doc comment\"\n-            }\n-            _ => \"expected item after attributes\",\n+    /// Recover if we parsed attributes and expected an item but there was none.\n+    fn recover_attrs_no_item(&mut self, attrs: &[Attribute]) -> PResult<'a, ()> {\n+        let (start, end) = match attrs {\n+            [] => return Ok(()),\n+            [x0] => (x0, x0),\n+            [x0, .., xn] => (x0, xn),\n         };\n-\n-        let mut err = self.struct_span_err(self.prev_span, message);\n-        if attrs.last().unwrap().is_doc_comment() {\n-            err.span_label(self.prev_span, \"this doc comment doesn't document anything\");\n+        let msg = if end.is_doc_comment() {\n+            \"expected item after doc comment\"\n+        } else {\n+            \"expected item after attributes\"\n+        };\n+        let mut err = self.struct_span_err(end.span, msg);\n+        if end.is_doc_comment() {\n+            err.span_label(end.span, \"this doc comment doesn't document anything\");\n+        }\n+        if let [.., penultimate, _] = attrs {\n+            err.span_label(start.span.to(penultimate.span), \"other attributes here\");\n         }\n         Err(err)\n     }\n \n-    pub(super) fn is_async_fn(&self) -> bool {\n+    fn is_async_fn(&self) -> bool {\n         self.token.is_keyword(kw::Async) && self.is_keyword_ahead(1, &[kw::Fn])\n     }\n \n-    /// Parses a macro invocation inside a `trait`, `impl` or `extern` block.\n-    fn parse_assoc_macro_invoc(\n-        &mut self,\n-        item_kind: &str,\n-        vis: Option<&Visibility>,\n-        at_end: &mut bool,\n-    ) -> PResult<'a, Option<Mac>> {\n-        if self.token.is_path_start() && !(self.is_async_fn() && self.token.span.rust_2015()) {\n-            let prev_span = self.prev_span;\n-            let path = self.parse_path(PathStyle::Mod)?;\n-\n-            if path.segments.len() == 1 {\n-                if !self.eat(&token::Not) {\n-                    return Err(self.missing_assoc_item_kind_err(item_kind, prev_span));\n-                }\n-            } else {\n-                self.expect(&token::Not)?;\n-            }\n-\n-            if let Some(vis) = vis {\n-                self.complain_if_pub_macro(&vis.node, prev_span);\n-            }\n-\n-            *at_end = true;\n-\n-            // eat a matched-delimiter token tree:\n-            let args = self.parse_mac_args()?;\n-            if args.need_semicolon() {\n-                self.expect_semi()?;\n-            }\n-\n-            Ok(Some(Mac { path, args, prior_type_ascription: self.last_type_ascription }))\n-        } else {\n-            Ok(None)\n-        }\n-    }\n-\n     fn missing_assoc_item_kind_err(\n         &self,\n         item_type: &str,\n@@ -442,7 +353,7 @@ impl<'a> Parser<'a> {\n         //   |        ^ missing `fn`, `type`, or `const`\n         //     pub  path(\n         //        ^^ `sp` below will point to this\n-        let sp = prev_span.between(self.prev_span);\n+        let sp = prev_span.between(self.token.span);\n         let mut err = self\n             .struct_span_err(sp, &format!(\"{} for {}-item declaration\", expected_kinds, item_type));\n         err.span_label(sp, expected_kinds);\n@@ -451,16 +362,21 @@ impl<'a> Parser<'a> {\n \n     /// Parses an implementation item, `impl` keyword is already parsed.\n     ///\n-    ///    impl<'a, T> TYPE { /* impl items */ }\n-    ///    impl<'a, T> TRAIT for TYPE { /* impl items */ }\n-    ///    impl<'a, T> !TRAIT for TYPE { /* impl items */ }\n-    ///    impl<'a, T> const TRAIT for TYPE { /* impl items */ }\n+    /// ```\n+    /// impl<'a, T> TYPE { /* impl items */ }\n+    /// impl<'a, T> TRAIT for TYPE { /* impl items */ }\n+    /// impl<'a, T> !TRAIT for TYPE { /* impl items */ }\n+    /// impl<'a, T> const TRAIT for TYPE { /* impl items */ }\n+    /// ```\n     ///\n     /// We actually parse slightly more relaxed grammar for better error reporting and recovery.\n-    ///   `impl` GENERICS `const`? `!`? TYPE `for`? (TYPE | `..`) (`where` PREDICATES)? `{` BODY `}`\n-    ///   `impl` GENERICS `const`? `!`? TYPE (`where` PREDICATES)? `{` BODY `}`\n+    /// ```\n+    /// \"impl\" GENERICS \"const\"? \"!\"? TYPE \"for\"? (TYPE | \"..\") (\"where\" PREDICATES)? \"{\" BODY \"}\"\n+    /// \"impl\" GENERICS \"const\"? \"!\"? TYPE (\"where\" PREDICATES)? \"{\" BODY \"}\"\n+    /// ```\n     fn parse_item_impl(\n         &mut self,\n+        attrs: &mut Vec<Attribute>,\n         unsafety: Unsafe,\n         defaultness: Defaultness,\n     ) -> PResult<'a, ItemInfo> {\n@@ -515,7 +431,7 @@ impl<'a> Parser<'a> {\n \n         generics.where_clause = self.parse_where_clause()?;\n \n-        let (impl_items, attrs) = self.parse_impl_body()?;\n+        let impl_items = self.parse_item_list(attrs, |p, at_end| p.parse_impl_item(at_end))?;\n \n         let item_kind = match ty_second {\n             Some(ty_second) => {\n@@ -568,18 +484,25 @@ impl<'a> Parser<'a> {\n             }\n         };\n \n-        Ok((Ident::invalid(), item_kind, Some(attrs)))\n+        Ok((Ident::invalid(), item_kind))\n     }\n \n-    fn parse_impl_body(&mut self) -> PResult<'a, (Vec<P<AssocItem>>, Vec<Attribute>)> {\n+    fn parse_item_list<T>(\n+        &mut self,\n+        attrs: &mut Vec<Attribute>,\n+        mut parse_item: impl FnMut(&mut Parser<'a>, &mut bool) -> PResult<'a, T>,\n+    ) -> PResult<'a, Vec<T>> {\n         self.expect(&token::OpenDelim(token::Brace))?;\n-        let attrs = self.parse_inner_attributes()?;\n+        attrs.append(&mut self.parse_inner_attributes()?);\n \n-        let mut impl_items = Vec::new();\n+        let mut items = Vec::new();\n         while !self.eat(&token::CloseDelim(token::Brace)) {\n+            if self.recover_doc_comment_before_brace() {\n+                continue;\n+            }\n             let mut at_end = false;\n-            match self.parse_impl_item(&mut at_end) {\n-                Ok(impl_item) => impl_items.push(impl_item),\n+            match parse_item(self, &mut at_end) {\n+                Ok(item) => items.push(item),\n                 Err(mut err) => {\n                     err.emit();\n                     if !at_end {\n@@ -589,7 +512,30 @@ impl<'a> Parser<'a> {\n                 }\n             }\n         }\n-        Ok((impl_items, attrs))\n+        Ok(items)\n+    }\n+\n+    /// Recover on a doc comment before `}`.\n+    fn recover_doc_comment_before_brace(&mut self) -> bool {\n+        if let token::DocComment(_) = self.token.kind {\n+            if self.look_ahead(1, |tok| tok == &token::CloseDelim(token::Brace)) {\n+                struct_span_err!(\n+                    self.diagnostic(),\n+                    self.token.span,\n+                    E0584,\n+                    \"found a documentation comment that doesn't document anything\",\n+                )\n+                .span_label(self.token.span, \"this doc comment doesn't document anything\")\n+                .help(\n+                    \"doc comments must come before what they document, maybe a \\\n+                    comment was intended with `//`?\",\n+                )\n+                .emit();\n+                self.bump();\n+                return true;\n+            }\n+        }\n+        false\n     }\n \n     /// Parses defaultness (i.e., `default` or nothing).\n@@ -617,8 +563,17 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    /// Parses `auto? trait Foo { ... }` or `trait Foo = Bar;`.\n-    fn parse_item_trait(&mut self, lo: Span, unsafety: Unsafe) -> PResult<'a, ItemInfo> {\n+    /// Is this an `(unsafe auto? | auto) trait` item?\n+    fn check_auto_or_unsafe_trait_item(&mut self) -> bool {\n+        // auto trait\n+        self.check_keyword(kw::Auto) && self.is_keyword_ahead(1, &[kw::Trait])\n+            // unsafe auto trait\n+            || self.check_keyword(kw::Unsafe) && self.is_keyword_ahead(1, &[kw::Trait, kw::Auto])\n+    }\n+\n+    /// Parses `unsafe? auto? trait Foo { ... }` or `trait Foo = Bar;`.\n+    fn parse_item_trait(&mut self, attrs: &mut Vec<Attribute>, lo: Span) -> PResult<'a, ItemInfo> {\n+        let unsafety = self.parse_unsafety();\n         // Parse optional `auto` prefix.\n         let is_auto = if self.eat_keyword(kw::Auto) { IsAuto::Yes } else { IsAuto::No };\n \n@@ -656,43 +611,12 @@ impl<'a> Parser<'a> {\n \n             self.sess.gated_spans.gate(sym::trait_alias, whole_span);\n \n-            Ok((ident, ItemKind::TraitAlias(tps, bounds), None))\n+            Ok((ident, ItemKind::TraitAlias(tps, bounds)))\n         } else {\n             // It's a normal trait.\n             tps.where_clause = self.parse_where_clause()?;\n-            self.expect(&token::OpenDelim(token::Brace))?;\n-            let mut trait_items = vec![];\n-            while !self.eat(&token::CloseDelim(token::Brace)) {\n-                if let token::DocComment(_) = self.token.kind {\n-                    if self.look_ahead(1, |tok| tok == &token::CloseDelim(token::Brace)) {\n-                        struct_span_err!(\n-                            self.diagnostic(),\n-                            self.token.span,\n-                            E0584,\n-                            \"found a documentation comment that doesn't document anything\",\n-                        )\n-                        .help(\n-                            \"doc comments must come before what they document, maybe a \\\n-                            comment was intended with `//`?\",\n-                        )\n-                        .emit();\n-                        self.bump();\n-                        continue;\n-                    }\n-                }\n-                let mut at_end = false;\n-                match self.parse_trait_item(&mut at_end) {\n-                    Ok(item) => trait_items.push(item),\n-                    Err(mut e) => {\n-                        e.emit();\n-                        if !at_end {\n-                            self.consume_block(token::Brace, ConsumeClosingDelim::Yes);\n-                            break;\n-                        }\n-                    }\n-                }\n-            }\n-            Ok((ident, ItemKind::Trait(is_auto, unsafety, tps, bounds, trait_items), None))\n+            let items = self.parse_item_list(attrs, |p, at_end| p.parse_trait_item(at_end))?;\n+            Ok((ident, ItemKind::Trait(is_auto, unsafety, tps, bounds, items)))\n         }\n     }\n \n@@ -740,28 +664,28 @@ impl<'a> Parser<'a> {\n         let lo = self.token.span;\n         let vis = self.parse_visibility(FollowedByType::No)?;\n         let defaultness = self.parse_defaultness();\n-        let (name, kind, generics) = if self.eat_keyword(kw::Type) {\n+\n+        let (ident, kind, generics) = if self.eat_keyword(kw::Type) {\n             self.parse_assoc_ty()?\n         } else if self.check_fn_front_matter() {\n             let (ident, sig, generics, body) = self.parse_fn(at_end, &mut attrs, req_name)?;\n             (ident, AssocItemKind::Fn(sig, body), generics)\n-        } else if let Some(mac) = self.parse_assoc_macro_invoc(\"associated\", Some(&vis), at_end)? {\n+        } else if self.check_keyword(kw::Const) {\n+            self.parse_assoc_const()?\n+        } else if self.isnt_macro_invocation() {\n+            return Err(self.missing_assoc_item_kind_err(\"associated\", self.prev_span));\n+        } else if self.token.is_path_start() {\n+            let mac = self.parse_item_macro(&vis)?;\n+            *at_end = true;\n             (Ident::invalid(), AssocItemKind::Macro(mac), Generics::default())\n         } else {\n-            self.parse_assoc_const()?\n+            self.recover_attrs_no_item(&attrs)?;\n+            self.unexpected()?\n         };\n \n-        Ok(AssocItem {\n-            id: DUMMY_NODE_ID,\n-            span: lo.to(self.prev_span),\n-            ident: name,\n-            attrs,\n-            vis,\n-            defaultness,\n-            generics,\n-            kind,\n-            tokens: None,\n-        })\n+        let span = lo.to(self.prev_span);\n+        let id = DUMMY_NODE_ID;\n+        Ok(AssocItem { id, span, ident, attrs, vis, defaultness, generics, kind, tokens: None })\n     }\n \n     /// This parses the grammar:\n@@ -860,7 +784,7 @@ impl<'a> Parser<'a> {\n \n     fn parse_ident_or_underscore(&mut self) -> PResult<'a, ast::Ident> {\n         match self.token.kind {\n-            token::Ident(name, false) if name == kw::Underscore => {\n+            token::Ident(name @ kw::Underscore, false) => {\n                 let span = self.token.span;\n                 self.bump();\n                 Ok(Ident::new(name, span))\n@@ -877,12 +801,7 @@ impl<'a> Parser<'a> {\n     /// extern crate foo;\n     /// extern crate bar as foo;\n     /// ```\n-    fn parse_item_extern_crate(\n-        &mut self,\n-        lo: Span,\n-        visibility: Visibility,\n-        attrs: Vec<Attribute>,\n-    ) -> PResult<'a, P<Item>> {\n+    fn parse_item_extern_crate(&mut self) -> PResult<'a, ItemInfo> {\n         // Accept `extern crate name-like-this` for better diagnostics\n         let orig_name = self.parse_crate_name_with_dashes()?;\n         let (item_name, orig_name) = if let Some(rename) = self.parse_rename()? {\n@@ -891,9 +810,7 @@ impl<'a> Parser<'a> {\n             (orig_name, None)\n         };\n         self.expect_semi()?;\n-\n-        let span = lo.to(self.prev_span);\n-        Ok(self.mk_item(span, item_name, ItemKind::ExternCrate(orig_name), visibility, attrs))\n+        Ok((item_name, ItemKind::ExternCrate(orig_name)))\n     }\n \n     fn parse_crate_name_with_dashes(&mut self) -> PResult<'a, ast::Ident> {\n@@ -936,66 +853,40 @@ impl<'a> Parser<'a> {\n \n     /// Parses `extern` for foreign ABIs modules.\n     ///\n-    /// `extern` is expected to have been\n-    /// consumed before calling this method.\n+    /// `extern` is expected to have been consumed before calling this method.\n     ///\n     /// # Examples\n     ///\n     /// ```ignore (only-for-syntax-highlight)\n     /// extern \"C\" {}\n     /// extern {}\n     /// ```\n-    fn parse_item_foreign_mod(\n-        &mut self,\n-        lo: Span,\n-        abi: Option<StrLit>,\n-        visibility: Visibility,\n-        mut attrs: Vec<Attribute>,\n-    ) -> PResult<'a, P<Item>> {\n-        self.expect(&token::OpenDelim(token::Brace))?;\n-\n-        attrs.extend(self.parse_inner_attributes()?);\n-\n-        let mut foreign_items = vec![];\n-        while !self.eat(&token::CloseDelim(token::Brace)) {\n-            foreign_items.push(self.parse_foreign_item()?);\n-        }\n-\n-        let prev_span = self.prev_span;\n-        let m = ast::ForeignMod { abi, items: foreign_items };\n-        let invalid = Ident::invalid();\n-        Ok(self.mk_item(lo.to(prev_span), invalid, ItemKind::ForeignMod(m), visibility, attrs))\n+    fn parse_item_foreign_mod(&mut self, attrs: &mut Vec<Attribute>) -> PResult<'a, ItemInfo> {\n+        let abi = self.parse_abi(); // ABI?\n+        let items = self.parse_item_list(attrs, |p, at_end| p.parse_foreign_item(at_end))?;\n+        let module = ast::ForeignMod { abi, items };\n+        Ok((Ident::invalid(), ItemKind::ForeignMod(module)))\n     }\n \n-    /// Parses a foreign item.\n-    pub fn parse_foreign_item(&mut self) -> PResult<'a, P<ForeignItem>> {\n+    /// Parses a foreign item (one in an `extern { ... }` block).\n+    pub fn parse_foreign_item(&mut self, at_end: &mut bool) -> PResult<'a, P<ForeignItem>> {\n         maybe_whole!(self, NtForeignItem, |ni| ni);\n \n         let mut attrs = self.parse_outer_attributes()?;\n         let lo = self.token.span;\n         let vis = self.parse_visibility(FollowedByType::No)?;\n \n-        if self.check_keyword(kw::Type) {\n+        let (ident, kind) = if self.check_keyword(kw::Type) {\n             // FOREIGN TYPE ITEM\n-            self.parse_item_foreign_type(vis, lo, attrs)\n+            self.parse_item_foreign_type()?\n         } else if self.check_fn_front_matter() {\n             // FOREIGN FUNCTION ITEM\n-            let (ident, sig, generics, body) = self.parse_fn(&mut false, &mut attrs, |_| true)?;\n-            let kind = ForeignItemKind::Fn(sig, generics, body);\n-            let span = lo.to(self.prev_span);\n-            Ok(P(ast::ForeignItem {\n-                ident,\n-                attrs,\n-                kind,\n-                id: DUMMY_NODE_ID,\n-                span,\n-                vis,\n-                tokens: None,\n-            }))\n+            let (ident, sig, generics, body) = self.parse_fn(at_end, &mut attrs, |_| true)?;\n+            (ident, ForeignItemKind::Fn(sig, generics, body))\n         } else if self.is_static_global() {\n             // FOREIGN STATIC ITEM\n             self.bump(); // `static`\n-            self.parse_item_foreign_static(vis, lo, attrs)\n+            self.parse_item_foreign_static()?\n         } else if self.token.is_keyword(kw::Const) {\n             // Treat `const` as `static` for error recovery, but don't add it to expected tokens.\n             self.bump(); // `const`\n@@ -1007,66 +898,37 @@ impl<'a> Parser<'a> {\n                     Applicability::MachineApplicable,\n                 )\n                 .emit();\n-            self.parse_item_foreign_static(vis, lo, attrs)\n-        } else if let Some(mac) = self.parse_assoc_macro_invoc(\"extern\", Some(&vis), &mut false)? {\n-            let kind = ForeignItemKind::Macro(mac);\n-            let span = lo.to(self.prev_span);\n-            let ident = Ident::invalid();\n-            Ok(P(ForeignItem { ident, span, id: DUMMY_NODE_ID, attrs, vis, kind, tokens: None }))\n+            self.parse_item_foreign_static()?\n+        } else if self.isnt_macro_invocation() {\n+            return Err(self.missing_assoc_item_kind_err(\"extern\", self.prev_span));\n+        } else if self.token.is_path_start() {\n+            let mac = self.parse_item_macro(&vis)?;\n+            *at_end = true;\n+            (Ident::invalid(), ForeignItemKind::Macro(mac))\n         } else {\n-            if !attrs.is_empty() {\n-                self.expected_item_err(&attrs)?;\n-            }\n-            self.unexpected()\n-        }\n+            self.recover_attrs_no_item(&attrs)?;\n+            self.unexpected()?\n+        };\n+        Ok(P(self.mk_item(lo, ident, kind, vis, attrs)))\n     }\n \n     /// Parses a static item from a foreign module.\n     /// Assumes that the `static` keyword is already parsed.\n-    fn parse_item_foreign_static(\n-        &mut self,\n-        vis: ast::Visibility,\n-        lo: Span,\n-        attrs: Vec<Attribute>,\n-    ) -> PResult<'a, P<ForeignItem>> {\n+    fn parse_item_foreign_static(&mut self) -> PResult<'a, (Ident, ForeignItemKind)> {\n         let mutbl = self.parse_mutability();\n         let ident = self.parse_ident()?;\n         self.expect(&token::Colon)?;\n         let ty = self.parse_ty()?;\n-        let hi = self.token.span;\n         self.expect_semi()?;\n-        Ok(P(ForeignItem {\n-            ident,\n-            attrs,\n-            kind: ForeignItemKind::Static(ty, mutbl),\n-            id: DUMMY_NODE_ID,\n-            span: lo.to(hi),\n-            vis,\n-            tokens: None,\n-        }))\n+        Ok((ident, ForeignItemKind::Static(ty, mutbl)))\n     }\n \n     /// Parses a type from a foreign module.\n-    fn parse_item_foreign_type(\n-        &mut self,\n-        vis: ast::Visibility,\n-        lo: Span,\n-        attrs: Vec<Attribute>,\n-    ) -> PResult<'a, P<ForeignItem>> {\n+    fn parse_item_foreign_type(&mut self) -> PResult<'a, (Ident, ForeignItemKind)> {\n         self.expect_keyword(kw::Type)?;\n-\n         let ident = self.parse_ident()?;\n-        let hi = self.token.span;\n         self.expect_semi()?;\n-        Ok(P(ast::ForeignItem {\n-            ident,\n-            attrs,\n-            kind: ForeignItemKind::Ty,\n-            id: DUMMY_NODE_ID,\n-            span: lo.to(hi),\n-            vis,\n-            tokens: None,\n-        }))\n+        Ok((ident, ForeignItemKind::Ty))\n     }\n \n     fn is_static_global(&mut self) -> bool {\n@@ -1086,6 +948,22 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n+    /// Recover on `const mut` with `const` already eaten.\n+    fn recover_const_mut(&mut self, const_span: Span) {\n+        if self.eat_keyword(kw::Mut) {\n+            let span = self.prev_span;\n+            self.struct_span_err(span, \"const globals cannot be mutable\")\n+                .span_label(span, \"cannot be mutable\")\n+                .span_suggestion(\n+                    const_span,\n+                    \"you might want to declare a static instead\",\n+                    \"static\".to_owned(),\n+                    Applicability::MaybeIncorrect,\n+                )\n+                .emit();\n+        }\n+    }\n+\n     /// Parse `[\"const\" | (\"static\" \"mut\"?)] $ident \":\" $ty = $expr` with\n     /// `[\"const\" | (\"static\" \"mut\"?)]` already parsed and stored in `m`.\n     ///\n@@ -1110,7 +988,7 @@ impl<'a> Parser<'a> {\n             Some(m) => ItemKind::Static(ty, m, e),\n             None => ItemKind::Const(ty, e),\n         };\n-        Ok((id, item, None))\n+        Ok((id, item))\n     }\n \n     /// We were supposed to parse `:` but instead, we're already at `=`.\n@@ -1163,7 +1041,7 @@ impl<'a> Parser<'a> {\n \n         let enum_definition =\n             EnumDef { variants: variants.into_iter().filter_map(|v| v).collect() };\n-        Ok((id, ItemKind::Enum(enum_definition, generics), None))\n+        Ok((id, ItemKind::Enum(enum_definition, generics)))\n     }\n \n     fn parse_enum_variant(&mut self) -> PResult<'a, Option<Variant>> {\n@@ -1257,7 +1135,7 @@ impl<'a> Parser<'a> {\n             return Err(err);\n         };\n \n-        Ok((class_name, ItemKind::Struct(vdata, generics), None))\n+        Ok((class_name, ItemKind::Struct(vdata, generics)))\n     }\n \n     /// Parses `union Foo { ... }`.\n@@ -1281,12 +1159,7 @@ impl<'a> Parser<'a> {\n             return Err(err);\n         };\n \n-        Ok((class_name, ItemKind::Union(vdata, generics), None))\n-    }\n-\n-    pub(super) fn is_union_item(&self) -> bool {\n-        self.token.is_keyword(kw::Union)\n-            && self.look_ahead(1, |t| t.is_ident() && !t.is_reserved_ident())\n+        Ok((class_name, ItemKind::Union(vdata, generics)))\n     }\n \n     fn parse_record_struct_body(\n@@ -1436,112 +1309,109 @@ impl<'a> Parser<'a> {\n         })\n     }\n \n-    pub(super) fn eat_macro_def(\n-        &mut self,\n-        attrs: &[Attribute],\n-        vis: &Visibility,\n-        lo: Span,\n-    ) -> PResult<'a, Option<P<Item>>> {\n-        let (ident, def) = if self.eat_keyword(kw::Macro) {\n-            let ident = self.parse_ident()?;\n-            let body = if self.check(&token::OpenDelim(token::Brace)) {\n-                self.parse_mac_args()?\n-            } else if self.check(&token::OpenDelim(token::Paren)) {\n-                let params = self.parse_token_tree();\n-                let pspan = params.span();\n-                let body = if self.check(&token::OpenDelim(token::Brace)) {\n-                    self.parse_token_tree()\n-                } else {\n-                    return self.unexpected();\n-                };\n-                let bspan = body.span();\n-                let tokens = TokenStream::new(vec![\n-                    params.into(),\n-                    TokenTree::token(token::FatArrow, pspan.between(bspan)).into(),\n-                    body.into(),\n-                ]);\n-                let dspan = DelimSpan::from_pair(pspan.shrink_to_lo(), bspan.shrink_to_hi());\n-                P(MacArgs::Delimited(dspan, MacDelimiter::Brace, tokens))\n-            } else {\n+    /// Parses a declarative macro 2.0 definition.\n+    /// The `macro` keyword has already been parsed.\n+    /// ```\n+    /// MacBody = \"{\" TOKEN_STREAM \"}\" ;\n+    /// MacParams = \"(\" TOKEN_STREAM \")\" ;\n+    /// DeclMac = \"macro\" Ident MacParams? MacBody ;\n+    /// ```\n+    fn parse_item_decl_macro(&mut self, lo: Span) -> PResult<'a, ItemInfo> {\n+        let ident = self.parse_ident()?;\n+        let body = if self.check(&token::OpenDelim(token::Brace)) {\n+            self.parse_mac_args()? // `MacBody`\n+        } else if self.check(&token::OpenDelim(token::Paren)) {\n+            let params = self.parse_token_tree(); // `MacParams`\n+            let pspan = params.span();\n+            if !self.check(&token::OpenDelim(token::Brace)) {\n                 return self.unexpected();\n-            };\n+            }\n+            let body = self.parse_token_tree(); // `MacBody`\n+            // Convert `MacParams MacBody` into `{ MacParams => MacBody }`.\n+            let bspan = body.span();\n+            let arrow = TokenTree::token(token::FatArrow, pspan.between(bspan)); // `=>`\n+            let tokens = TokenStream::new(vec![params.into(), arrow.into(), body.into()]);\n+            let dspan = DelimSpan::from_pair(pspan.shrink_to_lo(), bspan.shrink_to_hi());\n+            P(MacArgs::Delimited(dspan, MacDelimiter::Brace, tokens))\n+        } else {\n+            return self.unexpected();\n+        };\n+\n+        self.sess.gated_spans.gate(sym::decl_macro, lo.to(self.prev_span));\n+        Ok((ident, ItemKind::MacroDef(ast::MacroDef { body, legacy: false })))\n+    }\n \n-            (ident, ast::MacroDef { body, legacy: false })\n-        } else if self.check_keyword(sym::macro_rules)\n+    /// Is this unambiguously the start of a `macro_rules! foo` item defnition?\n+    fn is_macro_rules_item(&mut self) -> bool {\n+        self.check_keyword(sym::macro_rules)\n             && self.look_ahead(1, |t| *t == token::Not)\n             && self.look_ahead(2, |t| t.is_ident())\n-        {\n-            let prev_span = self.prev_span;\n-            self.complain_if_pub_macro(&vis.node, prev_span);\n-            self.bump();\n-            self.bump();\n-\n-            let ident = self.parse_ident()?;\n-            let body = self.parse_mac_args()?;\n-            if body.need_semicolon() && !self.eat(&token::Semi) {\n-                self.report_invalid_macro_expansion_item();\n-            }\n+    }\n \n-            (ident, ast::MacroDef { body, legacy: true })\n-        } else {\n-            return Ok(None);\n-        };\n+    /// Parses a legacy `macro_rules! foo { ... }` declarative macro.\n+    fn parse_item_macro_rules(&mut self, vis: &Visibility) -> PResult<'a, ItemInfo> {\n+        self.expect_keyword(sym::macro_rules)?; // `macro_rules`\n+        self.expect(&token::Not)?; // `!`\n \n-        let span = lo.to(self.prev_span);\n+        let ident = self.parse_ident()?;\n+        let body = self.parse_mac_args()?;\n+        self.eat_semi_for_macro_if_needed(&body);\n+        self.complain_if_pub_macro(vis, true);\n+\n+        Ok((ident, ItemKind::MacroDef(ast::MacroDef { body, legacy: true })))\n+    }\n \n-        if !def.legacy {\n-            self.sess.gated_spans.gate(sym::decl_macro, span);\n+    /// Item macro invocations or `macro_rules!` definitions need inherited visibility.\n+    /// If that's not the case, emit an error.\n+    fn complain_if_pub_macro(&self, vis: &Visibility, macro_rules: bool) {\n+        if let VisibilityKind::Inherited = vis.node {\n+            return;\n         }\n \n-        Ok(Some(self.mk_item(span, ident, ItemKind::MacroDef(def), vis.clone(), attrs.to_vec())))\n+        let vstr = pprust::vis_to_string(vis);\n+        let vstr = vstr.trim_end();\n+        if macro_rules {\n+            let msg = format!(\"can't qualify macro_rules invocation with `{}`\", vstr);\n+            self.struct_span_err(vis.span, &msg)\n+                .span_suggestion(\n+                    vis.span,\n+                    \"try exporting the macro\",\n+                    \"#[macro_export]\".to_owned(),\n+                    Applicability::MaybeIncorrect, // speculative\n+                )\n+                .emit();\n+        } else {\n+            self.struct_span_err(vis.span, \"can't qualify macro invocation with `pub`\")\n+                .span_suggestion(\n+                    vis.span,\n+                    \"remove the visibility\",\n+                    String::new(),\n+                    Applicability::MachineApplicable,\n+                )\n+                .help(&format!(\"try adjusting the macro to put `{}` inside the invocation\", vstr))\n+                .emit();\n+        }\n     }\n \n-    fn complain_if_pub_macro(&self, vis: &VisibilityKind, sp: Span) {\n-        match *vis {\n-            VisibilityKind::Inherited => {}\n-            _ => {\n-                let mut err = if self.token.is_keyword(sym::macro_rules) {\n-                    let mut err =\n-                        self.struct_span_err(sp, \"can't qualify macro_rules invocation with `pub`\");\n-                    err.span_suggestion(\n-                        sp,\n-                        \"try exporting the macro\",\n-                        \"#[macro_export]\".to_owned(),\n-                        Applicability::MaybeIncorrect, // speculative\n-                    );\n-                    err\n-                } else {\n-                    let mut err =\n-                        self.struct_span_err(sp, \"can't qualify macro invocation with `pub`\");\n-                    err.help(\"try adjusting the macro to put `pub` inside the invocation\");\n-                    err\n-                };\n-                err.emit();\n-            }\n+    fn eat_semi_for_macro_if_needed(&mut self, args: &MacArgs) {\n+        if args.need_semicolon() && !self.eat(&token::Semi) {\n+            self.report_invalid_macro_expansion_item(args);\n         }\n     }\n \n-    fn report_invalid_macro_expansion_item(&self) {\n-        let has_close_delim = self\n-            .sess\n-            .source_map()\n-            .span_to_snippet(self.prev_span)\n-            .map(|s| s.ends_with(\")\") || s.ends_with(\"]\"))\n-            .unwrap_or(false);\n-\n+    fn report_invalid_macro_expansion_item(&self, args: &MacArgs) {\n         let mut err = self.struct_span_err(\n             self.prev_span,\n             \"macros that expand to items must be delimited with braces or followed by a semicolon\",\n         );\n-\n-        // To avoid ICE, we shouldn't emit actual suggestions when it hasn't closing delims\n-        if has_close_delim {\n+        if self.unclosed_delims.is_empty() {\n+            let DelimSpan { open, close } = match args {\n+                MacArgs::Empty | MacArgs::Eq(..) => unreachable!(),\n+                MacArgs::Delimited(dspan, ..) => *dspan,\n+            };\n             err.multipart_suggestion(\n                 \"change the delimiters to curly braces\",\n-                vec![\n-                    (self.prev_span.with_hi(self.prev_span.lo() + BytePos(1)), '{'.to_string()),\n-                    (self.prev_span.with_lo(self.prev_span.hi() - BytePos(1)), '}'.to_string()),\n-                ],\n+                vec![(open, \"{\".to_string()), (close, '}'.to_string())],\n                 Applicability::MaybeIncorrect,\n             );\n         } else {\n@@ -1552,14 +1422,13 @@ impl<'a> Parser<'a> {\n                 Applicability::HasPlaceholders,\n             );\n         }\n-\n         err.span_suggestion(\n             self.prev_span.shrink_to_hi(),\n             \"add a semicolon\",\n             ';'.to_string(),\n             Applicability::MaybeIncorrect,\n-        )\n-        .emit();\n+        );\n+        err.emit();\n     }\n \n     /// Checks if current token is one of tokens which cannot be nested like `kw::Enum`. In case\n@@ -1591,15 +1460,16 @@ impl<'a> Parser<'a> {\n         Ok(true)\n     }\n \n-    fn mk_item(\n+    fn mk_item<K>(\n         &self,\n-        span: Span,\n+        lo: Span,\n         ident: Ident,\n-        kind: ItemKind,\n+        kind: K,\n         vis: Visibility,\n         attrs: Vec<Attribute>,\n-    ) -> P<Item> {\n-        P(Item { ident, attrs, id: DUMMY_NODE_ID, kind, vis, span, tokens: None })\n+    ) -> Item<K> {\n+        let span = lo.to(self.prev_span);\n+        Item { ident, attrs, id: DUMMY_NODE_ID, kind, vis, span, tokens: None }\n     }\n }\n "}, {"sha": "79944dc35e523f358ce672b6125d84bdedafdbfd", "filename": "src/librustc_parse/parser/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/89f5dcfb4316891fafb34d211b7bebc4cf8638d0/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89f5dcfb4316891fafb34d211b7bebc4cf8638d0/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fmod.rs?ref=89f5dcfb4316891fafb34d211b7bebc4cf8638d0", "patch": "@@ -572,6 +572,11 @@ impl<'a> Parser<'a> {\n         if !self.eat_keyword(kw) { self.unexpected() } else { Ok(()) }\n     }\n \n+    /// Is the given keyword `kw` followed by a non-reserved identifier?\n+    fn is_kw_followed_by_ident(&self, kw: Symbol) -> bool {\n+        self.token.is_keyword(kw) && self.look_ahead(1, |t| t.is_ident() && !t.is_reserved_ident())\n+    }\n+\n     fn check_or_expected(&mut self, ok: bool, typ: TokenType) -> bool {\n         if ok {\n             true"}, {"sha": "754923ae55e29683494143a914bcbf3086b15af2", "filename": "src/librustc_parse/parser/module.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/89f5dcfb4316891fafb34d211b7bebc4cf8638d0/src%2Flibrustc_parse%2Fparser%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89f5dcfb4316891fafb34d211b7bebc4cf8638d0/src%2Flibrustc_parse%2Fparser%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fmodule.rs?ref=89f5dcfb4316891fafb34d211b7bebc4cf8638d0", "patch": "@@ -40,36 +40,34 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses a `mod <foo> { ... }` or `mod <foo>;` item.\n-    pub(super) fn parse_item_mod(&mut self, outer_attrs: &[Attribute]) -> PResult<'a, ItemInfo> {\n-        let (in_cfg, outer_attrs) =\n-            crate::config::process_configure_mod(self.sess, self.cfg_mods, outer_attrs);\n+    pub(super) fn parse_item_mod(&mut self, attrs: &mut Vec<Attribute>) -> PResult<'a, ItemInfo> {\n+        let in_cfg = crate::config::process_configure_mod(self.sess, self.cfg_mods, attrs);\n \n         let id_span = self.token.span;\n         let id = self.parse_ident()?;\n-        if self.eat(&token::Semi) {\n+        let (module, mut inner_attrs) = if self.eat(&token::Semi) {\n             if in_cfg && self.recurse_into_file_modules {\n                 // This mod is in an external file. Let's go get it!\n                 let ModulePathSuccess { path, directory_ownership } =\n-                    self.submod_path(id, &outer_attrs, id_span)?;\n-                let (module, attrs) =\n-                    self.eval_src_mod(path, directory_ownership, id.to_string(), id_span)?;\n-                Ok((id, ItemKind::Mod(module), Some(attrs)))\n+                    self.submod_path(id, &attrs, id_span)?;\n+                self.eval_src_mod(path, directory_ownership, id.to_string(), id_span)?\n             } else {\n-                let placeholder = ast::Mod { inner: DUMMY_SP, items: Vec::new(), inline: false };\n-                Ok((id, ItemKind::Mod(placeholder), None))\n+                (ast::Mod { inner: DUMMY_SP, items: Vec::new(), inline: false }, Vec::new())\n             }\n         } else {\n             let old_directory = self.directory.clone();\n-            self.push_directory(id, &outer_attrs);\n+            self.push_directory(id, &attrs);\n \n             self.expect(&token::OpenDelim(token::Brace))?;\n             let mod_inner_lo = self.token.span;\n-            let attrs = self.parse_inner_attributes()?;\n+            let inner_attrs = self.parse_inner_attributes()?;\n             let module = self.parse_mod_items(&token::CloseDelim(token::Brace), mod_inner_lo)?;\n \n             self.directory = old_directory;\n-            Ok((id, ItemKind::Mod(module), Some(attrs)))\n-        }\n+            (module, inner_attrs)\n+        };\n+        attrs.append(&mut inner_attrs);\n+        Ok((id, ItemKind::Mod(module)))\n     }\n \n     /// Given a termination token, parses all of the items in a module."}, {"sha": "742fc4802fd9d6db0cb0f7fdfc982f0efd3bd8fa", "filename": "src/librustc_parse/parser/stmt.rs", "status": "modified", "additions": 8, "deletions": 32, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/89f5dcfb4316891fafb34d211b7bebc4cf8638d0/src%2Flibrustc_parse%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89f5dcfb4316891fafb34d211b7bebc4cf8638d0/src%2Flibrustc_parse%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fstmt.rs?ref=89f5dcfb4316891fafb34d211b7bebc4cf8638d0", "patch": "@@ -7,10 +7,10 @@ use crate::maybe_whole;\n use crate::DirectoryOwnership;\n \n use rustc_errors::{Applicability, PResult};\n-use rustc_span::source_map::{respan, BytePos, Span};\n-use rustc_span::symbol::{kw, sym, Symbol};\n+use rustc_span::source_map::{BytePos, Span};\n+use rustc_span::symbol::{kw, sym};\n use syntax::ast;\n-use syntax::ast::{AttrStyle, AttrVec, Attribute, Mac, MacStmtStyle, VisibilityKind};\n+use syntax::ast::{AttrStyle, AttrVec, Attribute, Mac, MacStmtStyle};\n use syntax::ast::{Block, BlockCheckMode, Expr, ExprKind, Local, Stmt, StmtKind, DUMMY_NODE_ID};\n use syntax::ptr::P;\n use syntax::token::{self, TokenKind};\n@@ -55,21 +55,11 @@ impl<'a> Parser<'a> {\n             return self.recover_stmt_local(lo, attrs.into(), msg, \"let\");\n         }\n \n-        let mac_vis = respan(lo, VisibilityKind::Inherited);\n-        if let Some(macro_def) = self.eat_macro_def(&attrs, &mac_vis, lo)? {\n-            return Ok(Some(self.mk_stmt(lo.to(self.prev_span), StmtKind::Item(macro_def))));\n-        }\n-\n-        // Starts like a simple path, being careful to avoid contextual keywords\n-        // such as a union items, item with `crate` visibility or auto trait items.\n-        // Our goal here is to parse an arbitrary path `a::b::c` but not something that starts\n-        // like a path (1 token), but it fact not a path.\n-        if self.token.is_path_start()\n-            && !self.token.is_qpath_start()\n-            && !self.is_union_item() // `union::b::c` - path, `union U { ... }` - not a path.\n-            && !self.is_crate_vis() // `crate::b::c` - path, `crate struct S;` - not a path.\n-            && !self.is_auto_trait_item()\n-            && !self.is_async_fn()\n+        // Starts like a simple path, being careful to avoid contextual keywords,\n+        // e.g., `union`, items with `crate` visibility, or `auto trait` items.\n+        // We aim to parse an arbitrary path `a::b` but not something that starts like a path\n+        // (1 token), but it fact not a path. Also, we avoid stealing syntax from `parse_item_`.\n+        if self.token.is_path_start() && !self.token.is_qpath_start() && !self.is_path_start_item()\n         {\n             let path = self.parse_path(PathStyle::Expr)?;\n \n@@ -199,10 +189,6 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    fn is_kw_followed_by_ident(&self, kw: Symbol) -> bool {\n-        self.token.is_keyword(kw) && self.look_ahead(1, |t| t.is_ident() && !t.is_reserved_ident())\n-    }\n-\n     fn recover_stmt_local(\n         &mut self,\n         lo: Span,\n@@ -299,16 +285,6 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    fn is_auto_trait_item(&self) -> bool {\n-        // auto trait\n-        (self.token.is_keyword(kw::Auto) &&\n-            self.is_keyword_ahead(1, &[kw::Trait]))\n-        || // unsafe auto trait\n-        (self.token.is_keyword(kw::Unsafe) &&\n-         self.is_keyword_ahead(1, &[kw::Auto]) &&\n-         self.is_keyword_ahead(2, &[kw::Trait]))\n-    }\n-\n     /// Parses a block. No inner attributes are allowed.\n     pub fn parse_block(&mut self) -> PResult<'a, P<Block>> {\n         maybe_whole!(self, NtBlock, |x| x);"}, {"sha": "bb4fb1459bd64597037bb9afad15ac31bb73bec0", "filename": "src/test/pretty/trait-inner-attr.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/89f5dcfb4316891fafb34d211b7bebc4cf8638d0/src%2Ftest%2Fpretty%2Ftrait-inner-attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89f5dcfb4316891fafb34d211b7bebc4cf8638d0/src%2Ftest%2Fpretty%2Ftrait-inner-attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Ftrait-inner-attr.rs?ref=89f5dcfb4316891fafb34d211b7bebc4cf8638d0", "patch": "@@ -0,0 +1,7 @@\n+// pp-exact\n+\n+trait Foo {\n+    #![allow(bar)]\n+}\n+\n+fn main() { }"}, {"sha": "6221b90b31dd7f7d2313674f180d1bc5fff08afd", "filename": "src/test/ui/issues/issue-58856-2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89f5dcfb4316891fafb34d211b7bebc4cf8638d0/src%2Ftest%2Fui%2Fissues%2Fissue-58856-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/89f5dcfb4316891fafb34d211b7bebc4cf8638d0/src%2Ftest%2Fui%2Fissues%2Fissue-58856-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-58856-2.stderr?ref=89f5dcfb4316891fafb34d211b7bebc4cf8638d0", "patch": "@@ -7,11 +7,11 @@ LL |     fn how_are_you(&self -> Empty {\n    |                   |     help: `)` may belong here\n    |                   unclosed delimiter\n \n-error: expected one of `async`, `const`, `crate`, `default`, `extern`, `fn`, `pub`, `type`, `unsafe`, or `}`, found `)`\n+error: expected one of `async`, `const`, `crate`, `default`, `extern`, `fn`, `pub`, `type`, `unsafe`, `}`, or identifier, found `)`\n   --> $DIR/issue-58856-2.rs:11:1\n    |\n LL |     }\n-   |      - expected one of 10 possible tokens\n+   |      - expected one of 11 possible tokens\n LL | }\n    | ^ unexpected token\n "}, {"sha": "b2beb73503bb074c6fdd56ade5db145d2f272019", "filename": "src/test/ui/issues/issue-60075.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89f5dcfb4316891fafb34d211b7bebc4cf8638d0/src%2Ftest%2Fui%2Fissues%2Fissue-60075.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/89f5dcfb4316891fafb34d211b7bebc4cf8638d0/src%2Ftest%2Fui%2Fissues%2Fissue-60075.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-60075.stderr?ref=89f5dcfb4316891fafb34d211b7bebc4cf8638d0", "patch": "@@ -4,7 +4,7 @@ error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n LL |         });\n    |          ^ expected one of `.`, `;`, `?`, `else`, or an operator\n \n-error: expected one of `async`, `const`, `crate`, `default`, `extern`, `fn`, `pub`, `type`, `unsafe`, or `}`, found `;`\n+error: expected one of `async`, `const`, `crate`, `default`, `extern`, `fn`, `pub`, `type`, `unsafe`, `}`, or identifier, found `;`\n   --> $DIR/issue-60075.rs:6:11\n    |\n LL |     fn qux() -> Option<usize> {"}, {"sha": "a70163df1cb93209788d3400b1a8e325d203e959", "filename": "src/test/ui/macros/issue-54441.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/89f5dcfb4316891fafb34d211b7bebc4cf8638d0/src%2Ftest%2Fui%2Fmacros%2Fissue-54441.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89f5dcfb4316891fafb34d211b7bebc4cf8638d0/src%2Ftest%2Fui%2Fmacros%2Fissue-54441.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fissue-54441.rs?ref=89f5dcfb4316891fafb34d211b7bebc4cf8638d0", "patch": "@@ -1,6 +1,7 @@\n macro_rules! m {\n+    //~^ ERROR missing `fn`, `type`, or `static` for extern-item declaration\n     () => {\n-        let //~ ERROR expected\n+        let\n     };\n }\n "}, {"sha": "761e7aec7235a2a14a878695ceb4807e3684122b", "filename": "src/test/ui/macros/issue-54441.stderr", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/89f5dcfb4316891fafb34d211b7bebc4cf8638d0/src%2Ftest%2Fui%2Fmacros%2Fissue-54441.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/89f5dcfb4316891fafb34d211b7bebc4cf8638d0/src%2Ftest%2Fui%2Fmacros%2Fissue-54441.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fissue-54441.stderr?ref=89f5dcfb4316891fafb34d211b7bebc4cf8638d0", "patch": "@@ -1,13 +1,11 @@\n-error: expected one of `async`, `const`, `crate`, `extern`, `fn`, `pub`, `static`, `type`, or `unsafe`, found keyword `let`\n-  --> $DIR/issue-54441.rs:3:9\n+error: missing `fn`, `type`, or `static` for extern-item declaration\n+  --> $DIR/issue-54441.rs:1:1\n    |\n-LL |         let\n-   |         ^^^ expected one of 9 possible tokens\n-...\n-LL |     m!();\n-   |     ----- in this macro invocation\n-   |\n-   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+LL | / macro_rules! m {\n+LL | |\n+LL | |     () => {\n+LL | |         let\n+   | |________^ missing `fn`, `type`, or `static`\n \n error: aborting due to previous error\n "}, {"sha": "a2acb94372b8cec895dfdd46bad4516971a48383", "filename": "src/test/ui/parser/attr-before-eof.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89f5dcfb4316891fafb34d211b7bebc4cf8638d0/src%2Ftest%2Fui%2Fparser%2Fattr-before-eof.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/89f5dcfb4316891fafb34d211b7bebc4cf8638d0/src%2Ftest%2Fui%2Fparser%2Fattr-before-eof.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fattr-before-eof.stderr?ref=89f5dcfb4316891fafb34d211b7bebc4cf8638d0", "patch": "@@ -1,8 +1,8 @@\n error: expected item after attributes\n-  --> $DIR/attr-before-eof.rs:3:16\n+  --> $DIR/attr-before-eof.rs:3:1\n    |\n LL | #[derive(Debug)]\n-   |                ^\n+   | ^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "1c892eac08f3bd13ea9844c430c3b0f4c883a20a", "filename": "src/test/ui/parser/attr-dangling-in-mod.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89f5dcfb4316891fafb34d211b7bebc4cf8638d0/src%2Ftest%2Fui%2Fparser%2Fattr-dangling-in-mod.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/89f5dcfb4316891fafb34d211b7bebc4cf8638d0/src%2Ftest%2Fui%2Fparser%2Fattr-dangling-in-mod.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fattr-dangling-in-mod.stderr?ref=89f5dcfb4316891fafb34d211b7bebc4cf8638d0", "patch": "@@ -1,8 +1,8 @@\n error: expected item after attributes\n-  --> $DIR/attr-dangling-in-mod.rs:6:14\n+  --> $DIR/attr-dangling-in-mod.rs:6:1\n    |\n LL | #[foo = \"bar\"]\n-   |              ^\n+   | ^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "ea899dca7b221d453848bee5712b39131f189e49", "filename": "src/test/ui/parser/attrs-after-extern-mod.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/89f5dcfb4316891fafb34d211b7bebc4cf8638d0/src%2Ftest%2Fui%2Fparser%2Fattrs-after-extern-mod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89f5dcfb4316891fafb34d211b7bebc4cf8638d0/src%2Ftest%2Fui%2Fparser%2Fattrs-after-extern-mod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fattrs-after-extern-mod.rs?ref=89f5dcfb4316891fafb34d211b7bebc4cf8638d0", "patch": "@@ -1,13 +1,7 @@\n-// Constants (static variables) can be used to match in patterns, but mutable\n-// statics cannot. This ensures that there's some form of error if this is\n-// attempted.\n+// Make sure there's an error when given `extern { ... #[attr] }`.\n \n-extern crate libc;\n+fn main() {}\n \n extern {\n-    static mut rust_dbg_static_mut: libc::c_int;\n-    pub fn rust_dbg_static_mut_check_four();\n     #[cfg(stage37)] //~ ERROR expected item after attributes\n }\n-\n-pub fn main() {}"}, {"sha": "6060f3afe1e95c4b78cdea35f6a6190cee207240", "filename": "src/test/ui/parser/attrs-after-extern-mod.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89f5dcfb4316891fafb34d211b7bebc4cf8638d0/src%2Ftest%2Fui%2Fparser%2Fattrs-after-extern-mod.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/89f5dcfb4316891fafb34d211b7bebc4cf8638d0/src%2Ftest%2Fui%2Fparser%2Fattrs-after-extern-mod.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fattrs-after-extern-mod.stderr?ref=89f5dcfb4316891fafb34d211b7bebc4cf8638d0", "patch": "@@ -1,8 +1,8 @@\n error: expected item after attributes\n-  --> $DIR/attrs-after-extern-mod.rs:10:19\n+  --> $DIR/attrs-after-extern-mod.rs:6:5\n    |\n LL |     #[cfg(stage37)]\n-   |                   ^\n+   |     ^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "65ecb1ebbe919fbe0ef59ac42a85e8e5c5de5b18", "filename": "src/test/ui/parser/default.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/89f5dcfb4316891fafb34d211b7bebc4cf8638d0/src%2Ftest%2Fui%2Fparser%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89f5dcfb4316891fafb34d211b7bebc4cf8638d0/src%2Ftest%2Fui%2Fparser%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fdefault.rs?ref=89f5dcfb4316891fafb34d211b7bebc4cf8638d0", "patch": "@@ -19,7 +19,8 @@ impl Foo for u16 {\n }\n \n impl Foo for u32 { //~ ERROR not all trait items implemented, missing: `foo`\n-    default pub fn foo<T: Default>() -> T { T::default() } //~ ERROR expected one of\n+    default pub fn foo<T: Default>() -> T { T::default() }\n+    //~^ ERROR missing `fn`, `type`, or `const` for associated-item declaration\n }\n \n fn main() {}"}, {"sha": "ede9e4715186311e9e4d28aa261562059956ae37", "filename": "src/test/ui/parser/default.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/89f5dcfb4316891fafb34d211b7bebc4cf8638d0/src%2Ftest%2Fui%2Fparser%2Fdefault.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/89f5dcfb4316891fafb34d211b7bebc4cf8638d0/src%2Ftest%2Fui%2Fparser%2Fdefault.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fdefault.stderr?ref=89f5dcfb4316891fafb34d211b7bebc4cf8638d0", "patch": "@@ -1,8 +1,8 @@\n-error: expected one of `async`, `const`, `extern`, `fn`, `type`, or `unsafe`, found keyword `pub`\n-  --> $DIR/default.rs:22:13\n+error: missing `fn`, `type`, or `const` for associated-item declaration\n+  --> $DIR/default.rs:22:12\n    |\n LL |     default pub fn foo<T: Default>() -> T { T::default() }\n-   |             ^^^ expected one of `async`, `const`, `extern`, `fn`, `type`, or `unsafe`\n+   |            ^ missing `fn`, `type`, or `const`\n \n error[E0449]: unnecessary visibility qualifier\n   --> $DIR/default.rs:16:5"}, {"sha": "14fd01af2f98af15345c4a6995b4634bf32390e7", "filename": "src/test/ui/parser/doc-before-attr.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/89f5dcfb4316891fafb34d211b7bebc4cf8638d0/src%2Ftest%2Fui%2Fparser%2Fdoc-before-attr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/89f5dcfb4316891fafb34d211b7bebc4cf8638d0/src%2Ftest%2Fui%2Fparser%2Fdoc-before-attr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fdoc-before-attr.stderr?ref=89f5dcfb4316891fafb34d211b7bebc4cf8638d0", "patch": "@@ -1,8 +1,10 @@\n error: expected item after attributes\n-  --> $DIR/doc-before-attr.rs:4:16\n+  --> $DIR/doc-before-attr.rs:4:1\n    |\n+LL | /// hi\n+   | ------ other attributes here\n LL | #[derive(Debug)]\n-   |                ^\n+   | ^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "040206b80ffd05d1b6be8a863c981e0557044b64", "filename": "src/test/ui/parser/doc-before-extern-rbrace.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89f5dcfb4316891fafb34d211b7bebc4cf8638d0/src%2Ftest%2Fui%2Fparser%2Fdoc-before-extern-rbrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89f5dcfb4316891fafb34d211b7bebc4cf8638d0/src%2Ftest%2Fui%2Fparser%2Fdoc-before-extern-rbrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fdoc-before-extern-rbrace.rs?ref=89f5dcfb4316891fafb34d211b7bebc4cf8638d0", "patch": "@@ -1,4 +1,6 @@\n+fn main() {}\n+\n extern {\n     /// hi\n-    //~^ ERROR expected item after doc comment\n+    //~^ ERROR found a documentation comment that doesn't document anything\n }"}, {"sha": "0edceb268a7f5a37dff21b7fe900b0cf5f1e7464", "filename": "src/test/ui/parser/doc-before-extern-rbrace.stderr", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/89f5dcfb4316891fafb34d211b7bebc4cf8638d0/src%2Ftest%2Fui%2Fparser%2Fdoc-before-extern-rbrace.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/89f5dcfb4316891fafb34d211b7bebc4cf8638d0/src%2Ftest%2Fui%2Fparser%2Fdoc-before-extern-rbrace.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fdoc-before-extern-rbrace.stderr?ref=89f5dcfb4316891fafb34d211b7bebc4cf8638d0", "patch": "@@ -1,8 +1,11 @@\n-error: expected item after doc comment\n-  --> $DIR/doc-before-extern-rbrace.rs:2:5\n+error[E0584]: found a documentation comment that doesn't document anything\n+  --> $DIR/doc-before-extern-rbrace.rs:4:5\n    |\n LL |     /// hi\n    |     ^^^^^^ this doc comment doesn't document anything\n+   |\n+   = help: doc comments must come before what they document, maybe a comment was intended with `//`?\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0584`."}, {"sha": "246255a0a46751f2d25f6df6dd48e07fcbd63f64", "filename": "src/test/ui/parser/doc-inside-trait-item.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89f5dcfb4316891fafb34d211b7bebc4cf8638d0/src%2Ftest%2Fui%2Fparser%2Fdoc-inside-trait-item.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/89f5dcfb4316891fafb34d211b7bebc4cf8638d0/src%2Ftest%2Fui%2Fparser%2Fdoc-inside-trait-item.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fdoc-inside-trait-item.stderr?ref=89f5dcfb4316891fafb34d211b7bebc4cf8638d0", "patch": "@@ -2,7 +2,7 @@ error[E0584]: found a documentation comment that doesn't document anything\n   --> $DIR/doc-inside-trait-item.rs:3:5\n    |\n LL |     /// empty doc\n-   |     ^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^ this doc comment doesn't document anything\n    |\n    = help: doc comments must come before what they document, maybe a comment was intended with `//`?\n "}, {"sha": "1d271fa64b0ec31c02c3c7bbd999ec521198cca6", "filename": "src/test/ui/parser/duplicate-visibility.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89f5dcfb4316891fafb34d211b7bebc4cf8638d0/src%2Ftest%2Fui%2Fparser%2Fduplicate-visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89f5dcfb4316891fafb34d211b7bebc4cf8638d0/src%2Ftest%2Fui%2Fparser%2Fduplicate-visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fduplicate-visibility.rs?ref=89f5dcfb4316891fafb34d211b7bebc4cf8638d0", "patch": "@@ -1,4 +1,6 @@\n-// error-pattern: expected one of `(`, `async`, `const`, `extern`, `fn`\n+fn main() {}\n+\n extern {\n     pub pub fn foo();\n+    //~^ ERROR missing `fn`, `type`, or `static` for extern-item declaration\n }"}, {"sha": "36a3a1ed5a0ccbd972ab381b784ff0f4fab5d0df", "filename": "src/test/ui/parser/duplicate-visibility.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/89f5dcfb4316891fafb34d211b7bebc4cf8638d0/src%2Ftest%2Fui%2Fparser%2Fduplicate-visibility.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/89f5dcfb4316891fafb34d211b7bebc4cf8638d0/src%2Ftest%2Fui%2Fparser%2Fduplicate-visibility.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fduplicate-visibility.stderr?ref=89f5dcfb4316891fafb34d211b7bebc4cf8638d0", "patch": "@@ -1,8 +1,8 @@\n-error: expected one of `(`, `async`, `const`, `extern`, `fn`, `static`, `type`, or `unsafe`, found keyword `pub`\n-  --> $DIR/duplicate-visibility.rs:3:9\n+error: missing `fn`, `type`, or `static` for extern-item declaration\n+  --> $DIR/duplicate-visibility.rs:4:8\n    |\n LL |     pub pub fn foo();\n-   |         ^^^ expected one of 8 possible tokens\n+   |        ^ missing `fn`, `type`, or `static`\n \n error: aborting due to previous error\n "}, {"sha": "8dba6b362cdfaf4f5d2c161b01f01f2da8a0fe47", "filename": "src/test/ui/parser/inner-attr-in-trait-def.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/89f5dcfb4316891fafb34d211b7bebc4cf8638d0/src%2Ftest%2Fui%2Fparser%2Finner-attr-in-trait-def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89f5dcfb4316891fafb34d211b7bebc4cf8638d0/src%2Ftest%2Fui%2Fparser%2Finner-attr-in-trait-def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Finner-attr-in-trait-def.rs?ref=89f5dcfb4316891fafb34d211b7bebc4cf8638d0", "patch": "@@ -0,0 +1,9 @@\n+// check-pass\n+\n+#![deny(non_camel_case_types)]\n+\n+fn main() {}\n+\n+trait foo_bar {\n+    #![allow(non_camel_case_types)]\n+}"}, {"sha": "982a6be23ac5fb1814e14e99b9ba14fbcade81a6", "filename": "src/test/ui/parser/issue-19398.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/89f5dcfb4316891fafb34d211b7bebc4cf8638d0/src%2Ftest%2Fui%2Fparser%2Fissue-19398.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89f5dcfb4316891fafb34d211b7bebc4cf8638d0/src%2Ftest%2Fui%2Fparser%2Fissue-19398.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-19398.rs?ref=89f5dcfb4316891fafb34d211b7bebc4cf8638d0", "patch": "@@ -1,5 +1,6 @@\n trait T {\n-    extern \"Rust\" unsafe fn foo(); //~ ERROR expected one of `async`, `const`\n+    //~^ ERROR missing `fn`, `type`, or `const` for associated-item declaration\n+    extern \"Rust\" unsafe fn foo();\n }\n \n fn main() {}"}, {"sha": "2bd6ac3a4b3a49998821322f793ec265e2d5330b", "filename": "src/test/ui/parser/issue-19398.stderr", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/89f5dcfb4316891fafb34d211b7bebc4cf8638d0/src%2Ftest%2Fui%2Fparser%2Fissue-19398.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/89f5dcfb4316891fafb34d211b7bebc4cf8638d0/src%2Ftest%2Fui%2Fparser%2Fissue-19398.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-19398.stderr?ref=89f5dcfb4316891fafb34d211b7bebc4cf8638d0", "patch": "@@ -1,10 +1,11 @@\n-error: expected one of `async`, `const`, `crate`, `default`, `extern`, `fn`, `pub`, `type`, `unsafe`, or `}`, found keyword `extern`\n-  --> $DIR/issue-19398.rs:2:5\n+error: missing `fn`, `type`, or `const` for associated-item declaration\n+  --> $DIR/issue-19398.rs:1:10\n    |\n-LL | trait T {\n-   |          - expected one of 10 possible tokens\n-LL |     extern \"Rust\" unsafe fn foo();\n-   |     ^^^^^^ unexpected token\n+LL |   trait T {\n+   |  __________^\n+LL | |\n+LL | |     extern \"Rust\" unsafe fn foo();\n+   | |____^ missing `fn`, `type`, or `const`\n \n error: aborting due to previous error\n "}, {"sha": "168c7e76162bcffc6d42e3920b727a41a2cfde09", "filename": "src/test/ui/parser/issue-20711-2.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/89f5dcfb4316891fafb34d211b7bebc4cf8638d0/src%2Ftest%2Fui%2Fparser%2Fissue-20711-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89f5dcfb4316891fafb34d211b7bebc4cf8638d0/src%2Ftest%2Fui%2Fparser%2Fissue-20711-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-20711-2.rs?ref=89f5dcfb4316891fafb34d211b7bebc4cf8638d0", "patch": "@@ -4,6 +4,7 @@ impl Foo {\n     fn foo() {}\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-} //~ ERROR expected one of `async`, `const`, `crate`, `default`, `extern`, `fn`, `pub`, `type`, or\n+    //~^ ERROR expected item after attributes\n+}\n \n fn main() {}"}, {"sha": "10ef31584dec10a516f3431b086a88a359f224e3", "filename": "src/test/ui/parser/issue-20711-2.stderr", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/89f5dcfb4316891fafb34d211b7bebc4cf8638d0/src%2Ftest%2Fui%2Fparser%2Fissue-20711-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/89f5dcfb4316891fafb34d211b7bebc4cf8638d0/src%2Ftest%2Fui%2Fparser%2Fissue-20711-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-20711-2.stderr?ref=89f5dcfb4316891fafb34d211b7bebc4cf8638d0", "patch": "@@ -1,10 +1,8 @@\n-error: expected one of `async`, `const`, `crate`, `default`, `extern`, `fn`, `pub`, `type`, or `unsafe`, found `}`\n-  --> $DIR/issue-20711-2.rs:7:1\n+error: expected item after attributes\n+  --> $DIR/issue-20711-2.rs:6:5\n    |\n LL |     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-   |                                                  - expected one of 9 possible tokens\n-LL | }\n-   | ^ unexpected token\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "020bb79d6e74e075effabfe12367e482a4a63e04", "filename": "src/test/ui/parser/issue-20711.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/89f5dcfb4316891fafb34d211b7bebc4cf8638d0/src%2Ftest%2Fui%2Fparser%2Fissue-20711.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89f5dcfb4316891fafb34d211b7bebc4cf8638d0/src%2Ftest%2Fui%2Fparser%2Fissue-20711.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-20711.rs?ref=89f5dcfb4316891fafb34d211b7bebc4cf8638d0", "patch": "@@ -2,6 +2,7 @@ struct Foo;\n \n impl Foo {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-} //~ ERROR expected one of `async`, `const`, `crate`, `default`, `extern`, `fn`, `pub`, `type`, or\n+    //~^ ERROR expected item after attributes\n+}\n \n fn main() {}"}, {"sha": "66768de569418dca62594660747e107ee2449770", "filename": "src/test/ui/parser/issue-20711.stderr", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/89f5dcfb4316891fafb34d211b7bebc4cf8638d0/src%2Ftest%2Fui%2Fparser%2Fissue-20711.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/89f5dcfb4316891fafb34d211b7bebc4cf8638d0/src%2Ftest%2Fui%2Fparser%2Fissue-20711.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-20711.stderr?ref=89f5dcfb4316891fafb34d211b7bebc4cf8638d0", "patch": "@@ -1,10 +1,8 @@\n-error: expected one of `async`, `const`, `crate`, `default`, `extern`, `fn`, `pub`, `type`, or `unsafe`, found `}`\n-  --> $DIR/issue-20711.rs:5:1\n+error: expected item after attributes\n+  --> $DIR/issue-20711.rs:4:5\n    |\n LL |     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-   |                                                  - expected one of 9 possible tokens\n-LL | }\n-   | ^ unexpected token\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "25c1efe35ae11cb7f31b806e48f5f439d7e262dd", "filename": "src/test/ui/parser/issue-32446.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89f5dcfb4316891fafb34d211b7bebc4cf8638d0/src%2Ftest%2Fui%2Fparser%2Fissue-32446.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/89f5dcfb4316891fafb34d211b7bebc4cf8638d0/src%2Ftest%2Fui%2Fparser%2Fissue-32446.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-32446.stderr?ref=89f5dcfb4316891fafb34d211b7bebc4cf8638d0", "patch": "@@ -1,8 +1,8 @@\n-error: expected one of `async`, `const`, `crate`, `default`, `extern`, `fn`, `pub`, `type`, `unsafe`, or `}`, found `...`\n+error: expected one of `async`, `const`, `crate`, `default`, `extern`, `fn`, `pub`, `type`, `unsafe`, `}`, or identifier, found `...`\n   --> $DIR/issue-32446.rs:4:11\n    |\n LL | trait T { ... }\n-   |           ^^^ expected one of 10 possible tokens\n+   |           ^^^ expected one of 11 possible tokens\n \n error: aborting due to previous error\n "}, {"sha": "327bc65818fa9ada1fc968b2677a5f4005f8df84", "filename": "src/test/ui/parser/issue-41155.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89f5dcfb4316891fafb34d211b7bebc4cf8638d0/src%2Ftest%2Fui%2Fparser%2Fissue-41155.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/89f5dcfb4316891fafb34d211b7bebc4cf8638d0/src%2Ftest%2Fui%2Fparser%2Fissue-41155.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-41155.stderr?ref=89f5dcfb4316891fafb34d211b7bebc4cf8638d0", "patch": "@@ -1,8 +1,8 @@\n-error: expected one of `(`, `async`, `const`, `default`, `extern`, `fn`, `type`, or `unsafe`, found `}`\n+error: expected one of `(`, `async`, `const`, `default`, `extern`, `fn`, `type`, `unsafe`, or identifier, found `}`\n   --> $DIR/issue-41155.rs:5:1\n    |\n LL |     pub\n-   |        - expected one of 8 possible tokens\n+   |        - expected one of 9 possible tokens\n LL | }\n    | ^ unexpected token\n "}, {"sha": "8a44ee761ed677e7a65b5b90c01af6bd11eaf7a3", "filename": "src/test/ui/parser/issue-58094-missing-right-square-bracket.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89f5dcfb4316891fafb34d211b7bebc4cf8638d0/src%2Ftest%2Fui%2Fparser%2Fissue-58094-missing-right-square-bracket.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/89f5dcfb4316891fafb34d211b7bebc4cf8638d0/src%2Ftest%2Fui%2Fparser%2Fissue-58094-missing-right-square-bracket.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-58094-missing-right-square-bracket.stderr?ref=89f5dcfb4316891fafb34d211b7bebc4cf8638d0", "patch": "@@ -7,10 +7,10 @@ LL | #[\u0405\n    |  unclosed delimiter\n \n error: expected item after attributes\n-  --> $DIR/issue-58094-missing-right-square-bracket.rs:4:4\n+  --> $DIR/issue-58094-missing-right-square-bracket.rs:4:1\n    |\n LL | #[\u0405\n-   |    ^\n+   | ^^^\n \n error: aborting due to 2 previous errors\n "}, {"sha": "f5f8a01e6a440eeea4fe03007d1579275d5e46cc", "filename": "src/test/ui/parser/macro/pub-item-macro.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/89f5dcfb4316891fafb34d211b7bebc4cf8638d0/src%2Ftest%2Fui%2Fparser%2Fmacro%2Fpub-item-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89f5dcfb4316891fafb34d211b7bebc4cf8638d0/src%2Ftest%2Fui%2Fparser%2Fmacro%2Fpub-item-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fmacro%2Fpub-item-macro.rs?ref=89f5dcfb4316891fafb34d211b7bebc4cf8638d0", "patch": "@@ -1,12 +1,15 @@\n // Issue #14660\n \n-macro_rules! priv_x { () => {\n-    static x: u32 = 0;\n-}}\n+macro_rules! priv_x {\n+    () => {\n+        static x: u32 = 0;\n+    };\n+}\n \n macro_rules! pub_x { () => {\n     pub priv_x!(); //~ ERROR can't qualify macro invocation with `pub`\n-    //~^ HELP try adjusting the macro to put `pub` inside the invocation\n+    //~^ HELP remove the visibility\n+    //~| HELP try adjusting the macro to put `pub` inside the invocation\n }}\n \n mod foo {"}, {"sha": "4ff96532e03a82d1fc9330f8fd2de093c5c95e7f", "filename": "src/test/ui/parser/macro/pub-item-macro.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/89f5dcfb4316891fafb34d211b7bebc4cf8638d0/src%2Ftest%2Fui%2Fparser%2Fmacro%2Fpub-item-macro.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/89f5dcfb4316891fafb34d211b7bebc4cf8638d0/src%2Ftest%2Fui%2Fparser%2Fmacro%2Fpub-item-macro.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fmacro%2Fpub-item-macro.stderr?ref=89f5dcfb4316891fafb34d211b7bebc4cf8638d0", "patch": "@@ -1,8 +1,8 @@\n error: can't qualify macro invocation with `pub`\n-  --> $DIR/pub-item-macro.rs:8:5\n+  --> $DIR/pub-item-macro.rs:10:5\n    |\n LL |     pub priv_x!();\n-   |     ^^^\n+   |     ^^^ help: remove the visibility\n ...\n LL |     pub_x!();\n    |     --------- in this macro invocation\n@@ -11,16 +11,16 @@ LL |     pub_x!();\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0603]: static `x` is private\n-  --> $DIR/pub-item-macro.rs:17:23\n+  --> $DIR/pub-item-macro.rs:20:23\n    |\n LL |     let y: u32 = foo::x;\n    |                       ^ this static is private\n    |\n note: the static `x` is defined here\n-  --> $DIR/pub-item-macro.rs:4:5\n+  --> $DIR/pub-item-macro.rs:5:9\n    |\n-LL |     static x: u32 = 0;\n-   |     ^^^^^^^^^^^^^^^^^^\n+LL |         static x: u32 = 0;\n+   |         ^^^^^^^^^^^^^^^^^^\n ...\n LL |     pub_x!();\n    |     --------- in this macro invocation"}, {"sha": "9d05e85bcc00e06e26881230e4678d256d9c0fc9", "filename": "src/test/ui/parser/macro/trait-non-item-macros.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89f5dcfb4316891fafb34d211b7bebc4cf8638d0/src%2Ftest%2Fui%2Fparser%2Fmacro%2Ftrait-non-item-macros.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/89f5dcfb4316891fafb34d211b7bebc4cf8638d0/src%2Ftest%2Fui%2Fparser%2Fmacro%2Ftrait-non-item-macros.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fmacro%2Ftrait-non-item-macros.stderr?ref=89f5dcfb4316891fafb34d211b7bebc4cf8638d0", "patch": "@@ -1,8 +1,8 @@\n-error: expected one of `async`, `const`, `crate`, `default`, `extern`, `fn`, `pub`, `type`, or `unsafe`, found `2`\n+error: expected one of `async`, `const`, `crate`, `default`, `extern`, `fn`, `pub`, `type`, `unsafe`, or identifier, found `2`\n   --> $DIR/trait-non-item-macros.rs:2:19\n    |\n LL |     ($a:expr) => ($a)\n-   |                   ^^ expected one of 9 possible tokens\n+   |                   ^^ expected one of 10 possible tokens\n ...\n LL |     bah!(2);\n    |     -------- in this macro invocation"}, {"sha": "592215030f552f2030ee4ee45abccae64ec5c7b4", "filename": "src/test/ui/parser/mismatched-braces/missing-close-brace-in-impl-trait.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/89f5dcfb4316891fafb34d211b7bebc4cf8638d0/src%2Ftest%2Fui%2Fparser%2Fmismatched-braces%2Fmissing-close-brace-in-impl-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89f5dcfb4316891fafb34d211b7bebc4cf8638d0/src%2Ftest%2Fui%2Fparser%2Fmismatched-braces%2Fmissing-close-brace-in-impl-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fmismatched-braces%2Fmissing-close-brace-in-impl-trait.rs?ref=89f5dcfb4316891fafb34d211b7bebc4cf8638d0", "patch": "@@ -1,12 +1,14 @@\n+fn main() {}\n+\n impl T for () { //~ ERROR cannot find trait `T` in this scope\n \n fn foo(&self) {}\n+//~^ ERROR missing `fn`, `type`, or `const`\n \n-trait T { //~ ERROR expected one of\n+trait T {\n     fn foo(&self);\n }\n \n pub(crate) struct Bar<T>();\n \n-fn main() {}\n //~ ERROR this file contains an unclosed delimiter"}, {"sha": "1ec54525105f66598efdaefd1ad2c7418cd129a8", "filename": "src/test/ui/parser/mismatched-braces/missing-close-brace-in-impl-trait.stderr", "status": "modified", "additions": 10, "deletions": 15, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/89f5dcfb4316891fafb34d211b7bebc4cf8638d0/src%2Ftest%2Fui%2Fparser%2Fmismatched-braces%2Fmissing-close-brace-in-impl-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/89f5dcfb4316891fafb34d211b7bebc4cf8638d0/src%2Ftest%2Fui%2Fparser%2Fmismatched-braces%2Fmissing-close-brace-in-impl-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fmismatched-braces%2Fmissing-close-brace-in-impl-trait.stderr?ref=89f5dcfb4316891fafb34d211b7bebc4cf8638d0", "patch": "@@ -1,29 +1,24 @@\n error: this file contains an unclosed delimiter\n-  --> $DIR/missing-close-brace-in-impl-trait.rs:12:52\n+  --> $DIR/missing-close-brace-in-impl-trait.rs:14:52\n    |\n LL | impl T for () {\n    |               - unclosed delimiter\n ...\n LL |\n    |                                                    ^\n \n-error: expected one of `async`, `const`, `crate`, `default`, `extern`, `fn`, `pub`, `type`, `unsafe`, or `}`, found keyword `trait`\n-  --> $DIR/missing-close-brace-in-impl-trait.rs:5:1\n+error: missing `fn`, `type`, or `const` for associated-item declaration\n+  --> $DIR/missing-close-brace-in-impl-trait.rs:5:17\n    |\n-LL | impl T for () {\n-   |               - unclosed delimiter\n-LL | \n-LL | fn foo(&self) {}\n-   |                 -\n-   |                 |\n-   |                 expected one of 10 possible tokens\n-   |                 help: `}` may belong here\n-LL | \n-LL | trait T {\n-   | ^^^^^ unexpected token\n+LL |   fn foo(&self) {}\n+   |  _________________^\n+LL | |\n+LL | |\n+LL | | trait T {\n+   | |_ missing `fn`, `type`, or `const`\n \n error[E0405]: cannot find trait `T` in this scope\n-  --> $DIR/missing-close-brace-in-impl-trait.rs:1:6\n+  --> $DIR/missing-close-brace-in-impl-trait.rs:3:6\n    |\n LL | impl T for () {\n    |      ^ not found in this scope"}, {"sha": "077e33471942741c42f993dde3e85ca95945f6cc", "filename": "src/test/ui/parser/mismatched-braces/missing-close-brace-in-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89f5dcfb4316891fafb34d211b7bebc4cf8638d0/src%2Ftest%2Fui%2Fparser%2Fmismatched-braces%2Fmissing-close-brace-in-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89f5dcfb4316891fafb34d211b7bebc4cf8638d0/src%2Ftest%2Fui%2Fparser%2Fmismatched-braces%2Fmissing-close-brace-in-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fmismatched-braces%2Fmissing-close-brace-in-trait.rs?ref=89f5dcfb4316891fafb34d211b7bebc4cf8638d0", "patch": "@@ -3,7 +3,7 @@ trait T {\n     fn foo(&self);\n \n pub(crate) struct Bar<T>();\n-//~^ ERROR expected one of\n+//~^ ERROR missing `fn`, `type`, or `const`\n \n impl T for Bar<usize> {\n fn foo(&self) {}"}, {"sha": "1bb153c461d90b20dd1feab86f6bfecf1b3cc4d6", "filename": "src/test/ui/parser/mismatched-braces/missing-close-brace-in-trait.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/89f5dcfb4316891fafb34d211b7bebc4cf8638d0/src%2Ftest%2Fui%2Fparser%2Fmismatched-braces%2Fmissing-close-brace-in-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/89f5dcfb4316891fafb34d211b7bebc4cf8638d0/src%2Ftest%2Fui%2Fparser%2Fmismatched-braces%2Fmissing-close-brace-in-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fmismatched-braces%2Fmissing-close-brace-in-trait.stderr?ref=89f5dcfb4316891fafb34d211b7bebc4cf8638d0", "patch": "@@ -7,11 +7,11 @@ LL | trait T {\n LL | fn main() {}\n    |                                                                 ^\n \n-error: expected one of `async`, `const`, `default`, `extern`, `fn`, `type`, or `unsafe`, found keyword `struct`\n-  --> $DIR/missing-close-brace-in-trait.rs:5:12\n+error: missing `fn`, `type`, or `const` for associated-item declaration\n+  --> $DIR/missing-close-brace-in-trait.rs:5:11\n    |\n LL | pub(crate) struct Bar<T>();\n-   |            ^^^^^^ expected one of 7 possible tokens\n+   |           ^ missing `fn`, `type`, or `const`\n \n error[E0601]: `main` function not found in crate `missing_close_brace_in_trait`\n   --> $DIR/missing-close-brace-in-trait.rs:1:1"}, {"sha": "0183bdcf6220bcf41a660803e46613ff2b8dd58d", "filename": "src/test/ui/parser/pub-method-macro.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/89f5dcfb4316891fafb34d211b7bebc4cf8638d0/src%2Ftest%2Fui%2Fparser%2Fpub-method-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89f5dcfb4316891fafb34d211b7bebc4cf8638d0/src%2Ftest%2Fui%2Fparser%2Fpub-method-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fpub-method-macro.rs?ref=89f5dcfb4316891fafb34d211b7bebc4cf8638d0", "patch": "@@ -15,7 +15,8 @@ mod bleh {\n \n     impl S {\n         pub defn!(f); //~ ERROR can't qualify macro invocation with `pub`\n-        //~^ HELP try adjusting the macro to put `pub` inside the invocation\n+        //~^ HELP remove the visibility\n+        //~| HELP try adjusting the macro to put `pub` inside the invocation\n     }\n }\n "}, {"sha": "7c7a909267a1cfecd4c53e209444643430ca723a", "filename": "src/test/ui/parser/pub-method-macro.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89f5dcfb4316891fafb34d211b7bebc4cf8638d0/src%2Ftest%2Fui%2Fparser%2Fpub-method-macro.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/89f5dcfb4316891fafb34d211b7bebc4cf8638d0/src%2Ftest%2Fui%2Fparser%2Fpub-method-macro.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fpub-method-macro.stderr?ref=89f5dcfb4316891fafb34d211b7bebc4cf8638d0", "patch": "@@ -2,7 +2,7 @@ error: can't qualify macro invocation with `pub`\n   --> $DIR/pub-method-macro.rs:17:9\n    |\n LL |         pub defn!(f);\n-   |         ^^^\n+   |         ^^^ help: remove the visibility\n    |\n    = help: try adjusting the macro to put `pub` inside the invocation\n "}, {"sha": "9e12222f3fd8b54d6b74c63cfd47c6685b050158", "filename": "src/test/ui/parser/removed-syntax-static-fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/89f5dcfb4316891fafb34d211b7bebc4cf8638d0/src%2Ftest%2Fui%2Fparser%2Fremoved-syntax-static-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89f5dcfb4316891fafb34d211b7bebc4cf8638d0/src%2Ftest%2Fui%2Fparser%2Fremoved-syntax-static-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fremoved-syntax-static-fn.rs?ref=89f5dcfb4316891fafb34d211b7bebc4cf8638d0", "patch": "@@ -1,8 +1,8 @@\n struct S;\n \n impl S {\n+    //~^ ERROR missing `fn`, `type`, or `const` for associated-item declaration\n     static fn f() {}\n-    //~^ ERROR expected one of `async`, `const`, `crate`, `default`, `extern`, `fn`, `pub`, `type`,\n }\n \n fn main() {}"}, {"sha": "5edf88026fbece1eb122ccaf4ab803568b12eb59", "filename": "src/test/ui/parser/removed-syntax-static-fn.stderr", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/89f5dcfb4316891fafb34d211b7bebc4cf8638d0/src%2Ftest%2Fui%2Fparser%2Fremoved-syntax-static-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/89f5dcfb4316891fafb34d211b7bebc4cf8638d0/src%2Ftest%2Fui%2Fparser%2Fremoved-syntax-static-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fremoved-syntax-static-fn.stderr?ref=89f5dcfb4316891fafb34d211b7bebc4cf8638d0", "patch": "@@ -1,10 +1,11 @@\n-error: expected one of `async`, `const`, `crate`, `default`, `extern`, `fn`, `pub`, `type`, `unsafe`, or `}`, found keyword `static`\n-  --> $DIR/removed-syntax-static-fn.rs:4:5\n+error: missing `fn`, `type`, or `const` for associated-item declaration\n+  --> $DIR/removed-syntax-static-fn.rs:3:9\n    |\n-LL | impl S {\n-   |         - expected one of 10 possible tokens\n-LL |     static fn f() {}\n-   |     ^^^^^^ unexpected token\n+LL |   impl S {\n+   |  _________^\n+LL | |\n+LL | |     static fn f() {}\n+   | |____^ missing `fn`, `type`, or `const`\n \n error: aborting due to previous error\n "}, {"sha": "3f8904fbe79d878e1fc261ea4162b1fd00ad5f4d", "filename": "src/test/ui/pub/pub-restricted-error-fn.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/89f5dcfb4316891fafb34d211b7bebc4cf8638d0/src%2Ftest%2Fui%2Fpub%2Fpub-restricted-error-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89f5dcfb4316891fafb34d211b7bebc4cf8638d0/src%2Ftest%2Fui%2Fpub%2Fpub-restricted-error-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpub%2Fpub-restricted-error-fn.rs?ref=89f5dcfb4316891fafb34d211b7bebc4cf8638d0", "patch": "@@ -1,3 +1,2 @@\n-#![feature(pub_restricted)]\n-\n pub(crate) () fn foo() {} //~ unmatched visibility\n+//~^ ERROR expected item, found `(`"}, {"sha": "c0168b02da607550a36e1d4610d74eed46281530", "filename": "src/test/ui/pub/pub-restricted-error-fn.stderr", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/89f5dcfb4316891fafb34d211b7bebc4cf8638d0/src%2Ftest%2Fui%2Fpub%2Fpub-restricted-error-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/89f5dcfb4316891fafb34d211b7bebc4cf8638d0/src%2Ftest%2Fui%2Fpub%2Fpub-restricted-error-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpub%2Fpub-restricted-error-fn.stderr?ref=89f5dcfb4316891fafb34d211b7bebc4cf8638d0", "patch": "@@ -1,8 +1,16 @@\n-error: unmatched visibility `pub`\n-  --> $DIR/pub-restricted-error-fn.rs:3:10\n+error: unmatched visibility `pub(crate)`\n+  --> $DIR/pub-restricted-error-fn.rs:1:1\n    |\n LL | pub(crate) () fn foo() {}\n-   |          ^\n+   | ^^^^^^^^^^ the unmatched visibility\n+   |\n+   = help: you likely meant to define an item, e.g., `pub(crate) fn foo() {}`\n+\n+error: expected item, found `(`\n+  --> $DIR/pub-restricted-error-fn.rs:1:12\n+   |\n+LL | pub(crate) () fn foo() {}\n+   |            ^ expected item\n \n-error: aborting due to previous error\n+error: aborting due to 2 previous errors\n "}]}