{"sha": "e355a330772a7b605649651f7e670ea636e73a6e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUzNTVhMzMwNzcyYTdiNjA1NjQ5NjUxZjdlNjcwZWE2MzZlNzNhNmU=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2020-02-22T22:29:36Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2020-02-23T14:35:48Z"}, "message": "Deduplicate identifier printing a bit", "tree": {"sha": "7cf6c115a3355c67f1d87f22d3b16b6d0269c7d1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7cf6c115a3355c67f1d87f22d3b16b6d0269c7d1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e355a330772a7b605649651f7e670ea636e73a6e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e355a330772a7b605649651f7e670ea636e73a6e", "html_url": "https://github.com/rust-lang/rust/commit/e355a330772a7b605649651f7e670ea636e73a6e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e355a330772a7b605649651f7e670ea636e73a6e/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9c230f39c159cf7645bc4dbab511b9586d033021", "url": "https://api.github.com/repos/rust-lang/rust/commits/9c230f39c159cf7645bc4dbab511b9586d033021", "html_url": "https://github.com/rust-lang/rust/commit/9c230f39c159cf7645bc4dbab511b9586d033021"}], "stats": {"total": 115, "additions": 66, "deletions": 49}, "files": [{"sha": "4e69253c34bf6d04a611b3926091887e9ea79501", "filename": "src/librustc_ast_pretty/pprust.rs", "status": "modified", "additions": 4, "deletions": 38, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/e355a330772a7b605649651f7e670ea636e73a6e/src%2Flibrustc_ast_pretty%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e355a330772a7b605649651f7e670ea636e73a6e/src%2Flibrustc_ast_pretty%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_pretty%2Fpprust.rs?ref=e355a330772a7b605649651f7e670ea636e73a6e", "patch": "@@ -3,7 +3,7 @@ use crate::pp::{self, Breaks};\n \n use rustc_span::edition::Edition;\n use rustc_span::source_map::{SourceMap, Spanned};\n-use rustc_span::symbol::{kw, sym};\n+use rustc_span::symbol::{kw, sym, IdentPrinter};\n use rustc_span::{BytePos, FileName, Span};\n use syntax::ast::{self, BlockCheckMode, PatKind, RangeEnd, RangeSyntax};\n use syntax::ast::{Attribute, GenericArg, MacArgs};\n@@ -196,40 +196,6 @@ pub fn literal_to_string(lit: token::Lit) -> String {\n     out\n }\n \n-/// Print an ident from AST, `$crate` is converted into its respective crate name.\n-pub fn ast_ident_to_string(ident: ast::Ident, is_raw: bool) -> String {\n-    ident_to_string(ident.name, is_raw, Some(ident.span))\n-}\n-\n-// AST pretty-printer is used as a fallback for turning AST structures into token streams for\n-// proc macros. Additionally, proc macros may stringify their input and expect it survive the\n-// stringification (especially true for proc macro derives written between Rust 1.15 and 1.30).\n-// So we need to somehow pretty-print `$crate` in a way preserving at least some of its\n-// hygiene data, most importantly name of the crate it refers to.\n-// As a result we print `$crate` as `crate` if it refers to the local crate\n-// and as `::other_crate_name` if it refers to some other crate.\n-// Note, that this is only done if the ident token is printed from inside of AST pretty-pringing,\n-// but not otherwise. Pretty-printing is the only way for proc macros to discover token contents,\n-// so we should not perform this lossy conversion if the top level call to the pretty-printer was\n-// done for a token stream or a single token.\n-fn ident_to_string(name: ast::Name, is_raw: bool, convert_dollar_crate: Option<Span>) -> String {\n-    if is_raw {\n-        format!(\"r#{}\", name)\n-    } else {\n-        if name == kw::DollarCrate {\n-            if let Some(span) = convert_dollar_crate {\n-                let converted = span.ctxt().dollar_crate_name();\n-                return if converted.is_path_segment_keyword() {\n-                    converted.to_string()\n-                } else {\n-                    format!(\"::{}\", converted)\n-                };\n-            }\n-        }\n-        name.to_string()\n-    }\n-}\n-\n /// Print the token kind precisely, without converting `$crate` into its respective crate name.\n pub fn token_kind_to_string(tok: &TokenKind) -> String {\n     token_kind_to_string_ext(tok, None)\n@@ -280,7 +246,7 @@ fn token_kind_to_string_ext(tok: &TokenKind, convert_dollar_crate: Option<Span>)\n         token::Literal(lit) => literal_to_string(lit),\n \n         /* Name components */\n-        token::Ident(s, is_raw) => ident_to_string(s, is_raw, convert_dollar_crate),\n+        token::Ident(s, is_raw) => IdentPrinter::new(s, is_raw, convert_dollar_crate).to_string(),\n         token::Lifetime(s) => s.to_string(),\n \n         /* Other */\n@@ -315,7 +281,7 @@ pub fn nonterminal_to_string(nt: &Nonterminal) -> String {\n         token::NtBlock(ref e) => block_to_string(e),\n         token::NtStmt(ref e) => stmt_to_string(e),\n         token::NtPat(ref e) => pat_to_string(e),\n-        token::NtIdent(e, is_raw) => ast_ident_to_string(e, is_raw),\n+        token::NtIdent(e, is_raw) => IdentPrinter::for_ast_ident(e, is_raw).to_string(),\n         token::NtLifetime(e) => e.to_string(),\n         token::NtLiteral(ref e) => expr_to_string(e),\n         token::NtTT(ref tree) => tt_to_string(tree.clone()),\n@@ -819,7 +785,7 @@ impl<'a> PrintState<'a> for State<'a> {\n     }\n \n     fn print_ident(&mut self, ident: ast::Ident) {\n-        self.s.word(ast_ident_to_string(ident, ident.is_raw_guess()));\n+        self.s.word(IdentPrinter::for_ast_ident(ident, ident.is_raw_guess()).to_string());\n         self.ann.post(self, AnnNode::Ident(&ident))\n     }\n "}, {"sha": "92bd8b1ba5f8484b889af0a43ca6ba9145f18816", "filename": "src/librustc_hir/print.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e355a330772a7b605649651f7e670ea636e73a6e/src%2Flibrustc_hir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e355a330772a7b605649651f7e670ea636e73a6e/src%2Flibrustc_hir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fprint.rs?ref=e355a330772a7b605649651f7e670ea636e73a6e", "patch": "@@ -1,8 +1,8 @@\n use rustc_ast_pretty::pp::Breaks::{Consistent, Inconsistent};\n use rustc_ast_pretty::pp::{self, Breaks};\n-use rustc_ast_pretty::pprust::{self, Comments, PrintState};\n+use rustc_ast_pretty::pprust::{Comments, PrintState};\n use rustc_span::source_map::{SourceMap, Spanned};\n-use rustc_span::symbol::kw;\n+use rustc_span::symbol::{kw, IdentPrinter};\n use rustc_span::{self, BytePos, FileName};\n use rustc_target::spec::abi::Abi;\n use syntax::ast;\n@@ -126,7 +126,7 @@ impl<'a> PrintState<'a> for State<'a> {\n     }\n \n     fn print_ident(&mut self, ident: ast::Ident) {\n-        self.s.word(pprust::ast_ident_to_string(ident, ident.is_raw_guess()));\n+        self.s.word(IdentPrinter::for_ast_ident(ident, ident.is_raw_guess()).to_string());\n         self.ann.post(self, AnnNode::Name(&ident.name))\n     }\n "}, {"sha": "b8e5ea97f4e4792f1d6ae642dc8b9d0e56dfb986", "filename": "src/librustc_span/symbol.rs", "status": "modified", "additions": 59, "deletions": 8, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/e355a330772a7b605649651f7e670ea636e73a6e/src%2Flibrustc_span%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e355a330772a7b605649651f7e670ea636e73a6e/src%2Flibrustc_span%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fsymbol.rs?ref=e355a330772a7b605649651f7e670ea636e73a6e", "patch": "@@ -893,19 +893,17 @@ impl Hash for Ident {\n \n impl fmt::Debug for Ident {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        if self.is_raw_guess() {\n-            write!(f, \"r#\")?;\n-        }\n-        write!(f, \"{}{:?}\", self.name, self.span.ctxt())\n+        fmt::Display::fmt(self, f)?;\n+        fmt::Debug::fmt(&self.span.ctxt(), f)\n     }\n }\n \n+/// This implementation is supposed to be used in error messages, so it's expected to be identical\n+/// to printing the original identifier token written in source code (`token_to_string`),\n+/// except that AST identifiers don't keep the rawness flag, so we have to guess it.\n impl fmt::Display for Ident {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        if self.is_raw_guess() {\n-            write!(f, \"r#\")?;\n-        }\n-        fmt::Display::fmt(&self.name, f)\n+        fmt::Display::fmt(&IdentPrinter::new(self.name, self.is_raw_guess(), None), f)\n     }\n }\n \n@@ -929,6 +927,59 @@ impl UseSpecializedDecodable for Ident {\n     }\n }\n \n+/// This is the most general way to print identifiers.\n+/// AST pretty-printer is used as a fallback for turning AST structures into token streams for\n+/// proc macros. Additionally, proc macros may stringify their input and expect it survive the\n+/// stringification (especially true for proc macro derives written between Rust 1.15 and 1.30).\n+/// So we need to somehow pretty-print `$crate` in a way preserving at least some of its\n+/// hygiene data, most importantly name of the crate it refers to.\n+/// As a result we print `$crate` as `crate` if it refers to the local crate\n+/// and as `::other_crate_name` if it refers to some other crate.\n+/// Note, that this is only done if the ident token is printed from inside of AST pretty-pringing,\n+/// but not otherwise. Pretty-printing is the only way for proc macros to discover token contents,\n+/// so we should not perform this lossy conversion if the top level call to the pretty-printer was\n+/// done for a token stream or a single token.\n+pub struct IdentPrinter {\n+    symbol: Symbol,\n+    is_raw: bool,\n+    /// Span used for retrieving the crate name to which `$crate` refers to,\n+    /// if this field is `None` then the `$crate` conversion doesn't happen.\n+    convert_dollar_crate: Option<Span>,\n+}\n+\n+impl IdentPrinter {\n+    /// The most general `IdentPrinter` constructor. Do not use this.\n+    pub fn new(symbol: Symbol, is_raw: bool, convert_dollar_crate: Option<Span>) -> IdentPrinter {\n+        IdentPrinter { symbol, is_raw, convert_dollar_crate }\n+    }\n+\n+    /// This implementation is supposed to be used when printing identifiers\n+    /// as a part of pretty-printing for larger AST pieces.\n+    /// Do not use this either.\n+    pub fn for_ast_ident(ident: Ident, is_raw: bool) -> IdentPrinter {\n+        IdentPrinter::new(ident.name, is_raw, Some(ident.span))\n+    }\n+}\n+\n+impl fmt::Display for IdentPrinter {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        if self.is_raw {\n+            f.write_str(\"r#\")?;\n+        } else {\n+            if self.symbol == kw::DollarCrate {\n+                if let Some(span) = self.convert_dollar_crate {\n+                    let converted = span.ctxt().dollar_crate_name();\n+                    if !converted.is_path_segment_keyword() {\n+                        f.write_str(\"::\")?;\n+                    }\n+                    return fmt::Display::fmt(&converted, f);\n+                }\n+            }\n+        }\n+        fmt::Display::fmt(&self.symbol, f)\n+    }\n+}\n+\n /// An interned string.\n ///\n /// Internally, a `Symbol` is implemented as an index, and all operations"}]}