{"sha": "1fce8b6ba32bebba36d588d07781e9e578845728", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFmY2U4YjZiYTMyYmViYmEzNmQ1ODhkMDc3ODFlOWU1Nzg4NDU3Mjg=", "commit": {"author": {"name": "David Lattimore", "email": "dml@google.com", "date": "2020-07-03T02:57:17Z"}, "committer": {"name": "David Lattimore", "email": "dml@google.com", "date": "2020-07-24T11:34:00Z"}, "message": "SSR: Change the way rules are stored internally.\n\nPreviously we had:\n\n- Multiple rules\n  - Each rule had its pattern parsed as an expression, path etc\n\nThis meant that there were two levels at which there could be multiple\nrules.\n\nNow we just have multiple rules. If a pattern can parse as more than one\nkind of thing, then they get stored as multiple separate rules.\n\nWe also now don't have separate fields for the different kinds of things\nthat a pattern can parse as. This makes adding new kinds of things\nsimpler.\n\nPreviously, add_search_pattern would construct a rule with a dummy\nreplacement. Now the replacement is an Option. This is slightly cleaner\nand also opens the way for parsing the replacement template as the same\nkind of thing as the search pattern.", "tree": {"sha": "c027096421e49a7e0279711e0ccd7491ca3d6a9a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c027096421e49a7e0279711e0ccd7491ca3d6a9a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1fce8b6ba32bebba36d588d07781e9e578845728", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1fce8b6ba32bebba36d588d07781e9e578845728", "html_url": "https://github.com/rust-lang/rust/commit/1fce8b6ba32bebba36d588d07781e9e578845728", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1fce8b6ba32bebba36d588d07781e9e578845728/comments", "author": {"login": "davidlattimore", "id": 8983542, "node_id": "MDQ6VXNlcjg5ODM1NDI=", "avatar_url": "https://avatars.githubusercontent.com/u/8983542?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidlattimore", "html_url": "https://github.com/davidlattimore", "followers_url": "https://api.github.com/users/davidlattimore/followers", "following_url": "https://api.github.com/users/davidlattimore/following{/other_user}", "gists_url": "https://api.github.com/users/davidlattimore/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidlattimore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidlattimore/subscriptions", "organizations_url": "https://api.github.com/users/davidlattimore/orgs", "repos_url": "https://api.github.com/users/davidlattimore/repos", "events_url": "https://api.github.com/users/davidlattimore/events{/privacy}", "received_events_url": "https://api.github.com/users/davidlattimore/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidlattimore", "id": 8983542, "node_id": "MDQ6VXNlcjg5ODM1NDI=", "avatar_url": "https://avatars.githubusercontent.com/u/8983542?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidlattimore", "html_url": "https://github.com/davidlattimore", "followers_url": "https://api.github.com/users/davidlattimore/followers", "following_url": "https://api.github.com/users/davidlattimore/following{/other_user}", "gists_url": "https://api.github.com/users/davidlattimore/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidlattimore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidlattimore/subscriptions", "organizations_url": "https://api.github.com/users/davidlattimore/orgs", "repos_url": "https://api.github.com/users/davidlattimore/repos", "events_url": "https://api.github.com/users/davidlattimore/events{/privacy}", "received_events_url": "https://api.github.com/users/davidlattimore/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2b53639e381b1f17c829fb33f6e4135a9c930f41", "url": "https://api.github.com/repos/rust-lang/rust/commits/2b53639e381b1f17c829fb33f6e4135a9c930f41", "html_url": "https://github.com/rust-lang/rust/commit/2b53639e381b1f17c829fb33f6e4135a9c930f41"}], "stats": {"total": 230, "additions": 123, "deletions": 107}, "files": [{"sha": "3009dcb93bd914cee2e6bfada6c5cbe856991ec3", "filename": "crates/ra_ssr/src/lib.rs", "status": "modified", "additions": 33, "deletions": 43, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/1fce8b6ba32bebba36d588d07781e9e578845728/crates%2Fra_ssr%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fce8b6ba32bebba36d588d07781e9e578845728/crates%2Fra_ssr%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ssr%2Fsrc%2Flib.rs?ref=1fce8b6ba32bebba36d588d07781e9e578845728", "patch": "@@ -13,35 +13,27 @@ mod tests;\n \n pub use crate::errors::SsrError;\n pub use crate::matching::Match;\n-use crate::matching::{record_match_fails_reasons_scope, MatchFailureReason};\n+use crate::matching::MatchFailureReason;\n use hir::Semantics;\n+use parsing::SsrTemplate;\n use ra_db::{FileId, FileRange};\n-use ra_syntax::{ast, AstNode, SmolStr, SyntaxKind, SyntaxNode, TextRange};\n+use ra_syntax::{ast, AstNode, SyntaxNode, TextRange};\n use ra_text_edit::TextEdit;\n-use rustc_hash::FxHashMap;\n \n // A structured search replace rule. Create by calling `parse` on a str.\n #[derive(Debug)]\n pub struct SsrRule {\n     /// A structured pattern that we're searching for.\n-    pattern: SsrPattern,\n+    pattern: parsing::RawPattern,\n     /// What we'll replace it with.\n-    template: parsing::SsrTemplate,\n+    template: SsrTemplate,\n+    parsed_rules: Vec<parsing::ParsedRule>,\n }\n \n #[derive(Debug)]\n pub struct SsrPattern {\n-    raw: parsing::RawSearchPattern,\n-    /// Placeholders keyed by the stand-in ident that we use in Rust source code.\n-    placeholders_by_stand_in: FxHashMap<SmolStr, parsing::Placeholder>,\n-    // We store our search pattern, parsed as each different kind of thing we can look for. As we\n-    // traverse the AST, we get the appropriate one of these for the type of node we're on. For many\n-    // search patterns, only some of these will be present.\n-    expr: Option<SyntaxNode>,\n-    type_ref: Option<SyntaxNode>,\n-    item: Option<SyntaxNode>,\n-    path: Option<SyntaxNode>,\n-    pattern: Option<SyntaxNode>,\n+    raw: parsing::RawPattern,\n+    parsed_rules: Vec<parsing::ParsedRule>,\n }\n \n #[derive(Debug, Default)]\n@@ -53,22 +45,25 @@ pub struct SsrMatches {\n pub struct MatchFinder<'db> {\n     /// Our source of information about the user's code.\n     sema: Semantics<'db, ra_ide_db::RootDatabase>,\n-    rules: Vec<SsrRule>,\n+    rules: Vec<parsing::ParsedRule>,\n }\n \n impl<'db> MatchFinder<'db> {\n     pub fn new(db: &'db ra_ide_db::RootDatabase) -> MatchFinder<'db> {\n         MatchFinder { sema: Semantics::new(db), rules: Vec::new() }\n     }\n \n+    /// Adds a rule to be applied. The order in which rules are added matters. Earlier rules take\n+    /// precedence. If a node is matched by an earlier rule, then later rules won't be permitted to\n+    /// match to it.\n     pub fn add_rule(&mut self, rule: SsrRule) {\n-        self.rules.push(rule);\n+        self.add_parsed_rules(rule.parsed_rules);\n     }\n \n     /// Adds a search pattern. For use if you intend to only call `find_matches_in_file`. If you\n     /// intend to do replacement, use `add_rule` instead.\n     pub fn add_search_pattern(&mut self, pattern: SsrPattern) {\n-        self.add_rule(SsrRule { pattern, template: \"()\".parse().unwrap() })\n+        self.add_parsed_rules(pattern.parsed_rules);\n     }\n \n     pub fn edits_for_file(&self, file_id: FileId) -> Option<TextEdit> {\n@@ -115,6 +110,14 @@ impl<'db> MatchFinder<'db> {\n         res\n     }\n \n+    fn add_parsed_rules(&mut self, parsed_rules: Vec<parsing::ParsedRule>) {\n+        // FIXME: This doesn't need to be a for loop, but does in a subsequent commit. Justify it\n+        // being a for-loop.\n+        for parsed_rule in parsed_rules {\n+            self.rules.push(parsed_rule);\n+        }\n+    }\n+\n     fn find_matches(\n         &self,\n         code: &SyntaxNode,\n@@ -177,16 +180,21 @@ impl<'db> MatchFinder<'db> {\n             }\n             if node_range.range == range.range {\n                 for rule in &self.rules {\n-                    let pattern =\n-                        rule.pattern.tree_for_kind_with_reason(node.kind()).map(|p| p.clone());\n+                    // For now we ignore rules that have a different kind than our node, otherwise\n+                    // we get lots of noise. If at some point we add support for restricting rules\n+                    // to a particular kind of thing (e.g. only match type references), then we can\n+                    // relax this.\n+                    if rule.pattern.kind() != node.kind() {\n+                        continue;\n+                    }\n                     out.push(MatchDebugInfo {\n                         matched: matching::get_match(true, rule, &node, restrict_range, &self.sema)\n                             .map_err(|e| MatchFailureReason {\n                                 reason: e.reason.unwrap_or_else(|| {\n                                     \"Match failed, but no reason was given\".to_owned()\n                                 }),\n                             }),\n-                        pattern,\n+                        pattern: rule.pattern.clone(),\n                         node: node.clone(),\n                     });\n                 }\n@@ -209,9 +217,8 @@ impl<'db> MatchFinder<'db> {\n \n pub struct MatchDebugInfo {\n     node: SyntaxNode,\n-    /// Our search pattern parsed as the same kind of syntax node as `node`. e.g. expression, item,\n-    /// etc. Will be absent if the pattern can't be parsed as that kind.\n-    pattern: Result<SyntaxNode, MatchFailureReason>,\n+    /// Our search pattern parsed as an expression or item, etc\n+    pattern: SyntaxNode,\n     matched: Result<Match, MatchFailureReason>,\n }\n \n@@ -228,29 +235,12 @@ impl std::fmt::Debug for MatchDebugInfo {\n             self.node\n         )?;\n         writeln!(f, \"========= PATTERN ==========\")?;\n-        match &self.pattern {\n-            Ok(pattern) => {\n-                writeln!(f, \"{:#?}\", pattern)?;\n-            }\n-            Err(err) => {\n-                writeln!(f, \"{}\", err.reason)?;\n-            }\n-        }\n+        writeln!(f, \"{:#?}\", self.pattern)?;\n         writeln!(f, \"============================\")?;\n         Ok(())\n     }\n }\n \n-impl SsrPattern {\n-    fn tree_for_kind_with_reason(\n-        &self,\n-        kind: SyntaxKind,\n-    ) -> Result<&SyntaxNode, MatchFailureReason> {\n-        record_match_fails_reasons_scope(true, || self.tree_for_kind(kind))\n-            .map_err(|e| MatchFailureReason { reason: e.reason.unwrap() })\n-    }\n-}\n-\n impl SsrMatches {\n     /// Returns `self` with any nested matches removed and made into top-level matches.\n     pub fn flattened(self) -> SsrMatches {"}, {"sha": "842f4b6f353c0f06196ff53c259643c6d1b10bdc", "filename": "crates/ra_ssr/src/matching.rs", "status": "modified", "additions": 9, "deletions": 33, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/1fce8b6ba32bebba36d588d07781e9e578845728/crates%2Fra_ssr%2Fsrc%2Fmatching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fce8b6ba32bebba36d588d07781e9e578845728/crates%2Fra_ssr%2Fsrc%2Fmatching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ssr%2Fsrc%2Fmatching.rs?ref=1fce8b6ba32bebba36d588d07781e9e578845728", "patch": "@@ -2,8 +2,8 @@\n //! process of matching, placeholder values are recorded.\n \n use crate::{\n-    parsing::{Constraint, NodeKind, Placeholder, SsrTemplate},\n-    SsrMatches, SsrPattern, SsrRule,\n+    parsing::{Constraint, NodeKind, ParsedRule, Placeholder, SsrTemplate},\n+    SsrMatches,\n };\n use hir::Semantics;\n use ra_db::FileRange;\n@@ -50,7 +50,7 @@ pub struct Match {\n     pub(crate) ignored_comments: Vec<ast::Comment>,\n     // A copy of the template for the rule that produced this match. We store this on the match for\n     // if/when we do replacement.\n-    pub(crate) template: SsrTemplate,\n+    pub(crate) template: Option<SsrTemplate>,\n }\n \n /// Represents a `$var` in an SSR query.\n@@ -86,7 +86,7 @@ pub(crate) struct MatchFailed {\n /// parent module, we don't populate nested matches.\n pub(crate) fn get_match(\n     debug_active: bool,\n-    rule: &SsrRule,\n+    rule: &ParsedRule,\n     code: &SyntaxNode,\n     restrict_range: &Option<FileRange>,\n     sema: &Semantics<ra_ide_db::RootDatabase>,\n@@ -102,7 +102,7 @@ struct Matcher<'db, 'sema> {\n     /// If any placeholders come from anywhere outside of this range, then the match will be\n     /// rejected.\n     restrict_range: Option<FileRange>,\n-    rule: &'sema SsrRule,\n+    rule: &'sema ParsedRule,\n }\n \n /// Which phase of matching we're currently performing. We do two phases because most attempted\n@@ -117,15 +117,14 @@ enum Phase<'a> {\n \n impl<'db, 'sema> Matcher<'db, 'sema> {\n     fn try_match(\n-        rule: &'sema SsrRule,\n+        rule: &ParsedRule,\n         code: &SyntaxNode,\n         restrict_range: &Option<FileRange>,\n         sema: &'sema Semantics<'db, ra_ide_db::RootDatabase>,\n     ) -> Result<Match, MatchFailed> {\n         let match_state = Matcher { sema, restrict_range: restrict_range.clone(), rule };\n-        let pattern_tree = rule.pattern.tree_for_kind(code.kind())?;\n         // First pass at matching, where we check that node types and idents match.\n-        match_state.attempt_match_node(&mut Phase::First, &pattern_tree, code)?;\n+        match_state.attempt_match_node(&mut Phase::First, &rule.pattern, code)?;\n         match_state.validate_range(&sema.original_range(code))?;\n         let mut the_match = Match {\n             range: sema.original_range(code),\n@@ -136,7 +135,7 @@ impl<'db, 'sema> Matcher<'db, 'sema> {\n         };\n         // Second matching pass, where we record placeholder matches, ignored comments and maybe do\n         // any other more expensive checks that we didn't want to do on the first pass.\n-        match_state.attempt_match_node(&mut Phase::Second(&mut the_match), &pattern_tree, code)?;\n+        match_state.attempt_match_node(&mut Phase::Second(&mut the_match), &rule.pattern, code)?;\n         Ok(the_match)\n     }\n \n@@ -444,8 +443,7 @@ impl<'db, 'sema> Matcher<'db, 'sema> {\n     }\n \n     fn get_placeholder(&self, element: &SyntaxElement) -> Option<&Placeholder> {\n-        only_ident(element.clone())\n-            .and_then(|ident| self.rule.pattern.placeholders_by_stand_in.get(ident.text()))\n+        only_ident(element.clone()).and_then(|ident| self.rule.get_placeholder(&ident))\n     }\n }\n \n@@ -510,28 +508,6 @@ impl PlaceholderMatch {\n     }\n }\n \n-impl SsrPattern {\n-    pub(crate) fn tree_for_kind(&self, kind: SyntaxKind) -> Result<&SyntaxNode, MatchFailed> {\n-        let (tree, kind_name) = if ast::Expr::can_cast(kind) {\n-            (&self.expr, \"expression\")\n-        } else if ast::TypeRef::can_cast(kind) {\n-            (&self.type_ref, \"type reference\")\n-        } else if ast::ModuleItem::can_cast(kind) {\n-            (&self.item, \"item\")\n-        } else if ast::Path::can_cast(kind) {\n-            (&self.path, \"path\")\n-        } else if ast::Pat::can_cast(kind) {\n-            (&self.pattern, \"pattern\")\n-        } else {\n-            fail_match!(\"Matching nodes of kind {:?} is not supported\", kind);\n-        };\n-        match tree {\n-            Some(tree) => Ok(tree),\n-            None => fail_match!(\"Pattern cannot be parsed as a {}\", kind_name),\n-        }\n-    }\n-}\n-\n impl NodeKind {\n     fn matches(&self, node: &SyntaxNode) -> Result<(), MatchFailed> {\n         let ok = match self {"}, {"sha": "682b7011a0df33d6b49596d40b1deaa901177c4f", "filename": "crates/ra_ssr/src/parsing.rs", "status": "modified", "additions": 76, "deletions": 30, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/1fce8b6ba32bebba36d588d07781e9e578845728/crates%2Fra_ssr%2Fsrc%2Fparsing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fce8b6ba32bebba36d588d07781e9e578845728/crates%2Fra_ssr%2Fsrc%2Fparsing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ssr%2Fsrc%2Fparsing.rs?ref=1fce8b6ba32bebba36d588d07781e9e578845728", "patch": "@@ -7,17 +7,24 @@\n \n use crate::errors::bail;\n use crate::{SsrError, SsrPattern, SsrRule};\n-use ra_syntax::{ast, AstNode, SmolStr, SyntaxKind, T};\n+use ra_syntax::{ast, AstNode, SmolStr, SyntaxKind, SyntaxNode, SyntaxToken, T};\n use rustc_hash::{FxHashMap, FxHashSet};\n use std::str::FromStr;\n \n+#[derive(Debug)]\n+pub(crate) struct ParsedRule {\n+    pub(crate) placeholders_by_stand_in: FxHashMap<SmolStr, Placeholder>,\n+    pub(crate) pattern: SyntaxNode,\n+    pub(crate) template: Option<SsrTemplate>,\n+}\n+\n #[derive(Clone, Debug)]\n pub(crate) struct SsrTemplate {\n     pub(crate) tokens: Vec<PatternElement>,\n }\n \n #[derive(Debug)]\n-pub(crate) struct RawSearchPattern {\n+pub(crate) struct RawPattern {\n     tokens: Vec<PatternElement>,\n }\n \n@@ -54,6 +61,50 @@ pub(crate) struct Token {\n     pub(crate) text: SmolStr,\n }\n \n+impl ParsedRule {\n+    fn new(\n+        pattern: &RawPattern,\n+        template: Option<&SsrTemplate>,\n+    ) -> Result<Vec<ParsedRule>, SsrError> {\n+        let raw_pattern = pattern.as_rust_code();\n+        let mut builder = RuleBuilder {\n+            placeholders_by_stand_in: pattern.placeholders_by_stand_in(),\n+            rules: Vec::new(),\n+        };\n+        builder.try_add(ast::Expr::parse(&raw_pattern), template);\n+        builder.try_add(ast::TypeRef::parse(&raw_pattern), template);\n+        builder.try_add(ast::ModuleItem::parse(&raw_pattern), template);\n+        builder.try_add(ast::Path::parse(&raw_pattern), template);\n+        builder.try_add(ast::Pat::parse(&raw_pattern), template);\n+        builder.build()\n+    }\n+}\n+\n+struct RuleBuilder {\n+    placeholders_by_stand_in: FxHashMap<SmolStr, Placeholder>,\n+    rules: Vec<ParsedRule>,\n+}\n+\n+impl RuleBuilder {\n+    fn try_add<T: AstNode>(&mut self, pattern: Result<T, ()>, template: Option<&SsrTemplate>) {\n+        match pattern {\n+            Ok(pattern) => self.rules.push(ParsedRule {\n+                placeholders_by_stand_in: self.placeholders_by_stand_in.clone(),\n+                pattern: pattern.syntax().clone(),\n+                template: template.cloned(),\n+            }),\n+            _ => {}\n+        }\n+    }\n+\n+    fn build(self) -> Result<Vec<ParsedRule>, SsrError> {\n+        if self.rules.is_empty() {\n+            bail!(\"Pattern is not a valid Rust expression, type, item, path or pattern\");\n+        }\n+        Ok(self.rules)\n+    }\n+}\n+\n impl FromStr for SsrRule {\n     type Err = SsrError;\n \n@@ -68,21 +119,24 @@ impl FromStr for SsrRule {\n         if it.next().is_some() {\n             return Err(SsrError(\"More than one delimiter found\".into()));\n         }\n-        let rule = SsrRule { pattern: pattern.parse()?, template: template.parse()? };\n+        let raw_pattern = pattern.parse()?;\n+        let raw_template = template.parse()?;\n+        let parsed_rules = ParsedRule::new(&raw_pattern, Some(&raw_template))?;\n+        let rule = SsrRule { pattern: raw_pattern, template: raw_template, parsed_rules };\n         validate_rule(&rule)?;\n         Ok(rule)\n     }\n }\n \n-impl FromStr for RawSearchPattern {\n+impl FromStr for RawPattern {\n     type Err = SsrError;\n \n-    fn from_str(pattern_str: &str) -> Result<RawSearchPattern, SsrError> {\n-        Ok(RawSearchPattern { tokens: parse_pattern(pattern_str)? })\n+    fn from_str(pattern_str: &str) -> Result<RawPattern, SsrError> {\n+        Ok(RawPattern { tokens: parse_pattern(pattern_str)? })\n     }\n }\n \n-impl RawSearchPattern {\n+impl RawPattern {\n     /// Returns this search pattern as Rust source code that we can feed to the Rust parser.\n     fn as_rust_code(&self) -> String {\n         let mut res = String::new();\n@@ -95,7 +149,7 @@ impl RawSearchPattern {\n         res\n     }\n \n-    fn placeholders_by_stand_in(&self) -> FxHashMap<SmolStr, Placeholder> {\n+    pub(crate) fn placeholders_by_stand_in(&self) -> FxHashMap<SmolStr, Placeholder> {\n         let mut res = FxHashMap::default();\n         for t in &self.tokens {\n             if let PatternElement::Placeholder(placeholder) = t {\n@@ -106,30 +160,22 @@ impl RawSearchPattern {\n     }\n }\n \n+impl ParsedRule {\n+    pub(crate) fn get_placeholder(&self, token: &SyntaxToken) -> Option<&Placeholder> {\n+        if token.kind() != SyntaxKind::IDENT {\n+            return None;\n+        }\n+        self.placeholders_by_stand_in.get(token.text())\n+    }\n+}\n+\n impl FromStr for SsrPattern {\n     type Err = SsrError;\n \n     fn from_str(pattern_str: &str) -> Result<SsrPattern, SsrError> {\n-        let raw: RawSearchPattern = pattern_str.parse()?;\n-        let raw_str = raw.as_rust_code();\n-        let res = SsrPattern {\n-            expr: ast::Expr::parse(&raw_str).ok().map(|n| n.syntax().clone()),\n-            type_ref: ast::TypeRef::parse(&raw_str).ok().map(|n| n.syntax().clone()),\n-            item: ast::ModuleItem::parse(&raw_str).ok().map(|n| n.syntax().clone()),\n-            path: ast::Path::parse(&raw_str).ok().map(|n| n.syntax().clone()),\n-            pattern: ast::Pat::parse(&raw_str).ok().map(|n| n.syntax().clone()),\n-            placeholders_by_stand_in: raw.placeholders_by_stand_in(),\n-            raw,\n-        };\n-        if res.expr.is_none()\n-            && res.type_ref.is_none()\n-            && res.item.is_none()\n-            && res.path.is_none()\n-            && res.pattern.is_none()\n-        {\n-            bail!(\"Pattern is not a valid Rust expression, type, item, path or pattern\");\n-        }\n-        Ok(res)\n+        let raw_pattern = pattern_str.parse()?;\n+        let parsed_rules = ParsedRule::new(&raw_pattern, None)?;\n+        Ok(SsrPattern { raw: raw_pattern, parsed_rules })\n     }\n }\n \n@@ -173,7 +219,7 @@ fn parse_pattern(pattern_str: &str) -> Result<Vec<PatternElement>, SsrError> {\n /// pattern didn't define.\n fn validate_rule(rule: &SsrRule) -> Result<(), SsrError> {\n     let mut defined_placeholders = FxHashSet::default();\n-    for p in &rule.pattern.raw.tokens {\n+    for p in &rule.pattern.tokens {\n         if let PatternElement::Placeholder(placeholder) = p {\n             defined_placeholders.insert(&placeholder.ident);\n         }\n@@ -316,7 +362,7 @@ mod tests {\n         }\n         let result: SsrRule = \"foo($a, $b) ==>> bar($b, $a)\".parse().unwrap();\n         assert_eq!(\n-            result.pattern.raw.tokens,\n+            result.pattern.tokens,\n             vec![\n                 token(SyntaxKind::IDENT, \"foo\"),\n                 token(T!['('], \"(\"),"}, {"sha": "81f8634baa8739b6dbefdaed659fc7e904889b7c", "filename": "crates/ra_ssr/src/replacing.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1fce8b6ba32bebba36d588d07781e9e578845728/crates%2Fra_ssr%2Fsrc%2Freplacing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fce8b6ba32bebba36d588d07781e9e578845728/crates%2Fra_ssr%2Fsrc%2Freplacing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ssr%2Fsrc%2Freplacing.rs?ref=1fce8b6ba32bebba36d588d07781e9e578845728", "patch": "@@ -31,7 +31,11 @@ fn matches_to_edit_at_offset(\n \n fn render_replace(match_info: &Match, file_src: &str) -> String {\n     let mut out = String::new();\n-    for r in &match_info.template.tokens {\n+    let template = match_info\n+        .template\n+        .as_ref()\n+        .expect(\"You called MatchFinder::edits after calling MatchFinder::add_search_pattern\");\n+    for r in &template.tokens {\n         match r {\n             PatternElement::Token(t) => out.push_str(t.text.as_str()),\n             PatternElement::Placeholder(p) => {"}]}