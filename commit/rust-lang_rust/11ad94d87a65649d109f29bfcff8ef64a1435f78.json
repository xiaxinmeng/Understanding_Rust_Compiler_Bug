{"sha": "11ad94d87a65649d109f29bfcff8ef64a1435f78", "node_id": "C_kwDOAAsO6NoAKDExYWQ5NGQ4N2E2NTY0OWQxMDlmMjliZmNmZjhlZjY0YTE0MzVmNzg", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-12-10T21:19:02Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-12-10T21:26:40Z"}, "message": "Some method confirmation code nits", "tree": {"sha": "a15152f7d2b0397fcfb4413c9741c9df5832fd76", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a15152f7d2b0397fcfb4413c9741c9df5832fd76"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/11ad94d87a65649d109f29bfcff8ef64a1435f78", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/11ad94d87a65649d109f29bfcff8ef64a1435f78", "html_url": "https://github.com/rust-lang/rust/commit/11ad94d87a65649d109f29bfcff8ef64a1435f78", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/11ad94d87a65649d109f29bfcff8ef64a1435f78/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a161a7b654083a881b22908a475988bcc3221a79", "url": "https://api.github.com/repos/rust-lang/rust/commits/a161a7b654083a881b22908a475988bcc3221a79", "html_url": "https://github.com/rust-lang/rust/commit/a161a7b654083a881b22908a475988bcc3221a79"}], "stats": {"total": 120, "additions": 61, "deletions": 59}, "files": [{"sha": "7a5191b77f1d45759a88ce6f7c6740f1b257df6d", "filename": "compiler/rustc_hir_typeck/src/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/11ad94d87a65649d109f29bfcff8ef64a1435f78/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11ad94d87a65649d109f29bfcff8ef64a1435f78/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs?ref=11ad94d87a65649d109f29bfcff8ef64a1435f78", "patch": "@@ -521,7 +521,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 callee_expr,\n                 call_expr,\n                 callee_ty,\n-                pick,\n+                &pick,\n                 segment,\n             );\n             if pick.illegal_sized_bound.is_some() {"}, {"sha": "218c54688aa3e959a187f7b69aded369e9ab8a99", "filename": "compiler/rustc_hir_typeck/src/method/confirm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/11ad94d87a65649d109f29bfcff8ef64a1435f78/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11ad94d87a65649d109f29bfcff8ef64a1435f78/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs?ref=11ad94d87a65649d109f29bfcff8ef64a1435f78", "patch": "@@ -45,7 +45,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self_expr: &'tcx hir::Expr<'tcx>,\n         call_expr: &'tcx hir::Expr<'tcx>,\n         unadjusted_self_ty: Ty<'tcx>,\n-        pick: probe::Pick<'tcx>,\n+        pick: &probe::Pick<'tcx>,\n         segment: &hir::PathSegment<'_>,\n     ) -> ConfirmResult<'tcx> {\n         debug!(\n@@ -71,7 +71,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n     fn confirm(\n         &mut self,\n         unadjusted_self_ty: Ty<'tcx>,\n-        pick: probe::Pick<'tcx>,\n+        pick: &probe::Pick<'tcx>,\n         segment: &hir::PathSegment<'_>,\n     ) -> ConfirmResult<'tcx> {\n         // Adjust the self expression the user provided and obtain the adjusted type."}, {"sha": "b15c086ffad5781f2b921dd61d5c97b31d8bb470", "filename": "compiler/rustc_hir_typeck/src/method/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/11ad94d87a65649d109f29bfcff8ef64a1435f78/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11ad94d87a65649d109f29bfcff8ef64a1435f78/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs?ref=11ad94d87a65649d109f29bfcff8ef64a1435f78", "patch": "@@ -192,8 +192,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         self.tcx.check_stability(pick.item.def_id, Some(call_expr.hir_id), span, None);\n \n-        let result =\n-            self.confirm_method(span, self_expr, call_expr, self_ty, pick.clone(), segment);\n+        let result = self.confirm_method(span, self_expr, call_expr, self_ty, &pick, segment);\n         debug!(\"result = {:?}\", result);\n \n         if let Some(span) = result.illegal_sized_bound {"}, {"sha": "070359e71becc13381d15e12fb510b336a58c28e", "filename": "compiler/rustc_hir_typeck/src/method/probe.rs", "status": "modified", "additions": 57, "deletions": 54, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/11ad94d87a65649d109f29bfcff8ef64a1435f78/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11ad94d87a65649d109f29bfcff8ef64a1435f78/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs?ref=11ad94d87a65649d109f29bfcff8ef64a1435f78", "patch": "@@ -38,9 +38,9 @@ use rustc_trait_selection::traits::query::method_autoderef::{\n use rustc_trait_selection::traits::query::CanonicalTyGoal;\n use rustc_trait_selection::traits::NormalizeExt;\n use rustc_trait_selection::traits::{self, ObligationCause};\n+use std::cell::RefCell;\n use std::cmp::max;\n use std::iter;\n-use std::mem;\n use std::ops::Deref;\n \n use smallvec::{smallvec, SmallVec};\n@@ -62,28 +62,29 @@ struct ProbeContext<'a, 'tcx> {\n \n     /// This is the OriginalQueryValues for the steps queries\n     /// that are answered in steps.\n-    orig_steps_var_values: OriginalQueryValues<'tcx>,\n+    orig_steps_var_values: &'a OriginalQueryValues<'tcx>,\n     steps: &'tcx [CandidateStep<'tcx>],\n \n     inherent_candidates: Vec<Candidate<'tcx>>,\n     extension_candidates: Vec<Candidate<'tcx>>,\n     impl_dups: FxHashSet<DefId>,\n \n-    /// Collects near misses when the candidate functions are missing a `self` keyword and is only\n-    /// used for error reporting\n-    static_candidates: Vec<CandidateSource>,\n-\n     /// When probing for names, include names that are close to the\n-    /// requested name (by Levensthein distance)\n+    /// requested name (by Levenshtein distance)\n     allow_similar_names: bool,\n \n     /// Some(candidate) if there is a private candidate\n     private_candidate: Option<(DefKind, DefId)>,\n \n+    /// Collects near misses when the candidate functions are missing a `self` keyword and is only\n+    /// used for error reporting\n+    static_candidates: RefCell<Vec<CandidateSource>>,\n+\n     /// Collects near misses when trait bounds for type parameters are unsatisfied and is only used\n     /// for error reporting\n-    unsatisfied_predicates:\n+    unsatisfied_predicates: RefCell<\n         Vec<(ty::Predicate<'tcx>, Option<ty::Predicate<'tcx>>, Option<ObligationCause<'tcx>>)>,\n+    >,\n \n     scope_expr_id: hir::HirId,\n }\n@@ -334,7 +335,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         op: OP,\n     ) -> Result<R, MethodError<'tcx>>\n     where\n-        OP: FnOnce(ProbeContext<'a, 'tcx>) -> Result<R, MethodError<'tcx>>,\n+        OP: FnOnce(ProbeContext<'_, 'tcx>) -> Result<R, MethodError<'tcx>>,\n     {\n         let mut orig_values = OriginalQueryValues::default();\n         let param_env_and_self_ty = self.canonicalize_query(\n@@ -445,7 +446,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 mode,\n                 method_name,\n                 return_type,\n-                orig_values,\n+                &orig_values,\n                 steps.steps,\n                 scope_expr_id,\n             );\n@@ -539,7 +540,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         mode: Mode,\n         method_name: Option<Ident>,\n         return_type: Option<Ty<'tcx>>,\n-        orig_steps_var_values: OriginalQueryValues<'tcx>,\n+        orig_steps_var_values: &'a OriginalQueryValues<'tcx>,\n         steps: &'tcx [CandidateStep<'tcx>],\n         scope_expr_id: hir::HirId,\n     ) -> ProbeContext<'a, 'tcx> {\n@@ -554,10 +555,10 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n             impl_dups: FxHashSet::default(),\n             orig_steps_var_values,\n             steps,\n-            static_candidates: Vec::new(),\n             allow_similar_names: false,\n             private_candidate: None,\n-            unsatisfied_predicates: Vec::new(),\n+            static_candidates: RefCell::new(Vec::new()),\n+            unsatisfied_predicates: RefCell::new(Vec::new()),\n             scope_expr_id,\n         }\n     }\n@@ -566,8 +567,9 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         self.inherent_candidates.clear();\n         self.extension_candidates.clear();\n         self.impl_dups.clear();\n-        self.static_candidates.clear();\n         self.private_candidate = None;\n+        self.static_candidates.borrow_mut().clear();\n+        self.unsatisfied_predicates.borrow_mut().clear();\n     }\n \n     ///////////////////////////////////////////////////////////////////////////\n@@ -1003,9 +1005,9 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n \n         debug!(\"pick: actual search failed, assemble diagnostics\");\n \n-        let static_candidates = mem::take(&mut self.static_candidates);\n+        let static_candidates = std::mem::take(self.static_candidates.get_mut());\n         let private_candidate = self.private_candidate.take();\n-        let unsatisfied_predicates = mem::take(&mut self.unsatisfied_predicates);\n+        let unsatisfied_predicates = std::mem::take(self.unsatisfied_predicates.get_mut());\n \n         // things failed, so lets look at all traits, for diagnostic purposes now:\n         self.reset();\n@@ -1050,7 +1052,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         }))\n     }\n \n-    fn pick_core(&mut self) -> Option<PickResult<'tcx>> {\n+    fn pick_core(&self) -> Option<PickResult<'tcx>> {\n         let pick = self.pick_all_method(Some(&mut vec![]));\n \n         // In this case unstable picking is done by `pick_method`.\n@@ -1065,11 +1067,10 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n     }\n \n     fn pick_all_method(\n-        &mut self,\n+        &self,\n         mut unstable_candidates: Option<&mut Vec<(Candidate<'tcx>, Symbol)>>,\n     ) -> Option<PickResult<'tcx>> {\n-        let steps = self.steps.clone();\n-        steps\n+        self.steps\n             .iter()\n             .filter(|step| {\n                 debug!(\"pick_all_method: step={:?}\", step);\n@@ -1123,7 +1124,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n     /// to transparently pass `&mut` pointers, in particular, without consuming\n     /// them for their entire lifetime.\n     fn pick_by_value_method(\n-        &mut self,\n+        &self,\n         step: &CandidateStep<'tcx>,\n         self_ty: Ty<'tcx>,\n         unstable_candidates: Option<&mut Vec<(Candidate<'tcx>, Symbol)>>,\n@@ -1151,7 +1152,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n     }\n \n     fn pick_autorefd_method(\n-        &mut self,\n+        &self,\n         step: &CandidateStep<'tcx>,\n         self_ty: Ty<'tcx>,\n         mutbl: hir::Mutability,\n@@ -1177,7 +1178,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n     /// special case for this is because going from `*mut T` to `*const T` with autoderefs and\n     /// autorefs would require dereferencing the pointer, which is not safe.\n     fn pick_const_ptr_method(\n-        &mut self,\n+        &self,\n         step: &CandidateStep<'tcx>,\n         self_ty: Ty<'tcx>,\n         unstable_candidates: Option<&mut Vec<(Candidate<'tcx>, Symbol)>>,\n@@ -1202,7 +1203,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         })\n     }\n \n-    fn pick_method_with_unstable(&mut self, self_ty: Ty<'tcx>) -> Option<PickResult<'tcx>> {\n+    fn pick_method_with_unstable(&self, self_ty: Ty<'tcx>) -> Option<PickResult<'tcx>> {\n         debug!(\"pick_method_with_unstable(self_ty={})\", self.ty_to_string(self_ty));\n \n         let mut possibly_unsatisfied_predicates = Vec::new();\n@@ -1213,7 +1214,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n             debug!(\"searching {} candidates\", kind);\n             let res = self.consider_candidates(\n                 self_ty,\n-                candidates.iter(),\n+                candidates,\n                 &mut possibly_unsatisfied_predicates,\n                 Some(&mut vec![]),\n             );\n@@ -1222,21 +1223,27 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n             }\n         }\n \n-        debug!(\"searching unstable candidates\");\n-        let res = self.consider_candidates(\n-            self_ty,\n-            self.inherent_candidates.iter().chain(&self.extension_candidates),\n-            &mut possibly_unsatisfied_predicates,\n-            None,\n-        );\n-        if res.is_none() {\n-            self.unsatisfied_predicates.extend(possibly_unsatisfied_predicates);\n+        for (kind, candidates) in\n+            &[(\"inherent\", &self.inherent_candidates), (\"extension\", &self.extension_candidates)]\n+        {\n+            debug!(\"searching unstable {kind} candidates\");\n+            let res = self.consider_candidates(\n+                self_ty,\n+                candidates,\n+                &mut possibly_unsatisfied_predicates,\n+                None,\n+            );\n+            if res.is_some() {\n+                return res;\n+            }\n         }\n-        res\n+\n+        self.unsatisfied_predicates.borrow_mut().extend(possibly_unsatisfied_predicates);\n+        None\n     }\n \n     fn pick_method(\n-        &mut self,\n+        &self,\n         self_ty: Ty<'tcx>,\n         mut unstable_candidates: Option<&mut Vec<(Candidate<'tcx>, Symbol)>>,\n     ) -> Option<PickResult<'tcx>> {\n@@ -1254,7 +1261,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n             debug!(\"searching {} candidates\", kind);\n             let res = self.consider_candidates(\n                 self_ty,\n-                candidates.iter(),\n+                candidates,\n                 &mut possibly_unsatisfied_predicates,\n                 unstable_candidates.as_deref_mut(),\n             );\n@@ -1266,28 +1273,24 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         // `pick_method` may be called twice for the same self_ty if no stable methods\n         // match. Only extend once.\n         if unstable_candidates.is_some() {\n-            self.unsatisfied_predicates.extend(possibly_unsatisfied_predicates);\n+            self.unsatisfied_predicates.borrow_mut().extend(possibly_unsatisfied_predicates);\n         }\n         None\n     }\n \n-    fn consider_candidates<'b, ProbesIter>(\n+    fn consider_candidates(\n         &self,\n         self_ty: Ty<'tcx>,\n-        probes: ProbesIter,\n+        candidates: &[Candidate<'tcx>],\n         possibly_unsatisfied_predicates: &mut Vec<(\n             ty::Predicate<'tcx>,\n             Option<ty::Predicate<'tcx>>,\n             Option<ObligationCause<'tcx>>,\n         )>,\n         mut unstable_candidates: Option<&mut Vec<(Candidate<'tcx>, Symbol)>>,\n-    ) -> Option<PickResult<'tcx>>\n-    where\n-        ProbesIter: Iterator<Item = &'b Candidate<'tcx>> + Clone,\n-        'tcx: 'b,\n-    {\n-        let mut applicable_candidates: Vec<_> = probes\n-            .clone()\n+    ) -> Option<PickResult<'tcx>> {\n+        let mut applicable_candidates: Vec<_> = candidates\n+            .iter()\n             .map(|probe| {\n                 (probe, self.consider_probe(self_ty, probe, possibly_unsatisfied_predicates))\n             })\n@@ -1305,19 +1308,19 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         }\n \n         if let Some(uc) = &mut unstable_candidates {\n-            applicable_candidates.retain(|&(p, _)| {\n+            applicable_candidates.retain(|&(candidate, _)| {\n                 if let stability::EvalResult::Deny { feature, .. } =\n-                    self.tcx.eval_stability(p.item.def_id, None, self.span, None)\n+                    self.tcx.eval_stability(candidate.item.def_id, None, self.span, None)\n                 {\n-                    uc.push((p.clone(), feature));\n+                    uc.push((candidate.clone(), feature));\n                     return false;\n                 }\n                 true\n             });\n         }\n \n         if applicable_candidates.len() > 1 {\n-            let sources = probes.map(|p| self.candidate_source(p, self_ty)).collect();\n+            let sources = candidates.iter().map(|p| self.candidate_source(p, self_ty)).collect();\n             return Some(Err(MethodError::Ambiguity(sources)));\n         }\n \n@@ -1701,7 +1704,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                 self.mode,\n                 self.method_name,\n                 self.return_type,\n-                self.orig_steps_var_values.clone(),\n+                &self.orig_steps_var_values,\n                 steps,\n                 self.scope_expr_id,\n             );\n@@ -1763,8 +1766,8 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         // -- but this could be overcome.\n     }\n \n-    fn record_static_candidate(&mut self, source: CandidateSource) {\n-        self.static_candidates.push(source);\n+    fn record_static_candidate(&self, source: CandidateSource) {\n+        self.static_candidates.borrow_mut().push(source);\n     }\n \n     #[instrument(level = \"debug\", skip(self))]"}]}