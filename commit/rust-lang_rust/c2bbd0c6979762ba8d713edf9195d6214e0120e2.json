{"sha": "c2bbd0c6979762ba8d713edf9195d6214e0120e2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMyYmJkMGM2OTc5NzYyYmE4ZDcxM2VkZjkxOTVkNjIxNGUwMTIwZTI=", "commit": {"author": {"name": "Yuki Okushi", "email": "huyuumi.dev@gmail.com", "date": "2021-01-10T07:56:00Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-01-10T07:56:00Z"}, "message": "Rollup merge of #80803 - jyn514:cleanup-fill-in, r=GuillaumeGomez\n\nRemove useless `fill_in` function\n\nIt was only used once, in a function that was otherwise trivial.", "tree": {"sha": "3e9728c8a4f7c4e7b8c12079fc62351042f18c89", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3e9728c8a4f7c4e7b8c12079fc62351042f18c89"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c2bbd0c6979762ba8d713edf9195d6214e0120e2", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJf+rMQCRBK7hj4Ov3rIwAAdHIIAANfx802HGGfM7sv2MuBAe5j\n/U+uCJrBNG28JGdHkW8NxBuoNEUA7SnAYo5u1lHdCg8p9acZA38jtuH2VtdpKOCD\nrYMlTknTMxbII46/F03ISsejPDTXRG+Y69YGZ5xhb9GytBHBYtUDwtoUjk9mjwM3\nFga5aEDJkHgpYYuyn3idFWEonRhhSjYomKVbkltPuimw/srxXdJAA/6tMMVcxNYL\nvWU0qpu6f9PdJ42XNveSqi6U2tQZX4mzg88R9LW9Azdp4P51PTzT21ZCFNabQOr4\nJIghxFtS+DiAoZVWBDoM142GbClxSqX9cUS6rpiBo6s/SYNL3VUm/AizbQPUwiY=\n=AZQS\n-----END PGP SIGNATURE-----\n", "payload": "tree 3e9728c8a4f7c4e7b8c12079fc62351042f18c89\nparent 700f3f23d8ac8971d107f26c18cd9f45276cff4d\nparent d72f58009f1b07175b6459ab3f538459cad8fd51\nauthor Yuki Okushi <huyuumi.dev@gmail.com> 1610265360 +0900\ncommitter GitHub <noreply@github.com> 1610265360 +0900\n\nRollup merge of #80803 - jyn514:cleanup-fill-in, r=GuillaumeGomez\n\nRemove useless `fill_in` function\n\nIt was only used once, in a function that was otherwise trivial.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c2bbd0c6979762ba8d713edf9195d6214e0120e2", "html_url": "https://github.com/rust-lang/rust/commit/c2bbd0c6979762ba8d713edf9195d6214e0120e2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c2bbd0c6979762ba8d713edf9195d6214e0120e2/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "700f3f23d8ac8971d107f26c18cd9f45276cff4d", "url": "https://api.github.com/repos/rust-lang/rust/commits/700f3f23d8ac8971d107f26c18cd9f45276cff4d", "html_url": "https://github.com/rust-lang/rust/commit/700f3f23d8ac8971d107f26c18cd9f45276cff4d"}, {"sha": "d72f58009f1b07175b6459ab3f538459cad8fd51", "url": "https://api.github.com/repos/rust-lang/rust/commits/d72f58009f1b07175b6459ab3f538459cad8fd51", "html_url": "https://github.com/rust-lang/rust/commit/d72f58009f1b07175b6459ab3f538459cad8fd51"}], "stats": {"total": 89, "additions": 40, "deletions": 49}, "files": [{"sha": "f0678b1904e5084186d43b7e642d3aa7895343b0", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 40, "deletions": 49, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/c2bbd0c6979762ba8d713edf9195d6214e0120e2/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2bbd0c6979762ba8d713edf9195d6214e0120e2/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=c2bbd0c6979762ba8d713edf9195d6214e0120e2", "patch": "@@ -441,60 +441,51 @@ crate fn build_impl(\n \n fn build_module(cx: &DocContext<'_>, did: DefId, visited: &mut FxHashSet<DefId>) -> clean::Module {\n     let mut items = Vec::new();\n-    fill_in(cx, did, &mut items, visited);\n-    return clean::Module { items, is_crate: false };\n-\n-    fn fill_in(\n-        cx: &DocContext<'_>,\n-        did: DefId,\n-        items: &mut Vec<clean::Item>,\n-        visited: &mut FxHashSet<DefId>,\n-    ) {\n-        // If we're re-exporting a re-export it may actually re-export something in\n-        // two namespaces, so the target may be listed twice. Make sure we only\n-        // visit each node at most once.\n-        for &item in cx.tcx.item_children(did).iter() {\n-            if item.vis == ty::Visibility::Public {\n-                if let Some(def_id) = item.res.mod_def_id() {\n-                    if did == def_id || !visited.insert(def_id) {\n-                        continue;\n-                    }\n+\n+    // If we're re-exporting a re-export it may actually re-export something in\n+    // two namespaces, so the target may be listed twice. Make sure we only\n+    // visit each node at most once.\n+    for &item in cx.tcx.item_children(did).iter() {\n+        if item.vis == ty::Visibility::Public {\n+            if let Some(def_id) = item.res.mod_def_id() {\n+                if did == def_id || !visited.insert(def_id) {\n+                    continue;\n                 }\n-                if let Res::PrimTy(p) = item.res {\n-                    // Primitive types can't be inlined so generate an import instead.\n-                    items.push(clean::Item {\n-                        name: None,\n-                        attrs: clean::Attributes::default(),\n-                        source: clean::Span::dummy(),\n-                        def_id: DefId::local(CRATE_DEF_INDEX),\n-                        visibility: clean::Public,\n-                        kind: box clean::ImportItem(clean::Import::new_simple(\n-                            item.ident.name,\n-                            clean::ImportSource {\n-                                path: clean::Path {\n-                                    global: false,\n-                                    res: item.res,\n-                                    segments: vec![clean::PathSegment {\n-                                        name: clean::PrimitiveType::from(p).as_sym(),\n-                                        args: clean::GenericArgs::AngleBracketed {\n-                                            args: Vec::new(),\n-                                            bindings: Vec::new(),\n-                                        },\n-                                    }],\n-                                },\n-                                did: None,\n+            }\n+            if let Res::PrimTy(p) = item.res {\n+                // Primitive types can't be inlined so generate an import instead.\n+                items.push(clean::Item {\n+                    name: None,\n+                    attrs: clean::Attributes::default(),\n+                    source: clean::Span::dummy(),\n+                    def_id: DefId::local(CRATE_DEF_INDEX),\n+                    visibility: clean::Public,\n+                    kind: box clean::ImportItem(clean::Import::new_simple(\n+                        item.ident.name,\n+                        clean::ImportSource {\n+                            path: clean::Path {\n+                                global: false,\n+                                res: item.res,\n+                                segments: vec![clean::PathSegment {\n+                                    name: clean::PrimitiveType::from(p).as_sym(),\n+                                    args: clean::GenericArgs::AngleBracketed {\n+                                        args: Vec::new(),\n+                                        bindings: Vec::new(),\n+                                    },\n+                                }],\n                             },\n-                            true,\n-                        )),\n-                    });\n-                } else if let Some(i) =\n-                    try_inline(cx, did, item.res, item.ident.name, None, visited)\n-                {\n-                    items.extend(i)\n-                }\n+                            did: None,\n+                        },\n+                        true,\n+                    )),\n+                });\n+            } else if let Some(i) = try_inline(cx, did, item.res, item.ident.name, None, visited) {\n+                items.extend(i)\n             }\n         }\n     }\n+\n+    clean::Module { items, is_crate: false }\n }\n \n crate fn print_inlined_const(cx: &DocContext<'_>, did: DefId) -> String {"}]}