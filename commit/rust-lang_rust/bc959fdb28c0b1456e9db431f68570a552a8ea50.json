{"sha": "bc959fdb28c0b1456e9db431f68570a552a8ea50", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJjOTU5ZmRiMjhjMGIxNDU2ZTlkYjQzMWY2ODU3MGE1NTJhOGVhNTA=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-03-04T15:52:39Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-04-01T12:40:42Z"}, "message": "Add a meta-hierarchy of trees -- in future, each fn body will inhabit\nits own disjoint region tree, and the new table encodes the lexical\nrelationships between those trees.", "tree": {"sha": "e006226543cd96d29c879a57127508637657ea8c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e006226543cd96d29c879a57127508637657ea8c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bc959fdb28c0b1456e9db431f68570a552a8ea50", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bc959fdb28c0b1456e9db431f68570a552a8ea50", "html_url": "https://github.com/rust-lang/rust/commit/bc959fdb28c0b1456e9db431f68570a552a8ea50", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bc959fdb28c0b1456e9db431f68570a552a8ea50/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d754722a04b99fdcae0fd97fa2a4395521145ef2", "url": "https://api.github.com/repos/rust-lang/rust/commits/d754722a04b99fdcae0fd97fa2a4395521145ef2", "html_url": "https://github.com/rust-lang/rust/commit/d754722a04b99fdcae0fd97fa2a4395521145ef2"}], "stats": {"total": 137, "additions": 93, "deletions": 44}, "files": [{"sha": "8f82a9d01bd09e25b831aaa628a0c0e34fd47d4e", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 93, "deletions": 44, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/bc959fdb28c0b1456e9db431f68570a552a8ea50/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc959fdb28c0b1456e9db431f68570a552a8ea50/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=bc959fdb28c0b1456e9db431f68570a552a8ea50", "patch": "@@ -206,50 +206,64 @@ impl CodeExtent {\n }\n \n /// The region maps encode information about region relationships.\n-///\n-/// - `scope_map` maps from a scope id to the enclosing scope id; this is\n-///   usually corresponding to the lexical nesting, though in the case of\n-///   closures the parent scope is the innermost conditional expression or repeating\n-///   block. (Note that the enclosing scope id for the block\n-///   associated with a closure is the closure itself.)\n-///\n-/// - `var_map` maps from a variable or binding id to the block in which\n-///   that variable is declared.\n-///\n-/// - `free_region_map` maps from a free region `a` to a list of free\n-///   regions `bs` such that `a <= b for all b in bs`\n-///   - the free region map is populated during type check as we check\n-///     each function. See the function `relate_free_regions` for\n-///     more information.\n-///\n-/// - `rvalue_scopes` includes entries for those expressions whose cleanup\n-///   scope is larger than the default. The map goes from the expression\n-///   id to the cleanup scope id. For rvalues not present in this table,\n-///   the appropriate cleanup scope is the innermost enclosing statement,\n-///   conditional expression, or repeating block (see `terminating_scopes`).\n-///\n-/// - `terminating_scopes` is a set containing the ids of each statement,\n-///   or conditional/repeating expression. These scopes are calling \"terminating\n-///   scopes\" because, when attempting to find the scope of a temporary, by\n-///   default we search up the enclosing scopes until we encounter the\n-///   terminating scope. A conditional/repeating\n-///   expression is one which is not guaranteed to execute exactly once\n-///   upon entering the parent scope. This could be because the expression\n-///   only executes conditionally, such as the expression `b` in `a && b`,\n-///   or because the expression may execute many times, such as a loop\n-///   body. The reason that we distinguish such expressions is that, upon\n-///   exiting the parent scope, we cannot statically know how many times\n-///   the expression executed, and thus if the expression creates\n-///   temporaries we cannot know statically how many such temporaries we\n-///   would have to cleanup. Therefore we ensure that the temporaries never\n-///   outlast the conditional/repeating expression, preventing the need\n-///   for dynamic checks and/or arbitrary amounts of stack space.\n pub struct RegionMaps {\n+    /// `scope_map` maps from a scope id to the enclosing scope id;\n+    /// this is usually corresponding to the lexical nesting, though\n+    /// in the case of closures the parent scope is the innermost\n+    /// conditional expression or repeating block. (Note that the\n+    /// enclosing scope id for the block associated with a closure is\n+    /// the closure itself.)\n     scope_map: RefCell<FnvHashMap<CodeExtent, CodeExtent>>,\n+\n+    /// `var_map` maps from a variable or binding id to the block in\n+    /// which that variable is declared.\n     var_map: RefCell<NodeMap<CodeExtent>>,\n+\n+    /// `free_region_map` maps from a free region `a` to a list of\n+    /// free regions `bs` such that `a <= b for all b in bs`\n+    ///\n+    /// NB. the free region map is populated during type check as we\n+    /// check each function. See the function `relate_free_regions`\n+    /// for more information.\n     free_region_map: RefCell<FnvHashMap<FreeRegion, Vec<FreeRegion>>>,\n+\n+    /// `rvalue_scopes` includes entries for those expressions whose cleanup scope is\n+    /// larger than the default. The map goes from the expression id\n+    /// to the cleanup scope id. For rvalues not present in this\n+    /// table, the appropriate cleanup scope is the innermost\n+    /// enclosing statement, conditional expression, or repeating\n+    /// block (see `terminating_scopes`).\n     rvalue_scopes: RefCell<NodeMap<CodeExtent>>,\n+\n+    /// `terminating_scopes` is a set containing the ids of each\n+    /// statement, or conditional/repeating expression. These scopes\n+    /// are calling \"terminating scopes\" because, when attempting to\n+    /// find the scope of a temporary, by default we search up the\n+    /// enclosing scopes until we encounter the terminating scope. A\n+    /// conditional/repeating expression is one which is not\n+    /// guaranteed to execute exactly once upon entering the parent\n+    /// scope. This could be because the expression only executes\n+    /// conditionally, such as the expression `b` in `a && b`, or\n+    /// because the expression may execute many times, such as a loop\n+    /// body. The reason that we distinguish such expressions is that,\n+    /// upon exiting the parent scope, we cannot statically know how\n+    /// many times the expression executed, and thus if the expression\n+    /// creates temporaries we cannot know statically how many such\n+    /// temporaries we would have to cleanup. Therefore we ensure that\n+    /// the temporaries never outlast the conditional/repeating\n+    /// expression, preventing the need for dynamic checks and/or\n+    /// arbitrary amounts of stack space.\n     terminating_scopes: RefCell<FnvHashSet<CodeExtent>>,\n+\n+    /// Encodes the hierarchy of fn bodies. Every fn body (including\n+    /// closures) forms its own distinct region hierarchy, rooted in\n+    /// the block that is the fn body. This map points from the id of\n+    /// that root block to the id of the root block for the enclosing\n+    /// fn, if any. Thus the map structures the fn bodies into a\n+    /// hierarchy based on their lexical mapping. This is used to\n+    /// handle the relationships between regions in a fn and in a\n+    /// closure defined by that fn.\n+    fn_tree: RefCell<NodeMap<ast::NodeId>>,\n }\n \n /// Carries the node id for the innermost block or match expression,\n@@ -320,6 +334,12 @@ impl InnermostEnclosingExpr {\n \n #[derive(Debug, Copy)]\n pub struct Context {\n+    /// the root of the current region tree. This is typically the id\n+    /// of the innermost fn body. Each fn forms its own disjoint tree\n+    /// in the region hierarchy. These fn bodies are themselves\n+    /// arranged into a tree.\n+    root_id: Option<ast::NodeId>,\n+\n     /// the scope that contains any new variables declared\n     var_parent: InnermostDeclaringBlock,\n \n@@ -381,19 +401,29 @@ impl RegionMaps {\n         self.free_region_map.borrow_mut().insert(sub, vec!(sup));\n     }\n \n-    pub fn record_encl_scope(&self, sub: CodeExtent, sup: CodeExtent) {\n+    /// Records that `sub_fn` is defined within `sup_fn`. These ids\n+    /// should be the id of the block that is the fn body, which is\n+    /// also the root of the region hierarchy for that fn.\n+    fn record_fn_parent(&self, sub_fn: ast::NodeId, sup_fn: ast::NodeId) {\n+        debug!(\"record_fn_parent(sub_fn={:?}, sup_fn={:?})\", sub_fn, sup_fn);\n+        assert!(sub_fn != sup_fn);\n+        let previous = self.fn_tree.borrow_mut().insert(sub_fn, sup_fn);\n+        assert!(previous.is_none());\n+    }\n+\n+    fn record_encl_scope(&self, sub: CodeExtent, sup: CodeExtent) {\n         debug!(\"record_encl_scope(sub={:?}, sup={:?})\", sub, sup);\n         assert!(sub != sup);\n         self.scope_map.borrow_mut().insert(sub, sup);\n     }\n \n-    pub fn record_var_scope(&self, var: ast::NodeId, lifetime: CodeExtent) {\n+    fn record_var_scope(&self, var: ast::NodeId, lifetime: CodeExtent) {\n         debug!(\"record_var_scope(sub={:?}, sup={:?})\", var, lifetime);\n         assert!(var != lifetime.node_id());\n         self.var_map.borrow_mut().insert(var, lifetime);\n     }\n \n-    pub fn record_rvalue_scope(&self, var: ast::NodeId, lifetime: CodeExtent) {\n+    fn record_rvalue_scope(&self, var: ast::NodeId, lifetime: CodeExtent) {\n         debug!(\"record_rvalue_scope(sub={:?}, sup={:?})\", var, lifetime);\n         assert!(var != lifetime.node_id());\n         self.rvalue_scopes.borrow_mut().insert(var, lifetime);\n@@ -402,7 +432,7 @@ impl RegionMaps {\n     /// Records that a scope is a TERMINATING SCOPE. Whenever we create automatic temporaries --\n     /// e.g. by an expression like `a().f` -- they will be freed within the innermost terminating\n     /// scope.\n-    pub fn mark_as_terminating_scope(&self, scope_id: CodeExtent) {\n+    fn mark_as_terminating_scope(&self, scope_id: CodeExtent) {\n         debug!(\"record_terminating_scope(scope_id={:?})\", scope_id);\n         self.terminating_scopes.borrow_mut().insert(scope_id);\n     }\n@@ -684,6 +714,7 @@ fn resolve_block(visitor: &mut RegionResolutionVisitor, blk: &ast::Block) {\n     // itself has returned.\n \n     visitor.cx = Context {\n+        root_id: prev_cx.root_id,\n         var_parent: InnermostDeclaringBlock::Block(blk.id),\n         parent: InnermostEnclosingExpr::Some(blk.id),\n     };\n@@ -710,6 +741,7 @@ fn resolve_block(visitor: &mut RegionResolutionVisitor, blk: &ast::Block) {\n                 record_superlifetime(\n                     visitor, declaring.to_code_extent(), statement.span);\n                 visitor.cx = Context {\n+                    root_id: prev_cx.root_id,\n                     var_parent: InnermostDeclaringBlock::Statement(declaring),\n                     parent: InnermostEnclosingExpr::Statement(declaring),\n                 };\n@@ -1103,6 +1135,7 @@ fn resolve_item(visitor: &mut RegionResolutionVisitor, item: &ast::Item) {\n     // Items create a new outer block scope as far as we're concerned.\n     let prev_cx = visitor.cx;\n     visitor.cx = Context {\n+        root_id: None,\n         var_parent: InnermostDeclaringBlock::None,\n         parent: InnermostEnclosingExpr::None\n     };\n@@ -1127,14 +1160,21 @@ fn resolve_fn(visitor: &mut RegionResolutionVisitor,\n \n     let body_scope = CodeExtent::from_node_id(body.id);\n     visitor.region_maps.mark_as_terminating_scope(body_scope);\n+\n     let dtor_scope = CodeExtent::DestructionScope(body.id);\n     visitor.region_maps.record_encl_scope(body_scope, dtor_scope);\n+\n     record_superlifetime(visitor, dtor_scope, body.span);\n \n+    if let Some(root_id) = visitor.cx.root_id {\n+        visitor.region_maps.record_fn_parent(body.id, root_id);\n+    }\n+\n     let outer_cx = visitor.cx;\n \n     // The arguments and `self` are parented to the body of the fn.\n     visitor.cx = Context {\n+        root_id: Some(body.id),\n         parent: InnermostEnclosingExpr::Some(body.id),\n         var_parent: InnermostDeclaringBlock::Block(body.id)\n     };\n@@ -1145,11 +1185,11 @@ fn resolve_fn(visitor: &mut RegionResolutionVisitor,\n     match fk {\n         visit::FkItemFn(..) | visit::FkMethod(..) => {\n             visitor.cx = Context {\n+                root_id: Some(body.id),\n                 parent: InnermostEnclosingExpr::None,\n                 var_parent: InnermostDeclaringBlock::None\n             };\n             visitor.visit_block(body);\n-            visitor.cx = outer_cx;\n         }\n         visit::FkFnBlock(..) => {\n             // FIXME(#3696) -- at present we are place the closure body\n@@ -1159,10 +1199,16 @@ fn resolve_fn(visitor: &mut RegionResolutionVisitor,\n             // but the correct fix is a bit subtle, and I am also not sure\n             // that the present approach is unsound -- it may not permit\n             // any illegal programs. See issue for more details.\n-            visitor.cx = outer_cx;\n+            visitor.cx = Context {\n+                root_id: Some(body.id),\n+                ..outer_cx\n+            };\n             visitor.visit_block(body);\n         }\n     }\n+\n+    // Restore context we had at the start.\n+    visitor.cx = outer_cx;\n }\n \n impl<'a, 'v> Visitor<'v> for RegionResolutionVisitor<'a> {\n@@ -1203,12 +1249,14 @@ pub fn resolve_crate(sess: &Session, krate: &ast::Crate) -> RegionMaps {\n         free_region_map: RefCell::new(FnvHashMap()),\n         rvalue_scopes: RefCell::new(NodeMap()),\n         terminating_scopes: RefCell::new(FnvHashSet()),\n+        fn_tree: RefCell::new(NodeMap()),\n     };\n     {\n         let mut visitor = RegionResolutionVisitor {\n             sess: sess,\n             region_maps: &maps,\n             cx: Context {\n+                root_id: None,\n                 parent: InnermostEnclosingExpr::None,\n                 var_parent: InnermostDeclaringBlock::None,\n             }\n@@ -1225,6 +1273,7 @@ pub fn resolve_inlined_item(sess: &Session,\n         sess: sess,\n         region_maps: region_maps,\n         cx: Context {\n+            root_id: None,\n             parent: InnermostEnclosingExpr::None,\n             var_parent: InnermostDeclaringBlock::None\n         }"}]}