{"sha": "1cdcea920e56a5d0587307a4c9cf8fff5c77c4bc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFjZGNlYTkyMGU1NmE1ZDA1ODczMDdhNGM5Y2Y4ZmZmNWM3N2M0YmM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-08-15T04:24:29Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-08-15T04:24:29Z"}, "message": "Auto merge of #62429 - cuviper:iter-closures, r=cramertj\n\nReduce the genericity of closures in the iterator traits\n\nBy default, closures inherit the generic parameters of their scope,\nincluding `Self`. However, in most cases, the closures used to implement\niterators don't need to be generic on the iterator type, only its `Item`\ntype. We can reduce this genericity by redirecting such closures through\nlocal functions.\n\nThis does make the closures more cumbersome to write, but it will\nhopefully reduce duplication in their monomorphizations, as well as\ntheir related type lengths.", "tree": {"sha": "ccb6b9be0ea3d973f4e0808ef6f7c11bebf52a9b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ccb6b9be0ea3d973f4e0808ef6f7c11bebf52a9b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1cdcea920e56a5d0587307a4c9cf8fff5c77c4bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1cdcea920e56a5d0587307a4c9cf8fff5c77c4bc", "html_url": "https://github.com/rust-lang/rust/commit/1cdcea920e56a5d0587307a4c9cf8fff5c77c4bc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1cdcea920e56a5d0587307a4c9cf8fff5c77c4bc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9e9a136fcec5eb78f09a14dfd072a51ae2550269", "url": "https://api.github.com/repos/rust-lang/rust/commits/9e9a136fcec5eb78f09a14dfd072a51ae2550269", "html_url": "https://github.com/rust-lang/rust/commit/9e9a136fcec5eb78f09a14dfd072a51ae2550269"}, {"sha": "bca6f28f7f7a6db3416c0d4e631a7a4cc1072cf7", "url": "https://api.github.com/repos/rust-lang/rust/commits/bca6f28f7f7a6db3416c0d4e631a7a4cc1072cf7", "html_url": "https://github.com/rust-lang/rust/commit/bca6f28f7f7a6db3416c0d4e631a7a4cc1072cf7"}], "stats": {"total": 1038, "additions": 714, "deletions": 324}, "files": [{"sha": "e3c85656116c0d5d91a23020603e9ccdf0c6f5c2", "filename": "src/libcore/iter/adapters/flatten.rs", "status": "modified", "additions": 52, "deletions": 26, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/1cdcea920e56a5d0587307a4c9cf8fff5c77c4bc/src%2Flibcore%2Fiter%2Fadapters%2Fflatten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cdcea920e56a5d0587307a4c9cf8fff5c77c4bc/src%2Flibcore%2Fiter%2Fadapters%2Fflatten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fadapters%2Fflatten.rs?ref=1cdcea920e56a5d0587307a4c9cf8fff5c77c4bc", "patch": "@@ -229,16 +229,16 @@ where\n                 if let elt@Some(_) = inner.next() { return elt }\n             }\n             match self.iter.next() {\n-                None => return self.backiter.as_mut().and_then(|it| it.next()),\n+                None => return self.backiter.as_mut()?.next(),\n                 Some(inner) => self.frontiter = Some(inner.into_iter()),\n             }\n         }\n     }\n \n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        let (flo, fhi) = self.frontiter.as_ref().map_or((0, Some(0)), |it| it.size_hint());\n-        let (blo, bhi) = self.backiter.as_ref().map_or((0, Some(0)), |it| it.size_hint());\n+        let (flo, fhi) = self.frontiter.as_ref().map_or((0, Some(0)), U::size_hint);\n+        let (blo, bhi) = self.backiter.as_ref().map_or((0, Some(0)), U::size_hint);\n         let lo = flo.saturating_add(blo);\n         match (self.iter.size_hint(), fhi, bhi) {\n             ((0, Some(0)), Some(a), Some(b)) => (lo, a.checked_add(b)),\n@@ -250,20 +250,25 @@ where\n     fn try_fold<Acc, Fold, R>(&mut self, mut init: Acc, mut fold: Fold) -> R where\n         Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n     {\n+        #[inline]\n+        fn flatten<'a, T: IntoIterator, Acc, R: Try<Ok = Acc>>(\n+            frontiter: &'a mut Option<T::IntoIter>,\n+            fold: &'a mut impl FnMut(Acc, T::Item) -> R,\n+        ) -> impl FnMut(Acc, T) -> R + 'a {\n+            move |acc, x| {\n+                let mut mid = x.into_iter();\n+                let r = mid.try_fold(acc, &mut *fold);\n+                *frontiter = Some(mid);\n+                r\n+            }\n+        }\n+\n         if let Some(ref mut front) = self.frontiter {\n             init = front.try_fold(init, &mut fold)?;\n         }\n         self.frontiter = None;\n \n-        {\n-            let frontiter = &mut self.frontiter;\n-            init = self.iter.try_fold(init, |acc, x| {\n-                let mut mid = x.into_iter();\n-                let r = mid.try_fold(acc, &mut fold);\n-                *frontiter = Some(mid);\n-                r\n-            })?;\n-        }\n+        init = self.iter.try_fold(init, flatten(&mut self.frontiter, &mut fold))?;\n         self.frontiter = None;\n \n         if let Some(ref mut back) = self.backiter {\n@@ -275,13 +280,20 @@ where\n     }\n \n     #[inline]\n-    fn fold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n+    fn fold<Acc, Fold>(self, init: Acc, ref mut fold: Fold) -> Acc\n         where Fold: FnMut(Acc, Self::Item) -> Acc,\n     {\n+        #[inline]\n+        fn flatten<U: Iterator, Acc>(\n+            fold: &mut impl FnMut(Acc, U::Item) -> Acc,\n+        ) -> impl FnMut(Acc, U) -> Acc + '_ {\n+            move |acc, iter| iter.fold(acc, &mut *fold)\n+        }\n+\n         self.frontiter.into_iter()\n             .chain(self.iter.map(IntoIterator::into_iter))\n             .chain(self.backiter)\n-            .fold(init, |acc, iter| iter.fold(acc, &mut fold))\n+            .fold(init, flatten(fold))\n     }\n }\n \n@@ -297,7 +309,7 @@ where\n                 if let elt@Some(_) = inner.next_back() { return elt }\n             }\n             match self.iter.next_back() {\n-                None => return self.frontiter.as_mut().and_then(|it| it.next_back()),\n+                None => return self.frontiter.as_mut()?.next_back(),\n                 next => self.backiter = next.map(IntoIterator::into_iter),\n             }\n         }\n@@ -307,20 +319,27 @@ where\n     fn try_rfold<Acc, Fold, R>(&mut self, mut init: Acc, mut fold: Fold) -> R where\n         Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n     {\n-        if let Some(ref mut back) = self.backiter {\n-            init = back.try_rfold(init, &mut fold)?;\n-        }\n-        self.backiter = None;\n-\n+        #[inline]\n+        fn flatten<'a, T: IntoIterator, Acc, R: Try<Ok = Acc>>(\n+            backiter: &'a mut Option<T::IntoIter>,\n+            fold: &'a mut impl FnMut(Acc, T::Item) -> R,\n+        ) -> impl FnMut(Acc, T) -> R + 'a where\n+            T::IntoIter: DoubleEndedIterator,\n         {\n-            let backiter = &mut self.backiter;\n-            init = self.iter.try_rfold(init, |acc, x| {\n+            move |acc, x| {\n                 let mut mid = x.into_iter();\n-                let r = mid.try_rfold(acc, &mut fold);\n+                let r = mid.try_rfold(acc, &mut *fold);\n                 *backiter = Some(mid);\n                 r\n-            })?;\n+            }\n         }\n+\n+        if let Some(ref mut back) = self.backiter {\n+            init = back.try_rfold(init, &mut fold)?;\n+        }\n+        self.backiter = None;\n+\n+        init = self.iter.try_rfold(init, flatten(&mut self.backiter, &mut fold))?;\n         self.backiter = None;\n \n         if let Some(ref mut front) = self.frontiter {\n@@ -332,12 +351,19 @@ where\n     }\n \n     #[inline]\n-    fn rfold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n+    fn rfold<Acc, Fold>(self, init: Acc, ref mut fold: Fold) -> Acc\n         where Fold: FnMut(Acc, Self::Item) -> Acc,\n     {\n+        #[inline]\n+        fn flatten<U: DoubleEndedIterator, Acc>(\n+            fold: &mut impl FnMut(Acc, U::Item) -> Acc,\n+        ) -> impl FnMut(Acc, U) -> Acc + '_ {\n+            move |acc, iter| iter.rfold(acc, &mut *fold)\n+        }\n+\n         self.frontiter.into_iter()\n             .chain(self.iter.map(IntoIterator::into_iter))\n             .chain(self.backiter)\n-            .rfold(init, |acc, iter| iter.rfold(acc, &mut fold))\n+            .rfold(init, flatten(fold))\n     }\n }"}, {"sha": "58e0a70cefb75af91068ec84e9506c7df628f2d5", "filename": "src/libcore/iter/adapters/mod.rs", "status": "modified", "additions": 331, "deletions": 205, "changes": 536, "blob_url": "https://github.com/rust-lang/rust/blob/1cdcea920e56a5d0587307a4c9cf8fff5c77c4bc/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cdcea920e56a5d0587307a4c9cf8fff5c77c4bc/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs?ref=1cdcea920e56a5d0587307a4c9cf8fff5c77c4bc", "patch": "@@ -1,6 +1,6 @@\n use crate::cmp;\n use crate::fmt;\n-use crate::ops::Try;\n+use crate::ops::{Add, AddAssign, Try};\n use crate::usize;\n use crate::intrinsics;\n \n@@ -143,6 +143,18 @@ impl<I> Copied<I> {\n     }\n }\n \n+fn copy_fold<T: Copy, Acc>(\n+    mut f: impl FnMut(Acc, T) -> Acc,\n+) -> impl FnMut(Acc, &T) -> Acc {\n+    move |acc, &elt| f(acc, elt)\n+}\n+\n+fn copy_try_fold<T: Copy, Acc, R>(\n+    mut f: impl FnMut(Acc, T) -> R,\n+) -> impl FnMut(Acc, &T) -> R {\n+    move |acc, &elt| f(acc, elt)\n+}\n+\n #[stable(feature = \"iter_copied\", since = \"1.36.0\")]\n impl<'a, I, T: 'a> Iterator for Copied<I>\n     where I: Iterator<Item=&'a T>, T: Copy\n@@ -157,16 +169,16 @@ impl<'a, I, T: 'a> Iterator for Copied<I>\n         self.it.size_hint()\n     }\n \n-    fn try_fold<B, F, R>(&mut self, init: B, mut f: F) -> R where\n+    fn try_fold<B, F, R>(&mut self, init: B, f: F) -> R where\n         Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n     {\n-        self.it.try_fold(init, move |acc, &elt| f(acc, elt))\n+        self.it.try_fold(init, copy_try_fold(f))\n     }\n \n-    fn fold<Acc, F>(self, init: Acc, mut f: F) -> Acc\n+    fn fold<Acc, F>(self, init: Acc, f: F) -> Acc\n         where F: FnMut(Acc, Self::Item) -> Acc,\n     {\n-        self.it.fold(init, move |acc, &elt| f(acc, elt))\n+        self.it.fold(init, copy_fold(f))\n     }\n }\n \n@@ -178,16 +190,16 @@ impl<'a, I, T: 'a> DoubleEndedIterator for Copied<I>\n         self.it.next_back().copied()\n     }\n \n-    fn try_rfold<B, F, R>(&mut self, init: B, mut f: F) -> R where\n+    fn try_rfold<B, F, R>(&mut self, init: B, f: F) -> R where\n         Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n     {\n-        self.it.try_rfold(init, move |acc, &elt| f(acc, elt))\n+        self.it.try_rfold(init, copy_try_fold(f))\n     }\n \n-    fn rfold<Acc, F>(self, init: Acc, mut f: F) -> Acc\n+    fn rfold<Acc, F>(self, init: Acc, f: F) -> Acc\n         where F: FnMut(Acc, Self::Item) -> Acc,\n     {\n-        self.it.rfold(init, move |acc, &elt| f(acc, elt))\n+        self.it.rfold(init, copy_fold(f))\n     }\n }\n \n@@ -248,6 +260,12 @@ impl<I> Cloned<I> {\n     }\n }\n \n+fn clone_try_fold<T: Clone, Acc, R>(\n+    mut f: impl FnMut(Acc, T) -> R,\n+) -> impl FnMut(Acc, &T) -> R {\n+    move |acc, elt| f(acc, elt.clone())\n+}\n+\n #[stable(feature = \"iter_cloned\", since = \"1.1.0\")]\n impl<'a, I, T: 'a> Iterator for Cloned<I>\n     where I: Iterator<Item=&'a T>, T: Clone\n@@ -262,16 +280,16 @@ impl<'a, I, T: 'a> Iterator for Cloned<I>\n         self.it.size_hint()\n     }\n \n-    fn try_fold<B, F, R>(&mut self, init: B, mut f: F) -> R where\n+    fn try_fold<B, F, R>(&mut self, init: B, f: F) -> R where\n         Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n     {\n-        self.it.try_fold(init, move |acc, elt| f(acc, elt.clone()))\n+        self.it.try_fold(init, clone_try_fold(f))\n     }\n \n-    fn fold<Acc, F>(self, init: Acc, mut f: F) -> Acc\n+    fn fold<Acc, F>(self, init: Acc, f: F) -> Acc\n         where F: FnMut(Acc, Self::Item) -> Acc,\n     {\n-        self.it.fold(init, move |acc, elt| f(acc, elt.clone()))\n+        self.it.map(T::clone).fold(init, f)\n     }\n }\n \n@@ -283,16 +301,16 @@ impl<'a, I, T: 'a> DoubleEndedIterator for Cloned<I>\n         self.it.next_back().cloned()\n     }\n \n-    fn try_rfold<B, F, R>(&mut self, init: B, mut f: F) -> R where\n+    fn try_rfold<B, F, R>(&mut self, init: B, f: F) -> R where\n         Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n     {\n-        self.it.try_rfold(init, move |acc, elt| f(acc, elt.clone()))\n+        self.it.try_rfold(init, clone_try_fold(f))\n     }\n \n-    fn rfold<Acc, F>(self, init: Acc, mut f: F) -> Acc\n+    fn rfold<Acc, F>(self, init: Acc, f: F) -> Acc\n         where F: FnMut(Acc, Self::Item) -> Acc,\n     {\n-        self.it.rfold(init, move |acc, elt| f(acc, elt.clone()))\n+        self.it.map(T::clone).rfold(init, f)\n     }\n }\n \n@@ -430,14 +448,24 @@ impl<I> Iterator for StepBy<I> where I: Iterator {\n \n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        let inner_hint = self.iter.size_hint();\n+        #[inline]\n+        fn first_size(step: usize) -> impl Fn(usize) -> usize {\n+            move |n| if n == 0 { 0 } else { 1 + (n - 1) / (step + 1) }\n+        }\n+\n+        #[inline]\n+        fn other_size(step: usize) -> impl Fn(usize) -> usize {\n+            move |n| n / (step + 1)\n+        }\n+\n+        let (low, high) = self.iter.size_hint();\n \n         if self.first_take {\n-            let f = |n| if n == 0 { 0 } else { 1 + (n-1)/(self.step+1) };\n-            (f(inner_hint.0), inner_hint.1.map(f))\n+            let f = first_size(self.step);\n+            (f(low), high.map(f))\n         } else {\n-            let f = |n| n / (self.step+1);\n-            (f(inner_hint.0), inner_hint.1.map(f))\n+            let f = other_size(self.step);\n+            (f(low), high.map(f))\n         }\n     }\n \n@@ -594,6 +622,20 @@ impl<I: fmt::Debug, F> fmt::Debug for Map<I, F> {\n     }\n }\n \n+fn map_fold<T, B, Acc>(\n+    mut f: impl FnMut(T) -> B,\n+    mut g: impl FnMut(Acc, B) -> Acc,\n+) -> impl FnMut(Acc, T) -> Acc {\n+    move |acc, elt| g(acc, f(elt))\n+}\n+\n+fn map_try_fold<'a, T, B, Acc, R>(\n+    f: &'a mut impl FnMut(T) -> B,\n+    mut g: impl FnMut(Acc, B) -> R + 'a,\n+) -> impl FnMut(Acc, T) -> R + 'a {\n+    move |acc, elt| g(acc, f(elt))\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<B, I: Iterator, F> Iterator for Map<I, F> where F: FnMut(I::Item) -> B {\n     type Item = B;\n@@ -608,18 +650,16 @@ impl<B, I: Iterator, F> Iterator for Map<I, F> where F: FnMut(I::Item) -> B {\n         self.iter.size_hint()\n     }\n \n-    fn try_fold<Acc, G, R>(&mut self, init: Acc, mut g: G) -> R where\n+    fn try_fold<Acc, G, R>(&mut self, init: Acc, g: G) -> R where\n         Self: Sized, G: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n     {\n-        let f = &mut self.f;\n-        self.iter.try_fold(init, move |acc, elt| g(acc, f(elt)))\n+        self.iter.try_fold(init, map_try_fold(&mut self.f, g))\n     }\n \n-    fn fold<Acc, G>(self, init: Acc, mut g: G) -> Acc\n+    fn fold<Acc, G>(self, init: Acc, g: G) -> Acc\n         where G: FnMut(Acc, Self::Item) -> Acc,\n     {\n-        let mut f = self.f;\n-        self.iter.fold(init, move |acc, elt| g(acc, f(elt)))\n+        self.iter.fold(init, map_fold(self.f, g))\n     }\n }\n \n@@ -632,18 +672,16 @@ impl<B, I: DoubleEndedIterator, F> DoubleEndedIterator for Map<I, F> where\n         self.iter.next_back().map(&mut self.f)\n     }\n \n-    fn try_rfold<Acc, G, R>(&mut self, init: Acc, mut g: G) -> R where\n+    fn try_rfold<Acc, G, R>(&mut self, init: Acc, g: G) -> R where\n         Self: Sized, G: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n     {\n-        let f = &mut self.f;\n-        self.iter.try_rfold(init, move |acc, elt| g(acc, f(elt)))\n+        self.iter.try_rfold(init, map_try_fold(&mut self.f, g))\n     }\n \n-    fn rfold<Acc, G>(self, init: Acc, mut g: G) -> Acc\n+    fn rfold<Acc, G>(self, init: Acc, g: G) -> Acc\n         where G: FnMut(Acc, Self::Item) -> Acc,\n     {\n-        let mut f = self.f;\n-        self.iter.rfold(init, move |acc, elt| g(acc, f(elt)))\n+        self.iter.rfold(init, map_fold(self.f, g))\n     }\n }\n \n@@ -710,13 +748,27 @@ impl<I: fmt::Debug, P> fmt::Debug for Filter<I, P> {\n     }\n }\n \n+fn filter_fold<T, Acc>(\n+    mut predicate: impl FnMut(&T) -> bool,\n+    mut fold: impl FnMut(Acc, T) -> Acc,\n+) -> impl FnMut(Acc, T) -> Acc {\n+    move |acc, item| if predicate(&item) { fold(acc, item) } else { acc }\n+}\n+\n+fn filter_try_fold<'a, T, Acc, R: Try<Ok = Acc>>(\n+    predicate: &'a mut impl FnMut(&T) -> bool,\n+    mut fold: impl FnMut(Acc, T) -> R + 'a,\n+) -> impl FnMut(Acc, T) -> R + 'a {\n+    move |acc, item| if predicate(&item) { fold(acc, item) } else { R::from_ok(acc) }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I: Iterator, P> Iterator for Filter<I, P> where P: FnMut(&I::Item) -> bool {\n     type Item = I::Item;\n \n     #[inline]\n     fn next(&mut self) -> Option<I::Item> {\n-        self.try_for_each(Err).err()\n+        self.iter.find(&mut self.predicate)\n     }\n \n     #[inline]\n@@ -738,32 +790,26 @@ impl<I: Iterator, P> Iterator for Filter<I, P> where P: FnMut(&I::Item) -> bool\n     // leaving more budget for LLVM optimizations.\n     #[inline]\n     fn count(self) -> usize {\n-        let mut predicate = self.predicate;\n-        self.iter.map(|x| predicate(&x) as usize).sum()\n+        #[inline]\n+        fn to_usize<T>(mut predicate: impl FnMut(&T) -> bool) -> impl FnMut(T) -> usize {\n+            move |x| predicate(&x) as usize\n+        }\n+\n+        self.iter.map(to_usize(self.predicate)).sum()\n     }\n \n     #[inline]\n-    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n         Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n     {\n-        let predicate = &mut self.predicate;\n-        self.iter.try_fold(init, move |acc, item| if predicate(&item) {\n-            fold(acc, item)\n-        } else {\n-            Try::from_ok(acc)\n-        })\n+        self.iter.try_fold(init, filter_try_fold(&mut self.predicate, fold))\n     }\n \n     #[inline]\n-    fn fold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n+    fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n         where Fold: FnMut(Acc, Self::Item) -> Acc,\n     {\n-        let mut predicate = self.predicate;\n-        self.iter.fold(init, move |acc, item| if predicate(&item) {\n-            fold(acc, item)\n-        } else {\n-            acc\n-        })\n+        self.iter.fold(init, filter_fold(self.predicate, fold))\n     }\n }\n \n@@ -773,31 +819,21 @@ impl<I: DoubleEndedIterator, P> DoubleEndedIterator for Filter<I, P>\n {\n     #[inline]\n     fn next_back(&mut self) -> Option<I::Item> {\n-        self.try_rfold((), |_, x| Err(x)).err()\n+        self.iter.rfind(&mut self.predicate)\n     }\n \n     #[inline]\n-    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n+    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n         Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n     {\n-        let predicate = &mut self.predicate;\n-        self.iter.try_rfold(init, move |acc, item| if predicate(&item) {\n-            fold(acc, item)\n-        } else {\n-            Try::from_ok(acc)\n-        })\n+        self.iter.try_rfold(init, filter_try_fold(&mut self.predicate, fold))\n     }\n \n     #[inline]\n-    fn rfold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n+    fn rfold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n         where Fold: FnMut(Acc, Self::Item) -> Acc,\n     {\n-        let mut predicate = self.predicate;\n-        self.iter.rfold(init, move |acc, item| if predicate(&item) {\n-            fold(acc, item)\n-        } else {\n-            acc\n-        })\n+        self.iter.rfold(init, filter_fold(self.predicate, fold))\n     }\n }\n \n@@ -834,6 +870,26 @@ impl<I: fmt::Debug, F> fmt::Debug for FilterMap<I, F> {\n     }\n }\n \n+fn filter_map_fold<T, B, Acc>(\n+    mut f: impl FnMut(T) -> Option<B>,\n+    mut fold: impl FnMut(Acc, B) -> Acc,\n+) -> impl FnMut(Acc, T) -> Acc {\n+    move |acc, item| match f(item) {\n+        Some(x) => fold(acc, x),\n+        None => acc,\n+    }\n+}\n+\n+fn filter_map_try_fold<'a, T, B, Acc, R: Try<Ok = Acc>>(\n+    f: &'a mut impl FnMut(T) -> Option<B>,\n+    mut fold: impl FnMut(Acc, B) -> R + 'a,\n+) -> impl FnMut(Acc, T) -> R + 'a {\n+    move |acc, item| match f(item) {\n+        Some(x) => fold(acc, x),\n+        None => R::from_ok(acc),\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<B, I: Iterator, F> Iterator for FilterMap<I, F>\n     where F: FnMut(I::Item) -> Option<B>,\n@@ -842,7 +898,7 @@ impl<B, I: Iterator, F> Iterator for FilterMap<I, F>\n \n     #[inline]\n     fn next(&mut self) -> Option<B> {\n-        self.try_for_each(Err).err()\n+        self.iter.find_map(&mut self.f)\n     }\n \n     #[inline]\n@@ -852,25 +908,17 @@ impl<B, I: Iterator, F> Iterator for FilterMap<I, F>\n     }\n \n     #[inline]\n-    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n         Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n     {\n-        let f = &mut self.f;\n-        self.iter.try_fold(init, move |acc, item| match f(item) {\n-            Some(x) => fold(acc, x),\n-            None => Try::from_ok(acc),\n-        })\n+        self.iter.try_fold(init, filter_map_try_fold(&mut self.f, fold))\n     }\n \n     #[inline]\n-    fn fold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n+    fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n         where Fold: FnMut(Acc, Self::Item) -> Acc,\n     {\n-        let mut f = self.f;\n-        self.iter.fold(init, move |acc, item| match f(item) {\n-            Some(x) => fold(acc, x),\n-            None => acc,\n-        })\n+        self.iter.fold(init, filter_map_fold(self.f, fold))\n     }\n }\n \n@@ -880,29 +928,31 @@ impl<B, I: DoubleEndedIterator, F> DoubleEndedIterator for FilterMap<I, F>\n {\n     #[inline]\n     fn next_back(&mut self) -> Option<B> {\n-        self.try_rfold((), |_, x| Err(x)).err()\n+        #[inline]\n+        fn find<T, B>(\n+            f: &mut impl FnMut(T) -> Option<B>\n+        ) -> impl FnMut((), T) -> LoopState<(), B> + '_ {\n+            move |(), x| match f(x) {\n+                Some(x) => LoopState::Break(x),\n+                None => LoopState::Continue(()),\n+            }\n+        }\n+\n+        self.iter.try_rfold((), find(&mut self.f)).break_value()\n     }\n \n     #[inline]\n-    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n+    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n         Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n     {\n-        let f = &mut self.f;\n-        self.iter.try_rfold(init, move |acc, item| match f(item) {\n-            Some(x) => fold(acc, x),\n-            None => Try::from_ok(acc),\n-        })\n+        self.iter.try_rfold(init, filter_map_try_fold(&mut self.f, fold))\n     }\n \n     #[inline]\n-    fn rfold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n+    fn rfold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n         where Fold: FnMut(Acc, Self::Item) -> Acc,\n     {\n-        let mut f = self.f;\n-        self.iter.rfold(init, move |acc, item| match f(item) {\n-            Some(x) => fold(acc, x),\n-            None => acc,\n-        })\n+        self.iter.rfold(init, filter_map_fold(self.f, fold))\n     }\n }\n \n@@ -944,14 +994,12 @@ impl<I> Iterator for Enumerate<I> where I: Iterator {\n     ///\n     /// Might panic if the index of the element overflows a `usize`.\n     #[inline]\n-    #[rustc_inherit_overflow_checks]\n     fn next(&mut self) -> Option<(usize, <I as Iterator>::Item)> {\n-        self.iter.next().map(|a| {\n-            let ret = (self.count, a);\n-            // Possible undefined overflow.\n-            self.count += 1;\n-            ret\n-        })\n+        let a = self.iter.next()?;\n+        let i = self.count;\n+        // Possible undefined overflow.\n+        AddAssign::add_assign(&mut self.count, 1);\n+        Some((i, a))\n     }\n \n     #[inline]\n@@ -960,13 +1008,12 @@ impl<I> Iterator for Enumerate<I> where I: Iterator {\n     }\n \n     #[inline]\n-    #[rustc_inherit_overflow_checks]\n     fn nth(&mut self, n: usize) -> Option<(usize, I::Item)> {\n-        self.iter.nth(n).map(|a| {\n-            let i = self.count + n;\n-            self.count = i + 1;\n-            (i, a)\n-        })\n+        let a = self.iter.nth(n)?;\n+        // Possible undefined overflow.\n+        let i = Add::add(self.count, n);\n+        self.count = Add::add(i, 1);\n+        Some((i, a))\n     }\n \n     #[inline]\n@@ -975,29 +1022,43 @@ impl<I> Iterator for Enumerate<I> where I: Iterator {\n     }\n \n     #[inline]\n-    #[rustc_inherit_overflow_checks]\n-    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n         Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n     {\n-        let count = &mut self.count;\n-        self.iter.try_fold(init, move |acc, item| {\n-            let acc = fold(acc, (*count, item));\n-            *count += 1;\n-            acc\n-        })\n+        #[inline]\n+        fn enumerate<'a, T, Acc, R>(\n+            count: &'a mut usize,\n+            mut fold: impl FnMut(Acc, (usize, T)) -> R + 'a,\n+        ) -> impl FnMut(Acc, T) -> R + 'a {\n+            move |acc, item| {\n+                let acc = fold(acc, (*count, item));\n+                // Possible undefined overflow.\n+                AddAssign::add_assign(count, 1);\n+                acc\n+            }\n+        }\n+\n+        self.iter.try_fold(init, enumerate(&mut self.count, fold))\n     }\n \n     #[inline]\n-    #[rustc_inherit_overflow_checks]\n-    fn fold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n+    fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n         where Fold: FnMut(Acc, Self::Item) -> Acc,\n     {\n-        let mut count = self.count;\n-        self.iter.fold(init, move |acc, item| {\n-            let acc = fold(acc, (count, item));\n-            count += 1;\n-            acc\n-        })\n+        #[inline]\n+        fn enumerate<T, Acc>(\n+            mut count: usize,\n+            mut fold: impl FnMut(Acc, (usize, T)) -> Acc,\n+        ) -> impl FnMut(Acc, T) -> Acc {\n+            move |acc, item| {\n+                let acc = fold(acc, (count, item));\n+                // Possible undefined overflow.\n+                AddAssign::add_assign(&mut count, 1);\n+                acc\n+            }\n+        }\n+\n+        self.iter.fold(init, enumerate(self.count, fold))\n     }\n }\n \n@@ -1007,48 +1068,60 @@ impl<I> DoubleEndedIterator for Enumerate<I> where\n {\n     #[inline]\n     fn next_back(&mut self) -> Option<(usize, <I as Iterator>::Item)> {\n-        self.iter.next_back().map(|a| {\n-            let len = self.iter.len();\n-            // Can safely add, `ExactSizeIterator` promises that the number of\n-            // elements fits into a `usize`.\n-            (self.count + len, a)\n-        })\n+        let a = self.iter.next_back()?;\n+        let len = self.iter.len();\n+        // Can safely add, `ExactSizeIterator` promises that the number of\n+        // elements fits into a `usize`.\n+        Some((self.count + len, a))\n     }\n \n     #[inline]\n     fn nth_back(&mut self, n: usize) -> Option<(usize, <I as Iterator>::Item)> {\n-        self.iter.nth_back(n).map(|a| {\n-            let len = self.iter.len();\n-            // Can safely add, `ExactSizeIterator` promises that the number of\n-            // elements fits into a `usize`.\n-            (self.count + len, a)\n-        })\n+        let a = self.iter.nth_back(n)?;\n+        let len = self.iter.len();\n+        // Can safely add, `ExactSizeIterator` promises that the number of\n+        // elements fits into a `usize`.\n+        Some((self.count + len, a))\n     }\n \n     #[inline]\n-    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n+    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n         Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n     {\n         // Can safely add and subtract the count, as `ExactSizeIterator` promises\n         // that the number of elements fits into a `usize`.\n-        let mut count = self.count + self.iter.len();\n-        self.iter.try_rfold(init, move |acc, item| {\n-            count -= 1;\n-            fold(acc, (count, item))\n-        })\n+        fn enumerate<T, Acc, R>(\n+            mut count: usize,\n+            mut fold: impl FnMut(Acc, (usize, T)) -> R,\n+        ) -> impl FnMut(Acc, T) -> R {\n+            move |acc, item| {\n+                count -= 1;\n+                fold(acc, (count, item))\n+            }\n+        }\n+\n+        let count = self.count + self.iter.len();\n+        self.iter.try_rfold(init, enumerate(count, fold))\n     }\n \n     #[inline]\n-    fn rfold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n+    fn rfold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n         where Fold: FnMut(Acc, Self::Item) -> Acc,\n     {\n         // Can safely add and subtract the count, as `ExactSizeIterator` promises\n         // that the number of elements fits into a `usize`.\n-        let mut count = self.count + self.iter.len();\n-        self.iter.rfold(init, move |acc, item| {\n-            count -= 1;\n-            fold(acc, (count, item))\n-        })\n+        fn enumerate<T, Acc>(\n+            mut count: usize,\n+            mut fold: impl FnMut(Acc, (usize, T)) -> Acc,\n+        ) -> impl FnMut(Acc, T) -> Acc {\n+            move |acc, item| {\n+                count -= 1;\n+                fold(acc, (count, item))\n+            }\n+        }\n+\n+        let count = self.count + self.iter.len();\n+        self.iter.rfold(init, enumerate(count, fold))\n     }\n }\n \n@@ -1162,7 +1235,10 @@ impl<I: Iterator> Iterator for Peekable<I> {\n         };\n         let (lo, hi) = self.iter.size_hint();\n         let lo = lo.saturating_add(peek_len);\n-        let hi = hi.and_then(|x| x.checked_add(peek_len));\n+        let hi = match hi {\n+            Some(x) => x.checked_add(peek_len),\n+            None => None,\n+        };\n         (lo, hi)\n     }\n \n@@ -1321,16 +1397,23 @@ impl<I: Iterator, P> Iterator for SkipWhile<I, P>\n \n     #[inline]\n     fn next(&mut self) -> Option<I::Item> {\n+        fn check<'a, T>(\n+            flag: &'a mut bool,\n+            pred: &'a mut impl FnMut(&T) -> bool,\n+        ) -> impl FnMut(&T) -> bool + 'a {\n+            move |x| {\n+                if *flag || !pred(x) {\n+                    *flag = true;\n+                    true\n+                } else {\n+                    false\n+                }\n+            }\n+        }\n+\n         let flag = &mut self.flag;\n         let pred = &mut self.predicate;\n-        self.iter.find(move |x| {\n-            if *flag || !pred(x) {\n-                *flag = true;\n-                true\n-            } else {\n-                false\n-            }\n-        })\n+        self.iter.find(check(flag, pred))\n     }\n \n     #[inline]\n@@ -1412,14 +1495,13 @@ impl<I: Iterator, P> Iterator for TakeWhile<I, P>\n         if self.flag {\n             None\n         } else {\n-            self.iter.next().and_then(|x| {\n-                if (self.predicate)(&x) {\n-                    Some(x)\n-                } else {\n-                    self.flag = true;\n-                    None\n-                }\n-            })\n+            let x = self.iter.next()?;\n+            if (self.predicate)(&x) {\n+                Some(x)\n+            } else {\n+                self.flag = true;\n+                None\n+            }\n         }\n     }\n \n@@ -1434,22 +1516,30 @@ impl<I: Iterator, P> Iterator for TakeWhile<I, P>\n     }\n \n     #[inline]\n-    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n         Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n     {\n-        if self.flag {\n-            Try::from_ok(init)\n-        } else {\n-            let flag = &mut self.flag;\n-            let p = &mut self.predicate;\n-            self.iter.try_fold(init, move |acc, x|{\n+        fn check<'a, T, Acc, R: Try<Ok = Acc>>(\n+            flag: &'a mut bool,\n+            p: &'a mut impl FnMut(&T) -> bool,\n+            mut fold: impl FnMut(Acc, T) -> R + 'a,\n+        ) -> impl FnMut(Acc, T) -> LoopState<Acc, R> + 'a {\n+            move |acc, x| {\n                 if p(&x) {\n                     LoopState::from_try(fold(acc, x))\n                 } else {\n                     *flag = true;\n                     LoopState::Break(Try::from_ok(acc))\n                 }\n-            }).into_try()\n+            }\n+        }\n+\n+        if self.flag {\n+            Try::from_ok(init)\n+        } else {\n+            let flag = &mut self.flag;\n+            let p = &mut self.predicate;\n+            self.iter.try_fold(init, check(flag, p, fold)).into_try()\n         }\n     }\n }\n@@ -1534,7 +1624,10 @@ impl<I> Iterator for Skip<I> where I: Iterator {\n         let (lower, upper) = self.iter.size_hint();\n \n         let lower = lower.saturating_sub(self.n);\n-        let upper = upper.map(|x| x.saturating_sub(self.n));\n+        let upper = match upper {\n+            Some(x) => Some(x.saturating_sub(self.n)),\n+            None => None,\n+        };\n \n         (lower, upper)\n     }\n@@ -1595,19 +1688,26 @@ impl<I> DoubleEndedIterator for Skip<I> where I: DoubleEndedIterator + ExactSize\n         }\n     }\n \n-    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n+    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n         Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n     {\n-        let mut n = self.len();\n-        if n == 0 {\n-            Try::from_ok(init)\n-        } else {\n-            self.iter.try_rfold(init, move |acc, x| {\n+        fn check<T, Acc, R: Try<Ok = Acc>>(\n+            mut n: usize,\n+            mut fold: impl FnMut(Acc, T) -> R,\n+        ) -> impl FnMut(Acc, T) -> LoopState<Acc, R> {\n+            move |acc, x| {\n                 n -= 1;\n                 let r = fold(acc, x);\n                 if n == 0 { LoopState::Break(r) }\n                 else { LoopState::from_try(r) }\n-            }).into_try()\n+            }\n+        }\n+\n+        let n = self.len();\n+        if n == 0 {\n+            Try::from_ok(init)\n+        } else {\n+            self.iter.try_rfold(init, check(n, fold)).into_try()\n         }\n     }\n }\n@@ -1682,19 +1782,26 @@ impl<I> Iterator for Take<I> where I: Iterator{\n     }\n \n     #[inline]\n-    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n         Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n     {\n-        if self.n == 0 {\n-            Try::from_ok(init)\n-        } else {\n-            let n = &mut self.n;\n-            self.iter.try_fold(init, move |acc, x| {\n+        fn check<'a, T, Acc, R: Try<Ok = Acc>>(\n+            n: &'a mut usize,\n+            mut fold: impl FnMut(Acc, T) -> R + 'a,\n+        ) -> impl FnMut(Acc, T) -> LoopState<Acc, R> + 'a {\n+            move |acc, x| {\n                 *n -= 1;\n                 let r = fold(acc, x);\n                 if *n == 0 { LoopState::Break(r) }\n                 else { LoopState::from_try(r) }\n-            }).into_try()\n+            }\n+        }\n+\n+        if self.n == 0 {\n+            Try::from_ok(init)\n+        } else {\n+            let n = &mut self.n;\n+            self.iter.try_fold(init, check(n, fold)).into_try()\n         }\n     }\n }\n@@ -1793,7 +1900,8 @@ impl<B, I, St, F> Iterator for Scan<I, St, F> where\n \n     #[inline]\n     fn next(&mut self) -> Option<B> {\n-        self.iter.next().and_then(|a| (self.f)(&mut self.state, a))\n+        let a = self.iter.next()?;\n+        (self.f)(&mut self.state, a)\n     }\n \n     #[inline]\n@@ -1803,17 +1911,25 @@ impl<B, I, St, F> Iterator for Scan<I, St, F> where\n     }\n \n     #[inline]\n-    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n         Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n     {\n+        fn scan<'a, T, St, B, Acc, R: Try<Ok = Acc>>(\n+            state: &'a mut St,\n+            f: &'a mut impl FnMut(&mut St, T) -> Option<B>,\n+            mut fold: impl FnMut(Acc, B) -> R + 'a,\n+        ) -> impl FnMut(Acc, T) -> LoopState<Acc, R> + 'a {\n+            move |acc, x| {\n+                match f(state, x) {\n+                    None => LoopState::Break(Try::from_ok(acc)),\n+                    Some(x) => LoopState::from_try(fold(acc, x)),\n+                }\n+            }\n+        }\n+\n         let state = &mut self.state;\n         let f = &mut self.f;\n-        self.iter.try_fold(init, move |acc, x| {\n-            match f(state, x) {\n-                None => LoopState::Break(Try::from_ok(acc)),\n-                Some(x) => LoopState::from_try(fold(acc, x)),\n-            }\n-        }).into_try()\n+        self.iter.try_fold(init, scan(state, f, fold)).into_try()\n     }\n }\n \n@@ -2104,6 +2220,20 @@ impl<I: Iterator, F> Inspect<I, F> where F: FnMut(&I::Item) {\n     }\n }\n \n+fn inspect_fold<T, Acc>(\n+    mut f: impl FnMut(&T),\n+    mut fold: impl FnMut(Acc, T) -> Acc,\n+) -> impl FnMut(Acc, T) -> Acc {\n+    move |acc, item| { f(&item); fold(acc, item) }\n+}\n+\n+fn inspect_try_fold<'a, T, Acc, R>(\n+    f: &'a mut impl FnMut(&T),\n+    mut fold: impl FnMut(Acc, T) -> R + 'a,\n+) -> impl FnMut(Acc, T) -> R + 'a {\n+    move |acc, item| { f(&item); fold(acc, item) }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I: Iterator, F> Iterator for Inspect<I, F> where F: FnMut(&I::Item) {\n     type Item = I::Item;\n@@ -2120,19 +2250,17 @@ impl<I: Iterator, F> Iterator for Inspect<I, F> where F: FnMut(&I::Item) {\n     }\n \n     #[inline]\n-    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n         Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n     {\n-        let f = &mut self.f;\n-        self.iter.try_fold(init, move |acc, item| { f(&item); fold(acc, item) })\n+        self.iter.try_fold(init, inspect_try_fold(&mut self.f, fold))\n     }\n \n     #[inline]\n-    fn fold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n+    fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n         where Fold: FnMut(Acc, Self::Item) -> Acc,\n     {\n-        let mut f = self.f;\n-        self.iter.fold(init, move |acc, item| { f(&item); fold(acc, item) })\n+        self.iter.fold(init, inspect_fold(self.f, fold))\n     }\n }\n \n@@ -2147,19 +2275,17 @@ impl<I: DoubleEndedIterator, F> DoubleEndedIterator for Inspect<I, F>\n     }\n \n     #[inline]\n-    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n+    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n         Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n     {\n-        let f = &mut self.f;\n-        self.iter.try_rfold(init, move |acc, item| { f(&item); fold(acc, item) })\n+        self.iter.try_rfold(init, inspect_try_fold(&mut self.f, fold))\n     }\n \n     #[inline]\n-    fn rfold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n+    fn rfold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n         where Fold: FnMut(Acc, Self::Item) -> Acc,\n     {\n-        let mut f = self.f;\n-        self.iter.rfold(init, move |acc, item| { f(&item); fold(acc, item) })\n+        self.iter.rfold(init, inspect_fold(self.f, fold))\n     }\n }\n "}, {"sha": "430ceacdd9fab674aad4b958263f1326c2c0b099", "filename": "src/libcore/iter/adapters/zip.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1cdcea920e56a5d0587307a4c9cf8fff5c77c4bc/src%2Flibcore%2Fiter%2Fadapters%2Fzip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cdcea920e56a5d0587307a4c9cf8fff5c77c4bc/src%2Flibcore%2Fiter%2Fadapters%2Fzip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fadapters%2Fzip.rs?ref=1cdcea920e56a5d0587307a4c9cf8fff5c77c4bc", "patch": "@@ -94,11 +94,9 @@ impl<A, B> ZipImpl<A, B> for Zip<A, B>\n \n     #[inline]\n     default fn next(&mut self) -> Option<(A::Item, B::Item)> {\n-        self.a.next().and_then(|x| {\n-            self.b.next().and_then(|y| {\n-                Some((x, y))\n-            })\n-        })\n+        let x = self.a.next()?;\n+        let y = self.b.next()?;\n+        Some((x, y))\n     }\n \n     #[inline]"}, {"sha": "183176005ede9605ba289c018d6adbe18f6d69c5", "filename": "src/libcore/iter/sources.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1cdcea920e56a5d0587307a4c9cf8fff5c77c4bc/src%2Flibcore%2Fiter%2Fsources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cdcea920e56a5d0587307a4c9cf8fff5c77c4bc/src%2Flibcore%2Fiter%2Fsources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fsources.rs?ref=1cdcea920e56a5d0587307a4c9cf8fff5c77c4bc", "patch": "@@ -394,7 +394,8 @@ impl<A, F: FnOnce() -> A> Iterator for OnceWith<F> {\n \n     #[inline]\n     fn next(&mut self) -> Option<A> {\n-        self.gen.take().map(|f| f())\n+        let f = self.gen.take()?;\n+        Some(f())\n     }\n \n     #[inline]\n@@ -608,10 +609,9 @@ impl<T, F> Iterator for Successors<T, F>\n \n     #[inline]\n     fn next(&mut self) -> Option<Self::Item> {\n-        self.next.take().map(|item| {\n-            self.next = (self.succ)(&item);\n-            item\n-        })\n+        let item = self.next.take()?;\n+        self.next = (self.succ)(&item);\n+        Some(item)\n     }\n \n     #[inline]"}, {"sha": "818f03303298f7b250d50486ca144b629f0a9954", "filename": "src/libcore/iter/traits/accum.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1cdcea920e56a5d0587307a4c9cf8fff5c77c4bc/src%2Flibcore%2Fiter%2Ftraits%2Faccum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cdcea920e56a5d0587307a4c9cf8fff5c77c4bc/src%2Flibcore%2Fiter%2Ftraits%2Faccum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Faccum.rs?ref=1cdcea920e56a5d0587307a4c9cf8fff5c77c4bc", "patch": "@@ -85,28 +85,28 @@ macro_rules! float_sum_product {\n         #[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")]\n         impl Sum for $a {\n             fn sum<I: Iterator<Item=$a>>(iter: I) -> $a {\n-                iter.fold(0.0, |a, b| a + b)\n+                iter.fold(0.0, Add::add)\n             }\n         }\n \n         #[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")]\n         impl Product for $a {\n             fn product<I: Iterator<Item=$a>>(iter: I) -> $a {\n-                iter.fold(1.0, |a, b| a * b)\n+                iter.fold(1.0, Mul::mul)\n             }\n         }\n \n         #[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")]\n         impl<'a> Sum<&'a $a> for $a {\n             fn sum<I: Iterator<Item=&'a $a>>(iter: I) -> $a {\n-                iter.fold(0.0, |a, b| a + *b)\n+                iter.fold(0.0, Add::add)\n             }\n         }\n \n         #[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")]\n         impl<'a> Product<&'a $a> for $a {\n             fn product<I: Iterator<Item=&'a $a>>(iter: I) -> $a {\n-                iter.fold(1.0, |a, b| a * *b)\n+                iter.fold(1.0, Mul::mul)\n             }\n         }\n     )*)"}, {"sha": "8e5bc9b664cf0d705949c6df99a0336b921b4aea", "filename": "src/libcore/iter/traits/double_ended.rs", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/1cdcea920e56a5d0587307a4c9cf8fff5c77c4bc/src%2Flibcore%2Fiter%2Ftraits%2Fdouble_ended.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cdcea920e56a5d0587307a4c9cf8fff5c77c4bc/src%2Flibcore%2Fiter%2Ftraits%2Fdouble_ended.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fdouble_ended.rs?ref=1cdcea920e56a5d0587307a4c9cf8fff5c77c4bc", "patch": "@@ -219,12 +219,17 @@ pub trait DoubleEndedIterator: Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"iter_rfold\", since = \"1.27.0\")]\n-    fn rfold<B, F>(mut self, accum: B, mut f: F) -> B\n+    fn rfold<B, F>(mut self, accum: B, f: F) -> B\n     where\n         Self: Sized,\n         F: FnMut(B, Self::Item) -> B,\n     {\n-        self.try_rfold(accum, move |acc, x| Ok::<B, !>(f(acc, x))).unwrap()\n+        #[inline]\n+        fn ok<B, T>(mut f: impl FnMut(B, T) -> B) -> impl FnMut(B, T) -> Result<B, !> {\n+            move |acc, x| Ok(f(acc, x))\n+        }\n+\n+        self.try_rfold(accum, ok(f)).unwrap()\n     }\n \n     /// Searches for an element of an iterator from the back that satisfies a predicate.\n@@ -271,15 +276,21 @@ pub trait DoubleEndedIterator: Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"iter_rfind\", since = \"1.27.0\")]\n-    fn rfind<P>(&mut self, mut predicate: P) -> Option<Self::Item>\n+    fn rfind<P>(&mut self, predicate: P) -> Option<Self::Item>\n     where\n         Self: Sized,\n         P: FnMut(&Self::Item) -> bool\n     {\n-        self.try_rfold((), move |(), x| {\n-            if predicate(&x) { LoopState::Break(x) }\n-            else { LoopState::Continue(()) }\n-        }).break_value()\n+        #[inline]\n+        fn check<T>(\n+            mut predicate: impl FnMut(&T) -> bool,\n+        ) -> impl FnMut((), T) -> LoopState<(), T> {\n+            move |(), x| {\n+                if predicate(&x) { LoopState::Break(x) } else { LoopState::Continue(()) }\n+            }\n+        }\n+\n+        self.try_rfold((), check(predicate)).break_value()\n     }\n }\n "}, {"sha": "d644787d2c462678e9af0b4ad494d34dc170730c", "filename": "src/libcore/iter/traits/iterator.rs", "status": "modified", "additions": 177, "deletions": 72, "changes": 249, "blob_url": "https://github.com/rust-lang/rust/blob/1cdcea920e56a5d0587307a4c9cf8fff5c77c4bc/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cdcea920e56a5d0587307a4c9cf8fff5c77c4bc/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs?ref=1cdcea920e56a5d0587307a4c9cf8fff5c77c4bc", "patch": "@@ -1,5 +1,5 @@\n use crate::cmp::Ordering;\n-use crate::ops::Try;\n+use crate::ops::{Add, Try};\n \n use super::super::LoopState;\n use super::super::{Chain, Cycle, Copied, Cloned, Enumerate, Filter, FilterMap, Fuse};\n@@ -234,11 +234,15 @@ pub trait Iterator {\n     /// assert_eq!(a.iter().count(), 5);\n     /// ```\n     #[inline]\n-    #[rustc_inherit_overflow_checks]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn count(self) -> usize where Self: Sized {\n-        // Might overflow.\n-        self.fold(0, |cnt, _| cnt + 1)\n+        #[inline]\n+        fn add1<T>(count: usize, _: T) -> usize {\n+            // Might overflow.\n+            Add::add(count, 1)\n+        }\n+\n+        self.fold(0, add1)\n     }\n \n     /// Consumes the iterator, returning the last element.\n@@ -263,7 +267,12 @@ pub trait Iterator {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn last(self) -> Option<Self::Item> where Self: Sized {\n-        self.fold(None, |_, x| Some(x))\n+        #[inline]\n+        fn some<T>(_: Option<T>, x: T) -> Option<T> {\n+            Some(x)\n+        }\n+\n+        self.fold(None, some)\n     }\n \n     /// Returns the `n`th element of the iterator.\n@@ -596,10 +605,15 @@ pub trait Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"iterator_for_each\", since = \"1.21.0\")]\n-    fn for_each<F>(self, mut f: F) where\n+    fn for_each<F>(self, f: F) where\n         Self: Sized, F: FnMut(Self::Item),\n     {\n-        self.fold((), move |(), item| f(item));\n+        #[inline]\n+        fn call<T>(mut f: impl FnMut(T)) -> impl FnMut((), T) {\n+            move |(), item| f(item)\n+        }\n+\n+        self.fold((), call(f));\n     }\n \n     /// Creates an iterator which uses a closure to determine if an element\n@@ -1490,21 +1504,30 @@ pub trait Iterator {\n     /// assert_eq!(odd, vec![1, 3]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn partition<B, F>(self, mut f: F) -> (B, B) where\n+    fn partition<B, F>(self, f: F) -> (B, B) where\n         Self: Sized,\n         B: Default + Extend<Self::Item>,\n         F: FnMut(&Self::Item) -> bool\n     {\n+        #[inline]\n+        fn extend<'a, T, B: Extend<T>>(\n+            mut f: impl FnMut(&T) -> bool + 'a,\n+            left: &'a mut B,\n+            right: &'a mut B,\n+        ) -> impl FnMut(T) + 'a {\n+            move |x| {\n+                if f(&x) {\n+                    left.extend(Some(x));\n+                } else {\n+                    right.extend(Some(x));\n+                }\n+            }\n+        }\n+\n         let mut left: B = Default::default();\n         let mut right: B = Default::default();\n \n-        self.for_each(|x| {\n-            if f(&x) {\n-                left.extend(Some(x))\n-            } else {\n-                right.extend(Some(x))\n-            }\n-        });\n+        self.for_each(extend(f, &mut left, &mut right));\n \n         (left, right)\n     }\n@@ -1702,10 +1725,15 @@ pub trait Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"iterator_try_fold\", since = \"1.27.0\")]\n-    fn try_for_each<F, R>(&mut self, mut f: F) -> R where\n+    fn try_for_each<F, R>(&mut self, f: F) -> R where\n         Self: Sized, F: FnMut(Self::Item) -> R, R: Try<Ok=()>\n     {\n-        self.try_fold((), move |(), x| f(x))\n+        #[inline]\n+        fn call<T, R>(mut f: impl FnMut(T) -> R) -> impl FnMut((), T) -> R {\n+            move |(), x| f(x)\n+        }\n+\n+        self.try_fold((), call(f))\n     }\n \n     /// An iterator method that applies a function, producing a single, final value.\n@@ -1777,10 +1805,15 @@ pub trait Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn fold<B, F>(mut self, init: B, mut f: F) -> B where\n+    fn fold<B, F>(mut self, init: B, f: F) -> B where\n         Self: Sized, F: FnMut(B, Self::Item) -> B,\n     {\n-        self.try_fold(init, move |acc, x| Ok::<B, !>(f(acc, x))).unwrap()\n+        #[inline]\n+        fn ok<B, T>(mut f: impl FnMut(B, T) -> B) -> impl FnMut(B, T) -> Result<B, !> {\n+            move |acc, x| Ok(f(acc, x))\n+        }\n+\n+        self.try_fold(init, ok(f)).unwrap()\n     }\n \n     /// Tests if every element of the iterator matches a predicate.\n@@ -1822,13 +1855,18 @@ pub trait Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn all<F>(&mut self, mut f: F) -> bool where\n+    fn all<F>(&mut self, f: F) -> bool where\n         Self: Sized, F: FnMut(Self::Item) -> bool\n     {\n-        self.try_for_each(move |x| {\n-            if f(x) { LoopState::Continue(()) }\n-            else { LoopState::Break(()) }\n-        }) == LoopState::Continue(())\n+        #[inline]\n+        fn check<T>(mut f: impl FnMut(T) -> bool) -> impl FnMut(T) -> LoopState<(), ()> {\n+            move |x| {\n+                if f(x) { LoopState::Continue(()) }\n+                else { LoopState::Break(()) }\n+            }\n+        }\n+\n+        self.try_for_each(check(f)) == LoopState::Continue(())\n     }\n \n     /// Tests if any element of the iterator matches a predicate.\n@@ -1870,14 +1908,19 @@ pub trait Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn any<F>(&mut self, mut f: F) -> bool where\n+    fn any<F>(&mut self, f: F) -> bool where\n         Self: Sized,\n         F: FnMut(Self::Item) -> bool\n     {\n-        self.try_for_each(move |x| {\n-            if f(x) { LoopState::Break(()) }\n-            else { LoopState::Continue(()) }\n-        }) == LoopState::Break(())\n+        #[inline]\n+        fn check<T>(mut f: impl FnMut(T) -> bool) -> impl FnMut(T) -> LoopState<(), ()> {\n+            move |x| {\n+                if f(x) { LoopState::Break(()) }\n+                else { LoopState::Continue(()) }\n+            }\n+        }\n+\n+        self.try_for_each(check(f)) == LoopState::Break(())\n     }\n \n     /// Searches for an element of an iterator that satisfies a predicate.\n@@ -1924,14 +1967,19 @@ pub trait Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn find<P>(&mut self, mut predicate: P) -> Option<Self::Item> where\n+    fn find<P>(&mut self, predicate: P) -> Option<Self::Item> where\n         Self: Sized,\n         P: FnMut(&Self::Item) -> bool,\n     {\n-        self.try_for_each(move |x| {\n-            if predicate(&x) { LoopState::Break(x) }\n-            else { LoopState::Continue(()) }\n-        }).break_value()\n+        #[inline]\n+        fn check<T>(mut predicate: impl FnMut(&T) -> bool) -> impl FnMut(T) -> LoopState<(), T> {\n+            move |x| {\n+                if predicate(&x) { LoopState::Break(x) }\n+                else { LoopState::Continue(()) }\n+            }\n+        }\n+\n+        self.try_for_each(check(predicate)).break_value()\n     }\n \n     /// Applies function to the elements of iterator and returns\n@@ -1951,16 +1999,19 @@ pub trait Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"iterator_find_map\", since = \"1.30.0\")]\n-    fn find_map<B, F>(&mut self, mut f: F) -> Option<B> where\n+    fn find_map<B, F>(&mut self, f: F) -> Option<B> where\n         Self: Sized,\n         F: FnMut(Self::Item) -> Option<B>,\n     {\n-        self.try_for_each(move |x| {\n-            match f(x) {\n+        #[inline]\n+        fn check<T, B>(mut f: impl FnMut(T) -> Option<B>) -> impl FnMut(T) -> LoopState<(), B> {\n+            move |x| match f(x) {\n                 Some(x) => LoopState::Break(x),\n                 None => LoopState::Continue(()),\n             }\n-        }).break_value()\n+        }\n+\n+        self.try_for_each(check(f)).break_value()\n     }\n \n     /// Searches for an element in an iterator, returning its index.\n@@ -2018,17 +2069,23 @@ pub trait Iterator {\n     ///\n     /// ```\n     #[inline]\n-    #[rustc_inherit_overflow_checks]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn position<P>(&mut self, mut predicate: P) -> Option<usize> where\n+    fn position<P>(&mut self, predicate: P) -> Option<usize> where\n         Self: Sized,\n         P: FnMut(Self::Item) -> bool,\n     {\n-        // The addition might panic on overflow\n-        self.try_fold(0, move |i, x| {\n-            if predicate(x) { LoopState::Break(i) }\n-            else { LoopState::Continue(i + 1) }\n-        }).break_value()\n+        #[inline]\n+        fn check<T>(\n+            mut predicate: impl FnMut(T) -> bool,\n+        ) -> impl FnMut(usize, T) -> LoopState<usize, usize> {\n+            // The addition might panic on overflow\n+            move |i, x| {\n+                if predicate(x) { LoopState::Break(i) }\n+                else { LoopState::Continue(Add::add(i, 1)) }\n+            }\n+        }\n+\n+        self.try_fold(0, check(predicate)).break_value()\n     }\n \n     /// Searches for an element in an iterator from the right, returning its\n@@ -2071,18 +2128,25 @@ pub trait Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn rposition<P>(&mut self, mut predicate: P) -> Option<usize> where\n+    fn rposition<P>(&mut self, predicate: P) -> Option<usize> where\n         P: FnMut(Self::Item) -> bool,\n         Self: Sized + ExactSizeIterator + DoubleEndedIterator\n     {\n         // No need for an overflow check here, because `ExactSizeIterator`\n         // implies that the number of elements fits into a `usize`.\n+        #[inline]\n+        fn check<T>(\n+            mut predicate: impl FnMut(T) -> bool,\n+        ) -> impl FnMut(usize, T) -> LoopState<usize, usize> {\n+            move |i, x| {\n+                let i = i - 1;\n+                if predicate(x) { LoopState::Break(i) }\n+                else { LoopState::Continue(i) }\n+            }\n+        }\n+\n         let n = self.len();\n-        self.try_rfold(n, move |i, x| {\n-            let i = i - 1;\n-            if predicate(x) { LoopState::Break(i) }\n-            else { LoopState::Continue(i) }\n-        }).break_value()\n+        self.try_rfold(n, check(predicate)).break_value()\n     }\n \n     /// Returns the maximum element of an iterator.\n@@ -2151,11 +2215,22 @@ pub trait Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"iter_cmp_by_key\", since = \"1.6.0\")]\n-    fn max_by_key<B: Ord, F>(self, mut f: F) -> Option<Self::Item>\n+    fn max_by_key<B: Ord, F>(self, f: F) -> Option<Self::Item>\n         where Self: Sized, F: FnMut(&Self::Item) -> B,\n     {\n+        #[inline]\n+        fn key<T, B>(mut f: impl FnMut(&T) -> B) -> impl FnMut(T) -> (B, T) {\n+            move |x| (f(&x), x)\n+        }\n+\n         // switch to y even if it is only equal, to preserve stability.\n-        select_fold1(self.map(|x| (f(&x), x)), |(x_p, _), (y_p, _)| x_p <= y_p).map(|(_, x)| x)\n+        #[inline]\n+        fn select<T, B: Ord>((x_p, _): &(B, T), (y_p, _): &(B, T)) -> bool {\n+            x_p <= y_p\n+        }\n+\n+        let (_, x) = select_fold1(self.map(key(f)), select)?;\n+        Some(x)\n     }\n \n     /// Returns the element that gives the maximum value with respect to the\n@@ -2174,11 +2249,16 @@ pub trait Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"iter_max_by\", since = \"1.15.0\")]\n-    fn max_by<F>(self, mut compare: F) -> Option<Self::Item>\n+    fn max_by<F>(self, compare: F) -> Option<Self::Item>\n         where Self: Sized, F: FnMut(&Self::Item, &Self::Item) -> Ordering,\n     {\n         // switch to y even if it is only equal, to preserve stability.\n-        select_fold1(self, |x, y| compare(x, y) != Ordering::Greater)\n+        #[inline]\n+        fn select<T>(mut compare: impl FnMut(&T, &T) -> Ordering) -> impl FnMut(&T, &T) -> bool {\n+            move |x, y| compare(x, y) != Ordering::Greater\n+        }\n+\n+        select_fold1(self, select(compare))\n     }\n \n     /// Returns the element that gives the minimum value from the\n@@ -2195,12 +2275,24 @@ pub trait Iterator {\n     /// let a = [-3_i32, 0, 1, 5, -10];\n     /// assert_eq!(*a.iter().min_by_key(|x| x.abs()).unwrap(), 0);\n     /// ```\n+    #[inline]\n     #[stable(feature = \"iter_cmp_by_key\", since = \"1.6.0\")]\n-    fn min_by_key<B: Ord, F>(self, mut f: F) -> Option<Self::Item>\n+    fn min_by_key<B: Ord, F>(self, f: F) -> Option<Self::Item>\n         where Self: Sized, F: FnMut(&Self::Item) -> B,\n     {\n+        #[inline]\n+        fn key<T, B>(mut f: impl FnMut(&T) -> B) -> impl FnMut(T) -> (B, T) {\n+            move |x| (f(&x), x)\n+        }\n+\n         // only switch to y if it is strictly smaller, to preserve stability.\n-        select_fold1(self.map(|x| (f(&x), x)), |(x_p, _), (y_p, _)| x_p > y_p).map(|(_, x)| x)\n+        #[inline]\n+        fn select<T, B: Ord>((x_p, _): &(B, T), (y_p, _): &(B, T)) -> bool {\n+            x_p > y_p\n+        }\n+\n+        let (_, x) = select_fold1(self.map(key(f)), select)?;\n+        Some(x)\n     }\n \n     /// Returns the element that gives the minimum value with respect to the\n@@ -2219,11 +2311,16 @@ pub trait Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"iter_min_by\", since = \"1.15.0\")]\n-    fn min_by<F>(self, mut compare: F) -> Option<Self::Item>\n+    fn min_by<F>(self, compare: F) -> Option<Self::Item>\n         where Self: Sized, F: FnMut(&Self::Item, &Self::Item) -> Ordering,\n     {\n         // only switch to y if it is strictly smaller, to preserve stability.\n-        select_fold1(self, |x, y| compare(x, y) == Ordering::Greater)\n+        #[inline]\n+        fn select<T>(mut compare: impl FnMut(&T, &T) -> Ordering) -> impl FnMut(&T, &T) -> bool {\n+            move |x, y| compare(x, y) == Ordering::Greater\n+        }\n+\n+        select_fold1(self, select(compare))\n     }\n \n \n@@ -2284,13 +2381,20 @@ pub trait Iterator {\n         FromB: Default + Extend<B>,\n         Self: Sized + Iterator<Item=(A, B)>,\n     {\n+        fn extend<'a, A, B>(\n+            ts: &'a mut impl Extend<A>,\n+            us: &'a mut impl Extend<B>,\n+        ) -> impl FnMut((A, B)) + 'a {\n+            move |(t, u)| {\n+                ts.extend(Some(t));\n+                us.extend(Some(u));\n+            }\n+        }\n+\n         let mut ts: FromA = Default::default();\n         let mut us: FromB = Default::default();\n \n-        self.for_each(|(t, u)| {\n-            ts.extend(Some(t));\n-            us.extend(Some(u));\n-        });\n+        self.for_each(extend(&mut ts, &mut us));\n \n         (ts, us)\n     }\n@@ -2617,7 +2721,7 @@ pub trait Iterator {\n         Self: Sized,\n         Self::Item: PartialOrd,\n     {\n-        self.is_sorted_by(|a, b| a.partial_cmp(b))\n+        self.is_sorted_by(PartialOrd::partial_cmp)\n     }\n \n     /// Checks if the elements of this iterator are sorted using the given comparator function.\n@@ -2639,10 +2743,7 @@ pub trait Iterator {\n         };\n \n         while let Some(curr) = self.next() {\n-            if compare(&last, &curr)\n-                .map(|o| o == Ordering::Greater)\n-                .unwrap_or(true)\n-            {\n+            if let Some(Ordering::Greater) | None = compare(&last, &curr) {\n                 return false;\n             }\n             last = curr;\n@@ -2687,17 +2788,21 @@ pub trait Iterator {\n /// commonalities of {max,min}{,_by}. In particular, this avoids\n /// having to implement optimizations several times.\n #[inline]\n-fn select_fold1<I, F>(mut it: I, mut f: F) -> Option<I::Item>\n+fn select_fold1<I, F>(mut it: I, f: F) -> Option<I::Item>\n     where\n         I: Iterator,\n         F: FnMut(&I::Item, &I::Item) -> bool,\n {\n+    #[inline]\n+    fn select<T>(mut f: impl FnMut(&T, &T) -> bool) -> impl FnMut(T, T) -> T {\n+        move |sel, x| if f(&sel, &x) { x } else { sel }\n+    }\n+\n     // start with the first element as our selection. This avoids\n     // having to use `Option`s inside the loop, translating to a\n     // sizeable performance gain (6x in one case).\n-    it.next().map(|first| {\n-        it.fold(first, |sel, x| if f(&sel, &x) { x } else { sel })\n-    })\n+    let first = it.next()?;\n+    Some(it.fold(first, select(f)))\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "ec58f7068abac0b276f9304b313d7574efebd647", "filename": "src/test/codegen/iter-fold-closure-no-dupes.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1cdcea920e56a5d0587307a4c9cf8fff5c77c4bc/src%2Ftest%2Fcodegen%2Fiter-fold-closure-no-dupes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cdcea920e56a5d0587307a4c9cf8fff5c77c4bc/src%2Ftest%2Fcodegen%2Fiter-fold-closure-no-dupes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fiter-fold-closure-no-dupes.rs?ref=1cdcea920e56a5d0587307a4c9cf8fff5c77c4bc", "patch": "@@ -0,0 +1,14 @@\n+//! Check that fold closures aren't duplicated for each iterator type.\n+// compile-flags: -C opt-level=0\n+\n+fn main() {\n+    (0i32..10).by_ref().count();\n+    (0i32..=10).by_ref().count();\n+}\n+\n+// `count` calls `fold`, which calls `try_fold` -- find the `fold` closure:\n+// CHECK: {{^define.*Iterator::fold::.*closure}}\n+//\n+// Only one closure is needed for both `count` calls, even from different\n+// monomorphized iterator types, as it's only generic over the item type.\n+// CHECK-NOT: {{^define.*Iterator::fold::.*closure}}"}, {"sha": "fbeafd5f395827b8774b5bd1695f4e2560a1d015", "filename": "src/test/codegen/iter-fold-closure-no-iterator.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1cdcea920e56a5d0587307a4c9cf8fff5c77c4bc/src%2Ftest%2Fcodegen%2Fiter-fold-closure-no-iterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cdcea920e56a5d0587307a4c9cf8fff5c77c4bc/src%2Ftest%2Fcodegen%2Fiter-fold-closure-no-iterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fiter-fold-closure-no-iterator.rs?ref=1cdcea920e56a5d0587307a4c9cf8fff5c77c4bc", "patch": "@@ -0,0 +1,10 @@\n+//! Check that fold closures aren't generic in the iterator type.\n+// compile-flags: -C opt-level=0\n+\n+fn main() {\n+    (0i32..10).by_ref().count();\n+}\n+\n+// `count` calls `fold`, which calls `try_fold` -- that `fold` closure should\n+// not be generic in the iterator type, only in the item type.\n+// CHECK-NOT: {{^define.*Iterator::fold::.*closure.*Range}}"}, {"sha": "d6612035750836e49accc865a8f2d05dcaeb35b3", "filename": "src/test/ui/iterators/iter-count-overflow-debug.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1cdcea920e56a5d0587307a4c9cf8fff5c77c4bc/src%2Ftest%2Fui%2Fiterators%2Fiter-count-overflow-debug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cdcea920e56a5d0587307a4c9cf8fff5c77c4bc/src%2Ftest%2Fui%2Fiterators%2Fiter-count-overflow-debug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fiterators%2Fiter-count-overflow-debug.rs?ref=1cdcea920e56a5d0587307a4c9cf8fff5c77c4bc", "patch": "@@ -0,0 +1,16 @@\n+// run-pass\n+// only-32bit too impatient for 2\u2076\u2074 items\n+// ignore-wasm32-bare compiled with panic=abort by default\n+// compile-flags: -C debug_assertions=yes -C opt-level=3\n+\n+use std::panic;\n+use std::usize::MAX;\n+\n+fn main() {\n+    assert_eq!((0..MAX).by_ref().count(), MAX);\n+\n+    let r = panic::catch_unwind(|| {\n+        (0..=MAX).by_ref().count()\n+    });\n+    assert!(r.is_err());\n+}"}, {"sha": "b755bb554f4418da870a96d5426d8c0fc2fddd69", "filename": "src/test/ui/iterators/iter-count-overflow-ndebug.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1cdcea920e56a5d0587307a4c9cf8fff5c77c4bc/src%2Ftest%2Fui%2Fiterators%2Fiter-count-overflow-ndebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cdcea920e56a5d0587307a4c9cf8fff5c77c4bc/src%2Ftest%2Fui%2Fiterators%2Fiter-count-overflow-ndebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fiterators%2Fiter-count-overflow-ndebug.rs?ref=1cdcea920e56a5d0587307a4c9cf8fff5c77c4bc", "patch": "@@ -0,0 +1,11 @@\n+// run-pass\n+// only-32bit too impatient for 2\u2076\u2074 items\n+// compile-flags: -C debug_assertions=no -C opt-level=3\n+\n+use std::panic;\n+use std::usize::MAX;\n+\n+fn main() {\n+    assert_eq!((0..MAX).by_ref().count(), MAX);\n+    assert_eq!((0..=MAX).by_ref().count(), 0);\n+}"}, {"sha": "8ce4fcd873174a88b260819094097cf0e2850259", "filename": "src/test/ui/iterators/iter-map-fold-type-length.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/1cdcea920e56a5d0587307a4c9cf8fff5c77c4bc/src%2Ftest%2Fui%2Fiterators%2Fiter-map-fold-type-length.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cdcea920e56a5d0587307a4c9cf8fff5c77c4bc/src%2Ftest%2Fui%2Fiterators%2Fiter-map-fold-type-length.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fiterators%2Fiter-map-fold-type-length.rs?ref=1cdcea920e56a5d0587307a4c9cf8fff5c77c4bc", "patch": "@@ -0,0 +1,38 @@\n+// run-pass\n+//! Check that type lengths don't explode with `Map` folds.\n+//!\n+//! The normal limit is a million, and this test used to exceed 1.5 million, but\n+//! now we can survive an even tighter limit. Still seems excessive though...\n+#![type_length_limit = \"256000\"]\n+\n+// Custom wrapper so Iterator methods aren't specialized.\n+struct Iter<I>(I);\n+\n+impl<I> Iterator for Iter<I>\n+where\n+    I: Iterator\n+{\n+    type Item = I::Item;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        self.0.next()\n+    }\n+}\n+\n+fn main() {\n+    let c = Iter(0i32..10)\n+        .map(|x| x)\n+        .map(|x| x)\n+        .map(|x| x)\n+        .map(|x| x)\n+        .map(|x| x)\n+        .map(|x| x)\n+        .map(|x| x)\n+        .map(|x| x)\n+        .map(|x| x)\n+        .map(|x| x)\n+        .map(|x| x)\n+        .map(|x| x)\n+        .count();\n+    assert_eq!(c, 10);\n+}"}, {"sha": "f1eded31702c4449d4ebf383127d13b251d84b81", "filename": "src/test/ui/iterators/iter-position-overflow-debug.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1cdcea920e56a5d0587307a4c9cf8fff5c77c4bc/src%2Ftest%2Fui%2Fiterators%2Fiter-position-overflow-debug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cdcea920e56a5d0587307a4c9cf8fff5c77c4bc/src%2Ftest%2Fui%2Fiterators%2Fiter-position-overflow-debug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fiterators%2Fiter-position-overflow-debug.rs?ref=1cdcea920e56a5d0587307a4c9cf8fff5c77c4bc", "patch": "@@ -0,0 +1,22 @@\n+// run-pass\n+// only-32bit too impatient for 2\u2076\u2074 items\n+// ignore-wasm32-bare compiled with panic=abort by default\n+// compile-flags: -C debug_assertions=yes -C opt-level=3\n+\n+use std::panic;\n+use std::usize::MAX;\n+\n+fn main() {\n+    let n = MAX as u64;\n+    assert_eq!((0..).by_ref().position(|i| i >= n), Some(MAX));\n+\n+    let r = panic::catch_unwind(|| {\n+        (0..).by_ref().position(|i| i > n)\n+    });\n+    assert!(r.is_err());\n+\n+    let r = panic::catch_unwind(|| {\n+        (0..=n + 1).by_ref().position(|_| false)\n+    });\n+    assert!(r.is_err());\n+}"}, {"sha": "368f9c0c02b07d3ab933f0123dd330c5f78da774", "filename": "src/test/ui/iterators/iter-position-overflow-ndebug.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1cdcea920e56a5d0587307a4c9cf8fff5c77c4bc/src%2Ftest%2Fui%2Fiterators%2Fiter-position-overflow-ndebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cdcea920e56a5d0587307a4c9cf8fff5c77c4bc/src%2Ftest%2Fui%2Fiterators%2Fiter-position-overflow-ndebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fiterators%2Fiter-position-overflow-ndebug.rs?ref=1cdcea920e56a5d0587307a4c9cf8fff5c77c4bc", "patch": "@@ -0,0 +1,13 @@\n+// run-pass\n+// only-32bit too impatient for 2\u2076\u2074 items\n+// compile-flags: -C debug_assertions=no -C opt-level=3\n+\n+use std::panic;\n+use std::usize::MAX;\n+\n+fn main() {\n+    let n = MAX as u64;\n+    assert_eq!((0..).by_ref().position(|i| i >= n), Some(MAX));\n+    assert_eq!((0..).by_ref().position(|i| i > n), Some(0));\n+    assert_eq!((0..=n + 1).by_ref().position(|_| false), None);\n+}"}]}