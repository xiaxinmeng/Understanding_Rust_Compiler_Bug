{"sha": "7a4df3b53da369110984a2b57419c05a53e33b38", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdhNGRmM2I1M2RhMzY5MTEwOTg0YTJiNTc0MTljMDVhNTNlMzNiMzg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-03-19T14:30:42Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-03-19T14:30:42Z"}, "message": "Auto merge of #59293 - Centril:rollup, r=Centril\n\nRollup of 11 pull requests\n\nSuccessful merges:\n\n - #56348 (Add todo!() macro)\n - #57729 (extra testing of how NLL handles wildcard type `_`)\n - #57847 (dbg!() without parameters)\n - #58778 (Implement ExactSizeIterator for ToLowercase and ToUppercase)\n - #58812 (Clarify distinction between floor() and trunc())\n - #58939 (Fix a tiny error in documentation of std::pin.)\n - #59116 (Be more discerning on when to attempt suggesting a comma in a macro invocation)\n - #59252 (add self to mailmap)\n - #59275 (Replaced self-reflective explicit types with clearer `Self` or `Self::\u2026` in stdlib docs)\n - #59280 (Stabilize refcell_map_split feature)\n - #59290 (Run branch cleanup after copy prop)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "629101116811e4754e95aadc38f9e9a3dd60b888", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/629101116811e4754e95aadc38f9e9a3dd60b888"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7a4df3b53da369110984a2b57419c05a53e33b38", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7a4df3b53da369110984a2b57419c05a53e33b38", "html_url": "https://github.com/rust-lang/rust/commit/7a4df3b53da369110984a2b57419c05a53e33b38", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7a4df3b53da369110984a2b57419c05a53e33b38/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ef4d1c419525e1510aa650e2bec0d8f7449a2130", "url": "https://api.github.com/repos/rust-lang/rust/commits/ef4d1c419525e1510aa650e2bec0d8f7449a2130", "html_url": "https://github.com/rust-lang/rust/commit/ef4d1c419525e1510aa650e2bec0d8f7449a2130"}, {"sha": "7f7829fa8f917b584c38ed0f0ec03ebaa4e2e1f0", "url": "https://api.github.com/repos/rust-lang/rust/commits/7f7829fa8f917b584c38ed0f0ec03ebaa4e2e1f0", "html_url": "https://github.com/rust-lang/rust/commit/7f7829fa8f917b584c38ed0f0ec03ebaa4e2e1f0"}], "stats": {"total": 387, "additions": 315, "deletions": 72}, "files": [{"sha": "120d1f1457e65798fbdead21f6fa634988f4fe3e", "filename": ".mailmap", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7a4df3b53da369110984a2b57419c05a53e33b38/.mailmap", "raw_url": "https://github.com/rust-lang/rust/raw/7a4df3b53da369110984a2b57419c05a53e33b38/.mailmap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.mailmap?ref=7a4df3b53da369110984a2b57419c05a53e33b38", "patch": "@@ -29,6 +29,7 @@ Ariel Ben-Yehuda <arielb1@mail.tau.ac.il> Ariel Ben-Yehuda <ariel.byd@gmail.com>\n Ariel Ben-Yehuda <arielb1@mail.tau.ac.il> arielb1 <arielb1@mail.tau.ac.il>\n Austin Seipp <mad.one@gmail.com> <as@hacks.yi.org>\n Aydin Kim <ladinjin@hanmail.net> aydin.kim <aydin.kim@samsung.com>\n+Bastian Kauschke <bastian_kauschke@hotmail.de>\n Barosl Lee <vcs@barosl.com> Barosl LEE <github@barosl.com>\n Ben Alpert <ben@benalpert.com> <spicyjalapeno@gmail.com>\n Ben Sago <ogham@users.noreply.github.com> Ben S <ogham@bsago.me>"}, {"sha": "753f10e6a0ad04cbc14f8c61b9e0dff360e5e044", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7a4df3b53da369110984a2b57419c05a53e33b38/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a4df3b53da369110984a2b57419c05a53e33b38/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=7a4df3b53da369110984a2b57419c05a53e33b38", "patch": "@@ -1186,7 +1186,6 @@ impl<'b, T: ?Sized> Ref<'b, T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(refcell_map_split)]\n     /// use std::cell::{Ref, RefCell};\n     ///\n     /// let cell = RefCell::new([1, 2, 3, 4]);\n@@ -1195,7 +1194,7 @@ impl<'b, T: ?Sized> Ref<'b, T> {\n     /// assert_eq!(*begin, [1, 2]);\n     /// assert_eq!(*end, [3, 4]);\n     /// ```\n-    #[unstable(feature = \"refcell_map_split\", issue = \"51476\")]\n+    #[stable(feature = \"refcell_map_split\", since = \"1.35.0\")]\n     #[inline]\n     pub fn map_split<U: ?Sized, V: ?Sized, F>(orig: Ref<'b, T>, f: F) -> (Ref<'b, U>, Ref<'b, V>)\n         where F: FnOnce(&T) -> (&U, &V)\n@@ -1268,7 +1267,6 @@ impl<'b, T: ?Sized> RefMut<'b, T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(refcell_map_split)]\n     /// use std::cell::{RefCell, RefMut};\n     ///\n     /// let cell = RefCell::new([1, 2, 3, 4]);\n@@ -1279,7 +1277,7 @@ impl<'b, T: ?Sized> RefMut<'b, T> {\n     /// begin.copy_from_slice(&[4, 3]);\n     /// end.copy_from_slice(&[2, 1]);\n     /// ```\n-    #[unstable(feature = \"refcell_map_split\", issue = \"51476\")]\n+    #[stable(feature = \"refcell_map_split\", since = \"1.35.0\")]\n     #[inline]\n     pub fn map_split<U: ?Sized, V: ?Sized, F>(\n         orig: RefMut<'b, T>, f: F"}, {"sha": "6683976642d402dad9c186a50bdc6f9d44bf3158", "filename": "src/libcore/char/mod.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7a4df3b53da369110984a2b57419c05a53e33b38/src%2Flibcore%2Fchar%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a4df3b53da369110984a2b57419c05a53e33b38/src%2Flibcore%2Fchar%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fmod.rs?ref=7a4df3b53da369110984a2b57419c05a53e33b38", "patch": "@@ -389,11 +389,17 @@ impl Iterator for ToLowercase {\n     fn next(&mut self) -> Option<char> {\n         self.0.next()\n     }\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.0.size_hint()\n+    }\n }\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl FusedIterator for ToLowercase {}\n \n+#[stable(feature = \"exact_size_case_mapping_iter\", since = \"1.35.0\")]\n+impl ExactSizeIterator for ToLowercase {}\n+\n /// Returns an iterator that yields the uppercase equivalent of a `char`.\n ///\n /// This `struct` is created by the [`to_uppercase`] method on [`char`]. See\n@@ -411,11 +417,17 @@ impl Iterator for ToUppercase {\n     fn next(&mut self) -> Option<char> {\n         self.0.next()\n     }\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.0.size_hint()\n+    }\n }\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl FusedIterator for ToUppercase {}\n \n+#[stable(feature = \"exact_size_case_mapping_iter\", since = \"1.35.0\")]\n+impl ExactSizeIterator for ToUppercase {}\n+\n #[derive(Debug, Clone)]\n enum CaseMappingIter {\n     Three(char, char, char),\n@@ -457,6 +469,16 @@ impl Iterator for CaseMappingIter {\n             CaseMappingIter::Zero => None,\n         }\n     }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let size = match self {\n+            CaseMappingIter::Three(..) => 3,\n+            CaseMappingIter::Two(..) => 2,\n+            CaseMappingIter::One(_) => 1,\n+            CaseMappingIter::Zero => 0,\n+        };\n+        (size, Some(size))\n+    }\n }\n \n impl fmt::Display for CaseMappingIter {"}, {"sha": "ea52b0ea7212054dea929b0a3eb85d7e0fe7c981", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7a4df3b53da369110984a2b57419c05a53e33b38/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a4df3b53da369110984a2b57419c05a53e33b38/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=7a4df3b53da369110984a2b57419c05a53e33b38", "patch": "@@ -72,7 +72,7 @@ use self::Ordering::*;\n /// }\n ///\n /// impl PartialEq for Book {\n-///     fn eq(&self, other: &Book) -> bool {\n+///     fn eq(&self, other: &Self) -> bool {\n ///         self.isbn == other.isbn\n ///     }\n /// }\n@@ -233,7 +233,7 @@ pub trait PartialEq<Rhs: ?Sized = Self> {\n ///     format: BookFormat,\n /// }\n /// impl PartialEq for Book {\n-///     fn eq(&self, other: &Book) -> bool {\n+///     fn eq(&self, other: &Self) -> bool {\n ///         self.isbn == other.isbn\n ///     }\n /// }\n@@ -493,19 +493,19 @@ impl<T: Ord> Ord for Reverse<T> {\n /// }\n ///\n /// impl Ord for Person {\n-///     fn cmp(&self, other: &Person) -> Ordering {\n+///     fn cmp(&self, other: &Self) -> Ordering {\n ///         self.height.cmp(&other.height)\n ///     }\n /// }\n ///\n /// impl PartialOrd for Person {\n-///     fn partial_cmp(&self, other: &Person) -> Option<Ordering> {\n+///     fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n ///         Some(self.cmp(other))\n ///     }\n /// }\n ///\n /// impl PartialEq for Person {\n-///     fn eq(&self, other: &Person) -> bool {\n+///     fn eq(&self, other: &Self) -> bool {\n ///         self.height == other.height\n ///     }\n /// }\n@@ -691,13 +691,13 @@ impl PartialOrd for Ordering {\n /// }\n ///\n /// impl PartialOrd for Person {\n-///     fn partial_cmp(&self, other: &Person) -> Option<Ordering> {\n+///     fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n ///         self.height.partial_cmp(&other.height)\n ///     }\n /// }\n ///\n /// impl PartialEq for Person {\n-///     fn eq(&self, other: &Person) -> bool {\n+///     fn eq(&self, other: &Self) -> bool {\n ///         self.height == other.height\n ///     }\n /// }"}, {"sha": "e6a616b680228c821f6c4f04aa6bd99022de7cff", "filename": "src/libcore/iter/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a4df3b53da369110984a2b57419c05a53e33b38/src%2Flibcore%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a4df3b53da369110984a2b57419c05a53e33b38/src%2Flibcore%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fmod.rs?ref=7a4df3b53da369110984a2b57419c05a53e33b38", "patch": "@@ -101,7 +101,7 @@\n //!     type Item = usize;\n //!\n //!     // next() is the only required method\n-//!     fn next(&mut self) -> Option<usize> {\n+//!     fn next(&mut self) -> Option<Self::Item> {\n //!         // Increment our count. This is why we started at zero.\n //!         self.count += 1;\n //!"}, {"sha": "cd61ab5c552b677948aacbb67c131e1862b3b1d4", "filename": "src/libcore/iter/traits/collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a4df3b53da369110984a2b57419c05a53e33b38/src%2Flibcore%2Fiter%2Ftraits%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a4df3b53da369110984a2b57419c05a53e33b38/src%2Flibcore%2Fiter%2Ftraits%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fcollect.rs?ref=7a4df3b53da369110984a2b57419c05a53e33b38", "patch": "@@ -167,7 +167,7 @@ pub trait FromIterator<A>: Sized {\n /// // and we'll implement IntoIterator\n /// impl IntoIterator for MyCollection {\n ///     type Item = i32;\n-///     type IntoIter = ::std::vec::IntoIter<i32>;\n+///     type IntoIter = ::std::vec::IntoIter<Self::Item>;\n ///\n ///     fn into_iter(self) -> Self::IntoIter {\n ///         self.0.into_iter()"}, {"sha": "8fc4ac93daa68115d0834b97d9a8ddcbc6dccfb6", "filename": "src/libcore/iter/traits/exact_size.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a4df3b53da369110984a2b57419c05a53e33b38/src%2Flibcore%2Fiter%2Ftraits%2Fexact_size.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a4df3b53da369110984a2b57419c05a53e33b38/src%2Flibcore%2Fiter%2Ftraits%2Fexact_size.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fexact_size.rs?ref=7a4df3b53da369110984a2b57419c05a53e33b38", "patch": "@@ -45,7 +45,7 @@\n /// # }\n /// # impl Iterator for Counter {\n /// #     type Item = usize;\n-/// #     fn next(&mut self) -> Option<usize> {\n+/// #     fn next(&mut self) -> Option<Self::Item> {\n /// #         self.count += 1;\n /// #         if self.count < 6 {\n /// #             Some(self.count)"}, {"sha": "d77936c7ddd913fe9cad93e213742ff693a6bb9f", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/7a4df3b53da369110984a2b57419c05a53e33b38/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a4df3b53da369110984a2b57419c05a53e33b38/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=7a4df3b53da369110984a2b57419c05a53e33b38", "patch": "@@ -559,6 +559,65 @@ macro_rules! unimplemented {\n     ($($arg:tt)+) => (panic!(\"not yet implemented: {}\", format_args!($($arg)*)));\n }\n \n+/// A standardized placeholder for marking unfinished code.\n+///\n+/// This can be useful if you are prototyping and are just looking to have your\n+/// code typecheck. `todo!` works exactly like `unimplemented!`, there only\n+/// difference between the two macros is the name.\n+///\n+/// # Panics\n+///\n+/// This will always [panic!](macro.panic.html)\n+///\n+/// # Examples\n+///\n+/// Here's an example of some in-progress code. We have a trait `Foo`:\n+///\n+/// ```\n+/// trait Foo {\n+///     fn bar(&self);\n+///     fn baz(&self);\n+/// }\n+/// ```\n+///\n+/// We want to implement `Foo` on one of our types, but we also want to work on\n+/// just `bar()` first. In order for our code to compile, we need to implement\n+/// `baz()`, so we can use `todo!`:\n+///\n+/// ```\n+/// #![feature(todo_macro)]\n+///\n+/// # trait Foo {\n+/// #     fn bar(&self);\n+/// #     fn baz(&self);\n+/// # }\n+/// struct MyStruct;\n+///\n+/// impl Foo for MyStruct {\n+///     fn bar(&self) {\n+///         // implementation goes here\n+///     }\n+///\n+///     fn baz(&self) {\n+///         // let's not worry about implementing baz() for now\n+///         todo!();\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     let s = MyStruct;\n+///     s.bar();\n+///\n+///     // we aren't even using baz() yet, so this is fine.\n+/// }\n+/// ```\n+#[macro_export]\n+#[unstable(feature = \"todo_macro\", issue = \"59277\")]\n+macro_rules! todo {\n+    () => (panic!(\"not yet implemented\"));\n+    ($($arg:tt)+) => (panic!(\"not yet implemented: {}\", format_args!($($arg)*)));\n+}\n+\n /// A macro to create an array of [`MaybeUninit`]\n ///\n /// This macro constructs an uninitialized array of the type `[MaybeUninit<K>; N]`."}, {"sha": "c5e908d7bb86bdb29940c630158f28c4b27c4c60", "filename": "src/libcore/ops/arith.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/7a4df3b53da369110984a2b57419c05a53e33b38/src%2Flibcore%2Fops%2Farith.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a4df3b53da369110984a2b57419c05a53e33b38/src%2Flibcore%2Fops%2Farith.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Farith.rs?ref=7a4df3b53da369110984a2b57419c05a53e33b38", "patch": "@@ -20,10 +20,10 @@\n /// }\n ///\n /// impl Add for Point {\n-///     type Output = Point;\n+///     type Output = Self;\n ///\n-///     fn add(self, other: Point) -> Point {\n-///         Point {\n+///     fn add(self, other: Self) -> Self {\n+///         Self {\n ///             x: self.x + other.x,\n ///             y: self.y + other.y,\n ///         }\n@@ -50,10 +50,10 @@\n ///\n /// // Notice that the implementation uses the associated type `Output`.\n /// impl<T: Add<Output = T>> Add for Point<T> {\n-///     type Output = Point<T>;\n+///     type Output = Self;\n ///\n-///     fn add(self, other: Point<T>) -> Point<T> {\n-///         Point {\n+///     fn add(self, other: Self) -> Self::Output {\n+///         Self {\n ///             x: self.x + other.x,\n ///             y: self.y + other.y,\n ///         }\n@@ -158,9 +158,9 @@ add_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n ///\n /// // Notice that the implementation uses the associated type `Output`.\n /// impl<T: Sub<Output = T>> Sub for Point<T> {\n-///     type Output = Point<T>;\n+///     type Output = Self;\n ///\n-///     fn sub(self, other: Point<T>) -> Point<T> {\n+///     fn sub(self, other: Self) -> Self::Output {\n ///         Point {\n ///             x: self.x - other.x,\n ///             y: self.y - other.y,\n@@ -280,9 +280,9 @@ sub_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n /// struct Vector { value: Vec<usize> }\n ///\n /// impl Mul<Scalar> for Vector {\n-///     type Output = Vector;\n+///     type Output = Self;\n ///\n-///     fn mul(self, rhs: Scalar) -> Vector {\n+///     fn mul(self, rhs: Scalar) -> Self::Output {\n ///         Vector { value: self.value.iter().map(|v| v * rhs.value).collect() }\n ///     }\n /// }\n@@ -364,7 +364,7 @@ mul_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n ///     // The division of rational numbers is a closed operation.\n ///     type Output = Self;\n ///\n-///     fn div(self, rhs: Self) -> Self {\n+///     fn div(self, rhs: Self) -> Self::Output {\n ///         if rhs.nominator == 0 {\n ///             panic!(\"Cannot divide by zero-valued `Rational`!\");\n ///         }\n@@ -404,9 +404,9 @@ mul_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n /// struct Vector { value: Vec<f32> }\n ///\n /// impl Div<Scalar> for Vector {\n-///     type Output = Vector;\n+///     type Output = Self;\n ///\n-///     fn div(self, rhs: Scalar) -> Vector {\n+///     fn div(self, rhs: Scalar) -> Self::Output {\n ///         Vector { value: self.value.iter().map(|v| v / rhs.value).collect() }\n ///     }\n /// }\n@@ -485,9 +485,9 @@ div_impl_float! { f32 f64 }\n /// }\n ///\n /// impl<'a, T> Rem<usize> for SplitSlice<'a, T> {\n-///     type Output = SplitSlice<'a, T>;\n+///     type Output = Self;\n ///\n-///     fn rem(self, modulus: usize) -> Self {\n+///     fn rem(self, modulus: usize) -> Self::Output {\n ///         let len = self.slice.len();\n ///         let rem = len % modulus;\n ///         let start = len - rem;\n@@ -571,7 +571,7 @@ rem_impl_float! { f32 f64 }\n /// impl Neg for Sign {\n ///     type Output = Sign;\n ///\n-///     fn neg(self) -> Sign {\n+///     fn neg(self) -> Self::Output {\n ///         match self {\n ///             Sign::Negative => Sign::Positive,\n ///             Sign::Zero => Sign::Zero,\n@@ -650,8 +650,8 @@ neg_impl_numeric! { isize i8 i16 i32 i64 i128 f32 f64 }\n /// }\n ///\n /// impl AddAssign for Point {\n-///     fn add_assign(&mut self, other: Point) {\n-///         *self = Point {\n+///     fn add_assign(&mut self, other: Self) {\n+///         *self = Self {\n ///             x: self.x + other.x,\n ///             y: self.y + other.y,\n ///         };\n@@ -706,8 +706,8 @@ add_assign_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n /// }\n ///\n /// impl SubAssign for Point {\n-///     fn sub_assign(&mut self, other: Point) {\n-///         *self = Point {\n+///     fn sub_assign(&mut self, other: Self) {\n+///         *self = Self {\n ///             x: self.x - other.x,\n ///             y: self.y - other.y,\n ///         };"}, {"sha": "c3615bdaafca97d8d10096109bc0e8c76acd9153", "filename": "src/libcore/ops/bit.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7a4df3b53da369110984a2b57419c05a53e33b38/src%2Flibcore%2Fops%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a4df3b53da369110984a2b57419c05a53e33b38/src%2Flibcore%2Fops%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Fbit.rs?ref=7a4df3b53da369110984a2b57419c05a53e33b38", "patch": "@@ -17,7 +17,7 @@\n /// impl Not for Answer {\n ///     type Output = Answer;\n ///\n-///     fn not(self) -> Answer {\n+///     fn not(self) -> Self::Output {\n ///         match self {\n ///             Answer::Yes => Answer::No,\n ///             Answer::No => Answer::Yes\n@@ -75,7 +75,7 @@ not_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n ///     type Output = Self;\n ///\n ///     // rhs is the \"right-hand side\" of the expression `a & b`\n-///     fn bitand(self, rhs: Self) -> Self {\n+///     fn bitand(self, rhs: Self) -> Self::Output {\n ///         Scalar(self.0 & rhs.0)\n ///     }\n /// }\n@@ -97,7 +97,7 @@ not_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n /// impl BitAnd for BooleanVector {\n ///     type Output = Self;\n ///\n-///     fn bitand(self, BooleanVector(rhs): Self) -> Self {\n+///     fn bitand(self, BooleanVector(rhs): Self) -> Self::Output {\n ///         let BooleanVector(lhs) = self;\n ///         assert_eq!(lhs.len(), rhs.len());\n ///         BooleanVector(lhs.iter().zip(rhs.iter()).map(|(x, y)| *x && *y).collect())\n@@ -181,7 +181,7 @@ bitand_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n /// impl BitOr for BooleanVector {\n ///     type Output = Self;\n ///\n-///     fn bitor(self, BooleanVector(rhs): Self) -> Self {\n+///     fn bitor(self, BooleanVector(rhs): Self) -> Self::Output {\n ///         let BooleanVector(lhs) = self;\n ///         assert_eq!(lhs.len(), rhs.len());\n ///         BooleanVector(lhs.iter().zip(rhs.iter()).map(|(x, y)| *x || *y).collect())\n@@ -243,7 +243,7 @@ bitor_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n ///     type Output = Self;\n ///\n ///     // rhs is the \"right-hand side\" of the expression `a ^ b`\n-///     fn bitxor(self, rhs: Self) -> Self {\n+///     fn bitxor(self, rhs: Self) -> Self::Output {\n ///         Scalar(self.0 ^ rhs.0)\n ///     }\n /// }\n@@ -265,7 +265,7 @@ bitor_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n /// impl BitXor for BooleanVector {\n ///     type Output = Self;\n ///\n-///     fn bitxor(self, BooleanVector(rhs): Self) -> Self {\n+///     fn bitxor(self, BooleanVector(rhs): Self) -> Self::Output {\n ///         let BooleanVector(lhs) = self;\n ///         assert_eq!(lhs.len(), rhs.len());\n ///         BooleanVector(lhs.iter()\n@@ -355,7 +355,7 @@ bitxor_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n /// impl<T: Clone> Shl<usize> for SpinVector<T> {\n ///     type Output = Self;\n ///\n-///     fn shl(self, rhs: usize) -> SpinVector<T> {\n+///     fn shl(self, rhs: usize) -> Self::Output {\n ///         // Rotate the vector by `rhs` places.\n ///         let (a, b) = self.vec.split_at(rhs);\n ///         let mut spun_vector: Vec<T> = vec![];\n@@ -464,7 +464,7 @@ shl_impl_all! { u8 u16 u32 u64 u128 usize i8 i16 i32 i64 isize i128 }\n /// impl<T: Clone> Shr<usize> for SpinVector<T> {\n ///     type Output = Self;\n ///\n-///     fn shr(self, rhs: usize) -> SpinVector<T> {\n+///     fn shr(self, rhs: usize) -> Self::Output {\n ///         // Rotate the vector by `rhs` places.\n ///         let (a, b) = self.vec.split_at(self.vec.len() - rhs);\n ///         let mut spun_vector: Vec<T> = vec![];"}, {"sha": "e44a6c4d2a0e92a13d35ccc978d56ba5030df1b8", "filename": "src/libcore/ops/deref.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7a4df3b53da369110984a2b57419c05a53e33b38/src%2Flibcore%2Fops%2Fderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a4df3b53da369110984a2b57419c05a53e33b38/src%2Flibcore%2Fops%2Fderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Fderef.rs?ref=7a4df3b53da369110984a2b57419c05a53e33b38", "patch": "@@ -49,7 +49,7 @@\n /// impl<T> Deref for DerefExample<T> {\n ///     type Target = T;\n ///\n-///     fn deref(&self) -> &T {\n+///     fn deref(&self) -> &Self::Target {\n ///         &self.value\n ///     }\n /// }\n@@ -139,13 +139,13 @@ impl<T: ?Sized> Deref for &mut T {\n /// impl<T> Deref for DerefMutExample<T> {\n ///     type Target = T;\n ///\n-///     fn deref(&self) -> &T {\n+///     fn deref(&self) -> &Self::Target {\n ///         &self.value\n ///     }\n /// }\n ///\n /// impl<T> DerefMut for DerefMutExample<T> {\n-///     fn deref_mut(&mut self) -> &mut T {\n+///     fn deref_mut(&mut self) -> &mut Self::Target {\n ///         &mut self.value\n ///     }\n /// }"}, {"sha": "3158f58e958068c75d8b108d6846a1a229f80c06", "filename": "src/libcore/ops/index.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7a4df3b53da369110984a2b57419c05a53e33b38/src%2Flibcore%2Fops%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a4df3b53da369110984a2b57419c05a53e33b38/src%2Flibcore%2Fops%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Findex.rs?ref=7a4df3b53da369110984a2b57419c05a53e33b38", "patch": "@@ -33,7 +33,7 @@\n /// impl Index<Nucleotide> for NucleotideCount {\n ///     type Output = usize;\n ///\n-///     fn index(&self, nucleotide: Nucleotide) -> &usize {\n+///     fn index(&self, nucleotide: Nucleotide) -> &Self::Output {\n ///         match nucleotide {\n ///             Nucleotide::A => &self.a,\n ///             Nucleotide::C => &self.c,\n@@ -105,7 +105,7 @@ pub trait Index<Idx: ?Sized> {\n /// impl Index<Side> for Balance {\n ///     type Output = Weight;\n ///\n-///     fn index<'a>(&'a self, index: Side) -> &'a Weight {\n+///     fn index<'a>(&'a self, index: Side) -> &'a Self::Output {\n ///         println!(\"Accessing {:?}-side of balance immutably\", index);\n ///         match index {\n ///             Side::Left => &self.left,\n@@ -115,7 +115,7 @@ pub trait Index<Idx: ?Sized> {\n /// }\n ///\n /// impl IndexMut<Side> for Balance {\n-///     fn index_mut<'a>(&'a mut self, index: Side) -> &'a mut Weight {\n+///     fn index_mut<'a>(&'a mut self, index: Side) -> &'a mut Self::Output {\n ///         println!(\"Accessing {:?}-side of balance mutably\", index);\n ///         match index {\n ///             Side::Left => &mut self.left,"}, {"sha": "57bd3ed12b28e8c9ad9f163628af0baf4c694f6a", "filename": "src/libcore/pin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a4df3b53da369110984a2b57419c05a53e33b38/src%2Flibcore%2Fpin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a4df3b53da369110984a2b57419c05a53e33b38/src%2Flibcore%2Fpin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpin.rs?ref=7a4df3b53da369110984a2b57419c05a53e33b38", "patch": "@@ -109,7 +109,7 @@\n //! assert_eq!(still_unmoved.slice, NonNull::from(&still_unmoved.data));\n //!\n //! // Since our type doesn't implement Unpin, this will fail to compile:\n-//! // let new_unmoved = Unmovable::new(\"world\".to_string());\n+//! // let mut new_unmoved = Unmovable::new(\"world\".to_string());\n //! // std::mem::swap(&mut *still_unmoved, &mut *new_unmoved);\n //! ```\n //!"}, {"sha": "57e9f4e384e0fe5557db7d35c86adeb36579ff06", "filename": "src/libcore/tests/char.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a4df3b53da369110984a2b57419c05a53e33b38/src%2Flibcore%2Ftests%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a4df3b53da369110984a2b57419c05a53e33b38/src%2Flibcore%2Ftests%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fchar.rs?ref=7a4df3b53da369110984a2b57419c05a53e33b38", "patch": "@@ -76,6 +76,8 @@ fn test_to_digit() {\n #[test]\n fn test_to_lowercase() {\n     fn lower(c: char) -> String {\n+        let to_lowercase = c.to_lowercase();\n+        assert_eq!(to_lowercase.len(), to_lowercase.count());\n         let iter: String = c.to_lowercase().collect();\n         let disp: String = c.to_lowercase().to_string();\n         assert_eq!(iter, disp);\n@@ -101,6 +103,8 @@ fn test_to_lowercase() {\n #[test]\n fn test_to_uppercase() {\n     fn upper(c: char) -> String {\n+        let to_uppercase = c.to_uppercase();\n+        assert_eq!(to_uppercase.len(), to_uppercase.count());\n         let iter: String = c.to_uppercase().collect();\n         let disp: String = c.to_uppercase().to_string();\n         assert_eq!(iter, disp);"}, {"sha": "08dda4bcc3d24403f69f3bfa1396a87ebc802d87", "filename": "src/libcore/tests/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7a4df3b53da369110984a2b57419c05a53e33b38/src%2Flibcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a4df3b53da369110984a2b57419c05a53e33b38/src%2Flibcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flib.rs?ref=7a4df3b53da369110984a2b57419c05a53e33b38", "patch": "@@ -16,7 +16,6 @@\n #![feature(pattern)]\n #![feature(range_is_empty)]\n #![feature(raw)]\n-#![feature(refcell_map_split)]\n #![feature(refcell_replace_swap)]\n #![feature(slice_patterns)]\n #![feature(sort_internals)]"}, {"sha": "8df0d72407b79e03733e66a731c339d898a6c7ca", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7a4df3b53da369110984a2b57419c05a53e33b38/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a4df3b53da369110984a2b57419c05a53e33b38/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=7a4df3b53da369110984a2b57419c05a53e33b38", "patch": "@@ -285,6 +285,7 @@ fn optimized_mir<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx\n         &simplify_branches::SimplifyBranches::new(\"after-const-prop\"),\n         &deaggregator::Deaggregator,\n         &copy_prop::CopyPropagation,\n+        &simplify_branches::SimplifyBranches::new(\"after-copy-prop\"),\n         &remove_noop_landing_pads::RemoveNoopLandingPads,\n         &simplify::SimplifyCfg::new(\"final\"),\n         &simplify::SimplifyLocals,"}, {"sha": "2fabe30fa93661a831dd4c728f02dd730e2af398", "filename": "src/libstd/f32.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7a4df3b53da369110984a2b57419c05a53e33b38/src%2Flibstd%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a4df3b53da369110984a2b57419c05a53e33b38/src%2Flibstd%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff32.rs?ref=7a4df3b53da369110984a2b57419c05a53e33b38", "patch": "@@ -32,11 +32,13 @@ impl f32 {\n     /// # Examples\n     ///\n     /// ```\n-    /// let f = 3.99_f32;\n+    /// let f = 3.7_f32;\n     /// let g = 3.0_f32;\n+    /// let h = -3.7_f32;\n     ///\n     /// assert_eq!(f.floor(), 3.0);\n     /// assert_eq!(g.floor(), 3.0);\n+    /// assert_eq!(h.floor(), -4.0);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -104,11 +106,13 @@ impl f32 {\n     /// # Examples\n     ///\n     /// ```\n-    /// let f = 3.3_f32;\n-    /// let g = -3.7_f32;\n+    /// let f = 3.7_f32;\n+    /// let g = 3.0_f32;\n+    /// let h = -3.7_f32;\n     ///\n     /// assert_eq!(f.trunc(), 3.0);\n-    /// assert_eq!(g.trunc(), -3.0);\n+    /// assert_eq!(g.trunc(), 3.0);\n+    /// assert_eq!(h.trunc(), -3.0);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]"}, {"sha": "a471117f6d6fdaf0789b3cc0822a06da18472c1d", "filename": "src/libstd/f64.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7a4df3b53da369110984a2b57419c05a53e33b38/src%2Flibstd%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a4df3b53da369110984a2b57419c05a53e33b38/src%2Flibstd%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff64.rs?ref=7a4df3b53da369110984a2b57419c05a53e33b38", "patch": "@@ -32,11 +32,13 @@ impl f64 {\n     /// # Examples\n     ///\n     /// ```\n-    /// let f = 3.99_f64;\n+    /// let f = 3.7_f64;\n     /// let g = 3.0_f64;\n+    /// let h = -3.7_f64;\n     ///\n     /// assert_eq!(f.floor(), 3.0);\n     /// assert_eq!(g.floor(), 3.0);\n+    /// assert_eq!(h.floor(), -4.0);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -84,11 +86,13 @@ impl f64 {\n     /// # Examples\n     ///\n     /// ```\n-    /// let f = 3.3_f64;\n-    /// let g = -3.7_f64;\n+    /// let f = 3.7_f64;\n+    /// let g = 3.0_f64;\n+    /// let h = -3.7_f64;\n     ///\n     /// assert_eq!(f.trunc(), 3.0);\n-    /// assert_eq!(g.trunc(), -3.0);\n+    /// assert_eq!(g.trunc(), 3.0);\n+    /// assert_eq!(h.trunc(), -3.0);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]"}, {"sha": "296c4c887274e61eb7b3f9d719c9915b322f69e7", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7a4df3b53da369110984a2b57419c05a53e33b38/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a4df3b53da369110984a2b57419c05a53e33b38/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=7a4df3b53da369110984a2b57419c05a53e33b38", "patch": "@@ -301,6 +301,7 @@\n #![feature(stmt_expr_attributes)]\n #![feature(str_internals)]\n #![feature(thread_local)]\n+#![feature(todo_macro)]\n #![feature(toowned_clone_into)]\n #![feature(try_reserve)]\n #![feature(unboxed_closures)]\n@@ -323,7 +324,7 @@ use prelude::v1::*;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::{assert_eq, assert_ne, debug_assert, debug_assert_eq, debug_assert_ne};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::{unreachable, unimplemented, write, writeln, r#try};\n+pub use core::{unreachable, unimplemented, write, writeln, r#try, todo};\n \n #[allow(unused_imports)] // macros from `alloc` are not used on all platforms\n #[macro_use]"}, {"sha": "d5dc5f7c4f0dfe3f4532974eb9e8910f8d5a0b37", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7a4df3b53da369110984a2b57419c05a53e33b38/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a4df3b53da369110984a2b57419c05a53e33b38/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=7a4df3b53da369110984a2b57419c05a53e33b38", "patch": "@@ -305,10 +305,16 @@ macro_rules! eprintln {\n /// let _ = dbg!(a); // <-- `a` is moved again; error!\n /// ```\n ///\n+/// You can also use `dbg!()` without a value to just print the\n+/// file and line whenever it's reached.\n+///\n /// [stderr]: https://en.wikipedia.org/wiki/Standard_streams#Standard_error_(stderr)\n #[macro_export]\n #[stable(feature = \"dbg_macro\", since = \"1.32.0\")]\n macro_rules! dbg {\n+    () => {\n+        eprintln!(\"[{}:{}]\", file!(), line!());\n+    };\n     ($val:expr) => {\n         // Use of `match` here is intentional because it affects the lifetimes\n         // of temporaries - https://stackoverflow.com/a/48732525/1063961"}, {"sha": "80a7bde606afa7e7dfbff028a51d96961ec46219", "filename": "src/libsyntax/tokenstream.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7a4df3b53da369110984a2b57419c05a53e33b38/src%2Flibsyntax%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a4df3b53da369110984a2b57419c05a53e33b38/src%2Flibsyntax%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftokenstream.rs?ref=7a4df3b53da369110984a2b57419c05a53e33b38", "patch": "@@ -178,9 +178,11 @@ impl TokenStream {\n             while let Some((pos, ts)) = iter.next() {\n                 if let Some((_, next)) = iter.peek() {\n                     let sp = match (&ts, &next) {\n-                        ((TokenTree::Token(_, token::Token::Comma), NonJoint), _) |\n-                        (_, (TokenTree::Token(_, token::Token::Comma), NonJoint)) => continue,\n-                        ((TokenTree::Token(sp, _), NonJoint), _) => *sp,\n+                        (_, (TokenTree::Token(_, token::Token::Comma), _)) => continue,\n+                        ((TokenTree::Token(sp, token_left), NonJoint),\n+                         (TokenTree::Token(_, token_right), _))\n+                        if (token_left.is_ident() || token_left.is_lit()) &&\n+                            (token_right.is_ident() || token_right.is_lit()) => *sp,\n                         ((TokenTree::Delimited(sp, ..), NonJoint), _) => sp.entire(),\n                         _ => continue,\n                     };"}, {"sha": "0192aa01d0188422214ce7ce6e4ee405cd15d766", "filename": "src/test/mir-opt/simplify_match.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7a4df3b53da369110984a2b57419c05a53e33b38/src%2Ftest%2Fmir-opt%2Fsimplify_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a4df3b53da369110984a2b57419c05a53e33b38/src%2Ftest%2Fmir-opt%2Fsimplify_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fsimplify_match.rs?ref=7a4df3b53da369110984a2b57419c05a53e33b38", "patch": "@@ -0,0 +1,22 @@\n+fn main() {\n+    match { let x = false; x } {\n+        true => println!(\"hello world!\"),\n+        false => {},\n+    }\n+}\n+\n+// END RUST SOURCE\n+// START rustc.main.SimplifyBranches-after-copy-prop.before.mir\n+// bb0: {\n+//     ...\n+//     switchInt(const false) -> [false: bb3, otherwise: bb1];\n+// }\n+// bb1: {\n+// END rustc.main.SimplifyBranches-after-copy-prop.before.mir\n+// START rustc.main.SimplifyBranches-after-copy-prop.after.mir\n+// bb0: {\n+//     ...\n+//     goto -> bb3;\n+// }\n+// bb1: {\n+// END rustc.main.SimplifyBranches-after-copy-prop.after.mir"}, {"sha": "2b411aba8a2eec557600f12c66343cb4c56da8e7", "filename": "src/test/ui/macros/missing-comma.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7a4df3b53da369110984a2b57419c05a53e33b38/src%2Ftest%2Fui%2Fmacros%2Fmissing-comma.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a4df3b53da369110984a2b57419c05a53e33b38/src%2Ftest%2Fui%2Fmacros%2Fmissing-comma.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmissing-comma.rs?ref=7a4df3b53da369110984a2b57419c05a53e33b38", "patch": "@@ -6,6 +6,11 @@ macro_rules! foo {\n     ($a:ident, $b:ident, $c:ident, $d:ident, $e:ident) => ();\n }\n \n+macro_rules! bar {\n+    ($lvl:expr, $($arg:tt)+) => {}\n+}\n+\n+\n fn main() {\n     println!(\"{}\" a);\n     //~^ ERROR expected token: `,`\n@@ -17,4 +22,6 @@ fn main() {\n     //~^ ERROR no rules expected the token `d`\n     foo!(a, b, c d e);\n     //~^ ERROR no rules expected the token `d`\n+    bar!(Level::Error, );\n+    //~^ ERROR unexpected end of macro invocation\n }"}, {"sha": "424fefd00f87381e7fa0944fa8838a4de51801b4", "filename": "src/test/ui/macros/missing-comma.stderr", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7a4df3b53da369110984a2b57419c05a53e33b38/src%2Ftest%2Fui%2Fmacros%2Fmissing-comma.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7a4df3b53da369110984a2b57419c05a53e33b38/src%2Ftest%2Fui%2Fmacros%2Fmissing-comma.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmissing-comma.stderr?ref=7a4df3b53da369110984a2b57419c05a53e33b38", "patch": "@@ -1,11 +1,11 @@\n error: expected token: `,`\n-  --> $DIR/missing-comma.rs:10:19\n+  --> $DIR/missing-comma.rs:15:19\n    |\n LL |     println!(\"{}\" a);\n    |                   ^\n \n error: no rules expected the token `b`\n-  --> $DIR/missing-comma.rs:12:12\n+  --> $DIR/missing-comma.rs:17:12\n    |\n LL | macro_rules! foo {\n    | ---------------- when calling this macro\n@@ -16,7 +16,7 @@ LL |     foo!(a b);\n    |           help: missing comma here\n \n error: no rules expected the token `e`\n-  --> $DIR/missing-comma.rs:14:21\n+  --> $DIR/missing-comma.rs:19:21\n    |\n LL | macro_rules! foo {\n    | ---------------- when calling this macro\n@@ -27,7 +27,7 @@ LL |     foo!(a, b, c, d e);\n    |                    help: missing comma here\n \n error: no rules expected the token `d`\n-  --> $DIR/missing-comma.rs:16:18\n+  --> $DIR/missing-comma.rs:21:18\n    |\n LL | macro_rules! foo {\n    | ---------------- when calling this macro\n@@ -38,13 +38,22 @@ LL |     foo!(a, b, c d, e);\n    |                 help: missing comma here\n \n error: no rules expected the token `d`\n-  --> $DIR/missing-comma.rs:18:18\n+  --> $DIR/missing-comma.rs:23:18\n    |\n LL | macro_rules! foo {\n    | ---------------- when calling this macro\n ...\n LL |     foo!(a, b, c d e);\n    |                  ^ no rules expected this token in macro call\n \n-error: aborting due to 5 previous errors\n+error: unexpected end of macro invocation\n+  --> $DIR/missing-comma.rs:25:23\n+   |\n+LL | macro_rules! bar {\n+   | ---------------- when calling this macro\n+...\n+LL |     bar!(Level::Error, );\n+   |                       ^ missing tokens in macro arguments\n+\n+error: aborting due to 6 previous errors\n "}, {"sha": "3d042d442d5318b3fde457e908eed0dcdca46119", "filename": "src/test/ui/nll/user-annotations/issue-55748-pat-types-constrain-bindings.rs", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/7a4df3b53da369110984a2b57419c05a53e33b38/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fissue-55748-pat-types-constrain-bindings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a4df3b53da369110984a2b57419c05a53e33b38/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fissue-55748-pat-types-constrain-bindings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fissue-55748-pat-types-constrain-bindings.rs?ref=7a4df3b53da369110984a2b57419c05a53e33b38", "patch": "@@ -0,0 +1,70 @@\n+// This test is ensuring that type ascriptions on let bindings\n+// constrain both:\n+//\n+// 1. the input expression on the right-hand side (after any potential\n+//    coercion, and allowing for covariance), *and*\n+//\n+// 2. the bindings (if any) nested within the pattern on the left-hand\n+//    side (and here, the type-constraint is *invariant*).\n+\n+#![feature(nll)]\n+\n+#![allow(dead_code, unused_mut)]\n+type PairUncoupled<'a, 'b, T> = (&'a T, &'b T);\n+type PairCoupledRegions<'a, T> = (&'a T, &'a T);\n+type PairCoupledTypes<T> = (T, T);\n+\n+fn uncoupled_lhs<'a>(_x: &'a u32, s: &'static u32) -> &'static u32 {\n+    let ((mut y, mut _z),): (PairUncoupled<u32>,) = ((s, &_x),); // ok\n+    // Above compiling does *not* imply below would compile.\n+    // ::std::mem::swap(&mut y, &mut _z);\n+    y\n+}\n+\n+fn swap_regions((mut y, mut _z): PairCoupledRegions<u32>) {\n+    ::std::mem::swap(&mut y, &mut _z);\n+}\n+\n+fn coupled_regions_lhs<'a>(_x: &'a u32, s: &'static u32) -> &'static u32 {\n+    let ((y, _z),): (PairCoupledRegions<u32>,) = ((s, &_x),);\n+    // If above line compiled, so should line below ...\n+\n+    // swap_regions((y, _z));\n+\n+    // ... but the ascribed type also invalidates this use of `y`\n+    y //~ ERROR lifetime may not live long enough\n+}\n+\n+fn swap_types((mut y, mut _z): PairCoupledTypes<&u32>) {\n+    ::std::mem::swap(&mut y, &mut _z);\n+}\n+\n+fn coupled_types_lhs<'a>(_x: &'a u32, s: &'static u32) -> &'static u32 {\n+    let ((y, _z),): (PairCoupledTypes<&u32>,) = ((s, &_x),);\n+    // If above line compiled, so should line below ...\n+\n+    // swap_types((y, _z));\n+\n+    // ... but the ascribed type also invalidates this use of `y`\n+    y //~ ERROR lifetime may not live long enough\n+}\n+\n+fn swap_wilds((mut y, mut _z): PairCoupledTypes<&u32>) {\n+    ::std::mem::swap(&mut y, &mut _z);\n+}\n+\n+fn coupled_wilds_lhs<'a>(_x: &'a u32, s: &'static u32) -> &'static u32 {\n+    let ((y, _z),): (PairCoupledTypes<_>,) = ((s, &_x),);\n+    // If above line compiled, so should line below\n+    // swap_wilds((y, _z));\n+\n+    // ... but the ascribed type also invalidates this use of `y`\n+    y //~ ERROR lifetime may not live long enough\n+}\n+\n+fn main() {\n+    uncoupled_lhs(&3, &4);\n+    coupled_regions_lhs(&3, &4);\n+    coupled_types_lhs(&3, &4);\n+    coupled_wilds_lhs(&3, &4);\n+}"}, {"sha": "5929707e41e10ba18c724401fd5503be3db368ae", "filename": "src/test/ui/nll/user-annotations/issue-55748-pat-types-constrain-bindings.stderr", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/7a4df3b53da369110984a2b57419c05a53e33b38/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fissue-55748-pat-types-constrain-bindings.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7a4df3b53da369110984a2b57419c05a53e33b38/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fissue-55748-pat-types-constrain-bindings.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fissue-55748-pat-types-constrain-bindings.stderr?ref=7a4df3b53da369110984a2b57419c05a53e33b38", "patch": "@@ -0,0 +1,29 @@\n+error: lifetime may not live long enough\n+  --> $DIR/issue-55748-pat-types-constrain-bindings.rs:35:5\n+   |\n+LL | fn coupled_regions_lhs<'a>(_x: &'a u32, s: &'static u32) -> &'static u32 {\n+   |                        -- lifetime `'a` defined here\n+...\n+LL |     y\n+   |     ^ returning this value requires that `'a` must outlive `'static`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/issue-55748-pat-types-constrain-bindings.rs:49:5\n+   |\n+LL | fn coupled_types_lhs<'a>(_x: &'a u32, s: &'static u32) -> &'static u32 {\n+   |                      -- lifetime `'a` defined here\n+...\n+LL |     y\n+   |     ^ returning this value requires that `'a` must outlive `'static`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/issue-55748-pat-types-constrain-bindings.rs:62:5\n+   |\n+LL | fn coupled_wilds_lhs<'a>(_x: &'a u32, s: &'static u32) -> &'static u32 {\n+   |                      -- lifetime `'a` defined here\n+...\n+LL |     y\n+   |     ^ returning this value requires that `'a` must outlive `'static`\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "67f7f80a9e2dac087839d305a6145869a02a31b8", "filename": "src/test/ui/rfc-2361-dbg-macro/dbg-macro-expected-behavior.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7a4df3b53da369110984a2b57419c05a53e33b38/src%2Ftest%2Fui%2Frfc-2361-dbg-macro%2Fdbg-macro-expected-behavior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a4df3b53da369110984a2b57419c05a53e33b38/src%2Ftest%2Fui%2Frfc-2361-dbg-macro%2Fdbg-macro-expected-behavior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2361-dbg-macro%2Fdbg-macro-expected-behavior.rs?ref=7a4df3b53da369110984a2b57419c05a53e33b38", "patch": "@@ -33,6 +33,9 @@ fn test() {\n     // We can move `b` because it's Copy.\n     drop(b);\n \n+    // Without parameters works as expected.\n+    let _: () = dbg!();\n+\n     // Test that we can borrow and that successive applications is still identity.\n     let a = NoCopy(1337);\n     let b: &NoCopy = dbg!(dbg!(&a));\n@@ -69,17 +72,19 @@ fn validate_stderr(stderr: Vec<String>) {\n         \"    y: 24\",\n         \"}\",\n \n-        \":38] &a = NoCopy(\",\n+        \":37]\",\n+\n+        \":41] &a = NoCopy(\",\n         \"    1337\",\n         \")\",\n \n-        \":38] dbg!(& a) = NoCopy(\",\n+        \":41] dbg!(& a) = NoCopy(\",\n         \"    1337\",\n         \")\",\n-        \":43] f(&42) = 42\",\n+        \":46] f(&42) = 42\",\n \n         \"before\",\n-        \":48] { foo += 1; eprintln!(\\\"before\\\"); 7331 } = 7331\",\n+        \":51] { foo += 1; eprintln!(\\\"before\\\"); 7331 } = 7331\",\n     ]);\n }\n "}]}