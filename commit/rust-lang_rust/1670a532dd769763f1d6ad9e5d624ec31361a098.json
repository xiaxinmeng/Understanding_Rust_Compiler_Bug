{"sha": "1670a532dd769763f1d6ad9e5d624ec31361a098", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE2NzBhNTMyZGQ3Njk3NjNmMWQ2YWQ5ZTVkNjI0ZWMzMTM2MWEwOTg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-02-15T13:35:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-02-15T13:35:20Z"}, "message": "Auto merge of #48203 - kennytm:rollup, r=kennytm\n\nRollup of 23 pull requests\n\n- Successful merges: #47784, #47806, #47846, #48005, #48033, #48065, #48087, #48114, #48126, #48130, #48133, #48151, #48154, #48156, #48162, #48163, #48165, #48167, #48181, #48186, #48195, #48035, #48210\n- Failed merges:", "tree": {"sha": "9e7f596ee88967152d1f6ed887476447ccb3c3a7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9e7f596ee88967152d1f6ed887476447ccb3c3a7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1670a532dd769763f1d6ad9e5d624ec31361a098", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1670a532dd769763f1d6ad9e5d624ec31361a098", "html_url": "https://github.com/rust-lang/rust/commit/1670a532dd769763f1d6ad9e5d624ec31361a098", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1670a532dd769763f1d6ad9e5d624ec31361a098/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c83fa5d91c3b16459ab7b87c48ed18bd059a23af", "url": "https://api.github.com/repos/rust-lang/rust/commits/c83fa5d91c3b16459ab7b87c48ed18bd059a23af", "html_url": "https://github.com/rust-lang/rust/commit/c83fa5d91c3b16459ab7b87c48ed18bd059a23af"}, {"sha": "03b089d2208167d113cb7bb81f2de48b78785658", "url": "https://api.github.com/repos/rust-lang/rust/commits/03b089d2208167d113cb7bb81f2de48b78785658", "html_url": "https://github.com/rust-lang/rust/commit/03b089d2208167d113cb7bb81f2de48b78785658"}], "stats": {"total": 1016, "additions": 805, "deletions": 211}, "files": [{"sha": "280da056995068fd58d6a8e1082f94f3d88be2f9", "filename": ".travis.yml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1670a532dd769763f1d6ad9e5d624ec31361a098/.travis.yml", "raw_url": "https://github.com/rust-lang/rust/raw/1670a532dd769763f1d6ad9e5d624ec31361a098/.travis.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.travis.yml?ref=1670a532dd769763f1d6ad9e5d624ec31361a098", "patch": "@@ -56,7 +56,7 @@ matrix:\n         NO_LLVM_ASSERTIONS=1\n         NO_DEBUG_ASSERTIONS=1\n       os: osx\n-      osx_image: xcode8.3\n+      osx_image: xcode9.2\n       if: branch = auto\n \n     - env: >\n@@ -70,7 +70,7 @@ matrix:\n         NO_LLVM_ASSERTIONS=1\n         NO_DEBUG_ASSERTIONS=1\n       os: osx\n-      osx_image: xcode8.3\n+      osx_image: xcode9.2\n       if: branch = auto\n \n     # OSX builders producing releases. These do not run the full test suite and"}, {"sha": "7a9d256be282f6db5704a3746e834f0eb49b3551", "filename": "RELEASES.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1670a532dd769763f1d6ad9e5d624ec31361a098/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/1670a532dd769763f1d6ad9e5d624ec31361a098/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=1670a532dd769763f1d6ad9e5d624ec31361a098", "patch": "@@ -78,6 +78,7 @@ Compatibility Notes\n - [`column!()` macro is one-based instead of zero-based][46977]\n - [`fmt::Arguments` can no longer be shared across threads][45198]\n - [Access to `#[repr(packed)]` struct fields is now unsafe][44884]\n+- [Cargo sets a different working directory for the compiler][cargo/4788]\n \n [44884]: https://github.com/rust-lang/rust/pull/44884\n [45198]: https://github.com/rust-lang/rust/pull/45198\n@@ -106,6 +107,7 @@ Compatibility Notes\n [47080]: https://github.com/rust-lang/rust/pull/47080\n [47084]: https://github.com/rust-lang/rust/pull/47084\n [cargo/4743]: https://github.com/rust-lang/cargo/pull/4743\n+[cargo/4788]: https://github.com/rust-lang/cargo/pull/4788\n [cargo/4817]: https://github.com/rust-lang/cargo/pull/4817\n [`RefCell::replace`]: https://doc.rust-lang.org/std/cell/struct.RefCell.html#method.replace\n [`RefCell::swap`]: https://doc.rust-lang.org/std/cell/struct.RefCell.html#method.swap"}, {"sha": "29cd23bdbb1978398043dd06b45a9d94502b26f1", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1670a532dd769763f1d6ad9e5d624ec31361a098/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1670a532dd769763f1d6ad9e5d624ec31361a098/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=1670a532dd769763f1d6ad9e5d624ec31361a098", "patch": "@@ -157,6 +157,14 @@ impl Step for Llvm {\n            .define(\"LLVM_TARGET_ARCH\", target.split('-').next().unwrap())\n            .define(\"LLVM_DEFAULT_TARGET_TRIPLE\", target);\n \n+        // By default, LLVM will automatically find OCaml and, if it finds it,\n+        // install the LLVM bindings in LLVM_OCAML_INSTALL_PATH, which defaults\n+        // to /usr/bin/ocaml.\n+        // This causes problem for non-root builds of Rust. Side-step the issue\n+        // by setting LLVM_OCAML_INSTALL_PATH to a relative path, so it installs\n+        // in the prefix.\n+        cfg.define(\"LLVM_OCAML_INSTALL_PATH\",\n+            env::var_os(\"LLVM_OCAML_INSTALL_PATH\").unwrap_or_else(|| \"usr/lib/ocaml\".into()));\n \n         // This setting makes the LLVM tools link to the dynamic LLVM library,\n         // which saves both memory during parallel links and overall disk space"}, {"sha": "5c7f8ef73217f62141e5afb84998a98b4db0b0cc", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 1, "deletions": 16, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/1670a532dd769763f1d6ad9e5d624ec31361a098/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1670a532dd769763f1d6ad9e5d624ec31361a098/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=1670a532dd769763f1d6ad9e5d624ec31361a098", "patch": "@@ -805,22 +805,7 @@ impl<T> Vec<T> {\n     pub fn retain<F>(&mut self, mut f: F)\n         where F: FnMut(&T) -> bool\n     {\n-        let len = self.len();\n-        let mut del = 0;\n-        {\n-            let v = &mut **self;\n-\n-            for i in 0..len {\n-                if !f(&v[i]) {\n-                    del += 1;\n-                } else if del > 0 {\n-                    v.swap(i - del, i);\n-                }\n-            }\n-        }\n-        if del > 0 {\n-            self.truncate(len - del);\n-        }\n+        self.drain_filter(|x| !f(x));\n     }\n \n     /// Removes all but the first of consecutive elements in the vector that resolve to the same"}, {"sha": "266ea0740a5bdd262a38bbd88fb55fc3d2a7a96e", "filename": "src/libcompiler_builtins", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcompiler_builtins?ref=1670a532dd769763f1d6ad9e5d624ec31361a098", "patch": "@@ -1 +1 @@\n-Subproject commit 345447948f7a51eca970fa036cefd613d54a4f79\n+Subproject commit 266ea0740a5bdd262a38bbd88fb55fc3d2a7a96e"}, {"sha": "d929d1d65a91892a55d47305298b261ef2a151cc", "filename": "src/libcore/iter/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1670a532dd769763f1d6ad9e5d624ec31361a098/src%2Flibcore%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1670a532dd769763f1d6ad9e5d624ec31361a098/src%2Flibcore%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fmod.rs?ref=1670a532dd769763f1d6ad9e5d624ec31361a098", "patch": "@@ -333,6 +333,8 @@ pub use self::range::Step;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::sources::{Repeat, repeat};\n+#[unstable(feature = \"iterator_repeat_with\", issue = \"48169\")]\n+pub use self::sources::{RepeatWith, repeat_with};\n #[stable(feature = \"iter_empty\", since = \"1.2.0\")]\n pub use self::sources::{Empty, empty};\n #[stable(feature = \"iter_once\", since = \"1.2.0\")]"}, {"sha": "3e9d799c089486b95c78cb022f834d4f521379bb", "filename": "src/libcore/iter/sources.rs", "status": "modified", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/1670a532dd769763f1d6ad9e5d624ec31361a098/src%2Flibcore%2Fiter%2Fsources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1670a532dd769763f1d6ad9e5d624ec31361a098/src%2Flibcore%2Fiter%2Fsources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fsources.rs?ref=1670a532dd769763f1d6ad9e5d624ec31361a098", "patch": "@@ -57,6 +57,12 @@ unsafe impl<A: Clone> TrustedLen for Repeat<A> {}\n ///\n /// [`take`]: trait.Iterator.html#method.take\n ///\n+/// If the element type of the iterator you need does not implement `Clone`,\n+/// or if you do not want to keep the repeated element in memory, you can\n+/// instead use the [`repeat_with`] function.\n+///\n+/// [`repeat_with`]: fn.repeat_with.html\n+///\n /// # Examples\n ///\n /// Basic usage:\n@@ -99,6 +105,115 @@ pub fn repeat<T: Clone>(elt: T) -> Repeat<T> {\n     Repeat{element: elt}\n }\n \n+/// An iterator that repeats elements of type `A` endlessly by\n+/// applying the provided closure `F: FnMut() -> A`.\n+///\n+/// This `struct` is created by the [`repeat_with`] function.\n+/// See its documentation for more.\n+///\n+/// [`repeat_with`]: fn.repeat_with.html\n+#[derive(Copy, Clone, Debug)]\n+#[unstable(feature = \"iterator_repeat_with\", issue = \"48169\")]\n+pub struct RepeatWith<F> {\n+    repeater: F\n+}\n+\n+#[unstable(feature = \"iterator_repeat_with\", issue = \"48169\")]\n+impl<A, F: FnMut() -> A> Iterator for RepeatWith<F> {\n+    type Item = A;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<A> { Some((self.repeater)()) }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) { (usize::MAX, None) }\n+}\n+\n+#[unstable(feature = \"iterator_repeat_with\", issue = \"48169\")]\n+impl<A, F: FnMut() -> A> DoubleEndedIterator for RepeatWith<F> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<A> { self.next() }\n+}\n+\n+#[unstable(feature = \"fused\", issue = \"35602\")]\n+impl<A, F: FnMut() -> A> FusedIterator for RepeatWith<F> {}\n+\n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<A, F: FnMut() -> A> TrustedLen for RepeatWith<F> {}\n+\n+/// Creates a new iterator that repeats elements of type `A` endlessly by\n+/// applying the provided closure, the repeater, `F: FnMut() -> A`.\n+///\n+/// The `repeat_with()` function calls the repeater over and over and over and\n+/// over and over and \ud83d\udd01.\n+///\n+/// Infinite iterators like `repeat_with()` are often used with adapters like\n+/// [`take`], in order to make them finite.\n+///\n+/// [`take`]: trait.Iterator.html#method.take\n+///\n+/// If the element type of the iterator you need implements `Clone`, and\n+/// it is OK to keep the source element in memory, you should instead use\n+/// the [`repeat`] function.\n+///\n+/// [`repeat`]: fn.repeat.html\n+///\n+/// An iterator produced by `repeat_with()` is a `DoubleEndedIterator`.\n+/// It is important to not that reversing `repeat_with(f)` will produce\n+/// the exact same sequence as the non-reversed iterator. In other words,\n+/// `repeat_with(f).rev().collect::<Vec<_>>()` is equivalent to\n+/// `repeat_with(f).collect::<Vec<_>>()`.\n+///\n+/// # Examples\n+///\n+/// Basic usage:\n+///\n+/// ```\n+/// #![feature(iterator_repeat_with)]\n+///\n+/// use std::iter;\n+///\n+/// // let's assume we have some value of a type that is not `Clone`\n+/// // or which don't want to have in memory just yet because it is expensive:\n+/// #[derive(PartialEq, Debug)]\n+/// struct Expensive;\n+///\n+/// // a particular value forever:\n+/// let mut things = iter::repeat_with(|| Expensive);\n+///\n+/// assert_eq!(Some(Expensive), things.next());\n+/// assert_eq!(Some(Expensive), things.next());\n+/// assert_eq!(Some(Expensive), things.next());\n+/// assert_eq!(Some(Expensive), things.next());\n+/// assert_eq!(Some(Expensive), things.next());\n+/// ```\n+///\n+/// Using mutation and going finite:\n+///\n+/// ```rust\n+/// #![feature(iterator_repeat_with)]\n+///\n+/// use std::iter;\n+///\n+/// // From the zeroth to the third power of two:\n+/// let mut curr = 1;\n+/// let mut pow2 = iter::repeat_with(|| { let tmp = curr; curr *= 2; tmp })\n+///                     .take(4);\n+///\n+/// assert_eq!(Some(1), pow2.next());\n+/// assert_eq!(Some(2), pow2.next());\n+/// assert_eq!(Some(4), pow2.next());\n+/// assert_eq!(Some(8), pow2.next());\n+///\n+/// // ... and now we're done\n+/// assert_eq!(None, pow2.next());\n+/// ```\n+#[inline]\n+#[unstable(feature = \"iterator_repeat_with\", issue = \"48169\")]\n+pub fn repeat_with<A, F: FnMut() -> A>(repeater: F) -> RepeatWith<F> {\n+    RepeatWith { repeater }\n+}\n+\n /// An iterator that yields nothing.\n ///\n /// This `struct` is created by the [`empty`] function. See its documentation for more."}, {"sha": "860742d9eab6047b3fc6ff0510401d33cfdda949", "filename": "src/libcore/iter/traits.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1670a532dd769763f1d6ad9e5d624ec31361a098/src%2Flibcore%2Fiter%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1670a532dd769763f1d6ad9e5d624ec31361a098/src%2Flibcore%2Fiter%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits.rs?ref=1670a532dd769763f1d6ad9e5d624ec31361a098", "patch": "@@ -706,7 +706,7 @@ pub trait ExactSizeIterator: Iterator {\n     /// ```\n     /// #![feature(exact_size_is_empty)]\n     ///\n-    /// let mut one_element = 0..1;\n+    /// let mut one_element = std::iter::once(0);\n     /// assert!(!one_element.is_empty());\n     ///\n     /// assert_eq!(one_element.next(), Some(0));"}, {"sha": "447e144bf0fd6083b43a7ec4f4a99284994d18da", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1670a532dd769763f1d6ad9e5d624ec31361a098/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1670a532dd769763f1d6ad9e5d624ec31361a098/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=1670a532dd769763f1d6ad9e5d624ec31361a098", "patch": "@@ -92,6 +92,7 @@\n #![feature(unwind_attributes)]\n #![feature(doc_spotlight)]\n #![feature(rustc_const_unstable)]\n+#![feature(iterator_repeat_with)]\n \n #[prelude_import]\n #[allow(unused)]"}, {"sha": "98e0f71eb935679b9ca97b4aab715b7c534305e2", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1670a532dd769763f1d6ad9e5d624ec31361a098/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1670a532dd769763f1d6ad9e5d624ec31361a098/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=1670a532dd769763f1d6ad9e5d624ec31361a098", "patch": "@@ -63,9 +63,13 @@ impl<T: ?Sized> !Send for *mut T { }\n /// struct BarUse(Bar<[i32]>); // OK\n /// ```\n ///\n-/// The one exception is the implicit `Self` type of a trait, which does not\n-/// get an implicit `Sized` bound. This is because a `Sized` bound prevents\n-/// the trait from being used to form a [trait object]:\n+/// The one exception is the implicit `Self` type of a trait. A trait does not\n+/// have an implicit `Sized` bound as this is incompatible with [trait object]s\n+/// where, by definition, the trait needs to work with all possible implementors,\n+/// and thus could be any size.\n+///\n+/// Although Rust will let you bind `Sized` to a trait, you won't\n+/// be able to use it to form a trait object later:\n ///\n /// ```\n /// # #![allow(unused_variables)]"}, {"sha": "21d4a486b983313cf407a9efe2cb282a2e7369f0", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1670a532dd769763f1d6ad9e5d624ec31361a098/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1670a532dd769763f1d6ad9e5d624ec31361a098/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=1670a532dd769763f1d6ad9e5d624ec31361a098", "patch": "@@ -2881,7 +2881,7 @@ pub enum FpCategory {\n            issue = \"32110\")]\n pub trait Float: Sized {\n     /// Type used by `to_bits` and `from_bits`.\n-    #[stable(feature = \"core_float_bits\", since = \"1.24.0\")]\n+    #[stable(feature = \"core_float_bits\", since = \"1.25.0\")]\n     type Bits;\n \n     /// Returns `true` if this value is NaN and false otherwise.\n@@ -2947,10 +2947,10 @@ pub trait Float: Sized {\n     fn min(self, other: Self) -> Self;\n \n     /// Raw transmutation to integer.\n-    #[stable(feature = \"core_float_bits\", since=\"1.24.0\")]\n+    #[stable(feature = \"core_float_bits\", since=\"1.25.0\")]\n     fn to_bits(self) -> Self::Bits;\n     /// Raw transmutation from integer.\n-    #[stable(feature = \"core_float_bits\", since=\"1.24.0\")]\n+    #[stable(feature = \"core_float_bits\", since=\"1.25.0\")]\n     fn from_bits(v: Self::Bits) -> Self;\n }\n "}, {"sha": "1d9c0f873b34a2baa51e2b0460d6540345818e7a", "filename": "src/libcore/ops/range.rs", "status": "modified", "additions": 81, "deletions": 9, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/1670a532dd769763f1d6ad9e5d624ec31361a098/src%2Flibcore%2Fops%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1670a532dd769763f1d6ad9e5d624ec31361a098/src%2Flibcore%2Fops%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Frange.rs?ref=1670a532dd769763f1d6ad9e5d624ec31361a098", "patch": "@@ -60,19 +60,19 @@ impl fmt::Debug for RangeFull {\n /// (`start..end`).\n ///\n /// The `Range` `start..end` contains all values with `x >= start` and\n-/// `x < end`.\n+/// `x < end`.  It is empty unless `start < end`.\n ///\n /// # Examples\n ///\n /// ```\n /// assert_eq!((3..5), std::ops::Range { start: 3, end: 5 });\n /// assert_eq!(3 + 4 + 5, (3..6).sum());\n ///\n-/// let arr = [0, 1, 2, 3];\n-/// assert_eq!(arr[ .. ], [0,1,2,3]);\n-/// assert_eq!(arr[ ..3], [0,1,2  ]);\n-/// assert_eq!(arr[1.. ], [  1,2,3]);\n-/// assert_eq!(arr[1..3], [  1,2  ]);  // Range\n+/// let arr = ['a', 'b', 'c', 'd'];\n+/// assert_eq!(arr[ .. ], ['a', 'b', 'c', 'd']);\n+/// assert_eq!(arr[ ..3], ['a', 'b', 'c',    ]);\n+/// assert_eq!(arr[1.. ], [     'b', 'c', 'd']);\n+/// assert_eq!(arr[1..3], [     'b', 'c'     ]);  // Range\n /// ```\n #[derive(Clone, PartialEq, Eq, Hash)]  // not Copy -- see #27186\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -92,7 +92,6 @@ impl<Idx: fmt::Debug> fmt::Debug for Range<Idx> {\n     }\n }\n \n-#[unstable(feature = \"range_contains\", reason = \"recently added as per RFC\", issue = \"32311\")]\n impl<Idx: PartialOrd<Idx>> Range<Idx> {\n     /// Returns `true` if `item` is contained in the range.\n     ///\n@@ -109,9 +108,37 @@ impl<Idx: PartialOrd<Idx>> Range<Idx> {\n     /// assert!(!(3..3).contains(3));\n     /// assert!(!(3..2).contains(3));\n     /// ```\n+    #[unstable(feature = \"range_contains\", reason = \"recently added as per RFC\", issue = \"32311\")]\n     pub fn contains(&self, item: Idx) -> bool {\n         (self.start <= item) && (item < self.end)\n     }\n+\n+    /// Returns `true` if the range contains no items.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(range_is_empty)]\n+    ///\n+    /// assert!(!(3..5).is_empty());\n+    /// assert!( (3..3).is_empty());\n+    /// assert!( (3..2).is_empty());\n+    /// ```\n+    ///\n+    /// The range is empty if either side is incomparable:\n+    ///\n+    /// ```\n+    /// #![feature(range_is_empty,inclusive_range_syntax)]\n+    ///\n+    /// use std::f32::NAN;\n+    /// assert!(!(3.0..5.0).is_empty());\n+    /// assert!( (3.0..NAN).is_empty());\n+    /// assert!( (NAN..5.0).is_empty());\n+    /// ```\n+    #[unstable(feature = \"range_is_empty\", reason = \"recently added\", issue = \"48111\")]\n+    pub fn is_empty(&self) -> bool {\n+        !(self.start < self.end)\n+    }\n }\n \n /// A range only bounded inclusively below (`start..`).\n@@ -244,7 +271,14 @@ impl<Idx: PartialOrd<Idx>> RangeTo<Idx> {\n /// An range bounded inclusively below and above (`start..=end`).\n ///\n /// The `RangeInclusive` `start..=end` contains all values with `x >= start`\n-/// and `x <= end`.\n+/// and `x <= end`.  It is empty unless `start <= end`.\n+///\n+/// This iterator is [fused], but the specific values of `start` and `end` after\n+/// iteration has finished are **unspecified** other than that [`.is_empty()`]\n+/// will return `true` once no more values will be produced.\n+///\n+/// [fused]: ../iter/trait.FusedIterator.html\n+/// [`.is_empty()`]: #method.is_empty\n ///\n /// # Examples\n ///\n@@ -280,7 +314,6 @@ impl<Idx: fmt::Debug> fmt::Debug for RangeInclusive<Idx> {\n     }\n }\n \n-#[unstable(feature = \"range_contains\", reason = \"recently added as per RFC\", issue = \"32311\")]\n impl<Idx: PartialOrd<Idx>> RangeInclusive<Idx> {\n     /// Returns `true` if `item` is contained in the range.\n     ///\n@@ -298,9 +331,48 @@ impl<Idx: PartialOrd<Idx>> RangeInclusive<Idx> {\n     /// assert!( (3..=3).contains(3));\n     /// assert!(!(3..=2).contains(3));\n     /// ```\n+    #[unstable(feature = \"range_contains\", reason = \"recently added as per RFC\", issue = \"32311\")]\n     pub fn contains(&self, item: Idx) -> bool {\n         self.start <= item && item <= self.end\n     }\n+\n+    /// Returns `true` if the range contains no items.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(range_is_empty,inclusive_range_syntax)]\n+    ///\n+    /// assert!(!(3..=5).is_empty());\n+    /// assert!(!(3..=3).is_empty());\n+    /// assert!( (3..=2).is_empty());\n+    /// ```\n+    ///\n+    /// The range is empty if either side is incomparable:\n+    ///\n+    /// ```\n+    /// #![feature(range_is_empty,inclusive_range_syntax)]\n+    ///\n+    /// use std::f32::NAN;\n+    /// assert!(!(3.0..=5.0).is_empty());\n+    /// assert!( (3.0..=NAN).is_empty());\n+    /// assert!( (NAN..=5.0).is_empty());\n+    /// ```\n+    ///\n+    /// This method returns `true` after iteration has finished:\n+    ///\n+    /// ```\n+    /// #![feature(range_is_empty,inclusive_range_syntax)]\n+    ///\n+    /// let mut r = 3..=5;\n+    /// for _ in r.by_ref() {}\n+    /// // Precise field values are unspecified here\n+    /// assert!(r.is_empty());\n+    /// ```\n+    #[unstable(feature = \"range_is_empty\", reason = \"recently added\", issue = \"48111\")]\n+    pub fn is_empty(&self) -> bool {\n+        !(self.start <= self.end)\n+    }\n }\n \n /// A range only bounded inclusively above (`..=end`)."}, {"sha": "b266771b818e5b71d5627ba3f4641216e402359a", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1670a532dd769763f1d6ad9e5d624ec31361a098/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1670a532dd769763f1d6ad9e5d624ec31361a098/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=1670a532dd769763f1d6ad9e5d624ec31361a098", "patch": "@@ -2573,7 +2573,7 @@ impl<T: ?Sized> Clone for NonNull<T> {\n #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n impl<T: ?Sized> Copy for NonNull<T> { }\n \n-#[stable(feature = \"nonnull\", since = \"1.25.0\")]\n+#[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n impl<T: ?Sized, U: ?Sized> CoerceUnsized<NonNull<U>> for NonNull<T> where T: Unsize<U> { }\n \n #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n@@ -2621,7 +2621,7 @@ impl<T: ?Sized> hash::Hash for NonNull<T> {\n     }\n }\n \n-#[stable(feature = \"nonnull\", since = \"1.25.0\")]\n+#[unstable(feature = \"ptr_internals\", issue = \"0\")]\n impl<T: ?Sized> From<Unique<T>> for NonNull<T> {\n     fn from(unique: Unique<T>) -> Self {\n         NonNull { pointer: unique.pointer }"}, {"sha": "f91c919d7447d6111d258a79532d6ef8fd8c29e1", "filename": "src/libcore/tests/iter.rs", "status": "modified", "additions": 97, "deletions": 9, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/1670a532dd769763f1d6ad9e5d624ec31361a098/src%2Flibcore%2Ftests%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1670a532dd769763f1d6ad9e5d624ec31361a098/src%2Flibcore%2Ftests%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fiter.rs?ref=1670a532dd769763f1d6ad9e5d624ec31361a098", "patch": "@@ -1322,42 +1322,84 @@ fn test_range() {\n                (isize::MAX as usize + 2, Some(isize::MAX as usize + 2)));\n }\n \n+#[test]\n+fn test_range_exhaustion() {\n+    let mut r = 10..10;\n+    assert!(r.is_empty());\n+    assert_eq!(r.next(), None);\n+    assert_eq!(r.next_back(), None);\n+    assert_eq!(r, 10..10);\n+\n+    let mut r = 10..12;\n+    assert_eq!(r.next(), Some(10));\n+    assert_eq!(r.next(), Some(11));\n+    assert!(r.is_empty());\n+    assert_eq!(r, 12..12);\n+    assert_eq!(r.next(), None);\n+\n+    let mut r = 10..12;\n+    assert_eq!(r.next_back(), Some(11));\n+    assert_eq!(r.next_back(), Some(10));\n+    assert!(r.is_empty());\n+    assert_eq!(r, 10..10);\n+    assert_eq!(r.next_back(), None);\n+\n+    let mut r = 100..10;\n+    assert!(r.is_empty());\n+    assert_eq!(r.next(), None);\n+    assert_eq!(r.next_back(), None);\n+    assert_eq!(r, 100..10);\n+}\n+\n #[test]\n fn test_range_inclusive_exhaustion() {\n     let mut r = 10..=10;\n     assert_eq!(r.next(), Some(10));\n-    assert_eq!(r, 1..=0);\n+    assert!(r.is_empty());\n+    assert_eq!(r.next(), None);\n+    assert_eq!(r.next(), None);\n \n     let mut r = 10..=10;\n     assert_eq!(r.next_back(), Some(10));\n-    assert_eq!(r, 1..=0);\n+    assert!(r.is_empty());\n+    assert_eq!(r.next_back(), None);\n \n     let mut r = 10..=12;\n     assert_eq!(r.next(), Some(10));\n     assert_eq!(r.next(), Some(11));\n     assert_eq!(r.next(), Some(12));\n-    assert_eq!(r, 1..=0);\n+    assert!(r.is_empty());\n+    assert_eq!(r.next(), None);\n \n     let mut r = 10..=12;\n     assert_eq!(r.next_back(), Some(12));\n     assert_eq!(r.next_back(), Some(11));\n     assert_eq!(r.next_back(), Some(10));\n-    assert_eq!(r, 1..=0);\n+    assert!(r.is_empty());\n+    assert_eq!(r.next_back(), None);\n \n     let mut r = 10..=12;\n     assert_eq!(r.nth(2), Some(12));\n-    assert_eq!(r, 1..=0);\n+    assert!(r.is_empty());\n+    assert_eq!(r.next(), None);\n \n     let mut r = 10..=12;\n     assert_eq!(r.nth(5), None);\n-    assert_eq!(r, 1..=0);\n+    assert!(r.is_empty());\n+    assert_eq!(r.next(), None);\n \n     let mut r = 100..=10;\n     assert_eq!(r.next(), None);\n+    assert!(r.is_empty());\n+    assert_eq!(r.next(), None);\n+    assert_eq!(r.next(), None);\n     assert_eq!(r, 100..=10);\n \n     let mut r = 100..=10;\n     assert_eq!(r.next_back(), None);\n+    assert!(r.is_empty());\n+    assert_eq!(r.next_back(), None);\n+    assert_eq!(r.next_back(), None);\n     assert_eq!(r, 100..=10);\n }\n \n@@ -1428,9 +1470,10 @@ fn test_range_inclusive_nth() {\n     assert_eq!(r.nth(2), Some(15));\n     assert_eq!(r, 16..=20);\n     assert_eq!(r.is_empty(), false);\n+    assert_eq!(ExactSizeIterator::is_empty(&r), false);\n     assert_eq!(r.nth(10), None);\n     assert_eq!(r.is_empty(), true);\n-    assert_eq!(r, 1..=0);  // We may not want to document/promise this detail\n+    assert_eq!(ExactSizeIterator::is_empty(&r), true);\n }\n \n #[test]\n@@ -1514,11 +1557,11 @@ fn test_range_inclusive_folds() {\n \n     let mut it = 10..=20;\n     assert_eq!(it.try_fold(0, |a,b| Some(a+b)), Some(165));\n-    assert_eq!(it, 1..=0);\n+    assert!(it.is_empty());\n \n     let mut it = 10..=20;\n     assert_eq!(it.try_rfold(0, |a,b| Some(a+b)), Some(165));\n-    assert_eq!(it, 1..=0);\n+    assert!(it.is_empty());\n }\n \n #[test]\n@@ -1549,6 +1592,51 @@ fn test_repeat_take_collect() {\n     assert_eq!(v, vec![42, 42, 42]);\n }\n \n+#[test]\n+fn test_repeat_with() {\n+    #[derive(PartialEq, Debug)]\n+    struct NotClone(usize);\n+    let mut it = repeat_with(|| NotClone(42));\n+    assert_eq!(it.next(), Some(NotClone(42)));\n+    assert_eq!(it.next(), Some(NotClone(42)));\n+    assert_eq!(it.next(), Some(NotClone(42)));\n+    assert_eq!(repeat_with(|| NotClone(42)).size_hint(), (usize::MAX, None));\n+}\n+\n+#[test]\n+fn test_repeat_with_rev() {\n+    let mut curr = 1;\n+    let mut pow2 = repeat_with(|| { let tmp = curr; curr *= 2; tmp })\n+                    .rev().take(4);\n+    assert_eq!(pow2.next(), Some(1));\n+    assert_eq!(pow2.next(), Some(2));\n+    assert_eq!(pow2.next(), Some(4));\n+    assert_eq!(pow2.next(), Some(8));\n+    assert_eq!(pow2.next(), None);\n+}\n+\n+#[test]\n+fn test_repeat_with_take() {\n+    let mut it = repeat_with(|| 42).take(3);\n+    assert_eq!(it.next(), Some(42));\n+    assert_eq!(it.next(), Some(42));\n+    assert_eq!(it.next(), Some(42));\n+    assert_eq!(it.next(), None);\n+    is_trusted_len(repeat_with(|| 42).take(3));\n+    assert_eq!(repeat_with(|| 42).take(3).size_hint(), (3, Some(3)));\n+    assert_eq!(repeat_with(|| 42).take(0).size_hint(), (0, Some(0)));\n+    assert_eq!(repeat_with(|| 42).take(usize::MAX).size_hint(),\n+               (usize::MAX, Some(usize::MAX)));\n+}\n+\n+#[test]\n+fn test_repeat_with_take_collect() {\n+    let mut curr = 1;\n+    let v: Vec<_> = repeat_with(|| { let tmp = curr; curr *= 2; tmp })\n+                      .take(5).collect();\n+    assert_eq!(v, vec![1, 2, 4, 8, 16]);\n+}\n+\n #[test]\n fn test_fuse() {\n     let mut it = 0..3;"}, {"sha": "3e901a9d442ce29bc8460e2c582fa417c859b93e", "filename": "src/libcore/tests/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1670a532dd769763f1d6ad9e5d624ec31361a098/src%2Flibcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1670a532dd769763f1d6ad9e5d624ec31361a098/src%2Flibcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flib.rs?ref=1670a532dd769763f1d6ad9e5d624ec31361a098", "patch": "@@ -27,8 +27,10 @@\n #![feature(iterator_try_fold)]\n #![feature(iter_rfind)]\n #![feature(iter_rfold)]\n+#![feature(iterator_repeat_with)]\n #![feature(nonzero)]\n #![feature(pattern)]\n+#![feature(range_is_empty)]\n #![feature(raw)]\n #![feature(refcell_replace_swap)]\n #![feature(sip_hash_13)]"}, {"sha": "bed08f86d72c124e4851f46364ddaf4eaee80b74", "filename": "src/libcore/tests/ops.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/1670a532dd769763f1d6ad9e5d624ec31361a098/src%2Flibcore%2Ftests%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1670a532dd769763f1d6ad9e5d624ec31361a098/src%2Flibcore%2Ftests%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fops.rs?ref=1670a532dd769763f1d6ad9e5d624ec31361a098", "patch": "@@ -68,3 +68,27 @@ fn test_range_inclusive() {\n     assert_eq!(r.size_hint(), (0, Some(0)));\n     assert_eq!(r.next(), None);\n }\n+\n+\n+#[test]\n+fn test_range_is_empty() {\n+    use core::f32::*;\n+\n+    assert!(!(0.0 .. 10.0).is_empty());\n+    assert!( (-0.0 .. 0.0).is_empty());\n+    assert!( (10.0 .. 0.0).is_empty());\n+\n+    assert!(!(NEG_INFINITY .. INFINITY).is_empty());\n+    assert!( (EPSILON .. NAN).is_empty());\n+    assert!( (NAN .. EPSILON).is_empty());\n+    assert!( (NAN .. NAN).is_empty());\n+\n+    assert!(!(0.0 ..= 10.0).is_empty());\n+    assert!(!(-0.0 ..= 0.0).is_empty());\n+    assert!( (10.0 ..= 0.0).is_empty());\n+\n+    assert!(!(NEG_INFINITY ..= INFINITY).is_empty());\n+    assert!( (EPSILON ..= NAN).is_empty());\n+    assert!( (NAN ..= EPSILON).is_empty());\n+    assert!( (NAN ..= NAN).is_empty());\n+}"}, {"sha": "b8d0719b9b992b565daf45d68b161b9e68dfff87", "filename": "src/libcore/time.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1670a532dd769763f1d6ad9e5d624ec31361a098/src%2Flibcore%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1670a532dd769763f1d6ad9e5d624ec31361a098/src%2Flibcore%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftime.rs?ref=1670a532dd769763f1d6ad9e5d624ec31361a098", "patch": "@@ -7,7 +7,7 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n-#![stable(feature = \"duration_core\", since = \"1.24.0\")]\n+#![stable(feature = \"duration_core\", since = \"1.25.0\")]\n \n //! Temporal quantification.\n //!\n@@ -58,7 +58,7 @@ const MICROS_PER_SEC: u64 = 1_000_000;\n ///\n /// let ten_millis = Duration::from_millis(10);\n /// ```\n-#[stable(feature = \"duration_core\", since = \"1.24.0\")]\n+#[stable(feature = \"duration\", since = \"1.3.0\")]\n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Debug, Hash, Default)]\n pub struct Duration {\n     secs: u64,"}, {"sha": "99b1e5783e01e18f698307b13181978f3bc23c53", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1670a532dd769763f1d6ad9e5d624ec31361a098/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1670a532dd769763f1d6ad9e5d624ec31361a098/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=1670a532dd769763f1d6ad9e5d624ec31361a098", "patch": "@@ -9,14 +9,15 @@\n // except according to those terms.\n \n use super::*;\n-\n use dep_graph::{DepGraph, DepKind, DepNodeIndex};\n+use hir::def_id::{LOCAL_CRATE, CrateNum};\n use hir::intravisit::{Visitor, NestedVisitorMap};\n use hir::svh::Svh;\n use middle::cstore::CrateStore;\n use session::CrateDisambiguator;\n use std::iter::repeat;\n use syntax::ast::{NodeId, CRATE_NODE_ID};\n+use syntax::codemap::CodeMap;\n use syntax_pos::Span;\n \n use ich::StableHashingContext;\n@@ -123,6 +124,7 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n     pub(super) fn finalize_and_compute_crate_hash(self,\n                                                   crate_disambiguator: CrateDisambiguator,\n                                                   cstore: &CrateStore,\n+                                                  codemap: &CodeMap,\n                                                   commandline_args_hash: u64)\n                                                   -> (Vec<MapEntry<'hir>>, Svh) {\n         let mut node_hashes: Vec<_> = self\n@@ -147,11 +149,25 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n             (name1, dis1).cmp(&(name2, dis2))\n         });\n \n+        // We hash the final, remapped names of all local source files so we\n+        // don't have to include the path prefix remapping commandline args.\n+        // If we included the full mapping in the SVH, we could only have\n+        // reproducible builds by compiling from the same directory. So we just\n+        // hash the result of the mapping instead of the mapping itself.\n+        let mut source_file_names: Vec<_> = codemap\n+            .files()\n+            .iter()\n+            .filter(|filemap| CrateNum::from_u32(filemap.crate_of_origin) == LOCAL_CRATE)\n+            .map(|filemap| filemap.name_hash)\n+            .collect();\n+\n+        source_file_names.sort_unstable();\n+\n         let (_, crate_dep_node_index) = self\n             .dep_graph\n             .with_task(DepNode::new_no_params(DepKind::Krate),\n                        &self.hcx,\n-                       ((node_hashes, upstream_crates),\n+                       (((node_hashes, upstream_crates), source_file_names),\n                         (commandline_args_hash,\n                          crate_disambiguator.to_fingerprint())),\n                        identity_fn);"}, {"sha": "b6b3e8955351c48a4a6d7db511e8fd7985162dd2", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1670a532dd769763f1d6ad9e5d624ec31361a098/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1670a532dd769763f1d6ad9e5d624ec31361a098/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=1670a532dd769763f1d6ad9e5d624ec31361a098", "patch": "@@ -1065,6 +1065,7 @@ pub fn map_crate<'hir>(sess: &::session::Session,\n         let cmdline_args = sess.opts.dep_tracking_hash();\n         collector.finalize_and_compute_crate_hash(crate_disambiguator,\n                                                   cstore,\n+                                                  sess.codemap(),\n                                                   cmdline_args)\n     };\n "}, {"sha": "cfbf233297cf82d32fa4e656232b1d52b86ebac1", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1670a532dd769763f1d6ad9e5d624ec31361a098/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1670a532dd769763f1d6ad9e5d624ec31361a098/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=1670a532dd769763f1d6ad9e5d624ec31361a098", "patch": "@@ -1269,9 +1269,9 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"set the optimization fuel quota for a crate\"),\n     print_fuel: Option<String> = (None, parse_opt_string, [TRACKED],\n         \"make Rustc print the total optimization fuel used by a crate\"),\n-    remap_path_prefix_from: Vec<PathBuf> = (vec![], parse_pathbuf_push, [TRACKED],\n+    remap_path_prefix_from: Vec<PathBuf> = (vec![], parse_pathbuf_push, [UNTRACKED],\n         \"add a source pattern to the file path remapping config\"),\n-    remap_path_prefix_to: Vec<PathBuf> = (vec![], parse_pathbuf_push, [TRACKED],\n+    remap_path_prefix_to: Vec<PathBuf> = (vec![], parse_pathbuf_push, [UNTRACKED],\n         \"add a mapping target to the file path remapping config\"),\n     force_unstable_if_unmarked: bool = (false, parse_bool, [TRACKED],\n         \"force all crates to be `rustc_private` unstable\"),\n@@ -1320,6 +1320,8 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"The epoch to build Rust with. Newer epochs may include features\n          that require breaking changes. The default epoch is 2015 (the first\n          epoch). Crates compiled with different epochs can be linked together.\"),\n+    run_dsymutil: Option<bool> = (None, parse_opt_bool, [TRACKED],\n+          \"run `dsymutil` and delete intermediate object files\"),\n }\n \n pub fn default_lib_output() -> CrateType {\n@@ -1717,7 +1719,7 @@ pub fn build_session_options_and_crate_config(matches: &getopts::Matches)\n     }\n \n     let remap_path_prefix_sources = debugging_opts.remap_path_prefix_from.len();\n-    let remap_path_prefix_targets = debugging_opts.remap_path_prefix_from.len();\n+    let remap_path_prefix_targets = debugging_opts.remap_path_prefix_to.len();\n \n     if remap_path_prefix_targets < remap_path_prefix_sources {\n         for source in &debugging_opts.remap_path_prefix_from[remap_path_prefix_targets..] {"}, {"sha": "b8a1fe99105406b63edbe42f6bb6e343a38578d6", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1670a532dd769763f1d6ad9e5d624ec31361a098/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1670a532dd769763f1d6ad9e5d624ec31361a098/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=1670a532dd769763f1d6ad9e5d624ec31361a098", "patch": "@@ -660,6 +660,15 @@ pub fn phase_2_configure_and_expand_inner<'a, F>(sess: &'a Session,\n         disambiguator,\n     );\n \n+    if sess.opts.incremental.is_some() {\n+        time(time_passes, \"garbage collect incremental cache directory\", || {\n+            if let Err(e) = rustc_incremental::garbage_collect_session_directories(sess) {\n+                warn!(\"Error while trying to garbage collect incremental \\\n+                       compilation cache directory: {}\", e);\n+            }\n+        });\n+    }\n+\n     // If necessary, compute the dependency graph (in the background).\n     let future_dep_graph = if sess.opts.build_dep_graph() {\n         Some(rustc_incremental::load_dep_graph(sess, time_passes))"}, {"sha": "65fbd9d0bf8f1a213a02dbe72347c60a1c1def77", "filename": "src/librustc_incremental/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1670a532dd769763f1d6ad9e5d624ec31361a098/src%2Flibrustc_incremental%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1670a532dd769763f1d6ad9e5d624ec31361a098/src%2Flibrustc_incremental%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Flib.rs?ref=1670a532dd769763f1d6ad9e5d624ec31361a098", "patch": "@@ -46,3 +46,4 @@ pub use persist::in_incr_comp_dir;\n pub use persist::prepare_session_directory;\n pub use persist::finalize_session_directory;\n pub use persist::delete_workproduct_files;\n+pub use persist::garbage_collect_session_directories;"}, {"sha": "795825f180c9dfdcb0658b1c2a1e6898043fff7a", "filename": "src/librustc_incremental/persist/fs.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1670a532dd769763f1d6ad9e5d624ec31361a098/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1670a532dd769763f1d6ad9e5d624ec31361a098/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs?ref=1670a532dd769763f1d6ad9e5d624ec31361a098", "patch": "@@ -603,7 +603,7 @@ fn timestamp_to_string(timestamp: SystemTime) -> String {\n }\n \n fn string_to_timestamp(s: &str) -> Result<SystemTime, ()> {\n-    let micros_since_unix_epoch = u64::from_str_radix(s, 36);\n+    let micros_since_unix_epoch = u64::from_str_radix(s, INT_ENCODE_BASE as u32);\n \n     if micros_since_unix_epoch.is_err() {\n         return Err(())\n@@ -733,6 +733,20 @@ pub fn garbage_collect_session_directories(sess: &Session) -> io::Result<()> {\n                                 })\n                                 .collect();\n \n+    // Delete all session directories that don't have a lock file.\n+    for directory_name in session_directories {\n+        if !lock_file_to_session_dir.values().any(|dir| *dir == directory_name) {\n+            let path = crate_directory.join(directory_name);\n+            if let Err(err) = safe_remove_dir_all(&path) {\n+                sess.warn(&format!(\"Failed to garbage collect invalid incremental \\\n+                                    compilation session directory `{}`: {}\",\n+                                    path.display(),\n+                                    err));\n+            }\n+        }\n+    }\n+\n+    // Now garbage collect the valid session directories.\n     let mut deletion_candidates = vec![];\n     let mut definitely_delete = vec![];\n "}, {"sha": "2f864aaefba89df6fb0a9075260e1ba0f8d53344", "filename": "src/librustc_incremental/persist/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1670a532dd769763f1d6ad9e5d624ec31361a098/src%2Flibrustc_incremental%2Fpersist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1670a532dd769763f1d6ad9e5d624ec31361a098/src%2Flibrustc_incremental%2Fpersist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fmod.rs?ref=1670a532dd769763f1d6ad9e5d624ec31361a098", "patch": "@@ -20,9 +20,10 @@ mod save;\n mod work_product;\n mod file_format;\n \n-pub use self::fs::prepare_session_directory;\n pub use self::fs::finalize_session_directory;\n+pub use self::fs::garbage_collect_session_directories;\n pub use self::fs::in_incr_comp_dir;\n+pub use self::fs::prepare_session_directory;\n pub use self::load::dep_graph_tcx_init;\n pub use self::load::load_dep_graph;\n pub use self::load::load_query_result_cache;"}, {"sha": "f734f3182a93139b29a84a249c251c59646e1837", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/1670a532dd769763f1d6ad9e5d624ec31361a098/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1670a532dd769763f1d6ad9e5d624ec31361a098/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=1670a532dd769763f1d6ad9e5d624ec31361a098", "patch": "@@ -11,6 +11,7 @@\n #![allow(non_snake_case)]\n \n use rustc::hir::def_id::DefId;\n+use rustc::hir::map as hir_map;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, AdtKind, Ty, TyCtxt};\n use rustc::ty::layout::{self, LayoutOf};\n@@ -176,6 +177,22 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                             _ => bug!(),\n                         };\n                         if lit_val < min || lit_val > max {\n+                            let parent_id = cx.tcx.hir.get_parent_node(e.id);\n+                            if let hir_map::NodeExpr(parent_expr) = cx.tcx.hir.get(parent_id) {\n+                                if let hir::ExprCast(..) = parent_expr.node {\n+                                    if let ty::TyChar = cx.tables.expr_ty(parent_expr).sty {\n+                                        let mut err = cx.struct_span_lint(\n+                                                             OVERFLOWING_LITERALS,\n+                                                             parent_expr.span,\n+                                                             \"only u8 can be casted into char\");\n+                                        err.span_suggestion(parent_expr.span,\n+                                                            &\"use a char literal instead\",\n+                                                            format!(\"'\\\\u{{{:X}}}'\", lit_val));\n+                                        err.emit();\n+                                        return\n+                                    }\n+                                }\n+                            }\n                             cx.span_lint(OVERFLOWING_LITERALS,\n                                          e.span,\n                                          &format!(\"literal out of range for {:?}\", t));"}, {"sha": "54e3f544acb68b0258186b0729245a02b324070a", "filename": "src/librustc_llvm/build.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1670a532dd769763f1d6ad9e5d624ec31361a098/src%2Flibrustc_llvm%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1670a532dd769763f1d6ad9e5d624ec31361a098/src%2Flibrustc_llvm%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fbuild.rs?ref=1670a532dd769763f1d6ad9e5d624ec31361a098", "patch": "@@ -155,6 +155,7 @@ fn main() {\n     cfg.file(\"../rustllvm/PassWrapper.cpp\")\n        .file(\"../rustllvm/RustWrapper.cpp\")\n        .file(\"../rustllvm/ArchiveWrapper.cpp\")\n+       .file(\"../rustllvm/Linker.cpp\")\n        .cpp(true)\n        .cpp_link_stdlib(None) // we handle this below\n        .compile(\"rustllvm\");"}, {"sha": "e71bef512cf067c84956d197d93394565fac9476", "filename": "src/librustc_llvm/ffi.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1670a532dd769763f1d6ad9e5d624ec31361a098/src%2Flibrustc_llvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1670a532dd769763f1d6ad9e5d624ec31361a098/src%2Flibrustc_llvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fffi.rs?ref=1670a532dd769763f1d6ad9e5d624ec31361a098", "patch": "@@ -444,6 +444,9 @@ pub type RustArchiveMemberRef = *mut RustArchiveMember_opaque;\n #[allow(missing_copy_implementations)]\n pub enum OperandBundleDef_opaque {}\n pub type OperandBundleDefRef = *mut OperandBundleDef_opaque;\n+#[allow(missing_copy_implementations)]\n+pub enum Linker_opaque {}\n+pub type LinkerRef = *mut Linker_opaque;\n \n pub type DiagnosticHandler = unsafe extern \"C\" fn(DiagnosticInfoRef, *mut c_void);\n pub type InlineAsmDiagHandler = unsafe extern \"C\" fn(SMDiagnosticRef, *const c_void, c_uint);\n@@ -1608,7 +1611,6 @@ extern \"C\" {\n     pub fn LLVMRustPrintPasses();\n     pub fn LLVMRustSetNormalizedTarget(M: ModuleRef, triple: *const c_char);\n     pub fn LLVMRustAddAlwaysInlinePass(P: PassManagerBuilderRef, AddLifetimes: bool);\n-    pub fn LLVMRustLinkInExternalBitcode(M: ModuleRef, bc: *const c_char, len: size_t) -> bool;\n     pub fn LLVMRustRunRestrictionPass(M: ModuleRef, syms: *const *const c_char, len: size_t);\n     pub fn LLVMRustMarkAllFunctionsNounwind(M: ModuleRef);\n \n@@ -1724,4 +1726,10 @@ extern \"C\" {\n                                            CU2: *mut *mut c_void);\n     pub fn LLVMRustThinLTOPatchDICompileUnit(M: ModuleRef, CU: *mut c_void);\n     pub fn LLVMRustThinLTORemoveAvailableExternally(M: ModuleRef);\n+\n+    pub fn LLVMRustLinkerNew(M: ModuleRef) -> LinkerRef;\n+    pub fn LLVMRustLinkerAdd(linker: LinkerRef,\n+                             bytecode: *const c_char,\n+                             bytecode_len: usize) -> bool;\n+    pub fn LLVMRustLinkerFree(linker: LinkerRef);\n }"}, {"sha": "7cc4ba84895251ec5303a99e86882d8135a87f78", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/1670a532dd769763f1d6ad9e5d624ec31361a098/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1670a532dd769763f1d6ad9e5d624ec31361a098/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=1670a532dd769763f1d6ad9e5d624ec31361a098", "patch": "@@ -238,7 +238,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         self.tcx.data_layout.pointer_size.bytes()\n     }\n \n-    pub fn endianess(&self) -> layout::Endian {\n+    pub fn endianness(&self) -> layout::Endian {\n         self.tcx.data_layout.endian\n     }\n \n@@ -722,7 +722,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n \n     pub fn read_primval(&self, ptr: MemoryPointer, ptr_align: Align, size: u64, signed: bool) -> EvalResult<'tcx, PrimVal> {\n         self.check_relocation_edges(ptr, size)?; // Make sure we don't read part of a pointer as a pointer\n-        let endianess = self.endianess();\n+        let endianness = self.endianness();\n         let bytes = self.get_bytes_unchecked(ptr, size, ptr_align.min(self.int_align(size)))?;\n         // Undef check happens *after* we established that the alignment is correct.\n         // We must not return Ok() for unaligned pointers!\n@@ -731,9 +731,9 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         }\n         // Now we do the actual reading\n         let bytes = if signed {\n-            read_target_int(endianess, bytes).unwrap() as u128\n+            read_target_int(endianness, bytes).unwrap() as u128\n         } else {\n-            read_target_uint(endianess, bytes).unwrap()\n+            read_target_uint(endianness, bytes).unwrap()\n         };\n         // See if we got a pointer\n         if size != self.pointer_size() {\n@@ -756,7 +756,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n     }\n \n     pub fn write_primval(&mut self, ptr: MemoryPointer, ptr_align: Align, val: PrimVal, size: u64, signed: bool) -> EvalResult<'tcx> {\n-        let endianess = self.endianess();\n+        let endianness = self.endianness();\n \n         let bytes = match val {\n             PrimVal::Ptr(val) => {\n@@ -788,9 +788,9 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n             let align = self.int_align(size);\n             let dst = self.get_bytes_mut(ptr, size, ptr_align.min(align))?;\n             if signed {\n-                write_target_int(endianess, dst, bytes as i128).unwrap();\n+                write_target_int(endianness, dst, bytes as i128).unwrap();\n             } else {\n-                write_target_uint(endianess, dst, bytes).unwrap();\n+                write_target_uint(endianness, dst, bytes).unwrap();\n             }\n         }\n \n@@ -941,41 +941,41 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n }\n \n ////////////////////////////////////////////////////////////////////////////////\n-// Methods to access integers in the target endianess\n+// Methods to access integers in the target endianness\n ////////////////////////////////////////////////////////////////////////////////\n \n fn write_target_uint(\n-    endianess: layout::Endian,\n+    endianness: layout::Endian,\n     mut target: &mut [u8],\n     data: u128,\n ) -> Result<(), io::Error> {\n     let len = target.len();\n-    match endianess {\n+    match endianness {\n         layout::Endian::Little => target.write_uint128::<LittleEndian>(data, len),\n         layout::Endian::Big => target.write_uint128::<BigEndian>(data, len),\n     }\n }\n fn write_target_int(\n-    endianess: layout::Endian,\n+    endianness: layout::Endian,\n     mut target: &mut [u8],\n     data: i128,\n ) -> Result<(), io::Error> {\n     let len = target.len();\n-    match endianess {\n+    match endianness {\n         layout::Endian::Little => target.write_int128::<LittleEndian>(data, len),\n         layout::Endian::Big => target.write_int128::<BigEndian>(data, len),\n     }\n }\n \n-fn read_target_uint(endianess: layout::Endian, mut source: &[u8]) -> Result<u128, io::Error> {\n-    match endianess {\n+fn read_target_uint(endianness: layout::Endian, mut source: &[u8]) -> Result<u128, io::Error> {\n+    match endianness {\n         layout::Endian::Little => source.read_uint128::<LittleEndian>(source.len()),\n         layout::Endian::Big => source.read_uint128::<BigEndian>(source.len()),\n     }\n }\n \n-fn read_target_int(endianess: layout::Endian, mut source: &[u8]) -> Result<i128, io::Error> {\n-    match endianess {\n+fn read_target_int(endianness: layout::Endian, mut source: &[u8]) -> Result<i128, io::Error> {\n+    match endianness {\n         layout::Endian::Little => source.read_int128::<LittleEndian>(source.len()),\n         layout::Endian::Big => source.read_int128::<BigEndian>(source.len()),\n     }"}, {"sha": "8309c91ab2573bcf4ee7f349cd9e7b45f79b3d05", "filename": "src/librustc_trans/attributes.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1670a532dd769763f1d6ad9e5d624ec31361a098/src%2Flibrustc_trans%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1670a532dd769763f1d6ad9e5d624ec31361a098/src%2Flibrustc_trans%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fattributes.rs?ref=1670a532dd769763f1d6ad9e5d624ec31361a098", "patch": "@@ -142,7 +142,7 @@ pub fn provide(providers: &mut Providers) {\n         assert_eq!(cnum, LOCAL_CRATE);\n         Rc::new(llvm_util::target_feature_whitelist(tcx.sess)\n             .iter()\n-            .map(|c| c.to_str().unwrap().to_string())\n+            .map(|c| c.to_string())\n             .collect())\n     };\n \n@@ -212,7 +212,8 @@ fn from_target_feature(\n         let value = value.as_str();\n         for feature in value.split(',') {\n             if whitelist.contains(feature) {\n-                target_features.push(format!(\"+{}\", feature));\n+                let llvm_feature = llvm_util::to_llvm_feature(feature);\n+                target_features.push(format!(\"+{}\", llvm_feature));\n                 continue\n             }\n "}, {"sha": "4fe294a790fc4467edaedbd686672d48535e3f09", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 55, "deletions": 3, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/1670a532dd769763f1d6ad9e5d624ec31361a098/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1670a532dd769763f1d6ad9e5d624ec31361a098/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=1670a532dd769763f1d6ad9e5d624ec31361a098", "patch": "@@ -166,7 +166,9 @@ pub(crate) fn link_binary(sess: &Session,\n \n     // Remove the temporary object file and metadata if we aren't saving temps\n     if !sess.opts.cg.save_temps {\n-        if sess.opts.output_types.should_trans() {\n+        if sess.opts.output_types.should_trans() &&\n+            !preserve_objects_for_their_debuginfo(sess)\n+        {\n             for obj in trans.modules.iter().filter_map(|m| m.object.as_ref()) {\n                 remove(sess, obj);\n             }\n@@ -190,6 +192,52 @@ pub(crate) fn link_binary(sess: &Session,\n     out_filenames\n }\n \n+/// Returns a boolean indicating whether we should preserve the object files on\n+/// the filesystem for their debug information. This is often useful with\n+/// split-dwarf like schemes.\n+fn preserve_objects_for_their_debuginfo(sess: &Session) -> bool {\n+    // If the objects don't have debuginfo there's nothing to preserve.\n+    if sess.opts.debuginfo == NoDebugInfo {\n+        return false\n+    }\n+\n+    // If we're only producing artifacts that are archives, no need to preserve\n+    // the objects as they're losslessly contained inside the archives.\n+    let output_linked = sess.crate_types.borrow()\n+        .iter()\n+        .any(|x| *x != config::CrateTypeRlib && *x != config::CrateTypeStaticlib);\n+    if !output_linked {\n+        return false\n+    }\n+\n+    // If we're on OSX then the equivalent of split dwarf is turned on by\n+    // default. The final executable won't actually have any debug information\n+    // except it'll have pointers to elsewhere. Historically we've always run\n+    // `dsymutil` to \"link all the dwarf together\" but this is actually sort of\n+    // a bummer for incremental compilation! (the whole point of split dwarf is\n+    // that you don't do this sort of dwarf link).\n+    //\n+    // Basically as a result this just means that if we're on OSX and we're\n+    // *not* running dsymutil then the object files are the only source of truth\n+    // for debug information, so we must preserve them.\n+    if sess.target.target.options.is_like_osx {\n+        match sess.opts.debugging_opts.run_dsymutil {\n+            // dsymutil is not being run, preserve objects\n+            Some(false) => return true,\n+\n+            // dsymutil is being run, no need to preserve the objects\n+            Some(true) => return false,\n+\n+            // The default historical behavior was to always run dsymutil, so\n+            // we're preserving that temporarily, but we're likely to switch the\n+            // default soon.\n+            None => return false,\n+        }\n+    }\n+\n+    false\n+}\n+\n fn filename_for_metadata(sess: &Session, crate_name: &str, outputs: &OutputFilenames) -> PathBuf {\n     let out_filename = outputs.single_output_file.clone()\n         .unwrap_or(outputs\n@@ -736,8 +784,12 @@ fn link_natively(sess: &Session,\n \n \n     // On macOS, debuggers need this utility to get run to do some munging of\n-    // the symbols\n-    if sess.target.target.options.is_like_osx && sess.opts.debuginfo != NoDebugInfo {\n+    // the symbols. Note, though, that if the object files are being preserved\n+    // for their debug information there's no need for us to run dsymutil.\n+    if sess.target.target.options.is_like_osx &&\n+        sess.opts.debuginfo != NoDebugInfo &&\n+        !preserve_objects_for_their_debuginfo(sess)\n+    {\n         match Command::new(\"dsymutil\").arg(out_filename).output() {\n             Ok(..) => {}\n             Err(e) => sess.fatal(&format!(\"failed to run dsymutil: {}\", e)),"}, {"sha": "a33270380196f5ec9ec5774eeecbd55ad5922029", "filename": "src/librustc_trans/back/lto.rs", "status": "modified", "additions": 32, "deletions": 8, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/1670a532dd769763f1d6ad9e5d624ec31361a098/src%2Flibrustc_trans%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1670a532dd769763f1d6ad9e5d624ec31361a098/src%2Flibrustc_trans%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flto.rs?ref=1670a532dd769763f1d6ad9e5d624ec31361a098", "patch": "@@ -247,22 +247,20 @@ fn fat_lto(cgcx: &CodegenContext,\n     // know much about the memory management here so we err on the side of being\n     // save and persist everything with the original module.\n     let mut serialized_bitcode = Vec::new();\n+    let mut linker = Linker::new(llmod);\n     for (bc_decoded, name) in serialized_modules {\n         info!(\"linking {:?}\", name);\n-        time(cgcx.time_passes, &format!(\"ll link {:?}\", name), || unsafe {\n+        time(cgcx.time_passes, &format!(\"ll link {:?}\", name), || {\n             let data = bc_decoded.data();\n-            if llvm::LLVMRustLinkInExternalBitcode(llmod,\n-                                                   data.as_ptr() as *const libc::c_char,\n-                                                   data.len() as libc::size_t) {\n-                Ok(())\n-            } else {\n+            linker.add(&data).map_err(|()| {\n                 let msg = format!(\"failed to load bc of {:?}\", name);\n-                Err(write::llvm_err(&diag_handler, msg))\n-            }\n+                write::llvm_err(&diag_handler, msg)\n+            })\n         })?;\n         timeline.record(&format!(\"link {:?}\", name));\n         serialized_bitcode.push(bc_decoded);\n     }\n+    drop(linker);\n     cgcx.save_temp_bitcode(&module, \"lto.input\");\n \n     // Internalize everything that *isn't* in our whitelist to help strip out\n@@ -289,6 +287,32 @@ fn fat_lto(cgcx: &CodegenContext,\n     }])\n }\n \n+struct Linker(llvm::LinkerRef);\n+\n+impl Linker {\n+    fn new(llmod: ModuleRef) -> Linker {\n+        unsafe { Linker(llvm::LLVMRustLinkerNew(llmod)) }\n+    }\n+\n+    fn add(&mut self, bytecode: &[u8]) -> Result<(), ()> {\n+        unsafe {\n+            if llvm::LLVMRustLinkerAdd(self.0,\n+                                       bytecode.as_ptr() as *const libc::c_char,\n+                                       bytecode.len()) {\n+                Ok(())\n+            } else {\n+                Err(())\n+            }\n+        }\n+    }\n+}\n+\n+impl Drop for Linker {\n+    fn drop(&mut self) {\n+        unsafe { llvm::LLVMRustLinkerFree(self.0); }\n+    }\n+}\n+\n /// Prepare \"thin\" LTO to get run on these modules.\n ///\n /// The general structure of ThinLTO is quite different from the structure of"}, {"sha": "b25562252e72e86cc70585acd9ac74a24faf7986", "filename": "src/librustc_trans/llvm_util.rs", "status": "modified", "additions": 39, "deletions": 35, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/1670a532dd769763f1d6ad9e5d624ec31361a098/src%2Flibrustc_trans%2Fllvm_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1670a532dd769763f1d6ad9e5d624ec31361a098/src%2Flibrustc_trans%2Fllvm_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fllvm_util.rs?ref=1670a532dd769763f1d6ad9e5d624ec31361a098", "patch": "@@ -14,7 +14,7 @@ use llvm;\n use rustc::session::Session;\n use rustc::session::config::PrintRequest;\n use libc::c_int;\n-use std::ffi::{CStr, CString};\n+use std::ffi::CString;\n \n use std::sync::atomic::{AtomicBool, Ordering};\n use std::sync::Once;\n@@ -79,57 +79,61 @@ unsafe fn configure_llvm(sess: &Session) {\n // detection code will walk past the end of the feature array,\n // leading to crashes.\n \n-const ARM_WHITELIST: &'static [&'static str] = &[\"neon\\0\", \"v7\\0\", \"vfp2\\0\", \"vfp3\\0\", \"vfp4\\0\"];\n+const ARM_WHITELIST: &'static [&'static str] = &[\"neon\", \"v7\", \"vfp2\", \"vfp3\", \"vfp4\"];\n \n-const AARCH64_WHITELIST: &'static [&'static str] = &[\"neon\\0\", \"v7\\0\"];\n+const AARCH64_WHITELIST: &'static [&'static str] = &[\"neon\", \"v7\"];\n \n-const X86_WHITELIST: &'static [&'static str] = &[\"avx\\0\", \"avx2\\0\", \"bmi\\0\", \"bmi2\\0\", \"sse\\0\",\n-                                                 \"sse2\\0\", \"sse3\\0\", \"sse4.1\\0\", \"sse4.2\\0\",\n-                                                 \"ssse3\\0\", \"tbm\\0\", \"lzcnt\\0\", \"popcnt\\0\",\n-                                                 \"sse4a\\0\", \"rdrnd\\0\", \"rdseed\\0\", \"fma\\0\",\n-                                                 \"xsave\\0\", \"xsaveopt\\0\", \"xsavec\\0\",\n-                                                 \"xsaves\\0\", \"aes\\0\",\n-                                                 \"avx512bw\\0\", \"avx512cd\\0\",\n-                                                 \"avx512dq\\0\", \"avx512er\\0\",\n-                                                 \"avx512f\\0\", \"avx512ifma\\0\",\n-                                                 \"avx512pf\\0\", \"avx512vbmi\\0\",\n-                                                 \"avx512vl\\0\", \"avx512vpopcntdq\\0\",\n-                                                 \"mmx\\0\", \"fxsr\\0\"];\n+const X86_WHITELIST: &'static [&'static str] = &[\"avx\", \"avx2\", \"bmi\", \"bmi2\", \"sse\",\n+                                                 \"sse2\", \"sse3\", \"sse4.1\", \"sse4.2\",\n+                                                 \"ssse3\", \"tbm\", \"lzcnt\", \"popcnt\",\n+                                                 \"sse4a\", \"rdrnd\", \"rdseed\", \"fma\",\n+                                                 \"xsave\", \"xsaveopt\", \"xsavec\",\n+                                                 \"xsaves\", \"aes\", \"pclmulqdq\",\n+                                                 \"avx512bw\", \"avx512cd\",\n+                                                 \"avx512dq\", \"avx512er\",\n+                                                 \"avx512f\", \"avx512ifma\",\n+                                                 \"avx512pf\", \"avx512vbmi\",\n+                                                 \"avx512vl\", \"avx512vpopcntdq\",\n+                                                 \"mmx\", \"fxsr\"];\n \n-const HEXAGON_WHITELIST: &'static [&'static str] = &[\"hvx\\0\", \"hvx-double\\0\"];\n+const HEXAGON_WHITELIST: &'static [&'static str] = &[\"hvx\", \"hvx-double\"];\n \n-const POWERPC_WHITELIST: &'static [&'static str] = &[\"altivec\\0\",\n-                                                     \"power8-altivec\\0\", \"power9-altivec\\0\",\n-                                                     \"power8-vector\\0\", \"power9-vector\\0\",\n-                                                     \"vsx\\0\"];\n+const POWERPC_WHITELIST: &'static [&'static str] = &[\"altivec\",\n+                                                     \"power8-altivec\", \"power9-altivec\",\n+                                                     \"power8-vector\", \"power9-vector\",\n+                                                     \"vsx\"];\n \n-const MIPS_WHITELIST: &'static [&'static str] = &[\"msa\\0\"];\n+const MIPS_WHITELIST: &'static [&'static str] = &[\"msa\"];\n+\n+pub fn to_llvm_feature(s: &str) -> &str {\n+    match s {\n+        \"pclmulqdq\" => \"pclmul\",\n+        s => s,\n+    }\n+}\n \n pub fn target_features(sess: &Session) -> Vec<Symbol> {\n-    let whitelist = target_feature_whitelist(sess);\n     let target_machine = create_target_machine(sess);\n-    let mut features = Vec::new();\n-    for feat in whitelist {\n-        if unsafe { llvm::LLVMRustHasFeature(target_machine, feat.as_ptr()) } {\n-            features.push(Symbol::intern(feat.to_str().unwrap()));\n-        }\n-    }\n-    features\n+    target_feature_whitelist(sess)\n+        .iter()\n+        .filter(|feature| {\n+            let llvm_feature = to_llvm_feature(feature);\n+            let cstr = CString::new(llvm_feature).unwrap();\n+            unsafe { llvm::LLVMRustHasFeature(target_machine, cstr.as_ptr()) }\n+        })\n+        .map(|feature| Symbol::intern(feature)).collect()\n }\n \n-pub fn target_feature_whitelist(sess: &Session) -> Vec<&CStr> {\n-    let whitelist = match &*sess.target.target.arch {\n+pub fn target_feature_whitelist(sess: &Session) -> &'static [&'static str] {\n+    match &*sess.target.target.arch {\n         \"arm\" => ARM_WHITELIST,\n         \"aarch64\" => AARCH64_WHITELIST,\n         \"x86\" | \"x86_64\" => X86_WHITELIST,\n         \"hexagon\" => HEXAGON_WHITELIST,\n         \"mips\" | \"mips64\" => MIPS_WHITELIST,\n         \"powerpc\" | \"powerpc64\" => POWERPC_WHITELIST,\n         _ => &[],\n-    };\n-    whitelist.iter().map(|m| {\n-        CStr::from_bytes_with_nul(m.as_bytes()).unwrap()\n-    }).collect()\n+    }\n }\n \n pub fn print_version() {"}, {"sha": "2d0fe55f70d265a039f973c9da82ab3fc860d1c0", "filename": "src/librustdoc/html/static/themes/dark.css", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1670a532dd769763f1d6ad9e5d624ec31361a098/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fdark.css", "raw_url": "https://github.com/rust-lang/rust/raw/1670a532dd769763f1d6ad9e5d624ec31361a098/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fdark.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fdark.css?ref=1670a532dd769763f1d6ad9e5d624ec31361a098", "patch": "@@ -130,7 +130,7 @@ pre {\n .content .highlighted.primitive { background-color: #00708a; }\n \n .content span.enum, .content a.enum, .block a.current.enum { color: #82b089; }\n-.content span.struct, .content a.struct, .block a.current.struct { color: #ff794d; }\n+.content span.struct, .content a.struct, .block a.current.struct { color: #2dbfb8; }\n .content span.type, .content a.type, .block a.current.type { color: #ff7f00; }\n .content span.foreigntype, .content a.foreigntype, .block a.current.foreigntype { color: #dd7de8; }\n .content span.macro, .content a.macro, .block a.current.macro { color: #09bd00; }"}, {"sha": "2334a2728554ea66dd8d345264a59e1e03ce843e", "filename": "src/librustdoc/html/static/themes/main.css", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1670a532dd769763f1d6ad9e5d624ec31361a098/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fmain.css", "raw_url": "https://github.com/rust-lang/rust/raw/1670a532dd769763f1d6ad9e5d624ec31361a098/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fmain.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fmain.css?ref=1670a532dd769763f1d6ad9e5d624ec31361a098", "patch": "@@ -130,7 +130,7 @@ pre {\n .content .highlighted.primitive { background-color: #9aecff; }\n \n .content span.enum, .content a.enum, .block a.current.enum { color: #508157; }\n-.content span.struct, .content a.struct, .block a.current.struct { color: #df3600; }\n+.content span.struct, .content a.struct, .block a.current.struct { color: #ad448e; }\n .content span.type, .content a.type, .block a.current.type { color: #ba5d00; }\n .content span.foreigntype, .content a.foreigntype, .block a.current.foreigntype { color: #cd00e2; }\n .content span.macro, .content a.macro, .block a.current.macro { color: #068000; }"}, {"sha": "a82ff915093c6ca0952bee2f672bb4cbb7e85df2", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 38, "deletions": 26, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/1670a532dd769763f1d6ad9e5d624ec31361a098/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1670a532dd769763f1d6ad9e5d624ec31361a098/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=1670a532dd769763f1d6ad9e5d624ec31361a098", "patch": "@@ -398,8 +398,9 @@ pub struct HashMap<K, V, S = RandomState> {\n }\n \n /// Search for a pre-hashed key.\n+/// If you don't already know the hash, use search or search_mut instead\n #[inline]\n-fn search_hashed<K, V, M, F>(table: M, hash: SafeHash, mut is_match: F) -> InternalEntry<K, V, M>\n+fn search_hashed<K, V, M, F>(table: M, hash: SafeHash, is_match: F) -> InternalEntry<K, V, M>\n     where M: Deref<Target = RawTable<K, V>>,\n           F: FnMut(&K) -> bool\n {\n@@ -410,6 +411,18 @@ fn search_hashed<K, V, M, F>(table: M, hash: SafeHash, mut is_match: F) -> Inter\n         return InternalEntry::TableIsEmpty;\n     }\n \n+    search_hashed_nonempty(table, hash, is_match)\n+}\n+\n+/// Search for a pre-hashed key when the hash map is known to be non-empty.\n+#[inline]\n+fn search_hashed_nonempty<K, V, M, F>(table: M, hash: SafeHash, mut is_match: F)\n+    -> InternalEntry<K, V, M>\n+    where M: Deref<Target = RawTable<K, V>>,\n+          F: FnMut(&K) -> bool\n+{\n+    // Do not check the capacity as an extra branch could slow the lookup.\n+\n     let size = table.size();\n     let mut probe = Bucket::new(table, hash);\n     let mut displacement = 0;\n@@ -543,24 +556,36 @@ impl<K, V, S> HashMap<K, V, S>\n     }\n \n     /// Search for a key, yielding the index if it's found in the hashtable.\n-    /// If you already have the hash for the key lying around, use\n-    /// search_hashed.\n+    /// If you already have the hash for the key lying around, or if you need an\n+    /// InternalEntry, use search_hashed or search_hashed_nonempty.\n     #[inline]\n-    fn search<'a, Q: ?Sized>(&'a self, q: &Q) -> InternalEntry<K, V, &'a RawTable<K, V>>\n+    fn search<'a, Q: ?Sized>(&'a self, q: &Q)\n+        -> Option<FullBucket<K, V, &'a RawTable<K, V>>>\n         where K: Borrow<Q>,\n               Q: Eq + Hash\n     {\n+        if self.is_empty() {\n+            return None;\n+        }\n+\n         let hash = self.make_hash(q);\n-        search_hashed(&self.table, hash, |k| q.eq(k.borrow()))\n+        search_hashed_nonempty(&self.table, hash, |k| q.eq(k.borrow()))\n+            .into_occupied_bucket()\n     }\n \n     #[inline]\n-    fn search_mut<'a, Q: ?Sized>(&'a mut self, q: &Q) -> InternalEntry<K, V, &'a mut RawTable<K, V>>\n+    fn search_mut<'a, Q: ?Sized>(&'a mut self, q: &Q)\n+        -> Option<FullBucket<K, V, &'a mut RawTable<K, V>>>\n         where K: Borrow<Q>,\n               Q: Eq + Hash\n     {\n+        if self.is_empty() {\n+            return None;\n+        }\n+\n         let hash = self.make_hash(q);\n-        search_hashed(&mut self.table, hash, |k| q.eq(k.borrow()))\n+        search_hashed_nonempty(&mut self.table, hash, |k| q.eq(k.borrow()))\n+            .into_occupied_bucket()\n     }\n \n     // The caller should ensure that invariants by Robin Hood Hashing hold\n@@ -1118,7 +1143,7 @@ impl<K, V, S> HashMap<K, V, S>\n         where K: Borrow<Q>,\n               Q: Hash + Eq\n     {\n-        self.search(k).into_occupied_bucket().map(|bucket| bucket.into_refs().1)\n+        self.search(k).map(|bucket| bucket.into_refs().1)\n     }\n \n     /// Returns true if the map contains a value for the specified key.\n@@ -1145,7 +1170,7 @@ impl<K, V, S> HashMap<K, V, S>\n         where K: Borrow<Q>,\n               Q: Hash + Eq\n     {\n-        self.search(k).into_occupied_bucket().is_some()\n+        self.search(k).is_some()\n     }\n \n     /// Returns a mutable reference to the value corresponding to the key.\n@@ -1174,7 +1199,7 @@ impl<K, V, S> HashMap<K, V, S>\n         where K: Borrow<Q>,\n               Q: Hash + Eq\n     {\n-        self.search_mut(k).into_occupied_bucket().map(|bucket| bucket.into_mut_refs().1)\n+        self.search_mut(k).map(|bucket| bucket.into_mut_refs().1)\n     }\n \n     /// Inserts a key-value pair into the map.\n@@ -1234,11 +1259,7 @@ impl<K, V, S> HashMap<K, V, S>\n         where K: Borrow<Q>,\n               Q: Hash + Eq\n     {\n-        if self.table.size() == 0 {\n-            return None;\n-        }\n-\n-        self.search_mut(k).into_occupied_bucket().map(|bucket| pop_internal(bucket).1)\n+        self.search_mut(k).map(|bucket| pop_internal(bucket).1)\n     }\n \n     /// Removes a key from the map, returning the stored key and value if the\n@@ -1269,12 +1290,7 @@ impl<K, V, S> HashMap<K, V, S>\n         where K: Borrow<Q>,\n               Q: Hash + Eq\n     {\n-        if self.table.size() == 0 {\n-            return None;\n-        }\n-\n         self.search_mut(k)\n-            .into_occupied_bucket()\n             .map(|bucket| {\n                 let (k, v, _) = pop_internal(bucket);\n                 (k, v)\n@@ -2632,15 +2648,11 @@ impl<K, S, Q: ?Sized> super::Recover<Q> for HashMap<K, (), S>\n \n     #[inline]\n     fn get(&self, key: &Q) -> Option<&K> {\n-        self.search(key).into_occupied_bucket().map(|bucket| bucket.into_refs().0)\n+        self.search(key).map(|bucket| bucket.into_refs().0)\n     }\n \n     fn take(&mut self, key: &Q) -> Option<K> {\n-        if self.table.size() == 0 {\n-            return None;\n-        }\n-\n-        self.search_mut(key).into_occupied_bucket().map(|bucket| pop_internal(bucket).0)\n+        self.search_mut(key).map(|bucket| pop_internal(bucket).0)\n     }\n \n     #[inline]"}, {"sha": "c4946b6b2824d3eed6e6d20567e2fa195ff2c511", "filename": "src/libstd/env.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1670a532dd769763f1d6ad9e5d624ec31361a098/src%2Flibstd%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1670a532dd769763f1d6ad9e5d624ec31361a098/src%2Flibstd%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fenv.rs?ref=1670a532dd769763f1d6ad9e5d624ec31361a098", "patch": "@@ -723,6 +723,12 @@ pub fn args_os() -> ArgsOs {\n     ArgsOs { inner: sys::args::args() }\n }\n \n+#[stable(feature = \"env_unimpl_send_sync\", since = \"1.25.0\")]\n+impl !Send for Args {}\n+\n+#[stable(feature = \"env_unimpl_send_sync\", since = \"1.25.0\")]\n+impl !Sync for Args {}\n+\n #[stable(feature = \"env\", since = \"1.0.0\")]\n impl Iterator for Args {\n     type Item = String;\n@@ -754,6 +760,12 @@ impl fmt::Debug for Args {\n     }\n }\n \n+#[stable(feature = \"env_unimpl_send_sync\", since = \"1.25.0\")]\n+impl !Send for ArgsOs {}\n+\n+#[stable(feature = \"env_unimpl_send_sync\", since = \"1.25.0\")]\n+impl !Sync for ArgsOs {}\n+\n #[stable(feature = \"env\", since = \"1.0.0\")]\n impl Iterator for ArgsOs {\n     type Item = OsString;"}, {"sha": "a760922115aef330ebb44463d4412c687e1cbbc4", "filename": "src/libstd/f32.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1670a532dd769763f1d6ad9e5d624ec31361a098/src%2Flibstd%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1670a532dd769763f1d6ad9e5d624ec31361a098/src%2Flibstd%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff32.rs?ref=1670a532dd769763f1d6ad9e5d624ec31361a098", "patch": "@@ -1023,7 +1023,7 @@ impl f32 {\n     /// This is currently identical to `transmute::<u32, f32>(v)` on all platforms.\n     /// It turns out this is incredibly portable, for two reasons:\n     ///\n-    /// * Floats and Ints have the same endianess on all supported platforms.\n+    /// * Floats and Ints have the same endianness on all supported platforms.\n     /// * IEEE-754 very precisely specifies the bit layout of floats.\n     ///\n     /// However there is one caveat: prior to the 2008 version of IEEE-754, how"}, {"sha": "6f34f176a971155b09c2d3e5ecad66cd56002ac7", "filename": "src/libstd/f64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1670a532dd769763f1d6ad9e5d624ec31361a098/src%2Flibstd%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1670a532dd769763f1d6ad9e5d624ec31361a098/src%2Flibstd%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff64.rs?ref=1670a532dd769763f1d6ad9e5d624ec31361a098", "patch": "@@ -978,7 +978,7 @@ impl f64 {\n     /// This is currently identical to `transmute::<u64, f64>(v)` on all platforms.\n     /// It turns out this is incredibly portable, for two reasons:\n     ///\n-    /// * Floats and Ints have the same endianess on all supported platforms.\n+    /// * Floats and Ints have the same endianness on all supported platforms.\n     /// * IEEE-754 very precisely specifies the bit layout of floats.\n     ///\n     /// However there is one caveat: prior to the 2008 version of IEEE-754, how"}, {"sha": "76bcb5fedc94aed53fe7c86454897938808c2e31", "filename": "src/libstd/io/cursor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1670a532dd769763f1d6ad9e5d624ec31361a098/src%2Flibstd%2Fio%2Fcursor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1670a532dd769763f1d6ad9e5d624ec31361a098/src%2Flibstd%2Fio%2Fcursor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fcursor.rs?ref=1670a532dd769763f1d6ad9e5d624ec31361a098", "patch": "@@ -296,7 +296,7 @@ impl<'a> Write for Cursor<&'a mut [u8]> {\n     fn flush(&mut self) -> io::Result<()> { Ok(()) }\n }\n \n-#[unstable(feature = \"cursor_mut_vec\", issue = \"30132\")]\n+#[stable(feature = \"cursor_mut_vec\", since = \"1.25.0\")]\n impl<'a> Write for Cursor<&'a mut Vec<u8>> {\n     fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n         vec_write(&mut self.pos, self.inner, buf)"}, {"sha": "e03a182653e5a451810c99820ed16ea8b1de4fe5", "filename": "src/libstd/path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1670a532dd769763f1d6ad9e5d624ec31361a098/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1670a532dd769763f1d6ad9e5d624ec31361a098/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=1670a532dd769763f1d6ad9e5d624ec31361a098", "patch": "@@ -576,7 +576,7 @@ impl<'a> AsRef<OsStr> for Component<'a> {\n     }\n }\n \n-#[stable(feature = \"path_component_asref\", since = \"1.24.0\")]\n+#[stable(feature = \"path_component_asref\", since = \"1.25.0\")]\n impl<'a> AsRef<Path> for Component<'a> {\n     fn as_ref(&self) -> &Path {\n         self.as_os_str().as_ref()"}, {"sha": "ff6f32fc3be0bb7808319ccc756159e1abcfee69", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1670a532dd769763f1d6ad9e5d624ec31361a098/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1670a532dd769763f1d6ad9e5d624ec31361a098/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=1670a532dd769763f1d6ad9e5d624ec31361a098", "patch": "@@ -690,14 +690,16 @@ impl CodeMap {\n             return 1;\n         }\n \n+        let src = local_begin.fm.external_src.borrow();\n+\n         // We need to extend the snippet to the end of the src rather than to end_index so when\n         // searching forwards for boundaries we've got somewhere to search.\n         let snippet = if let Some(ref src) = local_begin.fm.src {\n             let len = src.len();\n-            (&src[start_index..len]).to_string()\n-        } else if let Some(src) = local_begin.fm.external_src.borrow().get_source() {\n+            (&src[start_index..len])\n+        } else if let Some(src) = src.get_source() {\n             let len = src.len();\n-            (&src[start_index..len]).to_string()\n+            (&src[start_index..len])\n         } else {\n             return 1;\n         };"}, {"sha": "3b137f9570a390f138b9e9540acc19bd34ba13e5", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1670a532dd769763f1d6ad9e5d624ec31361a098/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1670a532dd769763f1d6ad9e5d624ec31361a098/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=1670a532dd769763f1d6ad9e5d624ec31361a098", "patch": "@@ -541,7 +541,7 @@ declare_features! (\n     // instead of just the platforms on which it is the C ABI\n     (accepted, abi_sysv64, \"1.24.0\", Some(36167)),\n     // Allows `repr(align(16))` struct attribute (RFC 1358)\n-    (accepted, repr_align, \"1.24.0\", Some(33626)),\n+    (accepted, repr_align, \"1.25.0\", Some(33626)),\n     // allow '|' at beginning of match arms (RFC 1925)\n     (accepted, match_beginning_vert, \"1.25.0\", Some(44101)),\n     // Nested groups in `use` (RFC 2128)"}, {"sha": "ac582627f88fdb34f6022c557180cbb169c1b9ba", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/1670a532dd769763f1d6ad9e5d624ec31361a098/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1670a532dd769763f1d6ad9e5d624ec31361a098/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=1670a532dd769763f1d6ad9e5d624ec31361a098", "patch": "@@ -4859,19 +4859,30 @@ impl<'a> Parser<'a> {\n                 |p| {\n                     if p.token == token::DotDotDot {\n                         p.bump();\n+                        variadic = true;\n                         if allow_variadic {\n                             if p.token != token::CloseDelim(token::Paren) {\n                                 let span = p.span;\n                                 p.span_err(span,\n                                     \"`...` must be last in argument list for variadic function\");\n                             }\n+                            Ok(None)\n                         } else {\n-                            let span = p.span;\n-                            p.span_err(span,\n-                                       \"only foreign functions are allowed to be variadic\");\n+                            let span = p.prev_span;\n+                            if p.token == token::CloseDelim(token::Paren) {\n+                                // continue parsing to present any further errors\n+                                p.struct_span_err(\n+                                    span,\n+                                    \"only foreign functions are allowed to be variadic\"\n+                                ).emit();\n+                                Ok(Some(dummy_arg(span)))\n+                           } else {\n+                               // this function definition looks beyond recovery, stop parsing\n+                                p.span_err(span,\n+                                           \"only foreign functions are allowed to be variadic\");\n+                                Ok(None)\n+                            }\n                         }\n-                        variadic = true;\n-                        Ok(None)\n                     } else {\n                         match p.parse_arg_general(named_args) {\n                             Ok(arg) => Ok(Some(arg)),"}, {"sha": "534e4b910902e89ce567eb364a3bf4b5e2b3600f", "filename": "src/rustllvm/Linker.cpp", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/1670a532dd769763f1d6ad9e5d624ec31361a098/src%2Frustllvm%2FLinker.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/1670a532dd769763f1d6ad9e5d624ec31361a098/src%2Frustllvm%2FLinker.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FLinker.cpp?ref=1670a532dd769763f1d6ad9e5d624ec31361a098", "patch": "@@ -0,0 +1,72 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#include \"llvm/Linker/Linker.h\"\n+\n+#include \"rustllvm.h\"\n+\n+using namespace llvm;\n+\n+struct RustLinker {\n+  Linker L;\n+  LLVMContext &Ctx;\n+\n+  RustLinker(Module &M) :\n+    L(M),\n+    Ctx(M.getContext())\n+  {}\n+};\n+\n+extern \"C\" RustLinker*\n+LLVMRustLinkerNew(LLVMModuleRef DstRef) {\n+  Module *Dst = unwrap(DstRef);\n+\n+  auto Ret = llvm::make_unique<RustLinker>(*Dst);\n+  return Ret.release();\n+}\n+\n+extern \"C\" void\n+LLVMRustLinkerFree(RustLinker *L) {\n+  delete L;\n+}\n+\n+extern \"C\" bool\n+LLVMRustLinkerAdd(RustLinker *L, char *BC, size_t Len) {\n+  std::unique_ptr<MemoryBuffer> Buf =\n+      MemoryBuffer::getMemBufferCopy(StringRef(BC, Len));\n+\n+#if LLVM_VERSION_GE(4, 0)\n+  Expected<std::unique_ptr<Module>> SrcOrError =\n+      llvm::getLazyBitcodeModule(Buf->getMemBufferRef(), L->Ctx);\n+  if (!SrcOrError) {\n+    LLVMRustSetLastError(toString(SrcOrError.takeError()).c_str());\n+    return false;\n+  }\n+\n+  auto Src = std::move(*SrcOrError);\n+#else\n+  ErrorOr<std::unique_ptr<Module>> Src =\n+      llvm::getLazyBitcodeModule(std::move(Buf), L->Ctx);\n+  if (!Src) {\n+    LLVMRustSetLastError(Src.getError().message().c_str());\n+    return false;\n+  }\n+#endif\n+\n+#if LLVM_VERSION_GE(4, 0)\n+  if (L->L.linkInModule(std::move(Src))) {\n+#else\n+  if (L->L.linkInModule(std::move(Src.get()))) {\n+#endif\n+    LLVMRustSetLastError(\"\");\n+    return false;\n+  }\n+  return true;\n+}"}, {"sha": "27d5496f57628c4c7d6c05c41a6fee03f12357c3", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/1670a532dd769763f1d6ad9e5d624ec31361a098/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/1670a532dd769763f1d6ad9e5d624ec31361a098/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=1670a532dd769763f1d6ad9e5d624ec31361a098", "patch": "@@ -916,46 +916,6 @@ extern \"C\" void LLVMRustWriteValueToString(LLVMValueRef V,\n   }\n }\n \n-extern \"C\" bool LLVMRustLinkInExternalBitcode(LLVMModuleRef DstRef, char *BC,\n-                                              size_t Len) {\n-  Module *Dst = unwrap(DstRef);\n-\n-  std::unique_ptr<MemoryBuffer> Buf =\n-      MemoryBuffer::getMemBufferCopy(StringRef(BC, Len));\n-\n-#if LLVM_VERSION_GE(4, 0)\n-  Expected<std::unique_ptr<Module>> SrcOrError =\n-      llvm::getLazyBitcodeModule(Buf->getMemBufferRef(), Dst->getContext());\n-  if (!SrcOrError) {\n-    LLVMRustSetLastError(toString(SrcOrError.takeError()).c_str());\n-    return false;\n-  }\n-\n-  auto Src = std::move(*SrcOrError);\n-#else\n-  ErrorOr<std::unique_ptr<Module>> Src =\n-      llvm::getLazyBitcodeModule(std::move(Buf), Dst->getContext());\n-  if (!Src) {\n-    LLVMRustSetLastError(Src.getError().message().c_str());\n-    return false;\n-  }\n-#endif\n-\n-  std::string Err;\n-\n-  raw_string_ostream Stream(Err);\n-  DiagnosticPrinterRawOStream DP(Stream);\n-#if LLVM_VERSION_GE(4, 0)\n-  if (Linker::linkModules(*Dst, std::move(Src))) {\n-#else\n-  if (Linker::linkModules(*Dst, std::move(Src.get()))) {\n-#endif\n-    LLVMRustSetLastError(Err.c_str());\n-    return false;\n-  }\n-  return true;\n-}\n-\n // Note that the two following functions look quite similar to the\n // LLVMGetSectionName function. Sadly, it appears that this function only\n // returns a char* pointer, which isn't guaranteed to be null-terminated. The"}, {"sha": "cd8ade5e51a1b748597ea000d83d6c17719e1a49", "filename": "src/test/ui/cast_char.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1670a532dd769763f1d6ad9e5d624ec31361a098/src%2Ftest%2Fui%2Fcast_char.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1670a532dd769763f1d6ad9e5d624ec31361a098/src%2Ftest%2Fui%2Fcast_char.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcast_char.rs?ref=1670a532dd769763f1d6ad9e5d624ec31361a098", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![deny(overflowing_literals)]\n+\n+fn main() {\n+    const XYZ: char = 0x1F888 as char;\n+    //~^ ERROR only u8 can be casted into char\n+    const XY: char = 129160 as char;\n+    //~^ ERROR only u8 can be casted into char\n+    const ZYX: char = '\\u{01F888}';\n+    println!(\"{}\", XYZ);\n+}"}, {"sha": "e42a38dace9d21aa48af4d79c02c324e35ba1e3a", "filename": "src/test/ui/cast_char.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1670a532dd769763f1d6ad9e5d624ec31361a098/src%2Ftest%2Fui%2Fcast_char.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1670a532dd769763f1d6ad9e5d624ec31361a098/src%2Ftest%2Fui%2Fcast_char.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcast_char.stderr?ref=1670a532dd769763f1d6ad9e5d624ec31361a098", "patch": "@@ -0,0 +1,20 @@\n+error: only u8 can be casted into char\n+  --> $DIR/cast_char.rs:14:23\n+   |\n+14 |     const XYZ: char = 0x1F888 as char;\n+   |                       ^^^^^^^^^^^^^^^ help: use a char literal instead: `'/u{1F888}'`\n+   |\n+note: lint level defined here\n+  --> $DIR/cast_char.rs:11:9\n+   |\n+11 | #![deny(overflowing_literals)]\n+   |         ^^^^^^^^^^^^^^^^^^^^\n+\n+error: only u8 can be casted into char\n+  --> $DIR/cast_char.rs:16:22\n+   |\n+16 |     const XY: char = 129160 as char;\n+   |                      ^^^^^^^^^^^^^^ help: use a char literal instead: `'/u{1F888}'`\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "3d421e00b08e44163d11adb8770f0db58f129cde", "filename": "src/test/ui/invalid-variadic-function.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1670a532dd769763f1d6ad9e5d624ec31361a098/src%2Ftest%2Fui%2Finvalid-variadic-function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1670a532dd769763f1d6ad9e5d624ec31361a098/src%2Ftest%2Fui%2Finvalid-variadic-function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finvalid-variadic-function.rs?ref=1670a532dd769763f1d6ad9e5d624ec31361a098", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+extern \"C\" fn foo(x: u8, ...);\n+//~^ ERROR only foreign functions are allowed to be variadic\n+//~| ERROR expected one of `->`, `where`, or `{`, found `;`"}, {"sha": "15a908b3f00f22f12b6f97f14661d00b663da95d", "filename": "src/test/ui/invalid-variadic-function.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1670a532dd769763f1d6ad9e5d624ec31361a098/src%2Ftest%2Fui%2Finvalid-variadic-function.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1670a532dd769763f1d6ad9e5d624ec31361a098/src%2Ftest%2Fui%2Finvalid-variadic-function.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finvalid-variadic-function.stderr?ref=1670a532dd769763f1d6ad9e5d624ec31361a098", "patch": "@@ -0,0 +1,14 @@\n+error: only foreign functions are allowed to be variadic\n+  --> $DIR/invalid-variadic-function.rs:11:26\n+   |\n+11 | extern \"C\" fn foo(x: u8, ...);\n+   |                          ^^^\n+\n+error: expected one of `->`, `where`, or `{`, found `;`\n+  --> $DIR/invalid-variadic-function.rs:11:30\n+   |\n+11 | extern \"C\" fn foo(x: u8, ...);\n+   |                              ^ expected one of `->`, `where`, or `{` here\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "486c0d81e3f407d0c3424cd049f3ea21df3e025a", "filename": "src/tools/compiletest/src/read2.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/1670a532dd769763f1d6ad9e5d624ec31361a098/src%2Ftools%2Fcompiletest%2Fsrc%2Fread2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1670a532dd769763f1d6ad9e5d624ec31361a098/src%2Ftools%2Fcompiletest%2Fsrc%2Fread2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fread2.rs?ref=1670a532dd769763f1d6ad9e5d624ec31361a098", "patch": "@@ -58,9 +58,12 @@ mod imp {\n         fds[0].events = libc::POLLIN;\n         fds[1].fd = err_pipe.as_raw_fd();\n         fds[1].events = libc::POLLIN;\n-        loop {\n+        let mut nfds = 2;\n+        let mut errfd = 1;\n+\n+        while nfds > 0 {\n             // wait for either pipe to become readable using `select`\n-            let r = unsafe { libc::poll(fds.as_mut_ptr(), 2, -1) };\n+            let r = unsafe { libc::poll(fds.as_mut_ptr(), nfds, -1) };\n             if r == -1 {\n                 let err = io::Error::last_os_error();\n                 if err.kind() == io::ErrorKind::Interrupted {\n@@ -86,19 +89,20 @@ mod imp {\n                     }\n                 }\n             };\n-            if !out_done && fds[0].revents != 0 && handle(out_pipe.read_to_end(&mut out))? {\n-                out_done = true;\n-            }\n-            data(true, &mut out, out_done);\n-            if !err_done && fds[1].revents != 0 && handle(err_pipe.read_to_end(&mut err))? {\n+            if !err_done && fds[errfd].revents != 0 && handle(err_pipe.read_to_end(&mut err))? {\n                 err_done = true;\n+                nfds -= 1;\n             }\n             data(false, &mut err, err_done);\n-\n-            if out_done && err_done {\n-                return Ok(())\n+            if !out_done && fds[0].revents != 0 && handle(out_pipe.read_to_end(&mut out))? {\n+                out_done = true;\n+                fds[0].fd = err_pipe.as_raw_fd();\n+                errfd = 0;\n+                nfds -= 1;\n             }\n+            data(true, &mut out, out_done);\n         }\n+        Ok(())\n     }\n }\n "}]}