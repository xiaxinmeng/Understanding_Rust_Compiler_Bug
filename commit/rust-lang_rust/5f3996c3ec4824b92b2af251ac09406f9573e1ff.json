{"sha": "5f3996c3ec4824b92b2af251ac09406f9573e1ff", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVmMzk5NmMzZWM0ODI0YjkyYjJhZjI1MWFjMDk0MDZmOTU3M2UxZmY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-03-16T08:22:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-03-16T08:22:11Z"}, "message": "Auto merge of #48813 - sinkuu:build_in_assert_macro, r=alexcrichton\n\nMake `assert` a built-in procedural macro\n\nMakes `assert` macro a built-in one without touching its functionality. This is a prerequisite for RFC 2011 (#44838).", "tree": {"sha": "c74124eca698a97097e3fba8a4b26a2cd28587b0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c74124eca698a97097e3fba8a4b26a2cd28587b0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5f3996c3ec4824b92b2af251ac09406f9573e1ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5f3996c3ec4824b92b2af251ac09406f9573e1ff", "html_url": "https://github.com/rust-lang/rust/commit/5f3996c3ec4824b92b2af251ac09406f9573e1ff", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5f3996c3ec4824b92b2af251ac09406f9573e1ff/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a7170b0412d1baa4e30cb31d1ea326617021f086", "url": "https://api.github.com/repos/rust-lang/rust/commits/a7170b0412d1baa4e30cb31d1ea326617021f086", "html_url": "https://github.com/rust-lang/rust/commit/a7170b0412d1baa4e30cb31d1ea326617021f086"}, {"sha": "4a254c00506abdbb660e9c71d34b5b836b86da8d", "url": "https://api.github.com/repos/rust-lang/rust/commits/4a254c00506abdbb660e9c71d34b5b836b86da8d", "html_url": "https://github.com/rust-lang/rust/commit/4a254c00506abdbb660e9c71d34b5b836b86da8d"}], "stats": {"total": 213, "additions": 210, "deletions": 3}, "files": [{"sha": "8a87bea71e2530cf9562698aa6650955a854cc33", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5f3996c3ec4824b92b2af251ac09406f9573e1ff/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f3996c3ec4824b92b2af251ac09406f9573e1ff/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=5f3996c3ec4824b92b2af251ac09406f9573e1ff", "patch": "@@ -76,6 +76,7 @@ macro_rules! panic {\n /// ```\n #[macro_export]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[cfg(stage0)]\n macro_rules! assert {\n     ($cond:expr) => (\n         if !$cond {\n@@ -784,4 +785,18 @@ mod builtin {\n         ($file:expr) => ({ /* compiler built-in */ });\n         ($file:expr,) => ({ /* compiler built-in */ });\n     }\n+\n+    /// Ensure that a boolean expression is `true` at runtime.\n+    ///\n+    /// For more information, see the documentation for [`std::assert!`].\n+    ///\n+    /// [`std::assert!`]: ../std/macro.assert.html\n+    #[macro_export]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[cfg(dox)]\n+    macro_rules! assert {\n+        ($cond:expr) => ({ /* compiler built-in */ });\n+        ($cond:expr,) => ({ /* compiler built-in */ });\n+        ($cond:expr, $($arg:tt)+) => ({ /* compiler built-in */ });\n+    }\n }"}, {"sha": "70a1f82c9a159be64737616e48735449558841b1", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5f3996c3ec4824b92b2af251ac09406f9573e1ff/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f3996c3ec4824b92b2af251ac09406f9573e1ff/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=5f3996c3ec4824b92b2af251ac09406f9573e1ff", "patch": "@@ -355,8 +355,9 @@ use prelude::v1::*;\n // We want to re-export a few macros from core but libcore has already been\n // imported by the compiler (via our #[no_std] attribute) In this case we just\n // add a new crate name so we can attach the re-exports to it.\n-#[macro_reexport(assert, assert_eq, assert_ne, debug_assert, debug_assert_eq,\n+#[macro_reexport(assert_eq, assert_ne, debug_assert, debug_assert_eq,\n                  debug_assert_ne, unreachable, unimplemented, write, writeln, try)]\n+#[cfg_attr(stage0, macro_reexport(assert))]\n extern crate core as __core;\n \n #[macro_use]"}, {"sha": "000f9713615300f5871cfd45a35c354c7fd85c40", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/5f3996c3ec4824b92b2af251ac09406f9573e1ff/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f3996c3ec4824b92b2af251ac09406f9573e1ff/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=5f3996c3ec4824b92b2af251ac09406f9573e1ff", "patch": "@@ -719,6 +719,60 @@ pub mod builtin {\n         ($file:expr) => ({ /* compiler built-in */ });\n         ($file:expr,) => ({ /* compiler built-in */ });\n     }\n+\n+    /// Ensure that a boolean expression is `true` at runtime.\n+    ///\n+    /// This will invoke the [`panic!`] macro if the provided expression cannot be\n+    /// evaluated to `true` at runtime.\n+    ///\n+    /// # Uses\n+    ///\n+    /// Assertions are always checked in both debug and release builds, and cannot\n+    /// be disabled. See [`debug_assert!`] for assertions that are not enabled in\n+    /// release builds by default.\n+    ///\n+    /// Unsafe code relies on `assert!` to enforce run-time invariants that, if\n+    /// violated could lead to unsafety.\n+    ///\n+    /// Other use-cases of `assert!` include [testing] and enforcing run-time\n+    /// invariants in safe code (whose violation cannot result in unsafety).\n+    ///\n+    /// # Custom Messages\n+    ///\n+    /// This macro has a second form, where a custom panic message can\n+    /// be provided with or without arguments for formatting.  See [`std::fmt`]\n+    /// for syntax for this form.\n+    ///\n+    /// [`panic!`]: macro.panic.html\n+    /// [`debug_assert!`]: macro.debug_assert.html\n+    /// [testing]: ../book/second-edition/ch11-01-writing-tests.html#checking-results-with-the-assert-macro\n+    /// [`std::fmt`]: ../std/fmt/index.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// // the panic message for these assertions is the stringified value of the\n+    /// // expression given.\n+    /// assert!(true);\n+    ///\n+    /// fn some_computation() -> bool { true } // a very simple function\n+    ///\n+    /// assert!(some_computation());\n+    ///\n+    /// // assert with a custom message\n+    /// let x = true;\n+    /// assert!(x, \"x wasn't true!\");\n+    ///\n+    /// let a = 3; let b = 27;\n+    /// assert!(a + b == 30, \"a = {}, b = {}\", a, b);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[macro_export]\n+    macro_rules! assert {\n+        ($cond:expr) => ({ /* compiler built-in */ });\n+        ($cond:expr,) => ({ /* compiler built-in */ });\n+        ($cond:expr, $($arg:tt)+) => ({ /* compiler built-in */ });\n+    }\n }\n \n /// A macro for defining #[cfg] if-else statements."}, {"sha": "8b29e6adeb9eb9ba2231e7175e2dc56a042d9df0", "filename": "src/libsyntax_ext/assert.rs", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/5f3996c3ec4824b92b2af251ac09406f9573e1ff/src%2Flibsyntax_ext%2Fassert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f3996c3ec4824b92b2af251ac09406f9573e1ff/src%2Flibsyntax_ext%2Fassert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fassert.rs?ref=5f3996c3ec4824b92b2af251ac09406f9573e1ff", "patch": "@@ -0,0 +1,122 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use syntax::ast::*;\n+use syntax::codemap::Spanned;\n+use syntax::ext::base::*;\n+use syntax::ext::build::AstBuilder;\n+use syntax::parse::token;\n+use syntax::print::pprust;\n+use syntax::tokenstream::{TokenStream, TokenTree};\n+use syntax_pos::{Span, DUMMY_SP};\n+\n+pub fn expand_assert<'cx>(\n+    cx: &'cx mut ExtCtxt,\n+    sp: Span,\n+    tts: &[TokenTree],\n+) -> Box<MacResult + 'cx> {\n+    let mut parser = cx.new_parser_from_tts(tts);\n+    let cond_expr = panictry!(parser.parse_expr());\n+    let custom_msg_args = if parser.eat(&token::Comma) {\n+        let ts = parser.parse_tokens();\n+        if !ts.is_empty() {\n+            Some(ts)\n+        } else {\n+            None\n+        }\n+    } else {\n+        None\n+    };\n+\n+    let sp = sp.with_ctxt(sp.ctxt().apply_mark(cx.current_expansion.mark));\n+    let panic_call = Mac_ {\n+        path: Path::from_ident(sp, Ident::from_str(\"panic\")),\n+        tts: if let Some(ts) = custom_msg_args {\n+            ts.into()\n+        } else {\n+            // `expr_to_string` escapes the string literals with `.escape_default()`\n+            // which escapes all non-ASCII characters with `\\u`.\n+            let escaped_expr = escape_format_string(&unescape_printable_unicode(\n+                &pprust::expr_to_string(&cond_expr),\n+            ));\n+\n+            TokenStream::from(TokenTree::Token(\n+                DUMMY_SP,\n+                token::Literal(\n+                    token::Lit::Str_(Name::intern(&format!(\"assertion failed: {}\", escaped_expr))),\n+                    None,\n+                ),\n+            )).into()\n+        },\n+    };\n+    let if_expr = cx.expr_if(\n+        sp,\n+        cx.expr(sp, ExprKind::Unary(UnOp::Not, cond_expr)),\n+        cx.expr(\n+            sp,\n+            ExprKind::Mac(Spanned {\n+                span: sp,\n+                node: panic_call,\n+            }),\n+        ),\n+        None,\n+    );\n+    MacEager::expr(if_expr)\n+}\n+\n+/// Escapes a string for use as a formatting string.\n+fn escape_format_string(s: &str) -> String {\n+    let mut res = String::with_capacity(s.len());\n+    for c in s.chars() {\n+        res.extend(c.escape_debug());\n+        match c {\n+            '{' | '}' => res.push(c),\n+            _ => {}\n+        }\n+    }\n+    res\n+}\n+\n+#[test]\n+fn test_escape_format_string() {\n+    assert!(escape_format_string(r\"foo{}\\\") == r\"foo{{}}\\\\\");\n+}\n+\n+/// Unescapes the escaped unicodes (`\\u{...}`) that are printable.\n+fn unescape_printable_unicode(mut s: &str) -> String {\n+    use std::{char, u32};\n+\n+    let mut res = String::with_capacity(s.len());\n+\n+    loop {\n+        if let Some(start) = s.find(r\"\\u{\") {\n+            res.push_str(&s[0..start]);\n+            s = &s[start..];\n+            s.find('}')\n+                .and_then(|end| {\n+                    let v = u32::from_str_radix(&s[3..end], 16).ok()?;\n+                    let c = char::from_u32(v)?;\n+                    // Escape unprintable characters.\n+                    res.extend(c.escape_debug());\n+                    s = &s[end + 1..];\n+                    Some(())\n+                })\n+                .expect(\"lexer should have rejected invalid escape sequences\");\n+        } else {\n+            res.push_str(s);\n+            return res;\n+        }\n+    }\n+}\n+\n+#[test]\n+fn test_unescape_printable_unicode() {\n+    assert!(unescape_printable_unicode(r\"\\u{2603}\\n\\u{0}\") == r\"\u2603\\n\\u{0}\");\n+}"}, {"sha": "249a64b353f5912f981425e92c1b94b7c3f7e928", "filename": "src/libsyntax_ext/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5f3996c3ec4824b92b2af251ac09406f9573e1ff/src%2Flibsyntax_ext%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f3996c3ec4824b92b2af251ac09406f9573e1ff/src%2Flibsyntax_ext%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Flib.rs?ref=5f3996c3ec4824b92b2af251ac09406f9573e1ff", "patch": "@@ -17,6 +17,7 @@\n \n #![feature(proc_macro_internals)]\n #![feature(decl_macro)]\n+#![feature(str_escape)]\n \n extern crate fmt_macros;\n #[macro_use]\n@@ -26,6 +27,7 @@ extern crate proc_macro;\n extern crate rustc_data_structures;\n extern crate rustc_errors as errors;\n \n+mod assert;\n mod asm;\n mod cfg;\n mod compile_error;\n@@ -112,6 +114,7 @@ pub fn register_builtins(resolver: &mut syntax::ext::base::Resolver,\n         log_syntax: log_syntax::expand_syntax_ext,\n         trace_macros: trace_macros::expand_trace_macros,\n         compile_error: compile_error::expand_compile_error,\n+        assert: assert::expand_assert,\n     }\n \n     // format_args uses `unstable` things internally."}, {"sha": "d340806c3577dc0d0d26f8b654efeb4b8844807f", "filename": "src/test/run-pass/assert-escape.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5f3996c3ec4824b92b2af251ac09406f9573e1ff/src%2Ftest%2Frun-pass%2Fassert-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f3996c3ec4824b92b2af251ac09406f9573e1ff/src%2Ftest%2Frun-pass%2Fassert-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassert-escape.rs?ref=5f3996c3ec4824b92b2af251ac09406f9573e1ff", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    assert!(r#\"\u2603\\backslash\"#.contains(\"\\\\\"));\n+}"}, {"sha": "c71c28ed62520d23d1b80e2affdff5fc02d55d22", "filename": "src/test/ui/codemap_tests/issue-28308.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5f3996c3ec4824b92b2af251ac09406f9573e1ff/src%2Ftest%2Fui%2Fcodemap_tests%2Fissue-28308.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f3996c3ec4824b92b2af251ac09406f9573e1ff/src%2Ftest%2Fui%2Fcodemap_tests%2Fissue-28308.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Fissue-28308.rs?ref=5f3996c3ec4824b92b2af251ac09406f9573e1ff", "patch": "@@ -10,4 +10,5 @@\n \n fn main() {\n     assert!(\"foo\");\n+    //~^ ERROR cannot apply unary operator `!`\n }"}, {"sha": "2c8a33d95c03a23e57839323ea4f1d5feb7afb90", "filename": "src/test/ui/codemap_tests/issue-28308.stderr", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f3996c3ec4824b92b2af251ac09406f9573e1ff/src%2Ftest%2Fui%2Fcodemap_tests%2Fissue-28308.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5f3996c3ec4824b92b2af251ac09406f9573e1ff/src%2Ftest%2Fui%2Fcodemap_tests%2Fissue-28308.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Fissue-28308.stderr?ref=5f3996c3ec4824b92b2af251ac09406f9573e1ff", "patch": "@@ -3,8 +3,6 @@ error[E0600]: cannot apply unary operator `!` to type `&'static str`\n    |\n LL |     assert!(\"foo\");\n    |     ^^^^^^^^^^^^^^^\n-   |\n-   = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n \n error: aborting due to previous error\n "}]}