{"sha": "aee42f70f3e5d5b670bcc8c0e482601e19cda547", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFlZTQyZjcwZjNlNWQ1YjY3MGJjYzhjMGU0ODI2MDFlMTljZGE1NDc=", "commit": {"author": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2015-10-27T17:33:58Z"}, "committer": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2015-10-27T17:33:58Z"}, "message": "Merge pull request #396 from fhartwig/while-let-for\n\nSuggest for loop instead of while-let when looping over iterators", "tree": {"sha": "3533258ad40bbf5046277f237c869d5fe6a88d6c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3533258ad40bbf5046277f237c869d5fe6a88d6c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aee42f70f3e5d5b670bcc8c0e482601e19cda547", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aee42f70f3e5d5b670bcc8c0e482601e19cda547", "html_url": "https://github.com/rust-lang/rust/commit/aee42f70f3e5d5b670bcc8c0e482601e19cda547", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aee42f70f3e5d5b670bcc8c0e482601e19cda547/comments", "author": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "committer": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3fe6ca9def2d9bf1107a2072455c0ab10ce18739", "url": "https://api.github.com/repos/rust-lang/rust/commits/3fe6ca9def2d9bf1107a2072455c0ab10ce18739", "html_url": "https://github.com/rust-lang/rust/commit/3fe6ca9def2d9bf1107a2072455c0ab10ce18739"}, {"sha": "c5b6fda399644147c9a002109a4be1ac9508e9ec", "url": "https://api.github.com/repos/rust-lang/rust/commits/c5b6fda399644147c9a002109a4be1ac9508e9ec", "html_url": "https://github.com/rust-lang/rust/commit/c5b6fda399644147c9a002109a4be1ac9508e9ec"}], "stats": {"total": 134, "additions": 130, "deletions": 4}, "files": [{"sha": "c602edca7df065dc39d65aeabf85419796bdfbca", "filename": "README.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/aee42f70f3e5d5b670bcc8c0e482601e19cda547/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/aee42f70f3e5d5b670bcc8c0e482601e19cda547/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=aee42f70f3e5d5b670bcc8c0e482601e19cda547", "patch": "@@ -6,7 +6,7 @@ A collection of lints to catch common mistakes and improve your Rust code.\n [Jump to usage instructions](#usage)\n \n ##Lints\n-There are 68 lints included in this crate:\n+There are 69 lints included in this crate:\n \n name                                                                                                   | default | meaning\n -------------------------------------------------------------------------------------------------------|---------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n@@ -74,6 +74,7 @@ name\n [unstable_as_slice](https://github.com/Manishearth/rust-clippy/wiki#unstable_as_slice)                 | warn    | as_slice is not stable and can be replaced by & v[..]see https://github.com/rust-lang/rust/issues/27729\n [unused_collect](https://github.com/Manishearth/rust-clippy/wiki#unused_collect)                       | warn    | `collect()`ing an iterator without using the result; this is usually better written as a for loop\n [while_let_loop](https://github.com/Manishearth/rust-clippy/wiki#while_let_loop)                       | warn    | `loop { if let { ... } else break }` can be written as a `while let` loop\n+[while_let_on_iterator](https://github.com/Manishearth/rust-clippy/wiki#while_let_on_iterator)         | warn    | using a while-let loop instead of a for loop on an iterator\n [wrong_pub_self_convention](https://github.com/Manishearth/rust-clippy/wiki#wrong_pub_self_convention) | allow   | defining a public method named with an established prefix (like \"into_\") that takes `self` with the wrong convention\n [wrong_self_convention](https://github.com/Manishearth/rust-clippy/wiki#wrong_self_convention)         | warn    | defining a method named with an established prefix (like \"into_\") that takes `self` with the wrong convention\n [zero_divided_by_zero](https://github.com/Manishearth/rust-clippy/wiki#zero_divided_by_zero)           | warn    | usage of `0.0 / 0.0` to obtain NaN instead of std::f32::NaN or std::f64::NaN"}, {"sha": "b84c1e2aab6b11bba6fb322e7ae1894b180f130a", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/aee42f70f3e5d5b670bcc8c0e482601e19cda547/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aee42f70f3e5d5b670bcc8c0e482601e19cda547/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=aee42f70f3e5d5b670bcc8c0e482601e19cda547", "patch": "@@ -138,6 +138,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n         loops::REVERSE_RANGE_LOOP,\n         loops::UNUSED_COLLECT,\n         loops::WHILE_LET_LOOP,\n+        loops::WHILE_LET_ON_ITERATOR,\n         matches::MATCH_BOOL,\n         matches::MATCH_REF_PATS,\n         matches::SINGLE_MATCH,"}, {"sha": "d056c67c541f36d14049529068ec70d87cdaad33", "filename": "src/loops.rs", "status": "modified", "additions": 68, "deletions": 2, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/aee42f70f3e5d5b670bcc8c0e482601e19cda547/src%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aee42f70f3e5d5b670bcc8c0e482601e19cda547/src%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Floops.rs?ref=aee42f70f3e5d5b670bcc8c0e482601e19cda547", "patch": "@@ -11,7 +11,8 @@ use std::collections::{HashSet,HashMap};\n use syntax::ast::Lit_::*;\n \n use utils::{snippet, span_lint, get_parent_expr, match_trait_method, match_type,\n-            in_external_macro, expr_block, span_help_and_lint, is_integer_literal};\n+            in_external_macro, expr_block, span_help_and_lint, is_integer_literal,\n+            get_enclosing_block};\n use utils::{VEC_PATH, LL_PATH};\n \n declare_lint!{ pub NEEDLESS_RANGE_LOOP, Warn,\n@@ -38,14 +39,17 @@ declare_lint!{ pub EXPLICIT_COUNTER_LOOP, Warn,\n \n declare_lint!{ pub EMPTY_LOOP, Warn, \"empty `loop {}` detected\" }\n \n+declare_lint!{ pub WHILE_LET_ON_ITERATOR, Warn, \"using a while-let loop instead of a for loop on an iterator\" }\n+\n #[derive(Copy, Clone)]\n pub struct LoopsPass;\n \n impl LintPass for LoopsPass {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(NEEDLESS_RANGE_LOOP, EXPLICIT_ITER_LOOP, ITER_NEXT_LOOP,\n                     WHILE_LET_LOOP, UNUSED_COLLECT, REVERSE_RANGE_LOOP,\n-                    EXPLICIT_COUNTER_LOOP, EMPTY_LOOP)\n+                    EXPLICIT_COUNTER_LOOP, EMPTY_LOOP,\n+                    WHILE_LET_ON_ITERATOR)\n     }\n }\n \n@@ -228,6 +232,28 @@ impl LateLintPass for LoopsPass {\n                 }\n             }\n         }\n+        if let ExprMatch(ref match_expr, ref arms, MatchSource::WhileLetDesugar) = expr.node {\n+            let pat = &arms[0].pats[0].node;\n+            if let (&PatEnum(ref path, Some(ref pat_args)),\n+                    &ExprMethodCall(method_name, _, ref method_args)) =\n+                        (pat, &match_expr.node) {\n+                let iter_expr = &method_args[0];\n+                if let Some(lhs_constructor) = path.segments.last() {\n+                    if method_name.node.as_str() == \"next\" &&\n+                            match_trait_method(cx, match_expr, &[\"core\", \"iter\", \"Iterator\"]) &&\n+                            lhs_constructor.identifier.name.as_str() == \"Some\" &&\n+                            !is_iterator_used_after_while_let(cx, iter_expr) {\n+                        let iterator = snippet(cx, method_args[0].span, \"_\");\n+                        let loop_var = snippet(cx, pat_args[0].span, \"_\");\n+                        span_help_and_lint(cx, WHILE_LET_ON_ITERATOR, expr.span,\n+                                           \"this loop could be written as a `for` loop\",\n+                                           &format!(\"try\\nfor {} in {} {{...}}\",\n+                                                    loop_var,\n+                                                    iterator));\n+                    }\n+                }\n+            }\n+        }\n     }\n \n     fn check_stmt(&mut self, cx: &LateContext, stmt: &Stmt) {\n@@ -300,6 +326,46 @@ impl<'v, 't> Visitor<'v> for VarVisitor<'v, 't> {\n     }\n }\n \n+fn is_iterator_used_after_while_let(cx: &LateContext, iter_expr: &Expr) -> bool {\n+    let def_id = match var_def_id(cx, iter_expr) {\n+        Some(id) => id,\n+        None => return false\n+    };\n+    let mut visitor = VarUsedAfterLoopVisitor {\n+        cx: cx,\n+        def_id: def_id,\n+        iter_expr_id: iter_expr.id,\n+        past_while_let: false,\n+        var_used_after_while_let: false\n+    };\n+    if let Some(enclosing_block) = get_enclosing_block(cx, def_id) {\n+        walk_block(&mut visitor, enclosing_block);\n+    }\n+    visitor.var_used_after_while_let\n+}\n+\n+struct VarUsedAfterLoopVisitor<'v, 't: 'v> {\n+    cx: &'v LateContext<'v, 't>,\n+    def_id: NodeId,\n+    iter_expr_id: NodeId,\n+    past_while_let: bool,\n+    var_used_after_while_let: bool\n+}\n+\n+impl <'v, 't> Visitor<'v> for VarUsedAfterLoopVisitor<'v, 't> {\n+    fn visit_expr(&mut self, expr: &'v Expr) {\n+        if self.past_while_let {\n+            if Some(self.def_id) == var_def_id(self.cx, expr) {\n+                self.var_used_after_while_let = true;\n+            }\n+        } else if self.iter_expr_id == expr.id {\n+            self.past_while_let = true;\n+        }\n+        walk_expr(self, expr);\n+    }\n+}\n+\n+\n /// Return true if the type of expr is one that provides IntoIterator impls\n /// for &T and &mut T, such as Vec.\n fn is_ref_iterable_type(cx: &LateContext, e: &Expr) -> bool {"}, {"sha": "7cbb532cf22edea666d22cb64cabe6a0eab36256", "filename": "src/utils.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/aee42f70f3e5d5b670bcc8c0e482601e19cda547/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aee42f70f3e5d5b670bcc8c0e482601e19cda547/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=aee42f70f3e5d5b670bcc8c0e482601e19cda547", "patch": "@@ -255,6 +255,20 @@ pub fn get_parent_expr<'c>(cx: &'c LateContext, e: &Expr) -> Option<&'c Expr> {\n         if let NodeExpr(parent) = node { Some(parent) } else { None } )\n }\n \n+#[allow(needless_lifetimes)] // workaround for https://github.com/Manishearth/rust-clippy/issues/417\n+pub fn get_enclosing_block<'c>(cx: &'c LateContext, node: NodeId) -> Option<&'c Block> {\n+    let map = &cx.tcx.map;\n+    let enclosing_node = map.get_enclosing_scope(node)\n+                            .and_then(|enclosing_id| map.find(enclosing_id));\n+    if let Some(node) = enclosing_node {\n+        match node {\n+            NodeBlock(ref block) => Some(block),\n+            NodeItem(&Item{ node: ItemFn(_, _, _, _, _, ref block), .. }) => Some(block),\n+            _ => None\n+        }\n+    } else { None }\n+}\n+\n #[cfg(not(feature=\"structured_logging\"))]\n pub fn span_lint<T: LintContext>(cx: &T, lint: &'static Lint, sp: Span, msg: &str) {\n     cx.span_lint(lint, sp, msg);"}, {"sha": "7d1904ad446183023d8d7147e7053f5a121cea16", "filename": "tests/compile-fail/while_loop.rs", "status": "modified", "additions": 45, "deletions": 1, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/aee42f70f3e5d5b670bcc8c0e482601e19cda547/tests%2Fcompile-fail%2Fwhile_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aee42f70f3e5d5b670bcc8c0e482601e19cda547/tests%2Fcompile-fail%2Fwhile_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fwhile_loop.rs?ref=aee42f70f3e5d5b670bcc8c0e482601e19cda547", "patch": "@@ -1,7 +1,7 @@\n #![feature(plugin)]\n #![plugin(clippy)]\n \n-#![deny(while_let_loop, empty_loop)]\n+#![deny(while_let_loop, empty_loop, while_let_on_iterator)]\n #![allow(dead_code, unused)]\n \n fn main() {\n@@ -53,6 +53,50 @@ fn main() {\n     while let Some(x) = y { // no error, obviously\n         println!(\"{}\", x);\n     }\n+\n+    let mut iter = 1..20;\n+    while let Option::Some(x) = iter.next() { //~ERROR this loop could be written as a `for` loop\n+        println!(\"{}\", x);\n+    }\n+\n+    let mut iter = 1..20;\n+    while let Some(x) = iter.next() { //~ERROR this loop could be written as a `for` loop\n+        println!(\"{}\", x);\n+    }\n+\n+    let mut iter = 1..20;\n+    while let Some(_) = iter.next() {} //~ERROR this loop could be written as a `for` loop\n+\n+    let mut iter = 1..20;\n+    while let None = iter.next() {} // this is fine (if nonsensical)\n+\n+    let mut iter = 1..20;\n+    if let Some(x) = iter.next() { // also fine\n+        println!(\"{}\", x)\n+    }\n+\n+    // the following shouldn't warn because it can't be written with a for loop\n+    let mut iter = 1u32..20;\n+    while let Some(x) = iter.next() {\n+        println!(\"next: {:?}\", iter.next())\n+    }\n+\n+    // neither can this\n+    let mut iter = 1u32..20;\n+    while let Some(x) = iter.next() {\n+        println!(\"next: {:?}\", iter.next());\n+    }\n+\n+    // or this\n+    let mut iter = 1u32..20;\n+    while let Some(x) = iter.next() {break;}\n+    println!(\"Remaining iter {:?}\", iter);\n+\n+    // or this\n+    let mut iter = 1u32..20;\n+    while let Some(x) = iter.next() {\n+        iter = 1..20;\n+    }\n }\n \n // regression test (#360)"}]}