{"sha": "baba6687df3e83fdb15cc6ec239b4a1c75a30505", "node_id": "C_kwDOAAsO6NoAKGJhYmE2Njg3ZGYzZTgzZmRiMTVjYzZlYzIzOWI0YTFjNzVhMzA1MDU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-11-03T18:13:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-11-03T18:13:11Z"}, "message": "Auto merge of #90413 - tmiasko:addr-of-mutable, r=RalfJung,oli-obk\n\n`addr_of!` grants mutable access, maybe?\n\nThe exact set of permissions granted when forming a raw reference is\ncurrently undecided https://github.com/rust-lang/rust/issues/56604.\n\nTo avoid presupposing any particular outcome, adjust the const\nqualification to be compatible with decision where raw reference\nconstructed from `addr_of!` grants mutable access.\n\nAdditionally, to avoid keeping `MaybeMutBorrowedLocals` in sync with\nconst qualification, remove it. It's no longer used.\n\n`@rust-lang/wg-const-eval`", "tree": {"sha": "6cb8a6c777f99c2dffb8d002b169d27acdde1779", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6cb8a6c777f99c2dffb8d002b169d27acdde1779"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/baba6687df3e83fdb15cc6ec239b4a1c75a30505", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/baba6687df3e83fdb15cc6ec239b4a1c75a30505", "html_url": "https://github.com/rust-lang/rust/commit/baba6687df3e83fdb15cc6ec239b4a1c75a30505", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/baba6687df3e83fdb15cc6ec239b4a1c75a30505/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7734cb80782e65875994ee4709b7752623ea9ed2", "url": "https://api.github.com/repos/rust-lang/rust/commits/7734cb80782e65875994ee4709b7752623ea9ed2", "html_url": "https://github.com/rust-lang/rust/commit/7734cb80782e65875994ee4709b7752623ea9ed2"}, {"sha": "bc4931ed7e98084480b82ef236d6c5c713645ea5", "url": "https://api.github.com/repos/rust-lang/rust/commits/bc4931ed7e98084480b82ef236d6c5c713645ea5", "html_url": "https://github.com/rust-lang/rust/commit/bc4931ed7e98084480b82ef236d6c5c713645ea5"}], "stats": {"total": 306, "additions": 88, "deletions": 218}, "files": [{"sha": "fcce829eba4121a23c0f0336cd0023ec2310b6dd", "filename": "compiler/rustc_const_eval/src/transform/check_consts/resolver.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/baba6687df3e83fdb15cc6ec239b4a1c75a30505/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/baba6687df3e83fdb15cc6ec239b4a1c75a30505/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fresolver.rs?ref=baba6687df3e83fdb15cc6ec239b4a1c75a30505", "patch": "@@ -94,11 +94,10 @@ where\n         }\n     }\n \n-    fn address_of_allows_mutation(&self, mt: mir::Mutability, place: mir::Place<'tcx>) -> bool {\n-        match mt {\n-            mir::Mutability::Mut => true,\n-            mir::Mutability::Not => self.shared_borrow_allows_mutation(place),\n-        }\n+    fn address_of_allows_mutation(&self, _mt: mir::Mutability, _place: mir::Place<'tcx>) -> bool {\n+        // Exact set of permissions granted by AddressOf is undecided. Conservatively assume that\n+        // it might allow mutation until resolution of #56604.\n+        true\n     }\n \n     fn ref_allows_mutation(&self, kind: mir::BorrowKind, place: mir::Place<'tcx>) -> bool {\n@@ -110,6 +109,15 @@ where\n         }\n     }\n \n+    /// `&` only allow mutation if the borrowed place is `!Freeze`.\n+    ///\n+    /// This assumes that it is UB to take the address of a struct field whose type is\n+    /// `Freeze`, then use pointer arithmetic to derive a pointer to a *different* field of\n+    /// that same struct whose type is `!Freeze`. If we decide that this is not UB, we will\n+    /// have to check the type of the borrowed **local** instead of the borrowed **place**\n+    /// below. See [rust-lang/unsafe-code-guidelines#134].\n+    ///\n+    /// [rust-lang/unsafe-code-guidelines#134]: https://github.com/rust-lang/unsafe-code-guidelines/issues/134\n     fn shared_borrow_allows_mutation(&self, place: mir::Place<'tcx>) -> bool {\n         !place\n             .ty(self.ccx.body, self.ccx.tcx)"}, {"sha": "d38b567a95849be35d1995a6e2e8c3707dd2e1e4", "filename": "compiler/rustc_mir_dataflow/src/impls/borrowed_locals.rs", "status": "modified", "additions": 15, "deletions": 117, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/baba6687df3e83fdb15cc6ec239b4a1c75a30505/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fborrowed_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/baba6687df3e83fdb15cc6ec239b4a1c75a30505/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fborrowed_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fborrowed_locals.rs?ref=baba6687df3e83fdb15cc6ec239b4a1c75a30505", "patch": "@@ -3,55 +3,26 @@ use super::*;\n use crate::{AnalysisDomain, GenKill, GenKillAnalysis};\n use rustc_middle::mir::visit::Visitor;\n use rustc_middle::mir::*;\n-use rustc_middle::ty::{ParamEnv, TyCtxt};\n-use rustc_span::DUMMY_SP;\n-\n-pub type MaybeMutBorrowedLocals<'mir, 'tcx> = MaybeBorrowedLocals<MutBorrow<'mir, 'tcx>>;\n \n /// A dataflow analysis that tracks whether a pointer or reference could possibly exist that points\n /// to a given local.\n ///\n-/// The `K` parameter determines what kind of borrows are tracked. By default,\n-/// `MaybeBorrowedLocals` looks for *any* borrow of a local. If you are only interested in borrows\n-/// that might allow mutation, use the `MaybeMutBorrowedLocals` type alias instead.\n-///\n /// At present, this is used as a very limited form of alias analysis. For example,\n /// `MaybeBorrowedLocals` is used to compute which locals are live during a yield expression for\n-/// immovable generators. `MaybeMutBorrowedLocals` is used during const checking to prove that a\n-/// local has not been mutated via indirect assignment (e.g., `*p = 42`), the side-effects of a\n-/// function call or inline assembly.\n-pub struct MaybeBorrowedLocals<K = AnyBorrow> {\n-    kind: K,\n+/// immovable generators.\n+pub struct MaybeBorrowedLocals {\n     ignore_borrow_on_drop: bool,\n }\n \n impl MaybeBorrowedLocals {\n     /// A dataflow analysis that records whether a pointer or reference exists that may alias the\n     /// given local.\n     pub fn all_borrows() -> Self {\n-        MaybeBorrowedLocals { kind: AnyBorrow, ignore_borrow_on_drop: false }\n-    }\n-}\n-\n-impl MaybeMutBorrowedLocals<'mir, 'tcx> {\n-    /// A dataflow analysis that records whether a pointer or reference exists that may *mutably*\n-    /// alias the given local.\n-    ///\n-    /// This includes `&mut` and pointers derived from an `&mut`, as well as shared borrows of\n-    /// types with interior mutability.\n-    pub fn mut_borrows_only(\n-        tcx: TyCtxt<'tcx>,\n-        body: &'mir mir::Body<'tcx>,\n-        param_env: ParamEnv<'tcx>,\n-    ) -> Self {\n-        MaybeBorrowedLocals {\n-            kind: MutBorrow { body, tcx, param_env },\n-            ignore_borrow_on_drop: false,\n-        }\n+        MaybeBorrowedLocals { ignore_borrow_on_drop: false }\n     }\n }\n \n-impl<K> MaybeBorrowedLocals<K> {\n+impl MaybeBorrowedLocals {\n     /// During dataflow analysis, ignore the borrow that may occur when a place is dropped.\n     ///\n     /// Drop terminators may call custom drop glue (`Drop::drop`), which takes `&mut self` as a\n@@ -69,21 +40,14 @@ impl<K> MaybeBorrowedLocals<K> {\n         MaybeBorrowedLocals { ignore_borrow_on_drop: true, ..self }\n     }\n \n-    fn transfer_function<'a, T>(&'a self, trans: &'a mut T) -> TransferFunction<'a, T, K> {\n-        TransferFunction {\n-            kind: &self.kind,\n-            trans,\n-            ignore_borrow_on_drop: self.ignore_borrow_on_drop,\n-        }\n+    fn transfer_function<'a, T>(&'a self, trans: &'a mut T) -> TransferFunction<'a, T> {\n+        TransferFunction { trans, ignore_borrow_on_drop: self.ignore_borrow_on_drop }\n     }\n }\n \n-impl<K> AnalysisDomain<'tcx> for MaybeBorrowedLocals<K>\n-where\n-    K: BorrowAnalysisKind<'tcx>,\n-{\n+impl AnalysisDomain<'tcx> for MaybeBorrowedLocals {\n     type Domain = BitSet<Local>;\n-    const NAME: &'static str = K::ANALYSIS_NAME;\n+    const NAME: &'static str = \"maybe_borrowed_locals\";\n \n     fn bottom_value(&self, body: &mir::Body<'tcx>) -> Self::Domain {\n         // bottom = unborrowed\n@@ -95,10 +59,7 @@ where\n     }\n }\n \n-impl<K> GenKillAnalysis<'tcx> for MaybeBorrowedLocals<K>\n-where\n-    K: BorrowAnalysisKind<'tcx>,\n-{\n+impl GenKillAnalysis<'tcx> for MaybeBorrowedLocals {\n     type Idx = Local;\n \n     fn statement_effect(\n@@ -131,16 +92,14 @@ where\n }\n \n /// A `Visitor` that defines the transfer function for `MaybeBorrowedLocals`.\n-struct TransferFunction<'a, T, K> {\n+struct TransferFunction<'a, T> {\n     trans: &'a mut T,\n-    kind: &'a K,\n     ignore_borrow_on_drop: bool,\n }\n \n-impl<T, K> Visitor<'tcx> for TransferFunction<'a, T, K>\n+impl<T> Visitor<'tcx> for TransferFunction<'a, T>\n where\n     T: GenKill<Local>,\n-    K: BorrowAnalysisKind<'tcx>,\n {\n     fn visit_statement(&mut self, stmt: &Statement<'tcx>, location: Location) {\n         self.super_statement(stmt, location);\n@@ -156,14 +115,14 @@ where\n         self.super_rvalue(rvalue, location);\n \n         match rvalue {\n-            mir::Rvalue::AddressOf(mt, borrowed_place) => {\n-                if !borrowed_place.is_indirect() && self.kind.in_address_of(*mt, *borrowed_place) {\n+            mir::Rvalue::AddressOf(_mt, borrowed_place) => {\n+                if !borrowed_place.is_indirect() {\n                     self.trans.gen(borrowed_place.local);\n                 }\n             }\n \n-            mir::Rvalue::Ref(_, kind, borrowed_place) => {\n-                if !borrowed_place.is_indirect() && self.kind.in_ref(*kind, *borrowed_place) {\n+            mir::Rvalue::Ref(_, _kind, borrowed_place) => {\n+                if !borrowed_place.is_indirect() {\n                     self.trans.gen(borrowed_place.local);\n                 }\n             }\n@@ -211,64 +170,3 @@ where\n         }\n     }\n }\n-\n-pub struct AnyBorrow;\n-\n-pub struct MutBorrow<'mir, 'tcx> {\n-    tcx: TyCtxt<'tcx>,\n-    body: &'mir Body<'tcx>,\n-    param_env: ParamEnv<'tcx>,\n-}\n-\n-impl MutBorrow<'mir, 'tcx> {\n-    /// `&` and `&raw` only allow mutation if the borrowed place is `!Freeze`.\n-    ///\n-    /// This assumes that it is UB to take the address of a struct field whose type is\n-    /// `Freeze`, then use pointer arithmetic to derive a pointer to a *different* field of\n-    /// that same struct whose type is `!Freeze`. If we decide that this is not UB, we will\n-    /// have to check the type of the borrowed **local** instead of the borrowed **place**\n-    /// below. See [rust-lang/unsafe-code-guidelines#134].\n-    ///\n-    /// [rust-lang/unsafe-code-guidelines#134]: https://github.com/rust-lang/unsafe-code-guidelines/issues/134\n-    fn shared_borrow_allows_mutation(&self, place: Place<'tcx>) -> bool {\n-        !place.ty(self.body, self.tcx).ty.is_freeze(self.tcx.at(DUMMY_SP), self.param_env)\n-    }\n-}\n-\n-pub trait BorrowAnalysisKind<'tcx> {\n-    const ANALYSIS_NAME: &'static str;\n-\n-    fn in_address_of(&self, mt: Mutability, place: Place<'tcx>) -> bool;\n-    fn in_ref(&self, kind: mir::BorrowKind, place: Place<'tcx>) -> bool;\n-}\n-\n-impl BorrowAnalysisKind<'tcx> for AnyBorrow {\n-    const ANALYSIS_NAME: &'static str = \"maybe_borrowed_locals\";\n-\n-    fn in_ref(&self, _: mir::BorrowKind, _: Place<'_>) -> bool {\n-        true\n-    }\n-    fn in_address_of(&self, _: Mutability, _: Place<'_>) -> bool {\n-        true\n-    }\n-}\n-\n-impl BorrowAnalysisKind<'tcx> for MutBorrow<'mir, 'tcx> {\n-    const ANALYSIS_NAME: &'static str = \"maybe_mut_borrowed_locals\";\n-\n-    fn in_ref(&self, kind: mir::BorrowKind, place: Place<'tcx>) -> bool {\n-        match kind {\n-            mir::BorrowKind::Mut { .. } => true,\n-            mir::BorrowKind::Shared | mir::BorrowKind::Shallow | mir::BorrowKind::Unique => {\n-                self.shared_borrow_allows_mutation(place)\n-            }\n-        }\n-    }\n-\n-    fn in_address_of(&self, mt: Mutability, place: Place<'tcx>) -> bool {\n-        match mt {\n-            Mutability::Mut => true,\n-            Mutability::Not => self.shared_borrow_allows_mutation(place),\n-        }\n-    }\n-}"}, {"sha": "91dddc6cd55c5d415b76548051dd488b0774bb4a", "filename": "compiler/rustc_mir_dataflow/src/impls/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/baba6687df3e83fdb15cc6ec239b4a1c75a30505/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/baba6687df3e83fdb15cc6ec239b4a1c75a30505/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fmod.rs?ref=baba6687df3e83fdb15cc6ec239b4a1c75a30505", "patch": "@@ -22,7 +22,7 @@ mod init_locals;\n mod liveness;\n mod storage_liveness;\n \n-pub use self::borrowed_locals::{MaybeBorrowedLocals, MaybeMutBorrowedLocals};\n+pub use self::borrowed_locals::MaybeBorrowedLocals;\n pub use self::init_locals::MaybeInitializedLocals;\n pub use self::liveness::MaybeLiveLocals;\n pub use self::storage_liveness::{MaybeRequiresStorage, MaybeStorageLive};"}, {"sha": "28e5d76783aa4015cb8af5bc2cce5b2a618cf584", "filename": "compiler/rustc_mir_dataflow/src/rustc_peek.rs", "status": "modified", "additions": 1, "deletions": 30, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/baba6687df3e83fdb15cc6ec239b4a1c75a30505/compiler%2Frustc_mir_dataflow%2Fsrc%2Frustc_peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/baba6687df3e83fdb15cc6ec239b4a1c75a30505/compiler%2Frustc_mir_dataflow%2Fsrc%2Frustc_peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Frustc_peek.rs?ref=baba6687df3e83fdb15cc6ec239b4a1c75a30505", "patch": "@@ -11,8 +11,7 @@ use rustc_middle::mir::{self, Body, Local, Location};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n \n use crate::impls::{\n-    DefinitelyInitializedPlaces, MaybeInitializedPlaces, MaybeLiveLocals, MaybeMutBorrowedLocals,\n-    MaybeUninitializedPlaces,\n+    DefinitelyInitializedPlaces, MaybeInitializedPlaces, MaybeLiveLocals, MaybeUninitializedPlaces,\n };\n use crate::move_paths::{HasMoveData, MoveData};\n use crate::move_paths::{LookupResult, MovePathIndex};\n@@ -62,14 +61,6 @@ impl<'tcx> MirPass<'tcx> for SanityCheck {\n             sanity_check_via_rustc_peek(tcx, body, &attributes, &flow_def_inits);\n         }\n \n-        if has_rustc_mir_with(sess, &attributes, sym::rustc_peek_indirectly_mutable).is_some() {\n-            let flow_mut_borrowed = MaybeMutBorrowedLocals::mut_borrows_only(tcx, body, param_env)\n-                .into_engine(tcx, body)\n-                .iterate_to_fixpoint();\n-\n-            sanity_check_via_rustc_peek(tcx, body, &attributes, &flow_mut_borrowed);\n-        }\n-\n         if has_rustc_mir_with(sess, &attributes, sym::rustc_peek_liveness).is_some() {\n             let flow_liveness = MaybeLiveLocals.into_engine(tcx, body).iterate_to_fixpoint();\n \n@@ -281,26 +272,6 @@ where\n     }\n }\n \n-impl<'tcx> RustcPeekAt<'tcx> for MaybeMutBorrowedLocals<'_, 'tcx> {\n-    fn peek_at(\n-        &self,\n-        tcx: TyCtxt<'tcx>,\n-        place: mir::Place<'tcx>,\n-        flow_state: &BitSet<Local>,\n-        call: PeekCall,\n-    ) {\n-        info!(?place, \"peek_at\");\n-        let Some(local) = place.as_local() else {\n-            tcx.sess.span_err(call.span, \"rustc_peek: argument was not a local\");\n-            return;\n-        };\n-\n-        if !flow_state.contains(local) {\n-            tcx.sess.span_err(call.span, \"rustc_peek: bit not set\");\n-        }\n-    }\n-}\n-\n impl<'tcx> RustcPeekAt<'tcx> for MaybeLiveLocals {\n     fn peek_at(\n         &self,"}, {"sha": "52e2a8f48e23be3f62f4f419d1ba34e7359c5b82", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/baba6687df3e83fdb15cc6ec239b4a1c75a30505/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/baba6687df3e83fdb15cc6ec239b4a1c75a30505/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=baba6687df3e83fdb15cc6ec239b4a1c75a30505", "patch": "@@ -1128,7 +1128,6 @@ symbols! {\n         rustc_partition_reused,\n         rustc_peek,\n         rustc_peek_definite_init,\n-        rustc_peek_indirectly_mutable,\n         rustc_peek_liveness,\n         rustc_peek_maybe_init,\n         rustc_peek_maybe_uninit,"}, {"sha": "f74a25a346fda1d3dbee947117bf3cd8390f951f", "filename": "src/test/ui/consts/qualif-indirect-mutation-fail.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/baba6687df3e83fdb15cc6ec239b4a1c75a30505/src%2Ftest%2Fui%2Fconsts%2Fqualif-indirect-mutation-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/baba6687df3e83fdb15cc6ec239b4a1c75a30505/src%2Ftest%2Fui%2Fconsts%2Fqualif-indirect-mutation-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fqualif-indirect-mutation-fail.rs?ref=baba6687df3e83fdb15cc6ec239b4a1c75a30505", "patch": "@@ -2,6 +2,7 @@\n #![feature(const_mut_refs)]\n #![feature(const_precise_live_drops)]\n #![feature(const_swap)]\n+#![feature(raw_ref_op)]\n \n // Mutable borrow of a field with drop impl.\n pub const fn f() {\n@@ -42,3 +43,22 @@ pub const fn g2<T>() {\n     let _ = x.is_some();\n     let _y = x; //~ ERROR destructors cannot be evaluated\n }\n+\n+// Mutable raw reference to a Drop type.\n+pub const fn address_of_mut() {\n+    let mut x: Option<String> = None; //~ ERROR destructors cannot be evaluated\n+    &raw mut x;\n+\n+    let mut y: Option<String> = None; //~ ERROR destructors cannot be evaluated\n+    std::ptr::addr_of_mut!(y);\n+}\n+\n+// Const raw reference to a Drop type. Conservatively assumed to allow mutation\n+// until resolution of https://github.com/rust-lang/rust/issues/56604.\n+pub const fn address_of_const() {\n+    let x: Option<String> = None; //~ ERROR destructors cannot be evaluated\n+    &raw const x;\n+\n+    let y: Option<String> = None; //~ ERROR destructors cannot be evaluated\n+    std::ptr::addr_of!(y);\n+}"}, {"sha": "713df12b7a55f5e4b12a4da0938f37d178e56371", "filename": "src/test/ui/consts/qualif-indirect-mutation-fail.stderr", "status": "modified", "additions": 30, "deletions": 6, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/baba6687df3e83fdb15cc6ec239b4a1c75a30505/src%2Ftest%2Fui%2Fconsts%2Fqualif-indirect-mutation-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/baba6687df3e83fdb15cc6ec239b4a1c75a30505/src%2Ftest%2Fui%2Fconsts%2Fqualif-indirect-mutation-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fqualif-indirect-mutation-fail.stderr?ref=baba6687df3e83fdb15cc6ec239b4a1c75a30505", "patch": "@@ -1,33 +1,57 @@\n error[E0493]: destructors cannot be evaluated at compile-time\n-  --> $DIR/qualif-indirect-mutation-fail.rs:8:9\n+  --> $DIR/qualif-indirect-mutation-fail.rs:9:9\n    |\n LL |     let mut a: (u32, Option<String>) = (0, None);\n    |         ^^^^^ constant functions cannot evaluate destructors\n \n error[E0493]: destructors cannot be evaluated at compile-time\n-  --> $DIR/qualif-indirect-mutation-fail.rs:14:9\n+  --> $DIR/qualif-indirect-mutation-fail.rs:15:9\n    |\n LL |     let mut x = None;\n    |         ^^^^^ constants cannot evaluate destructors\n \n error[E0493]: destructors cannot be evaluated at compile-time\n-  --> $DIR/qualif-indirect-mutation-fail.rs:30:9\n+  --> $DIR/qualif-indirect-mutation-fail.rs:31:9\n    |\n LL |     let _z = x;\n    |         ^^ constants cannot evaluate destructors\n \n error[E0493]: destructors cannot be evaluated at compile-time\n-  --> $DIR/qualif-indirect-mutation-fail.rs:35:9\n+  --> $DIR/qualif-indirect-mutation-fail.rs:36:9\n    |\n LL |     let x: Option<T> = None;\n    |         ^ constant functions cannot evaluate destructors\n \n error[E0493]: destructors cannot be evaluated at compile-time\n-  --> $DIR/qualif-indirect-mutation-fail.rs:43:9\n+  --> $DIR/qualif-indirect-mutation-fail.rs:44:9\n    |\n LL |     let _y = x;\n    |         ^^ constant functions cannot evaluate destructors\n \n-error: aborting due to 5 previous errors\n+error[E0493]: destructors cannot be evaluated at compile-time\n+  --> $DIR/qualif-indirect-mutation-fail.rs:52:9\n+   |\n+LL |     let mut y: Option<String> = None;\n+   |         ^^^^^ constant functions cannot evaluate destructors\n+\n+error[E0493]: destructors cannot be evaluated at compile-time\n+  --> $DIR/qualif-indirect-mutation-fail.rs:49:9\n+   |\n+LL |     let mut x: Option<String> = None;\n+   |         ^^^^^ constant functions cannot evaluate destructors\n+\n+error[E0493]: destructors cannot be evaluated at compile-time\n+  --> $DIR/qualif-indirect-mutation-fail.rs:62:9\n+   |\n+LL |     let y: Option<String> = None;\n+   |         ^ constant functions cannot evaluate destructors\n+\n+error[E0493]: destructors cannot be evaluated at compile-time\n+  --> $DIR/qualif-indirect-mutation-fail.rs:59:9\n+   |\n+LL |     let x: Option<String> = None;\n+   |         ^ constant functions cannot evaluate destructors\n+\n+error: aborting due to 9 previous errors\n \n For more information about this error, try `rustc --explain E0493`."}, {"sha": "06af6a03b8f60d86d66b042c4888315a7a466b57", "filename": "src/test/ui/consts/qualif-indirect-mutation-pass.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/baba6687df3e83fdb15cc6ec239b4a1c75a30505/src%2Ftest%2Fui%2Fconsts%2Fqualif-indirect-mutation-pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/baba6687df3e83fdb15cc6ec239b4a1c75a30505/src%2Ftest%2Fui%2Fconsts%2Fqualif-indirect-mutation-pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fqualif-indirect-mutation-pass.rs?ref=baba6687df3e83fdb15cc6ec239b4a1c75a30505", "patch": "@@ -3,14 +3,22 @@\n #![feature(const_mut_refs)]\n #![feature(const_precise_live_drops)]\n \n+// Mutable reference allows only mutation of !Drop place.\n pub const fn f() {\n     let mut x: (Option<String>, u32) = (None, 0);\n     let mut a = 10;\n     *(&mut a) = 11;\n     x.1 = a;\n }\n \n+// Mutable reference allows only mutation of !Drop place.\n pub const fn g() {\n     let mut a: (u32, Option<String>) = (0, None);\n     let _ = &mut a.0;\n }\n+\n+// Shared reference does not allow for mutation.\n+pub const fn h() {\n+    let x: Option<String> = None;\n+    let _ = &x;\n+}"}, {"sha": "374a9f75a134b68036aadf51d1d86d8beece9480", "filename": "src/test/ui/mir-dataflow/indirect-mutation-offset.rs", "status": "removed", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/7734cb80782e65875994ee4709b7752623ea9ed2/src%2Ftest%2Fui%2Fmir-dataflow%2Findirect-mutation-offset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7734cb80782e65875994ee4709b7752623ea9ed2/src%2Ftest%2Fui%2Fmir-dataflow%2Findirect-mutation-offset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmir-dataflow%2Findirect-mutation-offset.rs?ref=7734cb80782e65875994ee4709b7752623ea9ed2", "patch": "@@ -1,48 +0,0 @@\n-// compile-flags: -Zunleash-the-miri-inside-of-you\n-\n-// This test demonstrates a shortcoming of the `MaybeMutBorrowedLocals` analysis. It does not\n-// handle code that takes a reference to one field of a struct, then use pointer arithmetic to\n-// transform it to another field of that same struct that may have interior mutability. For now,\n-// this is UB, but this may change in the future. See [rust-lang/unsafe-code-guidelines#134].\n-//\n-// [rust-lang/unsafe-code-guidelines#134]: https://github.com/rust-lang/unsafe-code-guidelines/issues/134\n-\n-#![feature(core_intrinsics, rustc_attrs, const_raw_ptr_deref)]\n-\n-use std::cell::UnsafeCell;\n-use std::intrinsics::rustc_peek;\n-\n-#[repr(C)]\n-struct PartialInteriorMut {\n-    zst: [i32; 0],\n-    cell: UnsafeCell<i32>,\n-}\n-\n-#[rustc_mir(rustc_peek_indirectly_mutable,stop_after_dataflow)]\n-const BOO: i32 = {\n-    let x = PartialInteriorMut {\n-        zst: [],\n-        cell: UnsafeCell::new(0),\n-    };\n-\n-    let p_zst: *const _ = &x.zst ; // Doesn't cause `x` to get marked as indirectly mutable.\n-\n-    let rmut_cell = unsafe {\n-        // Take advantage of the fact that `zst` and `cell` are at the same location in memory.\n-        // This trick would work with any size type if miri implemented `ptr::offset`.\n-        let p_cell = p_zst as *const UnsafeCell<i32>;\n-\n-        let pmut_cell = (*p_cell).get();\n-        &mut *pmut_cell\n-    };\n-\n-    *rmut_cell = 42;  // Mutates `x` indirectly even though `x` is not marked indirectly mutable!!!\n-    let val = *rmut_cell;\n-    rustc_peek(x); //~ ERROR rustc_peek: bit not set\n-\n-    val\n-};\n-\n-fn main() {\n-    println!(\"{}\", BOO);\n-}"}, {"sha": "1d5287c15ab7994983d160f6764fa9b3872b5ab7", "filename": "src/test/ui/mir-dataflow/indirect-mutation-offset.stderr", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7734cb80782e65875994ee4709b7752623ea9ed2/src%2Ftest%2Fui%2Fmir-dataflow%2Findirect-mutation-offset.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7734cb80782e65875994ee4709b7752623ea9ed2/src%2Ftest%2Fui%2Fmir-dataflow%2Findirect-mutation-offset.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmir-dataflow%2Findirect-mutation-offset.stderr?ref=7734cb80782e65875994ee4709b7752623ea9ed2", "patch": "@@ -1,10 +0,0 @@\n-error: rustc_peek: bit not set\n-  --> $DIR/indirect-mutation-offset.rs:41:5\n-   |\n-LL |     rustc_peek(x);\n-   |     ^^^^^^^^^^^^^\n-\n-error: stop_after_dataflow ended compilation\n-\n-error: aborting due to 2 previous errors\n-"}]}