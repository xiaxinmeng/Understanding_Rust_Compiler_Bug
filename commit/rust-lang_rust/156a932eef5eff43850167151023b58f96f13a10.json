{"sha": "156a932eef5eff43850167151023b58f96f13a10", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE1NmE5MzJlZWY1ZWZmNDM4NTAxNjcxNTEwMjNiNThmOTZmMTNhMTA=", "commit": {"author": {"name": "scalexm", "email": "alexandre@scalexm.fr", "date": "2018-11-01T13:39:03Z"}, "committer": {"name": "scalexm", "email": "alexandre@scalexm.fr", "date": "2018-11-13T11:28:43Z"}, "message": "Reorder code in `rustc::traits::structural_impls`", "tree": {"sha": "9515e78964b469316bdcb64db196ae5a1d820f2c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9515e78964b469316bdcb64db196ae5a1d820f2c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/156a932eef5eff43850167151023b58f96f13a10", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/156a932eef5eff43850167151023b58f96f13a10", "html_url": "https://github.com/rust-lang/rust/commit/156a932eef5eff43850167151023b58f96f13a10", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/156a932eef5eff43850167151023b58f96f13a10/comments", "author": {"login": "scalexm", "id": 1173131, "node_id": "MDQ6VXNlcjExNzMxMzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1173131?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scalexm", "html_url": "https://github.com/scalexm", "followers_url": "https://api.github.com/users/scalexm/followers", "following_url": "https://api.github.com/users/scalexm/following{/other_user}", "gists_url": "https://api.github.com/users/scalexm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scalexm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scalexm/subscriptions", "organizations_url": "https://api.github.com/users/scalexm/orgs", "repos_url": "https://api.github.com/users/scalexm/repos", "events_url": "https://api.github.com/users/scalexm/events{/privacy}", "received_events_url": "https://api.github.com/users/scalexm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "scalexm", "id": 1173131, "node_id": "MDQ6VXNlcjExNzMxMzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1173131?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scalexm", "html_url": "https://github.com/scalexm", "followers_url": "https://api.github.com/users/scalexm/followers", "following_url": "https://api.github.com/users/scalexm/following{/other_user}", "gists_url": "https://api.github.com/users/scalexm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scalexm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scalexm/subscriptions", "organizations_url": "https://api.github.com/users/scalexm/orgs", "repos_url": "https://api.github.com/users/scalexm/repos", "events_url": "https://api.github.com/users/scalexm/events{/privacy}", "received_events_url": "https://api.github.com/users/scalexm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "239df7be3772b8ec0687d10df878d46fbe89d921", "url": "https://api.github.com/repos/rust-lang/rust/commits/239df7be3772b8ec0687d10df878d46fbe89d921", "html_url": "https://github.com/rust-lang/rust/commit/239df7be3772b8ec0687d10df878d46fbe89d921"}], "stats": {"total": 996, "additions": 498, "deletions": 498}, "files": [{"sha": "3e417f10c4494833340e5c582c47fbf1798d2a3a", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 498, "deletions": 498, "changes": 996, "blob_url": "https://github.com/rust-lang/rust/blob/156a932eef5eff43850167151023b58f96f13a10/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/156a932eef5eff43850167151023b58f96f13a10/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=156a932eef5eff43850167151023b58f96f13a10", "patch": "@@ -171,379 +171,112 @@ impl<'tcx> fmt::Debug for traits::MismatchedProjectionTypes<'tcx> {\n     }\n }\n \n-///////////////////////////////////////////////////////////////////////////\n-// Lift implementations\n+impl<'tcx> fmt::Display for traits::WhereClause<'tcx> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        use traits::WhereClause::*;\n \n-impl<'a, 'tcx> Lift<'tcx> for traits::SelectionError<'a> {\n-    type Lifted = traits::SelectionError<'tcx>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n-        match *self {\n-            super::Unimplemented => Some(super::Unimplemented),\n-            super::OutputTypeParameterMismatch(a, b, ref err) => {\n-                tcx.lift(&(a, b)).and_then(|(a, b)|\n-                    tcx.lift(err)\n-                        .map(|err| super::OutputTypeParameterMismatch(a, b, err))\n-                )\n+        // Bypass ppaux because it does not print out anonymous regions.\n+        fn write_region_name<'tcx>(\n+            r: ty::Region<'tcx>,\n+            fmt: &mut fmt::Formatter<'_>\n+        ) -> fmt::Result {\n+            match r {\n+                ty::ReLateBound(index, br) => match br {\n+                    ty::BoundRegion::BrNamed(_, name) => write!(fmt, \"{}\", name),\n+                    ty::BoundRegion::BrAnon(var) => {\n+                        if *index == ty::INNERMOST {\n+                            write!(fmt, \"'^{}\", var)\n+                        } else {\n+                            write!(fmt, \"'^{}_{}\", index.index(), var)\n+                        }\n+                    }\n+                    _ => write!(fmt, \"'_\"),\n+                }\n+\n+                _ => write!(fmt, \"{}\", r),\n             }\n-            super::TraitNotObjectSafe(def_id) => Some(super::TraitNotObjectSafe(def_id)),\n-            super::ConstEvalFailure(err) => Some(super::ConstEvalFailure(err)),\n-            super::Overflow => Some(super::Overflow),\n         }\n-    }\n-}\n \n-impl<'a, 'tcx> Lift<'tcx> for traits::ObligationCauseCode<'a> {\n-    type Lifted = traits::ObligationCauseCode<'tcx>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n-        match *self {\n-            super::ReturnNoExpression => Some(super::ReturnNoExpression),\n-            super::MiscObligation => Some(super::MiscObligation),\n-            super::SliceOrArrayElem => Some(super::SliceOrArrayElem),\n-            super::TupleElem => Some(super::TupleElem),\n-            super::ProjectionWf(proj) => tcx.lift(&proj).map(super::ProjectionWf),\n-            super::ItemObligation(def_id) => Some(super::ItemObligation(def_id)),\n-            super::ReferenceOutlivesReferent(ty) => {\n-                tcx.lift(&ty).map(super::ReferenceOutlivesReferent)\n-            }\n-            super::ObjectTypeBound(ty, r) => tcx.lift(&ty).and_then(|ty|\n-                tcx.lift(&r)\n-                   .and_then(|r| Some(super::ObjectTypeBound(ty, r)))\n-            ),\n-            super::ObjectCastObligation(ty) => tcx.lift(&ty).map(super::ObjectCastObligation),\n-            super::AssignmentLhsSized => Some(super::AssignmentLhsSized),\n-            super::TupleInitializerSized => Some(super::TupleInitializerSized),\n-            super::StructInitializerSized => Some(super::StructInitializerSized),\n-            super::VariableType(id) => Some(super::VariableType(id)),\n-            super::ReturnType(id) => Some(super::ReturnType(id)),\n-            super::SizedArgumentType => Some(super::SizedArgumentType),\n-            super::SizedReturnType => Some(super::SizedReturnType),\n-            super::SizedYieldType => Some(super::SizedYieldType),\n-            super::RepeatVec => Some(super::RepeatVec),\n-            super::FieldSized { adt_kind, last } => Some(super::FieldSized { adt_kind, last }),\n-            super::ConstSized => Some(super::ConstSized),\n-            super::SharedStatic => Some(super::SharedStatic),\n-            super::BuiltinDerivedObligation(ref cause) => {\n-                tcx.lift(cause).map(super::BuiltinDerivedObligation)\n+        match self {\n+            Implemented(trait_ref) => write!(fmt, \"Implemented({})\", trait_ref),\n+            ProjectionEq(projection) => write!(fmt, \"ProjectionEq({})\", projection),\n+            RegionOutlives(predicate) => {\n+                write!(fmt, \"RegionOutlives({}: \", predicate.0)?;\n+                write_region_name(predicate.1, fmt)?;\n+                write!(fmt, \")\")\n             }\n-            super::ImplDerivedObligation(ref cause) => {\n-                tcx.lift(cause).map(super::ImplDerivedObligation)\n+            TypeOutlives(predicate) => {\n+                write!(fmt, \"TypeOutlives({}: \", predicate.0)?;\n+                write_region_name(predicate.1, fmt)?;\n+                write!(fmt, \")\")\n             }\n-            super::CompareImplMethodObligation {\n-                item_name,\n-                impl_item_def_id,\n-                trait_item_def_id,\n-            } => Some(super::CompareImplMethodObligation {\n-                item_name,\n-                impl_item_def_id,\n-                trait_item_def_id,\n-            }),\n-            super::ExprAssignable => Some(super::ExprAssignable),\n-            super::MatchExpressionArm { arm_span, source } => Some(super::MatchExpressionArm {\n-                arm_span,\n-                source: source,\n-            }),\n-            super::IfExpression => Some(super::IfExpression),\n-            super::IfExpressionWithNoElse => Some(super::IfExpressionWithNoElse),\n-            super::MainFunctionType => Some(super::MainFunctionType),\n-            super::StartFunctionType => Some(super::StartFunctionType),\n-            super::IntrinsicType => Some(super::IntrinsicType),\n-            super::MethodReceiver => Some(super::MethodReceiver),\n-            super::BlockTailExpression(id) => Some(super::BlockTailExpression(id)),\n-            super::TrivialBound => Some(super::TrivialBound),\n         }\n     }\n }\n \n-impl<'a, 'tcx> Lift<'tcx> for traits::DerivedObligationCause<'a> {\n-    type Lifted = traits::DerivedObligationCause<'tcx>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(&self.parent_trait_ref).and_then(|trait_ref|\n-            tcx.lift(&*self.parent_code)\n-               .map(|code| traits::DerivedObligationCause {\n-                   parent_trait_ref: trait_ref,\n-                   parent_code: Rc::new(code),\n-               })\n-        )\n+impl<'tcx> fmt::Display for traits::WellFormed<'tcx> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        use traits::WellFormed::*;\n+\n+        match self {\n+            Trait(trait_ref) => write!(fmt, \"WellFormed({})\", trait_ref),\n+            Ty(ty) => write!(fmt, \"WellFormed({})\", ty),\n+        }\n     }\n }\n \n-impl<'a, 'tcx> Lift<'tcx> for traits::ObligationCause<'a> {\n-    type Lifted = traits::ObligationCause<'tcx>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(&self.code).map(|code| traits::ObligationCause {\n-            span: self.span,\n-            body_id: self.body_id,\n-            code,\n-        })\n+impl<'tcx> fmt::Display for traits::FromEnv<'tcx> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        use traits::FromEnv::*;\n+\n+        match self {\n+            Trait(trait_ref) => write!(fmt, \"FromEnv({})\", trait_ref),\n+            Ty(ty) => write!(fmt, \"FromEnv({})\", ty),\n+        }\n     }\n }\n \n-// For codegen only.\n-impl<'a, 'tcx> Lift<'tcx> for traits::Vtable<'a, ()> {\n-    type Lifted = traits::Vtable<'tcx, ()>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n-        match self.clone() {\n-            traits::VtableImpl(traits::VtableImplData {\n-                impl_def_id,\n-                substs,\n-                nested,\n-            }) => tcx.lift(&substs).map(|substs|\n-                traits::VtableImpl(traits::VtableImplData {\n-                    impl_def_id,\n-                    substs,\n-                    nested,\n-                })\n-            ),\n-            traits::VtableAutoImpl(t) => Some(traits::VtableAutoImpl(t)),\n-            traits::VtableGenerator(traits::VtableGeneratorData {\n-                generator_def_id,\n-                substs,\n-                nested,\n-            }) => tcx.lift(&substs).map(|substs|\n-                traits::VtableGenerator(traits::VtableGeneratorData {\n-                    generator_def_id: generator_def_id,\n-                    substs: substs,\n-                    nested: nested,\n-                })\n-            ),\n-            traits::VtableClosure(traits::VtableClosureData {\n-                closure_def_id,\n-                substs,\n-                nested,\n-            }) => tcx.lift(&substs).map(|substs|\n-                traits::VtableClosure(traits::VtableClosureData {\n-                    closure_def_id,\n-                    substs,\n-                    nested,\n-                })\n-            ),\n-            traits::VtableFnPointer(traits::VtableFnPointerData { fn_ty, nested }) => {\n-                tcx.lift(&fn_ty).map(|fn_ty|\n-                    traits::VtableFnPointer(traits::VtableFnPointerData { fn_ty, nested })\n-                )\n-            }\n-            traits::VtableParam(n) => Some(traits::VtableParam(n)),\n-            traits::VtableBuiltin(n) => Some(traits::VtableBuiltin(n)),\n-            traits::VtableObject(traits::VtableObjectData {\n-                upcast_trait_ref,\n-                vtable_base,\n-                nested,\n-            }) => tcx.lift(&upcast_trait_ref).map(|trait_ref|\n-                traits::VtableObject(traits::VtableObjectData {\n-                    upcast_trait_ref: trait_ref,\n-                    vtable_base,\n-                    nested,\n-                })\n-            ),\n-            traits::VtableTraitAlias(traits::VtableTraitAliasData {\n-                alias_def_id,\n-                substs,\n-                nested,\n-            }) => tcx.lift(&substs).map(|substs|\n-                traits::VtableTraitAlias(traits::VtableTraitAliasData {\n-                    alias_def_id,\n-                    substs,\n-                    nested,\n-                })\n+impl<'tcx> fmt::Display for traits::DomainGoal<'tcx> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        use traits::DomainGoal::*;\n+\n+        match self {\n+            Holds(wc) => write!(fmt, \"{}\", wc),\n+            WellFormed(wf) => write!(fmt, \"{}\", wf),\n+            FromEnv(from_env) => write!(fmt, \"{}\", from_env),\n+            Normalize(projection) => write!(\n+                fmt,\n+                \"Normalize({} -> {})\",\n+                projection.projection_ty,\n+                projection.ty\n             ),\n         }\n     }\n }\n \n-///////////////////////////////////////////////////////////////////////////\n-// TypeFoldable implementations.\n+impl fmt::Display for traits::QuantifierKind {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        use traits::QuantifierKind::*;\n \n-impl<'tcx, O: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::Obligation<'tcx, O> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        traits::Obligation {\n-            cause: self.cause.clone(),\n-            recursion_depth: self.recursion_depth,\n-            predicate: self.predicate.fold_with(folder),\n-            param_env: self.param_env.fold_with(folder),\n+        match self {\n+            Universal => write!(fmt, \"forall\"),\n+            Existential => write!(fmt, \"exists\"),\n         }\n     }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.predicate.visit_with(visitor)\n-    }\n }\n \n-BraceStructTypeFoldableImpl! {\n-    impl<'tcx, N> TypeFoldable<'tcx> for traits::VtableImplData<'tcx, N> {\n-        impl_def_id, substs, nested\n-    } where N: TypeFoldable<'tcx>\n-}\n-\n-BraceStructTypeFoldableImpl! {\n-    impl<'tcx, N> TypeFoldable<'tcx> for traits::VtableGeneratorData<'tcx, N> {\n-        generator_def_id, substs, nested\n-    } where N: TypeFoldable<'tcx>\n-}\n-\n-BraceStructTypeFoldableImpl! {\n-    impl<'tcx, N> TypeFoldable<'tcx> for traits::VtableClosureData<'tcx, N> {\n-        closure_def_id, substs, nested\n-    } where N: TypeFoldable<'tcx>\n-}\n-\n-BraceStructTypeFoldableImpl! {\n-    impl<'tcx, N> TypeFoldable<'tcx> for traits::VtableAutoImplData<N> {\n-        trait_def_id, nested\n-    } where N: TypeFoldable<'tcx>\n-}\n-\n-BraceStructTypeFoldableImpl! {\n-    impl<'tcx, N> TypeFoldable<'tcx> for traits::VtableBuiltinData<N> {\n-        nested\n-    } where N: TypeFoldable<'tcx>\n-}\n-\n-BraceStructTypeFoldableImpl! {\n-    impl<'tcx, N> TypeFoldable<'tcx> for traits::VtableObjectData<'tcx, N> {\n-        upcast_trait_ref, vtable_base, nested\n-    } where N: TypeFoldable<'tcx>\n-}\n-\n-BraceStructTypeFoldableImpl! {\n-    impl<'tcx, N> TypeFoldable<'tcx> for traits::VtableFnPointerData<'tcx, N> {\n-        fn_ty,\n-        nested\n-    } where N: TypeFoldable<'tcx>\n-}\n-\n-BraceStructTypeFoldableImpl! {\n-    impl<'tcx, N> TypeFoldable<'tcx> for traits::VtableTraitAliasData<'tcx, N> {\n-        alias_def_id, substs, nested\n-    } where N: TypeFoldable<'tcx>\n-}\n-\n-EnumTypeFoldableImpl! {\n-    impl<'tcx, N> TypeFoldable<'tcx> for traits::Vtable<'tcx, N> {\n-        (traits::VtableImpl)(a),\n-        (traits::VtableAutoImpl)(a),\n-        (traits::VtableGenerator)(a),\n-        (traits::VtableClosure)(a),\n-        (traits::VtableFnPointer)(a),\n-        (traits::VtableParam)(a),\n-        (traits::VtableBuiltin)(a),\n-        (traits::VtableObject)(a),\n-        (traits::VtableTraitAlias)(a),\n-    } where N: TypeFoldable<'tcx>\n-}\n-\n-BraceStructTypeFoldableImpl! {\n-    impl<'tcx, T> TypeFoldable<'tcx> for Normalized<'tcx, T> {\n-        value,\n-        obligations\n-    } where T: TypeFoldable<'tcx>\n-}\n-\n-impl<'tcx> fmt::Display for traits::WhereClause<'tcx> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        use traits::WhereClause::*;\n-\n-        // Bypass ppaux because it does not print out anonymous regions.\n-        fn write_region_name<'tcx>(\n-            r: ty::Region<'tcx>,\n-            fmt: &mut fmt::Formatter<'_>\n-        ) -> fmt::Result {\n-            match r {\n-                ty::ReLateBound(index, br) => match br {\n-                    ty::BoundRegion::BrNamed(_, name) => write!(fmt, \"{}\", name),\n-                    ty::BoundRegion::BrAnon(var) => {\n-                        if *index == ty::INNERMOST {\n-                            write!(fmt, \"'^{}\", var)\n-                        } else {\n-                            write!(fmt, \"'^{}_{}\", index.index(), var)\n-                        }\n-                    }\n-                    _ => write!(fmt, \"'_\"),\n-                }\n-\n-                _ => write!(fmt, \"{}\", r),\n-            }\n-        }\n-\n-        match self {\n-            Implemented(trait_ref) => write!(fmt, \"Implemented({})\", trait_ref),\n-            ProjectionEq(projection) => write!(fmt, \"ProjectionEq({})\", projection),\n-            RegionOutlives(predicate) => {\n-                write!(fmt, \"RegionOutlives({}: \", predicate.0)?;\n-                write_region_name(predicate.1, fmt)?;\n-                write!(fmt, \")\")\n-            }\n-            TypeOutlives(predicate) => {\n-                write!(fmt, \"TypeOutlives({}: \", predicate.0)?;\n-                write_region_name(predicate.1, fmt)?;\n-                write!(fmt, \")\")\n-            }\n-        }\n-    }\n-}\n-\n-impl<'tcx> fmt::Display for traits::WellFormed<'tcx> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        use traits::WellFormed::*;\n-\n-        match self {\n-            Trait(trait_ref) => write!(fmt, \"WellFormed({})\", trait_ref),\n-            Ty(ty) => write!(fmt, \"WellFormed({})\", ty),\n-        }\n-    }\n-}\n-\n-impl<'tcx> fmt::Display for traits::FromEnv<'tcx> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        use traits::FromEnv::*;\n-\n-        match self {\n-            Trait(trait_ref) => write!(fmt, \"FromEnv({})\", trait_ref),\n-            Ty(ty) => write!(fmt, \"FromEnv({})\", ty),\n-        }\n-    }\n-}\n-\n-impl<'tcx> fmt::Display for traits::DomainGoal<'tcx> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        use traits::DomainGoal::*;\n-\n-        match self {\n-            Holds(wc) => write!(fmt, \"{}\", wc),\n-            WellFormed(wf) => write!(fmt, \"{}\", wf),\n-            FromEnv(from_env) => write!(fmt, \"{}\", from_env),\n-            Normalize(projection) => write!(\n-                fmt,\n-                \"Normalize({} -> {})\",\n-                projection.projection_ty,\n-                projection.ty\n-            ),\n-        }\n-    }\n-}\n-\n-impl fmt::Display for traits::QuantifierKind {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        use traits::QuantifierKind::*;\n-\n-        match self {\n-            Universal => write!(fmt, \"forall\"),\n-            Existential => write!(fmt, \"exists\"),\n-        }\n-    }\n-}\n-\n-/// Collect names for regions / types bound by a quantified goal / clause.\n-/// This collector does not try to do anything clever like in ppaux, it's just used\n-/// for debug output in tests anyway.\n-struct BoundNamesCollector {\n-    // Just sort by name because `BoundRegion::BrNamed` does not have a `BoundVar` index anyway.\n-    regions: BTreeSet<InternedString>,\n-\n-    // Sort by `BoundVar` index, so usually this should be equivalent to the order given\n-    // by the list of type parameters.\n-    types: BTreeMap<u32, InternedString>,\n-\n-    binder_index: ty::DebruijnIndex,\n+/// Collect names for regions / types bound by a quantified goal / clause.\n+/// This collector does not try to do anything clever like in ppaux, it's just used\n+/// for debug output in tests anyway.\n+struct BoundNamesCollector {\n+    // Just sort by name because `BoundRegion::BrNamed` does not have a `BoundVar` index anyway.\n+    regions: BTreeSet<InternedString>,\n+\n+    // Sort by `BoundVar` index, so usually this should be equivalent to the order given\n+    // by the list of type parameters.\n+    types: BTreeMap<u32, InternedString>,\n+\n+    binder_index: ty::DebruijnIndex,\n }\n \n impl BoundNamesCollector {\n@@ -636,104 +369,446 @@ impl<'tcx> TypeVisitor<'tcx> for BoundNamesCollector {\n     }\n }\n \n-impl<'tcx> fmt::Display for traits::Goal<'tcx> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        use traits::GoalKind::*;\n-\n-        match self {\n-            Implies(hypotheses, goal) => {\n-                write!(fmt, \"if (\")?;\n-                for (index, hyp) in hypotheses.iter().enumerate() {\n-                    if index > 0 {\n-                        write!(fmt, \", \")?;\n-                    }\n-                    write!(fmt, \"{}\", hyp)?;\n-                }\n-                write!(fmt, \") {{ {} }}\", goal)\n+impl<'tcx> fmt::Display for traits::Goal<'tcx> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        use traits::GoalKind::*;\n+\n+        match self {\n+            Implies(hypotheses, goal) => {\n+                write!(fmt, \"if (\")?;\n+                for (index, hyp) in hypotheses.iter().enumerate() {\n+                    if index > 0 {\n+                        write!(fmt, \", \")?;\n+                    }\n+                    write!(fmt, \"{}\", hyp)?;\n+                }\n+                write!(fmt, \") {{ {} }}\", goal)\n+            }\n+            And(goal1, goal2) => write!(fmt, \"({} && {})\", goal1, goal2),\n+            Not(goal) => write!(fmt, \"not {{ {} }}\", goal),\n+            DomainGoal(goal) => write!(fmt, \"{}\", goal),\n+            Quantified(qkind, goal) => {\n+                let mut collector = BoundNamesCollector::new();\n+                goal.skip_binder().visit_with(&mut collector);\n+\n+                if !collector.is_empty() {\n+                    write!(fmt, \"{}<\", qkind)?;\n+                    collector.write_names(fmt)?;\n+                    write!(fmt, \"> {{ \")?;\n+                }\n+\n+                write!(fmt, \"{}\", goal.skip_binder())?;\n+\n+                if !collector.is_empty() {\n+                    write!(fmt, \" }}\")?;\n+                }\n+\n+                Ok(())\n+            }\n+            CannotProve => write!(fmt, \"CannotProve\"),\n+        }\n+    }\n+}\n+\n+impl<'tcx> fmt::Display for traits::ProgramClause<'tcx> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        let traits::ProgramClause { goal, hypotheses, .. } = self;\n+        write!(fmt, \"{}\", goal)?;\n+        if !hypotheses.is_empty() {\n+            write!(fmt, \" :- \")?;\n+            for (index, condition) in hypotheses.iter().enumerate() {\n+                if index > 0 {\n+                    write!(fmt, \", \")?;\n+                }\n+                write!(fmt, \"{}\", condition)?;\n+            }\n+        }\n+        write!(fmt, \".\")\n+    }\n+}\n+\n+impl<'tcx> fmt::Display for traits::Clause<'tcx> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        use traits::Clause::*;\n+\n+        match self {\n+            Implies(clause) => write!(fmt, \"{}\", clause),\n+            ForAll(clause) => {\n+                let mut collector = BoundNamesCollector::new();\n+                clause.skip_binder().visit_with(&mut collector);\n+\n+                if !collector.is_empty() {\n+                    write!(fmt, \"forall<\")?;\n+                    collector.write_names(fmt)?;\n+                    write!(fmt, \"> {{ \")?;\n+                }\n+\n+                write!(fmt, \"{}\", clause.skip_binder())?;\n+\n+                if !collector.is_empty() {\n+                    write!(fmt, \" }}\")?;\n+                }\n+\n+                Ok(())\n+            }\n+        }\n+    }\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+// Lift implementations\n+\n+impl<'a, 'tcx> Lift<'tcx> for traits::SelectionError<'a> {\n+    type Lifted = traits::SelectionError<'tcx>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        match *self {\n+            super::Unimplemented => Some(super::Unimplemented),\n+            super::OutputTypeParameterMismatch(a, b, ref err) => {\n+                tcx.lift(&(a, b)).and_then(|(a, b)|\n+                    tcx.lift(err)\n+                        .map(|err| super::OutputTypeParameterMismatch(a, b, err))\n+                )\n+            }\n+            super::TraitNotObjectSafe(def_id) => Some(super::TraitNotObjectSafe(def_id)),\n+            super::ConstEvalFailure(err) => Some(super::ConstEvalFailure(err)),\n+            super::Overflow => Some(super::Overflow),\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> Lift<'tcx> for traits::ObligationCauseCode<'a> {\n+    type Lifted = traits::ObligationCauseCode<'tcx>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        match *self {\n+            super::ReturnNoExpression => Some(super::ReturnNoExpression),\n+            super::MiscObligation => Some(super::MiscObligation),\n+            super::SliceOrArrayElem => Some(super::SliceOrArrayElem),\n+            super::TupleElem => Some(super::TupleElem),\n+            super::ProjectionWf(proj) => tcx.lift(&proj).map(super::ProjectionWf),\n+            super::ItemObligation(def_id) => Some(super::ItemObligation(def_id)),\n+            super::ReferenceOutlivesReferent(ty) => {\n+                tcx.lift(&ty).map(super::ReferenceOutlivesReferent)\n+            }\n+            super::ObjectTypeBound(ty, r) => tcx.lift(&ty).and_then(|ty|\n+                tcx.lift(&r)\n+                   .and_then(|r| Some(super::ObjectTypeBound(ty, r)))\n+            ),\n+            super::ObjectCastObligation(ty) => tcx.lift(&ty).map(super::ObjectCastObligation),\n+            super::AssignmentLhsSized => Some(super::AssignmentLhsSized),\n+            super::TupleInitializerSized => Some(super::TupleInitializerSized),\n+            super::StructInitializerSized => Some(super::StructInitializerSized),\n+            super::VariableType(id) => Some(super::VariableType(id)),\n+            super::ReturnType(id) => Some(super::ReturnType(id)),\n+            super::SizedArgumentType => Some(super::SizedArgumentType),\n+            super::SizedReturnType => Some(super::SizedReturnType),\n+            super::SizedYieldType => Some(super::SizedYieldType),\n+            super::RepeatVec => Some(super::RepeatVec),\n+            super::FieldSized { adt_kind, last } => Some(super::FieldSized { adt_kind, last }),\n+            super::ConstSized => Some(super::ConstSized),\n+            super::SharedStatic => Some(super::SharedStatic),\n+            super::BuiltinDerivedObligation(ref cause) => {\n+                tcx.lift(cause).map(super::BuiltinDerivedObligation)\n+            }\n+            super::ImplDerivedObligation(ref cause) => {\n+                tcx.lift(cause).map(super::ImplDerivedObligation)\n+            }\n+            super::CompareImplMethodObligation {\n+                item_name,\n+                impl_item_def_id,\n+                trait_item_def_id,\n+            } => Some(super::CompareImplMethodObligation {\n+                item_name,\n+                impl_item_def_id,\n+                trait_item_def_id,\n+            }),\n+            super::ExprAssignable => Some(super::ExprAssignable),\n+            super::MatchExpressionArm { arm_span, source } => Some(super::MatchExpressionArm {\n+                arm_span,\n+                source: source,\n+            }),\n+            super::IfExpression => Some(super::IfExpression),\n+            super::IfExpressionWithNoElse => Some(super::IfExpressionWithNoElse),\n+            super::MainFunctionType => Some(super::MainFunctionType),\n+            super::StartFunctionType => Some(super::StartFunctionType),\n+            super::IntrinsicType => Some(super::IntrinsicType),\n+            super::MethodReceiver => Some(super::MethodReceiver),\n+            super::BlockTailExpression(id) => Some(super::BlockTailExpression(id)),\n+            super::TrivialBound => Some(super::TrivialBound),\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> Lift<'tcx> for traits::DerivedObligationCause<'a> {\n+    type Lifted = traits::DerivedObligationCause<'tcx>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(&self.parent_trait_ref).and_then(|trait_ref|\n+            tcx.lift(&*self.parent_code)\n+               .map(|code| traits::DerivedObligationCause {\n+                   parent_trait_ref: trait_ref,\n+                   parent_code: Rc::new(code),\n+               })\n+        )\n+    }\n+}\n+\n+impl<'a, 'tcx> Lift<'tcx> for traits::ObligationCause<'a> {\n+    type Lifted = traits::ObligationCause<'tcx>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(&self.code).map(|code| traits::ObligationCause {\n+            span: self.span,\n+            body_id: self.body_id,\n+            code,\n+        })\n+    }\n+}\n+\n+// For codegen only.\n+impl<'a, 'tcx> Lift<'tcx> for traits::Vtable<'a, ()> {\n+    type Lifted = traits::Vtable<'tcx, ()>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        match self.clone() {\n+            traits::VtableImpl(traits::VtableImplData {\n+                impl_def_id,\n+                substs,\n+                nested,\n+            }) => tcx.lift(&substs).map(|substs|\n+                traits::VtableImpl(traits::VtableImplData {\n+                    impl_def_id,\n+                    substs,\n+                    nested,\n+                })\n+            ),\n+            traits::VtableAutoImpl(t) => Some(traits::VtableAutoImpl(t)),\n+            traits::VtableGenerator(traits::VtableGeneratorData {\n+                generator_def_id,\n+                substs,\n+                nested,\n+            }) => tcx.lift(&substs).map(|substs|\n+                traits::VtableGenerator(traits::VtableGeneratorData {\n+                    generator_def_id: generator_def_id,\n+                    substs: substs,\n+                    nested: nested,\n+                })\n+            ),\n+            traits::VtableClosure(traits::VtableClosureData {\n+                closure_def_id,\n+                substs,\n+                nested,\n+            }) => tcx.lift(&substs).map(|substs|\n+                traits::VtableClosure(traits::VtableClosureData {\n+                    closure_def_id,\n+                    substs,\n+                    nested,\n+                })\n+            ),\n+            traits::VtableFnPointer(traits::VtableFnPointerData { fn_ty, nested }) => {\n+                tcx.lift(&fn_ty).map(|fn_ty|\n+                    traits::VtableFnPointer(traits::VtableFnPointerData { fn_ty, nested })\n+                )\n+            }\n+            traits::VtableParam(n) => Some(traits::VtableParam(n)),\n+            traits::VtableBuiltin(n) => Some(traits::VtableBuiltin(n)),\n+            traits::VtableObject(traits::VtableObjectData {\n+                upcast_trait_ref,\n+                vtable_base,\n+                nested,\n+            }) => tcx.lift(&upcast_trait_ref).map(|trait_ref|\n+                traits::VtableObject(traits::VtableObjectData {\n+                    upcast_trait_ref: trait_ref,\n+                    vtable_base,\n+                    nested,\n+                })\n+            ),\n+            traits::VtableTraitAlias(traits::VtableTraitAliasData {\n+                alias_def_id,\n+                substs,\n+                nested,\n+            }) => tcx.lift(&substs).map(|substs|\n+                traits::VtableTraitAlias(traits::VtableTraitAliasData {\n+                    alias_def_id,\n+                    substs,\n+                    nested,\n+                })\n+            ),\n+        }\n+    }\n+}\n+\n+EnumLiftImpl! {\n+    impl<'a, 'tcx> Lift<'tcx> for traits::WhereClause<'a> {\n+        type Lifted = traits::WhereClause<'tcx>;\n+        (traits::WhereClause::Implemented)(trait_ref),\n+        (traits::WhereClause::ProjectionEq)(projection),\n+        (traits::WhereClause::TypeOutlives)(ty_outlives),\n+        (traits::WhereClause::RegionOutlives)(region_outlives),\n+    }\n+}\n+\n+EnumLiftImpl! {\n+    impl<'a, 'tcx> Lift<'tcx> for traits::WellFormed<'a> {\n+        type Lifted = traits::WellFormed<'tcx>;\n+        (traits::WellFormed::Trait)(trait_ref),\n+        (traits::WellFormed::Ty)(ty),\n+    }\n+}\n+\n+EnumLiftImpl! {\n+    impl<'a, 'tcx> Lift<'tcx> for traits::FromEnv<'a> {\n+        type Lifted = traits::FromEnv<'tcx>;\n+        (traits::FromEnv::Trait)(trait_ref),\n+        (traits::FromEnv::Ty)(ty),\n+    }\n+}\n+\n+EnumLiftImpl! {\n+    impl<'a, 'tcx> Lift<'tcx> for traits::DomainGoal<'a> {\n+        type Lifted = traits::DomainGoal<'tcx>;\n+        (traits::DomainGoal::Holds)(wc),\n+        (traits::DomainGoal::WellFormed)(wf),\n+        (traits::DomainGoal::FromEnv)(from_env),\n+        (traits::DomainGoal::Normalize)(projection),\n+    }\n+}\n+\n+EnumLiftImpl! {\n+    impl<'a, 'tcx> Lift<'tcx> for traits::GoalKind<'a> {\n+        type Lifted = traits::GoalKind<'tcx>;\n+        (traits::GoalKind::Implies)(hypotheses, goal),\n+        (traits::GoalKind::And)(goal1, goal2),\n+        (traits::GoalKind::Not)(goal),\n+        (traits::GoalKind::DomainGoal)(domain_goal),\n+        (traits::GoalKind::Quantified)(kind, goal),\n+        (traits::GoalKind::CannotProve),\n+    }\n+}\n+\n+impl<'a, 'tcx> Lift<'tcx> for traits::Environment<'a> {\n+    type Lifted = traits::Environment<'tcx>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(&self.clauses).map(|clauses| {\n+            traits::Environment {\n+                clauses,\n             }\n-            And(goal1, goal2) => write!(fmt, \"({} && {})\", goal1, goal2),\n-            Not(goal) => write!(fmt, \"not {{ {} }}\", goal),\n-            DomainGoal(goal) => write!(fmt, \"{}\", goal),\n-            Quantified(qkind, goal) => {\n-                let mut collector = BoundNamesCollector::new();\n-                goal.skip_binder().visit_with(&mut collector);\n+        })\n+    }\n+}\n \n-                if !collector.is_empty() {\n-                    write!(fmt, \"{}<\", qkind)?;\n-                    collector.write_names(fmt)?;\n-                    write!(fmt, \"> {{ \")?;\n+impl<'a, 'tcx, G: Lift<'tcx>> Lift<'tcx> for traits::InEnvironment<'a, G> {\n+    type Lifted = traits::InEnvironment<'tcx, G::Lifted>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(&self.environment).and_then(|environment| {\n+            tcx.lift(&self.goal).map(|goal| {\n+                traits::InEnvironment {\n+                    environment,\n+                    goal,\n                 }\n+            })\n+        })\n+    }\n+}\n \n-                write!(fmt, \"{}\", goal.skip_binder())?;\n-\n-                if !collector.is_empty() {\n-                    write!(fmt, \" }}\")?;\n-                }\n+impl<'tcx, C> Lift<'tcx> for chalk_engine::ExClause<C>\n+where\n+    C: chalk_engine::context::Context + Clone,\n+    C: traits::ExClauseLift<'tcx>,\n+{\n+    type Lifted = C::LiftedExClause;\n \n-                Ok(())\n-            }\n-            CannotProve => write!(fmt, \"CannotProve\"),\n-        }\n+    fn lift_to_tcx<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        <C as traits::ExClauseLift>::lift_ex_clause_to_tcx(self, tcx)\n     }\n }\n \n-impl<'tcx> fmt::Display for traits::ProgramClause<'tcx> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let traits::ProgramClause { goal, hypotheses, .. } = self;\n-        write!(fmt, \"{}\", goal)?;\n-        if !hypotheses.is_empty() {\n-            write!(fmt, \" :- \")?;\n-            for (index, condition) in hypotheses.iter().enumerate() {\n-                if index > 0 {\n-                    write!(fmt, \", \")?;\n-                }\n-                write!(fmt, \"{}\", condition)?;\n-            }\n+///////////////////////////////////////////////////////////////////////////\n+// TypeFoldable implementations.\n+\n+impl<'tcx, O: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::Obligation<'tcx, O> {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+        traits::Obligation {\n+            cause: self.cause.clone(),\n+            recursion_depth: self.recursion_depth,\n+            predicate: self.predicate.fold_with(folder),\n+            param_env: self.param_env.fold_with(folder),\n         }\n-        write!(fmt, \".\")\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.predicate.visit_with(visitor)\n     }\n }\n \n-impl<'tcx> fmt::Display for traits::Clause<'tcx> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        use traits::Clause::*;\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx, N> TypeFoldable<'tcx> for traits::VtableImplData<'tcx, N> {\n+        impl_def_id, substs, nested\n+    } where N: TypeFoldable<'tcx>\n+}\n \n-        match self {\n-            Implies(clause) => write!(fmt, \"{}\", clause),\n-            ForAll(clause) => {\n-                let mut collector = BoundNamesCollector::new();\n-                clause.skip_binder().visit_with(&mut collector);\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx, N> TypeFoldable<'tcx> for traits::VtableGeneratorData<'tcx, N> {\n+        generator_def_id, substs, nested\n+    } where N: TypeFoldable<'tcx>\n+}\n \n-                if !collector.is_empty() {\n-                    write!(fmt, \"forall<\")?;\n-                    collector.write_names(fmt)?;\n-                    write!(fmt, \"> {{ \")?;\n-                }\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx, N> TypeFoldable<'tcx> for traits::VtableClosureData<'tcx, N> {\n+        closure_def_id, substs, nested\n+    } where N: TypeFoldable<'tcx>\n+}\n \n-                write!(fmt, \"{}\", clause.skip_binder())?;\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx, N> TypeFoldable<'tcx> for traits::VtableAutoImplData<N> {\n+        trait_def_id, nested\n+    } where N: TypeFoldable<'tcx>\n+}\n \n-                if !collector.is_empty() {\n-                    write!(fmt, \" }}\")?;\n-                }\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx, N> TypeFoldable<'tcx> for traits::VtableBuiltinData<N> {\n+        nested\n+    } where N: TypeFoldable<'tcx>\n+}\n \n-                Ok(())\n-            }\n-        }\n-    }\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx, N> TypeFoldable<'tcx> for traits::VtableObjectData<'tcx, N> {\n+        upcast_trait_ref, vtable_base, nested\n+    } where N: TypeFoldable<'tcx>\n+}\n+\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx, N> TypeFoldable<'tcx> for traits::VtableFnPointerData<'tcx, N> {\n+        fn_ty,\n+        nested\n+    } where N: TypeFoldable<'tcx>\n+}\n+\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx, N> TypeFoldable<'tcx> for traits::VtableTraitAliasData<'tcx, N> {\n+        alias_def_id, substs, nested\n+    } where N: TypeFoldable<'tcx>\n }\n \n EnumTypeFoldableImpl! {\n-    impl<'tcx> TypeFoldable<'tcx> for traits::WhereClause<'tcx> {\n-        (traits::WhereClause::Implemented)(trait_ref),\n-        (traits::WhereClause::ProjectionEq)(projection),\n-        (traits::WhereClause::TypeOutlives)(ty_outlives),\n-        (traits::WhereClause::RegionOutlives)(region_outlives),\n-    }\n+    impl<'tcx, N> TypeFoldable<'tcx> for traits::Vtable<'tcx, N> {\n+        (traits::VtableImpl)(a),\n+        (traits::VtableAutoImpl)(a),\n+        (traits::VtableGenerator)(a),\n+        (traits::VtableClosure)(a),\n+        (traits::VtableFnPointer)(a),\n+        (traits::VtableParam)(a),\n+        (traits::VtableBuiltin)(a),\n+        (traits::VtableObject)(a),\n+        (traits::VtableTraitAlias)(a),\n+    } where N: TypeFoldable<'tcx>\n }\n \n-EnumLiftImpl! {\n-    impl<'a, 'tcx> Lift<'tcx> for traits::WhereClause<'a> {\n-        type Lifted = traits::WhereClause<'tcx>;\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx, T> TypeFoldable<'tcx> for Normalized<'tcx, T> {\n+        value,\n+        obligations\n+    } where T: TypeFoldable<'tcx>\n+}\n+\n+EnumTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for traits::WhereClause<'tcx> {\n         (traits::WhereClause::Implemented)(trait_ref),\n         (traits::WhereClause::ProjectionEq)(projection),\n         (traits::WhereClause::TypeOutlives)(ty_outlives),\n@@ -748,29 +823,13 @@ EnumTypeFoldableImpl! {\n     }\n }\n \n-EnumLiftImpl! {\n-    impl<'a, 'tcx> Lift<'tcx> for traits::WellFormed<'a> {\n-        type Lifted = traits::WellFormed<'tcx>;\n-        (traits::WellFormed::Trait)(trait_ref),\n-        (traits::WellFormed::Ty)(ty),\n-    }\n-}\n-\n EnumTypeFoldableImpl! {\n     impl<'tcx> TypeFoldable<'tcx> for traits::FromEnv<'tcx> {\n         (traits::FromEnv::Trait)(trait_ref),\n         (traits::FromEnv::Ty)(ty),\n     }\n }\n \n-EnumLiftImpl! {\n-    impl<'a, 'tcx> Lift<'tcx> for traits::FromEnv<'a> {\n-        type Lifted = traits::FromEnv<'tcx>;\n-        (traits::FromEnv::Trait)(trait_ref),\n-        (traits::FromEnv::Ty)(ty),\n-    }\n-}\n-\n EnumTypeFoldableImpl! {\n     impl<'tcx> TypeFoldable<'tcx> for traits::DomainGoal<'tcx> {\n         (traits::DomainGoal::Holds)(wc),\n@@ -780,16 +839,6 @@ EnumTypeFoldableImpl! {\n     }\n }\n \n-EnumLiftImpl! {\n-    impl<'a, 'tcx> Lift<'tcx> for traits::DomainGoal<'a> {\n-        type Lifted = traits::DomainGoal<'tcx>;\n-        (traits::DomainGoal::Holds)(wc),\n-        (traits::DomainGoal::WellFormed)(wf),\n-        (traits::DomainGoal::FromEnv)(from_env),\n-        (traits::DomainGoal::Normalize)(projection),\n-    }\n-}\n-\n CloneTypeFoldableAndLiftImpls! {\n     traits::QuantifierKind,\n }\n@@ -805,18 +854,6 @@ EnumTypeFoldableImpl! {\n     }\n }\n \n-EnumLiftImpl! {\n-    impl<'a, 'tcx> Lift<'tcx> for traits::GoalKind<'a> {\n-        type Lifted = traits::GoalKind<'tcx>;\n-        (traits::GoalKind::Implies)(hypotheses, goal),\n-        (traits::GoalKind::And)(goal1, goal2),\n-        (traits::GoalKind::Not)(goal),\n-        (traits::GoalKind::DomainGoal)(domain_goal),\n-        (traits::GoalKind::Quantified)(kind, goal),\n-        (traits::GoalKind::CannotProve),\n-    }\n-}\n-\n impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<traits::Goal<'tcx>> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         let v = self.iter()\n@@ -871,31 +908,6 @@ BraceStructTypeFoldableImpl! {\n     } where G: TypeFoldable<'tcx>\n }\n \n-impl<'a, 'tcx> Lift<'tcx> for traits::Environment<'a> {\n-    type Lifted = traits::Environment<'tcx>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(&self.clauses).map(|clauses| {\n-            traits::Environment {\n-                clauses,\n-            }\n-        })\n-    }\n-}\n-\n-impl<'a, 'tcx, G: Lift<'tcx>> Lift<'tcx> for traits::InEnvironment<'a, G> {\n-    type Lifted = traits::InEnvironment<'tcx, G::Lifted>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(&self.environment).and_then(|environment| {\n-            tcx.lift(&self.goal).map(|goal| {\n-                traits::InEnvironment {\n-                    environment,\n-                    goal,\n-                }\n-            })\n-        })\n-    }\n-}\n-\n impl<'tcx> TypeFoldable<'tcx> for traits::Clauses<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         let v = self.iter()\n@@ -930,18 +942,6 @@ where\n     }\n }\n \n-impl<'tcx, C> Lift<'tcx> for chalk_engine::ExClause<C>\n-where\n-    C: chalk_engine::context::Context + Clone,\n-    C: traits::ExClauseLift<'tcx>,\n-{\n-    type Lifted = C::LiftedExClause;\n-\n-    fn lift_to_tcx<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n-        <C as traits::ExClauseLift>::lift_ex_clause_to_tcx(self, tcx)\n-    }\n-}\n-\n EnumTypeFoldableImpl! {\n     impl<'tcx, C> TypeFoldable<'tcx> for chalk_engine::DelayedLiteral<C> {\n         (chalk_engine::DelayedLiteral::CannotProve)(a),"}]}