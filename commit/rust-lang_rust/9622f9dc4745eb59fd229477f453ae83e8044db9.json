{"sha": "9622f9dc4745eb59fd229477f453ae83e8044db9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk2MjJmOWRjNDc0NWViNTlmZDIyOTQ3N2Y0NTNhZTgzZTgwNDRkYjk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-12-20T12:42:54Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-12-20T12:42:54Z"}, "message": "Auto merge of #56647 - petrochenkov:dcrate2, r=alexcrichton\n\nRework treatment of `$crate` in procedural macros\n\nImportant clarification: `$crate` below means \"processed `$crate`\" or \"output `$crate`\". In the input of a decl macro `$crate` is just two separate tokens, but in the *output of a decl macro* `$crate` is a single keyword identifier (https://github.com/rust-lang/rust/issues/55640#issuecomment-435692791).\n\nFirst of all, this PR removes the `eliminate_crate_var` hack.\n`$crate::foo` is no longer replaced with `::foo` or `::crate_name::foo` in the input of derive proc macros, it's passed to the macro instead with its precise span and hygiene data, and can be treated as any other path segment keyword (like `crate` or `self`) after that. (Note: `eliminate_crate_var` was never used for non-derive proc macros.)\n\nThis creates an annoying problem - derive macros still may stringify their input before processing and expect `$crate` survive that stringification and refer to the same crate (the Rust 1.15-1.29 way of doing things).\nMoreover, the input of proc macro attributes and derives (but not fn-like proc macros) also effectively survives stringification before being passed to the macro (also for legacy implementation reasons).\n\nSo we kind of resurrect the `eliminate_crate_var` hack in reduced form, but apply it only to AST pretty-printing.\nIf an AST fragment is pretty-printed, the resulting *text* will have `$crate` replaced with `crate` or `::crate_name`. This should be enough to keep all the legacy cases working.\n\nCloses https://github.com/rust-lang/rust/issues/55640\nCloses https://github.com/rust-lang/rust/issues/56622\nr? @ghost", "tree": {"sha": "4d230e44e0f31c6c44a2728e4a1e89d513bfb441", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4d230e44e0f31c6c44a2728e4a1e89d513bfb441"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9622f9dc4745eb59fd229477f453ae83e8044db9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9622f9dc4745eb59fd229477f453ae83e8044db9", "html_url": "https://github.com/rust-lang/rust/commit/9622f9dc4745eb59fd229477f453ae83e8044db9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9622f9dc4745eb59fd229477f453ae83e8044db9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4755e2f3b635ad7391ba88b18672b05cbae5ba4c", "url": "https://api.github.com/repos/rust-lang/rust/commits/4755e2f3b635ad7391ba88b18672b05cbae5ba4c", "html_url": "https://github.com/rust-lang/rust/commit/4755e2f3b635ad7391ba88b18672b05cbae5ba4c"}, {"sha": "edab6c74923cacb3058fb7942577ad27e7cd32ff", "url": "https://api.github.com/repos/rust-lang/rust/commits/edab6c74923cacb3058fb7942577ad27e7cd32ff", "html_url": "https://github.com/rust-lang/rust/commit/edab6c74923cacb3058fb7942577ad27e7cd32ff"}], "stats": {"total": 676, "additions": 487, "deletions": 189}, "files": [{"sha": "ebba5c81fe077d455a931def3bb59bb53556591c", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9622f9dc4745eb59fd229477f453ae83e8044db9/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9622f9dc4745eb59fd229477f453ae83e8044db9/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=9622f9dc4745eb59fd229477f453ae83e8044db9", "patch": "@@ -729,11 +729,6 @@ impl Punct {\n     /// which can be further configured with the `set_span` method below.\n     #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     pub fn new(ch: char, spacing: Spacing) -> Punct {\n-        const LEGAL_CHARS: &[char] = &['=', '<', '>', '!', '~', '+', '-', '*', '/', '%', '^',\n-                                       '&', '|', '@', '.', ',', ';', ':', '#', '$', '?', '\\''];\n-        if !LEGAL_CHARS.contains(&ch) {\n-            panic!(\"unsupported character `{:?}`\", ch)\n-        }\n         Punct(bridge::client::Punct::new(ch, spacing))\n     }\n \n@@ -800,16 +795,6 @@ impl fmt::Debug for Punct {\n pub struct Ident(bridge::client::Ident);\n \n impl Ident {\n-    fn is_valid(string: &str) -> bool {\n-        let mut chars = string.chars();\n-        if let Some(start) = chars.next() {\n-            (start == '_' || start.is_xid_start())\n-                && chars.all(|cont| cont == '_' || cont.is_xid_continue())\n-        } else {\n-            false\n-        }\n-    }\n-\n     /// Creates a new `Ident` with the given `string` as well as the specified\n     /// `span`.\n     /// The `string` argument must be a valid identifier permitted by the\n@@ -831,18 +816,12 @@ impl Ident {\n     /// tokens, requires a `Span` to be specified at construction.\n     #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     pub fn new(string: &str, span: Span) -> Ident {\n-        if !Ident::is_valid(string) {\n-            panic!(\"`{:?}` is not a valid identifier\", string)\n-        }\n         Ident(bridge::client::Ident::new(string, span.0, false))\n     }\n \n     /// Same as `Ident::new`, but creates a raw identifier (`r#ident`).\n     #[unstable(feature = \"proc_macro_raw_ident\", issue = \"54723\")]\n     pub fn new_raw(string: &str, span: Span) -> Ident {\n-        if !Ident::is_valid(string) {\n-            panic!(\"`{:?}` is not a valid identifier\", string)\n-        }\n         Ident(bridge::client::Ident::new(string, span.0, true))\n     }\n "}, {"sha": "5c6845181afd19725f6f7132cfc58455dbefd8d6", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9622f9dc4745eb59fd229477f453ae83e8044db9/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9622f9dc4745eb59fd229477f453ae83e8044db9/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=9622f9dc4745eb59fd229477f453ae83e8044db9", "patch": "@@ -1622,8 +1622,7 @@ impl<'a> State<'a> {\n             if i > 0 {\n                 self.s.word(\"::\")?\n             }\n-            if segment.ident.name != keywords::PathRoot.name() &&\n-               segment.ident.name != keywords::DollarCrate.name() {\n+            if segment.ident.name != keywords::PathRoot.name() {\n                self.print_ident(segment.ident)?;\n                segment.with_generic_args(|generic_args| {\n                    self.print_generic_args(generic_args, segment.infer_types,\n@@ -1636,8 +1635,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_path_segment(&mut self, segment: &hir::PathSegment) -> io::Result<()> {\n-        if segment.ident.name != keywords::PathRoot.name() &&\n-           segment.ident.name != keywords::DollarCrate.name() {\n+        if segment.ident.name != keywords::PathRoot.name() {\n            self.print_ident(segment.ident)?;\n            segment.with_generic_args(|generic_args| {\n                self.print_generic_args(generic_args, segment.infer_types, false)\n@@ -1664,8 +1662,7 @@ impl<'a> State<'a> {\n                     if i > 0 {\n                         self.s.word(\"::\")?\n                     }\n-                    if segment.ident.name != keywords::PathRoot.name() &&\n-                       segment.ident.name != keywords::DollarCrate.name() {\n+                    if segment.ident.name != keywords::PathRoot.name() {\n                         self.print_ident(segment.ident)?;\n                         segment.with_generic_args(|generic_args| {\n                             self.print_generic_args(generic_args,"}, {"sha": "6cfa9f95082e0829e3c8d06429eea73bb20d509f", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9622f9dc4745eb59fd229477f453ae83e8044db9/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9622f9dc4745eb59fd229477f453ae83e8044db9/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=9622f9dc4745eb59fd229477f453ae83e8044db9", "patch": "@@ -1035,4 +1035,15 @@ impl<'a, 'b> Visitor<'a> for BuildReducedGraphVisitor<'a, 'b> {\n         }\n         visit::walk_attribute(self, attr);\n     }\n+\n+    fn visit_ident(&mut self, ident: Ident) {\n+        if ident.name == keywords::DollarCrate.name() {\n+            let name = match self.resolver.resolve_crate_root(ident).kind {\n+                ModuleKind::Def(_, name) if name != keywords::Invalid.name() => name,\n+                _ => keywords::Crate.name(),\n+            };\n+            ident.span.ctxt().set_dollar_crate_name(name);\n+        }\n+        visit::walk_ident(self, ident);\n+    }\n }"}, {"sha": "794e5741d62ca42265c1645dcc3e77e1f7633f35", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9622f9dc4745eb59fd229477f453ae83e8044db9/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9622f9dc4745eb59fd229477f453ae83e8044db9/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=9622f9dc4745eb59fd229477f453ae83e8044db9", "patch": "@@ -1173,10 +1173,6 @@ impl<'a> ModuleData<'a> {\n         }\n     }\n \n-    fn is_local(&self) -> bool {\n-        self.normal_ancestor_id.is_local()\n-    }\n-\n     fn nearest_item_scope(&'a self) -> Module<'a> {\n         if self.is_trait() { self.parent.unwrap() } else { self }\n     }"}, {"sha": "81633c8f57f9e73dac3ddd83b09aa20f460ce983", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 1, "deletions": 56, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/9622f9dc4745eb59fd229477f453ae83e8044db9/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9622f9dc4745eb59fd229477f453ae83e8044db9/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=9622f9dc4745eb59fd229477f453ae83e8044db9", "patch": "@@ -10,7 +10,7 @@\n \n use {AmbiguityError, AmbiguityKind, AmbiguityErrorMisc};\n use {CrateLint, Resolver, ResolutionError, ScopeSet, Weak};\n-use {Module, ModuleKind, NameBinding, NameBindingKind, PathResult, Segment, ToNameBinding};\n+use {Module, NameBinding, NameBindingKind, PathResult, Segment, ToNameBinding};\n use {is_known_tool, resolve_error};\n use ModuleOrUniformRoot;\n use Namespace::*;\n@@ -30,8 +30,6 @@ use syntax::ext::expand::{AstFragment, Invocation, InvocationKind};\n use syntax::ext::hygiene::{self, Mark};\n use syntax::ext::tt::macro_rules;\n use syntax::feature_gate::{feature_err, is_builtin_attr_name, GateIssue};\n-use syntax::fold::{self, Folder};\n-use syntax::ptr::P;\n use syntax::symbol::{Symbol, keywords};\n use syntax::util::lev_distance::find_best_match_for_name;\n use syntax_pos::{Span, DUMMY_SP};\n@@ -138,58 +136,6 @@ impl<'a> base::Resolver for Resolver<'a> {\n         mark\n     }\n \n-    fn eliminate_crate_var(&mut self, item: P<ast::Item>) -> P<ast::Item> {\n-        struct EliminateCrateVar<'b, 'a: 'b>(\n-            &'b mut Resolver<'a>, Span\n-        );\n-\n-        impl<'a, 'b> Folder for EliminateCrateVar<'a, 'b> {\n-            fn fold_path(&mut self, path: ast::Path) -> ast::Path {\n-                match self.fold_qpath(None, path) {\n-                    (None, path) => path,\n-                    _ => unreachable!(),\n-                }\n-            }\n-\n-            fn fold_qpath(&mut self, mut qself: Option<ast::QSelf>, mut path: ast::Path)\n-                          -> (Option<ast::QSelf>, ast::Path) {\n-                qself = qself.map(|ast::QSelf { ty, path_span, position }| {\n-                    ast::QSelf {\n-                        ty: self.fold_ty(ty),\n-                        path_span: self.new_span(path_span),\n-                        position,\n-                    }\n-                });\n-\n-                if path.segments[0].ident.name == keywords::DollarCrate.name() {\n-                    let module = self.0.resolve_crate_root(path.segments[0].ident);\n-                    path.segments[0].ident.name = keywords::PathRoot.name();\n-                    if !module.is_local() {\n-                        let span = path.segments[0].ident.span;\n-                        path.segments.insert(1, match module.kind {\n-                            ModuleKind::Def(_, name) => ast::PathSegment::from_ident(\n-                                ast::Ident::with_empty_ctxt(name).with_span_pos(span)\n-                            ),\n-                            _ => unreachable!(),\n-                        });\n-                        if let Some(qself) = &mut qself {\n-                            qself.position += 1;\n-                        }\n-                    }\n-                }\n-                (qself, path)\n-            }\n-\n-            fn fold_mac(&mut self, mac: ast::Mac) -> ast::Mac {\n-                fold::noop_fold_mac(mac, self)\n-            }\n-        }\n-\n-        let ret = EliminateCrateVar(self, item.span).fold_item(item);\n-        assert!(ret.len() == 1);\n-        ret.into_iter().next().unwrap()\n-    }\n-\n     fn visit_ast_fragment_with_placeholders(&mut self, mark: Mark, fragment: &AstFragment,\n                                             derives: &[Mark]) {\n         let invocation = self.invocations[&mark];\n@@ -259,7 +205,6 @@ impl<'a> base::Resolver for Resolver<'a> {\n             self.definitions.add_parent_module_of_macro_def(invoc.expansion_data.mark,\n                                                             normal_module_def_id);\n             invoc.expansion_data.mark.set_default_transparency(ext.default_transparency());\n-            invoc.expansion_data.mark.set_is_builtin(def_id.krate == CrateNum::BuiltinMacros);\n         }\n \n         Ok(Some(ext))"}, {"sha": "b807a65f6aed60d86d63b27274a38a85cf78bedf", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9622f9dc4745eb59fd229477f453ae83e8044db9/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9622f9dc4745eb59fd229477f453ae83e8044db9/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=9622f9dc4745eb59fd229477f453ae83e8044db9", "patch": "@@ -732,7 +732,6 @@ pub type NamedSyntaxExtension = (Name, SyntaxExtension);\n pub trait Resolver {\n     fn next_node_id(&mut self) -> ast::NodeId;\n     fn get_module_scope(&mut self, id: ast::NodeId) -> Mark;\n-    fn eliminate_crate_var(&mut self, item: P<ast::Item>) -> P<ast::Item>;\n \n     fn visit_ast_fragment_with_placeholders(&mut self, mark: Mark, fragment: &AstFragment,\n                                             derives: &[Mark]);\n@@ -766,7 +765,6 @@ pub struct DummyResolver;\n impl Resolver for DummyResolver {\n     fn next_node_id(&mut self) -> ast::NodeId { ast::DUMMY_NODE_ID }\n     fn get_module_scope(&mut self, _id: ast::NodeId) -> Mark { Mark::root() }\n-    fn eliminate_crate_var(&mut self, item: P<ast::Item>) -> P<ast::Item> { item }\n \n     fn visit_ast_fragment_with_placeholders(&mut self, _invoc: Mark, _fragment: &AstFragment,\n                                             _derives: &[Mark]) {}"}, {"sha": "57ccc3e981720a7dede977a971dc7a3ef73c7f7c", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9622f9dc4745eb59fd229477f453ae83e8044db9/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9622f9dc4745eb59fd229477f453ae83e8044db9/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=9622f9dc4745eb59fd229477f453ae83e8044db9", "patch": "@@ -203,10 +203,7 @@ fn macro_bang_format(path: &ast::Path) -> ExpnFormat {\n         if i != 0 {\n             path_str.push_str(\"::\");\n         }\n-\n-        if segment.ident.name != keywords::PathRoot.name() &&\n-            segment.ident.name != keywords::DollarCrate.name()\n-        {\n+        if segment.ident.name != keywords::PathRoot.name() {\n             path_str.push_str(&segment.ident.as_str())\n         }\n     }"}, {"sha": "badcc4ed8762d10e63f3492b2a1906417e07ad35", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9622f9dc4745eb59fd229477f453ae83e8044db9/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9622f9dc4745eb59fd229477f453ae83e8044db9/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=9622f9dc4745eb59fd229477f453ae83e8044db9", "patch": "@@ -633,7 +633,9 @@ impl Token {\n             (&Shebang(a), &Shebang(b)) => a == b,\n \n             (&Lifetime(a), &Lifetime(b)) => a.name == b.name,\n-            (&Ident(a, b), &Ident(c, d)) => a.name == c.name && b == d,\n+            (&Ident(a, b), &Ident(c, d)) => b == d && (a.name == c.name ||\n+                                                       a.name == keywords::DollarCrate.name() ||\n+                                                       c.name == keywords::DollarCrate.name()),\n \n             (&Literal(ref a, b), &Literal(ref c, d)) => {\n                 b == d && a.probably_equal_for_proc_macro(c)"}, {"sha": "5e7707f4e5c3c4dc45bae63b9238a3201b20281f", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 24, "deletions": 22, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/9622f9dc4745eb59fd229477f453ae83e8044db9/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9622f9dc4745eb59fd229477f453ae83e8044db9/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=9622f9dc4745eb59fd229477f453ae83e8044db9", "patch": "@@ -16,7 +16,6 @@ use util::parser::{self, AssocOp, Fixity};\n use attr;\n use source_map::{self, SourceMap, Spanned};\n use syntax_pos::{self, BytePos};\n-use syntax_pos::hygiene::{Mark, SyntaxContext};\n use parse::token::{self, BinOpToken, Token};\n use parse::lexer::comments;\n use parse::{self, ParseSess};\n@@ -724,12 +723,12 @@ pub trait PrintState<'a> {\n             if i > 0 {\n                 self.writer().word(\"::\")?\n             }\n-            if segment.ident.name != keywords::PathRoot.name() &&\n-               segment.ident.name != keywords::DollarCrate.name()\n-            {\n-                self.writer().word(segment.ident.as_str().get())?;\n-            } else if segment.ident.name == keywords::DollarCrate.name() {\n-                self.print_dollar_crate(segment.ident.span.ctxt())?;\n+            if segment.ident.name != keywords::PathRoot.name() {\n+                if segment.ident.name == keywords::DollarCrate.name() {\n+                    self.print_dollar_crate(segment.ident)?;\n+                } else {\n+                    self.writer().word(segment.ident.as_str().get())?;\n+                }\n             }\n         }\n         Ok(())\n@@ -843,17 +842,19 @@ pub trait PrintState<'a> {\n \n     fn nbsp(&mut self) -> io::Result<()> { self.writer().word(\" \") }\n \n-    fn print_dollar_crate(&mut self, mut ctxt: SyntaxContext) -> io::Result<()> {\n-        if let Some(mark) = ctxt.adjust(Mark::root()) {\n-            // Make a best effort to print something that complies\n-            if mark.is_builtin() {\n-                if let Some(name) = std_inject::injected_crate_name() {\n-                    self.writer().word(\"::\")?;\n-                    self.writer().word(name)?;\n-                }\n-            }\n+    // AST pretty-printer is used as a fallback for turning AST structures into token streams for\n+    // proc macros. Additionally, proc macros may stringify their input and expect it survive the\n+    // stringification (especially true for proc macro derives written between Rust 1.15 and 1.30).\n+    // So we need to somehow pretty-print `$crate` in paths in a way preserving at least some of\n+    // its hygiene data, most importantly name of the crate it refers to.\n+    // As a result we print `$crate` as `crate` if it refers to the local crate\n+    // and as `::other_crate_name` if it refers to some other crate.\n+    fn print_dollar_crate(&mut self, ident: ast::Ident) -> io::Result<()> {\n+        let name = ident.span.ctxt().dollar_crate_name();\n+        if !ast::Ident::with_empty_ctxt(name).is_path_segment_keyword() {\n+            self.writer().word(\"::\")?;\n         }\n-        Ok(())\n+        self.writer().word(name.as_str().get())\n     }\n }\n \n@@ -2463,14 +2464,15 @@ impl<'a> State<'a> {\n                           colons_before_params: bool)\n                           -> io::Result<()>\n     {\n-        if segment.ident.name != keywords::PathRoot.name() &&\n-           segment.ident.name != keywords::DollarCrate.name() {\n-            self.print_ident(segment.ident)?;\n+        if segment.ident.name != keywords::PathRoot.name() {\n+            if segment.ident.name == keywords::DollarCrate.name() {\n+                self.print_dollar_crate(segment.ident)?;\n+            } else {\n+                self.print_ident(segment.ident)?;\n+            }\n             if let Some(ref args) = segment.args {\n                 self.print_generic_args(args, colons_before_params)?;\n             }\n-        } else if segment.ident.name == keywords::DollarCrate.name() {\n-            self.print_dollar_crate(segment.ident.span.ctxt())?;\n         }\n         Ok(())\n     }"}, {"sha": "013ecd3d343c28c6c0422db40938956421e2e912", "filename": "src/libsyntax/tokenstream.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9622f9dc4745eb59fd229477f453ae83e8044db9/src%2Flibsyntax%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9622f9dc4745eb59fd229477f453ae83e8044db9/src%2Flibsyntax%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftokenstream.rs?ref=9622f9dc4745eb59fd229477f453ae83e8044db9", "patch": "@@ -348,7 +348,9 @@ impl TokenStream {\n                 | TokenTree::Token(_, Token::Semi)\n                 // The pretty printer collapses whitespace arbitrarily and can\n                 // introduce whitespace from `NoDelim`.\n-                | TokenTree::Token(_, Token::Whitespace) => false,\n+                | TokenTree::Token(_, Token::Whitespace)\n+                // The pretty printer can turn `$crate` into `::crate_name`\n+                | TokenTree::Token(_, Token::ModSep) => false,\n                 _ => true\n             }\n         }"}, {"sha": "cc2fa68568713283ef2d78df097aecc6107ca4ab", "filename": "src/libsyntax_ext/deriving/custom.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9622f9dc4745eb59fd229477f453ae83e8044db9/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9622f9dc4745eb59fd229477f453ae83e8044db9/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs?ref=9622f9dc4745eb59fd229477f453ae83e8044db9", "patch": "@@ -74,7 +74,6 @@ impl MultiItemModifier for ProcMacroDerive {\n         // Mark attributes as known, and used.\n         MarkAttrs(&self.attrs).visit_item(&item);\n \n-        let item = ecx.resolver.eliminate_crate_var(item);\n         let token = Token::interpolated(token::NtItem(item));\n         let input = tokenstream::TokenTree::Token(DUMMY_SP, token).into();\n "}, {"sha": "ca960cbe41b5d288a7e78aa3a590aa4f122f52dd", "filename": "src/libsyntax_ext/proc_macro_server.rs", "status": "modified", "additions": 62, "deletions": 51, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/9622f9dc4745eb59fd229477f453ae83e8044db9/src%2Flibsyntax_ext%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9622f9dc4745eb59fd229477f453ae83e8044db9/src%2Flibsyntax_ext%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_server.rs?ref=9622f9dc4745eb59fd229477f453ae83e8044db9", "patch": "@@ -81,29 +81,23 @@ impl FromInternal<(TokenStream, &'_ ParseSess, &'_ mut Vec<Self>)>\n                     $($field $(: $value)*,)*\n                     span,\n                 })\n-            )\n+            );\n+            ($ty:ident::$method:ident($($value:expr),*)) => (\n+                TokenTree::$ty(self::$ty::$method($($value,)* span))\n+            );\n         }\n         macro_rules! op {\n             ($a:expr) => {\n-                tt!(Punct { ch: $a, joint })\n+                tt!(Punct::new($a, joint))\n             };\n             ($a:expr, $b:expr) => {{\n-                stack.push(tt!(Punct { ch: $b, joint }));\n-                tt!(Punct {\n-                    ch: $a,\n-                    joint: true\n-                })\n+                stack.push(tt!(Punct::new($b, joint)));\n+                tt!(Punct::new($a, true))\n             }};\n             ($a:expr, $b:expr, $c:expr) => {{\n-                stack.push(tt!(Punct { ch: $c, joint }));\n-                stack.push(tt!(Punct {\n-                    ch: $b,\n-                    joint: true\n-                }));\n-                tt!(Punct {\n-                    ch: $a,\n-                    joint: true\n-                })\n+                stack.push(tt!(Punct::new($c, joint)));\n+                stack.push(tt!(Punct::new($b, true)));\n+                tt!(Punct::new($a, true))\n             }};\n         }\n \n@@ -156,20 +150,13 @@ impl FromInternal<(TokenStream, &'_ ParseSess, &'_ mut Vec<Self>)>\n             Question => op!('?'),\n             SingleQuote => op!('\\''),\n \n-            Ident(ident, is_raw) => tt!(Ident {\n-                sym: ident.name,\n-                is_raw\n-            }),\n+            Ident(ident, false) if ident.name == keywords::DollarCrate.name() =>\n+                tt!(Ident::dollar_crate()),\n+            Ident(ident, is_raw) => tt!(Ident::new(ident.name, is_raw)),\n             Lifetime(ident) => {\n                 let ident = ident.without_first_quote();\n-                stack.push(tt!(Ident {\n-                    sym: ident.name,\n-                    is_raw: false\n-                }));\n-                tt!(Punct {\n-                    ch: '\\'',\n-                    joint: true\n-                })\n+                stack.push(tt!(Ident::new(ident.name, false)));\n+                tt!(Punct::new('\\'', true))\n             }\n             Literal(lit, suffix) => tt!(Literal { lit, suffix }),\n             DocComment(c) => {\n@@ -193,15 +180,9 @@ impl FromInternal<(TokenStream, &'_ ParseSess, &'_ mut Vec<Self>)>\n                     span: DelimSpan::from_single(span),\n                 }));\n                 if style == ast::AttrStyle::Inner {\n-                    stack.push(tt!(Punct {\n-                        ch: '!',\n-                        joint: false\n-                    }));\n+                    stack.push(tt!(Punct::new('!', false)));\n                 }\n-                tt!(Punct {\n-                    ch: '#',\n-                    joint: false\n-                })\n+                tt!(Punct::new('#', false))\n             }\n \n             Interpolated(_) => {\n@@ -237,7 +218,7 @@ impl ToInternal<TokenStream> for TokenTree<Group, Punct, Ident, Literal> {\n                 )\n                 .into();\n             }\n-            TokenTree::Ident(self::Ident { sym, span, is_raw }) => {\n+            TokenTree::Ident(self::Ident { sym, is_raw, span }) => {\n                 let token = Ident(ast::Ident::new(sym, span), is_raw);\n                 return tokenstream::TokenTree::Token(span, token).into();\n             }\n@@ -338,11 +319,52 @@ pub struct Punct {\n     span: Span,\n }\n \n+impl Punct {\n+    fn new(ch: char, joint: bool, span: Span) -> Punct {\n+        const LEGAL_CHARS: &[char] = &['=', '<', '>', '!', '~', '+', '-', '*', '/', '%', '^',\n+                                       '&', '|', '@', '.', ',', ';', ':', '#', '$', '?', '\\''];\n+        if !LEGAL_CHARS.contains(&ch) {\n+            panic!(\"unsupported character `{:?}`\", ch)\n+        }\n+        Punct { ch, joint, span }\n+    }\n+}\n+\n #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n pub struct Ident {\n     sym: Symbol,\n-    span: Span,\n     is_raw: bool,\n+    span: Span,\n+}\n+\n+impl Ident {\n+    fn is_valid(string: &str) -> bool {\n+        let mut chars = string.chars();\n+        if let Some(start) = chars.next() {\n+            (start == '_' || start.is_xid_start())\n+                && chars.all(|cont| cont == '_' || cont.is_xid_continue())\n+        } else {\n+            false\n+        }\n+    }\n+    fn new(sym: Symbol, is_raw: bool, span: Span) -> Ident {\n+        let string = sym.as_str().get();\n+        if !Self::is_valid(string) {\n+            panic!(\"`{:?}` is not a valid identifier\", string)\n+        }\n+        if is_raw {\n+            let normalized_sym = Symbol::intern(string);\n+            if normalized_sym == keywords::Underscore.name() ||\n+               ast::Ident::with_empty_ctxt(normalized_sym).is_path_segment_keyword() {\n+                panic!(\"`{:?}` is not a valid raw identifier\", string)\n+            }\n+        }\n+        Ident { sym, is_raw, span }\n+    }\n+    fn dollar_crate(span: Span) -> Ident {\n+        // `$crate` is accepted as an ident only if it comes from the compiler.\n+        Ident { sym: keywords::DollarCrate.name(), is_raw: false, span }\n+    }\n }\n \n // FIXME(eddyb) `Literal` should not expose internal `Debug` impls.\n@@ -492,11 +514,7 @@ impl server::Group for Rustc<'_> {\n \n impl server::Punct for Rustc<'_> {\n     fn new(&mut self, ch: char, spacing: Spacing) -> Self::Punct {\n-        Punct {\n-            ch,\n-            joint: spacing == Spacing::Joint,\n-            span: server::Span::call_site(self),\n-        }\n+        Punct::new(ch, spacing == Spacing::Joint, server::Span::call_site(self))\n     }\n     fn as_char(&mut self, punct: Self::Punct) -> char {\n         punct.ch\n@@ -518,14 +536,7 @@ impl server::Punct for Rustc<'_> {\n \n impl server::Ident for Rustc<'_> {\n     fn new(&mut self, string: &str, span: Self::Span, is_raw: bool) -> Self::Ident {\n-        let sym = Symbol::intern(string);\n-        if is_raw\n-            && (sym == keywords::Underscore.name()\n-                || ast::Ident::with_empty_ctxt(sym).is_path_segment_keyword())\n-        {\n-            panic!(\"`{:?}` is not a valid raw identifier\", string)\n-        }\n-        Ident { sym, span, is_raw }\n+        Ident::new(Symbol::intern(string), is_raw, span)\n     }\n     fn span(&mut self, ident: Self::Ident) -> Self::Span {\n         ident.span"}, {"sha": "3dc884a94c0dc200be3bd9b4410b895777a79bf6", "filename": "src/libsyntax_pos/hygiene.rs", "status": "modified", "additions": 24, "deletions": 18, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/9622f9dc4745eb59fd229477f453ae83e8044db9/src%2Flibsyntax_pos%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9622f9dc4745eb59fd229477f453ae83e8044db9/src%2Flibsyntax_pos%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fhygiene.rs?ref=9622f9dc4745eb59fd229477f453ae83e8044db9", "patch": "@@ -18,11 +18,11 @@\n use GLOBALS;\n use Span;\n use edition::{Edition, DEFAULT_EDITION};\n-use symbol::Symbol;\n+use symbol::{keywords, Symbol};\n \n use serialize::{Encodable, Decodable, Encoder, Decoder};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use std::fmt;\n+use std::{fmt, mem};\n \n /// A SyntaxContext represents a chain of macro expansions (represented by marks).\n #[derive(Clone, Copy, PartialEq, Eq, Default, PartialOrd, Ord, Hash)]\n@@ -37,6 +37,8 @@ struct SyntaxContextData {\n     opaque: SyntaxContext,\n     // This context, but with all transparent marks filtered away.\n     opaque_and_semitransparent: SyntaxContext,\n+    // Name of the crate to which `$crate` with this context would resolve.\n+    dollar_crate_name: Symbol,\n }\n \n /// A mark is a unique id associated with a macro expansion.\n@@ -47,7 +49,6 @@ pub struct Mark(u32);\n struct MarkData {\n     parent: Mark,\n     default_transparency: Transparency,\n-    is_builtin: bool,\n     expn_info: Option<ExpnInfo>,\n }\n \n@@ -77,7 +78,6 @@ impl Mark {\n                 parent,\n                 // By default expansions behave like `macro_rules`.\n                 default_transparency: Transparency::SemiTransparent,\n-                is_builtin: false,\n                 expn_info: None,\n             });\n             Mark(data.marks.len() as u32 - 1)\n@@ -121,18 +121,6 @@ impl Mark {\n         HygieneData::with(|data| data.marks[self.0 as usize].default_transparency = transparency)\n     }\n \n-    #[inline]\n-    pub fn is_builtin(self) -> bool {\n-        assert_ne!(self, Mark::root());\n-        HygieneData::with(|data| data.marks[self.0 as usize].is_builtin)\n-    }\n-\n-    #[inline]\n-    pub fn set_is_builtin(self, is_builtin: bool) {\n-        assert_ne!(self, Mark::root());\n-        HygieneData::with(|data| data.marks[self.0 as usize].is_builtin = is_builtin)\n-    }\n-\n     pub fn is_descendant_of(mut self, ancestor: Mark) -> bool {\n         HygieneData::with(|data| {\n             while self != ancestor {\n@@ -206,7 +194,6 @@ impl HygieneData {\n                 // If the root is opaque, then loops searching for an opaque mark\n                 // will automatically stop after reaching it.\n                 default_transparency: Transparency::Opaque,\n-                is_builtin: true,\n                 expn_info: None,\n             }],\n             syntax_contexts: vec![SyntaxContextData {\n@@ -215,6 +202,7 @@ impl HygieneData {\n                 prev_ctxt: SyntaxContext(0),\n                 opaque: SyntaxContext(0),\n                 opaque_and_semitransparent: SyntaxContext(0),\n+                dollar_crate_name: keywords::DollarCrate.name(),\n             }],\n             markings: FxHashMap::default(),\n             default_edition: DEFAULT_EDITION,\n@@ -262,7 +250,6 @@ impl SyntaxContext {\n             data.marks.push(MarkData {\n                 parent: Mark::root(),\n                 default_transparency: Transparency::SemiTransparent,\n-                is_builtin: false,\n                 expn_info: Some(expansion_info),\n             });\n \n@@ -274,6 +261,7 @@ impl SyntaxContext {\n                 prev_ctxt: SyntaxContext::empty(),\n                 opaque: SyntaxContext::empty(),\n                 opaque_and_semitransparent: SyntaxContext::empty(),\n+                dollar_crate_name: keywords::DollarCrate.name(),\n             });\n             SyntaxContext(data.syntax_contexts.len() as u32 - 1)\n         })\n@@ -340,6 +328,7 @@ impl SyntaxContext {\n                         prev_ctxt,\n                         opaque: new_opaque,\n                         opaque_and_semitransparent: new_opaque,\n+                        dollar_crate_name: keywords::DollarCrate.name(),\n                     });\n                     new_opaque\n                 });\n@@ -357,6 +346,7 @@ impl SyntaxContext {\n                         prev_ctxt,\n                         opaque,\n                         opaque_and_semitransparent: new_opaque_and_semitransparent,\n+                        dollar_crate_name: keywords::DollarCrate.name(),\n                     });\n                     new_opaque_and_semitransparent\n                 });\n@@ -372,6 +362,7 @@ impl SyntaxContext {\n                     prev_ctxt,\n                     opaque,\n                     opaque_and_semitransparent,\n+                    dollar_crate_name: keywords::DollarCrate.name(),\n                 });\n                 new_opaque_and_semitransparent_and_transparent\n             })\n@@ -526,6 +517,21 @@ impl SyntaxContext {\n     pub fn outer(self) -> Mark {\n         HygieneData::with(|data| data.syntax_contexts[self.0 as usize].outer_mark)\n     }\n+\n+    pub fn dollar_crate_name(self) -> Symbol {\n+        HygieneData::with(|data| data.syntax_contexts[self.0 as usize].dollar_crate_name)\n+    }\n+\n+    pub fn set_dollar_crate_name(self, dollar_crate_name: Symbol) {\n+        HygieneData::with(|data| {\n+            let prev_dollar_crate_name = mem::replace(\n+                &mut data.syntax_contexts[self.0 as usize].dollar_crate_name, dollar_crate_name\n+            );\n+            assert!(dollar_crate_name == prev_dollar_crate_name ||\n+                    prev_dollar_crate_name == keywords::DollarCrate.name(),\n+                    \"$crate name is reset for a syntax context\");\n+        })\n+    }\n }\n \n impl fmt::Debug for SyntaxContext {"}, {"sha": "3b01ab3a47b6a30ada6d0ac8dc2d936d208f7dda", "filename": "src/test/pretty/issue-4264.pp", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9622f9dc4745eb59fd229477f453ae83e8044db9/src%2Ftest%2Fpretty%2Fissue-4264.pp", "raw_url": "https://github.com/rust-lang/rust/raw/9622f9dc4745eb59fd229477f453ae83e8044db9/src%2Ftest%2Fpretty%2Fissue-4264.pp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fissue-4264.pp?ref=9622f9dc4745eb59fd229477f453ae83e8044db9", "patch": "@@ -39,8 +39,8 @@\n \n \n \n-                  ((::fmt::format as\n-                       for<'r> fn(std::fmt::Arguments<'r>) -> std::string::String {std::fmt::format})(((<::fmt::Arguments>::new_v1\n+                  (($crate::fmt::format as\n+                       for<'r> fn(std::fmt::Arguments<'r>) -> std::string::String {std::fmt::format})(((<$crate::fmt::Arguments>::new_v1\n                                                                                                            as\n                                                                                                            fn(&[&str], &[std::fmt::ArgumentV1<'_>]) -> std::fmt::Arguments<'_> {std::fmt::Arguments<'_>::new_v1})((&([(\"test\"\n                                                                                                                                                                                                                           as"}, {"sha": "8f15a2b975bf342567e64c121c7cdd3cfac4b0f3", "filename": "src/test/ui/proc-macro/auxiliary/dollar-crate-external.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9622f9dc4745eb59fd229477f453ae83e8044db9/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fdollar-crate-external.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9622f9dc4745eb59fd229477f453ae83e8044db9/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fdollar-crate-external.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fdollar-crate-external.rs?ref=9622f9dc4745eb59fd229477f453ae83e8044db9", "patch": "@@ -0,0 +1,16 @@\n+pub type S = u8;\n+\n+#[macro_export]\n+macro_rules! external {\n+    () => {\n+        dollar_crate::m! {\n+            struct M($crate::S);\n+        }\n+\n+        #[dollar_crate::a]\n+        struct A($crate::S);\n+\n+        #[derive(dollar_crate::d)]\n+        struct D($crate::S);\n+    };\n+}"}, {"sha": "d0ea850d4e3231a07e048d0c3e4b36b087907062", "filename": "src/test/ui/proc-macro/auxiliary/dollar-crate.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/9622f9dc4745eb59fd229477f453ae83e8044db9/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fdollar-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9622f9dc4745eb59fd229477f453ae83e8044db9/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fdollar-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fdollar-crate.rs?ref=9622f9dc4745eb59fd229477f453ae83e8044db9", "patch": "@@ -0,0 +1,28 @@\n+// force-host\n+// no-prefer-dynamic\n+\n+#![crate_type = \"proc-macro\"]\n+\n+extern crate proc_macro;\n+use proc_macro::TokenStream;\n+\n+#[proc_macro]\n+pub fn m(input: TokenStream) -> TokenStream {\n+    println!(\"PROC MACRO INPUT (PRETTY-PRINTED): {}\", input);\n+    println!(\"PROC MACRO INPUT: {:#?}\", input);\n+    input.into_iter().collect()\n+}\n+\n+#[proc_macro_attribute]\n+pub fn a(_args: TokenStream, input: TokenStream) -> TokenStream {\n+    println!(\"ATTRIBUTE INPUT (PRETTY-PRINTED): {}\", input);\n+    println!(\"ATTRIBUTE INPUT: {:#?}\", input);\n+    input.into_iter().collect()\n+}\n+\n+#[proc_macro_derive(d)]\n+pub fn d(input: TokenStream) -> TokenStream {\n+    println!(\"DERIVE INPUT (PRETTY-PRINTED): {}\", input);\n+    println!(\"DERIVE INPUT: {:#?}\", input);\n+    input.into_iter().collect()\n+}"}, {"sha": "1460e9a3b2d55ab988a73ee675d9ccd313cd66a9", "filename": "src/test/ui/proc-macro/dollar-crate.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/9622f9dc4745eb59fd229477f453ae83e8044db9/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9622f9dc4745eb59fd229477f453ae83e8044db9/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate.rs?ref=9622f9dc4745eb59fd229477f453ae83e8044db9", "patch": "@@ -0,0 +1,40 @@\n+// edition:2018\n+// aux-build:dollar-crate.rs\n+// aux-build:dollar-crate-external.rs\n+\n+// Anonymize unstable non-dummy spans while still showing dummy spans `0..0`.\n+// normalize-stdout-test \"bytes\\([^0]\\w*\\.\\.(\\w+)\\)\" -> \"bytes(LO..$1)\"\n+// normalize-stdout-test \"bytes\\((\\w+)\\.\\.[^0]\\w*\\)\" -> \"bytes($1..HI)\"\n+\n+extern crate dollar_crate;\n+extern crate dollar_crate_external;\n+\n+type S = u8;\n+\n+mod local {\n+    use crate::dollar_crate;\n+\n+    macro_rules! local {\n+        () => {\n+            dollar_crate::m! {\n+                struct M($crate::S);\n+            }\n+\n+            #[dollar_crate::a]\n+            struct A($crate::S);\n+\n+            #[derive(dollar_crate::d)]\n+            struct D($crate::S); //~ ERROR the name `D` is defined multiple times\n+        };\n+    }\n+\n+    local!();\n+}\n+\n+mod external {\n+    use crate::dollar_crate_external;\n+\n+    dollar_crate_external::external!(); //~ ERROR the name `D` is defined multiple times\n+}\n+\n+fn main() {}"}, {"sha": "08de3c7d1a6664be06880b3e249406ee58b6efad", "filename": "src/test/ui/proc-macro/dollar-crate.stderr", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/9622f9dc4745eb59fd229477f453ae83e8044db9/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9622f9dc4745eb59fd229477f453ae83e8044db9/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate.stderr?ref=9622f9dc4745eb59fd229477f453ae83e8044db9", "patch": "@@ -0,0 +1,29 @@\n+error[E0428]: the name `D` is defined multiple times\n+  --> $DIR/dollar-crate.rs:27:13\n+   |\n+LL |             struct D($crate::S); //~ ERROR the name `D` is defined multiple times\n+   |             ^^^^^^^^^^^^^^^^^^^^\n+   |             |\n+   |             `D` redefined here\n+   |             previous definition of the type `D` here\n+...\n+LL |     local!();\n+   |     --------- in this macro invocation\n+   |\n+   = note: `D` must be defined only once in the type namespace of this module\n+\n+error[E0428]: the name `D` is defined multiple times\n+  --> $DIR/dollar-crate.rs:37:5\n+   |\n+LL |     dollar_crate_external::external!(); //~ ERROR the name `D` is defined multiple times\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |     |\n+   |     `D` redefined here\n+   |     previous definition of the type `D` here\n+   |\n+   = note: `D` must be defined only once in the type namespace of this module\n+   = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0428`."}, {"sha": "c47b3603f41c033fc1ac052168b51149322717f1", "filename": "src/test/ui/proc-macro/dollar-crate.stdout", "status": "added", "additions": 240, "deletions": 0, "changes": 240, "blob_url": "https://github.com/rust-lang/rust/blob/9622f9dc4745eb59fd229477f453ae83e8044db9/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/9622f9dc4745eb59fd229477f453ae83e8044db9/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate.stdout?ref=9622f9dc4745eb59fd229477f453ae83e8044db9", "patch": "@@ -0,0 +1,240 @@\n+PROC MACRO INPUT (PRETTY-PRINTED): struct M ( $crate :: S ) ;\n+PROC MACRO INPUT: TokenStream [\n+    Ident {\n+        ident: \"struct\",\n+        span: #2 bytes(LO..HI)\n+    },\n+    Ident {\n+        ident: \"M\",\n+        span: #2 bytes(LO..HI)\n+    },\n+    Group {\n+        delimiter: Parenthesis,\n+        stream: TokenStream [\n+            Ident {\n+                ident: \"$crate\",\n+                span: #2 bytes(LO..HI)\n+            },\n+            Punct {\n+                ch: ':',\n+                spacing: Joint,\n+                span: #2 bytes(LO..HI)\n+            },\n+            Punct {\n+                ch: ':',\n+                spacing: Alone,\n+                span: #2 bytes(LO..HI)\n+            },\n+            Ident {\n+                ident: \"S\",\n+                span: #2 bytes(LO..HI)\n+            }\n+        ],\n+        span: #2 bytes(LO..HI)\n+    },\n+    Punct {\n+        ch: ';',\n+        spacing: Alone,\n+        span: #2 bytes(LO..HI)\n+    }\n+]\n+ATTRIBUTE INPUT (PRETTY-PRINTED): struct A(crate::S);\n+ATTRIBUTE INPUT: TokenStream [\n+    Ident {\n+        ident: \"struct\",\n+        span: #2 bytes(LO..HI)\n+    },\n+    Ident {\n+        ident: \"A\",\n+        span: #2 bytes(LO..HI)\n+    },\n+    Group {\n+        delimiter: Parenthesis,\n+        stream: TokenStream [\n+            Ident {\n+                ident: \"$crate\",\n+                span: #2 bytes(LO..HI)\n+            },\n+            Punct {\n+                ch: ':',\n+                spacing: Joint,\n+                span: #2 bytes(LO..HI)\n+            },\n+            Punct {\n+                ch: ':',\n+                spacing: Alone,\n+                span: #2 bytes(LO..HI)\n+            },\n+            Ident {\n+                ident: \"S\",\n+                span: #2 bytes(LO..HI)\n+            }\n+        ],\n+        span: #2 bytes(LO..HI)\n+    },\n+    Punct {\n+        ch: ';',\n+        spacing: Alone,\n+        span: #2 bytes(LO..HI)\n+    }\n+]\n+DERIVE INPUT (PRETTY-PRINTED): struct D(crate::S);\n+DERIVE INPUT: TokenStream [\n+    Ident {\n+        ident: \"struct\",\n+        span: #2 bytes(LO..HI)\n+    },\n+    Ident {\n+        ident: \"D\",\n+        span: #2 bytes(LO..HI)\n+    },\n+    Group {\n+        delimiter: Parenthesis,\n+        stream: TokenStream [\n+            Ident {\n+                ident: \"$crate\",\n+                span: #2 bytes(LO..HI)\n+            },\n+            Punct {\n+                ch: ':',\n+                spacing: Joint,\n+                span: #2 bytes(LO..HI)\n+            },\n+            Punct {\n+                ch: ':',\n+                spacing: Alone,\n+                span: #2 bytes(LO..HI)\n+            },\n+            Ident {\n+                ident: \"S\",\n+                span: #2 bytes(LO..HI)\n+            }\n+        ],\n+        span: #2 bytes(LO..HI)\n+    },\n+    Punct {\n+        ch: ';',\n+        spacing: Alone,\n+        span: #2 bytes(LO..HI)\n+    }\n+]\n+PROC MACRO INPUT (PRETTY-PRINTED): struct M ( $crate :: S ) ;\n+PROC MACRO INPUT: TokenStream [\n+    Ident {\n+        ident: \"struct\",\n+        span: #10 bytes(LO..HI)\n+    },\n+    Ident {\n+        ident: \"M\",\n+        span: #10 bytes(LO..HI)\n+    },\n+    Group {\n+        delimiter: Parenthesis,\n+        stream: TokenStream [\n+            Ident {\n+                ident: \"$crate\",\n+                span: #10 bytes(LO..HI)\n+            },\n+            Punct {\n+                ch: ':',\n+                spacing: Joint,\n+                span: #10 bytes(LO..HI)\n+            },\n+            Punct {\n+                ch: ':',\n+                spacing: Alone,\n+                span: #10 bytes(LO..HI)\n+            },\n+            Ident {\n+                ident: \"S\",\n+                span: #10 bytes(LO..HI)\n+            }\n+        ],\n+        span: #10 bytes(LO..HI)\n+    },\n+    Punct {\n+        ch: ';',\n+        spacing: Alone,\n+        span: #10 bytes(LO..HI)\n+    }\n+]\n+ATTRIBUTE INPUT (PRETTY-PRINTED): struct A(::dollar_crate_external::S);\n+ATTRIBUTE INPUT: TokenStream [\n+    Ident {\n+        ident: \"struct\",\n+        span: #10 bytes(LO..HI)\n+    },\n+    Ident {\n+        ident: \"A\",\n+        span: #10 bytes(LO..HI)\n+    },\n+    Group {\n+        delimiter: Parenthesis,\n+        stream: TokenStream [\n+            Ident {\n+                ident: \"$crate\",\n+                span: #10 bytes(LO..HI)\n+            },\n+            Punct {\n+                ch: ':',\n+                spacing: Joint,\n+                span: #10 bytes(LO..HI)\n+            },\n+            Punct {\n+                ch: ':',\n+                spacing: Alone,\n+                span: #10 bytes(LO..HI)\n+            },\n+            Ident {\n+                ident: \"S\",\n+                span: #10 bytes(LO..HI)\n+            }\n+        ],\n+        span: #10 bytes(LO..HI)\n+    },\n+    Punct {\n+        ch: ';',\n+        spacing: Alone,\n+        span: #10 bytes(LO..HI)\n+    }\n+]\n+DERIVE INPUT (PRETTY-PRINTED): struct D(::dollar_crate_external::S);\n+DERIVE INPUT: TokenStream [\n+    Ident {\n+        ident: \"struct\",\n+        span: #10 bytes(LO..HI)\n+    },\n+    Ident {\n+        ident: \"D\",\n+        span: #10 bytes(LO..HI)\n+    },\n+    Group {\n+        delimiter: Parenthesis,\n+        stream: TokenStream [\n+            Ident {\n+                ident: \"$crate\",\n+                span: #10 bytes(LO..HI)\n+            },\n+            Punct {\n+                ch: ':',\n+                spacing: Joint,\n+                span: #10 bytes(LO..HI)\n+            },\n+            Punct {\n+                ch: ':',\n+                spacing: Alone,\n+                span: #10 bytes(LO..HI)\n+            },\n+            Ident {\n+                ident: \"S\",\n+                span: #10 bytes(LO..HI)\n+            }\n+        ],\n+        span: #10 bytes(LO..HI)\n+    },\n+    Punct {\n+        ch: ';',\n+        spacing: Alone,\n+        span: #10 bytes(LO..HI)\n+    }\n+]"}]}