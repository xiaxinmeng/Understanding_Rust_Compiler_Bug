{"sha": "9677cbe82e4b317c63e4459d90f7a1f2498c16ae", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk2NzdjYmU4MmU0YjMxN2M2M2U0NDU5ZDkwZjdhMWYyNDk4YzE2YWU=", "commit": {"author": {"name": "ben", "email": "benlewisj@gmail.com", "date": "2019-10-04T23:57:12Z"}, "committer": {"name": "ben", "email": "benlewisj@gmail.com", "date": "2019-10-08T16:10:00Z"}, "message": "Refactor pretty print const to use a big match statement", "tree": {"sha": "5275dc6a24a11008eb9ece01b834eaf9505cde86", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5275dc6a24a11008eb9ece01b834eaf9505cde86"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9677cbe82e4b317c63e4459d90f7a1f2498c16ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9677cbe82e4b317c63e4459d90f7a1f2498c16ae", "html_url": "https://github.com/rust-lang/rust/commit/9677cbe82e4b317c63e4459d90f7a1f2498c16ae", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9677cbe82e4b317c63e4459d90f7a1f2498c16ae/comments", "author": {"login": "BenLewis-Seequent", "id": 7391596, "node_id": "MDQ6VXNlcjczOTE1OTY=", "avatar_url": "https://avatars.githubusercontent.com/u/7391596?v=4", "gravatar_id": "", "url": "https://api.github.com/users/BenLewis-Seequent", "html_url": "https://github.com/BenLewis-Seequent", "followers_url": "https://api.github.com/users/BenLewis-Seequent/followers", "following_url": "https://api.github.com/users/BenLewis-Seequent/following{/other_user}", "gists_url": "https://api.github.com/users/BenLewis-Seequent/gists{/gist_id}", "starred_url": "https://api.github.com/users/BenLewis-Seequent/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/BenLewis-Seequent/subscriptions", "organizations_url": "https://api.github.com/users/BenLewis-Seequent/orgs", "repos_url": "https://api.github.com/users/BenLewis-Seequent/repos", "events_url": "https://api.github.com/users/BenLewis-Seequent/events{/privacy}", "received_events_url": "https://api.github.com/users/BenLewis-Seequent/received_events", "type": "User", "site_admin": false}, "committer": {"login": "BenLewis-Seequent", "id": 7391596, "node_id": "MDQ6VXNlcjczOTE1OTY=", "avatar_url": "https://avatars.githubusercontent.com/u/7391596?v=4", "gravatar_id": "", "url": "https://api.github.com/users/BenLewis-Seequent", "html_url": "https://github.com/BenLewis-Seequent", "followers_url": "https://api.github.com/users/BenLewis-Seequent/followers", "following_url": "https://api.github.com/users/BenLewis-Seequent/following{/other_user}", "gists_url": "https://api.github.com/users/BenLewis-Seequent/gists{/gist_id}", "starred_url": "https://api.github.com/users/BenLewis-Seequent/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/BenLewis-Seequent/subscriptions", "organizations_url": "https://api.github.com/users/BenLewis-Seequent/orgs", "repos_url": "https://api.github.com/users/BenLewis-Seequent/repos", "events_url": "https://api.github.com/users/BenLewis-Seequent/events{/privacy}", "received_events_url": "https://api.github.com/users/BenLewis-Seequent/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "43badf9b1d02f0e79341a93a442b0bad9312dc54", "url": "https://api.github.com/repos/rust-lang/rust/commits/43badf9b1d02f0e79341a93a442b0bad9312dc54", "html_url": "https://github.com/rust-lang/rust/commit/43badf9b1d02f0e79341a93a442b0bad9312dc54"}], "stats": {"total": 229, "additions": 106, "deletions": 123}, "files": [{"sha": "8cd637468ccd61470106f971b0aa4a27cae44fd7", "filename": "src/librustc/ty/print/pretty.rs", "status": "modified", "additions": 104, "deletions": 121, "changes": 225, "blob_url": "https://github.com/rust-lang/rust/blob/9677cbe82e4b317c63e4459d90f7a1f2498c16ae/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9677cbe82e4b317c63e4459d90f7a1f2498c16ae/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs?ref=9677cbe82e4b317c63e4459d90f7a1f2498c16ae", "patch": "@@ -863,137 +863,120 @@ pub trait PrettyPrinter<'tcx>:\n         }\n \n         let u8 = self.tcx().types.u8;\n-        if let ty::FnDef(did, substs) = ct.ty.kind {\n-            p!(print_value_path(did, substs));\n-            return Ok(self);\n-        }\n-        if let ConstValue::Unevaluated(did, substs) = ct.val {\n-            match self.tcx().def_kind(did) {\n-                | Some(DefKind::Static)\n-                | Some(DefKind::Const)\n-                | Some(DefKind::AssocConst) => p!(print_value_path(did, substs)),\n-                _ => if did.is_local() {\n-                    let span = self.tcx().def_span(did);\n-                    if let Ok(snip) = self.tcx().sess.source_map().span_to_snippet(span) {\n-                        p!(write(\"{}\", snip))\n-                    } else {\n-                        p!(write(\"_: \"), print(ct.ty))\n-                    }\n-                } else {\n-                    p!(write(\"_: \"), print(ct.ty))\n-                },\n-            }\n-            return Ok(self);\n-        }\n-        if let ConstValue::Infer(..) = ct.val {\n-            p!(write(\"_: \"), print(ct.ty));\n-            return Ok(self);\n-        }\n-        if let ConstValue::Param(ParamConst { name, .. }) = ct.val {\n-            p!(write(\"{}\", name));\n-            return Ok(self);\n-        }\n-        if let ConstValue::Scalar(Scalar::Raw { data, .. }) = ct.val {\n-            match ct.ty.kind {\n-                ty::Bool => {\n-                    p!(write(\"{}\", if data == 0 { \"false\" } else { \"true\" }));\n-                    return Ok(self);\n-                },\n-                ty::Float(ast::FloatTy::F32) => {\n-                    p!(write(\"{}f32\", Single::from_bits(data)));\n-                    return Ok(self);\n-                },\n-                ty::Float(ast::FloatTy::F64) => {\n-                    p!(write(\"{}f64\", Double::from_bits(data)));\n-                    return Ok(self);\n-                },\n-                ty::Uint(ui) => {\n-                    let bit_size = Integer::from_attr(&self.tcx(), UnsignedInt(ui)).size();\n-                    let max = truncate(u128::max_value(), bit_size);\n \n-                    if data == max {\n-                        p!(write(\"std::{}::MAX\", ui))\n+        match (ct.val, &ct.ty.kind) {\n+            (_,  ty::FnDef(did, substs)) => p!(print_value_path(*did, substs)),\n+            (ConstValue::Unevaluated(did, substs), _) => {\n+                match self.tcx().def_kind(did) {\n+                    | Some(DefKind::Static)\n+                    | Some(DefKind::Const)\n+                    | Some(DefKind::AssocConst) => p!(print_value_path(did, substs)),\n+                    _ => if did.is_local() {\n+                        let span = self.tcx().def_span(did);\n+                        if let Ok(snip) = self.tcx().sess.source_map().span_to_snippet(span) {\n+                            p!(write(\"{}\", snip))\n+                        } else {\n+                            p!(write(\"_: \"), print(ct.ty))\n+                        }\n                     } else {\n-                        p!(write(\"{}{}\", data, ui))\n-                    };\n-                    return Ok(self);\n-                },\n-                ty::Int(i) =>{\n-                    let bit_size = Integer::from_attr(&self.tcx(), SignedInt(i))\n-                        .size().bits() as u128;\n-                    let min = 1u128 << (bit_size - 1);\n-                    let max = min - 1;\n-\n-                    let ty = self.tcx().lift(&ct.ty).unwrap();\n-                    let size = self.tcx().layout_of(ty::ParamEnv::empty().and(ty))\n-                        .unwrap()\n-                        .size;\n-                    match data {\n-                        d if d == min => p!(write(\"std::{}::MIN\", i)),\n-                        d if d == max => p!(write(\"std::{}::MAX\", i)),\n-                        _ => p!(write(\"{}{}\", sign_extend(data, size) as i128, i))\n-                    }\n-                    return Ok(self);\n-                },\n-                ty::Char => {\n-                    p!(write(\"{:?}\", ::std::char::from_u32(data as u32).unwrap()));\n-                    return Ok(self);\n+                        p!(write(\"_: \"), print(ct.ty))\n+                    },\n                 }\n-                _ => {},\n-            }\n-        }\n-        if let ty::Ref(_, ref_ty, _) = ct.ty.kind {\n-            let byte_str = match (ct.val, &ref_ty.kind) {\n-                (ConstValue::Scalar(Scalar::Ptr(ptr)), ty::Array(t, n)) if *t == u8 => {\n-                    let n = n.eval_usize(self.tcx(), ty::ParamEnv::empty());\n-                    Some(self.tcx()\n-                        .alloc_map.lock()\n-                        .unwrap_memory(ptr.alloc_id)\n-                        .get_bytes(&self.tcx(), ptr, Size::from_bytes(n)).unwrap())\n-                },\n-                (ConstValue::Slice { data, start, end }, ty::Slice(t)) if *t == u8 => {\n-                    // The `inspect` here is okay since we checked the bounds, and there are no\n-                    // relocations (we have an active slice reference here). We don't use this\n-                    // result to affect interpreter execution.\n-                    Some(data.inspect_with_undef_and_ptr_outside_interpreter(start..end))\n-                },\n-                (ConstValue::Slice { data, start, end }, ty::Str) => {\n-                    // The `inspect` here is okay since we checked the bounds, and there are no\n-                    // relocations (we have an active `str` reference here). We don't use this\n-                    // result to affect interpreter execution.\n-                    let slice = data.inspect_with_undef_and_ptr_outside_interpreter(start..end);\n-                    let s = ::std::str::from_utf8(slice)\n-                        .expect(\"non utf8 str from miri\");\n-                    p!(write(\"{:?}\", s));\n-                    return Ok(self);\n-                },\n-                _ => None,\n-            };\n-            if let Some(byte_str) = byte_str {\n-                p!(write(\"b\\\"\"));\n-                for &c in byte_str {\n-                    for e in std::ascii::escape_default(c) {\n-                        self.write_char(e as char)?;\n-                    }\n+            },\n+            (ConstValue::Infer(..), _) =>  p!(write(\"_: \"), print(ct.ty)),\n+            (ConstValue::Param(ParamConst { name, .. }), _) => p!(write(\"{}\", name)),\n+            (ConstValue::Scalar(Scalar::Raw { data, .. }), ty::Bool) =>\n+                p!(write(\"{}\", if data == 0 { \"false\" } else { \"true\" })),\n+            (ConstValue::Scalar(Scalar::Raw { data, .. }), ty::Float(ast::FloatTy::F32)) =>\n+                p!(write(\"{}f32\", Single::from_bits(data))),\n+            (ConstValue::Scalar(Scalar::Raw { data, .. }), ty::Float(ast::FloatTy::F64)) =>\n+                p!(write(\"{}f64\", Double::from_bits(data))),\n+            (ConstValue::Scalar(Scalar::Raw { data, .. }), ty::Uint(ui)) => {\n+                let bit_size = Integer::from_attr(&self.tcx(), UnsignedInt(*ui)).size();\n+                let max = truncate(u128::max_value(), bit_size);\n+\n+                if data == max {\n+                    p!(write(\"std::{}::MAX\", ui))\n+                } else {\n+                    p!(write(\"{}{}\", data, ui))\n+                };\n+            },\n+            (ConstValue::Scalar(Scalar::Raw { data, .. }), ty::Int(i)) => {\n+                let bit_size = Integer::from_attr(&self.tcx(), SignedInt(*i))\n+                    .size().bits() as u128;\n+                let min = 1u128 << (bit_size - 1);\n+                let max = min - 1;\n+\n+                let ty = self.tcx().lift(&ct.ty).unwrap();\n+                let size = self.tcx().layout_of(ty::ParamEnv::empty().and(ty))\n+                    .unwrap()\n+                    .size;\n+                match data {\n+                    d if d == min => p!(write(\"std::{}::MIN\", i)),\n+                    d if d == max => p!(write(\"std::{}::MAX\", i)),\n+                    _ => p!(write(\"{}{}\", sign_extend(data, size) as i128, i))\n                 }\n-                p!(write(\"\\\"\"));\n-                return Ok(self);\n-            }\n-        }\n-\n-        if let ty::FnPtr(_) = ct.ty.kind {\n-            if let ConstValue::Scalar(Scalar::Ptr(ptr)) = ct.val {\n+            },\n+            (ConstValue::Scalar(Scalar::Raw { data, .. }), ty::Char) =>\n+                p!(write(\"{:?}\", ::std::char::from_u32(data as u32).unwrap())),\n+            (ConstValue::Scalar(Scalar::Ptr(ptr)), ty::FnPtr(_)) => {\n                 let instance = {\n                     let alloc_map = self.tcx().alloc_map.lock();\n                     alloc_map.unwrap_fn(ptr.alloc_id)\n                 };\n                 p!(print_value_path(instance.def_id(), instance.substs));\n-                return Ok(self);\n-            }\n-        }\n-\n-        p!(write(\"{:?} : \", ct.val), print(ct.ty));\n+            },\n+            _ => {\n+                let printed = if let ty::Ref(_, ref_ty, _) = ct.ty.kind {\n+                    let byte_str = match (ct.val, &ref_ty.kind) {\n+                        (ConstValue::Scalar(Scalar::Ptr(ptr)), ty::Array(t, n)) if *t == u8 => {\n+                            let n = n.eval_usize(self.tcx(), ty::ParamEnv::empty());\n+                            Some(self.tcx()\n+                                .alloc_map.lock()\n+                                .unwrap_memory(ptr.alloc_id)\n+                                .get_bytes(&self.tcx(), ptr, Size::from_bytes(n)).unwrap())\n+                        },\n+                        (ConstValue::Slice { data, start, end }, ty::Slice(t)) if *t == u8 => {\n+                            // The `inspect` here is okay since we checked the bounds, and there are\n+                            // no relocations (we have an active slice reference here). We don't use\n+                            // this result to affect interpreter execution.\n+                            Some(data.inspect_with_undef_and_ptr_outside_interpreter(start..end))\n+                        },\n+                        _ => None,\n+                    };\n \n+                    if let Some(byte_str) = byte_str {\n+                        p!(write(\"b\\\"\"));\n+                        for &c in byte_str {\n+                            for e in std::ascii::escape_default(c) {\n+                                self.write_char(e as char)?;\n+                            }\n+                        }\n+                        p!(write(\"\\\"\"));\n+                        true\n+                    } else if let (ConstValue::Slice { data, start, end }, ty::Str) =\n+                        (ct.val, &ref_ty.kind)\n+                    {\n+                        // The `inspect` here is okay since we checked the bounds, and there are no\n+                        // relocations (we have an active `str` reference here). We don't use this\n+                        // result to affect interpreter execution.\n+                        let slice = data.inspect_with_undef_and_ptr_outside_interpreter(start..end);\n+                        let s = ::std::str::from_utf8(slice)\n+                            .expect(\"non utf8 str from miri\");\n+                        p!(write(\"{:?}\", s));\n+                        true\n+                    } else {\n+                        false\n+                    }\n+                } else {\n+                    false\n+                };\n+                if !printed {\n+                    // fallback\n+                    p!(write(\"{:?} : \", ct.val), print(ct.ty))\n+                }\n+            }\n+        };\n         Ok(self)\n     }\n }"}, {"sha": "d26ab8be4c3fe67ab26e50a080847b3072b1c0eb", "filename": "src/test/ui/const-generics/raw-ptr-const-param-deref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9677cbe82e4b317c63e4459d90f7a1f2498c16ae/src%2Ftest%2Fui%2Fconst-generics%2Fraw-ptr-const-param-deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9677cbe82e4b317c63e4459d90f7a1f2498c16ae/src%2Ftest%2Fui%2Fconst-generics%2Fraw-ptr-const-param-deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fraw-ptr-const-param-deref.rs?ref=9677cbe82e4b317c63e4459d90f7a1f2498c16ae", "patch": "@@ -16,4 +16,4 @@ impl<const P: *const u32> Const<{P}> {\n \n fn main() {\n     assert_eq!(Const::<{&A as *const _}>::get(), 3)\n-}\n\\ No newline at end of file\n+}"}, {"sha": "f69c37fbb8f3d0e7be0b40c5ea6cf25fcb79de70", "filename": "src/test/ui/const-generics/raw-ptr-const-param.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9677cbe82e4b317c63e4459d90f7a1f2498c16ae/src%2Ftest%2Fui%2Fconst-generics%2Fraw-ptr-const-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9677cbe82e4b317c63e4459d90f7a1f2498c16ae/src%2Ftest%2Fui%2Fconst-generics%2Fraw-ptr-const-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fraw-ptr-const-param.rs?ref=9677cbe82e4b317c63e4459d90f7a1f2498c16ae", "patch": "@@ -6,4 +6,4 @@ struct Const<const P: *const u32>;\n fn main() {\n     let _: Const<{15 as *const _}> = Const::<{10 as *const _}>; //~ mismatched types\n     let _: Const<{10 as *const _}> = Const::<{10 as *const _}>;\n-}\n\\ No newline at end of file\n+}"}]}