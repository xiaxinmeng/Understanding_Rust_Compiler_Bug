{"sha": "84074cb1852aa702e1307e9533e1fa3448e3e04f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg0MDc0Y2IxODUyYWE3MDJlMTMwN2U5NTMzZTFmYTM0NDhlM2UwNGY=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2021-04-11T09:20:45Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2021-05-21T15:48:33Z"}, "message": "Remove our unification code, use Chalk's instead", "tree": {"sha": "87e1ba3ee0745bf10ab2de86714616e80972f024", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/87e1ba3ee0745bf10ab2de86714616e80972f024"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/84074cb1852aa702e1307e9533e1fa3448e3e04f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/84074cb1852aa702e1307e9533e1fa3448e3e04f", "html_url": "https://github.com/rust-lang/rust/commit/84074cb1852aa702e1307e9533e1fa3448e3e04f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/84074cb1852aa702e1307e9533e1fa3448e3e04f/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eb08a27f1bd31cc15db4893dded60663effaf3f9", "url": "https://api.github.com/repos/rust-lang/rust/commits/eb08a27f1bd31cc15db4893dded60663effaf3f9", "html_url": "https://github.com/rust-lang/rust/commit/eb08a27f1bd31cc15db4893dded60663effaf3f9"}], "stats": {"total": 563, "additions": 125, "deletions": 438}, "files": [{"sha": "b108fd559c431a15a55a467830a738e21f80ca95", "filename": "crates/hir_ty/src/chalk_db.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/84074cb1852aa702e1307e9533e1fa3448e3e04f/crates%2Fhir_ty%2Fsrc%2Fchalk_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84074cb1852aa702e1307e9533e1fa3448e3e04f/crates%2Fhir_ty%2Fsrc%2Fchalk_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fchalk_db.rs?ref=84074cb1852aa702e1307e9533e1fa3448e3e04f", "patch": "@@ -344,20 +344,20 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n     }\n \n     fn unification_database(&self) -> &dyn chalk_ir::UnificationDatabase<Interner> {\n-        self\n+        &self.db\n     }\n }\n \n-impl<'a> chalk_ir::UnificationDatabase<Interner> for ChalkContext<'a> {\n+impl<'a> chalk_ir::UnificationDatabase<Interner> for &'a dyn HirDatabase {\n     fn fn_def_variance(\n         &self,\n         fn_def_id: chalk_ir::FnDefId<Interner>,\n     ) -> chalk_ir::Variances<Interner> {\n-        self.db.fn_def_variance(self.krate, fn_def_id)\n+        HirDatabase::fn_def_variance(*self, fn_def_id)\n     }\n \n     fn adt_variance(&self, adt_id: chalk_ir::AdtId<Interner>) -> chalk_ir::Variances<Interner> {\n-        self.db.adt_variance(self.krate, adt_id)\n+        HirDatabase::adt_variance(*self, adt_id)\n     }\n }\n \n@@ -651,11 +651,7 @@ pub(crate) fn fn_def_datum_query(\n     Arc::new(datum)\n }\n \n-pub(crate) fn fn_def_variance_query(\n-    db: &dyn HirDatabase,\n-    _krate: CrateId,\n-    fn_def_id: FnDefId,\n-) -> Variances {\n+pub(crate) fn fn_def_variance_query(db: &dyn HirDatabase, fn_def_id: FnDefId) -> Variances {\n     let callable_def: CallableDefId = from_chalk(db, fn_def_id);\n     let generic_params = generics(db.upcast(), callable_def.into());\n     Variances::from_iter(\n@@ -666,7 +662,6 @@ pub(crate) fn fn_def_variance_query(\n \n pub(crate) fn adt_variance_query(\n     db: &dyn HirDatabase,\n-    _krate: CrateId,\n     chalk_ir::AdtId(adt_id): AdtId,\n ) -> Variances {\n     let generic_params = generics(db.upcast(), adt_id.into());"}, {"sha": "f773aa6211e404255beb1ad4d4427ce1ae2b74ce", "filename": "crates/hir_ty/src/db.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/84074cb1852aa702e1307e9533e1fa3448e3e04f/crates%2Fhir_ty%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84074cb1852aa702e1307e9533e1fa3448e3e04f/crates%2Fhir_ty%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdb.rs?ref=84074cb1852aa702e1307e9533e1fa3448e3e04f", "patch": "@@ -117,10 +117,10 @@ pub trait HirDatabase: DefDatabase + Upcast<dyn DefDatabase> {\n     fn fn_def_datum(&self, krate: CrateId, fn_def_id: FnDefId) -> Arc<chalk_db::FnDefDatum>;\n \n     #[salsa::invoke(chalk_db::fn_def_variance_query)]\n-    fn fn_def_variance(&self, krate: CrateId, fn_def_id: FnDefId) -> chalk_db::Variances;\n+    fn fn_def_variance(&self, fn_def_id: FnDefId) -> chalk_db::Variances;\n \n     #[salsa::invoke(chalk_db::adt_variance_query)]\n-    fn adt_variance(&self, krate: CrateId, adt_id: chalk_db::AdtId) -> chalk_db::Variances;\n+    fn adt_variance(&self, adt_id: chalk_db::AdtId) -> chalk_db::Variances;\n \n     #[salsa::invoke(chalk_db::associated_ty_value_query)]\n     fn associated_ty_value("}, {"sha": "2a82f1b47a47e772dde6e8abe78d485c146d402b", "filename": "crates/hir_ty/src/infer.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/84074cb1852aa702e1307e9533e1fa3448e3e04f/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84074cb1852aa702e1307e9533e1fa3448e3e04f/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer.rs?ref=84074cb1852aa702e1307e9533e1fa3448e3e04f", "patch": "@@ -217,7 +217,7 @@ struct InferenceContext<'a> {\n     owner: DefWithBodyId,\n     body: Arc<Body>,\n     resolver: Resolver,\n-    table: unify::InferenceTable,\n+    table: unify::InferenceTable<'a>,\n     trait_env: Arc<TraitEnvironment>,\n     obligations: Vec<DomainGoal>,\n     last_obligations_check: Option<u32>,\n@@ -252,15 +252,15 @@ fn find_breakable<'c>(\n \n impl<'a> InferenceContext<'a> {\n     fn new(db: &'a dyn HirDatabase, owner: DefWithBodyId, resolver: Resolver) -> Self {\n+        let trait_env =\n+            owner.as_generic_def_id().map_or_else(Default::default, |d| db.trait_environment(d));\n         InferenceContext {\n             result: InferenceResult::default(),\n-            table: unify::InferenceTable::new(),\n+            table: unify::InferenceTable::new(db, trait_env.clone()),\n             obligations: Vec::default(),\n             last_obligations_check: None,\n             return_ty: TyKind::Error.intern(&Interner), // set in collect_fn_signature\n-            trait_env: owner\n-                .as_generic_def_id()\n-                .map_or_else(Default::default, |d| db.trait_environment(d)),\n+            trait_env,\n             db,\n             owner,\n             body: db.body(owner),\n@@ -346,17 +346,12 @@ impl<'a> InferenceContext<'a> {\n     }\n \n     fn resolve_obligations_as_possible(&mut self) {\n-        if self.last_obligations_check == Some(self.table.revision) {\n-            // no change\n-            return;\n-        }\n         let _span = profile::span(\"resolve_obligations_as_possible\");\n \n-        self.last_obligations_check = Some(self.table.revision);\n         let obligations = mem::replace(&mut self.obligations, Vec::new());\n         for obligation in obligations {\n             let in_env = InEnvironment::new(&self.trait_env.env, obligation.clone());\n-            let canonicalized = self.canonicalizer().canonicalize_obligation(in_env);\n+            let canonicalized = self.canonicalize(in_env);\n             let solution =\n                 self.db.trait_solve(self.resolver.krate().unwrap(), canonicalized.value.clone());\n \n@@ -395,6 +390,7 @@ impl<'a> InferenceContext<'a> {\n         self.table.unify(ty1, ty2)\n     }\n \n+    // FIXME get rid of this, instead resolve shallowly where necessary\n     /// Resolves the type as far as currently possible, replacing type variables\n     /// by their known types. All types returned by the infer_* functions should\n     /// be resolved as far as possible, i.e. contain no type variables with"}, {"sha": "ae858b1b09d189639bdc571b3b3a65eb7ffc48fd", "filename": "crates/hir_ty/src/infer/coerce.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/84074cb1852aa702e1307e9533e1fa3448e3e04f/crates%2Fhir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84074cb1852aa702e1307e9533e1fa3448e3e04f/crates%2Fhir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fcoerce.rs?ref=84074cb1852aa702e1307e9533e1fa3448e3e04f", "patch": "@@ -7,7 +7,7 @@\n use chalk_ir::{cast::Cast, Mutability, TyVariableKind};\n use hir_def::lang_item::LangItemTarget;\n \n-use crate::{autoderef, Canonical, Interner, Solution, Ty, TyBuilder, TyExt, TyKind};\n+use crate::{autoderef, Canonical, DomainGoal, Interner, Solution, Ty, TyBuilder, TyExt, TyKind};\n \n use super::{InEnvironment, InferenceContext};\n \n@@ -141,10 +141,10 @@ impl<'a> InferenceContext<'a> {\n             b.push(from_ty.clone()).push(to_ty.clone()).build()\n         };\n \n-        let goal = InEnvironment::new(&self.trait_env.env, trait_ref.cast(&Interner));\n+        let goal: InEnvironment<DomainGoal> =\n+            InEnvironment::new(&self.trait_env.env, trait_ref.cast(&Interner));\n \n-        let canonicalizer = self.canonicalizer();\n-        let canonicalized = canonicalizer.canonicalize_obligation(goal);\n+        let canonicalized = self.canonicalize(goal);\n \n         let solution = self.db.trait_solve(krate, canonicalized.value.clone())?;\n \n@@ -169,7 +169,7 @@ impl<'a> InferenceContext<'a> {\n     ///\n     /// Note that the parameters are already stripped the outer reference.\n     fn unify_autoderef_behind_ref(&mut self, from_ty: &Ty, to_ty: &Ty) -> bool {\n-        let canonicalized = self.canonicalizer().canonicalize_ty(from_ty.clone());\n+        let canonicalized = self.canonicalize(from_ty.clone());\n         let to_ty = self.resolve_ty_shallow(&to_ty);\n         // FIXME: Auto DerefMut\n         for derefed_ty in autoderef::autoderef("}, {"sha": "aab4d31534c21dacd862a7c82188b278396ce6cb", "filename": "crates/hir_ty/src/infer/expr.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/84074cb1852aa702e1307e9533e1fa3448e3e04f/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84074cb1852aa702e1307e9533e1fa3448e3e04f/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs?ref=84074cb1852aa702e1307e9533e1fa3448e3e04f", "patch": "@@ -98,7 +98,7 @@ impl<'a> InferenceContext<'a> {\n             goal: projection.trait_ref(self.db).cast(&Interner),\n             environment: trait_env,\n         };\n-        let canonical = self.canonicalizer().canonicalize_obligation(obligation.clone());\n+        let canonical = self.canonicalize(obligation.clone());\n         if self.db.trait_solve(krate, canonical.value).is_some() {\n             self.push_obligation(obligation.goal);\n             let return_ty = self.normalize_projection_ty(projection);\n@@ -297,7 +297,7 @@ impl<'a> InferenceContext<'a> {\n             }\n             Expr::Call { callee, args } => {\n                 let callee_ty = self.infer_expr(*callee, &Expectation::none());\n-                let canonicalized = self.canonicalizer().canonicalize_ty(callee_ty.clone());\n+                let canonicalized = self.canonicalize(callee_ty.clone());\n                 let mut derefs = autoderef(\n                     self.db,\n                     self.resolver.krate(),\n@@ -442,7 +442,7 @@ impl<'a> InferenceContext<'a> {\n             }\n             Expr::Field { expr, name } => {\n                 let receiver_ty = self.infer_expr_inner(*expr, &Expectation::none());\n-                let canonicalized = self.canonicalizer().canonicalize_ty(receiver_ty);\n+                let canonicalized = self.canonicalize(receiver_ty);\n                 let ty = autoderef::autoderef(\n                     self.db,\n                     self.resolver.krate(),\n@@ -559,7 +559,7 @@ impl<'a> InferenceContext<'a> {\n                 match op {\n                     UnaryOp::Deref => match self.resolver.krate() {\n                         Some(krate) => {\n-                            let canonicalized = self.canonicalizer().canonicalize_ty(inner_ty);\n+                            let canonicalized = self.canonicalize(inner_ty);\n                             match autoderef::deref(\n                                 self.db,\n                                 krate,\n@@ -676,7 +676,7 @@ impl<'a> InferenceContext<'a> {\n                 if let (Some(index_trait), Some(krate)) =\n                     (self.resolve_ops_index(), self.resolver.krate())\n                 {\n-                    let canonicalized = self.canonicalizer().canonicalize_ty(base_ty);\n+                    let canonicalized = self.canonicalize(base_ty);\n                     let self_ty = method_resolution::resolve_indexing_op(\n                         self.db,\n                         &canonicalized.value,\n@@ -852,7 +852,7 @@ impl<'a> InferenceContext<'a> {\n         generic_args: Option<&GenericArgs>,\n     ) -> Ty {\n         let receiver_ty = self.infer_expr(receiver, &Expectation::none());\n-        let canonicalized_receiver = self.canonicalizer().canonicalize_ty(receiver_ty.clone());\n+        let canonicalized_receiver = self.canonicalize(receiver_ty.clone());\n \n         let traits_in_scope = self.resolver.traits_in_scope(self.db.upcast());\n "}, {"sha": "bc64b612b2e5bf8988c7db275c14d5ea9c69cc26", "filename": "crates/hir_ty/src/infer/path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/84074cb1852aa702e1307e9533e1fa3448e3e04f/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84074cb1852aa702e1307e9533e1fa3448e3e04f/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpath.rs?ref=84074cb1852aa702e1307e9533e1fa3448e3e04f", "patch": "@@ -218,7 +218,7 @@ impl<'a> InferenceContext<'a> {\n             return Some(result);\n         }\n \n-        let canonical_ty = self.canonicalizer().canonicalize_ty(ty.clone());\n+        let canonical_ty = self.canonicalize(ty.clone());\n         let krate = self.resolver.krate()?;\n         let traits_in_scope = self.resolver.traits_in_scope(self.db.upcast());\n "}, {"sha": "9b28c76d66fbfe5fd96874f22be4c9068a1eb9fa", "filename": "crates/hir_ty/src/infer/unify.rs", "status": "modified", "additions": 97, "deletions": 402, "changes": 499, "blob_url": "https://github.com/rust-lang/rust/blob/84074cb1852aa702e1307e9533e1fa3448e3e04f/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84074cb1852aa702e1307e9533e1fa3448e3e04f/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs?ref=84074cb1852aa702e1307e9533e1fa3448e3e04f", "patch": "@@ -1,133 +1,52 @@\n //! Unification and canonicalization logic.\n \n-use std::borrow::Cow;\n+use std::{borrow::Cow, fmt, sync::Arc};\n \n use chalk_ir::{\n     cast::Cast, fold::Fold, interner::HasInterner, FloatTy, IntTy, TyVariableKind, UniverseIndex,\n     VariableKind,\n };\n-use ena::unify::{InPlaceUnificationTable, NoError, UnifyKey, UnifyValue};\n+use chalk_solve::infer::ParameterEnaVariableExt;\n+use ena::unify::UnifyKey;\n \n-use super::{DomainGoal, InferenceContext};\n+use super::InferenceContext;\n use crate::{\n-    fold_tys, static_lifetime, AliasEq, AliasTy, BoundVar, Canonical, CanonicalVarKinds,\n-    DebruijnIndex, FnPointer, FnSubst, InEnvironment, InferenceVar, Interner, Scalar, Substitution,\n-    Ty, TyExt, TyKind, WhereClause,\n+    db::HirDatabase, fold_tys, static_lifetime, BoundVar, Canonical, DebruijnIndex, GenericArg,\n+    InferenceVar, Interner, Scalar, Substitution, TraitEnvironment, Ty, TyKind,\n };\n \n impl<'a> InferenceContext<'a> {\n-    pub(super) fn canonicalizer<'b>(&'b mut self) -> Canonicalizer<'a, 'b>\n+    pub(super) fn canonicalize<T: Fold<Interner> + HasInterner<Interner = Interner>>(\n+        &mut self,\n+        t: T,\n+    ) -> Canonicalized<T::Result>\n     where\n-        'a: 'b,\n+        T::Result: HasInterner<Interner = Interner>,\n     {\n-        Canonicalizer { ctx: self, free_vars: Vec::new(), var_stack: Vec::new() }\n+        let result = self.table.var_unification_table.canonicalize(&Interner, t);\n+        let free_vars = result\n+            .free_vars\n+            .into_iter()\n+            .map(|free_var| free_var.to_generic_arg(&Interner))\n+            .collect();\n+        Canonicalized { value: result.quantified, free_vars }\n     }\n }\n \n-pub(super) struct Canonicalizer<'a, 'b>\n-where\n-    'a: 'b,\n-{\n-    ctx: &'b mut InferenceContext<'a>,\n-    free_vars: Vec<(InferenceVar, TyVariableKind)>,\n-    /// A stack of type variables that is used to detect recursive types (which\n-    /// are an error, but we need to protect against them to avoid stack\n-    /// overflows).\n-    var_stack: Vec<TypeVarId>,\n-}\n-\n #[derive(Debug)]\n pub(super) struct Canonicalized<T>\n where\n     T: HasInterner<Interner = Interner>,\n {\n     pub(super) value: Canonical<T>,\n-    free_vars: Vec<(InferenceVar, TyVariableKind)>,\n-}\n-\n-impl<'a, 'b> Canonicalizer<'a, 'b> {\n-    fn add(&mut self, free_var: InferenceVar, kind: TyVariableKind) -> usize {\n-        self.free_vars.iter().position(|&(v, _)| v == free_var).unwrap_or_else(|| {\n-            let next_index = self.free_vars.len();\n-            self.free_vars.push((free_var, kind));\n-            next_index\n-        })\n-    }\n-\n-    fn do_canonicalize<T: Fold<Interner, Result = T> + HasInterner<Interner = Interner>>(\n-        &mut self,\n-        t: T,\n-        binders: DebruijnIndex,\n-    ) -> T {\n-        fold_tys(\n-            t,\n-            |ty, binders| match ty.kind(&Interner) {\n-                &TyKind::InferenceVar(var, kind) => {\n-                    let inner = from_inference_var(var);\n-                    if self.var_stack.contains(&inner) {\n-                        // recursive type\n-                        return self.ctx.table.type_variable_table.fallback_value(var, kind);\n-                    }\n-                    if let Some(known_ty) =\n-                        self.ctx.table.var_unification_table.inlined_probe_value(inner).known()\n-                    {\n-                        self.var_stack.push(inner);\n-                        let result = self.do_canonicalize(known_ty.clone(), binders);\n-                        self.var_stack.pop();\n-                        result\n-                    } else {\n-                        let root = self.ctx.table.var_unification_table.find(inner);\n-                        let position = self.add(to_inference_var(root), kind);\n-                        TyKind::BoundVar(BoundVar::new(binders, position)).intern(&Interner)\n-                    }\n-                }\n-                _ => ty,\n-            },\n-            binders,\n-        )\n-    }\n-\n-    fn into_canonicalized<T: HasInterner<Interner = Interner>>(\n-        self,\n-        result: T,\n-    ) -> Canonicalized<T> {\n-        let kinds = self\n-            .free_vars\n-            .iter()\n-            .map(|&(_, k)| chalk_ir::WithKind::new(VariableKind::Ty(k), UniverseIndex::ROOT));\n-        Canonicalized {\n-            value: Canonical {\n-                value: result,\n-                binders: CanonicalVarKinds::from_iter(&Interner, kinds),\n-            },\n-            free_vars: self.free_vars,\n-        }\n-    }\n-\n-    pub(crate) fn canonicalize_ty(mut self, ty: Ty) -> Canonicalized<Ty> {\n-        let result = self.do_canonicalize(ty, DebruijnIndex::INNERMOST);\n-        self.into_canonicalized(result)\n-    }\n-\n-    pub(crate) fn canonicalize_obligation(\n-        mut self,\n-        obligation: InEnvironment<DomainGoal>,\n-    ) -> Canonicalized<InEnvironment<DomainGoal>> {\n-        let result = match obligation.goal {\n-            DomainGoal::Holds(wc) => {\n-                DomainGoal::Holds(self.do_canonicalize(wc, DebruijnIndex::INNERMOST))\n-            }\n-            _ => unimplemented!(),\n-        };\n-        self.into_canonicalized(InEnvironment { goal: result, environment: obligation.environment })\n-    }\n+    free_vars: Vec<GenericArg>,\n }\n \n impl<T: HasInterner<Interner = Interner>> Canonicalized<T> {\n     pub(super) fn decanonicalize_ty(&self, ty: Ty) -> Ty {\n         crate::fold_free_vars(ty, |bound, _binders| {\n-            let (v, k) = self.free_vars[bound.index];\n-            TyKind::InferenceVar(v, k).intern(&Interner)\n+            let var = self.free_vars[bound.index];\n+            var.assert_ty_ref(&Interner).clone()\n         })\n     }\n \n@@ -155,23 +74,29 @@ impl<T: HasInterner<Interner = Interner>> Canonicalized<T> {\n             }),\n         );\n         for (i, ty) in solution.value.iter(&Interner).enumerate() {\n-            let (v, k) = self.free_vars[i];\n+            // FIXME: deal with non-type vars here -- the only problematic part is the normalization\n+            // and maybe we don't need that with lazy normalization?\n+            let var = self.free_vars[i];\n             // eagerly replace projections in the type; we may be getting types\n             // e.g. from where clauses where this hasn't happened yet\n             let ty = ctx.normalize_associated_types_in(\n                 new_vars.apply(ty.assert_ty_ref(&Interner).clone(), &Interner),\n             );\n-            ctx.table.unify(&TyKind::InferenceVar(v, k).intern(&Interner), &ty);\n+            ctx.table.unify(var.assert_ty_ref(&Interner), &ty);\n         }\n     }\n }\n \n-pub fn could_unify(t1: &Ty, t2: &Ty) -> bool {\n-    InferenceTable::new().unify(t1, t2)\n+pub fn could_unify(db: &dyn HirDatabase, env: Arc<TraitEnvironment>, t1: &Ty, t2: &Ty) -> bool {\n+    InferenceTable::new(db, env).unify(t1, t2)\n }\n \n-pub(crate) fn unify(tys: &Canonical<(Ty, Ty)>) -> Option<Substitution> {\n-    let mut table = InferenceTable::new();\n+pub(crate) fn unify(\n+    db: &dyn HirDatabase,\n+    env: Arc<TraitEnvironment>,\n+    tys: &Canonical<(Ty, Ty)>,\n+) -> Option<Substitution> {\n+    let mut table = InferenceTable::new(db, env);\n     let vars = Substitution::from_iter(\n         &Interner,\n         tys.binders\n@@ -214,16 +139,16 @@ impl TypeVariableTable {\n     }\n \n     pub(super) fn set_diverging(&mut self, iv: InferenceVar, diverging: bool) {\n-        self.inner[from_inference_var(iv).0 as usize].diverging = diverging;\n+        self.inner[iv.index() as usize].diverging = diverging;\n     }\n \n     fn is_diverging(&mut self, iv: InferenceVar) -> bool {\n-        self.inner[from_inference_var(iv).0 as usize].diverging\n+        self.inner[iv.index() as usize].diverging\n     }\n \n     fn fallback_value(&self, iv: InferenceVar, kind: TyVariableKind) -> Ty {\n         match kind {\n-            _ if self.inner[from_inference_var(iv).0 as usize].diverging => TyKind::Never,\n+            _ if self.inner[iv.index() as usize].diverging => TyKind::Never,\n             TyVariableKind::General => TyKind::Error,\n             TyVariableKind::Integer => TyKind::Scalar(Scalar::Int(IntTy::I32)),\n             TyVariableKind::Float => TyKind::Scalar(Scalar::Float(FloatTy::F64)),\n@@ -237,27 +162,35 @@ pub(crate) struct TypeVariableData {\n     diverging: bool,\n }\n \n-#[derive(Clone, Debug)]\n-pub(crate) struct InferenceTable {\n-    pub(super) var_unification_table: InPlaceUnificationTable<TypeVarId>,\n+type ChalkInferenceTable = chalk_solve::infer::InferenceTable<Interner>;\n+\n+#[derive(Clone)]\n+pub(crate) struct InferenceTable<'a> {\n+    db: &'a dyn HirDatabase,\n+    trait_env: Arc<TraitEnvironment>,\n+    pub(super) var_unification_table: ChalkInferenceTable,\n     pub(super) type_variable_table: TypeVariableTable,\n-    pub(super) revision: u32,\n }\n \n-impl InferenceTable {\n-    pub(crate) fn new() -> Self {\n+impl<'a> InferenceTable<'a> {\n+    pub(crate) fn new(db: &'a dyn HirDatabase, trait_env: Arc<TraitEnvironment>) -> Self {\n         InferenceTable {\n-            var_unification_table: InPlaceUnificationTable::new(),\n+            db,\n+            trait_env,\n+            var_unification_table: ChalkInferenceTable::new(),\n             type_variable_table: TypeVariableTable { inner: Vec::new() },\n-            revision: 0,\n         }\n     }\n \n     fn new_var(&mut self, kind: TyVariableKind, diverging: bool) -> Ty {\n-        self.type_variable_table.push(TypeVariableData { diverging });\n-        let key = self.var_unification_table.new_key(TypeVarValue::Unknown);\n-        assert_eq!(key.0 as usize, self.type_variable_table.inner.len() - 1);\n-        TyKind::InferenceVar(to_inference_var(key), kind).intern(&Interner)\n+        let var = self.var_unification_table.new_variable(UniverseIndex::ROOT);\n+        self.type_variable_table.inner.extend(\n+            (0..1 + var.index() as usize - self.type_variable_table.inner.len())\n+                .map(|_| TypeVariableData { diverging: false }),\n+        );\n+        assert_eq!(var.index() as usize, self.type_variable_table.inner.len() - 1);\n+        self.type_variable_table.inner[var.index() as usize].diverging = diverging;\n+        var.to_ty_with_kind(&Interner, kind)\n     }\n \n     pub(crate) fn new_type_var(&mut self) -> Ty {\n@@ -280,240 +213,59 @@ impl InferenceTable {\n         self.resolve_ty_completely_inner(&mut Vec::new(), ty)\n     }\n \n+    // FIXME get rid of this, instead resolve shallowly where necessary\n     pub(crate) fn resolve_ty_as_possible(&mut self, ty: Ty) -> Ty {\n         self.resolve_ty_as_possible_inner(&mut Vec::new(), ty)\n     }\n \n     pub(crate) fn unify(&mut self, ty1: &Ty, ty2: &Ty) -> bool {\n-        self.unify_inner(ty1, ty2, 0)\n-    }\n-\n-    pub(crate) fn unify_substs(\n-        &mut self,\n-        substs1: &Substitution,\n-        substs2: &Substitution,\n-        depth: usize,\n-    ) -> bool {\n-        substs1.iter(&Interner).zip(substs2.iter(&Interner)).all(|(t1, t2)| {\n-            self.unify_inner(t1.assert_ty_ref(&Interner), t2.assert_ty_ref(&Interner), depth)\n-        })\n-    }\n-\n-    fn unify_inner(&mut self, ty1: &Ty, ty2: &Ty, depth: usize) -> bool {\n-        if depth > 1000 {\n-            // prevent stackoverflows\n-            panic!(\"infinite recursion in unification\");\n-        }\n-        if ty1 == ty2 {\n-            return true;\n-        }\n-        // try to resolve type vars first\n-        let ty1 = self.resolve_ty_shallow(ty1);\n-        let ty2 = self.resolve_ty_shallow(ty2);\n-        if ty1.equals_ctor(&ty2) {\n-            match (ty1.kind(&Interner), ty2.kind(&Interner)) {\n-                (TyKind::Adt(_, substs1), TyKind::Adt(_, substs2))\n-                | (TyKind::FnDef(_, substs1), TyKind::FnDef(_, substs2))\n-                | (\n-                    TyKind::Function(FnPointer { substitution: FnSubst(substs1), .. }),\n-                    TyKind::Function(FnPointer { substitution: FnSubst(substs2), .. }),\n-                )\n-                | (TyKind::Tuple(_, substs1), TyKind::Tuple(_, substs2))\n-                | (TyKind::OpaqueType(_, substs1), TyKind::OpaqueType(_, substs2))\n-                | (TyKind::AssociatedType(_, substs1), TyKind::AssociatedType(_, substs2))\n-                | (TyKind::Closure(.., substs1), TyKind::Closure(.., substs2)) => {\n-                    self.unify_substs(substs1, substs2, depth + 1)\n-                }\n-                (TyKind::Array(ty1, c1), TyKind::Array(ty2, c2)) if c1 == c2 => {\n-                    self.unify_inner(ty1, ty2, depth + 1)\n-                }\n-                (TyKind::Ref(_, _, ty1), TyKind::Ref(_, _, ty2))\n-                | (TyKind::Raw(_, ty1), TyKind::Raw(_, ty2))\n-                | (TyKind::Slice(ty1), TyKind::Slice(ty2)) => self.unify_inner(ty1, ty2, depth + 1),\n-                _ => true, /* we checked equals_ctor already */\n-            }\n-        } else if let (TyKind::Closure(.., substs1), TyKind::Closure(.., substs2)) =\n-            (ty1.kind(&Interner), ty2.kind(&Interner))\n-        {\n-            self.unify_substs(substs1, substs2, depth + 1)\n+        let result = self.var_unification_table.relate(\n+            &Interner,\n+            &self.db,\n+            &self.trait_env.env,\n+            chalk_ir::Variance::Invariant,\n+            ty1,\n+            ty2,\n+        );\n+        let result = if let Ok(r) = result {\n+            r\n         } else {\n-            self.unify_inner_trivial(&ty1, &ty2, depth)\n-        }\n-    }\n-\n-    pub(super) fn unify_inner_trivial(&mut self, ty1: &Ty, ty2: &Ty, depth: usize) -> bool {\n-        match (ty1.kind(&Interner), ty2.kind(&Interner)) {\n-            (TyKind::Error, _) | (_, TyKind::Error) => true,\n-\n-            (TyKind::Placeholder(p1), TyKind::Placeholder(p2)) if *p1 == *p2 => true,\n-\n-            (TyKind::Dyn(dyn1), TyKind::Dyn(dyn2))\n-                if dyn1.bounds.skip_binders().interned().len()\n-                    == dyn2.bounds.skip_binders().interned().len() =>\n-            {\n-                for (pred1, pred2) in dyn1\n-                    .bounds\n-                    .skip_binders()\n-                    .interned()\n-                    .iter()\n-                    .zip(dyn2.bounds.skip_binders().interned().iter())\n-                {\n-                    if !self.unify_preds(pred1.skip_binders(), pred2.skip_binders(), depth + 1) {\n-                        return false;\n-                    }\n-                }\n-                true\n-            }\n-\n-            (\n-                TyKind::InferenceVar(tv1, TyVariableKind::General),\n-                TyKind::InferenceVar(tv2, TyVariableKind::General),\n-            )\n-            | (\n-                TyKind::InferenceVar(tv1, TyVariableKind::Integer),\n-                TyKind::InferenceVar(tv2, TyVariableKind::Integer),\n-            )\n-            | (\n-                TyKind::InferenceVar(tv1, TyVariableKind::Float),\n-                TyKind::InferenceVar(tv2, TyVariableKind::Float),\n-            ) if self.type_variable_table.is_diverging(*tv1)\n-                == self.type_variable_table.is_diverging(*tv2) =>\n-            {\n-                // both type vars are unknown since we tried to resolve them\n-                if !self\n-                    .var_unification_table\n-                    .unioned(from_inference_var(*tv1), from_inference_var(*tv2))\n-                {\n-                    self.var_unification_table\n-                        .union(from_inference_var(*tv1), from_inference_var(*tv2));\n-                    self.revision += 1;\n-                }\n-                true\n-            }\n-\n-            // The order of MaybeNeverTypeVar matters here.\n-            // Unifying MaybeNeverTypeVar and TypeVar will let the latter become MaybeNeverTypeVar.\n-            // Unifying MaybeNeverTypeVar and other concrete type will let the former become it.\n-            (TyKind::InferenceVar(tv, TyVariableKind::General), other)\n-            | (other, TyKind::InferenceVar(tv, TyVariableKind::General))\n-            | (\n-                TyKind::InferenceVar(tv, TyVariableKind::Integer),\n-                other @ TyKind::Scalar(Scalar::Int(_)),\n-            )\n-            | (\n-                other @ TyKind::Scalar(Scalar::Int(_)),\n-                TyKind::InferenceVar(tv, TyVariableKind::Integer),\n-            )\n-            | (\n-                TyKind::InferenceVar(tv, TyVariableKind::Integer),\n-                other @ TyKind::Scalar(Scalar::Uint(_)),\n-            )\n-            | (\n-                other @ TyKind::Scalar(Scalar::Uint(_)),\n-                TyKind::InferenceVar(tv, TyVariableKind::Integer),\n-            )\n-            | (\n-                TyKind::InferenceVar(tv, TyVariableKind::Float),\n-                other @ TyKind::Scalar(Scalar::Float(_)),\n-            )\n-            | (\n-                other @ TyKind::Scalar(Scalar::Float(_)),\n-                TyKind::InferenceVar(tv, TyVariableKind::Float),\n-            ) => {\n-                // the type var is unknown since we tried to resolve it\n-                self.var_unification_table.union_value(\n-                    from_inference_var(*tv),\n-                    TypeVarValue::Known(other.clone().intern(&Interner)),\n-                );\n-                self.revision += 1;\n-                true\n-            }\n-\n-            _ => false,\n-        }\n-    }\n-\n-    fn unify_preds(&mut self, pred1: &WhereClause, pred2: &WhereClause, depth: usize) -> bool {\n-        match (pred1, pred2) {\n-            (WhereClause::Implemented(tr1), WhereClause::Implemented(tr2))\n-                if tr1.trait_id == tr2.trait_id =>\n-            {\n-                self.unify_substs(&tr1.substitution, &tr2.substitution, depth + 1)\n-            }\n-            (\n-                WhereClause::AliasEq(AliasEq { alias: alias1, ty: ty1 }),\n-                WhereClause::AliasEq(AliasEq { alias: alias2, ty: ty2 }),\n-            ) => {\n-                let (substitution1, substitution2) = match (alias1, alias2) {\n-                    (AliasTy::Projection(projection_ty1), AliasTy::Projection(projection_ty2))\n-                        if projection_ty1.associated_ty_id == projection_ty2.associated_ty_id =>\n-                    {\n-                        (&projection_ty1.substitution, &projection_ty2.substitution)\n-                    }\n-                    (AliasTy::Opaque(opaque1), AliasTy::Opaque(opaque2))\n-                        if opaque1.opaque_ty_id == opaque2.opaque_ty_id =>\n-                    {\n-                        (&opaque1.substitution, &opaque2.substitution)\n-                    }\n-                    _ => return false,\n-                };\n-                self.unify_substs(&substitution1, &substitution2, depth + 1)\n-                    && self.unify_inner(&ty1, &ty2, depth + 1)\n-            }\n-            _ => false,\n-        }\n+            return false;\n+        };\n+        // TODO deal with new goals\n+        true\n     }\n \n     /// If `ty` is a type variable with known type, returns that type;\n     /// otherwise, return ty.\n+    // FIXME this could probably just return Ty\n     pub(crate) fn resolve_ty_shallow<'b>(&mut self, ty: &'b Ty) -> Cow<'b, Ty> {\n-        let mut ty = Cow::Borrowed(ty);\n-        // The type variable could resolve to a int/float variable. Hence try\n-        // resolving up to three times; each type of variable shouldn't occur\n-        // more than once\n-        for i in 0..3 {\n-            if i > 0 {\n-                cov_mark::hit!(type_var_resolves_to_int_var);\n-            }\n-            match ty.kind(&Interner) {\n-                TyKind::InferenceVar(tv, _) => {\n-                    let inner = from_inference_var(*tv);\n-                    match self.var_unification_table.inlined_probe_value(inner).known() {\n-                        Some(known_ty) => {\n-                            // The known_ty can't be a type var itself\n-                            ty = Cow::Owned(known_ty.clone());\n-                        }\n-                        _ => return ty,\n-                    }\n-                }\n-                _ => return ty,\n-            }\n-        }\n-        log::error!(\"Inference variable still not resolved: {:?}\", ty);\n-        ty\n+        self.var_unification_table\n+            .normalize_ty_shallow(&Interner, ty)\n+            .map_or(Cow::Borrowed(ty), Cow::Owned)\n     }\n \n     /// Resolves the type as far as currently possible, replacing type variables\n     /// by their known types. All types returned by the infer_* functions should\n     /// be resolved as far as possible, i.e. contain no type variables with\n     /// known type.\n-    fn resolve_ty_as_possible_inner(&mut self, tv_stack: &mut Vec<TypeVarId>, ty: Ty) -> Ty {\n+    fn resolve_ty_as_possible_inner(&mut self, tv_stack: &mut Vec<InferenceVar>, ty: Ty) -> Ty {\n         fold_tys(\n             ty,\n             |ty, _| match ty.kind(&Interner) {\n                 &TyKind::InferenceVar(tv, kind) => {\n-                    let inner = from_inference_var(tv);\n-                    if tv_stack.contains(&inner) {\n+                    if tv_stack.contains(&tv) {\n                         cov_mark::hit!(type_var_cycles_resolve_as_possible);\n                         // recursive type\n                         return self.type_variable_table.fallback_value(tv, kind);\n                     }\n-                    if let Some(known_ty) =\n-                        self.var_unification_table.inlined_probe_value(inner).known()\n-                    {\n+                    if let Some(known_ty) = self.var_unification_table.probe_var(tv) {\n                         // known_ty may contain other variables that are known by now\n-                        tv_stack.push(inner);\n-                        let result = self.resolve_ty_as_possible_inner(tv_stack, known_ty.clone());\n+                        tv_stack.push(tv);\n+                        let result = self.resolve_ty_as_possible_inner(\n+                            tv_stack,\n+                            known_ty.assert_ty_ref(&Interner).clone(),\n+                        );\n                         tv_stack.pop();\n                         result\n                     } else {\n@@ -528,23 +280,24 @@ impl InferenceTable {\n \n     /// Resolves the type completely; type variables without known type are\n     /// replaced by TyKind::Unknown.\n-    fn resolve_ty_completely_inner(&mut self, tv_stack: &mut Vec<TypeVarId>, ty: Ty) -> Ty {\n+    fn resolve_ty_completely_inner(&mut self, tv_stack: &mut Vec<InferenceVar>, ty: Ty) -> Ty {\n+        // FIXME implement as a proper Folder, handle lifetimes and consts as well\n         fold_tys(\n             ty,\n             |ty, _| match ty.kind(&Interner) {\n                 &TyKind::InferenceVar(tv, kind) => {\n-                    let inner = from_inference_var(tv);\n-                    if tv_stack.contains(&inner) {\n+                    if tv_stack.contains(&tv) {\n                         cov_mark::hit!(type_var_cycles_resolve_completely);\n                         // recursive type\n                         return self.type_variable_table.fallback_value(tv, kind);\n                     }\n-                    if let Some(known_ty) =\n-                        self.var_unification_table.inlined_probe_value(inner).known()\n-                    {\n+                    if let Some(known_ty) = self.var_unification_table.probe_var(tv) {\n                         // known_ty may contain other variables that are known by now\n-                        tv_stack.push(inner);\n-                        let result = self.resolve_ty_completely_inner(tv_stack, known_ty.clone());\n+                        tv_stack.push(tv);\n+                        let result = self.resolve_ty_completely_inner(\n+                            tv_stack,\n+                            known_ty.assert_ty_ref(&Interner).clone(),\n+                        );\n                         tv_stack.pop();\n                         result\n                     } else {\n@@ -558,68 +311,10 @@ impl InferenceTable {\n     }\n }\n \n-/// The ID of a type variable.\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n-pub(super) struct TypeVarId(pub(super) u32);\n-\n-impl UnifyKey for TypeVarId {\n-    type Value = TypeVarValue;\n-\n-    fn index(&self) -> u32 {\n-        self.0\n-    }\n-\n-    fn from_index(i: u32) -> Self {\n-        TypeVarId(i)\n-    }\n-\n-    fn tag() -> &'static str {\n-        \"TypeVarId\"\n-    }\n-}\n-\n-fn from_inference_var(var: InferenceVar) -> TypeVarId {\n-    TypeVarId(var.index())\n-}\n-\n-fn to_inference_var(TypeVarId(index): TypeVarId) -> InferenceVar {\n-    index.into()\n-}\n-\n-/// The value of a type variable: either we already know the type, or we don't\n-/// know it yet.\n-#[derive(Clone, PartialEq, Eq, Debug)]\n-pub(super) enum TypeVarValue {\n-    Known(Ty),\n-    Unknown,\n-}\n-\n-impl TypeVarValue {\n-    fn known(&self) -> Option<&Ty> {\n-        match self {\n-            TypeVarValue::Known(ty) => Some(ty),\n-            TypeVarValue::Unknown => None,\n-        }\n-    }\n-}\n-\n-impl UnifyValue for TypeVarValue {\n-    type Error = NoError;\n-\n-    fn unify_values(value1: &Self, value2: &Self) -> Result<Self, NoError> {\n-        match (value1, value2) {\n-            // We should never equate two type variables, both of which have\n-            // known types. Instead, we recursively equate those types.\n-            (TypeVarValue::Known(t1), TypeVarValue::Known(t2)) => panic!(\n-                \"equating two type variables, both of which have known types: {:?} and {:?}\",\n-                t1, t2\n-            ),\n-\n-            // If one side is known, prefer that one.\n-            (TypeVarValue::Known(..), TypeVarValue::Unknown) => Ok(value1.clone()),\n-            (TypeVarValue::Unknown, TypeVarValue::Known(..)) => Ok(value2.clone()),\n-\n-            (TypeVarValue::Unknown, TypeVarValue::Unknown) => Ok(TypeVarValue::Unknown),\n-        }\n+impl<'a> fmt::Debug for InferenceTable<'a> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"InferenceTable\")\n+            .field(\"num_vars\", &self.type_variable_table.inner.len())\n+            .finish()\n     }\n }"}, {"sha": "37e1f89d82564b53acd95081af98dbde06444c26", "filename": "crates/hir_ty/src/method_resolution.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/84074cb1852aa702e1307e9533e1fa3448e3e04f/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84074cb1852aa702e1307e9533e1fa3448e3e04f/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs?ref=84074cb1852aa702e1307e9533e1fa3448e3e04f", "patch": "@@ -798,7 +798,8 @@ pub(crate) fn inherent_impl_substs(\n         binders: CanonicalVarKinds::from_iter(&Interner, kinds),\n         value: (self_ty_with_vars, self_ty.value.clone()),\n     };\n-    let substs = super::infer::unify(&tys)?;\n+    let trait_env = Arc::new(TraitEnvironment::default()); // FIXME\n+    let substs = super::infer::unify(db, trait_env, &tys)?;\n     // We only want the substs for the vars we added, not the ones from self_ty.\n     // Also, if any of the vars we added are still in there, we replace them by\n     // Unknown. I think this can only really happen if self_ty contained"}]}