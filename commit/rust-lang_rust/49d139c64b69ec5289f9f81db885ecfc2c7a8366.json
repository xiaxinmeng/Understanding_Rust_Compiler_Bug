{"sha": "49d139c64b69ec5289f9f81db885ecfc2c7a8366", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ5ZDEzOWM2NGI2OWVjNTI4OWY5ZjgxZGI4ODVlY2ZjMmM3YTgzNjY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-05-16T01:26:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-05-16T01:26:13Z"}, "message": "Auto merge of #60693 - saleemjaffer:refactor_fntype_stuff, r=eddyb\n\nrefactor some `FnType` stuff to `rustc::ty::layout`\n\nDoes work in the direction of #56166.", "tree": {"sha": "cce722c0c6f116fd88e3cc695c33c0e19c7174c0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cce722c0c6f116fd88e3cc695c33c0e19c7174c0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/49d139c64b69ec5289f9f81db885ecfc2c7a8366", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/49d139c64b69ec5289f9f81db885ecfc2c7a8366", "html_url": "https://github.com/rust-lang/rust/commit/49d139c64b69ec5289f9f81db885ecfc2c7a8366", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/49d139c64b69ec5289f9f81db885ecfc2c7a8366/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7158ed9cbea805adf8161d3deaadba2f85b7692e", "url": "https://api.github.com/repos/rust-lang/rust/commits/7158ed9cbea805adf8161d3deaadba2f85b7692e", "html_url": "https://github.com/rust-lang/rust/commit/7158ed9cbea805adf8161d3deaadba2f85b7692e"}, {"sha": "44eb607d7665f09967403a1999d99f4559be1c21", "url": "https://api.github.com/repos/rust-lang/rust/commits/44eb607d7665f09967403a1999d99f4559be1c21", "html_url": "https://github.com/rust-lang/rust/commit/44eb607d7665f09967403a1999d99f4559be1c21"}], "stats": {"total": 830, "additions": 419, "deletions": 411}, "files": [{"sha": "6d7b0926c7ae26527fbb131fbec4f251104bbc04", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 383, "deletions": 0, "changes": 383, "blob_url": "https://github.com/rust-lang/rust/blob/49d139c64b69ec5289f9f81db885ecfc2c7a8366/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49d139c64b69ec5289f9f81db885ecfc2c7a8366/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=49d139c64b69ec5289f9f81db885ecfc2c7a8366", "patch": "@@ -19,6 +19,12 @@ use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n                                            StableHasherResult};\n \n pub use rustc_target::abi::*;\n+use rustc_target::spec::{HasTargetSpec, abi::Abi as SpecAbi};\n+use rustc_target::abi::call::{\n+    ArgAttribute, ArgAttributes, ArgType, Conv, FnType, IgnoreMode, PassMode, Reg, RegKind\n+};\n+\n+\n \n pub trait IntegerExt {\n     fn to_ty<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, signed: bool) -> Ty<'tcx>;\n@@ -2259,3 +2265,380 @@ impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for LayoutError<'gcx>\n         }\n     }\n }\n+\n+pub trait FnTypeExt<'tcx, C>\n+where\n+    C: LayoutOf<Ty = Ty<'tcx>, TyLayout = TyLayout<'tcx>>\n+        + HasDataLayout\n+        + HasTargetSpec\n+        + HasTyCtxt<'tcx>\n+        + HasParamEnv<'tcx>,\n+{\n+    fn of_instance(cx: &C, instance: &ty::Instance<'tcx>) -> Self;\n+    fn new(cx: &C, sig: ty::FnSig<'tcx>, extra_args: &[Ty<'tcx>]) -> Self;\n+    fn new_vtable(cx: &C, sig: ty::FnSig<'tcx>, extra_args: &[Ty<'tcx>]) -> Self;\n+    fn new_internal(\n+        cx: &C,\n+        sig: ty::FnSig<'tcx>,\n+        extra_args: &[Ty<'tcx>],\n+        mk_arg_type: impl Fn(Ty<'tcx>, Option<usize>) -> ArgType<'tcx, Ty<'tcx>>,\n+    ) -> Self;\n+    fn adjust_for_abi(&mut self, cx: &C, abi: SpecAbi);\n+}\n+\n+impl<'tcx, C> FnTypeExt<'tcx, C> for call::FnType<'tcx, Ty<'tcx>>\n+where\n+    C: LayoutOf<Ty = Ty<'tcx>, TyLayout = TyLayout<'tcx>>\n+        + HasDataLayout\n+        + HasTargetSpec\n+        + HasTyCtxt<'tcx>\n+        + HasParamEnv<'tcx>,\n+{\n+    fn of_instance(cx: &C, instance: &ty::Instance<'tcx>) -> Self {\n+        let sig = instance.fn_sig(cx.tcx());\n+        let sig = cx\n+            .tcx()\n+            .normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), &sig);\n+        call::FnType::new(cx, sig, &[])\n+    }\n+\n+    fn new(cx: &C, sig: ty::FnSig<'tcx>, extra_args: &[Ty<'tcx>]) -> Self {\n+        call::FnType::new_internal(cx, sig, extra_args, |ty, _| ArgType::new(cx.layout_of(ty)))\n+    }\n+\n+    fn new_vtable(cx: &C, sig: ty::FnSig<'tcx>, extra_args: &[Ty<'tcx>]) -> Self {\n+        FnTypeExt::new_internal(cx, sig, extra_args, |ty, arg_idx| {\n+            let mut layout = cx.layout_of(ty);\n+            // Don't pass the vtable, it's not an argument of the virtual fn.\n+            // Instead, pass just the data pointer, but give it the type `*const/mut dyn Trait`\n+            // or `&/&mut dyn Trait` because this is special-cased elsewhere in codegen\n+            if arg_idx == Some(0) {\n+                let fat_pointer_ty = if layout.is_unsized() {\n+                    // unsized `self` is passed as a pointer to `self`\n+                    // FIXME (mikeyhew) change this to use &own if it is ever added to the language\n+                    cx.tcx().mk_mut_ptr(layout.ty)\n+                } else {\n+                    match layout.abi {\n+                        Abi::ScalarPair(..) => (),\n+                        _ => bug!(\"receiver type has unsupported layout: {:?}\", layout),\n+                    }\n+\n+                    // In the case of Rc<Self>, we need to explicitly pass a *mut RcBox<Self>\n+                    // with a Scalar (not ScalarPair) ABI. This is a hack that is understood\n+                    // elsewhere in the compiler as a method on a `dyn Trait`.\n+                    // To get the type `*mut RcBox<Self>`, we just keep unwrapping newtypes until we\n+                    // get a built-in pointer type\n+                    let mut fat_pointer_layout = layout;\n+                    'descend_newtypes: while !fat_pointer_layout.ty.is_unsafe_ptr()\n+                        && !fat_pointer_layout.ty.is_region_ptr()\n+                    {\n+                        'iter_fields: for i in 0..fat_pointer_layout.fields.count() {\n+                            let field_layout = fat_pointer_layout.field(cx, i);\n+\n+                            if !field_layout.is_zst() {\n+                                fat_pointer_layout = field_layout;\n+                                continue 'descend_newtypes;\n+                            }\n+                        }\n+\n+                        bug!(\n+                            \"receiver has no non-zero-sized fields {:?}\",\n+                            fat_pointer_layout\n+                        );\n+                    }\n+\n+                    fat_pointer_layout.ty\n+                };\n+\n+                // we now have a type like `*mut RcBox<dyn Trait>`\n+                // change its layout to that of `*mut ()`, a thin pointer, but keep the same type\n+                // this is understood as a special case elsewhere in the compiler\n+                let unit_pointer_ty = cx.tcx().mk_mut_ptr(cx.tcx().mk_unit());\n+                layout = cx.layout_of(unit_pointer_ty);\n+                layout.ty = fat_pointer_ty;\n+            }\n+            ArgType::new(layout)\n+        })\n+    }\n+\n+    fn new_internal(\n+        cx: &C,\n+        sig: ty::FnSig<'tcx>,\n+        extra_args: &[Ty<'tcx>],\n+        mk_arg_type: impl Fn(Ty<'tcx>, Option<usize>) -> ArgType<'tcx, Ty<'tcx>>,\n+    ) -> Self {\n+        debug!(\"FnType::new_internal({:?}, {:?})\", sig, extra_args);\n+\n+        use rustc_target::spec::abi::Abi::*;\n+        let conv = match cx.tcx().sess.target.target.adjust_abi(sig.abi) {\n+            RustIntrinsic | PlatformIntrinsic | Rust | RustCall => Conv::C,\n+\n+            // It's the ABI's job to select this, not ours.\n+            System => bug!(\"system abi should be selected elsewhere\"),\n+\n+            Stdcall => Conv::X86Stdcall,\n+            Fastcall => Conv::X86Fastcall,\n+            Vectorcall => Conv::X86VectorCall,\n+            Thiscall => Conv::X86ThisCall,\n+            C => Conv::C,\n+            Unadjusted => Conv::C,\n+            Win64 => Conv::X86_64Win64,\n+            SysV64 => Conv::X86_64SysV,\n+            Aapcs => Conv::ArmAapcs,\n+            PtxKernel => Conv::PtxKernel,\n+            Msp430Interrupt => Conv::Msp430Intr,\n+            X86Interrupt => Conv::X86Intr,\n+            AmdGpuKernel => Conv::AmdGpuKernel,\n+\n+            // These API constants ought to be more specific...\n+            Cdecl => Conv::C,\n+        };\n+\n+        let mut inputs = sig.inputs();\n+        let extra_args = if sig.abi == RustCall {\n+            assert!(!sig.c_variadic && extra_args.is_empty());\n+\n+            match sig.inputs().last().unwrap().sty {\n+                ty::Tuple(tupled_arguments) => {\n+                    inputs = &sig.inputs()[0..sig.inputs().len() - 1];\n+                    tupled_arguments.iter().map(|k| k.expect_ty()).collect()\n+                }\n+                _ => {\n+                    bug!(\n+                        \"argument to function with \\\"rust-call\\\" ABI \\\n+                         is not a tuple\"\n+                    );\n+                }\n+            }\n+        } else {\n+            assert!(sig.c_variadic || extra_args.is_empty());\n+            extra_args.to_vec()\n+        };\n+\n+        let target = &cx.tcx().sess.target.target;\n+        let win_x64_gnu =\n+            target.target_os == \"windows\" && target.arch == \"x86_64\" && target.target_env == \"gnu\";\n+        let linux_s390x =\n+            target.target_os == \"linux\" && target.arch == \"s390x\" && target.target_env == \"gnu\";\n+        let linux_sparc64 =\n+            target.target_os == \"linux\" && target.arch == \"sparc64\" && target.target_env == \"gnu\";\n+        let rust_abi = match sig.abi {\n+            RustIntrinsic | PlatformIntrinsic | Rust | RustCall => true,\n+            _ => false,\n+        };\n+\n+        // Handle safe Rust thin and fat pointers.\n+        let adjust_for_rust_scalar = |attrs: &mut ArgAttributes,\n+                                      scalar: &Scalar,\n+                                      layout: TyLayout<'tcx>,\n+                                      offset: Size,\n+                                      is_return: bool| {\n+            // Booleans are always an i1 that needs to be zero-extended.\n+            if scalar.is_bool() {\n+                attrs.set(ArgAttribute::ZExt);\n+                return;\n+            }\n+\n+            // Only pointer types handled below.\n+            if scalar.value != Pointer {\n+                return;\n+            }\n+\n+            if scalar.valid_range.start() < scalar.valid_range.end() {\n+                if *scalar.valid_range.start() > 0 {\n+                    attrs.set(ArgAttribute::NonNull);\n+                }\n+            }\n+\n+            if let Some(pointee) = layout.pointee_info_at(cx, offset) {\n+                if let Some(kind) = pointee.safe {\n+                    attrs.pointee_size = pointee.size;\n+                    attrs.pointee_align = Some(pointee.align);\n+\n+                    // `Box` pointer parameters never alias because ownership is transferred\n+                    // `&mut` pointer parameters never alias other parameters,\n+                    // or mutable global data\n+                    //\n+                    // `&T` where `T` contains no `UnsafeCell<U>` is immutable,\n+                    // and can be marked as both `readonly` and `noalias`, as\n+                    // LLVM's definition of `noalias` is based solely on memory\n+                    // dependencies rather than pointer equality\n+                    let no_alias = match kind {\n+                        PointerKind::Shared => false,\n+                        PointerKind::UniqueOwned => true,\n+                        PointerKind::Frozen | PointerKind::UniqueBorrowed => !is_return,\n+                    };\n+                    if no_alias {\n+                        attrs.set(ArgAttribute::NoAlias);\n+                    }\n+\n+                    if kind == PointerKind::Frozen && !is_return {\n+                        attrs.set(ArgAttribute::ReadOnly);\n+                    }\n+                }\n+            }\n+        };\n+\n+        // Store the index of the last argument. This is useful for working with\n+        // C-compatible variadic arguments.\n+        let last_arg_idx = if sig.inputs().is_empty() {\n+            None\n+        } else {\n+            Some(sig.inputs().len() - 1)\n+        };\n+\n+        let arg_of = |ty: Ty<'tcx>, arg_idx: Option<usize>| {\n+            let is_return = arg_idx.is_none();\n+            let mut arg = mk_arg_type(ty, arg_idx);\n+            if arg.layout.is_zst() {\n+                // For some forsaken reason, x86_64-pc-windows-gnu\n+                // doesn't ignore zero-sized struct arguments.\n+                // The same is true for s390x-unknown-linux-gnu\n+                // and sparc64-unknown-linux-gnu.\n+                if is_return || rust_abi || (!win_x64_gnu && !linux_s390x && !linux_sparc64) {\n+                    arg.mode = PassMode::Ignore(IgnoreMode::Zst);\n+                }\n+            }\n+\n+            // If this is a C-variadic function, this is not the return value,\n+            // and there is one or more fixed arguments; ensure that the `VaList`\n+            // is ignored as an argument.\n+            if sig.c_variadic {\n+                match (last_arg_idx, arg_idx) {\n+                    (Some(last_idx), Some(cur_idx)) if last_idx == cur_idx => {\n+                        let va_list_did = match cx.tcx().lang_items().va_list() {\n+                            Some(did) => did,\n+                            None => bug!(\"`va_list` lang item required for C-variadic functions\"),\n+                        };\n+                        match ty.sty {\n+                            ty::Adt(def, _) if def.did == va_list_did => {\n+                                // This is the \"spoofed\" `VaList`. Set the arguments mode\n+                                // so that it will be ignored.\n+                                arg.mode = PassMode::Ignore(IgnoreMode::CVarArgs);\n+                            }\n+                            _ => (),\n+                        }\n+                    }\n+                    _ => {}\n+                }\n+            }\n+\n+            // FIXME(eddyb) other ABIs don't have logic for scalar pairs.\n+            if !is_return && rust_abi {\n+                if let Abi::ScalarPair(ref a, ref b) = arg.layout.abi {\n+                    let mut a_attrs = ArgAttributes::new();\n+                    let mut b_attrs = ArgAttributes::new();\n+                    adjust_for_rust_scalar(&mut a_attrs, a, arg.layout, Size::ZERO, false);\n+                    adjust_for_rust_scalar(\n+                        &mut b_attrs,\n+                        b,\n+                        arg.layout,\n+                        a.value.size(cx).align_to(b.value.align(cx).abi),\n+                        false,\n+                    );\n+                    arg.mode = PassMode::Pair(a_attrs, b_attrs);\n+                    return arg;\n+                }\n+            }\n+\n+            if let Abi::Scalar(ref scalar) = arg.layout.abi {\n+                if let PassMode::Direct(ref mut attrs) = arg.mode {\n+                    adjust_for_rust_scalar(attrs, scalar, arg.layout, Size::ZERO, is_return);\n+                }\n+            }\n+\n+            arg\n+        };\n+\n+        let mut fn_ty = FnType {\n+            ret: arg_of(sig.output(), None),\n+            args: inputs\n+                .iter()\n+                .cloned()\n+                .chain(extra_args)\n+                .enumerate()\n+                .map(|(i, ty)| arg_of(ty, Some(i)))\n+                .collect(),\n+            c_variadic: sig.c_variadic,\n+            conv,\n+        };\n+        fn_ty.adjust_for_abi(cx, sig.abi);\n+        fn_ty\n+    }\n+\n+    fn adjust_for_abi(&mut self, cx: &C, abi: SpecAbi) {\n+        if abi == SpecAbi::Unadjusted {\n+            return;\n+        }\n+\n+        if abi == SpecAbi::Rust\n+            || abi == SpecAbi::RustCall\n+            || abi == SpecAbi::RustIntrinsic\n+            || abi == SpecAbi::PlatformIntrinsic\n+        {\n+            let fixup = |arg: &mut ArgType<'tcx, Ty<'tcx>>| {\n+                if arg.is_ignore() {\n+                    return;\n+                }\n+\n+                match arg.layout.abi {\n+                    Abi::Aggregate { .. } => {}\n+\n+                    // This is a fun case! The gist of what this is doing is\n+                    // that we want callers and callees to always agree on the\n+                    // ABI of how they pass SIMD arguments. If we were to *not*\n+                    // make these arguments indirect then they'd be immediates\n+                    // in LLVM, which means that they'd used whatever the\n+                    // appropriate ABI is for the callee and the caller. That\n+                    // means, for example, if the caller doesn't have AVX\n+                    // enabled but the callee does, then passing an AVX argument\n+                    // across this boundary would cause corrupt data to show up.\n+                    //\n+                    // This problem is fixed by unconditionally passing SIMD\n+                    // arguments through memory between callers and callees\n+                    // which should get them all to agree on ABI regardless of\n+                    // target feature sets. Some more information about this\n+                    // issue can be found in #44367.\n+                    //\n+                    // Note that the platform intrinsic ABI is exempt here as\n+                    // that's how we connect up to LLVM and it's unstable\n+                    // anyway, we control all calls to it in libstd.\n+                    Abi::Vector { .. }\n+                        if abi != SpecAbi::PlatformIntrinsic\n+                            && cx.tcx().sess.target.target.options.simd_types_indirect =>\n+                    {\n+                        arg.make_indirect();\n+                        return;\n+                    }\n+\n+                    _ => return,\n+                }\n+\n+                let size = arg.layout.size;\n+                if arg.layout.is_unsized() || size > Pointer.size(cx) {\n+                    arg.make_indirect();\n+                } else {\n+                    // We want to pass small aggregates as immediates, but using\n+                    // a LLVM aggregate type for this leads to bad optimizations,\n+                    // so we pick an appropriately sized integer type instead.\n+                    arg.cast_to(Reg {\n+                        kind: RegKind::Integer,\n+                        size,\n+                    });\n+                }\n+            };\n+            fixup(&mut self.ret);\n+            for arg in &mut self.args {\n+                fixup(arg);\n+            }\n+            if let PassMode::Indirect(ref mut attrs, _) = self.ret.mode {\n+                attrs.set(ArgAttribute::StructRet);\n+            }\n+            return;\n+        }\n+\n+        if let Err(msg) = self.adjust_for_cabi(cx, abi) {\n+            cx.tcx().sess.fatal(&msg);\n+        }\n+    }\n+}"}, {"sha": "38d4b7e3f9d85504db9548447f19f8e294fec49f", "filename": "src/librustc_codegen_llvm/abi.rs", "status": "modified", "additions": 5, "deletions": 386, "changes": 391, "blob_url": "https://github.com/rust-lang/rust/blob/49d139c64b69ec5289f9f81db885ecfc2c7a8366/src%2Flibrustc_codegen_llvm%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49d139c64b69ec5289f9f81db885ecfc2c7a8366/src%2Flibrustc_codegen_llvm%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fabi.rs?ref=49d139c64b69ec5289f9f81db885ecfc2c7a8366", "patch": "@@ -11,9 +11,9 @@ use rustc_target::abi::call::ArgType;\n \n use rustc_codegen_ssa::traits::*;\n \n-use rustc_target::abi::{HasDataLayout, LayoutOf, Size, TyLayout, Abi as LayoutAbi};\n-use rustc::ty::{self, Ty, Instance};\n-use rustc::ty::layout::{self, PointerKind};\n+use rustc_target::abi::{HasDataLayout, LayoutOf};\n+use rustc::ty::{Ty};\n+use rustc::ty::layout::{self};\n \n use libc::c_uint;\n \n@@ -294,380 +294,15 @@ impl ArgTypeMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n     }\n }\n \n-pub trait FnTypeExt<'tcx> {\n-    fn of_instance(cx: &CodegenCx<'ll, 'tcx>, instance: &ty::Instance<'tcx>) -> Self;\n-    fn new(cx: &CodegenCx<'ll, 'tcx>,\n-           sig: ty::FnSig<'tcx>,\n-           extra_args: &[Ty<'tcx>]) -> Self;\n-    fn new_vtable(cx: &CodegenCx<'ll, 'tcx>,\n-                  sig: ty::FnSig<'tcx>,\n-                  extra_args: &[Ty<'tcx>]) -> Self;\n-    fn new_internal(\n-        cx: &CodegenCx<'ll, 'tcx>,\n-        sig: ty::FnSig<'tcx>,\n-        extra_args: &[Ty<'tcx>],\n-        mk_arg_type: impl Fn(Ty<'tcx>, Option<usize>) -> ArgType<'tcx, Ty<'tcx>>,\n-    ) -> Self;\n-    fn adjust_for_abi(&mut self,\n-                      cx: &CodegenCx<'ll, 'tcx>,\n-                      abi: Abi);\n+pub trait FnTypeLlvmExt<'tcx> {\n     fn llvm_type(&self, cx: &CodegenCx<'ll, 'tcx>) -> &'ll Type;\n     fn ptr_to_llvm_type(&self, cx: &CodegenCx<'ll, 'tcx>) -> &'ll Type;\n     fn llvm_cconv(&self) -> llvm::CallConv;\n     fn apply_attrs_llfn(&self, llfn: &'ll Value);\n     fn apply_attrs_callsite(&self, bx: &mut Builder<'a, 'll, 'tcx>, callsite: &'ll Value);\n }\n \n-impl<'tcx> FnTypeExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n-    fn of_instance(cx: &CodegenCx<'ll, 'tcx>, instance: &ty::Instance<'tcx>) -> Self {\n-        let sig = instance.fn_sig(cx.tcx);\n-        let sig = cx.tcx.normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), &sig);\n-        FnType::new(cx, sig, &[])\n-    }\n-\n-    fn new(cx: &CodegenCx<'ll, 'tcx>,\n-           sig: ty::FnSig<'tcx>,\n-           extra_args: &[Ty<'tcx>]) -> Self {\n-        FnType::new_internal(cx, sig, extra_args, |ty, _| {\n-            ArgType::new(cx.layout_of(ty))\n-        })\n-    }\n-\n-    fn new_vtable(cx: &CodegenCx<'ll, 'tcx>,\n-                  sig: ty::FnSig<'tcx>,\n-                  extra_args: &[Ty<'tcx>]) -> Self {\n-        FnType::new_internal(cx, sig, extra_args, |ty, arg_idx| {\n-            let mut layout = cx.layout_of(ty);\n-            // Don't pass the vtable, it's not an argument of the virtual fn.\n-            // Instead, pass just the data pointer, but give it the type `*const/mut dyn Trait`\n-            // or `&/&mut dyn Trait` because this is special-cased elsewhere in codegen\n-            if arg_idx == Some(0) {\n-                let fat_pointer_ty = if layout.is_unsized() {\n-                    // unsized `self` is passed as a pointer to `self`\n-                    // FIXME (mikeyhew) change this to use &own if it is ever added to the language\n-                    cx.tcx.mk_mut_ptr(layout.ty)\n-                } else {\n-                    match layout.abi {\n-                        LayoutAbi::ScalarPair(..) => (),\n-                        _ => bug!(\"receiver type has unsupported layout: {:?}\", layout)\n-                    }\n-\n-                    // In the case of Rc<Self>, we need to explicitly pass a *mut RcBox<Self>\n-                    // with a Scalar (not ScalarPair) ABI. This is a hack that is understood\n-                    // elsewhere in the compiler as a method on a `dyn Trait`.\n-                    // To get the type `*mut RcBox<Self>`, we just keep unwrapping newtypes until we\n-                    // get a built-in pointer type\n-                    let mut fat_pointer_layout = layout;\n-                    'descend_newtypes: while !fat_pointer_layout.ty.is_unsafe_ptr()\n-                        && !fat_pointer_layout.ty.is_region_ptr()\n-                    {\n-                        'iter_fields: for i in 0..fat_pointer_layout.fields.count() {\n-                            let field_layout = fat_pointer_layout.field(cx, i);\n-\n-                            if !field_layout.is_zst() {\n-                                fat_pointer_layout = field_layout;\n-                                continue 'descend_newtypes\n-                            }\n-                        }\n-\n-                        bug!(\"receiver has no non-zero-sized fields {:?}\", fat_pointer_layout);\n-                    }\n-\n-                    fat_pointer_layout.ty\n-                };\n-\n-                // we now have a type like `*mut RcBox<dyn Trait>`\n-                // change its layout to that of `*mut ()`, a thin pointer, but keep the same type\n-                // this is understood as a special case elsewhere in the compiler\n-                let unit_pointer_ty = cx.tcx.mk_mut_ptr(cx.tcx.mk_unit());\n-                layout = cx.layout_of(unit_pointer_ty);\n-                layout.ty = fat_pointer_ty;\n-            }\n-            ArgType::new(layout)\n-        })\n-    }\n-\n-    fn new_internal(\n-        cx: &CodegenCx<'ll, 'tcx>,\n-        sig: ty::FnSig<'tcx>,\n-        extra_args: &[Ty<'tcx>],\n-        mk_arg_type: impl Fn(Ty<'tcx>, Option<usize>) -> ArgType<'tcx, Ty<'tcx>>,\n-    ) -> Self {\n-        debug!(\"FnType::new_internal({:?}, {:?})\", sig, extra_args);\n-\n-        use self::Abi::*;\n-        let conv = match cx.sess().target.target.adjust_abi(sig.abi) {\n-            RustIntrinsic | PlatformIntrinsic |\n-            Rust | RustCall => Conv::C,\n-\n-            // It's the ABI's job to select this, not ours.\n-            System => bug!(\"system abi should be selected elsewhere\"),\n-\n-            Stdcall => Conv::X86Stdcall,\n-            Fastcall => Conv::X86Fastcall,\n-            Vectorcall => Conv::X86VectorCall,\n-            Thiscall => Conv::X86ThisCall,\n-            C => Conv::C,\n-            Unadjusted => Conv::C,\n-            Win64 => Conv::X86_64Win64,\n-            SysV64 => Conv::X86_64SysV,\n-            Aapcs => Conv::ArmAapcs,\n-            PtxKernel => Conv::PtxKernel,\n-            Msp430Interrupt => Conv::Msp430Intr,\n-            X86Interrupt => Conv::X86Intr,\n-            AmdGpuKernel => Conv::AmdGpuKernel,\n-\n-            // These API constants ought to be more specific...\n-            Cdecl => Conv::C,\n-        };\n-\n-        let mut inputs = sig.inputs();\n-        let extra_args = if sig.abi == RustCall {\n-            assert!(!sig.c_variadic && extra_args.is_empty());\n-\n-            match sig.inputs().last().unwrap().sty {\n-                ty::Tuple(tupled_arguments) => {\n-                    inputs = &sig.inputs()[0..sig.inputs().len() - 1];\n-                    tupled_arguments.iter().map(|k| k.expect_ty()).collect()\n-                }\n-                _ => {\n-                    bug!(\"argument to function with \\\"rust-call\\\" ABI \\\n-                          is not a tuple\");\n-                }\n-            }\n-        } else {\n-            assert!(sig.c_variadic || extra_args.is_empty());\n-            extra_args.to_vec()\n-        };\n-\n-        let target = &cx.sess().target.target;\n-        let win_x64_gnu = target.target_os == \"windows\"\n-                       && target.arch == \"x86_64\"\n-                       && target.target_env == \"gnu\";\n-        let linux_s390x = target.target_os == \"linux\"\n-                       && target.arch == \"s390x\"\n-                       && target.target_env == \"gnu\";\n-        let linux_sparc64 = target.target_os == \"linux\"\n-                       && target.arch == \"sparc64\"\n-                       && target.target_env == \"gnu\";\n-        let rust_abi = match sig.abi {\n-            RustIntrinsic | PlatformIntrinsic | Rust | RustCall => true,\n-            _ => false\n-        };\n-\n-        // Handle safe Rust thin and fat pointers.\n-        let adjust_for_rust_scalar = |attrs: &mut ArgAttributes,\n-                                      scalar: &layout::Scalar,\n-                                      layout: TyLayout<'tcx, Ty<'tcx>>,\n-                                      offset: Size,\n-                                      is_return: bool| {\n-            // Booleans are always an i1 that needs to be zero-extended.\n-            if scalar.is_bool() {\n-                attrs.set(ArgAttribute::ZExt);\n-                return;\n-            }\n-\n-            // Only pointer types handled below.\n-            if scalar.value != layout::Pointer {\n-                return;\n-            }\n-\n-            if scalar.valid_range.start() < scalar.valid_range.end() {\n-                if *scalar.valid_range.start() > 0 {\n-                    attrs.set(ArgAttribute::NonNull);\n-                }\n-            }\n-\n-            if let Some(pointee) = layout.pointee_info_at(cx, offset) {\n-                if let Some(kind) = pointee.safe {\n-                    attrs.pointee_size = pointee.size;\n-                    attrs.pointee_align = Some(pointee.align);\n-\n-                    // `Box` pointer parameters never alias because ownership is transferred\n-                    // `&mut` pointer parameters never alias other parameters,\n-                    // or mutable global data\n-                    //\n-                    // `&T` where `T` contains no `UnsafeCell<U>` is immutable,\n-                    // and can be marked as both `readonly` and `noalias`, as\n-                    // LLVM's definition of `noalias` is based solely on memory\n-                    // dependencies rather than pointer equality\n-                    let no_alias = match kind {\n-                        PointerKind::Shared => false,\n-                        PointerKind::UniqueOwned => true,\n-                        PointerKind::Frozen |\n-                        PointerKind::UniqueBorrowed => !is_return\n-                    };\n-                    if no_alias {\n-                        attrs.set(ArgAttribute::NoAlias);\n-                    }\n-\n-                    if kind == PointerKind::Frozen && !is_return {\n-                        attrs.set(ArgAttribute::ReadOnly);\n-                    }\n-                }\n-            }\n-        };\n-\n-        // Store the index of the last argument. This is useful for working with\n-        // C-compatible variadic arguments.\n-        let last_arg_idx = if sig.inputs().is_empty() {\n-            None\n-        } else {\n-            Some(sig.inputs().len() - 1)\n-        };\n-\n-        let arg_of = |ty: Ty<'tcx>, arg_idx: Option<usize>| {\n-            let is_return = arg_idx.is_none();\n-            let mut arg = mk_arg_type(ty, arg_idx);\n-            if arg.layout.is_zst() {\n-                // For some forsaken reason, x86_64-pc-windows-gnu\n-                // doesn't ignore zero-sized struct arguments.\n-                // The same is true for s390x-unknown-linux-gnu\n-                // and sparc64-unknown-linux-gnu.\n-                if is_return || rust_abi || (!win_x64_gnu && !linux_s390x && !linux_sparc64) {\n-                    arg.mode = PassMode::Ignore(IgnoreMode::Zst);\n-                }\n-            }\n-\n-            // If this is a C-variadic function, this is not the return value,\n-            // and there is one or more fixed arguments; ensure that the `VaList`\n-            // is ignored as an argument.\n-            if sig.c_variadic {\n-                match (last_arg_idx, arg_idx) {\n-                    (Some(last_idx), Some(cur_idx)) if last_idx == cur_idx => {\n-                        let va_list_did = match cx.tcx.lang_items().va_list() {\n-                            Some(did) => did,\n-                            None => bug!(\"`va_list` lang item required for C-variadic functions\"),\n-                        };\n-                        match ty.sty {\n-                            ty::Adt(def, _) if def.did == va_list_did => {\n-                                // This is the \"spoofed\" `VaList`. Set the arguments mode\n-                                // so that it will be ignored.\n-                                arg.mode = PassMode::Ignore(IgnoreMode::CVarArgs);\n-                            },\n-                            _ => (),\n-                        }\n-                    }\n-                    _ => {}\n-                }\n-            }\n-\n-            // FIXME(eddyb) other ABIs don't have logic for scalar pairs.\n-            if !is_return && rust_abi {\n-                if let layout::Abi::ScalarPair(ref a, ref b) = arg.layout.abi {\n-                    let mut a_attrs = ArgAttributes::new();\n-                    let mut b_attrs = ArgAttributes::new();\n-                    adjust_for_rust_scalar(&mut a_attrs,\n-                                           a,\n-                                           arg.layout,\n-                                           Size::ZERO,\n-                                           false);\n-                    adjust_for_rust_scalar(&mut b_attrs,\n-                                           b,\n-                                           arg.layout,\n-                                           a.value.size(cx).align_to(b.value.align(cx).abi),\n-                                           false);\n-                    arg.mode = PassMode::Pair(a_attrs, b_attrs);\n-                    return arg;\n-                }\n-            }\n-\n-            if let layout::Abi::Scalar(ref scalar) = arg.layout.abi {\n-                if let PassMode::Direct(ref mut attrs) = arg.mode {\n-                    adjust_for_rust_scalar(attrs,\n-                                           scalar,\n-                                           arg.layout,\n-                                           Size::ZERO,\n-                                           is_return);\n-                }\n-            }\n-\n-            arg\n-        };\n-\n-        let mut fn_ty = FnType {\n-            ret: arg_of(sig.output(), None),\n-            args: inputs.iter().cloned().chain(extra_args).enumerate().map(|(i, ty)| {\n-                arg_of(ty, Some(i))\n-            }).collect(),\n-            c_variadic: sig.c_variadic,\n-            conv,\n-        };\n-        fn_ty.adjust_for_abi(cx, sig.abi);\n-        fn_ty\n-    }\n-\n-    fn adjust_for_abi(&mut self,\n-                      cx: &CodegenCx<'ll, 'tcx>,\n-                      abi: Abi) {\n-        if abi == Abi::Unadjusted { return }\n-\n-        if abi == Abi::Rust || abi == Abi::RustCall ||\n-           abi == Abi::RustIntrinsic || abi == Abi::PlatformIntrinsic {\n-            let fixup = |arg: &mut ArgType<'tcx, Ty<'tcx>>| {\n-                if arg.is_ignore() { return; }\n-\n-                match arg.layout.abi {\n-                    layout::Abi::Aggregate { .. } => {}\n-\n-                    // This is a fun case! The gist of what this is doing is\n-                    // that we want callers and callees to always agree on the\n-                    // ABI of how they pass SIMD arguments. If we were to *not*\n-                    // make these arguments indirect then they'd be immediates\n-                    // in LLVM, which means that they'd used whatever the\n-                    // appropriate ABI is for the callee and the caller. That\n-                    // means, for example, if the caller doesn't have AVX\n-                    // enabled but the callee does, then passing an AVX argument\n-                    // across this boundary would cause corrupt data to show up.\n-                    //\n-                    // This problem is fixed by unconditionally passing SIMD\n-                    // arguments through memory between callers and callees\n-                    // which should get them all to agree on ABI regardless of\n-                    // target feature sets. Some more information about this\n-                    // issue can be found in #44367.\n-                    //\n-                    // Note that the platform intrinsic ABI is exempt here as\n-                    // that's how we connect up to LLVM and it's unstable\n-                    // anyway, we control all calls to it in libstd.\n-                    layout::Abi::Vector { .. }\n-                        if abi != Abi::PlatformIntrinsic &&\n-                            cx.sess().target.target.options.simd_types_indirect =>\n-                    {\n-                        arg.make_indirect();\n-                        return\n-                    }\n-\n-                    _ => return\n-                }\n-\n-                let size = arg.layout.size;\n-                if arg.layout.is_unsized() || size > layout::Pointer.size(cx) {\n-                    arg.make_indirect();\n-                } else {\n-                    // We want to pass small aggregates as immediates, but using\n-                    // a LLVM aggregate type for this leads to bad optimizations,\n-                    // so we pick an appropriately sized integer type instead.\n-                    arg.cast_to(Reg {\n-                        kind: RegKind::Integer,\n-                        size\n-                    });\n-                }\n-            };\n-            fixup(&mut self.ret);\n-            for arg in &mut self.args {\n-                fixup(arg);\n-            }\n-            if let PassMode::Indirect(ref mut attrs, _) = self.ret.mode {\n-                attrs.set(ArgAttribute::StructRet);\n-            }\n-            return;\n-        }\n-\n-        if let Err(msg) = self.adjust_for_cabi(cx, abi) {\n-            cx.sess().fatal(&msg);\n-        }\n-    }\n-\n+impl<'tcx> FnTypeLlvmExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n     fn llvm_type(&self, cx: &CodegenCx<'ll, 'tcx>) -> &'ll Type {\n         let args_capacity: usize = self.args.iter().map(|arg|\n             if arg.pad.is_some() { 1 } else { 0 } +\n@@ -836,22 +471,6 @@ impl<'tcx> FnTypeExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n     }\n }\n \n-impl AbiMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n-    fn new_fn_type(&self, sig: ty::FnSig<'tcx>, extra_args: &[Ty<'tcx>]) -> FnType<'tcx, Ty<'tcx>> {\n-        FnType::new(&self, sig, extra_args)\n-    }\n-    fn new_vtable(\n-        &self,\n-        sig: ty::FnSig<'tcx>,\n-        extra_args: &[Ty<'tcx>]\n-    ) -> FnType<'tcx, Ty<'tcx>> {\n-        FnType::new_vtable(&self, sig, extra_args)\n-    }\n-    fn fn_type_of_instance(&self, instance: &Instance<'tcx>) -> FnType<'tcx, Ty<'tcx>> {\n-        FnType::of_instance(&self, instance)\n-    }\n-}\n-\n impl AbiBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n     fn apply_attrs_callsite(\n         &mut self,"}, {"sha": "48808eea3045ea892382cf08046db9297eb4c466", "filename": "src/librustc_codegen_llvm/builder.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/49d139c64b69ec5289f9f81db885ecfc2c7a8366/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49d139c64b69ec5289f9f81db885ecfc2c7a8366/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbuilder.rs?ref=49d139c64b69ec5289f9f81db885ecfc2c7a8366", "patch": "@@ -18,6 +18,7 @@ use rustc_codegen_ssa::traits::*;\n use rustc_codegen_ssa::base::to_immediate;\n use rustc_codegen_ssa::mir::operand::{OperandValue, OperandRef};\n use rustc_codegen_ssa::mir::place::PlaceRef;\n+use rustc_target::spec::{HasTargetSpec, Target};\n use std::borrow::Cow;\n use std::ops::{Deref, Range};\n use std::ptr;\n@@ -72,6 +73,12 @@ impl ty::layout::HasParamEnv<'tcx> for Builder<'_, '_, 'tcx> {\n     }\n }\n \n+impl HasTargetSpec for Builder<'_, '_, 'tcx> {\n+    fn target_spec(&self) -> &Target {\n+        &self.cx.target_spec()\n+    }\n+}\n+\n impl ty::layout::LayoutOf for Builder<'_, '_, 'tcx> {\n     type Ty = Ty<'tcx>;\n     type TyLayout = TyLayout<'tcx>;"}, {"sha": "bcb14b8899ec245bb728af3535bc91e0557bf1f8", "filename": "src/librustc_codegen_llvm/declare.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/49d139c64b69ec5289f9f81db885ecfc2c7a8366/src%2Flibrustc_codegen_llvm%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49d139c64b69ec5289f9f81db885ecfc2c7a8366/src%2Flibrustc_codegen_llvm%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdeclare.rs?ref=49d139c64b69ec5289f9f81db885ecfc2c7a8366", "patch": "@@ -13,13 +13,13 @@\n \n use crate::llvm;\n use crate::llvm::AttributePlace::Function;\n-use crate::abi::{FnType, FnTypeExt};\n+use crate::abi::{FnType, FnTypeLlvmExt};\n use crate::attributes;\n use crate::context::CodegenCx;\n use crate::type_::Type;\n use crate::value::Value;\n use rustc::ty::{self, PolyFnSig};\n-use rustc::ty::layout::LayoutOf;\n+use rustc::ty::layout::{FnTypeExt, LayoutOf};\n use rustc::session::config::Sanitizer;\n use rustc_data_structures::small_c_str::SmallCStr;\n use rustc_codegen_ssa::traits::*;"}, {"sha": "a3d3f0756a5f3997405faf73485934f3bd9987de", "filename": "src/librustc_codegen_llvm/type_.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49d139c64b69ec5289f9f81db885ecfc2c7a8366/src%2Flibrustc_codegen_llvm%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49d139c64b69ec5289f9f81db885ecfc2c7a8366/src%2Flibrustc_codegen_llvm%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Ftype_.rs?ref=49d139c64b69ec5289f9f81db885ecfc2c7a8366", "patch": "@@ -10,7 +10,7 @@ use rustc_codegen_ssa::traits::*;\n \n use crate::common;\n use crate::type_of::LayoutLlvmExt;\n-use crate::abi::{LlvmType, FnTypeExt};\n+use crate::abi::{LlvmType, FnTypeLlvmExt};\n use syntax::ast;\n use rustc::ty::Ty;\n use rustc::ty::layout::{self, Align, Size, TyLayout};"}, {"sha": "800bf505125d677842d88e8023848b91edb342fa", "filename": "src/librustc_codegen_llvm/type_of.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/49d139c64b69ec5289f9f81db885ecfc2c7a8366/src%2Flibrustc_codegen_llvm%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49d139c64b69ec5289f9f81db885ecfc2c7a8366/src%2Flibrustc_codegen_llvm%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Ftype_of.rs?ref=49d139c64b69ec5289f9f81db885ecfc2c7a8366", "patch": "@@ -1,8 +1,8 @@\n-use crate::abi::{FnType, FnTypeExt};\n+use crate::abi::{FnType};\n use crate::common::*;\n use crate::type_::Type;\n use rustc::ty::{self, Ty, TypeFoldable};\n-use rustc::ty::layout::{self, Align, LayoutOf, PointeeInfo, Size, TyLayout};\n+use rustc::ty::layout::{self, Align, LayoutOf, FnTypeExt, PointeeInfo, Size, TyLayout};\n use rustc_target::abi::{FloatTy, TyLayoutMethods};\n use rustc_mir::monomorphize::item::DefPathBasedNames;\n use rustc_codegen_ssa::traits::*;"}, {"sha": "96b8558c1d2c447f2b8149f6d71cf647f5696260", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/49d139c64b69ec5289f9f81db885ecfc2c7a8366/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49d139c64b69ec5289f9f81db885ecfc2c7a8366/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=49d139c64b69ec5289f9f81db885ecfc2c7a8366", "patch": "@@ -1,6 +1,6 @@\n use rustc::middle::lang_items;\n use rustc::ty::{self, Ty, TypeFoldable};\n-use rustc::ty::layout::{self, LayoutOf, HasTyCtxt};\n+use rustc::ty::layout::{self, LayoutOf, HasTyCtxt, FnTypeExt};\n use rustc::mir::{self, Place, PlaceBase, Static, StaticKind};\n use rustc::mir::interpret::InterpError;\n use rustc_target::abi::call::{ArgType, FnType, PassMode, IgnoreMode};\n@@ -334,14 +334,14 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     ty::ParamEnv::reveal_all(),\n                     &sig,\n                 );\n-                let fn_ty = bx.new_vtable(sig, &[]);\n+                let fn_ty = FnType::new_vtable(&bx, sig, &[]);\n                 let vtable = args[1];\n                 args = &args[..1];\n                 (meth::DESTRUCTOR.get_fn(&mut bx, vtable, &fn_ty), fn_ty)\n             }\n             _ => {\n                 (bx.get_fn(drop_fn),\n-                 bx.fn_type_of_instance(&drop_fn))\n+                 FnType::of_instance(&bx, &drop_fn))\n             }\n         };\n         helper.do_call(self, &mut bx, fn_ty, drop_fn, args,\n@@ -439,7 +439,7 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         // Obtain the panic entry point.\n         let def_id = common::langcall(bx.tcx(), Some(span), \"\", lang_item);\n         let instance = ty::Instance::mono(bx.tcx(), def_id);\n-        let fn_ty = bx.fn_type_of_instance(&instance);\n+        let fn_ty = FnType::of_instance(&bx, &instance);\n         let llfn = bx.get_fn(instance);\n \n         // Codegen the actual panic invoke/call.\n@@ -518,15 +518,15 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n         let fn_ty = match def {\n             Some(ty::InstanceDef::Virtual(..)) => {\n-                bx.new_vtable(sig, &extra_args)\n+                FnType::new_vtable(&bx, sig, &extra_args)\n             }\n             Some(ty::InstanceDef::DropGlue(_, None)) => {\n                 // Empty drop glue; a no-op.\n                 let &(_, target) = destination.as_ref().unwrap();\n                 helper.funclet_br(self, &mut bx, target);\n                 return;\n             }\n-            _ => bx.new_fn_type(sig, &extra_args)\n+            _ => FnType::new(&bx, sig, &extra_args)\n         };\n \n         // Emit a panic or a no-op for `panic_if_uninhabited`.\n@@ -556,7 +556,7 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 let def_id =\n                     common::langcall(bx.tcx(), Some(span), \"\", lang_items::PanicFnLangItem);\n                 let instance = ty::Instance::mono(bx.tcx(), def_id);\n-                let fn_ty = bx.fn_type_of_instance(&instance);\n+                let fn_ty = FnType::of_instance(&bx, &instance);\n                 let llfn = bx.get_fn(instance);\n \n                 // Codegen the actual panic invoke/call."}, {"sha": "060d7d18625fcd358323405f1570db82a632d9cc", "filename": "src/librustc_codegen_ssa/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/49d139c64b69ec5289f9f81db885ecfc2c7a8366/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49d139c64b69ec5289f9f81db885ecfc2c7a8366/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs?ref=49d139c64b69ec5289f9f81db885ecfc2c7a8366", "patch": "@@ -1,5 +1,5 @@\n use rustc::ty::{self, Ty, TypeFoldable, UpvarSubsts};\n-use rustc::ty::layout::{TyLayout, HasTyCtxt};\n+use rustc::ty::layout::{TyLayout, HasTyCtxt, FnTypeExt};\n use rustc::mir::{self, Mir};\n use rustc::session::config::DebugInfo;\n use rustc_mir::monomorphize::Instance;\n@@ -202,7 +202,7 @@ pub fn codegen_mir<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n ) {\n     assert!(!instance.substs.needs_infer());\n \n-    let fn_ty = cx.new_fn_type(sig, &[]);\n+    let fn_ty = FnType::new(cx, sig, &[]);\n     debug!(\"fn_ty: {:?}\", fn_ty);\n     let mut debug_context =\n         cx.create_function_debug_context(instance, sig, llfn, mir);"}, {"sha": "509255c37be701853dd2f00e15406fa77c0d189e", "filename": "src/librustc_codegen_ssa/traits/abi.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/49d139c64b69ec5289f9f81db885ecfc2c7a8366/src%2Flibrustc_codegen_ssa%2Ftraits%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49d139c64b69ec5289f9f81db885ecfc2c7a8366/src%2Flibrustc_codegen_ssa%2Ftraits%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fabi.rs?ref=49d139c64b69ec5289f9f81db885ecfc2c7a8366", "patch": "@@ -1,13 +1,7 @@\n use super::BackendTypes;\n-use rustc::ty::{FnSig, Instance, Ty};\n+use rustc::ty::{Ty};\n use rustc_target::abi::call::FnType;\n \n-pub trait AbiMethods<'tcx> {\n-    fn new_fn_type(&self, sig: FnSig<'tcx>, extra_args: &[Ty<'tcx>]) -> FnType<'tcx, Ty<'tcx>>;\n-    fn new_vtable(&self, sig: FnSig<'tcx>, extra_args: &[Ty<'tcx>]) -> FnType<'tcx, Ty<'tcx>>;\n-    fn fn_type_of_instance(&self, instance: &Instance<'tcx>) -> FnType<'tcx, Ty<'tcx>>;\n-}\n-\n pub trait AbiBuilderMethods<'tcx>: BackendTypes {\n     fn apply_attrs_callsite(&mut self, ty: &FnType<'tcx, Ty<'tcx>>, callsite: Self::Value);\n     fn get_param(&self, index: usize) -> Self::Value;"}, {"sha": "0c4c4547a7955a1f0ad3ffdd391ea11d678509b4", "filename": "src/librustc_codegen_ssa/traits/builder.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49d139c64b69ec5289f9f81db885ecfc2c7a8366/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49d139c64b69ec5289f9f81db885ecfc2c7a8366/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbuilder.rs?ref=49d139c64b69ec5289f9f81db885ecfc2c7a8366", "patch": "@@ -11,6 +11,7 @@ use crate::mir::place::PlaceRef;\n use crate::MemFlags;\n use rustc::ty::Ty;\n use rustc::ty::layout::{Align, Size, HasParamEnv};\n+use rustc_target::spec::{HasTargetSpec};\n use std::ops::Range;\n use std::iter::TrustedLen;\n \n@@ -30,6 +31,7 @@ pub trait BuilderMethods<'a, 'tcx: 'a>:\n     + AsmBuilderMethods<'tcx>\n     + StaticBuilderMethods<'tcx>\n     + HasParamEnv<'tcx>\n+    + HasTargetSpec\n \n {\n     fn new_block<'b>(cx: &'a Self::CodegenCx, llfn: Self::Value, name: &'b str) -> Self;"}, {"sha": "2bb619e79f5e06ee0b0781c46463e0433d94ca41", "filename": "src/librustc_codegen_ssa/traits/mod.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/49d139c64b69ec5289f9f81db885ecfc2c7a8366/src%2Flibrustc_codegen_ssa%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49d139c64b69ec5289f9f81db885ecfc2c7a8366/src%2Flibrustc_codegen_ssa%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fmod.rs?ref=49d139c64b69ec5289f9f81db885ecfc2c7a8366", "patch": "@@ -27,7 +27,7 @@ mod statics;\n mod type_;\n mod write;\n \n-pub use self::abi::{AbiBuilderMethods, AbiMethods};\n+pub use self::abi::{AbiBuilderMethods};\n pub use self::asm::{AsmBuilderMethods, AsmMethods};\n pub use self::backend::{Backend, BackendTypes, ExtraBackendMethods};\n pub use self::builder::{BuilderMethods, OverflowOp};\n@@ -41,7 +41,8 @@ pub use self::type_::{\n     ArgTypeMethods, BaseTypeMethods, DerivedTypeMethods, LayoutTypeMethods, TypeMethods,\n };\n pub use self::write::{ModuleBufferMethods, ThinBufferMethods, WriteBackendMethods};\n-use rustc::ty::layout::{HasParamEnv};\n+use rustc::ty::layout::{HasParamEnv, HasTyCtxt};\n+use rustc_target::spec::{HasTargetSpec};\n \n \n use std::fmt;\n@@ -56,11 +57,12 @@ pub trait CodegenMethods<'tcx>:\n     + ConstMethods<'tcx>\n     + StaticMethods\n     + DebugInfoMethods<'tcx>\n-    + AbiMethods<'tcx>\n     + DeclareMethods<'tcx>\n     + AsmMethods<'tcx>\n     + PreDefineMethods<'tcx>\n     + HasParamEnv<'tcx>\n+    + HasTyCtxt<'tcx>\n+    + HasTargetSpec\n {\n }\n \n@@ -71,11 +73,12 @@ impl<'tcx, T> CodegenMethods<'tcx> for T where\n         + ConstMethods<'tcx>\n         + StaticMethods\n         + DebugInfoMethods<'tcx>\n-        + AbiMethods<'tcx>\n         + DeclareMethods<'tcx>\n         + AsmMethods<'tcx>\n         + PreDefineMethods<'tcx>\n         + HasParamEnv<'tcx>\n+        + HasTyCtxt<'tcx>\n+        + HasTargetSpec\n {\n }\n "}]}