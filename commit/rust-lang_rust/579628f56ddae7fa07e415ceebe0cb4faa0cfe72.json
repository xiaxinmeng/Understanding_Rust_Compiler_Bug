{"sha": "579628f56ddae7fa07e415ceebe0cb4faa0cfe72", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU3OTYyOGY1NmRkYWU3ZmEwN2U0MTVjZWViZTBjYjRmYWEwY2ZlNzI=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-06-20T17:20:54Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-06-20T17:20:54Z"}, "message": "Merge pull request #28 from oli-obk/oflo\n\ncleanup overflow binop code", "tree": {"sha": "a609487519dad70ca9f4043359d1b83eaf927fbe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a609487519dad70ca9f4043359d1b83eaf927fbe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/579628f56ddae7fa07e415ceebe0cb4faa0cfe72", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/579628f56ddae7fa07e415ceebe0cb4faa0cfe72", "html_url": "https://github.com/rust-lang/rust/commit/579628f56ddae7fa07e415ceebe0cb4faa0cfe72", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/579628f56ddae7fa07e415ceebe0cb4faa0cfe72/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c9d808e85f9c7ca1957ef54ddeb04d3888bd9552", "url": "https://api.github.com/repos/rust-lang/rust/commits/c9d808e85f9c7ca1957ef54ddeb04d3888bd9552", "html_url": "https://github.com/rust-lang/rust/commit/c9d808e85f9c7ca1957ef54ddeb04d3888bd9552"}, {"sha": "65de5dd2d0fd66c5277787558c3af9421545af24", "url": "https://api.github.com/repos/rust-lang/rust/commits/65de5dd2d0fd66c5277787558c3af9421545af24", "html_url": "https://github.com/rust-lang/rust/commit/65de5dd2d0fd66c5277787558c3af9421545af24"}], "stats": {"total": 422, "additions": 287, "deletions": 135}, "files": [{"sha": "b19f63231aff69050e35582b26ecbe549a62e954", "filename": "src/error.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/579628f56ddae7fa07e415ceebe0cb4faa0cfe72/src%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/579628f56ddae7fa07e415ceebe0cb4faa0cfe72/src%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ferror.rs?ref=579628f56ddae7fa07e415ceebe0cb4faa0cfe72", "patch": "@@ -3,6 +3,8 @@ use std::fmt;\n use rustc::mir::repr as mir;\n use rustc::ty::BareFnTy;\n use memory::Pointer;\n+use rustc_const_math::ConstMathErr;\n+use syntax::codemap::Span;\n \n #[derive(Clone, Debug)]\n pub enum EvalError<'tcx> {\n@@ -24,6 +26,8 @@ pub enum EvalError<'tcx> {\n     Unimplemented(String),\n     DerefFunctionPointer,\n     ExecuteMemory,\n+    ArrayIndexOutOfBounds(Span, u64, u64),\n+    Math(Span, ConstMathErr),\n }\n \n pub type EvalResult<'tcx, T> = Result<T, EvalError<'tcx>>;\n@@ -58,6 +62,10 @@ impl<'tcx> Error for EvalError<'tcx> {\n                 \"tried to dereference a function pointer\",\n             EvalError::ExecuteMemory =>\n                 \"tried to treat a memory pointer as a function pointer\",\n+            EvalError::ArrayIndexOutOfBounds(..) =>\n+                \"array index out of bounds\",\n+            EvalError::Math(..) =>\n+                \"mathematical operation failed\",\n         }\n     }\n \n@@ -73,6 +81,10 @@ impl<'tcx> fmt::Display for EvalError<'tcx> {\n             },\n             EvalError::FunctionPointerTyMismatch(expected, got) =>\n                 write!(f, \"tried to call a function of type {:?} through a function pointer of type {:?}\", expected, got),\n+            EvalError::ArrayIndexOutOfBounds(span, len, index) =>\n+                write!(f, \"array index {} out of bounds {} at {:?}\", index, len, span),\n+            EvalError::Math(span, ref err) =>\n+                write!(f, \"mathematical operation at {:?} failed with {:?}\", span, err),\n             _ => write!(f, \"{}\", self.description()),\n         }\n     }"}, {"sha": "0a8c82c5df3f59c30706bbb45d2b32cfbbab048a", "filename": "src/interpreter/mod.rs", "status": "modified", "additions": 111, "deletions": 90, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/579628f56ddae7fa07e415ceebe0cb4faa0cfe72/src%2Finterpreter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/579628f56ddae7fa07e415ceebe0cb4faa0cfe72/src%2Finterpreter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fmod.rs?ref=579628f56ddae7fa07e415ceebe0cb4faa0cfe72", "patch": "@@ -474,15 +474,23 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 self.frame_mut().block = target;\n             }\n \n-            Assert { ref cond, expected, ref msg, target, cleanup } => {\n-                let actual_ptr = self.eval_operand(cond)?;\n-                let actual = self.memory.read_bool(actual_ptr)?;\n-                if actual == expected {\n+            Assert { ref cond, expected, ref msg, target, .. } => {\n+                let cond_ptr = self.eval_operand(cond)?;\n+                if expected == self.memory.read_bool(cond_ptr)? {\n                     self.frame_mut().block = target;\n                 } else {\n-                    panic!(\"unimplemented: jump to {:?} and print {:?}\", cleanup, msg);\n+                    return match *msg {\n+                        mir::AssertMessage::BoundsCheck { ref len, ref index } => {\n+                            let len = self.eval_operand(len).expect(\"can't eval len\");\n+                            let len = self.memory.read_usize(len).expect(\"can't read len\");\n+                            let index = self.eval_operand(index).expect(\"can't eval index\");\n+                            let index = self.memory.read_usize(index).expect(\"can't read index\");\n+                            Err(EvalError::ArrayIndexOutOfBounds(terminator.source_info.span, len, index))\n+                        },\n+                        mir::AssertMessage::Math(ref err) => Err(EvalError::Math(terminator.source_info.span, err.clone())),\n+                    }\n                 }\n-            }\n+            },\n \n             DropAndReplace { .. } => unimplemented!(),\n             Resume => unimplemented!(),\n@@ -507,9 +515,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let name = self.tcx.item_name(def_id).as_str();\n                 match fn_ty.sig.0.output {\n                     ty::FnConverging(ty) => {\n-                        let size = self.type_size(ty);\n+                        let layout = self.type_layout(ty);\n                         let ret = return_ptr.unwrap();\n-                        self.call_intrinsic(&name, substs, args, ret, size)\n+                        self.call_intrinsic(&name, substs, args, ret, layout)\n                     }\n                     ty::FnDiverging => unimplemented!(),\n                 }\n@@ -659,87 +667,112 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         Ok(if not_null { nndiscr } else { 1 - nndiscr })\n     }\n \n+    /// applies the binary operation `op` to the two operands and writes a tuple of the result\n+    /// and a boolean signifying the potential overflow to the destination\n+    fn intrinsic_with_overflow(\n+        &mut self,\n+        op: mir::BinOp,\n+        left: &mir::Operand<'tcx>,\n+        right: &mir::Operand<'tcx>,\n+        dest: Pointer,\n+        dest_layout: &'tcx Layout,\n+    ) -> EvalResult<'tcx, ()> {\n+        use rustc::ty::layout::Layout::*;\n+        let tup_layout = match *dest_layout {\n+            Univariant { ref variant, .. } => variant,\n+            _ => panic!(\"checked bin op returns something other than a tuple\"),\n+        };\n+\n+        let overflowed = self.intrinsic_overflowing(op, left, right, dest)?;\n+        let offset = tup_layout.field_offset(1).bytes() as isize;\n+        self.memory.write_bool(dest.offset(offset), overflowed)\n+    }\n+\n+    /// Applies the binary operation `op` to the arguments and writes the result to the destination.\n+    /// Returns `true` if the operation overflowed.\n+    fn intrinsic_overflowing(\n+        &mut self,\n+        op: mir::BinOp,\n+        left: &mir::Operand<'tcx>,\n+        right: &mir::Operand<'tcx>,\n+        dest: Pointer,\n+    ) -> EvalResult<'tcx, bool> {\n+        let left_ptr = self.eval_operand(left)?;\n+        let left_ty = self.operand_ty(left);\n+        let left_val = self.read_primval(left_ptr, left_ty)?;\n+\n+        let right_ptr = self.eval_operand(right)?;\n+        let right_ty = self.operand_ty(right);\n+        let right_val = self.read_primval(right_ptr, right_ty)?;\n+\n+        let (val, overflow) = primval::binary_op(op, left_val, right_val)?;\n+        self.memory.write_primval(dest, val)?;\n+        Ok(overflow)\n+    }\n+\n     fn call_intrinsic(\n         &mut self,\n         name: &str,\n         substs: &'tcx Substs<'tcx>,\n         args: &[mir::Operand<'tcx>],\n         dest: Pointer,\n-        dest_size: usize\n+        dest_layout: &'tcx Layout,\n     ) -> EvalResult<'tcx, ()> {\n         let args_res: EvalResult<Vec<Pointer>> = args.iter()\n             .map(|arg| self.eval_operand(arg))\n             .collect();\n-        let args = args_res?;\n+        let args_ptrs = args_res?;\n+\n+        let pointer_size = self.memory.pointer_size;\n \n         match name {\n-            // FIXME(solson): Handle different integer types correctly.\n-            \"add_with_overflow\" => {\n-                let ty = *substs.types.get(subst::FnSpace, 0);\n-                let size = self.type_size(ty);\n-                let left = self.memory.read_int(args[0], size)?;\n-                let right = self.memory.read_int(args[1], size)?;\n-                let (n, overflowed) = unsafe {\n-                    ::std::intrinsics::add_with_overflow::<i64>(left, right)\n-                };\n-                self.memory.write_int(dest, n, size)?;\n-                self.memory.write_bool(dest.offset(size as isize), overflowed)?;\n-            }\n+            \"add_with_overflow\" => self.intrinsic_with_overflow(mir::BinOp::Add, &args[0], &args[1], dest, dest_layout)?,\n+            \"sub_with_overflow\" => self.intrinsic_with_overflow(mir::BinOp::Sub, &args[0], &args[1], dest, dest_layout)?,\n+            \"mul_with_overflow\" => self.intrinsic_with_overflow(mir::BinOp::Mul, &args[0], &args[1], dest, dest_layout)?,\n \n+            // FIXME: turn into an assertion to catch wrong `assume` that would cause UB in llvm\n             \"assume\" => {}\n \n             \"copy_nonoverlapping\" => {\n                 let elem_ty = *substs.types.get(subst::FnSpace, 0);\n                 let elem_size = self.type_size(elem_ty);\n-                let src = self.memory.read_ptr(args[0])?;\n-                let dest = self.memory.read_ptr(args[1])?;\n-                let count = self.memory.read_isize(args[2])?;\n+                let src = self.memory.read_ptr(args_ptrs[0])?;\n+                let dest = self.memory.read_ptr(args_ptrs[1])?;\n+                let count = self.memory.read_isize(args_ptrs[2])?;\n                 self.memory.copy(src, dest, count as usize * elem_size)?;\n             }\n \n             \"discriminant_value\" => {\n                 let ty = *substs.types.get(subst::FnSpace, 0);\n-                let adt_ptr = self.memory.read_ptr(args[0])?;\n+                let adt_ptr = self.memory.read_ptr(args_ptrs[0])?;\n                 let discr_val = self.read_discriminant_value(adt_ptr, ty)?;\n-                self.memory.write_uint(dest, discr_val, dest_size)?;\n+                self.memory.write_uint(dest, discr_val, 8)?;\n             }\n \n             \"forget\" => {\n                 let arg_ty = *substs.types.get(subst::FnSpace, 0);\n                 let arg_size = self.type_size(arg_ty);\n-                self.memory.drop_fill(args[0], arg_size)?;\n+                self.memory.drop_fill(args_ptrs[0], arg_size)?;\n             }\n \n-            \"init\" => self.memory.write_repeat(dest, 0, dest_size)?,\n+            \"init\" => self.memory.write_repeat(dest, 0, dest_layout.size(&self.tcx.data_layout).bytes() as usize)?,\n \n             \"min_align_of\" => {\n-                self.memory.write_int(dest, 1, dest_size)?;\n+                // FIXME: use correct value\n+                self.memory.write_int(dest, 1, pointer_size)?;\n             }\n \n             \"move_val_init\" => {\n                 let ty = *substs.types.get(subst::FnSpace, 0);\n-                let ptr = self.memory.read_ptr(args[0])?;\n-                self.move_(args[1], ptr, ty)?;\n-            }\n-\n-            // FIXME(solson): Handle different integer types correctly.\n-            \"mul_with_overflow\" => {\n-                let ty = *substs.types.get(subst::FnSpace, 0);\n-                let size = self.type_size(ty);\n-                let left = self.memory.read_int(args[0], size)?;\n-                let right = self.memory.read_int(args[1], size)?;\n-                let (n, overflowed) = unsafe {\n-                    ::std::intrinsics::mul_with_overflow::<i64>(left, right)\n-                };\n-                self.memory.write_int(dest, n, size)?;\n-                self.memory.write_bool(dest.offset(size as isize), overflowed)?;\n+                let ptr = self.memory.read_ptr(args_ptrs[0])?;\n+                self.move_(args_ptrs[1], ptr, ty)?;\n             }\n \n             \"offset\" => {\n                 let pointee_ty = *substs.types.get(subst::FnSpace, 0);\n                 let pointee_size = self.type_size(pointee_ty) as isize;\n-                let ptr_arg = args[0];\n-                let offset = self.memory.read_isize(args[1])?;\n+                let ptr_arg = args_ptrs[0];\n+                let offset = self.memory.read_isize(args_ptrs[1])?;\n \n                 match self.memory.read_ptr(ptr_arg) {\n                     Ok(ptr) => {\n@@ -755,35 +788,35 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 }\n             }\n \n-            // FIXME(solson): Handle different integer types correctly. Use primvals?\n             \"overflowing_sub\" => {\n-                let ty = *substs.types.get(subst::FnSpace, 0);\n-                let size = self.type_size(ty);\n-                let left = self.memory.read_int(args[0], size)?;\n-                let right = self.memory.read_int(args[1], size)?;\n-                let n = left.wrapping_sub(right);\n-                self.memory.write_int(dest, n, size)?;\n+                self.intrinsic_overflowing(mir::BinOp::Sub, &args[0], &args[1], dest)?;\n+            }\n+            \"overflowing_mul\" => {\n+                self.intrinsic_overflowing(mir::BinOp::Mul, &args[0], &args[1], dest)?;\n+            }\n+            \"overflowing_add\" => {\n+                self.intrinsic_overflowing(mir::BinOp::Add, &args[0], &args[1], dest)?;\n             }\n \n             \"size_of\" => {\n                 let ty = *substs.types.get(subst::FnSpace, 0);\n                 let size = self.type_size(ty) as u64;\n-                self.memory.write_uint(dest, size, dest_size)?;\n+                self.memory.write_uint(dest, size, pointer_size)?;\n             }\n \n             \"size_of_val\" => {\n                 let ty = *substs.types.get(subst::FnSpace, 0);\n                 if self.type_is_sized(ty) {\n                     let size = self.type_size(ty) as u64;\n-                    self.memory.write_uint(dest, size, dest_size)?;\n+                    self.memory.write_uint(dest, size, pointer_size)?;\n                 } else {\n                     match ty.sty {\n                         ty::TySlice(_) | ty::TyStr => {\n                             let elem_ty = ty.sequence_element_type(self.tcx);\n                             let elem_size = self.type_size(elem_ty) as u64;\n                             let ptr_size = self.memory.pointer_size as isize;\n-                            let n = self.memory.read_usize(args[0].offset(ptr_size))?;\n-                            self.memory.write_uint(dest, n * elem_size, dest_size)?;\n+                            let n = self.memory.read_usize(args_ptrs[0].offset(ptr_size))?;\n+                            self.memory.write_uint(dest, n * elem_size, pointer_size)?;\n                         }\n \n                         _ => return Err(EvalError::Unimplemented(format!(\"unimplemented: size_of_val::<{:?}>\", ty))),\n@@ -793,9 +826,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             \"transmute\" => {\n                 let ty = *substs.types.get(subst::FnSpace, 0);\n-                self.move_(args[0], dest, ty)?;\n+                self.move_(args_ptrs[0], dest, ty)?;\n             }\n-            \"uninit\" => self.memory.mark_definedness(dest, dest_size, false)?,\n+            \"uninit\" => self.memory.mark_definedness(dest, dest_layout.size(&self.tcx.data_layout).bytes() as usize, false)?,\n \n             name => return Err(EvalError::Unimplemented(format!(\"unimplemented intrinsic: {}\", name))),\n         }\n@@ -900,35 +933,12 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n \n             BinaryOp(bin_op, ref left, ref right) => {\n-                let left_ptr = self.eval_operand(left)?;\n-                let left_ty = self.operand_ty(left);\n-                let left_val = self.read_primval(left_ptr, left_ty)?;\n-\n-                let right_ptr = self.eval_operand(right)?;\n-                let right_ty = self.operand_ty(right);\n-                let right_val = self.read_primval(right_ptr, right_ty)?;\n-\n-                let val = primval::binary_op(bin_op, left_val, right_val)?;\n-                self.memory.write_primval(dest, val)?;\n+                // ignore overflow bit, rustc inserts check branches for us\n+                self.intrinsic_overflowing(bin_op, left, right, dest)?;\n             }\n \n-            // FIXME(solson): Factor this out with BinaryOp.\n             CheckedBinaryOp(bin_op, ref left, ref right) => {\n-                let left_ptr = self.eval_operand(left)?;\n-                let left_ty = self.operand_ty(left);\n-                let left_val = self.read_primval(left_ptr, left_ty)?;\n-\n-                let right_ptr = self.eval_operand(right)?;\n-                let right_ty = self.operand_ty(right);\n-                let right_val = self.read_primval(right_ptr, right_ty)?;\n-\n-                let val = primval::binary_op(bin_op, left_val, right_val)?;\n-                self.memory.write_primval(dest, val)?;\n-\n-                // FIXME(solson): Find the result type size properly. Perhaps refactor out\n-                // Projection calculations so we can do the equivalent of `dest.1` here.\n-                let s = self.type_size(left_ty);\n-                self.memory.write_bool(dest.offset(s as isize), false)?;\n+                self.intrinsic_with_overflow(bin_op, left, right, dest, dest_layout)?;\n             }\n \n             UnaryOp(un_op, ref operand) => {\n@@ -1103,9 +1113,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n                         // Hack to support fat pointer -> thin pointer casts to keep tests for\n                         // other things passing for now.\n-                        let is_fat_ptr_cast = pointee_type(src_ty).map(|ty| {\n-                            !self.type_is_sized(ty)\n-                        }).unwrap_or(false);\n+                        let is_fat_ptr_cast = pointee_type(src_ty).map_or(false, |ty| !self.type_is_sized(ty));\n \n                         if dest_size == src_size || is_fat_ptr_cast {\n                             self.memory.copy(src, dest, dest_size)?;\n@@ -1122,7 +1130,16 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                         ref other => panic!(\"reify fn pointer on {:?}\", other),\n                     },\n \n-                    _ => return Err(EvalError::Unimplemented(format!(\"can't handle cast: {:?}\", rvalue))),\n+                    UnsafeFnPointer => match dest_ty.sty {\n+                        ty::TyFnPtr(unsafe_fn_ty) => {\n+                            let src = self.eval_operand(operand)?;\n+                            let ptr = self.memory.read_ptr(src)?;\n+                            let fn_def = self.memory.get_fn(ptr.alloc_id)?;\n+                            let fn_ptr = self.memory.create_fn_ptr(fn_def.def_id, fn_def.substs, unsafe_fn_ty);\n+                            self.memory.write_ptr(dest, fn_ptr)?;\n+                        },\n+                        ref other => panic!(\"fn to unsafe fn cast on {:?}\", other),\n+                    },\n                 }\n             }\n \n@@ -1369,6 +1386,10 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             (8, &ty::TyUint(UintTy::Us)) |\n             (_, &ty::TyUint(UintTy::U64)) => PrimVal::U64(self.memory.read_uint(ptr, 8)? as u64),\n \n+            (_, &ty::TyFnDef(def_id, substs, fn_ty)) => {\n+                PrimVal::FnPtr(self.memory.create_fn_ptr(def_id, substs, fn_ty))\n+            },\n+            (_, &ty::TyFnPtr(_)) => self.memory.read_ptr(ptr).map(PrimVal::FnPtr)?,\n             (_, &ty::TyRef(_, ty::TypeAndMut { ty, .. })) |\n             (_, &ty::TyRawPtr(ty::TypeAndMut { ty, .. })) => {\n                 if self.type_is_sized(ty) {"}, {"sha": "8addef87b2fb2aa9bca18b2c5e65e71b88c13cf0", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/579628f56ddae7fa07e415ceebe0cb4faa0cfe72/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/579628f56ddae7fa07e415ceebe0cb4faa0cfe72/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=579628f56ddae7fa07e415ceebe0cb4faa0cfe72", "patch": "@@ -2,7 +2,6 @@\n     btree_range,\n     collections,\n     collections_bound,\n-    core_intrinsics,\n     filling_drop,\n     question_mark,\n     rustc_private,\n@@ -14,6 +13,7 @@\n extern crate rustc_data_structures;\n extern crate rustc_mir;\n extern crate rustc_trans;\n+extern crate rustc_const_math;\n extern crate syntax;\n #[macro_use] extern crate log;\n extern crate log_settings;"}, {"sha": "be0cd0ef4f321a939a8384c544ea8b023be9f5ec", "filename": "src/memory.rs", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/579628f56ddae7fa07e415ceebe0cb4faa0cfe72/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/579628f56ddae7fa07e415ceebe0cb4faa0cfe72/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=579628f56ddae7fa07e415ceebe0cb4faa0cfe72", "patch": "@@ -42,7 +42,7 @@ impl Pointer {\n     }\n }\n \n-#[derive(Debug, Copy, Clone)]\n+#[derive(Debug, Copy, Clone, Hash, Eq, PartialEq)]\n pub struct FunctionDefinition<'tcx> {\n     pub def_id: DefId,\n     pub substs: &'tcx Substs<'tcx>,\n@@ -59,6 +59,8 @@ pub struct Memory<'tcx> {\n     /// Function \"allocations\". They exist solely so pointers have something to point to, and\n     /// we can figure out what they point to.\n     functions: HashMap<AllocId, FunctionDefinition<'tcx>>,\n+    /// Inverse map of `functions` so we don't allocate a new pointer every time we need one\n+    function_alloc_cache: HashMap<FunctionDefinition<'tcx>, AllocId>,\n     next_id: AllocId,\n     pub pointer_size: usize,\n }\n@@ -69,22 +71,29 @@ impl<'tcx> Memory<'tcx> {\n         Memory {\n             alloc_map: HashMap::new(),\n             functions: HashMap::new(),\n+            function_alloc_cache: HashMap::new(),\n             next_id: AllocId(0),\n             pointer_size: pointer_size,\n         }\n     }\n \n-    // FIXME: never create two pointers to the same def_id + substs combination\n-    // maybe re-use the statics cache of the EvalContext?\n     pub fn create_fn_ptr(&mut self, def_id: DefId, substs: &'tcx Substs<'tcx>, fn_ty: &'tcx BareFnTy<'tcx>) -> Pointer {\n-        let id = self.next_id;\n-        debug!(\"creating fn ptr: {}\", id);\n-        self.next_id.0 += 1;\n-        self.functions.insert(id, FunctionDefinition {\n+        let def = FunctionDefinition {\n             def_id: def_id,\n             substs: substs,\n             fn_ty: fn_ty,\n-        });\n+        };\n+        if let Some(&alloc_id) = self.function_alloc_cache.get(&def) {\n+            return Pointer {\n+                alloc_id: alloc_id,\n+                offset: 0,\n+            };\n+        }\n+        let id = self.next_id;\n+        debug!(\"creating fn ptr: {}\", id);\n+        self.next_id.0 += 1;\n+        self.functions.insert(id, def);\n+        self.function_alloc_cache.insert(def, id);\n         Pointer {\n             alloc_id: id,\n             offset: 0,\n@@ -361,6 +370,7 @@ impl<'tcx> Memory<'tcx> {\n             PrimVal::U32(n)  => self.write_uint(ptr, n as u64, 4),\n             PrimVal::U64(n)  => self.write_uint(ptr, n as u64, 8),\n             PrimVal::IntegerPtr(n) => self.write_uint(ptr, n as u64, pointer_size),\n+            PrimVal::FnPtr(_p) |\n             PrimVal::AbstractPtr(_p) => unimplemented!(),\n         }\n     }"}, {"sha": "6b17a63b65862f57250f71b26e5b384b4ae53849", "filename": "src/primval.rs", "status": "modified", "additions": 89, "deletions": 13, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/579628f56ddae7fa07e415ceebe0cb4faa0cfe72/src%2Fprimval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/579628f56ddae7fa07e415ceebe0cb4faa0cfe72/src%2Fprimval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fprimval.rs?ref=579628f56ddae7fa07e415ceebe0cb4faa0cfe72", "patch": "@@ -10,28 +10,41 @@ pub enum PrimVal {\n     U8(u8), U16(u16), U32(u32), U64(u64),\n \n     AbstractPtr(Pointer),\n+    FnPtr(Pointer),\n     IntegerPtr(u64),\n }\n \n-pub fn binary_op<'tcx>(bin_op: mir::BinOp, left: PrimVal, right: PrimVal) -> EvalResult<'tcx, PrimVal> {\n+/// returns the result of the operation and whether the operation overflowed\n+pub fn binary_op<'tcx>(bin_op: mir::BinOp, left: PrimVal, right: PrimVal) -> EvalResult<'tcx, (PrimVal, bool)> {\n     use rustc::mir::repr::BinOp::*;\n     use self::PrimVal::*;\n \n+    macro_rules! overflow {\n+        ($v:ident, $v2:ident, $l:ident, $op:ident, $r:ident) => ({\n+            let (val, of) = $l.$op($r);\n+            if of {\n+                return Ok(($v(val), true));\n+            } else {\n+                $v(val)\n+            }\n+        })\n+    }\n+\n     macro_rules! int_binops {\n         ($v:ident, $l:ident, $r:ident) => ({\n             match bin_op {\n-                Add    => $v($l + $r),\n-                Sub    => $v($l - $r),\n-                Mul    => $v($l * $r),\n-                Div    => $v($l / $r),\n-                Rem    => $v($l % $r),\n+                Add    => overflow!($v, $v, $l, overflowing_add, $r),\n+                Sub    => overflow!($v, $v, $l, overflowing_sub, $r),\n+                Mul    => overflow!($v, $v, $l, overflowing_mul, $r),\n+                Div    => overflow!($v, $v, $l, overflowing_div, $r),\n+                Rem    => overflow!($v, $v, $l, overflowing_rem, $r),\n                 BitXor => $v($l ^ $r),\n                 BitAnd => $v($l & $r),\n                 BitOr  => $v($l | $r),\n \n-                // TODO(solson): Can have differently-typed RHS.\n-                Shl => $v($l << $r),\n-                Shr => $v($l >> $r),\n+                // these have already been handled\n+                Shl => unreachable!(),\n+                Shr => unreachable!(),\n \n                 Eq => Bool($l == $r),\n                 Ne => Bool($l != $r),\n@@ -53,6 +66,58 @@ pub fn binary_op<'tcx>(bin_op: mir::BinOp, left: PrimVal, right: PrimVal) -> Eva\n         }\n     }\n \n+    match bin_op {\n+        // can have rhs with a different numeric type\n+        Shl | Shr => {\n+            // these numbers are the maximum number a bitshift rhs could possibly have\n+            // e.g. u16 can be bitshifted by 0..16, so masking with 0b1111 (16 - 1) will ensure we are in that range\n+            let type_bits: u32 = match left {\n+                I8(_) | U8(_) => 8,\n+                I16(_) | U16(_) => 16,\n+                I32(_) | U32(_) => 32,\n+                I64(_) | U64(_) => 64,\n+                _ => unreachable!(),\n+            };\n+            assert!(type_bits.is_power_of_two());\n+            // turn into `u32` because `overflowing_sh{l,r}` only take `u32`\n+            let r = match right {\n+                I8(i) => i as u32,\n+                I16(i) => i as u32,\n+                I32(i) => i as u32,\n+                I64(i) => i as u32,\n+                U8(i) => i as u32,\n+                U16(i) => i as u32,\n+                U32(i) => i as u32,\n+                U64(i) => i as u32,\n+                _ => panic!(\"bad MIR: bitshift rhs is not integral\"),\n+            };\n+            // apply mask\n+            let r = r & (type_bits - 1);\n+            macro_rules! shift {\n+                ($v:ident, $l:ident, $r:ident) => ({\n+                    match bin_op {\n+                        Shl => overflow!($v, U32, $l, overflowing_shl, $r),\n+                        Shr => overflow!($v, U32, $l, overflowing_shr, $r),\n+                        _ => unreachable!(),\n+                    }\n+                })\n+            }\n+            let val = match left {\n+                I8(l) => shift!(I8, l, r),\n+                I16(l) => shift!(I16, l, r),\n+                I32(l) => shift!(I32, l, r),\n+                I64(l) => shift!(I64, l, r),\n+                U8(l) => shift!(U8, l, r),\n+                U16(l) => shift!(U16, l, r),\n+                U32(l) => shift!(U32, l, r),\n+                U64(l) => shift!(U64, l, r),\n+                _ => unreachable!(),\n+            };\n+            return Ok((val, false));\n+        },\n+        _ => {},\n+    }\n+\n     let val = match (left, right) {\n         (I8(l),  I8(r))  => int_binops!(I8, l, r),\n         (I16(l), I16(r)) => int_binops!(I16, l, r),\n@@ -80,12 +145,23 @@ pub fn binary_op<'tcx>(bin_op: mir::BinOp, left: PrimVal, right: PrimVal) -> Eva\n \n         (IntegerPtr(l), IntegerPtr(r)) => int_binops!(IntegerPtr, l, r),\n \n-        (AbstractPtr(_), IntegerPtr(_)) | (IntegerPtr(_), AbstractPtr(_)) =>\n-            return unrelated_ptr_ops(bin_op),\n+        (AbstractPtr(_), IntegerPtr(_)) |\n+        (IntegerPtr(_), AbstractPtr(_)) |\n+        (FnPtr(_), AbstractPtr(_)) |\n+        (AbstractPtr(_), FnPtr(_)) |\n+        (FnPtr(_), IntegerPtr(_)) |\n+        (IntegerPtr(_), FnPtr(_)) =>\n+            unrelated_ptr_ops(bin_op)?,\n+\n+        (FnPtr(l_ptr), FnPtr(r_ptr)) => match bin_op {\n+            Eq => Bool(l_ptr == r_ptr),\n+            Ne => Bool(l_ptr != r_ptr),\n+            _ => return Err(EvalError::Unimplemented(format!(\"unimplemented fn ptr comparison: {:?}\", bin_op))),\n+        },\n \n         (AbstractPtr(l_ptr), AbstractPtr(r_ptr)) => {\n             if l_ptr.alloc_id != r_ptr.alloc_id {\n-                return unrelated_ptr_ops(bin_op);\n+                return Ok((unrelated_ptr_ops(bin_op)?, false));\n             }\n \n             let l = l_ptr.offset;\n@@ -105,7 +181,7 @@ pub fn binary_op<'tcx>(bin_op: mir::BinOp, left: PrimVal, right: PrimVal) -> Eva\n         (l, r) => return Err(EvalError::Unimplemented(format!(\"unimplemented binary op: {:?}, {:?}, {:?}\", l, r, bin_op))),\n     };\n \n-    Ok(val)\n+    Ok((val, false))\n }\n \n pub fn unary_op<'tcx>(un_op: mir::UnOp, val: PrimVal) -> EvalResult<'tcx, PrimVal> {"}, {"sha": "225cd1391bc36d89aa7803a90f21c1d3b5c25de4", "filename": "tests/compile-fail/cast_fn_ptr_unsafe.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/579628f56ddae7fa07e415ceebe0cb4faa0cfe72/tests%2Fcompile-fail%2Fcast_fn_ptr_unsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/579628f56ddae7fa07e415ceebe0cb4faa0cfe72/tests%2Fcompile-fail%2Fcast_fn_ptr_unsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fcast_fn_ptr_unsafe.rs?ref=579628f56ddae7fa07e415ceebe0cb4faa0cfe72", "patch": "@@ -0,0 +1,10 @@\n+// just making sure that fn -> unsafe fn casts are handled by rustc so miri doesn't have to\n+fn main() {\n+    fn f() {}\n+\n+    let g = f as fn() as unsafe fn(i32); //~ERROR: non-scalar cast: `fn()` as `unsafe fn(i32)`\n+\n+    unsafe {\n+        g(42);\n+    }\n+}"}, {"sha": "c3a2fb9556f824b8ad74a6692eb7540324344bb3", "filename": "tests/compile-fail/cast_fn_ptr_unsafe2.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/579628f56ddae7fa07e415ceebe0cb4faa0cfe72/tests%2Fcompile-fail%2Fcast_fn_ptr_unsafe2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/579628f56ddae7fa07e415ceebe0cb4faa0cfe72/tests%2Fcompile-fail%2Fcast_fn_ptr_unsafe2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fcast_fn_ptr_unsafe2.rs?ref=579628f56ddae7fa07e415ceebe0cb4faa0cfe72", "patch": "@@ -0,0 +1,10 @@\n+// just making sure that fn -> unsafe fn casts are handled by rustc so miri doesn't have to\n+fn main() {\n+    fn f() {}\n+\n+    let g = f as fn() as fn(i32) as unsafe fn(i32); //~ERROR: non-scalar cast: `fn()` as `fn(i32)`\n+\n+    unsafe {\n+        g(42);\n+    }\n+}"}, {"sha": "b0068785e17eca214e42819f757b77ca2e286e38", "filename": "tests/compile-fail/env_args.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/579628f56ddae7fa07e415ceebe0cb4faa0cfe72/tests%2Fcompile-fail%2Fenv_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/579628f56ddae7fa07e415ceebe0cb4faa0cfe72/tests%2Fcompile-fail%2Fenv_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fenv_args.rs?ref=579628f56ddae7fa07e415ceebe0cb4faa0cfe72", "patch": "@@ -0,0 +1,6 @@\n+//error-pattern: no mir for `std\n+\n+fn main() {\n+    let x = std::env::args();\n+    assert_eq!(x.count(), 1);\n+}"}, {"sha": "5430501f05225d27d7b611cb69db1279a2ea374e", "filename": "tests/compiletest.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/579628f56ddae7fa07e415ceebe0cb4faa0cfe72/tests%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/579628f56ddae7fa07e415ceebe0cb4faa0cfe72/tests%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompiletest.rs?ref=579628f56ddae7fa07e415ceebe0cb4faa0cfe72", "patch": "@@ -3,23 +3,28 @@ extern crate compiletest_rs as compiletest;\n use std::path::{PathBuf, Path};\n use std::io::Write;\n \n-fn run_mode(dir: &'static str, mode: &'static str, sysroot: &str) {\n-    // Disable rustc's new error fomatting. It breaks these tests.\n-    std::env::remove_var(\"RUST_NEW_ERROR_FORMAT\");\n+fn compile_fail(sysroot: &str) {\n     let flags = format!(\"--sysroot {} -Dwarnings\", sysroot);\n     for_all_targets(sysroot, |target| {\n         let mut config = compiletest::default_config();\n         config.host_rustcflags = Some(flags.clone());\n-        config.mode = mode.parse().expect(\"Invalid mode\");\n+        config.mode = \"compile-fail\".parse().expect(\"Invalid mode\");\n         config.run_lib_path = Path::new(sysroot).join(\"lib\").join(\"rustlib\").join(&target).join(\"lib\");\n         config.rustc_path = \"target/debug/miri\".into();\n-        config.src_base = PathBuf::from(format!(\"tests/{}\", dir));\n+        config.src_base = PathBuf::from(\"tests/compile-fail\".to_string());\n         config.target = target.to_owned();\n         config.target_rustcflags = Some(flags.clone());\n         compiletest::run_tests(&config);\n     });\n }\n \n+fn run_pass() {\n+    let mut config = compiletest::default_config();\n+    config.mode = \"run-pass\".parse().expect(\"Invalid mode\");\n+    config.src_base = PathBuf::from(\"tests/run-pass\".to_string());\n+    compiletest::run_tests(&config);\n+}\n+\n fn for_all_targets<F: FnMut(String)>(sysroot: &str, mut f: F) {\n     for target in std::fs::read_dir(format!(\"{}/lib/rustlib/\", sysroot)).unwrap() {\n         let target = target.unwrap();\n@@ -38,7 +43,6 @@ fn for_all_targets<F: FnMut(String)>(sysroot: &str, mut f: F) {\n \n #[test]\n fn compile_test() {\n-    let mut failed = false;\n     // Taken from https://github.com/Manishearth/rust-clippy/pull/911.\n     let home = option_env!(\"RUSTUP_HOME\").or(option_env!(\"MULTIRUST_HOME\"));\n     let toolchain = option_env!(\"RUSTUP_TOOLCHAIN\").or(option_env!(\"MULTIRUST_TOOLCHAIN\"));\n@@ -48,7 +52,8 @@ fn compile_test() {\n             .expect(\"need to specify RUST_SYSROOT env var or use rustup or multirust\")\n             .to_owned(),\n     };\n-    run_mode(\"compile-fail\", \"compile-fail\", &sysroot);\n+    compile_fail(&sysroot);\n+    run_pass();\n     for_all_targets(&sysroot, |target| {\n         for file in std::fs::read_dir(\"tests/run-pass\").unwrap() {\n             let file = file.unwrap();\n@@ -72,21 +77,18 @@ fn compile_test() {\n             match cmd.output() {\n                 Ok(ref output) if output.status.success() => writeln!(stderr.lock(), \"ok\").unwrap(),\n                 Ok(output) => {\n-                    failed = true;\n                     writeln!(stderr.lock(), \"FAILED with exit code {}\", output.status.code().unwrap_or(0)).unwrap();\n                     writeln!(stderr.lock(), \"stdout: \\n {}\", std::str::from_utf8(&output.stdout).unwrap()).unwrap();\n                     writeln!(stderr.lock(), \"stderr: \\n {}\", std::str::from_utf8(&output.stderr).unwrap()).unwrap();\n+                    panic!(\"some tests failed\");\n                 }\n                 Err(e) => {\n-                    failed = true;\n                     writeln!(stderr.lock(), \"FAILED: {}\", e).unwrap();\n+                    panic!(\"some tests failed\");\n                 },\n             }\n         }\n         let stderr = std::io::stderr();\n         writeln!(stderr.lock(), \"\").unwrap();\n     });\n-    if failed {\n-        panic!(\"some tests failed\");\n-    }\n }"}, {"sha": "0cabb369bfdd907ee6a5db31d4a307d1ec8896f9", "filename": "tests/run-pass/cast_fn_ptr_unsafe.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/579628f56ddae7fa07e415ceebe0cb4faa0cfe72/tests%2Frun-pass%2Fcast_fn_ptr_unsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/579628f56ddae7fa07e415ceebe0cb4faa0cfe72/tests%2Frun-pass%2Fcast_fn_ptr_unsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fcast_fn_ptr_unsafe.rs?ref=579628f56ddae7fa07e415ceebe0cb4faa0cfe72", "patch": "@@ -0,0 +1,8 @@\n+fn main() {\n+    fn f() {}\n+\n+    let g = f as fn() as unsafe fn();\n+    unsafe {\n+        g();\n+    }\n+}"}, {"sha": "2e75a5a3ea2a5f74810df1ef5406e107c54f84ab", "filename": "tests/run-pass/function_pointers.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/579628f56ddae7fa07e415ceebe0cb4faa0cfe72/tests%2Frun-pass%2Ffunction_pointers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/579628f56ddae7fa07e415ceebe0cb4faa0cfe72/tests%2Frun-pass%2Ffunction_pointers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Ffunction_pointers.rs?ref=579628f56ddae7fa07e415ceebe0cb4faa0cfe72", "patch": "@@ -12,4 +12,6 @@ fn call_fn_ptr() -> i32 {\n \n fn main() {\n     assert_eq!(call_fn_ptr(), 42);\n+    assert!(return_fn_ptr() == f);\n+    assert!(return_fn_ptr() as unsafe fn() -> i32 == f as fn() -> i32 as unsafe fn() -> i32);\n }"}, {"sha": "4f23b5ec9c3816647be90d643b7cac4b8cd90481", "filename": "tests/run-pass/ints.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/579628f56ddae7fa07e415ceebe0cb4faa0cfe72/tests%2Frun-pass%2Fints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/579628f56ddae7fa07e415ceebe0cb4faa0cfe72/tests%2Frun-pass%2Fints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fints.rs?ref=579628f56ddae7fa07e415ceebe0cb4faa0cfe72", "patch": "@@ -1,34 +1,25 @@\n-#![feature(custom_attribute)]\n-#![allow(dead_code, unused_attributes)]\n-\n-#[miri_run]\n fn ret() -> i64 {\n     1\n }\n \n-#[miri_run]\n fn neg() -> i64 {\n     -1\n }\n \n-#[miri_run]\n fn add() -> i64 {\n     1 + 2\n }\n \n-#[miri_run]\n fn indirect_add() -> i64 {\n     let x = 1;\n     let y = 2;\n     x + y\n }\n \n-#[miri_run]\n fn arith() -> i32 {\n     3*3 + 4*4\n }\n \n-#[miri_run]\n fn match_int() -> i16 {\n     let n = 2;\n     match n {\n@@ -40,7 +31,6 @@ fn match_int() -> i16 {\n     }\n }\n \n-#[miri_run]\n fn match_int_range() -> i64 {\n     let n = 42;\n     match n {\n@@ -53,7 +43,6 @@ fn match_int_range() -> i64 {\n     }\n }\n \n-#[miri_run]\n fn main() {\n     assert_eq!(ret(), 1);\n     assert_eq!(neg(), -1);\n@@ -62,4 +51,8 @@ fn main() {\n     assert_eq!(arith(), 5*5);\n     assert_eq!(match_int(), 20);\n     assert_eq!(match_int_range(), 4);\n+    assert_eq!(i64::min_value().overflowing_mul(-1), (i64::min_value(), true));\n+    assert_eq!(i32::min_value().overflowing_mul(-1), (i32::min_value(), true));\n+    assert_eq!(i16::min_value().overflowing_mul(-1), (i16::min_value(), true));\n+    assert_eq!(i8::min_value().overflowing_mul(-1), (i8::min_value(), true));\n }"}, {"sha": "13894926d36db81eb3645d798103822eea445f69", "filename": "tests/run-pass/specialization.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/579628f56ddae7fa07e415ceebe0cb4faa0cfe72/tests%2Frun-pass%2Fspecialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/579628f56ddae7fa07e415ceebe0cb4faa0cfe72/tests%2Frun-pass%2Fspecialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fspecialization.rs?ref=579628f56ddae7fa07e415ceebe0cb4faa0cfe72", "patch": "@@ -1,3 +1,5 @@\n+#![feature(specialization)]\n+\n trait IsUnit {\n     fn is_unit() -> bool;\n }"}]}