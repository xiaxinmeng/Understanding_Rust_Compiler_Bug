{"sha": "3eebe058e52b749d1a38926390c12900e91b0b2c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNlZWJlMDU4ZTUyYjc0OWQxYTM4OTI2MzkwYzEyOTAwZTkxYjBiMmM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-12-12T11:51:26Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-12-12T11:51:26Z"}, "message": "Auto merge of #67079 - nnethercote:optimize-shallow_resolve_changed, r=nikomatsakis\n\nOptimize `shallow_resolve_changed`\n\nr? @nikomatsakis", "tree": {"sha": "c542244b9b8728d907e7b3556bb9c9052cfb2dd8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c542244b9b8728d907e7b3556bb9c9052cfb2dd8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3eebe058e52b749d1a38926390c12900e91b0b2c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3eebe058e52b749d1a38926390c12900e91b0b2c", "html_url": "https://github.com/rust-lang/rust/commit/3eebe058e52b749d1a38926390c12900e91b0b2c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3eebe058e52b749d1a38926390c12900e91b0b2c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f284f8b4be3a899bf2ecc03e2a1589f486b62a9f", "url": "https://api.github.com/repos/rust-lang/rust/commits/f284f8b4be3a899bf2ecc03e2a1589f486b62a9f", "html_url": "https://github.com/rust-lang/rust/commit/f284f8b4be3a899bf2ecc03e2a1589f486b62a9f"}, {"sha": "21f35bc26f1ffccf30916b7d6930d1526172f2da", "url": "https://api.github.com/repos/rust-lang/rust/commits/21f35bc26f1ffccf30916b7d6930d1526172f2da", "html_url": "https://github.com/rust-lang/rust/commit/21f35bc26f1ffccf30916b7d6930d1526172f2da"}], "stats": {"total": 64, "additions": 36, "deletions": 28}, "files": [{"sha": "73977878af3374bd2c6b370e1f54803b36e06853", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/3eebe058e52b749d1a38926390c12900e91b0b2c/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3eebe058e52b749d1a38926390c12900e91b0b2c/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=3eebe058e52b749d1a38926390c12900e91b0b2c", "patch": "@@ -1618,37 +1618,37 @@ impl<'a, 'tcx> ShallowResolver<'a, 'tcx> {\n     // inlined, despite being large, because it has only two call sites that\n     // are extremely hot.\n     #[inline(always)]\n-    pub fn shallow_resolve_changed(&mut self, typ: Ty<'tcx>) -> bool {\n-        match typ.kind {\n-            ty::Infer(ty::TyVar(v)) => {\n+    pub fn shallow_resolve_changed(&self, infer: ty::InferTy) -> bool {\n+        match infer {\n+            ty::TyVar(v) => {\n                 use self::type_variable::TypeVariableValue;\n \n-                // See the comment in `shallow_resolve()`.\n+                // If `inlined_probe` returns a `Known` value its `kind` never\n+                // matches `infer`.\n                 match self.infcx.type_variables.borrow_mut().inlined_probe(v) {\n-                    TypeVariableValue::Known { value: t } => self.fold_ty(t) != typ,\n                     TypeVariableValue::Unknown { .. } => false,\n+                    TypeVariableValue::Known { .. } => true,\n                 }\n             }\n \n-            ty::Infer(ty::IntVar(v)) => {\n-                match self.infcx.int_unification_table.borrow_mut().inlined_probe_value(v) {\n-                    Some(v) => v.to_type(self.infcx.tcx) != typ,\n-                    None => false,\n-                }\n+            ty::IntVar(v) => {\n+                // If inlined_probe_value returns a value it's always a\n+                // `ty::Int(_)` or `ty::UInt(_)`, which nevers matches a\n+                // `ty::Infer(_)`.\n+                self.infcx.int_unification_table.borrow_mut().inlined_probe_value(v).is_some()\n             }\n \n-            ty::Infer(ty::FloatVar(v)) => {\n+            ty::FloatVar(v) => {\n+                // If inlined_probe_value returns a value it's always a\n+                // `ty::Float(_)`, which nevers matches a `ty::Infer(_)`.\n+                //\n                 // Not `inlined_probe_value(v)` because this call site is colder.\n-                match self.infcx.float_unification_table.borrow_mut().probe_value(v) {\n-                    Some(v) => v.to_type(self.infcx.tcx) != typ,\n-                    None => false,\n-                }\n+                self.infcx.float_unification_table.borrow_mut().probe_value(v).is_some()\n             }\n \n-            _ => false,\n+            _ => unreachable!(),\n         }\n     }\n-\n }\n \n impl<'a, 'tcx> TypeFolder<'tcx> for ShallowResolver<'a, 'tcx> {"}, {"sha": "27731990d2b62242fd489c454ed72ebadfa83fe3", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 19, "deletions": 11, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/3eebe058e52b749d1a38926390c12900e91b0b2c/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3eebe058e52b749d1a38926390c12900e91b0b2c/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=3eebe058e52b749d1a38926390c12900e91b0b2c", "patch": "@@ -65,7 +65,7 @@ pub struct FulfillmentContext<'tcx> {\n #[derive(Clone, Debug)]\n pub struct PendingPredicateObligation<'tcx> {\n     pub obligation: PredicateObligation<'tcx>,\n-    pub stalled_on: Vec<Ty<'tcx>>,\n+    pub stalled_on: Vec<ty::InferTy>,\n }\n \n // `PendingPredicateObligation` is used a lot. Make sure it doesn't unintentionally get bigger.\n@@ -263,8 +263,8 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n             // Match arms are in order of frequency, which matters because this\n             // code is so hot. 1 and 0 dominate; 2+ is fairly rare.\n             1 => {\n-                let ty = pending_obligation.stalled_on[0];\n-                ShallowResolver::new(self.selcx.infcx()).shallow_resolve_changed(ty)\n+                let infer = pending_obligation.stalled_on[0];\n+                ShallowResolver::new(self.selcx.infcx()).shallow_resolve_changed(infer)\n             }\n             0 => {\n                 // In this case we haven't changed, but wish to make a change.\n@@ -274,8 +274,8 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n                 // This `for` loop was once a call to `all()`, but this lower-level\n                 // form was a perf win. See #64545 for details.\n                 (|| {\n-                    for &ty in &pending_obligation.stalled_on {\n-                        if ShallowResolver::new(self.selcx.infcx()).shallow_resolve_changed(ty) {\n+                    for &infer in &pending_obligation.stalled_on {\n+                        if ShallowResolver::new(self.selcx.infcx()).shallow_resolve_changed(infer) {\n                             return true;\n                         }\n                     }\n@@ -305,6 +305,13 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n \n         debug!(\"process_obligation: obligation = {:?} cause = {:?}\", obligation, obligation.cause);\n \n+        fn infer_ty(ty: Ty<'tcx>) -> ty::InferTy {\n+            match ty.kind {\n+                ty::Infer(infer) => infer,\n+                _ => panic!(),\n+            }\n+        }\n+\n         match obligation.predicate {\n             ty::Predicate::Trait(ref data) => {\n                 let trait_obligation = obligation.with(data.clone());\n@@ -459,7 +466,7 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n                     obligation.cause.span,\n                 ) {\n                     None => {\n-                        pending_obligation.stalled_on = vec![ty];\n+                        pending_obligation.stalled_on = vec![infer_ty(ty)];\n                         ProcessResult::Unchanged\n                     }\n                     Some(os) => ProcessResult::Changed(mk_pending(os))\n@@ -472,8 +479,8 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n                                                            subtype) {\n                     None => {\n                         // None means that both are unresolved.\n-                        pending_obligation.stalled_on = vec![subtype.skip_binder().a,\n-                                                             subtype.skip_binder().b];\n+                        pending_obligation.stalled_on = vec![infer_ty(subtype.skip_binder().a),\n+                                                             infer_ty(subtype.skip_binder().b)];\n                         ProcessResult::Unchanged\n                     }\n                     Some(Ok(ok)) => {\n@@ -517,7 +524,8 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n                             ))\n                         }\n                     } else {\n-                        pending_obligation.stalled_on = substs.types().collect();\n+                        pending_obligation.stalled_on =\n+                            substs.types().map(|ty| infer_ty(ty)).collect();\n                         ProcessResult::Unchanged\n                     }\n                 }\n@@ -542,13 +550,13 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n fn trait_ref_type_vars<'a, 'tcx>(\n     selcx: &mut SelectionContext<'a, 'tcx>,\n     t: ty::PolyTraitRef<'tcx>,\n-) -> Vec<Ty<'tcx>> {\n+) -> Vec<ty::InferTy> {\n     t.skip_binder() // ok b/c this check doesn't care about regions\n      .input_types()\n      .map(|t| selcx.infcx().resolve_vars_if_possible(&t))\n      .filter(|t| t.has_infer_types())\n      .flat_map(|t| t.walk())\n-     .filter(|t| match t.kind { ty::Infer(_) => true, _ => false })\n+     .filter_map(|t| match t.kind { ty::Infer(infer) => Some(infer), _ => None })\n      .collect()\n }\n "}]}