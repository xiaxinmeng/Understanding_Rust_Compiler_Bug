{"sha": "989d008124d62f7c1284633e6619db1a9e8b6598", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk4OWQwMDgxMjRkNjJmN2MxMjg0NjMzZTY2MTlkYjFhOWU4YjY1OTg=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-05-04T18:29:32Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-05-04T18:29:32Z"}, "message": "separate out write_guard code into its own module", "tree": {"sha": "638422a92cad54a5806e4bf0d8ce0262ac25fdff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/638422a92cad54a5806e4bf0d8ce0262ac25fdff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/989d008124d62f7c1284633e6619db1a9e8b6598", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/989d008124d62f7c1284633e6619db1a9e8b6598", "html_url": "https://github.com/rust-lang/rust/commit/989d008124d62f7c1284633e6619db1a9e8b6598", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/989d008124d62f7c1284633e6619db1a9e8b6598/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ccf2f7b979ad4e4defd9b856f6d16108c5760829", "url": "https://api.github.com/repos/rust-lang/rust/commits/ccf2f7b979ad4e4defd9b856f6d16108c5760829", "html_url": "https://github.com/rust-lang/rust/commit/ccf2f7b979ad4e4defd9b856f6d16108c5760829"}], "stats": {"total": 245, "additions": 41, "deletions": 204}, "files": [{"sha": "111ad1369deb962fd61b55fcbede14559b138679", "filename": "Makefile.in", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/989d008124d62f7c1284633e6619db1a9e8b6598/Makefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/989d008124d62f7c1284633e6619db1a9e8b6598/Makefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Makefile.in?ref=989d008124d62f7c1284633e6619db1a9e8b6598", "patch": "@@ -110,6 +110,9 @@ endif\n ifdef SAVE_TEMPS\n   CFG_RUSTC_FLAGS += --save-temps\n endif\n+ifdef ASM_COMMENTS\n+  CFG_RUSTC_FLAGS += -z asm-comments\n+endif\n ifdef TIME_PASSES\n   CFG_RUSTC_FLAGS += -Z time-passes\n endif"}, {"sha": "1a81d483dfc3c62831e44db3933c506cb7819c64", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 5, "deletions": 18, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/989d008124d62f7c1284633e6619db1a9e8b6598/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/989d008124d62f7c1284633e6619db1a9e8b6598/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=989d008124d62f7c1284633e6619db1a9e8b6598", "patch": "@@ -969,30 +969,17 @@ pub fn pats_require_rooting(bcx: block,\n     })\n }\n \n-pub fn root_pats_as_necessary(bcx: block,\n+pub fn root_pats_as_necessary(mut bcx: block,\n                               m: &[@Match],\n                               col: uint,\n                               val: ValueRef)\n                            -> block {\n-    let mut bcx = bcx;\n     for vec::each(m) |br| {\n         let pat_id = br.pats[col].id;\n-\n-        let key = root_map_key {id: pat_id, derefs: 0u };\n-        match bcx.ccx().maps.root_map.find(&key) {\n-            None => (),\n-            Some(&root_info) => {\n-                // Note: the scope_id will always be the id of the match.  See\n-                // the extended comment in rustc::middle::borrowck::preserve()\n-                // for details (look for the case covering cat_discr).\n-\n-                let datum = Datum {val: val, ty: node_id_type(bcx, pat_id),\n-                                   mode: ByRef, source: ZeroMem};\n-                bcx = datum.root(bcx, br.pats[col].span, key, root_info);\n-                // If we kept going, we'd only re-root the same value, so\n-                // return now.\n-                return bcx;\n-            }\n+        if pat_id != 0 {\n+            let datum = Datum {val: val, ty: node_id_type(bcx, pat_id),\n+                               mode: ByRef, source: ZeroMem};\n+            bcx = datum.root_and_write_guard(bcx, br.pats[col].span, pat_id, 0);\n         }\n     }\n     return bcx;"}, {"sha": "f8b75838b87264a0310f920740c01f123dcdb13d", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 18, "deletions": 40, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/989d008124d62f7c1284633e6619db1a9e8b6598/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/989d008124d62f7c1284633e6619db1a9e8b6598/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=989d008124d62f7c1284633e6619db1a9e8b6598", "patch": "@@ -27,18 +27,18 @@ use middle::resolve;\n use middle::trans::adt;\n use middle::trans::base;\n use middle::trans::build;\n-use middle::trans::callee;\n use middle::trans::datum;\n use middle::trans::debuginfo;\n-use middle::trans::expr;\n use middle::trans::glue;\n use middle::trans::reachable;\n use middle::trans::shape;\n use middle::trans::type_of;\n use middle::trans::type_use;\n+use middle::trans::write_guard;\n use middle::ty::substs;\n use middle::ty;\n use middle::typeck;\n+use middle::borrowck::root_map_key;\n use util::ppaux::{Repr};\n \n use core::cast::transmute;\n@@ -468,6 +468,7 @@ pub fn add_clean_temp_mem(bcx: block, val: ValueRef, t: ty::t) {\n     }\n }\n pub fn add_clean_return_to_mut(bcx: block,\n+                               root_key: root_map_key,\n                                frozen_val_ref: ValueRef,\n                                bits_val_ref: ValueRef,\n                                filename_val: ValueRef,\n@@ -488,44 +489,12 @@ pub fn add_clean_return_to_mut(bcx: block,\n         scope_info.cleanups.push(\n             clean_temp(\n                 frozen_val_ref,\n-                |bcx| {\n-                    let mut bcx = bcx;\n-\n-                    let box_ptr =\n-                        build::Load(bcx,\n-                                    build::PointerCast(bcx,\n-                                                       frozen_val_ref,\n-                                                       T_ptr(T_ptr(T_i8()))));\n-\n-                    let bits_val =\n-                        build::Load(bcx,\n-                                    bits_val_ref);\n-\n-                    if bcx.tcx().sess.opts.optimize == session::No {\n-                        bcx = callee::trans_lang_call(\n-                            bcx,\n-                            bcx.tcx().lang_items.unrecord_borrow_fn(),\n-                            ~[\n-                                box_ptr,\n-                                bits_val,\n-                                filename_val,\n-                                line_val\n-                            ],\n-                            expr::Ignore);\n-                    }\n-\n-                    callee::trans_lang_call(\n-                        bcx,\n-                        bcx.tcx().lang_items.return_to_mut_fn(),\n-                        ~[\n-                            box_ptr,\n-                            bits_val,\n-                            filename_val,\n-                            line_val\n-                        ],\n-                        expr::Ignore\n-                    )\n-                },\n+                |bcx| write_guard::return_to_mut(bcx,\n+                                                 root_key,\n+                                                 frozen_val_ref,\n+                                                 bits_val_ref,\n+                                                 filename_val,\n+                                                 line_val),\n                 normal_exit_only));\n         scope_clean_changed(scope_info);\n     }\n@@ -1563,6 +1532,15 @@ pub fn dummy_substs(tps: ~[ty::t]) -> ty::substs {\n     }\n }\n \n+pub fn filename_and_line_num_from_span(bcx: block,\n+                                       span: span) -> (ValueRef, ValueRef) {\n+    let loc = bcx.sess().parse_sess.cm.lookup_char_pos(span.lo);\n+    let filename_cstr = C_cstr(bcx.ccx(), @/*bad*/copy loc.file.name);\n+    let filename = build::PointerCast(bcx, filename_cstr, T_ptr(T_i8()));\n+    let line = C_int(bcx.ccx(), loc.line as int);\n+    (filename, line)\n+}\n+\n // Casts a Rust bool value to an i1.\n pub fn bool_to_i1(bcx: block, llval: ValueRef) -> ValueRef {\n     build::ICmp(bcx, lib::llvm::IntNE, llval, C_bool(false))"}, {"sha": "e91bec5efed4a2bc1f248b0c1816e63693791791", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/989d008124d62f7c1284633e6619db1a9e8b6598/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/989d008124d62f7c1284633e6619db1a9e8b6598/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=989d008124d62f7c1284633e6619db1a9e8b6598", "patch": "@@ -385,13 +385,7 @@ fn trans_fail_value(bcx: block,\n pub fn trans_fail_bounds_check(bcx: block, sp: span,\n                                index: ValueRef, len: ValueRef) -> block {\n     let _icx = bcx.insn_ctxt(\"trans_fail_bounds_check\");\n-    let ccx = bcx.ccx();\n-\n-    let loc = bcx.sess().parse_sess.cm.lookup_char_pos(sp.lo);\n-    let line = C_int(ccx, loc.line as int);\n-    let filename_cstr = C_cstr(bcx.ccx(), @/*bad*/copy loc.file.name);\n-    let filename = PointerCast(bcx, filename_cstr, T_ptr(T_i8()));\n-\n+    let (filename, line) = filename_and_line_num_from_span(bcx, sp);\n     let args = ~[filename, line, index, len];\n     let bcx = callee::trans_lang_call(\n         bcx, bcx.tcx().lang_items.fail_bounds_check_fn(), args, expr::Ignore);"}, {"sha": "d4ca0f3c4bed20f9d34b4c00a168e873407ce51d", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 13, "deletions": 139, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/989d008124d62f7c1284633e6619db1a9e8b6598/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/989d008124d62f7c1284633e6619db1a9e8b6598/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=989d008124d62f7c1284633e6619db1a9e8b6598", "patch": "@@ -87,21 +87,19 @@\n \n use lib;\n use lib::llvm::ValueRef;\n-use middle::borrowck::{RootInfo, root_map_key, DynaImm, DynaMut};\n use middle::trans::adt;\n use middle::trans::base::*;\n use middle::trans::build::*;\n-use middle::trans::callee;\n use middle::trans::common::*;\n use middle::trans::common;\n use middle::trans::expr;\n use middle::trans::glue;\n use middle::trans::tvec;\n use middle::trans::type_of;\n+use middle::trans::write_guard;\n use middle::ty;\n use util::common::indenter;\n use util::ppaux::ty_to_str;\n-use driver::session;\n \n use core::container::Set; // XXX: this should not be necessary\n use core::to_bytes;\n@@ -518,113 +516,6 @@ pub impl Datum {\n         }\n     }\n \n-    fn root(&self, mut bcx: block, span: span,\n-            root_key: root_map_key, root_info: RootInfo) -> block {\n-        /*!\n-         *\n-         * In some cases, borrowck will decide that an @T/@[]/@str\n-         * value must be rooted for the program to be safe.  In that\n-         * case, we will call this function, which will stash a copy\n-         * away until we exit the scope `scope_id`. */\n-\n-        debug!(\"root(root_map_key=%?, root_info=%?, self=%?)\",\n-               root_key, root_info, self.to_str(bcx.ccx()));\n-\n-        if bcx.sess().trace() {\n-            trans_trace(\n-                bcx, None,\n-                @fmt!(\"preserving until end of scope %d\",\n-                     root_info.scope));\n-        }\n-\n-        // First, root the datum. Note that we must zero this value,\n-        // because sometimes we root on one path but not another.\n-        // See e.g. #4904.\n-        let scratch = scratch_datum(bcx, self.ty, true);\n-        self.copy_to_datum(bcx, INIT, scratch);\n-        let cleanup_bcx = find_bcx_for_scope(bcx, root_info.scope);\n-        add_clean_temp_mem(cleanup_bcx, scratch.val, scratch.ty);\n-\n-        // Now, consider also freezing it.\n-        match root_info.freeze {\n-            None => {}\n-            Some(freeze_kind) => {\n-                let loc = bcx.sess().parse_sess.cm.lookup_char_pos(span.lo);\n-                let line = C_int(bcx.ccx(), loc.line as int);\n-                let filename_cstr = C_cstr(bcx.ccx(), @/*bad*/copy loc.file.name);\n-                let filename = PointerCast(bcx, filename_cstr, T_ptr(T_i8()));\n-\n-                // in this case, we don't have to zero, because\n-                // scratch.val will be NULL should the cleanup get\n-                // called without the freezing actually occurring, and\n-                // return_to_mut checks for this condition.\n-                let scratch_bits = scratch_datum(bcx, ty::mk_uint(), false);\n-\n-                let freeze_did = match freeze_kind {\n-                    DynaImm => bcx.tcx().lang_items.borrow_as_imm_fn(),\n-                    DynaMut => bcx.tcx().lang_items.borrow_as_mut_fn(),\n-                };\n-\n-                let box_ptr = Load(bcx,\n-                                   PointerCast(bcx,\n-                                               scratch.val,\n-                                               T_ptr(T_ptr(T_i8()))));\n-\n-                bcx = callee::trans_lang_call(\n-                    bcx,\n-                    freeze_did,\n-                    ~[\n-                        box_ptr,\n-                        filename,\n-                        line\n-                    ],\n-                    expr::SaveIn(scratch_bits.val));\n-\n-                if bcx.tcx().sess.opts.optimize == session::No {\n-                    bcx = callee::trans_lang_call(\n-                        bcx,\n-                        bcx.tcx().lang_items.record_borrow_fn(),\n-                        ~[\n-                            box_ptr,\n-                            Load(bcx, scratch_bits.val),\n-                            filename,\n-                            line\n-                        ],\n-                        expr::Ignore);\n-                }\n-\n-                add_clean_return_to_mut(\n-                    cleanup_bcx, scratch.val, scratch_bits.val,\n-                    filename, line);\n-            }\n-        }\n-\n-        bcx\n-    }\n-\n-    fn perform_write_guard(&self, bcx: block, span: span) -> block {\n-        debug!(\"perform_write_guard\");\n-\n-        // Create scratch space, but do not root it.\n-        let llval = match self.mode {\n-            ByValue => self.val,\n-            ByRef => Load(bcx, self.val),\n-        };\n-\n-        let loc = bcx.sess().parse_sess.cm.lookup_char_pos(span.lo);\n-        let line = C_int(bcx.ccx(), loc.line as int);\n-        let filename_cstr = C_cstr(bcx.ccx(), @/*bad*/copy loc.file.name);\n-        let filename = PointerCast(bcx, filename_cstr, T_ptr(T_i8()));\n-\n-        callee::trans_lang_call(\n-            bcx,\n-            bcx.tcx().lang_items.check_not_borrowed_fn(),\n-            ~[PointerCast(bcx, llval, T_ptr(T_i8())),\n-              filename,\n-              line],\n-            expr::Ignore)\n-    }\n-\n     fn drop_val(&self, bcx: block) -> block {\n         if !ty::type_needs_drop(bcx.tcx(), self.ty) {\n             return bcx;\n@@ -687,7 +578,9 @@ pub impl Datum {\n         debug!(\"try_deref(expr_id=%?, derefs=%?, is_auto=%b, self=%?)\",\n                expr_id, derefs, is_auto, self.to_str(bcx.ccx()));\n \n-        let bcx = self.root_and_write_guard(bcx, span, expr_id, derefs);\n+        let bcx =\n+            write_guard::root_and_write_guard(\n+                self, bcx, span, expr_id, derefs);\n \n         match ty::get(self.ty).sty {\n             ty::ty_box(_) | ty::ty_uniq(_) => {\n@@ -841,33 +734,6 @@ pub impl Datum {\n         DatumBlock { bcx: bcx, datum: datum }\n     }\n \n-    fn root_and_write_guard(&self,\n-                            mut bcx: block,\n-                            span: span,\n-                            expr_id: ast::node_id,\n-                            derefs: uint) -> block {\n-        let key = root_map_key { id: expr_id, derefs: derefs };\n-        debug!(\"root_and_write_guard(key=%?)\", key);\n-\n-        // root the autoderef'd value, if necessary:\n-        //\n-        // (Note: root'd values are always boxes)\n-        let ccx = bcx.ccx();\n-        bcx = match ccx.maps.root_map.find(&key) {\n-            None => bcx,\n-            Some(&root_info) => self.root(bcx, span, key, root_info)\n-        };\n-\n-        // Perform the write guard, if necessary.\n-        //\n-        // (Note: write-guarded values are always boxes)\n-        if ccx.maps.write_guard_map.contains(&key) {\n-            self.perform_write_guard(bcx, span)\n-        } else {\n-            bcx\n-        }\n-    }\n-\n     fn get_vec_base_and_len(&self,\n                             mut bcx: block,\n                             span: span,\n@@ -877,7 +743,7 @@ pub impl Datum {\n         //! and write guards checks.\n \n         // only imp't for @[] and @str, but harmless\n-        bcx = self.root_and_write_guard(bcx, span, expr_id, 0);\n+        bcx = write_guard::root_and_write_guard(self, bcx, span, expr_id, 0);\n         let (base, len) = self.get_vec_base_and_len_no_root(bcx);\n         (bcx, base, len)\n     }\n@@ -890,6 +756,14 @@ pub impl Datum {\n         tvec::get_base_and_len(bcx, llval, self.ty)\n     }\n \n+    fn root_and_write_guard(&self,\n+                            bcx: block,\n+                            span: span,\n+                            expr_id: ast::node_id,\n+                            derefs: uint) -> block {\n+        write_guard::root_and_write_guard(self, bcx, span, expr_id, derefs)\n+    }\n+\n     fn to_result(&self, bcx: block) -> common::Result {\n         rslt(bcx, self.to_appropriate_llval(bcx))\n     }"}, {"sha": "7191a98e5dbc678f625eae1509ba7207826f98de", "filename": "src/librustc/rustc.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/989d008124d62f7c1284633e6619db1a9e8b6598/src%2Flibrustc%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/989d008124d62f7c1284633e6619db1a9e8b6598/src%2Flibrustc%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Frustc.rc?ref=989d008124d62f7c1284633e6619db1a9e8b6598", "patch": "@@ -47,6 +47,7 @@ pub mod middle {\n         pub mod controlflow;\n         pub mod glue;\n         pub mod datum;\n+        pub mod write_guard;\n         pub mod callee;\n         pub mod expr;\n         pub mod common;"}]}