{"sha": "7d2c2dbf4b284ff898caea84e92dd313c6e2419a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdkMmMyZGJmNGIyODRmZjg5OGNhZWE4NGU5MmRkMzEzYzZlMjQxOWE=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-12-20T08:33:15Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-12-21T00:32:41Z"}, "message": "tutorial: Reorder sections on traits\n\n/cc: #4217", "tree": {"sha": "fbe95070186298f8a521b73ce2ae6b29575e9769", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fbe95070186298f8a521b73ce2ae6b29575e9769"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7d2c2dbf4b284ff898caea84e92dd313c6e2419a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7d2c2dbf4b284ff898caea84e92dd313c6e2419a", "html_url": "https://github.com/rust-lang/rust/commit/7d2c2dbf4b284ff898caea84e92dd313c6e2419a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7d2c2dbf4b284ff898caea84e92dd313c6e2419a/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "850050b7dfad4dbc241d299842c7f8e12b2053e9", "url": "https://api.github.com/repos/rust-lang/rust/commits/850050b7dfad4dbc241d299842c7f8e12b2053e9", "html_url": "https://github.com/rust-lang/rust/commit/850050b7dfad4dbc241d299842c7f8e12b2053e9"}], "stats": {"total": 164, "additions": 82, "deletions": 82}, "files": [{"sha": "812e46624aaf2ff8967e6f045f601e76a5bf6549", "filename": "doc/tutorial.md", "status": "modified", "additions": 82, "deletions": 82, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/7d2c2dbf4b284ff898caea84e92dd313c6e2419a/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/7d2c2dbf4b284ff898caea84e92dd313c6e2419a/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=7d2c2dbf4b284ff898caea84e92dd313c6e2419a", "patch": "@@ -2092,6 +2092,88 @@ the preferred way to use traits polymorphically.\n \n This usage of traits is similar to Haskell type classes.\n \n+## Trait objects and dynamic method dispatch\n+\n+The above allows us to define functions that polymorphically act on\n+values of a single unknown type that conforms to a given trait.\n+However, consider this function:\n+\n+~~~~\n+# type Circle = int; type Rectangle = int;\n+# impl int: Drawable { fn draw() {} }\n+# fn new_circle() -> int { 1 }\n+trait Drawable { fn draw(); }\n+\n+fn draw_all<T: Drawable>(shapes: ~[T]) {\n+    for shapes.each |shape| { shape.draw(); }\n+}\n+# let c: Circle = new_circle();\n+# draw_all(~[c]);\n+~~~~\n+\n+You can call that on an array of circles, or an array of squares\n+(assuming those have suitable `Drawable` traits defined), but not on\n+an array containing both circles and squares. When such behavior is\n+needed, a trait name can alternately be used as a type, called\n+an _object_.\n+\n+~~~~\n+# trait Drawable { fn draw(); }\n+fn draw_all(shapes: &[@Drawable]) {\n+    for shapes.each |shape| { shape.draw(); }\n+}\n+~~~~\n+\n+In this example, there is no type parameter. Instead, the `@Drawable`\n+type denotes any managed box value that implements the `Drawable`\n+trait. To construct such a value, you use the `as` operator to cast a\n+value to an object:\n+\n+~~~~\n+# type Circle = int; type Rectangle = bool;\n+# trait Drawable { fn draw(); }\n+# fn new_circle() -> Circle { 1 }\n+# fn new_rectangle() -> Rectangle { true }\n+# fn draw_all(shapes: &[@Drawable]) {}\n+\n+impl Circle: Drawable { fn draw() { ... } }\n+\n+impl Rectangle: Drawable { fn draw() { ... } }\n+\n+let c: @Circle = @new_circle();\n+let r: @Rectangle = @new_rectangle();\n+draw_all([c as @Drawable, r as @Drawable]);\n+~~~~\n+\n+We omit the code for `new_circle` and `new_rectangle`; imagine that\n+these just return `Circle`s and `Rectangle`s with a default size. Note\n+that, like strings and vectors, objects have dynamic size and may\n+only be referred to via one of the pointer types.\n+Other pointer types work as well.\n+Casts to traits may only be done with compatible pointers so,\n+for example, an `@Circle` may not be cast to an `~Drawable`.\n+\n+~~~\n+# type Circle = int; type Rectangle = int;\n+# trait Drawable { fn draw(); }\n+# impl int: Drawable { fn draw() {} }\n+# fn new_circle() -> int { 1 }\n+# fn new_rectangle() -> int { 2 }\n+// A managed object\n+let boxy: @Drawable = @new_circle() as @Drawable;\n+// An owned object\n+let owny: ~Drawable = ~new_circle() as ~Drawable;\n+// A borrowed object\n+let stacky: &Drawable = &new_circle() as &Drawable;\n+~~~\n+\n+Method calls to trait types are _dynamically dispatched_. Since the\n+compiler doesn't know specifically which functions to call at compile\n+time, it uses a lookup table (also known as a vtable or dictionary) to\n+select the method to call at runtime.\n+\n+This usage of traits is similar to Java interfaces.\n+\n ## Static methods\n \n Traits can define _static_ methods, which don't have an implicit `self` argument.\n@@ -2179,88 +2261,6 @@ let nonsense = mycircle.radius() * mycircle.area();\n \n > ***Note:*** Trait inheritance does not actually work with objects yet\n \n-## Trait objects and dynamic method dispatch\n-\n-The above allows us to define functions that polymorphically act on\n-values of a single unknown type that conforms to a given trait.\n-However, consider this function:\n-\n-~~~~\n-# type Circle = int; type Rectangle = int;\n-# impl int: Drawable { fn draw() {} }\n-# fn new_circle() -> int { 1 }\n-trait Drawable { fn draw(); }\n-\n-fn draw_all<T: Drawable>(shapes: ~[T]) {\n-    for shapes.each |shape| { shape.draw(); }\n-}\n-# let c: Circle = new_circle();\n-# draw_all(~[c]);\n-~~~~\n-\n-You can call that on an array of circles, or an array of squares\n-(assuming those have suitable `Drawable` traits defined), but not on\n-an array containing both circles and squares. When such behavior is\n-needed, a trait name can alternately be used as a type, called\n-an _object_.\n-\n-~~~~\n-# trait Drawable { fn draw(); }\n-fn draw_all(shapes: &[@Drawable]) {\n-    for shapes.each |shape| { shape.draw(); }\n-}\n-~~~~\n-\n-In this example, there is no type parameter. Instead, the `@Drawable`\n-type denotes any managed box value that implements the `Drawable`\n-trait. To construct such a value, you use the `as` operator to cast a\n-value to an object:\n-\n-~~~~\n-# type Circle = int; type Rectangle = bool;\n-# trait Drawable { fn draw(); }\n-# fn new_circle() -> Circle { 1 }\n-# fn new_rectangle() -> Rectangle { true }\n-# fn draw_all(shapes: &[@Drawable]) {}\n-\n-impl Circle: Drawable { fn draw() { ... } }\n-\n-impl Rectangle: Drawable { fn draw() { ... } }\n-\n-let c: @Circle = @new_circle();\n-let r: @Rectangle = @new_rectangle();\n-draw_all([c as @Drawable, r as @Drawable]);\n-~~~~\n-\n-We omit the code for `new_circle` and `new_rectangle`; imagine that\n-these just return `Circle`s and `Rectangle`s with a default size. Note\n-that, like strings and vectors, objects have dynamic size and may\n-only be referred to via one of the pointer types.\n-Other pointer types work as well.\n-Casts to traits may only be done with compatible pointers so,\n-for example, an `@Circle` may not be cast to an `~Drawable`.\n-\n-~~~\n-# type Circle = int; type Rectangle = int;\n-# trait Drawable { fn draw(); }\n-# impl int: Drawable { fn draw() {} }\n-# fn new_circle() -> int { 1 }\n-# fn new_rectangle() -> int { 2 }\n-// A managed object\n-let boxy: @Drawable = @new_circle() as @Drawable;\n-// An owned object\n-let owny: ~Drawable = ~new_circle() as ~Drawable;\n-// A borrowed object\n-let stacky: &Drawable = &new_circle() as &Drawable;\n-~~~\n-\n-Method calls to trait types are _dynamically dispatched_. Since the\n-compiler doesn't know specifically which functions to call at compile\n-time, it uses a lookup table (also known as a vtable or dictionary) to\n-select the method to call at runtime.\n-\n-This usage of traits is similar to Java interfaces.\n-\n # Modules and crates\n \n The Rust namespace is arranged in a hierarchy of modules. Each source"}]}