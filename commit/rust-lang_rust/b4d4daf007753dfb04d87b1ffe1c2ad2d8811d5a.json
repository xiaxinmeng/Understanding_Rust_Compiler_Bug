{"sha": "b4d4daf007753dfb04d87b1ffe1c2ad2d8811d5a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI0ZDRkYWYwMDc3NTNkZmIwNGQ4N2IxZmZlMWMyYWQyZDg4MTFkNWE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-03-21T23:33:27Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-03-23T20:55:43Z"}, "message": "Adjust Index/IndexMut impls. For generic collections, we take\nreferences. For collections whose keys are integers, we take both\nreferences and by-value.", "tree": {"sha": "c35d3d74c271c4ec72678d9d866bcad331a9e706", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c35d3d74c271c4ec72678d9d866bcad331a9e706"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b4d4daf007753dfb04d87b1ffe1c2ad2d8811d5a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b4d4daf007753dfb04d87b1ffe1c2ad2d8811d5a", "html_url": "https://github.com/rust-lang/rust/commit/b4d4daf007753dfb04d87b1ffe1c2ad2d8811d5a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b4d4daf007753dfb04d87b1ffe1c2ad2d8811d5a/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bc1dde468c1613743c919cb9f33923cc9916c5b4", "url": "https://api.github.com/repos/rust-lang/rust/commits/bc1dde468c1613743c919cb9f33923cc9916c5b4", "html_url": "https://github.com/rust-lang/rust/commit/bc1dde468c1613743c919cb9f33923cc9916c5b4"}], "stats": {"total": 608, "additions": 600, "deletions": 8}, "files": [{"sha": "0a72f24b437405ddf5252f014c310aef4f3126b2", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b4d4daf007753dfb04d87b1ffe1c2ad2d8811d5a/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4d4daf007753dfb04d87b1ffe1c2ad2d8811d5a/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=b4d4daf007753dfb04d87b1ffe1c2ad2d8811d5a", "patch": "@@ -914,12 +914,27 @@ impl<K: Debug, V: Debug> Debug for BTreeMap<K, V> {\n     }\n }\n \n+#[cfg(stage0)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K: Ord, Q: ?Sized, V> Index<Q> for BTreeMap<K, V>\n     where K: Borrow<Q>, Q: Ord\n {\n     type Output = V;\n \n+    #[inline]\n+    fn index(&self, key: &Q) -> &V {\n+        self.get(key).expect(\"no entry found for key\")\n+    }\n+}\n+\n+#[cfg(not(stage0))]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, K: Ord, Q: ?Sized, V> Index<&'a Q> for BTreeMap<K, V>\n+    where K: Borrow<Q>, Q: Ord\n+{\n+    type Output = V;\n+\n+    #[inline]\n     fn index(&self, key: &Q) -> &V {\n         self.get(key).expect(\"no entry found for key\")\n     }"}, {"sha": "3f869d0b8ae45bf2c9203627b2704aad05ae209a", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b4d4daf007753dfb04d87b1ffe1c2ad2d8811d5a/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4d4daf007753dfb04d87b1ffe1c2ad2d8811d5a/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=b4d4daf007753dfb04d87b1ffe1c2ad2d8811d5a", "patch": "@@ -870,34 +870,66 @@ impl<'a> Add<&'a str> for String {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl ops::Index<ops::Range<usize>> for String {\n     type Output = str;\n+\n+    #[cfg(stage0)]\n     #[inline]\n     fn index(&self, index: &ops::Range<usize>) -> &str {\n         &self[..][*index]\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index(&self, index: ops::Range<usize>) -> &str {\n+        &self[..][index]\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl ops::Index<ops::RangeTo<usize>> for String {\n     type Output = str;\n+\n+    #[cfg(stage0)]\n     #[inline]\n     fn index(&self, index: &ops::RangeTo<usize>) -> &str {\n         &self[..][*index]\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index(&self, index: ops::RangeTo<usize>) -> &str {\n+        &self[..][index]\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl ops::Index<ops::RangeFrom<usize>> for String {\n     type Output = str;\n+\n+    #[cfg(stage0)]\n     #[inline]\n     fn index(&self, index: &ops::RangeFrom<usize>) -> &str {\n         &self[..][*index]\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index(&self, index: ops::RangeFrom<usize>) -> &str {\n+        &self[..][index]\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl ops::Index<ops::RangeFull> for String {\n     type Output = str;\n+\n+    #[cfg(stage0)]\n     #[inline]\n     fn index(&self, _index: &ops::RangeFull) -> &str {\n         unsafe { mem::transmute(&*self.vec) }\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index(&self, _index: ops::RangeFull) -> &str {\n+        unsafe { mem::transmute(&*self.vec) }\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "3e46ebfc44634e9fe316187542257f043be91646", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/b4d4daf007753dfb04d87b1ffe1c2ad2d8811d5a/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4d4daf007753dfb04d87b1ffe1c2ad2d8811d5a/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=b4d4daf007753dfb04d87b1ffe1c2ad2d8811d5a", "patch": "@@ -1323,83 +1323,165 @@ impl<T: Hash> Hash for Vec<T> {\n impl<T> Index<usize> for Vec<T> {\n     type Output = T;\n \n+\n+    #[cfg(stage0)]\n     #[inline]\n     fn index(&self, index: &usize) -> &T {\n         // NB built-in indexing via `&[T]`\n         &(**self)[*index]\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index(&self, index: usize) -> &T {\n+        // NB built-in indexing via `&[T]`\n+        &(**self)[index]\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> IndexMut<usize> for Vec<T> {\n+\n+    #[cfg(stage0)]\n     #[inline]\n     fn index_mut(&mut self, index: &usize) -> &mut T {\n         // NB built-in indexing via `&mut [T]`\n         &mut (**self)[*index]\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index_mut(&mut self, index: usize) -> &mut T {\n+        // NB built-in indexing via `&mut [T]`\n+        &mut (**self)[index]\n+    }\n }\n \n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::Index<ops::Range<usize>> for Vec<T> {\n     type Output = [T];\n+\n+    #[cfg(stage0)]\n     #[inline]\n     fn index(&self, index: &ops::Range<usize>) -> &[T] {\n         Index::index(&**self, index)\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index(&self, index: ops::Range<usize>) -> &[T] {\n+        Index::index(&**self, index)\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::Index<ops::RangeTo<usize>> for Vec<T> {\n     type Output = [T];\n+\n+    #[cfg(stage0)]\n     #[inline]\n     fn index(&self, index: &ops::RangeTo<usize>) -> &[T] {\n         Index::index(&**self, index)\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index(&self, index: ops::RangeTo<usize>) -> &[T] {\n+        Index::index(&**self, index)\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::Index<ops::RangeFrom<usize>> for Vec<T> {\n     type Output = [T];\n+\n+    #[cfg(stage0)]\n     #[inline]\n     fn index(&self, index: &ops::RangeFrom<usize>) -> &[T] {\n         Index::index(&**self, index)\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index(&self, index: ops::RangeFrom<usize>) -> &[T] {\n+        Index::index(&**self, index)\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::Index<ops::RangeFull> for Vec<T> {\n     type Output = [T];\n+\n+    #[cfg(stage0)]\n     #[inline]\n     fn index(&self, _index: &ops::RangeFull) -> &[T] {\n         self.as_slice()\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index(&self, _index: ops::RangeFull) -> &[T] {\n+        self.as_slice()\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::IndexMut<ops::Range<usize>> for Vec<T> {\n+\n+    #[cfg(stage0)]\n     #[inline]\n     fn index_mut(&mut self, index: &ops::Range<usize>) -> &mut [T] {\n         IndexMut::index_mut(&mut **self, index)\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index_mut(&mut self, index: ops::Range<usize>) -> &mut [T] {\n+        IndexMut::index_mut(&mut **self, index)\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::IndexMut<ops::RangeTo<usize>> for Vec<T> {\n+\n+    #[cfg(stage0)]\n     #[inline]\n     fn index_mut(&mut self, index: &ops::RangeTo<usize>) -> &mut [T] {\n         IndexMut::index_mut(&mut **self, index)\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index_mut(&mut self, index: ops::RangeTo<usize>) -> &mut [T] {\n+        IndexMut::index_mut(&mut **self, index)\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::IndexMut<ops::RangeFrom<usize>> for Vec<T> {\n+\n+    #[cfg(stage0)]\n     #[inline]\n     fn index_mut(&mut self, index: &ops::RangeFrom<usize>) -> &mut [T] {\n         IndexMut::index_mut(&mut **self, index)\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index_mut(&mut self, index: ops::RangeFrom<usize>) -> &mut [T] {\n+        IndexMut::index_mut(&mut **self, index)\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::IndexMut<ops::RangeFull> for Vec<T> {\n+\n+    #[cfg(stage0)]\n     #[inline]\n     fn index_mut(&mut self, _index: &ops::RangeFull) -> &mut [T] {\n         self.as_mut_slice()\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index_mut(&mut self, _index: ops::RangeFull) -> &mut [T] {\n+        self.as_mut_slice()\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "591ad48f57912316e9bccf26d97132862ce34706", "filename": "src/libcollections/vec_deque.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b4d4daf007753dfb04d87b1ffe1c2ad2d8811d5a/src%2Flibcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4d4daf007753dfb04d87b1ffe1c2ad2d8811d5a/src%2Flibcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_deque.rs?ref=b4d4daf007753dfb04d87b1ffe1c2ad2d8811d5a", "patch": "@@ -1689,18 +1689,32 @@ impl<A: Hash> Hash for VecDeque<A> {\n impl<A> Index<usize> for VecDeque<A> {\n     type Output = A;\n \n+    #[cfg(stage0)]\n     #[inline]\n     fn index(&self, i: &usize) -> &A {\n         self.get(*i).expect(\"Out of bounds access\")\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index(&self, i: usize) -> &A {\n+        self.get(i).expect(\"Out of bounds access\")\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A> IndexMut<usize> for VecDeque<A> {\n+    #[cfg(stage0)]\n     #[inline]\n     fn index_mut(&mut self, i: &usize) -> &mut A {\n         self.get_mut(*i).expect(\"Out of bounds access\")\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index_mut(&mut self, i: usize) -> &mut A {\n+        self.get_mut(i).expect(\"Out of bounds access\")\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "05693ec52756ad0e9a95505e603c75e456ebf987", "filename": "src/libcollections/vec_map.rs", "status": "modified", "additions": 41, "deletions": 1, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/b4d4daf007753dfb04d87b1ffe1c2ad2d8811d5a/src%2Flibcollections%2Fvec_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4d4daf007753dfb04d87b1ffe1c2ad2d8811d5a/src%2Flibcollections%2Fvec_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_map.rs?ref=b4d4daf007753dfb04d87b1ffe1c2ad2d8811d5a", "patch": "@@ -798,6 +798,7 @@ impl<V> Extend<(usize, V)> for VecMap<V> {\n     }\n }\n \n+#[cfg(stage0)]\n impl<V> Index<usize> for VecMap<V> {\n     type Output = V;\n \n@@ -807,10 +808,49 @@ impl<V> Index<usize> for VecMap<V> {\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl<V> Index<usize> for VecMap<V> {\n+    type Output = V;\n+\n+    #[inline]\n+    fn index<'a>(&'a self, i: usize) -> &'a V {\n+        self.get(&i).expect(\"key not present\")\n+    }\n+}\n+\n+#[cfg(not(stage0))]\n+impl<'a,V> Index<&'a usize> for VecMap<V> {\n+    type Output = V;\n+\n+    #[inline]\n+    fn index(&self, i: &usize) -> &V {\n+        self.get(i).expect(\"key not present\")\n+    }\n+}\n+\n+#[cfg(stage0)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<V> IndexMut<usize> for VecMap<V> {\n+    #[inline]\n+    fn index_mut(&mut self, i: &usize) -> &mut V {\n+        self.get_mut(&i).expect(\"key not present\")\n+    }\n+}\n+\n+#[cfg(not(stage0))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<V> IndexMut<usize> for VecMap<V> {\n     #[inline]\n-    fn index_mut<'a>(&'a mut self, i: &usize) -> &'a mut V {\n+    fn index_mut(&mut self, i: usize) -> &mut V {\n+        self.get_mut(&i).expect(\"key not present\")\n+    }\n+}\n+\n+#[cfg(not(stage0))]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, V> IndexMut<&'a usize> for VecMap<V> {\n+    #[inline]\n+    fn index_mut(&mut self, i: &usize) -> &mut V {\n         self.get_mut(i).expect(\"key not present\")\n     }\n }"}, {"sha": "6e6f97a7af7d9e1d2595309f78ef918885ba4965", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b4d4daf007753dfb04d87b1ffe1c2ad2d8811d5a/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4d4daf007753dfb04d87b1ffe1c2ad2d8811d5a/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=b4d4daf007753dfb04d87b1ffe1c2ad2d8811d5a", "patch": "@@ -898,7 +898,7 @@ shr_impl_all! { u8 u16 u32 u64 usize i8 i16 i32 i64 isize }\n /// impl Index<Bar> for Foo {\n ///     type Output = Foo;\n ///\n-///     fn index<'a>(&'a self, _index: &Bar) -> &'a Foo {\n+///     fn index<'a>(&'a self, _index: Bar) -> &'a Foo {\n ///         println!(\"Indexing!\");\n ///         self\n ///     }\n@@ -945,13 +945,13 @@ pub trait Index<Idx: ?Sized> {\n /// impl Index<Bar> for Foo {\n ///     type Output = Foo;\n ///\n-///     fn index<'a>(&'a self, _index: &Bar) -> &'a Foo {\n+///     fn index<'a>(&'a self, _index: Bar) -> &'a Foo {\n ///         self\n ///     }\n /// }\n ///\n /// impl IndexMut<Bar> for Foo {\n-///     fn index_mut<'a>(&'a mut self, _index: &Bar) -> &'a mut Foo {\n+///     fn index_mut<'a>(&'a mut self, _index: Bar) -> &'a mut Foo {\n ///         println!(\"Indexing!\");\n ///         self\n ///     }"}, {"sha": "04b425416f3af31970a682b87b1657045f28d771", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 201, "deletions": 0, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/b4d4daf007753dfb04d87b1ffe1c2ad2d8811d5a/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4d4daf007753dfb04d87b1ffe1c2ad2d8811d5a/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=b4d4daf007753dfb04d87b1ffe1c2ad2d8811d5a", "patch": "@@ -263,6 +263,7 @@ impl<T> SliceExt for [T] {\n     #[inline]\n     fn as_mut_slice(&mut self) -> &mut [T] { self }\n \n+    #[cfg(stage0)]\n     #[inline]\n     fn split_at_mut(&mut self, mid: usize) -> (&mut [T], &mut [T]) {\n         unsafe {\n@@ -273,6 +274,17 @@ impl<T> SliceExt for [T] {\n         }\n     }\n \n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn split_at_mut(&mut self, mid: usize) -> (&mut [T], &mut [T]) {\n+        unsafe {\n+            let self2: &mut [T] = mem::transmute_copy(&self);\n+\n+            (ops::IndexMut::index_mut(self, ops::RangeTo { end: mid } ),\n+             ops::IndexMut::index_mut(self2, ops::RangeFrom { start: mid } ))\n+        }\n+    }\n+\n     #[inline]\n     fn iter_mut<'a>(&'a mut self) -> IterMut<'a, T> {\n         unsafe {\n@@ -495,25 +507,45 @@ impl<T> SliceExt for [T] {\n impl<T> ops::Index<usize> for [T] {\n     type Output = T;\n \n+    #[cfg(stage0)]\n     fn index(&self, &index: &usize) -> &T {\n         assert!(index < self.len());\n \n         unsafe { mem::transmute(self.repr().data.offset(index as isize)) }\n     }\n+\n+    #[cfg(not(stage0))]\n+    fn index(&self, index: usize) -> &T {\n+        assert!(index < self.len());\n+\n+        unsafe { mem::transmute(self.repr().data.offset(index as isize)) }\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::IndexMut<usize> for [T] {\n+    #[cfg(stage0)]\n+    #[inline]\n     fn index_mut(&mut self, &index: &usize) -> &mut T {\n         assert!(index < self.len());\n \n         unsafe { mem::transmute(self.repr().data.offset(index as isize)) }\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index_mut(&mut self, index: usize) -> &mut T {\n+        assert!(index < self.len());\n+\n+        unsafe { mem::transmute(self.repr().data.offset(index as isize)) }\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::Index<ops::Range<usize>> for [T] {\n     type Output = [T];\n+\n+    #[cfg(stage0)]\n     #[inline]\n     fn index(&self, index: &ops::Range<usize>) -> &[T] {\n         assert!(index.start <= index.end);\n@@ -525,34 +557,72 @@ impl<T> ops::Index<ops::Range<usize>> for [T] {\n             )\n         }\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index(&self, index: ops::Range<usize>) -> &[T] {\n+        assert!(index.start <= index.end);\n+        assert!(index.end <= self.len());\n+        unsafe {\n+            from_raw_parts (\n+                self.as_ptr().offset(index.start as isize),\n+                index.end - index.start\n+            )\n+        }\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::Index<ops::RangeTo<usize>> for [T] {\n     type Output = [T];\n+\n+    #[cfg(stage0)]\n     #[inline]\n     fn index(&self, index: &ops::RangeTo<usize>) -> &[T] {\n         self.index(&ops::Range{ start: 0, end: index.end })\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index(&self, index: ops::RangeTo<usize>) -> &[T] {\n+        self.index(ops::Range{ start: 0, end: index.end })\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::Index<ops::RangeFrom<usize>> for [T] {\n     type Output = [T];\n+\n+    #[cfg(stage0)]\n     #[inline]\n     fn index(&self, index: &ops::RangeFrom<usize>) -> &[T] {\n         self.index(&ops::Range{ start: index.start, end: self.len() })\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index(&self, index: ops::RangeFrom<usize>) -> &[T] {\n+        self.index(ops::Range{ start: index.start, end: self.len() })\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::Index<RangeFull> for [T] {\n     type Output = [T];\n+\n+    #[cfg(stage0)]\n     #[inline]\n     fn index(&self, _index: &RangeFull) -> &[T] {\n         self\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index(&self, _index: RangeFull) -> &[T] {\n+        self\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::IndexMut<ops::Range<usize>> for [T] {\n+    #[cfg(stage0)]\n     #[inline]\n     fn index_mut(&mut self, index: &ops::Range<usize>) -> &mut [T] {\n         assert!(index.start <= index.end);\n@@ -564,28 +634,64 @@ impl<T> ops::IndexMut<ops::Range<usize>> for [T] {\n             )\n         }\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index_mut(&mut self, index: ops::Range<usize>) -> &mut [T] {\n+        assert!(index.start <= index.end);\n+        assert!(index.end <= self.len());\n+        unsafe {\n+            from_raw_parts_mut(\n+                self.as_mut_ptr().offset(index.start as isize),\n+                index.end - index.start\n+            )\n+        }\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::IndexMut<ops::RangeTo<usize>> for [T] {\n+    #[cfg(stage0)]\n     #[inline]\n     fn index_mut(&mut self, index: &ops::RangeTo<usize>) -> &mut [T] {\n         self.index_mut(&ops::Range{ start: 0, end: index.end })\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index_mut(&mut self, index: ops::RangeTo<usize>) -> &mut [T] {\n+        self.index_mut(ops::Range{ start: 0, end: index.end })\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::IndexMut<ops::RangeFrom<usize>> for [T] {\n+    #[cfg(stage0)]\n     #[inline]\n     fn index_mut(&mut self, index: &ops::RangeFrom<usize>) -> &mut [T] {\n         let len = self.len();\n         self.index_mut(&ops::Range{ start: index.start, end: len })\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index_mut(&mut self, index: ops::RangeFrom<usize>) -> &mut [T] {\n+        let len = self.len();\n+        self.index_mut(ops::Range{ start: index.start, end: len })\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::IndexMut<RangeFull> for [T] {\n+\n+    #[cfg(stage0)]\n     #[inline]\n     fn index_mut(&mut self, _index: &RangeFull) -> &mut [T] {\n         self\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index_mut(&mut self, _index: RangeFull) -> &mut [T] {\n+        self\n+    }\n }\n \n \n@@ -763,37 +869,69 @@ unsafe impl<'a, T: Sync> Send for Iter<'a, T> {}\n #[unstable(feature = \"core\")]\n impl<'a, T> ops::Index<ops::Range<usize>> for Iter<'a, T> {\n     type Output = [T];\n+\n+    #[cfg(stage0)]\n     #[inline]\n     fn index(&self, index: &ops::Range<usize>) -> &[T] {\n         self.as_slice().index(index)\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index(&self, index: ops::Range<usize>) -> &[T] {\n+        self.as_slice().index(index)\n+    }\n }\n \n #[unstable(feature = \"core\")]\n impl<'a, T> ops::Index<ops::RangeTo<usize>> for Iter<'a, T> {\n     type Output = [T];\n+\n+    #[cfg(stage0)]\n     #[inline]\n     fn index(&self, index: &ops::RangeTo<usize>) -> &[T] {\n         self.as_slice().index(index)\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index(&self, index: ops::RangeTo<usize>) -> &[T] {\n+        self.as_slice().index(index)\n+    }\n }\n \n #[unstable(feature = \"core\")]\n impl<'a, T> ops::Index<ops::RangeFrom<usize>> for Iter<'a, T> {\n     type Output = [T];\n+\n+    #[cfg(stage0)]\n     #[inline]\n     fn index(&self, index: &ops::RangeFrom<usize>) -> &[T] {\n         self.as_slice().index(index)\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index(&self, index: ops::RangeFrom<usize>) -> &[T] {\n+        self.as_slice().index(index)\n+    }\n }\n \n #[unstable(feature = \"core\")]\n impl<'a, T> ops::Index<RangeFull> for Iter<'a, T> {\n     type Output = [T];\n+\n+    #[cfg(stage0)]\n     #[inline]\n     fn index(&self, _index: &RangeFull) -> &[T] {\n         self.as_slice()\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index(&self, _index: RangeFull) -> &[T] {\n+        self.as_slice()\n+    }\n }\n \n impl<'a, T> Iter<'a, T> {\n@@ -856,63 +994,126 @@ unsafe impl<'a, T: Send> Send for IterMut<'a, T> {}\n #[unstable(feature = \"core\")]\n impl<'a, T> ops::Index<ops::Range<usize>> for IterMut<'a, T> {\n     type Output = [T];\n+\n+    #[cfg(stage0)]\n     #[inline]\n     fn index(&self, index: &ops::Range<usize>) -> &[T] {\n         self.index(&RangeFull).index(index)\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index(&self, index: ops::Range<usize>) -> &[T] {\n+        self.index(RangeFull).index(index)\n+    }\n }\n #[unstable(feature = \"core\")]\n impl<'a, T> ops::Index<ops::RangeTo<usize>> for IterMut<'a, T> {\n     type Output = [T];\n+\n+    #[cfg(stage0)]\n     #[inline]\n     fn index(&self, index: &ops::RangeTo<usize>) -> &[T] {\n         self.index(&RangeFull).index(index)\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index(&self, index: ops::RangeTo<usize>) -> &[T] {\n+        self.index(RangeFull).index(index)\n+    }\n }\n #[unstable(feature = \"core\")]\n impl<'a, T> ops::Index<ops::RangeFrom<usize>> for IterMut<'a, T> {\n     type Output = [T];\n+\n+    #[cfg(stage0)]\n     #[inline]\n     fn index(&self, index: &ops::RangeFrom<usize>) -> &[T] {\n         self.index(&RangeFull).index(index)\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index(&self, index: ops::RangeFrom<usize>) -> &[T] {\n+        self.index(RangeFull).index(index)\n+    }\n }\n #[unstable(feature = \"core\")]\n impl<'a, T> ops::Index<RangeFull> for IterMut<'a, T> {\n     type Output = [T];\n+\n+    #[cfg(stage0)]\n     #[inline]\n     fn index(&self, _index: &RangeFull) -> &[T] {\n         make_slice!(T => &[T]: self.ptr, self.end)\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index(&self, _index: RangeFull) -> &[T] {\n+        make_slice!(T => &[T]: self.ptr, self.end)\n+    }\n }\n \n #[unstable(feature = \"core\")]\n impl<'a, T> ops::IndexMut<ops::Range<usize>> for IterMut<'a, T> {\n+    #[cfg(stage0)]\n     #[inline]\n     fn index_mut(&mut self, index: &ops::Range<usize>) -> &mut [T] {\n         self.index_mut(&RangeFull).index_mut(index)\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index_mut(&mut self, index: ops::Range<usize>) -> &mut [T] {\n+        self.index_mut(RangeFull).index_mut(index)\n+    }\n }\n #[unstable(feature = \"core\")]\n impl<'a, T> ops::IndexMut<ops::RangeTo<usize>> for IterMut<'a, T> {\n+\n+    #[cfg(stage0)]\n     #[inline]\n     fn index_mut(&mut self, index: &ops::RangeTo<usize>) -> &mut [T] {\n         self.index_mut(&RangeFull).index_mut(index)\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index_mut(&mut self, index: ops::RangeTo<usize>) -> &mut [T] {\n+        self.index_mut(RangeFull).index_mut(index)\n+    }\n }\n #[unstable(feature = \"core\")]\n impl<'a, T> ops::IndexMut<ops::RangeFrom<usize>> for IterMut<'a, T> {\n+\n+    #[cfg(stage0)]\n     #[inline]\n     fn index_mut(&mut self, index: &ops::RangeFrom<usize>) -> &mut [T] {\n         self.index_mut(&RangeFull).index_mut(index)\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index_mut(&mut self, index: ops::RangeFrom<usize>) -> &mut [T] {\n+        self.index_mut(RangeFull).index_mut(index)\n+    }\n }\n #[unstable(feature = \"core\")]\n impl<'a, T> ops::IndexMut<RangeFull> for IterMut<'a, T> {\n+\n+    #[cfg(stage0)]\n     #[inline]\n     fn index_mut(&mut self, _index: &RangeFull) -> &mut [T] {\n         make_mut_slice!(T => &mut [T]: self.ptr, self.end)\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index_mut(&mut self, _index: RangeFull) -> &mut [T] {\n+        make_mut_slice!(T => &mut [T]: self.ptr, self.end)\n+    }\n }\n \n "}, {"sha": "b9a655c6d4e2858f3133054b0451f901fc386ea6", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/b4d4daf007753dfb04d87b1ffe1c2ad2d8811d5a/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4d4daf007753dfb04d87b1ffe1c2ad2d8811d5a/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=b4d4daf007753dfb04d87b1ffe1c2ad2d8811d5a", "patch": "@@ -1203,6 +1203,7 @@ mod traits {\n     /// // byte 100 is outside the string\n     /// // &s[3 .. 100];\n     /// ```\n+    #[cfg(stage0)]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl ops::Index<ops::Range<usize>> for str {\n         type Output = str;\n@@ -1219,6 +1220,49 @@ mod traits {\n         }\n     }\n \n+    /// Returns a slice of the given string from the byte range\n+    /// [`begin`..`end`).\n+    ///\n+    /// This operation is `O(1)`.\n+    ///\n+    /// Panics when `begin` and `end` do not point to valid characters\n+    /// or point beyond the last character of the string.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    /// assert_eq!(&s[0 .. 1], \"L\");\n+    ///\n+    /// assert_eq!(&s[1 .. 9], \"\u00f6we \u8001\");\n+    ///\n+    /// // these will panic:\n+    /// // byte 2 lies within `\u00f6`:\n+    /// // &s[2 ..3];\n+    ///\n+    /// // byte 8 lies within `\u8001`\n+    /// // &s[1 .. 8];\n+    ///\n+    /// // byte 100 is outside the string\n+    /// // &s[3 .. 100];\n+    /// ```\n+    #[cfg(not(stage0))]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    impl ops::Index<ops::Range<usize>> for str {\n+        type Output = str;\n+        #[inline]\n+        fn index(&self, index: ops::Range<usize>) -> &str {\n+            // is_char_boundary checks that the index is in [0, .len()]\n+            if index.start <= index.end &&\n+               self.is_char_boundary(index.start) &&\n+               self.is_char_boundary(index.end) {\n+                unsafe { self.slice_unchecked(index.start, index.end) }\n+            } else {\n+                super::slice_error_fail(self, index.start, index.end)\n+            }\n+        }\n+    }\n+\n     /// Returns a slice of the string from the beginning to byte\n     /// `end`.\n     ///\n@@ -1229,6 +1273,8 @@ mod traits {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl ops::Index<ops::RangeTo<usize>> for str {\n         type Output = str;\n+\n+        #[cfg(stage0)]\n         #[inline]\n         fn index(&self, index: &ops::RangeTo<usize>) -> &str {\n             // is_char_boundary checks that the index is in [0, .len()]\n@@ -1238,6 +1284,17 @@ mod traits {\n                 super::slice_error_fail(self, 0, index.end)\n             }\n         }\n+\n+        #[cfg(not(stage0))]\n+        #[inline]\n+        fn index(&self, index: ops::RangeTo<usize>) -> &str {\n+            // is_char_boundary checks that the index is in [0, .len()]\n+            if self.is_char_boundary(index.end) {\n+                unsafe { self.slice_unchecked(0, index.end) }\n+            } else {\n+                super::slice_error_fail(self, 0, index.end)\n+            }\n+        }\n     }\n \n     /// Returns a slice of the string from `begin` to its end.\n@@ -1249,6 +1306,8 @@ mod traits {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl ops::Index<ops::RangeFrom<usize>> for str {\n         type Output = str;\n+\n+        #[cfg(stage0)]\n         #[inline]\n         fn index(&self, index: &ops::RangeFrom<usize>) -> &str {\n             // is_char_boundary checks that the index is in [0, .len()]\n@@ -1258,15 +1317,34 @@ mod traits {\n                 super::slice_error_fail(self, index.start, self.len())\n             }\n         }\n+\n+        #[cfg(not(stage0))]\n+        #[inline]\n+        fn index(&self, index: ops::RangeFrom<usize>) -> &str {\n+            // is_char_boundary checks that the index is in [0, .len()]\n+            if self.is_char_boundary(index.start) {\n+                unsafe { self.slice_unchecked(index.start, self.len()) }\n+            } else {\n+                super::slice_error_fail(self, index.start, self.len())\n+            }\n+        }\n     }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl ops::Index<ops::RangeFull> for str {\n         type Output = str;\n+\n+        #[cfg(stage0)]\n         #[inline]\n         fn index(&self, _index: &ops::RangeFull) -> &str {\n             self\n         }\n+\n+        #[cfg(not(stage0))]\n+        #[inline]\n+        fn index(&self, _index: ops::RangeFull) -> &str {\n+            self\n+        }\n     }\n }\n "}, {"sha": "abbfc82319f5b30e24035442aedaaa532c0e80a4", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/b4d4daf007753dfb04d87b1ffe1c2ad2d8811d5a/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4d4daf007753dfb04d87b1ffe1c2ad2d8811d5a/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=b4d4daf007753dfb04d87b1ffe1c2ad2d8811d5a", "patch": "@@ -1218,6 +1218,7 @@ impl Json {\n     }\n }\n \n+#[cfg(stage0)]\n impl<'a> Index<&'a str>  for Json {\n     type Output = Json;\n \n@@ -1226,6 +1227,16 @@ impl<'a> Index<&'a str>  for Json {\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl<'a> Index<&'a str>  for Json {\n+    type Output = Json;\n+\n+    fn index(&self, idx: &'a str) -> &Json {\n+        self.find(idx).unwrap()\n+    }\n+}\n+\n+#[cfg(stage0)]\n impl Index<uint> for Json {\n     type Output = Json;\n \n@@ -1237,6 +1248,18 @@ impl Index<uint> for Json {\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl Index<uint> for Json {\n+    type Output = Json;\n+\n+    fn index<'a>(&'a self, idx: uint) -> &'a Json {\n+        match self {\n+            &Json::Array(ref v) => &v[idx],\n+            _ => panic!(\"can only index Json with uint if it is an array\")\n+        }\n+    }\n+}\n+\n /// The output of the streaming parser.\n #[derive(PartialEq, Clone, Debug)]\n pub enum JsonEvent {"}, {"sha": "86664d7eb0cf14ad9b81eaba3c3fe7a5be344bd0", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b4d4daf007753dfb04d87b1ffe1c2ad2d8811d5a/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4d4daf007753dfb04d87b1ffe1c2ad2d8811d5a/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=b4d4daf007753dfb04d87b1ffe1c2ad2d8811d5a", "patch": "@@ -1088,7 +1088,7 @@ impl<K, V, S> HashMap<K, V, S>\n     ///     Some(x) => *x = \"b\",\n     ///     None => (),\n     /// }\n-    /// assert_eq!(map[1], \"b\");\n+    /// assert_eq!(map[&1], \"b\");\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get_mut<Q: ?Sized>(&mut self, k: &Q) -> Option<&mut V>\n@@ -1111,7 +1111,7 @@ impl<K, V, S> HashMap<K, V, S>\n     ///\n     /// map.insert(37, \"b\");\n     /// assert_eq!(map.insert(37, \"c\"), Some(\"b\"));\n-    /// assert_eq!(map[37], \"c\");\n+    /// assert_eq!(map[&37], \"c\");\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn insert(&mut self, k: K, v: V) -> Option<V> {\n@@ -1244,6 +1244,7 @@ impl<K, V, S> Default for HashMap<K, V, S>\n     }\n }\n \n+#[cfg(stage0)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K, Q: ?Sized, V, S> Index<Q> for HashMap<K, V, S>\n     where K: Eq + Hash + Borrow<Q>,\n@@ -1258,6 +1259,21 @@ impl<K, Q: ?Sized, V, S> Index<Q> for HashMap<K, V, S>\n     }\n }\n \n+#[cfg(not(stage0))]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, K, Q: ?Sized, V, S> Index<&'a Q> for HashMap<K, V, S>\n+    where K: Eq + Hash + Borrow<Q>,\n+          Q: Eq + Hash,\n+          S: HashState,\n+{\n+    type Output = V;\n+\n+    #[inline]\n+    fn index(&self, index: &Q) -> &V {\n+        self.get(index).expect(\"no entry found for key\")\n+    }\n+}\n+\n /// HashMap iterator.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a, K: 'a, V: 'a> {\n@@ -2185,7 +2201,7 @@ mod test_map {\n         map.insert(2, 1);\n         map.insert(3, 4);\n \n-        assert_eq!(map[2], 1);\n+        assert_eq!(map[&2], 1);\n     }\n \n     #[test]\n@@ -2197,7 +2213,7 @@ mod test_map {\n         map.insert(2, 1);\n         map.insert(3, 4);\n \n-        map[4];\n+        map[&4];\n     }\n \n     #[test]"}, {"sha": "290c48b1310d58a870a98a30e1a7ae014df2d365", "filename": "src/libstd/ffi/os_str.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b4d4daf007753dfb04d87b1ffe1c2ad2d8811d5a/src%2Flibstd%2Fffi%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4d4daf007753dfb04d87b1ffe1c2ad2d8811d5a/src%2Flibstd%2Fffi%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fos_str.rs?ref=b4d4daf007753dfb04d87b1ffe1c2ad2d8811d5a", "patch": "@@ -103,6 +103,7 @@ impl OsString {\n     }\n }\n \n+#[cfg(stage0)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl ops::Index<ops::RangeFull> for OsString {\n     type Output = OsStr;\n@@ -113,6 +114,17 @@ impl ops::Index<ops::RangeFull> for OsString {\n     }\n }\n \n+#[cfg(not(stage0))]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl ops::Index<ops::RangeFull> for OsString {\n+    type Output = OsStr;\n+\n+    #[inline]\n+    fn index(&self, _index: ops::RangeFull) -> &OsStr {\n+        unsafe { mem::transmute(self.inner.as_slice()) }\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl ops::Deref for OsString {\n     type Target = OsStr;"}, {"sha": "9f3dae34c7a4bff3a127111110fa955d335748e3", "filename": "src/libstd/sys/common/wtf8.rs", "status": "modified", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/b4d4daf007753dfb04d87b1ffe1c2ad2d8811d5a/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4d4daf007753dfb04d87b1ffe1c2ad2d8811d5a/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs?ref=b4d4daf007753dfb04d87b1ffe1c2ad2d8811d5a", "patch": "@@ -634,6 +634,7 @@ impl Wtf8 {\n ///\n /// Panics when `begin` and `end` do not point to code point boundaries,\n /// or point beyond the end of the string.\n+#[cfg(stage0)]\n impl ops::Index<ops::Range<usize>> for Wtf8 {\n     type Output = Wtf8;\n \n@@ -650,12 +651,36 @@ impl ops::Index<ops::Range<usize>> for Wtf8 {\n     }\n }\n \n+/// Return a slice of the given string for the byte range [`begin`..`end`).\n+///\n+/// # Panics\n+///\n+/// Panics when `begin` and `end` do not point to code point boundaries,\n+/// or point beyond the end of the string.\n+#[cfg(not(stage0))]\n+impl ops::Index<ops::Range<usize>> for Wtf8 {\n+    type Output = Wtf8;\n+\n+    #[inline]\n+    fn index(&self, range: ops::Range<usize>) -> &Wtf8 {\n+        // is_code_point_boundary checks that the index is in [0, .len()]\n+        if range.start <= range.end &&\n+           is_code_point_boundary(self, range.start) &&\n+           is_code_point_boundary(self, range.end) {\n+            unsafe { slice_unchecked(self, range.start, range.end) }\n+        } else {\n+            slice_error_fail(self, range.start, range.end)\n+        }\n+    }\n+}\n+\n /// Return a slice of the given string from byte `begin` to its end.\n ///\n /// # Panics\n ///\n /// Panics when `begin` is not at a code point boundary,\n /// or is beyond the end of the string.\n+#[cfg(stage0)]\n impl ops::Index<ops::RangeFrom<usize>> for Wtf8 {\n     type Output = Wtf8;\n \n@@ -670,12 +695,34 @@ impl ops::Index<ops::RangeFrom<usize>> for Wtf8 {\n     }\n }\n \n+/// Return a slice of the given string from byte `begin` to its end.\n+///\n+/// # Panics\n+///\n+/// Panics when `begin` is not at a code point boundary,\n+/// or is beyond the end of the string.\n+#[cfg(not(stage0))]\n+impl ops::Index<ops::RangeFrom<usize>> for Wtf8 {\n+    type Output = Wtf8;\n+\n+    #[inline]\n+    fn index(&self, range: ops::RangeFrom<usize>) -> &Wtf8 {\n+        // is_code_point_boundary checks that the index is in [0, .len()]\n+        if is_code_point_boundary(self, range.start) {\n+            unsafe { slice_unchecked(self, range.start, self.len()) }\n+        } else {\n+            slice_error_fail(self, range.start, self.len())\n+        }\n+    }\n+}\n+\n /// Return a slice of the given string from its beginning to byte `end`.\n ///\n /// # Panics\n ///\n /// Panics when `end` is not at a code point boundary,\n /// or is beyond the end of the string.\n+#[cfg(stage0)]\n impl ops::Index<ops::RangeTo<usize>> for Wtf8 {\n     type Output = Wtf8;\n \n@@ -690,6 +737,28 @@ impl ops::Index<ops::RangeTo<usize>> for Wtf8 {\n     }\n }\n \n+/// Return a slice of the given string from its beginning to byte `end`.\n+///\n+/// # Panics\n+///\n+/// Panics when `end` is not at a code point boundary,\n+/// or is beyond the end of the string.\n+#[cfg(not(stage0))]\n+impl ops::Index<ops::RangeTo<usize>> for Wtf8 {\n+    type Output = Wtf8;\n+\n+    #[inline]\n+    fn index(&self, range: ops::RangeTo<usize>) -> &Wtf8 {\n+        // is_code_point_boundary checks that the index is in [0, .len()]\n+        if is_code_point_boundary(self, range.end) {\n+            unsafe { slice_unchecked(self, 0, range.end) }\n+        } else {\n+            slice_error_fail(self, 0, range.end)\n+        }\n+    }\n+}\n+\n+#[cfg(stage0)]\n impl ops::Index<ops::RangeFull> for Wtf8 {\n     type Output = Wtf8;\n \n@@ -699,6 +768,16 @@ impl ops::Index<ops::RangeFull> for Wtf8 {\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl ops::Index<ops::RangeFull> for Wtf8 {\n+    type Output = Wtf8;\n+\n+    #[inline]\n+    fn index(&self, _range: ops::RangeFull) -> &Wtf8 {\n+        self\n+    }\n+}\n+\n #[inline]\n fn decode_surrogate(second_byte: u8, third_byte: u8) -> u16 {\n     // The first byte is assumed to be 0xED"}]}