{"sha": "05accaa16787285560c6ddb1afe9dec45726a7f4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA1YWNjYWExNjc4NzI4NTU2MGM2ZGRiMWFmZTlkZWM0NTcyNmE3ZjQ=", "commit": {"author": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2012-08-17T01:06:30Z"}, "committer": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2012-08-21T01:51:39Z"}, "message": "implement arc::unwrap and add exclusive_unwrap tests", "tree": {"sha": "7b6f33670848e491f291a1b47193a6efb031f167", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7b6f33670848e491f291a1b47193a6efb031f167"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/05accaa16787285560c6ddb1afe9dec45726a7f4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/05accaa16787285560c6ddb1afe9dec45726a7f4", "html_url": "https://github.com/rust-lang/rust/commit/05accaa16787285560c6ddb1afe9dec45726a7f4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/05accaa16787285560c6ddb1afe9dec45726a7f4/comments", "author": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "842db0b64547ae4d2b88e3a7cf3563c0ef4de381", "url": "https://api.github.com/repos/rust-lang/rust/commits/842db0b64547ae4d2b88e3a7cf3563c0ef4de381", "html_url": "https://github.com/rust-lang/rust/commit/842db0b64547ae4d2b88e3a7cf3563c0ef4de381"}], "stats": {"total": 220, "additions": 200, "deletions": 20}, "files": [{"sha": "d2162428ca12f2bc7d60610846541352340c72e8", "filename": "src/libcore/unsafe.rs", "status": "modified", "additions": 200, "deletions": 20, "changes": 220, "blob_url": "https://github.com/rust-lang/rust/blob/05accaa16787285560c6ddb1afe9dec45726a7f4/src%2Flibcore%2Funsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05accaa16787285560c6ddb1afe9dec45726a7f4/src%2Flibcore%2Funsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funsafe.rs?ref=05accaa16787285560c6ddb1afe9dec45726a7f4", "patch": "@@ -5,6 +5,7 @@ export transmute_mut, transmute_immut, transmute_region, transmute_mut_region;\n \n export SharedMutableState, shared_mutable_state, clone_shared_mutable_state;\n export get_shared_mutable_state, get_shared_immutable_state;\n+export unwrap_shared_mutable_state;\n export Exclusive, exclusive;\n \n import task::atomically;\n@@ -69,24 +70,120 @@ unsafe fn transmute_mut_region<T>(+ptr: &a/mut T) -> &b/mut T {\n  * Shared state & exclusive ARC\n  ****************************************************************************/\n \n-type ArcData<T> = {\n-    mut count: libc::intptr_t,\n-    data: T\n-};\n+// An unwrapper uses this protocol to communicate with the \"other\" task that\n+// drops the last refcount on an arc. Unfortunately this can't be a proper\n+// pipe protocol because the unwrapper has to access both stages at once.\n+type UnwrapProto = ~mut option<(pipes::chan_one<()>, pipes::port_one<bool>)>;\n+\n+struct ArcData<T> {\n+    mut count:     libc::intptr_t;\n+    mut unwrapper: libc::uintptr_t; // either a UnwrapProto or 0\n+    // FIXME(#3224) should be able to make this non-option to save memory, and\n+    // in unwrap() use \"let ~ArcData { data: result, _ } = thing\" to unwrap it\n+    mut data:      option<T>;\n+}\n \n struct ArcDestruct<T> {\n-   let data: *libc::c_void;\n-   new(data: *libc::c_void) { self.data = data; }\n-   drop unsafe {\n-      let data: ~ArcData<T> = unsafe::reinterpret_cast(self.data);\n-      let new_count = rustrt::rust_atomic_decrement(&mut data.count);\n-      assert new_count >= 0;\n-      if new_count == 0 {\n-          // drop glue takes over.\n-      } else {\n-        unsafe::forget(data);\n-      }\n-   }\n+    mut data: *libc::c_void;\n+    new(data: *libc::c_void) { self.data = data; }\n+    drop unsafe {\n+        if self.data.is_null() {\n+            return; // Happens when destructing an unwrapper's handle.\n+        }\n+        do task::unkillable {\n+            let data: ~ArcData<T> = unsafe::reinterpret_cast(self.data);\n+            let new_count = rustrt::rust_atomic_decrement(&mut data.count);\n+            assert new_count >= 0;\n+            if new_count == 0 {\n+                // Were we really last, or should we hand off to an unwrapper?\n+                // It's safe to not xchg because the unwrapper will set the\n+                // unwrap lock *before* dropping his/her reference. In effect,\n+                // being here means we're the only *awake* task with the data.\n+                if data.unwrapper != 0 {\n+                    let p: UnwrapProto =\n+                        unsafe::reinterpret_cast(data.unwrapper);\n+                    let (message, response) = option::swap_unwrap(p);\n+                    // Send 'ready' and wait for a response.\n+                    pipes::send_one(message, ());\n+                    // Unkillable wait. Message guaranteed to come.\n+                    if pipes::recv_one(response) {\n+                        // Other task got the data.\n+                        unsafe::forget(data);\n+                    } else {\n+                        // Other task was killed. drop glue takes over.\n+                    }\n+                } else {\n+                    // drop glue takes over.\n+                }\n+            } else {\n+                unsafe::forget(data);\n+            }\n+        }\n+    }\n+}\n+\n+unsafe fn unwrap_shared_mutable_state<T: send>(+rc: SharedMutableState<T>)\n+        -> T {\n+    struct DeathThroes<T> {\n+        mut ptr:      option<~ArcData<T>>;\n+        mut response: option<pipes::chan_one<bool>>;\n+        drop unsafe {\n+            let response = option::swap_unwrap(&mut self.response);\n+            // In case we get killed early, we need to tell the person who\n+            // tried to wake us whether they should hand-off the data to us.\n+            if task::failing() {\n+                pipes::send_one(response, false);\n+                // Either this swap_unwrap or the one below (at \"Got here\")\n+                // ought to run.\n+                unsafe::forget(option::swap_unwrap(&mut self.ptr));\n+            } else {\n+                assert self.ptr.is_none();\n+                pipes::send_one(response, true);\n+            }\n+        }\n+    }\n+\n+    do task::unkillable {\n+        let ptr: ~ArcData<T> = unsafe::reinterpret_cast(rc.data);\n+        let (c1,p1) = pipes::oneshot(); // ()\n+        let (c2,p2) = pipes::oneshot(); // bool\n+        let server: UnwrapProto = ~mut some((c1,p2));\n+        let serverp: libc::uintptr_t = unsafe::transmute(server);\n+        // Try to put our server end in the unwrapper slot.\n+        if rustrt::rust_compare_and_swap_ptr(&mut ptr.unwrapper, 0, serverp) {\n+            // Got in. Step 0: Tell destructor not to run. We are now it.\n+            rc.data = ptr::null();\n+            // Step 1 - drop our own reference.\n+            let new_count = rustrt::rust_atomic_decrement(&mut ptr.count);\n+            assert new_count >= 0;\n+            if new_count == 0 {\n+                // We were the last owner. Can unwrap immediately.\n+                // Also we have to free the server endpoints.\n+                let _server: UnwrapProto = unsafe::transmute(serverp);\n+                option::swap_unwrap(&mut ptr.data)\n+                // drop glue takes over.\n+            } else {\n+                // The *next* person who sees the refcount hit 0 will wake us.\n+                let end_result =\n+                    DeathThroes { ptr: some(ptr), response: some(c2) };\n+                let mut p1 = some(p1); // argh\n+                do task::rekillable {\n+                    pipes::recv_one(option::swap_unwrap(&mut p1));\n+                }\n+                // Got here. Back in the 'unkillable' without getting killed.\n+                // Recover ownership of ptr, then take the data out.\n+                let ptr = option::swap_unwrap(&mut end_result.ptr);\n+                option::swap_unwrap(&mut ptr.data)\n+                // drop glue takes over.\n+            }\n+        } else {\n+            // Somebody else was trying to unwrap. Avoid guaranteed deadlock.\n+            unsafe::forget(ptr);\n+            // Also we have to free the (rejected) server endpoints.\n+            let _server: UnwrapProto = unsafe::transmute(serverp);\n+            fail ~\"Another task is already unwrapping this ARC!\";\n+        }\n+    }\n }\n \n /**\n@@ -98,7 +195,7 @@ struct ArcDestruct<T> {\n type SharedMutableState<T: send> = ArcDestruct<T>;\n \n unsafe fn shared_mutable_state<T: send>(+data: T) -> SharedMutableState<T> {\n-    let data = ~{mut count: 1, data: data};\n+    let data = ~ArcData { count: 1, unwrapper: 0, data: some(data) };\n     unsafe {\n         let ptr = unsafe::transmute(data);\n         ArcDestruct(ptr)\n@@ -112,9 +209,9 @@ unsafe fn get_shared_mutable_state<T: send>(rc: &SharedMutableState<T>)\n         let ptr: ~ArcData<T> = unsafe::reinterpret_cast((*rc).data);\n         assert ptr.count > 0;\n         // Cast us back into the correct region\n-        let r = unsafe::reinterpret_cast(&ptr.data);\n+        let r = unsafe::transmute_region(option::get_ref(&ptr.data));\n         unsafe::forget(ptr);\n-        return r;\n+        return unsafe::transmute_mut(r);\n     }\n }\n #[inline(always)]\n@@ -124,7 +221,7 @@ unsafe fn get_shared_immutable_state<T: send>(rc: &SharedMutableState<T>)\n         let ptr: ~ArcData<T> = unsafe::reinterpret_cast((*rc).data);\n         assert ptr.count > 0;\n         // Cast us back into the correct region\n-        let r = unsafe::reinterpret_cast(&ptr.data);\n+        let r = unsafe::transmute_region(option::get_ref(&ptr.data));\n         unsafe::forget(ptr);\n         return r;\n     }\n@@ -156,6 +253,11 @@ extern mod rustrt {\n     fn rust_atomic_decrement(p: &mut libc::intptr_t)\n         -> libc::intptr_t;\n \n+    #[rust_stack]\n+    fn rust_compare_and_swap_ptr(address: &mut libc::uintptr_t,\n+                                 oldval: libc::uintptr_t,\n+                                 newval: libc::uintptr_t) -> bool;\n+\n     fn rust_create_little_lock() -> rust_little_lock;\n     fn rust_destroy_little_lock(lock: rust_little_lock);\n     fn rust_lock_little_lock(lock: rust_little_lock);\n@@ -227,6 +329,15 @@ impl<T: send> Exclusive<T> {\n     }\n }\n \n+// FIXME(#2585) make this a by-move method on the exclusive\n+#[cfg(stage1)]\n+fn unwrap_exclusive<T: send>(+arc: Exclusive<T>) -> T {\n+    let Exclusive { x: x } = arc;\n+    let inner = unsafe { unwrap_shared_mutable_state(x) };\n+    let ExData { data: data, _ } = inner;\n+    data\n+}\n+\n /****************************************************************************\n  * Tests\n  ****************************************************************************/\n@@ -313,4 +424,73 @@ mod tests {\n             assert *one == 1;\n         }\n     }\n+\n+    #[test]\n+    #[cfg(stage1)]\n+    fn exclusive_unwrap_basic() {\n+        let x = exclusive(~~\"hello\");\n+        assert unwrap_exclusive(x) == ~~\"hello\";\n+    }\n+\n+    #[test]\n+    #[cfg(stage1)]\n+    fn exclusive_unwrap_contended() {\n+        let x = exclusive(~~\"hello\");\n+        let x2 = ~mut some(x.clone());\n+        do task::spawn {\n+            let x2 = option::swap_unwrap(x2);\n+            do x2.with |_hello| { }\n+            task::yield();\n+        }\n+        assert unwrap_exclusive(x) == ~~\"hello\";\n+\n+        // Now try the same thing, but with the child task blocking.\n+        let x = exclusive(~~\"hello\");\n+        let x2 = ~mut some(x.clone());\n+        let mut res = none;\n+        do task::task().future_result(|+r| res = some(r)).spawn {\n+            let x2 = option::swap_unwrap(x2);\n+            assert unwrap_exclusive(x2) == ~~\"hello\";\n+        }\n+        // Have to get rid of our reference before blocking.\n+        { let _x = move x; } // FIXME(#3161) util::ignore doesn't work here\n+        let res = option::swap_unwrap(&mut res);\n+        future::get(&res);\n+    }\n+\n+    #[test] #[should_fail] #[ignore(cfg(windows))]\n+    #[cfg(stage1)]\n+    fn exclusive_unwrap_conflict() {\n+        let x = exclusive(~~\"hello\");\n+        let x2 = ~mut some(x.clone());\n+        let mut res = none;\n+        do task::task().future_result(|+r| res = some(r)).spawn {\n+            let x2 = option::swap_unwrap(x2);\n+            assert unwrap_exclusive(x2) == ~~\"hello\";\n+        }\n+        assert unwrap_exclusive(x) == ~~\"hello\";\n+        let res = option::swap_unwrap(&mut res);\n+        future::get(&res);\n+    }\n+\n+    #[test] #[ignore(cfg(windows))]\n+    #[cfg(stage1)]\n+    fn exclusive_unwrap_deadlock() {\n+        // This is not guaranteed to get to the deadlock before being killed,\n+        // but it will show up sometimes, and if the deadlock were not there,\n+        // the test would nondeterministically fail.\n+        let result = do task::try {\n+            // a task that has two references to the same exclusive will\n+            // deadlock when it unwraps. nothing to be done about that.\n+            let x = exclusive(~~\"hello\");\n+            let x2 = x.clone();\n+            do task::spawn {\n+                for 10.times { task::yield(); } // try to let the unwrapper go\n+                fail; // punt it awake from its deadlock\n+            }\n+            let _z = unwrap_exclusive(x);\n+            do x2.with |_hello| { }\n+        };\n+        assert result.is_err();\n+    }\n }"}]}