{"sha": "7b0735a832dd49cb482084590eb0f2577955c079", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdiMDczNWE4MzJkZDQ5Y2I0ODIwODQ1OTBlYjBmMjU3Nzk1NWMwNzk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-10-26T00:04:29Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-10-26T00:04:29Z"}, "message": "Auto merge of #54145 - nrc:save-path-segments, r=petrochenkov\n\nKeep resolved defs in path prefixes and emit them in save-analysis\n\nCloses https://github.com/nrc/rls-analysis/issues/109\n\nr? @eddyb or @petrochenkov", "tree": {"sha": "4643cd80f8d6e5f3ace9574a30158020dba1c830", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4643cd80f8d6e5f3ace9574a30158020dba1c830"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7b0735a832dd49cb482084590eb0f2577955c079", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7b0735a832dd49cb482084590eb0f2577955c079", "html_url": "https://github.com/rust-lang/rust/commit/7b0735a832dd49cb482084590eb0f2577955c079", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7b0735a832dd49cb482084590eb0f2577955c079/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4bd4e4130ed531a644263db26bf8461704215c77", "url": "https://api.github.com/repos/rust-lang/rust/commits/4bd4e4130ed531a644263db26bf8461704215c77", "html_url": "https://github.com/rust-lang/rust/commit/4bd4e4130ed531a644263db26bf8461704215c77"}, {"sha": "6dd5bb18d7a832add3f0cadb70897da6fd44892b", "url": "https://api.github.com/repos/rust-lang/rust/commits/6dd5bb18d7a832add3f0cadb70897da6fd44892b", "html_url": "https://github.com/rust-lang/rust/commit/6dd5bb18d7a832add3f0cadb70897da6fd44892b"}], "stats": {"total": 1558, "additions": 725, "deletions": 833}, "files": [{"sha": "dcc0f8545e5d77f560094aea0dbab7a5ee4b7985", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7b0735a832dd49cb482084590eb0f2577955c079/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b0735a832dd49cb482084590eb0f2577955c079/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=7b0735a832dd49cb482084590eb0f2577955c079", "patch": "@@ -298,6 +298,9 @@ pub trait Visitor<'v> : Sized {\n     fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v FnDecl, b: BodyId, s: Span, id: NodeId) {\n         walk_fn(self, fk, fd, b, s, id)\n     }\n+    fn visit_use(&mut self, path: &'v Path, id: NodeId, hir_id: HirId) {\n+        walk_use(self, path, id, hir_id)\n+    }\n     fn visit_trait_item(&mut self, ti: &'v TraitItem) {\n         walk_trait_item(self, ti)\n     }\n@@ -471,8 +474,7 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n             }\n         }\n         ItemKind::Use(ref path, _) => {\n-            visitor.visit_id(item.id);\n-            visitor.visit_path(path, item.hir_id);\n+            visitor.visit_use(path, item.id, item.hir_id);\n         }\n         ItemKind::Static(ref typ, _, body) |\n         ItemKind::Const(ref typ, body) => {\n@@ -554,6 +556,14 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n     walk_list!(visitor, visit_attribute, &item.attrs);\n }\n \n+pub fn walk_use<'v, V: Visitor<'v>>(visitor: &mut V,\n+                                    path: &'v Path,\n+                                    item_id: NodeId,\n+                                    hir_id: HirId) {\n+    visitor.visit_id(item_id);\n+    visitor.visit_path(path, hir_id);\n+}\n+\n pub fn walk_enum_def<'v, V: Visitor<'v>>(visitor: &mut V,\n                                          enum_definition: &'v EnumDef,\n                                          generics: &'v Generics,\n@@ -652,6 +662,9 @@ pub fn walk_path_segment<'v, V: Visitor<'v>>(visitor: &mut V,\n                                              path_span: Span,\n                                              segment: &'v PathSegment) {\n     visitor.visit_ident(segment.ident);\n+    if let Some(id) = segment.id {\n+        visitor.visit_id(id);\n+    }\n     if let Some(ref args) = segment.args {\n         visitor.visit_generic_args(path_span, args);\n     }"}, {"sha": "6370a52018338842ec60d80a8414032c4745fcc2", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 89, "deletions": 33, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/7b0735a832dd49cb482084590eb0f2577955c079/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b0735a832dd49cb482084590eb0f2577955c079/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=7b0735a832dd49cb482084590eb0f2577955c079", "patch": "@@ -143,8 +143,12 @@ pub struct LoweringContext<'a> {\n }\n \n pub trait Resolver {\n-    /// Resolve a hir path generated by the lowerer when expanding `for`, `if let`, etc.\n-    fn resolve_hir_path(&mut self, path: &mut hir::Path, is_value: bool);\n+    /// Resolve a path generated by the lowerer when expanding `for`, `if let`, etc.\n+    fn resolve_hir_path(\n+        &mut self,\n+        path: &ast::Path,\n+        is_value: bool,\n+    ) -> hir::Path;\n \n     /// Obtain the resolution for a node id\n     fn get_resolution(&mut self, id: NodeId) -> Option<PathResolution>;\n@@ -163,7 +167,6 @@ pub trait Resolver {\n         span: Span,\n         crate_root: Option<&str>,\n         components: &[&str],\n-        params: Option<P<hir::GenericArgs>>,\n         is_value: bool,\n     ) -> hir::Path;\n }\n@@ -1064,6 +1067,9 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn lower_attr(&mut self, attr: &Attribute) -> Attribute {\n+        // Note that we explicitly do not walk the path. Since we don't really\n+        // lower attributes (we use the AST version) there is nowhere to keep\n+        // the HirIds. We don't actually need HIR version of attributes anyway.\n         Attribute {\n             id: attr.id,\n             style: attr.style,\n@@ -1677,6 +1683,7 @@ impl<'a> LoweringContext<'a> {\n                         num_lifetimes,\n                         parenthesized_generic_args,\n                         itctx.reborrow(),\n+                        None,\n                     )\n                 })\n                 .collect(),\n@@ -1720,6 +1727,7 @@ impl<'a> LoweringContext<'a> {\n                 0,\n                 ParenthesizedGenericArgs::Warn,\n                 itctx.reborrow(),\n+                None,\n             ));\n             let qpath = hir::QPath::TypeRelative(ty, segment);\n \n@@ -1748,6 +1756,7 @@ impl<'a> LoweringContext<'a> {\n         p: &Path,\n         ident: Option<Ident>,\n         param_mode: ParamMode,\n+        explicit_owner: Option<NodeId>,\n     ) -> hir::Path {\n         hir::Path {\n             def,\n@@ -1761,6 +1770,7 @@ impl<'a> LoweringContext<'a> {\n                         0,\n                         ParenthesizedGenericArgs::Err,\n                         ImplTraitContext::disallowed(),\n+                        explicit_owner,\n                     )\n                 })\n                 .chain(ident.map(|ident| hir::PathSegment::from_ident(ident)))\n@@ -1771,7 +1781,7 @@ impl<'a> LoweringContext<'a> {\n \n     fn lower_path(&mut self, id: NodeId, p: &Path, param_mode: ParamMode) -> hir::Path {\n         let def = self.expect_full_def(id);\n-        self.lower_path_extra(def, p, None, param_mode)\n+        self.lower_path_extra(def, p, None, param_mode, None)\n     }\n \n     fn lower_path_segment(\n@@ -1782,6 +1792,7 @@ impl<'a> LoweringContext<'a> {\n         expected_lifetimes: usize,\n         parenthesized_generic_args: ParenthesizedGenericArgs,\n         itctx: ImplTraitContext<'_>,\n+        explicit_owner: Option<NodeId>,\n     ) -> hir::PathSegment {\n         let (mut generic_args, infer_types) = if let Some(ref generic_args) = segment.args {\n             let msg = \"parenthesized parameters may only be used with a trait\";\n@@ -1852,8 +1863,17 @@ impl<'a> LoweringContext<'a> {\n             }\n         }\n \n+        let def = self.expect_full_def(segment.id);\n+        let id = if let Some(owner) = explicit_owner {\n+            self.lower_node_id_with_owner(segment.id, owner)\n+        } else {\n+            self.lower_node_id(segment.id)\n+        };\n+\n         hir::PathSegment::new(\n             segment.ident,\n+            Some(id.node_id),\n+            Some(def),\n             generic_args,\n             infer_types,\n         )\n@@ -2936,19 +2956,20 @@ impl<'a> LoweringContext<'a> {\n         attrs: &hir::HirVec<Attribute>,\n     ) -> hir::ItemKind {\n         let path = &tree.prefix;\n+        let segments = prefix\n+            .segments\n+            .iter()\n+            .chain(path.segments.iter())\n+            .cloned()\n+            .collect();\n \n         match tree.kind {\n             UseTreeKind::Simple(rename, id1, id2) => {\n                 *name = tree.ident().name;\n \n                 // First apply the prefix to the path\n                 let mut path = Path {\n-                    segments: prefix\n-                        .segments\n-                        .iter()\n-                        .chain(path.segments.iter())\n-                        .cloned()\n-                        .collect(),\n+                    segments,\n                     span: path.span,\n                 };\n \n@@ -2968,9 +2989,18 @@ impl<'a> LoweringContext<'a> {\n                 // for later\n                 let ret_def = defs.next().unwrap_or(Def::Err);\n \n+                // Here, we are looping over namespaces, if they exist for the definition\n+                // being imported. We only handle type and value namespaces because we\n+                // won't be dealing with macros in the rest of the compiler.\n+                // Essentially a single `use` which imports two names is desugared into\n+                // two imports.\n                 for (def, &new_node_id) in defs.zip([id1, id2].iter()) {\n                     let vis = vis.clone();\n                     let name = name.clone();\n+                    let mut path = path.clone();\n+                    for seg in &mut path.segments {\n+                        seg.id = self.sess.next_node_id();\n+                    }\n                     let span = path.span;\n                     self.resolver.definitions().create_def_with_parent(\n                         parent_def_index,\n@@ -2983,7 +3013,8 @@ impl<'a> LoweringContext<'a> {\n \n                     self.with_hir_id_owner(new_node_id, |this| {\n                         let new_id = this.lower_node_id(new_node_id);\n-                        let path = this.lower_path_extra(def, &path, None, ParamMode::Explicit);\n+                        let path =\n+                            this.lower_path_extra(def, &path, None, ParamMode::Explicit, None);\n                         let item = hir::ItemKind::Use(P(path), hir::UseKind::Single);\n                         let vis_kind = match vis.node {\n                             hir::VisibilityKind::Public => hir::VisibilityKind::Public,\n@@ -2993,7 +3024,6 @@ impl<'a> LoweringContext<'a> {\n                                 let id = this.next_id();\n                                 hir::VisibilityKind::Restricted {\n                                     path: path.clone(),\n-                                    // We are allocating a new NodeId here\n                                     id: id.node_id,\n                                     hir_id: id.hir_id,\n                                 }\n@@ -3016,50 +3046,60 @@ impl<'a> LoweringContext<'a> {\n                     });\n                 }\n \n-                let path = P(self.lower_path_extra(ret_def, &path, None, ParamMode::Explicit));\n+                let path =\n+                    P(self.lower_path_extra(ret_def, &path, None, ParamMode::Explicit, None));\n                 hir::ItemKind::Use(path, hir::UseKind::Single)\n             }\n             UseTreeKind::Glob => {\n                 let path = P(self.lower_path(\n                     id,\n                     &Path {\n-                        segments: prefix\n-                            .segments\n-                            .iter()\n-                            .chain(path.segments.iter())\n-                            .cloned()\n-                            .collect(),\n+                        segments,\n                         span: path.span,\n                     },\n                     ParamMode::Explicit,\n                 ));\n                 hir::ItemKind::Use(path, hir::UseKind::Glob)\n             }\n             UseTreeKind::Nested(ref trees) => {\n+                // Nested imports are desugared into simple imports.\n+\n                 let prefix = Path {\n-                    segments: prefix\n-                        .segments\n-                        .iter()\n-                        .chain(path.segments.iter())\n-                        .cloned()\n-                        .collect(),\n+                    segments,\n                     span: prefix.span.to(path.span),\n                 };\n \n-                // Add all the nested PathListItems in the HIR\n+                // Add all the nested PathListItems to the HIR.\n                 for &(ref use_tree, id) in trees {\n                     self.allocate_hir_id_counter(id, &use_tree);\n+\n                     let LoweredNodeId {\n                         node_id: new_id,\n                         hir_id: new_hir_id,\n                     } = self.lower_node_id(id);\n \n                     let mut vis = vis.clone();\n                     let mut name = name.clone();\n-                    let item =\n-                        self.lower_use_tree(use_tree, &prefix, new_id, &mut vis, &mut name, &attrs);\n+                    let mut prefix = prefix.clone();\n \n+                    // Give the segments new ids since they are being cloned.\n+                    for seg in &mut prefix.segments {\n+                        seg.id = self.sess.next_node_id();\n+                    }\n+\n+                    // Each `use` import is an item and thus are owners of the\n+                    // names in the path. Up to this point the nested import is\n+                    // the current owner, since we want each desugared import to\n+                    // own its own names, we have to adjust the owner before\n+                    // lowering the rest of the import.\n                     self.with_hir_id_owner(new_id, |this| {\n+                        let item = this.lower_use_tree(use_tree,\n+                                                       &prefix,\n+                                                       new_id,\n+                                                       &mut vis,\n+                                                       &mut name,\n+                                                       attrs);\n+\n                         let vis_kind = match vis.node {\n                             hir::VisibilityKind::Public => hir::VisibilityKind::Public,\n                             hir::VisibilityKind::Crate(sugar) => hir::VisibilityKind::Crate(sugar),\n@@ -3068,7 +3108,6 @@ impl<'a> LoweringContext<'a> {\n                                 let id = this.next_id();\n                                 hir::VisibilityKind::Restricted {\n                                     path: path.clone(),\n-                                    // We are allocating a new NodeId here\n                                     id: id.node_id,\n                                     hir_id: id.hir_id,\n                                 }\n@@ -3081,7 +3120,7 @@ impl<'a> LoweringContext<'a> {\n                             hir::Item {\n                                 id: new_id,\n                                 hir_id: new_hir_id,\n-                                name: name,\n+                                name,\n                                 attrs: attrs.clone(),\n                                 node: item,\n                                 vis,\n@@ -3645,6 +3684,7 @@ impl<'a> LoweringContext<'a> {\n                     0,\n                     ParenthesizedGenericArgs::Err,\n                     ImplTraitContext::disallowed(),\n+                    None,\n                 );\n                 let args = args.iter().map(|x| self.lower_expr(x)).collect();\n                 hir::ExprKind::MethodCall(hir_seg, seg.ident.span, args)\n@@ -4498,8 +4538,15 @@ impl<'a> LoweringContext<'a> {\n                 } else {\n                     self.lower_node_id(id)\n                 };\n+                let def = self.expect_full_def(id);\n                 hir::VisibilityKind::Restricted {\n-                    path: P(self.lower_path(id, path, ParamMode::Explicit)),\n+                    path: P(self.lower_path_extra(\n+                        def,\n+                        path,\n+                        None,\n+                        ParamMode::Explicit,\n+                        explicit_owner,\n+                    )),\n                     id: lowered_id.node_id,\n                     hir_id: lowered_id.hir_id,\n                 }\n@@ -4806,8 +4853,17 @@ impl<'a> LoweringContext<'a> {\n         params: Option<P<hir::GenericArgs>>,\n         is_value: bool\n     ) -> hir::Path {\n-        self.resolver\n-            .resolve_str_path(span, self.crate_root, components, params, is_value)\n+        let mut path = self.resolver\n+            .resolve_str_path(span, self.crate_root, components, is_value);\n+        path.segments.last_mut().unwrap().args = params;\n+\n+\n+        for seg in path.segments.iter_mut() {\n+            if let Some(id) = seg.id {\n+                seg.id = Some(self.lower_node_id(id).node_id);\n+            }\n+        }\n+        path\n     }\n \n     fn ty_path(&mut self, id: LoweredNodeId, span: Span, qpath: hir::QPath) -> hir::Ty {"}, {"sha": "8c701d9e4188fafa44fcebf7fdd4d536f3fb9087", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7b0735a832dd49cb482084590eb0f2577955c079/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b0735a832dd49cb482084590eb0f2577955c079/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=7b0735a832dd49cb482084590eb0f2577955c079", "patch": "@@ -210,17 +210,22 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n                     None => format!(\"{:?}\", node)\n                 };\n \n-                if hir_id == ::hir::DUMMY_HIR_ID {\n-                    debug!(\"Maybe you forgot to lower the node id {:?}?\", id);\n-                }\n+                let forgot_str = if hir_id == ::hir::DUMMY_HIR_ID {\n+                    format!(\"\\nMaybe you forgot to lower the node id {:?}?\", id)\n+                } else {\n+                    String::new()\n+                };\n \n                 bug!(\"inconsistent DepNode for `{}`: \\\n-                      current_dep_node_owner={}, hir_id.owner={}\",\n+                      current_dep_node_owner={} ({:?}), hir_id.owner={} ({:?}) {}\",\n                     node_str,\n                     self.definitions\n                         .def_path(self.current_dep_node_owner)\n                         .to_string_no_crate(),\n-                    self.definitions.def_path(hir_id.owner).to_string_no_crate())\n+                    self.current_dep_node_owner,\n+                    self.definitions.def_path(hir_id.owner).to_string_no_crate(),\n+                    hir_id.owner,\n+                    forgot_str)\n             }\n         }\n \n@@ -392,6 +397,13 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         });\n     }\n \n+    fn visit_path_segment(&mut self, path_span: Span, path_segment: &'hir PathSegment) {\n+        if let Some(id) = path_segment.id {\n+            self.insert(id, Node::PathSegment(path_segment));\n+        }\n+        intravisit::walk_path_segment(self, path_span, path_segment);\n+    }\n+\n     fn visit_ty(&mut self, ty: &'hir Ty) {\n         self.insert(ty.id, Node::Ty(ty));\n "}, {"sha": "896a6163eba64466d44f30d34418c3e0da84bbde", "filename": "src/librustc/hir/map/hir_id_validator.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7b0735a832dd49cb482084590eb0f2577955c079/src%2Flibrustc%2Fhir%2Fmap%2Fhir_id_validator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b0735a832dd49cb482084590eb0f2577955c079/src%2Flibrustc%2Fhir%2Fmap%2Fhir_id_validator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fhir_id_validator.rs?ref=7b0735a832dd49cb482084590eb0f2577955c079", "patch": "@@ -88,7 +88,7 @@ impl<'a, 'hir: 'a> HirIdValidator<'a, 'hir> {\n         walk(self);\n \n         if owner_def_index == CRATE_DEF_INDEX {\n-            return\n+            return;\n         }\n \n         // There's always at least one entry for the owning item itself\n@@ -129,13 +129,16 @@ impl<'a, 'hir: 'a> HirIdValidator<'a, 'hir> {\n                                            local_id,\n                                            self.hir_map.node_to_string(node_id)));\n             }\n-\n             self.errors.push(format!(\n                 \"ItemLocalIds not assigned densely in {}. \\\n-                Max ItemLocalId = {}, missing IDs = {:?}\",\n+                Max ItemLocalId = {}, missing IDs = {:?}; seens IDs = {:?}\",\n                 self.hir_map.def_path(DefId::local(owner_def_index)).to_string_no_crate(),\n                 max,\n-                missing_items));\n+                missing_items,\n+                self.hir_ids_seen\n+                    .values()\n+                    .map(|n| format!(\"({:?} {})\", n, self.hir_map.node_to_string(*n)))\n+                    .collect::<Vec<_>>()));\n         }\n     }\n }\n@@ -155,6 +158,7 @@ impl<'a, 'hir: 'a> intravisit::Visitor<'hir> for HirIdValidator<'a, 'hir> {\n             self.errors.push(format!(\"HirIdValidator: No HirId assigned for NodeId {}: {:?}\",\n                                      node_id,\n                                      self.hir_map.node_to_string(node_id)));\n+            return;\n         }\n \n         if owner != stable_id.owner {"}, {"sha": "7a20146130d9480e640e0d1ba328bd980eed2b38", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7b0735a832dd49cb482084590eb0f2577955c079/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b0735a832dd49cb482084590eb0f2577955c079/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=7b0735a832dd49cb482084590eb0f2577955c079", "patch": "@@ -204,7 +204,7 @@ impl<'hir> Map<'hir> {\n         if let Some(entry) = self.map[id.as_usize()] {\n             self.dep_graph.read_index(entry.dep_node);\n         } else {\n-            bug!(\"called `HirMap::read()` with invalid `NodeId`\")\n+            bug!(\"called `HirMap::read()` with invalid `NodeId`: {:?}\", id)\n         }\n     }\n \n@@ -344,6 +344,7 @@ impl<'hir> Map<'hir> {\n             Node::AnonConst(_) |\n             Node::Expr(_) |\n             Node::Stmt(_) |\n+            Node::PathSegment(_) |\n             Node::Ty(_) |\n             Node::TraitRef(_) |\n             Node::Pat(_) |\n@@ -884,6 +885,7 @@ impl<'hir> Map<'hir> {\n             Some(Node::AnonConst(constant)) => self.body(constant.body).value.span,\n             Some(Node::Expr(expr)) => expr.span,\n             Some(Node::Stmt(stmt)) => stmt.span,\n+            Some(Node::PathSegment(seg)) => seg.ident.span,\n             Some(Node::Ty(ty)) => ty.span,\n             Some(Node::TraitRef(tr)) => tr.path.span,\n             Some(Node::Binding(pat)) => pat.span,\n@@ -1098,6 +1100,7 @@ impl<'a> print::State<'a> {\n             Node::AnonConst(a)    => self.print_anon_const(&a),\n             Node::Expr(a)         => self.print_expr(&a),\n             Node::Stmt(a)         => self.print_stmt(&a),\n+            Node::PathSegment(a)  => self.print_path_segment(&a),\n             Node::Ty(a)           => self.print_type(&a),\n             Node::TraitRef(a)     => self.print_trait_ref(&a),\n             Node::Binding(a)      |\n@@ -1215,6 +1218,9 @@ fn node_id_to_string(map: &Map<'_>, id: NodeId, include_id: bool) -> String {\n         Some(Node::Stmt(_)) => {\n             format!(\"stmt {}{}\", map.node_to_pretty_string(id), id_str)\n         }\n+        Some(Node::PathSegment(_)) => {\n+            format!(\"path segment {}{}\", map.node_to_pretty_string(id), id_str)\n+        }\n         Some(Node::Ty(_)) => {\n             format!(\"type {}{}\", map.node_to_pretty_string(id), id_str)\n         }"}, {"sha": "a2095ff40c0402da70feed0d958ee80d406e2d1d", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7b0735a832dd49cb482084590eb0f2577955c079/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b0735a832dd49cb482084590eb0f2577955c079/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=7b0735a832dd49cb482084590eb0f2577955c079", "patch": "@@ -347,6 +347,13 @@ impl fmt::Display for Path {\n pub struct PathSegment {\n     /// The identifier portion of this path segment.\n     pub ident: Ident,\n+    // `id` and `def` are optional. We currently only use these in save-analysis,\n+    // any path segments without these will not have save-analysis info and\n+    // therefore will not have 'jump to def' in IDEs, but otherwise will not be\n+    // affected. (In general, we don't bother to get the defs for synthesized\n+    // segments, only for segments which have come from the AST).\n+    pub id: Option<NodeId>,\n+    pub def: Option<Def>,\n \n     /// Type/lifetime parameters attached to this path. They come in\n     /// two flavors: `Path<A,B,C>` and `Path(A,B) -> C`. Note that\n@@ -367,14 +374,24 @@ impl PathSegment {\n     pub fn from_ident(ident: Ident) -> PathSegment {\n         PathSegment {\n             ident,\n+            id: None,\n+            def: None,\n             infer_types: true,\n             args: None,\n         }\n     }\n \n-    pub fn new(ident: Ident, args: GenericArgs, infer_types: bool) -> Self {\n+    pub fn new(\n+        ident: Ident,\n+        id: Option<NodeId>,\n+        def: Option<Def>,\n+        args: GenericArgs,\n+        infer_types: bool,\n+    ) -> Self {\n         PathSegment {\n             ident,\n+            id,\n+            def,\n             infer_types,\n             args: if args.is_empty() {\n                 None\n@@ -2511,6 +2528,7 @@ pub enum Node<'hir> {\n     AnonConst(&'hir AnonConst),\n     Expr(&'hir Expr),\n     Stmt(&'hir Stmt),\n+    PathSegment(&'hir PathSegment),\n     Ty(&'hir Ty),\n     TraitRef(&'hir TraitRef),\n     Binding(&'hir Pat),"}, {"sha": "e69d32ad1deafbddc9d8420276aeb19dddaf304f", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7b0735a832dd49cb482084590eb0f2577955c079/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b0735a832dd49cb482084590eb0f2577955c079/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=7b0735a832dd49cb482084590eb0f2577955c079", "patch": "@@ -1633,6 +1633,17 @@ impl<'a> State<'a> {\n         Ok(())\n     }\n \n+    pub fn print_path_segment(&mut self, segment: &hir::PathSegment) -> io::Result<()> {\n+        if segment.ident.name != keywords::CrateRoot.name() &&\n+           segment.ident.name != keywords::DollarCrate.name() {\n+           self.print_ident(segment.ident)?;\n+           segment.with_generic_args(|generic_args| {\n+               self.print_generic_args(generic_args, segment.infer_types, false)\n+           })?;\n+        }\n+        Ok(())\n+    }\n+\n     pub fn print_qpath(&mut self,\n                        qpath: &hir::QPath,\n                        colons_before_params: bool)"}, {"sha": "b220634d0d90316897725879b39d2189c6a1ae74", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b0735a832dd49cb482084590eb0f2577955c079/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b0735a832dd49cb482084590eb0f2577955c079/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=7b0735a832dd49cb482084590eb0f2577955c079", "patch": "@@ -174,6 +174,8 @@ impl_stable_hash_for!(struct hir::Path {\n \n impl_stable_hash_for!(struct hir::PathSegment {\n     ident -> (ident.name),\n+    id,\n+    def,\n     infer_types,\n     args\n });"}, {"sha": "b7ed3ef59b4c891349c2695af1e7d8bab6108bf0", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 32, "deletions": 26, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/7b0735a832dd49cb482084590eb0f2577955c079/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b0735a832dd49cb482084590eb0f2577955c079/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=7b0735a832dd49cb482084590eb0f2577955c079", "patch": "@@ -16,7 +16,7 @@\n use macros::{InvocationData, ParentScope, LegacyScope};\n use resolve_imports::ImportDirective;\n use resolve_imports::ImportDirectiveSubclass::{self, GlobImport, SingleImport};\n-use {Module, ModuleData, ModuleKind, NameBinding, NameBindingKind, ToNameBinding};\n+use {Module, ModuleData, ModuleKind, NameBinding, NameBindingKind, Segment, ToNameBinding};\n use {ModuleOrUniformRoot, PerNS, Resolver, ResolverArenas, ExternPreludeEntry};\n use Namespace::{self, TypeNS, ValueNS, MacroNS};\n use {resolve_error, resolve_struct_error, ResolutionError};\n@@ -122,7 +122,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         use_tree: &ast::UseTree,\n         id: NodeId,\n         vis: ty::Visibility,\n-        parent_prefix: &[Ident],\n+        parent_prefix: &[Segment],\n         mut uniform_paths_canary_emitted: bool,\n         nested: bool,\n         item: &Item,\n@@ -139,10 +139,10 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n             self.session.features_untracked().uniform_paths;\n \n         let prefix_iter = || parent_prefix.iter().cloned()\n-            .chain(use_tree.prefix.segments.iter().map(|seg| seg.ident));\n+            .chain(use_tree.prefix.segments.iter().map(|seg| seg.into()));\n         let prefix_start = prefix_iter().next();\n-        let starts_with_non_keyword = prefix_start.map_or(false, |ident| {\n-            !ident.is_path_segment_keyword()\n+        let starts_with_non_keyword = prefix_start.map_or(false, |seg| {\n+            !seg.ident.is_path_segment_keyword()\n         });\n \n         // Imports are resolved as global by default, prepend `CrateRoot`,\n@@ -156,7 +156,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n             };\n         let root = if inject_crate_root {\n             let span = use_tree.prefix.span.shrink_to_lo();\n-            Some(Ident::new(keywords::CrateRoot.name(), span))\n+            Some(Segment::from_ident(Ident::new(keywords::CrateRoot.name(), span)))\n         } else {\n             None\n         };\n@@ -202,13 +202,13 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n             let source = prefix_start.unwrap();\n \n             // Helper closure to emit a canary with the given base path.\n-            let emit = |this: &mut Self, base: Option<Ident>| {\n+            let emit = |this: &mut Self, base: Option<Segment>| {\n                 let subclass = SingleImport {\n                     target: Ident {\n                         name: keywords::Underscore.name().gensymed(),\n-                        span: source.span,\n+                        span: source.ident.span,\n                     },\n-                    source,\n+                    source: source.ident,\n                     result: PerNS {\n                         type_ns: Cell::new(Err(Undetermined)),\n                         value_ns: Cell::new(Err(Undetermined)),\n@@ -219,7 +219,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                 this.add_import_directive(\n                     base.into_iter().collect(),\n                     subclass.clone(),\n-                    source.span,\n+                    source.ident.span,\n                     id,\n                     root_use_tree.span,\n                     root_id,\n@@ -230,15 +230,18 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n             };\n \n             // A single simple `self::x` canary.\n-            emit(self, Some(Ident {\n-                name: keywords::SelfValue.name(),\n-                span: source.span,\n+            emit(self, Some(Segment {\n+                ident: Ident {\n+                    name: keywords::SelfValue.name(),\n+                    span: source.ident.span,\n+                },\n+                id: source.id\n             }));\n \n             // One special unprefixed canary per block scope around\n             // the import, to detect items unreachable by `self::x`.\n             let orig_current_module = self.current_module;\n-            let mut span = source.span.modern();\n+            let mut span = source.ident.span.modern();\n             loop {\n                 match self.current_module.kind {\n                     ModuleKind::Block(..) => emit(self, None),\n@@ -265,11 +268,11 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n \n                 if nested {\n                     // Correctly handle `self`\n-                    if source.name == keywords::SelfValue.name() {\n+                    if source.ident.name == keywords::SelfValue.name() {\n                         type_ns_only = true;\n \n-                        let empty_prefix = module_path.last().map_or(true, |ident| {\n-                            ident.name == keywords::CrateRoot.name()\n+                        let empty_prefix = module_path.last().map_or(true, |seg| {\n+                            seg.ident.name == keywords::CrateRoot.name()\n                         });\n                         if empty_prefix {\n                             resolve_error(\n@@ -284,20 +287,20 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                         // Replace `use foo::self;` with `use foo;`\n                         source = module_path.pop().unwrap();\n                         if rename.is_none() {\n-                            ident = source;\n+                            ident = source.ident;\n                         }\n                     }\n                 } else {\n                     // Disallow `self`\n-                    if source.name == keywords::SelfValue.name() {\n+                    if source.ident.name == keywords::SelfValue.name() {\n                         resolve_error(self,\n                                       use_tree.span,\n                                       ResolutionError::SelfImportsOnlyAllowedWithin);\n                     }\n \n                     // Disallow `use $crate;`\n-                    if source.name == keywords::DollarCrate.name() && module_path.is_empty() {\n-                        let crate_root = self.resolve_crate_root(source);\n+                    if source.ident.name == keywords::DollarCrate.name() && module_path.is_empty() {\n+                        let crate_root = self.resolve_crate_root(source.ident);\n                         let crate_name = match crate_root.kind {\n                             ModuleKind::Def(_, name) => name,\n                             ModuleKind::Block(..) => unreachable!(),\n@@ -307,11 +310,14 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                         // while the current crate doesn't have a valid `crate_name`.\n                         if crate_name != keywords::Invalid.name() {\n                             // `crate_name` should not be interpreted as relative.\n-                            module_path.push(Ident {\n-                                name: keywords::CrateRoot.name(),\n-                                span: source.span,\n+                            module_path.push(Segment {\n+                                ident: Ident {\n+                                    name: keywords::CrateRoot.name(),\n+                                    span: source.ident.span,\n+                                },\n+                                id: Some(self.session.next_node_id()),\n                             });\n-                            source.name = crate_name;\n+                            source.ident.name = crate_name;\n                         }\n                         if rename.is_none() {\n                             ident.name = crate_name;\n@@ -332,7 +338,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n \n                 let subclass = SingleImport {\n                     target: ident,\n-                    source,\n+                    source: source.ident,\n                     result: PerNS {\n                         type_ns: Cell::new(Err(Undetermined)),\n                         value_ns: Cell::new(Err(Undetermined)),"}, {"sha": "d77b1868ed72e736331ec463aaf0f3d275f0f379", "filename": "src/librustc_resolve/error_reporting.rs", "status": "modified", "additions": 17, "deletions": 19, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/7b0735a832dd49cb482084590eb0f2577955c079/src%2Flibrustc_resolve%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b0735a832dd49cb482084590eb0f2577955c079/src%2Flibrustc_resolve%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Ferror_reporting.rs?ref=7b0735a832dd49cb482084590eb0f2577955c079", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use {CrateLint, PathResult};\n+use {CrateLint, PathResult, Segment};\n \n use std::collections::BTreeSet;\n \n@@ -23,8 +23,8 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n     pub(crate) fn make_path_suggestion(\n         &mut self,\n         span: Span,\n-        path: Vec<Ident>\n-    ) -> Option<Vec<Ident>> {\n+        path: Vec<Segment>\n+    ) -> Option<Vec<Segment>> {\n         debug!(\"make_path_suggestion: span={:?} path={:?}\", span, path);\n         // If we don't have a path to suggest changes to, then return.\n         if path.is_empty() {\n@@ -37,13 +37,13 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n \n         match (path.get(0), path.get(1)) {\n             // Make suggestions that require at least two non-special path segments.\n-            (Some(fst), Some(snd)) if !is_special(*fst) && !is_special(*snd) => {\n+            (Some(fst), Some(snd)) if !is_special(fst.ident) && !is_special(snd.ident) => {\n                 debug!(\"make_path_suggestion: fst={:?} snd={:?}\", fst, snd);\n \n                 self.make_missing_self_suggestion(span, path.clone())\n                     .or_else(|| self.make_missing_crate_suggestion(span, path.clone()))\n                     .or_else(|| self.make_missing_super_suggestion(span, path.clone()))\n-                    .or_else(|| self.make_external_crate_suggestion(span, path.clone()))\n+                    .or_else(|| self.make_external_crate_suggestion(span, path))\n             },\n             _ => None,\n         }\n@@ -59,10 +59,10 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n     fn make_missing_self_suggestion(\n         &mut self,\n         span: Span,\n-        mut path: Vec<Ident>\n-    ) -> Option<Vec<Ident>> {\n+        mut path: Vec<Segment>\n+    ) -> Option<Vec<Segment>> {\n         // Replace first ident with `self` and check if that is valid.\n-        path[0].name = keywords::SelfValue.name();\n+        path[0].ident.name = keywords::SelfValue.name();\n         let result = self.resolve_path(None, &path, None, false, span, CrateLint::No);\n         debug!(\"make_missing_self_suggestion: path={:?} result={:?}\", path, result);\n         if let PathResult::Module(..) = result {\n@@ -82,10 +82,10 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n     fn make_missing_crate_suggestion(\n         &mut self,\n         span: Span,\n-        mut path: Vec<Ident>\n-    ) -> Option<Vec<Ident>> {\n+        mut path: Vec<Segment>\n+    ) -> Option<Vec<Segment>> {\n         // Replace first ident with `crate` and check if that is valid.\n-        path[0].name = keywords::Crate.name();\n+        path[0].ident.name = keywords::Crate.name();\n         let result = self.resolve_path(None, &path, None, false, span, CrateLint::No);\n         debug!(\"make_missing_crate_suggestion:  path={:?} result={:?}\", path, result);\n         if let PathResult::Module(..) = result {\n@@ -105,10 +105,10 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n     fn make_missing_super_suggestion(\n         &mut self,\n         span: Span,\n-        mut path: Vec<Ident>\n-    ) -> Option<Vec<Ident>> {\n+        mut path: Vec<Segment>\n+    ) -> Option<Vec<Segment>> {\n         // Replace first ident with `crate` and check if that is valid.\n-        path[0].name = keywords::Super.name();\n+        path[0].ident.name = keywords::Super.name();\n         let result = self.resolve_path(None, &path, None, false, span, CrateLint::No);\n         debug!(\"make_missing_super_suggestion:  path={:?} result={:?}\", path, result);\n         if let PathResult::Module(..) = result {\n@@ -131,8 +131,8 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n     fn make_external_crate_suggestion(\n         &mut self,\n         span: Span,\n-        mut path: Vec<Ident>\n-    ) -> Option<Vec<Ident>> {\n+        mut path: Vec<Segment>\n+    ) -> Option<Vec<Segment>> {\n         // Need to clone else we can't call `resolve_path` without a borrow error. We also store\n         // into a `BTreeMap` so we can get consistent ordering (and therefore the same diagnostic)\n         // each time.\n@@ -148,7 +148,7 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n         for name in external_crate_names.iter().rev() {\n             // Replace the first after root (a placeholder we inserted) with a crate name\n             // and check if that is valid.\n-            path[1].name = *name;\n+            path[1].ident.name = *name;\n             let result = self.resolve_path(None, &path, None, false, span, CrateLint::No);\n             debug!(\"make_external_crate_suggestion: name={:?} path={:?} result={:?}\",\n                     name, path, result);\n@@ -157,8 +157,6 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n             }\n         }\n \n-        // Remove our placeholder segment.\n-        path.remove(1);\n         None\n     }\n }"}, {"sha": "546c5a5ed3d6cadbcf2c019f1dc356fd67b96a29", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 149, "deletions": 78, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/7b0735a832dd49cb482084590eb0f2577955c079/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b0735a832dd49cb482084590eb0f2577955c079/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=7b0735a832dd49cb482084590eb0f2577955c079", "patch": "@@ -632,6 +632,43 @@ impl<'a> PathSource<'a> {\n     }\n }\n \n+// A minimal representation of a path segment. We use this in resolve because\n+// we synthesize 'path segments' which don't have the rest of an AST or HIR\n+// PathSegment.\n+#[derive(Clone, Copy, Debug)]\n+pub struct Segment {\n+    ident: Ident,\n+    id: Option<NodeId>,\n+}\n+\n+impl Segment {\n+    fn from_path(path: &Path) -> Vec<Segment> {\n+        path.segments.iter().map(|s| s.into()).collect()\n+    }\n+\n+    fn from_ident(ident: Ident) -> Segment {\n+        Segment {\n+            ident,\n+            id: None,\n+        }\n+    }\n+\n+    fn names_to_string(segments: &[Segment]) -> String {\n+        names_to_string(&segments.iter()\n+                            .map(|seg| seg.ident)\n+                            .collect::<Vec<_>>())\n+    }\n+}\n+\n+impl<'a> From<&'a ast::PathSegment> for Segment {\n+    fn from(seg: &'a ast::PathSegment) -> Segment {\n+        Segment {\n+            ident: seg.ident,\n+            id: Some(seg.id),\n+        }\n+    }\n+}\n+\n struct UsePlacementFinder {\n     target_module: NodeId,\n     span: Option<Span>,\n@@ -1534,7 +1571,11 @@ impl<'a, 'b: 'a, 'cl: 'b> ty::DefIdTree for &'a Resolver<'b, 'cl> {\n /// This interface is used through the AST\u2192HIR step, to embed full paths into the HIR. After that\n /// the resolver is no longer needed as all the relevant information is inline.\n impl<'a, 'cl> hir::lowering::Resolver for Resolver<'a, 'cl> {\n-    fn resolve_hir_path(&mut self, path: &mut hir::Path, is_value: bool) {\n+    fn resolve_hir_path(\n+        &mut self,\n+        path: &ast::Path,\n+        is_value: bool,\n+    ) -> hir::Path {\n         self.resolve_hir_path_cb(path, is_value,\n                                  |resolver, span, error| resolve_error(resolver, span, error))\n     }\n@@ -1544,33 +1585,22 @@ impl<'a, 'cl> hir::lowering::Resolver for Resolver<'a, 'cl> {\n         span: Span,\n         crate_root: Option<&str>,\n         components: &[&str],\n-        args: Option<P<hir::GenericArgs>>,\n         is_value: bool\n     ) -> hir::Path {\n-        let mut segments = iter::once(keywords::CrateRoot.ident())\n+        let segments = iter::once(keywords::CrateRoot.ident())\n             .chain(\n                 crate_root.into_iter()\n                     .chain(components.iter().cloned())\n                     .map(Ident::from_str)\n-            ).map(hir::PathSegment::from_ident).collect::<Vec<_>>();\n+            ).map(|i| self.new_ast_path_segment(i)).collect::<Vec<_>>();\n \n-        if let Some(args) = args {\n-            let ident = segments.last().unwrap().ident;\n-            *segments.last_mut().unwrap() = hir::PathSegment {\n-                ident,\n-                args: Some(args),\n-                infer_types: true,\n-            };\n-        }\n \n-        let mut path = hir::Path {\n+        let path = ast::Path {\n             span,\n-            def: Def::Err,\n-            segments: segments.into(),\n+            segments,\n         };\n \n-        self.resolve_hir_path(&mut path, is_value);\n-        path\n+        self.resolve_hir_path(&path, is_value)\n     }\n \n     fn get_resolution(&mut self, id: NodeId) -> Option<PathResolution> {\n@@ -1596,23 +1626,27 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n         use std::iter;\n         let mut errored = false;\n \n-        let mut path = if path_str.starts_with(\"::\") {\n-            hir::Path {\n+        let path = if path_str.starts_with(\"::\") {\n+            ast::Path {\n                 span,\n-                def: Def::Err,\n-                segments: iter::once(keywords::CrateRoot.ident()).chain({\n-                    path_str.split(\"::\").skip(1).map(Ident::from_str)\n-                }).map(hir::PathSegment::from_ident).collect(),\n+                segments: iter::once(keywords::CrateRoot.ident())\n+                    .chain({\n+                        path_str.split(\"::\").skip(1).map(Ident::from_str)\n+                    })\n+                    .map(|i| self.new_ast_path_segment(i))\n+                    .collect(),\n             }\n         } else {\n-            hir::Path {\n+            ast::Path {\n                 span,\n-                def: Def::Err,\n-                segments: path_str.split(\"::\").map(Ident::from_str)\n-                                  .map(hir::PathSegment::from_ident).collect(),\n+                segments: path_str\n+                    .split(\"::\")\n+                    .map(Ident::from_str)\n+                    .map(|i| self.new_ast_path_segment(i))\n+                    .collect(),\n             }\n         };\n-        self.resolve_hir_path_cb(&mut path, is_value, |_, _, _| errored = true);\n+        let path = self.resolve_hir_path_cb(&path, is_value, |_, _, _| errored = true);\n         if errored || path.def == Def::Err {\n             Err(())\n         } else {\n@@ -1621,19 +1655,25 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n     }\n \n     /// resolve_hir_path, but takes a callback in case there was an error\n-    fn resolve_hir_path_cb<F>(&mut self, path: &mut hir::Path, is_value: bool, error_callback: F)\n+    fn resolve_hir_path_cb<F>(\n+        &mut self,\n+        path: &ast::Path,\n+        is_value: bool,\n+        error_callback: F,\n+    ) -> hir::Path\n         where F: for<'c, 'b> FnOnce(&'c mut Resolver, Span, ResolutionError<'b>)\n     {\n         let namespace = if is_value { ValueNS } else { TypeNS };\n-        let hir::Path { ref segments, span, ref mut def } = *path;\n-        let path: Vec<_> = segments.iter().map(|seg| seg.ident).collect();\n+        let span = path.span;\n+        let segments = &path.segments;\n+        let path = Segment::from_path(&path);\n         // FIXME (Manishearth): Intra doc links won't get warned of epoch changes\n-        match self.resolve_path(None, &path, Some(namespace), true, span, CrateLint::No) {\n+        let def = match self.resolve_path(None, &path, Some(namespace), true, span, CrateLint::No) {\n             PathResult::Module(ModuleOrUniformRoot::Module(module)) =>\n-                *def = module.def().unwrap(),\n+                module.def().unwrap(),\n             PathResult::NonModule(path_res) if path_res.unresolved_segments() == 0 =>\n-                *def = path_res.base_def(),\n-            PathResult::NonModule(..) =>\n+                path_res.base_def(),\n+            PathResult::NonModule(..) => {\n                 if let PathResult::Failed(span, msg, _) = self.resolve_path(\n                     None,\n                     &path,\n@@ -1643,14 +1683,34 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n                     CrateLint::No,\n                 ) {\n                     error_callback(self, span, ResolutionError::FailedToResolve(&msg));\n-                },\n+                }\n+                Def::Err\n+            }\n             PathResult::Module(ModuleOrUniformRoot::UniformRoot(_)) |\n             PathResult::Indeterminate => unreachable!(),\n             PathResult::Failed(span, msg, _) => {\n                 error_callback(self, span, ResolutionError::FailedToResolve(&msg));\n+                Def::Err\n             }\n+        };\n+\n+        let segments: Vec<_> = segments.iter().map(|seg| {\n+            let mut hir_seg = hir::PathSegment::from_ident(seg.ident);\n+            hir_seg.def = Some(self.def_map.get(&seg.id).map_or(Def::Err, |p| p.base_def()));\n+            hir_seg\n+        }).collect();\n+        hir::Path {\n+            span,\n+            def,\n+            segments: segments.into(),\n         }\n     }\n+\n+    fn new_ast_path_segment(&self, ident: Ident) -> ast::PathSegment {\n+        let mut seg = ast::PathSegment::from_ident(ident);\n+        seg.id = self.session.next_node_id();\n+        seg\n+    }\n }\n \n impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n@@ -2457,9 +2517,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n         let mut new_val = None;\n         let mut new_id = None;\n         if let Some(trait_ref) = opt_trait_ref {\n-            let path: Vec<_> = trait_ref.path.segments.iter()\n-                .map(|seg| seg.ident)\n-                .collect();\n+            let path: Vec<_> = Segment::from_path(&trait_ref.path);\n             let def = self.smart_resolve_path_fragment(\n                 trait_ref.ref_id,\n                 None,\n@@ -2955,21 +3013,25 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n         source: PathSource,\n         crate_lint: CrateLint\n     ) -> PathResolution {\n-        let segments = &path.segments.iter()\n-            .map(|seg| seg.ident)\n-            .collect::<Vec<_>>();\n-        self.smart_resolve_path_fragment(id, qself, segments, path.span, source, crate_lint)\n+        self.smart_resolve_path_fragment(\n+            id,\n+            qself,\n+            &Segment::from_path(path),\n+            path.span,\n+            source,\n+            crate_lint,\n+        )\n     }\n \n     fn smart_resolve_path_fragment(&mut self,\n                                    id: NodeId,\n                                    qself: Option<&QSelf>,\n-                                   path: &[Ident],\n+                                   path: &[Segment],\n                                    span: Span,\n                                    source: PathSource,\n                                    crate_lint: CrateLint)\n                                    -> PathResolution {\n-        let ident_span = path.last().map_or(span, |ident| ident.span);\n+        let ident_span = path.last().map_or(span, |ident| ident.ident.span);\n         let ns = source.namespace();\n         let is_expected = &|def| source.is_expected(def);\n         let is_enum_variant = &|def| if let Def::Variant(..) = def { true } else { false };\n@@ -2978,18 +3040,18 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n         let report_errors = |this: &mut Self, def: Option<Def>| {\n             // Make the base error.\n             let expected = source.descr_expected();\n-            let path_str = names_to_string(path);\n-            let item_str = path.last().unwrap();\n+            let path_str = Segment::names_to_string(path);\n+            let item_str = path.last().unwrap().ident;\n             let code = source.error_code(def.is_some());\n             let (base_msg, fallback_label, base_span) = if let Some(def) = def {\n                 (format!(\"expected {}, found {} `{}`\", expected, def.kind_name(), path_str),\n                  format!(\"not a {}\", expected),\n                  span)\n             } else {\n-                let item_span = path.last().unwrap().span;\n+                let item_span = path.last().unwrap().ident.span;\n                 let (mod_prefix, mod_str) = if path.len() == 1 {\n                     (String::new(), \"this scope\".to_string())\n-                } else if path.len() == 2 && path[0].name == keywords::CrateRoot.name() {\n+                } else if path.len() == 2 && path[0].ident.name == keywords::CrateRoot.name() {\n                     (String::new(), \"the crate root\".to_string())\n                 } else {\n                     let mod_path = &path[..path.len() - 1];\n@@ -2999,7 +3061,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                             module.def(),\n                         _ => None,\n                     }.map_or(String::new(), |def| format!(\"{} \", def.kind_name()));\n-                    (mod_prefix, format!(\"`{}`\", names_to_string(mod_path)))\n+                    (mod_prefix, format!(\"`{}`\", Segment::names_to_string(mod_path)))\n                 };\n                 (format!(\"cannot find {} `{}` in {}{}\", expected, item_str, mod_prefix, mod_str),\n                  format!(\"not found in {}\", mod_str),\n@@ -3010,7 +3072,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n \n             // Emit help message for fake-self from other languages like `this`(javascript)\n             if [\"this\", \"my\"].contains(&&*item_str.as_str())\n-                && this.self_value_is_available(path[0].span, span) {\n+                && this.self_value_is_available(path[0].ident.span, span) {\n                 err.span_suggestion_with_applicability(\n                     span,\n                     \"did you mean\",\n@@ -3045,7 +3107,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n             }\n \n             // Try to lookup the name in more relaxed fashion for better error reporting.\n-            let ident = *path.last().unwrap();\n+            let ident = path.last().unwrap().ident;\n             let candidates = this.lookup_import_candidates(ident.name, ns, is_expected);\n             if candidates.is_empty() && is_expected(Def::Enum(DefId::local(CRATE_DEF_INDEX))) {\n                 let enum_candidates =\n@@ -3072,7 +3134,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n             }\n             if path.len() == 1 && this.self_type_is_available(span) {\n                 if let Some(candidate) = this.lookup_assoc_candidate(ident, ns, is_expected) {\n-                    let self_is_available = this.self_value_is_available(path[0].span, span);\n+                    let self_is_available = this.self_value_is_available(path[0].ident.span, span);\n                     match candidate {\n                         AssocSuggestion::Field => {\n                             err.span_suggestion_with_applicability(\n@@ -3307,7 +3369,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                 // or `<T>::A::B`. If `B` should be resolved in value namespace then\n                 // it needs to be added to the trait map.\n                 if ns == ValueNS {\n-                    let item_name = *path.last().unwrap();\n+                    let item_name = path.last().unwrap().ident;\n                     let traits = self.get_traits_containing_item(item_name, ns);\n                     self.trait_map.insert(id, traits);\n                 }\n@@ -3377,7 +3439,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n     fn resolve_qpath_anywhere(&mut self,\n                               id: NodeId,\n                               qself: Option<&QSelf>,\n-                              path: &[Ident],\n+                              path: &[Segment],\n                               primary_ns: Namespace,\n                               span: Span,\n                               defer_to_typeck: bool,\n@@ -3399,10 +3461,10 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n             }\n         }\n         if primary_ns != MacroNS &&\n-           (self.macro_names.contains(&path[0].modern()) ||\n-            self.builtin_macros.get(&path[0].name).cloned()\n+           (self.macro_names.contains(&path[0].ident.modern()) ||\n+            self.builtin_macros.get(&path[0].ident.name).cloned()\n                                .and_then(NameBinding::macro_kind) == Some(MacroKind::Bang) ||\n-            self.macro_use_prelude.get(&path[0].name).cloned()\n+            self.macro_use_prelude.get(&path[0].ident.name).cloned()\n                                   .and_then(NameBinding::macro_kind) == Some(MacroKind::Bang)) {\n             // Return some dummy definition, it's enough for error reporting.\n             return Some(\n@@ -3416,7 +3478,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n     fn resolve_qpath(&mut self,\n                      id: NodeId,\n                      qself: Option<&QSelf>,\n-                     path: &[Ident],\n+                     path: &[Segment],\n                      ns: Namespace,\n                      span: Span,\n                      global_by_default: bool,\n@@ -3506,8 +3568,8 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n             PathResult::Failed(..)\n                     if (ns == TypeNS || path.len() > 1) &&\n                        self.primitive_type_table.primitive_types\n-                           .contains_key(&path[0].name) => {\n-                let prim = self.primitive_type_table.primitive_types[&path[0].name];\n+                           .contains_key(&path[0].ident.name) => {\n+                let prim = self.primitive_type_table.primitive_types[&path[0].ident.name];\n                 PathResolution::with_unresolved_segments(Def::PrimTy(prim), path.len() - 1)\n             }\n             PathResult::Module(ModuleOrUniformRoot::Module(module)) =>\n@@ -3522,8 +3584,8 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n         };\n \n         if path.len() > 1 && !global_by_default && result.base_def() != Def::Err &&\n-           path[0].name != keywords::CrateRoot.name() &&\n-           path[0].name != keywords::DollarCrate.name() {\n+           path[0].ident.name != keywords::CrateRoot.name() &&\n+           path[0].ident.name != keywords::DollarCrate.name() {\n             let unqualified_result = {\n                 match self.resolve_path(\n                     None,\n@@ -3551,7 +3613,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n     fn resolve_path(\n         &mut self,\n         base_module: Option<ModuleOrUniformRoot<'a>>,\n-        path: &[Ident],\n+        path: &[Segment],\n         opt_ns: Option<Namespace>, // `None` indicates a module path\n         record_used: bool,\n         path_span: Span,\n@@ -3565,7 +3627,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n     fn resolve_path_with_parent_scope(\n         &mut self,\n         base_module: Option<ModuleOrUniformRoot<'a>>,\n-        path: &[Ident],\n+        path: &[Segment],\n         opt_ns: Option<Namespace>, // `None` indicates a module path\n         parent_scope: &ParentScope<'a>,\n         record_used: bool,\n@@ -3587,8 +3649,9 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n             crate_lint,\n         );\n \n-        for (i, &ident) in path.iter().enumerate() {\n+        for (i, &Segment { ident, id }) in path.iter().enumerate() {\n             debug!(\"resolve_path ident {} {:?}\", i, ident);\n+\n             let is_last = i == path.len() - 1;\n             let ns = if is_last { opt_ns.unwrap_or(TypeNS) } else { TypeNS };\n             let name = ident.name;\n@@ -3648,7 +3711,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                 } else {\n                     format!(\"`{}`\", name)\n                 };\n-                let msg = if i == 1 && path[0].name == keywords::CrateRoot.name() {\n+                let msg = if i == 1 && path[0].ident.name == keywords::CrateRoot.name() {\n                     format!(\"global paths cannot start with {}\", name_str)\n                 } else {\n                     format!(\"{} in paths can only be used in start position\", name_str)\n@@ -3688,6 +3751,14 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                     let maybe_assoc = opt_ns != Some(MacroNS) && PathSource::Type.is_expected(def);\n                     if let Some(next_module) = binding.module() {\n                         module = Some(ModuleOrUniformRoot::Module(next_module));\n+                        if record_used {\n+                            if let Some(id) = id {\n+                                if !self.def_map.contains_key(&id) {\n+                                    assert!(id != ast::DUMMY_NODE_ID, \"Trying to resolve dummy id\");\n+                                    self.record_def(id, PathResolution::new(def));\n+                                }\n+                            }\n+                        }\n                     } else if def == Def::ToolMod && i + 1 != path.len() {\n                         let def = Def::NonMacroAttr(NonMacroAttrKind::Tool);\n                         return PathResult::NonModule(PathResolution::new(def));\n@@ -3737,7 +3808,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                     } else if i == 0 {\n                         format!(\"Use of undeclared type or module `{}`\", ident)\n                     } else {\n-                        format!(\"Could not find `{}` in `{}`\", ident, path[i - 1])\n+                        format!(\"Could not find `{}` in `{}`\", ident, path[i - 1].ident)\n                     };\n                     return PathResult::Failed(ident.span, msg, is_last);\n                 }\n@@ -3755,7 +3826,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n     fn lint_if_path_starts_with_module(\n         &self,\n         crate_lint: CrateLint,\n-        path: &[Ident],\n+        path: &[Segment],\n         path_span: Span,\n         second_binding: Option<&NameBinding>,\n     ) {\n@@ -3772,7 +3843,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n         };\n \n         let first_name = match path.get(0) {\n-            Some(ident) => ident.name,\n+            Some(ident) => ident.ident.name,\n             None => return,\n         };\n \n@@ -3784,7 +3855,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n \n         match path.get(1) {\n             // If this import looks like `crate::...` it's already good\n-            Some(ident) if ident.name == keywords::Crate.name() => return,\n+            Some(Segment { ident, .. }) if ident.name == keywords::Crate.name() => return,\n             // Otherwise go below to see if it's an extern crate\n             Some(_) => {}\n             // If the path has length one (and it's `CrateRoot` most likely)\n@@ -3977,7 +4048,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n     }\n \n     fn lookup_typo_candidate<FilterFn>(&mut self,\n-                                       path: &[Ident],\n+                                       path: &[Segment],\n                                        ns: Namespace,\n                                        filter_fn: FilterFn,\n                                        span: Span)\n@@ -4041,7 +4112,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n             }\n         }\n \n-        let name = path[path.len() - 1].name;\n+        let name = path[path.len() - 1].ident.name;\n         // Make sure error reporting is deterministic.\n         names.sort_by_cached_key(|name| name.as_str());\n         match find_best_match_for_name(names.iter(), &name.as_str(), None) {\n@@ -4558,7 +4629,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n             ast::VisibilityKind::Restricted { ref path, id, .. } => {\n                 // Visibilities are resolved as global by default, add starting root segment.\n                 let segments = path.make_root().iter().chain(path.segments.iter())\n-                    .map(|seg| seg.ident)\n+                    .map(|seg| Segment { ident: seg.ident, id: Some(seg.id) })\n                     .collect::<Vec<_>>();\n                 let def = self.smart_resolve_path_fragment(\n                     id,\n@@ -4851,12 +4922,12 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n     }\n }\n \n-fn is_self_type(path: &[Ident], namespace: Namespace) -> bool {\n-    namespace == TypeNS && path.len() == 1 && path[0].name == keywords::SelfType.name()\n+fn is_self_type(path: &[Segment], namespace: Namespace) -> bool {\n+    namespace == TypeNS && path.len() == 1 && path[0].ident.name == keywords::SelfType.name()\n }\n \n-fn is_self_value(path: &[Ident], namespace: Namespace) -> bool {\n-    namespace == ValueNS && path.len() == 1 && path[0].name == keywords::SelfValue.name()\n+fn is_self_value(path: &[Segment], namespace: Namespace) -> bool {\n+    namespace == ValueNS && path.len() == 1 && path[0].ident.name == keywords::SelfValue.name()\n }\n \n fn names_to_string(idents: &[Ident]) -> String {"}, {"sha": "68b3a6be2928253a48a385f8aaaa80f1d42da9e3", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7b0735a832dd49cb482084590eb0f2577955c079/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b0735a832dd49cb482084590eb0f2577955c079/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=7b0735a832dd49cb482084590eb0f2577955c079", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use {AmbiguityError, CrateLint, Resolver, ResolutionError, is_known_tool, resolve_error};\n-use {Module, ModuleKind, NameBinding, NameBindingKind, PathResult, ToNameBinding};\n+use {Module, ModuleKind, NameBinding, NameBindingKind, PathResult, Segment, ToNameBinding};\n use ModuleOrUniformRoot;\n use Namespace::{self, *};\n use build_reduced_graph::{BuildReducedGraphVisitor, IsMacroExport};\n@@ -461,14 +461,15 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         parent_scope: &ParentScope<'a>,\n         force: bool,\n     ) -> Result<Def, Determinacy> {\n-        let ast::Path { ref segments, span } = *path;\n-        let mut path: Vec<_> = segments.iter().map(|seg| seg.ident).collect();\n+        let span = path.span;\n+        let mut path = Segment::from_path(path);\n \n         // Possibly apply the macro helper hack\n         if kind == MacroKind::Bang && path.len() == 1 &&\n-           path[0].span.ctxt().outer().expn_info().map_or(false, |info| info.local_inner_macros) {\n-            let root = Ident::new(keywords::DollarCrate.name(), path[0].span);\n-            path.insert(0, root);\n+           path[0].ident.span.ctxt().outer().expn_info()\n+               .map_or(false, |info| info.local_inner_macros) {\n+            let root = Ident::new(keywords::DollarCrate.name(), path[0].ident.span);\n+            path.insert(0, Segment::from_ident(root));\n         }\n \n         if path.len() > 1 {\n@@ -496,12 +497,16 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n             };\n \n             parent_scope.module.macro_resolutions.borrow_mut()\n-                .push((path.into_boxed_slice(), span));\n+                .push((path\n+                    .iter()\n+                    .map(|seg| seg.ident)\n+                    .collect::<Vec<Ident>>()\n+                    .into_boxed_slice(), span));\n \n             def\n         } else {\n             let binding = self.early_resolve_ident_in_lexical_scope(\n-                path[0], MacroNS, Some(kind), parent_scope, false, force, span\n+                path[0].ident, MacroNS, Some(kind), parent_scope, false, force, span\n             );\n             match binding {\n                 Ok(..) => {}\n@@ -510,7 +515,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n             }\n \n             parent_scope.module.legacy_macro_resolutions.borrow_mut()\n-                .push((path[0], kind, parent_scope.clone(), binding.ok()));\n+                .push((path[0].ident, kind, parent_scope.clone(), binding.ok()));\n \n             binding.map(|binding| binding.def_ignoring_ambiguity())\n         }\n@@ -846,6 +851,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n     pub fn finalize_current_module_macro_resolutions(&mut self) {\n         let module = self.current_module;\n         for &(ref path, span) in module.macro_resolutions.borrow().iter() {\n+            let path: Vec<_> = path.iter().map(|&ident| Segment::from_ident(ident)).collect();\n             match self.resolve_path(None, &path, Some(MacroNS), true, span, CrateLint::No) {\n                 PathResult::NonModule(_) => {},\n                 PathResult::Failed(span, msg, _) => {\n@@ -938,7 +944,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                 }\n             };\n             let ident = Ident::new(Symbol::intern(name), span);\n-            self.lookup_typo_candidate(&[ident], MacroNS, is_macro, span)\n+            self.lookup_typo_candidate(&[Segment::from_ident(ident)], MacroNS, is_macro, span)\n         });\n \n         if let Some(suggestion) = suggestion {"}, {"sha": "810aff7f9b0a86c7eaca20a8945f31f04ccc8d87", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/7b0735a832dd49cb482084590eb0f2577955c079/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b0735a832dd49cb482084590eb0f2577955c079/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=7b0735a832dd49cb482084590eb0f2577955c079", "patch": "@@ -13,7 +13,7 @@ use self::ImportDirectiveSubclass::*;\n use {AmbiguityError, CrateLint, Module, ModuleOrUniformRoot, PerNS};\n use Namespace::{self, TypeNS, MacroNS};\n use {NameBinding, NameBindingKind, ToNameBinding, PathResult, PrivacyError};\n-use Resolver;\n+use {Resolver, Segment};\n use {names_to_string, module_to_string};\n use {resolve_error, ResolutionError};\n \n@@ -89,7 +89,7 @@ pub struct ImportDirective<'a> {\n     pub root_span: Span,\n \n     pub parent: Module<'a>,\n-    pub module_path: Vec<Ident>,\n+    pub module_path: Vec<Segment>,\n     /// The resolution of `module_path`.\n     pub imported_module: Cell<Option<ModuleOrUniformRoot<'a>>>,\n     pub subclass: ImportDirectiveSubclass<'a>,\n@@ -393,7 +393,7 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n \n     // Add an import directive to the current module.\n     pub fn add_import_directive(&mut self,\n-                                module_path: Vec<Ident>,\n+                                module_path: Vec<Segment>,\n                                 subclass: ImportDirectiveSubclass<'a>,\n                                 span: Span,\n                                 id: NodeId,\n@@ -679,7 +679,7 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n \n                 let has_explicit_self =\n                     !import.module_path.is_empty() &&\n-                    import.module_path[0].name == keywords::SelfValue.name();\n+                    import.module_path[0].ident.name == keywords::SelfValue.name();\n \n                 self.per_ns(|_, ns| {\n                     if let Some(result) = result[ns].get().ok() {\n@@ -728,9 +728,11 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n                     self.throw_unresolved_import_error(empty_vec, None);\n                 }\n                 if !seen_spans.contains(&span) {\n-                    let path = import_path_to_string(&import.module_path[..],\n-                                                     &import.subclass,\n-                                                     span);\n+                    let path = import_path_to_string(\n+                        &import.module_path.iter().map(|seg| seg.ident).collect::<Vec<_>>(),\n+                        &import.subclass,\n+                        span,\n+                    );\n                     error_vec.push((span, path, err));\n                     seen_spans.insert(span);\n                     prev_root_id = import.root_id;\n@@ -851,9 +853,10 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n     /// If successful, the resolved bindings are written into the module.\n     fn resolve_import(&mut self, directive: &'b ImportDirective<'b>) -> bool {\n         debug!(\"(resolving import for module) resolving import `{}::...` in `{}`\",\n-               names_to_string(&directive.module_path[..]),\n+               Segment::names_to_string(&directive.module_path[..]),\n                module_to_string(self.current_module).unwrap_or_else(|| \"???\".to_string()));\n \n+\n         self.current_module = directive.parent;\n \n         let module = if let Some(module) = directive.imported_module.get() {\n@@ -966,7 +969,7 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n                 ) {\n                     Some((\n                         span,\n-                        format!(\"Did you mean `{}`?\", names_to_string(&suggested_path[..]))\n+                        format!(\"Did you mean `{}`?\", Segment::names_to_string(&suggested_path))\n                     ))\n                 } else {\n                     Some((span, msg))\n@@ -982,7 +985,7 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n                     // HACK(eddyb) `lint_if_path_starts_with_module` needs at least\n                     // 2 segments, so the `resolve_path` above won't trigger it.\n                     let mut full_path = module_path.clone();\n-                    full_path.push(keywords::Invalid.ident());\n+                    full_path.push(Segment::from_ident(keywords::Invalid.ident()));\n                     self.lint_if_path_starts_with_module(\n                         directive.crate_lint(),\n                         &full_path,\n@@ -1146,7 +1149,7 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n             // HACK(eddyb) `lint_if_path_starts_with_module` needs at least\n             // 2 segments, so the `resolve_path` above won't trigger it.\n             let mut full_path = module_path.clone();\n-            full_path.push(ident);\n+            full_path.push(Segment::from_ident(ident));\n             self.per_ns(|this, ns| {\n                 if let Ok(binding) = result[ns].get() {\n                     this.lint_if_path_starts_with_module(\n@@ -1288,7 +1291,7 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n                         let resolutions = imported_module.parent.expect(\"parent should exist\")\n                             .resolutions.borrow();\n                         let enum_path_segment_index = directive.module_path.len() - 1;\n-                        let enum_ident = directive.module_path[enum_path_segment_index];\n+                        let enum_ident = directive.module_path[enum_path_segment_index].ident;\n \n                         let enum_resolution = resolutions.get(&(enum_ident, TypeNS))\n                             .expect(\"resolution should exist\");"}, {"sha": "a7fe1bb421c378805a4e769479144016243ec8c3", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 81, "deletions": 214, "changes": 295, "blob_url": "https://github.com/rust-lang/rust/blob/7b0735a832dd49cb482084590eb0f2577955c079/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b0735a832dd49cb482084590eb0f2577955c079/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=7b0735a832dd49cb482084590eb0f2577955c079", "patch": "@@ -34,12 +34,10 @@ use std::env;\n \n use syntax::ast::{self, Attribute, NodeId, PatKind, CRATE_NODE_ID};\n use syntax::parse::token;\n-use syntax::symbol::keywords;\n use syntax::visit::{self, Visitor};\n use syntax::print::pprust::{\n     bounds_to_string,\n     generic_params_to_string,\n-    path_to_string,\n     ty_to_string\n };\n use syntax::ptr::P;\n@@ -219,95 +217,21 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n         self.dumper.compilation_opts(data);\n     }\n \n-    // Return all non-empty prefixes of a path.\n-    // For each prefix, we return the span for the last segment in the prefix and\n-    // a str representation of the entire prefix.\n-    fn process_path_prefixes(&self, path: &ast::Path) -> Vec<(Span, String)> {\n-        let segments = &path.segments[if path.is_global() { 1 } else { 0 }..];\n-\n-        let mut result = Vec::with_capacity(segments.len());\n-        let mut segs = Vec::with_capacity(segments.len());\n-\n-        for (i, seg) in segments.iter().enumerate() {\n-            segs.push(seg.clone());\n-            let sub_path = ast::Path {\n-                span: seg.ident.span, // span for the last segment\n-                segments: segs,\n-            };\n-            let qualname = if i == 0 && path.is_global() {\n-                format!(\"::{}\", path_to_string(&sub_path))\n-            } else {\n-                path_to_string(&sub_path)\n-            };\n-            result.push((seg.ident.span, qualname));\n-            segs = sub_path.segments;\n-        }\n-\n-        result\n-    }\n-\n     fn write_sub_paths(&mut self, path: &ast::Path) {\n-        let sub_paths = self.process_path_prefixes(path);\n-        for (span, _) in sub_paths {\n-            let span = self.span_from_span(span);\n-            self.dumper.dump_ref(Ref {\n-                kind: RefKind::Mod,\n-                span,\n-                ref_id: ::null_id(),\n-            });\n+        for seg in &path.segments {\n+            if let Some(data) = self.save_ctxt.get_path_segment_data(seg) {\n+                self.dumper.dump_ref(data);\n+            }\n         }\n     }\n \n     // As write_sub_paths, but does not process the last ident in the path (assuming it\n     // will be processed elsewhere). See note on write_sub_paths about global.\n     fn write_sub_paths_truncated(&mut self, path: &ast::Path) {\n-        let sub_paths = self.process_path_prefixes(path);\n-        let len = sub_paths.len();\n-        if len <= 1 {\n-            return;\n-        }\n-\n-        for (span, _) in sub_paths.into_iter().take(len - 1) {\n-            let span = self.span_from_span(span);\n-            self.dumper.dump_ref(Ref {\n-                kind: RefKind::Mod,\n-                span,\n-                ref_id: ::null_id(),\n-            });\n-        }\n-    }\n-\n-    // As write_sub_paths, but expects a path of the form module_path::trait::method\n-    // Where trait could actually be a struct too.\n-    fn write_sub_path_trait_truncated(&mut self, path: &ast::Path) {\n-        let sub_paths = self.process_path_prefixes(path);\n-        let len = sub_paths.len();\n-        if len <= 1 {\n-            return;\n-        }\n-        let sub_paths = &sub_paths[..(len - 1)];\n-\n-        // write the trait part of the sub-path\n-        let (ref span, _) = sub_paths[len - 2];\n-        let span = self.span_from_span(*span);\n-        self.dumper.dump_ref(Ref {\n-            kind: RefKind::Type,\n-            ref_id: ::null_id(),\n-            span,\n-        });\n-\n-        // write the other sub-paths\n-        if len <= 2 {\n-            return;\n-        }\n-        let sub_paths = &sub_paths[..len - 2];\n-        for &(ref span, _) in sub_paths {\n-            let span = self.span_from_span(*span);\n-            self.dumper.dump_ref(Ref {\n-                kind: RefKind::Mod,\n-                span,\n-                ref_id: ::null_id(),\n-            });\n+        for seg in &path.segments[..path.segments.len() - 1] {\n+            if let Some(data) = self.save_ctxt.get_path_segment_data(seg) {\n+                self.dumper.dump_ref(data);\n+            }\n         }\n     }\n \n@@ -323,18 +247,16 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n             self.visit_pat(&arg.pat);\n             let mut collector = PathCollector::new();\n             collector.visit_pat(&arg.pat);\n-            let span_utils = self.span.clone();\n \n             for (id, ident, ..) in collector.collected_idents {\n                 let hir_id = self.tcx.hir.node_to_hir_id(id);\n                 let typ = match self.save_ctxt.tables.node_id_to_type_opt(hir_id) {\n                     Some(s) => s.to_string(),\n                     None => continue,\n                 };\n-                let sub_span = span_utils.span_for_last_ident(ident.span);\n-                if !self.span.filter_generated(sub_span, ident.span) {\n+                if !self.span.filter_generated(ident.span) {\n                     let id = ::id_from_node_id(id, &self.save_ctxt);\n-                    let span = self.span_from_span(sub_span.expect(\"No span found for variable\"));\n+                    let span = self.span_from_span(ident.span);\n \n                     self.dumper.dump_def(\n                         &Access {\n@@ -373,7 +295,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n     ) {\n         debug!(\"process_method: {}:{}\", id, ident);\n \n-        if let Some(mut method_data) = self.save_ctxt.get_method_data(id, ident.name, span) {\n+        if let Some(mut method_data) = self.save_ctxt.get_method_data(id, ident, span) {\n             let sig_str = ::make_signature(&sig.decl, &generics);\n             if body.is_some() {\n                 self.nest_tables(\n@@ -382,7 +304,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n                 );\n             }\n \n-            self.process_generic_params(&generics, span, &method_data.qualname, id);\n+            self.process_generic_params(&generics, &method_data.qualname, id);\n \n             method_data.value = sig_str;\n             method_data.sig = sig::method_signature(id, ident, generics, sig, &self.save_ctxt);\n@@ -415,7 +337,6 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n     fn process_generic_params(\n         &mut self,\n         generics: &'l ast::Generics,\n-        full_span: Span,\n         prefix: &str,\n         id: NodeId,\n     ) {\n@@ -427,7 +348,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n                     let name = escape(self.span.snippet(param_ss));\n                     // Append $id to name to make sure each one is unique.\n                     let qualname = format!(\"{}::{}${}\", prefix, name, id);\n-                    if !self.span.filter_generated(Some(param_ss), full_span) {\n+                    if !self.span.filter_generated(param_ss) {\n                         let id = ::id_from_node_id(param.id, &self.save_ctxt);\n                         let span = self.span_from_span(param_ss);\n \n@@ -471,7 +392,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n                 item.id,\n                 |v| v.process_formals(&decl.inputs, &fn_data.qualname),\n             );\n-            self.process_generic_params(ty_params, item.span, &fn_data.qualname, item.id);\n+            self.process_generic_params(ty_params, &fn_data.qualname, item.id);\n             self.dumper.dump_def(&access_from!(self.save_ctxt, item), fn_data);\n         }\n \n@@ -505,8 +426,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n     fn process_assoc_const(\n         &mut self,\n         id: ast::NodeId,\n-        name: ast::Name,\n-        span: Span,\n+        ident: ast::Ident,\n         typ: &'l ast::Ty,\n         expr: Option<&'l ast::Expr>,\n         parent_id: DefId,\n@@ -515,19 +435,17 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n     ) {\n         let qualname = format!(\"::{}\", self.tcx.node_path_str(id));\n \n-        let sub_span = self.span.sub_span_after_keyword(span, keywords::Const);\n-\n-        if !self.span.filter_generated(sub_span, span) {\n-            let sig = sig::assoc_const_signature(id, name, typ, expr, &self.save_ctxt);\n-            let span = self.span_from_span(sub_span.expect(\"No span found for variable\"));\n+        if !self.span.filter_generated(ident.span) {\n+            let sig = sig::assoc_const_signature(id, ident.name, typ, expr, &self.save_ctxt);\n+            let span = self.span_from_span(ident.span);\n \n             self.dumper.dump_def(\n                 &access_from!(self.save_ctxt, vis, id),\n                 Def {\n                     kind: DefKind::Const,\n                     id: ::id_from_node_id(id, &self.save_ctxt),\n                     span,\n-                    name: name.to_string(),\n+                    name: ident.name.to_string(),\n                     qualname,\n                     value: ty_to_string(&typ),\n                     parent: Some(::id_from_def_id(parent_id)),\n@@ -558,13 +476,12 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n         let name = item.ident.to_string();\n         let qualname = format!(\"::{}\", self.tcx.node_path_str(item.id));\n \n-        let (kind, keyword) = match item.node {\n-            ast::ItemKind::Struct(_, _) => (DefKind::Struct, keywords::Struct),\n-            ast::ItemKind::Union(_, _) => (DefKind::Union, keywords::Union),\n+        let kind = match item.node {\n+            ast::ItemKind::Struct(_, _) => DefKind::Struct,\n+            ast::ItemKind::Union(_, _) => DefKind::Union,\n             _ => unreachable!(),\n         };\n \n-        let sub_span = self.span.sub_span_after_keyword(item.span, keyword);\n         let (value, fields) = match item.node {\n             ast::ItemKind::Struct(ast::VariantData::Struct(ref fields, _), _) |\n             ast::ItemKind::Union(ast::VariantData::Struct(ref fields, _), _) => {\n@@ -595,8 +512,8 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n             _ => (String::new(), vec![]),\n         };\n \n-        if !self.span.filter_generated(sub_span, item.span) {\n-            let span = self.span_from_span(sub_span.expect(\"No span found for struct\"));\n+        if !self.span.filter_generated(item.ident.span) {\n+            let span = self.span_from_span(item.ident.span);\n             self.dumper.dump_def(\n                 &access_from!(self.save_ctxt, item),\n                 Def {\n@@ -621,7 +538,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n             self.visit_ty(&field.ty);\n         }\n \n-        self.process_generic_params(ty_params, item.span, &qualname, item.id);\n+        self.process_generic_params(ty_params, &qualname, item.id);\n     }\n \n     fn process_enum(\n@@ -642,10 +559,10 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n         for variant in &enum_definition.variants {\n             let name = variant.node.ident.name.to_string();\n             let qualname = format!(\"{}::{}\", enum_data.qualname, name);\n+            let name_span = variant.node.ident.span;\n \n             match variant.node.data {\n                 ast::VariantData::Struct(ref fields, _) => {\n-                    let sub_span = self.span.span_for_first_ident(variant.span);\n                     let fields_str = fields\n                         .iter()\n                         .enumerate()\n@@ -655,9 +572,8 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n                         .collect::<Vec<_>>()\n                         .join(\", \");\n                     let value = format!(\"{}::{} {{ {} }}\", enum_data.name, name, fields_str);\n-                    if !self.span.filter_generated(sub_span, variant.span) {\n-                        let span = self\n-                            .span_from_span(sub_span.expect(\"No span found for struct variant\"));\n+                    if !self.span.filter_generated(name_span) {\n+                        let span = self.span_from_span(name_span);\n                         let id = ::id_from_node_id(variant.node.data.id(), &self.save_ctxt);\n                         let parent = Some(::id_from_node_id(item.id, &self.save_ctxt));\n \n@@ -684,7 +600,6 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n                     }\n                 }\n                 ref v => {\n-                    let sub_span = self.span.span_for_first_ident(variant.span);\n                     let mut value = format!(\"{}::{}\", enum_data.name, name);\n                     if let &ast::VariantData::Tuple(ref fields, _) = v {\n                         value.push('(');\n@@ -695,9 +610,8 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n                             .join(\", \"));\n                         value.push(')');\n                     }\n-                    if !self.span.filter_generated(sub_span, variant.span) {\n-                        let span =\n-                            self.span_from_span(sub_span.expect(\"No span found for tuple variant\"));\n+                    if !self.span.filter_generated(name_span) {\n+                        let span = self.span_from_span(name_span);\n                         let id = ::id_from_node_id(variant.node.data.id(), &self.save_ctxt);\n                         let parent = Some(::id_from_node_id(item.id, &self.save_ctxt));\n \n@@ -731,7 +645,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n                 self.visit_ty(&field.ty);\n             }\n         }\n-        self.process_generic_params(ty_params, item.span, &enum_data.qualname, item.id);\n+        self.process_generic_params(ty_params, &enum_data.qualname, item.id);\n         self.dumper.dump_def(&access, enum_data);\n     }\n \n@@ -755,7 +669,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n         if let &Some(ref trait_ref) = trait_ref {\n             self.process_path(trait_ref.ref_id, &trait_ref.path);\n         }\n-        self.process_generic_params(type_parameters, item.span, \"\", item.id);\n+        self.process_generic_params(type_parameters, \"\", item.id);\n         for impl_item in impl_items {\n             let map = &self.tcx.hir;\n             self.process_impl_item(impl_item, map.local_def_id(item.id));\n@@ -779,10 +693,9 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n             val.push_str(\": \");\n             val.push_str(&bounds_to_string(trait_refs));\n         }\n-        let sub_span = self.span.sub_span_after_keyword(item.span, keywords::Trait);\n-        if !self.span.filter_generated(sub_span, item.span) {\n+        if !self.span.filter_generated(item.ident.span) {\n             let id = ::id_from_node_id(item.id, &self.save_ctxt);\n-            let span = self.span_from_span(sub_span.expect(\"No span found for trait\"));\n+            let span = self.span_from_span(item.ident.span);\n             let children = methods\n                 .iter()\n                 .map(|i| ::id_from_node_id(i.id, &self.save_ctxt))\n@@ -815,21 +728,18 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n \n             let trait_ref = &trait_ref.trait_ref;\n             if let Some(id) = self.lookup_def_id(trait_ref.ref_id) {\n-                let sub_span = self.span.sub_span_for_type_name(trait_ref.path.span);\n-                if !self.span.filter_generated(sub_span, trait_ref.path.span) {\n-                    let span = self.span_from_span(sub_span.expect(\"No span found for trait ref\"));\n+                let sub_span = trait_ref.path.segments.last().unwrap().ident.span;\n+                if !self.span.filter_generated(sub_span) {\n+                    let span = self.span_from_span(sub_span);\n                     self.dumper.dump_ref(Ref {\n                         kind: RefKind::Type,\n-                        span,\n+                        span: span.clone(),\n                         ref_id: ::id_from_def_id(id),\n                     });\n-                }\n \n-                if !self.span.filter_generated(sub_span, trait_ref.path.span) {\n-                    let sub_span = self.span_from_span(sub_span.expect(\"No span for inheritance\"));\n                     self.dumper.dump_relation(Relation {\n                         kind: RelationKind::SuperTrait,\n-                        span: sub_span,\n+                        span,\n                         from: ::id_from_def_id(id),\n                         to: ::id_from_node_id(item.id, &self.save_ctxt),\n                     });\n@@ -838,7 +748,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n         }\n \n         // walk generics and methods\n-        self.process_generic_params(generics, item.span, &qualname, item.id);\n+        self.process_generic_params(generics, &qualname, item.id);\n         for method in methods {\n             let map = &self.tcx.hir;\n             self.process_trait_item(method, map.local_def_id(item.id))\n@@ -891,29 +801,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n             }\n         }\n \n-        // Modules or types in the path prefix.\n-        match self.save_ctxt.get_path_def(id) {\n-            HirDef::Method(did) => {\n-                let ti = self.tcx.associated_item(did);\n-                if ti.kind == ty::AssociatedKind::Method && ti.method_has_self_argument {\n-                    self.write_sub_path_trait_truncated(path);\n-                }\n-            }\n-            HirDef::Fn(..) |\n-            HirDef::Const(..) |\n-            HirDef::Static(..) |\n-            HirDef::StructCtor(..) |\n-            HirDef::VariantCtor(..) |\n-            HirDef::AssociatedConst(..) |\n-            HirDef::Local(..) |\n-            HirDef::Upvar(..) |\n-            HirDef::Struct(..) |\n-            HirDef::Union(..) |\n-            HirDef::Variant(..) |\n-            HirDef::TyAlias(..) |\n-            HirDef::AssociatedTy(..) => self.write_sub_paths_truncated(path),\n-            _ => {}\n-        }\n+        self.write_sub_paths_truncated(path);\n     }\n \n     fn process_struct_lit(\n@@ -924,9 +812,8 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n         variant: &'l ty::VariantDef,\n         base: &'l Option<P<ast::Expr>>,\n     ) {\n-        self.write_sub_paths_truncated(path);\n-\n         if let Some(struct_lit_data) = self.save_ctxt.get_expr_data(ex) {\n+            self.write_sub_paths_truncated(path);\n             down_cast_data!(struct_lit_data, RefData, ex.span);\n             if !generated_code(ex.span) {\n                 self.dumper.dump_ref(struct_lit_data);\n@@ -988,12 +875,10 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n                 };\n                 let variant = adt.variant_of_def(self.save_ctxt.get_path_def(p.id));\n \n-                for &Spanned { node: ref field, span } in fields {\n-                    let sub_span = self.span.span_for_first_ident(span);\n+                for &Spanned { node: ref field, .. } in fields {\n                     if let Some(index) = self.tcx.find_field_index(field.ident, variant) {\n-                        if !self.span.filter_generated(sub_span, span) {\n-                            let span =\n-                                self.span_from_span(sub_span.expect(\"No span fund for var ref\"));\n+                        if !self.span.filter_generated(field.ident.span) {\n+                            let span = self.span_from_span(field.ident.span);\n                             self.dumper.dump_ref(Ref {\n                                 kind: RefKind::Variable,\n                                 span,\n@@ -1034,7 +919,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n                     value.push_str(\": \");\n                     value.push_str(&typ);\n \n-                    if !self.span.filter_generated(Some(ident.span), ident.span) {\n+                    if !self.span.filter_generated(ident.span) {\n                         let qualname = format!(\"{}${}\", ident.to_string(), id);\n                         let id = ::id_from_node_id(id, &self.save_ctxt);\n                         let span = self.span_from_span(ident.span);\n@@ -1109,14 +994,11 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n                 None => String::new(),\n             };\n \n-            // Get the span only for the name of the variable (I hope the path\n-            // is only ever a variable name, but who knows?).\n-            let sub_span = self.span.span_for_last_ident(ident.span);\n             // Rust uses the id of the pattern for var lookups, so we'll use it too.\n-            if !self.span.filter_generated(sub_span, ident.span) {\n+            if !self.span.filter_generated(ident.span) {\n                 let qualname = format!(\"{}${}\", ident.to_string(), id);\n                 let id = ::id_from_node_id(id, &self.save_ctxt);\n-                let span = self.span_from_span(sub_span.expect(\"No span found for variable\"));\n+                let span = self.span_from_span(ident.span);\n \n                 self.dumper.dump_def(\n                     &Access {\n@@ -1190,8 +1072,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n             ast::TraitItemKind::Const(ref ty, ref expr) => {\n                 self.process_assoc_const(\n                     trait_item.id,\n-                    trait_item.ident.name,\n-                    trait_item.span,\n+                    trait_item.ident,\n                     &ty,\n                     expr.as_ref().map(|e| &**e),\n                     trait_id,\n@@ -1214,11 +1095,9 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n                 // FIXME do something with _bounds (for type refs)\n                 let name = trait_item.ident.name.to_string();\n                 let qualname = format!(\"::{}\", self.tcx.node_path_str(trait_item.id));\n-                let sub_span = self.span\n-                    .sub_span_after_keyword(trait_item.span, keywords::Type);\n \n-                if !self.span.filter_generated(sub_span, trait_item.span) {\n-                    let span = self.span_from_span(sub_span.expect(\"No span found for assoc type\"));\n+                if !self.span.filter_generated(trait_item.ident.span) {\n+                    let span = self.span_from_span(trait_item.ident.span);\n                     let id = ::id_from_node_id(trait_item.id, &self.save_ctxt);\n \n                     self.dumper.dump_def(\n@@ -1263,8 +1142,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n             ast::ImplItemKind::Const(ref ty, ref expr) => {\n                 self.process_assoc_const(\n                     impl_item.id,\n-                    impl_item.ident.name,\n-                    impl_item.span,\n+                    impl_item.ident,\n                     &ty,\n                     Some(expr),\n                     impl_id,\n@@ -1328,7 +1206,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n             .map(::id_from_def_id);\n \n         match use_tree.kind {\n-            ast::UseTreeKind::Simple(..) => {\n+            ast::UseTreeKind::Simple(alias, ..) => {\n                 let ident = use_tree.ident();\n                 let path = ast::Path {\n                     segments: prefix.segments\n@@ -1339,24 +1217,22 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n                     span: path.span,\n                 };\n \n-                let sub_span = self.span.span_for_last_ident(path.span);\n-                let alias_span = self.span.sub_span_after_keyword(use_tree.span, keywords::As);\n-                let ref_id = self.lookup_def_id(id);\n-\n-                if !self.span.filter_generated(sub_span, path.span) {\n-                    let span = self.span_from_span(sub_span.expect(\"No span found for use\"));\n-                    let alias_span = alias_span.map(|sp| self.span_from_span(sp));\n+                let sub_span = path.segments.last().unwrap().ident.span;\n+                if !self.span.filter_generated(sub_span) {\n+                    let ref_id = self.lookup_def_id(id).map(|id| ::id_from_def_id(id));\n+                    let alias_span = alias.map(|i| self.span_from_span(i.span));\n+                    let span = self.span_from_span(sub_span);\n                     self.dumper.import(&access, Import {\n                         kind: ImportKind::Use,\n-                        ref_id: ref_id.map(|id| ::id_from_def_id(id)),\n+                        ref_id,\n                         span,\n                         alias_span,\n                         name: ident.to_string(),\n                         value: String::new(),\n                         parent,\n                     });\n+                    self.write_sub_paths_truncated(&path);\n                 }\n-                self.write_sub_paths_truncated(&path);\n             }\n             ast::UseTreeKind::Glob => {\n                 let path = ast::Path {\n@@ -1377,9 +1253,9 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n                     Vec::new()\n                 };\n \n-                let sub_span = self.span.sub_span_of_token(use_tree.span,\n-                                                           token::BinOp(token::Star));\n-                if !self.span.filter_generated(sub_span, use_tree.span) {\n+                let sub_span =\n+                    self.span.sub_span_of_token(use_tree.span, token::BinOp(token::Star));\n+                if !self.span.filter_generated(use_tree.span) {\n                     let span =\n                         self.span_from_span(sub_span.expect(\"No span found for use glob\"));\n                     self.dumper.import(&access, Import {\n@@ -1391,8 +1267,8 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n                         value: names.join(\", \"),\n                         parent,\n                     });\n+                    self.write_sub_paths(&path);\n                 }\n-                self.write_sub_paths(&path);\n             }\n             ast::UseTreeKind::Nested(ref nested_items) => {\n                 let prefix = ast::Path {\n@@ -1471,11 +1347,9 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tc\n                 self.process_use_tree(use_tree, item.id, item, &prefix);\n             }\n             ExternCrate(_) => {\n-                let alias_span = self.span.span_for_last_ident(item.span);\n-\n-                if !self.span.filter_generated(alias_span, item.span) {\n-                    let span =\n-                        self.span_from_span(alias_span.expect(\"No span found for extern crate\"));\n+                let name_span = item.ident.span;\n+                if !self.span.filter_generated(name_span) {\n+                    let span = self.span_from_span(name_span);\n                     let parent = self.save_ctxt.tcx.hir.opt_local_def_id(item.id)\n                         .and_then(|id| self.save_ctxt.tcx.parent_def_id(id))\n                         .map(::id_from_def_id);\n@@ -1518,9 +1392,8 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tc\n             Ty(ref ty, ref ty_params) => {\n                 let qualname = format!(\"::{}\", self.tcx.node_path_str(item.id));\n                 let value = ty_to_string(&ty);\n-                let sub_span = self.span.sub_span_after_keyword(item.span, keywords::Type);\n-                if !self.span.filter_generated(sub_span, item.span) {\n-                    let span = self.span_from_span(sub_span.expect(\"No span found for typedef\"));\n+                if !self.span.filter_generated(item.ident.span) {\n+                    let span = self.span_from_span(item.ident.span);\n                     let id = ::id_from_node_id(item.id, &self.save_ctxt);\n \n                     self.dumper.dump_def(\n@@ -1543,15 +1416,14 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tc\n                 }\n \n                 self.visit_ty(&ty);\n-                self.process_generic_params(ty_params, item.span, &qualname, item.id);\n+                self.process_generic_params(ty_params, &qualname, item.id);\n             }\n             Existential(ref _bounds, ref ty_params) => {\n                 let qualname = format!(\"::{}\", self.tcx.node_path_str(item.id));\n                 // FIXME do something with _bounds\n                 let value = String::new();\n-                let sub_span = self.span.sub_span_after_keyword(item.span, keywords::Type);\n-                if !self.span.filter_generated(sub_span, item.span) {\n-                    let span = self.span_from_span(sub_span.expect(\"No span found for typedef\"));\n+                if !self.span.filter_generated(item.ident.span) {\n+                    let span = self.span_from_span(item.ident.span);\n                     let id = ::id_from_node_id(item.id, &self.save_ctxt);\n \n                     self.dumper.dump_def(\n@@ -1573,7 +1445,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tc\n                     );\n                 }\n \n-                self.process_generic_params(ty_params, item.span, &qualname, item.id);\n+                self.process_generic_params(ty_params, &qualname, item.id);\n             }\n             Mac(_) => (),\n             _ => visit::walk_item(self, item),\n@@ -1606,14 +1478,13 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tc\n                 }\n \n                 if let Some(id) = self.lookup_def_id(t.id) {\n-                    if let Some(sub_span) = self.span.sub_span_for_type_name(t.span) {\n-                        let span = self.span_from_span(sub_span);\n-                        self.dumper.dump_ref(Ref {\n-                            kind: RefKind::Type,\n-                            span,\n-                            ref_id: ::id_from_def_id(id),\n-                        });\n-                    }\n+                    let sub_span = path.segments.last().unwrap().ident.span;\n+                    let span = self.span_from_span(sub_span);\n+                    self.dumper.dump_ref(Ref {\n+                        kind: RefKind::Type,\n+                        span,\n+                        ref_id: ::id_from_def_id(id),\n+                    });\n                 }\n \n                 self.write_sub_paths_truncated(path);\n@@ -1753,11 +1624,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tc\n                 if let Some(fn_data) = self.save_ctxt.get_extern_item_data(item) {\n                     down_cast_data!(fn_data, DefData, item.span);\n \n-                    self.nest_tables(\n-                        item.id,\n-                        |v| v.process_formals(&decl.inputs, &fn_data.qualname),\n-                    );\n-                    self.process_generic_params(generics, item.span, &fn_data.qualname, item.id);\n+                    self.process_generic_params(generics, &fn_data.qualname, item.id);\n                     self.dumper.dump_def(&access, fn_data);\n                 }\n "}, {"sha": "7689406b59a04917ab8d67e0c6063618d8a13987", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 67, "deletions": 98, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/7b0735a832dd49cb482084590eb0f2577955c079/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b0735a832dd49cb482084590eb0f2577955c079/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=7b0735a832dd49cb482084590eb0f2577955c079", "patch": "@@ -57,12 +57,10 @@ use std::env;\n use std::fs::File;\n use std::path::{Path, PathBuf};\n \n-use syntax::ast::{self, Attribute, NodeId, PatKind};\n+use syntax::ast::{self, Attribute, DUMMY_NODE_ID, NodeId, PatKind};\n use syntax::source_map::Spanned;\n use syntax::parse::lexer::comments::strip_doc_comment_decoration;\n-use syntax::parse::token;\n use syntax::print::pprust;\n-use syntax::symbol::keywords;\n use syntax::visit::{self, Visitor};\n use syntax::print::pprust::{arg_to_string, ty_to_string};\n use syntax::source_map::MacroAttribute;\n@@ -162,14 +160,12 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n         let qualname = format!(\"::{}\", self.tcx.node_path_str(item.id));\n         match item.node {\n             ast::ForeignItemKind::Fn(ref decl, ref generics) => {\n-                let sub_span = self.span_utils\n-                    .sub_span_after_keyword(item.span, keywords::Fn);\n-                filter!(self.span_utils, sub_span, item.span, None);\n+                filter!(self.span_utils, item.ident.span);\n \n                 Some(Data::DefData(Def {\n                     kind: DefKind::ForeignFunction,\n                     id: id_from_node_id(item.id, self),\n-                    span: self.span_from_span(sub_span.unwrap()),\n+                    span: self.span_from_span(item.ident.span),\n                     name: item.ident.to_string(),\n                     qualname,\n                     value: make_signature(decl, generics),\n@@ -181,13 +177,11 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     attributes: lower_attributes(item.attrs.clone(), self),\n                 }))\n             }\n-            ast::ForeignItemKind::Static(ref ty, m) => {\n-                let keyword = if m { keywords::Mut } else { keywords::Static };\n-                let sub_span = self.span_utils.sub_span_after_keyword(item.span, keyword);\n-                filter!(self.span_utils, sub_span, item.span, None);\n+            ast::ForeignItemKind::Static(ref ty, _) => {\n+                filter!(self.span_utils, item.ident.span);\n \n                 let id = ::id_from_node_id(item.id, self);\n-                let span = self.span_from_span(sub_span.unwrap());\n+                let span = self.span_from_span(item.ident.span);\n \n                 Some(Data::DefData(Def {\n                     kind: DefKind::ForeignStatic,\n@@ -214,13 +208,11 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n         match item.node {\n             ast::ItemKind::Fn(ref decl, .., ref generics, _) => {\n                 let qualname = format!(\"::{}\", self.tcx.node_path_str(item.id));\n-                let sub_span = self.span_utils\n-                    .sub_span_after_keyword(item.span, keywords::Fn);\n-                filter!(self.span_utils, sub_span, item.span, None);\n+                filter!(self.span_utils, item.ident.span);\n                 Some(Data::DefData(Def {\n                     kind: DefKind::Function,\n                     id: id_from_node_id(item.id, self),\n-                    span: self.span_from_span(sub_span.unwrap()),\n+                    span: self.span_from_span(item.ident.span),\n                     name: item.ident.to_string(),\n                     qualname,\n                     value: make_signature(decl, generics),\n@@ -232,19 +224,13 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     attributes: lower_attributes(item.attrs.clone(), self),\n                 }))\n             }\n-            ast::ItemKind::Static(ref typ, mt, _) => {\n+            ast::ItemKind::Static(ref typ, ..) => {\n                 let qualname = format!(\"::{}\", self.tcx.node_path_str(item.id));\n \n-                let keyword = match mt {\n-                    ast::Mutability::Mutable => keywords::Mut,\n-                    ast::Mutability::Immutable => keywords::Static,\n-                };\n-\n-                let sub_span = self.span_utils.sub_span_after_keyword(item.span, keyword);\n-                filter!(self.span_utils, sub_span, item.span, None);\n+                filter!(self.span_utils, item.ident.span);\n \n                 let id = id_from_node_id(item.id, self);\n-                let span = self.span_from_span(sub_span.unwrap());\n+                let span = self.span_from_span(item.ident.span);\n \n                 Some(Data::DefData(Def {\n                     kind: DefKind::Static,\n@@ -263,12 +249,10 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             }\n             ast::ItemKind::Const(ref typ, _) => {\n                 let qualname = format!(\"::{}\", self.tcx.node_path_str(item.id));\n-                let sub_span = self.span_utils\n-                    .sub_span_after_keyword(item.span, keywords::Const);\n-                filter!(self.span_utils, sub_span, item.span, None);\n+                filter!(self.span_utils, item.ident.span);\n \n                 let id = id_from_node_id(item.id, self);\n-                let span = self.span_from_span(sub_span.unwrap());\n+                let span = self.span_from_span(item.ident.span);\n \n                 Some(Data::DefData(Def {\n                     kind: DefKind::Const,\n@@ -291,16 +275,14 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                 let cm = self.tcx.sess.source_map();\n                 let filename = cm.span_to_filename(m.inner);\n \n-                let sub_span = self.span_utils\n-                    .sub_span_after_keyword(item.span, keywords::Mod);\n-                filter!(self.span_utils, sub_span, item.span, None);\n+                filter!(self.span_utils, item.ident.span);\n \n                 Some(Data::DefData(Def {\n                     kind: DefKind::Mod,\n                     id: id_from_node_id(item.id, self),\n                     name: item.ident.to_string(),\n                     qualname,\n-                    span: self.span_from_span(sub_span.unwrap()),\n+                    span: self.span_from_span(item.ident.span),\n                     value: filename.to_string(),\n                     parent: None,\n                     children: m.items\n@@ -316,9 +298,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             ast::ItemKind::Enum(ref def, _) => {\n                 let name = item.ident.to_string();\n                 let qualname = format!(\"::{}\", self.tcx.node_path_str(item.id));\n-                let sub_span = self.span_utils\n-                    .sub_span_after_keyword(item.span, keywords::Enum);\n-                filter!(self.span_utils, sub_span, item.span, None);\n+                filter!(self.span_utils, item.ident.span);\n                 let variants_str = def.variants\n                     .iter()\n                     .map(|v| v.node.ident.to_string())\n@@ -328,7 +308,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                 Some(Data::DefData(Def {\n                     kind: DefKind::Enum,\n                     id: id_from_node_id(item.id, self),\n-                    span: self.span_from_span(sub_span.unwrap()),\n+                    span: self.span_from_span(item.ident.span),\n                     name,\n                     qualname,\n                     value,\n@@ -349,11 +329,11 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     if generated_code(path.span) {\n                         return None;\n                     }\n-                    let sub_span = self.span_utils.sub_span_for_type_name(path.span);\n-                    filter!(self.span_utils, sub_span, typ.span, None);\n+                    let sub_span = path.segments.last().unwrap().ident.span;\n+                    filter!(self.span_utils, sub_span);\n \n                     let impl_id = self.next_impl_id();\n-                    let span = self.span_from_span(sub_span.unwrap());\n+                    let span = self.span_from_span(sub_span);\n \n                     let type_data = self.lookup_ref_id(typ.id);\n                     type_data.map(|type_data| {\n@@ -402,15 +382,13 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n         if let Some(ident) = field.ident {\n             let name = ident.to_string();\n             let qualname = format!(\"::{}::{}\", self.tcx.node_path_str(scope), ident);\n-            let sub_span = self.span_utils\n-                .sub_span_before_token(field.span, token::Colon);\n-            filter!(self.span_utils, sub_span, field.span, None);\n+            filter!(self.span_utils, ident.span);\n             let def_id = self.tcx.hir.local_def_id(field.id);\n             let typ = self.tcx.type_of(def_id).to_string();\n \n \n             let id = id_from_node_id(field.id, self);\n-            let span = self.span_from_span(sub_span.unwrap());\n+            let span = self.span_from_span(ident.span);\n \n             Some(Def {\n                 kind: DefKind::Field,\n@@ -433,7 +411,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n \n     // FIXME would be nice to take a MethodItem here, but the ast provides both\n     // trait and impl flavours, so the caller must do the disassembly.\n-    pub fn get_method_data(&self, id: ast::NodeId, name: ast::Name, span: Span) -> Option<Def> {\n+    pub fn get_method_data(&self, id: ast::NodeId, ident: ast::Ident, span: Span) -> Option<Def> {\n         // The qualname for a method is the trait name or name of the struct in an impl in\n         // which the method is declared in, followed by the method's name.\n         let (qualname, parent_scope, decl_id, docs, attributes) =\n@@ -459,7 +437,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                                 qualname.push_str(&self.tcx.item_path_str(def_id));\n                                 self.tcx\n                                     .associated_items(def_id)\n-                                    .find(|item| item.ident.name == name)\n+                                    .find(|item| item.ident.name == ident.name)\n                                     .map(|item| decl_id = Some(item.def_id));\n                             }\n                             qualname.push_str(\">\");\n@@ -512,16 +490,15 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                 },\n             };\n \n-        let qualname = format!(\"{}::{}\", qualname, name);\n+        let qualname = format!(\"{}::{}\", qualname, ident.name);\n \n-        let sub_span = self.span_utils.sub_span_after_keyword(span, keywords::Fn);\n-        filter!(self.span_utils, sub_span, span, None);\n+        filter!(self.span_utils, ident.span);\n \n         Some(Def {\n             kind: DefKind::Method,\n             id: id_from_node_id(id, self),\n-            span: self.span_from_span(sub_span.unwrap()),\n-            name: name.to_string(),\n+            span: self.span_from_span(ident.span),\n+            name: ident.name.to_string(),\n             qualname,\n             // FIXME you get better data here by using the visitor.\n             value: String::new(),\n@@ -540,9 +517,9 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             if generated_code(span) {\n                 return None;\n             }\n-            let sub_span = self.span_utils.sub_span_for_type_name(span).or(Some(span));\n-            filter!(self.span_utils, sub_span, span, None);\n-            let span = self.span_from_span(sub_span.unwrap());\n+            let sub_span = trait_ref.path.segments.last().unwrap().ident.span;\n+            filter!(self.span_utils, sub_span);\n+            let span = self.span_from_span(sub_span);\n             Some(Ref {\n                 kind: RefKind::Type,\n                 span,\n@@ -574,9 +551,8 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     ty::Adt(def, _) if !def.is_enum() => {\n                         let variant = &def.non_enum_variant();\n                         let index = self.tcx.find_field_index(ident, variant).unwrap();\n-                        let sub_span = self.span_utils.span_for_last_ident(expr.span);\n-                        filter!(self.span_utils, sub_span, expr.span, None);\n-                        let span = self.span_from_span(sub_span.unwrap());\n+                        filter!(self.span_utils, ident.span);\n+                        let span = self.span_from_span(ident.span);\n                         return Some(Data::RefData(Ref {\n                             kind: RefKind::Variable,\n                             span,\n@@ -593,9 +569,9 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             ast::ExprKind::Struct(ref path, ..) => {\n                 match self.tables.expr_ty_adjusted(&hir_node).sty {\n                     ty::Adt(def, _) if !def.is_enum() => {\n-                        let sub_span = self.span_utils.span_for_last_ident(path.span);\n-                        filter!(self.span_utils, sub_span, path.span, None);\n-                        let span = self.span_from_span(sub_span.unwrap());\n+                        let sub_span = path.segments.last().unwrap().ident.span;\n+                        filter!(self.span_utils, sub_span);\n+                        let span = self.span_from_span(sub_span);\n                         Some(Data::RefData(Ref {\n                             kind: RefKind::Type,\n                             span,\n@@ -624,7 +600,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     ty::TraitContainer(_) => (None, Some(method_id)),\n                 };\n                 let sub_span = seg.ident.span;\n-                filter!(self.span_utils, Some(sub_span), expr.span, None);\n+                filter!(self.span_utils, sub_span);\n                 let span = self.span_from_span(sub_span);\n                 Some(Data::RefData(Ref {\n                     kind: RefKind::Function,\n@@ -656,6 +632,10 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             Node::Visibility(&Spanned {\n                 node: hir::VisibilityKind::Restricted { ref path, .. }, .. }) => path.def,\n \n+            Node::PathSegment(seg) => match seg.def {\n+                Some(def) => def,\n+                None => HirDef::Err,\n+            },\n             Node::Expr(&hir::Expr {\n                 node: hir::ExprKind::Struct(ref qpath, ..),\n                 ..\n@@ -708,31 +688,32 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n         }\n     }\n \n-    pub fn get_path_data(&self, id: NodeId, path: &ast::Path) -> Option<Ref> {\n+    pub fn get_path_data(&self, _id: NodeId, path: &ast::Path) -> Option<Ref> {\n+        path.segments.last().and_then(|seg| self.get_path_segment_data(seg))\n+    }\n+\n+    pub fn get_path_segment_data(&self, path_seg: &ast::PathSegment) -> Option<Ref> {\n         // Returns true if the path is function type sugar, e.g., `Fn(A) -> B`.\n-        fn fn_type(path: &ast::Path) -> bool {\n-            if path.segments.len() != 1 {\n-                return false;\n-            }\n-            if let Some(ref generic_args) = path.segments[0].args {\n+        fn fn_type(seg: &ast::PathSegment) -> bool {\n+            if let Some(ref generic_args) = seg.args {\n                 if let ast::GenericArgs::Parenthesized(_) = **generic_args {\n                     return true;\n                 }\n             }\n             false\n         }\n \n-        if path.segments.is_empty() {\n+        if path_seg.id == DUMMY_NODE_ID {\n             return None;\n         }\n \n-        let def = self.get_path_def(id);\n-        let last_seg = &path.segments[path.segments.len() - 1];\n-        let sub_span = last_seg.ident.span;\n-        filter!(self.span_utils, Some(sub_span), path.span, None);\n+        let def = self.get_path_def(path_seg.id);\n+        let span = path_seg.ident.span;\n+        filter!(self.span_utils, span);\n+        let span = self.span_from_span(span);\n+\n         match def {\n             HirDef::Upvar(id, ..) | HirDef::Local(id) => {\n-                let span = self.span_from_span(sub_span);\n                 Some(Ref {\n                     kind: RefKind::Variable,\n                     span,\n@@ -743,23 +724,17 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             HirDef::Const(..) |\n             HirDef::AssociatedConst(..) |\n             HirDef::VariantCtor(..) => {\n-                let span = self.span_from_span(sub_span);\n                 Some(Ref {\n                     kind: RefKind::Variable,\n                     span,\n                     ref_id: id_from_def_id(def.def_id()),\n                 })\n             }\n-            HirDef::Trait(def_id) if fn_type(path) => {\n-                // Function type bounds are desugared in the parser, so we have to\n-                // special case them here.\n-                let fn_span = self.span_utils.span_for_first_ident(path.span);\n-                fn_span.map(|span| {\n-                    Ref {\n-                        kind: RefKind::Type,\n-                        span: self.span_from_span(span),\n-                        ref_id: id_from_def_id(def_id),\n-                    }\n+            HirDef::Trait(def_id) if fn_type(path_seg) => {\n+                Some(Ref {\n+                    kind: RefKind::Type,\n+                    span,\n+                    ref_id: id_from_def_id(def_id),\n                 })\n             }\n             HirDef::Struct(def_id) |\n@@ -774,7 +749,6 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             HirDef::Trait(def_id) |\n             HirDef::Existential(def_id) |\n             HirDef::TyParam(def_id) => {\n-                let span = self.span_from_span(sub_span);\n                 Some(Ref {\n                     kind: RefKind::Type,\n                     span,\n@@ -785,7 +759,6 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                 // This is a reference to a tuple struct where the def_id points\n                 // to an invisible constructor function. That is not a very useful\n                 // def, so adjust to point to the tuple struct itself.\n-                let span = self.span_from_span(sub_span);\n                 let parent_def_id = self.tcx.parent_def_id(def_id).unwrap();\n                 Some(Ref {\n                     kind: RefKind::Type,\n@@ -804,23 +777,20 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                 } else {\n                     None\n                 };\n-                let span = self.span_from_span(sub_span);\n                 Some(Ref {\n                     kind: RefKind::Function,\n                     span,\n                     ref_id: id_from_def_id(def_id.unwrap_or(decl_id)),\n                 })\n             }\n             HirDef::Fn(def_id) => {\n-                let span = self.span_from_span(sub_span);\n                 Some(Ref {\n                     kind: RefKind::Function,\n                     span,\n                     ref_id: id_from_def_id(def_id),\n                 })\n             }\n             HirDef::Mod(def_id) => {\n-                let span = self.span_from_span(sub_span);\n                 Some(Ref {\n                     kind: RefKind::Mod,\n                     span,\n@@ -843,15 +813,14 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n         field_ref: &ast::Field,\n         variant: &ty::VariantDef,\n     ) -> Option<Ref> {\n-        let index = self.tcx.find_field_index(field_ref.ident, variant).unwrap();\n-        // We don't really need a sub-span here, but no harm done\n-        let sub_span = self.span_utils.span_for_last_ident(field_ref.ident.span);\n-        filter!(self.span_utils, sub_span, field_ref.ident.span, None);\n-        let span = self.span_from_span(sub_span.unwrap());\n-        Some(Ref {\n-            kind: RefKind::Variable,\n-            span,\n-            ref_id: id_from_def_id(variant.fields[index].did),\n+        filter!(self.span_utils, field_ref.ident.span);\n+        self.tcx.find_field_index(field_ref.ident, variant).map(|index| {\n+            let span = self.span_from_span(field_ref.ident.span);\n+            Ref {\n+                kind: RefKind::Variable,\n+                span,\n+                ref_id: id_from_def_id(variant.fields[index].did),\n+            }\n         })\n     }\n "}, {"sha": "902353da13f76072b14da48ef182521dcd23c1fd", "filename": "src/librustc_save_analysis/span_utils.rs", "status": "modified", "additions": 11, "deletions": 173, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/7b0735a832dd49cb482084590eb0f2577955c079/src%2Flibrustc_save_analysis%2Fspan_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b0735a832dd49cb482084590eb0f2577955c079/src%2Flibrustc_save_analysis%2Fspan_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fspan_utils.rs?ref=7b0735a832dd49cb482084590eb0f2577955c079", "patch": "@@ -16,7 +16,6 @@ use std::cell::Cell;\n \n use syntax::parse::lexer::{self, StringReader};\n use syntax::parse::token::{self, Token};\n-use syntax::symbol::keywords;\n use syntax_pos::*;\n \n #[derive(Clone)]\n@@ -67,131 +66,6 @@ impl<'a> SpanUtils<'a> {\n         lexer::StringReader::retokenize(&self.sess.parse_sess, span)\n     }\n \n-    // Re-parses a path and returns the span for the last identifier in the path\n-    pub fn span_for_last_ident(&self, span: Span) -> Option<Span> {\n-        let mut result = None;\n-\n-        let mut toks = self.retokenise_span(span);\n-        let mut bracket_count = 0;\n-        loop {\n-            let ts = toks.real_token();\n-            if ts.tok == token::Eof {\n-                return result;\n-            }\n-            if bracket_count == 0 && (ts.tok.is_ident() || ts.tok.is_keyword(keywords::SelfValue)) {\n-                result = Some(ts.sp);\n-            }\n-\n-            bracket_count += match ts.tok {\n-                token::Lt => 1,\n-                token::Gt => -1,\n-                token::BinOp(token::Shr) => -2,\n-                _ => 0,\n-            }\n-        }\n-    }\n-\n-    // Return the span for the first identifier in the path.\n-    pub fn span_for_first_ident(&self, span: Span) -> Option<Span> {\n-        let mut toks = self.retokenise_span(span);\n-        let mut bracket_count = 0;\n-        loop {\n-            let ts = toks.real_token();\n-            if ts.tok == token::Eof {\n-                return None;\n-            }\n-            if bracket_count == 0 && (ts.tok.is_ident() || ts.tok.is_keyword(keywords::SelfValue)) {\n-                return Some(ts.sp);\n-            }\n-\n-            bracket_count += match ts.tok {\n-                token::Lt => 1,\n-                token::Gt => -1,\n-                token::BinOp(token::Shr) => -2,\n-                _ => 0,\n-            }\n-        }\n-    }\n-\n-    // Return the span for the last ident before a `<` and outside any\n-    // angle brackets, or the last span.\n-    pub fn sub_span_for_type_name(&self, span: Span) -> Option<Span> {\n-        let mut toks = self.retokenise_span(span);\n-        let mut prev = toks.real_token();\n-        let mut result = None;\n-\n-        // We keep track of the following two counts - the depth of nesting of\n-        // angle brackets, and the depth of nesting of square brackets. For the\n-        // angle bracket count, we only count tokens which occur outside of any\n-        // square brackets (i.e. bracket_count == 0). The intuition here is\n-        // that we want to count angle brackets in the type, but not any which\n-        // could be in expression context (because these could mean 'less than',\n-        // etc.).\n-        let mut angle_count = 0;\n-        let mut bracket_count = 0;\n-        loop {\n-            let next = toks.real_token();\n-\n-            if (next.tok == token::Lt || next.tok == token::Colon) && angle_count == 0\n-                && bracket_count == 0 && prev.tok.is_ident()\n-            {\n-                result = Some(prev.sp);\n-            }\n-\n-            if bracket_count == 0 {\n-                angle_count += match prev.tok {\n-                    token::Lt => 1,\n-                    token::Gt => -1,\n-                    token::BinOp(token::Shl) => 2,\n-                    token::BinOp(token::Shr) => -2,\n-                    _ => 0,\n-                };\n-            }\n-\n-            bracket_count += match prev.tok {\n-                token::OpenDelim(token::Bracket) => 1,\n-                token::CloseDelim(token::Bracket) => -1,\n-                _ => 0,\n-            };\n-\n-            if next.tok == token::Eof {\n-                break;\n-            }\n-            prev = next;\n-        }\n-        #[cfg(debug_assertions)] {\n-            if angle_count != 0 || bracket_count != 0 {\n-                let loc = self.sess.source_map().lookup_char_pos(span.lo());\n-                span_bug!(\n-                    span,\n-                    \"Mis-counted brackets when breaking path? Parsing '{}' in {}, line {}\",\n-                    self.snippet(span),\n-                    loc.file.name,\n-                    loc.line\n-                );\n-            }\n-        }\n-        if result.is_none() && prev.tok.is_ident() {\n-            return Some(prev.sp);\n-        }\n-        result\n-    }\n-\n-    pub fn sub_span_before_token(&self, span: Span, tok: Token) -> Option<Span> {\n-        let mut toks = self.retokenise_span(span);\n-        let mut prev = toks.real_token();\n-        loop {\n-            if prev.tok == token::Eof {\n-                return None;\n-            }\n-            let next = toks.real_token();\n-            if next.tok == tok {\n-                return Some(prev.sp);\n-            }\n-            prev = next;\n-        }\n-    }\n-\n     pub fn sub_span_of_token(&self, span: Span, tok: Token) -> Option<Span> {\n         let mut toks = self.retokenise_span(span);\n         loop {\n@@ -205,28 +79,6 @@ impl<'a> SpanUtils<'a> {\n         }\n     }\n \n-    pub fn sub_span_after_keyword(&self, span: Span, keyword: keywords::Keyword) -> Option<Span> {\n-        self.sub_span_after(span, |t| t.is_keyword(keyword))\n-    }\n-\n-    fn sub_span_after<F: Fn(Token) -> bool>(&self, span: Span, f: F) -> Option<Span> {\n-        let mut toks = self.retokenise_span(span);\n-        loop {\n-            let ts = toks.real_token();\n-            if ts.tok == token::Eof {\n-                return None;\n-            }\n-            if f(ts.tok) {\n-                let ts = toks.real_token();\n-                if ts.tok == token::Eof {\n-                    return None;\n-                } else {\n-                    return Some(ts.sp);\n-                }\n-            }\n-        }\n-    }\n-\n     // // Return the name for a macro definition (identifier after first `!`)\n     // pub fn span_for_macro_def_name(&self, span: Span) -> Option<Span> {\n     //     let mut toks = self.retokenise_span(span);\n@@ -271,42 +123,28 @@ impl<'a> SpanUtils<'a> {\n     ///\n     /// Used to filter out spans of minimal value,\n     /// such as references to macro internal variables.\n-    pub fn filter_generated(&self, sub_span: Option<Span>, parent: Span) -> bool {\n-        if !generated_code(parent) {\n-            // Edge case - this occurs on generated code with incorrect expansion info.\n-            return sub_span.is_none()\n+    pub fn filter_generated(&self, span: Span) -> bool {\n+        if span.is_dummy() {\n+            return true;\n+        }\n+\n+        if !generated_code(span) {\n+            return false;\n         }\n-        // If sub_span is none, filter out generated code.\n-        let sub_span = match sub_span {\n-            Some(ss) => ss,\n-            None => return true,\n-        };\n \n         //If the span comes from a fake source_file, filter it.\n-        if !self.sess\n+        !self.sess\n             .source_map()\n-            .lookup_char_pos(parent.lo())\n+            .lookup_char_pos(span.lo())\n             .file\n             .is_real_file()\n-        {\n-            return true;\n-        }\n-\n-        // Otherwise, a generated span is deemed invalid if it is not a sub-span of the root\n-        // callsite. This filters out macro internal variables and most malformed spans.\n-        !parent.source_callsite().contains(sub_span)\n     }\n }\n \n macro_rules! filter {\n-    ($util: expr, $span: expr, $parent: expr, None) => {\n-        if $util.filter_generated($span, $parent) {\n+    ($util: expr, $parent: expr) => {\n+        if $util.filter_generated($parent) {\n             return None;\n         }\n     };\n-    ($util: expr, $span: ident, $parent: expr) => {\n-        if $util.filter_generated($span, $parent) {\n-            return;\n-        }\n-    };\n }"}, {"sha": "9b2720717c9b391aaa0e33eda84b84a11db520d3", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b0735a832dd49cb482084590eb0f2577955c079/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b0735a832dd49cb482084590eb0f2577955c079/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=7b0735a832dd49cb482084590eb0f2577955c079", "patch": "@@ -4012,6 +4012,8 @@ where F: Fn(DefId) -> Def {\n         def: def_ctor(def_id),\n         segments: hir::HirVec::from_vec(apb.names.iter().map(|s| hir::PathSegment {\n             ident: ast::Ident::from_str(&s),\n+            id: None,\n+            def: None,\n             args: None,\n             infer_types: false,\n         }).collect())"}, {"sha": "d6b0127e44d019e02faf3de39f5b359b9808b9c6", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b0735a832dd49cb482084590eb0f2577955c079/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b0735a832dd49cb482084590eb0f2577955c079/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=7b0735a832dd49cb482084590eb0f2577955c079", "patch": "@@ -186,6 +186,8 @@ impl<'a, 'tcx, 'rcx, 'cstore> DocContext<'a, 'tcx, 'rcx, 'cstore> {\n \n         segments.push(hir::PathSegment::new(\n             real_name.unwrap_or(last.ident),\n+            None,\n+            None,\n             self.generics_to_path_params(generics.clone()),\n             false,\n         ));"}, {"sha": "ee82b9860058a1fd1b68db5581aa84957d93871e", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7b0735a832dd49cb482084590eb0f2577955c079/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b0735a832dd49cb482084590eb0f2577955c079/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=7b0735a832dd49cb482084590eb0f2577955c079", "patch": "@@ -129,6 +129,8 @@ pub struct PathSegment {\n     /// The identifier portion of this path segment.\n     pub ident: Ident,\n \n+    pub id: NodeId,\n+\n     /// Type/lifetime parameters attached to this path. They come in\n     /// two flavors: `Path<A,B,C>` and `Path(A,B) -> C`.\n     /// `None` means that no parameter list is supplied (`Path`),\n@@ -140,7 +142,7 @@ pub struct PathSegment {\n \n impl PathSegment {\n     pub fn from_ident(ident: Ident) -> Self {\n-        PathSegment { ident, args: None }\n+        PathSegment { ident, id: DUMMY_NODE_ID, args: None }\n     }\n     pub fn crate_root(span: Span) -> Self {\n         PathSegment::from_ident(Ident::new(keywords::CrateRoot.name(), span))"}, {"sha": "7928ec1606b1d5b986db8f9a7df31474016d851d", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7b0735a832dd49cb482084590eb0f2577955c079/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b0735a832dd49cb482084590eb0f2577955c079/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=7b0735a832dd49cb482084590eb0f2577955c079", "patch": "@@ -329,7 +329,11 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         } else {\n             None\n         };\n-        segments.push(ast::PathSegment { ident: last_ident.with_span_pos(span), args });\n+        segments.push(ast::PathSegment {\n+            ident: last_ident.with_span_pos(span),\n+            id: ast::DUMMY_NODE_ID,\n+            args,\n+        });\n         let mut path = ast::Path { span, segments };\n         if global {\n             if let Some(seg) = path.make_root() {\n@@ -366,7 +370,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         } else {\n             None\n         };\n-        path.segments.push(ast::PathSegment { ident, args });\n+        path.segments.push(ast::PathSegment { ident, id: ast::DUMMY_NODE_ID, args });\n \n         (ast::QSelf {\n             ty: self_type,"}, {"sha": "bec193548e176389edb161ce37aad598fb831653", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7b0735a832dd49cb482084590eb0f2577955c079/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b0735a832dd49cb482084590eb0f2577955c079/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=7b0735a832dd49cb482084590eb0f2577955c079", "patch": "@@ -468,8 +468,9 @@ pub fn noop_fold_usize<T: Folder>(i: usize, _: &mut T) -> usize {\n \n pub fn noop_fold_path<T: Folder>(Path { segments, span }: Path, fld: &mut T) -> Path {\n     Path {\n-        segments: segments.move_map(|PathSegment { ident, args }| PathSegment {\n+        segments: segments.move_map(|PathSegment { ident, id, args }| PathSegment {\n             ident: fld.fold_ident(ident),\n+            id: fld.new_id(id),\n             args: args.map(|args| args.map(|args| fld.fold_generic_args(args))),\n         }),\n         span: fld.new_span(span)\n@@ -1234,6 +1235,7 @@ pub fn noop_fold_expr<T: Folder>(Expr {id, node, span, attrs}: Expr, folder: &mu\n                 ExprKind::MethodCall(\n                     PathSegment {\n                         ident: folder.fold_ident(seg.ident),\n+                        id: folder.new_id(seg.id),\n                         args: seg.args.map(|args| {\n                             args.map(|args| folder.fold_generic_args(args))\n                         }),"}, {"sha": "589b3e30fcfbc41bbd24a258f4f70bd969e5a60a", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b0735a832dd49cb482084590eb0f2577955c079/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b0735a832dd49cb482084590eb0f2577955c079/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=7b0735a832dd49cb482084590eb0f2577955c079", "patch": "@@ -2134,7 +2134,7 @@ impl<'a> Parser<'a> {\n                 ParenthesisedArgs { inputs, output, span }.into()\n             };\n \n-            PathSegment { ident, args }\n+            PathSegment { ident, args, id: ast::DUMMY_NODE_ID }\n         } else {\n             // Generic arguments are not found.\n             PathSegment::from_ident(ident)"}, {"sha": "85d1f3df05b1d2a1c49f0ea50eab1f11c05bd637", "filename": "src/test/incremental/hashes/closure_expressions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b0735a832dd49cb482084590eb0f2577955c079/src%2Ftest%2Fincremental%2Fhashes%2Fclosure_expressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b0735a832dd49cb482084590eb0f2577955c079/src%2Ftest%2Fincremental%2Fhashes%2Fclosure_expressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fclosure_expressions.rs?ref=7b0735a832dd49cb482084590eb0f2577955c079", "patch": "@@ -95,7 +95,7 @@ pub fn add_type_ascription_to_parameter() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, TypeckTables\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, MirValidated, TypeckTables\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn add_type_ascription_to_parameter() {\n     let closure = |x: u32| x + 1u32;"}, {"sha": "dd1c2bd51260b066f2942a2f519165f6722b3caf", "filename": "src/test/mir-opt/end_region_1.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7b0735a832dd49cb482084590eb0f2577955c079/src%2Ftest%2Fmir-opt%2Fend_region_1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b0735a832dd49cb482084590eb0f2577955c079/src%2Ftest%2Fmir-opt%2Fend_region_1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_1.rs?ref=7b0735a832dd49cb482084590eb0f2577955c079", "patch": "@@ -22,7 +22,7 @@ fn main() {\n // START rustc.main.SimplifyCfg-qualify-consts.after.mir\n //     let mut _0: ();\n //     ...\n-//     let _2: &'10_1rs i32;\n+//     let _2: &'11_1rs i32;\n //     ...\n //     let _1: i32;\n //     ...\n@@ -31,10 +31,10 @@ fn main() {\n //         _1 = const 3i32;\n //         FakeRead(ForLet, _1);\n //         StorageLive(_2);\n-//         _2 = &'10_1rs _1;\n+//         _2 = &'11_1rs _1;\n //         FakeRead(ForLet, _2);\n //         _0 = ();\n-//         EndRegion('10_1rs);\n+//         EndRegion('11_1rs);\n //         StorageDead(_2);\n //         StorageDead(_1);\n //         return;"}, {"sha": "6b0a28b8110073c9eac5bd5a7e48a2b4dd31973d", "filename": "src/test/mir-opt/end_region_2.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7b0735a832dd49cb482084590eb0f2577955c079/src%2Ftest%2Fmir-opt%2Fend_region_2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b0735a832dd49cb482084590eb0f2577955c079/src%2Ftest%2Fmir-opt%2Fend_region_2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_2.rs?ref=7b0735a832dd49cb482084590eb0f2577955c079", "patch": "@@ -27,9 +27,9 @@ fn main() {\n // START rustc.main.SimplifyCfg-qualify-consts.after.mir\n //     let mut _0: ();\n //     ...\n-//     let _7: &'23_3rs bool;\n+//     let _7: &'26_3rs bool;\n //     ...\n-//     let _3: &'23_1rs bool;\n+//     let _3: &'26_1rs bool;\n //     ...\n //     let _2: bool;\n //     ...\n@@ -47,7 +47,7 @@ fn main() {\n //         _2 = const true;\n //         FakeRead(ForLet, _2);\n //         StorageLive(_3);\n-//         _3 = &'23_1rs _2;\n+//         _3 = &'26_1rs _2;\n //         FakeRead(ForLet, _3);\n //         StorageLive(_5);\n //         _5 = _2;\n@@ -59,7 +59,7 @@ fn main() {\n //     bb4: {\n //         _0 = ();\n //         StorageDead(_5);\n-//         EndRegion('23_1rs);\n+//         EndRegion('26_1rs);\n //         StorageDead(_3);\n //         StorageDead(_2);\n //         return;\n@@ -68,12 +68,12 @@ fn main() {\n //         _4 = ();\n //         StorageDead(_5);\n //         StorageLive(_7);\n-//         _7 = &'23_3rs _2;\n+//         _7 = &'26_3rs _2;\n //         FakeRead(ForLet, _7);\n //         _1 = ();\n-//         EndRegion('23_3rs);\n+//         EndRegion('26_3rs);\n //         StorageDead(_7);\n-//         EndRegion('23_1rs);\n+//         EndRegion('26_1rs);\n //         StorageDead(_3);\n //         StorageDead(_2);\n //         goto -> bb1;"}, {"sha": "d8d48358e53fc27fb98a708dbeae316a480d7f5c", "filename": "src/test/mir-opt/end_region_3.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7b0735a832dd49cb482084590eb0f2577955c079/src%2Ftest%2Fmir-opt%2Fend_region_3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b0735a832dd49cb482084590eb0f2577955c079/src%2Ftest%2Fmir-opt%2Fend_region_3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_3.rs?ref=7b0735a832dd49cb482084590eb0f2577955c079", "patch": "@@ -28,9 +28,9 @@ fn main() {\n // START rustc.main.SimplifyCfg-qualify-consts.after.mir\n //     let mut _0: ();\n //     ...\n-//     let _7: &'26_3rs bool;\n+//     let _7: &'30_3rs bool;\n //     ...\n-//     let _3: &'26_1rs bool;\n+//     let _3: &'30_1rs bool;\n //     ...\n //     let mut _1: bool;\n //     ...\n@@ -48,7 +48,7 @@ fn main() {\n //     bb2: {\n //         _1 = const true;\n //         StorageLive(_3);\n-//         _3 = &'26_1rs _1;\n+//         _3 = &'30_1rs _1;\n //         FakeRead(ForLet, _3);\n //         StorageLive(_5);\n //         _5 = _1;\n@@ -60,7 +60,7 @@ fn main() {\n //     bb4: {\n //         _0 = ();\n //         StorageDead(_5);\n-//         EndRegion('26_1rs);\n+//         EndRegion('30_1rs);\n //         StorageDead(_3);\n //         StorageDead(_1);\n //         return;\n@@ -69,12 +69,12 @@ fn main() {\n //         _4 = ();\n //         StorageDead(_5);\n //         StorageLive(_7);\n-//         _7 = &'26_3rs _1;\n+//         _7 = &'30_3rs _1;\n //         FakeRead(ForLet, _7);\n //         _2 = ();\n-//         EndRegion('26_3rs);\n+//         EndRegion('30_3rs);\n //         StorageDead(_7);\n-//         EndRegion('26_1rs);\n+//         EndRegion('30_1rs);\n //         StorageDead(_3);\n //         goto -> bb1;\n //     }"}, {"sha": "359ed07a9c0953466257eb38bfef40fd4818f624", "filename": "src/test/mir-opt/end_region_4.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7b0735a832dd49cb482084590eb0f2577955c079/src%2Ftest%2Fmir-opt%2Fend_region_4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b0735a832dd49cb482084590eb0f2577955c079/src%2Ftest%2Fmir-opt%2Fend_region_4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_4.rs?ref=7b0735a832dd49cb482084590eb0f2577955c079", "patch": "@@ -32,9 +32,9 @@ fn foo(i: i32) {\n // START rustc.main.SimplifyCfg-qualify-consts.after.mir\n //     let mut _0: ();\n //     ...\n-//     let _6: &'26_4rs i32;\n+//     let _6: &'31_4rs i32;\n //     ...\n-//     let _3: &'26_2rs i32;\n+//     let _3: &'31_2rs i32;\n //     ...\n //     let _2: i32;\n //     ...\n@@ -50,7 +50,7 @@ fn foo(i: i32) {\n //         _2 = const 0i32;\n //         FakeRead(ForLet, _2);\n //         StorageLive(_3);\n-//         _3 = &'26_2rs _2;\n+//         _3 = &'31_2rs _2;\n //         FakeRead(ForLet, _3);\n //         StorageLive(_5);\n //         _5 = (*_3);\n@@ -62,18 +62,18 @@ fn foo(i: i32) {\n //     bb2: {\n //         StorageDead(_5);\n //         StorageLive(_6);\n-//         _6 = &'26_4rs _2;\n+//         _6 = &'31_4rs _2;\n //         FakeRead(ForLet, _6);\n //         _0 = ();\n-//         EndRegion('26_4rs);\n+//         EndRegion('31_4rs);\n //         StorageDead(_6);\n-//         EndRegion('26_2rs);\n+//         EndRegion('31_2rs);\n //         StorageDead(_3);\n //         StorageDead(_2);\n //         drop(_1) -> [return: bb4, unwind: bb1];\n //     }\n //     bb3: {\n-//         EndRegion('26_2rs);\n+//         EndRegion('31_2rs);\n //         drop(_1) -> bb1;\n //     }\n //     bb4: {"}, {"sha": "3b632e198cd669dbef85b63062c888eee7a31b9d", "filename": "src/test/mir-opt/end_region_5.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7b0735a832dd49cb482084590eb0f2577955c079/src%2Ftest%2Fmir-opt%2Fend_region_5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b0735a832dd49cb482084590eb0f2577955c079/src%2Ftest%2Fmir-opt%2Fend_region_5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_5.rs?ref=7b0735a832dd49cb482084590eb0f2577955c079", "patch": "@@ -33,30 +33,30 @@ fn foo<F>(f: F) where F: FnOnce() -> i32 {\n //     let _1: D;\n //     ...\n //     let mut _2: ();\n-//     let mut _3: [closure@NodeId(18) d:&'14s D];\n-//     let mut _4: &'14s D;\n+//     let mut _3: [closure@NodeId(28) d:&'18s D];\n+//     let mut _4: &'18s D;\n //     bb0: {\n //         StorageLive(_1);\n //         _1 = D::{{constructor}}(const 0i32,);\n //         FakeRead(ForLet, _1);\n //         StorageLive(_3);\n //         StorageLive(_4);\n-//         _4 = &'14s _1;\n-//         _3 = [closure@NodeId(18)] { d: move _4 };\n+//         _4 = &'18s _1;\n+//         _3 = [closure@NodeId(28)] { d: move _4 };\n //         StorageDead(_4);\n //         _2 = const foo(move _3) -> [return: bb2, unwind: bb3];\n //     }\n //     bb1: {\n //         resume;\n //     }\n //     bb2: {\n-//         EndRegion('14s);\n+//         EndRegion('18s);\n //         StorageDead(_3);\n //         _0 = ();\n //         drop(_1) -> [return: bb4, unwind: bb1];\n //     }\n //     bb3: {\n-//         EndRegion('14s);\n+//         EndRegion('18s);\n //         drop(_1) -> bb1;\n //     }\n //     bb4: {\n@@ -67,11 +67,11 @@ fn foo<F>(f: F) where F: FnOnce() -> i32 {\n // END rustc.main.SimplifyCfg-qualify-consts.after.mir\n \n // START rustc.main-{{closure}}.SimplifyCfg-qualify-consts.after.mir\n-// fn main::{{closure}}(_1: [closure@NodeId(18) d:&'14s D]) -> i32 {\n+// fn main::{{closure}}(_1: [closure@NodeId(28) d:&'18s D]) -> i32 {\n //    let mut _0: i32;\n //\n //    bb0: {\n-//        _0 = ((*(_1.0: &'14s D)).0: i32);\n+//        _0 = ((*(_1.0: &'18s D)).0: i32);\n //        return;\n //    }\n // END rustc.main-{{closure}}.SimplifyCfg-qualify-consts.after.mir"}, {"sha": "03c7de02ec11166236399cd1626c60b6329c5103", "filename": "src/test/mir-opt/end_region_6.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7b0735a832dd49cb482084590eb0f2577955c079/src%2Ftest%2Fmir-opt%2Fend_region_6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b0735a832dd49cb482084590eb0f2577955c079/src%2Ftest%2Fmir-opt%2Fend_region_6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_6.rs?ref=7b0735a832dd49cb482084590eb0f2577955c079", "patch": "@@ -33,30 +33,30 @@ fn foo<F>(f: F) where F: FnOnce() -> i32 {\n //     let _1: D;\n //     ...\n //     let mut _2: ();\n-//     let mut _3: [closure@NodeId(22) d:&'19s D];\n-//     let mut _4: &'19s D;\n+//     let mut _3: [closure@NodeId(33) d:&'24s D];\n+//     let mut _4: &'24s D;\n //     bb0: {\n //         StorageLive(_1);\n //         _1 = D::{{constructor}}(const 0i32,);\n //         FakeRead(ForLet, _1);\n //         StorageLive(_3);\n //         StorageLive(_4);\n-//         _4 = &'19s _1;\n-//         _3 = [closure@NodeId(22)] { d: move _4 };\n+//         _4 = &'24s _1;\n+//         _3 = [closure@NodeId(33)] { d: move _4 };\n //         StorageDead(_4);\n //         _2 = const foo(move _3) -> [return: bb2, unwind: bb3];\n //     }\n //     bb1: {\n //         resume;\n //     }\n //     bb2: {\n-//         EndRegion('19s);\n+//         EndRegion('24s);\n //         StorageDead(_3);\n //         _0 = ();\n //         drop(_1) -> [return: bb4, unwind: bb1];\n //     }\n //     bb3: {\n-//         EndRegion('19s);\n+//         EndRegion('24s);\n //         drop(_1) -> bb1;\n //     }\n //     bb4: {\n@@ -66,17 +66,17 @@ fn foo<F>(f: F) where F: FnOnce() -> i32 {\n // END rustc.main.SimplifyCfg-qualify-consts.after.mir\n \n // START rustc.main-{{closure}}.SimplifyCfg-qualify-consts.after.mir\n-// fn main::{{closure}}(_1: [closure@NodeId(22) d:&'19s D]) -> i32 {\n+// fn main::{{closure}}(_1: [closure@NodeId(33) d:&'24s D]) -> i32 {\n //     let mut _0: i32;\n //     ...\n-//     let _2: &'16_0rs D;\n+//     let _2: &'21_0rs D;\n //     ...\n //     bb0: {\n //         StorageLive(_2);\n-//         _2 = &'16_0rs (*(_1.0: &'19s D));\n+//         _2 = &'21_0rs (*(_1.0: &'24s D));\n //         FakeRead(ForLet, _2);\n //         _0 = ((*_2).0: i32);\n-//         EndRegion('16_0rs);\n+//         EndRegion('21_0rs);\n //         StorageDead(_2);\n //         return;\n //     }"}, {"sha": "56e3e0aa6f7a9a6ff195389ecb53682035817d3b", "filename": "src/test/mir-opt/end_region_7.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7b0735a832dd49cb482084590eb0f2577955c079/src%2Ftest%2Fmir-opt%2Fend_region_7.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b0735a832dd49cb482084590eb0f2577955c079/src%2Ftest%2Fmir-opt%2Fend_region_7.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_7.rs?ref=7b0735a832dd49cb482084590eb0f2577955c079", "patch": "@@ -33,13 +33,13 @@ fn foo<F>(f: F) where F: FnOnce() -> i32 {\n //     let _1: D;\n //     ...\n //     let mut _2: ();\n-//     let mut _3: [closure@NodeId(22) d:D];\n+//     let mut _3: [closure@NodeId(33) d:D];\n //     bb0: {\n //         StorageLive(_1);\n //         _1 = D::{{constructor}}(const 0i32,);\n //         FakeRead(ForLet, _1);\n //         StorageLive(_3);\n-//         _3 = [closure@NodeId(22)] { d: move _1 };\n+//         _3 = [closure@NodeId(33)] { d: move _1 };\n //         _2 = const foo(move _3) -> [return: bb2, unwind: bb4];\n //     }\n //     bb1: {\n@@ -67,17 +67,17 @@ fn foo<F>(f: F) where F: FnOnce() -> i32 {\n // END rustc.main.SimplifyCfg-qualify-consts.after.mir\n \n // START rustc.main-{{closure}}.SimplifyCfg-qualify-consts.after.mir\n-// fn main::{{closure}}(_1: [closure@NodeId(22) d:D]) -> i32 {\n+// fn main::{{closure}}(_1: [closure@NodeId(33) d:D]) -> i32 {\n //     let mut _0: i32;\n //     ...\n-//     let _2: &'16_0rs D;\n+//     let _2: &'21_0rs D;\n //     ...\n //     bb0: {\n //         StorageLive(_2);\n-//         _2 = &'16_0rs (_1.0: D);\n+//         _2 = &'21_0rs (_1.0: D);\n //         FakeRead(ForLet, _2);\n //         _0 = ((*_2).0: i32);\n-//         EndRegion('16_0rs);\n+//         EndRegion('21_0rs);\n //         StorageDead(_2);\n //         drop(_1) -> [return: bb2, unwind: bb1];\n //     }"}, {"sha": "0a54dcaa0d33fa31f574df55d0f02868b4c69119", "filename": "src/test/mir-opt/end_region_8.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7b0735a832dd49cb482084590eb0f2577955c079/src%2Ftest%2Fmir-opt%2Fend_region_8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b0735a832dd49cb482084590eb0f2577955c079/src%2Ftest%2Fmir-opt%2Fend_region_8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_8.rs?ref=7b0735a832dd49cb482084590eb0f2577955c079", "patch": "@@ -31,37 +31,37 @@ fn foo<F>(f: F) where F: FnOnce() -> i32 {\n // fn main() -> () {\n //    let mut _0: ();\n //    ...\n-//    let _2: &'21_1rs D;\n+//    let _2: &'26_1rs D;\n //    ...\n //    let _1: D;\n //    ...\n //    let mut _3: ();\n-//    let mut _4: [closure@NodeId(22) r:&'19s D];\n+//    let mut _4: [closure@NodeId(33) r:&'24s D];\n //    bb0: {\n //        StorageLive(_1);\n //        _1 = D::{{constructor}}(const 0i32,);\n //        FakeRead(ForLet, _1);\n //        StorageLive(_2);\n-//        _2 = &'21_1rs _1;\n+//        _2 = &'26_1rs _1;\n //        FakeRead(ForLet, _2);\n //        StorageLive(_4);\n-//        _4 = [closure@NodeId(22)] { r: _2 };\n+//        _4 = [closure@NodeId(33)] { r: _2 };\n //        _3 = const foo(move _4) -> [return: bb2, unwind: bb3];\n //    }\n //    bb1: {\n //        resume;\n //    }\n //    bb2: {\n-//        EndRegion('19s);\n+//        EndRegion('24s);\n //        StorageDead(_4);\n //        _0 = ();\n-//        EndRegion('21_1rs);\n+//        EndRegion('26_1rs);\n //        StorageDead(_2);\n //        drop(_1) -> [return: bb4, unwind: bb1];\n //    }\n //    bb3: {\n-//        EndRegion('19s);\n-//        EndRegion('21_1rs);\n+//        EndRegion('24s);\n+//        EndRegion('26_1rs);\n //        drop(_1) -> bb1;\n //    }\n //    bb4: {\n@@ -72,11 +72,11 @@ fn foo<F>(f: F) where F: FnOnce() -> i32 {\n // END rustc.main.SimplifyCfg-qualify-consts.after.mir\n \n // START rustc.main-{{closure}}.SimplifyCfg-qualify-consts.after.mir\n-// fn main::{{closure}}(_1: [closure@NodeId(22) r:&'19s D]) -> i32 {\n+// fn main::{{closure}}(_1: [closure@NodeId(33) r:&'24s D]) -> i32 {\n //     let mut _0: i32;\n //\n //     bb0: {\n-//         _0 = ((*(_1.0: &'21_1rs D)).0: i32);\n+//         _0 = ((*(_1.0: &'26_1rs D)).0: i32);\n //         return;\n //     }\n // }"}, {"sha": "ef2d949d3074eb4c990c8c06636c5d190abb9f1c", "filename": "src/test/mir-opt/end_region_9.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7b0735a832dd49cb482084590eb0f2577955c079/src%2Ftest%2Fmir-opt%2Fend_region_9.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b0735a832dd49cb482084590eb0f2577955c079/src%2Ftest%2Fmir-opt%2Fend_region_9.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_9.rs?ref=7b0735a832dd49cb482084590eb0f2577955c079", "patch": "@@ -41,7 +41,7 @@ fn main() {\n // fn main() -> () {\n //     let mut _0: ();\n //     ...\n-//     let mut _4: &'33_0rs i32;\n+//     let mut _4: &'37_0rs i32;\n //     ...\n //     let _2: i32;\n //     ...\n@@ -79,14 +79,14 @@ fn main() {\n //    bb5: {\n //        _0 = ();\n //        StorageDead(_7);\n-//        EndRegion('33_0rs);\n+//        EndRegion('37_0rs);\n //        StorageDead(_4);\n //        StorageDead(_2);\n //        StorageDead(_1);\n //        return;\n //    }\n //    bb6: {\n-//        _4 = &'33_0rs _2;\n+//        _4 = &'37_0rs _2;\n //        _6 = ();\n //        StorageDead(_7);\n //        _1 = const true;"}, {"sha": "3dbc73caf65d87e6d396fa5975f73adf0bf93094", "filename": "src/test/mir-opt/end_region_cyclic.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/7b0735a832dd49cb482084590eb0f2577955c079/src%2Ftest%2Fmir-opt%2Fend_region_cyclic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b0735a832dd49cb482084590eb0f2577955c079/src%2Ftest%2Fmir-opt%2Fend_region_cyclic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_cyclic.rs?ref=7b0735a832dd49cb482084590eb0f2577955c079", "patch": "@@ -45,24 +45,24 @@ fn query() -> bool { true }\n //     scope 1 {\n //     }\n //     scope 2 {\n-//         let _2: S<'36_0rs>;\n+//         let _2: S<'49_0rs>;\n //     }\n //     let mut _1: ();\n-//     let mut _3: std::cell::Cell<std::option::Option<&'36_0rs S<'36_0rs>>>;\n-//     let mut _4: std::option::Option<&'36_0rs S<'36_0rs>>;\n+//     let mut _3: std::cell::Cell<std::option::Option<&'49_0rs S<'49_0rs>>>;\n+//     let mut _4: std::option::Option<&'49_0rs S<'49_0rs>>;\n //     let mut _5: ();\n-//     let mut _6: &'17s std::cell::Cell<std::option::Option<&'36_0rs S<'36_0rs>>>;\n-//     let mut _7: std::option::Option<&'36_0rs S<'36_0rs>>;\n-//     let mut _8: &'36_0rs S<'36_0rs>;\n-//     let mut _9: &'36_0rs S<'36_0rs>;\n+//     let mut _6: &'25s std::cell::Cell<std::option::Option<&'49_0rs S<'49_0rs>>>;\n+//     let mut _7: std::option::Option<&'49_0rs S<'49_0rs>>;\n+//     let mut _8: &'49_0rs S<'49_0rs>;\n+//     let mut _9: &'49_0rs S<'49_0rs>;\n //     let mut _10: ();\n //     let mut _11: bool;\n //     let mut _12: !;\n //     let mut _13: ();\n-//     let mut _14: &'34s std::cell::Cell<std::option::Option<&'36_0rs S<'36_0rs>>>;\n-//     let mut _15: std::option::Option<&'36_0rs S<'36_0rs>>;\n-//     let mut _16: &'36_0rs S<'36_0rs>;\n-//     let mut _17: &'36_0rs S<'36_0rs>;\n+//     let mut _14: &'47s std::cell::Cell<std::option::Option<&'49_0rs S<'49_0rs>>>;\n+//     let mut _15: std::option::Option<&'49_0rs S<'49_0rs>>;\n+//     let mut _16: &'49_0rs S<'49_0rs>;\n+//     let mut _17: &'49_0rs S<'49_0rs>;\n //     bb0: {\n //         goto -> bb1;\n //     }\n@@ -73,30 +73,30 @@ fn query() -> bool { true }\n //         StorageLive(_2);\n //         StorageLive(_3);\n //         StorageLive(_4);\n-//         _4 = std::option::Option<&'36_0rs S<'36_0rs>>::None;\n+//         _4 = std::option::Option<&'49_0rs S<'49_0rs>>::None;\n //         _3 = const <std::cell::Cell<T>>::new(move _4) -> [return: bb4, unwind: bb3];\n //     }\n //     bb3: {\n //         resume;\n //     }\n //     bb4: {\n //         StorageDead(_4);\n-//         _2 = S<'36_0rs> { r: move _3 };\n+//         _2 = S<'49_0rs> { r: move _3 };\n //         StorageDead(_3);\n //         FakeRead(ForLet, _2);\n //         StorageLive(_6);\n-//         _6 = &'17s (_2.0: std::cell::Cell<std::option::Option<&'36_0rs S<'36_0rs>>>);\n+//         _6 = &'25s (_2.0: std::cell::Cell<std::option::Option<&'49_0rs S<'49_0rs>>>);\n //         StorageLive(_7);\n //         StorageLive(_8);\n //         StorageLive(_9);\n-//         _9 = &'36_0rs _2;\n-//         _8 = &'36_0rs (*_9);\n-//         _7 = std::option::Option<&'36_0rs S<'36_0rs>>::Some(move _8,);\n+//         _9 = &'49_0rs _2;\n+//         _8 = &'49_0rs (*_9);\n+//         _7 = std::option::Option<&'49_0rs S<'49_0rs>>::Some(move _8,);\n //         StorageDead(_8);\n //         _5 = const <std::cell::Cell<T>>::set(move _6, move _7) -> [return: bb5, unwind: bb3];\n //     }\n //     bb5: {\n-//         EndRegion('17s);\n+//         EndRegion('25s);\n //         StorageDead(_7);\n //         StorageDead(_6);\n //         StorageDead(_9);\n@@ -109,31 +109,31 @@ fn query() -> bool { true }\n //     bb7: {\n //         _0 = ();\n //         StorageDead(_11);\n-//         EndRegion('36_0rs);\n+//         EndRegion('49_0rs);\n //         StorageDead(_2);\n //         return;\n //     }\n //     bb8: {\n //         _10 = ();\n //         StorageDead(_11);\n //         StorageLive(_14);\n-//         _14 = &'34s (_2.0: std::cell::Cell<std::option::Option<&'36_0rs S<'36_0rs>>>);\n+//         _14 = &'47s (_2.0: std::cell::Cell<std::option::Option<&'49_0rs S<'49_0rs>>>);\n //         StorageLive(_15);\n //         StorageLive(_16);\n //         StorageLive(_17);\n-//         _17 = &'36_0rs _2;\n-//         _16 = &'36_0rs (*_17);\n-//         _15 = std::option::Option<&'36_0rs S<'36_0rs>>::Some(move _16,);\n+//         _17 = &'49_0rs _2;\n+//         _16 = &'49_0rs (*_17);\n+//         _15 = std::option::Option<&'49_0rs S<'49_0rs>>::Some(move _16,);\n //         StorageDead(_16);\n //         _13 = const <std::cell::Cell<T>>::set(move _14, move _15) -> [return: bb9, unwind: bb3];\n //     }\n //     bb9: {\n-//         EndRegion('34s);\n+//         EndRegion('47s);\n //         StorageDead(_15);\n //         StorageDead(_14);\n //         StorageDead(_17);\n //         _1 = ();\n-//         EndRegion('36_0rs);\n+//         EndRegion('49_0rs);\n //         StorageDead(_2);\n //         goto -> bb1;\n //     }"}, {"sha": "a5107d304386f6b56b0caeaa1edfd4f9ce588982", "filename": "src/test/mir-opt/end_region_destruction_extents_1.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/7b0735a832dd49cb482084590eb0f2577955c079/src%2Ftest%2Fmir-opt%2Fend_region_destruction_extents_1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b0735a832dd49cb482084590eb0f2577955c079/src%2Ftest%2Fmir-opt%2Fend_region_destruction_extents_1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_destruction_extents_1.rs?ref=7b0735a832dd49cb482084590eb0f2577955c079", "patch": "@@ -41,16 +41,16 @@ unsafe impl<'a, #[may_dangle] 'b> Drop for D1<'a, 'b> {\n \n // Notes on the MIR output below:\n //\n-// 1. The `EndRegion('10s)` is allowed to precede the `drop(_3)`\n+// 1. The `EndRegion('13s)` is allowed to precede the `drop(_3)`\n //    solely because of the #[may_dangle] mentioned above.\n //\n-// 2. Regarding the occurrence of `EndRegion('12ds)` *after* `StorageDead(_6)`\n-//    (where we have borrows `&'12ds _6`): Eventually:\n+// 2. Regarding the occurrence of `EndRegion('15ds)` *after* `StorageDead(_6)`\n+//    (where we have borrows `&'15ds _6`): Eventually:\n //\n //    i. this code should be rejected (by mir-borrowck), or\n //\n //    ii. the MIR code generation should be changed so that the\n-//        EndRegion('12ds)` precedes `StorageDead(_6)` in the\n+//        EndRegion('15ds)` precedes `StorageDead(_6)` in the\n //        control-flow.  (Note: arielb1 views drop+storagedead as one\n //        unit, and does not see this option as a useful avenue to\n //        explore.), or\n@@ -66,33 +66,33 @@ unsafe impl<'a, #[may_dangle] 'b> Drop for D1<'a, 'b> {\n // START rustc.main.QualifyAndPromoteConstants.before.mir\n // fn main() -> () {\n // let mut _0: ();\n-//     let mut _1: &'12ds S1;\n-//     let mut _2: D1<'12ds, '10s>;\n-//     let mut _3: &'12ds S1;\n-//     let mut _4: &'12ds S1;\n+//     let mut _1: &'15ds S1;\n+//     let mut _2: D1<'15ds, '13s>;\n+//     let mut _3: &'15ds S1;\n+//     let mut _4: &'15ds S1;\n //     let _5: S1;\n-//     let mut _6: &'10s S1;\n-//     let mut _7: &'10s S1;\n+//     let mut _6: &'13s S1;\n+//     let mut _7: &'13s S1;\n //     let _8: S1;\n //     bb0: {\n //         StorageLive(_2);\n //         StorageLive(_3);\n //         StorageLive(_4);\n //         StorageLive(_5);\n //         _5 = S1::{{constructor}}(const \"ex1\",);\n-//         _4 = &'12ds _5;\n-//         _3 = &'12ds (*_4);\n+//         _4 = &'15ds _5;\n+//         _3 = &'15ds (*_4);\n //         StorageLive(_6);\n //         StorageLive(_7);\n //         StorageLive(_8);\n //         _8 = S1::{{constructor}}(const \"dang1\",);\n-//         _7 = &'10s _8;\n-//         _6 = &'10s (*_7);\n-//         _2 = D1<'12ds, '10s>::{{constructor}}(move _3, move _6);\n-//         EndRegion('10s);\n+//         _7 = &'13s _8;\n+//         _6 = &'13s (*_7);\n+//         _2 = D1<'15ds, '13s>::{{constructor}}(move _3, move _6);\n+//         EndRegion('13s);\n //         StorageDead(_6);\n //         StorageDead(_3);\n-//         _1 = (_2.0: &'12ds S1);\n+//         _1 = (_2.0: &'15ds S1);\n //         drop(_2) -> [return: bb2, unwind: bb1];\n //     }\n //     bb1: {\n@@ -104,7 +104,7 @@ unsafe impl<'a, #[may_dangle] 'b> Drop for D1<'a, 'b> {\n //         StorageDead(_8);\n //         StorageDead(_4);\n //         StorageDead(_5);\n-//         EndRegion('12ds);\n+//         EndRegion('15ds);\n //         _0 = ();\n //         return;\n //     }\n@@ -114,29 +114,29 @@ unsafe impl<'a, #[may_dangle] 'b> Drop for D1<'a, 'b> {\n // START rustc.main.QualifyAndPromoteConstants.after.mir\n // fn main() -> (){\n //     let mut _0: ();\n-//     let mut _1: &'12ds S1;\n-//     let mut _2: D1<'12ds, '10s>;\n-//     let mut _3: &'12ds S1;\n-//     let mut _4: &'12ds S1;\n+//     let mut _1: &'15ds S1;\n+//     let mut _2: D1<'15ds, '13s>;\n+//     let mut _3: &'15ds S1;\n+//     let mut _4: &'15ds S1;\n //     let _5: S1;\n-//     let mut _6: &'10s S1;\n-//     let mut _7: &'10s S1;\n+//     let mut _6: &'13s S1;\n+//     let mut _7: &'13s S1;\n //     let _8: S1;\n //     bb0: {\n //         StorageLive(_2);\n //         StorageLive(_3);\n //         StorageLive(_4);\n-//         _4 = &'12ds (promoted[1]: S1);\n-//         _3 = &'12ds (*_4);\n+//         _4 = &'15ds (promoted[1]: S1);\n+//         _3 = &'15ds (*_4);\n //         StorageLive(_6);\n //         StorageLive(_7);\n-//         _7 = &'10s (promoted[0]: S1);\n-//         _6 = &'10s (*_7);\n-//         _2 = D1<'12ds, '10s>::{{constructor}}(move _3, move _6);\n-//         EndRegion('10s);\n+//         _7 = &'13s (promoted[0]: S1);\n+//         _6 = &'13s (*_7);\n+//         _2 = D1<'15ds, '13s>::{{constructor}}(move _3, move _6);\n+//         EndRegion('13s);\n //         StorageDead(_6);\n //         StorageDead(_3);\n-//         _1 = (_2.0: &'12ds S1);\n+//         _1 = (_2.0: &'15ds S1);\n //         drop(_2) -> [return: bb2, unwind: bb1];\n //     }\n //     bb1: {\n@@ -146,7 +146,7 @@ unsafe impl<'a, #[may_dangle] 'b> Drop for D1<'a, 'b> {\n //         StorageDead(_2);\n //         StorageDead(_7);\n //         StorageDead(_4);\n-//         EndRegion('12ds);\n+//         EndRegion('15ds);\n //         _0 = ();\n //         return;\n //     }"}, {"sha": "ba1712f4ca39884985f47da40fcbc758fbefc180", "filename": "src/test/mir-opt/inline-closure-borrows-arg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b0735a832dd49cb482084590eb0f2577955c079/src%2Ftest%2Fmir-opt%2Finline-closure-borrows-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b0735a832dd49cb482084590eb0f2577955c079/src%2Ftest%2Fmir-opt%2Finline-closure-borrows-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline-closure-borrows-arg.rs?ref=7b0735a832dd49cb482084590eb0f2577955c079", "patch": "@@ -30,7 +30,7 @@ fn foo<T: Copy>(_t: T, q: &i32) -> i32 {\n // ...\n // bb0: {\n //     ...\n-//     _3 = [closure@NodeId(39)];\n+//     _3 = [closure@NodeId(53)];\n //     ...\n //     _4 = &_3;\n //     ..."}, {"sha": "9cb0a4dc2bfacf7c4df8d5cce916d6d75b169486", "filename": "src/test/mir-opt/inline-closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b0735a832dd49cb482084590eb0f2577955c079/src%2Ftest%2Fmir-opt%2Finline-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b0735a832dd49cb482084590eb0f2577955c079/src%2Ftest%2Fmir-opt%2Finline-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline-closure.rs?ref=7b0735a832dd49cb482084590eb0f2577955c079", "patch": "@@ -26,7 +26,7 @@ fn foo<T: Copy>(_t: T, q: i32) -> i32 {\n // ...\n // bb0: {\n //     ...\n-//     _3 = [closure@NodeId(28)];\n+//     _3 = [closure@NodeId(39)];\n //     ...\n //     _4 = &_3;\n //     ..."}, {"sha": "f1544968adb6a2135afe4b3486db2191fb787d44", "filename": "src/test/mir-opt/validate_1.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7b0735a832dd49cb482084590eb0f2577955c079/src%2Ftest%2Fmir-opt%2Fvalidate_1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b0735a832dd49cb482084590eb0f2577955c079/src%2Ftest%2Fmir-opt%2Fvalidate_1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fvalidate_1.rs?ref=7b0735a832dd49cb482084590eb0f2577955c079", "patch": "@@ -40,35 +40,35 @@ fn main() {\n //     ...\n //     bb0: {\n //         ...\n-//         Validate(Suspend(ReScope(Node(ItemLocalId(10)))), [_1: i32]);\n+//         Validate(Suspend(ReScope(Node(ItemLocalId(13)))), [_1: i32]);\n //         _6 = &ReErased mut _1;\n-//         Validate(Acquire, [(*_6): i32/ReScope(Node(ItemLocalId(10)))]);\n-//         Validate(Suspend(ReScope(Node(ItemLocalId(10)))), [(*_6): i32/ReScope(Node(ItemLocalId(10)))]);\n+//         Validate(Acquire, [(*_6): i32/ReScope(Node(ItemLocalId(13)))]);\n+//         Validate(Suspend(ReScope(Node(ItemLocalId(13)))), [(*_6): i32/ReScope(Node(ItemLocalId(13)))]);\n //         _5 = &ReErased mut (*_6);\n-//         Validate(Acquire, [(*_5): i32/ReScope(Node(ItemLocalId(10)))]);\n-//         Validate(Release, [_2: (), _3: &ReScope(Node(ItemLocalId(10))) Test, _5: &ReScope(Node(ItemLocalId(10))) mut i32]);\n+//         Validate(Acquire, [(*_5): i32/ReScope(Node(ItemLocalId(13)))]);\n+//         Validate(Release, [_2: (), _3: &ReScope(Node(ItemLocalId(13))) Test, _5: &ReScope(Node(ItemLocalId(13))) mut i32]);\n //         _2 = const Test::foo(move _3, move _5) -> bb1;\n //     }\n //\n //     bb1: {\n //         Validate(Acquire, [_2: ()]);\n-//         EndRegion(ReScope(Node(ItemLocalId(10))));\n+//         EndRegion(ReScope(Node(ItemLocalId(13))));\n //         ...\n //         return;\n //     }\n // }\n // END rustc.main.EraseRegions.after.mir\n // START rustc.main-{{closure}}.EraseRegions.after.mir\n-// fn main::{{closure}}(_1: &ReErased [closure@NodeId(50)], _2: &ReErased mut i32) -> i32 {\n+// fn main::{{closure}}(_1: &ReErased [closure@NodeId(65)], _2: &ReErased mut i32) -> i32 {\n //     ...\n //     bb0: {\n-//         Validate(Acquire, [_1: &ReFree(DefId(0/1:11 ~ validate_1[317d]::main[0]::{{closure}}[0]), BrEnv) [closure@NodeId(50)], _2: &ReFree(DefId(0/1:11 ~ validate_1[317d]::main[0]::{{closure}}[0]), BrAnon(0)) mut i32]);\n+//         Validate(Acquire, [_1: &ReFree(DefId(0/1:11 ~ validate_1[317d]::main[0]::{{closure}}[0]), BrEnv) [closure@NodeId(65)], _2: &ReFree(DefId(0/1:11 ~ validate_1[317d]::main[0]::{{closure}}[0]), BrAnon(0)) mut i32]);\n //         StorageLive(_3);\n-//         Validate(Suspend(ReScope(Remainder { block: ItemLocalId(25), first_statement_index: 0 })), [(*_2): i32]);\n+//         Validate(Suspend(ReScope(Remainder { block: ItemLocalId(31), first_statement_index: 0 })), [(*_2): i32]);\n //         _3 = &ReErased (*_2);\n-//         Validate(Acquire, [(*_3): i32/ReScope(Remainder { block: ItemLocalId(25), first_statement_index: 0 }) (imm)]);\n+//         Validate(Acquire, [(*_3): i32/ReScope(Remainder { block: ItemLocalId(31), first_statement_index: 0 }) (imm)]);\n //         _0 = (*_3);\n-//         EndRegion(ReScope(Remainder { block: ItemLocalId(25), first_statement_index: 0 }));\n+//         EndRegion(ReScope(Remainder { block: ItemLocalId(31), first_statement_index: 0 }));\n //         StorageDead(_3);\n //         return;\n //     }"}, {"sha": "ce840397713ad6031063f69b97a21552734f301c", "filename": "src/test/mir-opt/validate_3.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7b0735a832dd49cb482084590eb0f2577955c079/src%2Ftest%2Fmir-opt%2Fvalidate_3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b0735a832dd49cb482084590eb0f2577955c079/src%2Ftest%2Fmir-opt%2Fvalidate_3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fvalidate_3.rs?ref=7b0735a832dd49cb482084590eb0f2577955c079", "patch": "@@ -48,27 +48,27 @@ fn main() {\n //         StorageLive(_1);\n //         _1 = Test { x: const 0i32 };\n //         StorageLive(_2);\n-//         Validate(Suspend(ReScope(Remainder { block: ItemLocalId(20), first_statement_index: 3 })), [_1: Test]);\n+//         Validate(Suspend(ReScope(Remainder { block: ItemLocalId(24), first_statement_index: 3 })), [_1: Test]);\n //         _2 = &ReErased _1;\n-//         Validate(Acquire, [(*_2): Test/ReScope(Remainder { block: ItemLocalId(20), first_statement_index: 3 }) (imm)]);\n+//         Validate(Acquire, [(*_2): Test/ReScope(Remainder { block: ItemLocalId(24), first_statement_index: 3 }) (imm)]);\n //         StorageLive(_4);\n //         StorageLive(_5);\n-//         Validate(Suspend(ReScope(Node(ItemLocalId(18)))), [((*_2).0: i32): i32/ReScope(Remainder { block: ItemLocalId(20), first_statement_index: 3 }) (imm)]);\n+//         Validate(Suspend(ReScope(Node(ItemLocalId(22)))), [((*_2).0: i32): i32/ReScope(Remainder { block: ItemLocalId(24), first_statement_index: 3 }) (imm)]);\n //         _5 = &ReErased ((*_2).0: i32);\n-//         Validate(Acquire, [(*_5): i32/ReScope(Node(ItemLocalId(18))) (imm)]);\n-//         Validate(Suspend(ReScope(Node(ItemLocalId(18)))), [(*_5): i32/ReScope(Node(ItemLocalId(18))) (imm)]);\n+//         Validate(Acquire, [(*_5): i32/ReScope(Node(ItemLocalId(22))) (imm)]);\n+//         Validate(Suspend(ReScope(Node(ItemLocalId(22)))), [(*_5): i32/ReScope(Node(ItemLocalId(22))) (imm)]);\n //         _4 = &ReErased (*_5);\n-//         Validate(Acquire, [(*_4): i32/ReScope(Node(ItemLocalId(18))) (imm)]);\n-//         Validate(Release, [_3: (), _4: &ReScope(Node(ItemLocalId(18))) i32]);\n+//         Validate(Acquire, [(*_4): i32/ReScope(Node(ItemLocalId(22))) (imm)]);\n+//         Validate(Release, [_3: (), _4: &ReScope(Node(ItemLocalId(22))) i32]);\n //         _3 = const foo(move _4) -> bb1;\n //     }\n //     bb1: {\n //         Validate(Acquire, [_3: ()]);\n-//         EndRegion(ReScope(Node(ItemLocalId(18))));\n+//         EndRegion(ReScope(Node(ItemLocalId(22))));\n //         StorageDead(_4);\n //         StorageDead(_5);\n //         _0 = ();\n-//         EndRegion(ReScope(Remainder { block: ItemLocalId(20), first_statement_index: 3 }));\n+//         EndRegion(ReScope(Remainder { block: ItemLocalId(24), first_statement_index: 3 }));\n //         StorageDead(_2);\n //         StorageDead(_1);\n //         return;"}, {"sha": "542ac8a42411f1d852565b6be9f87f31f00e7646", "filename": "src/test/mir-opt/validate_4.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7b0735a832dd49cb482084590eb0f2577955c079/src%2Ftest%2Fmir-opt%2Fvalidate_4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b0735a832dd49cb482084590eb0f2577955c079/src%2Ftest%2Fmir-opt%2Fvalidate_4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fvalidate_4.rs?ref=7b0735a832dd49cb482084590eb0f2577955c079", "patch": "@@ -48,11 +48,11 @@ fn main() {\n // }\n // END rustc.write_42.EraseRegions.after.mir\n // START rustc.write_42-{{closure}}.EraseRegions.after.mir\n-// fn write_42::{{closure}}(_1: &ReErased [closure@NodeId(22)], _2: *mut i32) -> () {\n+// fn write_42::{{closure}}(_1: &ReErased [closure@NodeId(32)], _2: *mut i32) -> () {\n //     ...\n //     bb0: {\n-//         Validate(Acquire, [_1: &ReFree(DefId(0/1:9 ~ validate_4[317d]::write_42[0]::{{closure}}[0]), BrEnv) [closure@NodeId(22)], _2: *mut i32]);\n-//         Validate(Release, [_1: &ReFree(DefId(0/1:9 ~ validate_4[317d]::write_42[0]::{{closure}}[0]), BrEnv) [closure@NodeId(22)], _2: *mut i32]);\n+//         Validate(Acquire, [_1: &ReFree(DefId(0/1:9 ~ validate_4[317d]::write_42[0]::{{closure}}[0]), BrEnv) [closure@NodeId(32)], _2: *mut i32]);\n+//         Validate(Release, [_1: &ReFree(DefId(0/1:9 ~ validate_4[317d]::write_42[0]::{{closure}}[0]), BrEnv) [closure@NodeId(32)], _2: *mut i32]);\n //         (*_2) = const 23i32;\n //         _0 = ();\n //         return;\n@@ -76,11 +76,11 @@ fn main() {\n // }\n // END rustc.test.EraseRegions.after.mir\n // START rustc.main-{{closure}}.EraseRegions.after.mir\n-// fn main::{{closure}}(_1: &ReErased [closure@NodeId(60)], _2: &ReErased mut i32) -> bool {\n+// fn main::{{closure}}(_1: &ReErased [closure@NodeId(80)], _2: &ReErased mut i32) -> bool {\n //     ...\n //     bb0: {\n-//         Validate(Acquire, [_1: &ReFree(DefId(0/1:10 ~ validate_4[317d]::main[0]::{{closure}}[0]), BrEnv) [closure@NodeId(60)], _2: &ReFree(DefId(0/1:10 ~ validate_4[317d]::main[0]::{{closure}}[0]), BrAnon(0)) mut i32]);\n-//         Validate(Release, [_1: &ReFree(DefId(0/1:10 ~ validate_4[317d]::main[0]::{{closure}}[0]), BrEnv) [closure@NodeId(60)], _2: &ReFree(DefId(0/1:10 ~ validate_4[317d]::main[0]::{{closure}}[0]), BrAnon(0)) mut i32]);\n+//         Validate(Acquire, [_1: &ReFree(DefId(0/1:10 ~ validate_4[317d]::main[0]::{{closure}}[0]), BrEnv) [closure@NodeId(80)], _2: &ReFree(DefId(0/1:10 ~ validate_4[317d]::main[0]::{{closure}}[0]), BrAnon(0)) mut i32]);\n+//         Validate(Release, [_1: &ReFree(DefId(0/1:10 ~ validate_4[317d]::main[0]::{{closure}}[0]), BrEnv) [closure@NodeId(80)], _2: &ReFree(DefId(0/1:10 ~ validate_4[317d]::main[0]::{{closure}}[0]), BrAnon(0)) mut i32]);\n //         StorageLive(_3);\n //         ...\n //         _0 = const write_42(move _3) -> bb1;"}, {"sha": "955de0c3bad043e45d8d46c2722e6bc5199e87dc", "filename": "src/test/mir-opt/validate_5.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7b0735a832dd49cb482084590eb0f2577955c079/src%2Ftest%2Fmir-opt%2Fvalidate_5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b0735a832dd49cb482084590eb0f2577955c079/src%2Ftest%2Fmir-opt%2Fvalidate_5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fvalidate_5.rs?ref=7b0735a832dd49cb482084590eb0f2577955c079", "patch": "@@ -46,19 +46,19 @@ fn main() {\n // }\n // END rustc.test.EraseRegions.after.mir\n // START rustc.main-{{closure}}.EraseRegions.after.mir\n-// fn main::{{closure}}(_1: &ReErased [closure@NodeId(46)], _2: &ReErased mut i32) -> bool {\n+// fn main::{{closure}}(_1: &ReErased [closure@NodeId(62)], _2: &ReErased mut i32) -> bool {\n //     ...\n //     bb0: {\n-//         Validate(Acquire, [_1: &ReFree(DefId(0/1:9 ~ validate_5[317d]::main[0]::{{closure}}[0]), BrEnv) [closure@NodeId(46)], _2: &ReFree(DefId(0/1:9 ~ validate_5[317d]::main[0]::{{closure}}[0]), BrAnon(0)) mut i32]);\n+//         Validate(Acquire, [_1: &ReFree(DefId(0/1:9 ~ validate_5[317d]::main[0]::{{closure}}[0]), BrEnv) [closure@NodeId(62)], _2: &ReFree(DefId(0/1:9 ~ validate_5[317d]::main[0]::{{closure}}[0]), BrAnon(0)) mut i32]);\n //         StorageLive(_3);\n //         StorageLive(_4);\n //         StorageLive(_5);\n-//         Validate(Suspend(ReScope(Node(ItemLocalId(12)))), [(*_2): i32]);\n+//         Validate(Suspend(ReScope(Node(ItemLocalId(16)))), [(*_2): i32]);\n //         _5 = &ReErased mut (*_2);\n-//         Validate(Acquire, [(*_5): i32/ReScope(Node(ItemLocalId(12)))]);\n+//         Validate(Acquire, [(*_5): i32/ReScope(Node(ItemLocalId(16)))]);\n //         _4 = move _5 as *mut i32 (Misc);\n //         _3 = move _4;\n-//         EndRegion(ReScope(Node(ItemLocalId(12))));\n+//         EndRegion(ReScope(Node(ItemLocalId(16))));\n //         StorageDead(_4);\n //         StorageDead(_5);\n //         Validate(Release, [_0: bool, _3: *mut i32]);"}]}