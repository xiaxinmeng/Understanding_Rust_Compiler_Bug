{"sha": "11577288c23b1f2de1aaba0137c9c2d6344b9a92", "node_id": "MDY6Q29tbWl0NzI0NzEyOjExNTc3Mjg4YzIzYjFmMmRlMWFhYmEwMTM3YzljMmQ2MzQ0YjlhOTI=", "commit": {"author": {"name": "Ekaterina Babshukova", "email": "ekaterina.babshukova@yandex.ru", "date": "2019-09-14T11:38:10Z"}, "committer": {"name": "Ekaterina Babshukova", "email": "ekaterina.babshukova@yandex.ru", "date": "2019-10-22T20:47:31Z"}, "message": "initial classify_name", "tree": {"sha": "14b7da3cf3688fccc5994596fd21454896b3b0da", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/14b7da3cf3688fccc5994596fd21454896b3b0da"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/11577288c23b1f2de1aaba0137c9c2d6344b9a92", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/11577288c23b1f2de1aaba0137c9c2d6344b9a92", "html_url": "https://github.com/rust-lang/rust/commit/11577288c23b1f2de1aaba0137c9c2d6344b9a92", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/11577288c23b1f2de1aaba0137c9c2d6344b9a92/comments", "author": {"login": "viorina", "id": 6714973, "node_id": "MDQ6VXNlcjY3MTQ5NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/6714973?v=4", "gravatar_id": "", "url": "https://api.github.com/users/viorina", "html_url": "https://github.com/viorina", "followers_url": "https://api.github.com/users/viorina/followers", "following_url": "https://api.github.com/users/viorina/following{/other_user}", "gists_url": "https://api.github.com/users/viorina/gists{/gist_id}", "starred_url": "https://api.github.com/users/viorina/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/viorina/subscriptions", "organizations_url": "https://api.github.com/users/viorina/orgs", "repos_url": "https://api.github.com/users/viorina/repos", "events_url": "https://api.github.com/users/viorina/events{/privacy}", "received_events_url": "https://api.github.com/users/viorina/received_events", "type": "User", "site_admin": false}, "committer": {"login": "viorina", "id": 6714973, "node_id": "MDQ6VXNlcjY3MTQ5NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/6714973?v=4", "gravatar_id": "", "url": "https://api.github.com/users/viorina", "html_url": "https://github.com/viorina", "followers_url": "https://api.github.com/users/viorina/followers", "following_url": "https://api.github.com/users/viorina/following{/other_user}", "gists_url": "https://api.github.com/users/viorina/gists{/gist_id}", "starred_url": "https://api.github.com/users/viorina/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/viorina/subscriptions", "organizations_url": "https://api.github.com/users/viorina/orgs", "repos_url": "https://api.github.com/users/viorina/repos", "events_url": "https://api.github.com/users/viorina/events{/privacy}", "received_events_url": "https://api.github.com/users/viorina/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c15ee97fff4324981d03f65210d794664c28f0e4", "url": "https://api.github.com/repos/rust-lang/rust/commits/c15ee97fff4324981d03f65210d794664c28f0e4", "html_url": "https://github.com/rust-lang/rust/commit/c15ee97fff4324981d03f65210d794664c28f0e4"}], "stats": {"total": 412, "additions": 376, "deletions": 36}, "files": [{"sha": "e09414ca3d6e553c9447a79393ab94918cb4e5e1", "filename": "crates/ra_hir/src/from_source.rs", "status": "modified", "additions": 58, "deletions": 2, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/11577288c23b1f2de1aaba0137c9c2d6344b9a92/crates%2Fra_hir%2Fsrc%2Ffrom_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11577288c23b1f2de1aaba0137c9c2d6344b9a92/crates%2Fra_hir%2Fsrc%2Ffrom_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ffrom_source.rs?ref=11577288c23b1f2de1aaba0137c9c2d6344b9a92", "patch": "@@ -11,8 +11,9 @@ use crate::{\n     db::{AstDatabase, DefDatabase, HirDatabase},\n     ids::{AstItemDef, LocationCtx},\n     name::AsName,\n-    Const, Crate, Enum, EnumVariant, FieldSource, Function, HasSource, ImplBlock, Module,\n-    ModuleSource, Source, Static, Struct, StructField, Trait, TypeAlias, Union, VariantDef,\n+    AssocItem, Const, Crate, Enum, EnumVariant, FieldSource, Function, HasSource, ImplBlock,\n+    Module, ModuleDef, ModuleSource, Source, Static, Struct, StructField, Trait, TypeAlias, Union,\n+    VariantDef,\n };\n \n pub trait FromSource: Sized {\n@@ -129,6 +130,61 @@ impl FromSource for StructField {\n     }\n }\n \n+impl FromSource for AssocItem {\n+    type Ast = ast::ImplItem;\n+    fn from_source(db: &(impl DefDatabase + AstDatabase), src: Source<Self::Ast>) -> Option<Self> {\n+        macro_rules! def {\n+            ($kind:ident, $ast:ident) => {\n+                $kind::from_source(db, Source { file_id: src.file_id, ast: $ast })\n+                    .and_then(|it| Some(AssocItem::from(it)))\n+            };\n+        }\n+\n+        match src.ast {\n+            ast::ImplItem::FnDef(f) => def!(Function, f),\n+            ast::ImplItem::ConstDef(c) => def!(Const, c),\n+            ast::ImplItem::TypeAliasDef(a) => def!(TypeAlias, a),\n+        }\n+    }\n+}\n+\n+// not fully matched\n+impl FromSource for ModuleDef {\n+    type Ast = ast::ModuleItem;\n+    fn from_source(db: &(impl DefDatabase + AstDatabase), src: Source<Self::Ast>) -> Option<Self> {\n+        macro_rules! def {\n+            ($kind:ident, $ast:ident) => {\n+                $kind::from_source(db, Source { file_id: src.file_id, ast: $ast })\n+                    .and_then(|it| Some(ModuleDef::from(it)))\n+            };\n+        }\n+\n+        match src.ast {\n+            ast::ModuleItem::FnDef(f) => def!(Function, f),\n+            ast::ModuleItem::ConstDef(c) => def!(Const, c),\n+            ast::ModuleItem::TypeAliasDef(a) => def!(TypeAlias, a),\n+            ast::ModuleItem::TraitDef(t) => def!(Trait, t),\n+            ast::ModuleItem::StaticDef(s) => def!(Static, s),\n+            ast::ModuleItem::StructDef(s) => {\n+                let src = Source { file_id: src.file_id, ast: s };\n+                let s = Struct::from_source(db, src)?;\n+                Some(ModuleDef::Adt(s.into()))\n+            }\n+            ast::ModuleItem::EnumDef(e) => {\n+                let src = Source { file_id: src.file_id, ast: e };\n+                let e = Enum::from_source(db, src)?;\n+                Some(ModuleDef::Adt(e.into()))\n+            }\n+            ast::ModuleItem::Module(ref m) if !m.has_semi() => {\n+                let src = Source { file_id: src.file_id, ast: ModuleSource::Module(m.clone()) };\n+                let module = Module::from_definition(db, src)?;\n+                Some(ModuleDef::Module(module))\n+            }\n+            _ => None,\n+        }\n+    }\n+}\n+\n // FIXME: simplify it\n impl ModuleSource {\n     pub fn from_position("}, {"sha": "13e42bb35c1a8b593ced1b1c764ba3edc1fd1b62", "filename": "crates/ra_ide_api/src/goto_definition.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/11577288c23b1f2de1aaba0137c9c2d6344b9a92/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11577288c23b1f2de1aaba0137c9c2d6344b9a92/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs?ref=11577288c23b1f2de1aaba0137c9c2d6344b9a92", "patch": "@@ -10,7 +10,7 @@ use ra_syntax::{\n use crate::{\n     db::RootDatabase,\n     display::ShortLabel,\n-    name_ref_kind::{classify_name_ref, NameRefKind::*},\n+    name_ref_kind::{classify_name_ref, NameKind::*},\n     FilePosition, NavigationTarget, RangeInfo,\n };\n "}, {"sha": "5c2549dc38cc50ab0a76b924706a27d2dad3874b", "filename": "crates/ra_ide_api/src/hover.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/11577288c23b1f2de1aaba0137c9c2d6344b9a92/crates%2Fra_ide_api%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11577288c23b1f2de1aaba0137c9c2d6344b9a92/crates%2Fra_ide_api%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fhover.rs?ref=11577288c23b1f2de1aaba0137c9c2d6344b9a92", "patch": "@@ -14,7 +14,7 @@ use crate::{\n         description_from_symbol, docs_from_symbol, macro_label, rust_code_markup,\n         rust_code_markup_with_doc, ShortLabel,\n     },\n-    name_ref_kind::{classify_name_ref, NameRefKind::*},\n+    name_ref_kind::{classify_name_ref, NameKind::*},\n     FilePosition, FileRange, RangeInfo,\n };\n "}, {"sha": "eb8caabfe42723103a3cb37a90db12fb836ad582", "filename": "crates/ra_ide_api/src/name_ref_kind.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/11577288c23b1f2de1aaba0137c9c2d6344b9a92/crates%2Fra_ide_api%2Fsrc%2Fname_ref_kind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11577288c23b1f2de1aaba0137c9c2d6344b9a92/crates%2Fra_ide_api%2Fsrc%2Fname_ref_kind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fname_ref_kind.rs?ref=11577288c23b1f2de1aaba0137c9c2d6344b9a92", "patch": "@@ -6,7 +6,7 @@ use test_utils::tested_by;\n \n use crate::db::RootDatabase;\n \n-pub enum NameRefKind {\n+pub enum NameKind {\n     Method(hir::Function),\n     Macro(hir::MacroDef),\n     FieldAccess(hir::StructField),\n@@ -22,8 +22,8 @@ pub(crate) fn classify_name_ref(\n     db: &RootDatabase,\n     analyzer: &hir::SourceAnalyzer,\n     name_ref: &ast::NameRef,\n-) -> Option<NameRefKind> {\n-    use NameRefKind::*;\n+) -> Option<NameKind> {\n+    use NameKind::*;\n \n     // Check if it is a method\n     if let Some(method_call) = name_ref.syntax().parent().and_then(ast::MethodCallExpr::cast) {"}, {"sha": "9335bc8cab248478d2a0d1e5d0afb075fc5a3d4b", "filename": "crates/ra_ide_api/src/references.rs", "status": "modified", "additions": 126, "deletions": 28, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/11577288c23b1f2de1aaba0137c9c2d6344b9a92/crates%2Fra_ide_api%2Fsrc%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11577288c23b1f2de1aaba0137c9c2d6344b9a92/crates%2Fra_ide_api%2Fsrc%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Freferences.rs?ref=11577288c23b1f2de1aaba0137c9c2d6344b9a92", "patch": "@@ -1,13 +1,18 @@\n //! FIXME: write short doc here\n \n-use hir::{Either, ModuleSource};\n+use hir::{FromSource, ModuleSource};\n use ra_db::{SourceDatabase, SourceDatabaseExt};\n-use ra_syntax::{algo::find_node_at_offset, ast, AstNode, SourceFile, SyntaxNode};\n+use ra_syntax::{algo::find_node_at_offset, ast, AstNode, AstPtr, SyntaxNode};\n use relative_path::{RelativePath, RelativePathBuf};\n \n use crate::{\n-    db::RootDatabase, FileId, FilePosition, FileRange, FileSystemEdit, NavigationTarget, RangeInfo,\n-    SourceChange, SourceFileEdit, TextRange,\n+    db::RootDatabase,\n+    name_ref_kind::{\n+        classify_name_ref,\n+        NameKind::{self, *},\n+    },\n+    FileId, FilePosition, FileRange, FileSystemEdit, NavigationTarget, RangeInfo, SourceChange,\n+    SourceFileEdit, TextRange,\n };\n \n #[derive(Debug, Clone)]\n@@ -52,41 +57,92 @@ pub(crate) fn find_all_refs(\n     position: FilePosition,\n ) -> Option<RangeInfo<ReferenceSearchResult>> {\n     let parse = db.parse(position.file_id);\n-    let RangeInfo { range, info: (binding, analyzer) } = find_binding(db, &parse.tree(), position)?;\n-    let declaration = NavigationTarget::from_bind_pat(position.file_id, &binding);\n+    let syntax = parse.tree().syntax().clone();\n+    let RangeInfo { range, info: (analyzer, name_kind) } = find_name(db, &syntax, position)?;\n+\n+    let declaration = match name_kind {\n+        Macro(mac) => NavigationTarget::from_macro_def(db, mac),\n+        FieldAccess(field) => NavigationTarget::from_field(db, field),\n+        AssocItem(assoc) => NavigationTarget::from_assoc_item(db, assoc),\n+        Method(func) => NavigationTarget::from_def_source(db, func),\n+        Def(def) => NavigationTarget::from_def(db, def)?,\n+        SelfType(ref ty) => match ty.as_adt() {\n+            Some((def_id, _)) => NavigationTarget::from_adt_def(db, def_id),\n+            None => return None,\n+        },\n+        Pat(pat) => NavigationTarget::from_pat(db, position.file_id, pat),\n+        SelfParam(par) => NavigationTarget::from_self_param(position.file_id, par),\n+        GenericParam(_) => return None,\n+    };\n \n-    let references = analyzer\n-        .find_all_refs(&binding)\n-        .into_iter()\n-        .map(move |ref_desc| FileRange { file_id: position.file_id, range: ref_desc.range })\n-        .collect::<Vec<_>>();\n+    let references = match name_kind {\n+        Pat(pat) => analyzer\n+            .find_all_refs(&pat.to_node(&syntax))\n+            .into_iter()\n+            .map(move |ref_desc| FileRange { file_id: position.file_id, range: ref_desc.range })\n+            .collect::<Vec<_>>(),\n+        _ => vec![],\n+    };\n \n     return Some(RangeInfo::new(range, ReferenceSearchResult { declaration, references }));\n \n-    fn find_binding<'a>(\n+    fn find_name<'a>(\n         db: &RootDatabase,\n-        source_file: &SourceFile,\n+        syntax: &SyntaxNode,\n         position: FilePosition,\n-    ) -> Option<RangeInfo<(ast::BindPat, hir::SourceAnalyzer)>> {\n-        let syntax = source_file.syntax();\n-        if let Some(binding) = find_node_at_offset::<ast::BindPat>(syntax, position.offset) {\n-            let range = binding.syntax().text_range();\n-            let analyzer = hir::SourceAnalyzer::new(db, position.file_id, binding.syntax(), None);\n-            return Some(RangeInfo::new(range, (binding, analyzer)));\n-        };\n-        let name_ref = find_node_at_offset::<ast::NameRef>(syntax, position.offset)?;\n+    ) -> Option<RangeInfo<(hir::SourceAnalyzer, NameKind)>> {\n+        if let Some(name) = find_node_at_offset::<ast::Name>(&syntax, position.offset) {\n+            let analyzer = hir::SourceAnalyzer::new(db, position.file_id, name.syntax(), None);\n+            let name_kind = classify_name(db, position.file_id, &name)?;\n+            let range = name.syntax().text_range();\n+            return Some(RangeInfo::new(range, (analyzer, name_kind)));\n+        }\n+        let name_ref = find_node_at_offset::<ast::NameRef>(&syntax, position.offset)?;\n         let range = name_ref.syntax().text_range();\n         let analyzer = hir::SourceAnalyzer::new(db, position.file_id, name_ref.syntax(), None);\n-        let resolved = analyzer.resolve_local_name(&name_ref)?;\n-        if let Either::A(ptr) = resolved.ptr() {\n-            if let ast::Pat::BindPat(binding) = ptr.to_node(source_file.syntax()) {\n-                return Some(RangeInfo::new(range, (binding, analyzer)));\n-            }\n-        }\n-        None\n+        let name_kind = classify_name_ref(db, &analyzer, &name_ref)?;\n+        Some(RangeInfo::new(range, (analyzer, name_kind)))\n     }\n }\n \n+fn classify_name(db: &RootDatabase, file_id: FileId, name: &ast::Name) -> Option<NameKind> {\n+    let parent = name.syntax().parent()?;\n+    let file_id = file_id.into();\n+\n+    if let Some(pat) = ast::BindPat::cast(parent.clone()) {\n+        return Some(Pat(AstPtr::new(&pat)));\n+    }\n+    if let Some(var) = ast::EnumVariant::cast(parent.clone()) {\n+        let src = hir::Source { file_id, ast: var };\n+        let var = hir::EnumVariant::from_source(db, src)?;\n+        return Some(Def(var.into()));\n+    }\n+    if let Some(field) = ast::RecordFieldDef::cast(parent.clone()) {\n+        let src = hir::Source { file_id, ast: hir::FieldSource::Named(field) };\n+        let field = hir::StructField::from_source(db, src)?;\n+        return Some(FieldAccess(field));\n+    }\n+    if let Some(field) = ast::TupleFieldDef::cast(parent.clone()) {\n+        let src = hir::Source { file_id, ast: hir::FieldSource::Pos(field) };\n+        let field = hir::StructField::from_source(db, src)?;\n+        return Some(FieldAccess(field));\n+    }\n+    if let Some(_) = parent.parent().and_then(ast::ItemList::cast) {\n+        let ast = ast::ImplItem::cast(parent.clone())?;\n+        let src = hir::Source { file_id, ast };\n+        let item = hir::AssocItem::from_source(db, src)?;\n+        return Some(AssocItem(item));\n+    }\n+    if let Some(item) = ast::ModuleItem::cast(parent.clone()) {\n+        let src = hir::Source { file_id, ast: item };\n+        let def = hir::ModuleDef::from_source(db, src)?;\n+        return Some(Def(def));\n+    }\n+    // FIXME: TYPE_PARAM, ALIAS, MACRO_CALL; Union\n+\n+    None\n+}\n+\n pub(crate) fn rename(\n     db: &RootDatabase,\n     position: FilePosition,\n@@ -249,6 +305,48 @@ mod tests {\n         assert_eq!(refs.len(), 2);\n     }\n \n+    #[test]\n+    fn test_find_all_refs_field_name() {\n+        let code = r#\"\n+            //- /lib.rs\n+            struct Foo {\n+                spam<|>: u32,\n+            }\n+        \"#;\n+\n+        let refs = get_all_refs(code);\n+        assert_eq!(refs.len(), 1);\n+    }\n+\n+    #[test]\n+    fn test_find_all_refs_impl_item_name() {\n+        let code = r#\"\n+            //- /lib.rs\n+            struct Foo;\n+            impl Foo {\n+                fn f<|>(&self) {  }\n+            }\n+        \"#;\n+\n+        let refs = get_all_refs(code);\n+        assert_eq!(refs.len(), 1);\n+    }\n+\n+    #[test]\n+    fn test_find_all_refs_enum_var_name() {\n+        let code = r#\"\n+            //- /lib.rs\n+            enum Foo {\n+                A,\n+                B<|>,\n+                C,\n+            }\n+        \"#;\n+\n+        let refs = get_all_refs(code);\n+        assert_eq!(refs.len(), 1);\n+    }\n+\n     fn get_all_refs(text: &str) -> ReferenceSearchResult {\n         let (analysis, position) = single_file_with_position(text);\n         analysis.find_all_refs(position).unwrap().unwrap()"}, {"sha": "ca1ac2b03098c58ed3159d745456e926995317b8", "filename": "crates/ra_ide_api/src/search_scope.rs", "status": "added", "additions": 186, "deletions": 0, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/11577288c23b1f2de1aaba0137c9c2d6344b9a92/crates%2Fra_ide_api%2Fsrc%2Fsearch_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11577288c23b1f2de1aaba0137c9c2d6344b9a92/crates%2Fra_ide_api%2Fsrc%2Fsearch_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fsearch_scope.rs?ref=11577288c23b1f2de1aaba0137c9c2d6344b9a92", "patch": "@@ -0,0 +1,186 @@\n+pub enum SearchScope {\n+    Function(hir::Function),\n+    Module(hir::Module),\n+    Crate(hir::Crate),\n+    Crates(Vec<hir::Crate>),\n+}\n+\n+pub struct SearchScope{ \n+    pub scope: Vec<SyntaxNode>\n+}\n+\n+pub fn find_all_refs(db: &RootDatabase, decl: NameKind) -> Vec<ReferenceDescriptor> {\n+    let (module, visibility) = match decl {\n+        FieldAccess(field) => {\n+            let parent = field.parent_def(db);\n+            let module = parent.module(db);\n+            let visibility = match parent {\n+                VariantDef::Struct(s) => s.source(db).ast.visibility(),\n+                VariantDef::EnumVariant(v) => v.parent_enum(db).source(db).ast.visibility(),\n+            };\n+            (module, visibility)\n+        }\n+        AssocItem(item) => {\n+            let parent = item.parent_trait(db)?;\n+            let module = parent.module(db);\n+            let visibility = parent.source(db).ast.visibility();\n+            (module, visibility)\n+        }\n+        Def(def) => {\n+            let (module, visibility) = match def {\n+                ModuleDef::Module(m) => (m, ),\n+                ModuleDef::Function(f) => (f.module(db), f.source(db).ast.visibility()),\n+                ModuleDef::Adt::Struct(s) => (s.module(db), s.source(db).ast.visibility()),\n+                ModuleDef::Adt::Union(u) => (u.module(db), u.source(db).ast.visibility()),\n+                ModuleDef::Adt::Enum(e) => (e.module(db), e.source(db).ast.visibility()),\n+                ModuleDef::EnumVariant(v) => (v.module(db), v.source(db).ast.visibility()),\n+                ModuleDef::Const(c) => (c.module(db), c.source(db).ast.visibility()),\n+                ModuleDef::Static(s) => (s.module(db), s.source(db).ast.visibility()),\n+                ModuleDef::Trait(t) => (t.module(db), t.source(db).ast.visibility()),\n+                ModuleDef::TypeAlias(a) => (a.module(db), a.source(db).ast.visibility()),\n+                ModuleDef::BuiltinType(_) => return vec![];\n+            };\n+            (module, visibility)\n+        }\n+        // FIXME: add missing kinds\n+        _ => return vec![];\n+    };\n+    let scope = scope(db, module, visibility);\n+}\n+\n+fn scope(db: &RootDatabase, module: hir::Module, item_vis: Option<ast::Visibility>) -> SearchScope {\n+    if let Some(v) = item_vis {\n+        let krate = module.krate(db)?;\n+\n+        if v.syntax().text() == \"pub\" {\n+            SearchScope::Crate(krate)\n+        }\n+        if v.syntax().text() == \"pub(crate)\" {\n+            let crate_graph = db.crate_graph();\n+            let crates = crate_graph.iter().filter(|id| {\n+                crate_graph.dependencies(id).any(|d| d.crate_id() == krate.crate_id())\n+            }).map(|id| Crate { id }).collect::<Vec<_>>();\n+            crates.insert(0, krate);\n+            SearchScope::Crates(crates)\n+        }\n+        // FIXME: \"pub(super)\", \"pub(in path)\"\n+        SearchScope::Module(module)\n+    }\n+    SearchScope::Module(module)\n+}\n+\n+fn process_one(db, scope: SearchScope, pat) {\n+    match scope {\n+        SearchScope::Crate(krate) => {\n+            let text = db.file_text(position.file_id).as_str();\n+            let parse = SourceFile::parse(text);\n+            for (offset, name) in text.match_indices(pat) {\n+                if let Some() = find_node_at_offset<ast::NameRef>(parse, offset) {\n+                    \n+                }\n+            }\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::{\n+        mock_analysis::analysis_and_position, mock_analysis::single_file_with_position, FileId,\n+        ReferenceSearchResult,\n+    };\n+    use insta::assert_debug_snapshot;\n+    use test_utils::assert_eq_text;\n+\n+    #[test]\n+    fn test_find_all_refs_for_local() {\n+        let code = r#\"\n+            fn main() {\n+                let mut i = 1;\n+                let j = 1;\n+                i = i<|> + j;\n+\n+                {\n+                    i = 0;\n+                }\n+\n+                i = 5;\n+            }\n+        \"#;\n+\n+        let refs = get_all_refs(code);\n+        assert_eq!(refs.len(), 5);\n+    }\n+\n+    #[test]\n+    fn test_find_all_refs_for_param_inside() {\n+        let code = r#\"\n+    fn foo(i : u32) -> u32 {\n+        i<|>\n+    }\"#;\n+\n+        let refs = get_all_refs(code);\n+        assert_eq!(refs.len(), 2);\n+    }\n+\n+    #[test]\n+    fn test_find_all_refs_for_fn_param() {\n+        let code = r#\"\n+    fn foo(i<|> : u32) -> u32 {\n+        i\n+    }\"#;\n+\n+        let refs = get_all_refs(code);\n+        assert_eq!(refs.len(), 2);\n+    }\n+\n+    #[test]\n+    fn test_find_all_refs_field_name() {\n+        let code = r#\"\n+            //- /lib.rs\n+            struct Foo {\n+                spam<|>: u32,\n+            }\n+        \"#;\n+\n+        let refs = get_all_refs(code);\n+        assert_eq!(refs.len(), 1);\n+    }\n+\n+    #[test]\n+    fn test_find_all_refs_methods() {\n+        let code = r#\"\n+            //- /lib.rs\n+            struct Foo;\n+            impl Foo {\n+                pub fn a() {\n+                    self.b()\n+                }\n+                fn b(&self) {}\n+            }\n+        \"#;\n+\n+        let refs = get_all_refs(code);\n+        assert_eq!(refs.len(), 1);\n+    }\n+\n+    #[test]\n+    fn test_find_all_refs_pub_enum() {\n+        let code = r#\"\n+            //- /lib.rs\n+            pub enum Foo {\n+                A,\n+                B<|>,\n+                C,\n+            }\n+        \"#;\n+\n+        let refs = get_all_refs(code);\n+        assert_eq!(refs.len(), 1);\n+    }\n+\n+    fn get_all_refs(text: &str) -> ReferenceSearchResult {\n+        let (analysis, position) = single_file_with_position(text);\n+        analysis.find_all_refs(position).unwrap().unwrap()\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "03104e3486cf5913cd459635622693ed623828b1", "filename": "crates/ra_ide_api/src/syntax_highlighting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/11577288c23b1f2de1aaba0137c9c2d6344b9a92/crates%2Fra_ide_api%2Fsrc%2Fsyntax_highlighting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11577288c23b1f2de1aaba0137c9c2d6344b9a92/crates%2Fra_ide_api%2Fsrc%2Fsyntax_highlighting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fsyntax_highlighting.rs?ref=11577288c23b1f2de1aaba0137c9c2d6344b9a92", "patch": "@@ -14,7 +14,7 @@ use ra_syntax::{\n \n use crate::{\n     db::RootDatabase,\n-    name_ref_kind::{classify_name_ref, NameRefKind::*},\n+    name_ref_kind::{classify_name_ref, NameKind::*},\n     FileId,\n };\n "}]}