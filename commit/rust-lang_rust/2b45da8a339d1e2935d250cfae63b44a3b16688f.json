{"sha": "2b45da8a339d1e2935d250cfae63b44a3b16688f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJiNDVkYThhMzM5ZDFlMjkzNWQyNTBjZmFlNjNiNDRhM2IxNjY4OGY=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-03-28T19:54:06Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-03-30T02:41:09Z"}, "message": "refactor to store the types during inference in tables in the fcx\n\nthis is a step towards separating out the repr. of\ntypes during inference from the repr. in later stages.", "tree": {"sha": "870c5afa7eeadae4dfc8d822ab9dcf536c016fb6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/870c5afa7eeadae4dfc8d822ab9dcf536c016fb6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2b45da8a339d1e2935d250cfae63b44a3b16688f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2b45da8a339d1e2935d250cfae63b44a3b16688f", "html_url": "https://github.com/rust-lang/rust/commit/2b45da8a339d1e2935d250cfae63b44a3b16688f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2b45da8a339d1e2935d250cfae63b44a3b16688f/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f682b99e36b8963890c3280c784f88274de55267", "url": "https://api.github.com/repos/rust-lang/rust/commits/f682b99e36b8963890c3280c784f88274de55267", "html_url": "https://github.com/rust-lang/rust/commit/f682b99e36b8963890c3280c784f88274de55267"}], "stats": {"total": 538, "additions": 358, "deletions": 180}, "files": [{"sha": "a27293ea19e30205c9615d03ee76c82352ecee66", "filename": "src/librustsyntax/visit.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2b45da8a339d1e2935d250cfae63b44a3b16688f/src%2Flibrustsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b45da8a339d1e2935d250cfae63b44a3b16688f/src%2Flibrustsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fvisit.rs?ref=2b45da8a339d1e2935d250cfae63b44a3b16688f", "patch": "@@ -130,7 +130,7 @@ fn visit_item<E>(i: @item, e: E, v: vt<E>) {\n       }\n       item_impl(tps, ifce, ty, methods) {\n         v.visit_ty_params(tps, e, v);\n-        alt ifce { some(ty) { v.visit_ty(ty, e, v); } _ {} }\n+        alt ifce { some(ty) { v.visit_ty(ty, e, v); } none {} }\n         v.visit_ty(ty, e, v);\n         for m in methods {\n             visit_method_helper(m, e, v)\n@@ -193,7 +193,11 @@ fn visit_ty<E>(t: @ty, e: E, v: vt<E>) {\n             v.visit_constr(tc.node.path, tc.span, tc.node.id, e, v);\n         }\n       }\n-      _ {}\n+      ty_nil |\n+      ty_bot |\n+      ty_mac(_) |\n+      ty_infer {\n+      }\n     }\n }\n \n@@ -243,7 +247,7 @@ fn visit_ty_params<E>(tps: [ty_param], e: E, v: vt<E>) {\n         for bound in *tp.bounds {\n             alt bound {\n               bound_iface(t) { v.visit_ty(t, e, v); }\n-              _ {}\n+              bound_copy | bound_send { }\n             }\n         }\n     }"}, {"sha": "070787737a6f7bdd336ddbf322aeda2554bfb15f", "filename": "src/rustc/middle/ast_map.rs", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/2b45da8a339d1e2935d250cfae63b44a3b16688f/src%2Frustc%2Fmiddle%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b45da8a339d1e2935d250cfae63b44a3b16688f/src%2Frustc%2Fmiddle%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fast_map.rs?ref=2b45da8a339d1e2935d250cfae63b44a3b16688f", "patch": "@@ -1,6 +1,7 @@\n import std::map;\n import std::map::hashmap;\n import syntax::ast::*;\n+import syntax::print::pprust;\n import syntax::ast_util;\n import syntax::ast_util::inlined_item_methods;\n import syntax::{visit, codemap};\n@@ -20,6 +21,14 @@ fn path_to_str_with_sep(p: path, sep: str) -> str {\n     str::connect(strs, sep)\n }\n \n+fn path_ident_to_str(p: path, i: ident) -> str {\n+    if vec::is_empty(p) {\n+        i\n+    } else {\n+        #fmt[\"%s::%s\", path_to_str(p), i]\n+    }\n+}\n+\n fn path_to_str(p: path) -> str {\n     path_to_str_with_sep(p, \"::\")\n }\n@@ -224,6 +233,49 @@ fn map_expr(ex: @expr, cx: ctx, v: vt) {\n     visit::visit_expr(ex, cx, v);\n }\n \n+fn node_id_to_str(map: map, id: node_id) -> str {\n+    alt map.find(id) {\n+      none {\n+        #fmt[\"unknown node (id=%d)\", id]\n+      }\n+      some(node_item(item, path)) {\n+        #fmt[\"item %s (id=%?)\", path_ident_to_str(*path, item.ident), id]\n+      }\n+      some(node_native_item(item, abi, path)) {\n+        #fmt[\"native item %s with abi %? (id=%?)\",\n+             path_ident_to_str(*path, item.ident), abi, id]\n+      }\n+      some(node_method(m, impl_did, path)) {\n+        #fmt[\"method %s in %s (id=%?)\",\n+             m.ident, path_to_str(*path), id]\n+      }\n+      some(node_variant(variant, def_id, path)) {\n+        #fmt[\"variant %s in %s (id=%?)\",\n+             variant.node.name, path_to_str(*path), id]\n+      }\n+      some(node_expr(expr)) {\n+        #fmt[\"expr %s (id=%?)\",\n+             pprust::expr_to_str(expr), id]\n+      }\n+      some(node_export(_, path)) {\n+        #fmt[\"export %s (id=%?)\", // FIXME: add more info here\n+             path_to_str(*path), id]\n+      }\n+      some(node_arg(_, _)) { // FIXME: add more info here\n+        #fmt[\"arg (id=%?)\", id]\n+      }\n+      some(node_local(_)) { // FIXME: add more info here\n+        #fmt[\"local (id=%?)\", id]\n+      }\n+      some(node_ctor(_, _)) { // FIXME: add more info here\n+        #fmt[\"node_ctor (id=%?)\", id]\n+      }\n+      some(node_block(_)) {\n+        #fmt[\"block\"]\n+      }\n+    }\n+}\n+\n // Local Variables:\n // mode: rust\n // fill-column: 78;"}, {"sha": "ad4d0ec58b25add5f395a306a751bc4d00f8231e", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2b45da8a339d1e2935d250cfae63b44a3b16688f/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b45da8a339d1e2935d250cfae63b44a3b16688f/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=2b45da8a339d1e2935d250cfae63b44a3b16688f", "patch": "@@ -1561,7 +1561,8 @@ fn constrs_eq(cs: [@constr], ds: [@constr]) -> bool {\n fn node_id_to_type(cx: ctxt, id: ast::node_id) -> t {\n     alt smallintmap::find(*cx.node_types, id as uint) {\n        some(t) { t }\n-       none { cx.sess.bug(#fmt(\"node_id_to_type: unbound node ID %?\", id)); }\n+       none { cx.sess.bug(#fmt(\"node_id_to_type: unbound node ID %s\",\n+                               ast_map::node_id_to_str(cx.items, id))); }\n     }\n }\n "}, {"sha": "12c81361c6b81e6feaef3fbef74012197616dc4c", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 297, "deletions": 176, "changes": 473, "blob_url": "https://github.com/rust-lang/rust/blob/2b45da8a339d1e2935d250cfae63b44a3b16688f/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b45da8a339d1e2935d250cfae63b44a3b16688f/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=2b45da8a339d1e2935d250cfae63b44a3b16688f", "patch": "@@ -9,11 +9,12 @@ import util::common::*;\n import syntax::codemap::span;\n import pat_util::*;\n import middle::ty;\n-import middle::ty::{node_id_to_type, arg, block_ty,\n-                    expr_ty, field, node_type_table, mk_nil,\n+import middle::ty::{arg, field, node_type_table, mk_nil,\n                     ty_param_bounds_and_ty, lookup_public_fields};\n import util::ppaux::ty_to_str;\n import std::smallintmap;\n+import std::smallintmap::map;\n+import std::map;\n import std::map::{hashmap, int_hash};\n import std::serialization::{serialize_uint, deserialize_uint};\n import std::ufind;\n@@ -81,6 +82,8 @@ type fn_ctxt =\n      locals: hashmap<ast::node_id, int>,\n      next_var_id: @mut int,\n      next_region_var_id: @mut int,\n+     node_types: smallintmap::smallintmap<ty::t>,\n+     node_type_substs: hashmap<ast::node_id, [ty::t]>,\n      ccx: @crate_ctxt};\n \n // Determines whether the given node ID is a use of the def of\n@@ -202,12 +205,12 @@ fn instantiate_path(fcx: @fn_ctxt, pth: @ast::path,\n         let substs = vec::map(pth.node.types, {|aty|\n             ast_ty_to_ty_crate(fcx.ccx, aty)\n         });\n-        write_ty_substs(fcx.ccx.tcx, id, tpt.ty, substs);\n+        fcx.write_ty_substs(id, tpt.ty, substs);\n     } else if ty_param_count > 0u {\n         let vars = vec::from_fn(ty_param_count, {|_i| next_ty_var(fcx)});\n-        write_ty_substs(fcx.ccx.tcx, id, tpt.ty, vars);\n+        fcx.write_ty_substs(id, tpt.ty, vars);\n     } else {\n-        write_ty(fcx.ccx.tcx, id, tpt.ty);\n+        fcx.write_ty(id, tpt.ty);\n     }\n }\n \n@@ -308,7 +311,7 @@ fn ast_ty_to_ty(tcx: ty::ctxt, mode: mode, &&ast_ty: @ast::ty) -> ty::t {\n         let typ =\n             ty::substitute_type_params(tcx, param_bindings,\n                                        ty_param_bounds_and_ty.ty);\n-        write_substs(tcx, path_id, param_bindings);\n+        write_substs_to_tcx(tcx, path_id, param_bindings);\n         ret typ;\n     }\n     fn do_ast_ty_to_ty(tcx: ty::ctxt, mode: mode, &&ast_ty: @ast::ty)\n@@ -738,25 +741,83 @@ fn ast_ty_to_ty_crate_infer(ccx: @crate_ctxt, &&ast_ty: @ast::ty) ->\n \n \n // Functions that write types into the node type table\n-fn write_ty(tcx: ty::ctxt, node_id: ast::node_id, ty: ty::t) {\n+fn write_ty_to_tcx(tcx: ty::ctxt, node_id: ast::node_id, ty: ty::t) {\n     smallintmap::insert(*tcx.node_types, node_id as uint, ty);\n }\n-fn write_substs(tcx: ty::ctxt, node_id: ast::node_id, +substs: [ty::t]) {\n+fn write_substs_to_tcx(tcx: ty::ctxt, node_id: ast::node_id,\n+                       +substs: [ty::t]) {\n     tcx.node_type_substs.insert(node_id, substs);\n }\n-fn write_ty_substs(tcx: ty::ctxt, node_id: ast::node_id, ty: ty::t,\n+fn write_ty_substs_to_tcx(tcx: ty::ctxt, node_id: ast::node_id, ty: ty::t,\n                    +substs: [ty::t]) {\n     let ty = if ty::type_has_params(ty) {\n         ty::substitute_type_params(tcx, substs, ty)\n     } else { ty };\n-    write_ty(tcx, node_id, ty);\n-    write_substs(tcx, node_id, substs);\n+    write_ty_to_tcx(tcx, node_id, ty);\n+    write_substs_to_tcx(tcx, node_id, substs);\n }\n-fn write_nil(tcx: ty::ctxt, node_id: ast::node_id) {\n-    write_ty(tcx, node_id, ty::mk_nil(tcx));\n-}\n-fn write_bot(tcx: ty::ctxt, node_id: ast::node_id) {\n-    write_ty(tcx, node_id, ty::mk_bot(tcx));\n+\n+impl methods for @fn_ctxt {\n+    fn tcx() -> ty::ctxt { self.ccx.tcx }\n+    fn tag() -> str { #fmt[\"%x\", ptr::addr_of(*self) as uint] }\n+    fn write_ty(node_id: ast::node_id, ty: ty::t) {\n+        #debug[\"write_ty(%d, %s) in fcx %s\",\n+               node_id, ty_to_str(self.tcx(), ty), self.tag()];\n+        self.node_types.insert(node_id as uint, ty);\n+    }\n+    fn write_substs(node_id: ast::node_id, +substs: [ty::t]) {\n+        self.node_type_substs.insert(node_id, substs);\n+    }\n+    fn write_ty_substs(node_id: ast::node_id, ty: ty::t, +substs: [ty::t]) {\n+        if substs.len() == 0u {\n+            self.write_ty(node_id, ty)\n+        } else {\n+            let ty = ty::substitute_type_params(self.tcx(), substs, ty);\n+            self.write_ty(node_id, ty);\n+            self.write_substs(node_id, substs);\n+        }\n+    }\n+    fn write_nil(node_id: ast::node_id) {\n+        self.write_ty(node_id, ty::mk_nil(self.tcx()));\n+    }\n+    fn write_bot(node_id: ast::node_id) {\n+        self.write_ty(node_id, ty::mk_bot(self.tcx()));\n+    }\n+\n+    fn expr_ty(ex: @ast::expr) -> ty::t {\n+        alt self.node_types.find(ex.id as uint) {\n+          some(t) { t }\n+          none {\n+            self.tcx().sess.bug(#fmt[\"no type for expr %d (%s) in fcx %s\",\n+                                     ex.id, expr_to_str(ex), self.tag()]);\n+          }\n+        }\n+    }\n+    fn node_ty(id: ast::node_id) -> ty::t {\n+        alt self.node_types.find(id as uint) {\n+          some(t) { t }\n+          none {\n+            self.tcx().sess.bug(\n+                #fmt[\"no type for node %d: %s in fcx %s\",\n+                     id, ast_map::node_id_to_str(self.tcx().items, id),\n+                     self.tag()]);\n+          }\n+        }\n+    }\n+    fn node_ty_substs(id: ast::node_id) -> [ty::t] {\n+        alt self.node_type_substs.find(id) {\n+          some(ts) { ts }\n+          none {\n+            self.tcx().sess.bug(\n+                #fmt[\"no type substs for node %d: %s in fcx %s\",\n+                     id, ast_map::node_id_to_str(self.tcx().items, id),\n+                     self.tag()]);\n+          }\n+        }\n+    }\n+    fn opt_node_ty_substs(id: ast::node_id) -> option<[ty::t]> {\n+        self.node_type_substs.find(id)\n+    }\n }\n \n fn mk_ty_params(tcx: ty::ctxt, atps: [ast::ty_param])\n@@ -926,7 +987,7 @@ mod collect {\n             let tpt = {bounds: ty_param_bounds(tcx, m_collect, ty_params),\n                        ty: result_ty};\n             tcx.tcache.insert(local_def(variant.node.id), tpt);\n-            write_ty(tcx, variant.node.id, result_ty);\n+            write_ty_to_tcx(tcx, variant.node.id, result_ty);\n         }\n     }\n     fn ensure_iface_methods(tcx: ty::ctxt, id: ast::node_id) {\n@@ -958,7 +1019,7 @@ mod collect {\n          class. outside the class, it's done with expr_field */\n         let tt = ast_ty_to_ty(tcx, m_collect, v.ty);\n         #debug(\"convert_class_item: %s %?\", v.ident, v.id);\n-        write_ty(tcx, v.id, tt);\n+        write_ty_to_tcx(tcx, v.id, tt);\n     }\n     fn convert_methods(tcx: ty::ctxt, ms: [@ast::method],\n         i_bounds: @[ty::param_bounds], maybe_self: option<ty::t>)\n@@ -967,7 +1028,7 @@ mod collect {\n         for m in ms {\n            alt maybe_self {\n               some(selfty) {\n-                write_ty(tcx, m.self_id, selfty);\n+                write_ty_to_tcx(tcx, m.self_id, selfty);\n               }\n               _ {}\n            }\n@@ -978,7 +1039,7 @@ mod collect {\n            tcx.tcache.insert(local_def(m.id),\n                              {bounds: @(*i_bounds + *bounds),\n                                      ty: fty});\n-           write_ty(tcx, m.id, fty);\n+           write_ty_to_tcx(tcx, m.id, fty);\n         }\n         my_methods\n     }\n@@ -994,13 +1055,13 @@ mod collect {\n           }\n           ast::item_enum(variants, ty_params) {\n             let tpt = ty_of_item(tcx, m_collect, it);\n-            write_ty(tcx, it.id, tpt.ty);\n+            write_ty_to_tcx(tcx, it.id, tpt.ty);\n             get_enum_variant_types(tcx, tpt.ty, variants, ty_params);\n           }\n           ast::item_impl(tps, ifce, selfty, ms) {\n             let i_bounds = ty_param_bounds(tcx, m_collect, tps);\n             let selfty = ast_ty_to_ty(tcx, m_collect, selfty);\n-            write_ty(tcx, it.id, selfty);\n+            write_ty_to_tcx(tcx, it.id, selfty);\n             tcx.tcache.insert(local_def(it.id), {bounds: i_bounds,\n                                                  ty: selfty});\n             let my_methods = convert_methods(tcx, ms, i_bounds, some(selfty));\n@@ -1011,7 +1072,9 @@ mod collect {\n                   ty::ty_iface(did, tys) {\n                     // Store the iface type in the type node\n                     alt check t.node {\n-                      ast::ty_path(_, t_id) { write_ty(tcx, t_id, iface_ty); }\n+                      ast::ty_path(_, t_id) {\n+                        write_ty_to_tcx(tcx, t_id, iface_ty);\n+                      }\n                     }\n                     if did.crate == ast::local_crate {\n                         ensure_iface_methods(tcx, did.node);\n@@ -1034,7 +1097,7 @@ mod collect {\n                                 tcx.tcache.insert(local_def(id),\n                                                      {bounds: old.bounds,\n                                                      ty: mt});\n-                                write_ty(tcx, id, mt);\n+                                write_ty_to_tcx(tcx, id, mt);\n                             }\n                           }\n                           none {\n@@ -1069,27 +1132,27 @@ mod collect {\n                 inputs: [t_arg], output: ty::mk_nil(tcx),\n                 ret_style: ast::return_val, constraints: []\n             });\n-            write_ty(tcx, it.id, t_res);\n-            write_ty(tcx, ctor_id, t_ctor);\n+            write_ty_to_tcx(tcx, it.id, t_res);\n+            write_ty_to_tcx(tcx, ctor_id, t_ctor);\n             tcx.tcache.insert(local_def(ctor_id),\n                               {bounds: bounds, ty: t_ctor});\n             tcx.tcache.insert(def_id, {bounds: bounds, ty: t_res});\n-            write_ty(tcx, dtor_id, t_dtor);\n+            write_ty_to_tcx(tcx, dtor_id, t_dtor);\n           }\n           ast::item_iface(_, ms) {\n             let tpt = ty_of_item(tcx, m_collect, it);\n-            write_ty(tcx, it.id, tpt.ty);\n+            write_ty_to_tcx(tcx, it.id, tpt.ty);\n             ensure_iface_methods(tcx, it.id);\n           }\n           ast::item_class(tps, members, ctor) {\n               // Write the class type\n               let tpt = ty_of_item(tcx, m_collect, it);\n-              write_ty(tcx, it.id, tpt.ty);\n+              write_ty_to_tcx(tcx, it.id, tpt.ty);\n               // Write the ctor type\n               let t_ctor = ty::mk_fn(tcx,\n                                      ty_of_fn_decl(tcx, m_collect,\n                                              ast::proto_any, ctor.node.dec));\n-              write_ty(tcx, ctor.node.id, t_ctor);\n+              write_ty_to_tcx(tcx, ctor.node.id, t_ctor);\n               tcx.tcache.insert(local_def(ctor.node.id),\n                                    {bounds: tpt.bounds, ty: t_ctor});\n               ensure_iface_methods(tcx, it.id);\n@@ -1111,7 +1174,7 @@ mod collect {\n             // of the item in passing. All we have to do here is to write\n             // it into the node type table.\n             let tpt = ty_of_item(tcx, m_collect, it);\n-            write_ty(tcx, it.id, tpt.ty);\n+            write_ty_to_tcx(tcx, it.id, tpt.ty);\n           }\n         }\n     }\n@@ -1121,7 +1184,9 @@ mod collect {\n         // table.\n         let tpt = ty_of_native_item(tcx, m_collect, i);\n         alt i.node {\n-          ast::native_item_fn(_, _) { write_ty(tcx, i.id, tpt.ty); }\n+          ast::native_item_fn(_, _) {\n+            write_ty_to_tcx(tcx, i.id, tpt.ty);\n+          }\n         }\n     }\n     fn collect_item_types(tcx: ty::ctxt, crate: @ast::crate) {\n@@ -1327,7 +1392,7 @@ fn variant_arg_types(ccx: @crate_ctxt, _sp: span, vid: ast::def_id,\n // substitutions.\n mod writeback {\n \n-    export resolve_type_vars_in_block;\n+    export resolve_type_vars_in_fn;\n     export resolve_type_vars_in_expr;\n \n     fn resolve_type_vars_in_type(fcx: @fn_ctxt, sp: span, typ: ty::t) ->\n@@ -1353,15 +1418,15 @@ mod writeback {\n     fn resolve_type_vars_for_node(wbcx: wb_ctxt, sp: span, id: ast::node_id)\n         -> option<ty::t> {\n         let fcx = wbcx.fcx, tcx = fcx.ccx.tcx;\n-        alt resolve_type_vars_in_type(fcx, sp, ty::node_id_to_type(tcx, id)) {\n+        alt resolve_type_vars_in_type(fcx, sp, fcx.node_ty(id)) {\n           none {\n             wbcx.success = false;\n             ret none;\n           }\n \n           some(t) {\n-            write_ty(tcx, id, t);\n-            alt tcx.node_type_substs.find(id) {\n+            write_ty_to_tcx(tcx, id, t);\n+            alt fcx.opt_node_ty_substs(id) {\n               some(substs) {\n                 let mut new_substs = [];\n                 for subst: ty::t in substs {\n@@ -1370,7 +1435,7 @@ mod writeback {\n                       none { wbcx.success = false; ret none; }\n                     }\n                 }\n-                write_substs(tcx, id, new_substs);\n+                write_substs_to_tcx(tcx, id, new_substs);\n               }\n               none {}\n             }\n@@ -1379,6 +1444,16 @@ mod writeback {\n         }\n     }\n \n+    fn maybe_resolve_type_vars_for_node(wbcx: wb_ctxt, sp: span,\n+                                        id: ast::node_id)\n+        -> option<ty::t> {\n+        if wbcx.fcx.node_types.contains_key(id as uint) {\n+            resolve_type_vars_for_node(wbcx, sp, id)\n+        } else {\n+            none\n+        }\n+    }\n+\n     type wb_ctxt =\n         // As soon as we hit an error we have to stop resolving\n         // the entire function\n@@ -1411,6 +1486,17 @@ mod writeback {\n                 }\n             }\n           }\n+\n+          ast::expr_new(_, alloc_id, _) {\n+            resolve_type_vars_for_node(wbcx, e.span, alloc_id);\n+          }\n+\n+          ast::expr_binary(_, _, _) | ast::expr_unary(_, _) |\n+          ast::expr_assign_op(_, _, _) | ast::expr_index(_, _) {\n+            maybe_resolve_type_vars_for_node(wbcx, e.span,\n+                                             ast_util::op_expr_callee_id(e));\n+          }\n+\n           _ { }\n         }\n         visit::visit_expr(e, wbcx, v);\n@@ -1438,7 +1524,7 @@ mod writeback {\n             #debug[\"Type for local %s (id %d) resolved to %s\",\n                    pat_to_str(l.node.pat), l.node.id,\n                    ty_to_str(wbcx.fcx.ccx.tcx, lty)];\n-            write_ty(wbcx.fcx.ccx.tcx, l.node.id, lty);\n+            write_ty_to_tcx(wbcx.fcx.ccx.tcx, l.node.id, lty);\n           }\n           result::err(-1) {\n             wbcx.fcx.ccx.tcx.sess.span_err(\n@@ -1469,11 +1555,13 @@ mod writeback {\n                            visit_pat: visit_pat,\n                            visit_local: visit_local\n                               with *visit::default_visitor()});\n-        visit::visit_expr(e, wbcx, visit);\n+        visit.visit_expr(e, wbcx, visit);\n         ret wbcx.success;\n     }\n \n-    fn resolve_type_vars_in_block(fcx: @fn_ctxt, blk: ast::blk) -> bool {\n+    fn resolve_type_vars_in_fn(fcx: @fn_ctxt,\n+                               decl: ast::fn_decl,\n+                               blk: ast::blk) -> bool {\n         let wbcx = {fcx: fcx, mut success: true};\n         let visit =\n             visit::mk_vt(@{visit_item: visit_item,\n@@ -1484,8 +1572,12 @@ mod writeback {\n                            visit_local: visit_local\n                               with *visit::default_visitor()});\n         visit.visit_block(blk, wbcx, visit);\n+        for arg in decl.inputs {\n+            resolve_type_vars_for_node(wbcx, arg.ty.span, arg.id);\n+        }\n         ret wbcx.success;\n     }\n+\n }\n \n fn check_intrinsic_type(tcx: ty::ctxt, it: @ast::native_item) {\n@@ -1541,7 +1633,7 @@ type gather_result =\n fn gather_locals(ccx: @crate_ctxt,\n                  decl: ast::fn_decl,\n                  body: ast::blk,\n-                 id: ast::node_id,\n+                 arg_tys: [ty::t],\n                  old_fcx: option<@fn_ctxt>) -> gather_result {\n     let {infcx, locals, nvi} = alt old_fcx {\n       none {\n@@ -1571,13 +1663,10 @@ fn gather_locals(ccx: @crate_ctxt,\n     };\n \n     // Add formal parameters.\n-    let args = ty::ty_fn_args(ty::node_id_to_type(ccx.tcx, id));\n-    let mut i = 0u;\n-    for arg: ty::arg in args {\n-        assign(decl.inputs[i].id, some(arg.ty));\n+    vec::iter2(arg_tys, decl.inputs) {|arg_ty, input|\n+        assign(input.id, some(arg_ty));\n         #debug[\"Argument %s is assigned to <T%d>\",\n-               decl.inputs[i].ident, locals.get(decl.inputs[i].id)];\n-        i += 1u;\n+               input.ident, locals.get(input.id)];\n     }\n \n     // Add explicitly-declared locals.\n@@ -1724,6 +1813,7 @@ fn universally_quantify_regions(fcx: @fn_ctxt, renv: @region_env, ty: ty::t)\n fn check_pat_variant(pcx: pat_ctxt, pat: @ast::pat, path: @ast::path,\n                      subpats: [@ast::pat], expected: ty::t) {\n     // Typecheck the path.\n+    let fcx = pcx.fcx;\n     let tcx = pcx.fcx.ccx.tcx;\n     let v_def = lookup_def(pcx.fcx, path.span, pat.id);\n     let v_def_ids = ast_util::variant_def_ids(v_def);\n@@ -1733,7 +1823,7 @@ fn check_pat_variant(pcx: pat_ctxt, pat: @ast::pat, path: @ast::path,\n     // Take the enum type params out of `expected`.\n     alt structure_of(pcx.fcx, pat.span, expected) {\n       ty::ty_enum(_, expected_tps) {\n-        let ctor_ty = ty::node_id_to_type(tcx, pat.id);\n+        let ctor_ty = fcx.node_ty(pat.id);\n         demand::with_substs(pcx.fcx, pat.span, expected, ctor_ty,\n                             expected_tps);\n         // Get the number of arguments in this enum variant.\n@@ -1780,24 +1870,25 @@ fn check_pat_variant(pcx: pat_ctxt, pat: @ast::pat, path: @ast::path,\n // Pattern checking is top-down rather than bottom-up so that bindings get\n // their types immediately.\n fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n+    let fcx = pcx.fcx;\n     let tcx = pcx.fcx.ccx.tcx;\n     alt pat.node {\n       ast::pat_wild {\n-        write_ty(tcx, pat.id, expected);\n+        fcx.write_ty(pat.id, expected);\n       }\n       ast::pat_lit(lt) {\n         check_expr_with(pcx.fcx, lt, expected);\n-        write_ty(tcx, pat.id, expr_ty(tcx, lt));\n+        fcx.write_ty(pat.id, fcx.expr_ty(lt));\n       }\n       ast::pat_range(begin, end) {\n         check_expr_with(pcx.fcx, begin, expected);\n         check_expr_with(pcx.fcx, end, expected);\n         let b_ty = resolve_type_vars_if_possible(pcx.fcx,\n-                                                 expr_ty(tcx, begin));\n+                                                 fcx.expr_ty(begin));\n         if !require_same_types(\n             tcx, pat.span, b_ty,\n             resolve_type_vars_if_possible(\n-                pcx.fcx, expr_ty(tcx, end)),\n+                pcx.fcx, fcx.expr_ty(end)),\n             {|| \"mismatched types in range\" }) {\n             // no-op\n         } else if !ty::type_is_numeric(b_ty) {\n@@ -1806,7 +1897,7 @@ fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n             tcx.sess.span_err(begin.span, \"lower range bound must be less \\\n                                            than upper\");\n         }\n-        write_ty(tcx, pat.id, b_ty);\n+        fcx.write_ty(pat.id, b_ty);\n       }\n       ast::pat_ident(name, sub)\n       if !pat_util::pat_is_variant(tcx.def_map, pat) {\n@@ -1819,7 +1910,7 @@ fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n             let ct = ty::mk_var(tcx, tv_id);\n             typ = demand::simple(pcx.fcx, pat.span, ct, typ);\n         }\n-        write_ty(tcx, pat.id, typ);\n+        fcx.write_ty(pat.id, typ);\n         alt sub {\n           some(p) { check_pat(pcx, p, expected); }\n           _ {}\n@@ -1866,7 +1957,7 @@ fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n               }\n             }\n         }\n-        write_ty(tcx, pat.id, expected);\n+        fcx.write_ty(pat.id, expected);\n       }\n       ast::pat_tup(elts) {\n         let ex_elts = alt structure_of(pcx.fcx, pat.span, expected) {\n@@ -1891,13 +1982,13 @@ fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n             i += 1u;\n         }\n \n-        write_ty(tcx, pat.id, expected);\n+        fcx.write_ty(pat.id, expected);\n       }\n       ast::pat_box(inner) {\n         alt structure_of(pcx.fcx, pat.span, expected) {\n           ty::ty_box(e_inner) {\n             check_pat(pcx, inner, e_inner.ty);\n-            write_ty(tcx, pat.id, expected);\n+            fcx.write_ty(pat.id, expected);\n           }\n           _ {\n             tcx.sess.span_fatal(pat.span,\n@@ -1911,7 +2002,7 @@ fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n         alt structure_of(pcx.fcx, pat.span, expected) {\n           ty::ty_uniq(e_inner) {\n             check_pat(pcx, inner, e_inner.ty);\n-            write_ty(tcx, pat.id, expected);\n+            fcx.write_ty(pat.id, expected);\n           }\n           _ {\n             tcx.sess.span_fatal(pat.span,\n@@ -2036,24 +2127,24 @@ fn lookup_method(fcx: @fn_ctxt, expr: @ast::expr, node_id: ast::node_id,\n             } else {\n                 substs += tps;\n             }\n-            write_ty_substs(tcx, node_id, fty, substs);\n+            fcx.write_ty_substs(node_id, fty, substs);\n         } else {\n             if n_tys > 0u {\n                 tcx.sess.span_err(expr.span, \"this method does not take type \\\n                                               parameters\");\n             }\n-            write_ty(tcx, node_id, fty);\n+            fcx.write_ty(node_id, fty);\n         }\n         if has_self && !option::is_none(self_sub) {\n-            let fty = ty::node_id_to_type(tcx, node_id);\n+            let fty = fcx.node_ty(node_id);\n             let fty = fixup_self_in_method_ty(\n                 tcx, fty, substs, option::get(self_sub));\n-            write_ty(tcx, node_id, fty);\n+            fcx.write_ty(node_id, fty);\n         }\n         if ty::type_has_rptrs(ty::ty_fn_ret(fty)) {\n-            let fty = ty::node_id_to_type(tcx, node_id);\n+            let fty = fcx.node_ty(node_id);\n             let fty = fixup_self_region_in_method_ty(fcx, fty, expr);\n-            write_ty(tcx, node_id, fty);\n+            fcx.write_ty(node_id, fty);\n         }\n         some(origin)\n       }\n@@ -2286,7 +2377,7 @@ fn region_of(fcx: @fn_ctxt, expr: @ast::expr) -> ty::region {\n                                          \"regions of index operations\");\n         }\n         ast::expr_unary(ast::deref, base) {\n-            let expr_ty = ty::expr_ty(fcx.ccx.tcx, base);\n+            let expr_ty = fcx.expr_ty(base);\n             let expr_ty = structurally_resolved_type(fcx, expr.span, expr_ty);\n             alt ty::get(expr_ty).struct {\n                 ty::ty_rptr(region, _) { region }\n@@ -2319,15 +2410,19 @@ fn check_expr_fn_with_unifier(fcx: @fn_ctxt,\n            expr_to_str(expr),\n            ty_to_str(tcx, fty));\n \n-    write_ty(tcx, expr.id, fty);\n+    fcx.write_ty(expr.id, fty);\n \n     // Unify the type of the function with the expected type before we\n     // typecheck the body so that we have more information about the\n     // argument types in the body. This is needed to make binops and\n     // record projection work on type inferred arguments.\n     unify(fcx, expr.span, expected, fty);\n \n-    check_fn(fcx.ccx, proto, decl, body, expr.id, is_loop_body, some(fcx));\n+    let ret_ty = ty::ty_fn_ret(fty);\n+    let arg_tys = vec::map(ty::ty_fn_args(fty)) {|a| a.ty };\n+\n+    check_fn(fcx.ccx, proto, decl, body,\n+             ret_ty, arg_tys, is_loop_body, some(fcx));\n }\n \n fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n@@ -2415,8 +2510,8 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n     fn check_assignment(fcx: @fn_ctxt, _sp: span, lhs: @ast::expr,\n                         rhs: @ast::expr, id: ast::node_id) -> bool {\n         let mut bot = check_expr(fcx, lhs);\n-        bot |= check_expr_with(fcx, rhs, expr_ty(fcx.ccx.tcx, lhs));\n-        write_ty(fcx.ccx.tcx, id, ty::mk_nil(fcx.ccx.tcx));\n+        bot |= check_expr_with(fcx, rhs, fcx.expr_ty(lhs));\n+        fcx.write_ty(id, ty::mk_nil(fcx.ccx.tcx));\n         ret bot;\n     }\n \n@@ -2430,7 +2525,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n \n         let bot = check_expr(fcx, f);\n \n-        let mut fn_ty = expr_ty(fcx.ccx.tcx, f);\n+        let mut fn_ty = fcx.expr_ty(f);\n         fn_ty = universally_quantify_regions(fcx, region_env(), fn_ty);\n \n         // Call the generic checker.\n@@ -2446,15 +2541,15 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n         require_pure_call(fcx.ccx, fcx.purity, f, sp);\n \n         // Pull the return type out of the type of the function.\n-        let fty = ty::expr_ty(fcx.ccx.tcx, f);\n+        let fty = fcx.expr_ty(f);\n         let mut rt_1 = alt structure_of(fcx, sp, fty) {\n           ty::ty_fn(f) {\n             bot |= f.ret_style == ast::noreturn;\n             f.output\n           }\n           _ { fcx.ccx.tcx.sess.span_fatal(sp, \"calling non-function\"); }\n         };\n-        write_ty(fcx.ccx.tcx, id, rt_1);\n+        fcx.write_ty(id, rt_1);\n         ret bot;\n     }\n \n@@ -2468,7 +2563,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n                        element_ty);\n         let bot = check_decl_local(fcx, local);\n         check_block_no_value(fcx, body);\n-        write_nil(fcx.ccx.tcx, node_id);\n+        fcx.write_nil(node_id);\n         ret bot;\n     }\n \n@@ -2482,7 +2577,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n               some(els) {\n                 let if_t = next_ty_var(fcx);\n                 let thn_bot = check_block(fcx, thn);\n-                let thn_t = block_ty(fcx.ccx.tcx, thn);\n+                let thn_t = fcx.node_ty(thn.node.id);\n                 demand::simple(fcx, thn.span, if_t, thn_t);\n                 let els_bot = check_expr_with(fcx, els, if_t);\n                 (if_t, thn_bot & els_bot)\n@@ -2492,7 +2587,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n                 (ty::mk_nil(fcx.ccx.tcx), false)\n               }\n             };\n-        write_ty(fcx.ccx.tcx, id, if_t);\n+        fcx.write_ty(id, if_t);\n         ret if_bot;\n     }\n \n@@ -2510,8 +2605,8 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n         let callee_id = ast_util::op_expr_callee_id(op_ex);\n         alt lookup_method(fcx, op_ex, callee_id, opname, self_t, [], false) {\n           some(origin) {\n-            let mut method_ty = ty::node_id_to_type(fcx.ccx.tcx, callee_id);\n-            method_ty = universally_quantify_regions(fcx, region_env(),\n+            let method_ty = fcx.node_ty(callee_id);\n+            let method_ty = universally_quantify_regions(fcx, region_env(),\n                                                      method_ty);\n             let bot = check_call_or_bind(fcx, op_ex.span, method_ty, args);\n             fcx.ccx.method_map.insert(op_ex.id, origin);\n@@ -2527,7 +2622,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n                    rhs: @ast::expr) -> bool {\n         let tcx = fcx.ccx.tcx;\n         let lhs_bot = check_expr(fcx, lhs);\n-        let lhs_t = expr_ty(tcx, lhs);\n+        let lhs_t = fcx.expr_ty(lhs);\n         let lhs_t = structurally_resolved_type(fcx, lhs.span, lhs_t);\n         ret alt (op, ty::get(lhs_t).struct) {\n           (ast::add, ty::ty_vec(lhs_mt)) {\n@@ -2545,17 +2640,17 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n             let rhs_bot = check_expr_with(fcx, rhs, const_vec_t);\n             let result_var = next_ty_var(fcx);\n             demand::simple(fcx, lhs.span, const_vec_t, result_var);\n-            write_ty(tcx, expr.id, result_var);\n+            fcx.write_ty(expr.id, result_var);\n             lhs_bot | rhs_bot\n           }\n \n           (_, _) if ty::type_is_integral(lhs_t) &&\n           ast_util::is_shift_binop(op) {\n             // Shift is a special case: rhs can be any integral type\n             let rhs_bot = check_expr(fcx, rhs);\n-            let rhs_t = expr_ty(tcx, rhs);\n+            let rhs_t = fcx.expr_ty(rhs);\n             require_integral(fcx, rhs.span, rhs_t);\n-            write_ty(tcx, expr.id, lhs_t);\n+            fcx.write_ty(expr.id, lhs_t);\n             lhs_bot | rhs_bot\n           }\n \n@@ -2575,15 +2670,15 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n               }\n               _ { lhs_t }\n             };\n-            write_ty(tcx, expr.id, rhs_t);\n+            fcx.write_ty(expr.id, rhs_t);\n             if !ast_util::lazy_binop(op) { lhs_bot | rhs_bot }\n             else { lhs_bot }\n           }\n \n           (_, _) {\n             let (result, rhs_bot) =\n                 check_user_binop(fcx, expr, lhs_t, op, rhs);\n-            write_ty(tcx, expr.id, result);\n+            fcx.write_ty(expr.id, result);\n             lhs_bot | rhs_bot\n           }\n         };\n@@ -2627,7 +2722,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n     alt expr.node {\n       ast::expr_lit(lit) {\n         let typ = check_lit(fcx.ccx, lit);\n-        write_ty(tcx, id, typ);\n+        fcx.write_ty(id, typ);\n       }\n \n       // Something of a hack: special rules for comparison operators that\n@@ -2646,26 +2741,26 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n         let tvar = next_ty_var(fcx);\n         bot |= check_expr_with(fcx, lhs, tvar);\n         bot |= check_expr_with(fcx, rhs, tvar);\n-        write_ty(tcx, id, ty::mk_bool(tcx));\n+        fcx.write_ty(id, ty::mk_bool(tcx));\n       }\n       ast::expr_binary(op, lhs, rhs) {\n         bot |= check_binop(fcx, expr, op, lhs, rhs);\n       }\n       ast::expr_assign_op(op, lhs, rhs) {\n         require_impure(tcx.sess, fcx.purity, expr.span);\n         bot |= check_binop(fcx, expr, op, lhs, rhs);\n-        let lhs_t = ty::expr_ty(tcx, lhs);\n-        let result_t = ty::expr_ty(tcx, expr);\n+        let lhs_t = fcx.expr_ty(lhs);\n+        let result_t = fcx.expr_ty(expr);\n         demand::simple(fcx, expr.span, result_t, lhs_t);\n \n         // Overwrite result of check_binop...this preserves existing behavior\n         // but seems quite dubious with regard to user-defined methods\n         // and so forth. - Niko\n-        write_nil(tcx, expr.id);\n+        fcx.write_nil(expr.id);\n       }\n       ast::expr_unary(unop, oper) {\n         bot = check_expr(fcx, oper);\n-        let mut oper_t = expr_ty(tcx, oper);\n+        let mut oper_t = fcx.expr_ty(oper);\n         alt unop {\n           ast::box(mutbl) {\n             oper_t = ty::mk_box(tcx, {ty: oper_t, mutbl: mutbl});\n@@ -2717,16 +2812,16 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n             }\n           }\n         }\n-        write_ty(tcx, id, oper_t);\n+        fcx.write_ty(id, oper_t);\n       }\n       ast::expr_addr_of(mutbl, oper) {\n         bot = check_expr(fcx, oper);\n-        let mut oper_t = expr_ty(tcx, oper);\n+        let mut oper_t = fcx.expr_ty(oper);\n \n         let region = region_of(fcx, oper);\n         let tm = { ty: oper_t, mutbl: mutbl };\n         oper_t = ty::mk_rptr(tcx, region, tm);\n-        write_ty(tcx, id, oper_t);\n+        fcx.write_ty(id, oper_t);\n       }\n       ast::expr_path(pth) {\n         let defn = lookup_def(fcx, pth.span, id);\n@@ -2742,7 +2837,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n                                     \"this kind of value does not \\\n                                      take type parameters\");\n             }\n-            write_ty(tcx, id, tpt.ty);\n+            fcx.write_ty(id, tpt.ty);\n         }\n       }\n       ast::expr_mac(_) { tcx.sess.bug(\"unexpanded macro\"); }\n@@ -2752,10 +2847,10 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n           none {/* do nothing */ }\n           some(e) { check_expr_with(fcx, e, ty::mk_str(tcx)); }\n         }\n-        write_bot(tcx, id);\n+        fcx.write_bot(id);\n       }\n-      ast::expr_break { write_bot(tcx, id); bot = true; }\n-      ast::expr_cont { write_bot(tcx, id); bot = true; }\n+      ast::expr_break { fcx.write_bot(id); bot = true; }\n+      ast::expr_cont { fcx.write_bot(id); bot = true; }\n       ast::expr_ret(expr_opt) {\n         bot = true;\n         let ret_ty = alt fcx.indirect_ret_ty {\n@@ -2771,24 +2866,24 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n           }\n           some(e) { check_expr_with(fcx, e, ret_ty); }\n         }\n-        write_bot(tcx, id);\n+        fcx.write_bot(id);\n       }\n       ast::expr_be(e) {\n         // FIXME: prove instead of assert\n         assert (ast_util::is_call_expr(e));\n         check_expr_with(fcx, e, fcx.ret_ty);\n         bot = true;\n-        write_nil(tcx, id);\n+        fcx.write_nil(id);\n       }\n       ast::expr_log(_, lv, e) {\n         bot = check_expr_with(fcx, lv, ty::mk_mach_uint(tcx, ast::ty_u32));\n         // Note: this does not always execute, so do not propagate bot:\n         check_expr(fcx, e);\n-        write_nil(tcx, id);\n+        fcx.write_nil(id);\n       }\n       ast::expr_check(_, e) {\n         bot = check_pred_expr(fcx, e);\n-        write_nil(tcx, id);\n+        fcx.write_nil(id);\n       }\n       ast::expr_if_check(cond, thn, elsopt) {\n         bot =\n@@ -2797,11 +2892,11 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n       }\n       ast::expr_assert(e) {\n         bot = check_expr_with(fcx, e, ty::mk_bool(tcx));\n-        write_nil(tcx, id);\n+        fcx.write_nil(id);\n       }\n       ast::expr_copy(a) {\n         bot = check_expr_with_unifier(fcx, a, unify, expected);\n-        write_ty(tcx, id, ty::node_id_to_type(tcx, a.id));\n+        fcx.write_ty(id, fcx.expr_ty(a));\n       }\n       ast::expr_move(lhs, rhs) {\n         require_impure(tcx.sess, fcx.purity, expr.span);\n@@ -2823,7 +2918,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n       ast::expr_for(decl, seq, body) {\n         bot = check_expr(fcx, seq);\n         let mut elt_ty;\n-        let ety = expr_ty(tcx, seq);\n+        let ety = fcx.expr_ty(seq);\n         alt structure_of(fcx, expr.span, ety) {\n           ty::ty_vec(vec_elt_ty) { elt_ty = vec_elt_ty.ty; }\n           ty::ty_str { elt_ty = ty::mk_mach_uint(tcx, ast::ty_u8); }\n@@ -2838,16 +2933,16 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n       ast::expr_while(cond, body) {\n         bot = check_expr_with(fcx, cond, ty::mk_bool(tcx));\n         check_block_no_value(fcx, body);\n-        write_ty(tcx, id, ty::mk_nil(tcx));\n+        fcx.write_ty(id, ty::mk_nil(tcx));\n       }\n       ast::expr_do_while(body, cond) {\n         bot = check_expr_with(fcx, cond, ty::mk_bool(tcx)) |\n               check_block_no_value(fcx, body);\n-        write_ty(tcx, id, block_ty(tcx, body));\n+        fcx.write_ty(id, fcx.node_ty(body.node.id));\n       }\n       ast::expr_loop(body) {\n           check_block_no_value(fcx, body);\n-          write_ty(tcx, id, ty::mk_nil(tcx));\n+          fcx.write_ty(id, ty::mk_nil(tcx));\n           bot = !may_break(body);\n       }\n       ast::expr_alt(discrim, arms, _) {\n@@ -2858,7 +2953,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n \n         // Typecheck the patterns first, so that we get types for all the\n         // bindings.\n-        //let pattern_ty = ty::expr_ty(tcx, discrim);\n+        //let pattern_ty = fcx.expr_ty(discrim);\n         for arm: ast::arm in arms {\n             let pcx = {\n                 fcx: fcx,\n@@ -2881,12 +2976,12 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n               none { }\n             }\n             if !check_block(fcx, arm.body) { arm_non_bot = true; }\n-            let bty = block_ty(tcx, arm.body);\n+            let bty = fcx.node_ty(arm.body.node.id);\n             result_ty = demand::simple(fcx, arm.body.span, result_ty, bty);\n         }\n         bot |= !arm_non_bot;\n         if !arm_non_bot { result_ty = ty::mk_bot(tcx); }\n-        write_ty(tcx, id, result_ty);\n+        fcx.write_ty(id, result_ty);\n       }\n       ast::expr_fn(proto, decl, body, captures) {\n         check_expr_fn_with_unifier(fcx, expr, proto, decl, body,\n@@ -2921,11 +3016,11 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n           }\n         }\n         let block_ty = structurally_resolved_type(\n-            fcx, expr.span, ty::node_id_to_type(tcx, b.id));\n+            fcx, expr.span, fcx.node_ty(b.id));\n         alt check ty::get(block_ty).struct {\n           ty::ty_fn(fty) {\n-            write_ty(tcx, expr.id, ty::mk_fn(tcx, {output: ty::mk_bool(tcx)\n-                                                   with fty}));\n+            fcx.write_ty(expr.id, ty::mk_fn(tcx, {output: ty::mk_bool(tcx)\n+                                                  with fty}));\n           }\n         }\n       }\n@@ -2934,16 +3029,16 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n         bot = check_block(fcx, b);\n         let typ =\n             alt b.node.expr {\n-              some(expr) { expr_ty(tcx, expr) }\n+              some(expr) { fcx.expr_ty(expr) }\n               none { ty::mk_nil(tcx) }\n             };\n-        write_ty(tcx, id, typ);\n+        fcx.write_ty(id, typ);\n       }\n       ast::expr_bind(f, args) {\n         // Call the generic checker.\n         bot = check_expr(fcx, f);\n \n-        let mut fn_ty = expr_ty(fcx.ccx.tcx, f);\n+        let mut fn_ty = fcx.expr_ty(f);\n         fn_ty = universally_quantify_regions(fcx, region_env(), fn_ty);\n \n         let ccob_bot = check_call_or_bind(fcx, expr.span, fn_ty, args);\n@@ -2953,7 +3048,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n \n         // Pull the argument and return types out.\n         let mut proto, arg_tys, rt, cf, constrs;\n-        alt structure_of(fcx, expr.span, expr_ty(tcx, f)) {\n+        alt structure_of(fcx, expr.span, fcx.expr_ty(f)) {\n           // FIXME:\n           // probably need to munge the constrs to drop constraints\n           // for any bound args\n@@ -2994,15 +3089,15 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n         let ft = ty::mk_fn(tcx, {proto: proto,\n                                  inputs: out_args, output: rt,\n                                  ret_style: cf, constraints: constrs});\n-        write_ty(tcx, id, ft);\n+        fcx.write_ty(id, ft);\n       }\n       ast::expr_call(f, args, _) {\n         bot = check_call_full(fcx, expr.span, expr.id, f, args);\n       }\n       ast::expr_cast(e, t) {\n         bot = check_expr(fcx, e);\n         let t_1 = ast_ty_to_ty_crate(fcx.ccx, t);\n-        let t_e = ty::expr_ty(tcx, e);\n+        let t_e = fcx.expr_ty(e);\n \n         alt ty::get(t_1).struct {\n           // This will be looked up later on\n@@ -3030,30 +3125,30 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n             }\n           }\n         }\n-        write_ty(tcx, id, t_1);\n+        fcx.write_ty(id, t_1);\n       }\n       ast::expr_vec(args, mutbl) {\n         let t: ty::t = next_ty_var(fcx);\n         for e: @ast::expr in args { bot |= check_expr_with(fcx, e, t); }\n         let typ = ty::mk_vec(tcx, {ty: t, mutbl: mutbl});\n-        write_ty(tcx, id, typ);\n+        fcx.write_ty(id, typ);\n       }\n       ast::expr_tup(elts) {\n         let mut elt_ts = [];\n         vec::reserve(elt_ts, vec::len(elts));\n         for e in elts {\n             check_expr(fcx, e);\n-            let ety = expr_ty(tcx, e);\n+            let ety = fcx.expr_ty(e);\n             elt_ts += [ety];\n         }\n         let typ = ty::mk_tup(tcx, elt_ts);\n-        write_ty(tcx, id, typ);\n+        fcx.write_ty(id, typ);\n       }\n       ast::expr_rec(fields, base) {\n         option::may(base) {|b| check_expr(fcx, b); }\n         let fields_t = vec::map(fields, {|f|\n             bot |= check_expr(fcx, f.node.expr);\n-            let expr_t = expr_ty(tcx, f.node.expr);\n+            let expr_t = fcx.expr_ty(f.node.expr);\n             let expr_mt = {ty: expr_t, mutbl: f.node.mutbl};\n             // for the most precise error message,\n             // should be f.node.expr.span, not f.span\n@@ -3063,11 +3158,11 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n           none {\n             fn get_node(f: spanned<field>) -> field { f.node }\n             let typ = ty::mk_rec(tcx, vec::map(fields_t, get_node));\n-            write_ty(tcx, id, typ);\n+            fcx.write_ty(id, typ);\n           }\n           some(bexpr) {\n             bot |= check_expr(fcx, bexpr);\n-            let bexpr_t = expr_ty(tcx, bexpr);\n+            let bexpr_t = fcx.expr_ty(bexpr);\n             let mut base_fields: [field] = [];\n             alt structure_of(fcx, expr.span, bexpr_t) {\n               ty::ty_rec(flds) { base_fields = flds; }\n@@ -3076,7 +3171,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n                                     \"record update has non-record base\");\n               }\n             }\n-            write_ty(tcx, id, bexpr_t);\n+            fcx.write_ty(id, bexpr_t);\n             for f: spanned<ty::field> in fields_t {\n                 let mut found = false;\n                 for bf: ty::field in base_fields {\n@@ -3097,7 +3192,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n       ast::expr_field(base, field, tys) {\n         bot |= check_expr(fcx, base);\n         let expr_t = structurally_resolved_type(fcx, expr.span,\n-                                                expr_ty(tcx, base));\n+                                                fcx.expr_ty(base));\n         let base_t = do_autoderef(fcx, expr.span, expr_t);\n         let mut handled = false;\n         let n_tys = vec::len(tys);\n@@ -3110,7 +3205,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n                                       \"can't provide type parameters \\\n                                        to a field access\");\n                 }\n-                write_ty(tcx, id, fields[ix].mt.ty);\n+                fcx.write_ty(id, fields[ix].mt.ty);\n                 handled = true;\n               }\n               _ {}\n@@ -3139,7 +3234,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n                  some(field_ty) {\n                     // (2) look up what field's type is, and return it\n                     // FIXME: actually instantiate any type params\n-                     write_ty(tcx, id, field_ty);\n+                     fcx.write_ty(id, field_ty);\n                      handled = true;\n                  }\n                  none {}\n@@ -3161,33 +3256,33 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n                                field, ty_to_str(tcx, t_err)];\n                 tcx.sess.span_err(expr.span, msg);\n                 // NB: Adding a bogus type to allow typechecking to continue\n-                write_ty(tcx, id, next_ty_var(fcx));\n+                fcx.write_ty(id, next_ty_var(fcx));\n               }\n             }\n         }\n       }\n       ast::expr_index(base, idx) {\n         bot |= check_expr(fcx, base);\n-        let raw_base_t = expr_ty(tcx, base);\n+        let raw_base_t = fcx.expr_ty(base);\n         let base_t = do_autoderef(fcx, expr.span, raw_base_t);\n         bot |= check_expr(fcx, idx);\n-        let idx_t = expr_ty(tcx, idx);\n+        let idx_t = fcx.expr_ty(idx);\n         alt structure_of(fcx, expr.span, base_t) {\n           ty::ty_vec(mt) {\n             require_integral(fcx, idx.span, idx_t);\n-            write_ty(tcx, id, mt.ty);\n+            fcx.write_ty(id, mt.ty);\n           }\n           ty::ty_str {\n             require_integral(fcx, idx.span, idx_t);\n             let typ = ty::mk_mach_uint(tcx, ast::ty_u8);\n-            write_ty(tcx, id, typ);\n+            fcx.write_ty(id, typ);\n           }\n           _ {\n             let resolved = structurally_resolved_type(fcx, expr.span,\n                                                       raw_base_t);\n             alt lookup_op_method(fcx, expr, resolved, \"[]\",\n                                  [some(idx)]) {\n-              some((ret_ty, _)) { write_ty(tcx, id, ret_ty); }\n+              some((ret_ty, _)) { fcx.write_ty(id, ret_ty); }\n               _ {\n                 tcx.sess.span_fatal(\n                     expr.span, \"cannot index a value of type `\" +\n@@ -3201,7 +3296,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n         bot |= check_expr(fcx, p);\n         bot |= check_expr(fcx, v);\n \n-        let p_ty = expr_ty(tcx, p);\n+        let p_ty = fcx.expr_ty(p);\n \n         alt lookup_method(fcx, p, alloc_id, \"alloc\", p_ty, [], false) {\n           some(origin) {\n@@ -3223,7 +3318,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n             };\n \n             demand::simple(fcx, expr.span,\n-                           expected_ty, node_id_to_type(tcx, alloc_id));\n+                           expected_ty, fcx.node_ty(alloc_id));\n           }\n \n           none {\n@@ -3237,20 +3332,20 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n         // The region value must have a type like &r.T.  The resulting\n         // memory will be allocated into the region `r`.\n         let pool_region = region_of(fcx, p);\n-        let v_ty = expr_ty(tcx, v);\n+        let v_ty = fcx.expr_ty(v);\n         let res_ty = ty::mk_rptr(tcx, pool_region, {ty: v_ty,\n                                                     mutbl: ast::m_imm});\n-        write_ty(tcx, expr.id, res_ty);\n+        fcx.write_ty(expr.id, res_ty);\n       }\n     }\n-    if bot { write_ty(tcx, expr.id, ty::mk_bot(tcx)); }\n+    if bot { fcx.write_bot(expr.id); }\n \n     #debug(\"type of expr %s is %s, expected is %s\",\n            syntax::print::pprust::expr_to_str(expr),\n-           ty_to_str(tcx, expr_ty(tcx, expr)),\n+           ty_to_str(tcx, fcx.expr_ty(expr)),\n            ty_to_str(tcx, expected));\n \n-    unify(fcx, expr.span, expected, expr_ty(tcx, expr));\n+    unify(fcx, expr.span, expected, fcx.expr_ty(expr));\n     ret bot;\n }\n \n@@ -3302,7 +3397,7 @@ fn check_decl_local(fcx: @fn_ctxt, local: @ast::local) -> bool {\n     let mut bot = false;\n \n     let t = ty::mk_var(fcx.ccx.tcx, fcx.locals.get(local.node.id));\n-    write_ty(fcx.ccx.tcx, local.node.id, t);\n+    fcx.write_ty(local.node.id, t);\n     alt local.node.init {\n       some(init) {\n         bot = check_decl_initializer(fcx, local.node.id, init);\n@@ -3346,14 +3441,14 @@ fn check_stmt(fcx: @fn_ctxt, stmt: @ast::stmt) -> bool {\n         bot = check_expr(fcx, expr);\n       }\n     }\n-    write_nil(fcx.ccx.tcx, node_id);\n+    fcx.write_nil(node_id);\n     ret bot;\n }\n \n fn check_block_no_value(fcx: @fn_ctxt, blk: ast::blk) -> bool {\n     let bot = check_block(fcx, blk);\n     if !bot {\n-        let blkty = ty::node_id_to_type(fcx.ccx.tcx, blk.node.id);\n+        let blkty = fcx.node_ty(blk.node.id);\n         let nilty = ty::mk_nil(fcx.ccx.tcx);\n         demand::simple(fcx, blk.span, nilty, blkty);\n     }\n@@ -3383,26 +3478,26 @@ fn check_block(fcx0: @fn_ctxt, blk: ast::blk) -> bool {\n         bot |= check_stmt(fcx, s);\n     }\n     alt blk.node.expr {\n-      none { write_nil(fcx.ccx.tcx, blk.node.id); }\n+      none { fcx.write_nil(blk.node.id); }\n       some(e) {\n         if bot && !warned {\n             fcx.ccx.tcx.sess.span_warn(e.span, \"unreachable expression\");\n         }\n         bot |= check_expr(fcx, e);\n-        let ety = expr_ty(fcx.ccx.tcx, e);\n-        write_ty(fcx.ccx.tcx, blk.node.id, ety);\n+        let ety = fcx.expr_ty(e);\n+        fcx.write_ty(blk.node.id, ety);\n       }\n     }\n     if bot {\n-        write_ty(fcx.ccx.tcx, blk.node.id, ty::mk_bot(fcx.ccx.tcx));\n+        fcx.write_bot(blk.node.id);\n     }\n     ret bot;\n }\n \n fn check_const(ccx: @crate_ctxt, _sp: span, e: @ast::expr, id: ast::node_id) {\n     // FIXME: this is kinda a kludge; we manufacture a fake function context\n     // and statement context for checking the initializer expression.\n-    let rty = node_id_to_type(ccx.tcx, id);\n+    let rty = ty::node_id_to_type(ccx.tcx, id);\n     let fcx: @fn_ctxt =\n         @{ret_ty: rty,\n           indirect_ret_ty: none,\n@@ -3412,11 +3507,14 @@ fn check_const(ccx: @crate_ctxt, _sp: span, e: @ast::expr, id: ast::node_id) {\n           locals: int_hash::<int>(),\n           next_var_id: @mut 0,\n           next_region_var_id: @mut 0,\n+          node_types: smallintmap::mk(),\n+          node_type_substs: map::int_hash(),\n           ccx: ccx};\n     check_expr(fcx, e);\n-    let cty = expr_ty(fcx.ccx.tcx, e);\n+    let cty = fcx.expr_ty(e);\n     let declty = fcx.ccx.tcx.tcache.get(local_def(id)).ty;\n     demand::simple(fcx, e.span, declty, cty);\n+    writeback::resolve_type_vars_in_expr(fcx, e);\n }\n \n fn check_instantiable(tcx: ty::ctxt,\n@@ -3435,7 +3533,7 @@ fn check_enum_variants(ccx: @crate_ctxt, sp: span, vs: [ast::variant],\n                       id: ast::node_id) {\n     // FIXME: this is kinda a kludge; we manufacture a fake function context\n     // and statement context for checking the initializer expression.\n-    let rty = node_id_to_type(ccx.tcx, id);\n+    let rty = ty::node_id_to_type(ccx.tcx, id);\n     let fcx: @fn_ctxt =\n         @{ret_ty: rty,\n           indirect_ret_ty: none,\n@@ -3445,14 +3543,16 @@ fn check_enum_variants(ccx: @crate_ctxt, sp: span, vs: [ast::variant],\n           locals: int_hash::<int>(),\n           next_var_id: @mut 0,\n           next_region_var_id: @mut 0,\n+          node_types: smallintmap::mk(),\n+          node_type_substs: map::int_hash(),\n           ccx: ccx};\n     let mut disr_vals: [int] = [];\n     let mut disr_val = 0;\n     for v in vs {\n         alt v.node.disr_expr {\n           some(e) {\n             check_expr(fcx, e);\n-            let cty = expr_ty(ccx.tcx, e);\n+            let cty = fcx.expr_ty(e);\n             let declty = ty::mk_int(ccx.tcx);\n             demand::simple(fcx, e.span, declty, cty);\n             // FIXME: issue #1417\n@@ -3508,7 +3608,7 @@ fn check_pred_expr(fcx: @fn_ctxt, e: @ast::expr) -> bool {\n     literals or slots */\n     alt e.node {\n       ast::expr_call(operator, operands, _) {\n-        if !ty::is_pred_ty(expr_ty(fcx.ccx.tcx, operator)) {\n+        if !ty::is_pred_ty(fcx.expr_ty(operator)) {\n             fcx.ccx.tcx.sess.span_err\n                 (operator.span,\n                  \"operator in constraint has non-boolean return type\");\n@@ -3607,21 +3707,42 @@ fn check_constraints(fcx: @fn_ctxt, cs: [@ast::constr], args: [ast::arg]) {\n     }\n }\n \n+fn check_bare_fn(ccx: @crate_ctxt,\n+                 decl: ast::fn_decl,\n+                 body: ast::blk,\n+                 id: ast::node_id) {\n+    let fty = ty::node_id_to_type(ccx.tcx, id);\n+    let ret_ty = ty::ty_fn_ret(fty);\n+    let arg_tys = vec::map(ty::ty_fn_args(fty)) {|a| a.ty };\n+    check_fn(ccx, ast::proto_bare, decl, body,\n+             ret_ty, arg_tys, false, none);\n+}\n+\n fn check_fn(ccx: @crate_ctxt,\n             proto: ast::proto,\n             decl: ast::fn_decl,\n             body: ast::blk,\n-            id: ast::node_id,\n+            ret_ty: ty::t,\n+            arg_tys: [ty::t],\n             indirect_ret: bool,\n             old_fcx: option<@fn_ctxt>) {\n     // If old_fcx is some(...), this is a block fn { |x| ... }.\n     // In that case, the purity is inherited from the context.\n-    let purity = alt old_fcx {\n-      none { decl.purity }\n-      some(f) { assert decl.purity == ast::impure_fn; f.purity }\n+    let {purity, node_types, node_type_substs} = alt old_fcx {\n+      none {\n+        {purity: decl.purity,\n+         node_types: smallintmap::mk(),\n+         node_type_substs: map::int_hash()}\n+      }\n+      some(f) {\n+        assert decl.purity == ast::impure_fn;\n+        {purity: f.purity,\n+         node_types: f.node_types,\n+         node_type_substs: f.node_type_substs}\n+      }\n     };\n \n-    let gather_result = gather_locals(ccx, decl, body, id, old_fcx);\n+    let gather_result = gather_locals(ccx, decl, body, arg_tys, old_fcx);\n     let indirect_ret_ty = if indirect_ret {\n         let ofcx = option::get(old_fcx);\n         alt ofcx.indirect_ret_ty {\n@@ -3630,14 +3751,16 @@ fn check_fn(ccx: @crate_ctxt,\n         }\n     } else { none };\n     let fcx: @fn_ctxt =\n-        @{ret_ty: ty::ty_fn_ret(ty::node_id_to_type(ccx.tcx, id)),\n+        @{ret_ty: ret_ty,\n           indirect_ret_ty: indirect_ret_ty,\n           purity: purity,\n           proto: proto,\n           infcx: gather_result.infcx,\n           locals: gather_result.locals,\n           next_var_id: gather_result.next_var_id,\n           next_region_var_id: @mut 0,\n+          node_types: node_types,\n+          node_type_substs: node_type_substs,\n           ccx: ccx};\n \n     check_constraints(fcx, decl.constraints, decl.inputs);\n@@ -3647,16 +3770,15 @@ fn check_fn(ccx: @crate_ctxt,\n     // function result type, if there is a tail expr.\n     alt body.node.expr {\n       some(tail_expr) {\n-        let tail_expr_ty = expr_ty(ccx.tcx, tail_expr);\n+        let tail_expr_ty = fcx.expr_ty(tail_expr);\n         demand::simple(fcx, tail_expr.span, fcx.ret_ty, tail_expr_ty);\n       }\n       none { }\n     }\n \n-    let args = ty::ty_fn_args(ty::node_id_to_type(ccx.tcx, id));\n     let mut i = 0u;\n-    for arg: ty::arg in args {\n-        write_ty(ccx.tcx, decl.inputs[i].id, arg.ty);\n+    vec::iter(arg_tys) {|arg|\n+        fcx.write_ty(decl.inputs[i].id, arg);\n         i += 1u;\n     }\n \n@@ -3666,13 +3788,12 @@ fn check_fn(ccx: @crate_ctxt,\n     // resolved when the enclosing scope finishes up.\n     if option::is_none(old_fcx) {\n         vtable::resolve_in_block(fcx, body);\n-        writeback::resolve_type_vars_in_block(fcx, body);\n+        writeback::resolve_type_vars_in_fn(fcx, decl, body);\n     }\n }\n \n fn check_method(ccx: @crate_ctxt, method: @ast::method) {\n-    check_fn(ccx, ast::proto_bare, method.decl, method.body, method.id,\n-             false, none);\n+    check_bare_fn(ccx, method.decl, method.body, method.id);\n }\n \n fn class_types(ccx: @crate_ctxt, members: [@ast::class_member]) -> class_map {\n@@ -3708,11 +3829,11 @@ fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n       ast::item_const(_, e) { check_const(ccx, it.span, e, it.id); }\n       ast::item_enum(vs, _) { check_enum_variants(ccx, it.span, vs, it.id); }\n       ast::item_fn(decl, tps, body) {\n-        check_fn(ccx, ast::proto_bare, decl, body, it.id, false, none);\n+        check_bare_fn(ccx, decl, body, it.id);\n       }\n       ast::item_res(decl, tps, body, dtor_id, _) {\n         check_instantiable(ccx.tcx, it.span, it.id);\n-        check_fn(ccx, ast::proto_bare, decl, body, dtor_id, false, none);\n+        check_bare_fn(ccx, decl, body, dtor_id);\n       }\n       ast::item_impl(tps, _, ty, ms) {\n         let mut self_ty = ast_ty_to_ty(ccx.tcx, m_check, ty);\n@@ -3726,16 +3847,16 @@ fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n       }\n       ast::item_class(tps, members, ctor) {\n           let cid = some(it.id);\n-          let class_t = node_id_to_type(ccx.tcx, it.id);\n+          let class_t = ty::node_id_to_type(ccx.tcx, it.id);\n           let members_info = class_types(ccx, members);\n           // can also ditch the enclosing_class stuff once we move to self\n           // FIXME\n           let class_ccx = @{enclosing_class_id:cid,\n                             enclosing_class:members_info with *ccx};\n           class_ccx.self_infos += [self_impl(class_t, ctor.node.self_id)];\n           // typecheck the ctor\n-          check_fn(class_ccx, ast::proto_bare, ctor.node.dec,\n-                   ctor.node.body, ctor.node.id, false, none);\n+          check_bare_fn(class_ccx, ctor.node.dec,\n+                        ctor.node.body, ctor.node.id);\n           vec::pop(class_ccx.self_infos);\n           // typecheck the members\n           for m in members { check_class_member(class_ccx, class_t, m); }\n@@ -3965,7 +4086,7 @@ mod vtable {\n         let cx = fcx.ccx;\n         alt ex.node {\n           ast::expr_path(_) {\n-            alt cx.tcx.node_type_substs.find(ex.id) {\n+            alt fcx.opt_node_ty_substs(ex.id) {\n               some(ts) {\n                 let did = ast_util::def_id_of_def(cx.tcx.def_map.get(ex.id));\n                 let item_ty = ty::lookup_item_type(cx.tcx, did);\n@@ -3990,7 +4111,7 @@ mod vtable {\n                       ast::expr_field(_, _, _) { ex.id }\n                       _ { ast_util::op_expr_callee_id(ex) }\n                     };\n-                    let ts = ty::node_id_to_type_params(cx.tcx, callee_id);\n+                    let ts = fcx.node_ty_substs(callee_id);\n                     let iscs = cx.impl_map.get(ex.id);\n                     cx.vtable_map.insert(callee_id, lookup_vtables(\n                         fcx, iscs, ex.span, bounds, ts, false));\n@@ -4000,12 +4121,12 @@ mod vtable {\n             }\n           }\n           ast::expr_cast(src, _) {\n-            let target_ty = expr_ty(cx.tcx, ex);\n+            let target_ty = fcx.expr_ty(ex);\n             alt ty::get(target_ty).struct {\n               ty::ty_iface(_, _) {\n                 let impls = cx.impl_map.get(ex.id);\n                 let vtable = lookup_vtable(fcx, impls, ex.span,\n-                                           expr_ty(cx.tcx, src), target_ty,\n+                                           fcx.expr_ty(src), target_ty,\n                                            true);\n                 cx.vtable_map.insert(ex.id, @[vtable]);\n               }"}]}