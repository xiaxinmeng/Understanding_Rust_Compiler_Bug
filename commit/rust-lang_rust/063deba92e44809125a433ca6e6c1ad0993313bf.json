{"sha": "063deba92e44809125a433ca6e6c1ad0993313bf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA2M2RlYmE5MmU0NDgwOTEyNWE0MzNjYTZlNmMxYWQwOTkzMzEzYmY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-02-23T11:21:29Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-02-23T11:21:29Z"}, "message": "Auto merge of #47799 - topecongiro:fix-span-of-visibility, r=petrochenkov\n\nFix span of visibility\n\nThis PR\n\n1. adds a closing parenthesis to the span of `Visibility::Crate` (e.g. `pub(crate)`). The current span only covers `pub(crate`.\n2. adds a `span` field to `Visibility::Restricted`. This span covers the entire visibility expression (e.g. `pub (in self)`). Currently all we can have is a span for `Path`.\n\nThis PR is motivated by the bug found in rustfmt (https://github.com/rust-lang-nursery/rustfmt/issues/2398).\n\nThe first change is a strict improvement IMHO. The second change may not be desirable, as it adds a field which is currently not used by the compiler.", "tree": {"sha": "95ff2922a9ae38b3059361343514e920f2931a4d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/95ff2922a9ae38b3059361343514e920f2931a4d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/063deba92e44809125a433ca6e6c1ad0993313bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/063deba92e44809125a433ca6e6c1ad0993313bf", "html_url": "https://github.com/rust-lang/rust/commit/063deba92e44809125a433ca6e6c1ad0993313bf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/063deba92e44809125a433ca6e6c1ad0993313bf/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "928435305ad1d778d7c4d2c2ff989c6a87be0223", "url": "https://api.github.com/repos/rust-lang/rust/commits/928435305ad1d778d7c4d2c2ff989c6a87be0223", "html_url": "https://github.com/rust-lang/rust/commit/928435305ad1d778d7c4d2c2ff989c6a87be0223"}, {"sha": "8e9fa57055a083ebc2378d855514166e3ec7a566", "url": "https://api.github.com/repos/rust-lang/rust/commits/8e9fa57055a083ebc2378d855514166e3ec7a566", "html_url": "https://github.com/rust-lang/rust/commit/8e9fa57055a083ebc2378d855514166e3ec7a566"}], "stats": {"total": 303, "additions": 174, "deletions": 129}, "files": [{"sha": "e3af285053805e68c768e80a5ff92431eb4d6589", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/063deba92e44809125a433ca6e6c1ad0993313bf/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/063deba92e44809125a433ca6e6c1ad0993313bf/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=063deba92e44809125a433ca6e6c1ad0993313bf", "patch": "@@ -3362,10 +3362,10 @@ impl<'a> LoweringContext<'a> {\n                         v: &Visibility,\n                         explicit_owner: Option<NodeId>)\n                         -> hir::Visibility {\n-        match *v {\n-            Visibility::Public => hir::Public,\n-            Visibility::Crate(..) => hir::Visibility::Crate,\n-            Visibility::Restricted { ref path, id } => {\n+        match v.node {\n+            VisibilityKind::Public => hir::Public,\n+            VisibilityKind::Crate(..) => hir::Visibility::Crate,\n+            VisibilityKind::Restricted { ref path, id, .. } => {\n                 hir::Visibility::Restricted {\n                     path: P(self.lower_path(id, path, ParamMode::Explicit, true)),\n                     id: if let Some(owner) = explicit_owner {\n@@ -3375,7 +3375,7 @@ impl<'a> LoweringContext<'a> {\n                     }\n                 }\n             }\n-            Visibility::Inherited => hir::Inherited,\n+            VisibilityKind::Inherited => hir::Inherited,\n         }\n     }\n "}, {"sha": "c088458c3557c7076e26c42cbe208e8a2c01d3f7", "filename": "src/librustc_allocator/expand.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/063deba92e44809125a433ca6e6c1ad0993313bf/src%2Flibrustc_allocator%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/063deba92e44809125a433ca6e6c1ad0993313bf/src%2Flibrustc_allocator%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_allocator%2Fexpand.rs?ref=063deba92e44809125a433ca6e6c1ad0993313bf", "patch": "@@ -13,9 +13,9 @@ use rustc_errors;\n use syntax::abi::Abi;\n use syntax::ast::{Crate, Attribute, LitKind, StrStyle, ExprKind};\n use syntax::ast::{Unsafety, Constness, Generics, Mutability, Ty, Mac, Arg};\n-use syntax::ast::{self, Ident, Item, ItemKind, TyKind, Visibility, Expr};\n+use syntax::ast::{self, Ident, Item, ItemKind, TyKind, VisibilityKind, Expr};\n use syntax::attr;\n-use syntax::codemap::dummy_spanned;\n+use syntax::codemap::{dummy_spanned, respan};\n use syntax::codemap::{ExpnInfo, NameAndSpan, MacroAttribute};\n use syntax::ext::base::ExtCtxt;\n use syntax::ext::base::Resolver;\n@@ -97,7 +97,11 @@ impl<'a> Folder for ExpandAllocatorDirectives<'a> {\n         ]);\n         let mut items = vec![\n             f.cx.item_extern_crate(f.span, f.alloc),\n-            f.cx.item_use_simple(f.span, Visibility::Inherited, super_path),\n+            f.cx.item_use_simple(\n+                f.span,\n+                respan(f.span.empty(), VisibilityKind::Inherited),\n+                super_path,\n+            ),\n         ];\n         for method in ALLOCATOR_METHODS {\n             items.push(f.allocator_fn(method));"}, {"sha": "c1340d0a28a4421fa15b28efaed0bfde5ad2d225", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/063deba92e44809125a433ca6e6c1ad0993313bf/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/063deba92e44809125a433ca6e6c1ad0993313bf/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=063deba92e44809125a433ca6e6c1ad0993313bf", "patch": "@@ -34,6 +34,7 @@ use std::rc::Rc;\n \n use syntax::ast;\n use syntax::attr;\n+use syntax::codemap;\n use syntax::ext::base::SyntaxExtension;\n use syntax::parse::filemap_to_stream;\n use syntax::symbol::Symbol;\n@@ -496,7 +497,7 @@ impl CrateStore for cstore::CStore {\n                 tokens: body.into(),\n                 legacy: def.legacy,\n             }),\n-            vis: ast::Visibility::Inherited,\n+            vis: codemap::respan(local_span.empty(), ast::VisibilityKind::Inherited),\n             tokens: None,\n         })\n     }"}, {"sha": "bb6dbe632e3168d1f57317f019ab4a508ac37d3c", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/063deba92e44809125a433ca6e6c1ad0993313bf/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/063deba92e44809125a433ca6e6c1ad0993313bf/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=063deba92e44809125a433ca6e6c1ad0993313bf", "patch": "@@ -58,14 +58,14 @@ impl<'a> AstValidator<'a> {\n         }\n     }\n \n-    fn invalid_visibility(&self, vis: &Visibility, span: Span, note: Option<&str>) {\n-        if vis != &Visibility::Inherited {\n+    fn invalid_visibility(&self, vis: &Visibility, note: Option<&str>) {\n+        if vis.node != VisibilityKind::Inherited {\n             let mut err = struct_span_err!(self.session,\n-                                           span,\n+                                           vis.span,\n                                            E0449,\n                                            \"unnecessary visibility qualifier\");\n-            if vis == &Visibility::Public {\n-                err.span_label(span, \"`pub` not needed here\");\n+            if vis.node == VisibilityKind::Public {\n+                err.span_label(vis.span, \"`pub` not needed here\");\n             }\n             if let Some(note) = note {\n                 err.note(note);\n@@ -216,7 +216,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n     fn visit_item(&mut self, item: &'a Item) {\n         match item.node {\n             ItemKind::Impl(unsafety, polarity, _, _, Some(..), ref ty, ref impl_items) => {\n-                self.invalid_visibility(&item.vis, item.span, None);\n+                self.invalid_visibility(&item.vis, None);\n                 if ty.node == TyKind::Err {\n                     self.err_handler()\n                         .struct_span_err(item.span, \"`impl Trait for .. {}` is an obsolete syntax\")\n@@ -226,15 +226,14 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                     span_err!(self.session, item.span, E0198, \"negative impls cannot be unsafe\");\n                 }\n                 for impl_item in impl_items {\n-                    self.invalid_visibility(&impl_item.vis, impl_item.span, None);\n+                    self.invalid_visibility(&impl_item.vis, None);\n                     if let ImplItemKind::Method(ref sig, _) = impl_item.node {\n                         self.check_trait_fn_not_const(sig.constness);\n                     }\n                 }\n             }\n             ItemKind::Impl(unsafety, polarity, defaultness, _, None, _, _) => {\n                 self.invalid_visibility(&item.vis,\n-                                        item.span,\n                                         Some(\"place qualifiers on individual impl items instead\"));\n                 if unsafety == Unsafety::Unsafe {\n                     span_err!(self.session, item.span, E0197, \"inherent impls cannot be unsafe\");\n@@ -247,16 +246,16 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 }\n             }\n             ItemKind::ForeignMod(..) => {\n-                self.invalid_visibility(&item.vis,\n-                                        item.span,\n-                                        Some(\"place qualifiers on individual foreign items \\\n-                                              instead\"));\n+                self.invalid_visibility(\n+                    &item.vis,\n+                    Some(\"place qualifiers on individual foreign items instead\"),\n+                );\n             }\n             ItemKind::Enum(ref def, _) => {\n                 for variant in &def.variants {\n                     self.invalid_non_exhaustive_attribute(variant);\n                     for field in variant.node.data.fields() {\n-                        self.invalid_visibility(&field.vis, field.span, None);\n+                        self.invalid_visibility(&field.vis, None);\n                     }\n                 }\n             }\n@@ -359,8 +358,8 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n     }\n \n     fn visit_vis(&mut self, vis: &'a Visibility) {\n-        match *vis {\n-            Visibility::Restricted { ref path, .. } => {\n+        match vis.node {\n+            VisibilityKind::Restricted { ref path, .. } => {\n                 path.segments.iter().find(|segment| segment.parameters.is_some()).map(|segment| {\n                     self.err_handler().span_err(segment.parameters.as_ref().unwrap().span(),\n                                                 \"generic arguments in visibility path\");"}, {"sha": "163f6a64010b502968cd733d202d37af5abe879d", "filename": "src/librustc_resolve/check_unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/063deba92e44809125a433ca6e6c1ad0993313bf/src%2Flibrustc_resolve%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/063deba92e44809125a433ca6e6c1ad0993313bf/src%2Flibrustc_resolve%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fcheck_unused.rs?ref=063deba92e44809125a433ca6e6c1ad0993313bf", "patch": "@@ -86,7 +86,7 @@ impl<'a, 'b> Visitor<'a> for UnusedImportCheckVisitor<'a, 'b> {\n         // because this means that they were generated in some fashion by the\n         // compiler and we don't need to consider them.\n         if let ast::ItemKind::Use(..) = item.node {\n-            if item.vis == ast::Visibility::Public || item.span.source_equal(&DUMMY_SP) {\n+            if item.vis.node == ast::VisibilityKind::Public || item.span.source_equal(&DUMMY_SP) {\n                 return;\n             }\n         }"}, {"sha": "e6b9150fa3aec0d1e52c2d95fdd102704750e2a9", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/063deba92e44809125a433ca6e6c1ad0993313bf/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/063deba92e44809125a433ca6e6c1ad0993313bf/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=063deba92e44809125a433ca6e6c1ad0993313bf", "patch": "@@ -3796,13 +3796,15 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn resolve_visibility(&mut self, vis: &ast::Visibility) -> ty::Visibility {\n-        match *vis {\n-            ast::Visibility::Public => ty::Visibility::Public,\n-            ast::Visibility::Crate(..) => ty::Visibility::Restricted(DefId::local(CRATE_DEF_INDEX)),\n-            ast::Visibility::Inherited => {\n+        match vis.node {\n+            ast::VisibilityKind::Public => ty::Visibility::Public,\n+            ast::VisibilityKind::Crate(..) => {\n+                ty::Visibility::Restricted(DefId::local(CRATE_DEF_INDEX))\n+            }\n+            ast::VisibilityKind::Inherited => {\n                 ty::Visibility::Restricted(self.current_module.normal_ancestor_id)\n             }\n-            ast::Visibility::Restricted { ref path, id } => {\n+            ast::VisibilityKind::Restricted { ref path, id, .. } => {\n                 let def = self.smart_resolve_path(id, None, path,\n                                                   PathSource::Visibility).base_def();\n                 if def == Def::Err {"}, {"sha": "bf82b0774238bf4879273b5c9df5c94d4ba6dea4", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 17, "deletions": 20, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/063deba92e44809125a433ca6e6c1ad0993313bf/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/063deba92e44809125a433ca6e6c1ad0993313bf/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=063deba92e44809125a433ca6e6c1ad0993313bf", "patch": "@@ -43,7 +43,7 @@ use syntax::print::pprust::{\n     ty_to_string\n };\n use syntax::ptr::P;\n-use syntax::codemap::{Spanned, DUMMY_SP};\n+use syntax::codemap::{Spanned, DUMMY_SP, respan};\n use syntax_pos::*;\n \n use {escape, generated_code, lower_attributes, PathCollector, SaveContext};\n@@ -65,12 +65,19 @@ macro_rules! down_cast_data {\n }\n \n macro_rules! access_from {\n+    ($save_ctxt:expr, $vis:expr, $id:expr) => {\n+        Access {\n+            public: $vis.node == ast::VisibilityKind::Public,\n+            reachable: $save_ctxt.analysis.access_levels.is_reachable($id),\n+        }\n+    };\n+\n     ($save_ctxt:expr, $item:expr) => {\n         Access {\n-            public: $item.vis == ast::Visibility::Public,\n+            public: $item.vis.node == ast::VisibilityKind::Public,\n             reachable: $save_ctxt.analysis.access_levels.is_reachable($item.id),\n         }\n-    }\n+    };\n }\n \n pub struct DumpVisitor<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> {\n@@ -405,12 +412,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n \n             method_data.value = sig_str;\n             method_data.sig = sig::method_signature(id, name, generics, sig, &self.save_ctxt);\n-            self.dumper.dump_def(\n-                &Access {\n-                    public: vis == ast::Visibility::Public,\n-                    reachable: self.save_ctxt.analysis.access_levels.is_reachable(id),\n-                },\n-                method_data);\n+            self.dumper.dump_def(&access_from!(self.save_ctxt, vis, id), method_data);\n         }\n \n         // walk arg and return types\n@@ -543,10 +545,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n             let span = self.span_from_span(sub_span.expect(\"No span found for variable\"));\n \n             self.dumper.dump_def(\n-                &Access {\n-                    public: vis == ast::Visibility::Public,\n-                    reachable: self.save_ctxt.analysis.access_levels.is_reachable(id),\n-                },\n+                &access_from!(self.save_ctxt, vis, id),\n                 Def {\n                     kind: DefKind::Const,\n                     id: ::id_from_node_id(id, &self.save_ctxt),\n@@ -597,7 +596,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n                     .iter()\n                     .enumerate()\n                     .filter_map(|(i, f)| {\n-                        if include_priv_fields || f.vis == ast::Visibility::Public {\n+                        if include_priv_fields || f.vis.node == ast::VisibilityKind::Public {\n                             f.ident\n                                 .map(|i| i.to_string())\n                                 .or_else(|| Some(i.to_string()))\n@@ -1135,6 +1134,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n \n     fn process_trait_item(&mut self, trait_item: &'l ast::TraitItem, trait_id: DefId) {\n         self.process_macro_use(trait_item.span);\n+        let vis_span = trait_item.span.empty();\n         match trait_item.node {\n             ast::TraitItemKind::Const(ref ty, ref expr) => {\n                 self.process_assoc_const(\n@@ -1144,7 +1144,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n                     &ty,\n                     expr.as_ref().map(|e| &**e),\n                     trait_id,\n-                    ast::Visibility::Public,\n+                    respan(vis_span, ast::VisibilityKind::Public),\n                     &trait_item.attrs,\n                 );\n             }\n@@ -1155,7 +1155,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n                     trait_item.id,\n                     trait_item.ident,\n                     &trait_item.generics,\n-                    ast::Visibility::Public,\n+                    respan(vis_span, ast::VisibilityKind::Public),\n                     trait_item.span,\n                 );\n             }\n@@ -1259,10 +1259,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n \n         // The access is calculated using the current tree ID, but with the root tree's visibility\n         // (since nested trees don't have their own visibility).\n-        let access = Access {\n-            public: root_item.vis == ast::Visibility::Public,\n-            reachable: self.save_ctxt.analysis.access_levels.is_reachable(id),\n-        };\n+        let access = access_from!(self.save_ctxt, root_item.vis, id);\n \n         // The parent def id of a given use tree is always the enclosing item.\n         let parent = self.save_ctxt.tcx.hir.opt_local_def_id(id)"}, {"sha": "c7ce7fffaa21b2e3fd72043a8542ce7ae918eeaf", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/063deba92e44809125a433ca6e6c1ad0993313bf/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/063deba92e44809125a433ca6e6c1ad0993313bf/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=063deba92e44809125a433ca6e6c1ad0993313bf", "patch": "@@ -1937,10 +1937,12 @@ pub enum CrateSugar {\n     JustCrate,\n }\n \n+pub type Visibility = Spanned<VisibilityKind>;\n+\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub enum Visibility {\n+pub enum VisibilityKind {\n     Public,\n-    Crate(Span, CrateSugar),\n+    Crate(CrateSugar),\n     Restricted { path: P<Path>, id: NodeId },\n     Inherited,\n }"}, {"sha": "dd27dea4f0d978d04f73a10a6f6a11d51ddfc597", "filename": "src/libsyntax/diagnostics/plugin.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/063deba92e44809125a433ca6e6c1ad0993313bf/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/063deba92e44809125a433ca6e6c1ad0993313bf/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs?ref=063deba92e44809125a433ca6e6c1ad0993313bf", "patch": "@@ -14,6 +14,7 @@ use std::env;\n \n use ast;\n use ast::{Ident, Name};\n+use codemap;\n use syntax_pos::Span;\n use ext::base::{ExtCtxt, MacEager, MacResult};\n use ext::build::AstBuilder;\n@@ -234,7 +235,7 @@ pub fn expand_build_diagnostic_array<'cx>(ecx: &'cx mut ExtCtxt,\n                 ty,\n                 expr,\n             ),\n-            vis: ast::Visibility::Public,\n+            vis: codemap::respan(span.empty(), ast::VisibilityKind::Public),\n             span,\n             tokens: None,\n         })"}, {"sha": "7681f55bd8ccb4f96c4b6422c272c46c6cd7be90", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/063deba92e44809125a433ca6e6c1ad0993313bf/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/063deba92e44809125a433ca6e6c1ad0993313bf/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=063deba92e44809125a433ca6e6c1ad0993313bf", "patch": "@@ -987,7 +987,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n             attrs,\n             id: ast::DUMMY_NODE_ID,\n             node,\n-            vis: ast::Visibility::Inherited,\n+            vis: respan(span.empty(), ast::VisibilityKind::Inherited),\n             span,\n             tokens: None,\n         })\n@@ -1033,7 +1033,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                 span: ty.span,\n                 ty,\n                 ident: None,\n-                vis: ast::Visibility::Inherited,\n+                vis: respan(span.empty(), ast::VisibilityKind::Inherited),\n                 attrs: Vec::new(),\n                 id: ast::DUMMY_NODE_ID,\n             }"}, {"sha": "d4d9dfb01da2c4fa181441255851577cade059ca", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/063deba92e44809125a433ca6e6c1ad0993313bf/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/063deba92e44809125a433ca6e6c1ad0993313bf/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=063deba92e44809125a433ca6e6c1ad0993313bf", "patch": "@@ -11,7 +11,7 @@\n use ast::{self, Block, Ident, NodeId, PatKind, Path};\n use ast::{MacStmtStyle, StmtKind, ItemKind};\n use attr::{self, HasAttrs};\n-use codemap::{ExpnInfo, NameAndSpan, MacroBang, MacroAttribute, dummy_spanned};\n+use codemap::{ExpnInfo, NameAndSpan, MacroBang, MacroAttribute, dummy_spanned, respan};\n use config::{is_test_or_bench, StripUnconfigured};\n use errors::FatalError;\n use ext::base::*;\n@@ -238,7 +238,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             node: ast::ItemKind::Mod(krate.module),\n             ident: keywords::Invalid.ident(),\n             id: ast::DUMMY_NODE_ID,\n-            vis: ast::Visibility::Public,\n+            vis: respan(krate.span.empty(), ast::VisibilityKind::Public),\n             tokens: None,\n         })));\n \n@@ -1022,7 +1022,10 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n             // Ensure that test functions are accessible from the test harness.\n             ast::ItemKind::Fn(..) if self.cx.ecfg.should_test => {\n                 if item.attrs.iter().any(|attr| is_test_or_bench(attr)) {\n-                    item = item.map(|mut item| { item.vis = ast::Visibility::Public; item });\n+                    item = item.map(|mut item| {\n+                        item.vis = respan(item.vis.span, ast::VisibilityKind::Public);\n+                        item\n+                    });\n                 }\n                 noop_fold_item(item, self)\n             }"}, {"sha": "9c2c22476e9d9f598edf2e6358f134cdaeb661a7", "filename": "src/libsyntax/ext/placeholders.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/063deba92e44809125a433ca6e6c1ad0993313bf/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/063deba92e44809125a433ca6e6c1ad0993313bf/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fplaceholders.rs?ref=063deba92e44809125a433ca6e6c1ad0993313bf", "patch": "@@ -33,7 +33,7 @@ pub fn placeholder(kind: ExpansionKind, id: ast::NodeId) -> Expansion {\n     let ident = keywords::Invalid.ident();\n     let attrs = Vec::new();\n     let generics = ast::Generics::default();\n-    let vis = ast::Visibility::Inherited;\n+    let vis = dummy_spanned(ast::VisibilityKind::Inherited);\n     let span = DUMMY_SP;\n     let expr_placeholder = || P(ast::Expr {\n         id, span,"}, {"sha": "7a024dbad88300e0fe451f6503c6b280c5e7c686", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/063deba92e44809125a433ca6e6c1ad0993313bf/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/063deba92e44809125a433ca6e6c1ad0993313bf/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=063deba92e44809125a433ca6e6c1ad0993313bf", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use ast::{self, Arg, Arm, Block, Expr, Item, Pat, Stmt, Ty};\n+use codemap::respan;\n use syntax_pos::Span;\n use ext::base::ExtCtxt;\n use ext::base;\n@@ -855,7 +856,12 @@ fn expand_wrapper(cx: &ExtCtxt,\n     let mut stmts = imports.iter().map(|path| {\n         // make item: `use ...;`\n         let path = path.iter().map(|s| s.to_string()).collect();\n-        cx.stmt_item(sp, cx.item_use_glob(sp, ast::Visibility::Inherited, ids_ext(path)))\n+        let use_item = cx.item_use_glob(\n+            sp,\n+            respan(sp.empty(), ast::VisibilityKind::Inherited),\n+            ids_ext(path),\n+        );\n+        cx.stmt_item(sp, use_item)\n     }).chain(Some(stmt_let_ext_cx)).collect::<Vec<_>>();\n     stmts.push(cx.stmt_expr(expr));\n "}, {"sha": "c0fde71d086f4a717d701a506379c573296d6e1b", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/063deba92e44809125a433ca6e6c1ad0993313bf/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/063deba92e44809125a433ca6e6c1ad0993313bf/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=063deba92e44809125a433ca6e6c1ad0993313bf", "patch": "@@ -1816,8 +1816,8 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n     }\n \n     fn visit_vis(&mut self, vis: &'a ast::Visibility) {\n-        if let ast::Visibility::Crate(span, ast::CrateSugar::JustCrate) = *vis {\n-            gate_feature_post!(&self, crate_visibility_modifier, span,\n+        if let ast::VisibilityKind::Crate(ast::CrateSugar::JustCrate) = vis.node {\n+            gate_feature_post!(&self, crate_visibility_modifier, vis.span,\n                                \"`crate` visibility modifier is experimental\");\n         }\n         visit::walk_vis(self, vis);"}, {"sha": "1a2025b073b2b85081f96883242dda1909531f13", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/063deba92e44809125a433ca6e6c1ad0993313bf/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/063deba92e44809125a433ca6e6c1ad0993313bf/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=063deba92e44809125a433ca6e6c1ad0993313bf", "patch": "@@ -1018,7 +1018,7 @@ pub fn noop_fold_crate<T: Folder>(Crate {module, attrs, span}: Crate,\n         ident: keywords::Invalid.ident(),\n         attrs,\n         id: ast::DUMMY_NODE_ID,\n-        vis: ast::Visibility::Public,\n+        vis: respan(span.empty(), ast::VisibilityKind::Public),\n         span,\n         node: ast::ItemKind::Mod(module),\n         tokens: None,\n@@ -1367,11 +1367,13 @@ pub fn noop_fold_stmt_kind<T: Folder>(node: StmtKind, folder: &mut T) -> SmallVe\n }\n \n pub fn noop_fold_vis<T: Folder>(vis: Visibility, folder: &mut T) -> Visibility {\n-    match vis {\n-        Visibility::Restricted { path, id } => Visibility::Restricted {\n-            path: path.map(|path| folder.fold_path(path)),\n-            id: folder.new_id(id)\n-        },\n+    match vis.node {\n+        VisibilityKind::Restricted { path, id } => {\n+            respan(vis.span, VisibilityKind::Restricted {\n+                path: path.map(|path| folder.fold_path(path)),\n+                id: folder.new_id(id),\n+            })\n+        }\n         _ => vis,\n     }\n }"}, {"sha": "06eb64e157cd53f0727450b210384a911f548870", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/063deba92e44809125a433ca6e6c1ad0993313bf/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/063deba92e44809125a433ca6e6c1ad0993313bf/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=063deba92e44809125a433ca6e6c1ad0993313bf", "patch": "@@ -664,7 +664,7 @@ pub fn integer_lit(s: &str, suffix: Option<Symbol>, diag: Option<(Span, &Handler\n mod tests {\n     use super::*;\n     use syntax_pos::{self, Span, BytePos, Pos, NO_EXPANSION};\n-    use codemap::Spanned;\n+    use codemap::{respan, Spanned};\n     use ast::{self, Ident, PatKind};\n     use abi::Abi;\n     use attr::first_attr_value_str_by_name;\n@@ -932,7 +932,7 @@ mod tests {\n                                         span: sp(15,21),\n                                         recovered: false,\n                                     })),\n-                            vis: ast::Visibility::Inherited,\n+                            vis: respan(sp(0, 0), ast::VisibilityKind::Inherited),\n                             span: sp(0,21)})));\n     }\n "}, {"sha": "74daa5179d381c79d5e86f620a4f21df2ebfb550", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 34, "deletions": 19, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/063deba92e44809125a433ca6e6c1ad0993313bf/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/063deba92e44809125a433ca6e6c1ad0993313bf/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=063deba92e44809125a433ca6e6c1ad0993313bf", "patch": "@@ -36,7 +36,7 @@ use ast::StrStyle;\n use ast::SelfKind;\n use ast::{TraitItem, TraitRef, TraitObjectSyntax};\n use ast::{Ty, TyKind, TypeBinding, TyParam, TyParamBounds};\n-use ast::{Visibility, WhereClause, CrateSugar};\n+use ast::{Visibility, VisibilityKind, WhereClause, CrateSugar};\n use ast::{UseTree, UseTreeKind};\n use ast::{BinOpKind, UnOp};\n use ast::{RangeEnd, RangeSyntax};\n@@ -4132,7 +4132,7 @@ impl<'a> Parser<'a> {\n             token::Ident(ident) if ident.name == \"macro_rules\" &&\n                                    self.look_ahead(1, |t| *t == token::Not) => {\n                 let prev_span = self.prev_span;\n-                self.complain_if_pub_macro(vis, prev_span);\n+                self.complain_if_pub_macro(&vis.node, prev_span);\n                 self.bump();\n                 self.bump();\n \n@@ -4169,7 +4169,11 @@ impl<'a> Parser<'a> {\n                 node: StmtKind::Local(self.parse_local(attrs.into())?),\n                 span: lo.to(self.prev_span),\n             }\n-        } else if let Some(macro_def) = self.eat_macro_def(&attrs, &Visibility::Inherited, lo)? {\n+        } else if let Some(macro_def) = self.eat_macro_def(\n+            &attrs,\n+            &codemap::respan(lo, VisibilityKind::Inherited),\n+            lo,\n+        )? {\n             Stmt {\n                 id: ast::DUMMY_NODE_ID,\n                 node: StmtKind::Item(macro_def),\n@@ -4296,7 +4300,7 @@ impl<'a> Parser<'a> {\n                         self.mk_item(\n                             span, id /*id is good here*/,\n                             ItemKind::Mac(respan(span, Mac_ { path: pth, tts: tts })),\n-                            Visibility::Inherited,\n+                            respan(lo, VisibilityKind::Inherited),\n                             attrs)\n                     }),\n                 }\n@@ -5213,15 +5217,15 @@ impl<'a> Parser<'a> {\n         })\n     }\n \n-    fn complain_if_pub_macro(&mut self, vis: &Visibility, sp: Span) {\n+    fn complain_if_pub_macro(&mut self, vis: &VisibilityKind, sp: Span) {\n         if let Err(mut err) = self.complain_if_pub_macro_diag(vis, sp) {\n             err.emit();\n         }\n     }\n \n-    fn complain_if_pub_macro_diag(&mut self, vis: &Visibility, sp: Span) -> PResult<'a, ()> {\n+    fn complain_if_pub_macro_diag(&mut self, vis: &VisibilityKind, sp: Span) -> PResult<'a, ()> {\n         match *vis {\n-            Visibility::Inherited => Ok(()),\n+            VisibilityKind::Inherited => Ok(()),\n             _ => {\n                 let is_macro_rules: bool = match self.token {\n                     token::Ident(sid) => sid.name == Symbol::intern(\"macro_rules\"),\n@@ -5283,7 +5287,7 @@ impl<'a> Parser<'a> {\n                 self.expect(&token::Not)?;\n             }\n \n-            self.complain_if_pub_macro(vis, prev_span);\n+            self.complain_if_pub_macro(&vis.node, prev_span);\n \n             // eat a matched-delimiter token tree:\n             *at_end = true;\n@@ -5686,12 +5690,13 @@ impl<'a> Parser<'a> {\n         self.expected_tokens.push(TokenType::Keyword(keywords::Crate));\n         if self.is_crate_vis() {\n             self.bump(); // `crate`\n-            return Ok(Visibility::Crate(self.prev_span, CrateSugar::JustCrate));\n+            return Ok(respan(self.prev_span, VisibilityKind::Crate(CrateSugar::JustCrate)));\n         }\n \n         if !self.eat_keyword(keywords::Pub) {\n-            return Ok(Visibility::Inherited)\n+            return Ok(respan(self.prev_span, VisibilityKind::Inherited))\n         }\n+        let lo = self.prev_span;\n \n         if self.check(&token::OpenDelim(token::Paren)) {\n             // We don't `self.bump()` the `(` yet because this might be a struct definition where\n@@ -5702,25 +5707,35 @@ impl<'a> Parser<'a> {\n                 // `pub(crate)`\n                 self.bump(); // `(`\n                 self.bump(); // `crate`\n-                let vis = Visibility::Crate(self.prev_span, CrateSugar::PubCrate);\n                 self.expect(&token::CloseDelim(token::Paren))?; // `)`\n+                let vis = respan(\n+                    lo.to(self.prev_span),\n+                    VisibilityKind::Crate(CrateSugar::PubCrate),\n+                );\n                 return Ok(vis)\n             } else if self.look_ahead(1, |t| t.is_keyword(keywords::In)) {\n                 // `pub(in path)`\n                 self.bump(); // `(`\n                 self.bump(); // `in`\n                 let path = self.parse_path(PathStyle::Mod)?.default_to_global(); // `path`\n-                let vis = Visibility::Restricted { path: P(path), id: ast::DUMMY_NODE_ID };\n                 self.expect(&token::CloseDelim(token::Paren))?; // `)`\n+                let vis = respan(lo.to(self.prev_span), VisibilityKind::Restricted {\n+                    path: P(path),\n+                    id: ast::DUMMY_NODE_ID,\n+                });\n                 return Ok(vis)\n             } else if self.look_ahead(2, |t| t == &token::CloseDelim(token::Paren)) &&\n                       self.look_ahead(1, |t| t.is_keyword(keywords::Super) ||\n-                                             t.is_keyword(keywords::SelfValue)) {\n+                                             t.is_keyword(keywords::SelfValue))\n+            {\n                 // `pub(self)` or `pub(super)`\n                 self.bump(); // `(`\n                 let path = self.parse_path(PathStyle::Mod)?.default_to_global(); // `super`/`self`\n-                let vis = Visibility::Restricted { path: P(path), id: ast::DUMMY_NODE_ID };\n                 self.expect(&token::CloseDelim(token::Paren))?; // `)`\n+                let vis = respan(lo.to(self.prev_span), VisibilityKind::Restricted {\n+                    path: P(path),\n+                    id: ast::DUMMY_NODE_ID,\n+                });\n                 return Ok(vis)\n             } else if !can_take_tuple {  // Provide this diagnostic if this is not a tuple struct\n                 // `pub(something) fn ...` or `struct X { pub(something) y: Z }`\n@@ -5740,7 +5755,7 @@ impl<'a> Parser<'a> {\n             }\n         }\n \n-        Ok(Visibility::Public)\n+        Ok(respan(lo, VisibilityKind::Public))\n     }\n \n     /// Parse defaultness: `default` or nothing.\n@@ -6573,7 +6588,7 @@ impl<'a> Parser<'a> {\n \n         // Verify whether we have encountered a struct or method definition where the user forgot to\n         // add the `struct` or `fn` keyword after writing `pub`: `pub S {}`\n-        if visibility == Visibility::Public &&\n+        if visibility.node == VisibilityKind::Public &&\n             self.check_ident() &&\n             self.look_ahead(1, |t| *t != token::Not)\n         {\n@@ -6681,7 +6696,7 @@ impl<'a> Parser<'a> {\n             // MACRO INVOCATION ITEM\n \n             let prev_span = self.prev_span;\n-            self.complain_if_pub_macro(&visibility, prev_span);\n+            self.complain_if_pub_macro(&visibility.node, prev_span);\n \n             let mac_lo = self.span;\n \n@@ -6715,8 +6730,8 @@ impl<'a> Parser<'a> {\n         }\n \n         // FAILURE TO PARSE ITEM\n-        match visibility {\n-            Visibility::Inherited => {}\n+        match visibility.node {\n+            VisibilityKind::Inherited => {}\n             _ => {\n                 return Err(self.span_fatal(self.prev_span, \"unmatched visibility `pub`\"));\n             }"}, {"sha": "3dfe3c9e5b990590e12c1e8efe97a45163eb1875", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 19, "deletions": 11, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/063deba92e44809125a433ca6e6c1ad0993313bf/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/063deba92e44809125a433ca6e6c1ad0993313bf/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=063deba92e44809125a433ca6e6c1ad0993313bf", "patch": "@@ -377,7 +377,7 @@ pub fn fun_to_string(decl: &ast::FnDecl,\n     to_string(|s| {\n         s.head(\"\")?;\n         s.print_fn(decl, unsafety, constness, Abi::Rust, Some(name),\n-                   generics, &ast::Visibility::Inherited)?;\n+                   generics, &codemap::dummy_spanned(ast::VisibilityKind::Inherited))?;\n         s.end()?; // Close the head box\n         s.end() // Close the outer box\n     })\n@@ -1458,21 +1458,21 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_visibility(&mut self, vis: &ast::Visibility) -> io::Result<()> {\n-        match *vis {\n-            ast::Visibility::Public => self.word_nbsp(\"pub\"),\n-            ast::Visibility::Crate(_, sugar) => match sugar {\n+        match vis.node {\n+            ast::VisibilityKind::Public => self.word_nbsp(\"pub\"),\n+            ast::VisibilityKind::Crate(sugar) => match sugar {\n                 ast::CrateSugar::PubCrate => self.word_nbsp(\"pub(crate)\"),\n                 ast::CrateSugar::JustCrate => self.word_nbsp(\"crate\")\n             }\n-            ast::Visibility::Restricted { ref path, .. } => {\n+            ast::VisibilityKind::Restricted { ref path, .. } => {\n                 let path = to_string(|s| s.print_path(path, false, 0, true));\n                 if path == \"self\" || path == \"super\" {\n                     self.word_nbsp(&format!(\"pub({})\", path))\n                 } else {\n                     self.word_nbsp(&format!(\"pub(in {})\", path))\n                 }\n             }\n-            ast::Visibility::Inherited => Ok(())\n+            ast::VisibilityKind::Inherited => Ok(())\n         }\n     }\n \n@@ -1569,15 +1569,23 @@ impl<'a> State<'a> {\n         self.print_outer_attributes(&ti.attrs)?;\n         match ti.node {\n             ast::TraitItemKind::Const(ref ty, ref default) => {\n-                self.print_associated_const(ti.ident, ty,\n-                                            default.as_ref().map(|expr| &**expr),\n-                                            &ast::Visibility::Inherited)?;\n+                self.print_associated_const(\n+                    ti.ident,\n+                    ty,\n+                    default.as_ref().map(|expr| &**expr),\n+                    &codemap::respan(ti.span.empty(), ast::VisibilityKind::Inherited),\n+                )?;\n             }\n             ast::TraitItemKind::Method(ref sig, ref body) => {\n                 if body.is_some() {\n                     self.head(\"\")?;\n                 }\n-                self.print_method_sig(ti.ident, &ti.generics, sig, &ast::Visibility::Inherited)?;\n+                self.print_method_sig(\n+                    ti.ident,\n+                    &ti.generics,\n+                    sig,\n+                    &codemap::respan(ti.span.empty(), ast::VisibilityKind::Inherited),\n+                )?;\n                 if let Some(ref body) = *body {\n                     self.nbsp()?;\n                     self.print_block_with_attrs(body, &ti.attrs)?;\n@@ -3055,7 +3063,7 @@ impl<'a> State<'a> {\n                       abi,\n                       name,\n                       &generics,\n-                      &ast::Visibility::Inherited)?;\n+                      &codemap::dummy_spanned(ast::VisibilityKind::Inherited))?;\n         self.end()\n     }\n "}, {"sha": "da24107f4c33b53485f44008d93b9de19183d68a", "filename": "src/libsyntax/std_inject.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/063deba92e44809125a433ca6e6c1ad0993313bf/src%2Flibsyntax%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/063deba92e44809125a433ca6e6c1ad0993313bf/src%2Flibsyntax%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fstd_inject.rs?ref=063deba92e44809125a433ca6e6c1ad0993313bf", "patch": "@@ -14,7 +14,7 @@ use std::cell::Cell;\n use ext::hygiene::{Mark, SyntaxContext};\n use symbol::{Symbol, keywords};\n use syntax_pos::{DUMMY_SP, Span};\n-use codemap::{ExpnInfo, NameAndSpan, MacroAttribute};\n+use codemap::{ExpnInfo, NameAndSpan, MacroAttribute, dummy_spanned, respan};\n use ptr::P;\n use tokenstream::TokenStream;\n \n@@ -60,7 +60,7 @@ pub fn maybe_inject_crates_ref(mut krate: ast::Crate, alt_std_name: Option<Strin\n         attrs: vec![attr::mk_attr_outer(DUMMY_SP,\n                                         attr::mk_attr_id(),\n                                         attr::mk_word_item(Symbol::intern(\"macro_use\")))],\n-        vis: ast::Visibility::Inherited,\n+        vis: dummy_spanned(ast::VisibilityKind::Inherited),\n         node: ast::ItemKind::ExternCrate(Some(crate_name)),\n         ident: ast::Ident::from_str(name),\n         id: ast::DUMMY_NODE_ID,\n@@ -78,7 +78,7 @@ pub fn maybe_inject_crates_ref(mut krate: ast::Crate, alt_std_name: Option<Strin\n             is_sugared_doc: false,\n             span,\n         }],\n-        vis: ast::Visibility::Inherited,\n+        vis: respan(span.empty(), ast::VisibilityKind::Inherited),\n         node: ast::ItemKind::Use(P(ast::UseTree {\n             prefix: ast::Path {\n                 segments: [\"{{root}}\", name, \"prelude\", \"v1\"].into_iter().map(|name| {"}, {"sha": "7b119c576db5821e33e7d42642bda77e29c09944", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/063deba92e44809125a433ca6e6c1ad0993313bf/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/063deba92e44809125a433ca6e6c1ad0993313bf/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=063deba92e44809125a433ca6e6c1ad0993313bf", "patch": "@@ -233,11 +233,11 @@ fn mk_reexport_mod(cx: &mut TestCtxt,\n     let super_ = Ident::from_str(\"super\");\n \n     let items = tests.into_iter().map(|r| {\n-        cx.ext_cx.item_use_simple(DUMMY_SP, ast::Visibility::Public,\n+        cx.ext_cx.item_use_simple(DUMMY_SP, dummy_spanned(ast::VisibilityKind::Public),\n                                   cx.ext_cx.path(DUMMY_SP, vec![super_, r]))\n     }).chain(tested_submods.into_iter().map(|(r, sym)| {\n         let path = cx.ext_cx.path(DUMMY_SP, vec![super_, r, sym]);\n-        cx.ext_cx.item_use_simple_(DUMMY_SP, ast::Visibility::Public, r, path)\n+        cx.ext_cx.item_use_simple_(DUMMY_SP, dummy_spanned(ast::VisibilityKind::Public), r, path)\n     })).collect();\n \n     let reexport_mod = ast::Mod {\n@@ -253,7 +253,7 @@ fn mk_reexport_mod(cx: &mut TestCtxt,\n         attrs: Vec::new(),\n         id: ast::DUMMY_NODE_ID,\n         node: ast::ItemKind::Mod(reexport_mod),\n-        vis: ast::Visibility::Public,\n+        vis: dummy_spanned(ast::VisibilityKind::Public),\n         span: DUMMY_SP,\n         tokens: None,\n     })).pop().unwrap();\n@@ -462,16 +462,16 @@ fn mk_std(cx: &TestCtxt) -> P<ast::Item> {\n             prefix: path_node(vec![id_test]),\n             kind: ast::UseTreeKind::Simple(id_test),\n         })),\n-         ast::Visibility::Public, keywords::Invalid.ident())\n+         ast::VisibilityKind::Public, keywords::Invalid.ident())\n     } else {\n-        (ast::ItemKind::ExternCrate(None), ast::Visibility::Inherited, id_test)\n+        (ast::ItemKind::ExternCrate(None), ast::VisibilityKind::Inherited, id_test)\n     };\n     P(ast::Item {\n         id: ast::DUMMY_NODE_ID,\n         ident,\n         node: vi,\n         attrs: vec![],\n-        vis,\n+        vis: dummy_spanned(vis),\n         span: sp,\n         tokens: None,\n     })\n@@ -513,7 +513,7 @@ fn mk_main(cx: &mut TestCtxt) -> P<ast::Item> {\n         attrs: vec![main_attr],\n         id: ast::DUMMY_NODE_ID,\n         node: main,\n-        vis: ast::Visibility::Public,\n+        vis: dummy_spanned(ast::VisibilityKind::Public),\n         span: sp,\n         tokens: None,\n     })\n@@ -543,7 +543,7 @@ fn mk_test_module(cx: &mut TestCtxt) -> (P<ast::Item>, Option<P<ast::Item>>) {\n         ident: mod_ident,\n         attrs: vec![],\n         node: item_,\n-        vis: ast::Visibility::Public,\n+        vis: dummy_spanned(ast::VisibilityKind::Public),\n         span: DUMMY_SP,\n         tokens: None,\n     })).pop().unwrap();\n@@ -562,7 +562,7 @@ fn mk_test_module(cx: &mut TestCtxt) -> (P<ast::Item>, Option<P<ast::Item>>) {\n             ident: keywords::Invalid.ident(),\n             attrs: vec![],\n             node: ast::ItemKind::Use(P(use_path)),\n-            vis: ast::Visibility::Inherited,\n+            vis: dummy_spanned(ast::VisibilityKind::Inherited),\n             span: DUMMY_SP,\n             tokens: None,\n         })).pop().unwrap()"}, {"sha": "4691ddafa36e8480f2463ad81caffe85245bf214", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/063deba92e44809125a433ca6e6c1ad0993313bf/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/063deba92e44809125a433ca6e6c1ad0993313bf/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=063deba92e44809125a433ca6e6c1ad0993313bf", "patch": "@@ -811,7 +811,7 @@ pub fn walk_arm<'a, V: Visitor<'a>>(visitor: &mut V, arm: &'a Arm) {\n }\n \n pub fn walk_vis<'a, V: Visitor<'a>>(visitor: &mut V, vis: &'a Visibility) {\n-    if let Visibility::Restricted { ref path, id } = *vis {\n+    if let VisibilityKind::Restricted { ref path, id } = vis.node {\n         visitor.visit_path(path, id);\n     }\n }"}, {"sha": "1b3917efdd1e78a631da4c48c257ebf35b67e9b2", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/063deba92e44809125a433ca6e6c1ad0993313bf/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/063deba92e44809125a433ca6e6c1ad0993313bf/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=063deba92e44809125a433ca6e6c1ad0993313bf", "patch": "@@ -530,7 +530,7 @@ impl<'a> TraitDef<'a> {\n                 id: ast::DUMMY_NODE_ID,\n                 span: self.span,\n                 ident,\n-                vis: ast::Visibility::Inherited,\n+                vis: respan(self.span.empty(), ast::VisibilityKind::Inherited),\n                 defaultness: ast::Defaultness::Final,\n                 attrs: Vec::new(),\n                 generics: Generics::default(),\n@@ -977,7 +977,7 @@ impl<'a> MethodDef<'a> {\n             attrs: self.attributes.clone(),\n             generics: fn_generics,\n             span: trait_.span,\n-            vis: ast::Visibility::Inherited,\n+            vis: respan(trait_.span.empty(), ast::VisibilityKind::Inherited),\n             defaultness: ast::Defaultness::Final,\n             ident: method_ident,\n             node: ast::ImplItemKind::Method(ast::MethodSig {"}, {"sha": "9605f6b5c5a9d30b60e24ad724e04d0ea089241e", "filename": "src/libsyntax_ext/global_asm.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/063deba92e44809125a433ca6e6c1ad0993313bf/src%2Flibsyntax_ext%2Fglobal_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/063deba92e44809125a433ca6e6c1ad0993313bf/src%2Flibsyntax_ext%2Fglobal_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fglobal_asm.rs?ref=063deba92e44809125a433ca6e6c1ad0993313bf", "patch": "@@ -19,6 +19,7 @@\n /// therefore apply.\n \n use syntax::ast;\n+use syntax::codemap::respan;\n use syntax::ext::base;\n use syntax::ext::base::*;\n use syntax::feature_gate;\n@@ -59,7 +60,7 @@ pub fn expand_global_asm<'cx>(cx: &'cx mut ExtCtxt,\n             asm,\n             ctxt: cx.backtrace(),\n         })),\n-        vis: ast::Visibility::Inherited,\n+        vis: respan(sp.empty(), ast::VisibilityKind::Inherited),\n         span: sp,\n         tokens: None,\n     })))"}, {"sha": "e623779ce63ba732eade30cca564e192939fd63c", "filename": "src/libsyntax_ext/proc_macro_registrar.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/063deba92e44809125a433ca6e6c1ad0993313bf/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/063deba92e44809125a433ca6e6c1ad0993313bf/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs?ref=063deba92e44809125a433ca6e6c1ad0993313bf", "patch": "@@ -14,7 +14,7 @@ use errors;\n \n use syntax::ast::{self, Ident, NodeId};\n use syntax::attr;\n-use syntax::codemap::{ExpnInfo, NameAndSpan, MacroAttribute};\n+use syntax::codemap::{ExpnInfo, NameAndSpan, MacroAttribute, respan};\n use syntax::ext::base::ExtCtxt;\n use syntax::ext::build::AstBuilder;\n use syntax::ext::expand::ExpansionConfig;\n@@ -103,7 +103,7 @@ impl<'a> CollectProcMacros<'a> {\n     fn check_not_pub_in_root(&self, vis: &ast::Visibility, sp: Span) {\n         if self.is_proc_macro_crate &&\n            self.in_root &&\n-           *vis == ast::Visibility::Public {\n+           vis.node == ast::VisibilityKind::Public {\n             self.handler.span_err(sp,\n                                   \"`proc-macro` crate types cannot \\\n                                    export any items other than functions \\\n@@ -181,7 +181,7 @@ impl<'a> CollectProcMacros<'a> {\n             Vec::new()\n         };\n \n-        if self.in_root && item.vis == ast::Visibility::Public {\n+        if self.in_root && item.vis.node == ast::VisibilityKind::Public {\n             self.derives.push(ProcMacroDerive {\n                 span: item.span,\n                 trait_name,\n@@ -206,7 +206,7 @@ impl<'a> CollectProcMacros<'a> {\n             return;\n         }\n \n-        if self.in_root && item.vis == ast::Visibility::Public {\n+        if self.in_root && item.vis.node == ast::VisibilityKind::Public {\n             self.attr_macros.push(ProcMacroDef {\n                 span: item.span,\n                 function_name: item.ident,\n@@ -229,7 +229,7 @@ impl<'a> CollectProcMacros<'a> {\n             return;\n         }\n \n-        if self.in_root && item.vis == ast::Visibility::Public {\n+        if self.in_root && item.vis.node == ast::VisibilityKind::Public {\n             self.bang_macros.push(ProcMacroDef {\n                 span: item.span,\n                 function_name: item.ident,\n@@ -439,12 +439,12 @@ fn mk_registrar(cx: &mut ExtCtxt,\n     let derive_registrar = cx.attribute(span, derive_registrar);\n     let func = func.map(|mut i| {\n         i.attrs.push(derive_registrar);\n-        i.vis = ast::Visibility::Public;\n+        i.vis = respan(span, ast::VisibilityKind::Public);\n         i\n     });\n     let ident = ast::Ident::with_empty_ctxt(Symbol::gensym(\"registrar\"));\n     let module = cx.item_mod(span, span, ident, Vec::new(), vec![krate, func]).map(|mut i| {\n-        i.vis = ast::Visibility::Public;\n+        i.vis = respan(span, ast::VisibilityKind::Public);\n         i\n     });\n "}, {"sha": "0f6dbc39e217a1a16a3642e3f2257c9107621918", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/063deba92e44809125a433ca6e6c1ad0993313bf/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/063deba92e44809125a433ca6e6c1ad0993313bf/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=063deba92e44809125a433ca6e6c1ad0993313bf", "patch": "@@ -216,6 +216,12 @@ impl Span {\n         self.data().with_ctxt(ctxt)\n     }\n \n+    /// Returns a new span representing an empty span at the beginning of this span\n+    #[inline]\n+    pub fn empty(self) -> Span {\n+        self.with_hi(self.lo())\n+    }\n+\n     /// Returns `self` if `self` is not the dummy span, and `other` otherwise.\n     pub fn substitute_dummy(self, other: Span) -> Span {\n         if self.source_equal(&DUMMY_SP) { other } else { self }"}, {"sha": "3587319ed0cbc38e60b6a93201b083e78eb63b18", "filename": "src/test/ui/error-codes/E0449.stderr", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/063deba92e44809125a433ca6e6c1ad0993313bf/src%2Ftest%2Fui%2Ferror-codes%2FE0449.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/063deba92e44809125a433ca6e6c1ad0993313bf/src%2Ftest%2Fui%2Ferror-codes%2FE0449.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0449.stderr?ref=063deba92e44809125a433ca6e6c1ad0993313bf", "patch": "@@ -2,23 +2,21 @@ error[E0449]: unnecessary visibility qualifier\n   --> $DIR/E0449.rs:17:1\n    |\n 17 | pub impl Bar {} //~ ERROR E0449\n-   | ^^^^^^^^^^^^^^^ `pub` not needed here\n+   | ^^^ `pub` not needed here\n    |\n    = note: place qualifiers on individual impl items instead\n \n error[E0449]: unnecessary visibility qualifier\n   --> $DIR/E0449.rs:19:1\n    |\n-19 | / pub impl Foo for Bar { //~ ERROR E0449\n-20 | |     pub fn foo() {} //~ ERROR E0449\n-21 | | }\n-   | |_^ `pub` not needed here\n+19 | pub impl Foo for Bar { //~ ERROR E0449\n+   | ^^^ `pub` not needed here\n \n error[E0449]: unnecessary visibility qualifier\n   --> $DIR/E0449.rs:20:5\n    |\n 20 |     pub fn foo() {} //~ ERROR E0449\n-   |     ^^^^^^^^^^^^^^^ `pub` not needed here\n+   |     ^^^ `pub` not needed here\n \n error: aborting due to 3 previous errors\n "}]}