{"sha": "f6efb54d4446313d6dba93dd6bde33cd79354543", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY2ZWZiNTRkNDQ0NjMxM2Q2ZGJhOTNkZDZiZGUzM2NkNzkzNTQ1NDM=", "commit": {"author": {"name": "Jakub Wieczorek", "email": "jakub@jakub.cc", "date": "2014-06-12T20:54:27Z"}, "committer": {"name": "Jakub Wieczorek", "email": "jakub@jakub.cc", "date": "2014-06-14T21:32:28Z"}, "message": "Fix an ICE on a cast from an inferred nil to uint\n\nFixes #10991.", "tree": {"sha": "068b4388824786897f63d70bf3541198dd2e4404", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/068b4388824786897f63d70bf3541198dd2e4404"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f6efb54d4446313d6dba93dd6bde33cd79354543", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f6efb54d4446313d6dba93dd6bde33cd79354543", "html_url": "https://github.com/rust-lang/rust/commit/f6efb54d4446313d6dba93dd6bde33cd79354543", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f6efb54d4446313d6dba93dd6bde33cd79354543/comments", "author": null, "committer": null, "parents": [{"sha": "6d8342f5e9f7093694548e761ee7df4f55243f3f", "url": "https://api.github.com/repos/rust-lang/rust/commits/6d8342f5e9f7093694548e761ee7df4f55243f3f", "html_url": "https://github.com/rust-lang/rust/commit/6d8342f5e9f7093694548e761ee7df4f55243f3f"}], "stats": {"total": 86, "additions": 29, "deletions": 57}, "files": [{"sha": "993b88a6eeb4a588c027a34040fd27b1db6e1ad5", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 15, "deletions": 57, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/f6efb54d4446313d6dba93dd6bde33cd79354543/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6efb54d4446313d6dba93dd6bde33cd79354543/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=f6efb54d4446313d6dba93dd6bde33cd79354543", "patch": "@@ -3023,6 +3023,9 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                 ty::ty_trait(..) => (),\n \n                 _ => {\n+                    let t_1 = structurally_resolved_type(fcx, e.span, t_1);\n+                    let t_e = structurally_resolved_type(fcx, e.span, t_e);\n+\n                     if ty::type_is_nil(t_e) {\n                         fcx.type_error_message(expr.span, |actual| {\n                             format!(\"cast from nil: `{}` as `{}`\",\n@@ -3037,21 +3040,14 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                         }, t_e, None);\n                     }\n \n-                    let t1 = structurally_resolved_type(fcx, e.span, t_1);\n-                    let te = structurally_resolved_type(fcx, e.span, t_e);\n-                    let t_1_is_scalar = type_is_scalar(fcx, expr.span, t_1);\n-                    let t_1_is_char = type_is_char(fcx, expr.span, t_1);\n-                    let t_1_is_bare_fn = type_is_bare_fn(fcx, expr.span, t_1);\n-                    let t_1_is_float = type_is_floating_point(fcx,\n-                                                              expr.span,\n-                                                              t_1);\n+                    let t_1_is_scalar = ty::type_is_scalar(t_1);\n+                    let t_1_is_char = ty::type_is_char(t_1);\n+                    let t_1_is_bare_fn = ty::type_is_bare_fn(t_1);\n+                    let t_1_is_float = ty::type_is_floating_point(t_1);\n \n                     // casts to scalars other than `char` and `bare fn` are trivial\n-                    let t_1_is_trivial = t_1_is_scalar &&\n-                        !t_1_is_char && !t_1_is_bare_fn;\n-\n-                    if type_is_c_like_enum(fcx, expr.span, t_e) &&\n-                            t_1_is_trivial {\n+                    let t_1_is_trivial = t_1_is_scalar && !t_1_is_char && !t_1_is_bare_fn;\n+                    if ty::type_is_c_like_enum(fcx.tcx(), t_e) && t_1_is_trivial {\n                         if t_1_is_float {\n                             fcx.type_error_message(expr.span, |actual| {\n                                 format!(\"illegal cast; cast through an \\\n@@ -3062,22 +3058,20 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                         }\n                         // casts from C-like enums are allowed\n                     } else if t_1_is_char {\n-                        let te = fcx.infcx().resolve_type_vars_if_possible(te);\n-                        if ty::get(te).sty != ty::ty_uint(ast::TyU8) {\n+                        let t_e = fcx.infcx().resolve_type_vars_if_possible(t_e);\n+                        if ty::get(t_e).sty != ty::ty_uint(ast::TyU8) {\n                             fcx.type_error_message(expr.span, |actual| {\n                                 format!(\"only `u8` can be cast as \\\n                                          `char`, not `{}`\", actual)\n                             }, t_e, None);\n                         }\n-                    } else if ty::get(t1).sty == ty::ty_bool {\n+                    } else if ty::get(t_1).sty == ty::ty_bool {\n                         fcx.tcx()\n                            .sess\n                            .span_err(expr.span,\n                                      \"cannot cast as `bool`, compare with \\\n                                       zero instead\");\n-                    } else if type_is_region_ptr(fcx, expr.span, t_e) &&\n-                        type_is_unsafe_ptr(fcx, expr.span, t_1) {\n-\n+                    } else if ty::type_is_region_ptr(t_e) && ty::type_is_unsafe_ptr(t_1) {\n                         fn is_vec(t: ty::t) -> bool {\n                             match ty::get(t).sty {\n                                 ty::ty_vec(..) => true,\n@@ -3110,7 +3104,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n \n                         /* this cast is only allowed from &[T] to *T or\n                         &T to *T. */\n-                        match (&ty::get(te).sty, &ty::get(t_1).sty) {\n+                        match (&ty::get(t_e).sty, &ty::get(t_1).sty) {\n                             (&ty::ty_rptr(_, ty::mt { ty: mt1, mutbl: ast::MutImmutable }),\n                              &ty::ty_ptr(ty::mt { ty: mt2, mutbl: ast::MutImmutable }))\n                             if types_compatible(fcx, e.span, mt1, mt2) => {\n@@ -3120,8 +3114,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                                 demand::coerce(fcx, e.span, t_1, &**e);\n                             }\n                         }\n-                    } else if !(type_is_scalar(fcx,expr.span,t_e)\n-                                && t_1_is_trivial) {\n+                    } else if !(ty::type_is_scalar(t_e) && t_1_is_trivial) {\n                         /*\n                         If more type combinations should be supported than are\n                         supported here, then file an enhancement issue and\n@@ -4203,41 +4196,6 @@ pub fn type_is_uint(fcx: &FnCtxt, sp: Span, typ: ty::t) -> bool {\n     return ty::type_is_uint(typ_s);\n }\n \n-pub fn type_is_scalar(fcx: &FnCtxt, sp: Span, typ: ty::t) -> bool {\n-    let typ_s = structurally_resolved_type(fcx, sp, typ);\n-    return ty::type_is_scalar(typ_s);\n-}\n-\n-pub fn type_is_char(fcx: &FnCtxt, sp: Span, typ: ty::t) -> bool {\n-    let typ_s = structurally_resolved_type(fcx, sp, typ);\n-    return ty::type_is_char(typ_s);\n-}\n-\n-pub fn type_is_bare_fn(fcx: &FnCtxt, sp: Span, typ: ty::t) -> bool {\n-    let typ_s = structurally_resolved_type(fcx, sp, typ);\n-    return ty::type_is_bare_fn(typ_s);\n-}\n-\n-pub fn type_is_floating_point(fcx: &FnCtxt, sp: Span, typ: ty::t) -> bool {\n-    let typ_s = structurally_resolved_type(fcx, sp, typ);\n-    return ty::type_is_floating_point(typ_s);\n-}\n-\n-pub fn type_is_unsafe_ptr(fcx: &FnCtxt, sp: Span, typ: ty::t) -> bool {\n-    let typ_s = structurally_resolved_type(fcx, sp, typ);\n-    return ty::type_is_unsafe_ptr(typ_s);\n-}\n-\n-pub fn type_is_region_ptr(fcx: &FnCtxt, sp: Span, typ: ty::t) -> bool {\n-    let typ_s = structurally_resolved_type(fcx, sp, typ);\n-    return ty::type_is_region_ptr(typ_s);\n-}\n-\n-pub fn type_is_c_like_enum(fcx: &FnCtxt, sp: Span, typ: ty::t) -> bool {\n-    let typ_s = structurally_resolved_type(fcx, sp, typ);\n-    return ty::type_is_c_like_enum(fcx.ccx.tcx, typ_s);\n-}\n-\n pub fn ast_expr_vstore_to_ty(fcx: &FnCtxt,\n                              e: &ast::Expr,\n                              v: ast::ExprVstore,"}, {"sha": "8f7e6470f909530117d0c527fe0f5591ac48c0ef", "filename": "src/test/compile-fail/issue-10991.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f6efb54d4446313d6dba93dd6bde33cd79354543/src%2Ftest%2Fcompile-fail%2Fissue-10991.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6efb54d4446313d6dba93dd6bde33cd79354543/src%2Ftest%2Fcompile-fail%2Fissue-10991.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-10991.rs?ref=f6efb54d4446313d6dba93dd6bde33cd79354543", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    let nil = ();\n+    let _t = nil as uint; //~ ERROR: cast from nil: `()` as `uint`\n+}"}]}