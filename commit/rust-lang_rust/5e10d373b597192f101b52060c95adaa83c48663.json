{"sha": "5e10d373b597192f101b52060c95adaa83c48663", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVlMTBkMzczYjU5NzE5MmYxMDFiNTIwNjBjOTVhZGFhODNjNDg2NjM=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-05-20T01:08:33Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-05-20T01:12:18Z"}, "message": "rustuv: Remove usage of UnsafeArc", "tree": {"sha": "dc803b35763316b670b398040164d6a169de794b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dc803b35763316b670b398040164d6a169de794b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5e10d373b597192f101b52060c95adaa83c48663", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5e10d373b597192f101b52060c95adaa83c48663", "html_url": "https://github.com/rust-lang/rust/commit/5e10d373b597192f101b52060c95adaa83c48663", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5e10d373b597192f101b52060c95adaa83c48663/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "88b322c5fdcdf5b3dc2bb635dd9696a58ec48ea2", "url": "https://api.github.com/repos/rust-lang/rust/commits/88b322c5fdcdf5b3dc2bb635dd9696a58ec48ea2", "html_url": "https://github.com/rust-lang/rust/commit/88b322c5fdcdf5b3dc2bb635dd9696a58ec48ea2"}], "stats": {"total": 50, "additions": 23, "deletions": 27}, "files": [{"sha": "63d9aa7ead0a0a22c96a53a8cb1751865d3ec131", "filename": "src/librustuv/access.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5e10d373b597192f101b52060c95adaa83c48663/src%2Flibrustuv%2Faccess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e10d373b597192f101b52060c95adaa83c48663/src%2Flibrustuv%2Faccess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Faccess.rs?ref=5e10d373b597192f101b52060c95adaa83c48663", "patch": "@@ -14,15 +14,16 @@\n /// It is assumed that all invocations of this struct happen on the same thread\n /// (the uv event loop).\n \n+use alloc::arc::Arc;\n use std::mem;\n use std::rt::local::Local;\n use std::rt::task::{BlockedTask, Task};\n-use std::sync::arc::UnsafeArc;\n+use std::ty::Unsafe;\n \n use homing::HomingMissile;\n \n pub struct Access {\n-    inner: UnsafeArc<Inner>,\n+    inner: Arc<Unsafe<Inner>>,\n }\n \n pub struct Guard<'a> {\n@@ -39,11 +40,11 @@ struct Inner {\n impl Access {\n     pub fn new() -> Access {\n         Access {\n-            inner: UnsafeArc::new(Inner {\n+            inner: Arc::new(Unsafe::new(Inner {\n                 queue: vec![],\n                 held: false,\n                 closed: false,\n-            })\n+            }))\n         }\n     }\n "}, {"sha": "0a6a305a3b78084c9d7a2ae4471a33c4e7ebc0d8", "filename": "src/librustuv/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5e10d373b597192f101b52060c95adaa83c48663/src%2Flibrustuv%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e10d373b597192f101b52060c95adaa83c48663/src%2Flibrustuv%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Flib.rs?ref=5e10d373b597192f101b52060c95adaa83c48663", "patch": "@@ -46,6 +46,7 @@ via `close` and `delete` methods.\n #[cfg(test)] extern crate green;\n #[cfg(test)] extern crate realrustuv = \"rustuv\";\n extern crate libc;\n+extern crate alloc;\n \n use libc::{c_int, c_void};\n use std::fmt;"}, {"sha": "98ae865cb1da32c440c52d1aa8509b2e5d7057d0", "filename": "src/librustuv/queue.rs", "status": "modified", "additions": 13, "deletions": 20, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/5e10d373b597192f101b52060c95adaa83c48663/src%2Flibrustuv%2Fqueue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e10d373b597192f101b52060c95adaa83c48663/src%2Flibrustuv%2Fqueue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fqueue.rs?ref=5e10d373b597192f101b52060c95adaa83c48663", "patch": "@@ -20,10 +20,10 @@\n \n #![allow(dead_code)]\n \n+use alloc::arc::Arc;\n use libc::c_void;\n use std::mem;\n use std::rt::task::BlockedTask;\n-use std::sync::arc::UnsafeArc;\n use std::unstable::mutex::NativeMutex;\n use mpsc = std::sync::mpsc_queue;\n \n@@ -46,20 +46,20 @@ struct State {\n /// This structure is intended to be stored next to the event loop, and it is\n /// used to create new `Queue` structures.\n pub struct QueuePool {\n-    queue: UnsafeArc<State>,\n+    queue: Arc<State>,\n     refcnt: uint,\n }\n \n /// This type is used to send messages back to the original event loop.\n pub struct Queue {\n-    queue: UnsafeArc<State>,\n+    queue: Arc<State>,\n }\n \n extern fn async_cb(handle: *uvll::uv_async_t) {\n     let pool: &mut QueuePool = unsafe {\n         mem::transmute(uvll::get_data_for_uv_handle(handle))\n     };\n-    let state: &mut State = unsafe { mem::transmute(pool.queue.get()) };\n+    let state: &State = &*pool.queue;\n \n     // Remember that there is no guarantee about how many times an async\n     // callback is called with relation to the number of sends, so process the\n@@ -109,7 +109,7 @@ extern fn async_cb(handle: *uvll::uv_async_t) {\n impl QueuePool {\n     pub fn new(loop_: &mut Loop) -> Box<QueuePool> {\n         let handle = UvHandle::alloc(None::<AsyncWatcher>, uvll::UV_ASYNC);\n-        let state = UnsafeArc::new(State {\n+        let state = Arc::new(State {\n             handle: handle,\n             lock: unsafe {NativeMutex::new()},\n             queue: mpsc::Queue::new(),\n@@ -132,24 +132,20 @@ impl QueuePool {\n     pub fn queue(&mut self) -> Queue {\n         unsafe {\n             if self.refcnt == 0 {\n-                uvll::uv_ref((*self.queue.get()).handle);\n+                uvll::uv_ref(self.queue.handle);\n             }\n             self.refcnt += 1;\n         }\n         Queue { queue: self.queue.clone() }\n     }\n \n-    pub fn handle(&self) -> *uvll::uv_async_t {\n-        unsafe { (*self.queue.get()).handle }\n-    }\n+    pub fn handle(&self) -> *uvll::uv_async_t { self.queue.handle }\n }\n \n impl Queue {\n     pub fn push(&mut self, task: BlockedTask) {\n-        unsafe {\n-            (*self.queue.get()).queue.push(Task(task));\n-            uvll::uv_async_send((*self.queue.get()).handle);\n-        }\n+        self.queue.queue.push(Task(task));\n+        unsafe { uvll::uv_async_send(self.queue.handle); }\n     }\n }\n \n@@ -160,9 +156,7 @@ impl Clone for Queue {\n         // that the count is at least one (because we have a queue right here),\n         // and if the queue is dropped later on it'll see the increment for the\n         // decrement anyway.\n-        unsafe {\n-            (*self.queue.get()).queue.push(Increment);\n-        }\n+        self.queue.queue.push(Increment);\n         Queue { queue: self.queue.clone() }\n     }\n }\n@@ -172,10 +166,9 @@ impl Drop for Queue {\n         // See the comments in the async_cb function for why there is a lock\n         // that is acquired only on a drop.\n         unsafe {\n-            let state = self.queue.get();\n-            let _l = (*state).lock.lock();\n-            (*state).queue.push(Decrement);\n-            uvll::uv_async_send((*state).handle);\n+            let _l = self.queue.lock.lock();\n+            self.queue.queue.push(Decrement);\n+            uvll::uv_async_send(self.queue.handle);\n         }\n     }\n }"}, {"sha": "2a1a6b9f26d474fa2e07364dff65bd8b76cbf92f", "filename": "src/librustuv/rc.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5e10d373b597192f101b52060c95adaa83c48663/src%2Flibrustuv%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e10d373b597192f101b52060c95adaa83c48663/src%2Flibrustuv%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Frc.rs?ref=5e10d373b597192f101b52060c95adaa83c48663", "patch": "@@ -16,16 +16,17 @@\n /// the same underlying uv object, hence Rc is not used and this simple counter\n /// should suffice.\n \n-use std::sync::arc::UnsafeArc;\n+use alloc::arc::Arc;\n+use std::ty::Unsafe;\n \n pub struct Refcount {\n-    rc: UnsafeArc<uint>,\n+    rc: Arc<Unsafe<uint>>,\n }\n \n impl Refcount {\n     /// Creates a new refcount of 1\n     pub fn new() -> Refcount {\n-        Refcount { rc: UnsafeArc::new(1) }\n+        Refcount { rc: Arc::new(Unsafe::new(1)) }\n     }\n \n     fn increment(&self) {"}]}