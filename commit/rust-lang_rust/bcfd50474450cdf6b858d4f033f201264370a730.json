{"sha": "bcfd50474450cdf6b858d4f033f201264370a730", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJjZmQ1MDQ3NDQ1MGNkZjZiODU4ZDRmMDMzZjIwMTI2NDM3MGE3MzA=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2016-12-30T01:26:15Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-12-30T01:26:15Z"}, "message": "Rollup merge of #38559 - japaric:ptx2, r=alexcrichton\n\nPTX support, take 2\n\n- You can generate PTX using `--emit=asm` and the right (custom) target. Which\n  then you can run on a NVIDIA GPU.\n\n- You can compile `core` to PTX. [Xargo] also works and it can compile some\n  other crates like `collections` (but I doubt all of those make sense on a GPU)\n\n[Xargo]: https://github.com/japaric/xargo\n\n- You can create \"global\" functions, which can be \"called\" by the host, using\n  the `\"ptx-kernel\"` ABI, e.g. `extern \"ptx-kernel\" fn kernel() { .. }`. Every\n  other function is a \"device\" function and can only be called by the GPU.\n\n- Intrinsics like `__syncthreads()` and `blockIdx.x` are available as\n  `\"platform-intrinsics\"`. These intrinsics are *not* in the `core` crate but\n  any Rust user can create \"bindings\" to them using an `extern\n  \"platform-intrinsics\"` block. See example at the end.\n\n- Trying to emit PTX with `-g` (debuginfo); you get an LLVM error. But I don't\n  think PTX can contain debuginfo anyway so `-g` should be ignored and a warning\n  should be printed (\"`-g` doesn't work with this target\" or something).\n\n- \"Single source\" support. You *can't* write a single source file that contains\n  both host and device code. I think that should be possible to implement that\n  outside the compiler using compiler plugins / build scripts.\n\n- The equivalent to CUDA `__shared__` which it's used to declare memory that's\n  shared between the threads of the same block. This could be implemented using\n  attributes: `#[shared] static mut SCRATCH_MEMORY: [f32; 64]` but hasn't been\n  implemented yet.\n\n- Built-in targets. This PR doesn't add targets to the compiler just yet but one\n  can create custom targets to be able to emit PTX code (see the example at the\n  end). The idea is to have people experiment with this feature before\n  committing to it (built-in targets are \"insta-stable\")\n\n- All functions must be \"inlined\". IOW, the `.rlib` must always contain the LLVM\n  bitcode of all the functions of the crate it was produced from. Otherwise, you\n  end with \"undefined references\" in the final PTX code but you won't get *any*\n  linker error because no linker is involved. IOW, you'll hit a runtime error\n  when loading the PTX into the GPU. The workaround is to use `#[inline]` on\n  non-generic functions and to never use `#[inline(never)]` but this may not\n  always be possible because e.g. you could be relying on third party code.\n\n- Should `--emit=asm` generate a `.ptx` file instead of a `.s` file?\n\nTL;DR Use Xargo to turn a crate into a PTX module (a `.s` file). Then pass that\nPTX module, as a string, to the GPU and run it.\n\nThe full code is in [this repository]. This section gives an overview of how to\nrun Rust code on a NVIDIA GPU.\n\n[this repository]: https://github.com/japaric/cuda\n\n- Create a custom target. Here's the 64-bit NVPTX target (NOTE: the comments\n  are not valid because this is supposed to be a JSON file; remove them before\n  you use this file):\n\n``` js\n// nvptx64-nvidia-cuda.json\n{\n  \"arch\": \"nvptx64\",  // matches LLVM\n  \"cpu\": \"sm_20\",  // \"oldest\" compute capability supported by LLVM\n  \"data-layout\": \"e-i64:64-v16:16-v32:32-n16:32:64\",\n  \"llvm-target\": \"nvptx64-nvidia-cuda\",\n  \"max-atomic-width\": 0,  // LLVM errors with any other value :-(\n  \"os\": \"cuda\",  // matches LLVM\n  \"panic-strategy\": \"abort\",\n  \"target-endian\": \"little\",\n  \"target-pointer-width\": \"64\",\n  \"target-vendor\": \"nvidia\",  // matches LLVM -- not required\n}\n```\n\n(There's a 32-bit target specification in the linked repository)\n\n- Write a kernel\n\n``` rust\n\nextern \"platform-intrinsic\" {\n    fn nvptx_block_dim_x() -> i32;\n    fn nvptx_block_idx_x() -> i32;\n    fn nvptx_thread_idx_x() -> i32;\n}\n\n/// Copies an array of `n` floating point numbers from `src` to `dst`\npub unsafe extern \"ptx-kernel\" fn memcpy(dst: *mut f32,\n                                         src: *const f32,\n                                         n: usize) {\n    let i = (nvptx_block_dim_x() as isize)\n        .wrapping_mul(nvptx_block_idx_x() as isize)\n        .wrapping_add(nvptx_thread_idx_x() as isize);\n\n    if (i as usize) < n {\n        *dst.offset(i) = *src.offset(i);\n    }\n}\n```\n\n- Emit PTX code\n\n```\n$ xargo rustc --target nvptx64-nvidia-cuda --release -- --emit=asm\n   Compiling core v0.0.0 (file://..)\n   (..)\n   Compiling nvptx-builtins v0.1.0 (https://github.com/japaric/nvptx-builtins)\n   Compiling kernel v0.1.0\n\n$ cat target/nvptx64-nvidia-cuda/release/deps/kernel-*.s\n//\n// Generated by LLVM NVPTX Back-End\n//\n\n.version 3.2\n.target sm_20\n.address_size 64\n\n        // .globl       memcpy\n\n.visible .entry memcpy(\n        .param .u64 memcpy_param_0,\n        .param .u64 memcpy_param_1,\n        .param .u64 memcpy_param_2\n)\n{\n        .reg .pred      %p<2>;\n        .reg .s32       %r<5>;\n        .reg .s64       %rd<12>;\n\n        ld.param.u64    %rd7, [memcpy_param_2];\n        mov.u32 %r1, %ntid.x;\n        mov.u32 %r2, %ctaid.x;\n        mul.wide.s32    %rd8, %r2, %r1;\n        mov.u32 %r3, %tid.x;\n        cvt.s64.s32     %rd9, %r3;\n        add.s64         %rd10, %rd9, %rd8;\n        setp.ge.u64     %p1, %rd10, %rd7;\n        @%p1 bra        LBB0_2;\n        ld.param.u64    %rd3, [memcpy_param_0];\n        ld.param.u64    %rd4, [memcpy_param_1];\n        cvta.to.global.u64      %rd5, %rd4;\n        cvta.to.global.u64      %rd6, %rd3;\n        shl.b64         %rd11, %rd10, 2;\n        add.s64         %rd1, %rd6, %rd11;\n        add.s64         %rd2, %rd5, %rd11;\n        ld.global.u32   %r4, [%rd2];\n        st.global.u32   [%rd1], %r4;\nLBB0_2:\n        ret;\n}\n```\n\n- Run it on the GPU\n\n``` rust\n// `kernel.ptx` is the `*.s` file we got in the previous step\nconst KERNEL: &'static str = include_str!(\"kernel.ptx\");\n\ndriver::initialize()?;\n\nlet device = Device(0)?;\nlet ctx = device.create_context()?;\nlet module = ctx.load_module(KERNEL)?;\nlet kernel = module.function(\"memcpy\")?;\n\nlet h_a: Vec<f32> = /* create some random data */;\nlet h_b = vec![0.; N];\n\nlet d_a = driver::allocate(bytes)?;\nlet d_b = driver::allocate(bytes)?;\n\n// Copy from host to GPU\ndriver::copy(h_a, d_a)?;\n\n// Run `memcpy` on the GPU\nkernel.launch(d_b, d_a, N)?;\n\n// Copy from GPU to host\ndriver::copy(d_b, h_b)?;\n\n// Verify\nassert_eq!(h_a, h_b);\n\n// `d_a`, `d_b`, `h_a`, `h_b` are dropped/freed here\n```\n\n---\n\ncc @alexcrichton @brson @rkruppe\n\n> What has changed since #34195?\n\n- `core` now can be compiled into PTX. Which makes it very easy to turn `no_std`\n  crates into \"kernels\" with the help of Xargo.\n\n- There's now a way, the `\"ptx-kernel\"` ABI, to generate \"global\" functions. The\n  old PR required a manual step (it was hack) to \"convert\" \"device\" functions\n  into \"global\" functions. (Only \"global\" functions can be launched by the host)\n\n- Everything is unstable. There are not \"insta stable\" built-in targets this\n  time (\\*). The users have to use a custom target to experiment with this\n  feature. Also, PTX instrinsics, like `__syncthreads` and `blockIdx.x`, are now\n  implemented as `\"platform-intrinsics\"` so they no longer live in the `core`\n  crate.\n\n(\\*) I'd actually like to have in-tree targets because that makes this target\nmore discoverable, removes the need to lug around .json files, etc.\n\nHowever, bundling a target with the compiler immediately puts it in the path\ntowards stabilization. Which gives us just two cycles to find and fix any\nproblem with the target specification. Afterwards, it becomes hard to tweak\nthe specification because that could be a breaking change.\n\nA possible solution could be \"unstable built-in targets\". Basically, to use an\nunstable target, you'll have to also pass `-Z unstable-options` to the compiler.\nAnd unstable targets, being unstable, wouldn't be available on stable.\n\n> Why should this be merged?\n\n- To let people experiment with the feature out of tree. Having easy access to\n  the feature (in every nightly) allows this. I also think that, as it is, it\n  should be possible to start prototyping type-safe single source support using\n  build scripts, macros and/or plugins.\n\n- It's a straightforward implementation. No different that adding support for\n  any other architecture.", "tree": {"sha": "3f03699f7e6470eda62cb0e8560ab15bbc14690c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3f03699f7e6470eda62cb0e8560ab15bbc14690c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bcfd50474450cdf6b858d4f033f201264370a730", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bcfd50474450cdf6b858d4f033f201264370a730", "html_url": "https://github.com/rust-lang/rust/commit/bcfd50474450cdf6b858d4f033f201264370a730", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bcfd50474450cdf6b858d4f033f201264370a730/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4e2e01ec9570997b9a0588f691d85dd081f83fd9", "url": "https://api.github.com/repos/rust-lang/rust/commits/4e2e01ec9570997b9a0588f691d85dd081f83fd9", "html_url": "https://github.com/rust-lang/rust/commit/4e2e01ec9570997b9a0588f691d85dd081f83fd9"}, {"sha": "aac5ff76649a2257e2c04f1d44cf11e999a39442", "url": "https://api.github.com/repos/rust-lang/rust/commits/aac5ff76649a2257e2c04f1d44cf11e999a39442", "html_url": "https://github.com/rust-lang/rust/commit/aac5ff76649a2257e2c04f1d44cf11e999a39442"}], "stats": {"total": 349, "additions": 345, "deletions": 4}, "files": [{"sha": "80f27a5ab673f5f464cf2f6ce4c2da1f3266ad0d", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bcfd50474450cdf6b858d4f033f201264370a730/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcfd50474450cdf6b858d4f033f201264370a730/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=bcfd50474450cdf6b858d4f033f201264370a730", "patch": "@@ -81,7 +81,7 @@ pub fn llvm(build: &Build, target: &str) {\n        .profile(profile)\n        .define(\"LLVM_ENABLE_ASSERTIONS\", assertions)\n        .define(\"LLVM_TARGETS_TO_BUILD\",\n-               \"X86;ARM;AArch64;Mips;PowerPC;SystemZ;JSBackend;MSP430;Sparc\")\n+               \"X86;ARM;AArch64;Mips;PowerPC;SystemZ;JSBackend;MSP430;Sparc;NVPTX\")\n        .define(\"LLVM_INCLUDE_EXAMPLES\", \"OFF\")\n        .define(\"LLVM_INCLUDE_TESTS\", \"OFF\")\n        .define(\"LLVM_INCLUDE_DOCS\", \"OFF\")"}, {"sha": "1beaaeb5d8718161e5ceba4a42d9d3fe3b903c07", "filename": "src/etc/platform-intrinsics/nvptx/cuda.json", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/bcfd50474450cdf6b858d4f033f201264370a730/src%2Fetc%2Fplatform-intrinsics%2Fnvptx%2Fcuda.json", "raw_url": "https://github.com/rust-lang/rust/raw/bcfd50474450cdf6b858d4f033f201264370a730/src%2Fetc%2Fplatform-intrinsics%2Fnvptx%2Fcuda.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fplatform-intrinsics%2Fnvptx%2Fcuda.json?ref=bcfd50474450cdf6b858d4f033f201264370a730", "patch": "@@ -0,0 +1,13 @@\n+{\n+    \"intrinsic_prefix\": \"_\",\n+    \"llvm_prefix\": \"llvm.cuda.\",\n+    \"intrinsics\": [\n+        {\n+            \"intrinsic\": \"syncthreads\",\n+            \"width\": [\"0\"],\n+            \"llvm\": \"syncthreads\",\n+            \"ret\": \"V\",\n+            \"args\": []\n+        }\n+    ]\n+}"}, {"sha": "80332c54e04141dff0866ad6a104fd6225214418", "filename": "src/etc/platform-intrinsics/nvptx/info.json", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bcfd50474450cdf6b858d4f033f201264370a730/src%2Fetc%2Fplatform-intrinsics%2Fnvptx%2Finfo.json", "raw_url": "https://github.com/rust-lang/rust/raw/bcfd50474450cdf6b858d4f033f201264370a730/src%2Fetc%2Fplatform-intrinsics%2Fnvptx%2Finfo.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fplatform-intrinsics%2Fnvptx%2Finfo.json?ref=bcfd50474450cdf6b858d4f033f201264370a730", "patch": "@@ -0,0 +1,7 @@\n+{\n+  \"platform\": \"nvptx\",\n+  \"number_info\": {\n+    \"signed\": {}\n+  },\n+  \"width_info\": {}\n+}"}, {"sha": "33d97f2694699d0069d54266135347efe88acaf4", "filename": "src/etc/platform-intrinsics/nvptx/sreg.json", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/bcfd50474450cdf6b858d4f033f201264370a730/src%2Fetc%2Fplatform-intrinsics%2Fnvptx%2Fsreg.json", "raw_url": "https://github.com/rust-lang/rust/raw/bcfd50474450cdf6b858d4f033f201264370a730/src%2Fetc%2Fplatform-intrinsics%2Fnvptx%2Fsreg.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fplatform-intrinsics%2Fnvptx%2Fsreg.json?ref=bcfd50474450cdf6b858d4f033f201264370a730", "patch": "@@ -0,0 +1,90 @@\n+{\n+    \"intrinsic_prefix\": \"_\",\n+    \"llvm_prefix\": \"llvm.nvvm.read.ptx.sreg.\",\n+    \"intrinsics\": [\n+        {\n+            \"intrinsic\": \"block_dim_x\",\n+            \"width\": [\"0\"],\n+            \"llvm\": \"ntid.x\",\n+            \"ret\": \"S32\",\n+            \"args\": []\n+        },\n+        {\n+            \"intrinsic\": \"block_dim_y\",\n+            \"width\": [\"0\"],\n+            \"llvm\": \"ntid.y\",\n+            \"ret\": \"S32\",\n+            \"args\": []\n+        },\n+        {\n+            \"intrinsic\": \"block_dim_z\",\n+            \"width\": [\"0\"],\n+            \"llvm\": \"ntid.z\",\n+            \"ret\": \"S32\",\n+            \"args\": []\n+        },\n+        {\n+            \"intrinsic\": \"block_idx_x\",\n+            \"width\": [\"0\"],\n+            \"llvm\": \"ctaid.x\",\n+            \"ret\": \"S32\",\n+            \"args\": []\n+        },\n+        {\n+            \"intrinsic\": \"block_idx_y\",\n+            \"width\": [\"0\"],\n+            \"llvm\": \"ctaid.y\",\n+            \"ret\": \"S32\",\n+            \"args\": []\n+        },\n+        {\n+            \"intrinsic\": \"block_idx_z\",\n+            \"width\": [\"0\"],\n+            \"llvm\": \"ctaid.z\",\n+            \"ret\": \"S32\",\n+            \"args\": []\n+        },\n+        {\n+            \"intrinsic\": \"grid_dim_x\",\n+            \"width\": [\"0\"],\n+            \"llvm\": \"nctaid.x\",\n+            \"ret\": \"S32\",\n+            \"args\": []\n+        },\n+        {\n+            \"intrinsic\": \"grid_dim_y\",\n+            \"width\": [\"0\"],\n+            \"llvm\": \"nctaid.y\",\n+            \"ret\": \"S32\",\n+            \"args\": []\n+        },\n+        {\n+            \"intrinsic\": \"grid_dim_z\",\n+            \"width\": [\"0\"],\n+            \"llvm\": \"nctaid.z\",\n+            \"ret\": \"S32\",\n+            \"args\": []\n+        },\n+        {\n+            \"intrinsic\": \"thread_idx_x\",\n+            \"width\": [\"0\"],\n+            \"llvm\": \"tid.x\",\n+            \"ret\": \"S32\",\n+            \"args\": []\n+        },\n+        {\n+            \"intrinsic\": \"thread_idx_y\",\n+            \"width\": [\"0\"],\n+            \"llvm\": \"tid.y\",\n+            \"ret\": \"S32\",\n+            \"args\": []\n+        },\n+        {\n+            \"intrinsic\": \"thread_idx_z\",\n+            \"width\": [\"0\"],\n+            \"llvm\": \"tid.z\",\n+            \"ret\": \"S32\",\n+            \"args\": []\n+        }\n+    ]\n+}"}, {"sha": "2ee4cc49435611316e1a7e1d3b717dae609c8574", "filename": "src/librustc_llvm/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bcfd50474450cdf6b858d4f033f201264370a730/src%2Flibrustc_llvm%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcfd50474450cdf6b858d4f033f201264370a730/src%2Flibrustc_llvm%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fbuild.rs?ref=bcfd50474450cdf6b858d4f033f201264370a730", "patch": "@@ -96,7 +96,7 @@ fn main() {\n \n     let optional_components =\n         [\"x86\", \"arm\", \"aarch64\", \"mips\", \"powerpc\", \"pnacl\", \"systemz\", \"jsbackend\", \"msp430\",\n-         \"sparc\"];\n+         \"sparc\", \"nvptx\"];\n \n     // FIXME: surely we don't need all these components, right? Stuff like mcjit\n     //        or interpreter the compiler itself never uses."}, {"sha": "c1705815165939b505ed948ab23434f655a145bd", "filename": "src/librustc_llvm/ffi.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bcfd50474450cdf6b858d4f033f201264370a730/src%2Flibrustc_llvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcfd50474450cdf6b858d4f033f201264370a730/src%2Flibrustc_llvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fffi.rs?ref=bcfd50474450cdf6b858d4f033f201264370a730", "patch": "@@ -42,6 +42,7 @@ pub enum CallConv {\n     X86StdcallCallConv = 64,\n     X86FastcallCallConv = 65,\n     ArmAapcsCallConv = 67,\n+    PtxKernel = 71,\n     X86_64_SysV = 78,\n     X86_64_Win64 = 79,\n     X86_VectorCall = 80,"}, {"sha": "1e45ea083c9e011046d33475e8e0df4852d48161", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bcfd50474450cdf6b858d4f033f201264370a730/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcfd50474450cdf6b858d4f033f201264370a730/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=bcfd50474450cdf6b858d4f033f201264370a730", "patch": "@@ -376,6 +376,11 @@ pub fn initialize_available_targets() {\n                  LLVMInitializeSparcTargetMC,\n                  LLVMInitializeSparcAsmPrinter,\n                  LLVMInitializeSparcAsmParser);\n+    init_target!(llvm_component = \"nvptx\",\n+                 LLVMInitializeNVPTXTargetInfo,\n+                 LLVMInitializeNVPTXTarget,\n+                 LLVMInitializeNVPTXTargetMC,\n+                 LLVMInitializeNVPTXAsmPrinter);\n }\n \n pub fn last_error() -> Option<String> {"}, {"sha": "e814050e9609771a0d859249dcd95c173ed7c703", "filename": "src/librustc_platform_intrinsics/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bcfd50474450cdf6b858d4f033f201264370a730/src%2Flibrustc_platform_intrinsics%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcfd50474450cdf6b858d4f033f201264370a730/src%2Flibrustc_platform_intrinsics%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_platform_intrinsics%2Flib.rs?ref=bcfd50474450cdf6b858d4f033f201264370a730", "patch": "@@ -95,6 +95,7 @@ static VOID: Type = Type::Void;\n mod x86;\n mod arm;\n mod aarch64;\n+mod nvptx;\n \n impl Intrinsic {\n     pub fn find(name: &str) -> Option<Intrinsic> {\n@@ -104,6 +105,8 @@ impl Intrinsic {\n             arm::find(name)\n         } else if name.starts_with(\"aarch64_\") {\n             aarch64::find(name)\n+        } else if name.starts_with(\"nvptx_\") {\n+            nvptx::find(name)\n         } else {\n             None\n         }"}, {"sha": "82408723ebe6fafe8cf342b58514c1c62cec63b5", "filename": "src/librustc_platform_intrinsics/nvptx.rs", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/bcfd50474450cdf6b858d4f033f201264370a730/src%2Flibrustc_platform_intrinsics%2Fnvptx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcfd50474450cdf6b858d4f033f201264370a730/src%2Flibrustc_platform_intrinsics%2Fnvptx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_platform_intrinsics%2Fnvptx.rs?ref=bcfd50474450cdf6b858d4f033f201264370a730", "patch": "@@ -0,0 +1,92 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// DO NOT EDIT: autogenerated by etc/platform-intrinsics/generator.py\n+// ignore-tidy-linelength\n+\n+#![allow(unused_imports)]\n+\n+use {Intrinsic, Type};\n+use IntrinsicDef::Named;\n+\n+// The default inlining settings trigger a pathological behaviour in\n+// LLVM, which causes makes compilation very slow. See #28273.\n+#[inline(never)]\n+pub fn find(name: &str) -> Option<Intrinsic> {\n+    if !name.starts_with(\"nvptx\") { return None }\n+    Some(match &name[\"nvptx\".len()..] {\n+        \"_syncthreads\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 0] = []; &INPUTS },\n+            output: &::VOID,\n+            definition: Named(\"llvm.cuda.syncthreads\")\n+        },\n+        \"_block_dim_x\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 0] = []; &INPUTS },\n+            output: &::I32,\n+            definition: Named(\"llvm.nvvm.read.ptx.sreg.ntid.x\")\n+        },\n+        \"_block_dim_y\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 0] = []; &INPUTS },\n+            output: &::I32,\n+            definition: Named(\"llvm.nvvm.read.ptx.sreg.ntid.y\")\n+        },\n+        \"_block_dim_z\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 0] = []; &INPUTS },\n+            output: &::I32,\n+            definition: Named(\"llvm.nvvm.read.ptx.sreg.ntid.z\")\n+        },\n+        \"_block_idx_x\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 0] = []; &INPUTS },\n+            output: &::I32,\n+            definition: Named(\"llvm.nvvm.read.ptx.sreg.ctaid.x\")\n+        },\n+        \"_block_idx_y\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 0] = []; &INPUTS },\n+            output: &::I32,\n+            definition: Named(\"llvm.nvvm.read.ptx.sreg.ctaid.y\")\n+        },\n+        \"_block_idx_z\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 0] = []; &INPUTS },\n+            output: &::I32,\n+            definition: Named(\"llvm.nvvm.read.ptx.sreg.ctaid.z\")\n+        },\n+        \"_grid_dim_x\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 0] = []; &INPUTS },\n+            output: &::I32,\n+            definition: Named(\"llvm.nvvm.read.ptx.sreg.nctaid.x\")\n+        },\n+        \"_grid_dim_y\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 0] = []; &INPUTS },\n+            output: &::I32,\n+            definition: Named(\"llvm.nvvm.read.ptx.sreg.nctaid.y\")\n+        },\n+        \"_grid_dim_z\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 0] = []; &INPUTS },\n+            output: &::I32,\n+            definition: Named(\"llvm.nvvm.read.ptx.sreg.nctaid.z\")\n+        },\n+        \"_thread_idx_x\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 0] = []; &INPUTS },\n+            output: &::I32,\n+            definition: Named(\"llvm.nvvm.read.ptx.sreg.tid.x\")\n+        },\n+        \"_thread_idx_y\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 0] = []; &INPUTS },\n+            output: &::I32,\n+            definition: Named(\"llvm.nvvm.read.ptx.sreg.tid.y\")\n+        },\n+        \"_thread_idx_z\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 0] = []; &INPUTS },\n+            output: &::I32,\n+            definition: Named(\"llvm.nvvm.read.ptx.sreg.tid.z\")\n+        },\n+        _ => return None,\n+    })\n+}"}, {"sha": "81e4b4d1f21c76c84ed115ac748d519a007617ff", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bcfd50474450cdf6b858d4f033f201264370a730/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcfd50474450cdf6b858d4f033f201264370a730/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=bcfd50474450cdf6b858d4f033f201264370a730", "patch": "@@ -25,6 +25,8 @@ use cabi_mips64;\n use cabi_asmjs;\n use cabi_msp430;\n use cabi_sparc;\n+use cabi_nvptx;\n+use cabi_nvptx64;\n use machine::{llalign_of_min, llsize_of, llsize_of_alloc};\n use type_::Type;\n use type_of;\n@@ -353,6 +355,7 @@ impl FnType {\n             Win64 => llvm::X86_64_Win64,\n             SysV64 => llvm::X86_64_SysV,\n             Aapcs => llvm::ArmAapcsCallConv,\n+            PtxKernel => llvm::PtxKernel,\n \n             // These API constants ought to be more specific...\n             Cdecl => llvm::CCallConv,\n@@ -608,6 +611,8 @@ impl FnType {\n             \"wasm32\" => cabi_asmjs::compute_abi_info(ccx, self),\n             \"msp430\" => cabi_msp430::compute_abi_info(ccx, self),\n             \"sparc\" => cabi_sparc::compute_abi_info(ccx, self),\n+            \"nvptx\" => cabi_nvptx::compute_abi_info(ccx, self),\n+            \"nvptx64\" => cabi_nvptx64::compute_abi_info(ccx, self),\n             a => ccx.sess().fatal(&format!(\"unrecognized arch \\\"{}\\\" in target specification\", a))\n         }\n "}, {"sha": "5ece19f764a8ac2572f9161815e7f62a9040c22e", "filename": "src/librustc_trans/cabi_nvptx.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/bcfd50474450cdf6b858d4f033f201264370a730/src%2Flibrustc_trans%2Fcabi_nvptx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcfd50474450cdf6b858d4f033f201264370a730/src%2Flibrustc_trans%2Fcabi_nvptx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_nvptx.rs?ref=bcfd50474450cdf6b858d4f033f201264370a730", "patch": "@@ -0,0 +1,53 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Reference: PTX Writer's Guide to Interoperability\n+// http://docs.nvidia.com/cuda/ptx-writers-guide-to-interoperability\n+\n+#![allow(non_upper_case_globals)]\n+\n+use llvm::Struct;\n+\n+use abi::{self, ArgType, FnType};\n+use context::CrateContext;\n+use type_::Type;\n+\n+fn ty_size(ty: Type) -> usize {\n+    abi::ty_size(ty, 4)\n+}\n+\n+fn classify_ret_ty(ccx: &CrateContext, ret: &mut ArgType) {\n+    if ret.ty.kind() == Struct && ty_size(ret.ty) > 32 {\n+        ret.make_indirect(ccx);\n+    } else {\n+        ret.extend_integer_width_to(32);\n+    }\n+}\n+\n+fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType) {\n+    if arg.ty.kind() == Struct && ty_size(arg.ty) > 32 {\n+        arg.make_indirect(ccx);\n+    } else {\n+        arg.extend_integer_width_to(32);\n+    }\n+}\n+\n+pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n+    if !fty.ret.is_ignore() {\n+        classify_ret_ty(ccx, &mut fty.ret);\n+    }\n+\n+    for arg in &mut fty.args {\n+        if arg.is_ignore() {\n+            continue;\n+        }\n+        classify_arg_ty(ccx, arg);\n+    }\n+}"}, {"sha": "880c6cfd7a8ac24387c183f97ef9848bb577ec89", "filename": "src/librustc_trans/cabi_nvptx64.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/bcfd50474450cdf6b858d4f033f201264370a730/src%2Flibrustc_trans%2Fcabi_nvptx64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcfd50474450cdf6b858d4f033f201264370a730/src%2Flibrustc_trans%2Fcabi_nvptx64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_nvptx64.rs?ref=bcfd50474450cdf6b858d4f033f201264370a730", "patch": "@@ -0,0 +1,53 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Reference: PTX Writer's Guide to Interoperability\n+// http://docs.nvidia.com/cuda/ptx-writers-guide-to-interoperability\n+\n+#![allow(non_upper_case_globals)]\n+\n+use llvm::Struct;\n+\n+use abi::{self, ArgType, FnType};\n+use context::CrateContext;\n+use type_::Type;\n+\n+fn ty_size(ty: Type) -> usize {\n+    abi::ty_size(ty, 8)\n+}\n+\n+fn classify_ret_ty(ccx: &CrateContext, ret: &mut ArgType) {\n+    if ret.ty.kind() == Struct && ty_size(ret.ty) > 64 {\n+        ret.make_indirect(ccx);\n+    } else {\n+        ret.extend_integer_width_to(64);\n+    }\n+}\n+\n+fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType) {\n+    if arg.ty.kind() == Struct && ty_size(arg.ty) > 64 {\n+        arg.make_indirect(ccx);\n+    } else {\n+        arg.extend_integer_width_to(64);\n+    }\n+}\n+\n+pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n+    if !fty.ret.is_ignore() {\n+        classify_ret_ty(ccx, &mut fty.ret);\n+    }\n+\n+    for arg in &mut fty.args {\n+        if arg.is_ignore() {\n+            continue;\n+        }\n+        classify_arg_ty(ccx, arg);\n+    }\n+}"}, {"sha": "0d3e1853f011eb001cb0f8219e6cf1996b6c3b5a", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bcfd50474450cdf6b858d4f033f201264370a730/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcfd50474450cdf6b858d4f033f201264370a730/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=bcfd50474450cdf6b858d4f033f201264370a730", "patch": "@@ -103,6 +103,8 @@ mod cabi_asmjs;\n mod cabi_mips;\n mod cabi_mips64;\n mod cabi_msp430;\n+mod cabi_nvptx;\n+mod cabi_nvptx64;\n mod cabi_powerpc;\n mod cabi_powerpc64;\n mod cabi_s390x;"}, {"sha": "0cc62fb43a54d270cbf287167944c44782fd41f1", "filename": "src/libsyntax/abi.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bcfd50474450cdf6b858d4f033f201264370a730/src%2Flibsyntax%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcfd50474450cdf6b858d4f033f201264370a730/src%2Flibsyntax%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fabi.rs?ref=bcfd50474450cdf6b858d4f033f201264370a730", "patch": "@@ -41,6 +41,7 @@ pub enum Abi {\n     Aapcs,\n     Win64,\n     SysV64,\n+    PtxKernel,\n \n     // Multiplatform / generic ABIs\n     Rust,\n@@ -82,6 +83,7 @@ const AbiDatas: &'static [AbiData] = &[\n     AbiData {abi: Abi::Aapcs, name: \"aapcs\", generic: false },\n     AbiData {abi: Abi::Win64, name: \"win64\", generic: false },\n     AbiData {abi: Abi::SysV64, name: \"sysv64\", generic: false },\n+    AbiData {abi: Abi::PtxKernel, name: \"ptx-kernel\", generic: false },\n \n     // Cross-platform ABIs\n     AbiData {abi: Abi::Rust, name: \"Rust\", generic: true },"}, {"sha": "625af803458b5bd939782b4a4dafb698342b9e78", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/bcfd50474450cdf6b858d4f033f201264370a730/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcfd50474450cdf6b858d4f033f201264370a730/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=bcfd50474450cdf6b858d4f033f201264370a730", "patch": "@@ -318,6 +318,9 @@ declare_features! (\n \n     // Allow safe suggestions for potential type conversions.\n     (active, safe_suggestion, \"1.0.0\", Some(37384)),\n+\n+    // `extern \"ptx-*\" fn()`\n+    (active, abi_ptx, \"1.15.0\", None),\n );\n \n declare_features! (\n@@ -986,7 +989,19 @@ impl<'a> PostExpansionVisitor<'a> {\n                 gate_feature_post!(&self, abi_sysv64, span,\n                                    \"sysv64 ABI is experimental and subject to change\");\n             },\n-            _ => {}\n+            Abi::PtxKernel => {\n+                gate_feature_post!(&self, abi_ptx, span,\n+                                   \"PTX ABIs are experimental and subject to change\");\n+            }\n+            // Stable\n+            Abi::Cdecl |\n+            Abi::Stdcall |\n+            Abi::Fastcall |\n+            Abi::Aapcs |\n+            Abi::Win64 |\n+            Abi::Rust |\n+            Abi::C |\n+            Abi::System => {}\n         }\n     }\n }"}, {"sha": "70fe17888e84d6a74fef8daee7ec9c03eeb941d7", "filename": "src/test/ui/codemap_tests/unicode.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bcfd50474450cdf6b858d4f033f201264370a730/src%2Ftest%2Fui%2Fcodemap_tests%2Funicode.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bcfd50474450cdf6b858d4f033f201264370a730/src%2Ftest%2Fui%2Fcodemap_tests%2Funicode.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Funicode.stderr?ref=bcfd50474450cdf6b858d4f033f201264370a730", "patch": "@@ -1,4 +1,4 @@\n-error: invalid ABI: expected one of [cdecl, stdcall, fastcall, vectorcall, aapcs, win64, sysv64, Rust, C, system, rust-intrinsic, rust-call, platform-intrinsic], found `\u8def\u6feb\u72fc\u00e1\u0301\u0301`\n+error: invalid ABI: expected one of [cdecl, stdcall, fastcall, vectorcall, aapcs, win64, sysv64, ptx-kernel, Rust, C, system, rust-intrinsic, rust-call, platform-intrinsic], found `\u8def\u6feb\u72fc\u00e1\u0301\u0301`\n   --> $DIR/unicode.rs:11:8\n    |\n 11 | extern \"\u8def\u6feb\u72fc\u00e1\u0301\u0301\" fn foo() {}"}]}