{"sha": "f027bdc1c8a133693651f333624b756abe21960f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYwMjdiZGMxYzhhMTMzNjkzNjUxZjMzMzYyNGI3NTZhYmUyMTk2MGY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-07-03T21:31:46Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-07-03T21:31:46Z"}, "message": "Auto merge of #26378 - arielb1:unused-mut, r=pnkfelix\n\nThis makes it somewhat more aggressive, so this is kind-of a [breaking-change] for these compiling with `#[deny(unused_mut)]`.\r\n\r\nr? @pnkfelix", "tree": {"sha": "be2f5dba08045127e9852e45ffc9bfbb90ffb362", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/be2f5dba08045127e9852e45ffc9bfbb90ffb362"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f027bdc1c8a133693651f333624b756abe21960f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f027bdc1c8a133693651f333624b756abe21960f", "html_url": "https://github.com/rust-lang/rust/commit/f027bdc1c8a133693651f333624b756abe21960f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f027bdc1c8a133693651f333624b756abe21960f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7b148381c755b88b032de67aea4b8a0ee6ea7985", "url": "https://api.github.com/repos/rust-lang/rust/commits/7b148381c755b88b032de67aea4b8a0ee6ea7985", "html_url": "https://github.com/rust-lang/rust/commit/7b148381c755b88b032de67aea4b8a0ee6ea7985"}, {"sha": "a18d9842ed94ecca3e7161945bb2f749d98d18ee", "url": "https://api.github.com/repos/rust-lang/rust/commits/a18d9842ed94ecca3e7161945bb2f749d98d18ee", "html_url": "https://github.com/rust-lang/rust/commit/a18d9842ed94ecca3e7161945bb2f749d98d18ee"}], "stats": {"total": 427, "additions": 150, "deletions": 277}, "files": [{"sha": "4c8511eb1902c55f0e2fec2c09ad4934530f53ea", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f027bdc1c8a133693651f333624b756abe21960f/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f027bdc1c8a133693651f333624b756abe21960f/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=f027bdc1c8a133693651f333624b756abe21960f", "patch": "@@ -2655,8 +2655,8 @@ macro_rules! step_impl_signed {\n             #[allow(trivial_numeric_casts)]\n             fn steps_between(start: &$t, end: &$t, by: &$t) -> Option<usize> {\n                 if *by == 0 { return None; }\n-                let mut diff: usize;\n-                let mut by_u: usize;\n+                let diff: usize;\n+                let by_u: usize;\n                 if *by > 0 {\n                     if *start >= *end {\n                         return Some(0);"}, {"sha": "7ca89cfd0c9cc828cee98ef95f313011d8bb7750", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f027bdc1c8a133693651f333624b756abe21960f/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f027bdc1c8a133693651f333624b756abe21960f/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=f027bdc1c8a133693651f333624b756abe21960f", "patch": "@@ -399,7 +399,7 @@ impl<'a> Parser<'a> {\n             }\n             Some(..) | None => { return &self.input[..0]; }\n         };\n-        let mut end;\n+        let end;\n         loop {\n             match self.cur.clone().next() {\n                 Some((_, c)) if c.is_xid_continue() => {"}, {"sha": "6d5b47d8ed980bb40a0d3eef2c3ea8f53f1222fb", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f027bdc1c8a133693651f333624b756abe21960f/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f027bdc1c8a133693651f333624b756abe21960f/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=f027bdc1c8a133693651f333624b756abe21960f", "patch": "@@ -1854,7 +1854,7 @@ impl LifeGiver {\n     }\n \n     fn give_lifetime(&self) -> ast::Lifetime {\n-        let mut lifetime;\n+        let lifetime;\n         loop {\n             let mut s = String::from(\"'\");\n             s.push_str(&num_to_string(self.counter.get()));"}, {"sha": "1be2b605dbdcc5f45c0e0492e2d6f65a3294ad2d", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 19, "deletions": 193, "changes": 212, "blob_url": "https://github.com/rust-lang/rust/blob/f027bdc1c8a133693651f333624b756abe21960f/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f027bdc1c8a133693651f333624b756abe21960f/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=f027bdc1c8a133693651f333624b756abe21960f", "patch": "@@ -183,7 +183,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n             None => { }\n         }\n \n-        self.check_assignment(assignment_id, assignment_span, assignee_cmt, mode);\n+        self.check_assignment(assignment_id, assignment_span, assignee_cmt);\n     }\n \n     fn decl_without_init(&mut self, _id: ast::NodeId, _span: Span) { }\n@@ -567,13 +567,6 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n         true\n     }\n \n-    fn is_local_variable_or_arg(&self, cmt: mc::cmt<'tcx>) -> bool {\n-        match cmt.cat {\n-          mc::cat_local(_) => true,\n-          _ => false\n-        }\n-    }\n-\n     fn consume_common(&self,\n                       id: ast::NodeId,\n                       span: Span,\n@@ -791,202 +784,35 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n     fn check_assignment(&self,\n                         assignment_id: ast::NodeId,\n                         assignment_span: Span,\n-                        assignee_cmt: mc::cmt<'tcx>,\n-                        mode: euv::MutateMode) {\n+                        assignee_cmt: mc::cmt<'tcx>) {\n         debug!(\"check_assignment(assignee_cmt={:?})\", assignee_cmt);\n \n-        // Mutable values can be assigned, as long as they obey loans\n-        // and aliasing restrictions:\n-        if assignee_cmt.mutbl.is_mutable() {\n-            if check_for_aliasable_mutable_writes(self, assignment_span, assignee_cmt.clone()) {\n-                if mode != euv::Init {\n-                    check_for_assignment_to_borrowed_path(\n-                        self, assignment_id, assignment_span, assignee_cmt.clone());\n-                    mark_variable_as_used_mut(self, assignee_cmt);\n-                }\n-            }\n-\n-            return;\n-        }\n-\n-        // Initializations are OK if and only if they aren't partial\n-        // reinitialization of a partially-uninitialized structure.\n-        if mode == euv::Init {\n-            return\n-        }\n-\n-        // For immutable local variables, assignments are legal\n-        // if they cannot already have been assigned\n-        if self.is_local_variable_or_arg(assignee_cmt.clone()) {\n-            assert!(assignee_cmt.mutbl.is_immutable()); // no \"const\" locals\n-            let lp = opt_loan_path(&assignee_cmt).unwrap();\n-            self.move_data.each_assignment_of(assignment_id, &lp, |assign| {\n-                self.bccx.report_reassigned_immutable_variable(\n-                    assignment_span,\n-                    &*lp,\n-                    assign);\n+        // Check that we don't invalidate any outstanding loans\n+        if let Some(loan_path) = opt_loan_path(&assignee_cmt) {\n+            let scope = region::CodeExtent::from_node_id(assignment_id);\n+            self.each_in_scope_loan_affecting_path(scope, &*loan_path, |loan| {\n+                self.report_illegal_mutation(assignment_span, &*loan_path, loan);\n                 false\n             });\n-            return;\n         }\n \n-        // Otherwise, just a plain error.\n-        match assignee_cmt.note {\n-            mc::NoteClosureEnv(upvar_id) => {\n-                // If this is an `Fn` closure, it simply can't mutate upvars.\n-                // If it's an `FnMut` closure, the original variable was declared immutable.\n-                // We need to determine which is the case here.\n-                let kind = match assignee_cmt.upvar().unwrap().cat {\n-                    mc::cat_upvar(mc::Upvar { kind, .. }) => kind,\n-                    _ => unreachable!()\n-                };\n-                if kind == ty::FnClosureKind {\n-                    self.bccx.span_err(\n-                        assignment_span,\n-                        &format!(\"cannot assign to {}\",\n-                                self.bccx.cmt_to_string(&*assignee_cmt)));\n-                    self.bccx.span_help(\n-                        self.tcx().map.span(upvar_id.closure_expr_id),\n-                        \"consider changing this closure to take self by mutable reference\");\n+        // Check for reassignments to (immutable) local variables. This\n+        // needs to be done here instead of in check_loans because we\n+        // depend on move data.\n+        if let mc::cat_local(local_id) = assignee_cmt.cat {\n+            let lp = opt_loan_path(&assignee_cmt).unwrap();\n+            self.move_data.each_assignment_of(assignment_id, &lp, |assign| {\n+                if assignee_cmt.mutbl.is_mutable() {\n+                    self.tcx().used_mut_nodes.borrow_mut().insert(local_id);\n                 } else {\n-                    self.bccx.span_err(\n+                    self.bccx.report_reassigned_immutable_variable(\n                         assignment_span,\n-                        &format!(\"cannot assign to {} {}\",\n-                                assignee_cmt.mutbl.to_user_str(),\n-                                self.bccx.cmt_to_string(&*assignee_cmt)));\n-                }\n-            }\n-            _ => match opt_loan_path(&assignee_cmt) {\n-                Some(lp) => {\n-                    self.bccx.span_err(\n-                        assignment_span,\n-                        &format!(\"cannot assign to {} {} `{}`\",\n-                                assignee_cmt.mutbl.to_user_str(),\n-                                self.bccx.cmt_to_string(&*assignee_cmt),\n-                                self.bccx.loan_path_to_string(&*lp)));\n-                }\n-                None => {\n-                    self.bccx.span_err(\n-                        assignment_span,\n-                        &format!(\"cannot assign to {} {}\",\n-                                assignee_cmt.mutbl.to_user_str(),\n-                                self.bccx.cmt_to_string(&*assignee_cmt)));\n-                }\n-            }\n-        }\n-        return;\n-\n-        fn mark_variable_as_used_mut<'a, 'tcx>(this: &CheckLoanCtxt<'a, 'tcx>,\n-                                               mut cmt: mc::cmt<'tcx>) {\n-            //! If the mutability of the `cmt` being written is inherited\n-            //! from a local variable, liveness will\n-            //! not have been able to detect that this variable's mutability\n-            //! is important, so we must add the variable to the\n-            //! `used_mut_nodes` table here.\n-\n-            loop {\n-                debug!(\"mark_variable_as_used_mut(cmt={:?})\", cmt);\n-                match cmt.cat.clone() {\n-                    mc::cat_upvar(mc::Upvar { id: ty::UpvarId { var_id: id, .. }, .. }) |\n-                    mc::cat_local(id) => {\n-                        this.tcx().used_mut_nodes.borrow_mut().insert(id);\n-                        return;\n-                    }\n-\n-                    mc::cat_rvalue(..) |\n-                    mc::cat_static_item |\n-                    mc::cat_deref(_, _, mc::UnsafePtr(..)) |\n-                    mc::cat_deref(_, _, mc::Implicit(..)) => {\n-                        assert_eq!(cmt.mutbl, mc::McDeclared);\n-                        return;\n-                    }\n-\n-                    mc::cat_deref(_, _, mc::BorrowedPtr(..)) => {\n-                        assert_eq!(cmt.mutbl, mc::McDeclared);\n-                        // We need to drill down to upvar if applicable\n-                        match cmt.upvar() {\n-                            Some(b) => cmt = b,\n-                            None => return\n-                        }\n-                    }\n-\n-                    mc::cat_deref(b, _, mc::Unique) => {\n-                        assert_eq!(cmt.mutbl, mc::McInherited);\n-                        cmt = b;\n-                    }\n-\n-                    mc::cat_downcast(b, _) |\n-                    mc::cat_interior(b, _) => {\n-                        assert_eq!(cmt.mutbl, mc::McInherited);\n-                        cmt = b;\n-                    }\n-                }\n-            }\n-        }\n-\n-        fn check_for_aliasable_mutable_writes<'a, 'tcx>(this: &CheckLoanCtxt<'a, 'tcx>,\n-                                                        span: Span,\n-                                                        cmt: mc::cmt<'tcx>) -> bool {\n-            //! Safety checks related to writes to aliasable, mutable locations\n-\n-            let guarantor = cmt.guarantor();\n-            debug!(\"check_for_aliasable_mutable_writes(cmt={:?}, guarantor={:?})\",\n-                   cmt, guarantor);\n-            if let mc::cat_deref(ref b, _, mc::BorrowedPtr(ty::MutBorrow, _)) = guarantor.cat {\n-                // Statically prohibit writes to `&mut` when aliasable\n-                check_for_aliasability_violation(this, span, b.clone());\n-            }\n-\n-            return true; // no errors reported\n-        }\n-\n-        fn check_for_aliasability_violation<'a, 'tcx>(this: &CheckLoanCtxt<'a, 'tcx>,\n-                                                      span: Span,\n-                                                      cmt: mc::cmt<'tcx>)\n-                                                      -> bool {\n-            match cmt.freely_aliasable(this.tcx()) {\n-                mc::Aliasability::NonAliasable => {\n-                    return true;\n-                }\n-                mc::Aliasability::FreelyAliasable(mc::AliasableStaticMut(..)) => {\n-                    return true;\n-                }\n-                mc::Aliasability::ImmutableUnique(_) => {\n-                    this.bccx.report_aliasability_violation(\n-                        span,\n-                        MutabilityViolation,\n-                        mc::AliasableReason::UnaliasableImmutable);\n-                    return false;\n-                }\n-                mc::Aliasability::FreelyAliasable(cause) => {\n-                    this.bccx.report_aliasability_violation(\n-                        span,\n-                        MutabilityViolation,\n-                        cause);\n-                    return false;\n+                        &*lp,\n+                        assign);\n                 }\n-            }\n-        }\n-\n-        fn check_for_assignment_to_borrowed_path<'a, 'tcx>(\n-            this: &CheckLoanCtxt<'a, 'tcx>,\n-            assignment_id: ast::NodeId,\n-            assignment_span: Span,\n-            assignee_cmt: mc::cmt<'tcx>)\n-        {\n-            //! Check for assignments that violate the terms of an\n-            //! outstanding loan.\n-\n-            let loan_path = match opt_loan_path(&assignee_cmt) {\n-                Some(lp) => lp,\n-                None => { return; /* no loan path, can't be any loans */ }\n-            };\n-\n-            let scope = region::CodeExtent::from_node_id(assignment_id);\n-            this.each_in_scope_loan_affecting_path(scope, &*loan_path, |loan| {\n-                this.report_illegal_mutation(assignment_span, &*loan_path, loan);\n                 false\n             });\n+            return\n         }\n     }\n "}, {"sha": "919bc45f00ddfe955e4ae188574ef83af8cb3a54", "filename": "src/librustc_borrowck/borrowck/gather_loans/lifetime.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f027bdc1c8a133693651f333624b756abe21960f/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f027bdc1c8a133693651f333624b756abe21960f/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs?ref=f027bdc1c8a133693651f333624b756abe21960f", "patch": "@@ -137,7 +137,7 @@ impl<'a, 'tcx> GuaranteeLifetimeContext<'a, 'tcx> {\n     fn report_error(&self, code: bckerr_code) {\n         self.bccx.report(BckError { cmt: self.cmt_original.clone(),\n                                     span: self.span,\n-                                    cause: self.cause,\n+                                    cause: BorrowViolation(self.cause),\n                                     code: code });\n     }\n }"}, {"sha": "6899892a245ed5d5d4512705e36cc2f0428839d3", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 96, "deletions": 59, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/f027bdc1c8a133693651f333624b756abe21960f/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f027bdc1c8a133693651f333624b756abe21960f/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=f027bdc1c8a133693651f333624b756abe21960f", "patch": "@@ -152,22 +152,10 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n               assignee_cmt: mc::cmt<'tcx>,\n               mode: euv::MutateMode)\n     {\n-        let opt_lp = opt_loan_path(&assignee_cmt);\n-        debug!(\"mutate(assignment_id={}, assignee_cmt={:?}) opt_lp={:?}\",\n-               assignment_id, assignee_cmt, opt_lp);\n-\n-        match opt_lp {\n-            Some(lp) => {\n-                gather_moves::gather_assignment(self.bccx, &self.move_data,\n-                                                assignment_id, assignment_span,\n-                                                lp, assignee_cmt.id, mode);\n-            }\n-            None => {\n-                // This can occur with e.g. `*foo() = 5`.  In such\n-                // cases, there is no need to check for conflicts\n-                // with moves etc, just ignore.\n-            }\n-        }\n+        self.guarantee_assignment_valid(assignment_id,\n+                                        assignment_span,\n+                                        assignee_cmt,\n+                                        mode);\n     }\n \n     fn decl_without_init(&mut self, id: ast::NodeId, span: Span) {\n@@ -178,7 +166,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n /// Implements the A-* rules in README.md.\n fn check_aliasability<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                 borrow_span: Span,\n-                                loan_cause: euv::LoanCause,\n+                                loan_cause: AliasableViolationKind,\n                                 cmt: mc::cmt<'tcx>,\n                                 req_kind: ty::BorrowKind)\n                                 -> Result<(),()> {\n@@ -204,15 +192,15 @@ fn check_aliasability<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n         (mc::Aliasability::ImmutableUnique(_), ty::MutBorrow) => {\n             bccx.report_aliasability_violation(\n                         borrow_span,\n-                        BorrowViolation(loan_cause),\n+                        loan_cause,\n                         mc::AliasableReason::UnaliasableImmutable);\n             Err(())\n         }\n         (mc::Aliasability::FreelyAliasable(alias_cause), ty::UniqueImmBorrow) |\n         (mc::Aliasability::FreelyAliasable(alias_cause), ty::MutBorrow) => {\n             bccx.report_aliasability_violation(\n                         borrow_span,\n-                        BorrowViolation(loan_cause),\n+                        loan_cause,\n                         alias_cause);\n             Err(())\n         }\n@@ -222,9 +210,94 @@ fn check_aliasability<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n     }\n }\n \n+/// Implements the M-* rules in README.md.\n+fn check_mutability<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n+                              borrow_span: Span,\n+                              cause: AliasableViolationKind,\n+                              cmt: mc::cmt<'tcx>,\n+                              req_kind: ty::BorrowKind)\n+                              -> Result<(),()> {\n+    debug!(\"check_mutability(cause={:?} cmt={:?} req_kind={:?}\",\n+           cause, cmt, req_kind);\n+    match req_kind {\n+        ty::UniqueImmBorrow | ty::ImmBorrow => {\n+            match cmt.mutbl {\n+                // I am intentionally leaving this here to help\n+                // refactoring if, in the future, we should add new\n+                // kinds of mutability.\n+                mc::McImmutable | mc::McDeclared | mc::McInherited => {\n+                    // both imm and mut data can be lent as imm;\n+                    // for mutable data, this is a freeze\n+                    Ok(())\n+                }\n+            }\n+        }\n+\n+        ty::MutBorrow => {\n+            // Only mutable data can be lent as mutable.\n+            if !cmt.mutbl.is_mutable() {\n+                Err(bccx.report(BckError { span: borrow_span,\n+                                           cause: cause,\n+                                           cmt: cmt,\n+                                           code: err_mutbl }))\n+            } else {\n+                Ok(())\n+            }\n+        }\n+    }\n+}\n+\n impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n     pub fn tcx(&self) -> &'a ty::ctxt<'tcx> { self.bccx.tcx }\n \n+    /// Guarantees that `cmt` is assignable, or reports an error.\n+    fn guarantee_assignment_valid(&mut self,\n+                                  assignment_id: ast::NodeId,\n+                                  assignment_span: Span,\n+                                  cmt: mc::cmt<'tcx>,\n+                                  mode: euv::MutateMode) {\n+\n+        let opt_lp = opt_loan_path(&cmt);\n+        debug!(\"guarantee_assignment_valid(assignment_id={}, cmt={:?}) opt_lp={:?}\",\n+               assignment_id, cmt, opt_lp);\n+\n+        if let mc::cat_local(..) = cmt.cat {\n+            // Only re-assignments to locals require it to be\n+            // mutable - this is checked in check_loans.\n+        } else {\n+            // Check that we don't allow assignments to non-mutable data.\n+            if check_mutability(self.bccx, assignment_span, MutabilityViolation,\n+                                cmt.clone(), ty::MutBorrow).is_err() {\n+                return; // reported an error, no sense in reporting more.\n+            }\n+        }\n+\n+        // Check that we don't allow assignments to aliasable data\n+        if check_aliasability(self.bccx, assignment_span, MutabilityViolation,\n+                              cmt.clone(), ty::MutBorrow).is_err() {\n+            return; // reported an error, no sense in reporting more.\n+        }\n+\n+        match opt_lp {\n+            Some(lp) => {\n+                if let mc::cat_local(..) = cmt.cat {\n+                    // Only re-assignments to locals require it to be\n+                    // mutable - this is checked in check_loans.\n+                } else {\n+                    self.mark_loan_path_as_mutated(&lp);\n+                }\n+                gather_moves::gather_assignment(self.bccx, &self.move_data,\n+                                                assignment_id, assignment_span,\n+                                                lp, cmt.id, mode);\n+            }\n+            None => {\n+                // This can occur with e.g. `*foo() = 5`.  In such\n+                // cases, there is no need to check for conflicts\n+                // with moves etc, just ignore.\n+            }\n+        }\n+    }\n+\n     /// Guarantees that `addr_of(cmt)` will be valid for the duration of `static_scope_r`, or\n     /// reports an error.  This may entail taking out loans, which will be added to the\n     /// `req_loan_map`.\n@@ -257,13 +330,13 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n         }\n \n         // Check that we don't allow mutable borrows of non-mutable data.\n-        if check_mutability(self.bccx, borrow_span, cause,\n+        if check_mutability(self.bccx, borrow_span, BorrowViolation(cause),\n                             cmt.clone(), req_kind).is_err() {\n             return; // reported an error, no sense in reporting more.\n         }\n \n         // Check that we don't allow mutable borrows of aliasable data.\n-        if check_aliasability(self.bccx, borrow_span, cause,\n+        if check_aliasability(self.bccx, borrow_span, BorrowViolation(cause),\n                               cmt.clone(), req_kind).is_err() {\n             return; // reported an error, no sense in reporting more.\n         }\n@@ -369,43 +442,6 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n             //        restrictions: restrictions\n             //    }\n         // }\n-\n-        fn check_mutability<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n-                                      borrow_span: Span,\n-                                      cause: euv::LoanCause,\n-                                      cmt: mc::cmt<'tcx>,\n-                                      req_kind: ty::BorrowKind)\n-                                      -> Result<(),()> {\n-            //! Implements the M-* rules in README.md.\n-            debug!(\"check_mutability(cause={:?} cmt={:?} req_kind={:?}\",\n-                   cause, cmt, req_kind);\n-            match req_kind {\n-                ty::UniqueImmBorrow | ty::ImmBorrow => {\n-                    match cmt.mutbl {\n-                        // I am intentionally leaving this here to help\n-                        // refactoring if, in the future, we should add new\n-                        // kinds of mutability.\n-                        mc::McImmutable | mc::McDeclared | mc::McInherited => {\n-                            // both imm and mut data can be lent as imm;\n-                            // for mutable data, this is a freeze\n-                            Ok(())\n-                        }\n-                    }\n-                }\n-\n-                ty::MutBorrow => {\n-                    // Only mutable data can be lent as mutable.\n-                    if !cmt.mutbl.is_mutable() {\n-                        Err(bccx.report(BckError { span: borrow_span,\n-                                                   cause: cause,\n-                                                   cmt: cmt,\n-                                                   code: err_mutbl }))\n-                    } else {\n-                        Ok(())\n-                    }\n-                }\n-            }\n-        }\n     }\n \n     pub fn mark_loan_path_as_mutated(&self, loan_path: &LoanPath) {\n@@ -496,7 +532,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for StaticInitializerCtxt<'a, 'tcx> {\n             let base_cmt = mc.cat_expr(&**base).unwrap();\n             let borrow_kind = ty::BorrowKind::from_mutbl(mutbl);\n             // Check that we don't allow borrows of unsafe static items.\n-            if check_aliasability(self.bccx, ex.span, euv::AddrOf,\n+            if check_aliasability(self.bccx, ex.span,\n+                                  BorrowViolation(euv::AddrOf),\n                                   base_cmt, borrow_kind).is_err() {\n                 return; // reported an error, no sense in reporting more.\n             }"}, {"sha": "4c186dd840610a071816952be41a50c671314d4f", "filename": "src/librustc_borrowck/borrowck/gather_loans/restrictions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f027bdc1c8a133693651f333624b756abe21960f/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f027bdc1c8a133693651f333624b756abe21960f/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs?ref=f027bdc1c8a133693651f333624b756abe21960f", "patch": "@@ -124,7 +124,7 @@ impl<'a, 'tcx> RestrictionsContext<'a, 'tcx> {\n                             self.bccx.report(\n                                 BckError {\n                                     span: self.span,\n-                                    cause: self.cause,\n+                                    cause: BorrowViolation(self.cause),\n                                     cmt: cmt_base,\n                                     code: err_borrowed_pointer_too_short(\n                                         self.loan_region, lt)});"}, {"sha": "0d475e125714188e1780766d97a97d39c5289f8a", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/f027bdc1c8a133693651f333624b756abe21960f/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f027bdc1c8a133693651f333624b756abe21960f/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=f027bdc1c8a133693651f333624b756abe21960f", "patch": "@@ -545,12 +545,12 @@ pub enum bckerr_code {\n #[derive(PartialEq)]\n pub struct BckError<'tcx> {\n     span: Span,\n-    cause: euv::LoanCause,\n+    cause: AliasableViolationKind,\n     cmt: mc::cmt<'tcx>,\n     code: bckerr_code\n }\n \n-#[derive(Copy, Clone)]\n+#[derive(Copy, Clone, Debug, PartialEq)]\n pub enum AliasableViolationKind {\n     MutabilityViolation,\n     BorrowViolation(euv::LoanCause)\n@@ -575,8 +575,10 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n     pub fn report(&self, err: BckError<'tcx>) {\n         // Catch and handle some particular cases.\n         match (&err.code, &err.cause) {\n-            (&err_out_of_scope(ty::ReScope(_), ty::ReStatic), &euv::ClosureCapture(span)) |\n-            (&err_out_of_scope(ty::ReScope(_), ty::ReFree(..)), &euv::ClosureCapture(span)) => {\n+            (&err_out_of_scope(ty::ReScope(_), ty::ReStatic),\n+             &BorrowViolation(euv::ClosureCapture(span))) |\n+            (&err_out_of_scope(ty::ReScope(_), ty::ReFree(..)),\n+             &BorrowViolation(euv::ClosureCapture(span))) => {\n                 return self.report_out_of_scope_escaping_closure_capture(&err, span);\n             }\n             _ => { }\n@@ -795,10 +797,6 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n         self.tcx.sess.span_end_note(s, m);\n     }\n \n-    pub fn span_help(&self, s: Span, m: &str) {\n-        self.tcx.sess.span_help(s, m);\n-    }\n-\n     pub fn fileline_help(&self, s: Span, m: &str) {\n         self.tcx.sess.fileline_help(s, m);\n     }\n@@ -826,19 +824,22 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 };\n \n                 match err.cause {\n-                    euv::ClosureCapture(_) => {\n+                    MutabilityViolation => {\n+                        format!(\"cannot assign to {}\", descr)\n+                    }\n+                    BorrowViolation(euv::ClosureCapture(_)) => {\n                         format!(\"closure cannot assign to {}\", descr)\n                     }\n-                    euv::OverloadedOperator |\n-                    euv::AddrOf |\n-                    euv::RefBinding |\n-                    euv::AutoRef |\n-                    euv::AutoUnsafe |\n-                    euv::ForLoop |\n-                    euv::MatchDiscriminant => {\n+                    BorrowViolation(euv::OverloadedOperator) |\n+                    BorrowViolation(euv::AddrOf) |\n+                    BorrowViolation(euv::RefBinding) |\n+                    BorrowViolation(euv::AutoRef) |\n+                    BorrowViolation(euv::AutoUnsafe) |\n+                    BorrowViolation(euv::ForLoop) |\n+                    BorrowViolation(euv::MatchDiscriminant) => {\n                         format!(\"cannot borrow {} as mutable\", descr)\n                     }\n-                    euv::ClosureInvocation => {\n+                    BorrowViolation(euv::ClosureInvocation) => {\n                         self.tcx.sess.span_bug(err.span,\n                             \"err_mutbl with a closure invocation\");\n                     }"}, {"sha": "4e3b99276a9c76646e04fdf294287c71249fa7a3", "filename": "src/librustc_trans/save/dump_csv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f027bdc1c8a133693651f333624b756abe21960f/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f027bdc1c8a133693651f333624b756abe21960f/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs?ref=f027bdc1c8a133693651f333624b756abe21960f", "patch": "@@ -308,7 +308,7 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n \n         debug!(\"process_method: {}:{}\", id, token::get_name(name));\n \n-        let mut scope_id;\n+        let scope_id;\n         // The qualname for a method is the trait name or name of the struct in an impl in\n         // which the method is declared in, followed by the method's name.\n         let qualname = match self.tcx.impl_of_method(ast_util::local_def(id)) {"}, {"sha": "507bd9de2a11a769488fd3ade4775b15a4bfd7db", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f027bdc1c8a133693651f333624b756abe21960f/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f027bdc1c8a133693651f333624b756abe21960f/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=f027bdc1c8a133693651f333624b756abe21960f", "patch": "@@ -598,7 +598,7 @@ impl<'a> StringReader<'a> {\n \n     /// Lex a LIT_INTEGER or a LIT_FLOAT\n     fn scan_number(&mut self, c: char) -> token::Lit {\n-        let mut num_digits;\n+        let num_digits;\n         let mut base = 10;\n         let start_bpos = self.last_pos;\n "}, {"sha": "8165dd0fa29c0ee7049522f2f46969a46d78bf57", "filename": "src/test/compile-fail/lint-unused-mut-variables.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f027bdc1c8a133693651f333624b756abe21960f/src%2Ftest%2Fcompile-fail%2Flint-unused-mut-variables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f027bdc1c8a133693651f333624b756abe21960f/src%2Ftest%2Fcompile-fail%2Flint-unused-mut-variables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-unused-mut-variables.rs?ref=f027bdc1c8a133693651f333624b756abe21960f", "patch": "@@ -23,6 +23,15 @@ fn main() {\n     let mut b = 3; //~ ERROR: variable does not need to be mutable\n     let mut a = vec!(3); //~ ERROR: variable does not need to be mutable\n     let (mut a, b) = (1, 2); //~ ERROR: variable does not need to be mutable\n+    let mut a; //~ ERROR: variable does not need to be mutable\n+    a = 3;\n+\n+    let mut b; //~ ERROR: variable does not need to be mutable\n+    if true {\n+        b = 3;\n+    } else {\n+        b = 4;\n+    }\n \n     match 30 {\n         mut x => {} //~ ERROR: variable does not need to be mutable"}]}