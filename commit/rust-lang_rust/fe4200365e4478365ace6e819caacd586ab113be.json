{"sha": "fe4200365e4478365ace6e819caacd586ab113be", "node_id": "C_kwDOAAsO6NoAKGZlNDIwMDM2NWU0NDc4MzY1YWNlNmU4MTljYWFjZDU4NmFiMTEzYmU", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-10-07T16:35:31Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-10-07T16:35:31Z"}, "message": "Rollup merge of #102760 - saethlin:dont-reinit-buffer, r=Mark-Simulacrum\n\nAvoid repeated re-initialization of the BufReader buffer\n\nFixes https://github.com/rust-lang/rust/issues/102727\n\nWe accidentally removed this in https://github.com/rust-lang/rust/pull/98748. It looks so redundant. But it isn't.\n\nThe default `Read::read_buf` will defensively initialize the whole buffer, if any of it is indicated to be uninitialized. In uses where reads from the wrapped `Read` impl completely fill the `BufReader`, `initialized` and `filled` are the same, and this extra member isn't required. But in the reported issue, the `BufReader` wraps a `Read` impl which will _never_ fill the whole buffer. So the default `Read::read_buf` implementation repeatedly re-initializes the extra space in the buffer.\n\nThis adds back the extra `initialized` member, which ensures that the default `Read::read_buf` only zero-initialized the buffer once, and I've tried to add a comment which explains this whole situation.", "tree": {"sha": "a97dde214c606788d4e98f4767100cb039b8dec6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a97dde214c606788d4e98f4767100cb039b8dec6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fe4200365e4478365ace6e819caacd586ab113be", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjQFVTCRBK7hj4Ov3rIwAAV/QIAGKK00EHV/aieBpRToJQjLz4\nHlSYcyuYVbAWGxOJL2e96tlOZZVviHNaJExrP8/pdzoiGiBFX8YMne3qn2uOkt2U\nriT9wYzRLj8GZ1hV5xFJqdrww/mGpQwh6jAVl62N7A+86UfA29KZT7Wn+89clabK\nRfGI+9NTgHn9T0KmOfEKMMSqWjwCx/dpDc+B8mb0QkVDy+FIHjaOdk6UoXYGmWUZ\nrE4EXKgw3YUp9Tv2G7JGCIBF+i8EWVJvYkBvhqB3HmPdkletW51XhwSs7uj0fSIf\n+R2nnrXBaem5Z900bz0eRGGkIWjm4FaL/vXM2F73UsE+fdcTHRCEF0cLc+TLzvU=\n=bgFI\n-----END PGP SIGNATURE-----\n", "payload": "tree a97dde214c606788d4e98f4767100cb039b8dec6\nparent e461e94165e56be0b40d3916a0eb24745ea6e75c\nparent 95ae993bd86b97aff9a27498f2187fef431cab58\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1665160531 +0530\ncommitter GitHub <noreply@github.com> 1665160531 +0530\n\nRollup merge of #102760 - saethlin:dont-reinit-buffer, r=Mark-Simulacrum\n\nAvoid repeated re-initialization of the BufReader buffer\n\nFixes https://github.com/rust-lang/rust/issues/102727\n\nWe accidentally removed this in https://github.com/rust-lang/rust/pull/98748. It looks so redundant. But it isn't.\n\nThe default `Read::read_buf` will defensively initialize the whole buffer, if any of it is indicated to be uninitialized. In uses where reads from the wrapped `Read` impl completely fill the `BufReader`, `initialized` and `filled` are the same, and this extra member isn't required. But in the reported issue, the `BufReader` wraps a `Read` impl which will _never_ fill the whole buffer. So the default `Read::read_buf` implementation repeatedly re-initializes the extra space in the buffer.\n\nThis adds back the extra `initialized` member, which ensures that the default `Read::read_buf` only zero-initialized the buffer once, and I've tried to add a comment which explains this whole situation.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fe4200365e4478365ace6e819caacd586ab113be", "html_url": "https://github.com/rust-lang/rust/commit/fe4200365e4478365ace6e819caacd586ab113be", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fe4200365e4478365ace6e819caacd586ab113be/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e461e94165e56be0b40d3916a0eb24745ea6e75c", "url": "https://api.github.com/repos/rust-lang/rust/commits/e461e94165e56be0b40d3916a0eb24745ea6e75c", "html_url": "https://github.com/rust-lang/rust/commit/e461e94165e56be0b40d3916a0eb24745ea6e75c"}, {"sha": "95ae993bd86b97aff9a27498f2187fef431cab58", "url": "https://api.github.com/repos/rust-lang/rust/commits/95ae993bd86b97aff9a27498f2187fef431cab58", "html_url": "https://github.com/rust-lang/rust/commit/95ae993bd86b97aff9a27498f2187fef431cab58"}], "stats": {"total": 51, "additions": 48, "deletions": 3}, "files": [{"sha": "4f339a18a480ec8ef42187b347b9dc0ce2bfbd1e", "filename": "library/std/src/io/buffered/bufreader.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fe4200365e4478365ace6e819caacd586ab113be/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe4200365e4478365ace6e819caacd586ab113be/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufreader.rs?ref=fe4200365e4478365ace6e819caacd586ab113be", "patch": "@@ -224,6 +224,14 @@ impl<R> BufReader<R> {\n     }\n }\n \n+// This is only used by a test which asserts that the initialization-tracking is correct.\n+#[cfg(test)]\n+impl<R> BufReader<R> {\n+    pub fn initialized(&self) -> usize {\n+        self.buf.initialized()\n+    }\n+}\n+\n impl<R: Seek> BufReader<R> {\n     /// Seeks relative to the current position. If the new position lies within the buffer,\n     /// the buffer will not be flushed, allowing for more efficient seeks."}, {"sha": "e9e29d60ca2826a915937688e8fe02488b861a4e", "filename": "library/std/src/io/buffered/bufreader/buffer.rs", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/fe4200365e4478365ace6e819caacd586ab113be/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufreader%2Fbuffer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe4200365e4478365ace6e819caacd586ab113be/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufreader%2Fbuffer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufreader%2Fbuffer.rs?ref=fe4200365e4478365ace6e819caacd586ab113be", "patch": "@@ -20,13 +20,19 @@ pub struct Buffer {\n     // Each call to `fill_buf` sets `filled` to indicate how many bytes at the start of `buf` are\n     // initialized with bytes from a read.\n     filled: usize,\n+    // This is the max number of bytes returned across all `fill_buf` calls. We track this so that we\n+    // can accurately tell `read_buf` how many bytes of buf are initialized, to bypass as much of its\n+    // defensive initialization as possible. Note that while this often the same as `filled`, it\n+    // doesn't need to be. Calls to `fill_buf` are not required to actually fill the buffer, and\n+    // omitting this is a huge perf regression for `Read` impls that do not.\n+    initialized: usize,\n }\n \n impl Buffer {\n     #[inline]\n     pub fn with_capacity(capacity: usize) -> Self {\n         let buf = Box::new_uninit_slice(capacity);\n-        Self { buf, pos: 0, filled: 0 }\n+        Self { buf, pos: 0, filled: 0, initialized: 0 }\n     }\n \n     #[inline]\n@@ -51,6 +57,12 @@ impl Buffer {\n         self.pos\n     }\n \n+    // This is only used by a test which asserts that the initialization-tracking is correct.\n+    #[cfg(test)]\n+    pub fn initialized(&self) -> usize {\n+        self.initialized\n+    }\n+\n     #[inline]\n     pub fn discard_buffer(&mut self) {\n         self.pos = 0;\n@@ -96,13 +108,14 @@ impl Buffer {\n             let mut buf = BorrowedBuf::from(&mut *self.buf);\n             // SAFETY: `self.filled` bytes will always have been initialized.\n             unsafe {\n-                buf.set_init(self.filled);\n+                buf.set_init(self.initialized);\n             }\n \n             reader.read_buf(buf.unfilled())?;\n \n-            self.filled = buf.len();\n             self.pos = 0;\n+            self.filled = buf.len();\n+            self.initialized = buf.init_len();\n         }\n         Ok(self.buffer())\n     }"}, {"sha": "f4e688eb926cc7bff8962f1f79ecca455d7c27bc", "filename": "library/std/src/io/buffered/tests.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fe4200365e4478365ace6e819caacd586ab113be/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe4200365e4478365ace6e819caacd586ab113be/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Ftests.rs?ref=fe4200365e4478365ace6e819caacd586ab113be", "patch": "@@ -1039,3 +1039,27 @@ fn single_formatted_write() {\n     writeln!(&mut writer, \"{}, {}!\", \"hello\", \"world\").unwrap();\n     assert_eq!(writer.get_ref().events, [RecordedEvent::Write(\"hello, world!\\n\".to_string())]);\n }\n+\n+#[test]\n+fn bufreader_full_initialize() {\n+    struct OneByteReader;\n+    impl Read for OneByteReader {\n+        fn read(&mut self, buf: &mut [u8]) -> crate::io::Result<usize> {\n+            if buf.len() > 0 {\n+                buf[0] = 0;\n+                Ok(1)\n+            } else {\n+                Ok(0)\n+            }\n+        }\n+    }\n+    let mut reader = BufReader::new(OneByteReader);\n+    // Nothing is initialized yet.\n+    assert_eq!(reader.initialized(), 0);\n+\n+    let buf = reader.fill_buf().unwrap();\n+    // We read one byte...\n+    assert_eq!(buf.len(), 1);\n+    // But we initialized the whole buffer!\n+    assert_eq!(reader.initialized(), reader.capacity());\n+}"}]}