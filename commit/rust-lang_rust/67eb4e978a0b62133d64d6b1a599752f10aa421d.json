{"sha": "67eb4e978a0b62133d64d6b1a599752f10aa421d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY3ZWI0ZTk3OGEwYjYyMTMzZDY0ZDZiMWE1OTk3NTJmMTBhYTQyMWQ=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-06-10T00:26:02Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-06-10T02:51:29Z"}, "message": "Merge remote-tracking branch 'z0w0/cargo-deps'\n\nConflicts:\n\tsrc/cargo/cargo.rs", "tree": {"sha": "2d6172fbe1dec4cacb45d617f45cac167ff3a09e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2d6172fbe1dec4cacb45d617f45cac167ff3a09e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/67eb4e978a0b62133d64d6b1a599752f10aa421d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/67eb4e978a0b62133d64d6b1a599752f10aa421d", "html_url": "https://github.com/rust-lang/rust/commit/67eb4e978a0b62133d64d6b1a599752f10aa421d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/67eb4e978a0b62133d64d6b1a599752f10aa421d/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "67885ac089869fbfabfb7f10a994c2549d891807", "url": "https://api.github.com/repos/rust-lang/rust/commits/67885ac089869fbfabfb7f10a994c2549d891807", "html_url": "https://github.com/rust-lang/rust/commit/67885ac089869fbfabfb7f10a994c2549d891807"}], "stats": {"total": 1253, "additions": 1004, "deletions": 249}, "files": [{"sha": "83ede212233f78d3e52de31805cdcb8a8bdc2e2d", "filename": "src/cargo/cargo.rs", "status": "modified", "additions": 1004, "deletions": 249, "changes": 1253, "blob_url": "https://github.com/rust-lang/rust/blob/67eb4e978a0b62133d64d6b1a599752f10aa421d/src%2Fcargo%2Fcargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67eb4e978a0b62133d64d6b1a599752f10aa421d/src%2Fcargo%2Fcargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcargo%2Fcargo.rs?ref=67eb4e978a0b62133d64d6b1a599752f10aa421d", "patch": "@@ -1,7 +1,8 @@\n // cargo.rs - Rust package manager\n \n-import syntax::{ast, codemap};\n-import syntax::parse;\n+import syntax::{ast, codemap, parse, visit, attr};\n+import syntax::diagnostic::span_handler;\n+import codemap::span;\n import rustc::metadata::filesearch::{get_cargo_root, get_cargo_root_nearest,\n                                      get_cargo_sysroot, libdir};\n import syntax::diagnostic;\n@@ -16,21 +17,29 @@ import vec;\n import getopts::{optflag, optopt, opt_present};\n \n type package = {\n-    name: str,\n-    uuid: str,\n-    url: str,\n-    method: str,\n-    description: str,\n-    ref: option<str>,\n-    tags: [str]\n+    mut name: str,\n+    mut uuid: str,\n+    mut url: str,\n+    mut method: str,\n+    mut description: str,\n+    mut ref: option<str>,\n+    mut tags: [str],\n+    mut versions: [(str, str)]\n+};\n+\n+type local_package = {\n+    mut name: str,\n+    mut metaname: str,\n+    mut version: str,\n+    mut files: [str]\n };\n \n type source = {\n-    name: str,\n-    url: str,\n-    sig: option<str>,\n-    key: option<str>,\n-    keyfp: option<str>,\n+    mut name: str,\n+    mut url: str,\n+    mut method: str,\n+    mut key: option<str>,\n+    mut keyfp: option<str>,\n     mut packages: [package]\n };\n \n@@ -43,16 +52,19 @@ type cargo = {\n     workdir: str,\n     sourcedir: str,\n     sources: map::hashmap<str, source>,\n+    mut current_install: str,\n+    dep_cache: map::hashmap<str, bool>,\n     opts: options\n };\n \n-type pkg = {\n-    name: str,\n-    vers: str,\n-    uuid: str,\n-    desc: option<str>,\n-    sigs: option<str>,\n-    crate_type: option<str>\n+type crate = {\n+    mut name: str,\n+    mut vers: str,\n+    mut uuid: str,\n+    mut desc: option<str>,\n+    mut sigs: option<str>,\n+    mut crate_type: option<str>,\n+    mut deps: [str]\n };\n \n type options = {\n@@ -108,17 +120,16 @@ fn is_uuid(id: str) -> bool {\n     if vec::len(parts) == 5u {\n         let mut correct = 0u;\n         for vec::eachi(parts) { |i, part|\n+            fn is_hex_digit(ch: char) -> bool {\n+                ('0' <= ch && ch <= '9') ||\n+                ('a' <= ch && ch <= 'f') ||\n+                ('A' <= ch && ch <= 'F')\n+            }\n \n             if !part.all(is_hex_digit) {\n                 ret false;\n             }\n \n-            fn is_hex_digit(ch: char) -> bool {\n-                ('0' <= ch && ch <= '9') ||\n-                    ('a' <= ch && ch <= 'f') ||\n-                    ('A' <= ch && ch <= 'F')\n-            }\n-\n             alt i {\n                 0u {\n                     if str::len(part) == 8u {\n@@ -156,27 +167,35 @@ fn test_is_uuid() {\n     assert !is_uuid(\"aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaa\u0e1b\");\n }\n \n-// FIXME: implement URI/URL parsing so we don't have to resort to weak checks\n+// FIXME: implement url/URL parsing so we don't have to resort to weak checks\n+\n+fn has_archive_extension(p: str) -> bool {\n+    str::ends_with(p, \".tar\") ||\n+    str::ends_with(p, \".tar.gz\") ||\n+    str::ends_with(p, \".tar.bz2\") ||\n+    str::ends_with(p, \".tar.Z\") ||\n+    str::ends_with(p, \".tar.lz\") ||\n+    str::ends_with(p, \".tar.xz\") ||\n+    str::ends_with(p, \".tgz\") ||\n+    str::ends_with(p, \".tbz\") ||\n+    str::ends_with(p, \".tbz2\") ||\n+    str::ends_with(p, \".tb2\") ||\n+    str::ends_with(p, \".taz\") ||\n+    str::ends_with(p, \".tlz\") ||\n+    str::ends_with(p, \".txz\")\n+}\n \n-fn is_archive_uri(uri: str) -> bool {\n-    str::ends_with(uri, \".tar\")\n-    || str::ends_with(uri, \".tar.gz\")\n-    || str::ends_with(uri, \".tar.xz\")\n-    || str::ends_with(uri, \".tar.bz2\")\n+fn is_archive_path(u: str) -> bool {\n+    has_archive_extension(u) && os::path_exists(u)\n }\n \n-fn is_archive_url(url: str) -> bool {\n-    // FIXME: this requires the protocol bit - if we had proper URI parsing,\n+fn is_archive_url(u: str) -> bool {\n+    // FIXME: this requires the protocol bit - if we had proper url parsing,\n     // we wouldn't need it\n \n-    alt str::find_str(url, \"://\") {\n-        option::some(idx) {\n-            str::ends_with(url, \".tar\")\n-            || str::ends_with(url, \".tar.gz\")\n-            || str::ends_with(url, \".tar.xz\")\n-            || str::ends_with(url, \".tar.bz2\")\n-        }\n-        option::none { false }\n+    alt str::find_str(u, \"://\") {\n+        option::some(i) { has_archive_extension(u) }\n+        _ { false }\n     }\n }\n \n@@ -187,6 +206,17 @@ fn is_git_url(url: str) -> bool {\n     }\n }\n \n+fn assume_source_method(url: str) -> str {\n+    if is_git_url(url) {\n+        ret \"git\";\n+    }\n+    if str::starts_with(url, \"file://\") || os::path_exists(url) {\n+        ret \"file\";\n+    }\n+\n+    \"curl\"\n+}\n+\n fn load_link(mis: [@ast::meta_item]) -> (option<str>,\n                                          option<str>,\n                                          option<str>) {\n@@ -209,7 +239,7 @@ fn load_link(mis: [@ast::meta_item]) -> (option<str>,\n     (name, vers, uuid)\n }\n \n-fn load_pkg(filename: str) -> option<pkg> {\n+fn load_crate(filename: str) -> option<crate> {\n     let cm = codemap::new_codemap();\n     let handler = diagnostic::mk_handler(none);\n     let sess = @{\n@@ -246,19 +276,87 @@ fn load_pkg(filename: str) -> option<pkg> {\n                     uuid = u;\n                 }\n             }\n-            _ { fail \"load_pkg: pkg attributes may not contain meta_words\"; }\n+            _ {\n+                fail \"crate attributes may not contain \" +\n+                     \"meta_words\";\n+            }\n         }\n     }\n \n+    type env = @{\n+        mut deps: [str]\n+    };\n+\n+    fn goto_view_item(e: env, i: @ast::view_item) {\n+        alt i.node {\n+            ast::view_item_use(ident, metas, id) {\n+                let name_items = attr::find_meta_items_by_name(metas, \"name\");\n+                let m = if name_items.is_empty() {\n+                    metas + [attr::mk_name_value_item_str(\"name\", ident)]\n+                } else {\n+                    metas\n+                };\n+                let mut attr_name = ident;\n+                let mut attr_vers = \"\";\n+                let mut attr_from = \"\";\n+\n+                for m.each { |item|\n+                    alt attr::get_meta_item_value_str(item) {\n+                        some(value) {\n+                            let name = attr::get_meta_item_name(item);\n+\n+                            alt name {\n+                                \"vers\" { attr_vers = value; }\n+                                \"from\" { attr_from = value; }\n+                                _ {}\n+                            }\n+                        }\n+                        none {}\n+                    }\n+                }\n+\n+                let query = if !str::is_empty(attr_from) {\n+                    attr_from\n+                } else {\n+                    if !str::is_empty(attr_vers) {\n+                        attr_name + \"@\" + attr_vers\n+                    } else { attr_name }\n+                };\n+\n+                alt attr_name {\n+                    \"std\" | \"core\" { }\n+                    _ { e.deps += [query]; }\n+                }\n+            }\n+            _ { }\n+        }\n+    }\n+    fn goto_item(_e: env, _i: @ast::item) {\n+    }\n+\n+    let e = @{\n+        mut deps: []\n+    };\n+    let v = visit::mk_simple_visitor(@{\n+        visit_view_item: bind goto_view_item(e, _),\n+        visit_item: bind goto_item(e, _),\n+        with *visit::default_simple_visitor()\n+    });\n+\n+    visit::visit_crate(*c, (), v);\n+\n+    let deps = copy e.deps;\n+\n     alt (name, vers, uuid) {\n         (some(name0), some(vers0), some(uuid0)) {\n             some({\n-                name: name0,\n-                vers: vers0,\n-                uuid: uuid0,\n-                desc: desc,\n-                sigs: sigs,\n-                crate_type: crate_type})\n+                mut name: name0,\n+                mut vers: vers0,\n+                mut uuid: uuid0,\n+                mut desc: desc,\n+                mut sigs: sigs,\n+                mut crate_type: crate_type,\n+                mut deps: deps })\n         }\n         _ { ret none; }\n     }\n@@ -283,20 +381,36 @@ fn need_dir(s: str) {\n     }\n }\n \n+fn valid_pkg_name(s: str) -> bool {\n+    fn is_valid_digit(c: char) -> bool {\n+        ('0' <= c && c <= '9') ||\n+        ('a' <= c && c <= 'z') ||\n+        ('A' <= c && c <= 'Z') ||\n+        c == '-' ||\n+        c == '_'\n+    }\n+\n+    s.all(is_valid_digit)\n+}\n+\n fn parse_source(name: str, j: json::json) -> source {\n+    if !valid_pkg_name(name) {\n+        fail #fmt(\"'%s' is an invalid source name\", name);\n+    }\n+\n     alt j {\n         json::dict(_j) {\n-            let url = alt _j.find(\"url\") {\n+            let mut url = alt _j.find(\"url\") {\n                 some(json::string(u)) {\n                     u\n                 }\n                 _ { fail \"needed 'url' field in source\"; }\n             };\n-            let sig = alt _j.find(\"sig\") {\n+            let method = alt _j.find(\"method\") {\n                 some(json::string(u)) {\n-                    some(u)\n+                    u\n                 }\n-                _ { none }\n+                _ { assume_source_method(url) }\n             };\n             let key = alt _j.find(\"key\") {\n                 some(json::string(u)) {\n@@ -310,7 +424,14 @@ fn parse_source(name: str, j: json::json) -> source {\n                 }\n                 _ { none }\n             };\n-            ret { name: name, url: url, sig: sig, key: key, keyfp: keyfp,\n+            if method == \"file\" {\n+                url = os::make_absolute(url);\n+            }\n+            ret { mut name: name,\n+                  mut url: url,\n+                  mut method: method,\n+                  mut key: key,\n+                  mut keyfp: keyfp,\n                   mut packages: [] };\n         }\n         _ { fail \"needed dict value in source\"; }\n@@ -334,15 +455,30 @@ fn try_parse_sources(filename: str, sources: map::hashmap<str, source>) {\n \n fn load_one_source_package(&&src: source, p: map::hashmap<str, json::json>) {\n     let name = alt p.find(\"name\") {\n-        some(json::string(_n)) { _n }\n+        some(json::string(_n)) {\n+            if !valid_pkg_name(_n) {\n+                warn(\"malformed source json: \" + src.name + \", '\" + _n + \"'\"+\n+                     \" is an invalid name (alphanumeric, underscores and\" +\n+                     \" dashes only)\");\n+                ret;\n+            }\n+            _n\n+        }\n         _ {\n             warn(\"malformed source json: \" + src.name + \" (missing name)\");\n             ret;\n         }\n     };\n \n     let uuid = alt p.find(\"uuid\") {\n-        some(json::string(_n)) { _n }\n+        some(json::string(_n)) {\n+            if !is_uuid(_n) {\n+                warn(\"malformed source json: \" + src.name + \", '\" + _n + \"'\"+\n+                     \" is an invalid uuid\");\n+                ret;\n+            }\n+            _n\n+        }\n         _ {\n             warn(\"malformed source json: \" + src.name + \" (missing uuid)\");\n             ret;\n@@ -392,20 +528,59 @@ fn load_one_source_package(&&src: source, p: map::hashmap<str, json::json>) {\n         }\n     };\n \n-    vec::grow(src.packages, 1u, {\n-        name: name,\n-        uuid: uuid,\n-        url: url,\n-        method: method,\n-        description: description,\n-        ref: ref,\n-        tags: tags\n-    });\n+    let newpkg = {\n+        mut name: name,\n+        mut uuid: uuid,\n+        mut url: url,\n+        mut method: method,\n+        mut description: description,\n+        mut ref: ref,\n+        mut tags: tags,\n+        mut versions: []\n+    };\n+\n+    for src.packages.each { |pkg|\n+        if pkg.uuid == uuid {\n+            pkg.name = newpkg.name;\n+            pkg.uuid = newpkg.uuid;\n+            pkg.url = newpkg.url;\n+            pkg.method = newpkg.method;\n+            pkg.description = newpkg.description;\n+            pkg.ref = newpkg.ref;\n+            pkg.tags = newpkg.tags;\n+            pkg.versions = newpkg.versions;\n+            log(debug, \"  updated package: \" + src.name + \"/\" + name);\n+            ret;\n+        }\n+    }\n+\n+    vec::grow(src.packages, 1u, newpkg);\n     log(debug, \"  loaded package: \" + src.name + \"/\" + name);\n }\n \n-fn load_source_packages(&&c: cargo, &&src: source) {\n-    log(debug, \"Loading source: \" + src.name);\n+fn load_source_info(&c: cargo, &src: source) {\n+    let dir = path::connect(c.sourcedir, src.name);\n+    let srcfile = path::connect(dir, \"source.json\");\n+    if !os::path_exists(srcfile) { ret; }\n+    let srcstr = io::read_whole_file_str(srcfile);\n+    alt json::from_str(result::get(srcstr)) {\n+        ok(json::dict(_s)) {\n+            let o = parse_source(src.name, json::dict(_s));\n+\n+            src.key = o.key;\n+            src.keyfp = o.keyfp;\n+        }\n+        ok(_) {\n+            warn(\"malformed source.json: \" + src.name +\n+                 \"(source info is not a dict)\");\n+        }\n+        err(e) {\n+            warn(#fmt(\"%s:%u:%u: %s\", src.name, e.line, e.col, e.msg));\n+        }\n+    };\n+}\n+fn load_source_packages(&&c: cargo, &src: source) {\n+    log(debug, \"loading source: \" + src.name);\n     let dir = path::connect(c.sourcedir, src.name);\n     let pkgfile = path::connect(dir, \"packages.json\");\n     if !os::path_exists(pkgfile) { ret; }\n@@ -425,7 +600,7 @@ fn load_source_packages(&&c: cargo, &&src: source) {\n             }\n         }\n         ok(_) {\n-            warn(\"malformed source json: \" + src.name +\n+            warn(\"malformed packages.json: \" + src.name +\n                  \"(packages is not a list)\");\n         }\n         err(e) {\n@@ -483,6 +658,8 @@ fn configure(opts: options) -> cargo {\n     try_parse_sources(path::connect(home, \"sources.json\"), sources);\n     try_parse_sources(path::connect(home, \"local-sources.json\"), sources);\n \n+    let dep_cache = map::str_hash::<bool>();\n+\n     let mut c = {\n         pgp: pgp::supported(),\n         root: home,\n@@ -492,6 +669,8 @@ fn configure(opts: options) -> cargo {\n         workdir: path::connect(home, \"work\"),\n         sourcedir: path::connect(home, \"sources\"),\n         sources: sources,\n+        mut current_install: \"\",\n+        dep_cache: dep_cache,\n         opts: opts\n     };\n \n@@ -519,7 +698,7 @@ fn configure(opts: options) -> cargo {\n     c\n }\n \n-fn for_each_package(c: cargo, b: fn(source, package)) {\n+fn for_each_package(&c: cargo, b: fn(source, package)) {\n     for c.sources.each_value {|v|\n         // FIXME (#2280): this temporary shouldn't be\n         // necessary, but seems to be, for borrowing.\n@@ -563,7 +742,7 @@ fn test_one_crate(_c: cargo, path: str, cf: str) {\n   run_programs(buildpath);\n }\n \n-fn install_one_crate(c: cargo, path: str, cf: str) {\n+fn install_one_crate(&c: cargo, path: str, cf: str) {\n     let buildpath = alt run_in_buildpath(\"installing\", path,\n                                          \"/build\", cf, []) {\n       none { ret; }\n@@ -603,7 +782,7 @@ fn rustc_sysroot() -> str {\n     }\n }\n \n-fn install_source(c: cargo, path: str) {\n+fn install_source(&c: cargo, path: str) {\n     #debug(\"source: %s\", path);\n     os::change_dir(path);\n \n@@ -619,10 +798,23 @@ fn install_source(c: cargo, path: str) {\n     }\n \n     for cratefiles.each {|cf|\n-        let p = load_pkg(cf);\n-        alt p {\n+        alt load_crate(cf) {\n             none { cont; }\n-            some(_) {\n+            some(crate) {\n+                for crate.deps.each { |query|\n+                    // TODO: handle cyclic dependencies\n+\n+                    let wd_base = c.workdir + path::path_sep();\n+                    let wd = alt tempfile::mkdtemp(wd_base, \"\") {\n+                        some(_wd) { _wd }\n+                        none { fail #fmt(\"needed temp dir: %s\", wd_base); }\n+                    };\n+\n+                    install_query(c, wd, query);\n+                }\n+\n+                os::change_dir(path);\n+\n                 if c.opts.test {\n                     test_one_crate(c, path, cf);\n                 }\n@@ -632,9 +824,8 @@ fn install_source(c: cargo, path: str) {\n     }\n }\n \n-fn install_git(c: cargo, wd: str, url: str, ref: option<str>) {\n-    info(\"installing with git from \" + url + \"...\");\n-    run::run_program(\"git\", [\"clone\", url, wd]);\n+fn install_git(&c: cargo, wd: str, url: str, ref: option<str>) {\n+    run::program_output(\"git\", [\"clone\", url, wd]);\n     if option::is_some::<str>(ref) {\n         let r = option::get::<str>(ref);\n         os::change_dir(wd);\n@@ -644,8 +835,7 @@ fn install_git(c: cargo, wd: str, url: str, ref: option<str>) {\n     install_source(c, wd);\n }\n \n-fn install_curl(c: cargo, wd: str, url: str) {\n-    info(\"installing with curl from \" + url + \"...\");\n+fn install_curl(&c: cargo, wd: str, url: str) {\n     let tarpath = path::connect(wd, \"pkg.tar\");\n     let p = run::program_output(\"curl\", [\"-f\", \"-s\", \"-o\",\n                                          tarpath, url]);\n@@ -657,96 +847,95 @@ fn install_curl(c: cargo, wd: str, url: str) {\n     install_source(c, wd);\n }\n \n-fn install_file(c: cargo, wd: str, path: str) {\n-    info(\"installing with tar from \" + path + \"...\");\n-    run::run_program(\"tar\", [\"-x\", \"--strip-components=1\",\n+fn install_file(&c: cargo, wd: str, path: str) {\n+    run::program_output(\"tar\", [\"-x\", \"--strip-components=1\",\n                              \"-C\", wd, \"-f\", path]);\n     install_source(c, wd);\n }\n \n-fn install_package(c: cargo, wd: str, pkg: package) {\n-    alt pkg.method {\n-        \"git\" { install_git(c, wd, pkg.url, pkg.ref); }\n-        \"http\" | \"ftp\" | \"curl\" { install_curl(c, wd, pkg.url); }\n-        \"file\" { install_file(c, wd, pkg.url); }\n-        _ { fail #fmt(\"don't know how to install with: %s\", pkg.method) }\n+fn install_package(&c: cargo, src: str, wd: str, pkg: package) {\n+    let url = copy pkg.url;\n+    let method = alt pkg.method {\n+        \"git\" { \"git\" }\n+        \"file\" { \"file\" }\n+        _ { \"curl\" }\n+    };\n+\n+    info(#fmt[\"installing %s/%s via %s...\", src, pkg.name, method]);\n+\n+    alt method {\n+        \"git\" { install_git(c, wd, url, copy pkg.ref); }\n+        \"file\" { install_file(c, wd, url); }\n+        \"curl\" { install_curl(c, wd, copy url); }\n+        _ {}\n     }\n }\n \n-fn cargo_suggestion(c: cargo, syncing: bool, fallback: fn())\n+fn cargo_suggestion(&c: cargo, fallback: fn())\n {\n     if c.sources.size() == 0u {\n         error(\"no sources defined - you may wish to run \" +\n-              \"`cargo init` then `cargo sync`\");\n+              \"`cargo init`\");\n         ret;\n     }\n-    if !syncing {\n-        let mut npkg = 0u;\n-        for c.sources.each_value { |v| npkg += vec::len(v.packages) }\n-        if npkg == 0u {\n-            error(\"no packages synced - you may wish to run \" +\n-                  \"`cargo sync`\");\n-            ret;\n-        }\n-    }\n     fallback();\n }\n \n-fn install_uuid(c: cargo, wd: str, uuid: str) {\n+fn install_uuid(&c: cargo, wd: str, uuid: str) {\n     let mut ps = [];\n     for_each_package(c, { |s, p|\n         if p.uuid == uuid {\n-            vec::grow(ps, 1u, (s.name, p));\n+            vec::grow(ps, 1u, (s.name, copy p));\n         }\n     });\n     if vec::len(ps) == 1u {\n-        let (_, p) = ps[0];\n-        install_package(c, wd, p);\n+        let (sname, p) = copy ps[0];\n+        install_package(c, sname, wd, p);\n         ret;\n     } else if vec::len(ps) == 0u {\n-        cargo_suggestion(c, false, { ||\n+        cargo_suggestion(c, { ||\n             error(\"can't find package: \" + uuid);\n         });\n         ret;\n     }\n     error(\"found multiple packages:\");\n     for ps.each {|elt|\n-        let (sname,p) = elt;\n+        let (sname,p) = copy elt;\n         info(\"  \" + sname + \"/\" + p.uuid + \" (\" + p.name + \")\");\n     }\n }\n \n-fn install_named(c: cargo, wd: str, name: str) {\n+fn install_named(&c: cargo, wd: str, name: str) {\n     let mut ps = [];\n     for_each_package(c, { |s, p|\n         if p.name == name {\n-            vec::grow(ps, 1u, (s.name, p));\n+            vec::grow(ps, 1u, (s.name, copy p));\n         }\n     });\n     if vec::len(ps) == 1u {\n-        let (_, p) = ps[0];\n-        install_package(c, wd, p);\n+        let (sname, p) = copy ps[0];\n+        install_package(c, sname, wd, p);\n         ret;\n     } else if vec::len(ps) == 0u {\n-        cargo_suggestion(c, false, { ||\n+        cargo_suggestion(c, { ||\n             error(\"can't find package: \" + name);\n         });\n         ret;\n     }\n     error(\"found multiple packages:\");\n     for ps.each {|elt|\n-        let (sname,p) = elt;\n+        let (sname,p) = copy elt;\n         info(\"  \" + sname + \"/\" + p.uuid + \" (\" + p.name + \")\");\n     }\n }\n \n-fn install_uuid_specific(c: cargo, wd: str, src: str, uuid: str) {\n+fn install_uuid_specific(&c: cargo, wd: str, src: str, uuid: str) {\n     alt c.sources.find(src) {\n       some(s) {\n         let packages = copy s.packages;\n         if vec::any(packages, { |p|\n             if p.uuid == uuid {\n-                install_package(c, wd, p);\n+                install_package(c, src, wd, p);\n                 true\n             } else { false }\n         }) { ret; }\n@@ -756,13 +945,13 @@ fn install_uuid_specific(c: cargo, wd: str, src: str, uuid: str) {\n     error(\"can't find package: \" + src + \"/\" + uuid);\n }\n \n-fn install_named_specific(c: cargo, wd: str, src: str, name: str) {\n+fn install_named_specific(&c: cargo, wd: str, src: str, name: str) {\n     alt c.sources.find(src) {\n         some(s) {\n           let packages = copy s.packages;\n           if vec::any(packages, { |p|\n                 if p.name == name {\n-                    install_package(c, wd, p);\n+                    install_package(c, src, wd, p);\n                     true\n                 } else { false }\n             }) { ret; }\n@@ -772,7 +961,7 @@ fn install_named_specific(c: cargo, wd: str, src: str, name: str) {\n     error(\"can't find package: \" + src + \"/\" + name);\n }\n \n-fn cmd_uninstall(c: cargo) {\n+fn cmd_uninstall(&c: cargo) {\n     if vec::len(c.opts.free) < 3u {\n         cmd_usage();\n         ret;\n@@ -837,44 +1026,30 @@ fn cmd_uninstall(c: cargo) {\n     }\n }\n \n-fn cmd_install(c: cargo) unsafe {\n-    // cargo install [pkg]\n-    if vec::len(c.opts.free) < 2u {\n-        cmd_usage();\n-        ret;\n-    }\n-\n-    let wd_base = c.workdir + path::path_sep();\n-    let wd = alt tempfile::mkdtemp(wd_base, \"\") {\n-        some(_wd) { _wd }\n-        none { fail #fmt(\"needed temp dir: %s\", wd_base); }\n-    };\n-\n-    if vec::len(c.opts.free) == 2u {\n-        let cwd = os::getcwd();\n-        let status = run::run_program(\"cp\", [\"-R\", cwd, wd]);\n-\n-        if status != 0 {\n-            fail #fmt(\"could not copy directory: %s\", cwd);\n+fn install_query(&c: cargo, wd: str, target: str) {\n+    alt c.dep_cache.find(target) {\n+        some(_inst) {\n+            if _inst {\n+                ret;\n+            }\n         }\n-\n-        install_source(c, wd);\n-        ret;\n+        none {}\n     }\n \n-    let target = c.opts.free[2];\n+    c.dep_cache.insert(target, true);\n \n-    if is_archive_url(target) {\n-        install_curl(c, wd, target);\n+    if is_archive_path(target) {\n+        install_file(c, wd, target);\n+        ret;\n     } else if is_git_url(target) {\n         let ref = if c.opts.free.len() >= 4u {\n             some(c.opts.free[3u])\n         } else {\n             none\n         };\n-        install_git(c, wd, target, ref)\n-    } else if is_archive_uri(target) {\n-        install_file(c, wd, target);\n+        install_git(c, wd, target, ref);\n+    } else if !valid_pkg_name(target) && has_archive_extension(target) {\n+        install_curl(c, wd, target);\n         ret;\n     } else {\n         let mut ps = copy target;\n@@ -898,82 +1073,361 @@ fn cmd_install(c: cargo) unsafe {\n             }\n         }\n     }\n+\n+    // FIXME: This whole dep_cache and current_install\n+    // thing is a bit of a hack. It should be cleaned up in the future.\n+\n+    if target == c.current_install {\n+        for c.dep_cache.each { |k, _v|\n+            c.dep_cache.remove(k);\n+        }\n+\n+        c.current_install = \"\";\n+    }\n+}\n+\n+fn cmd_install(&c: cargo) unsafe {\n+    let wd_base = c.workdir + path::path_sep();\n+    let wd = alt tempfile::mkdtemp(wd_base, \"\") {\n+        some(_wd) { _wd }\n+        none { fail #fmt(\"needed temp dir: %s\", wd_base); }\n+    };\n+\n+    if vec::len(c.opts.free) == 2u {\n+        let cwd = os::getcwd();\n+        let status = run::run_program(\"cp\", [\"-R\", cwd, wd]);\n+\n+        if status != 0 {\n+            fail #fmt(\"could not copy directory: %s\", cwd);\n+        }\n+\n+        install_source(c, wd);\n+        ret;\n+    }\n+\n+    sync(c);\n+\n+    let query = c.opts.free[2];\n+    c.current_install = copy query;\n+\n+    install_query(c, wd, copy query);\n+}\n+\n+fn sync(&c: cargo) {\n+    for c.sources.each_key { |k|\n+        let mut s = c.sources.get(k);\n+        sync_one(c, s);\n+        c.sources.insert(k, s);\n+    }\n }\n \n-fn sync_one(c: cargo, name: str, src: source) {\n-    let dir = path::connect(c.sourcedir, name);\n+fn sync_one_file(&c: cargo, dir: str, &src: source) -> bool {\n+    let name = src.name;\n+    let srcfile = path::connect(dir, \"source.json.new\");\n+    let destsrcfile = path::connect(dir, \"source.json\");\n     let pkgfile = path::connect(dir, \"packages.json.new\");\n     let destpkgfile = path::connect(dir, \"packages.json\");\n-    let sigfile = path::connect(dir, \"packages.json.sig\");\n     let keyfile = path::connect(dir, \"key.gpg\");\n+    let srcsigfile = path::connect(dir, \"source.json.sig\");\n+    let sigfile = path::connect(dir, \"packages.json.sig\");\n     let url = src.url;\n-    need_dir(dir);\n-    info(#fmt[\"fetching source %s...\", name]);\n-    let p = run::program_output(\"curl\", [\"-f\", \"-s\", \"-o\", pkgfile, url]);\n-    if p.status != 0 {\n-        warn(#fmt[\"fetch for source %s (url %s) failed\", name, url]);\n-    } else {\n-        info(#fmt[\"fetched source: %s\", name]);\n+    let mut has_src_file = false;\n+\n+    if !os::copy_file(path::connect(url, \"packages.json\"), pkgfile) {\n+        error(#fmt[\"fetch for source %s (url %s) failed\", name, url]);\n+        ret false;\n+    }\n+\n+    if os::copy_file(path::connect(url, \"source.json\"), srcfile) {\n+        has_src_file = false;\n     }\n-    alt src.sig {\n+\n+    os::copy_file(path::connect(url, \"source.json.sig\"), srcsigfile);\n+    os::copy_file(path::connect(url, \"packages.json.sig\"), sigfile);\n+\n+    alt src.key {\n         some(u) {\n-            let p = run::program_output(\"curl\", [\"-f\", \"-s\", \"-o\", sigfile,\n-                                                 u]);\n+            let p = run::program_output(\"curl\",  [\"-f\", \"-s\", \"-o\", keyfile,\n+                                                  u]);\n             if p.status != 0 {\n-                warn(#fmt[\"fetch for source %s (sig %s) failed\", name, u]);\n+                error(#fmt[\"fetch for source %s (key %s) failed\", name, u]);\n+                ret false;\n             }\n+            pgp::add(c.root, keyfile);\n         }\n         _ { }\n     }\n+    alt (src.key, src.keyfp) {\n+        (some(_), some(f)) {\n+            let r = pgp::verify(c.root, pkgfile, sigfile, f);\n+\n+            if !r {\n+                error(#fmt[\"signature verification failed for source %s\",\n+                          name]);\n+                ret false;\n+            }\n+\n+            if has_src_file {\n+                let e = pgp::verify(c.root, srcfile, srcsigfile, f);\n+\n+                if !e {\n+                    error(#fmt[\"signature verification failed for source %s\",\n+                              name]);\n+                    ret false;\n+                }\n+            }\n+        }\n+        _ {}\n+    }\n+\n+    copy_warn(pkgfile, destpkgfile);\n+\n+    if has_src_file {\n+        copy_warn(srcfile, destsrcfile);\n+    }\n+\n+    os::remove_file(keyfile);\n+    os::remove_file(srcfile);\n+    os::remove_file(srcsigfile);\n+    os::remove_file(pkgfile);\n+    os::remove_file(sigfile);\n+\n+    info(#fmt[\"synced source: %s\", name]);\n+\n+    ret true;\n+}\n+\n+fn sync_one_git(&c: cargo, dir: str, &src: source) -> bool {\n+    let name = src.name;\n+    let srcfile = path::connect(dir, \"source.json\");\n+    let pkgfile = path::connect(dir, \"packages.json\");\n+    let keyfile = path::connect(dir, \"key.gpg\");\n+    let srcsigfile = path::connect(dir, \"source.json.sig\");\n+    let sigfile = path::connect(dir, \"packages.json.sig\");\n+    let url = src.url;\n+\n+    fn rollback(name: str, dir: str, insecure: bool) {\n+        fn msg(name: str, insecure: bool) {\n+            error(#fmt[\"could not rollback source: %s\", name]);\n+\n+            if insecure {\n+                warn(\"a past security check failed on source \" +\n+                     name + \" and rolling back the source failed -\"\n+                     + \" this source may be compromised\");\n+            }\n+        }\n+\n+        if !os::change_dir(dir) {\n+            msg(name, insecure);\n+        }\n+        else {\n+            let p = run::program_output(\"git\", [\"reset\", \"--hard\",\n+                                                \"HEAD@{1}\"]);\n+\n+            if p.status != 0 {\n+                msg(name, insecure);\n+            }\n+        }\n+    }\n+\n+    if !os::path_exists(path::connect(dir, \".git\")) {\n+        let p = run::program_output(\"git\", [\"clone\", url, dir]);\n+\n+        if p.status != 0 {\n+            error(#fmt[\"fetch for source %s (url %s) failed\", name, url]);\n+            ret false;\n+        }\n+    }\n+    else {\n+        if !os::change_dir(dir) {\n+            error(#fmt[\"fetch for source %s (url %s) failed\", name, url]);\n+            ret false;\n+        }\n+\n+        let p = run::program_output(\"git\", [\"pull\"]);\n+\n+        if p.status != 0 {\n+            error(#fmt[\"fetch for source %s (url %s) failed\", name, url]);\n+            ret false;\n+        }\n+    }\n+\n+    let has_src_file = os::path_exists(srcfile);\n+\n     alt src.key {\n         some(u) {\n             let p = run::program_output(\"curl\",  [\"-f\", \"-s\", \"-o\", keyfile,\n                                                   u]);\n             if p.status != 0 {\n-                warn(#fmt[\"fetch for source %s (key %s) failed\", name, u]);\n+                error(#fmt[\"fetch for source %s (key %s) failed\", name, u]);\n+                rollback(name, dir, false);\n+                ret false;\n             }\n             pgp::add(c.root, keyfile);\n         }\n         _ { }\n     }\n-    alt (src.sig, src.key, src.keyfp) {\n-        (some(_), some(_), some(f)) {\n+    alt (src.key, src.keyfp) {\n+        (some(_), some(f)) {\n             let r = pgp::verify(c.root, pkgfile, sigfile, f);\n+\n             if !r {\n-                warn(#fmt[\"signature verification failed for source %s\",\n+                error(#fmt[\"signature verification failed for source %s\",\n                           name]);\n-            } else {\n-                info(#fmt[\"signature ok for source %s\", name]);\n+                rollback(name, dir, false);\n+                ret false;\n+            }\n+\n+            if has_src_file {\n+                let e = pgp::verify(c.root, srcfile, srcsigfile, f);\n+\n+                if !e {\n+                    error(#fmt[\"signature verification failed for source %s\",\n+                              name]);\n+                    rollback(name, dir, false);\n+                    ret false;\n+                }\n             }\n         }\n-        _ {\n-            info(#fmt[\"no signature for source %s\", name]);\n-        }\n+        _ {}\n     }\n-    copy_warn(pkgfile, destpkgfile);\n+\n+    os::remove_file(keyfile);\n+\n+    info(#fmt[\"synced source: %s\", name]);\n+\n+    ret true;\n }\n \n-fn cmd_sync(c: cargo) {\n-    if vec::len(c.opts.free) >= 3u {\n-        vec::iter_between(c.opts.free, 2u, vec::len(c.opts.free)) { |name|\n-            alt c.sources.find(name) {\n-                some(source) {\n-                    sync_one(c, name, source);\n+fn sync_one_curl(&c: cargo, dir: str, &src: source) -> bool {\n+    let name = src.name;\n+    let srcfile = path::connect(dir, \"source.json.new\");\n+    let destsrcfile = path::connect(dir, \"source.json\");\n+    let pkgfile = path::connect(dir, \"packages.json.new\");\n+    let destpkgfile = path::connect(dir, \"packages.json\");\n+    let keyfile = path::connect(dir, \"key.gpg\");\n+    let srcsigfile = path::connect(dir, \"source.json.sig\");\n+    let sigfile = path::connect(dir, \"packages.json.sig\");\n+    let mut url = src.url;\n+    let smart = !str::ends_with(src.url, \"packages.json\");\n+    let mut has_src_file = false;\n+\n+    if smart {\n+        url += \"/packages.json\";\n+    }\n+\n+    let p = run::program_output(\"curl\", [\"-f\", \"-s\", \"-o\", pkgfile, url]);\n+\n+    if p.status != 0 {\n+        error(#fmt[\"fetch for source %s (url %s) failed\", name, url]);\n+        ret false;\n+    }\n+    if smart {\n+        url = src.url + \"/source.json\";\n+        let p = run::program_output(\"curl\", [\"-f\", \"-s\", \"-o\", srcfile, url]);\n+\n+        if p.status == 0 {\n+            has_src_file = true;\n+        }\n+    }\n+\n+    alt src.key {\n+        some(u) {\n+            let p = run::program_output(\"curl\",  [\"-f\", \"-s\", \"-o\", keyfile,\n+                                                  u]);\n+            if p.status != 0 {\n+                error(#fmt[\"fetch for source %s (key %s) failed\", name, u]);\n+                ret false;\n+            }\n+            pgp::add(c.root, keyfile);\n+        }\n+        _ { }\n+    }\n+    alt (src.key, src.keyfp) {\n+        (some(_), some(f)) {\n+            if smart {\n+                url = src.url + \"/packages.json.sig\";\n+            }\n+            else {\n+                url = src.url + \".sig\";\n+            }\n+\n+            let mut p = run::program_output(\"curl\", [\"-f\", \"-s\", \"-o\",\n+                        sigfile, url]);\n+            if p.status != 0 {\n+                error(#fmt[\"fetch for source %s (sig %s) failed\", name, url]);\n+                ret false;\n+            }\n+\n+            let r = pgp::verify(c.root, pkgfile, sigfile, f);\n+\n+            if !r {\n+                error(#fmt[\"signature verification failed for source %s\",\n+                          name]);\n+                ret false;\n+            }\n+\n+            if smart && has_src_file {\n+                url = src.url + \"/source.json.sig\";\n+\n+                p = run::program_output(\"curl\", [\"-f\", \"-s\", \"-o\", srcsigfile,\n+                                                     url]);\n+                if p.status != 0 {\n+                    error(#fmt[\"fetch for source %s (sig %s) failed\",\n+                          name, url]);\n+                    ret false;\n                 }\n-                none {\n-                    error(#fmt(\"no such source: %s\", name));\n+\n+                let e = pgp::verify(c.root, srcfile, srcsigfile, f);\n+\n+                if !e {\n+                    error(\"signature verification failed for \" +\n+                          \"source \" + name);\n+                    ret false;\n                 }\n             }\n         }\n-    } else {\n-        cargo_suggestion(c, true, { || } );\n-        for c.sources.each_value { |v|\n-            sync_one(c, v.name, v);\n-        }\n+        _ {}\n+    }\n+\n+    copy_warn(pkgfile, destpkgfile);\n+\n+    if smart && has_src_file {\n+        copy_warn(srcfile, destsrcfile);\n+    }\n+\n+    os::remove_file(keyfile);\n+    os::remove_file(srcfile);\n+    os::remove_file(srcsigfile);\n+    os::remove_file(pkgfile);\n+    os::remove_file(sigfile);\n+\n+    info(#fmt[\"synced source: %s\", name]);\n+\n+    ret true;\n+}\n+\n+fn sync_one(&c: cargo, &src: source) {\n+    let name = src.name;\n+    let dir = path::connect(c.sourcedir, name);\n+\n+    info(#fmt[\"syncing source: %s...\", name]);\n+\n+    need_dir(dir);\n+\n+    let result = alt src.method {\n+        \"git\" { sync_one_git(c, dir, src) }\n+        \"file\" { sync_one_file(c, dir, src) }\n+        _ { sync_one_curl(c, dir, src) }\n+    };\n+\n+    if result {\n+        load_source_info(c, src);\n+        load_source_packages(c, src);\n     }\n }\n \n-fn cmd_init(c: cargo) {\n+fn cmd_init(&c: cargo) {\n     let srcurl = \"http://www.rust-lang.org/cargo/sources.json\";\n     let sigurl = \"http://www.rust-lang.org/cargo/sources.json.sig\";\n \n@@ -983,23 +1437,25 @@ fn cmd_init(c: cargo) {\n \n     let p = run::program_output(\"curl\", [\"-f\", \"-s\", \"-o\", srcfile, srcurl]);\n     if p.status != 0 {\n-        warn(#fmt[\"fetch of sources.json failed: %s\", p.out]);\n+        error(#fmt[\"fetch of sources.json failed: %s\", p.out]);\n         ret;\n     }\n \n     let p = run::program_output(\"curl\", [\"-f\", \"-s\", \"-o\", sigfile, sigurl]);\n     if p.status != 0 {\n-        warn(#fmt[\"fetch of sources.json.sig failed: %s\", p.out]);\n+        error(#fmt[\"fetch of sources.json.sig failed: %s\", p.out]);\n         ret;\n     }\n \n     let r = pgp::verify(c.root, srcfile, sigfile, pgp::signing_key_fp());\n     if !r {\n-        warn(#fmt[\"signature verification failed for '%s'\", srcfile]);\n-    } else {\n-        info(#fmt[\"signature ok for '%s'\", srcfile]);\n+        error(#fmt[\"signature verification failed for '%s'\", srcfile]);\n+        ret;\n     }\n+\n     copy_warn(srcfile, destsrcfile);\n+    os::remove_file(srcfile);\n+    os::remove_file(sigfile);\n \n     info(#fmt[\"initialized .cargo in %s\", c.root]);\n }\n@@ -1038,15 +1494,21 @@ fn print_source(s: source) {\n     });\n }\n \n-fn cmd_list(c: cargo) {\n+fn cmd_list(&c: cargo) {\n+    sync(c);\n+\n     if vec::len(c.opts.free) >= 3u {\n         vec::iter_between(c.opts.free, 2u, vec::len(c.opts.free)) { |name|\n-            alt c.sources.find(name) {\n-                some(source) {\n-                    print_source(source);\n-                }\n-                none {\n-                    error(#fmt(\"no such source: %s\", name));\n+            if !valid_pkg_name(name) {\n+                error(#fmt(\"'%s' is an invalid source name\", name));\n+            } else {\n+                alt c.sources.find(name) {\n+                    some(source) {\n+                        print_source(source);\n+                    }\n+                    none {\n+                        error(#fmt(\"no such source: %s\", name));\n+                    }\n                 }\n             }\n         }\n@@ -1057,11 +1519,14 @@ fn cmd_list(c: cargo) {\n     }\n }\n \n-fn cmd_search(c: cargo) {\n+fn cmd_search(&c: cargo) {\n     if vec::len(c.opts.free) < 3u {\n         cmd_usage();\n         ret;\n     }\n+\n+    sync(c);\n+\n     let mut n = 0;\n     let name = c.opts.free[2];\n     let tags = vec::slice(c.opts.free, 3u, vec::len(c.opts.free));\n@@ -1086,74 +1551,362 @@ fn install_to_dir(srcfile: str, destdir: str) {\n     }\n }\n \n+fn dump_cache(&c: cargo) {\n+    need_dir(c.root);\n+\n+    let out = path::connect(c.root, \"cache.json\");\n+    let _root = json::dict(map::str_hash());\n+\n+    if os::path_exists(out) {\n+        copy_warn(out, path::connect(c.root, \"cache.json.old\"));\n+    }\n+}\n+fn dump_sources(&c: cargo) {\n+    if c.sources.size() < 1u {\n+        ret;\n+    }\n+\n+    need_dir(c.root);\n+\n+    let out = path::connect(c.root, \"sources.json\");\n+\n+    if os::path_exists(out) {\n+        copy_warn(out, path::connect(c.root, \"sources.json.old\"));\n+    }\n+\n+    alt io::buffered_file_writer(out) {\n+        result::ok(writer) {\n+            let hash = map::str_hash();\n+            let root = json::dict(hash);\n+\n+            for c.sources.each { |k, v|\n+                let chash = map::str_hash();\n+                let child = json::dict(chash);\n+\n+                chash.insert(\"url\", json::string(v.url));\n+                chash.insert(\"method\", json::string(v.method));\n+\n+                alt v.key {\n+                    some(key) {\n+                        chash.insert(\"key\", json::string(key));\n+                    }\n+                    _ {}\n+                }\n+                alt v.keyfp {\n+                    some(keyfp) {\n+                        chash.insert(\"keyfp\", json::string(keyfp));\n+                    }\n+                    _ {}\n+                }\n+\n+                hash.insert(k, child);\n+            }\n+\n+            writer.write_str(json::to_str(root));\n+        }\n+        result::err(e) {\n+            error(#fmt(\"could not dump sources: %s\", e));\n+        }\n+    }\n+}\n+\n fn copy_warn(srcfile: str, destfile: str) {\n-  if !os::copy_file(srcfile, destfile) {\n-      warn(#fmt[\"copying %s to %s failed\", srcfile, destfile]);\n-  }\n+    if !os::copy_file(srcfile, destfile) {\n+        warn(#fmt[\"copying %s to %s failed\", srcfile, destfile]);\n+    }\n+}\n+\n+fn cmd_sources(&c: cargo) {\n+    if vec::len(c.opts.free) < 3u {\n+        for c.sources.each_value { |v|\n+            info(#fmt(\"%s (%s) via %s\", v.name, v.url, v.method));\n+        }\n+        ret;\n+    }\n+\n+    let action = c.opts.free[2u];\n+\n+    alt action {\n+        \"clear\" {\n+            for c.sources.each_key { |k|\n+                c.sources.remove(k);\n+            }\n+\n+            info(\"cleared sources\");\n+        }\n+        \"add\" {\n+            if vec::len(c.opts.free) < 5u {\n+                cmd_usage();\n+                ret;\n+            }\n+\n+            let name = c.opts.free[3u];\n+            let url = c.opts.free[4u];\n+\n+            if !valid_pkg_name(name) {\n+                error(#fmt(\"'%s' is an invalid source name\", name));\n+                ret;\n+            }\n+\n+            alt c.sources.find(name) {\n+                some(source) {\n+                    error(#fmt(\"source already exists: %s\", name));\n+                }\n+                none {\n+                    c.sources.insert(name, {\n+                        mut name: name,\n+                        mut url: url,\n+                        mut method: assume_source_method(url),\n+                        mut key: none,\n+                        mut keyfp: none,\n+                        mut packages: []\n+                    });\n+                    info(#fmt(\"added source: %s\", name));\n+                }\n+            }\n+        }\n+        \"remove\" {\n+            if vec::len(c.opts.free) < 4u {\n+                cmd_usage();\n+                ret;\n+            }\n+\n+            let name = c.opts.free[3u];\n+\n+            if !valid_pkg_name(name) {\n+                error(#fmt(\"'%s' is an invalid source name\", name));\n+                ret;\n+            }\n+\n+            alt c.sources.find(name) {\n+                some(source) {\n+                    c.sources.remove(name);\n+                    info(#fmt(\"removed source: %s\", name));\n+                }\n+                none {\n+                    error(#fmt(\"no such source: %s\", name));\n+                }\n+            }\n+        }\n+        \"set-url\" {\n+            if vec::len(c.opts.free) < 5u {\n+                cmd_usage();\n+                ret;\n+            }\n+\n+            let name = c.opts.free[3u];\n+            let url = c.opts.free[4u];\n+\n+            if !valid_pkg_name(name) {\n+                error(#fmt(\"'%s' is an invalid source name\", name));\n+                ret;\n+            }\n+\n+            alt c.sources.find(name) {\n+                some(source) {\n+                    let old = copy source.url;\n+                    let method = assume_source_method(url);\n+\n+                    source.url = url;\n+                    source.method = method;\n+\n+                    c.sources.insert(name, source);\n+\n+                    info(#fmt(\"changed source url: '%s' to '%s'\", old, url));\n+                }\n+                none {\n+                    error(#fmt(\"no such source: %s\", name));\n+                }\n+            }\n+        }\n+        \"set-method\" {\n+            if vec::len(c.opts.free) < 5u {\n+                cmd_usage();\n+                ret;\n+            }\n+\n+            let name = c.opts.free[3u];\n+            let method = c.opts.free[4u];\n+\n+            if !valid_pkg_name(name) {\n+                error(#fmt(\"'%s' is an invalid source name\", name));\n+                ret;\n+            }\n+\n+            alt c.sources.find(name) {\n+                some(source) {\n+                    let old = copy source.method;\n+\n+                    source.method = alt method {\n+                        \"git\" { \"git\" }\n+                        \"file\" { \"file\" }\n+                        _ { \"curl\" }\n+                    };\n+\n+                    c.sources.insert(name, source);\n+\n+                    info(#fmt(\"changed source method: '%s' to '%s'\", old,\n+                         method));\n+                }\n+                none {\n+                    error(#fmt(\"no such source: %s\", name));\n+                }\n+            }\n+        }\n+        \"rename\" {\n+            if vec::len(c.opts.free) < 5u {\n+                cmd_usage();\n+                ret;\n+            }\n+\n+            let name = c.opts.free[3u];\n+            let newn = c.opts.free[4u];\n+\n+            if !valid_pkg_name(name) {\n+                error(#fmt(\"'%s' is an invalid source name\", name));\n+                ret;\n+            }\n+            if !valid_pkg_name(newn) {\n+                error(#fmt(\"'%s' is an invalid source name\", newn));\n+                ret;\n+            }\n+\n+            alt c.sources.find(name) {\n+                some(source) {\n+                    c.sources.remove(name);\n+                    c.sources.insert(newn, source);\n+                    info(#fmt(\"renamed source: %s to %s\", name, newn));\n+                }\n+                none {\n+                    error(#fmt(\"no such source: %s\", name));\n+                }\n+            }\n+        }\n+        _ { cmd_usage(); }\n+    }\n }\n \n fn cmd_usage() {\n-    print(\"Usage: cargo <verb> [options] [args..]\\n\" +\n-          \" e.g.: cargo [init | sync]\\n\" +\n-          \" e.g.: cargo install [-g | -G] <package>\n-\n-General:\n-    init                    Reinitialize cargo in ~/.cargo\n-    usage                   Display this message\n-    sync [sources..]        Sync all sources (or specific sources)\n-\n-Querying:\n-    list [sources..]                        List sources and their packages\n-                                            or a single source\n-    search <name | '*'> [tags...]           Search packages\n-\n-Packages:\n-    install [options]                       Install a package from source\n-                                            code in the current directory\n-    install [options] [source/]<name>       Install a package by name\n-    install [options] [source/]<uuid>       Install a package by uuid\n-    install [options] <url>                 Install a package via curl (HTTP,\n-                                            FTP, etc.) from an\n-                                            .tar[.gz|bz2|xz] file\n-    install [options] <url> [ref]           Install a package via git\n-    install [options] <file>                Install a package directly from an\n-                                            .tar[.gz|bz2|xz] file\n-    uninstall [options] <name>              Remove a package by (meta) name\n-    uninstall [options] <uuid>              Remove a package by (meta) uuid\n-\n-Package installation options:\n-    --tests         Run crate tests before installing\n-\n-Package [un]installation options:\n-    -g              Work at the user level (~/.cargo/bin/ instead of\n-                    locally in ./.cargo/bin/ by default)\n-    -G              Work at the system level (/usr/local/lib/cargo/bin/)\n-\n-Other:\n-    -h, --help     Display this message\n+    print(\"Usage: cargo <cmd> [options] [args..]\n+e.g. cargo install <name>\n+\n+Where <cmd> is one of:\n+    init, install, list, search, sources,\n+    uninstall, usage\n+\n+Options:\n+\n+    -h, --help                  Display this message\n+    <cmd> -h, <cmd> --help      Display help for <cmd>\n+\");\n+}\n+\n+fn cmd_usage_init() {\n+    print(\"cargo init\n+\n+Re-initialize cargo in ~/.cargo. Clears all sources and then adds the\n+default sources from <www.rust-lang.org/sources.json>.\");\n+}\n+\n+fn cmd_usage_install() {\n+    print(\"cargo install\n+cargo install [source/]<name>[@version]\n+cargo install [source/]<uuid>[@version]\n+cargo install <git url> [ref]\n+cargo install <tarball url>\n+cargo install <tarball file>\n+\n+Options:\n+    --test      Run crate tests before installing\n+    -g          Install to the user level (~/.cargo/bin/ instead of\n+                locally in ./.cargo/bin/ by default)\n+    -G          Install to the system level (/usr/local/lib/cargo/bin/)\n+\n+Install a crate. If no arguments are supplied, it installs from\n+the current working directory. If a source is provided, only install\n+from that source, otherwise it installs from any source.\");\n+}\n+\n+fn cmd_usage_uninstall() {\n+    print(\"cargo uninstall [source/]<name>[@version]\n+cargo uninstall [source/]<uuid>[@version]\n+cargo uninstall <meta-name>[@version]\n+cargo uninstall <meta-uuid>[@version]\n+\n+Options:\n+    -g          Remove from the user level (~/.cargo/bin/ instead of\n+                locally in ./.cargo/bin/ by default)\n+    -G          Remove from the system level (/usr/local/lib/cargo/bin/)\n+\n+Remove a crate. If a source is provided, only remove\n+from that source, otherwise it removes from any source.\n+If a crate was installed directly (git, tarball, etc.), you can remove\n+it by metadata.\");\n+}\n+\n+fn cmd_usage_list() {\n+    print(\"cargo list [sources..]\n+\n+If no arguments are provided, list all sources and their packages.\n+If source names are provided, list those sources and their packages.\n \");\n }\n \n+fn cmd_usage_search() {\n+    print(\"cargo search <query | '*'> [tags..]\n+\n+Search packages.\");\n+}\n+\n+fn cmd_usage_sources() {\n+    print(\"cargo sources\n+cargo sources add <name> <url>\n+cargo sources remove <name>\n+cargo sources rename <name> <new>\n+cargo sources set-url <name> <url>\n+cargo sources set-method <name> <method>\n+\n+If no arguments are supplied, list all sources (but not their packages).\n+\n+Commands:\n+    add             Add a source. The source method will be guessed\n+                    from the URL.\n+    remove          Remove a source.\n+    rename          Rename a source.\n+    set-url         Change the URL for a source.\n+    set-method      Change the method for a source.\");\n+}\n+\n fn main(argv: [str]) {\n     let o = build_cargo_options(argv);\n \n-    if vec::len(o.free) < 2u || o.help {\n+    if vec::len(o.free) < 2u {\n+        cmd_usage();\n+        ret;\n+    }\n+    if o.help {\n+        alt o.free[1] {\n+            \"init\" { cmd_usage_init(); }\n+            \"install\" { cmd_usage_install(); }\n+            \"uninstall\" { cmd_usage_uninstall(); }\n+            \"list\" { cmd_usage_list(); }\n+            \"search\" { cmd_usage_search(); }\n+            \"sources\" { cmd_usage_sources(); }\n+            _ { cmd_usage(); }\n+        }\n+        ret;\n+    }\n+    if o.free[1] == \"usage\" {\n         cmd_usage();\n         ret;\n     }\n \n     let mut c = configure(o);\n-    let mut sources = c.sources;\n     let home = c.root;\n+    let first_time = os::path_exists(path::connect(home, \"sources.json\"));\n \n-    if !os::path_exists(path::connect(home, \"sources.json\")) {\n+    if !first_time && o.free[1] != \"init\" {\n         cmd_init(c);\n-        try_parse_sources(path::connect(home, \"sources.json\"), sources);\n-        try_parse_sources(path::connect(home, \"local-sources.json\"), sources);\n-\n-        for sources.each_value { |v|\n-            sync_one(c, v.name, v);\n-        }\n \n         // FIXME: shouldn't need to reconfigure\n         c = configure(o);\n@@ -1165,8 +1918,10 @@ fn main(argv: [str]) {\n         \"uninstall\" { cmd_uninstall(c); }\n         \"list\" { cmd_list(c); }\n         \"search\" { cmd_search(c); }\n-        \"sync\" { cmd_sync(c); }\n-        \"usage\" { cmd_usage(); }\n+        \"sources\" { cmd_sources(c); }\n         _ { cmd_usage(); }\n     }\n+\n+    dump_cache(c);\n+    dump_sources(c);\n }"}]}