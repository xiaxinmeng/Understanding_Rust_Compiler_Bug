{"sha": "38357ebef48aba5ac134dbc32adb445a08db1e20", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM4MzU3ZWJlZjQ4YWJhNWFjMTM0ZGJjMzJhZGI0NDVhMDhkYjFlMjA=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-08-11T17:36:36Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-08-11T17:59:46Z"}, "message": "typeck/check/method: Remove `pub` from most methods", "tree": {"sha": "432fa4e516ac529867e73c092c9e15a2949da7ce", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/432fa4e516ac529867e73c092c9e15a2949da7ce"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/38357ebef48aba5ac134dbc32adb445a08db1e20", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/38357ebef48aba5ac134dbc32adb445a08db1e20", "html_url": "https://github.com/rust-lang/rust/commit/38357ebef48aba5ac134dbc32adb445a08db1e20", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/38357ebef48aba5ac134dbc32adb445a08db1e20/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "38b2e2980e6e30eca28d059428cd6eec3182ef9b", "url": "https://api.github.com/repos/rust-lang/rust/commits/38b2e2980e6e30eca28d059428cd6eec3182ef9b", "html_url": "https://github.com/rust-lang/rust/commit/38b2e2980e6e30eca28d059428cd6eec3182ef9b"}], "stats": {"total": 62, "additions": 33, "deletions": 29}, "files": [{"sha": "408f5989d60a9a07fa5243b6c1244bbe448955d8", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 33, "deletions": 29, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/38357ebef48aba5ac134dbc32adb445a08db1e20/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38357ebef48aba5ac134dbc32adb445a08db1e20/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=38357ebef48aba5ac134dbc32adb445a08db1e20", "patch": "@@ -247,7 +247,7 @@ impl<'self> LookupContext<'self> {\n         self.search_for_autosliced_method(self_ty, autoderefs)\n     }\n \n-    pub fn deref(&self, ty: ty::t)\n+    fn deref(&self, ty: ty::t)\n                  -> Option<ty::t> {\n         match ty::deref(self.tcx(), ty, false) {\n             None => None,\n@@ -262,7 +262,12 @@ impl<'self> LookupContext<'self> {\n     // ______________________________________________________________________\n     // Candidate collection (see comment at start of file)\n \n-    pub fn push_inherent_candidates(&self, self_ty: ty::t) {\n+    fn reset_candidates(&self) {\n+        *self.inherent_candidates = ~[];\n+        *self.extension_candidates = ~[];\n+    }\n+\n+    fn push_inherent_candidates(&self, self_ty: ty::t) {\n         /*!\n          * Collect all inherent candidates into\n          * `self.inherent_candidates`.  See comment at the start of\n@@ -403,7 +408,7 @@ impl<'self> LookupContext<'self> {\n     }\n \n \n-    pub fn push_inherent_candidates_from_self(&self,\n+    fn push_inherent_candidates_from_self(&self,\n                                               self_ty: ty::t,\n                                               did: def_id) {\n         let tcx = self.tcx();\n@@ -413,7 +418,7 @@ impl<'self> LookupContext<'self> {\n             self_ty, &[trait_ref], param_self);\n     }\n \n-    pub fn push_inherent_candidates_from_bounds(&self,\n+    fn push_inherent_candidates_from_bounds(&self,\n                                                 self_ty: ty::t,\n                                                 bounds: &[@TraitRef],\n                                                 param: param_index) {\n@@ -459,7 +464,7 @@ impl<'self> LookupContext<'self> {\n     }\n \n \n-    pub fn push_inherent_impl_candidates_for_type(&self, did: def_id) {\n+    fn push_inherent_impl_candidates_for_type(&self, did: def_id) {\n         let opt_impl_infos = self.tcx().inherent_impls.find(&did);\n         for impl_infos in opt_impl_infos.iter() {\n             for impl_info in impl_infos.iter() {\n@@ -469,7 +474,7 @@ impl<'self> LookupContext<'self> {\n         }\n     }\n \n-    pub fn push_candidates_from_impl(&self,\n+    fn push_candidates_from_impl(&self,\n                                      candidates: &mut ~[Candidate],\n                                      impl_info: &ty::Impl) {\n         if !self.impl_dups.insert(impl_info.did) {\n@@ -512,7 +517,7 @@ impl<'self> LookupContext<'self> {\n     // ______________________________________________________________________\n     // Candidate selection (see comment at start of file)\n \n-    pub fn search_for_autoderefd_method(&self,\n+    fn search_for_autoderefd_method(&self,\n                                         self_ty: ty::t,\n                                         autoderefs: uint)\n                                         -> Option<method_map_entry> {\n@@ -531,12 +536,11 @@ impl<'self> LookupContext<'self> {\n         }\n     }\n \n-    pub fn consider_reborrow(&self,\n+    fn consider_reborrow(&self,\n                              self_ty: ty::t,\n                              autoderefs: uint)\n                              -> (ty::t, ty::AutoAdjustment) {\n         /*!\n-         *\n          * In the event that we are invoking a method with a receiver\n          * of a borrowed type like `&T`, `&mut T`, or `&mut [T]`,\n          * we will \"reborrow\" the receiver implicitly.  For example, if\n@@ -598,7 +602,7 @@ impl<'self> LookupContext<'self> {\n         }\n     }\n \n-    pub fn search_for_autosliced_method(&self,\n+    fn search_for_autosliced_method(&self,\n                                         self_ty: ty::t,\n                                         autoderefs: uint)\n                                         -> Option<method_map_entry> {\n@@ -664,7 +668,7 @@ impl<'self> LookupContext<'self> {\n         }\n     }\n \n-    pub fn search_for_autoptrd_method(&self, self_ty: ty::t, autoderefs: uint)\n+    fn search_for_autoptrd_method(&self, self_ty: ty::t, autoderefs: uint)\n                                       -> Option<method_map_entry> {\n         /*!\n          *\n@@ -696,7 +700,7 @@ impl<'self> LookupContext<'self> {\n         }\n     }\n \n-    pub fn search_for_some_kind_of_autorefd_method(\n+    fn search_for_some_kind_of_autorefd_method(\n         &self,\n         kind: &fn(Region, ast::mutability) -> ty::AutoRef,\n         autoderefs: uint,\n@@ -725,7 +729,7 @@ impl<'self> LookupContext<'self> {\n         return None;\n     }\n \n-    pub fn search_for_method(&self, rcvr_ty: ty::t)\n+    fn search_for_method(&self, rcvr_ty: ty::t)\n                              -> Option<method_map_entry> {\n         debug!(\"search_for_method(rcvr_ty=%s)\", self.ty_to_str(rcvr_ty));\n         let _indenter = indenter();\n@@ -753,7 +757,7 @@ impl<'self> LookupContext<'self> {\n         }\n     }\n \n-    pub fn consider_candidates(&self,\n+    fn consider_candidates(&self,\n                                rcvr_ty: ty::t,\n                                candidates: &mut ~[Candidate])\n                                -> Option<method_map_entry> {\n@@ -780,7 +784,7 @@ impl<'self> LookupContext<'self> {\n         Some(self.confirm_candidate(rcvr_ty, &relevant_candidates[0]))\n     }\n \n-    pub fn merge_candidates(&self, candidates: &[Candidate]) -> ~[Candidate] {\n+    fn merge_candidates(&self, candidates: &[Candidate]) -> ~[Candidate] {\n         let mut merged = ~[];\n         let mut i = 0;\n         while i < candidates.len() {\n@@ -826,7 +830,7 @@ impl<'self> LookupContext<'self> {\n         return merged;\n     }\n \n-    pub fn confirm_candidate(&self, rcvr_ty: ty::t, candidate: &Candidate)\n+    fn confirm_candidate(&self, rcvr_ty: ty::t, candidate: &Candidate)\n                              -> method_map_entry {\n         let tcx = self.tcx();\n         let fty = self.fn_ty_from_origin(&candidate.origin);\n@@ -1108,7 +1112,7 @@ impl<'self> LookupContext<'self> {\n         }\n     }\n \n-    pub fn fn_ty_from_origin(&self, origin: &method_origin) -> ty::t {\n+    fn fn_ty_from_origin(&self, origin: &method_origin) -> ty::t {\n         return match *origin {\n             method_static(did) => {\n                 ty::lookup_item_type(self.tcx(), did).ty\n@@ -1129,7 +1133,7 @@ impl<'self> LookupContext<'self> {\n         }\n     }\n \n-    pub fn report_candidate(&self, idx: uint, origin: &method_origin) {\n+    fn report_candidate(&self, idx: uint, origin: &method_origin) {\n         match *origin {\n             method_static(impl_did) => {\n                 self.report_static_candidate(idx, impl_did)\n@@ -1143,7 +1147,7 @@ impl<'self> LookupContext<'self> {\n         }\n     }\n \n-    pub fn report_static_candidate(&self, idx: uint, did: def_id) {\n+    fn report_static_candidate(&self, idx: uint, did: def_id) {\n         let span = if did.crate == ast::LOCAL_CRATE {\n             match self.tcx().items.find(&did.node) {\n               Some(&ast_map::node_method(m, _, _)) => m.span,\n@@ -1159,15 +1163,15 @@ impl<'self> LookupContext<'self> {\n                  ty::item_path_str(self.tcx(), did)));\n     }\n \n-    pub fn report_param_candidate(&self, idx: uint, did: def_id) {\n+    fn report_param_candidate(&self, idx: uint, did: def_id) {\n         self.tcx().sess.span_note(\n             self.expr.span,\n             fmt!(\"candidate #%u derives from the bound `%s`\",\n                  (idx+1u),\n                  ty::item_path_str(self.tcx(), did)));\n     }\n \n-    pub fn report_trait_candidate(&self, idx: uint, did: def_id) {\n+    fn report_trait_candidate(&self, idx: uint, did: def_id) {\n         self.tcx().sess.span_note(\n             self.expr.span,\n             fmt!(\"candidate #%u derives from the type of the receiver, \\\n@@ -1176,31 +1180,31 @@ impl<'self> LookupContext<'self> {\n                  ty::item_path_str(self.tcx(), did)));\n     }\n \n-    pub fn infcx(&self) -> @mut infer::InferCtxt {\n+    fn infcx(&self) -> @mut infer::InferCtxt {\n         self.fcx.inh.infcx\n     }\n \n-    pub fn tcx(&self) -> ty::ctxt {\n+    fn tcx(&self) -> ty::ctxt {\n         self.fcx.tcx()\n     }\n \n-    pub fn ty_to_str(&self, t: ty::t) -> ~str {\n+    fn ty_to_str(&self, t: ty::t) -> ~str {\n         self.fcx.infcx().ty_to_str(t)\n     }\n \n-    pub fn cand_to_str(&self, cand: &Candidate) -> ~str {\n+    fn cand_to_str(&self, cand: &Candidate) -> ~str {\n         fmt!(\"Candidate(rcvr_ty=%s, rcvr_substs=%s, origin=%?)\",\n-             self.ty_to_str(cand.rcvr_ty),\n+             cand.rcvr_match_condition.repr(self.tcx()),\n              ty::substs_to_str(self.tcx(), &cand.rcvr_substs),\n              cand.origin)\n     }\n \n-    pub fn did_to_str(&self, did: def_id) -> ~str {\n+    fn did_to_str(&self, did: def_id) -> ~str {\n         ty::item_path_str(self.tcx(), did)\n     }\n \n-    pub fn bug(&self, s: ~str) -> ! {\n-        self.tcx().sess.bug(s)\n+    fn bug(&self, s: ~str) -> ! {\n+        self.tcx().sess.span_bug(self.self_expr.span, s)\n     }\n }\n "}]}