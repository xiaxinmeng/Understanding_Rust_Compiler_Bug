{"sha": "e8e82ce032f8678929b015e6f70ac060bb2cf94c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU4ZTgyY2UwMzJmODY3ODkyOWIwMTVlNmY3MGFjMDYwYmIyY2Y5NGM=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-01-14T20:58:20Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-01-14T20:58:20Z"}, "message": "Merge #485\n\n485: Add type inference for a bunch of primitives r=flodiebold a=marcusklaas\n\nThis PR adds inference for `&str`, `&[u8]`, `char`, `bool`, floats and integers. For floats and integers it uses type variables to infer the exact type, i.e. `u32`, from context when it's not annotated explicitly.\r\n\r\nI'm not quite happy with the implementation yet, but I think it mostly works now.\n\nCo-authored-by: Marcus Klaas de Vries <mail@marcusklaas.nl>", "tree": {"sha": "9fb158e9f7115bb70cf2b8623b70710c55497ed4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9fb158e9f7115bb70cf2b8623b70710c55497ed4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e8e82ce032f8678929b015e6f70ac060bb2cf94c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e8e82ce032f8678929b015e6f70ac060bb2cf94c", "html_url": "https://github.com/rust-lang/rust/commit/e8e82ce032f8678929b015e6f70ac060bb2cf94c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e8e82ce032f8678929b015e6f70ac060bb2cf94c/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "784ff638e549a27503b719e5c2f0009b40d25364", "url": "https://api.github.com/repos/rust-lang/rust/commits/784ff638e549a27503b719e5c2f0009b40d25364", "html_url": "https://github.com/rust-lang/rust/commit/784ff638e549a27503b719e5c2f0009b40d25364"}, {"sha": "37ba237e6686d94783d1f025d23823ad7c0cb0c8", "url": "https://api.github.com/repos/rust-lang/rust/commits/37ba237e6686d94783d1f025d23823ad7c0cb0c8", "html_url": "https://github.com/rust-lang/rust/commit/37ba237e6686d94783d1f025d23823ad7c0cb0c8"}], "stats": {"total": 755, "additions": 625, "deletions": 130}, "files": [{"sha": "5081466a2f075ae06de8ac5023980cd8e766329a", "filename": "crates/ra_hir/src/expr.rs", "status": "modified", "additions": 54, "deletions": 2, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/e8e82ce032f8678929b015e6f70ac060bb2cf94c/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8e82ce032f8678929b015e6f70ac060bb2cf94c/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr.rs?ref=e8e82ce032f8678929b015e6f70ac060bb2cf94c", "patch": "@@ -5,9 +5,12 @@ use rustc_hash::FxHashMap;\n \n use ra_arena::{Arena, RawId, impl_arena_id, map::ArenaMap};\n use ra_db::{LocalSyntaxPtr, Cancelable};\n-use ra_syntax::ast::{self, AstNode, LoopBodyOwner, ArgListOwner, NameOwner};\n+use ra_syntax::{\n+    ast::{self, AstNode, LoopBodyOwner, ArgListOwner, NameOwner, LiteralFlavor}\n+};\n \n use crate::{Path, type_ref::{Mutability, TypeRef}, Name, HirDatabase, DefId, Def, name::AsName};\n+use crate::ty::primitive::{UintTy, UncertainIntTy, UncertainFloatTy};\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub struct ExprId(RawId);\n@@ -103,6 +106,16 @@ impl BodySyntaxMapping {\n     }\n }\n \n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub enum Literal {\n+    String(String),\n+    ByteString(Vec<u8>),\n+    Char(char),\n+    Bool(bool),\n+    Int(u64, UncertainIntTy),\n+    Float(u64, UncertainFloatTy), // FIXME: f64 is not Eq\n+}\n+\n #[derive(Debug, Clone, Eq, PartialEq)]\n pub enum Expr {\n     /// This is produced if syntax tree does not have a required expression piece.\n@@ -186,6 +199,7 @@ pub enum Expr {\n     Tuple {\n         exprs: Vec<ExprId>,\n     },\n+    Literal(Literal),\n }\n \n pub use ra_syntax::ast::PrefixOp as UnaryOp;\n@@ -305,6 +319,7 @@ impl Expr {\n                     f(*expr);\n                 }\n             }\n+            Expr::Literal(_) => {}\n         }\n     }\n }\n@@ -633,13 +648,50 @@ impl ExprCollector {\n                 let exprs = e.exprs().map(|expr| self.collect_expr(expr)).collect();\n                 self.alloc_expr(Expr::Tuple { exprs }, syntax_ptr)\n             }\n+            ast::ExprKind::Literal(e) => {\n+                let child = if let Some(child) = e.literal_expr() {\n+                    child\n+                } else {\n+                    return self.alloc_expr(Expr::Missing, syntax_ptr);\n+                };\n+\n+                let lit = match child.flavor() {\n+                    LiteralFlavor::IntNumber { suffix } => {\n+                        let known_name = suffix\n+                            .map(|s| Name::new(s))\n+                            .and_then(|name| UncertainIntTy::from_name(&name));\n+\n+                        Literal::Int(\n+                            Default::default(),\n+                            known_name.unwrap_or(UncertainIntTy::Unknown),\n+                        )\n+                    }\n+                    LiteralFlavor::FloatNumber { suffix } => {\n+                        let known_name = suffix\n+                            .map(|s| Name::new(s))\n+                            .and_then(|name| UncertainFloatTy::from_name(&name));\n+\n+                        Literal::Float(\n+                            Default::default(),\n+                            known_name.unwrap_or(UncertainFloatTy::Unknown),\n+                        )\n+                    }\n+                    LiteralFlavor::ByteString => Literal::ByteString(Default::default()),\n+                    LiteralFlavor::String => Literal::String(Default::default()),\n+                    LiteralFlavor::Byte => {\n+                        Literal::Int(Default::default(), UncertainIntTy::Unsigned(UintTy::U8))\n+                    }\n+                    LiteralFlavor::Bool => Literal::Bool(Default::default()),\n+                    LiteralFlavor::Char => Literal::Char(Default::default()),\n+                };\n+                self.alloc_expr(Expr::Literal(lit), syntax_ptr)\n+            }\n \n             // TODO implement HIR for these:\n             ast::ExprKind::Label(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n             ast::ExprKind::IndexExpr(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n             ast::ExprKind::ArrayExpr(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n             ast::ExprKind::RangeExpr(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n-            ast::ExprKind::Literal(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n         }\n     }\n "}, {"sha": "8d786d2ac57a7dbd2e2161d3f5fc4e4c733ecd45", "filename": "crates/ra_hir/src/name.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8e82ce032f8678929b015e6f70ac060bb2cf94c/crates%2Fra_hir%2Fsrc%2Fname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8e82ce032f8678929b015e6f70ac060bb2cf94c/crates%2Fra_hir%2Fsrc%2Fname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fname.rs?ref=e8e82ce032f8678929b015e6f70ac060bb2cf94c", "patch": "@@ -23,7 +23,7 @@ impl fmt::Debug for Name {\n }\n \n impl Name {\n-    fn new(text: SmolStr) -> Name {\n+    pub(crate) fn new(text: SmolStr) -> Name {\n         Name { text }\n     }\n "}, {"sha": "5579db8fbcdececf7e9887623918c50d20df8f60", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 104, "deletions": 44, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/e8e82ce032f8678929b015e6f70ac060bb2cf94c/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8e82ce032f8678929b015e6f70ac060bb2cf94c/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=e8e82ce032f8678929b015e6f70ac060bb2cf94c", "patch": "@@ -14,7 +14,7 @@\n //! rustc.\n \n mod autoderef;\n-mod primitive;\n+pub(crate) mod primitive;\n #[cfg(test)]\n mod tests;\n pub(crate) mod method_resolution;\n@@ -38,7 +38,7 @@ use crate::{\n     db::HirDatabase,\n     type_ref::{TypeRef, Mutability},\n     name::KnownName,\n-    expr::{Body, Expr, ExprId, PatId, UnaryOp, BinaryOp, Statement},\n+    expr::{Body, Expr, Literal, ExprId, PatId, UnaryOp, BinaryOp, Statement},\n };\n \n fn transpose<T>(x: Cancelable<Option<T>>) -> Option<Cancelable<T>> {\n@@ -107,13 +107,35 @@ impl UnifyValue for TypeVarValue {\n     }\n }\n \n-/// The kinds of placeholders we need during type inference. Currently, we only\n-/// have type variables; in the future, we will probably also need int and float\n-/// variables, for inference of literal values (e.g. `100` could be one of\n+/// The kinds of placeholders we need during type inference. There's separate\n+/// values for general types, and for integer and float variables. The latter\n+/// two are used for inference of literal values (e.g. `100` could be one of\n /// several integer types).\n-#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n pub enum InferTy {\n     TypeVar(TypeVarId),\n+    IntVar(TypeVarId),\n+    FloatVar(TypeVarId),\n+}\n+\n+impl InferTy {\n+    fn to_inner(self) -> TypeVarId {\n+        match self {\n+            InferTy::TypeVar(ty) | InferTy::IntVar(ty) | InferTy::FloatVar(ty) => ty,\n+        }\n+    }\n+\n+    fn fallback_value(self) -> Ty {\n+        match self {\n+            InferTy::TypeVar(..) => Ty::Unknown,\n+            InferTy::IntVar(..) => {\n+                Ty::Int(primitive::UncertainIntTy::Signed(primitive::IntTy::I32))\n+            }\n+            InferTy::FloatVar(..) => {\n+                Ty::Float(primitive::UncertainFloatTy::Known(primitive::FloatTy::F64))\n+            }\n+        }\n+    }\n }\n \n /// When inferring an expression, we propagate downward whatever type hint we\n@@ -151,14 +173,11 @@ pub enum Ty {\n     /// (a non-surrogate code point). Written as `char`.\n     Char,\n \n-    /// A primitive signed integer type. For example, `i32`.\n-    Int(primitive::IntTy),\n-\n-    /// A primitive unsigned integer type. For example, `u32`.\n-    Uint(primitive::UintTy),\n+    /// A primitive integer type. For example, `i32`.\n+    Int(primitive::UncertainIntTy),\n \n     /// A primitive floating-point type. For example, `f64`.\n-    Float(primitive::FloatTy),\n+    Float(primitive::UncertainFloatTy),\n \n     /// Structures, enumerations and unions.\n     Adt {\n@@ -198,8 +217,9 @@ pub enum Ty {\n     // above function pointer type. Once we implement generics, we will probably\n     // need this as well.\n \n-    // A trait, defined with `dyn trait`.\n+    // A trait, defined with `dyn Trait`.\n     // Dynamic(),\n+\n     // The anonymous type of a closure. Used to represent the type of\n     // `|a| a`.\n     // Closure(DefId, ClosureSubsts<'tcx>),\n@@ -312,20 +332,19 @@ impl Ty {\n         path: &Path,\n     ) -> Cancelable<Self> {\n         if let Some(name) = path.as_ident() {\n-            if let Some(KnownName::Bool) = name.as_known_name() {\n-                return Ok(Ty::Bool);\n-            } else if let Some(KnownName::Char) = name.as_known_name() {\n-                return Ok(Ty::Char);\n-            } else if let Some(KnownName::Str) = name.as_known_name() {\n-                return Ok(Ty::Str);\n-            } else if let Some(int_ty) = primitive::IntTy::from_name(name) {\n+            if let Some(int_ty) = primitive::UncertainIntTy::from_name(name) {\n                 return Ok(Ty::Int(int_ty));\n-            } else if let Some(uint_ty) = primitive::UintTy::from_name(name) {\n-                return Ok(Ty::Uint(uint_ty));\n-            } else if let Some(float_ty) = primitive::FloatTy::from_name(name) {\n+            } else if let Some(float_ty) = primitive::UncertainFloatTy::from_name(name) {\n                 return Ok(Ty::Float(float_ty));\n             } else if name.as_known_name() == Some(KnownName::SelfType) {\n                 return Ty::from_hir_opt(db, module, None, impl_block.map(|i| i.target_type()));\n+            } else if let Some(known) = name.as_known_name() {\n+                match known {\n+                    KnownName::Bool => return Ok(Ty::Bool),\n+                    KnownName::Char => return Ok(Ty::Char),\n+                    KnownName::Str => return Ok(Ty::Str),\n+                    _ => {}\n+                }\n             }\n         }\n \n@@ -392,7 +411,6 @@ impl fmt::Display for Ty {\n             Ty::Bool => write!(f, \"bool\"),\n             Ty::Char => write!(f, \"char\"),\n             Ty::Int(t) => write!(f, \"{}\", t.ty_to_string()),\n-            Ty::Uint(t) => write!(f, \"{}\", t.ty_to_string()),\n             Ty::Float(t) => write!(f, \"{}\", t.ty_to_string()),\n             Ty::Str => write!(f, \"str\"),\n             Ty::Slice(t) => write!(f, \"[{}]\", t),\n@@ -587,7 +605,7 @@ fn binary_op_return_ty(op: BinaryOp, rhs_ty: Ty) -> Ty {\n         | BinaryOp::BitwiseAnd\n         | BinaryOp::BitwiseOr\n         | BinaryOp::BitwiseXor => match rhs_ty {\n-            Ty::Uint(..) | Ty::Int(..) | Ty::Float(..) => rhs_ty,\n+            Ty::Int(..) | Ty::Float(..) => rhs_ty,\n             _ => Ty::Unknown,\n         },\n         BinaryOp::RangeRightOpen | BinaryOp::RangeRightClosed => Ty::Unknown,\n@@ -598,7 +616,7 @@ fn binary_op_rhs_expectation(op: BinaryOp, lhs_ty: Ty) -> Ty {\n     match op {\n         BinaryOp::BooleanAnd | BinaryOp::BooleanOr => Ty::Bool,\n         BinaryOp::Assignment | BinaryOp::EqualityTest => match lhs_ty {\n-            Ty::Uint(..) | Ty::Int(..) | Ty::Float(..) | Ty::Str | Ty::Char | Ty::Bool => lhs_ty,\n+            Ty::Int(..) | Ty::Float(..) | Ty::Str | Ty::Char | Ty::Bool => lhs_ty,\n             _ => Ty::Unknown,\n         },\n         BinaryOp::LesserEqualTest\n@@ -625,7 +643,7 @@ fn binary_op_rhs_expectation(op: BinaryOp, lhs_ty: Ty) -> Ty {\n         | BinaryOp::BitwiseAnd\n         | BinaryOp::BitwiseOr\n         | BinaryOp::BitwiseXor => match lhs_ty {\n-            Ty::Uint(..) | Ty::Int(..) | Ty::Float(..) => lhs_ty,\n+            Ty::Int(..) | Ty::Float(..) => lhs_ty,\n             _ => Ty::Unknown,\n         },\n         _ => Ty::Unknown,\n@@ -695,13 +713,17 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         match (&*ty1, &*ty2) {\n             (Ty::Unknown, ..) => true,\n             (.., Ty::Unknown) => true,\n-            (Ty::Bool, _)\n-            | (Ty::Str, _)\n-            | (Ty::Never, _)\n-            | (Ty::Char, _)\n-            | (Ty::Int(..), Ty::Int(..))\n-            | (Ty::Uint(..), Ty::Uint(..))\n-            | (Ty::Float(..), Ty::Float(..)) => ty1 == ty2,\n+            (Ty::Int(t1), Ty::Int(t2)) => match (t1, t2) {\n+                (primitive::UncertainIntTy::Unknown, _)\n+                | (_, primitive::UncertainIntTy::Unknown) => true,\n+                _ => t1 == t2,\n+            },\n+            (Ty::Float(t1), Ty::Float(t2)) => match (t1, t2) {\n+                (primitive::UncertainFloatTy::Unknown, _)\n+                | (_, primitive::UncertainFloatTy::Unknown) => true,\n+                _ => t1 == t2,\n+            },\n+            (Ty::Bool, _) | (Ty::Str, _) | (Ty::Never, _) | (Ty::Char, _) => ty1 == ty2,\n             (\n                 Ty::Adt {\n                     def_id: def_id1, ..\n@@ -718,12 +740,19 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 .iter()\n                 .zip(ts2.iter())\n                 .all(|(t1, t2)| self.unify(t1, t2)),\n-            (Ty::Infer(InferTy::TypeVar(tv1)), Ty::Infer(InferTy::TypeVar(tv2))) => {\n+            (Ty::Infer(InferTy::TypeVar(tv1)), Ty::Infer(InferTy::TypeVar(tv2)))\n+            | (Ty::Infer(InferTy::IntVar(tv1)), Ty::Infer(InferTy::IntVar(tv2)))\n+            | (Ty::Infer(InferTy::FloatVar(tv1)), Ty::Infer(InferTy::FloatVar(tv2))) => {\n                 // both type vars are unknown since we tried to resolve them\n                 self.var_unification_table.union(*tv1, *tv2);\n                 true\n             }\n-            (Ty::Infer(InferTy::TypeVar(tv)), other) | (other, Ty::Infer(InferTy::TypeVar(tv))) => {\n+            (Ty::Infer(InferTy::TypeVar(tv)), other)\n+            | (other, Ty::Infer(InferTy::TypeVar(tv)))\n+            | (Ty::Infer(InferTy::IntVar(tv)), other)\n+            | (other, Ty::Infer(InferTy::IntVar(tv)))\n+            | (Ty::Infer(InferTy::FloatVar(tv)), other)\n+            | (other, Ty::Infer(InferTy::FloatVar(tv))) => {\n                 // the type var is unknown since we tried to resolve it\n                 self.var_unification_table\n                     .union_value(*tv, TypeVarValue::Known(other.clone()));\n@@ -739,10 +768,24 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         ))\n     }\n \n+    fn new_integer_var(&mut self) -> Ty {\n+        Ty::Infer(InferTy::IntVar(\n+            self.var_unification_table.new_key(TypeVarValue::Unknown),\n+        ))\n+    }\n+\n+    fn new_float_var(&mut self) -> Ty {\n+        Ty::Infer(InferTy::FloatVar(\n+            self.var_unification_table.new_key(TypeVarValue::Unknown),\n+        ))\n+    }\n+\n     /// Replaces Ty::Unknown by a new type var, so we can maybe still infer it.\n     fn insert_type_vars_shallow(&mut self, ty: Ty) -> Ty {\n         match ty {\n             Ty::Unknown => self.new_type_var(),\n+            Ty::Int(primitive::UncertainIntTy::Unknown) => self.new_integer_var(),\n+            Ty::Float(primitive::UncertainFloatTy::Unknown) => self.new_float_var(),\n             _ => ty,\n         }\n     }\n@@ -757,12 +800,13 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     /// known type.\n     fn resolve_ty_as_possible(&mut self, ty: Ty) -> Ty {\n         ty.fold(&mut |ty| match ty {\n-            Ty::Infer(InferTy::TypeVar(tv)) => {\n-                if let Some(known_ty) = self.var_unification_table.probe_value(tv).known() {\n+            Ty::Infer(tv) => {\n+                let inner = tv.to_inner();\n+                if let Some(known_ty) = self.var_unification_table.probe_value(inner).known() {\n                     // known_ty may contain other variables that are known by now\n                     self.resolve_ty_as_possible(known_ty.clone())\n                 } else {\n-                    Ty::Infer(InferTy::TypeVar(tv))\n+                    ty\n                 }\n             }\n             _ => ty,\n@@ -773,8 +817,9 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     /// otherwise, return ty.\n     fn resolve_ty_shallow<'b>(&mut self, ty: &'b Ty) -> Cow<'b, Ty> {\n         match ty {\n-            Ty::Infer(InferTy::TypeVar(tv)) => {\n-                match self.var_unification_table.probe_value(*tv).known() {\n+            Ty::Infer(tv) => {\n+                let inner = tv.to_inner();\n+                match self.var_unification_table.probe_value(inner).known() {\n                     Some(known_ty) => {\n                         // The known_ty can't be a type var itself\n                         Cow::Owned(known_ty.clone())\n@@ -790,12 +835,13 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     /// replaced by Ty::Unknown.\n     fn resolve_ty_completely(&mut self, ty: Ty) -> Ty {\n         ty.fold(&mut |ty| match ty {\n-            Ty::Infer(InferTy::TypeVar(tv)) => {\n-                if let Some(known_ty) = self.var_unification_table.probe_value(tv).known() {\n+            Ty::Infer(tv) => {\n+                let inner = tv.to_inner();\n+                if let Some(known_ty) = self.var_unification_table.probe_value(inner).known() {\n                     // known_ty may contain other variables that are known by now\n                     self.resolve_ty_completely(known_ty.clone())\n                 } else {\n-                    Ty::Unknown\n+                    tv.fallback_value()\n                 }\n             }\n             _ => ty,\n@@ -1067,6 +1113,20 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n \n                 Ty::Tuple(Arc::from(ty_vec))\n             }\n+            Expr::Literal(lit) => match lit {\n+                Literal::Bool(..) => Ty::Bool,\n+                Literal::String(..) => Ty::Ref(Arc::new(Ty::Str), Mutability::Shared),\n+                Literal::ByteString(..) => {\n+                    let byte_type = Arc::new(Ty::Int(primitive::UncertainIntTy::Unsigned(\n+                        primitive::UintTy::U8,\n+                    )));\n+                    let slice_type = Arc::new(Ty::Slice(byte_type));\n+                    Ty::Ref(slice_type, Mutability::Shared)\n+                }\n+                Literal::Char(..) => Ty::Char,\n+                Literal::Int(_v, ty) => Ty::Int(*ty),\n+                Literal::Float(_v, ty) => Ty::Float(*ty),\n+            },\n         };\n         // use a new type variable if we got Ty::Unknown here\n         let ty = self.insert_type_vars_shallow(ty);"}, {"sha": "5741ca90d3763ad397ddb4dd018be7bb70714655", "filename": "crates/ra_hir/src/ty/primitive.rs", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/e8e82ce032f8678929b015e6f70ac060bb2cf94c/crates%2Fra_hir%2Fsrc%2Fty%2Fprimitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8e82ce032f8678929b015e6f70ac060bb2cf94c/crates%2Fra_hir%2Fsrc%2Fty%2Fprimitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fprimitive.rs?ref=e8e82ce032f8678929b015e6f70ac060bb2cf94c", "patch": "@@ -2,6 +2,56 @@ use std::fmt;\n \n use crate::{Name, KnownName};\n \n+#[derive(Debug, Clone, Eq, PartialEq, Hash, Copy)]\n+pub enum UncertainIntTy {\n+    Unknown,\n+    Unsigned(UintTy),\n+    Signed(IntTy),\n+}\n+\n+impl UncertainIntTy {\n+    pub fn ty_to_string(&self) -> &'static str {\n+        match *self {\n+            UncertainIntTy::Unknown => \"{integer}\",\n+            UncertainIntTy::Signed(ty) => ty.ty_to_string(),\n+            UncertainIntTy::Unsigned(ty) => ty.ty_to_string(),\n+        }\n+    }\n+\n+    pub fn from_name(name: &Name) -> Option<UncertainIntTy> {\n+        if let Some(ty) = IntTy::from_name(name) {\n+            Some(UncertainIntTy::Signed(ty))\n+        } else if let Some(ty) = UintTy::from_name(name) {\n+            Some(UncertainIntTy::Unsigned(ty))\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Clone, Eq, PartialEq, Hash, Copy)]\n+pub enum UncertainFloatTy {\n+    Unknown,\n+    Known(FloatTy),\n+}\n+\n+impl UncertainFloatTy {\n+    pub fn ty_to_string(&self) -> &'static str {\n+        match *self {\n+            UncertainFloatTy::Unknown => \"{float}\",\n+            UncertainFloatTy::Known(ty) => ty.ty_to_string(),\n+        }\n+    }\n+\n+    pub fn from_name(name: &Name) -> Option<UncertainFloatTy> {\n+        if let Some(ty) = FloatTy::from_name(name) {\n+            Some(UncertainFloatTy::Known(ty))\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Copy)]\n pub enum IntTy {\n     Isize,"}, {"sha": "8aacb1a7fde5939b65cbe82943f2bd78c5f09f2a", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 27, "deletions": 3, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/e8e82ce032f8678929b015e6f70ac060bb2cf94c/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8e82ce032f8678929b015e6f70ac060bb2cf94c/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=e8e82ce032f8678929b015e6f70ac060bb2cf94c", "patch": "@@ -132,6 +132,32 @@ fn test(a: &u32, b: &mut u32, c: *const u32, d: *mut u32) {\n     );\n }\n \n+#[test]\n+fn infer_literals() {\n+    check_inference(\n+        r##\"\n+fn test() {\n+    5i32;\n+    \"hello\";\n+    b\"bytes\";\n+    'c';\n+    b'b';\n+    3.14;\n+    5000;\n+    false;\n+    true;\n+    r#\"\n+        //! doc\n+        // non-doc\n+        mod foo {}\n+        \"#;\n+    br#\"yolo\"#;\n+}\n+\"##,\n+        \"literals.txt\",\n+    );\n+}\n+\n #[test]\n fn infer_backwards() {\n     check_inference(\n@@ -180,7 +206,7 @@ fn f(x: bool) -> i32 {\n     0i32\n }\n \n-fn test() {\n+fn test() -> bool {\n     let x = a && b;\n     let y = true || false;\n     let z = x == y;\n@@ -277,8 +303,6 @@ fn test(x: &str, y: isize) {\n     let b = (a, x);\n     let c = (y, x);\n     let d = (c, x);\n-\n-    // we have not infered these case yet.\n     let e = (1, \"e\");\n     let f = (e, \"d\");\n }"}, {"sha": "e65fe07aa47fb81a9dd9651c953e1dbbbf39ec96", "filename": "crates/ra_hir/src/ty/tests/data/basics.txt", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e8e82ce032f8678929b015e6f70ac060bb2cf94c/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Fbasics.txt", "raw_url": "https://github.com/rust-lang/rust/raw/e8e82ce032f8678929b015e6f70ac060bb2cf94c/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Fbasics.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Fbasics.txt?ref=e8e82ce032f8678929b015e6f70ac060bb2cf94c", "patch": "@@ -7,7 +7,7 @@\n [55; 56) 'b': isize\n [62; 63) 'c': !\n [69; 70) 'd': &str\n-[76; 82) '1usize': [unknown]\n-[88; 94) '1isize': [unknown]\n-[100; 106) '\"test\"': [unknown]\n-[112; 118) '1.0f32': [unknown]\n+[76; 82) '1usize': usize\n+[88; 94) '1isize': isize\n+[100; 106) '\"test\"': &str\n+[112; 118) '1.0f32': f32"}, {"sha": "58a7276916f249b4c524bad06c621fa979dc50e5", "filename": "crates/ra_hir/src/ty/tests/data/binary_op.txt", "status": "modified", "additions": 43, "deletions": 43, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/e8e82ce032f8678929b015e6f70ac060bb2cf94c/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Fbinary_op.txt", "raw_url": "https://github.com/rust-lang/rust/raw/e8e82ce032f8678929b015e6f70ac060bb2cf94c/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Fbinary_op.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Fbinary_op.txt?ref=e8e82ce032f8678929b015e6f70ac060bb2cf94c", "patch": "@@ -1,46 +1,46 @@\n [6; 7) 'x': bool\n [22; 34) '{     0i32 }': i32\n [28; 32) '0i32': i32\n-[46; 342) '{     ... < 3 }': bool\n-[56; 57) 'x': bool\n-[60; 61) 'a': bool\n-[60; 66) 'a && b': bool\n-[65; 66) 'b': bool\n-[76; 77) 'y': bool\n-[80; 84) 'true': bool\n-[80; 93) 'true || false': bool\n-[88; 93) 'false': bool\n-[103; 104) 'z': bool\n-[107; 108) 'x': bool\n-[107; 113) 'x == y': bool\n-[112; 113) 'y': bool\n-[123; 134) 'minus_forty': isize\n-[144; 152) '-40isize': isize\n-[145; 152) '40isize': [unknown]\n-[162; 163) 'h': bool\n-[166; 177) 'minus_forty': isize\n-[166; 188) 'minus_...ONST_2': bool\n-[181; 188) 'CONST_2': isize\n-[198; 199) 'c': i32\n-[202; 203) 'f': fn(bool) -> i32\n-[202; 211) 'f(z || y)': i32\n-[202; 215) 'f(z || y) + 5': i32\n-[204; 205) 'z': bool\n-[204; 210) 'z || y': bool\n-[209; 210) 'y': bool\n-[214; 215) '5': i32\n-[225; 226) 'd': [unknown]\n-[229; 230) 'b': [unknown]\n-[240; 241) 'g': ()\n-[244; 255) 'minus_forty': isize\n-[244; 260) 'minus_...y ^= i': ()\n-[259; 260) 'i': isize\n-[270; 273) 'ten': usize\n-[283; 285) '10': usize\n-[295; 308) 'ten_is_eleven': bool\n-[311; 314) 'ten': usize\n-[311; 326) 'ten == some_num': bool\n-[318; 326) 'some_num': usize\n-[333; 336) 'ten': usize\n-[333; 340) 'ten < 3': bool\n-[339; 340) '3': usize\n+[54; 350) '{     ... < 3 }': bool\n+[64; 65) 'x': bool\n+[68; 69) 'a': bool\n+[68; 74) 'a && b': bool\n+[73; 74) 'b': bool\n+[84; 85) 'y': bool\n+[88; 92) 'true': bool\n+[88; 101) 'true || false': bool\n+[96; 101) 'false': bool\n+[111; 112) 'z': bool\n+[115; 116) 'x': bool\n+[115; 121) 'x == y': bool\n+[120; 121) 'y': bool\n+[131; 142) 'minus_forty': isize\n+[152; 160) '-40isize': isize\n+[153; 160) '40isize': isize\n+[170; 171) 'h': bool\n+[174; 185) 'minus_forty': isize\n+[174; 196) 'minus_...ONST_2': bool\n+[189; 196) 'CONST_2': isize\n+[206; 207) 'c': i32\n+[210; 211) 'f': fn(bool) -> i32\n+[210; 219) 'f(z || y)': i32\n+[210; 223) 'f(z || y) + 5': i32\n+[212; 213) 'z': bool\n+[212; 218) 'z || y': bool\n+[217; 218) 'y': bool\n+[222; 223) '5': i32\n+[233; 234) 'd': [unknown]\n+[237; 238) 'b': [unknown]\n+[248; 249) 'g': ()\n+[252; 263) 'minus_forty': isize\n+[252; 268) 'minus_...y ^= i': ()\n+[267; 268) 'i': isize\n+[278; 281) 'ten': usize\n+[291; 293) '10': usize\n+[303; 316) 'ten_is_eleven': bool\n+[319; 322) 'ten': usize\n+[319; 334) 'ten == some_num': bool\n+[326; 334) 'some_num': usize\n+[341; 344) 'ten': usize\n+[341; 348) 'ten < 3': bool\n+[347; 348) '3': usize"}, {"sha": "8815dba411b2de3772f05cecf52777b8418d553d", "filename": "crates/ra_hir/src/ty/tests/data/let.txt", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e8e82ce032f8678929b015e6f70ac060bb2cf94c/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Flet.txt", "raw_url": "https://github.com/rust-lang/rust/raw/e8e82ce032f8678929b015e6f70ac060bb2cf94c/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Flet.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Flet.txt?ref=e8e82ce032f8678929b015e6f70ac060bb2cf94c", "patch": "@@ -1,6 +1,6 @@\n [11; 71) '{     ...= b; }': ()\n-[21; 22) 'a': [unknown]\n-[25; 31) '1isize': [unknown]\n+[21; 22) 'a': isize\n+[25; 31) '1isize': isize\n [41; 42) 'b': usize\n [52; 53) '1': usize\n [63; 64) 'c': usize"}, {"sha": "84ee2c11b9ec497d490cdef2bc9a9ed96f5dd284", "filename": "crates/ra_hir/src/ty/tests/data/literals.txt", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e8e82ce032f8678929b015e6f70ac060bb2cf94c/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Fliterals.txt", "raw_url": "https://github.com/rust-lang/rust/raw/e8e82ce032f8678929b015e6f70ac060bb2cf94c/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Fliterals.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Fliterals.txt?ref=e8e82ce032f8678929b015e6f70ac060bb2cf94c", "patch": "@@ -0,0 +1,12 @@\n+[11; 201) '{     ...o\"#; }': ()\n+[17; 21) '5i32': i32\n+[27; 34) '\"hello\"': &str\n+[40; 48) 'b\"bytes\"': &[u8]\n+[54; 57) ''c'': char\n+[63; 67) 'b'b'': u8\n+[73; 77) '3.14': f64\n+[83; 87) '5000': i32\n+[93; 98) 'false': bool\n+[104; 108) 'true': bool\n+[114; 182) 'r#\"   ...    \"#': &str\n+[188; 198) 'br#\"yolo\"#': &[u8]"}, {"sha": "be9e12d024ac44f96f37e2c65ad792ed0b3cd0c6", "filename": "crates/ra_hir/src/ty/tests/data/struct.txt", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e8e82ce032f8678929b015e6f70ac060bb2cf94c/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Fstruct.txt", "raw_url": "https://github.com/rust-lang/rust/raw/e8e82ce032f8678929b015e6f70ac060bb2cf94c/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Fstruct.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Fstruct.txt?ref=e8e82ce032f8678929b015e6f70ac060bb2cf94c", "patch": "@@ -2,14 +2,14 @@\n [82; 83) 'c': [unknown]\n [86; 87) 'C': [unknown]\n [86; 90) 'C(1)': [unknown]\n-[88; 89) '1': [unknown]\n+[88; 89) '1': i32\n [96; 97) 'B': [unknown]\n [107; 108) 'a': A\n [114; 133) 'A { b:...C(1) }': A\n [121; 122) 'B': B\n [127; 128) 'C': [unknown]\n [127; 131) 'C(1)': C\n-[129; 130) '1': [unknown]\n+[129; 130) '1': i32\n [139; 140) 'a': A\n [139; 142) 'a.b': B\n [148; 149) 'a': A"}, {"sha": "a95d3c286e8e508f721b6eed9912850583288d0d", "filename": "crates/ra_hir/src/ty/tests/data/tuple.txt", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e8e82ce032f8678929b015e6f70ac060bb2cf94c/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Ftuple.txt", "raw_url": "https://github.com/rust-lang/rust/raw/e8e82ce032f8678929b015e6f70ac060bb2cf94c/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Ftuple.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Ftuple.txt?ref=e8e82ce032f8678929b015e6f70ac060bb2cf94c", "patch": "@@ -1,6 +1,6 @@\n [9; 10) 'x': &str\n [18; 19) 'y': isize\n-[28; 214) '{     ...d\"); }': ()\n+[28; 170) '{     ...d\"); }': ()\n [38; 39) 'a': (u32, &str)\n [55; 63) '(1, \"a\")': (u32, &str)\n [56; 57) '1': u32\n@@ -17,11 +17,11 @@\n [117; 123) '(c, x)': ((isize, &str), &str)\n [118; 119) 'c': (isize, &str)\n [121; 122) 'x': &str\n-[177; 178) 'e': ([unknown], [unknown])\n-[181; 189) '(1, \"e\")': ([unknown], [unknown])\n-[182; 183) '1': [unknown]\n-[185; 188) '\"e\"': [unknown]\n-[199; 200) 'f': (([unknown], [unknown]), [unknown])\n-[203; 211) '(e, \"d\")': (([unknown], [unknown]), [unknown])\n-[204; 205) 'e': ([unknown], [unknown])\n-[207; 210) '\"d\"': [unknown]\n+[133; 134) 'e': (i32, &str)\n+[137; 145) '(1, \"e\")': (i32, &str)\n+[138; 139) '1': i32\n+[141; 144) '\"e\"': &str\n+[155; 156) 'f': ((i32, &str), &str)\n+[159; 167) '(e, \"d\")': ((i32, &str), &str)\n+[160; 161) 'e': (i32, &str)\n+[163; 166) '\"d\"': &str"}, {"sha": "107b2383385390ecaedd6d3274b92edba63a7a25", "filename": "crates/ra_ide_api/src/hover.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e8e82ce032f8678929b015e6f70ac060bb2cf94c/crates%2Fra_ide_api%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8e82ce032f8678929b015e6f70ac060bb2cf94c/crates%2Fra_ide_api%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fhover.rs?ref=e8e82ce032f8678929b015e6f70ac060bb2cf94c", "patch": "@@ -230,20 +230,19 @@ mod tests {\n         assert_eq!(\"[unknown]\", &type_name);\n     }\n \n-    // FIXME: improve type_of to make this work\n     #[test]\n     fn test_type_of_for_expr_2() {\n         let (analysis, range) = single_file_with_range(\n             \"\n             fn main() {\n                 let foo: usize = 1;\n-                let bar = <|>1 + foo_test<|>;\n+                let bar = <|>1 + foo<|>;\n             }\n             \",\n         );\n \n         let type_name = analysis.type_of(range).unwrap().unwrap();\n-        assert_eq!(\"[unknown]\", &type_name);\n+        assert_eq!(\"usize\", &type_name);\n     }\n \n }"}, {"sha": "211ba31e573e580544fc10cc18e9b3f1a2f6789a", "filename": "crates/ra_syntax/src/ast.rs", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/e8e82ce032f8678929b015e6f70ac060bb2cf94c/crates%2Fra_syntax%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8e82ce032f8678929b015e6f70ac060bb2cf94c/crates%2Fra_syntax%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast.rs?ref=e8e82ce032f8678929b015e6f70ac060bb2cf94c", "patch": "@@ -609,6 +609,52 @@ impl SelfParam {\n     }\n }\n \n+#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n+pub enum LiteralFlavor {\n+    String,\n+    ByteString,\n+    Char,\n+    Byte,\n+    IntNumber { suffix: Option<SmolStr> },\n+    FloatNumber { suffix: Option<SmolStr> },\n+    Bool,\n+}\n+\n+impl LiteralExpr {\n+    pub fn flavor(&self) -> LiteralFlavor {\n+        let syntax = self.syntax();\n+        match syntax.kind() {\n+            INT_NUMBER => {\n+                let allowed_suffix_list = [\n+                    \"isize\", \"i128\", \"i64\", \"i32\", \"i16\", \"i8\", \"usize\", \"u128\", \"u64\", \"u32\",\n+                    \"u16\", \"u8\",\n+                ];\n+                let text = syntax.text().to_string();\n+                let suffix = allowed_suffix_list\n+                    .iter()\n+                    .find(|&s| text.ends_with(s))\n+                    .map(|&suf| SmolStr::new(suf));\n+                LiteralFlavor::IntNumber { suffix: suffix }\n+            }\n+            FLOAT_NUMBER => {\n+                let allowed_suffix_list = [\"f64\", \"f32\"];\n+                let text = syntax.text().to_string();\n+                let suffix = allowed_suffix_list\n+                    .iter()\n+                    .find(|&s| text.ends_with(s))\n+                    .map(|&suf| SmolStr::new(suf));\n+                LiteralFlavor::FloatNumber { suffix: suffix }\n+            }\n+            STRING | RAW_STRING => LiteralFlavor::String,\n+            TRUE_KW | FALSE_KW => LiteralFlavor::Bool,\n+            BYTE_STRING | RAW_BYTE_STRING => LiteralFlavor::ByteString,\n+            CHAR => LiteralFlavor::Char,\n+            BYTE => LiteralFlavor::Byte,\n+            _ => unreachable!(),\n+        }\n+    }\n+}\n+\n #[test]\n fn test_doc_comment_of_items() {\n     let file = SourceFile::parse("}, {"sha": "3471d52264666ec3bf9675abfc1fe1069c0e6155", "filename": "crates/ra_syntax/src/ast/generated.rs", "status": "modified", "additions": 219, "deletions": 1, "changes": 220, "blob_url": "https://github.com/rust-lang/rust/blob/e8e82ce032f8678929b015e6f70ac060bb2cf94c/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8e82ce032f8678929b015e6f70ac060bb2cf94c/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs?ref=e8e82ce032f8678929b015e6f70ac060bb2cf94c", "patch": "@@ -793,6 +793,31 @@ impl AstNode for ExternCrateItem {\n \n impl ExternCrateItem {}\n \n+// FalseKw\n+#[derive(Debug, PartialEq, Eq, Hash)]\n+#[repr(transparent)]\n+pub struct FalseKw {\n+    pub(crate) syntax: SyntaxNode,\n+}\n+unsafe impl TransparentNewType for FalseKw {\n+    type Repr = rowan::SyntaxNode<RaTypes>;\n+}\n+\n+impl AstNode for FalseKw {\n+    fn cast(syntax: &SyntaxNode) -> Option<&Self> {\n+        match syntax.kind() {\n+            FALSE_KW => Some(FalseKw::from_repr(syntax.into_repr())),\n+            _ => None,\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n+    fn to_owned(&self) -> TreeArc<FalseKw> { TreeArc::cast(self.syntax.to_owned()) }\n+}\n+\n+\n+impl ast::AstToken for FalseKw {}\n+impl FalseKw {}\n+\n // FieldExpr\n #[derive(Debug, PartialEq, Eq, Hash)]\n #[repr(transparent)]\n@@ -849,6 +874,31 @@ impl AstNode for FieldPatList {\n \n impl FieldPatList {}\n \n+// FloatNumber\n+#[derive(Debug, PartialEq, Eq, Hash)]\n+#[repr(transparent)]\n+pub struct FloatNumber {\n+    pub(crate) syntax: SyntaxNode,\n+}\n+unsafe impl TransparentNewType for FloatNumber {\n+    type Repr = rowan::SyntaxNode<RaTypes>;\n+}\n+\n+impl AstNode for FloatNumber {\n+    fn cast(syntax: &SyntaxNode) -> Option<&Self> {\n+        match syntax.kind() {\n+            FLOAT_NUMBER => Some(FloatNumber::from_repr(syntax.into_repr())),\n+            _ => None,\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n+    fn to_owned(&self) -> TreeArc<FloatNumber> { TreeArc::cast(self.syntax.to_owned()) }\n+}\n+\n+\n+impl ast::AstToken for FloatNumber {}\n+impl FloatNumber {}\n+\n // FnDef\n #[derive(Debug, PartialEq, Eq, Hash)]\n #[repr(transparent)]\n@@ -1130,6 +1180,31 @@ impl AstNode for IndexExpr {\n \n impl IndexExpr {}\n \n+// IntNumber\n+#[derive(Debug, PartialEq, Eq, Hash)]\n+#[repr(transparent)]\n+pub struct IntNumber {\n+    pub(crate) syntax: SyntaxNode,\n+}\n+unsafe impl TransparentNewType for IntNumber {\n+    type Repr = rowan::SyntaxNode<RaTypes>;\n+}\n+\n+impl AstNode for IntNumber {\n+    fn cast(syntax: &SyntaxNode) -> Option<&Self> {\n+        match syntax.kind() {\n+            INT_NUMBER => Some(IntNumber::from_repr(syntax.into_repr())),\n+            _ => None,\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n+    fn to_owned(&self) -> TreeArc<IntNumber> { TreeArc::cast(self.syntax.to_owned()) }\n+}\n+\n+\n+impl ast::AstToken for IntNumber {}\n+impl IntNumber {}\n+\n // ItemList\n #[derive(Debug, PartialEq, Eq, Hash)]\n #[repr(transparent)]\n@@ -1327,7 +1402,75 @@ impl AstNode for Literal {\n }\n \n \n-impl Literal {}\n+impl Literal {\n+    pub fn literal_expr(&self) -> Option<&LiteralExpr> {\n+        super::child_opt(self)\n+    }\n+}\n+\n+// LiteralExpr\n+#[derive(Debug, PartialEq, Eq, Hash)]\n+#[repr(transparent)]\n+pub struct LiteralExpr {\n+    pub(crate) syntax: SyntaxNode,\n+}\n+unsafe impl TransparentNewType for LiteralExpr {\n+    type Repr = rowan::SyntaxNode<RaTypes>;\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n+pub enum LiteralExprKind<'a> {\n+    String(&'a String),\n+    ByteString(&'a ByteString),\n+    RawString(&'a RawString),\n+    RawByteString(&'a RawByteString),\n+    Char(&'a Char),\n+    Byte(&'a Byte),\n+    IntNumber(&'a IntNumber),\n+    FloatNumber(&'a FloatNumber),\n+    TrueKw(&'a TrueKw),\n+    FalseKw(&'a FalseKw),\n+}\n+\n+impl AstNode for LiteralExpr {\n+    fn cast(syntax: &SyntaxNode) -> Option<&Self> {\n+        match syntax.kind() {\n+            | STRING\n+            | BYTE_STRING\n+            | RAW_STRING\n+            | RAW_BYTE_STRING\n+            | CHAR\n+            | BYTE\n+            | INT_NUMBER\n+            | FLOAT_NUMBER\n+            | TRUE_KW\n+            | FALSE_KW => Some(LiteralExpr::from_repr(syntax.into_repr())),\n+            _ => None,\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n+    fn to_owned(&self) -> TreeArc<LiteralExpr> { TreeArc::cast(self.syntax.to_owned()) }\n+}\n+\n+impl LiteralExpr {\n+    pub fn kind(&self) -> LiteralExprKind {\n+        match self.syntax.kind() {\n+            STRING => LiteralExprKind::String(String::cast(&self.syntax).unwrap()),\n+            BYTE_STRING => LiteralExprKind::ByteString(ByteString::cast(&self.syntax).unwrap()),\n+            RAW_STRING => LiteralExprKind::RawString(RawString::cast(&self.syntax).unwrap()),\n+            RAW_BYTE_STRING => LiteralExprKind::RawByteString(RawByteString::cast(&self.syntax).unwrap()),\n+            CHAR => LiteralExprKind::Char(Char::cast(&self.syntax).unwrap()),\n+            BYTE => LiteralExprKind::Byte(Byte::cast(&self.syntax).unwrap()),\n+            INT_NUMBER => LiteralExprKind::IntNumber(IntNumber::cast(&self.syntax).unwrap()),\n+            FLOAT_NUMBER => LiteralExprKind::FloatNumber(FloatNumber::cast(&self.syntax).unwrap()),\n+            TRUE_KW => LiteralExprKind::TrueKw(TrueKw::cast(&self.syntax).unwrap()),\n+            FALSE_KW => LiteralExprKind::FalseKw(FalseKw::cast(&self.syntax).unwrap()),\n+            _ => unreachable!(),\n+        }\n+    }\n+}\n+\n+impl LiteralExpr {}\n \n // LoopExpr\n #[derive(Debug, PartialEq, Eq, Hash)]\n@@ -2406,6 +2549,56 @@ impl AstNode for RangePat {\n \n impl RangePat {}\n \n+// RawByteString\n+#[derive(Debug, PartialEq, Eq, Hash)]\n+#[repr(transparent)]\n+pub struct RawByteString {\n+    pub(crate) syntax: SyntaxNode,\n+}\n+unsafe impl TransparentNewType for RawByteString {\n+    type Repr = rowan::SyntaxNode<RaTypes>;\n+}\n+\n+impl AstNode for RawByteString {\n+    fn cast(syntax: &SyntaxNode) -> Option<&Self> {\n+        match syntax.kind() {\n+            RAW_BYTE_STRING => Some(RawByteString::from_repr(syntax.into_repr())),\n+            _ => None,\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n+    fn to_owned(&self) -> TreeArc<RawByteString> { TreeArc::cast(self.syntax.to_owned()) }\n+}\n+\n+\n+impl ast::AstToken for RawByteString {}\n+impl RawByteString {}\n+\n+// RawString\n+#[derive(Debug, PartialEq, Eq, Hash)]\n+#[repr(transparent)]\n+pub struct RawString {\n+    pub(crate) syntax: SyntaxNode,\n+}\n+unsafe impl TransparentNewType for RawString {\n+    type Repr = rowan::SyntaxNode<RaTypes>;\n+}\n+\n+impl AstNode for RawString {\n+    fn cast(syntax: &SyntaxNode) -> Option<&Self> {\n+        match syntax.kind() {\n+            RAW_STRING => Some(RawString::from_repr(syntax.into_repr())),\n+            _ => None,\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n+    fn to_owned(&self) -> TreeArc<RawString> { TreeArc::cast(self.syntax.to_owned()) }\n+}\n+\n+\n+impl ast::AstToken for RawString {}\n+impl RawString {}\n+\n // RefExpr\n #[derive(Debug, PartialEq, Eq, Hash)]\n #[repr(transparent)]\n@@ -2919,6 +3112,31 @@ impl ast::AttrsOwner for TraitDef {}\n impl ast::DocCommentsOwner for TraitDef {}\n impl TraitDef {}\n \n+// TrueKw\n+#[derive(Debug, PartialEq, Eq, Hash)]\n+#[repr(transparent)]\n+pub struct TrueKw {\n+    pub(crate) syntax: SyntaxNode,\n+}\n+unsafe impl TransparentNewType for TrueKw {\n+    type Repr = rowan::SyntaxNode<RaTypes>;\n+}\n+\n+impl AstNode for TrueKw {\n+    fn cast(syntax: &SyntaxNode) -> Option<&Self> {\n+        match syntax.kind() {\n+            TRUE_KW => Some(TrueKw::from_repr(syntax.into_repr())),\n+            _ => None,\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n+    fn to_owned(&self) -> TreeArc<TrueKw> { TreeArc::cast(self.syntax.to_owned()) }\n+}\n+\n+\n+impl ast::AstToken for TrueKw {}\n+impl TrueKw {}\n+\n // TryExpr\n #[derive(Debug, PartialEq, Eq, Hash)]\n #[repr(transparent)]"}, {"sha": "bd8c5b41106115d6b9bb233ea0917921b268f9c5", "filename": "crates/ra_syntax/src/grammar.ron", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e8e82ce032f8678929b015e6f70ac060bb2cf94c/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron", "raw_url": "https://github.com/rust-lang/rust/raw/e8e82ce032f8678929b015e6f70ac060bb2cf94c/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron?ref=e8e82ce032f8678929b015e6f70ac060bb2cf94c", "patch": "@@ -426,11 +426,32 @@ Grammar(\n         \"PrefixExpr\": (options: [\"Expr\"]),\n         \"RangeExpr\": (),\n         \"BinExpr\": (),\n+\n+        \"IntNumber\": ( traits: [\"AstToken\"] ),\n+        \"FloatNumber\": ( traits: [\"AstToken\"] ),\n         \"String\": ( traits: [\"AstToken\"] ),\n+        \"RawString\": ( traits: [\"AstToken\"] ),\n         \"Byte\": ( traits: [\"AstToken\"] ),\n+        \"RawByteString\": ( traits: [\"AstToken\"] ),\n         \"ByteString\": ( traits: [\"AstToken\"] ),\n         \"Char\": ( traits: [\"AstToken\"] ),\n-        \"Literal\": (),\n+        \"TrueKw\": ( traits: [\"AstToken\"] ),\n+        \"FalseKw\": ( traits: [\"AstToken\"] ),\n+        \"LiteralExpr\": (\n+            enum: [\n+                \"String\",\n+                \"ByteString\",\n+                \"RawString\",\n+                \"RawByteString\",\n+                \"Char\",\n+                \"Byte\",\n+                \"IntNumber\",\n+                \"FloatNumber\",\n+                \"TrueKw\",\n+                \"FalseKw\",\n+            ]\n+        ),\n+        \"Literal\": (options: [\"LiteralExpr\"]),\n \n         \"Expr\": (\n             enum: ["}, {"sha": "0865b7f3b70493a9e11cbef2fec0de0f51a54f34", "filename": "crates/ra_syntax/src/lexer/strings.rs", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e8e82ce032f8678929b015e6f70ac060bb2cf94c/crates%2Fra_syntax%2Fsrc%2Flexer%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8e82ce032f8678929b015e6f70ac060bb2cf94c/crates%2Fra_syntax%2Fsrc%2Flexer%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Flexer%2Fstrings.rs?ref=e8e82ce032f8678929b015e6f70ac060bb2cf94c", "patch": "@@ -49,7 +49,7 @@ pub(crate) fn scan_byte_char_or_string(ptr: &mut Ptr) -> SyntaxKind {\n             BYTE_STRING\n         }\n         'r' => {\n-            scan_raw_byte_string(ptr);\n+            scan_raw_string(ptr);\n             RAW_BYTE_STRING\n         }\n         _ => unreachable!(),\n@@ -108,16 +108,3 @@ fn scan_byte(ptr: &mut Ptr) {\n fn scan_byte_string(ptr: &mut Ptr) {\n     scan_string(ptr)\n }\n-\n-fn scan_raw_byte_string(ptr: &mut Ptr) {\n-    if !ptr.at('\"') {\n-        return;\n-    }\n-    ptr.bump();\n-\n-    while let Some(c) = ptr.bump() {\n-        if c == '\"' {\n-            return;\n-        }\n-    }\n-}"}, {"sha": "bc311cbbcbc3e4235263d71cb9363bf4d9b48284", "filename": "crates/ra_syntax/src/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e8e82ce032f8678929b015e6f70ac060bb2cf94c/crates%2Fra_syntax%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8e82ce032f8678929b015e6f70ac060bb2cf94c/crates%2Fra_syntax%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Flib.rs?ref=e8e82ce032f8678929b015e6f70ac060bb2cf94c", "patch": "@@ -59,24 +59,29 @@ impl SourceFile {\n         assert_eq!(root.kind(), SyntaxKind::SOURCE_FILE);\n         TreeArc::cast(root)\n     }\n+\n     pub fn parse(text: &str) -> TreeArc<SourceFile> {\n         let tokens = tokenize(&text);\n         let (green, errors) =\n             parser_impl::parse_with(yellow::GreenBuilder::new(), text, &tokens, grammar::root);\n         SourceFile::new(green, errors)\n     }\n+\n     pub fn reparse(&self, edit: &AtomTextEdit) -> TreeArc<SourceFile> {\n         self.incremental_reparse(edit)\n             .unwrap_or_else(|| self.full_reparse(edit))\n     }\n+\n     pub fn incremental_reparse(&self, edit: &AtomTextEdit) -> Option<TreeArc<SourceFile>> {\n         reparsing::incremental_reparse(self.syntax(), edit, self.errors())\n             .map(|(green_node, errors)| SourceFile::new(green_node, errors))\n     }\n+\n     fn full_reparse(&self, edit: &AtomTextEdit) -> TreeArc<SourceFile> {\n         let text = edit.apply(self.syntax().text().to_string());\n         SourceFile::parse(&text)\n     }\n+\n     pub fn errors(&self) -> Vec<SyntaxError> {\n         let mut errors = self.syntax.root_data().clone();\n         errors.extend(validation::validate(self));"}, {"sha": "9b93945ccd21e9d710da1c7ae3066663a4fb117b", "filename": "crates/ra_syntax/src/yellow.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e8e82ce032f8678929b015e6f70ac060bb2cf94c/crates%2Fra_syntax%2Fsrc%2Fyellow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8e82ce032f8678929b015e6f70ac060bb2cf94c/crates%2Fra_syntax%2Fsrc%2Fyellow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fyellow.rs?ref=e8e82ce032f8678929b015e6f70ac060bb2cf94c", "patch": "@@ -128,40 +128,52 @@ impl SyntaxNode {\n     pub(crate) fn root_data(&self) -> &Vec<SyntaxError> {\n         self.0.root_data()\n     }\n+\n     pub(crate) fn replace_with(&self, replacement: GreenNode) -> GreenNode {\n         self.0.replace_self(replacement)\n     }\n+\n     pub fn to_owned(&self) -> TreeArc<SyntaxNode> {\n         let ptr = TreeArc(self.0.to_owned());\n         TreeArc::cast(ptr)\n     }\n+\n     pub fn kind(&self) -> SyntaxKind {\n         self.0.kind()\n     }\n+\n     pub fn range(&self) -> TextRange {\n         self.0.range()\n     }\n+\n     pub fn text(&self) -> SyntaxText {\n         SyntaxText::new(self)\n     }\n+\n     pub fn is_leaf(&self) -> bool {\n         self.0.is_leaf()\n     }\n+\n     pub fn parent(&self) -> Option<&SyntaxNode> {\n         self.0.parent().map(SyntaxNode::from_repr)\n     }\n+\n     pub fn first_child(&self) -> Option<&SyntaxNode> {\n         self.0.first_child().map(SyntaxNode::from_repr)\n     }\n+\n     pub fn last_child(&self) -> Option<&SyntaxNode> {\n         self.0.last_child().map(SyntaxNode::from_repr)\n     }\n+\n     pub fn next_sibling(&self) -> Option<&SyntaxNode> {\n         self.0.next_sibling().map(SyntaxNode::from_repr)\n     }\n+\n     pub fn prev_sibling(&self) -> Option<&SyntaxNode> {\n         self.0.prev_sibling().map(SyntaxNode::from_repr)\n     }\n+\n     pub fn children(&self) -> SyntaxNodeChildren {\n         SyntaxNodeChildren(self.0.children())\n     }"}, {"sha": "378cd1b2e21c6ad888d67f70e3720fdbd7f5becd", "filename": "crates/ra_syntax/src/yellow/syntax_text.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e8e82ce032f8678929b015e6f70ac060bb2cf94c/crates%2Fra_syntax%2Fsrc%2Fyellow%2Fsyntax_text.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8e82ce032f8678929b015e6f70ac060bb2cf94c/crates%2Fra_syntax%2Fsrc%2Fyellow%2Fsyntax_text.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fyellow%2Fsyntax_text.rs?ref=e8e82ce032f8678929b015e6f70ac060bb2cf94c", "patch": "@@ -15,6 +15,7 @@ impl<'a> SyntaxText<'a> {\n             range: node.range(),\n         }\n     }\n+\n     pub fn chunks(&self) -> impl Iterator<Item = &'a str> {\n         let range = self.range;\n         self.node.descendants().filter_map(move |node| {\n@@ -24,15 +25,19 @@ impl<'a> SyntaxText<'a> {\n             Some(&text[range])\n         })\n     }\n+\n     pub fn push_to(&self, buf: &mut String) {\n         self.chunks().for_each(|it| buf.push_str(it));\n     }\n+\n     pub fn to_string(&self) -> String {\n         self.chunks().collect()\n     }\n+\n     pub fn contains(&self, c: char) -> bool {\n         self.chunks().any(|it| it.contains(c))\n     }\n+\n     pub fn find(&self, c: char) -> Option<TextUnit> {\n         let mut acc: TextUnit = 0.into();\n         for chunk in self.chunks() {\n@@ -44,9 +49,11 @@ impl<'a> SyntaxText<'a> {\n         }\n         None\n     }\n+\n     pub fn len(&self) -> TextUnit {\n         self.range.len()\n     }\n+\n     pub fn slice(&self, range: impl SyntaxTextSlice) -> SyntaxText<'a> {\n         let range = range.restrict(self.range).unwrap_or_else(|| {\n             panic!(\"invalid slice, range: {:?}, slice: {:?}\", self.range, range)\n@@ -56,8 +63,10 @@ impl<'a> SyntaxText<'a> {\n             range,\n         }\n     }\n-    pub fn char_at(&self, offset: TextUnit) -> Option<char> {\n+\n+    pub fn char_at(&self, offset: impl Into<TextUnit>) -> Option<char> {\n         let mut start: TextUnit = 0.into();\n+        let offset = offset.into();\n         for chunk in self.chunks() {\n             let end = start + TextUnit::of_str(chunk);\n             if start <= offset && offset < end {"}]}