{"sha": "b1f04a3a2e1a01ea1b77153dd8d22e7837542aa0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIxZjA0YTNhMmUxYTAxZWExYjc3MTUzZGQ4ZDIyZTc4Mzc1NDJhYTA=", "commit": {"author": {"name": "Vitali Lovich", "email": "vlovich@google.com", "date": "2018-02-15T17:28:25Z"}, "committer": {"name": "Vitali Lovich", "email": "vlovich@google.com", "date": "2018-02-17T04:00:18Z"}, "message": "Fix unit test compilation\n\nAlso fix some code snippets in documentation.", "tree": {"sha": "f07dbb5fe606e63c458ebea53429a9e4cd2bf115", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f07dbb5fe606e63c458ebea53429a9e4cd2bf115"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b1f04a3a2e1a01ea1b77153dd8d22e7837542aa0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b1f04a3a2e1a01ea1b77153dd8d22e7837542aa0", "html_url": "https://github.com/rust-lang/rust/commit/b1f04a3a2e1a01ea1b77153dd8d22e7837542aa0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b1f04a3a2e1a01ea1b77153dd8d22e7837542aa0/comments", "author": null, "committer": null, "parents": [{"sha": "6fe2d1d765810c05ce2aa2184baa9f4aabf1a151", "url": "https://api.github.com/repos/rust-lang/rust/commits/6fe2d1d765810c05ce2aa2184baa9f4aabf1a151", "html_url": "https://github.com/rust-lang/rust/commit/6fe2d1d765810c05ce2aa2184baa9f4aabf1a151"}], "stats": {"total": 28, "additions": 17, "deletions": 11}, "files": [{"sha": "546e105deb7e6fe6ff4c87c1c4f8208209f84d5b", "filename": "src/libstd/sync/condvar.rs", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b1f04a3a2e1a01ea1b77153dd8d22e7837542aa0/src%2Flibstd%2Fsync%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1f04a3a2e1a01ea1b77153dd8d22e7837542aa0/src%2Flibstd%2Fsync%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fcondvar.rs?ref=b1f04a3a2e1a01ea1b77153dd8d22e7837542aa0", "patch": "@@ -244,6 +244,8 @@ impl Condvar {\n     /// # Examples\n     ///\n     /// ```\n+    /// #![feature(wait_until)]\n+    ///\n     /// use std::sync::{Arc, Mutex, Condvar};\n     /// use std::thread;\n     ///\n@@ -261,7 +263,7 @@ impl Condvar {\n     /// // Wait for the thread to start up.\n     /// let &(ref lock, ref cvar) = &*pair;\n     /// // As long as the value inside the `Mutex` is false, we wait.\n-    /// cvar.wait_until(lock.lock().unwrap(), |started| { started });\n+    /// let _guard = cvar.wait_until(lock.lock().unwrap(), |started| { *started }).unwrap();\n     /// ```\n     #[unstable(feature = \"wait_until\", issue = \"47960\")]\n     pub fn wait_until<'a, T, F>(&self, mut guard: MutexGuard<'a, T>,\n@@ -445,6 +447,8 @@ impl Condvar {\n     /// # Examples\n     ///\n     /// ```\n+    /// #![feature(wait_timeout_until)]\n+    ///\n     /// use std::sync::{Arc, Mutex, Condvar};\n     /// use std::thread;\n     /// use std::time::Duration;\n@@ -462,8 +466,8 @@ impl Condvar {\n     ///\n     /// // wait for the thread to start up\n     /// let &(ref lock, ref cvar) = &*pair;\n-    /// let result = cvar.wait_timeout_until(lock, Duration::from_millis(100), |started| {\n-    ///     started\n+    /// let result = cvar.wait_timeout_until(lock.lock().unwrap(), Duration::from_millis(100), |started| {\n+    ///     *started\n     /// }).unwrap();\n     /// if result.1.timed_out() {\n     ///     // timed-out without the condition ever evaluating to true.\n@@ -613,6 +617,7 @@ impl Drop for Condvar {\n \n #[cfg(test)]\n mod tests {\n+    /// #![feature(wait_until)]\n     use sync::mpsc::channel;\n     use sync::{Condvar, Mutex, Arc};\n     use sync::atomic::{AtomicBool, Ordering};\n@@ -699,9 +704,9 @@ mod tests {\n         // Wait for the thread to start up.\n         let &(ref lock, ref cvar) = &*pair;\n         let guard = cvar.wait_until(lock.lock().unwrap(), |started| {\n-            started\n+            *started\n         });\n-        assert!(*guard);\n+        assert!(*guard.unwrap());\n     }\n \n     #[test]\n@@ -730,7 +735,7 @@ mod tests {\n         let c = Arc::new(Condvar::new());\n \n         let g = m.lock().unwrap();\n-        let (_g, wait) = c.wait_timeout_until(g, Duration::from_millis(1), || { false }).unwrap();\n+        let (_g, wait) = c.wait_timeout_until(g, Duration::from_millis(1), |_| { false }).unwrap();\n         // no spurious wakeups. ensure it timed-out\n         assert!(wait.timed_out());\n     }\n@@ -742,7 +747,7 @@ mod tests {\n         let c = Arc::new(Condvar::new());\n \n         let g = m.lock().unwrap();\n-        let (_g, wait) = c.wait_timeout_until(g, Duration::from_millis(0), || { true }).unwrap();\n+        let (_g, wait) = c.wait_timeout_until(g, Duration::from_millis(0), |_| { true }).unwrap();\n         // ensure it didn't time-out even if we were not given any time.\n         assert!(!wait.timed_out());\n     }\n@@ -753,15 +758,16 @@ mod tests {\n         let pair = Arc::new((Mutex::new(false), Condvar::new()));\n         let pair_copy = pair.clone();\n \n+        let &(ref m, ref c) = &*pair;\n         let g = m.lock().unwrap();\n-        let t = thread::spawn(move || {\n-            let &(ref lock, ref cvar) = &*pair2;\n+        let _t = thread::spawn(move || {\n+            let &(ref lock, ref cvar) = &*pair_copy;\n             let mut started = lock.lock().unwrap();\n             thread::sleep(Duration::from_millis(1));\n-            started = true;\n+            *started = true;\n             cvar.notify_one();\n         });\n-        let (g2, wait) = c.wait_timeout_until(g, Duration::from_millis(u64::MAX), |&notified| {\n+        let (g2, wait) = c.wait_timeout_until(g, Duration::from_millis(u64::MAX), |&mut notified| {\n             notified\n         }).unwrap();\n         // ensure it didn't time-out even if we were not given any time."}]}