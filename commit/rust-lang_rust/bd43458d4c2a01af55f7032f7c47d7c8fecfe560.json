{"sha": "bd43458d4c2a01af55f7032f7c47d7c8fecfe560", "node_id": "C_kwDOAAsO6NoAKGJkNDM0NThkNGMyYTAxYWY1NWY3MDMyZjdjNDdkN2M4ZmVjZmU1NjA", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-14T03:38:42Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-14T03:38:42Z"}, "message": "Auto merge of #108992 - petrochenkov:qcstore2, r=cjgillot\n\nresolve: Querify most cstore access methods (subset)\n\nA subset of https://github.com/rust-lang/rust/pull/108346 that is not on a hot path in any way.", "tree": {"sha": "fa4c6514b8ee8a07183fe6df38c29654c37148a2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fa4c6514b8ee8a07183fe6df38c29654c37148a2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bd43458d4c2a01af55f7032f7c47d7c8fecfe560", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bd43458d4c2a01af55f7032f7c47d7c8fecfe560", "html_url": "https://github.com/rust-lang/rust/commit/bd43458d4c2a01af55f7032f7c47d7c8fecfe560", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bd43458d4c2a01af55f7032f7c47d7c8fecfe560/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c54af457d05722321ca88c2ae0e5706ef803c5fb", "url": "https://api.github.com/repos/rust-lang/rust/commits/c54af457d05722321ca88c2ae0e5706ef803c5fb", "html_url": "https://github.com/rust-lang/rust/commit/c54af457d05722321ca88c2ae0e5706ef803c5fb"}, {"sha": "4a61922ef00153a2c6e74d3cc97f687c9c8c6817", "url": "https://api.github.com/repos/rust-lang/rust/commits/4a61922ef00153a2c6e74d3cc97f687c9c8c6817", "html_url": "https://github.com/rust-lang/rust/commit/4a61922ef00153a2c6e74d3cc97f687c9c8c6817"}], "stats": {"total": 419, "additions": 169, "deletions": 250}, "files": [{"sha": "71bdd4df95ba384298d31552890d262cbf1bbbf4", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/bd43458d4c2a01af55f7032f7c47d7c8fecfe560/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd43458d4c2a01af55f7032f7c47d7c8fecfe560/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=bd43458d4c2a01af55f7032f7c47d7c8fecfe560", "patch": "@@ -26,7 +26,7 @@ use rustc_plugin_impl as plugin;\n use rustc_query_impl::{OnDiskCache, Queries as TcxQueries};\n use rustc_resolve::Resolver;\n use rustc_session::config::{CrateType, Input, OutputFilenames, OutputType};\n-use rustc_session::cstore::{CrateStoreDyn, MetadataLoader, Untracked};\n+use rustc_session::cstore::{MetadataLoader, Untracked};\n use rustc_session::output::filename_for_input;\n use rustc_session::search_paths::PathKind;\n use rustc_session::{Limit, Session};\n@@ -442,13 +442,9 @@ fn escape_dep_env(symbol: Symbol) -> String {\n     escaped\n }\n \n-fn write_out_deps(\n-    sess: &Session,\n-    cstore: &CrateStoreDyn,\n-    outputs: &OutputFilenames,\n-    out_filenames: &[PathBuf],\n-) {\n+fn write_out_deps(tcx: TyCtxt<'_>, outputs: &OutputFilenames, out_filenames: &[PathBuf]) {\n     // Write out dependency rules to the dep-info file if requested\n+    let sess = tcx.sess;\n     if !sess.opts.output_types.contains_key(&OutputType::DepInfo) {\n         return;\n     }\n@@ -496,9 +492,8 @@ fn write_out_deps(\n                 }\n             }\n \n-            let cstore = cstore.as_any().downcast_ref::<CStore>().unwrap();\n-            for cnum in cstore.crates_untracked() {\n-                let source = cstore.crate_source_untracked(cnum);\n+            for &cnum in tcx.crates(()) {\n+                let source = tcx.used_crate_source(cnum);\n                 if let Some((path, _)) = &source.dylib {\n                     files.push(escape_dep_filename(&path.display().to_string()));\n                 }\n@@ -612,7 +607,7 @@ fn output_filenames(tcx: TyCtxt<'_>, (): ()) -> Arc<OutputFilenames> {\n         }\n     }\n \n-    write_out_deps(sess, &*tcx.cstore_untracked(), &outputs, &output_paths);\n+    write_out_deps(tcx, &outputs, &output_paths);\n \n     let only_dep_info = sess.opts.output_types.contains_key(&OutputType::DepInfo)\n         && sess.opts.output_types.len() == 1;"}, {"sha": "f870a1db82d9ca19bca3f38e635e9afcfc3db1ce", "filename": "compiler/rustc_metadata/src/creader.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/bd43458d4c2a01af55f7032f7c47d7c8fecfe560/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd43458d4c2a01af55f7032f7c47d7c8fecfe560/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs?ref=bd43458d4c2a01af55f7032f7c47d7c8fecfe560", "patch": "@@ -8,7 +8,7 @@ use rustc_ast::expand::allocator::AllocatorKind;\n use rustc_ast::{self as ast, *};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::svh::Svh;\n-use rustc_data_structures::sync::MappedReadGuard;\n+use rustc_data_structures::sync::{MappedReadGuard, MappedWriteGuard, ReadGuard, WriteGuard};\n use rustc_expand::base::SyntaxExtension;\n use rustc_hir::def_id::{CrateNum, LocalDefId, StableCrateId, LOCAL_CRATE};\n use rustc_hir::definitions::Definitions;\n@@ -133,8 +133,14 @@ impl<'a> std::fmt::Debug for CrateDump<'a> {\n \n impl CStore {\n     pub fn from_tcx(tcx: TyCtxt<'_>) -> MappedReadGuard<'_, CStore> {\n-        MappedReadGuard::map(tcx.cstore_untracked(), |c| {\n-            c.as_any().downcast_ref::<CStore>().expect(\"`tcx.cstore` is not a `CStore`\")\n+        ReadGuard::map(tcx.untracked().cstore.read(), |cstore| {\n+            cstore.as_any().downcast_ref::<CStore>().expect(\"`tcx.cstore` is not a `CStore`\")\n+        })\n+    }\n+\n+    pub fn from_tcx_mut(tcx: TyCtxt<'_>) -> MappedWriteGuard<'_, CStore> {\n+        WriteGuard::map(tcx.untracked().cstore.write(), |cstore| {\n+            cstore.untracked_as_any().downcast_mut().expect(\"`tcx.cstore` is not a `CStore`\")\n         })\n     }\n \n@@ -268,9 +274,6 @@ impl<'a, 'tcx> CrateLoader<'a, 'tcx> {\n     ) -> Self {\n         CrateLoader { tcx, cstore, used_extern_options }\n     }\n-    pub fn cstore(&self) -> &CStore {\n-        &self.cstore\n-    }\n \n     fn existing_match(&self, name: Symbol, hash: Option<Svh>, kind: PathKind) -> Option<CrateNum> {\n         for (cnum, data) in self.cstore.iter_crate_data() {"}, {"sha": "a680730d1f52d7da9824c09839de54f6e6e07167", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 1, "deletions": 29, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/bd43458d4c2a01af55f7032f7c47d7c8fecfe560/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd43458d4c2a01af55f7032f7c47d7c8fecfe560/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=bd43458d4c2a01af55f7032f7c47d7c8fecfe560", "patch": "@@ -30,7 +30,6 @@ use rustc_session::cstore::{\n };\n use rustc_session::Session;\n use rustc_span::hygiene::ExpnIndex;\n-use rustc_span::source_map::{respan, Spanned};\n use rustc_span::symbol::{kw, Ident, Symbol};\n use rustc_span::{self, BytePos, ExpnId, Pos, Span, SyntaxContext, DUMMY_SP};\n \n@@ -930,7 +929,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         self.root.tables.generics_of.get(self, item_id).unwrap().decode((self, sess))\n     }\n \n-    fn get_visibility(self, id: DefIndex) -> ty::Visibility<DefId> {\n+    fn get_visibility(self, id: DefIndex) -> Visibility<DefId> {\n         self.root\n             .tables\n             .visibility\n@@ -1134,33 +1133,6 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             .decode((self, sess))\n     }\n \n-    fn get_struct_field_names(\n-        self,\n-        id: DefIndex,\n-        sess: &'a Session,\n-    ) -> impl Iterator<Item = Spanned<Symbol>> + 'a {\n-        self.root\n-            .tables\n-            .children\n-            .get(self, id)\n-            .expect(\"fields not encoded for a struct\")\n-            .decode(self)\n-            .map(move |index| respan(self.get_span(index, sess), self.item_name(index)))\n-    }\n-\n-    fn get_struct_field_visibilities(\n-        self,\n-        id: DefIndex,\n-    ) -> impl Iterator<Item = Visibility<DefId>> + 'a {\n-        self.root\n-            .tables\n-            .children\n-            .get(self, id)\n-            .expect(\"fields not encoded for a struct\")\n-            .decode(self)\n-            .map(move |field_index| self.get_visibility(field_index))\n-    }\n-\n     fn get_inherent_implementations_for_type(\n         self,\n         tcx: TyCtxt<'tcx>,"}, {"sha": "6c5e8863010850e40abe3b648cd320665c1707cf", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 6, "deletions": 35, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/bd43458d4c2a01af55f7032f7c47d7c8fecfe560/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd43458d4c2a01af55f7032f7c47d7c8fecfe560/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=bd43458d4c2a01af55f7032f7c47d7c8fecfe560", "patch": "@@ -15,12 +15,12 @@ use rustc_middle::middle::exported_symbols::ExportedSymbol;\n use rustc_middle::middle::stability::DeprecationEntry;\n use rustc_middle::ty::fast_reject::SimplifiedType;\n use rustc_middle::ty::query::{ExternProviders, Providers};\n-use rustc_middle::ty::{self, TyCtxt, Visibility};\n-use rustc_session::cstore::{CrateSource, CrateStore};\n+use rustc_middle::ty::{self, TyCtxt};\n+use rustc_session::cstore::CrateStore;\n use rustc_session::{Session, StableCrateId};\n use rustc_span::hygiene::{ExpnHash, ExpnId};\n-use rustc_span::source_map::{Span, Spanned};\n use rustc_span::symbol::{kw, Symbol};\n+use rustc_span::Span;\n \n use rustc_data_structures::sync::Lrc;\n use std::any::Any;\n@@ -501,35 +501,18 @@ pub(in crate::rmeta) fn provide(providers: &mut Providers) {\n             tcx.arena\n                 .alloc_slice(&CStore::from_tcx(tcx).crate_dependencies_in_postorder(LOCAL_CRATE))\n         },\n-        crates: |tcx, ()| tcx.arena.alloc_from_iter(CStore::from_tcx(tcx).crates_untracked()),\n+        crates: |tcx, ()| {\n+            tcx.arena.alloc_from_iter(CStore::from_tcx(tcx).iter_crate_data().map(|(cnum, _)| cnum))\n+        },\n         ..*providers\n     };\n }\n \n impl CStore {\n-    pub fn struct_field_names_untracked<'a>(\n-        &'a self,\n-        def: DefId,\n-        sess: &'a Session,\n-    ) -> impl Iterator<Item = Spanned<Symbol>> + 'a {\n-        self.get_crate_data(def.krate).get_struct_field_names(def.index, sess)\n-    }\n-\n-    pub fn struct_field_visibilities_untracked(\n-        &self,\n-        def: DefId,\n-    ) -> impl Iterator<Item = Visibility<DefId>> + '_ {\n-        self.get_crate_data(def.krate).get_struct_field_visibilities(def.index)\n-    }\n-\n     pub fn ctor_untracked(&self, def: DefId) -> Option<(CtorKind, DefId)> {\n         self.get_crate_data(def.krate).get_ctor(def.index)\n     }\n \n-    pub fn visibility_untracked(&self, def: DefId) -> Visibility<DefId> {\n-        self.get_crate_data(def.krate).get_visibility(def.index)\n-    }\n-\n     pub fn module_children_untracked<'a>(\n         &'a self,\n         def_id: DefId,\n@@ -566,14 +549,6 @@ impl CStore {\n         )\n     }\n \n-    pub fn fn_has_self_parameter_untracked(&self, def: DefId, sess: &Session) -> bool {\n-        self.get_crate_data(def.krate).get_fn_has_self_parameter(def.index, sess)\n-    }\n-\n-    pub fn crate_source_untracked(&self, cnum: CrateNum) -> Lrc<CrateSource> {\n-        self.get_crate_data(cnum).source.clone()\n-    }\n-\n     pub fn get_span_untracked(&self, def_id: DefId, sess: &Session) -> Span {\n         self.get_crate_data(def_id.krate).get_span(def_id.index, sess)\n     }\n@@ -582,10 +557,6 @@ impl CStore {\n         self.get_crate_data(def.krate).def_kind(def.index)\n     }\n \n-    pub fn crates_untracked(&self) -> impl Iterator<Item = CrateNum> + '_ {\n-        self.iter_crate_data().map(|(cnum, _)| cnum)\n-    }\n-\n     pub fn item_generics_num_lifetimes(&self, def_id: DefId, sess: &Session) -> usize {\n         self.get_crate_data(def_id.krate).get_generics(def_id.index, sess).own_counts().lifetimes\n     }"}, {"sha": "362ef693c48d5b5576fde410a454fd102f6df021", "filename": "compiler/rustc_resolve/src/build_reduced_graph.rs", "status": "modified", "additions": 13, "deletions": 47, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/bd43458d4c2a01af55f7032f7c47d7c8fecfe560/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd43458d4c2a01af55f7032f7c47d7c8fecfe560/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs?ref=bd43458d4c2a01af55f7032f7c47d7c8fecfe560", "patch": "@@ -29,7 +29,6 @@ use rustc_middle::metadata::ModChild;\n use rustc_middle::{bug, ty};\n use rustc_session::cstore::CrateStore;\n use rustc_span::hygiene::{ExpnId, LocalExpnId, MacroKind};\n-use rustc_span::source_map::respan;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::Span;\n \n@@ -130,12 +129,11 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     };\n \n                     let expn_id = self.cstore().module_expansion_untracked(def_id, &self.tcx.sess);\n-                    let span = self.cstore().get_span_untracked(def_id, &self.tcx.sess);\n                     Some(self.new_module(\n                         parent,\n                         ModuleKind::Def(def_kind, def_id, name),\n                         expn_id,\n-                        span,\n+                        self.def_span(def_id),\n                         // FIXME: Account for `#[no_implicit_prelude]` attributes.\n                         parent.map_or(false, |module| module.no_implicit_prelude),\n                     ))\n@@ -328,13 +326,13 @@ impl<'a, 'b, 'tcx> BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n         }\n     }\n \n-    fn insert_field_names_local(&mut self, def_id: DefId, vdata: &ast::VariantData) {\n-        let field_names = vdata\n-            .fields()\n-            .iter()\n-            .map(|field| respan(field.span, field.ident.map_or(kw::Empty, |ident| ident.name)))\n-            .collect();\n-        self.r.field_names.insert(def_id, field_names);\n+    fn insert_field_def_ids(&mut self, def_id: LocalDefId, vdata: &ast::VariantData) {\n+        if vdata.fields().iter().any(|field| field.is_placeholder) {\n+            // The fields are not expanded yet.\n+            return;\n+        }\n+        let def_ids = vdata.fields().iter().map(|field| self.r.local_def_id(field.id).to_def_id());\n+        self.r.field_def_ids.insert(def_id, self.r.tcx.arena.alloc_from_iter(def_ids));\n     }\n \n     fn insert_field_visibilities_local(&mut self, def_id: DefId, vdata: &ast::VariantData) {\n@@ -346,12 +344,6 @@ impl<'a, 'b, 'tcx> BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n         self.r.field_visibility_spans.insert(def_id, field_vis);\n     }\n \n-    fn insert_field_names_extern(&mut self, def_id: DefId) {\n-        let field_names =\n-            self.r.cstore().struct_field_names_untracked(def_id, self.r.tcx.sess).collect();\n-        self.r.field_names.insert(def_id, field_names);\n-    }\n-\n     fn block_needs_anonymous_module(&mut self, block: &Block) -> bool {\n         // If any statements are items, we need to create an anonymous module\n         block\n@@ -749,7 +741,7 @@ impl<'a, 'b, 'tcx> BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n                 self.r.define(parent, ident, TypeNS, (res, vis, sp, expansion));\n \n                 // Record field names for error reporting.\n-                self.insert_field_names_local(def_id, vdata);\n+                self.insert_field_def_ids(local_def_id, vdata);\n                 self.insert_field_visibilities_local(def_id, vdata);\n \n                 // If this is a tuple or unit struct, define a name\n@@ -789,7 +781,7 @@ impl<'a, 'b, 'tcx> BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n \n                     self.r\n                         .struct_constructors\n-                        .insert(def_id, (ctor_res, ctor_vis.to_def_id(), ret_fields));\n+                        .insert(local_def_id, (ctor_res, ctor_vis.to_def_id(), ret_fields));\n                 }\n             }\n \n@@ -798,7 +790,7 @@ impl<'a, 'b, 'tcx> BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n                 self.r.define(parent, ident, TypeNS, (res, vis, sp, expansion));\n \n                 // Record field names for error reporting.\n-                self.insert_field_names_local(def_id, vdata);\n+                self.insert_field_def_ids(local_def_id, vdata);\n                 self.insert_field_visibilities_local(def_id, vdata);\n             }\n \n@@ -1004,32 +996,6 @@ impl<'a, 'b, 'tcx> BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n             | Res::SelfCtor(..)\n             | Res::Err => bug!(\"unexpected resolution: {:?}\", res),\n         }\n-        // Record some extra data for better diagnostics.\n-        match res {\n-            Res::Def(DefKind::Struct, def_id) => {\n-                let cstore = self.r.cstore();\n-                if let Some((ctor_kind, ctor_def_id)) = cstore.ctor_untracked(def_id) {\n-                    let ctor_res = Res::Def(DefKind::Ctor(CtorOf::Struct, ctor_kind), ctor_def_id);\n-                    let ctor_vis = cstore.visibility_untracked(ctor_def_id);\n-                    let field_visibilities =\n-                        cstore.struct_field_visibilities_untracked(def_id).collect();\n-                    drop(cstore);\n-                    self.r\n-                        .struct_constructors\n-                        .insert(def_id, (ctor_res, ctor_vis, field_visibilities));\n-                } else {\n-                    drop(cstore);\n-                }\n-                self.insert_field_names_extern(def_id)\n-            }\n-            Res::Def(DefKind::Union, def_id) => self.insert_field_names_extern(def_id),\n-            Res::Def(DefKind::AssocFn, def_id) => {\n-                if self.r.cstore().fn_has_self_parameter_untracked(def_id, self.r.tcx.sess) {\n-                    self.r.has_self.insert(def_id);\n-                }\n-            }\n-            _ => {}\n-        }\n     }\n \n     fn add_macro_use_binding(\n@@ -1426,7 +1392,7 @@ impl<'a, 'b, 'tcx> Visitor<'b> for BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n                 AssocItemKind::Const(..) => (DefKind::AssocConst, ValueNS),\n                 AssocItemKind::Fn(box Fn { ref sig, .. }) => {\n                     if sig.decl.has_self() {\n-                        self.r.has_self.insert(def_id);\n+                        self.r.has_self.insert(local_def_id);\n                     }\n                     (DefKind::AssocFn, ValueNS)\n                 }\n@@ -1540,7 +1506,7 @@ impl<'a, 'b, 'tcx> Visitor<'b> for BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n         }\n \n         // Record field names for error reporting.\n-        self.insert_field_names_local(def_id.to_def_id(), &variant.data);\n+        self.insert_field_def_ids(def_id, &variant.data);\n         self.insert_field_visibilities_local(def_id.to_def_id(), &variant.data);\n \n         visit::walk_variant(self, variant);"}, {"sha": "44a3d4e628ebce8b13a0f30c04ad6fd5004ab461", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 22, "deletions": 30, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/bd43458d4c2a01af55f7032f7c47d7c8fecfe560/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd43458d4c2a01af55f7032f7c47d7c8fecfe560/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=bd43458d4c2a01af55f7032f7c47d7c8fecfe560", "patch": "@@ -12,7 +12,7 @@ use rustc_errors::{struct_span_err, SuggestionStyle};\n use rustc_feature::BUILTIN_ATTRIBUTES;\n use rustc_hir::def::Namespace::{self, *};\n use rustc_hir::def::{self, CtorKind, CtorOf, DefKind, NonMacroAttrKind, PerNS};\n-use rustc_hir::def_id::{DefId, CRATE_DEF_ID, LOCAL_CRATE};\n+use rustc_hir::def_id::{DefId, CRATE_DEF_ID};\n use rustc_hir::PrimTy;\n use rustc_middle::bug;\n use rustc_middle::ty::TyCtxt;\n@@ -555,25 +555,22 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         return err;\n                     }\n                     Res::SelfTyAlias { alias_to: def_id, .. } => {\n-                        if let Some(impl_span) = self.opt_span(def_id) {\n-                            err.span_label(\n-                                reduce_impl_span_to_impl_keyword(sm, impl_span),\n-                                \"`Self` type implicitly declared here, by this `impl`\",\n-                            );\n-                        }\n+                        err.span_label(\n+                            reduce_impl_span_to_impl_keyword(sm, self.def_span(def_id)),\n+                            \"`Self` type implicitly declared here, by this `impl`\",\n+                        );\n                         err.span_label(span, \"use a type here instead\");\n                         return err;\n                     }\n                     Res::Def(DefKind::TyParam, def_id) => {\n-                        if let Some(span) = self.opt_span(def_id) {\n-                            err.span_label(span, \"type parameter from outer function\");\n-                        }\n+                        err.span_label(self.def_span(def_id), \"type parameter from outer function\");\n                         def_id\n                     }\n                     Res::Def(DefKind::ConstParam, def_id) => {\n-                        if let Some(span) = self.opt_span(def_id) {\n-                            err.span_label(span, \"const parameter from outer function\");\n-                        }\n+                        err.span_label(\n+                            self.def_span(def_id),\n+                            \"const parameter from outer function\",\n+                        );\n                         def_id\n                     }\n                     _ => {\n@@ -589,7 +586,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     // Try to retrieve the span of the function signature and generate a new\n                     // message with a local type or const parameter.\n                     let sugg_msg = \"try using a local generic parameter instead\";\n-                    let name = self.opt_name(def_id).unwrap_or(sym::T);\n+                    let name = self.tcx.item_name(def_id);\n                     let (span, snippet) = if span.is_empty() {\n                         let snippet = format!(\"<{}>\", name);\n                         (span, snippet)\n@@ -1216,15 +1213,11 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             // a note about editions\n                             let note = if let Some(did) = did {\n                                 let requires_note = !did.is_local()\n-                                    && this.cstore().item_attrs_untracked(did, this.tcx.sess).any(\n+                                    && this.tcx.get_attrs(did, sym::rustc_diagnostic_item).any(\n                                         |attr| {\n-                                            if attr.has_name(sym::rustc_diagnostic_item) {\n-                                                [sym::TryInto, sym::TryFrom, sym::FromIterator]\n-                                                    .map(|x| Some(x))\n-                                                    .contains(&attr.value_str())\n-                                            } else {\n-                                                false\n-                                            }\n+                                            [sym::TryInto, sym::TryFrom, sym::FromIterator]\n+                                                .map(|x| Some(x))\n+                                                .contains(&attr.value_str())\n                                         },\n                                     );\n \n@@ -1373,8 +1366,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         }\n         if ident.name == kw::Default\n             && let ModuleKind::Def(DefKind::Enum, def_id, _) = parent_scope.module.kind\n-            && let Some(span) = self.opt_span(def_id)\n         {\n+            let span = self.def_span(def_id);\n             let source_map = self.tcx.sess.source_map();\n             let head_span = source_map.guess_head_span(span);\n             if let Ok(head) = source_map.span_to_snippet(head_span) {\n@@ -1450,11 +1443,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             Some(suggestion) if suggestion.candidate == kw::Underscore => return false,\n             Some(suggestion) => suggestion,\n         };\n-        let def_span = suggestion.res.opt_def_id().and_then(|def_id| match def_id.krate {\n-            LOCAL_CRATE => self.opt_span(def_id),\n-            _ => Some(self.cstore().get_span_untracked(def_id, self.tcx.sess)),\n-        });\n-        if let Some(def_span) = def_span {\n+        if let Some(def_span) = suggestion.res.opt_def_id().map(|def_id| self.def_span(def_id)) {\n             if span.overlaps(def_span) {\n                 // Don't suggest typo suggestion for itself like in the following:\n                 // error[E0423]: expected function, tuple struct or tuple variant, found struct `X`\n@@ -1592,8 +1581,11 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         )) = binding.kind\n         {\n             let def_id = self.tcx.parent(ctor_def_id);\n-            let fields = self.field_names.get(&def_id)?;\n-            return fields.iter().map(|name| name.span).reduce(Span::to); // None for `struct Foo()`\n+            return self\n+                .field_def_ids(def_id)?\n+                .iter()\n+                .map(|&field_id| self.def_span(field_id))\n+                .reduce(Span::to); // None for `struct Foo()`\n         }\n         None\n     }"}, {"sha": "eff10e5af9fe879d849ca3df0b7ddc6718de8e28", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd43458d4c2a01af55f7032f7c47d7c8fecfe560/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd43458d4c2a01af55f7032f7c47d7c8fecfe560/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=bd43458d4c2a01af55f7032f7c47d7c8fecfe560", "patch": "@@ -3376,7 +3376,7 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n                         participle: \"defined\",\n                         article: res.article(),\n                         shadowed_binding: res,\n-                        shadowed_binding_span: self.r.opt_span(def_id).expect(\"const parameter defined outside of local crate\"),\n+                        shadowed_binding_span: self.r.def_span(def_id),\n                     }\n                 );\n                 None"}, {"sha": "805c2ff280d8be69ed9e627beeece02ec0191d7f", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 85, "deletions": 61, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/bd43458d4c2a01af55f7032f7c47d7c8fecfe560/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd43458d4c2a01af55f7032f7c47d7c8fecfe560/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=bd43458d4c2a01af55f7032f7c47d7c8fecfe560", "patch": "@@ -19,7 +19,7 @@ use rustc_errors::{\n use rustc_hir as hir;\n use rustc_hir::def::Namespace::{self, *};\n use rustc_hir::def::{self, CtorKind, CtorOf, DefKind};\n-use rustc_hir::def_id::{DefId, CRATE_DEF_ID, LOCAL_CRATE};\n+use rustc_hir::def_id::{DefId, CRATE_DEF_ID};\n use rustc_hir::PrimTy;\n use rustc_session::lint;\n use rustc_session::parse::feature_err;\n@@ -166,13 +166,6 @@ impl TypoCandidate {\n }\n \n impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n-    fn def_span(&self, def_id: DefId) -> Option<Span> {\n-        match def_id.krate {\n-            LOCAL_CRATE => self.r.opt_span(def_id),\n-            _ => Some(self.r.cstore().get_span_untracked(def_id, self.r.tcx.sess)),\n-        }\n-    }\n-\n     fn make_base_error(\n         &mut self,\n         path: &[Segment],\n@@ -191,7 +184,7 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n                 span,\n                 span_label: match res {\n                     Res::Def(kind, def_id) if kind == DefKind::TyParam => {\n-                        self.def_span(def_id).map(|span| (span, \"found this type parameter\"))\n+                        Some((self.r.def_span(def_id), \"found this type parameter\"))\n                     }\n                     _ => None,\n                 },\n@@ -1295,28 +1288,30 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n                 }\n                 PathSource::Expr(_) | PathSource::TupleStruct(..) | PathSource::Pat => {\n                     let span = find_span(&source, err);\n-                    if let Some(span) = self.def_span(def_id) {\n-                        err.span_label(span, &format!(\"`{}` defined here\", path_str));\n-                    }\n+                    err.span_label(self.r.def_span(def_id), &format!(\"`{path_str}` defined here\"));\n                     let (tail, descr, applicability) = match source {\n                         PathSource::Pat | PathSource::TupleStruct(..) => {\n                             (\"\", \"pattern\", Applicability::MachineApplicable)\n                         }\n                         _ => (\": val\", \"literal\", Applicability::HasPlaceholders),\n                     };\n-                    let (fields, applicability) = match self.r.field_names.get(&def_id) {\n-                        Some(fields) => (\n-                            fields\n+\n+                    let field_ids = self.r.field_def_ids(def_id);\n+                    let (fields, applicability) = match field_ids {\n+                        Some(field_ids) => (\n+                            field_ids\n                                 .iter()\n-                                .map(|f| format!(\"{}{}\", f.node, tail))\n+                                .map(|&field_id| {\n+                                    format!(\"{}{tail}\", self.r.tcx.item_name(field_id))\n+                                })\n                                 .collect::<Vec<String>>()\n                                 .join(\", \"),\n                             applicability,\n                         ),\n                         None => (\"/* fields */\".to_string(), Applicability::HasPlaceholders),\n                     };\n-                    let pad = match self.r.field_names.get(&def_id) {\n-                        Some(fields) if fields.is_empty() => \"\",\n+                    let pad = match field_ids {\n+                        Some(field_ids) if field_ids.is_empty() => \"\",\n                         _ => \" \",\n                     };\n                     err.span_suggestion(\n@@ -1359,17 +1354,14 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n                 if self.r.tcx.sess.is_nightly_build() {\n                     let msg = \"you might have meant to use `#![feature(trait_alias)]` instead of a \\\n                                `type` alias\";\n-                    if let Some(span) = self.def_span(def_id) {\n-                        if let Ok(snip) = self.r.tcx.sess.source_map().span_to_snippet(span) {\n-                            // The span contains a type alias so we should be able to\n-                            // replace `type` with `trait`.\n-                            let snip = snip.replacen(\"type\", \"trait\", 1);\n-                            err.span_suggestion(span, msg, snip, Applicability::MaybeIncorrect);\n-                        } else {\n-                            err.span_help(span, msg);\n-                        }\n+                    let span = self.r.def_span(def_id);\n+                    if let Ok(snip) = self.r.tcx.sess.source_map().span_to_snippet(span) {\n+                        // The span contains a type alias so we should be able to\n+                        // replace `type` with `trait`.\n+                        let snip = snip.replacen(\"type\", \"trait\", 1);\n+                        err.span_suggestion(span, msg, snip, Applicability::MaybeIncorrect);\n                     } else {\n-                        err.help(msg);\n+                        err.span_help(span, msg);\n                     }\n                 }\n             }\n@@ -1408,19 +1400,38 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n                 self.suggest_using_enum_variant(err, source, def_id, span);\n             }\n             (Res::Def(DefKind::Struct, def_id), source) if ns == ValueNS => {\n-                let (ctor_def, ctor_vis, fields) =\n-                    if let Some(struct_ctor) = self.r.struct_constructors.get(&def_id).cloned() {\n-                        if let PathSource::Expr(Some(parent)) = source {\n-                            if let ExprKind::Field(..) | ExprKind::MethodCall(..) = parent.kind {\n-                                bad_struct_syntax_suggestion(def_id);\n-                                return true;\n-                            }\n+                let struct_ctor = match def_id.as_local() {\n+                    Some(def_id) => self.r.struct_constructors.get(&def_id).cloned(),\n+                    None => {\n+                        let ctor = self.r.cstore().ctor_untracked(def_id);\n+                        ctor.map(|(ctor_kind, ctor_def_id)| {\n+                            let ctor_res =\n+                                Res::Def(DefKind::Ctor(CtorOf::Struct, ctor_kind), ctor_def_id);\n+                            let ctor_vis = self.r.tcx.visibility(ctor_def_id);\n+                            let field_visibilities = self\n+                                .r\n+                                .tcx\n+                                .associated_item_def_ids(def_id)\n+                                .iter()\n+                                .map(|field_id| self.r.tcx.visibility(field_id))\n+                                .collect();\n+                            (ctor_res, ctor_vis, field_visibilities)\n+                        })\n+                    }\n+                };\n+\n+                let (ctor_def, ctor_vis, fields) = if let Some(struct_ctor) = struct_ctor {\n+                    if let PathSource::Expr(Some(parent)) = source {\n+                        if let ExprKind::Field(..) | ExprKind::MethodCall(..) = parent.kind {\n+                            bad_struct_syntax_suggestion(def_id);\n+                            return true;\n                         }\n-                        struct_ctor\n-                    } else {\n-                        bad_struct_syntax_suggestion(def_id);\n-                        return true;\n-                    };\n+                    }\n+                    struct_ctor\n+                } else {\n+                    bad_struct_syntax_suggestion(def_id);\n+                    return true;\n+                };\n \n                 let is_accessible = self.r.is_accessible_from(ctor_vis, self.parent_scope.module);\n                 if !is_expected(ctor_def) || is_accessible {\n@@ -1444,10 +1455,12 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n                         );\n \n                         // Use spans of the tuple struct definition.\n-                        self.r\n-                            .field_names\n-                            .get(&def_id)\n-                            .map(|fields| fields.iter().map(|f| f.span).collect::<Vec<_>>())\n+                        self.r.field_def_ids(def_id).map(|field_ids| {\n+                            field_ids\n+                                .iter()\n+                                .map(|&field_id| self.r.def_span(field_id))\n+                                .collect::<Vec<_>>()\n+                        })\n                     }\n                     _ => None,\n                 };\n@@ -1493,9 +1506,10 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n                 match source {\n                     PathSource::Expr(_) | PathSource::TupleStruct(..) | PathSource::Pat => {\n                         let span = find_span(&source, err);\n-                        if let Some(span) = self.def_span(def_id) {\n-                            err.span_label(span, &format!(\"`{}` defined here\", path_str));\n-                        }\n+                        err.span_label(\n+                            self.r.def_span(def_id),\n+                            &format!(\"`{path_str}` defined here\"),\n+                        );\n                         err.span_suggestion(\n                             span,\n                             \"use this syntax instead\",\n@@ -1508,12 +1522,10 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n             }\n             (Res::Def(DefKind::Ctor(_, CtorKind::Fn), ctor_def_id), _) if ns == ValueNS => {\n                 let def_id = self.r.tcx.parent(ctor_def_id);\n-                if let Some(span) = self.def_span(def_id) {\n-                    err.span_label(span, &format!(\"`{}` defined here\", path_str));\n-                }\n-                let fields = self.r.field_names.get(&def_id).map_or_else(\n+                err.span_label(self.r.def_span(def_id), &format!(\"`{path_str}` defined here\"));\n+                let fields = self.r.field_def_ids(def_id).map_or_else(\n                     || \"/* fields */\".to_string(),\n-                    |fields| vec![\"_\"; fields.len()].join(\", \"),\n+                    |field_ids| vec![\"_\"; field_ids.len()].join(\", \"),\n                 );\n                 err.span_suggestion(\n                     span,\n@@ -1594,8 +1606,11 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n                     if let Some(Res::Def(DefKind::Struct | DefKind::Union, did)) =\n                         resolution.full_res()\n                     {\n-                        if let Some(field_names) = self.r.field_names.get(&did) {\n-                            if field_names.iter().any(|&field_name| ident.name == field_name.node) {\n+                        if let Some(field_ids) = self.r.field_def_ids(did) {\n+                            if field_ids\n+                                .iter()\n+                                .any(|&field_id| ident.name == self.r.tcx.item_name(field_id))\n+                            {\n                                 return Some(AssocSuggestion::Field);\n                             }\n                         }\n@@ -1630,7 +1645,17 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n             ) {\n                 let res = binding.res();\n                 if filter_fn(res) {\n-                    if self.r.has_self.contains(&res.def_id()) {\n+                    let def_id = res.def_id();\n+                    let has_self = match def_id.as_local() {\n+                        Some(def_id) => self.r.has_self.contains(&def_id),\n+                        None => self\n+                            .r\n+                            .tcx\n+                            .fn_arg_names(def_id)\n+                            .first()\n+                            .map_or(false, |ident| ident.name == kw::SelfLower),\n+                    };\n+                    if has_self {\n                         return Some(AssocSuggestion::MethodWithSelf { called });\n                     } else {\n                         match res {\n@@ -1999,11 +2024,12 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n         } else {\n             let needs_placeholder = |ctor_def_id: DefId, kind: CtorKind| {\n                 let def_id = self.r.tcx.parent(ctor_def_id);\n-                let has_no_fields = self.r.field_names.get(&def_id).map_or(false, |f| f.is_empty());\n                 match kind {\n                     CtorKind::Const => false,\n-                    CtorKind::Fn if has_no_fields => false,\n-                    _ => true,\n+                    CtorKind::Fn => !self\n+                        .r\n+                        .field_def_ids(def_id)\n+                        .map_or(false, |field_ids| field_ids.is_empty()),\n                 }\n             };\n \n@@ -2064,9 +2090,7 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n         };\n \n         if def_id.is_local() {\n-            if let Some(span) = self.def_span(def_id) {\n-                err.span_note(span, \"the enum is defined here\");\n-            }\n+            err.span_note(self.r.def_span(def_id), \"the enum is defined here\");\n         }\n     }\n "}, {"sha": "cd90fd3ef84d882ffb0d9a5faa18a7402056e281", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 22, "deletions": 26, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/bd43458d4c2a01af55f7032f7c47d7c8fecfe560/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd43458d4c2a01af55f7032f7c47d7c8fecfe560/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=bd43458d4c2a01af55f7032f7c47d7c8fecfe560", "patch": "@@ -35,7 +35,7 @@ use rustc_errors::{\n use rustc_expand::base::{DeriveResolutions, SyntaxExtension, SyntaxExtensionKind};\n use rustc_hir::def::Namespace::{self, *};\n use rustc_hir::def::{self, CtorOf, DefKind, DocLinkResMap, LifetimeRes, PartialRes, PerNS};\n-use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, LocalDefId};\n+use rustc_hir::def_id::{CrateNum, DefId, LocalDefId, LocalDefIdMap, LocalDefIdSet};\n use rustc_hir::def_id::{CRATE_DEF_ID, LOCAL_CRATE};\n use rustc_hir::definitions::DefPathData;\n use rustc_hir::TraitCandidate;\n@@ -48,10 +48,8 @@ use rustc_middle::span_bug;\n use rustc_middle::ty::{self, MainDefinition, RegisteredTools, TyCtxt};\n use rustc_middle::ty::{ResolverGlobalCtxt, ResolverOutputs};\n use rustc_query_system::ich::StableHashingContext;\n-use rustc_session::cstore::CrateStore;\n use rustc_session::lint::LintBuffer;\n use rustc_span::hygiene::{ExpnId, LocalExpnId, MacroKind, SyntaxContext, Transparency};\n-use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n \n@@ -881,11 +879,8 @@ pub struct Resolver<'a, 'tcx> {\n     extern_prelude: FxHashMap<Ident, ExternPreludeEntry<'a>>,\n \n     /// N.B., this is used only for better diagnostics, not name resolution itself.\n-    has_self: FxHashSet<DefId>,\n-\n-    /// Names of fields of an item `DefId` accessible with dot syntax.\n-    /// Used for hints during error reporting.\n-    field_names: FxHashMap<DefId, Vec<Spanned<Symbol>>>,\n+    has_self: LocalDefIdSet,\n+    field_def_ids: LocalDefIdMap<&'tcx [DefId]>,\n \n     /// Span of the privacy modifier in fields of an item `DefId` accessible with dot syntax.\n     /// Used for hints during error reporting.\n@@ -1009,7 +1004,7 @@ pub struct Resolver<'a, 'tcx> {\n     /// Table for mapping struct IDs into struct constructor IDs,\n     /// it's not used during normal resolution, only for better error reporting.\n     /// Also includes of list of each fields visibility\n-    struct_constructors: DefIdMap<(Res, ty::Visibility<DefId>, Vec<ty::Visibility<DefId>>)>,\n+    struct_constructors: LocalDefIdMap<(Res, ty::Visibility<DefId>, Vec<ty::Visibility<DefId>>)>,\n \n     /// Features enabled for this crate.\n     active_features: FxHashSet<Symbol>,\n@@ -1249,8 +1244,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             prelude: None,\n             extern_prelude,\n \n-            has_self: FxHashSet::default(),\n-            field_names: FxHashMap::default(),\n+            has_self: Default::default(),\n+            field_def_ids: Default::default(),\n             field_visibility_spans: FxHashMap::default(),\n \n             determined_imports: Vec::new(),\n@@ -1436,9 +1431,11 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     }\n \n     fn crate_loader<T>(&mut self, f: impl FnOnce(&mut CrateLoader<'_, '_>) -> T) -> T {\n-        let mut cstore = self.tcx.untracked().cstore.write();\n-        let cstore = cstore.untracked_as_any().downcast_mut().unwrap();\n-        f(&mut CrateLoader::new(self.tcx, &mut *cstore, &mut self.used_extern_options))\n+        f(&mut CrateLoader::new(\n+            self.tcx,\n+            &mut CStore::from_tcx_mut(self.tcx),\n+            &mut self.used_extern_options,\n+        ))\n     }\n \n     fn cstore(&self) -> MappedReadGuard<'_, CStore> {\n@@ -1870,20 +1867,19 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         }\n     }\n \n-    /// Retrieves the span of the given `DefId` if `DefId` is in the local crate.\n-    #[inline]\n-    fn opt_span(&self, def_id: DefId) -> Option<Span> {\n-        def_id.as_local().map(|def_id| self.tcx.source_span(def_id))\n+    /// Retrieves definition span of the given `DefId`.\n+    fn def_span(&self, def_id: DefId) -> Span {\n+        match def_id.as_local() {\n+            Some(def_id) => self.tcx.source_span(def_id),\n+            None => self.cstore().get_span_untracked(def_id, self.tcx.sess),\n+        }\n     }\n \n-    /// Retrieves the name of the given `DefId`.\n-    #[inline]\n-    fn opt_name(&self, def_id: DefId) -> Option<Symbol> {\n-        let def_key = match def_id.as_local() {\n-            Some(def_id) => self.tcx.definitions_untracked().def_key(def_id),\n-            None => self.cstore().def_key(def_id),\n-        };\n-        def_key.get_opt_name()\n+    fn field_def_ids(&self, def_id: DefId) -> Option<&'tcx [DefId]> {\n+        match def_id.as_local() {\n+            Some(def_id) => self.field_def_ids.get(&def_id).copied(),\n+            None => Some(self.tcx.associated_item_def_ids(def_id)),\n+        }\n     }\n \n     /// Checks if an expression refers to a function marked with"}, {"sha": "45001c7975324e48e087cfd1b3cbb70e362c2992", "filename": "tests/ui/empty/empty-struct-tuple-pat.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bd43458d4c2a01af55f7032f7c47d7c8fecfe560/tests%2Fui%2Fempty%2Fempty-struct-tuple-pat.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bd43458d4c2a01af55f7032f7c47d7c8fecfe560/tests%2Fui%2Fempty%2Fempty-struct-tuple-pat.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fempty%2Fempty-struct-tuple-pat.stderr?ref=bd43458d4c2a01af55f7032f7c47d7c8fecfe560", "patch": "@@ -46,8 +46,8 @@ LL |     XEmpty5(),\n    |\n help: use the tuple variant pattern syntax instead\n    |\n-LL |         XE::XEmpty5(/* fields */) => (),\n-   |         ~~~~~~~~~~~~~~~~~~~~~~~~~\n+LL |         XE::XEmpty5() => (),\n+   |         ~~~~~~~~~~~~~\n help: a unit variant with a similar name exists\n    |\n LL |         XE::XEmpty4 => (),"}, {"sha": "0d7f2e4af69aa5be95050f1d00a501b24b05cb21", "filename": "tests/ui/pattern/pat-tuple-field-count-cross.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bd43458d4c2a01af55f7032f7c47d7c8fecfe560/tests%2Fui%2Fpattern%2Fpat-tuple-field-count-cross.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bd43458d4c2a01af55f7032f7c47d7c8fecfe560/tests%2Fui%2Fpattern%2Fpat-tuple-field-count-cross.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern%2Fpat-tuple-field-count-cross.stderr?ref=bd43458d4c2a01af55f7032f7c47d7c8fecfe560", "patch": "@@ -113,8 +113,8 @@ LL | pub enum E1 { Z0, Z1(), S(u8, u8, u8) }\n    |\n help: use the tuple variant pattern syntax instead\n    |\n-LL |         E1::Z1(/* fields */) => {}\n-   |         ~~~~~~~~~~~~~~~~~~~~\n+LL |         E1::Z1() => {}\n+   |         ~~~~~~~~\n help: a unit variant with a similar name exists\n    |\n LL |         E1::Z0 => {}"}]}