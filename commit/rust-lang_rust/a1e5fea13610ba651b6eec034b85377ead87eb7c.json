{"sha": "a1e5fea13610ba651b6eec034b85377ead87eb7c", "node_id": "C_kwDOAAsO6NoAKGExZTVmZWExMzYxMGJhNjUxYjZlZWMwMzRiODUzNzdlYWQ4N2ViN2M", "commit": {"author": {"name": "Nilstrieb", "email": "48135649+Nilstrieb@users.noreply.github.com", "date": "2022-11-20T12:06:44Z"}, "committer": {"name": "Nilstrieb", "email": "48135649+Nilstrieb@users.noreply.github.com", "date": "2022-11-20T12:06:44Z"}, "message": "Move macro_rules diagnostics to diagnostics module", "tree": {"sha": "b490a3d8bba5391f6ea790aba0688f1f75085980", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b490a3d8bba5391f6ea790aba0688f1f75085980"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a1e5fea13610ba651b6eec034b85377ead87eb7c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN SSH SIGNATURE-----\nU1NIU0lHAAAAAQAAADMAAAALc3NoLWVkMjU1MTkAAAAgbSfWKRQb2tiqhuHtakDJeupmrF\nChDbM0msU+PXaBOk8AAAADZ2l0AAAAAAAAAAZzaGE1MTIAAABTAAAAC3NzaC1lZDI1NTE5\nAAAAQIQb2Ym9An+6OA7l2L9OSz1twWEfmdRI3RuN/krb9JDXdy8Z9y9qTbzwUFY0Pt78Do\nwQgvUvarSwq2c057iXCQw=\n-----END SSH SIGNATURE-----", "payload": "tree b490a3d8bba5391f6ea790aba0688f1f75085980\nparent e07425d55b77fde99af2092a92109a0da0860692\nauthor Nilstrieb <48135649+Nilstrieb@users.noreply.github.com> 1668946004 +0100\ncommitter Nilstrieb <48135649+Nilstrieb@users.noreply.github.com> 1668946004 +0100\n\nMove macro_rules diagnostics to diagnostics module\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a1e5fea13610ba651b6eec034b85377ead87eb7c", "html_url": "https://github.com/rust-lang/rust/commit/a1e5fea13610ba651b6eec034b85377ead87eb7c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a1e5fea13610ba651b6eec034b85377ead87eb7c/comments", "author": {"login": "Nilstrieb", "id": 48135649, "node_id": "MDQ6VXNlcjQ4MTM1NjQ5", "avatar_url": "https://avatars.githubusercontent.com/u/48135649?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nilstrieb", "html_url": "https://github.com/Nilstrieb", "followers_url": "https://api.github.com/users/Nilstrieb/followers", "following_url": "https://api.github.com/users/Nilstrieb/following{/other_user}", "gists_url": "https://api.github.com/users/Nilstrieb/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nilstrieb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nilstrieb/subscriptions", "organizations_url": "https://api.github.com/users/Nilstrieb/orgs", "repos_url": "https://api.github.com/users/Nilstrieb/repos", "events_url": "https://api.github.com/users/Nilstrieb/events{/privacy}", "received_events_url": "https://api.github.com/users/Nilstrieb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nilstrieb", "id": 48135649, "node_id": "MDQ6VXNlcjQ4MTM1NjQ5", "avatar_url": "https://avatars.githubusercontent.com/u/48135649?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nilstrieb", "html_url": "https://github.com/Nilstrieb", "followers_url": "https://api.github.com/users/Nilstrieb/followers", "following_url": "https://api.github.com/users/Nilstrieb/following{/other_user}", "gists_url": "https://api.github.com/users/Nilstrieb/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nilstrieb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nilstrieb/subscriptions", "organizations_url": "https://api.github.com/users/Nilstrieb/orgs", "repos_url": "https://api.github.com/users/Nilstrieb/repos", "events_url": "https://api.github.com/users/Nilstrieb/events{/privacy}", "received_events_url": "https://api.github.com/users/Nilstrieb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e07425d55b77fde99af2092a92109a0da0860692", "url": "https://api.github.com/repos/rust-lang/rust/commits/e07425d55b77fde99af2092a92109a0da0860692", "html_url": "https://github.com/rust-lang/rust/commit/e07425d55b77fde99af2092a92109a0da0860692"}], "stats": {"total": 505, "additions": 268, "deletions": 237}, "files": [{"sha": "f7f3075e19bddf8fa328555b38ffa793cabc7a5d", "filename": "compiler/rustc_expand/src/expand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1e5fea13610ba651b6eec034b85377ead87eb7c/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1e5fea13610ba651b6eec034b85377ead87eb7c/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs?ref=a1e5fea13610ba651b6eec034b85377ead87eb7c", "patch": "@@ -1,7 +1,7 @@\n use crate::base::*;\n use crate::config::StripUnconfigured;\n use crate::hygiene::SyntaxContext;\n-use crate::mbe::macro_rules::annotate_err_with_kind;\n+use crate::mbe::diagnostics::annotate_err_with_kind;\n use crate::module::{mod_dir_path, parse_external_mod, DirOwnership, ParsedExternalMod};\n use crate::placeholders::{placeholder, PlaceholderExpander};\n "}, {"sha": "a43b2a001883a38d2cd0ff230b44c7831e7497b8", "filename": "compiler/rustc_expand/src/mbe.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a1e5fea13610ba651b6eec034b85377ead87eb7c/compiler%2Frustc_expand%2Fsrc%2Fmbe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1e5fea13610ba651b6eec034b85377ead87eb7c/compiler%2Frustc_expand%2Fsrc%2Fmbe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe.rs?ref=a1e5fea13610ba651b6eec034b85377ead87eb7c", "patch": "@@ -3,6 +3,7 @@\n //! why we call this module `mbe`. For external documentation, prefer the\n //! official terminology: \"declarative macros\".\n \n+pub(crate) mod diagnostics;\n pub(crate) mod macro_check;\n pub(crate) mod macro_parser;\n pub(crate) mod macro_rules;"}, {"sha": "197f056917f5de75171e64c73c238b82559b7315", "filename": "compiler/rustc_expand/src/mbe/diagnostics.rs", "status": "added", "additions": 257, "deletions": 0, "changes": 257, "blob_url": "https://github.com/rust-lang/rust/blob/a1e5fea13610ba651b6eec034b85377ead87eb7c/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1e5fea13610ba651b6eec034b85377ead87eb7c/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fdiagnostics.rs?ref=a1e5fea13610ba651b6eec034b85377ead87eb7c", "patch": "@@ -0,0 +1,257 @@\n+use std::borrow::Cow;\n+\n+use crate::base::{DummyResult, ExtCtxt, MacResult};\n+use crate::expand::{parse_ast_fragment, AstFragmentKind};\n+use crate::mbe::{\n+    macro_parser::{MatcherLoc, NamedParseResult, ParseResult::*, TtParser},\n+    macro_rules::{try_match_macro, Tracker},\n+};\n+use rustc_ast::token::{self, Token};\n+use rustc_ast::tokenstream::TokenStream;\n+use rustc_ast_pretty::pprust;\n+use rustc_errors::{Applicability, Diagnostic, DiagnosticBuilder, DiagnosticMessage};\n+use rustc_parse::parser::{Parser, Recovery};\n+use rustc_span::source_map::SourceMap;\n+use rustc_span::symbol::Ident;\n+use rustc_span::Span;\n+\n+use super::macro_rules::{parser_from_cx, NoopTracker};\n+\n+pub(super) fn failed_to_match_macro<'cx>(\n+    cx: &'cx mut ExtCtxt<'_>,\n+    sp: Span,\n+    def_span: Span,\n+    name: Ident,\n+    arg: TokenStream,\n+    lhses: &[Vec<MatcherLoc>],\n+) -> Box<dyn MacResult + 'cx> {\n+    let sess = &cx.sess.parse_sess;\n+\n+    // An error occurred, try the expansion again, tracking the expansion closely for better diagnostics.\n+    let mut tracker = CollectTrackerAndEmitter::new(cx, sp);\n+\n+    let try_success_result = try_match_macro(sess, name, &arg, lhses, &mut tracker);\n+\n+    if try_success_result.is_ok() {\n+        // Nonterminal parser recovery might turn failed matches into successful ones,\n+        // but for that it must have emitted an error already\n+        tracker.cx.sess.delay_span_bug(sp, \"Macro matching returned a success on the second try\");\n+    }\n+\n+    if let Some(result) = tracker.result {\n+        // An irrecoverable error occurred and has been emitted.\n+        return result;\n+    }\n+\n+    let Some((token, label, remaining_matcher)) = tracker.best_failure else {\n+        return DummyResult::any(sp);\n+    };\n+\n+    let span = token.span.substitute_dummy(sp);\n+\n+    let mut err = cx.struct_span_err(span, &parse_failure_msg(&token));\n+    err.span_label(span, label);\n+    if !def_span.is_dummy() && !cx.source_map().is_imported(def_span) {\n+        err.span_label(cx.source_map().guess_head_span(def_span), \"when calling this macro\");\n+    }\n+\n+    annotate_doc_comment(&mut err, sess.source_map(), span);\n+\n+    if let Some(span) = remaining_matcher.span() {\n+        err.span_note(span, format!(\"while trying to match {remaining_matcher}\"));\n+    } else {\n+        err.note(format!(\"while trying to match {remaining_matcher}\"));\n+    }\n+\n+    // Check whether there's a missing comma in this macro call, like `println!(\"{}\" a);`\n+    if let Some((arg, comma_span)) = arg.add_comma() {\n+        for lhs in lhses {\n+            let parser = parser_from_cx(sess, arg.clone(), Recovery::Allowed);\n+            let mut tt_parser = TtParser::new(name);\n+\n+            if let Success(_) =\n+                tt_parser.parse_tt(&mut Cow::Borrowed(&parser), lhs, &mut NoopTracker)\n+            {\n+                if comma_span.is_dummy() {\n+                    err.note(\"you might be missing a comma\");\n+                } else {\n+                    err.span_suggestion_short(\n+                        comma_span,\n+                        \"missing comma here\",\n+                        \", \",\n+                        Applicability::MachineApplicable,\n+                    );\n+                }\n+            }\n+        }\n+    }\n+    err.emit();\n+    cx.trace_macros_diag();\n+    DummyResult::any(sp)\n+}\n+\n+/// The tracker used for the slow error path that collects useful info for diagnostics.\n+struct CollectTrackerAndEmitter<'a, 'cx, 'matcher> {\n+    cx: &'a mut ExtCtxt<'cx>,\n+    remaining_matcher: Option<&'matcher MatcherLoc>,\n+    /// Which arm's failure should we report? (the one furthest along)\n+    best_failure: Option<(Token, &'static str, MatcherLoc)>,\n+    root_span: Span,\n+    result: Option<Box<dyn MacResult + 'cx>>,\n+}\n+\n+impl<'a, 'cx, 'matcher> Tracker<'matcher> for CollectTrackerAndEmitter<'a, 'cx, 'matcher> {\n+    fn before_match_loc(&mut self, parser: &TtParser, matcher: &'matcher MatcherLoc) {\n+        if self.remaining_matcher.is_none()\n+            || (parser.has_no_remaining_items_for_step() && *matcher != MatcherLoc::Eof)\n+        {\n+            self.remaining_matcher = Some(matcher);\n+        }\n+    }\n+\n+    fn after_arm(&mut self, result: &NamedParseResult) {\n+        match result {\n+            Success(_) => {\n+                // Nonterminal parser recovery might turn failed matches into successful ones,\n+                // but for that it must have emitted an error already\n+                self.cx.sess.delay_span_bug(\n+                    self.root_span,\n+                    \"should not collect detailed info for successful macro match\",\n+                );\n+            }\n+            Failure(token, msg) => match self.best_failure {\n+                Some((ref best_token, _, _)) if best_token.span.lo() >= token.span.lo() => {}\n+                _ => {\n+                    self.best_failure = Some((\n+                        token.clone(),\n+                        msg,\n+                        self.remaining_matcher\n+                            .expect(\"must have collected matcher already\")\n+                            .clone(),\n+                    ))\n+                }\n+            },\n+            Error(err_sp, msg) => {\n+                let span = err_sp.substitute_dummy(self.root_span);\n+                self.cx.struct_span_err(span, msg).emit();\n+                self.result = Some(DummyResult::any(span));\n+            }\n+            ErrorReported(_) => self.result = Some(DummyResult::any(self.root_span)),\n+        }\n+    }\n+\n+    fn description() -> &'static str {\n+        \"detailed\"\n+    }\n+\n+    fn recovery() -> Recovery {\n+        Recovery::Allowed\n+    }\n+}\n+\n+impl<'a, 'cx> CollectTrackerAndEmitter<'a, 'cx, '_> {\n+    fn new(cx: &'a mut ExtCtxt<'cx>, root_span: Span) -> Self {\n+        Self { cx, remaining_matcher: None, best_failure: None, root_span, result: None }\n+    }\n+}\n+\n+pub(super) fn emit_frag_parse_err(\n+    mut e: DiagnosticBuilder<'_, rustc_errors::ErrorGuaranteed>,\n+    parser: &Parser<'_>,\n+    orig_parser: &mut Parser<'_>,\n+    site_span: Span,\n+    arm_span: Span,\n+    kind: AstFragmentKind,\n+) {\n+    // FIXME(davidtwco): avoid depending on the error message text\n+    if parser.token == token::Eof\n+        && let DiagnosticMessage::Str(message) = &e.message[0].0\n+        && message.ends_with(\", found `<eof>`\")\n+    {\n+        let msg = &e.message[0];\n+        e.message[0] = (\n+            DiagnosticMessage::Str(format!(\n+                \"macro expansion ends with an incomplete expression: {}\",\n+                message.replace(\", found `<eof>`\", \"\"),\n+            )),\n+            msg.1,\n+        );\n+        if !e.span.is_dummy() {\n+            // early end of macro arm (#52866)\n+            e.replace_span_with(parser.token.span.shrink_to_hi());\n+        }\n+    }\n+    if e.span.is_dummy() {\n+        // Get around lack of span in error (#30128)\n+        e.replace_span_with(site_span);\n+        if !parser.sess.source_map().is_imported(arm_span) {\n+            e.span_label(arm_span, \"in this macro arm\");\n+        }\n+    } else if parser.sess.source_map().is_imported(parser.token.span) {\n+        e.span_label(site_span, \"in this macro invocation\");\n+    }\n+    match kind {\n+        // Try a statement if an expression is wanted but failed and suggest adding `;` to call.\n+        AstFragmentKind::Expr => match parse_ast_fragment(orig_parser, AstFragmentKind::Stmts) {\n+            Err(err) => err.cancel(),\n+            Ok(_) => {\n+                e.note(\n+                    \"the macro call doesn't expand to an expression, but it can expand to a statement\",\n+                );\n+                e.span_suggestion_verbose(\n+                    site_span.shrink_to_hi(),\n+                    \"add `;` to interpret the expansion as a statement\",\n+                    \";\",\n+                    Applicability::MaybeIncorrect,\n+                );\n+            }\n+        },\n+        _ => annotate_err_with_kind(&mut e, kind, site_span),\n+    };\n+    e.emit();\n+}\n+\n+pub(crate) fn annotate_err_with_kind(err: &mut Diagnostic, kind: AstFragmentKind, span: Span) {\n+    match kind {\n+        AstFragmentKind::Ty => {\n+            err.span_label(span, \"this macro call doesn't expand to a type\");\n+        }\n+        AstFragmentKind::Pat => {\n+            err.span_label(span, \"this macro call doesn't expand to a pattern\");\n+        }\n+        _ => {}\n+    };\n+}\n+\n+#[derive(Subdiagnostic)]\n+enum ExplainDocComment {\n+    #[label(expand_explain_doc_comment_inner)]\n+    Inner {\n+        #[primary_span]\n+        span: Span,\n+    },\n+    #[label(expand_explain_doc_comment_outer)]\n+    Outer {\n+        #[primary_span]\n+        span: Span,\n+    },\n+}\n+\n+pub(super) fn annotate_doc_comment(err: &mut Diagnostic, sm: &SourceMap, span: Span) {\n+    if let Ok(src) = sm.span_to_snippet(span) {\n+        if src.starts_with(\"///\") || src.starts_with(\"/**\") {\n+            err.subdiagnostic(ExplainDocComment::Outer { span });\n+        } else if src.starts_with(\"//!\") || src.starts_with(\"/*!\") {\n+            err.subdiagnostic(ExplainDocComment::Inner { span });\n+        }\n+    }\n+}\n+\n+/// Generates an appropriate parsing failure message. For EOF, this is \"unexpected end...\". For\n+/// other tokens, this is \"unexpected token...\".\n+pub(super) fn parse_failure_msg(tok: &Token) -> String {\n+    match tok.kind {\n+        token::Eof => \"unexpected end of macro invocation\".to_string(),\n+        _ => format!(\"no rules expected the token `{}`\", pprust::token_to_string(tok),),\n+    }\n+}"}, {"sha": "fc33974dd178034dc22f9d9366a0418913053a4a", "filename": "compiler/rustc_expand/src/mbe/macro_rules.rs", "status": "modified", "additions": 9, "deletions": 236, "changes": 245, "blob_url": "https://github.com/rust-lang/rust/blob/a1e5fea13610ba651b6eec034b85377ead87eb7c/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1e5fea13610ba651b6eec034b85377ead87eb7c/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs?ref=a1e5fea13610ba651b6eec034b85377ead87eb7c", "patch": "@@ -2,6 +2,7 @@ use crate::base::{DummyResult, ExtCtxt, MacResult, TTMacroExpander};\n use crate::base::{SyntaxExtension, SyntaxExtensionKind};\n use crate::expand::{ensure_complete_parse, parse_ast_fragment, AstFragment, AstFragmentKind};\n use crate::mbe;\n+use crate::mbe::diagnostics::{annotate_doc_comment, parse_failure_msg};\n use crate::mbe::macro_check;\n use crate::mbe::macro_parser::{Error, ErrorReported, Failure, Success, TtParser};\n use crate::mbe::macro_parser::{MatchedSeq, MatchedTokenTree, MatcherLoc};\n@@ -14,9 +15,7 @@ use rustc_ast::{NodeId, DUMMY_NODE_ID};\n use rustc_ast_pretty::pprust;\n use rustc_attr::{self as attr, TransparencyError};\n use rustc_data_structures::fx::{FxHashMap, FxIndexMap};\n-use rustc_errors::{\n-    Applicability, Diagnostic, DiagnosticBuilder, DiagnosticMessage, ErrorGuaranteed,\n-};\n+use rustc_errors::{Applicability, ErrorGuaranteed};\n use rustc_feature::Features;\n use rustc_lint_defs::builtin::{\n     RUST_2021_INCOMPATIBLE_OR_PATTERNS, SEMICOLON_IN_EXPRESSIONS_FROM_MACROS,\n@@ -27,14 +26,14 @@ use rustc_session::parse::ParseSess;\n use rustc_session::Session;\n use rustc_span::edition::Edition;\n use rustc_span::hygiene::Transparency;\n-use rustc_span::source_map::SourceMap;\n use rustc_span::symbol::{kw, sym, Ident, MacroRulesNormalizedIdent};\n use rustc_span::Span;\n \n use std::borrow::Cow;\n use std::collections::hash_map::Entry;\n use std::{mem, slice};\n \n+use super::diagnostics;\n use super::macro_parser::{NamedMatches, NamedParseResult};\n \n pub(crate) struct ParserAnyMacro<'a> {\n@@ -51,74 +50,6 @@ pub(crate) struct ParserAnyMacro<'a> {\n     is_local: bool,\n }\n \n-pub(crate) fn annotate_err_with_kind(err: &mut Diagnostic, kind: AstFragmentKind, span: Span) {\n-    match kind {\n-        AstFragmentKind::Ty => {\n-            err.span_label(span, \"this macro call doesn't expand to a type\");\n-        }\n-        AstFragmentKind::Pat => {\n-            err.span_label(span, \"this macro call doesn't expand to a pattern\");\n-        }\n-        _ => {}\n-    };\n-}\n-\n-fn emit_frag_parse_err(\n-    mut e: DiagnosticBuilder<'_, rustc_errors::ErrorGuaranteed>,\n-    parser: &Parser<'_>,\n-    orig_parser: &mut Parser<'_>,\n-    site_span: Span,\n-    arm_span: Span,\n-    kind: AstFragmentKind,\n-) {\n-    // FIXME(davidtwco): avoid depending on the error message text\n-    if parser.token == token::Eof\n-        && let DiagnosticMessage::Str(message) = &e.message[0].0\n-        && message.ends_with(\", found `<eof>`\")\n-    {\n-        let msg = &e.message[0];\n-        e.message[0] = (\n-            DiagnosticMessage::Str(format!(\n-                \"macro expansion ends with an incomplete expression: {}\",\n-                message.replace(\", found `<eof>`\", \"\"),\n-            )),\n-            msg.1,\n-        );\n-        if !e.span.is_dummy() {\n-            // early end of macro arm (#52866)\n-            e.replace_span_with(parser.token.span.shrink_to_hi());\n-        }\n-    }\n-    if e.span.is_dummy() {\n-        // Get around lack of span in error (#30128)\n-        e.replace_span_with(site_span);\n-        if !parser.sess.source_map().is_imported(arm_span) {\n-            e.span_label(arm_span, \"in this macro arm\");\n-        }\n-    } else if parser.sess.source_map().is_imported(parser.token.span) {\n-        e.span_label(site_span, \"in this macro invocation\");\n-    }\n-    match kind {\n-        // Try a statement if an expression is wanted but failed and suggest adding `;` to call.\n-        AstFragmentKind::Expr => match parse_ast_fragment(orig_parser, AstFragmentKind::Stmts) {\n-            Err(err) => err.cancel(),\n-            Ok(_) => {\n-                e.note(\n-                    \"the macro call doesn't expand to an expression, but it can expand to a statement\",\n-                );\n-                e.span_suggestion_verbose(\n-                    site_span.shrink_to_hi(),\n-                    \"add `;` to interpret the expansion as a statement\",\n-                    \";\",\n-                    Applicability::MaybeIncorrect,\n-                );\n-            }\n-        },\n-        _ => annotate_err_with_kind(&mut e, kind, site_span),\n-    };\n-    e.emit();\n-}\n-\n impl<'a> ParserAnyMacro<'a> {\n     pub(crate) fn make(mut self: Box<ParserAnyMacro<'a>>, kind: AstFragmentKind) -> AstFragment {\n         let ParserAnyMacro {\n@@ -134,7 +65,7 @@ impl<'a> ParserAnyMacro<'a> {\n         let fragment = match parse_ast_fragment(parser, kind) {\n             Ok(f) => f,\n             Err(err) => {\n-                emit_frag_parse_err(err, parser, snapshot, site_span, arm_span, kind);\n+                diagnostics::emit_frag_parse_err(err, parser, snapshot, site_span, arm_span, kind);\n                 return kind.dummy(site_span);\n             }\n         };\n@@ -224,7 +155,7 @@ pub(super) trait Tracker<'matcher> {\n }\n \n /// A noop tracker that is used in the hot path of the expansion, has zero overhead thanks to monomorphization.\n-struct NoopTracker;\n+pub(super) struct NoopTracker;\n \n impl<'matcher> Tracker<'matcher> for NoopTracker {\n     fn before_match_loc(&mut self, _: &TtParser, _: &'matcher MatcherLoc) {}\n@@ -331,135 +262,10 @@ fn expand_macro<'cx>(\n         }\n     }\n \n-    // An error occurred, try the expansion again, tracking the expansion closely for better diagnostics.\n-    let mut tracker = CollectTrackerAndEmitter::new(cx, sp);\n-\n-    let try_success_result = try_match_macro(sess, name, &arg, lhses, &mut tracker);\n-\n-    if try_success_result.is_ok() {\n-        // Nonterminal parser recovery might turn failed matches into successful ones,\n-        // but for that it must have emitted an error already\n-        tracker.cx.sess.delay_span_bug(sp, \"Macro matching returned a success on the second try\");\n-    }\n-\n-    if let Some(result) = tracker.result {\n-        // An irrecoverable error occurred and has been emitted.\n-        return result;\n-    }\n-\n-    let Some((token, label, remaining_matcher)) = tracker.best_failure else {\n-        return DummyResult::any(sp);\n-    };\n-\n-    let span = token.span.substitute_dummy(sp);\n-\n-    let mut err = cx.struct_span_err(span, &parse_failure_msg(&token));\n-    err.span_label(span, label);\n-    if !def_span.is_dummy() && !cx.source_map().is_imported(def_span) {\n-        err.span_label(cx.source_map().guess_head_span(def_span), \"when calling this macro\");\n-    }\n-\n-    annotate_doc_comment(&mut err, sess.source_map(), span);\n-\n-    if let Some(span) = remaining_matcher.span() {\n-        err.span_note(span, format!(\"while trying to match {remaining_matcher}\"));\n-    } else {\n-        err.note(format!(\"while trying to match {remaining_matcher}\"));\n-    }\n-\n-    // Check whether there's a missing comma in this macro call, like `println!(\"{}\" a);`\n-    if let Some((arg, comma_span)) = arg.add_comma() {\n-        for lhs in lhses {\n-            let parser = parser_from_cx(sess, arg.clone(), Recovery::Allowed);\n-            let mut tt_parser = TtParser::new(name);\n-\n-            if let Success(_) =\n-                tt_parser.parse_tt(&mut Cow::Borrowed(&parser), lhs, &mut NoopTracker)\n-            {\n-                if comma_span.is_dummy() {\n-                    err.note(\"you might be missing a comma\");\n-                } else {\n-                    err.span_suggestion_short(\n-                        comma_span,\n-                        \"missing comma here\",\n-                        \", \",\n-                        Applicability::MachineApplicable,\n-                    );\n-                }\n-            }\n-        }\n-    }\n-    err.emit();\n-    cx.trace_macros_diag();\n-    DummyResult::any(sp)\n+    diagnostics::failed_to_match_macro(cx, sp, def_span, name, arg, lhses)\n }\n \n-/// The tracker used for the slow error path that collects useful info for diagnostics.\n-struct CollectTrackerAndEmitter<'a, 'cx, 'matcher> {\n-    cx: &'a mut ExtCtxt<'cx>,\n-    remaining_matcher: Option<&'matcher MatcherLoc>,\n-    /// Which arm's failure should we report? (the one furthest along)\n-    best_failure: Option<(Token, &'static str, MatcherLoc)>,\n-    root_span: Span,\n-    result: Option<Box<dyn MacResult + 'cx>>,\n-}\n-\n-impl<'a, 'cx, 'matcher> Tracker<'matcher> for CollectTrackerAndEmitter<'a, 'cx, 'matcher> {\n-    fn before_match_loc(&mut self, parser: &TtParser, matcher: &'matcher MatcherLoc) {\n-        if self.remaining_matcher.is_none()\n-            || (parser.has_no_remaining_items_for_step() && *matcher != MatcherLoc::Eof)\n-        {\n-            self.remaining_matcher = Some(matcher);\n-        }\n-    }\n-\n-    fn after_arm(&mut self, result: &NamedParseResult) {\n-        match result {\n-            Success(_) => {\n-                // Nonterminal parser recovery might turn failed matches into successful ones,\n-                // but for that it must have emitted an error already\n-                self.cx.sess.delay_span_bug(\n-                    self.root_span,\n-                    \"should not collect detailed info for successful macro match\",\n-                );\n-            }\n-            Failure(token, msg) => match self.best_failure {\n-                Some((ref best_token, _, _)) if best_token.span.lo() >= token.span.lo() => {}\n-                _ => {\n-                    self.best_failure = Some((\n-                        token.clone(),\n-                        msg,\n-                        self.remaining_matcher\n-                            .expect(\"must have collected matcher already\")\n-                            .clone(),\n-                    ))\n-                }\n-            },\n-            Error(err_sp, msg) => {\n-                let span = err_sp.substitute_dummy(self.root_span);\n-                self.cx.struct_span_err(span, msg).emit();\n-                self.result = Some(DummyResult::any(span));\n-            }\n-            ErrorReported(_) => self.result = Some(DummyResult::any(self.root_span)),\n-        }\n-    }\n-\n-    fn description() -> &'static str {\n-        \"detailed\"\n-    }\n-\n-    fn recovery() -> Recovery {\n-        Recovery::Allowed\n-    }\n-}\n-\n-impl<'a, 'cx> CollectTrackerAndEmitter<'a, 'cx, '_> {\n-    fn new(cx: &'a mut ExtCtxt<'cx>, root_span: Span) -> Self {\n-        Self { cx, remaining_matcher: None, best_failure: None, root_span, result: None }\n-    }\n-}\n-\n-enum CanRetry {\n+pub(super) enum CanRetry {\n     Yes,\n     /// We are not allowed to retry macro expansion as a fatal error has been emitted already.\n     No(ErrorGuaranteed),\n@@ -469,7 +275,7 @@ enum CanRetry {\n /// and nothing if it failed. On failure, it's the callers job to use `track` accordingly to record all errors\n /// correctly.\n #[instrument(level = \"debug\", skip(sess, arg, lhses, track), fields(tracking = %T::description()))]\n-fn try_match_macro<'matcher, T: Tracker<'matcher>>(\n+pub(super) fn try_match_macro<'matcher, T: Tracker<'matcher>>(\n     sess: &ParseSess,\n     name: Ident,\n     arg: &TokenStream,\n@@ -769,30 +575,6 @@ pub fn compile_declarative_macro(\n     (mk_syn_ext(expander), rule_spans)\n }\n \n-#[derive(Subdiagnostic)]\n-enum ExplainDocComment {\n-    #[label(expand_explain_doc_comment_inner)]\n-    Inner {\n-        #[primary_span]\n-        span: Span,\n-    },\n-    #[label(expand_explain_doc_comment_outer)]\n-    Outer {\n-        #[primary_span]\n-        span: Span,\n-    },\n-}\n-\n-fn annotate_doc_comment(err: &mut Diagnostic, sm: &SourceMap, span: Span) {\n-    if let Ok(src) = sm.span_to_snippet(span) {\n-        if src.starts_with(\"///\") || src.starts_with(\"/**\") {\n-            err.subdiagnostic(ExplainDocComment::Outer { span });\n-        } else if src.starts_with(\"//!\") || src.starts_with(\"/*!\") {\n-            err.subdiagnostic(ExplainDocComment::Inner { span });\n-        }\n-    }\n-}\n-\n fn check_lhs_nt_follows(sess: &ParseSess, def: &ast::Item, lhs: &mbe::TokenTree) -> bool {\n     // lhs is going to be like TokenTree::Delimited(...), where the\n     // entire lhs is those tts. Or, it can be a \"bare sequence\", not wrapped in parens.\n@@ -1577,15 +1359,6 @@ fn quoted_tt_to_string(tt: &mbe::TokenTree) -> String {\n     }\n }\n \n-fn parser_from_cx(sess: &ParseSess, tts: TokenStream, recovery: Recovery) -> Parser<'_> {\n+pub(super) fn parser_from_cx(sess: &ParseSess, tts: TokenStream, recovery: Recovery) -> Parser<'_> {\n     Parser::new(sess, tts, true, rustc_parse::MACRO_ARGUMENTS).recovery(recovery)\n }\n-\n-/// Generates an appropriate parsing failure message. For EOF, this is \"unexpected end...\". For\n-/// other tokens, this is \"unexpected token...\".\n-fn parse_failure_msg(tok: &Token) -> String {\n-    match tok.kind {\n-        token::Eof => \"unexpected end of macro invocation\".to_string(),\n-        _ => format!(\"no rules expected the token `{}`\", pprust::token_to_string(tok),),\n-    }\n-}"}]}