{"sha": "408e2ac3bb35a54529ea0647a024fb817a27a8c2", "node_id": "C_kwDOAAsO6NoAKDQwOGUyYWMzYmIzNWE1NDUyOWVhMDY0N2EwMjRmYjgxN2EyN2E4YzI", "commit": {"author": {"name": "Scott McMurray", "email": "scottmcm@users.noreply.github.com", "date": "2023-03-30T18:19:38Z"}, "committer": {"name": "Scott McMurray", "email": "scottmcm@users.noreply.github.com", "date": "2023-03-30T18:19:53Z"}, "message": "Add `IndexSlice` to go with `IndexVec`\n\nMoves the methods that don't need full `IndexVec`-ness over to `IndexSlice`, and have `IndexVec` deref to `IndexSlice` so everything keeps working.", "tree": {"sha": "07114dd1b3dd8ce72bd7db46535abcee5abc73c8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/07114dd1b3dd8ce72bd7db46535abcee5abc73c8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/408e2ac3bb35a54529ea0647a024fb817a27a8c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/408e2ac3bb35a54529ea0647a024fb817a27a8c2", "html_url": "https://github.com/rust-lang/rust/commit/408e2ac3bb35a54529ea0647a024fb817a27a8c2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/408e2ac3bb35a54529ea0647a024fb817a27a8c2/comments", "author": {"login": "scottmcm", "id": 18526288, "node_id": "MDQ6VXNlcjE4NTI2Mjg4", "avatar_url": "https://avatars.githubusercontent.com/u/18526288?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottmcm", "html_url": "https://github.com/scottmcm", "followers_url": "https://api.github.com/users/scottmcm/followers", "following_url": "https://api.github.com/users/scottmcm/following{/other_user}", "gists_url": "https://api.github.com/users/scottmcm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottmcm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottmcm/subscriptions", "organizations_url": "https://api.github.com/users/scottmcm/orgs", "repos_url": "https://api.github.com/users/scottmcm/repos", "events_url": "https://api.github.com/users/scottmcm/events{/privacy}", "received_events_url": "https://api.github.com/users/scottmcm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "scottmcm", "id": 18526288, "node_id": "MDQ6VXNlcjE4NTI2Mjg4", "avatar_url": "https://avatars.githubusercontent.com/u/18526288?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottmcm", "html_url": "https://github.com/scottmcm", "followers_url": "https://api.github.com/users/scottmcm/followers", "following_url": "https://api.github.com/users/scottmcm/following{/other_user}", "gists_url": "https://api.github.com/users/scottmcm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottmcm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottmcm/subscriptions", "organizations_url": "https://api.github.com/users/scottmcm/orgs", "repos_url": "https://api.github.com/users/scottmcm/repos", "events_url": "https://api.github.com/users/scottmcm/events{/privacy}", "received_events_url": "https://api.github.com/users/scottmcm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "10338571cfa7c2be0aeed309141ced91454d41e1", "url": "https://api.github.com/repos/rust-lang/rust/commits/10338571cfa7c2be0aeed309141ced91454d41e1", "html_url": "https://github.com/rust-lang/rust/commit/10338571cfa7c2be0aeed309141ced91454d41e1"}], "stats": {"total": 230, "additions": 160, "deletions": 70}, "files": [{"sha": "596849bd456825cc80b8cfb21213f73e5072d1dc", "filename": "compiler/rustc_index/src/vec.rs", "status": "modified", "additions": 160, "deletions": 70, "changes": 230, "blob_url": "https://github.com/rust-lang/rust/blob/408e2ac3bb35a54529ea0647a024fb817a27a8c2/compiler%2Frustc_index%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/408e2ac3bb35a54529ea0647a024fb817a27a8c2/compiler%2Frustc_index%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2Fsrc%2Fvec.rs?ref=408e2ac3bb35a54529ea0647a024fb817a27a8c2", "patch": "@@ -5,7 +5,7 @@ use std::fmt;\n use std::fmt::Debug;\n use std::hash::Hash;\n use std::marker::PhantomData;\n-use std::ops::{Index, IndexMut, RangeBounds};\n+use std::ops::{Deref, DerefMut, Index, IndexMut, RangeBounds};\n use std::slice;\n use std::vec;\n \n@@ -52,15 +52,27 @@ impl Idx for u32 {\n }\n \n #[derive(Clone, PartialEq, Eq, Hash)]\n+#[repr(transparent)]\n pub struct IndexVec<I: Idx, T> {\n     pub raw: Vec<T>,\n     _marker: PhantomData<fn(&I)>,\n }\n \n+#[derive(PartialEq, Eq, Hash)]\n+#[repr(transparent)]\n+pub struct IndexSlice<I: Idx, T> {\n+    _marker: PhantomData<fn(&I)>,\n+    pub raw: [T],\n+}\n+\n // Whether `IndexVec` is `Send` depends only on the data,\n // not the phantom data.\n unsafe impl<I: Idx, T> Send for IndexVec<I, T> where T: Send {}\n \n+// Whether `IndexSlice` is `Send` depends only on the data,\n+// not the phantom data.\n+unsafe impl<I: Idx, T> Send for IndexSlice<I, T> where T: Send {}\n+\n #[cfg(feature = \"rustc_serialize\")]\n impl<S: Encoder, I: Idx, T: Encodable<S>> Encodable<S> for IndexVec<I, T> {\n     fn encode(&self, s: &mut S) {\n@@ -122,6 +134,16 @@ impl<I: Idx, T> IndexVec<I, T> {\n         Self::from_raw(indices.map(func).collect())\n     }\n \n+    #[inline]\n+    pub fn as_slice(&self) -> &IndexSlice<I, T> {\n+        IndexSlice::from_raw(&self.raw)\n+    }\n+\n+    #[inline]\n+    pub fn as_mut_slice(&mut self) -> &mut IndexSlice<I, T> {\n+        IndexSlice::from_raw_mut(&mut self.raw)\n+    }\n+\n     #[inline]\n     pub fn push(&mut self, d: T) -> I {\n         let idx = I::new(self.len());\n@@ -135,32 +157,119 @@ impl<I: Idx, T> IndexVec<I, T> {\n     }\n \n     #[inline]\n-    pub fn len(&self) -> usize {\n-        self.raw.len()\n+    pub fn into_iter(self) -> vec::IntoIter<T> {\n+        self.raw.into_iter()\n     }\n \n-    /// Gives the next index that will be assigned when `push` is\n-    /// called.\n     #[inline]\n-    pub fn next_index(&self) -> I {\n-        I::new(self.len())\n+    pub fn into_iter_enumerated(\n+        self,\n+    ) -> impl DoubleEndedIterator<Item = (I, T)> + ExactSizeIterator {\n+        self.raw.into_iter().enumerate().map(|(n, t)| (I::new(n), t))\n     }\n \n     #[inline]\n-    pub fn is_empty(&self) -> bool {\n-        self.raw.is_empty()\n+    pub fn drain<'a, R: RangeBounds<usize>>(\n+        &'a mut self,\n+        range: R,\n+    ) -> impl Iterator<Item = T> + 'a {\n+        self.raw.drain(range)\n     }\n \n     #[inline]\n-    pub fn into_iter(self) -> vec::IntoIter<T> {\n-        self.raw.into_iter()\n+    pub fn drain_enumerated<'a, R: RangeBounds<usize>>(\n+        &'a mut self,\n+        range: R,\n+    ) -> impl Iterator<Item = (I, T)> + 'a {\n+        let begin = match range.start_bound() {\n+            std::ops::Bound::Included(i) => *i,\n+            std::ops::Bound::Excluded(i) => i.checked_add(1).unwrap(),\n+            std::ops::Bound::Unbounded => 0,\n+        };\n+        self.raw.drain(range).enumerate().map(move |(n, t)| (I::new(begin + n), t))\n     }\n \n     #[inline]\n-    pub fn into_iter_enumerated(\n-        self,\n-    ) -> impl DoubleEndedIterator<Item = (I, T)> + ExactSizeIterator {\n-        self.raw.into_iter().enumerate().map(|(n, t)| (I::new(n), t))\n+    pub fn shrink_to_fit(&mut self) {\n+        self.raw.shrink_to_fit()\n+    }\n+\n+    #[inline]\n+    pub fn truncate(&mut self, a: usize) {\n+        self.raw.truncate(a)\n+    }\n+\n+    pub fn convert_index_type<Ix: Idx>(self) -> IndexVec<Ix, T> {\n+        IndexVec { raw: self.raw, _marker: PhantomData }\n+    }\n+\n+    /// Grows the index vector so that it contains an entry for\n+    /// `elem`; if that is already true, then has no\n+    /// effect. Otherwise, inserts new values as needed by invoking\n+    /// `fill_value`.\n+    #[inline]\n+    pub fn ensure_contains_elem(&mut self, elem: I, fill_value: impl FnMut() -> T) {\n+        let min_new_len = elem.index() + 1;\n+        if self.len() < min_new_len {\n+            self.raw.resize_with(min_new_len, fill_value);\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn resize_to_elem(&mut self, elem: I, fill_value: impl FnMut() -> T) {\n+        let min_new_len = elem.index() + 1;\n+        self.raw.resize_with(min_new_len, fill_value);\n+    }\n+}\n+\n+impl<I: Idx, T> Deref for IndexVec<I, T> {\n+    type Target = IndexSlice<I, T>;\n+\n+    #[inline]\n+    fn deref(&self) -> &Self::Target {\n+        self.as_slice()\n+    }\n+}\n+\n+impl<I: Idx, T> DerefMut for IndexVec<I, T> {\n+    #[inline]\n+    fn deref_mut(&mut self) -> &mut Self::Target {\n+        self.as_mut_slice()\n+    }\n+}\n+\n+impl<I: Idx, T> IndexSlice<I, T> {\n+    #[inline]\n+    pub fn from_raw(raw: &[T]) -> &Self {\n+        let ptr: *const [T] = raw;\n+        // SAFETY: `IndexSlice` is `repr(transparent)` over a normal slice\n+        unsafe { &*(ptr as *const Self) }\n+    }\n+\n+    #[inline]\n+    pub fn from_raw_mut(raw: &mut [T]) -> &mut Self {\n+        let ptr: *mut [T] = raw;\n+        // SAFETY: `IndexSlice` is `repr(transparent)` over a normal slice\n+        unsafe { &mut *(ptr as *mut Self) }\n+    }\n+\n+    #[inline]\n+    pub fn len(&self) -> usize {\n+        self.raw.len()\n+    }\n+\n+    /// Gives the next index that will be assigned when `push` is called.\n+    ///\n+    /// Manual bounds checks can be done using `idx < slice.next_index()`\n+    /// (as opposed to `idx.index() < slice.len()`).\n+    #[inline]\n+    pub fn next_index(&self) -> I {\n+        I::new(self.len())\n+    }\n+\n+    #[inline]\n+    pub fn is_empty(&self) -> bool {\n+        self.raw.is_empty()\n     }\n \n     #[inline]\n@@ -194,47 +303,16 @@ impl<I: Idx, T> IndexVec<I, T> {\n         self.raw.iter_mut().enumerate().map(|(n, t)| (I::new(n), t))\n     }\n \n-    #[inline]\n-    pub fn drain<'a, R: RangeBounds<usize>>(\n-        &'a mut self,\n-        range: R,\n-    ) -> impl Iterator<Item = T> + 'a {\n-        self.raw.drain(range)\n-    }\n-\n-    #[inline]\n-    pub fn drain_enumerated<'a, R: RangeBounds<usize>>(\n-        &'a mut self,\n-        range: R,\n-    ) -> impl Iterator<Item = (I, T)> + 'a {\n-        let begin = match range.start_bound() {\n-            std::ops::Bound::Included(i) => *i,\n-            std::ops::Bound::Excluded(i) => i.checked_add(1).unwrap(),\n-            std::ops::Bound::Unbounded => 0,\n-        };\n-        self.raw.drain(range).enumerate().map(move |(n, t)| (I::new(begin + n), t))\n-    }\n-\n     #[inline]\n     pub fn last_index(&self) -> Option<I> {\n         self.len().checked_sub(1).map(I::new)\n     }\n \n-    #[inline]\n-    pub fn shrink_to_fit(&mut self) {\n-        self.raw.shrink_to_fit()\n-    }\n-\n     #[inline]\n     pub fn swap(&mut self, a: I, b: I) {\n         self.raw.swap(a.index(), b.index())\n     }\n \n-    #[inline]\n-    pub fn truncate(&mut self, a: usize) {\n-        self.raw.truncate(a)\n-    }\n-\n     #[inline]\n     pub fn get(&self, index: I) -> Option<&T> {\n         self.raw.get(index.index())\n@@ -274,28 +352,6 @@ impl<I: Idx, T> IndexVec<I, T> {\n         let ptr = self.raw.as_mut_ptr();\n         unsafe { (&mut *ptr.add(ai), &mut *ptr.add(bi), &mut *ptr.add(ci)) }\n     }\n-\n-    pub fn convert_index_type<Ix: Idx>(self) -> IndexVec<Ix, T> {\n-        IndexVec { raw: self.raw, _marker: PhantomData }\n-    }\n-\n-    /// Grows the index vector so that it contains an entry for\n-    /// `elem`; if that is already true, then has no\n-    /// effect. Otherwise, inserts new values as needed by invoking\n-    /// `fill_value`.\n-    #[inline]\n-    pub fn ensure_contains_elem(&mut self, elem: I, fill_value: impl FnMut() -> T) {\n-        let min_new_len = elem.index() + 1;\n-        if self.len() < min_new_len {\n-            self.raw.resize_with(min_new_len, fill_value);\n-        }\n-    }\n-\n-    #[inline]\n-    pub fn resize_to_elem(&mut self, elem: I, fill_value: impl FnMut() -> T) {\n-        let min_new_len = elem.index() + 1;\n-        self.raw.resize_with(min_new_len, fill_value);\n-    }\n }\n \n /// `IndexVec` is often used as a map, so it provides some map-like APIs.\n@@ -336,7 +392,7 @@ impl<I: Idx, T: Ord> IndexVec<I, T> {\n     }\n }\n \n-impl<I: Idx, T> Index<I> for IndexVec<I, T> {\n+impl<I: Idx, T> Index<I> for IndexSlice<I, T> {\n     type Output = T;\n \n     #[inline]\n@@ -345,7 +401,7 @@ impl<I: Idx, T> Index<I> for IndexVec<I, T> {\n     }\n }\n \n-impl<I: Idx, T> IndexMut<I> for IndexVec<I, T> {\n+impl<I: Idx, T> IndexMut<I> for IndexSlice<I, T> {\n     #[inline]\n     fn index_mut(&mut self, index: I) -> &mut T {\n         &mut self.raw[index.index()]\n@@ -359,6 +415,20 @@ impl<I: Idx, T> Default for IndexVec<I, T> {\n     }\n }\n \n+impl<I: Idx, T> Default for &IndexSlice<I, T> {\n+    #[inline]\n+    fn default() -> Self {\n+        IndexSlice::from_raw(Default::default())\n+    }\n+}\n+\n+impl<I: Idx, T> Default for &mut IndexSlice<I, T> {\n+    #[inline]\n+    fn default() -> Self {\n+        IndexSlice::from_raw_mut(Default::default())\n+    }\n+}\n+\n impl<I: Idx, T> Extend<T> for IndexVec<I, T> {\n     #[inline]\n     fn extend<J: IntoIterator<Item = T>>(&mut self, iter: J) {\n@@ -418,5 +488,25 @@ impl<'a, I: Idx, T> IntoIterator for &'a mut IndexVec<I, T> {\n     }\n }\n \n+impl<'a, I: Idx, T> IntoIterator for &'a IndexSlice<I, T> {\n+    type Item = &'a T;\n+    type IntoIter = slice::Iter<'a, T>;\n+\n+    #[inline]\n+    fn into_iter(self) -> slice::Iter<'a, T> {\n+        self.raw.iter()\n+    }\n+}\n+\n+impl<'a, I: Idx, T> IntoIterator for &'a mut IndexSlice<I, T> {\n+    type Item = &'a mut T;\n+    type IntoIter = slice::IterMut<'a, T>;\n+\n+    #[inline]\n+    fn into_iter(self) -> slice::IterMut<'a, T> {\n+        self.raw.iter_mut()\n+    }\n+}\n+\n #[cfg(test)]\n mod tests;"}]}