{"sha": "948a62401ef717eb484c2215713291749f0f35ed", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk0OGE2MjQwMWVmNzE3ZWI0ODRjMjIxNTcxMzI5MTc0OWYwZjM1ZWQ=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-07-17T00:20:43Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-07-17T03:33:04Z"}, "message": "Add a `get_mut` method for TLS\n\nSimulates borrow checks for '@mut' boxes, or at least it's the same idea.", "tree": {"sha": "b0d41c9f8fade92bcf1582f3c66111a9e0288573", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b0d41c9f8fade92bcf1582f3c66111a9e0288573"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/948a62401ef717eb484c2215713291749f0f35ed", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/948a62401ef717eb484c2215713291749f0f35ed", "html_url": "https://github.com/rust-lang/rust/commit/948a62401ef717eb484c2215713291749f0f35ed", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/948a62401ef717eb484c2215713291749f0f35ed/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9db190305f7562f15b5282fed508aef81cfc9689", "url": "https://api.github.com/repos/rust-lang/rust/commits/9db190305f7562f15b5282fed508aef81cfc9689", "html_url": "https://github.com/rust-lang/rust/commit/9db190305f7562f15b5282fed508aef81cfc9689"}], "stats": {"total": 161, "additions": 145, "deletions": 16}, "files": [{"sha": "6c1640e683e59f259542768441a3898722258523", "filename": "src/libstd/local_data.rs", "status": "modified", "additions": 76, "deletions": 1, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/948a62401ef717eb484c2215713291749f0f35ed/src%2Flibstd%2Flocal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/948a62401ef717eb484c2215713291749f0f35ed/src%2Flibstd%2Flocal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flocal_data.rs?ref=948a62401ef717eb484c2215713291749f0f35ed", "patch": "@@ -41,7 +41,7 @@ magic.\n \n use prelude::*;\n \n-use task::local_data_priv::{local_get, local_pop, local_set, Handle};\n+use task::local_data_priv::*;\n \n #[cfg(test)] use task;\n \n@@ -95,6 +95,13 @@ pub fn get<T: 'static, U>(key: Key<@T>, f: &fn(Option<&@T>) -> U) -> U {\n pub fn get<T: 'static, U>(key: Key<T>, f: &fn(Option<&T>) -> U) -> U {\n     unsafe { local_get(Handle::new(), key, f) }\n }\n+/**\n+ * Retrieve a mutable borrowed pointer to a task-local data value.\n+ */\n+#[cfg(not(stage0))]\n+pub fn get_mut<T: 'static, U>(key: Key<T>, f: &fn(Option<&mut T>) -> U) -> U {\n+    unsafe { local_get_mut(Handle::new(), key, f) }\n+}\n /**\n  * Store a value in task-local data. If this key already has a value,\n  * that value is overwritten (and its destructor is run).\n@@ -262,6 +269,34 @@ fn test_static_pointer() {\n fn test_owned() {\n     static key: Key<~int> = &Key;\n     set(key, ~1);\n+\n+    do get(key) |v| {\n+        do get(key) |v| {\n+            do get(key) |v| {\n+                assert_eq!(**v.unwrap(), 1);\n+            }\n+            assert_eq!(**v.unwrap(), 1);\n+        }\n+        assert_eq!(**v.unwrap(), 1);\n+    }\n+    set(key, ~2);\n+    do get(key) |v| {\n+        assert_eq!(**v.unwrap(), 2);\n+    }\n+}\n+\n+#[test]\n+fn test_get_mut() {\n+    static key: Key<int> = &Key;\n+    set(key, 1);\n+\n+    do get_mut(key) |v| {\n+        *v.unwrap() = 2;\n+    }\n+\n+    do get(key) |v| {\n+        assert_eq!(*v.unwrap(), 2);\n+    }\n }\n \n #[test]\n@@ -283,3 +318,43 @@ fn test_same_key_type() {\n     get(key4, |x| assert_eq!(*x.unwrap(), 4));\n     get(key5, |x| assert_eq!(*x.unwrap(), 5));\n }\n+\n+#[test]\n+#[should_fail]\n+fn test_nested_get_set1() {\n+    static key: Key<int> = &Key;\n+    set(key, 4);\n+    do get(key) |_| {\n+        set(key, 4);\n+    }\n+}\n+\n+#[test]\n+#[should_fail]\n+fn test_nested_get_mut2() {\n+    static key: Key<int> = &Key;\n+    set(key, 4);\n+    do get(key) |_| {\n+        get_mut(key, |_| {})\n+    }\n+}\n+\n+#[test]\n+#[should_fail]\n+fn test_nested_get_mut3() {\n+    static key: Key<int> = &Key;\n+    set(key, 4);\n+    do get_mut(key) |_| {\n+        get(key, |_| {})\n+    }\n+}\n+\n+#[test]\n+#[should_fail]\n+fn test_nested_get_mut4() {\n+    static key: Key<int> = &Key;\n+    set(key, 4);\n+    do get_mut(key) |_| {\n+        get_mut(key, |_| {})\n+    }\n+}"}, {"sha": "75fd6eacc1b3a66826d49955ae32c1b6b8966015", "filename": "src/libstd/task/local_data_priv.rs", "status": "modified", "additions": 69, "deletions": 15, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/948a62401ef717eb484c2215713291749f0f35ed/src%2Flibstd%2Ftask%2Flocal_data_priv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/948a62401ef717eb484c2215713291749f0f35ed/src%2Flibstd%2Ftask%2Flocal_data_priv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Flocal_data_priv.rs?ref=948a62401ef717eb484c2215713291749f0f35ed", "patch": "@@ -44,6 +44,21 @@ impl Handle {\n     }\n }\n \n+#[deriving(Eq)]\n+enum LoanState {\n+    NoLoan, ImmLoan, MutLoan\n+}\n+\n+impl LoanState {\n+    fn describe(&self) -> &'static str {\n+        match *self {\n+            NoLoan => \"no loan\",\n+            ImmLoan => \"immutable\",\n+            MutLoan => \"mutable\"\n+        }\n+    }\n+}\n+\n trait LocalData {}\n impl<T: 'static> LocalData for T {}\n \n@@ -77,7 +92,7 @@ impl<T: 'static> LocalData for T {}\n //\n // n.b. If TLS is used heavily in future, this could be made more efficient with\n //      a proper map.\n-type TaskLocalMap = ~[Option<(*libc::c_void, TLSValue, uint)>];\n+type TaskLocalMap = ~[Option<(*libc::c_void, TLSValue, LoanState)>];\n type TLSValue = ~LocalData:;\n \n fn cleanup_task_local_map(map_ptr: *libc::c_void) {\n@@ -152,9 +167,10 @@ pub unsafe fn local_pop<T: 'static>(handle: Handle,\n \n     for map.mut_iter().advance |entry| {\n         match *entry {\n-            Some((k, _, loans)) if k == key_value => {\n-                if loans != 0 {\n-                    fail!(\"TLS value has been loaned via get already\");\n+            Some((k, _, loan)) if k == key_value => {\n+                if loan != NoLoan {\n+                    fail!(\"TLS value cannot be removed because it is already \\\n+                          borrowed as %s\", loan.describe());\n                 }\n                 // Move the data out of the `entry` slot via util::replace. This\n                 // is guaranteed to succeed because we already matched on `Some`\n@@ -192,6 +208,29 @@ pub unsafe fn local_pop<T: 'static>(handle: Handle,\n pub unsafe fn local_get<T: 'static, U>(handle: Handle,\n                                        key: local_data::Key<T>,\n                                        f: &fn(Option<&T>) -> U) -> U {\n+    local_get_with(handle, key, ImmLoan, f)\n+}\n+\n+pub unsafe fn local_get_mut<T: 'static, U>(handle: Handle,\n+                                           key: local_data::Key<T>,\n+                                           f: &fn(Option<&mut T>) -> U) -> U {\n+    do local_get_with(handle, key, MutLoan) |x| {\n+        match x {\n+            None => f(None),\n+            // We're violating a lot of compiler guarantees with this\n+            // invocation of `transmute_mut`, but we're doing runtime checks to\n+            // ensure that it's always valid (only one at a time).\n+            //\n+            // there is no need to be upset!\n+            Some(x) => { f(Some(cast::transmute_mut(x))) }\n+        }\n+    }\n+}\n+\n+unsafe fn local_get_with<T: 'static, U>(handle: Handle,\n+                                        key: local_data::Key<T>,\n+                                        state: LoanState,\n+                                        f: &fn(Option<&T>) -> U) -> U {\n     // This function must be extremely careful. Because TLS can store owned\n     // values, and we must have some form of `get` function other than `pop`,\n     // this function has to give a `&` reference back to the caller.\n@@ -218,12 +257,24 @@ pub unsafe fn local_get<T: 'static, U>(handle: Handle,\n         None => { return f(None); }\n         Some(i) => {\n             let ret;\n+            let mut return_loan = false;\n             match map[i] {\n-                Some((_, ref data, ref mut loans)) => {\n-                    *loans = *loans + 1;\n+                Some((_, ref data, ref mut loan)) => {\n+                    match (state, *loan) {\n+                        (_, NoLoan) => {\n+                            *loan = state;\n+                            return_loan = true;\n+                        }\n+                        (ImmLoan, ImmLoan) => {}\n+                        (want, cur) => {\n+                            fail!(\"TLS slot cannot be borrowed as %s because \\\n+                                   it is already borrowed as %s\",\n+                                  want.describe(), cur.describe());\n+                        }\n+                    }\n                     // data was created with `~~T as ~LocalData`, so we extract\n                     // pointer part of the trait, (as ~~T), and then use\n-                    // compiler coercions to achieve a '&' pointer\n+                    // compiler coercions to achieve a '&' pointer.\n                     match *cast::transmute::<&TLSValue, &(uint, ~~T)>(data) {\n                         (_vtable, ref box) => {\n                             let value: &T = **box;\n@@ -238,9 +289,11 @@ pub unsafe fn local_get<T: 'static, U>(handle: Handle,\n             // 'f' returned because `f` could have appended more TLS items which\n             // in turn relocated the vector. Hence we do another lookup here to\n             // fixup the loans.\n-            match map[i] {\n-                Some((_, _, ref mut loans)) => { *loans = *loans - 1; }\n-                None => { libc::abort(); }\n+            if return_loan {\n+                match map[i] {\n+                    Some((_, _, ref mut loan)) => { *loan = NoLoan; }\n+                    None => { libc::abort(); }\n+                }\n             }\n             return ret;\n         }\n@@ -269,9 +322,10 @@ pub unsafe fn local_set<T: 'static>(handle: Handle,\n         // First see if the map contains this key already\n         let curspot = map.iter().position(|entry| {\n             match *entry {\n-                Some((ekey, _, loans)) if key == ekey => {\n-                    if loans != 0 {\n-                        fail!(\"TLS value has been loaned via get already\");\n+                Some((ekey, _, loan)) if key == ekey => {\n+                    if loan != NoLoan {\n+                        fail!(\"TLS value cannot be overwritten because it is\n+                               already borrowed as %s\", loan.describe())\n                     }\n                     true\n                 }\n@@ -286,7 +340,7 @@ pub unsafe fn local_set<T: 'static>(handle: Handle,\n     }\n \n     match insertion_position(map, keyval) {\n-        Some(i) => { map[i] = Some((keyval, data, 0)); }\n-        None => { map.push(Some((keyval, data, 0))); }\n+        Some(i) => { map[i] = Some((keyval, data, NoLoan)); }\n+        None => { map.push(Some((keyval, data, NoLoan))); }\n     }\n }"}]}