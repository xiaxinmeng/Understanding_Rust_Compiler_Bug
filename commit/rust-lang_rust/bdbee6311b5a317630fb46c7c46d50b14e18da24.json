{"sha": "bdbee6311b5a317630fb46c7c46d50b14e18da24", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJkYmVlNjMxMWI1YTMxNzYzMGZiNDZjN2M0NmQ1MGIxNGUxOGRhMjQ=", "commit": {"author": {"name": "Nikita Popov", "email": "nikita.ppv@gmail.com", "date": "2018-12-03T19:45:03Z"}, "committer": {"name": "Nikita Popov", "email": "nikita.ppv@gmail.com", "date": "2018-12-04T15:10:24Z"}, "message": "Separate out methods for running thin and fat LTO", "tree": {"sha": "89b9c9b88953086ae80151740407a6b080fa4b3d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/89b9c9b88953086ae80151740407a6b080fa4b3d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bdbee6311b5a317630fb46c7c46d50b14e18da24", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bdbee6311b5a317630fb46c7c46d50b14e18da24", "html_url": "https://github.com/rust-lang/rust/commit/bdbee6311b5a317630fb46c7c46d50b14e18da24", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bdbee6311b5a317630fb46c7c46d50b14e18da24/comments", "author": {"login": "nikic", "id": 216080, "node_id": "MDQ6VXNlcjIxNjA4MA==", "avatar_url": "https://avatars.githubusercontent.com/u/216080?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikic", "html_url": "https://github.com/nikic", "followers_url": "https://api.github.com/users/nikic/followers", "following_url": "https://api.github.com/users/nikic/following{/other_user}", "gists_url": "https://api.github.com/users/nikic/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikic/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikic/subscriptions", "organizations_url": "https://api.github.com/users/nikic/orgs", "repos_url": "https://api.github.com/users/nikic/repos", "events_url": "https://api.github.com/users/nikic/events{/privacy}", "received_events_url": "https://api.github.com/users/nikic/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikic", "id": 216080, "node_id": "MDQ6VXNlcjIxNjA4MA==", "avatar_url": "https://avatars.githubusercontent.com/u/216080?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikic", "html_url": "https://github.com/nikic", "followers_url": "https://api.github.com/users/nikic/followers", "following_url": "https://api.github.com/users/nikic/following{/other_user}", "gists_url": "https://api.github.com/users/nikic/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikic/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikic/subscriptions", "organizations_url": "https://api.github.com/users/nikic/orgs", "repos_url": "https://api.github.com/users/nikic/repos", "events_url": "https://api.github.com/users/nikic/events{/privacy}", "received_events_url": "https://api.github.com/users/nikic/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a17de6980ac3289e2929da86f1e7259e83eef125", "url": "https://api.github.com/repos/rust-lang/rust/commits/a17de6980ac3289e2929da86f1e7259e83eef125", "html_url": "https://github.com/rust-lang/rust/commit/a17de6980ac3289e2929da86f1e7259e83eef125"}], "stats": {"total": 121, "additions": 74, "deletions": 47}, "files": [{"sha": "c88f5993889d62242682a7a352f93d714a396a91", "filename": "src/librustc_codegen_llvm/back/lto.rs", "status": "modified", "additions": 50, "deletions": 37, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/bdbee6311b5a317630fb46c7c46d50b14e18da24/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdbee6311b5a317630fb46c7c46d50b14e18da24/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs?ref=bdbee6311b5a317630fb46c7c46d50b14e18da24", "patch": "@@ -48,18 +48,11 @@ pub fn crate_type_allows_lto(crate_type: config::CrateType) -> bool {\n     }\n }\n \n-/// Performs LTO, which in the case of full LTO means merging all modules into\n-/// a single one and returning it for further optimizing. For ThinLTO, it will\n-/// do the global analysis necessary and return two lists, one of the modules\n-/// the need optimization and another for modules that can simply be copied over\n-/// from the incr. comp. cache.\n-pub(crate) fn run(cgcx: &CodegenContext<LlvmCodegenBackend>,\n-                  modules: Vec<ModuleCodegen<ModuleLlvm>>,\n-                  cached_modules: Vec<(SerializedModule<ModuleBuffer>, WorkProduct)>,\n-                  timeline: &mut Timeline)\n-    -> Result<(Vec<LtoModuleCodegen<LlvmCodegenBackend>>, Vec<WorkProduct>), FatalError>\n+fn prepare_lto(cgcx: &CodegenContext<LlvmCodegenBackend>,\n+               timeline: &mut Timeline,\n+               diag_handler: &Handler)\n+    -> Result<(Vec<CString>, Vec<(SerializedModule<ModuleBuffer>, CString)>), FatalError>\n {\n-    let diag_handler = cgcx.create_diag_handler();\n     let export_threshold = match cgcx.lto {\n         // We're just doing LTO for our one crate\n         Lto::ThinLocal => SymbolExportLevel::Rust,\n@@ -144,36 +137,56 @@ pub(crate) fn run(cgcx: &CodegenContext<LlvmCodegenBackend>,\n         }\n     }\n \n+    Ok((symbol_white_list, upstream_modules))\n+}\n+\n+/// Performs fat LTO by merging all modules into a single one and returning it\n+/// for further optimization.\n+pub(crate) fn run_fat(cgcx: &CodegenContext<LlvmCodegenBackend>,\n+                      modules: Vec<ModuleCodegen<ModuleLlvm>>,\n+                      _cached_modules: Vec<(SerializedModule<ModuleBuffer>, WorkProduct)>,\n+                      timeline: &mut Timeline)\n+    -> Result<(Vec<LtoModuleCodegen<LlvmCodegenBackend>>, Vec<WorkProduct>), FatalError>\n+{\n+    let diag_handler = cgcx.create_diag_handler();\n+    let (symbol_white_list, upstream_modules) = prepare_lto(cgcx, timeline, &diag_handler)?;\n     let symbol_white_list = symbol_white_list.iter()\n                                              .map(|c| c.as_ptr())\n                                              .collect::<Vec<_>>();\n-    match cgcx.lto {\n-        Lto::Fat => {\n-            assert!(cached_modules.is_empty());\n-            let opt_jobs = fat_lto(cgcx,\n-                                   &diag_handler,\n-                                   modules,\n-                                   upstream_modules,\n-                                   &symbol_white_list,\n-                                   timeline);\n-            opt_jobs.map(|opt_jobs| (opt_jobs, vec![]))\n-        }\n-        Lto::Thin |\n-        Lto::ThinLocal => {\n-            if cgcx.opts.debugging_opts.cross_lang_lto.enabled() {\n-                unreachable!(\"We should never reach this case if the LTO step \\\n-                              is deferred to the linker\");\n-            }\n-            thin_lto(cgcx,\n-                     &diag_handler,\n-                     modules,\n-                     upstream_modules,\n-                     cached_modules,\n-                     &symbol_white_list,\n-                     timeline)\n-        }\n-        Lto::No => unreachable!(),\n+    let opt_jobs = fat_lto(cgcx,\n+                           &diag_handler,\n+                           modules,\n+                           upstream_modules,\n+                           &symbol_white_list,\n+                           timeline);\n+    opt_jobs.map(|opt_jobs| (opt_jobs, vec![]))\n+}\n+\n+/// Performs thin LTO by performing necessary global analysis and returning two\n+/// lists, one of the modules that need optimization and another for modules that\n+/// can simply be copied over from the incr. comp. cache.\n+pub(crate) fn run_thin(cgcx: &CodegenContext<LlvmCodegenBackend>,\n+                       modules: Vec<ModuleCodegen<ModuleLlvm>>,\n+                       cached_modules: Vec<(SerializedModule<ModuleBuffer>, WorkProduct)>,\n+                       timeline: &mut Timeline)\n+    -> Result<(Vec<LtoModuleCodegen<LlvmCodegenBackend>>, Vec<WorkProduct>), FatalError>\n+{\n+    let diag_handler = cgcx.create_diag_handler();\n+    let (symbol_white_list, upstream_modules) = prepare_lto(cgcx, timeline, &diag_handler)?;\n+    let symbol_white_list = symbol_white_list.iter()\n+                                             .map(|c| c.as_ptr())\n+                                             .collect::<Vec<_>>();\n+    if cgcx.opts.debugging_opts.cross_lang_lto.enabled() {\n+        unreachable!(\"We should never reach this case if the LTO step \\\n+                      is deferred to the linker\");\n     }\n+    thin_lto(cgcx,\n+             &diag_handler,\n+             modules,\n+             upstream_modules,\n+             cached_modules,\n+             &symbol_white_list,\n+             timeline)\n }\n \n fn fat_lto(cgcx: &CodegenContext<LlvmCodegenBackend>,"}, {"sha": "7d941a99e2f2b97553d1475e6cea4ac64b119e88", "filename": "src/librustc_codegen_llvm/lib.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bdbee6311b5a317630fb46c7c46d50b14e18da24/src%2Flibrustc_codegen_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdbee6311b5a317630fb46c7c46d50b14e18da24/src%2Flibrustc_codegen_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Flib.rs?ref=bdbee6311b5a317630fb46c7c46d50b14e18da24", "patch": "@@ -176,13 +176,21 @@ impl WriteBackendMethods for LlvmCodegenBackend {\n     fn print_pass_timings(&self) {\n             unsafe { llvm::LLVMRustPrintPassTimings(); }\n     }\n-    fn run_lto(\n+    fn run_fat_lto(\n         cgcx: &CodegenContext<Self>,\n         modules: Vec<ModuleCodegen<Self::Module>>,\n         cached_modules: Vec<(SerializedModule<Self::ModuleBuffer>, WorkProduct)>,\n         timeline: &mut Timeline\n     ) -> Result<(Vec<LtoModuleCodegen<Self>>, Vec<WorkProduct>), FatalError> {\n-        back::lto::run(cgcx, modules, cached_modules, timeline)\n+        back::lto::run_fat(cgcx, modules, cached_modules, timeline)\n+    }\n+    fn run_thin_lto(\n+        cgcx: &CodegenContext<Self>,\n+        modules: Vec<ModuleCodegen<Self::Module>>,\n+        cached_modules: Vec<(SerializedModule<Self::ModuleBuffer>, WorkProduct)>,\n+        timeline: &mut Timeline\n+    ) -> Result<(Vec<LtoModuleCodegen<Self>>, Vec<WorkProduct>), FatalError> {\n+        back::lto::run_thin(cgcx, modules, cached_modules, timeline)\n     }\n     unsafe fn optimize(\n         cgcx: &CodegenContext<Self>,"}, {"sha": "5e89265d56f29c07597158d4f71bad09d66d04a9", "filename": "src/librustc_codegen_ssa/back/write.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bdbee6311b5a317630fb46c7c46d50b14e18da24/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdbee6311b5a317630fb46c7c46d50b14e18da24/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs?ref=bdbee6311b5a317630fb46c7c46d50b14e18da24", "patch": "@@ -264,11 +264,11 @@ fn generate_lto_work<B: ExtraBackendMethods>(\n \n     let (lto_modules, copy_jobs) = if !needs_fat_lto.is_empty() {\n         assert!(needs_thin_lto.is_empty());\n-        B::run_lto(cgcx, needs_fat_lto, import_only_modules, &mut timeline)\n+        B::run_fat_lto(cgcx, needs_fat_lto, import_only_modules, &mut timeline)\n             .unwrap_or_else(|e| e.raise())\n     } else {\n         assert!(needs_fat_lto.is_empty());\n-        B::run_lto(cgcx, needs_thin_lto, import_only_modules, &mut timeline)\n+        B::run_thin_lto(cgcx, needs_thin_lto, import_only_modules, &mut timeline)\n             .unwrap_or_else(|e| e.raise())\n     };\n "}, {"sha": "5bc44dfeeb32a4db327b1760b9da5fb3090b777e", "filename": "src/librustc_codegen_ssa/traits/write.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/bdbee6311b5a317630fb46c7c46d50b14e18da24/src%2Flibrustc_codegen_ssa%2Ftraits%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdbee6311b5a317630fb46c7c46d50b14e18da24/src%2Flibrustc_codegen_ssa%2Ftraits%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fwrite.rs?ref=bdbee6311b5a317630fb46c7c46d50b14e18da24", "patch": "@@ -24,12 +24,18 @@ pub trait WriteBackendMethods: 'static + Sized + Clone {\n     type ThinData: Send + Sync;\n     type ThinBuffer: ThinBufferMethods;\n \n-    /// Performs LTO, which in the case of full LTO means merging all modules into\n-    /// a single one and returning it for further optimizing. For ThinLTO, it will\n-    /// do the global analysis necessary and return two lists, one of the modules\n-    /// the need optimization and another for modules that can simply be copied over\n-    /// from the incr. comp. cache.\n-    fn run_lto(\n+    /// Performs fat LTO by merging all modules into a single one and returning it\n+    /// for further optimization.\n+    fn run_fat_lto(\n+        cgcx: &CodegenContext<Self>,\n+        modules: Vec<ModuleCodegen<Self::Module>>,\n+        cached_modules: Vec<(SerializedModule<Self::ModuleBuffer>, WorkProduct)>,\n+        timeline: &mut Timeline,\n+    ) -> Result<(Vec<LtoModuleCodegen<Self>>, Vec<WorkProduct>), FatalError>;\n+    /// Performs thin LTO by performing necessary global analysis and returning two\n+    /// lists, one of the modules that need optimization and another for modules that\n+    /// can simply be copied over from the incr. comp. cache.\n+    fn run_thin_lto(\n         cgcx: &CodegenContext<Self>,\n         modules: Vec<ModuleCodegen<Self::Module>>,\n         cached_modules: Vec<(SerializedModule<Self::ModuleBuffer>, WorkProduct)>,"}]}