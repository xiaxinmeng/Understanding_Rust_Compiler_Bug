{"sha": "201ae7387245caa4591d4c8db4c35c170c64faf0", "node_id": "C_kwDOAAsO6NoAKDIwMWFlNzM4NzI0NWNhYTQ1OTFkNGM4ZGI0YzM1YzE3MGM2NGZhZjA", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-12-27T11:31:17Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2023-02-06T10:46:32Z"}, "message": "make PointerKind directly reflect pointer types\n\nThe code that consumes PointerKind (`adjust_for_rust_scalar` in rustc_ty_utils)\nended up using PointerKind variants to talk about Rust reference types (& and\n&mut) anyway, making the old code structure quite confusing: one always had to\nkeep in mind which PointerKind corresponds to which type. So this changes\nPointerKind to directly reflect the type.\n\nThis does not change behavior.", "tree": {"sha": "011ec2bc77cfee914cfab9d89b61c40232046986", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/011ec2bc77cfee914cfab9d89b61c40232046986"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/201ae7387245caa4591d4c8db4c35c170c64faf0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/201ae7387245caa4591d4c8db4c35c170c64faf0", "html_url": "https://github.com/rust-lang/rust/commit/201ae7387245caa4591d4c8db4c35c170c64faf0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/201ae7387245caa4591d4c8db4c35c170c64faf0/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0c13c172507f01d921808107d2c4ec37b43b982d", "url": "https://api.github.com/repos/rust-lang/rust/commits/0c13c172507f01d921808107d2c4ec37b43b982d", "html_url": "https://github.com/rust-lang/rust/commit/0c13c172507f01d921808107d2c4ec37b43b982d"}], "stats": {"total": 99, "additions": 40, "deletions": 59}, "files": [{"sha": "9126c516d381e24550c7df127e4f014e3646a5ed", "filename": "compiler/rustc_abi/src/lib.rs", "status": "modified", "additions": 6, "deletions": 15, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/201ae7387245caa4591d4c8db4c35c170c64faf0/compiler%2Frustc_abi%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/201ae7387245caa4591d4c8db4c35c170c64faf0/compiler%2Frustc_abi%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_abi%2Fsrc%2Flib.rs?ref=201ae7387245caa4591d4c8db4c35c170c64faf0", "patch": "@@ -1439,21 +1439,12 @@ impl<V: Idx> fmt::Debug for LayoutS<V> {\n \n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n pub enum PointerKind {\n-    /// Most general case, we know no restrictions to tell LLVM.\n-    SharedMutable,\n-\n-    /// `&T` where `T` contains no `UnsafeCell`, is `dereferenceable`, `noalias` and `readonly`.\n-    Frozen,\n-\n-    /// `&mut T` which is `dereferenceable` and `noalias` but not `readonly`.\n-    UniqueBorrowed,\n-\n-    /// `&mut !Unpin`, which is `dereferenceable` but neither `noalias` nor `readonly`.\n-    UniqueBorrowedPinned,\n-\n-    /// `Box<T>`, which is `noalias` (even on return types, unlike the above) but neither `readonly`\n-    /// nor `dereferenceable`.\n-    UniqueOwned,\n+    /// Shared reference. `frozen` indicates the absence of any `UnsafeCell`.\n+    SharedRef { frozen: bool },\n+    /// Mutable reference. `unpin` indicates the absence of any pinned data.\n+    MutableRef { unpin: bool },\n+    /// Box.\n+    Box,\n }\n \n /// Note that this information is advisory only, and backends are free to ignore it."}, {"sha": "1244922c6d4aa4e40fb7b508970b6990e6925315", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 12, "deletions": 27, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/201ae7387245caa4591d4c8db4c35c170c64faf0/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/201ae7387245caa4591d4c8db4c35c170c64faf0/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=201ae7387245caa4591d4c8db4c35c170c64faf0", "patch": "@@ -833,32 +833,17 @@ where\n                     })\n                 }\n                 ty::Ref(_, ty, mt) if offset.bytes() == 0 => {\n-                    let kind = if tcx.sess.opts.optimize == OptLevel::No {\n-                        // Use conservative pointer kind if not optimizing. This saves us the\n-                        // Freeze/Unpin queries, and can save time in the codegen backend (noalias\n-                        // attributes in LLVM have compile-time cost even in unoptimized builds).\n-                        PointerKind::SharedMutable\n-                    } else {\n-                        match mt {\n-                            hir::Mutability::Not => {\n-                                if ty.is_freeze(tcx, cx.param_env()) {\n-                                    PointerKind::Frozen\n-                                } else {\n-                                    PointerKind::SharedMutable\n-                                }\n-                            }\n-                            hir::Mutability::Mut => {\n-                                // References to self-referential structures should not be considered\n-                                // noalias, as another pointer to the structure can be obtained, that\n-                                // is not based-on the original reference. We consider all !Unpin\n-                                // types to be potentially self-referential here.\n-                                if ty.is_unpin(tcx, cx.param_env()) {\n-                                    PointerKind::UniqueBorrowed\n-                                } else {\n-                                    PointerKind::UniqueBorrowedPinned\n-                                }\n-                            }\n-                        }\n+                    // Use conservative pointer kind if not optimizing. This saves us the\n+                    // Freeze/Unpin queries, and can save time in the codegen backend (noalias\n+                    // attributes in LLVM have compile-time cost even in unoptimized builds).\n+                    let optimize = tcx.sess.opts.optimize != OptLevel::No;\n+                    let kind = match mt {\n+                        hir::Mutability::Not => PointerKind::SharedRef {\n+                            frozen: optimize && ty.is_freeze(tcx, cx.param_env()),\n+                        },\n+                        hir::Mutability::Mut => PointerKind::MutableRef {\n+                            unpin: optimize && ty.is_unpin(tcx, cx.param_env()),\n+                        },\n                     };\n \n                     tcx.layout_of(param_env.and(ty)).ok().map(|layout| PointeeInfo {\n@@ -929,7 +914,7 @@ where\n                     if let Some(ref mut pointee) = result {\n                         if let ty::Adt(def, _) = this.ty.kind() {\n                             if def.is_box() && offset.bytes() == 0 {\n-                                pointee.safe = Some(PointerKind::UniqueOwned);\n+                                pointee.safe = Some(PointerKind::Box);\n                             }\n                         }\n                     }"}, {"sha": "884087987ce08c6e98123a696e70730887c5f703", "filename": "compiler/rustc_ty_utils/src/abi.rs", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/201ae7387245caa4591d4c8db4c35c170c64faf0/compiler%2Frustc_ty_utils%2Fsrc%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/201ae7387245caa4591d4c8db4c35c170c64faf0/compiler%2Frustc_ty_utils%2Fsrc%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fabi.rs?ref=201ae7387245caa4591d4c8db4c35c170c64faf0", "patch": "@@ -254,15 +254,15 @@ fn adjust_for_rust_scalar<'tcx>(\n         if let Some(kind) = pointee.safe {\n             attrs.pointee_align = Some(pointee.align);\n \n-            // `Box` (`UniqueBorrowed`) are not necessarily dereferenceable\n-            // for the entire duration of the function as they can be deallocated\n-            // at any time. Same for shared mutable references. If LLVM had a\n-            // way to say \"dereferenceable on entry\" we could use it here.\n+            // `Box` are not necessarily dereferenceable for the entire duration of the function as\n+            // they can be deallocated at any time. Same for non-frozen shared references (see\n+            // <https://github.com/rust-lang/rust/pull/98017>). If LLVM had a way to say\n+            // \"dereferenceable on entry\" we could use it here.\n             attrs.pointee_size = match kind {\n-                PointerKind::UniqueBorrowed\n-                | PointerKind::UniqueBorrowedPinned\n-                | PointerKind::Frozen => pointee.size,\n-                PointerKind::SharedMutable | PointerKind::UniqueOwned => Size::ZERO,\n+                PointerKind::Box | PointerKind::SharedRef { frozen: false } => Size::ZERO,\n+                PointerKind::SharedRef { frozen: true } | PointerKind::MutableRef { .. } => {\n+                    pointee.size\n+                }\n             };\n \n             // The aliasing rules for `Box<T>` are still not decided, but currently we emit\n@@ -278,23 +278,22 @@ fn adjust_for_rust_scalar<'tcx>(\n             // `&mut` pointer parameters never alias other parameters,\n             // or mutable global data\n             //\n-            // `&T` where `T` contains no `UnsafeCell<U>` is immutable,\n-            // and can be marked as both `readonly` and `noalias`, as\n-            // LLVM's definition of `noalias` is based solely on memory\n-            // dependencies rather than pointer equality\n+            // `&T` where `T` contains no `UnsafeCell<U>` is immutable, and can be marked as both\n+            // `readonly` and `noalias`, as LLVM's definition of `noalias` is based solely on memory\n+            // dependencies rather than pointer equality. However this only applies to arguments,\n+            // not return values.\n             let no_alias = match kind {\n-                PointerKind::SharedMutable | PointerKind::UniqueBorrowedPinned => false,\n-                PointerKind::UniqueBorrowed => noalias_mut_ref,\n-                PointerKind::UniqueOwned => noalias_for_box,\n-                PointerKind::Frozen => true,\n+                PointerKind::SharedRef { frozen } => frozen,\n+                PointerKind::MutableRef { unpin } => unpin && noalias_mut_ref,\n+                PointerKind::Box => noalias_for_box,\n             };\n             // We can never add `noalias` in return position; that LLVM attribute has some very surprising semantics\n             // (see <https://github.com/rust-lang/unsafe-code-guidelines/issues/385#issuecomment-1368055745>).\n             if no_alias && !is_return {\n                 attrs.set(ArgAttribute::NoAlias);\n             }\n \n-            if kind == PointerKind::Frozen && !is_return {\n+            if matches!(kind, PointerKind::SharedRef { frozen: true }) && !is_return {\n                 attrs.set(ArgAttribute::ReadOnly);\n             }\n         }"}, {"sha": "0c62e0d35e36d91624e2ac519e56f1cc72d9c91e", "filename": "tests/codegen/function-arguments-noopt.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/201ae7387245caa4591d4c8db4c35c170c64faf0/tests%2Fcodegen%2Ffunction-arguments-noopt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/201ae7387245caa4591d4c8db4c35c170c64faf0/tests%2Fcodegen%2Ffunction-arguments-noopt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Ffunction-arguments-noopt.rs?ref=201ae7387245caa4591d4c8db4c35c170c64faf0", "patch": "@@ -29,6 +29,12 @@ pub fn borrow(x: &i32) -> &i32 {\n   x\n }\n \n+// CHECK: align 4 {{i32\\*|ptr}} @borrow_mut({{i32\\*|ptr}} align 4 %x)\n+#[no_mangle]\n+pub fn borrow_mut(x: &mut i32) -> &mut i32 {\n+  x\n+}\n+\n // CHECK-LABEL: @borrow_call\n #[no_mangle]\n pub fn borrow_call(x: &i32, f: fn(&i32) -> &i32) -> &i32 {"}]}