{"sha": "cc0f2c6bb26ba38d3487a396fa8625e938af6820", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNjMGYyYzZiYjI2YmEzOGQzNDg3YTM5NmZhODYyNWU5MzhhZjY4MjA=", "commit": {"author": {"name": "Simon BD", "email": "simon@server", "date": "2012-10-22T23:33:41Z"}, "committer": {"name": "Simon BD", "email": "simon@server", "date": "2012-10-22T23:33:41Z"}, "message": "Merge remote-tracking branch 'original/incoming' into incoming", "tree": {"sha": "6c2063df35144c5477b0adc9e49933d71224dc2a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6c2063df35144c5477b0adc9e49933d71224dc2a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cc0f2c6bb26ba38d3487a396fa8625e938af6820", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cc0f2c6bb26ba38d3487a396fa8625e938af6820", "html_url": "https://github.com/rust-lang/rust/commit/cc0f2c6bb26ba38d3487a396fa8625e938af6820", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cc0f2c6bb26ba38d3487a396fa8625e938af6820/comments", "author": {"login": "14427", "id": 2423611, "node_id": "MDQ6VXNlcjI0MjM2MTE=", "avatar_url": "https://avatars.githubusercontent.com/u/2423611?v=4", "gravatar_id": "", "url": "https://api.github.com/users/14427", "html_url": "https://github.com/14427", "followers_url": "https://api.github.com/users/14427/followers", "following_url": "https://api.github.com/users/14427/following{/other_user}", "gists_url": "https://api.github.com/users/14427/gists{/gist_id}", "starred_url": "https://api.github.com/users/14427/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/14427/subscriptions", "organizations_url": "https://api.github.com/users/14427/orgs", "repos_url": "https://api.github.com/users/14427/repos", "events_url": "https://api.github.com/users/14427/events{/privacy}", "received_events_url": "https://api.github.com/users/14427/received_events", "type": "User", "site_admin": false}, "committer": {"login": "14427", "id": 2423611, "node_id": "MDQ6VXNlcjI0MjM2MTE=", "avatar_url": "https://avatars.githubusercontent.com/u/2423611?v=4", "gravatar_id": "", "url": "https://api.github.com/users/14427", "html_url": "https://github.com/14427", "followers_url": "https://api.github.com/users/14427/followers", "following_url": "https://api.github.com/users/14427/following{/other_user}", "gists_url": "https://api.github.com/users/14427/gists{/gist_id}", "starred_url": "https://api.github.com/users/14427/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/14427/subscriptions", "organizations_url": "https://api.github.com/users/14427/orgs", "repos_url": "https://api.github.com/users/14427/repos", "events_url": "https://api.github.com/users/14427/events{/privacy}", "received_events_url": "https://api.github.com/users/14427/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9aec7a3e85c5b07923eab05d3ebe9d031bf258f3", "url": "https://api.github.com/repos/rust-lang/rust/commits/9aec7a3e85c5b07923eab05d3ebe9d031bf258f3", "html_url": "https://github.com/rust-lang/rust/commit/9aec7a3e85c5b07923eab05d3ebe9d031bf258f3"}, {"sha": "9ee5fff4f16cfc3390bd69abbb46b0a68521667c", "url": "https://api.github.com/repos/rust-lang/rust/commits/9ee5fff4f16cfc3390bd69abbb46b0a68521667c", "html_url": "https://github.com/rust-lang/rust/commit/9ee5fff4f16cfc3390bd69abbb46b0a68521667c"}], "stats": {"total": 21052, "additions": 10912, "deletions": 10140}, "files": [{"sha": "9ab084c5db2d733bdd0c952af1658e7624e22836", "filename": "AUTHORS.txt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/AUTHORS.txt", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/AUTHORS.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/AUTHORS.txt?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820", "patch": "@@ -41,6 +41,7 @@ Erick Tryzelaar <erick.tryzelaar@gmail.com>\n Erik Rose <erik@mozilla.com>\n Evan McClanahan <evan@evanmcc.com>\n Francisco Souza <f@souza.cc>\n+Gabriel <g2p.code@gmail.com>\n Gareth Daniel Smith <garethdanielsmith@gmail.com>\n Glenn Willen <gwillen@nerdnet.org>\n Gon\u00e7alo Cabrita <_@gmcabrita.com>\n@@ -49,6 +50,7 @@ Grahame Bowland <grahame@angrygoats.net>\n Haitao Li <lihaitao@gmail.com>\n Ian D. Bollinger <ian.bollinger@gmail.com>\n Ivano Coppola <rgbfirefox@gmail.com>\n+Jacob Harris Cryer Kragh <jhckragh@gmail.com>\n Jacob Parker <j3parker@csclub.uwaterloo.ca>\n Jason Orendorff <jorendorff@mozilla.com>\n Jed Davis <jld@panix.com>\n@@ -71,7 +73,9 @@ Kevin Cantu <me@kevincantu.org>\n Lennart Kudling\n Lindsey Kuper <lindsey@rockstargirl.org>\n Luca Bruno <lucab@debian.org>\n+Luqman Aden <laden@csclub.uwaterloo.ca>\n Magnus Auvinen <magnus.auvinen@gmail.com>\n+Mahmut Bulut <mahmutbulut0@gmail.com>\n Margaret Meyerhofer <mmeyerho@andrew.cmu.edu>\n Marijn Haverbeke <marijnh@gmail.com>\n Matt Brubeck <mbrubeck@limpet.net>"}, {"sha": "fb674878f556f3aa4aebc95fee2d8274516fd8ff", "filename": "Makefile.in", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/Makefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/Makefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Makefile.in?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820", "patch": "@@ -132,7 +132,7 @@ LIBSYNTAX_DSYM_GLOB :=$(call CFG_LIB_DSYM_GLOB,syntax)\n \n # version-string calculation\n CFG_GIT_DIR := $(CFG_SRC_DIR).git\n-CFG_RELEASE = 0.4\n+CFG_RELEASE = 0.5\n CFG_VERSION = $(CFG_RELEASE)\n \n ifneq ($(wildcard $(CFG_GIT)),)\n@@ -144,8 +144,9 @@ ifneq ($(wildcard $(CFG_GIT_DIR)),)\n endif\n endif\n \n-ifdef CFG_DISABLE_VALGRIND\n-  $(info cfg: disabling valgrind (CFG_DISABLE_VALGRIND))\n+ifdef CFG_ENABLE_VALGRIND\n+  $(info cfg: enabling valgrind (CFG_ENABLE_VALGRIND))\n+else\n   CFG_VALGRIND :=\n endif\n ifdef CFG_BAD_VALGRIND"}, {"sha": "9f875ac346e1c40d2327b5ace958b48a068d2d9a", "filename": "README.md", "status": "modified", "additions": 36, "deletions": 27, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820", "patch": "@@ -6,52 +6,61 @@ documentation.\n \n ## Installation\n \n-The Rust compiler is slightly unusual in that it is written in Rust and\n-therefore must be built by a precompiled \"snapshot\" version of itself (made in\n-an earlier state of development). As such, source builds require that:\n+The Rust compiler currently must be built from a [tarball], unless you\n+are on Windows, in which case using the [installer][win-exe] is\n+recommended.\n \n-* You are connected to the internet, to fetch snapshots.\n+Since the Rust compiler is written in Rust, it must be built by\n+a precompiled \"snapshot\" version of itself (made in an earlier state\n+of development). As such, source builds require a connection to\n+the Internet, to fetch snapshots, and an OS that can execute the\n+available snapshot binaries.\n \n-* You can at least execute snapshot binaries of one of the forms we offer\n-  them in. Currently we build and test snapshots on:\n+Snapshot binaries are currently built and tested on several platforms:\n \n-  * Windows (7, server 2008 r2) x86 only\n-  * Linux 2.6.x (various distributions) x86 and x86-64\n-  * OSX 10.6 (\"Snow Leopard\") or 10.7 (\"Lion\") x86 and x86-64\n+* Windows (7, Server 2008 R2), x86 only\n+* Linux (various distributions), x86 and x86-64\n+* OSX 10.6 (\"Snow Leopard\") or greater, x86 and x86-64\n \n-You may find other platforms work, but these are our \"tier 1\" supported build\n-environments that are most likely to work. Further platforms will be added to\n-the list in the future via cross-compilation.\n+You may find that other platforms work, but these are our \"tier 1\"\n+supported build environments that are most likely to work.\n \n-To build from source you will also need the following prerequisite packages:\n+> ***Note:*** Windows users should read the detailed\n+> [getting started][wiki-start] notes on the wiki. Even when using\n+> the binary installer the Windows build requires a MinGW installation,\n+> the precise details of which are not discussed here.\n+\n+To build from source you will also need the following prerequisite\n+packages:\n \n * g++ 4.4 or clang++ 3.x\n-* python 2.6 or later\n+* python 2.6 or later (but not 3.x)\n * perl 5.0 or later\n * gnu make 3.81 or later\n * curl\n \n-Assuming you're on a relatively modern Linux/OSX system and have met the\n-prerequisites, something along these lines should work:\n+Assuming you're on a relatively modern *nix system and have met the\n+prerequisites, something along these lines should work.\n \n+    $ wget http://dl.rust-lang.org/dist/rust-0.4.tar.gz\n     $ tar -xzf rust-0.4.tar.gz\n     $ cd rust-0.4\n     $ ./configure\n     $ make && make install\n \n-When complete, make install will place the following programs into\n-/usr/local/bin:\n-\n-* rustc, the Rust compiler\n-* rustdoc, the API-documentation tool\n-* cargo, the Rust package manager\n+You may need to use `sudo make install` if you do not normally have\n+permission to modify the destination directory. The install locations\n+can be adjusted by passing a `--prefix` argument to\n+`configure`. Various other options are also supported, pass `--help`\n+for more information on them.\n \n-In addition to a manual page under /usr/local/share/man and a set of host and\n-target libraries under /usr/local/lib/rustc.\n+When complete, `make install` will place several programs into\n+`/usr/local/bin`: `rustc`, the Rust compiler; `rustdoc`, the\n+API-documentation tool, and `cargo`, the Rust package manager.\n \n-The install locations can be adjusted by passing a --prefix argument to\n-configure. Various other options are also supported, pass --help for more\n-information on them.\n+[wiki-start]: https://github.com/mozilla/rust/wiki/Note-getting-started-developing-Rust\n+[tarball]: http://dl.rust-lang.org/dist/rust-0.4.tar.gz\n+[win-exe]: http://dl.rust-lang.org/dist/rust-0.4-install.exe\n \n \n ## License"}, {"sha": "03e058817e2088f4b339cf42aec4dbf1175498d4", "filename": "RELEASES.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/RELEASES.txt", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/RELEASES.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.txt?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820", "patch": "@@ -1,7 +1,7 @@\n Version 0.4 (October 2012)\n --------------------------\n \n-   * ~1500 changes, numerous bugfixes\n+   * ~2000 changes, numerous bugfixes\n \n    * Syntax\n       * All keywords are now strict and may not be used as identifiers anywhere"}, {"sha": "a8c3ba59e61af93d8a8e5c5b58cc2afcad9640f3", "filename": "configure", "status": "modified", "additions": 22, "deletions": 6, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/configure", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820", "patch": "@@ -187,6 +187,7 @@ need_cmd cmp\n need_cmd mkdir\n need_cmd printf\n need_cmd cut\n+need_cmd head\n need_cmd grep\n need_cmd xargs\n need_cmd cp\n@@ -257,6 +258,16 @@ case $CFG_CPUTYPE in\n         err \"unknown CPU type: $CFG_CPUTYPE\"\n esac\n \n+# Detect 64 bit linux systems with 32 bit userland and force 32 bit compilation\n+if [ $CFG_OSTYPE = unknown-linux-gnu -a $CFG_CPUTYPE = x86_64 ]\n+then\n+    file -L \"$SHELL\" | grep -q \"x86[_-]64\"\n+    if [ $? != 0 ]; then\n+        CFG_CPUTYPE=i686\n+    fi\n+fi\n+\n+\n DEFAULT_HOST_TRIPLE=\"${CFG_CPUTYPE}-${CFG_OSTYPE}\"\n \n CFG_SRC_DIR=\"$(cd $(dirname $0) && pwd)/\"\n@@ -283,7 +294,7 @@ else\n fi\n \n opt sharedstd 1 \"build libstd as a shared library\"\n-opt valgrind 1 \"run tests with valgrind (memcheck by default)\"\n+opt valgrind 0 \"run tests with valgrind (memcheck by default)\"\n opt helgrind 0 \"run tests with helgrind instead of memcheck\"\n opt docs     1 \"build documentation\"\n opt optimize 1 \"build optimized rust code\"\n@@ -352,11 +363,16 @@ fi\n \n if [ ! -z \"$CFG_PANDOC\" ]\n then\n-    PV=$(pandoc --version | awk '/^pandoc/ {print $2}')\n-    if [ \"$PV\" \\< \"1.8\" ]\n+    PANDOC_VER_LINE=$(pandoc --version | grep '^pandoc ')\n+    PANDOC_VER=${PANDOC_VER_LINE#pandoc }\n+    PV_MAJOR_MINOR=${PANDOC_VER%.[0-9]*}\n+    PV_MAJOR=${PV_MAJOR_MINOR%%[.][0-9]*}\n+    PV_MINOR=${PV_MAJOR_MINOR#[0-9]*[.]}\n+    PV_MINOR=${PV_MINOR%%[.][0-9]*}\n+    if [ \"$PV_MAJOR\" -lt \"1\" ] || [ \"$PV_MINOR\" -lt \"8\" ]\n     then\n-\tstep_msg \"pandoc $PV is too old. disabling\"\n-\tBAD_PANDOC=1\n+\t\tstep_msg \"pandoc $PV_MAJOR.$PV_MINOR is too old. disabling\"\n+\t\tBAD_PANDOC=1\n     fi\n fi\n \n@@ -579,7 +595,7 @@ then\n     need_ok \"git failed\"\n \n     msg \"git: submodule foreach sync\"\n-    \"${CFG_GIT}\" submodule --quiet foreach --recursive git submodule sync\n+    \"${CFG_GIT}\" submodule --quiet foreach --recursive 'if test -e .gitmodules; then git submodule sync; fi'\n     need_ok \"git failed\"\n \n     msg \"git: submodule foreach update\""}, {"sha": "727882d30994cf2b96425be5aace15f8dd6a302f", "filename": "doc/lib/codemirror-rust.js", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/doc%2Flib%2Fcodemirror-rust.js", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/doc%2Flib%2Fcodemirror-rust.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Flib%2Fcodemirror-rust.js?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820", "patch": "@@ -9,7 +9,7 @@ CodeMirror.defineMode(\"rust\", function() {\n     \"as\": \"op\", \"true\": \"atom\", \"false\": \"atom\", \"assert\": \"op\", \"check\": \"op\",\n     \"claim\": \"op\", \"extern\": \"ignore\", \"unsafe\": \"ignore\", \"import\": \"else-style\",\n     \"export\": \"else-style\", \"copy\": \"op\", \"log\": \"op\",\n-    \"use\": \"op\", \"self\": \"atom\"\n+    \"use\": \"op\", \"self\": \"atom\", \"pub\": \"atom\", \"priv\": \"atom\"\n   };\n   var typeKeywords = function() {\n     var keywords = {\"fn\": \"fn\"};"}, {"sha": "7e1c6e6e088ba70aa3820292f061b6b19ac0bb72", "filename": "doc/rust.md", "status": "modified", "additions": 723, "deletions": 678, "changes": 1401, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820", "patch": "@@ -41,9 +41,6 @@ If you have suggestions to make, please try to focus them on *reductions* to\n the language: possible features that can be combined or omitted. We aim to\n keep the size and complexity of the language under control.\n \n-> **Note:** This manual is very out of date. The best source of Rust\n-> documentation is currently the tutorial.\n-\n > **Note:** The grammar for Rust given in this document is rough and\n > very incomplete; only a modest number of sections have accompanying grammar\n > rules. Formalizing the grammar accepted by the Rust parser is ongoing work,\n@@ -160,13 +157,19 @@ Some productions are defined by exclusion of particular Unicode characters:\n ~~~~~~~~ {.ebnf .gram}\n comment : block_comment | line_comment ;\n block_comment : \"/*\" block_comment_body * \"*/\" ;\n-block_comment_body : block_comment | non_star * | '*' non_slash ;\n+block_comment_body : non_star * | '*' non_slash ;\n line_comment : \"//\" non_eol * ;\n ~~~~~~~~\n \n-Comments in Rust code follow the general C++ style of line and block-comment\n-forms, with proper nesting of block-comment delimiters. Comments are\n-interpreted as a form of whitespace.\n+Comments in Rust code follow the general C++ style of line and block-comment forms,\n+with no nesting of block-comment delimiters.\n+\n+Line comments beginning with _three_ slashes (`///`),\n+and block comments beginning with a repeated asterisk in the block-open sequence (`/**`),\n+are interpreted as a special syntax for `doc` [attributes](#attributes).\n+That is, they are equivalent to writing `#[doc \"...\"]` around the comment's text.\n+\n+Non-doc comments are interpreted as a form of whitespace.\n \n ## Whitespace\n \n@@ -385,11 +388,10 @@ Examples of floating-point literals of various forms:\n 12E+99_f64;                        // type f64\n ~~~~\n \n-##### Nil and boolean literals\n+##### Unit and boolean literals\n \n-The _nil value_, the only value of the type by the same name, is\n-written as `()`. The two values of the boolean type are written `true`\n-and `false`.\n+The _unit value_, the only value of the type that has the same name, is written as `()`.\n+The two values of the boolean type are written `true` and `false`.\n \n ### Symbols\n \n@@ -475,11 +477,8 @@ with values. `proto!` is an item, defining a new name.\n \n ## Macros\n \n-User-defined syntax extensions are called \"macros\", and they can be defined\n-with the `macro_rules!` syntax extension. User-defined macros can currently\n-only be invoked in expression position.\n+~~~~~~~~ {.ebnf .gram}\n \n-~~~~ {.ebnf .gram}\n expr_macro_rules : \"macro_rules\" '!' ident '(' macro_rule * ')'\n macro_rule : '(' matcher * ')' \"=>\" '(' transcriber * ')' ';'\n matcher : '(' matcher * ')' | '[' matcher * ']'\n@@ -491,19 +490,23 @@ transcriber : '(' transcriber * ')' | '[' transcriber * ']'\n             | '$' '(' transcriber * ')' sep_token? [ '*' | '+' ]\n             | non_special_token\n \n-~~~~\n+~~~~~~~~\n+\n+User-defined syntax extensions are called \"macros\", and they can be defined\n+with the `macro_rules!` syntax extension. User-defined macros can currently\n+only be invoked in expression position.\n+\n (A `sep_token` is any token other than `*` and `+`. A `non_special_token` is\n any token other than a delimiter or `$`.)\n \n Macro invocations are looked up by name, and each macro rule is tried in turn;\n-the first successful match is transcribed. The matching and transcribing\n-processes are close cousins, and will be described together:\n+the first successful match is transcribed. The matching and transcription\n+processes are closely related, and will be described together:\n \n ### Macro By Example\n \n-Everything that does not begin with a `$` is matched and transcirbed\n-literally, including delimiters. For parsing reasons, they must be matched,\n-but they are otherwise not special.\n+The macro expander matches and transcribes every token that does not begin with a `$` literally, including delimiters.\n+For parsing reasons, delimiters must be balanced, but they are otherwise not special.\n \n In the matcher, `$` _name_ `:` _designator_ matches the nonterminal in the\n Rust syntax named by _designator_. Valid designators are `item`, `block`,\n@@ -512,11 +515,11 @@ are the right-hand side and the left-hand side respectively of the `=>` in\n macro rules. In the transcriber, the designator is already known, and so only\n the name of a matched nonterminal comes after the dollar sign.\n \n-In bothe the matcher and transcriber, the Kleene star-like operator,\n-consisting of `$` and parens, optionally followed by a separator token,\n-followed by `*` or `+`, indicates repetition. (`*` means zero or more\n-repetitions, `+` means at least one repetition. The parens are not matched or\n-transcribed). On the matcher side, a name is bound to _all_ of the names it\n+In both the matcher and transcriber, the Kleene star-like operator indicates repetition.\n+The Kleene star operator consists of `$` and parens, optionally followed by a separator token, followed by `*` or `+`.\n+`*` means zero or more repetitions, `+` means at least one repetition.\n+The parens are not matched or transcribed.\n+On the matcher side, a name is bound to _all_ of the names it\n matches, in a structure that mimics the structure of the repetition\n encountered on a successful match. The job of the transcriber is to sort that\n structure out.\n@@ -545,59 +548,52 @@ Rust syntax is restricted in two ways:\n 1. The parser will always parse as much as possible. If it attempts to match\n `$i:expr [ , ]` against `8 [ , ]`, it will attempt to parse `i` as an array\n index operation and fail. Adding a separator can solve this problem.\n-2. The parser must have eliminated all ambiguity by the time it reaches a\n-`$` _name_ `:` _designator_. This most often affects them when they occur in\n-the beginning of, or immediately after, a `$(...)*`; requiring a distinctive\n-token in front can solve the problem.\n+2. The parser must have eliminated all ambiguity by the time it reaches a `$` _name_ `:` _designator_.\n+This requirement most often affects name-designator pairs when they occur at the beginning of, or immediately after, a `$(...)*`; requiring a distinctive token in front can solve the problem.\n \n \n ## Syntax extensions useful for the macro author\n \n * `log_syntax!` : print out the arguments at compile time\n-* `trace_macros!` : supply `true` or `false` to enable or disable printing\n-of the macro expansion process.\n-* `ident_to_str!` : turns the identifier argument into a string literal\n-* `concat_idents!` : creates a new identifier by concatenating its arguments\n+* `trace_macros!` : supply `true` or `false` to enable or disable printing of the macro expansion process.\n+* `ident_to_str!` : turn the identifier argument into a string literal\n+* `concat_idents!` : create a new identifier by concatenating the arguments\n \n \n \n # Crates and source files\n \n-Rust is a *compiled* language. Its semantics are divided along a\n-*phase distinction* between compile-time and run-time. Those semantic\n-rules that have a *static interpretation* govern the success or failure\n-of compilation. A program that fails to compile due to violation of a\n-compile-time rule has no defined semantics at run-time; the compiler should\n-halt with an error report, and produce no executable artifact.\n+Rust is a *compiled* language.\n+Its semantics obey a *phase distinction* between compile-time and run-time.\n+Those semantic rules that have a *static interpretation* govern the success or failure of compilation.\n+We refer to these rules as \"static semantics\".\n+Semantic rules called \"dynamic semantics\" govern the behavior of programs at run-time.\n+A program that fails to compile due to violation of a compile-time rule has no defined dynamic semantics; the compiler should halt with an error report, and produce no executable artifact.\n \n-The compilation model centres on artifacts called _crates_. Each compilation\n-is directed towards a single crate in source form, and if successful,\n-produces a single crate in binary form: either an executable or a library.\n+The compilation model centres on artifacts called _crates_.\n+Each compilation processes a single crate in source form, and if successful, produces a single crate in binary form: either an executable or a library.\n \n-A _crate_ is a unit of compilation and linking, as well as versioning,\n-distribution and runtime loading. A crate contains a _tree_ of nested\n-[module](#modules) scopes. The top level of this tree is a module that is\n-anonymous -- from the point of view of paths within the module -- and any item\n-within a crate has a canonical [module path](#paths) denoting its location\n-within the crate's module tree.\n+A _crate_ is a unit of compilation and linking, as well as versioning, distribution and runtime loading.\n+A crate contains a _tree_ of nested [module](#modules) scopes.\n+The top level of this tree is a module that is anonymous (from the point of view of paths within the module) and any item within a crate has a canonical [module path](#paths) denoting its location within the crate's module tree.\n \n Crates are provided to the Rust compiler through two kinds of file:\n \n   - _crate files_, that end in `.rc` and each define a `crate`.\n   - _source files_, that end in `.rs` and each define a `module`.\n \n-The Rust compiler is always invoked with a single input file, and always\n-produces a single output crate.\n+> **Note:** The functionality of crate files will be merged into source files in future versions of Rust.\n+> The separate processing of crate files, both their grammar and file extension, will be removed.\n+\n+The Rust compiler is always invoked with a single crate file as input, and always produces a single output crate.\n \n When the Rust compiler is invoked with a crate file, it reads the _explicit_\n definition of the crate it's compiling from that file, and populates the\n crate with modules derived from all the source files referenced by the\n crate, reading and processing all the referenced modules at once.\n \n-When the Rust compiler is invoked with a source file, it creates an\n-_implicit_ crate and treats the source file as though it was referenced as\n-the sole module populating this implicit crate. The module name is derived\n-from the source file name, with the `.rs` extension removed.\n+When the Rust compiler is invoked with a source file, it creates an _implicit_ crate and treats the source file as if it is the sole module populating this explicit crate.\n+The module name is derived from the source file name, with the `.rs` extension removed.\n \n ## Crate files\n \n@@ -654,10 +650,8 @@ containing source files and/or further subdirectories. The filesystem\n directory associated with a `dir_directive` module can either be explicit,\n or if omitted, is implicitly the same name as the module.\n \n-A `source_directive` references a source file, either explicitly or\n-implicitly by combining the module name with the file extension `.rs`.  The\n-module contained in that source file is bound to the module path formed by\n-the `dir_directive` modules containing the `source_directive`.\n+A `source_directive` references a source file, either explicitly or implicitly, by combining the module name with the file extension `.rs`.\n+The module contained in that source file is bound to the module path formed by the `dir_directive` modules containing the `source_directive`.\n \n ## Source files\n \n@@ -667,20 +661,19 @@ location of which -- in the module tree of the current crate -- is defined\n from outside the source file: either by an explicit `source_directive` in\n a referencing crate file, or by the filename of the source file itself.\n \n-A source file that contains a `main` function can be compiled to an\n-executable. If a `main` function is present, it must have no [type parameters](#type-parameters)\n-and no [constraints](#constraints). Its return type must be [`nil`](#primitive-types) and it must either have no arguments, or a single argument of type `[~str]`.\n+A source file that contains a `main` function can be compiled to an executable.\n+If a `main` function is present, its return type must be [`unit`](#primitive-types) and it must take no arguments.\n \n # Items and attributes\n \n-A crate is a collection of [items](#items), each of which may have some number\n-of [attributes](#attributes) attached to it.\n+Crates contain [items](#items),\n+each of which may have some number of [attributes](#attributes) attached to it.\n \n ## Items\n \n ~~~~~~~~ {.ebnf .gram}\n item : mod_item | fn_item | type_item | enum_item\n-     | res_item | trait_item | impl_item | foreign_mod_item ;\n+     | const_item | trait_item | impl_item | foreign_mod_item ;\n ~~~~~~~~\n \n An _item_ is a component of a crate; some module items can be defined in crate\n@@ -697,8 +690,9 @@ There are several kinds of item:\n   * [modules](#modules)\n   * [functions](#functions)\n   * [type definitions](#type-definitions)\n+  * [structures](#structures)\n   * [enumerations](#enumerations)\n-  * [resources](#resources)\n+  * [constants](#constants)\n   * [traits](#traits)\n   * [implementations](#implementations)\n \n@@ -709,22 +703,19 @@ otherwise compose the item body. The meaning of these scoped items is the same\n as if the item was declared outside the scope -- it is still a static item --\n except that the item's *path name* within the module namespace is qualified by\n the name of the enclosing item, or is private to the enclosing item (in the\n-case of functions). The exact locations in which sub-items may be declared is\n-given by the grammar.\n+case of functions).\n+The grammar specifies the exact locations in which sub-item declarations may appear.\n \n ### Type Parameters\n \n-All items except modules may be *parametrized* by type. Type parameters are\n+All items except modules may be *parameterized* by type. Type parameters are\n given as a comma-separated list of identifiers enclosed in angle brackets\n-(`<...>`), after the name of the item and before its definition. The type\n-parameters of an item are considered \"part of the name\", not the type of the\n-item; in order to refer to the type-parametrized item, a referencing\n-[path](#paths) must in general provide type arguments as a list of\n-comma-separated types enclosed within angle brackets. In practice, the\n-type-inference system can usually infer such argument types from\n-context. There are no general type-parametric types, only type-parametric\n-items.\n-\n+(`<...>`), after the name of the item and before its definition.\n+The type parameters of an item are considered \"part of the name\", not part of the type of the item.\n+A referencing [path](#paths) must (in principle) provide type arguments as a list of comma-separated types enclosed within angle brackets, in order to refer to the type-parameterized item.\n+In practice, the type-inference system can usually infer such argument types from context.\n+There are no general type-parametric types, only type-parametric items.\n+That is, Rust has no notion of type abstraction: there are no first-class \"forall\" types.\n \n ### Modules\n \n@@ -769,9 +760,9 @@ mod math {\n view_item : extern_mod_decl | use_decl ;\n ~~~~~~~~\n \n-A view item manages the namespace of a module; it does not define new items\n-but simply changes the visibility of other items. There are several kinds of\n-view item:\n+A view item manages the namespace of a module.\n+View items do not define new items, but rather, simply change other items' visibilit.\n+There are several kinds of view item:\n \n  * [`extern mod` declarations](#extern-mod-declarations)\n  * [`use` declarations](#use-declarations)\n@@ -795,7 +786,7 @@ compiler's library path and matching the `link_attrs` provided in the\n crate when it was compiled. If no `link_attrs` are provided, a default `name`\n attribute is assumed, equal to the `ident` given in the `use_decl`.\n \n-Two examples of `extern mod` declarations:\n+Three examples of `extern mod` declarations:\n \n ~~~~~~~~{.xfail-test}\n extern mod pcre (uuid = \"54aba0f8-a7b1-4beb-92f1-4cf625264841\");\n@@ -817,7 +808,7 @@ path_glob : ident [ \"::\" path_glob ] ?\n ~~~~~~~~\n \n A _use declaration_ creates one or more local name bindings synonymous\n-with some other [path](#paths). Usually an use declaration is used to\n+with some other [path](#paths). Usually a `use` declaration is used to\n shorten the path required to refer to a module item.\n \n *Note*: unlike many languages, Rust's `use` declarations do *not* declare\n@@ -850,8 +841,8 @@ fn main() {\n     log(info, Some(1.0));\n \n     // Equivalent to 'log(core::info,\n-    //                    core::str::to_upper(core::str::slice(~\"foo\", 0u, 1u)));'\n-    log(info, to_upper(slice(~\"foo\", 0u, 1u)));\n+    //                    core::str::to_upper(core::str::slice(\"foo\", 0, 1)));'\n+    log(info, to_upper(slice(\"foo\", 0, 1)));\n }\n ~~~~\n \n@@ -863,13 +854,9 @@ If a sequence of such redirections form a cycle or cannot be unambiguously resol\n \n ### Functions\n \n-A _function item_ defines a sequence of [statements](#statements) and an\n-optional final [expression](#expressions) associated with a name and a set of\n-parameters. Functions are declared with the keyword `fn`. Functions declare a\n-set of *input* [*slots*](#memory-slots) as parameters, through which the\n-caller passes arguments into the function, and an *output*\n-[*slot*](#memory-slots) through which the function passes results back to\n-the caller.\n+A _function item_ defines a sequence of [statements](#statements) and an optional final [expression](#expressions), along with a name and a set of parameters.\n+Functions are declared with the keyword `fn`.\n+Functions declare a set of *input* [*slots*](#memory-slots) as parameters, through which the caller passes arguments into the function, and an *output* [*slot*](#memory-slots) through which the function passes results back to the caller.\n \n A function may also be copied into a first class *value*, in which case the\n value has the corresponding [*function type*](#function-types), and can be\n@@ -890,59 +877,76 @@ fn add(x: int, y: int) -> int {\n }\n ~~~~\n \n-#### Diverging functions\n \n-A special kind of function can be declared with a `!` character where the\n-output slot type would normally be. For example:\n+#### Generic functions\n \n-~~~~\n-fn my_err(s: ~str) -> ! {\n-    log(info, s);\n-    fail;\n+A _generic function_ allows one or more _parameterized types_ to\n+appear in its signature. Each type parameter must be explicitly\n+declared, in an angle-bracket-enclosed, comma-separated list following\n+the function name.\n+\n+~~~~ {.xfail-test}\n+fn iter<T>(seq: &[T], f: fn(T)) {\n+    for seq.each |elt| { f(elt); }\n+}\n+fn map<T, U>(seq: &[T], f: fn(T) -> U) -> ~[U] {\n+    let mut acc = ~[];\n+    for seq.each |elt| { acc.push(f(elt)); }\n+    acc\n }\n ~~~~\n \n-We call such functions \"diverging\" because they never return a value to the\n-caller. Every control path in a diverging function must end with a\n-[`fail`](#fail-expressions) or a call to another diverging function on every\n-control path. The `!` annotation does *not* denote a type. Rather, the result\n-type of a diverging function is a special type called $\\bot$ (\"bottom\") that\n-unifies with any type. Rust has no syntax for $\\bot$.\n+Inside the function signature and body, the name of the type parameter\n+can be used as a type name.\n \n-It might be necessary to declare a diverging function because as mentioned\n-previously, the typechecker checks that every control path in a function ends\n-with a [`return`](#return-expressions) or diverging expression. So, if `my_err`\n-were declared without the `!` annotation, the following code would not\n-typecheck:\n+When a generic function is referenced, its type is instantiated based\n+on the context of the reference. For example, calling the `iter`\n+function defined above on `[1, 2]` will instantiate type parameter `T`\n+with `int`, and require the closure parameter to have type\n+`fn(int)`.\n \n-~~~~\n-# fn my_err(s: ~str) -> ! { fail }\n+Since a parameter type is opaque to the generic function, the set of\n+operations that can be performed on it is limited. Values of parameter\n+type can always be moved, but they can only be copied when the\n+parameter is given a [`Copy` bound](#type-kinds).\n \n-fn f(i: int) -> int {\n-   if i == 42 {\n-     return 42;\n-   }\n-   else {\n-     my_err(~\"Bad number!\");\n-   }\n-}\n ~~~~\n+fn id<T: Copy>(x: T) -> T { x }\n+~~~~\n+\n+Similarly, [trait](#traits) bounds can be specified for type\n+parameters to allow methods with that trait to be called on values\n+of that type.\n+\n+\n+#### Unsafe functions\n+\n+Unsafe functions are those containing unsafe operations that are not contained in an [`unsafe` block](#unsafe-blocks).\n+Such a function must be prefixed with the keyword `unsafe`.\n+\n+Unsafe operations are those that potentially violate the memory-safety guarantees of Rust's static semantics.\n+Specifically, the following operations are considered unsafe:\n+\n+  - Dereferencing a [raw pointer](#pointer-types).\n+  - Casting a [raw pointer](#pointer-types) to a safe pointer type.\n+  - Breaking the [purity-checking rules](#pure-functions) in a `pure` function.\n+  - Calling an unsafe function.\n+\n+##### Unsafe blocks\n+\n+A block of code can also be prefixed with the `unsafe` keyword, to permit a sequence of unsafe operations in an otherwise-safe function.\n+This facility exists because the static semantics of Rust are a necessary approximation of the dynamic semantics.\n+When a programmer has sufficient conviction that a sequence of unsafe operations is actually safe, they can encapsulate that sequence (taken as a whole) within an `unsafe` block. The compiler will consider uses of such code \"safe\", to the surrounding context.\n \n-The typechecker would complain that `f` doesn't return a value in the\n-`else` branch. Adding the `!` annotation on `my_err` would\n-express that `f` requires no explicit `return`, as if it returns\n-control to the caller, it returns a value (true because it never returns\n-control).\n \n #### Pure functions\n \n A pure function declaration is identical to a function declaration, except that\n it is declared with the additional keyword `pure`. In addition, the typechecker\n checks the body of a pure function with a restricted set of typechecking rules.\n-A pure function\n-\n-* may not contain an assignment or self-call expression; and\n-* may only call other pure functions, not general functions.\n+A pure function may only modify data owned by its own stack frame.\n+So, a pure function may modify a local variable allocated on the stack, but not a mutable reference that it takes as an argument.\n+A pure function may only call other pure functions, not general functions.\n \n An example of a pure function:\n \n@@ -963,96 +967,59 @@ pure fn nonempty_list<T>(ls: List<T>) -> bool { pure_length(ls) > 0u }\n These purity-checking rules approximate the concept of referential transparency:\n that a call-expression could be rewritten with the literal-expression of its return value, without changing the meaning of the program.\n Since they are an approximation, sometimes these rules are *too* restrictive.\n-Rust allows programmers to violate these rules using [`unsafe` blocks](#unsafe-blocks).\n+Rust allows programmers to violate these rules using [`unsafe` blocks](#unsafe-blocks), which we already saw.\n As with any `unsafe` block, those that violate static purity carry transfer the burden of safety-proof from the compiler to the programmer.\n Programmers should exercise caution when breaking such rules.\n \n-An example of a pure function that uses an unsafe block:\n+For more details on purity, see [the borrowed pointer tutorial][borrow].\n \n-~~~~ {.xfail-test}\n-# use std::list::*;\n+[borrow]: tutorial-borrowed-ptr.html\n \n-fn pure_foldl<T, U: Copy>(ls: List<T>, u: U, f: fn(&&T, &&U) -> U) -> U {\n-    match ls {\n-      Nil => u,\n-      Cons(hd, tl) => f(hd, pure_foldl(*tl, f(hd, u), f))\n-    }\n-}\n-\n-pure fn pure_length<T>(ls: List<T>) -> uint {\n-    fn count<T>(_t: T, &&u: uint) -> uint { u + 1u }\n-    unsafe {\n-        pure_foldl(ls, 0u, count)\n-    }\n-}\n-~~~~\n-\n-Despite its name, `pure_foldl` is a `fn`, not a `pure fn`, because there is no\n-way in Rust to specify that the higher-order function argument `f` is a pure\n-function. So, to use `foldl` in a pure list length function that a pure function\n-could then use, we must use an `unsafe` block wrapped around the call to\n-`pure_foldl` in the definition of `pure_length`.\n-\n-#### Generic functions\n+#### Diverging functions\n \n-A _generic function_ allows one or more _parameterized types_ to\n-appear in its signature. Each type parameter must be explicitly\n-declared, in an angle-bracket-enclosed, comma-separated list following\n-the function name.\n+A special kind of function can be declared with a `!` character where the\n+output slot type would normally be. For example:\n \n-~~~~ {.xfail-test}\n-fn iter<T>(seq: ~[T], f: fn(T)) {\n-    for seq.each |elt| { f(elt); }\n-}\n-fn map<T, U>(seq: ~[T], f: fn(T) -> U) -> ~[U] {\n-    let mut acc = ~[];\n-    for seq.each |elt| { acc.push(f(elt)); }\n-    acc\n+~~~~\n+fn my_err(s: &str) -> ! {\n+    log(info, s);\n+    fail;\n }\n ~~~~\n \n-Inside the function signature and body, the name of the type parameter\n-can be used as a type name.\n-\n-When a generic function is referenced, its type is instantiated based\n-on the context of the reference. For example, calling the `iter`\n-function defined above on `[1, 2]` will instantiate type parameter `T`\n-with `int`, and require the closure parameter to have type\n-`fn(int)`.\n+We call such functions \"diverging\" because they never return a value to the\n+caller. Every control path in a diverging function must end with a\n+[`fail`](#fail-expressions) or a call to another diverging function on every\n+control path. The `!` annotation does *not* denote a type. Rather, the result\n+type of a diverging function is a special type called $\\bot$ (\"bottom\") that\n+unifies with any type. Rust has no syntax for $\\bot$.\n \n-Since a parameter type is opaque to the generic function, the set of\n-operations that can be performed on it is limited. Values of parameter\n-type can always be moved, but they can only be copied when the\n-parameter is given a [`copy` bound](#type-kinds).\n+It might be necessary to declare a diverging function because as mentioned\n+previously, the typechecker checks that every control path in a function ends\n+with a [`return`](#return-expressions) or diverging expression. So, if `my_err`\n+were declared without the `!` annotation, the following code would not\n+typecheck:\n \n ~~~~\n-fn id<T: Copy>(x: T) -> T { x }\n-~~~~\n-\n-Similarly, [trait](#traits) bounds can be specified for type\n-parameters to allow methods with that trait to be called on values\n-of that type.\n-\n-#### Unsafe functions\n-\n-Unsafe functions are those containing unsafe operations that are not contained in an [`unsafe` block](#unsafe-blocks).\n+# fn my_err(s: &str) -> ! { fail }\n \n-Unsafe operations are those that potentially violate the memory-safety guarantees of Rust's static semantics.\n-Specifically, the following operations are considered unsafe:\n-\n-  - Dereferencing a [raw pointer](#pointer-types)\n-  - Casting a [raw pointer](#pointer-types) to a safe pointer type\n-  - Breaking the [purity-checking rules](#pure-functions)\n-  - Calling an unsafe function\n-\n-##### Unsafe blocks\n+fn f(i: int) -> int {\n+   if i == 42 {\n+     return 42;\n+   }\n+   else {\n+     my_err(\"Bad number!\");\n+   }\n+}\n+~~~~\n \n-A block of code can also be prefixed with the `unsafe` keyword,\n-to permit a sequence of unsafe operations in an otherwise-safe function.\n-This facility exists because the static semantics of a Rust are a necessary approximation of the dynamic semantics.\n-When a programmer has sufficient conviction that a sequence of unsafe operations is actually safe,\n-they can encapsulate that sequence (taken as a whole) within an `unsafe` block.\n-The compiler will consider uses of such code \"safe\", to the surrounding context.\n+This will not compile without the `!` annotation on `my_err`,\n+since the `else` branch of the conditional in `f` does not return an `int`,\n+as required by the signature of `f`.\n+Adding the `!` annotation to `my_err` informs the typechecker that,\n+should control ever enter `my_err`, no further type judgments about `f` need to hold,\n+since control will never resume in any context that relies on those judgments.\n+Thus the return type on `f` only needs to reflect the `if` branch of the conditional.\n \n \n #### Extern functions\n@@ -1089,177 +1056,172 @@ specific type; the type-specified aspects of a value include:\n * Whether the value represents textual or numerical information.\n * Whether the value represents integral or floating-point information.\n * The sequence of memory operations required to access the value.\n-* The *kind* of the type (pinned, unique or shared).\n+* The [kind](#type-kinds) of the type.\n \n-For example, the type `{x: u8, y: u8`} defines the set of immutable values\n-that are composite records, each containing two unsigned 8-bit integers\n-accessed through the components `x` and `y`, and laid out in memory with the\n-`x` component preceding the `y` component.\n+For example, the type `(u8, u8)` defines the set of immutable values that are composite pairs,\n+each containing two unsigned 8-bit integers accessed by pattern-matching and laid out in memory with the `x` component preceding the `y` component.\n \n-### Enumerations\n+### Structures\n \n-An _enumeration item_ simultaneously declares a new nominal\n-[enumerated type](#enumerated-types) as well as a set of *constructors* that\n-can be used to create or pattern-match values of the corresponding enumerated\n-type. Note that `enum` previously was referred to as a `tag`, however this\n-definition has been deprecated. While `tag` is no longer used, the two are\n-synonymous.\n+A _structure_ is a nominal [structure type](#structure-types) defined with the keyword `struct`.\n \n-The constructors of an `enum` type may be recursive: that is, each constructor\n-may take an argument that refers, directly or indirectly, to the enumerated\n-type the constructor is a member of. Such recursion has restrictions:\n+An example of a `struct` item and its use:\n \n-* Recursive types can be introduced only through `enum` constructors.\n-* A recursive `enum` item must have at least one non-recursive constructor (in\n-  order to give the recursion a basis case).\n-* The recursive argument of recursive `enum` constructors must be [*box*\n-  values](#box-types) (in order to bound the in-memory size of the\n-  constructor).\n-* Recursive type definitions can cross module boundaries, but not module\n-  *visibility* boundaries or crate boundaries (in order to simplify the\n-  module system).\n+~~~~\n+struct Point {x: int, y: int}\n+let p = Point {x: 10, y: 11};\n+let px: int = p.x;\n+~~~~\n+\n+### Enumerations\n \n+An _enumeration_ is a simultaneous definition of a nominal [enumerated type](#enumerated-types) as well as a set of *constructors*,\n+that can be used to create or pattern-match values of the corresponding enumerated type.\n+\n+Enumerations are declared with the keyword `enum`.\n \n An example of an `enum` item and its use:\n \n ~~~~\n-enum animal {\n-  dog,\n-  cat\n+enum Animal {\n+  Dog,\n+  Cat\n }\n \n-let mut a: animal = dog;\n-a = cat;\n+let mut a: Animal = Dog;\n+a = Cat;\n ~~~~\n \n-An example of a *recursive* `enum` item and its use:\n+### Constants\n \n-~~~~\n-enum list<T> {\n-  nil,\n-  cons(T, @list<T>)\n-}\n+~~~~~~~~ {.ebnf .gram}\n+const_item : \"const\" ident ':' type '=' expr ';' ;\n+~~~~~~~~\n \n-let a: list<int> = cons(7, @cons(13, @nil));\n-~~~~\n+A *constant* is a named value stored in read-only memory in a crate.\n+The value bound to a constant is evaluated at compile time.\n+Constants are declared with the `const` keyword.\n+A constant item must have an expression giving its definition.\n+The definition expression of a constant is limited to expression forms that can be evaluated at compile time.\n \n ### Traits\n \n-A _trait item_ describes a set of method types. [_implementation\n-items_](#implementations) can be used to provide implementations of\n-those methods for a specific type.\n+A _trait_ describes a set of method types.\n+\n+Traits can include default implementations of methods,\n+written in terms of some unknown [`self` type](#self-types);\n+the `self` type may either be completely unspecified,\n+or constrained by some other [trait type](#trait-types).\n+\n+Traits are implemented for specific types through separate [implementations](#implementations).\n \n ~~~~\n-# type surface = int;\n-# type bounding_box = int;\n+# type Surface = int;\n+# type BoundingBox = int;\n \n-trait shape {\n-    fn draw(surface);\n-    fn bounding_box() -> bounding_box;\n+trait Shape {\n+    fn draw(Surface);\n+    fn bounding_box() -> BoundingBox;\n }\n ~~~~\n \n-This defines a trait with two methods. All values that have\n-[implementations](#implementations) of this trait in scope can\n-have their `draw` and `bounding_box` methods called, using\n-`value.bounding_box()` [syntax](#field-expressions).\n+This defines a trait with two methods.\n+All values that have [implementations](#implementations) of this trait in scope can have their `draw` and `bounding_box` methods called,\n+using `value.bounding_box()` [syntax](#method-call-expressions).\n \n Type parameters can be specified for a trait to make it generic.\n-These appear after the name, using the same syntax used in [generic\n-functions](#generic-functions).\n+These appear after the trait name, using the same syntax used in [generic functions](#generic-functions).\n \n ~~~~\n-trait seq<T> {\n+trait Seq<T> {\n    fn len() -> uint;\n    fn elt_at(n: uint) -> T;\n    fn iter(fn(T));\n }\n ~~~~\n \n-Generic functions may use traits as bounds on their type\n-parameters. This will have two effects: only types that have the trait\n-may instantiate the parameter, and within the\n-generic function, the methods of the trait can be called on values\n-that have the parameter's type. For example:\n+Generic functions may use traits as _bounds_ on their type parameters.\n+This will have two effects: only types that have the trait may instantiate the parameter,\n+and within the generic function,\n+the methods of the trait can be called on values that have the parameter's type.\n+For example:\n \n ~~~~\n-# type surface = int;\n-# trait shape { fn draw(surface); }\n+# type Surface = int;\n+# trait Shape { fn draw(Surface); }\n \n-fn draw_twice<T: shape>(surface: surface, sh: T) {\n+fn draw_twice<T: Shape>(surface: Surface, sh: T) {\n     sh.draw(surface);\n     sh.draw(surface);\n }\n ~~~~\n \n-Trait items also define a type with the same name as the\n-trait. Values of this type are created by\n-[casting](#type-cast-expressions) values (of a type for which an\n-implementation of the given trait is in scope) to the trait\n-type.\n+Traits also define a [type](#trait-types) with the same name as the trait.\n+Values of this type are created by [casting](#type-cast-expressions) pointer values\n+(pointing to a type for which an implementation of the given trait is in scope)\n+to pointers to the trait name, used as a type.\n \n ~~~~\n-# trait shape { }\n-# impl int: shape { }\n+# trait Shape { }\n+# impl int: Shape { }\n # let mycircle = 0;\n \n-let myshape: shape = mycircle as shape;\n+let myshape: Shape = @mycircle as @Shape;\n ~~~~\n \n-The resulting value is a reference-counted box containing the value\n-that was cast along with information that identify the methods of the\n-implementation that was used. Values with a trait type can always\n-have methods from their trait called on them, and can be used to\n-instantiate type parameters that are bounded by their trait.\n+The resulting value is a managed box containing the value that was cast,\n+along with information that identifies the methods of the implementation that was used.\n+Values with a trait type can have [methods called](#method-call-expressions) on them,\n+for any method in the trait,\n+and can be used to instantiate type parameters that are bounded by the trait.\n \n ### Implementations\n \n-An _implementation item_ provides an implementation of a\n-[trait](#traits) for a type.\n+An _implementation_ is an item that implements a [trait](#traits) for a specific type.\n+\n+Implementations are defined with the keyword `impl`.\n \n ~~~~\n-# type point = {x: float, y: float};\n-# type surface = int;\n-# type bounding_box = {x: float, y: float, width: float, height: float};\n-# trait shape { fn draw(surface); fn bounding_box() -> bounding_box; }\n-# fn do_draw_circle(s: surface, c: circle) { }\n+# type Point = {x: float, y: float};\n+# type Surface = int;\n+# type BoundingBox = {x: float, y: float, width: float, height: float};\n+# trait Shape { fn draw(Surface); fn bounding_box() -> BoundingBox; }\n+# fn do_draw_circle(s: Surface, c: Circle) { }\n \n-type circle = {radius: float, center: point};\n+type Circle = {radius: float, center: Point};\n \n-impl circle: shape {\n-    fn draw(s: surface) { do_draw_circle(s, self); }\n-    fn bounding_box() -> bounding_box {\n+impl Circle: Shape {\n+    fn draw(s: Surface) { do_draw_circle(s, self); }\n+    fn bounding_box() -> BoundingBox {\n         let r = self.radius;\n         {x: self.center.x - r, y: self.center.y - r,\n          width: 2.0 * r, height: 2.0 * r}\n     }\n }\n ~~~~\n \n-It is possible to define an implementation without referring to a\n-trait.  The methods in such an implementation can only be used\n-statically (as direct calls on the values of the type that the\n-implementation targets). In such an implementation, the type after the colon is omitted,\n-and the name is mandatory.  Such implementations are\n-limited to nominal types (enums, structs) and the implementation must\n-appear in the same module or a sub-module as the receiver type.\n+It is possible to define an implementation without referring to a trait.\n+The methods in such an implementation can only be used statically\n+(as direct calls on the values of the type that the implementation targets).\n+In such an implementation, the type after the colon is omitted.\n+Such implementations are limited to nominal types (enums, structs),\n+and the implementation must appear in the same module or a sub-module as the `self` type.\n \n-_When_ a trait is specified, all methods declared as part of the\n-trait must be present, with matching types and type parameter\n-counts, in the implementation.\n+When a trait _is_ specified in an `impl`,\n+all methods declared as part of the trait must be implemented,\n+with matching types and type parameter counts.\n \n-An implementation can take type parameters, which can be different\n-from the type parameters taken by the trait it implements. They\n-are written after the name of the implementation, or if that is not\n-specified, after the `impl` keyword.\n+An implementation can take type parameters,\n+which can be different from the type parameters taken by the trait it implements.\n+Implementation parameters are written after after the `impl` keyword.\n \n ~~~~\n-# trait seq<T> { }\n+# trait Seq<T> { }\n \n-impl<T> ~[T]: seq<T> {\n+impl<T> ~[T]: Seq<T> {\n    ...\n }\n-impl u32: seq<bool> {\n+impl u32: Seq<bool> {\n    /* Treat the integer as a sequence of bits */\n }\n ~~~~\n@@ -1273,9 +1235,9 @@ foreign_mod : [ foreign_fn ] * ;\n \n Foreign modules form the basis for Rust's foreign function interface. A\n foreign module describes functions in external, non-Rust\n-libraries. Functions within foreign modules are declared the same as other\n-Rust functions, with the exception that they may not have a body and are\n-instead terminated by a semi-colon.\n+libraries.\n+Functions within foreign modules are declared in the same way as other Rust functions,\n+with the exception that they may not have a body and are instead terminated by a semicolon.\n \n ~~~\n # use libc::{c_char, FILE};\n@@ -1286,9 +1248,8 @@ extern mod c {\n }\n ~~~\n \n-Functions within foreign modules may be called by Rust code as it would any\n-normal function and the Rust compiler will automatically translate between\n-the Rust ABI and the foreign ABI.\n+Functions within foreign modules may be called by Rust code, just like functions defined in Rust.\n+The Rust compiler automatically translates between the Rust ABI and the foreign ABI.\n \n The name of the foreign module has special meaning to the Rust compiler in\n that it will treat the module name as the name of a library to link to,\n@@ -1302,7 +1263,7 @@ A number of [attributes](#attributes) control the behavior of foreign\n modules.\n \n By default foreign modules assume that the library they are calling use the\n-standard C \"cdecl\" ABI. Other ABI's may be specified using the `abi`\n+standard C \"cdecl\" ABI. Other ABIs may be specified using the `abi`\n attribute as in\n \n ~~~{.xfail-test}\n@@ -1312,15 +1273,15 @@ extern mod kernel32 { }\n ~~~\n \n The `link_name` attribute allows the default library naming behavior to\n-be overriden by explicitly specifying the name of the library.\n+be overridden by explicitly specifying the name of the library.\n \n ~~~{.xfail-test}\n #[link_name = \"crypto\"]\n extern mod mycrypto { }\n ~~~\n \n-The `nolink` attribute tells the Rust compiler not to perform any linking\n-for the foreign module. This is particularly useful for creating foreign\n+The `nolink` attribute tells the Rust compiler not to do any linking for the foreign module.\n+This is particularly useful for creating foreign\n modules for libc, which tends to not follow standard library naming\n conventions and is linked to all Rust programs anyway.\n \n@@ -1335,9 +1296,9 @@ attr : ident [ '=' literal\n \n Static entities in Rust -- crates, modules and items -- may have _attributes_\n applied to them. ^[Attributes in Rust are modeled on Attributes in ECMA-335,\n-C#] An attribute is a general, free-form piece of metadata that is interpreted\n-according to name, convention, and language and compiler version.  Attributes\n-may appear as any of:\n+C#]\n+An attribute is a general, free-form metadatum that is interpreted according to name, convention, and language and compiler version.\n+Attributes may appear as any of\n \n * A single identifier, the attribute name\n * An identifier followed by the equals sign '=' and a literal, providing a key/value pair\n@@ -1370,10 +1331,8 @@ mod bar {\n fn add(x: int, y: int) { x + y }\n ~~~~~~~~\n \n-In future versions of Rust, user-provided extensions to the compiler will be\n-able to interpret attributes. When this facility is provided, the compiler\n-will distinguish will be made between language-reserved and user-available\n-attributes.\n+> **Note:** In future versions of Rust, user-provided extensions to the compiler will be able to interpret attributes.\n+> When this facility is provided, the compiler will distinguish between language-reserved and user-available attributes.\n \n At present, only the Rust compiler interprets attributes, so all attribute\n names are effectively reserved. Some significant attributes include:\n@@ -1401,25 +1360,22 @@ sequence expression evaluation.\n ## Statements\n \n A _statement_ is a component of a block, which is in turn a component of an\n-outer [expression](#expressions) or [function](#functions). When a function is\n-spawned into a [task](#tasks), the task *executes* statements in an order\n-determined by the body of the enclosing function. Each statement causes the\n-task to perform certain actions.\n+outer [expression](#expressions) or [function](#functions).\n \n Rust has two kinds of statement:\n [declaration statements](#declaration-statements) and\n [expression statements](#expression-statements).\n \n ### Declaration statements\n \n-A _declaration statement_ is one that introduces a *name* into the enclosing\n-statement block. The declared name may denote a new slot or a new item.\n+A _declaration statement_ is one that introduces one or more *names* into the enclosing statement block.\n+The declared names may denote new slots or new items.\n \n #### Item declarations\n \n An _item declaration statement_ has a syntactic form identical to an\n [item](#items) declaration within a module. Declaring an item -- a function,\n-enumeration, type, resource, trait, implementation or module -- locally\n+enumeration, type, constant, trait, implementation or module -- locally\n within a statement block is simply a way of restricting its scope to a narrow\n region containing all of its uses; it is otherwise identical in meaning to\n declaring the item outside the statement block.\n@@ -1435,27 +1391,11 @@ let_decl : \"let\" pat [':' type ] ? [ init ] ? ';' ;\n init : [ '=' | '<-' ] expr ;\n ~~~~~~~~\n \n-\n-A _slot declaration_ has one of two forms:\n-\n-* `let` `pattern` `optional-init`;\n-* `let` `pattern` : `type` `optional-init`;\n-\n-Where `type` is a type expression, `pattern` is an irrefutable pattern (often\n-just the name of a single slot), and `optional-init` is an optional\n-initializer. If present, the initializer consists of either an assignment\n-operator (`=`) or move operator (`<-`), followed by an expression.\n-\n-Both forms introduce a new slot into the enclosing block scope. The new slot\n-is visible from the point of declaration until the end of the enclosing block\n-scope.\n-\n-The former form, with no type annotation, causes the compiler to infer the\n-static type of the slot through unification with the types of values assigned\n-to the slot in the remaining code in the block scope. Inference only occurs on\n-frame-local variable, not argument slots. Function signatures must\n-always declare types for all argument slots.\n-\n+A _slot declaration_ introduces a new set of slots, given by a pattern.\n+The pattern may be followed by a type annotation, and/or an initializer expression.\n+When no type annotation is given, the compiler will infer the type,\n+or signal an error if insufficient type information is available for definite inference.\n+Any slots introduced by a slot declaration are visible from the point of declaration until the end of the enclosing block scope.\n \n ### Expression statements\n \n@@ -1484,10 +1424,15 @@ Expressions are divided into two main categories: _lvalues_ and _rvalues_.\n Likewise within each expression, sub-expressions may occur in _lvalue context_ or _rvalue context_.\n The evaluation of an expression depends both on its own category and the context it occurs within.\n \n-Path, field and index expressions are lvalues.\n+[Path](#path-expressions), [field](#field-expressions) and [index](#index-expressions) expressions are lvalues.\n All other expressions are rvalues.\n \n-The left operand of an assignment expression and the operand of the borrow operator are lvalue contexts.\n+The left operand of an [assignment](#assignment-expressions),\n+[binary move](#binary-move-expressions) or\n+[compound-assignment](#compound-assignment-expressions) expression is an lvalue context,\n+as is the single operand of a unary [borrow](#unary-operator-expressions),\n+or [move](#unary-move-expressions) expression,\n+and _both_ operands of a [swap](#swap-expressions) expression.\n All other expression contexts are rvalue contexts.\n \n When an lvalue is evaluated in an _lvalue context_, it denotes a memory location;\n@@ -1501,15 +1446,20 @@ A temporary's lifetime equals the largest lifetime of any borrowed pointer that\n \n A _literal expression_ consists of one of the [literal](#literals)\n forms described earlier. It directly describes a number, character,\n-string, boolean value, or the nil value.\n+string, boolean value, or the unit value.\n \n ~~~~~~~~ {.literals}\n-();        // nil type\n-~\"hello\";  // string type\n+();        // unit type\n+\"hello\";   // string type\n '5';       // character type\n 5;         // integer type\n ~~~~~~~~\n \n+### Path expressions\n+\n+A [path](#paths) used as an expression context denotes either a local variable or an item.\n+Path expressions are [lvalues](#lvalues-rvalues-and-temporaries).\n+\n ### Tuple expressions\n \n Tuples are written by enclosing two or more comma-separated\n@@ -1518,15 +1468,15 @@ values.\n \n ~~~~~~~~ {.tuple}\n (0f, 4.5f);\n-(~\"a\", 4u, true);\n+(\"a\", 4u, true);\n ~~~~~~~~\n \n ### Record expressions\n \n ~~~~~~~~{.ebnf .gram}\n rec_expr : '{' ident ':' expr\n                [ ',' ident ':' expr ] *\n-               [ \"with\" expr ] '}'\n+               [ \"..\" expr ] '}'\n ~~~~~~~~\n \n A [_record_](#record-types) _expression_ is one or more comma-separated\n@@ -1537,8 +1487,8 @@ written before its name.\n \n ~~~~\n {x: 10f, y: 20f};\n-{name: ~\"Joe\", age: 35u, score: 100_000};\n-{ident: ~\"X\", mut count: 0u};\n+{name: \"Joe\", age: 35u, score: 100_000};\n+{ident: \"X\", mut count: 0u};\n ~~~~\n \n The order of the fields in a record expression is significant, and\n@@ -1559,34 +1509,39 @@ let base = {x: 1, y: 2, z: 3};\n {y: 0, z: 10, .. base};\n ~~~~\n \n+### Method-call expressions\n+\n+~~~~~~~~{.ebnf .gram}\n+method_call_expr : expr '.' ident paren_expr_list ;\n+~~~~~~~~\n+\n+A _method call_ consists of an expression followed by a single dot, an identifier, and a parenthesized expression-list.\n+Method calls are resolved to methods on specific traits,\n+either statically dispatching to a method if the exact `self`-type of the left-hand-side is known,\n+or dynamically dispatching if the left-hand-side expression is an indirect [trait type](#trait-types).\n+\n+\n ### Field expressions\n \n ~~~~~~~~{.ebnf .gram}\n-field_expr : expr '.' expr\n+field_expr : expr '.' ident\n ~~~~~~~~\n \n-A dot can be used to access a field in a record.\n+A _field expression_ consists of an expression followed by a single dot and an identifier,\n+when not immediately followed by a parenthesized expression-list (the latter is a [method call expression](#method-call-expressions)).\n+A field expression denotes a field of a [structure](#structure-types) or [record](#record-types).\n \n ~~~~~~~~ {.field}\n myrecord.myfield;\n {a: 10, b: 20}.a;\n ~~~~~~~~\n \n-A field access on a record is an _lval_ referring to the value of that\n-field. When the field is mutable, it can be\n-[assigned](#assignment-expressions) to.\n+A field access on a record is an [lvalue](#lvalues-rvalues-and-temporaries) referring to the value of that field.\n+When the field is mutable, it can be [assigned](#assignment-expressions) to.\n \n-When the type of the expression to the left of the dot is a boxed\n-record, it is automatically derferenced to make the field access\n-possible.\n+When the type of the expression to the left of the dot is a pointer to a record or structure,\n+it is automatically derferenced to make the field access possible.\n \n-Field access syntax is overloaded for [trait method](#traits)\n-access. When no matching field is found, or the expression to the left\n-of the dot is not a (boxed) record, an\n-[implementation](#implementations) that matches this type and the\n-given method name is looked up instead, and the result of the\n-expression is this method, with its _self_ argument bound to the\n-expression on the left of the dot.\n \n ### Vector expressions\n \n@@ -1601,9 +1556,9 @@ indicate that the elements of the resulting vector may be mutated.\n When no mutability is specified, the vector is immutable.\n \n ~~~~\n-~[1, 2, 3, 4];\n-~[~\"a\", ~\"b\", ~\"c\", ~\"d\"];\n-~[mut 0u8, 0u8, 0u8, 0u8];\n+[1, 2, 3, 4];\n+[\"a\", \"b\", \"c\", \"d\"];\n+[mut 0u8, 0u8, 0u8, 0u8];\n ~~~~\n \n ### Index expressions\n@@ -1615,7 +1570,7 @@ idx_expr : expr '[' expr ']'\n \n [Vector](#vector-types)-typed expressions can be indexed by writing a\n square-bracket-enclosed expression (the index) after them. When the\n-vector is mutable, the resulting _lval_ can be assigned to.\n+vector is mutable, the resulting [lvalue](#lvalues-rvalues-and-temporaries) can be assigned to.\n \n Indices are zero-based, and may be of any integral type. Vector access\n is bounds-checked at run-time. When the check fails, it will put the\n@@ -1624,35 +1579,37 @@ task in a _failing state_.\n ~~~~\n # do task::spawn_unlinked {\n \n-(~[1, 2, 3, 4])[0];\n-(~[mut 'x', 'y'])[1] = 'z';\n-(~[~\"a\", ~\"b\"])[10]; // fails\n+([1, 2, 3, 4])[0];\n+([mut 'x', 'y'])[1] = 'z';\n+([\"a\", \"b\"])[10]; // fails\n \n # }\n ~~~~\n \n ### Unary operator expressions\n \n-Rust defines five unary operators. They are all written as prefix\n-operators, before the expression they apply to.\n+Rust defines six symbolic unary operators,\n+in addition to the unary [copy](#unary-copy-expressions) and [move](#unary-move-expressions) operators.\n+They are all written as prefix operators, before the expression they apply to.\n \n `-`\n   : Negation. May only be applied to numeric types.\n `*`\n-  : Dereference. When applied to a [box](#box-types) or\n-    [resource](#resources) type, it accesses the inner value. For\n-    mutable boxes, the resulting _lval_ can be assigned to. For\n-    [enums](#enumerated-types) that have only a single variant,\n-    containing a single parameter, the dereference operator accesses\n-    this parameter.\n+  : Dereference. When applied to a [pointer](#pointer-types) it denotes the pointed-to location.\n+    For pointers to mutable locations, the resulting [lvalue](#lvalues-rvalues-and-temporaries) can be assigned to.\n+    For [enums](#enumerated-types) that have only a single variant, containing a single parameter,\n+    the dereference operator accesses this parameter.\n `!`\n   : Logical negation. On the boolean type, this flips between `true` and\n     `false`. On integer types, this inverts the individual bits in the\n     two's complement representation of the value.\n `@` and `~`\n-  :  [Boxing](#box-types) operators. Allocate a box to hold the value\n-     they are applied to, and store the value in it. `@` creates a\n-     shared, reference-counted box, whereas `~` creates a unique box.\n+  :  [Boxing](#pointer-types) operators. Allocate a box to hold the value they are applied to,\n+     and store the value in it. `@` creates a managed box, whereas `~` creates an owned box.\n+`&`\n+  : Borrow operator. Returns a borrowed pointer, pointing to its operand.\n+    The operand of a borrowed pointer is statically proven to outlive the resulting pointer.\n+    If the borrow-checker cannot prove this, it is a compilation error.\n \n ### Binary operator expressions\n \n@@ -1665,40 +1622,49 @@ Binary operators expressions are given in terms of\n \n #### Arithmetic operators\n \n-Binary arithmetic expressions require both their operands to be of the\n-same type, and can be applied only to numeric types, with the\n-exception of `+`, which acts both as addition operator on numbers and\n-as concatenate operator on vectors and strings.\n+Binary arithmetic expressions are syntactic sugar for calls to built-in traits,\n+defined in the `core::ops` module of the `core` library.\n+This means that arithmetic operators can be overridden for user-defined types.\n+The default meaning of the operators on standard types is given here.\n \n `+`\n   : Addition and vector/string concatenation.\n+    Calls the `add` method on the `core::ops::Add` trait.\n `-`\n   : Subtraction.\n+    Calls the `sub` method on the `core::ops::Sub` trait.\n `*`\n   : Multiplication.\n+    Calls the `mul` method on the `core::ops::Mul` trait.\n `/`\n   : Division.\n+    Calls the `div` method on the `core::ops::Div` trait.\n `%`\n-  : Remainder.\n+  : Modulo (a.k.a. \"remainder\").\n+    Calls the `modulo` method on the `core::ops::Modulo` trait.\n \n #### Bitwise operators\n \n-Bitwise operators apply only to integer types, and perform their\n-operation on the bits of the two's complement representation of the\n-values.\n+Bitwise operators are, like the [arithmetic operators](#arithmetic-operators),\n+syntactic sugar for calls to built-in traits.\n+This means that bitwise operators can be overridden for user-defined types.\n+The default meaning of the operators on standard types is given here.\n \n `&`\n   : And.\n+    Calls the `bitand` method on the `core::ops::BitAnd` trait.\n `|`\n   : Inclusive or.\n+    Calls the `bitor` method on the `core::ops::BitOr` trait.\n `^`\n   : Exclusive or.\n+    Calls the `bitxor` method on the `core::ops::BitXor` trait.\n `<<`\n   : Logical left shift.\n+    Calls the `shl` method on the `core::ops::Shl` trait.\n `>>`\n   : Logical right shift.\n-`>>>`\n-  : Arithmetic right shift.\n+    Calls the `shr` method on the `core::ops::Shr` trait.\n \n #### Lazy boolean operators\n \n@@ -1712,23 +1678,31 @@ and `&&` only when it evaluates to `true`.\n \n #### Comparison operators\n \n+Comparison operators are, like the [arithmetic operators](#arithmetic-operators),\n+and [bitwise operators](#bitwise-operators),\n+syntactic sugar for calls to built-in traits.\n+This means that comparison operators can be overridden for user-defined types.\n+The default meaning of the operators on standard types is given here.\n+\n `==`\n   : Equal to.\n+    Calls the `eq` method on the `core::cmp::Eq` trait.\n `!=`\n   : Unequal to.\n+    Calls the `ne` method on the `core::cmp::Eq` trait.\n `<`\n   : Less than.\n+    Calls the `lt` method on the `core::cmp::Ord` trait.\n `>`\n   : Greater than.\n+    Calls the `gt` method on the `core::cmp::Ord` trait.\n `<=`\n   : Less than or equal.\n+    Calls the `le` method on the `core::cmp::Ord` trait.\n `>=`\n   : Greater than or equal.\n+    Calls the `ge` method on the `core::cmp::Ord` trait.\n \n-The binary comparison operators can be applied to any two operands of\n-the same type, and produce a boolean value.\n-\n-*TODO* details on how types are descended during comparison.\n \n #### Type cast expressions\n \n@@ -1744,42 +1718,38 @@ Any other cast is unsupported and will fail to compile.\n An example of an `as` expression:\n \n ~~~~\n-# fn sum(v: ~[float]) -> float { 0.0 }\n-# fn len(v: ~[float]) -> int { 0 }\n+# fn sum(v: &[float]) -> float { 0.0 }\n+# fn len(v: &[float]) -> int { 0 }\n \n-fn avg(v: ~[float]) -> float {\n+fn avg(v: &[float]) -> float {\n   let sum: float = sum(v);\n   let sz: float = len(v) as float;\n   return sum / sz;\n }\n ~~~~\n \n-A cast is a *trivial cast* iff the type of the casted expression and the\n-target type are identical after replacing all occurrences of `int`, `uint`,\n-`float` with their machine type equivalents of the target architecture in both\n-types.\n-\n \n #### Binary move expressions\n \n-A _binary move expression_ consists of an *lval* followed by a left-pointing\n-arrow (`<-`) and an *rval* expression.\n+A _binary move expression_ consists of an [lvalue](#lvalues-rvalues-and-temporaries) followed by a left-pointing\n+arrow (`<-`) and an [rvalue](#lvalues-rvalues-and-temporaries) expression.\n \n-Evaluating a move expression causes, as a side effect, the *rval* to be\n-*moved* into the *lval*. If the *rval* was itself an *lval*, it must be a\n-local variable, as it will be de-initialized in the process.\n+Evaluating a move expression causes, as a side effect,\n+the rvalue to be *moved* into the lvalue.\n+If the rvalue was itself an lvalue, it must be a local variable,\n+as it will be de-initialized in the process.\n \n-Evaluating a move expression does not change reference counts, nor does it\n-cause a deep copy of any unique structure pointed to by the moved\n-*rval*. Instead, the move expression represents an indivisible *transfer of\n-ownership* from the right-hand-side to the left-hand-side of the\n-expression. No allocation or destruction is entailed.\n+Evaluating a move expression does not change reference counts,\n+nor does it cause a deep copy of any owned structure pointed to by the moved rvalue.\n+Instead, the move expression represents an indivisible *transfer of ownership*\n+from the right-hand-side to the left-hand-side of the expression.\n+No allocation or destruction is entailed.\n \n An example of three different move expressions:\n \n ~~~~~~~~\n-# let mut x = ~[mut 0];\n-# let a = ~[mut 0];\n+# let mut x = &[mut 0];\n+# let a = &[mut 0];\n # let b = 0;\n # let y = {mut z: 0};\n # let c = 0;\n@@ -1792,23 +1762,21 @@ y.z <- c;\n \n #### Swap expressions\n \n-A _swap expression_ consists of an *lval* followed by a bi-directional arrow\n-(`<->`) and another *lval* expression.\n+A _swap expression_ consists of an [lvalue](#lvalues-rvalues-and-temporaries) followed by a bi-directional arrow (`<->`) and another [lvalue](#lvalues-rvalues-and-temporaries).\n \n-Evaluating a swap expression causes, as a side effect, the values held in the\n-left-hand-side and right-hand-side *lvals* to be exchanged indivisibly.\n+Evaluating a swap expression causes, as a side effect, the values held in the left-hand-side and right-hand-side [lvalues](#lvalues-rvalues-and-temporaries) to be exchanged indivisibly.\n \n-Evaluating a swap expression neither changes reference counts nor deeply\n-copies any unique structure pointed to by the moved\n-*rval*. Instead, the swap expression represents an indivisible *exchange of\n-ownership* between the right-hand-side and the left-hand-side of the\n-expression. No allocation or destruction is entailed.\n+Evaluating a swap expression neither changes reference counts,\n+nor deeply copies any owned structure pointed to by the moved [rvalue](#lvalues-rvalues-and-temporaries).\n+Instead, the swap expression represents an indivisible *exchange of ownership*,\n+between the right-hand-side and the left-hand-side of the expression.\n+No allocation or destruction is entailed.\n \n An example of three different swap expressions:\n \n ~~~~~~~~\n-# let mut x = ~[mut 0];\n-# let mut a = ~[mut 0];\n+# let mut x = &[mut 0];\n+# let mut a = &[mut 0];\n # let i = 0;\n # let y = {mut z: 0};\n # let b = {mut c: 0};\n@@ -1821,8 +1789,8 @@ y.z <-> b.c;\n \n #### Assignment expressions\n \n-An _assignment expression_ consists of an *lval* expression followed by an\n-equals sign (`=`) and an *rval* expression.\n+An _assignment expression_ consists of an [lvalue](#lvalues-rvalues-and-temporaries) expression followed by an\n+equals sign (`=`) and an [rvalue](#lvalues-rvalues-and-temporaries) expression.\n \n Evaluating an assignment expression is equivalent to evaluating a [binary move\n expression](#binary-move-expressions) applied to a [unary copy\n@@ -1841,12 +1809,12 @@ The former is just more terse and familiar.\n \n #### Compound assignment expressions\n \n-The `+`, `-`, `*`, `/`, `%`, `&`, `|`, `^`, `<<`, `>>`, and `>>>`\n+The `+`, `-`, `*`, `/`, `%`, `&`, `|`, `^`, `<<`, and `>>`\n operators may be composed with the `=` operator. The expression `lval\n OP= val` is equivalent to `lval = lval OP val`. For example, `x = x +\n 1` may be written as `x += 1`.\n \n-Any such expression always has the [`nil`](#primitive-types) type.\n+Any such expression always has the [`unit`](#primitive-types) type.\n \n #### Operator precedence\n \n@@ -1857,7 +1825,7 @@ from strong to weak:\n * / %\n as\n + -\n-<< >> >>>\n+<< >>\n &\n ^\n |\n@@ -1899,13 +1867,12 @@ Evaluating a copy expression first evaluates the argument expression, then\n copies the resulting value, allocating any memory necessary to hold the new\n copy.\n \n-[Shared boxes](#box-types) (type `@`) are, as usual, shallow-copied, as they\n-may be cyclic. [Unique boxes](#box-types), [vectors](#vector-types) and\n-similar unique types are deep-copied.\n+[Managed boxes](#pointer-types) (type `@`) are, as usual, shallow-copied,\n+as are raw and borrowed pointers.\n+[Owned boxes](#pointer-types), [owned vectors](#vector-types) and similar owned types are deep-copied.\n \n-Since the binary [assignment operator](#assignment-expressions) `=` performs a\n-copy implicitly, the unary copy operator is typically only used to cause an\n-argument to a function to be copied and passed by value.\n+Since the binary [assignment operator](#assignment-expressions) `=` performs a copy implicitly,\n+the unary copy operator is typically only used to cause an argument to a function to be copied and passed by value.\n \n An example of a copy expression:\n \n@@ -1921,6 +1888,20 @@ mutate(copy v);   // Pass a copy\n assert v[0] == 1; // Original was not modified\n ~~~~\n \n+### Unary move expressions\n+\n+~~~~~~~~{.ebnf .gram}\n+move_expr : \"move\" expr ;\n+~~~~~~~~\n+\n+A _unary move expression_ is similar to a [unary copy](#unary-copy-expressions) expression,\n+except that it can only be applied to an [lvalue](#lvalues-rvalues-and-temporaries),\n+and it performs a _move_ on its operand, rather than a copy.\n+That is, the memory location denoted by its operand is de-initialized after evaluation,\n+and the resulting value is a shallow copy of the operand,\n+even if the operand is an [owning type](#type-kinds).\n+\n+\n ### Call expressions\n \n ~~~~~~~~ {.abnf .gram}\n@@ -1942,19 +1923,52 @@ An example of a call expression:\n let x: int = add(1, 2);\n ~~~~\n \n-### Shared function expressions\n+### Lambda expressions\n \n-*TODO*.\n+~~~~~~~~ {.abnf .gram}\n+ident_list : [ ident [ ',' ident ]* ] ? ;\n+lambda_expr : '|' ident_list '| expr ;\n+~~~~~~~~\n \n-### Unique function expressions\n+A _lambda expression_ (a.k.a. \"anonymous function expression\") defines a function and denotes it as a value,\n+in a single expression.\n+Lambda expressions are written by prepending a list of identifiers, surrounded by pipe symbols (`|`),\n+to an expression.\n \n-*TODO*.\n+A lambda expression denotes a function mapping parameters to the expression to the right of the `ident_list`.\n+The identifiers in the `ident_list` are the parameters to the function, with types inferred from context.\n+\n+Lambda expressions are most useful when passing functions as arguments to other functions,\n+as an abbreviation for defining and capturing a separate fucntion.\n+\n+Significantly, lambda expressions _capture their environment_,\n+which regular [function definitions](#functions) do not.\n+\n+The exact type of capture depends on the [function type](#function-types) inferred for the lambda expression;\n+in the simplest and least-expensive form, the environment is captured by reference,\n+effectively borrowing pointers to all outer variables referenced inside the function.\n+Other forms of capture include making copies of captured variables,\n+and moving values from the environment into the lambda expression's captured environment.\n+\n+An example of a lambda expression:\n+\n+~~~~\n+fn ten_times(f: fn(int)) {\n+    let mut i = 0;\n+    while i < 10 {\n+        f(i);\n+        i += 1;\n+    }\n+}\n+\n+ten_times(|j| io::println(fmt!(\"hello, %d\", j)));\n+\n+~~~~\n \n ### While loops\n \n ~~~~~~~~{.ebnf .gram}\n-while_expr : \"while\" expr '{' block '}'\n-           | \"do\" '{' block '}' \"while\" expr ;\n+while_expr : \"while\" expr '{' block '}' ;\n ~~~~~~~~\n \n A `while` loop begins by evaluating the boolean loop conditional expression.\n@@ -1968,7 +1982,7 @@ An example:\n let mut i = 0;\n \n while i < 10 {\n-    io::println(~\"hello\\n\");\n+    io::println(\"hello\\n\");\n     i = i + 1;\n }\n ~~~~\n@@ -2005,16 +2019,64 @@ the loop.\n A `loop` expression is only permitted in the body of a loop.\n \n \n+### Do expressions\n+\n+~~~~~~~~{.ebnf .gram}\n+do_expr : \"do\" expr [ '|' ident_list '|' ] ? '{' block '}' ;\n+~~~~~~~~\n+\n+A _do expression_ provides a more-familiar block-syntax for a [lambda expression](#lambda-expressions),\n+including a special translation of [return expressions](#return-expressions) inside the supplied block.\n+\n+The optional `ident_list` and `block` provided in a `do` expression are parsed as though they constitute a lambda expression;\n+if the `ident_list` is missing, an empty `ident_list` is implied.\n+\n+The lambda expression is then provided as a _trailing argument_\n+to the outermost [call](#call-expressions) or [method call](#method-call-expressions) expression\n+in the `expr` following `do`.\n+If the `expr` is a [path expression](#path-expressions), it is parsed as though it is a call expression.\n+If the `expr` is a [field expression](#field-expressions), it is parsed as though it is a method call expression.\n+\n+In this example, both calls to `f` are equivalent:\n+\n+~~~~\n+# fn f(f: fn(int)) { }\n+# fn g(i: int) { }\n+\n+f(|j| g(j));\n+\n+do f |j| {\n+    g(j);\n+}\n+~~~~\n+\n+\n ### For expressions\n \n ~~~~~~~~{.ebnf .gram}\n-for_expr : \"for\" pat \"in\" expr '{' block '}' ;\n+for_expr : \"for\" expr [ '|' ident_list '|' ] ? '{' block '}' ;\n ~~~~~~~~\n \n-A _for loop_ is controlled by a vector or string. The for loop bounds-checks\n-the underlying sequence *once* when initiating the loop, then repeatedly\n-executes the loop body with the loop variable referencing the successive\n-elements of the underlying sequence, one iteration per sequence element.\n+A _for expression_ is similar to a [`do` expression](#do-expressions),\n+in that it provides a special block-form of lambda expression,\n+suited to passing the `block` function to a higher-order function implementing a loop.\n+\n+Like a `do` expression, a `return` expression inside a `for` expresison is rewritten,\n+to access a local flag that causes an early return in the caller.\n+\n+Additionally, any occurrence of a [return expression](#return-expressions)\n+inside the `block` of a `for` expression is rewritten\n+as a reference to an (anonymous) flag set in the caller's environment,\n+which is checked on return from the `expr` and, if set,\n+causes a corresponding return from the caller.\n+In this way, the meaning of `return` statements in language built-in control blocks is preserved,\n+if they are rewritten using lambda functions and `do` expressions as abstractions.\n+\n+Like `return` expressions, any [`break`](#break-expressions) and [`loop`](#loop-expressions) expressions\n+are rewritten inside `for` expressions, with a combination of local flag variables,\n+and early boolean-valued returns from the `block` function,\n+such that the meaning of `break` and `loop` is preserved in a primitive loop\n+when rewritten as a `for` loop controlled by a higher order function.\n \n An example a for loop:\n \n@@ -2023,7 +2085,7 @@ An example a for loop:\n # fn bar(f: foo) { }\n # let a = 0, b = 0, c = 0;\n \n-let v: ~[foo] = ~[a, b, c];\n+let v: &[foo] = &[a, b, c];\n \n for v.each |e| {\n     bar(*e);\n@@ -2058,15 +2120,15 @@ then any `else` block is executed.\n ~~~~~~~~{.ebnf .gram}\n match_expr : \"match\" expr '{' match_arm [ '|' match_arm ] * '}' ;\n \n-match_arm : match_pat '=>' expr_or_blockish ;\n+match_arm : match_pat '=>' [ expr \",\" | '{' block '}' ] ;\n \n-match_pat : pat [ \"to\" pat ] ? [ \"if\" expr ] ;\n+match_pat : pat [ \"..\" pat ] ? [ \"if\" expr ] ;\n ~~~~~~~~\n \n \n A `match` expression branches on a *pattern*. The exact form of matching that\n occurs depends on the pattern. Patterns consist of some combination of\n-literals, destructured enum constructors, records and tuples, variable binding\n+literals, destructured enum constructors, structures, records and tuples, variable binding\n specifications, wildcards (`*`), and placeholders (`_`). A `match` expression has a *head\n expression*, which is the value to compare to the patterns. The type of the\n patterns must equal the type of the head expression.\n@@ -2076,19 +2138,19 @@ In a pattern whose head expression has an `enum` type, a placeholder (`_`) stand\n variant. For example:\n \n ~~~~\n-enum list<X> { nil, cons(X, @list<X>) }\n+enum List<X> { Nil, Cons(X, @List<X>) }\n \n-let x: list<int> = cons(10, @cons(11, @nil));\n+let x: List<int> = Cons(10, @Cons(11, @Nil));\n \n match x {\n-    cons(_, @nil) => fail ~\"singleton list\",\n-    cons(*)       => return,\n-    nil           => fail ~\"empty list\"\n+    Cons(_, @Nil) => fail ~\"singleton list\",\n+    Cons(*)       => return,\n+    Nil           => fail ~\"empty list\"\n }\n ~~~~\n \n-The first pattern matches lists constructed by applying `cons` to any head value, and a\n-tail value of `@nil`. The second pattern matches `any` list constructed with `cons`,\n+The first pattern matches lists constructed by applying `Cons` to any head value, and a\n+tail value of `@Nil`. The second pattern matches _any_ list constructed with `Cons`,\n ignoring the values of its arguments. The difference between `_` and `*` is that the pattern `C(_)` is only type-correct if\n `C` has exactly one argument, while the pattern `C(*)` is type-correct for any enum variant `C`, regardless of how many arguments `C` has.\n \n@@ -2105,18 +2167,18 @@ An example of an `match` expression:\n # fn process_pair(a: int, b: int) { }\n # fn process_ten() { }\n \n-enum list<X> { nil, cons(X, @list<X>) }\n+enum List<X> { Nil, Cons(X, @List<X>) }\n \n-let x: list<int> = cons(10, @cons(11, @nil));\n+let x: List<int> = Cons(10, @Cons(11, @Nil));\n \n match x {\n-    cons(a, @cons(b, _)) => {\n+    Cons(a, @Cons(b, _)) => {\n         process_pair(a,b);\n     }\n-    cons(10, _) => {\n+    Cons(10, _) => {\n         process_ten();\n     }\n-    nil => {\n+    Nil => {\n         return;\n     }\n     _ => {\n@@ -2125,7 +2187,7 @@ match x {\n }\n ~~~~\n \n-Records can also be pattern-matched and their fields bound to variables.\n+Records and structures can also be pattern-matched and their fields bound to variables.\n When matching fields of a record, the fields being matched are specified\n first, then a placeholder (`_`) represents the remaining fields.\n \n@@ -2167,9 +2229,9 @@ range of values may be specified with `..`. For example:\n # let x = 2;\n \n let message = match x {\n-  0 | 1  => ~\"not many\",\n-  2 .. 9 => ~\"a few\",\n-  _      => ~\"lots\"\n+  0 | 1  => \"not many\",\n+  2 .. 9 => \"a few\",\n+  _      => \"lots\"\n };\n ~~~~\n \n@@ -2199,57 +2261,9 @@ fail_expr : \"fail\" expr ? ;\n \n Evaluating a `fail` expression causes a task to enter the *failing* state. In\n the *failing* state, a task unwinds its stack, destroying all frames and\n-freeing all resources until it reaches its entry frame, at which point it\n+running all destructors until it reaches its entry frame, at which point it\n halts execution in the *dead* state.\n \n-### Note expressions\n-\n-~~~~~~~~{.ebnf .gram}\n-note_expr : \"note\" expr ;\n-~~~~~~~~\n-\n-**Note: Note expressions are not yet supported by the compiler.**\n-\n-A `note` expression has no effect during normal execution. The purpose of a\n-`note` expression is to provide additional diagnostic information to the\n-logging subsystem during task failure. See [log\n-expressions](#log-expressions). Using `note` expressions, normal diagnostic\n-logging can be kept relatively sparse, while still providing verbose\n-diagnostic \"back-traces\" when a task fails.\n-\n-When a task is failing, control frames *unwind* from the innermost frame to\n-the outermost, and from the innermost lexical block within an unwinding frame\n-to the outermost. When unwinding a lexical block, the runtime processes all\n-the `note` expressions in the block sequentially, from the first expression of\n-the block to the last.  During processing, a `note` expression has equivalent\n-meaning to a `log` expression: it causes the runtime to append the argument of\n-the `note` to the internal logging diagnostic buffer.\n-\n-An example of a `note` expression:\n-\n-~~~~{.xfail-test}\n-fn read_file_lines(path: ~str) -> ~[~str] {\n-    note path;\n-    let r: [~str];\n-    let f: file = open_read(path);\n-    lines(f) |s| {\n-        r += ~[s];\n-    }\n-    return r;\n-}\n-~~~~\n-\n-In this example, if the task fails while attempting to open or read a file,\n-the runtime will log the path name that was being read. If the function\n-completes normally, the runtime will not log the path.\n-\n-A value that is marked by a `note` expression is *not* copied aside\n-when control passes through the `note`. In other words, if a `note`\n-expression notes a particular `lval`, and code after the `note`\n-mutates that slot, and then a subsequent failure occurs, the *mutated*\n-value will be logged during unwinding, *not* the original value that was\n-denoted by the `lval` at the moment control passed through the `note`\n-expression.\n \n ### Return expressions\n \n@@ -2258,8 +2272,7 @@ return_expr : \"return\" expr ? ;\n ~~~~~~~~\n \n Return expressions are denoted with the keyword `return`. Evaluating a `return`\n-expression^[A `return` expression is analogous to a `return` expression\n-in the C family.] moves its argument into the output slot of the current\n+expression moves its argument into the output slot of the current\n function, destroys the current function activation frame, and transfers\n control to the caller frame.\n \n@@ -2301,7 +2314,7 @@ The following examples all produce the same output, logged at the `error`\n logging level:\n \n ~~~~\n-# let filename = ~\"bulbasaur\";\n+# let filename = \"bulbasaur\";\n \n // Full version, logging a value.\n log(core::error, ~\"file not found: \" + filename);\n@@ -2333,35 +2346,28 @@ It is therefore recommended to use the macro forms of logging (`error!`, `debug!\n assert_expr : \"assert\" expr ;\n ~~~~~~~~\n \n-An `assert` expression is similar to a `check` expression, except\n-the condition may be any boolean-typed expression, and the compiler makes no\n-use of the knowledge that the condition holds if the program continues to\n-execute after the `assert`.\n+> **Note:** In future versions of Rust, `assert` will be changed from a full expression to a macro.\n \n+An `assert` expression causes the program to fail if its `expr` argument evaluates to `false`.\n+The failure carries string representation of the false expression.\n \n # Type system\n \n ## Types\n \n-Every slot and value in a Rust program has a type. The _type_ of a *value*\n-defines the interpretation of the memory holding it. The type of a *slot* may\n-also include [constraints](#constraints).\n+Every slot, item and value in a Rust program has a type. The _type_ of a *value*\n+defines the interpretation of the memory holding it.\n \n Built-in types and type-constructors are tightly integrated into the language,\n in nontrivial ways that are not possible to emulate in user-defined\n-types. User-defined types have limited capabilities. In addition, every\n-built-in type or type-constructor name is reserved as a *keyword* in Rust;\n-they cannot be used as user-defined identifiers in any context.\n+types. User-defined types have limited capabilities.\n \n ### Primitive types\n \n The primitive types are the following:\n \n-* The \"nil\" type `()`, having the single \"nil\" value `()`.^[The \"nil\" value\n-  `()` is *not* a sentinel \"null pointer\" value for reference slots; the \"nil\"\n-  type is the implicit return type from functions otherwise lacking a return\n-  type, and can be used in other contexts (such as message-sending or\n-  type-parametric code) as a zero-size type.]\n+* The \"unit\" type `()`, having the single \"unit\" value `()` (occasionally called \"nil\").\n+  ^[The \"unit\" value `()` is *not* a sentinel \"null pointer\" value for reference slots; the \"unit\" type is the implicit return type from functions otherwise lacking a return type, and can be used in other contexts (such as message-sending or type-parametric code) as a zero-size type.]\n * The boolean type `bool` with values `true` and `false`.\n * The machine types.\n * The machine-dependent integer and floating-point types.\n@@ -2372,12 +2378,12 @@ The machine types are the following:\n \n \n * The unsigned word types `u8`, `u16`, `u32` and `u64`, with values drawn from\n-  the integer intervals $[0, 2^8 - 1]$, $[0, 2^16 - 1]$, $[0, 2^32 - 1]$ and\n-  $[0, 2^64 - 1]$ respectively.\n+  the integer intervals $[0, 2^8 - 1]$, $[0, 2^{16} - 1]$, $[0, 2^{32} - 1]$ and\n+  $[0, 2^{64} - 1]$ respectively.\n \n * The signed two's complement word types `i8`, `i16`, `i32` and `i64`, with\n   values drawn from the integer intervals $[-(2^7), 2^7 - 1]$,\n-  $[-(2^15), 2^15 - 1]$, $[-(2^31), 2^31 - 1]$, $[-(2^63), 2^63 - 1]$\n+  $[-(2^{15}), 2^{15} - 1]$, $[-(2^{31}), 2^{31} - 1]$, $[-(2^{63}), 2^{63} - 1]$\n   respectively.\n \n * The IEEE 754-2008 `binary32` and `binary64` floating-point types: `f32` and\n@@ -2411,31 +2417,18 @@ type `float` may not be equal to the largest *supported* floating-point type.\n \n ### Textual types\n \n-The types `char` and `~str` hold textual data.\n+The types `char` and `str` hold textual data.\n \n A value of type `char` is a Unicode character, represented as a 32-bit\n unsigned word holding a UCS-4 codepoint.\n \n-A value of type `~str` is a Unicode string, represented as a vector of 8-bit\n+A value of type `str` is a Unicode string, represented as a vector of 8-bit\n unsigned bytes holding a sequence of UTF-8 codepoints.\n+Since `str` is of indefinite size, it is not a _first class_ type,\n+but can only be instantiated through a pointer type,\n+such as `&str`, `@str` or `~str`.\n \n \n-### Record types\n-\n-The record type-constructor forms a new heterogeneous product of values.^[The\n-record type-constructor is analogous to the `struct` type-constructor in the\n-Algol/C family, the *record* types of the ML family, or the *structure* types\n-of the Lisp family.] Fields of a record type are accessed by name and are\n-arranged in memory in the order specified by the record type.\n-\n-An example of a record type and its use:\n-\n-~~~~\n-type point = {x: int, y: int};\n-let p: point = {x: 10, y: 11};\n-let px: int = p.x;\n-~~~~\n-\n ### Tuple types\n \n The tuple type-constructor forms a new heterogeneous product of values similar\n@@ -2454,56 +2447,118 @@ order specified by the tuple type.\n An example of a tuple type and its use:\n \n ~~~~\n-type pair = (int,~str);\n-let p: pair = (10,~\"hello\");\n+type Pair = (int,&str);\n+let p: Pair = (10,\"hello\");\n let (a, b) = p;\n-assert b != ~\"world\";\n+assert b != \"world\";\n ~~~~\n \n+\n ### Vector types\n \n-The vector type-constructor represents a homogeneous array of values of a\n-given type. A vector has a fixed size. The kind of a vector type depends on\n-the kind of its member type, as with other simple structural types.\n+The vector type-constructor represents a homogeneous array of values of a given type.\n+A vector has a fixed size.\n+A vector type can be accompanied by _definite_ size, written with a trailing asterisk and integer literal, such as `[int * 10]`.\n+Such a definite-sized vector can be treated as a first class type since its size is known statically.\n+A vector without such a size is said to be of _indefinite_ size,\n+and is therefore not a _first class_ type,\n+can only be instantiated through a pointer type,\n+such as `&[T]`, `@[T]` or `~[T]`.\n+The kind of a vector type depends on the kind of its member type, as with other simple structural types.\n \n An example of a vector type and its use:\n \n ~~~~\n-let v: ~[int] = ~[7, 5, 3];\n+let v: &[int] = &[7, 5, 3];\n let i: int = v[2];\n assert (i == 3);\n ~~~~\n \n-Vectors always *allocate* a storage region sufficient to store the first power\n-of two worth of elements greater than or equal to the size of the vector. This\n-behaviour supports idiomatic in-place \"growth\" of a mutable slot holding a\n-vector:\n+All accessible elements of a vector are always initialized, and access to a vector is always bounds-checked.\n+\n+\n+### Structure types\n+\n+A `struct` *type* is a heterogeneous product of other types, called the *fields* of the type.\n+^[`struct` types are analogous `struct` types in C,\n+the *record* types of the ML family,\n+or the *structure* types of the Lisp family.]\n+\n+New instances of a `struct` can be constructed with a [struct expression](#struct-expressions).\n+\n+The memory order of fields in a `struct` is given by the item defining it.\n+Fields may be given in any order in a corresponding struct *expression*;\n+the resulting `struct` value will always be laid out in memory in the order specified by the corresponding *item*.\n+\n+The fields of a `struct` may be qualified by [visibility modifiers](#visibility-modifiers),\n+to restrict access to implementation-private data in a structure.\n \n \n+### Enumerated types\n+\n+An *enumerated type* is a nominal, heterogeneous disjoint union type,\n+denoted by the name of an [`enum` item](#enumerations).\n+^[The `enum` type is analogous to a `data` constructor declaration in ML,\n+or a *pick ADT* in Limbo.]\n+\n+An [`enum` item](#enumerations) declares both the type and a number of *variant constructors*,\n+each of which is independently named and takes an optional tuple of arguments.\n+\n+New instances of an `enum` can be constructed by calling one of the variant constructors,\n+in a [call expression](#call-expressions).\n+\n+Any `enum` value consumes as much memory as the largest variant constructor for its corresponding `enum` type.\n+\n+Enum types cannot be denoted *structurally* as types,\n+but must be denoted by named reference to an [`enum` item](#enumerations).\n+\n+\n+### Recursive types\n+\n+Nominal types -- [enumerations](#enumerated-types) and [structures](#structure-types) -- may be recursive.\n+That is, each `enum` constructor or `struct` field may refer, directly or indirectly, to the enclosing `enum` or `struct` type itself.\n+Such recursion has restrictions:\n+\n+* Recursive types must include a nominal type in the recursion\n+  (not mere [type definitions](#type-definitions),\n+   or other structural types such as [vectors](#vector-types) or [tuples](#tuple-types)).\n+* A recursive `enum` item must have at least one non-recursive constructor\n+  (in order to give the recursion a basis case).\n+* The size of a recursive type must be finite;\n+  in other words the recursive fields of the type must be [pointer types](#pointer-types).\n+* Recursive type definitions can cross module boundaries, but not module *visibility* boundaries,\n+  or crate boundaries (in order to simplify the module system and type checker).\n+\n+An example of a *recursive* type and its use:\n+\n ~~~~\n-let mut v: ~[int] = ~[1, 2, 3];\n-v += ~[4, 5, 6];\n+enum List<T> {\n+  Nil,\n+  Cons(T, @List<T>)\n+}\n+\n+let a: List<int> = Cons(7, @Cons(13, @Nil));\n ~~~~\n \n-Normal vector concatenation causes the allocation of a fresh vector to hold\n-the result; in this case, however, the slot holding the vector recycles the\n-underlying storage in-place (since the reference-count of the underlying\n-storage is equal to 1).\n \n-All accessible elements of a vector are always initialized, and access to a\n-vector is always bounds-checked.\n+### Record types\n \n+> **Note:** Records are not nominal types, thus do not directly support recursion, visibility control,\n+> out-of-order field initialization, or coherent trait implementation.\n+> Records are therefore deprecared and will be removed in future versions of Rust.\n+> [Structure types](#structure-types) should be used instead.\n \n-### Enumerated types\n+The record type-constructor forms a new heterogeneous product of values.\n+Fields of a record type are accessed by name and are arranged in memory in the order specified by the record type.\n+\n+An example of a record type and its use:\n \n-An *enumerated type* is a nominal, heterogeneous disjoint union type.^[The\n-`enum` type is analogous to a `data` constructor declaration in ML or a *pick\n-ADT* in Limbo.] An [`enum` *item*](#enumerations) consists of a number of\n-*constructors*, each of which is independently named and takes an optional\n-tuple of arguments.\n+~~~~\n+type Point = {x: int, y: int};\n+let p: Point = {x: 10, y: 11};\n+let px: int = p.x;\n+~~~~\n \n-Enumerated types cannot be denoted *structurally* as types, but must be\n-denoted by named reference to an [*enumeration* item](#enumerations).\n \n ### Pointer types\n \n@@ -2553,11 +2608,12 @@ Raw pointers (`*`)\n     they exist to support interoperability with foreign code,\n     and writing performance-critical or low-level functions.\n \n+\n ### Function types\n \n The function type-constructor `fn` forms new function types. A function type\n-consists of a sequence of input slots, an optional set of\n-[input constraints](#constraints) and an output slot.\n+consists of a set of function-type modifiers (`pure`, `unsafe`, `extern`, etc.),\n+a sequence of input slots and an output slot.\n \n An example of a `fn` type:\n \n@@ -2568,8 +2624,8 @@ fn add(x: int, y: int) -> int {\n \n let mut x = add(5,7);\n \n-type binop = fn(int,int) -> int;\n-let bo: binop = add;\n+type Binop = fn(int,int) -> int;\n+let bo: Binop = add;\n x = bo(5,7);\n ~~~~~~~~\n \n@@ -2579,36 +2635,32 @@ Every trait item (see [traits](#traits)) defines a type with the same name\n as the trait. For a trait `T`, cast expressions introduce values of type `T`:\n \n ~~~~~~~~\n-trait printable {\n+trait Printable {\n   fn to_str() -> ~str;\n }\n \n-impl ~str: printable {\n-  fn to_str() -> ~str { self }\n+impl int: Printable {\n+  fn to_str() -> ~str { int::to_str(self, 10) }\n }\n \n-fn print(a: printable) {\n+fn print(a: @Printable) {\n    io::println(a.to_str());\n }\n \n fn main() {\n-   print(~\"meow\" as printable);\n+   print(@10 as @Printable);\n }\n ~~~~~~~~\n \n-In this example, the trait `printable` occurs as a type in both the type signature of\n+In this example, the trait `Printable` occurs as a type in both the type signature of\n `print`, and the cast expression in `main`.\n \n-### Struct types\n-\n-Every struct item defines a type.\n-\n ### Type parameters\n \n Within the body of an item that has type parameter declarations, the names of its type parameters are types:\n \n ~~~~~~~\n-fn map<A: Copy, B: Copy>(f: fn(A) -> B, xs: ~[A]) -> ~[B] {\n+fn map<A: Copy, B: Copy>(f: fn(A) -> B, xs: &[A]) -> ~[B] {\n    if xs.len() == 0 { return ~[]; }\n    let first: B = f(xs[0]);\n    let rest: ~[B] = map(f, xs.slice(1, xs.len()));\n@@ -2619,61 +2671,66 @@ fn map<A: Copy, B: Copy>(f: fn(A) -> B, xs: ~[A]) -> ~[B] {\n Here, `first` has type `B`, referring to `map`'s `B` type parameter; and `rest` has\n type `~[B]`, a vector type with element type `B`.\n \n-### Self type\n+### Self types\n \n The special type `self` has a meaning within methods inside an\n impl item. It refers to the type of the implicit `self` argument. For\n example, in:\n \n ~~~~~~\n-trait printable {\n+trait Printable {\n   fn to_str() -> ~str;\n }\n \n-impl ~str: printable {\n+impl ~str: Printable {\n   fn to_str() -> ~str { self }\n }\n ~~~~~~\n \n-`self` refers to the value of type `str` that is the receiver for a\n+`self` refers to the value of type `~str` that is the receiver for a\n call to the method `to_str`.\n \n ## Type kinds\n \n-Types in Rust are categorized into three kinds, based on whether they\n-allow copying of their values, and sending to different tasks. The\n-kinds are:\n+Types in Rust are categorized into kinds, based on various properties of the components of the type.\n+The kinds are:\n \n-Sendable\n-  : Values with a sendable type can be safely sent to another task.\n-    This kind includes scalars, unique pointers, unique closures, and\n+`Const`\n+  : Types of this kind are deeply immutable;\n+    they contain no mutable memory locations directly or indirectly via pointers.\n+`Send`\n+  : Types of this kind can be safely sent between tasks.\n+    This kind includes scalars, owning pointers, owned closures, and\n     structural types containing only other sendable types.\n-Copyable\n+`Owned`\n+  : Types of this kind do not contain any borrowed pointers;\n+    this can be a useful guarantee for code that breaks borrowing assumptions using [`unsafe` operations](#unsafe-functions).    \n+`Copy`\n   : This kind includes all types that can be copied. All types with\n-    sendable kind are copyable, as are shared boxes, shared closures,\n+    sendable kind are copyable, as are managed boxes, managed closures,\n     trait types, and structural types built out of these.\n-Noncopyable\n-  : [Resource](#resources) types, and every type that includes a\n-    resource without storing it in a shared box, may not be copied.\n-    Types of sendable or copyable type can always be used in places\n-    where a noncopyable type is expected, so in effect this kind\n-    includes all types.\n-\n-These form a hierarchy. The noncopyable kind is the widest, including\n-all types in the language. The copyable kind is a subset of that, and\n-the sendable kind is a subset of the copyable kind.\n-\n-Any operation that causes a value to be copied requires the type of\n-that value to be of copyable kind. Type parameter types are assumed to\n-be noncopyable, unless one of the special bounds `send` or `copy` is\n-declared for it. For example, this is not a valid program:\n+_Default_\n+  : Types with destructors, closure environments,\n+    and various other _non-first-class_ types,\n+    are not copyable at all.\n+    Such types can usually only be accessed through pointers,\n+    or in some cases, moved between mutable locations.\n+\n+Kinds can be supplied as _bounds_ on type parameters, like traits,\n+in which case the parameter is constrained to types satisfying that kind.\n+\n+By default, type parameters do not carry any assumed kind-bounds at all.\n+\n+Any operation that causes a value to be copied requires the type of that value to be of copyable kind,\n+so the `Copy` bound is frequently required on function type parameters.\n+For example, this is not a valid program:\n \n ~~~~{.xfail-test}\n fn box<T>(x: T) -> @T { @x }\n ~~~~\n \n-Putting `x` into a shared box involves copying, and the `T` parameter\n-is assumed to be noncopyable. To change that, a bound is declared:\n+Putting `x` into a managed box involves copying, and the `T` parameter has the default (non-copyable) kind.\n+To change that, a bound is declared:\n \n ~~~~\n fn box<T: Copy>(x: T) -> @T { @x }\n@@ -2722,7 +2779,7 @@ entry to each function as the task executes. A stack allocation is reclaimed\n when control leaves the frame containing it.\n \n The _heap_ is a general term that describes two separate sets of boxes:\n-shared boxes -- which may be subject to garbage collection -- and unique\n+managed boxes -- which may be subject to garbage collection -- and owned\n boxes.  The lifetime of an allocation in the heap depends on the lifetime of\n the box values pointing to it. Since box values may themselves be passed in\n and out of frames, or stored in the heap, heap allocations may outlive the\n@@ -2741,13 +2798,13 @@ it is only instantiated for (transitively) sendable kinds of data constructor an\n never including managed or borrowed pointers.\n \n When a stack frame is exited, its local allocations are all released, and its\n-references to boxes (both shared and owned) are dropped.\n+references to boxes (both managed and owned) are dropped.\n \n-A shared box may (in the case of a recursive, mutable shared type) be cyclic;\n-in this case the release of memory inside the shared structure may be deferred\n+A managed box may (in the case of a recursive, mutable managed type) be cyclic;\n+in this case the release of memory inside the managed structure may be deferred\n until task-local garbage collection can reclaim it. Code can ensure no such\n-delayed deallocation occurs by restricting itself to unique boxes and similar\n-unshared kinds of data.\n+delayed deallocation occurs by restricting itself to owned boxes and similar\n+unmanaged kinds of data.\n \n When a task finishes, its stack is necessarily empty and it therefore has no\n references to any boxes; the remainder of its heap is immediately freed.\n@@ -2757,16 +2814,12 @@ references to any boxes; the remainder of its heap is immediately freed.\n \n A task's stack contains slots.\n \n-A _slot_ is a component of a stack frame. A slot is either a *local variable*\n-or a *reference*.\n+A _slot_ is a component of a stack frame, either a function parameter,\n+a [temporary](#lvalues-rvalues-and-temporaries), or a local variable.\n \n A _local variable_ (or *stack-local* allocation) holds a value directly,\n allocated within the stack's memory. The value is a part of the stack frame.\n \n-A _reference_ references a value outside the frame. It may refer to a\n-value allocated in another frame *or* a boxed value in the heap. The\n-reference-formation rules ensure that the referent will outlive the reference.\n-\n Local variables are immutable unless declared with `let mut`.  The\n `mut` keyword applies to all local variables declared within that\n declaration (so `let mut x, y` declares two mutable variables, `x` and\n@@ -2778,40 +2831,26 @@ state. Subsequent statements within a function may or may not initialize the\n local variables. Local variables can be used only after they have been\n initialized; this is enforced by the compiler.\n \n-References are created for function arguments. If the compiler can not prove\n-that the referred-to value will outlive the reference, it will try to set\n-aside a copy of that value to refer to. If this is not semantically safe (for\n-example, if the referred-to value contains mutable fields), it will reject the\n-program. If the compiler deems copying the value expensive, it will warn.\n-\n-A function with an argument of type `&mut T`, for some type `T`, can write to\n-the slot that its argument refers to. An example of such a function is:\n-\n-~~~~~~~~\n-fn incr(i: &mut int) {\n-    *i = *i + 1;\n-}\n-~~~~~~~~\n \n ### Memory boxes\n \n A _box_ is a reference to a heap allocation holding another value. There\n-are two kinds of boxes: *shared boxes* and *unique boxes*.\n+are two kinds of boxes: *managed boxes* and *owned boxes*.\n \n-A _shared box_ type or value is constructed by the prefix *at* sigil `@`.\n+A _managed box_ type or value is constructed by the prefix *at* sigil `@`.\n \n-A _unique box_ type or value is constructed by the prefix *tilde* sigil `~`.\n+An _owned box_ type or value is constructed by the prefix *tilde* sigil `~`.\n \n-Multiple shared box values can point to the same heap allocation; copying a\n-shared box value makes a shallow copy of the pointer (optionally incrementing\n-a reference count, if the shared box is implemented through\n+Multiple managed box values can point to the same heap allocation; copying a\n+managed box value makes a shallow copy of the pointer (optionally incrementing\n+a reference count, if the managed box is implemented through\n reference-counting).\n \n-Unique box values exist in 1:1 correspondence with their heap allocation;\n-copying a unique box value makes a deep copy of the heap allocation and\n+Owned box values exist in 1:1 correspondence with their heap allocation;\n+copying an owned box value makes a deep copy of the heap allocation and\n produces a pointer to the new allocation.\n \n-An example of constructing one shared box type and value, and one unique box\n+An example of constructing one managed box type and value, and one owned box\n type and value:\n \n ~~~~~~~~\n@@ -2884,6 +2923,7 @@ and data races on memory are prohibited by the type system.\n \n Inter-task communication and co-ordination facilities are provided in the standard library.\n These include:\n+\n   - synchronous and asynchronous communication channels with various communication topologies\n   - read-only and read-write shared variables with various safe mutual exclusion patterns\n   - simple locks and semaphores\n@@ -2954,10 +2994,10 @@ non-executing state (blocked, dead) similarly deschedules the task.\n A call to `core::task::spawn`, passing a 0-argument function as its single\n argument, causes the runtime to construct a new task executing the passed\n function. The passed function is referred to as the _entry function_ for\n-the spawned task, and any captured environment is carries is moved from the\n+the spawned task, and any captured environment it carries is moved from the\n spawning task to the spawned task before the spawned task begins execution.\n \n-The result of a `spawn` call is a `core::task::task` value.\n+The result of a `spawn` call is a `core::task::Task` value.\n \n An example of a `spawn` call:\n \n@@ -3006,16 +3046,20 @@ An example of a *receive*:\n let s = comm::recv(po);\n ~~~~~~~~\n \n+> **Note:** this communication system will be replaced by a higher-performance system called \"pipes\",\n+> in future versions of Rust.\n+\n \n # Runtime services, linkage and debugging\n \n \n-The Rust _runtime_ is a relatively compact collection of C and Rust code\n+The Rust _runtime_ is a relatively compact collection of C++ and Rust code\n that provides fundamental services and datatypes to all Rust tasks at\n run-time. It is smaller and simpler than many modern language runtimes. It is\n tightly integrated into the language's execution model of memory, tasks,\n communication and logging.\n \n+> **Note:** The runtime library will merge with the `core` library in future versions of Rust.\n \n ### Memory allocation\n \n@@ -3177,7 +3221,8 @@ Additional specific influences can be seen from the following languages:\n * The stack-growth implementation of Go.\n * The structural algebraic types and compilation manager of SML.\n * The attribute and assembly systems of C#.\n-* The deterministic destructor system of C++.\n+* The references and deterministic destructor system of C++.\n+* The memory region systems of the ML Kit and Cyclone.\n * The typeclass system of Haskell.\n * The lexical identifier rule of Python.\n * The block syntax of Ruby."}, {"sha": "921418fa1bda7fc1a452d0a43beb7d8e55cae500", "filename": "doc/tutorial-borrowed-ptr.md", "status": "modified", "additions": 235, "deletions": 219, "changes": 454, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/doc%2Ftutorial-borrowed-ptr.md", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/doc%2Ftutorial-borrowed-ptr.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-borrowed-ptr.md?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820", "patch": "@@ -2,40 +2,40 @@\n \n # Introduction\n \n-Borrowed pointers are one of the more flexible and powerful tools\n-available in Rust. A borrowed pointer can be used to point anywhere:\n-into the managed and exchange heaps, into the stack, and even into the\n-interior of another data structure. With regard to flexibility, it is\n-comparable to a C pointer or C++ reference. However, unlike C and C++,\n-the Rust compiler includes special checks that ensure that borrowed\n-pointers are being used safely. Another advantage of borrowed pointers\n-is that they are invisible to the garbage collector, so working with\n-borrowed pointers helps keep things efficient.\n-\n-Despite the fact that they are completely safe, at runtime, a borrowed\n-pointer is \u201cjust a pointer\u201d. They introduce zero overhead. All safety\n-checks are done at compilation time.\n+Borrowed pointers are one of the more flexible and powerful tools available in\n+Rust. A borrowed pointer can point anywhere: into the managed or exchange\n+heap, into the stack, and even into the interior of another data structure. A\n+borrowed pointer is as flexible as a C pointer or C++ reference. However,\n+unlike C and C++ compilers, the Rust compiler includes special static checks\n+that ensure that programs use borrowed pointers safely. Another advantage of\n+borrowed pointers is that they are invisible to the garbage collector, so\n+working with borrowed pointers helps reduce the overhead of automatic memory\n+management.\n+\n+Despite their complete safety, a borrowed pointer's representation at runtime\n+is the same as that of an ordinary pointer in a C program. They introduce zero\n+overhead. The compiler does all safety checks at compile time.\n \n Although borrowed pointers have rather elaborate theoretical\n underpinnings (region pointers), the core concepts will be familiar to\n-anyone who worked with C or C++. Therefore, the best way to explain\n+anyone who has worked with C or C++. Therefore, the best way to explain\n how they are used\u2014and their limitations\u2014is probably just to work\n through several examples.\n \n # By example\n \n-Borrowed pointers are called borrowed because they are only valid for\n-a limit duration. Borrowed pointers never claim any kind of ownership\n-over the data that they point at: instead, they are used for cases\n-where you like to make use of data for a short time.\n+Borrowed pointers are called *borrowed* because they are only valid for\n+a limited duration. Borrowed pointers never claim any kind of ownership\n+over the data that they point to: instead, they are used for cases\n+where you would like to use data for a short time.\n \n As an example, consider a simple struct type `Point`:\n \n ~~~\n struct Point {x: float, y: float}\n ~~~\n \n-We can use this simple definition to allocate points in many ways. For\n+We can use this simple definition to allocate points in many different ways. For\n example, in this code, each of these three local variables contains a\n point, but allocated in a different place:\n \n@@ -46,17 +46,17 @@ let shared_box   : @Point = @Point {x: 5.0, y: 1.0};\n let unique_box   : ~Point = ~Point {x: 7.0, y: 9.0};\n ~~~\n \n-Suppose we wanted to write a procedure that computed the distance\n-between any two points, no matter where they were stored. For example,\n-we might like to compute the distance between `on_the_stack` and\n-`shared_box`, or between `shared_box` and `unique_box`. One option is\n-to define a function that takes two arguments of type point\u2014that is,\n-it takes the points by value. But this will cause the points to be\n-copied when we call the function. For points, this is probably not so\n-bad, but often copies are expensive or, worse, if there are mutable\n-fields, they can change the semantics of your program. So we\u2019d like to\n-define a function that takes the points by pointer. We can use\n-borrowed pointers to do this:\n+Suppose we wanted to write a procedure that computed the distance between any\n+two points, no matter where they were stored. For example, we might like to\n+compute the distance between `on_the_stack` and `shared_box`, or between\n+`shared_box` and `unique_box`. One option is to define a function that takes\n+two arguments of type `Point`\u2014that is, it takes the points by value. But we\n+define it this way, calling the function will cause the points to be\n+copied. For points, this is probably not so bad, but often copies are\n+expensive. Worse, if the data type contains mutable fields, copying can change\n+the semantics of your program in unexpected ways. So we'd like to define a\n+function that takes the points by pointer. We can use borrowed pointers to do\n+this:\n \n ~~~\n # struct Point {x: float, y: float}\n@@ -80,28 +80,28 @@ compute_distance(&on_the_stack, shared_box);\n compute_distance(shared_box, unique_box);\n ~~~\n \n-Here the `&` operator is used to take the address of the variable\n+Here, the `&` operator takes the address of the variable\n `on_the_stack`; this is because `on_the_stack` has the type `Point`\n (that is, a struct value) and we have to take its address to get a\n value. We also call this _borrowing_ the local variable\n-`on_the_stack`, because we are created an alias: that is, another\n-route to the same data.\n-\n-In the case of the boxes `shared_box` and `unique_box`, however, no\n-explicit action is necessary. The compiler will automatically convert\n-a box like `@Point` or `~Point` to a borrowed pointer like\n-`&Point`. This is another form of borrowing; in this case, the\n-contents of the shared/unique box is being lent out.\n-\n-Whenever a value is borrowed, there are some limitations on what you\n-can do with the original. For example, if the contents of a variable\n-have been lent out, you cannot send that variable to another task, nor\n-will you be permitted to take actions that might cause the borrowed\n-value to be freed or to change its type (I\u2019ll get into what kinds of\n-actions those are shortly). This rule should make intuitive sense: you\n-must wait for a borrowed value to be returned (that is, for the\n-borrowed pointer to go out of scope) before you can make full use of\n-it again.\n+`on_the_stack`, because we have created an alias: that is, another\n+name for the same data.\n+\n+In contrast, we can pass the boxes `shared_box` and `unique_box` to\n+`compute_distance` directly. The compiler automatically converts a box like\n+`@Point` or `~Point` to a borrowed pointer like `&Point`. This is another form\n+of borrowing: in this case, the caller lends the contents of the shared or\n+unique box to the callee.\n+\n+Whenever a caller lends data to a callee, there are some limitations on what\n+the caller can do with the original. For example, if the contents of a\n+variable have been lent out, you cannot send that variable to another task. In\n+addition, the compiler will reject any code that might cause the borrowed\n+value to be freed or overwrite its component fields with values of different\n+types (I'll get into what kinds of actions those are shortly). This rule\n+should make intuitive sense: you must wait for a borrower to return the value\n+that you lent it (that is, wait for the borrowed pointer to go out of scope)\n+before you can make full use of it again.\n \n # Other uses for the & operator\n \n@@ -112,18 +112,19 @@ In the previous example, the value `on_the_stack` was defined like so:\n let on_the_stack: Point = Point {x: 3.0, y: 4.0};\n ~~~\n \n-This results in a by-value variable. As a consequence, we had to\n-explicitly take the address of `on_the_stack` to get a borrowed\n-pointer. Sometimes however it is more convenient to move the &\n-operator into the definition of `on_the_stack`:\n+This declaration means that code can only pass `Point` by value to other\n+functions. As a consequence, we had to explicitly take the address of\n+`on_the_stack` to get a borrowed pointer. Sometimes however it is more\n+convenient to move the & operator into the definition of `on_the_stack`:\n \n ~~~\n # struct Point {x: float, y: float}\n let on_the_stack2: &Point = &Point {x: 3.0, y: 4.0};\n ~~~\n \n Applying `&` to an rvalue (non-assignable location) is just a convenient\n-shorthand for creating a temporary and taking its address:\n+shorthand for creating a temporary and taking its address. A more verbose\n+way to write the same code is:\n \n ~~~\n # struct Point {x: float, y: float}\n@@ -134,7 +135,7 @@ let on_the_stack2 : &Point = &tmp;\n # Taking the address of fields\n \n As in C, the `&` operator is not limited to taking the address of\n-local variables. It can also be used to take the address of fields or\n+local variables. It can also take the address of fields or\n individual array elements. For example, consider this type definition\n for `rectangle`:\n \n@@ -144,7 +145,7 @@ struct Size {w: float, h: float} // as before\n struct Rectangle {origin: Point, size: Size}\n ~~~\n \n-Now again I can define rectangles in a few different ways:\n+Now, as before, we can define rectangles in a few different ways:\n \n ~~~\n # struct Point {x: float, y: float}\n@@ -158,8 +159,8 @@ let rect_unique  = ~Rectangle {origin: Point {x: 5f, y: 6f},\n                                size: Size {w: 3f, h: 4f}};\n ~~~\n \n-In each case I can use the `&` operator to extact out individual\n-subcomponents. For example, I could write:\n+In each case, we can extract out individual subcomponents with the `&`\n+operator. For example, I could write:\n \n ~~~\n # struct Point {x: float, y: float} // as before\n@@ -173,29 +174,31 @@ compute_distance(&rect_stack.origin, &rect_managed.origin);\n ~~~\n \n which would borrow the field `origin` from the rectangle on the stack\n-from the managed box and then compute the distance between them.\n+as well as from the managed box, and then compute the distance between them.\n \n # Borrowing managed boxes and rooting\n \n-We\u2019ve seen a few examples so far where heap boxes (both managed and\n-unique) are borrowed. Up till this point, we\u2019ve glossed over issues of\n+We\u2019ve seen a few examples so far of borrowing heap boxes, both managed\n+and unique. Up till this point, we\u2019ve glossed over issues of\n safety. As stated in the introduction, at runtime a borrowed pointer\n-is simply a pointer, nothing more. Therefore, if we wish to avoid the\n-issues that C has with dangling pointers (and we do!), a compile-time\n-safety check is required.\n-\n-The basis for the check is the notion of _lifetimes_. A lifetime is\n-basically a static approximation of the period in which the pointer is\n-valid: it always corresponds to some expression or block within the\n-program. Within that expression, the pointer can be used freely, but\n-if the pointer somehow leaks outside of that expression, the compiler\n-will report an error. We\u2019ll be discussing lifetimes more in the\n-examples to come, and a more thorough introduction is also available.\n-\n-When a borrowed pointer is created, the compiler must ensure that it\n-will remain valid for its entire lifetime. Sometimes this is\n-relatively easy, such as when taking the address of a local variable\n-or a field that is stored on the stack:\n+is simply a pointer, nothing more. Therefore, avoiding C's problems\n+with dangling pointers requires a compile-time safety check.\n+\n+The basis for the check is the notion of _lifetimes_. A lifetime is a\n+static approximation of the span of execution during which the pointer\n+is valid: it always corresponds to some expression or block within the\n+program. Code inside that expression can use the pointer without\n+restrictions. But if the pointer escapes from that expression (for\n+example, if the expression contains an assignment expression that\n+assigns the pointer to a mutable field of a data structure with a\n+broader scope than the pointer itself), the compiler reports an\n+error. We'll be discussing lifetimes more in the examples to come, and\n+a more thorough introduction is also available.\n+\n+When the `&` operator creates a borrowed pointer, the compiler must\n+ensure that the pointer remains valid for its entire\n+lifetime. Sometimes this is relatively easy, such as when taking the\n+address of a local variable or a field that is stored on the stack:\n \n ~~~\n struct X { f: int }\n@@ -206,12 +209,12 @@ fn example1() {\n }                      // -+\n ~~~\n \n-Here, the lifetime of the borrowed pointer is simply L, the remainder\n-of the function body. No extra work is required to ensure that `x.f`\n-will not be freed. This is true even if `x` is mutated.\n+Here, the lifetime of the borrowed pointer `y` is simply L, the\n+remainder of the function body. The compiler need not do any other\n+work to prove that code will not free `x.f`. This is true even if the\n+code mutates `x`.\n \n-The situation gets more complex when borrowing data that resides in\n-heap boxes:\n+The situation gets more complex when borrowing data inside heap boxes:\n \n ~~~\n # struct X { f: int }\n@@ -222,20 +225,25 @@ fn example2() {\n }                      // -+\n ~~~\n \n-In this example, the value `x` is in fact a heap box, and `y` is\n-therefore a pointer into that heap box. Again the lifetime of `y` will\n-be L, the remainder of the function body. But there is a crucial\n-difference: suppose `x` were reassigned during the lifetime L? If\n-we\u2019re not careful, that could mean that the managed box would become\n-unrooted and therefore be subject to garbage collection\n+In this example, the value `x` is a heap box, and `y` is therefore a\n+pointer into that heap box. Again the lifetime of `y` is L, the\n+remainder of the function body. But there is a crucial difference:\n+suppose `x` were to be reassigned during the lifetime L? If the\n+compiler isn't careful, the managed box could become *unrooted*, and\n+would therefore be subject to garbage collection. A heap box that is\n+unrooted is one such that no pointer values in the heap point to\n+it. It would violate memory safety for the box that was originally\n+assigned to `x` to be garbage-collected, since a non-heap\n+pointer---`y`---still points into it.\n \n-> ***Note:***In our current implementation, the garbage collector is\n-> implemented using reference counting and cycle detection.\n+> ***Note:*** Our current implementation implements the garbage collector\n+> using reference counting and cycle detection.\n \n-For this reason, whenever the interior of a managed box stored in a\n-mutable location is borrowed, the compiler will insert a temporary\n-that ensures that the managed box remains live for the entire\n-lifetime. So, the above example would be compiled as:\n+For this reason, whenever an `&` expression borrows the interior of a\n+managed box stored in a mutable location, the compiler inserts a\n+temporary that ensures that the managed box remains live for the\n+entire lifetime. So, the above example would be compiled as if it were\n+written\n \n ~~~\n # struct X { f: int }\n@@ -254,9 +262,9 @@ process is called *rooting*.\n \n The previous example demonstrated *rooting*, the process by which the\n compiler ensures that managed boxes remain live for the duration of a\n-borrow. Unfortunately, rooting does not work if the data being\n-borrowed is a unique box, as it is not possible to have two references\n-to a unique box.\n+borrow. Unfortunately, rooting does not work for borrows of unique\n+boxes, because it is not possible to have two references to a unique\n+box.\n \n For unique boxes, therefore, the compiler will only allow a borrow *if\n the compiler can guarantee that the unique box will not be reassigned\n@@ -279,14 +287,14 @@ fn example3() -> int {\n ~~~\n \n Here, as before, the interior of the variable `x` is being borrowed\n-and `x` is declared as mutable. However, the compiler can clearly see\n-that `x` is not assigned anywhere in the lifetime L of the variable\n+and `x` is declared as mutable. However, the compiler can prove that\n+`x` is not assigned anywhere in the lifetime L of the variable\n `y`. Therefore, it accepts the function, even though `x` is mutable\n and in fact is mutated later in the function.\n \n-It may not be clear why we are so concerned about the variable which\n-was borrowed being mutated. The reason is that unique boxes are freed\n-_as soon as their owning reference is changed or goes out of\n+It may not be clear why we are so concerned about mutating a borrowed\n+variable. The reason is that the runtime system frees any unique box\n+_as soon as its owning reference changes or goes out of\n scope_. Therefore, a program like this is illegal (and would be\n rejected by the compiler):\n \n@@ -331,11 +339,11 @@ Once the reassignment occurs, the memory will look like this:\n Here you can see that the variable `y` still points at the old box,\n which has been freed.\n \n-In fact, the compiler can apply this same kind of reasoning can be\n-applied to any memory which is _(uniquely) owned by the stack\n-frame_. So we could modify the previous example to introduce\n-additional unique pointers and structs, and the compiler will still be\n-able to detect possible mutations:\n+In fact, the compiler can apply the same kind of reasoning to any\n+memory that is _(uniquely) owned by the stack frame_. So we could\n+modify the previous example to introduce additional unique pointers\n+and structs, and the compiler will still be able to detect possible\n+mutations:\n \n ~~~ {.xfail-test}\n fn example3() -> int {\n@@ -352,11 +360,11 @@ fn example3() -> int {\n \n In this case, two errors are reported, one when the variable `x` is\n modified and another when `x.f` is modified. Either modification would\n-cause the pointer `y` to be invalidated.\n+invalidate the pointer `y`.\n \n-Things get tricker when the unique box is not uniquely owned by the\n-stack frame (or when the compiler doesn\u2019t know who the owner\n-is). Consider a program like this:\n+Things get trickier when the unique box is not uniquely owned by the\n+stack frame, or when there is no way for the compiler to determine the\n+box's owner. Consider a program like this:\n \n ~~~\n struct R { g: int }\n@@ -380,18 +388,18 @@ Here the heap looks something like:\n     +------+\n ~~~\n \n-In this case, the owning reference to the value being borrowed is in\n-fact `x.f`. Moreover, `x.f` is both mutable and aliasable. Aliasable\n-means that it is possible that there are other pointers to that same\n-managed box, so even if the compiler were to prevent `x.f` from being\n-mutated, the field might still be changed through some alias of\n-`x`. Therefore, to be safe, the compiler only accepts pure actions\n-during the lifetime of `y`. We\u2019ll have a final example on purity but\n-inn unique fields, as in the following example:\n+In this case, the owning reference to the value being borrowed is\n+`x.f`. Moreover, `x.f` is both mutable and *aliasable*. Aliasable\n+means that there may be other pointers to that same managed box, so\n+even if the compiler were to prove an absence of mutations to `x.f`,\n+code could mutate `x.f` indirectly by changing an alias of\n+`x`. Therefore, to be safe, the compiler only accepts *pure* actions\n+during the lifetime of `y`. We define what \"pure\" means in the section\n+on [purity](#purity).\n \n Besides ensuring purity, the only way to borrow the interior of a\n-unique found in aliasable memory is to ensure that it is stored within\n-unique fields, as in the following example:\n+unique found in aliasable memory is to ensure that the borrowed field\n+itself is also unique, as in the following example:\n \n ~~~\n struct R { g: int }\n@@ -408,7 +416,7 @@ the compiler to know that, even if aliases to `x` exist, the field `f`\n cannot be changed and hence the unique box `g` will remain valid.\n \n If you do have a unique box in a mutable field, and you wish to borrow\n-it, one option is to use the swap operator to bring that unique box\n+it, one option is to use the swap operator to move that unique box\n onto your stack:\n \n ~~~\n@@ -429,22 +437,21 @@ fn example5c(x: @S) -> int {\n \n Of course, this has the side effect of modifying your managed box for\n the duration of the borrow, so it only works when you know that you\n-won\u2019t be accessing that same box for the duration of the loan.  Note\n-also that sometimes it is necessary to introduce additional blocks to\n-constrain the scope of the loan.  In this example, the borrowed\n-pointer `y` would still be in scope when you moved the value `v` back\n-into `x.f`, and hence moving `v` would be considered illegal.  You\n-cannot move values if they are outstanding loans which are still\n-valid.  By introducing the block, the scope of `y` is restricted and so\n-the move is legal.\n+won't be accessing that same box for the duration of the loan. Also,\n+it is sometimes necessary to introduce additional blocks to constrain\n+the scope of the loan.  In this example, the borrowed pointer `y`\n+would still be in scope when you moved the value `v` back into `x.f`,\n+and hence moving `v` would be considered illegal.  You cannot move\n+values if they are the targets of valid outstanding loans. Introducing\n+the block restricts the scope of `y`, making the move legal.\n \n # Borrowing and enums\n \n-The previous example showed that borrowing unique boxes found in\n-aliasable, mutable memory is not permitted, so as to prevent pointers\n-into freed memory. There is one other case where the compiler must be\n-very careful to ensure that pointers remain valid: pointers into the\n-interior of an enum.\n+The previous example showed that the type system forbids any borrowing\n+of unique boxes found in aliasable, mutable memory. This restriction\n+prevents pointers from pointing into freed memory. There is one other\n+case where the compiler must be very careful to ensure that pointers\n+remain valid: pointers into the interior of an `enum`.\n \n As an example, let\u2019s look at the following `shape` type that can\n represent both rectangles and circles:\n@@ -458,9 +465,9 @@ enum Shape {\n }\n ~~~\n \n-Now I might write a function to compute the area of a shape. This\n-function takes a borrowed pointer to a shape to avoid the need of\n-copying them.\n+Now we might write a function to compute the area of a shape. This\n+function takes a borrowed pointer to a shape, to avoid the need for\n+copying.\n \n ~~~\n # struct Point {x: float, y: float}; // as before\n@@ -478,21 +485,21 @@ fn compute_area(shape: &Shape) -> float {\n }\n ~~~\n \n-The first case matches against circles. Here the radius is extracted\n-from the shape variant and used to compute the area of the circle\n-(Like any up-to-date engineer, we use the [tau circle constant][tau]\n-and not that dreadfully outdated notion of pi).\n+The first case matches against circles. Here, the pattern extracts the\n+radius from the shape variant and the action uses it to compute the\n+area of the circle. (Like any up-to-date engineer, we use the [tau\n+circle constant][tau] and not that dreadfully outdated notion of pi).\n \n [tau]: http://www.math.utah.edu/~palais/pi.html\n \n The second match is more interesting. Here we match against a\n-rectangle and extract its size: but rather than copy the `size` struct,\n-we use a by-reference binding to create a pointer to it. In other\n-words, a pattern binding like `ref size` in fact creates a pointer of\n-type `&size` into the _interior of the enum_.\n+rectangle and extract its size: but rather than copy the `size`\n+struct, we use a by-reference binding to create a pointer to it. In\n+other words, a pattern binding like `ref size` binds the name `size`\n+to a pointer of type `&size` into the _interior of the enum_.\n \n-To make this more clear, let\u2019s look at a diagram of how things are\n-laid out in memory in the case where `shape` points at a rectangle:\n+To make this more clear, let's look at a diagram of memory layout in\n+the case where `shape` points at a rectangle:\n \n ~~~ {.notrust}\n Stack             Memory\n@@ -516,8 +523,8 @@ the shape.\n Perhaps you can see where the danger lies: if the shape were somehow\n to be reassigned, perhaps to a circle, then although the memory used\n to store that shape value would still be valid, _it would have a\n-different type_! This is shown in the following diagram, depicting what\n-the state of memory would be if shape were overwritten with a circle:\n+different type_! The following diagram shows what memory would look\n+like if code overwrote `shape` with a circle:\n \n ~~~ {.notrust}\n Stack             Memory\n@@ -531,20 +538,23 @@ Stack             Memory\n                   +---------------+\n ~~~\n \n-As you can see, the `size` pointer would not be pointing at a `float` and\n-not a struct. This is not good.\n+As you can see, the `size` pointer would be pointing at a `float`\n+instead of a struct. This is not good: dereferencing the second field\n+of a `float` as if it were a struct with two fields would be a memory\n+safety violation.\n \n So, in fact, for every `ref` binding, the compiler will impose the\n same rules as the ones we saw for borrowing the interior of a unique\n-box: it must be able to guarantee that the enum will not be\n-overwritten for the duration of the borrow.  In fact, the example I\n-gave earlier would be considered safe. This is because the shape\n-pointer has type `&Shape`, which means \u201cborrowed pointer to immutable\n-memory containing a shape\u201d. If however the type of that pointer were\n-`&const Shape` or `&mut Shape`, then the ref binding would not be\n-permitted. Just as with unique boxes, the compiler will permit ref\n-bindings into data owned by the stack frame even if it is mutable, but\n-otherwise it requires that the data reside in immutable memory.\n+box: it must be able to guarantee that the `enum` will not be\n+overwritten for the duration of the borrow.  In fact, the compiler\n+would accept the example we gave earlier. The example is safe because\n+the shape pointer has type `&Shape`, which means \"borrowed pointer to\n+immutable memory containing a `shape`\". If, however, the type of that\n+pointer were `&const Shape` or `&mut Shape`, then the ref binding\n+would be ill-typed. Just as with unique boxes, the compiler will\n+permit `ref` bindings into data owned by the stack frame even if the\n+data are mutable, but otherwise it requires that the data reside in\n+immutable memory.\n \n > ***Note:*** Right now, pattern bindings not explicitly annotated\n > with `ref` or `copy` use a special mode of \"implicit by reference\".\n@@ -553,11 +563,11 @@ otherwise it requires that the data reside in immutable memory.\n \n # Returning borrowed pointers\n \n-So far, all of the examples we\u2019ve looked at use borrowed pointers in a\n-\u201cdownward\u201d direction. That is, the borrowed pointer is created and\n-then used during the method or code block which created it. It is also\n-possible to return borrowed pointers to the caller, but as we'll see\n-this requires some explicit annotation.\n+So far, all of the examples we've looked at use borrowed pointers in a\n+\u201cdownward\u201d direction. That is, a method or code block creates a\n+borrowed pointer, then uses it within the same scope. It is also\n+possible to return borrowed pointers as the result of a function, but\n+as we'll see, doing so requires some explicit annotation.\n \n For example, we could write a subroutine like this:\n \n@@ -566,23 +576,25 @@ struct Point {x: float, y: float}\n fn get_x(p: &r/Point) -> &r/float { &p.x }\n ~~~\n \n-Here, the function `get_x()` returns a pointer into the structure it was\n-given. The type of the parameter (`&r/Point`) and return type (`&r/float`) both\n-make use of a new syntactic form that we have not seen so far.  Here the identifier `r`\n-serves as an explicit name for the lifetime of the pointer.  So in effect\n-this function is declaring that it takes in a pointer with lifetime `r` and returns\n-a pointer with that same lifetime.\n+Here, the function `get_x()` returns a pointer into the structure it\n+was given. The type of the parameter (`&r/Point`) and return type\n+(`&r/float`) both use a new syntactic form that we have not seen so\n+far.  Here the identifier `r` names the lifetime of the pointer\n+explicitly. So in effect, this function declares that it takes a\n+pointer with lifetime `r` and returns a pointer with that same\n+lifetime.\n \n In general, it is only possible to return borrowed pointers if they\n-are derived from a borrowed pointer which was given as input to the\n-procedure.  In that case, they will always have the same lifetime as\n-one of the parameters; named lifetimes are used to indicate which\n-parameter that is.\n+are derived from a parameter to the procedure. In that case, the\n+pointer result will always have the same lifetime as one of the\n+parameters; named lifetimes indicate which parameter that\n+is.\n \n-In the examples before, function parameter types did not include a\n-lifetime name.  In this case, the compiler simply creates a new,\n-anonymous name, meaning that the parameter is assumed to have a\n-distinct lifetime from all other parameters.\n+In the previous examples, function parameter types did not include a\n+lifetime name. In those examples, the compiler simply creates a fresh\n+name for the lifetime automatically: that is, the lifetime name is\n+guaranteed to refer to a distinct lifetime from the lifetimes of all\n+other parameters.\n \n Named lifetimes that appear in function signatures are conceptually\n the same as the other lifetimes we've seen before, but they are a bit\n@@ -592,13 +604,13 @@ lifetime `r` is actually a kind of *lifetime parameter*: it is defined\n by the caller to `get_x()`, just as the value for the parameter `p` is\n defined by that caller.\n \n-In any case, whatever the lifetime `r` is, the pointer produced by\n-`&p.x` always has the same lifetime as `p` itself, as a pointer to a\n+In any case, whatever the lifetime of `r` is, the pointer produced by\n+`&p.x` always has the same lifetime as `p` itself: a pointer to a\n field of a struct is valid as long as the struct is valid. Therefore,\n-the compiler is satisfied with the function `get_x()`.\n+the compiler accepts the function `get_x()`.\n \n-To drill in this point, let\u2019s look at a variation on the example, this\n-time one which does not compile:\n+To emphasize this point, let\u2019s look at a variation on the example, this\n+time one that does not compile:\n \n ~~~ {.xfail-test}\n struct Point {x: float, y: float}\n@@ -610,22 +622,21 @@ fn get_x_sh(p: @Point) -> &float {\n Here, the function `get_x_sh()` takes a managed box as input and\n returns a borrowed pointer. As before, the lifetime of the borrowed\n pointer that will be returned is a parameter (specified by the\n-caller). That means that effectively `get_x_sh()` is promising to\n-return a borrowed pointer that is valid for as long as the caller\n-would like: this is subtly different from the first example, which\n-promised to return a pointer that was valid for as long as the pointer\n-it was given.\n+caller). That means that `get_x_sh()` promises to return a borrowed\n+pointer that is valid for as long as the caller would like: this is\n+subtly different from the first example, which promised to return a\n+pointer that was valid for as long as its pointer argument was valid.\n \n Within `get_x_sh()`, we see the expression `&p.x` which takes the\n-address of a field of a managed box. This implies that the compiler\n-must guarantee that, so long as the resulting pointer is valid, the\n-managed box will not be reclaimed by the garbage collector. But recall\n-that `get_x_sh()` also promised to return a pointer that was valid for\n-as long as the caller wanted it to be. Clearly, `get_x_sh()` is not in\n-a position to make both of these guarantees; in fact, it cannot\n-guarantee that the pointer will remain valid at all once it returns,\n-as the parameter `p` may or may not be live in the caller. Therefore,\n-the compiler will report an error here.\n+address of a field of a managed box. The presence of this expression\n+implies that the compiler must guarantee that, so long as the\n+resulting pointer is valid, the managed box will not be reclaimed by\n+the garbage collector. But recall that `get_x_sh()` also promised to\n+return a pointer that was valid for as long as the caller wanted it to\n+be. Clearly, `get_x_sh()` is not in a position to make both of these\n+guarantees; in fact, it cannot guarantee that the pointer will remain\n+valid at all once it returns, as the parameter `p` may or may not be\n+live in the caller. Therefore, the compiler will report an error here.\n \n In general, if you borrow a managed (or unique) box to create a\n borrowed pointer, the pointer will only be valid within the function\n@@ -636,9 +647,9 @@ points at a static constant).\n \n # Named lifetimes\n \n-Let's look at named lifetimes in more detail.  In effect, the use of\n-named lifetimes allows you to group parameters by lifetime.  For\n-example, consider this function:\n+Let's look at named lifetimes in more detail. Named lifetimes allow\n+for grouping of parameters by lifetime. For example, consider this\n+function:\n \n ~~~\n # struct Point {x: float, y: float}; // as before\n@@ -711,10 +722,10 @@ fn select<T>(shape: &tmp/Shape, threshold: float,\n }\n ~~~\n \n-Here you can see the lifetime of shape is now being called `tmp`. The\n-parameters `a`, `b`, and the return value are all given the lifetime\n-`r`.  However, since the lifetime `tmp` is not returned, it would be shorter\n-to just omit the named lifetime for `shape` altogether:\n+Here you can see that `shape`'s lifetime is now named `tmp`. The\n+parameters `a`, `b`, and the return value all have the lifetime `r`.\n+However, since the lifetime `tmp` is not returned, it would be more\n+concise to just omit the named lifetime for `shape` altogether:\n \n ~~~\n # struct Point {x: float, y: float}; // as before\n@@ -735,17 +746,22 @@ This is equivalent to the previous definition.\n # Purity\n \n As mentioned before, the Rust compiler offers a kind of escape hatch\n-that permits borrowing of any data, but only if the actions that occur\n+that permits borrowing of any data, as long as the actions that occur\n during the lifetime of the borrow are pure. Pure actions are those\n-which only modify data owned by the current stack frame. The compiler\n+that only modify data owned by the current stack frame. The compiler\n can therefore permit arbitrary pointers into the heap, secure in the\n knowledge that no pure action will ever cause them to become\n invalidated (the compiler must still track data on the stack which is\n-borrowed and enforce those rules normally, of course).\n-\n-Let\u2019s revisit a previous example and show how purity can affect the\n-compiler\u2019s result. Here is `example5a()`, which borrows the interior of\n-a unique box found in an aliasable, mutable location, only now we\u2019ve\n+borrowed and enforce those rules normally, of course). A pure function\n+in Rust is referentially transparent: it returns the same results\n+given the same (observably equivalent) inputs. That is because while\n+pure functions are allowed to modify data, they may only modify\n+*stack-local* data, which cannot be observed outside the scope of the\n+function itself. (Using an `unsafe` block invalidates this guarantee.)\n+\n+Let\u2019s revisit a previous example and show how purity can affect\n+typechecking. Here is `example5a()`, which borrows the interior of a\n+unique box found in an aliasable, mutable location, only now we\u2019ve\n replaced the `...` with some specific code:\n \n ~~~\n@@ -757,8 +773,8 @@ fn example5a(x: @S ...) -> int {\n }\n ~~~\n \n-The new code simply returns an incremented version of `y`. This clearly\n-doesn\u2019t do mutate anything in the heap, so the compiler is satisfied.\n+The new code simply returns an incremented version of `y`. This code\n+clearly doesn't mutate the heap, so the compiler is satisfied.\n \n But suppose we wanted to pull the increment code into a helper, like\n this:\n@@ -780,8 +796,8 @@ fn example5a(x: @S ...) -> int {\n ~~~\n \n But now the compiler will report an error again. The reason is that it\n-only considers one function at a time (like most type checkers), and\n-so it does not know that `add_one()` only takes pure actions. We can\n+only considers one function at a time (like most typecheckers), and\n+so it does not know that `add_one()` consists of pure code. We can\n help the compiler by labeling `add_one()` as pure:\n \n ~~~\n@@ -792,7 +808,7 @@ With this change, the modified version of `example5a()` will again compile.\n \n # Conclusion\n \n-So there you have it. A (relatively) brief tour of borrowed pointer\n-system. For more details, I refer to the (yet to be written) reference\n+So there you have it: a (relatively) brief tour of the borrowed pointer\n+system. For more details, we refer to the (yet to be written) reference\n document on borrowed pointers, which will explain the full notation\n and give more examples."}, {"sha": "895aaf224364eb7dd1f07c5e090e994ee6a40e6c", "filename": "doc/tutorial-ffi.md", "status": "modified", "additions": 65, "deletions": 66, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/doc%2Ftutorial-ffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/doc%2Ftutorial-ffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-ffi.md?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820", "patch": "@@ -2,17 +2,15 @@\n \n # Introduction\n \n-One of Rust's aims, as a system programming language, is to\n+Because Rust is a systems programming language, one of its goals is to\n interoperate well with C code.\n \n-We'll start with an example. It's a bit bigger than usual, and\n-contains a number of new concepts. We'll go over it one piece at a\n-time.\n-\n-This is a program that uses OpenSSL's `SHA1` function to compute the\n-hash of its first command-line argument, which it then converts to a\n-hexadecimal string and prints to standard output. If you have the\n-OpenSSL libraries installed, it should 'just work'.\n+We'll start with an example, which is a bit bigger than usual. We'll\n+go over it one piece at a time. This is a program that uses OpenSSL's\n+`SHA1` function to compute the hash of its first command-line\n+argument, which it then converts to a hexadecimal string and prints to\n+standard output. If you have the OpenSSL libraries installed, it\n+should compile and run without any extra effort.\n \n ~~~~ {.xfail-test}\n extern mod std;\n@@ -32,7 +30,7 @@ fn sha1(data: ~str) -> ~str unsafe {\n     let bytes = str::to_bytes(data);\n     let hash = crypto::SHA1(vec::raw::to_ptr(bytes),\n                             vec::len(bytes) as c_uint, ptr::null());\n-    return as_hex(vec::raw::from_buf(hash, 20u));\n+    return as_hex(vec::from_buf(hash, 20));\n }\n \n fn main(args: ~[~str]) {\n@@ -42,26 +40,27 @@ fn main(args: ~[~str]) {\n \n # Foreign modules\n \n-Before we can call `SHA1`, we have to declare it. That is what this\n-part of the program is responsible for:\n+Before we can call the `SHA1` function defined in the OpenSSL library, we have\n+to declare it. That is what this part of the program does:\n \n ~~~~ {.xfail-test}\n extern mod crypto {\n-    fn SHA1(src: *u8, sz: uint, out: *u8) -> *u8;\n-}\n+    fn SHA1(src: *u8, sz: uint, out: *u8) -> *u8; }\n ~~~~\n \n-An `extern` module declaration containing function signatures introduces\n-the functions listed as _foreign functions_, that are implemented in some\n-other language (usually C) and accessed through Rust's foreign function\n-interface (FFI). An extern module like this is called a foreign module, and\n-implicitly tells the compiler to link with a library with the same name as\n-the module, and that it will find the foreign functions in that library.\n+An `extern` module declaration containing function signatures introduces the\n+functions listed as _foreign functions_. Foreign functions differ from regular\n+Rust functions in that they are implemented in some other language (usually C)\n+and called through Rust's foreign function interface (FFI). An extern module\n+like this is called a foreign module, and implicitly tells the compiler to\n+link with a library that contains the listed foreign functions, and has the\n+same name as the module.\n \n-In this case, it'll change the name `crypto` to a shared library name\n-in a platform-specific way (`libcrypto.so` on Linux, for example), and\n-link that in. If you want the module to have a different name from the\n-actual library, you can use the `\"link_name\"` attribute, like:\n+In this case, the Rust compiler changes the name `crypto` to a shared library\n+name in a platform-specific way (`libcrypto.so` on Linux, for example),\n+searches for the shared library with that name, and links the library into the\n+program. If you want the module to have a different name from the actual\n+library, you can use the `\"link_name\"` attribute, like:\n \n ~~~~ {.xfail-test}\n #[link_name = \"crypto\"]\n@@ -72,11 +71,11 @@ extern mod something {\n \n # Foreign calling conventions\n \n-Most foreign code will be C code, which usually uses the `cdecl` calling\n+Most foreign code is C code, which usually uses the `cdecl` calling\n convention, so that is what Rust uses by default when calling foreign\n functions. Some foreign functions, most notably the Windows API, use other\n-calling conventions, so Rust provides a way to hint to the compiler which\n-is expected by using the `\"abi\"` attribute:\n+calling conventions. Rust provides the `\"abi\"` attribute as a way to hint to\n+the compiler which calling convention to use:\n \n ~~~~\n #[cfg(target_os = \"win32\")]\n@@ -86,14 +85,14 @@ extern mod kernel32 {\n }\n ~~~~\n \n-The `\"abi\"` attribute applies to a foreign module (it can not be applied\n+The `\"abi\"` attribute applies to a foreign module (it cannot be applied\n to a single function within a module), and must be either `\"cdecl\"`\n-or `\"stdcall\"`. Other conventions may be defined in the future.\n+or `\"stdcall\"`. We may extend the compiler in the future to support other\n+calling conventions.\n \n # Unsafe pointers\n \n-The foreign `SHA1` function is declared to take three arguments, and\n-return a pointer.\n+The foreign `SHA1` function takes three arguments, and returns a pointer.\n \n ~~~~ {.xfail-test}\n # extern mod crypto {\n@@ -104,21 +103,20 @@ fn SHA1(src: *u8, sz: libc::c_uint, out: *u8) -> *u8;\n When declaring the argument types to a foreign function, the Rust\n compiler has no way to check whether your declaration is correct, so\n you have to be careful. If you get the number or types of the\n-arguments wrong, you're likely to get a segmentation fault. Or,\n+arguments wrong, you're likely to cause a segmentation fault. Or,\n probably even worse, your code will work on one platform, but break on\n another.\n \n-In this case, `SHA1` is defined as taking two `unsigned char*`\n-arguments and one `unsigned long`. The rust equivalents are `*u8`\n+In this case, we declare that `SHA1` takes two `unsigned char*`\n+arguments and one `unsigned long`. The Rust equivalents are `*u8`\n unsafe pointers and an `uint` (which, like `unsigned long`, is a\n machine-word-sized type).\n \n-Unsafe pointers can be created through various functions in the\n-standard lib, usually with `unsafe` somewhere in their name. You can\n-dereference an unsafe pointer with `*` operator, but use\n-caution\u2014unlike Rust's other pointer types, unsafe pointers are\n-completely unmanaged, so they might point at invalid memory, or be\n-null pointers.\n+The standard library provides various functions to create unsafe pointers,\n+such as those in `core::cast`. Most of these functions have `unsafe` in their\n+name.  You can dereference an unsafe pointer with the `*` operator, but use\n+caution: unlike Rust's other pointer types, unsafe pointers are completely\n+unmanaged, so they might point at invalid memory, or be null pointers.\n \n # Unsafe blocks\n \n@@ -134,12 +132,12 @@ fn sha1(data: ~str) -> ~str {\n         let bytes = str::to_bytes(data);\n         let hash = crypto::SHA1(vec::raw::to_ptr(bytes),\n                                 vec::len(bytes), ptr::null());\n-        return as_hex(vec::raw::from_buf(hash, 20u));\n+        return as_hex(vec::from_buf(hash, 20));\n     }\n }\n ~~~~\n \n-Firstly, what does the `unsafe` keyword at the top of the function\n+First, what does the `unsafe` keyword at the top of the function\n mean? `unsafe` is a block modifier\u2014it declares the block following it\n to be known to be unsafe.\n \n@@ -158,8 +156,8 @@ advertise it to the world. An unsafe function is written like this:\n unsafe fn kaboom() { ~\"I'm harmless!\"; }\n ~~~~\n \n-This function can only be called from an unsafe block or another\n-unsafe function.\n+This function can only be called from an `unsafe` block or another\n+`unsafe` function.\n \n # Pointer fiddling\n \n@@ -179,35 +177,36 @@ Let's look at our `sha1` function again.\n let bytes = str::to_bytes(data);\n let hash = crypto::SHA1(vec::raw::to_ptr(bytes),\n                         vec::len(bytes), ptr::null());\n-return as_hex(vec::raw::from_buf(hash, 20u));\n+return as_hex(vec::from_buf(hash, 20));\n # }\n # }\n ~~~~\n \n-The `str::to_bytes` function is perfectly safe: it converts a string to\n-a `[u8]`. This byte array is then fed to `vec::raw::to_ptr`, which\n+The `str::to_bytes` function is perfectly safe: it converts a string to a\n+`~[u8]`. The program then feeds this byte array to `vec::raw::to_ptr`, which\n returns an unsafe pointer to its contents.\n \n-This pointer will become invalid as soon as the vector it points into\n-is cleaned up, so you should be very careful how you use it. In this\n-case, the local variable `bytes` outlives the pointer, so we're good.\n+This pointer will become invalid at the end of the scope in which the vector\n+it points to (`bytes`) is valid, so you should be very careful how you use\n+it. In this case, the local variable `bytes` outlives the pointer, so we're\n+good.\n \n Passing a null pointer as the third argument to `SHA1` makes it use a\n static buffer, and thus save us the effort of allocating memory\n-ourselves. `ptr::null` is a generic function that will return an\n-unsafe null pointer of the correct type (Rust generics are awesome\n-like that\u2014they can take the right form depending on the type that they\n-are expected to return).\n-\n-Finally, `vec::raw::from_buf` builds up a new `[u8]` from the\n-unsafe pointer that was returned by `SHA1`. SHA1 digests are always\n-twenty bytes long, so we can pass `20u` for the length of the new\n+ourselves. `ptr::null` is a generic function that, in this case, returns an\n+unsafe null pointer of type `*u8`. (Rust generics are awesome\n+like that: they can take the right form depending on the type that they\n+are expected to return.)\n+\n+Finally, `vec::from_buf` builds up a new `~[u8]` from the\n+unsafe pointer that `SHA1` returned. SHA1 digests are always\n+twenty bytes long, so we can pass `20` for the length of the new\n vector.\n \n # Passing structures\n \n C functions often take pointers to structs as arguments. Since Rust\n-structs are binary-compatible with C structs, Rust programs can call\n+`struct`s are binary-compatible with C structs, Rust programs can call\n such functions directly.\n \n This program uses the POSIX function `gettimeofday` to get a\n@@ -241,12 +240,12 @@ fn unix_time_in_microseconds() -> u64 unsafe {\n The `#[nolink]` attribute indicates that there's no foreign library to\n link in. The standard C library is already linked with Rust programs.\n \n-A `timeval`, in C, is a struct with two 32-bit integers. Thus, we\n-define a struct type with the same contents, and declare\n-`gettimeofday` to take a pointer to such a struct.\n+In C, a `timeval` is a struct with two 32-bit integer fields. Thus, we\n+define a `struct` type with the same contents, and declare\n+`gettimeofday` to take a pointer to such a `struct`.\n \n-The second argument to `gettimeofday` (the time zone) is not used by\n-this program, so it simply declares it to be a pointer to the nil\n-type. Since all null pointers have the same representation regardless of\n-their referent type, this is safe.\n+This program does not use the second argument to `gettimeofday` (the time\n+ zone), so the `extern mod` declaration for it simply declares this argument\n+ to be a pointer to the unit type (written `()`). Since all null pointers have\n+ the same representation regardless of their referent type, this is safe.\n "}, {"sha": "40cbcacf1e1b0a4cf214bd5bbdc1360af7196f77", "filename": "doc/tutorial-macros.md", "status": "modified", "additions": 78, "deletions": 49, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/doc%2Ftutorial-macros.md", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/doc%2Ftutorial-macros.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-macros.md?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820", "patch": "@@ -2,10 +2,11 @@\n \n # Introduction\n \n-Functions are the programmer's primary tool of abstraction, but there are\n-cases in which they are insufficient, because the programmer wants to\n-abstract over concepts not represented as values. Consider the following\n-example:\n+Functions are the primary tool that programmers can use to build abstractions.\n+Sometimes, however, programmers want to perform abstractions over things that are not\n+runtime values. Macros provide a syntactic abstraction. For an example of how this\n+can be useful, consider the following two code fragments, which both pattern-match\n+on their input and return early in one case, and do nothing otherwise:\n \n ~~~~\n # enum t { special_a(uint), special_b(uint) };\n@@ -24,11 +25,12 @@ match input_2 {\n # }\n ~~~~\n \n-This code could become tiresome if repeated many times. However, there is\n-no reasonable function that could be written to solve this problem. In such a\n-case, it's possible to define a macro to solve the problem. Macros are\n+This code could become tiresome if repeated many times. However, there is no\n+straightforward way to rewrite it without the repeated code, using functions\n+alone. There is a solution, though: defining a macro to solve the problem. Macros are\n lightweight custom syntax extensions, themselves defined using the\n-`macro_rules!` syntax extension:\n+`macro_rules!` syntax extension. The following `early_return` macro captures\n+the pattern in the above code:\n \n ~~~~\n # enum t { special_a(uint), special_b(uint) };\n@@ -50,48 +52,72 @@ early_return!(input_2 special_b);\n # }\n ~~~~\n \n-Macros are defined in pattern-matching style:\n+Macros are defined in pattern-matching style: in the above example, the text\n+`($inp:expr $sp:ident)` that appears on the left-hand side of the `=>` is the\n+*macro invocation syntax*, a pattern denoting how to write a call to the\n+macro. The text on the right-hand side of the `=>`, beginning with `match\n+$inp`, is the *macro transcription syntax*: what the macro expands to.\n \n # Invocation syntax\n \n-On the left-hand-side of the `=>` is the macro invocation syntax. It is\n-free-form, excepting the following rules:\n+The macro invocation syntax specifies the syntax for the arguments to the\n+macro. It appears on the left-hand side of the `=>` in a macro definition. It\n+conforms to the following rules:\n \n-1. It must be surrounded in parentheses.\n+1. It must be surrounded by parentheses.\n 2. `$` has special meaning.\n 3. The `()`s, `[]`s, and `{}`s it contains must balance. For example, `([)` is\n forbidden.\n \n+Otherwise, the invocation syntax is free-form.\n+\n To take as an argument a fragment of Rust code, write `$` followed by a name\n- (for use on the right-hand side), followed by a `:`, followed by the sort of\n-fragment to match (the most common ones are `ident`, `expr`, `ty`, `pat`, and\n-`block`). Anything not preceded by a `$` is taken literally. The standard\n+ (for use on the right-hand side), followed by a `:`, followed by a *fragment\n+ specifier*. The fragment specifier denotes the sort of fragment to match. The\n+ most common fragment specifiers are:\n+\n+* `ident` (an identifier, referring to a variable or item. Examples: `f`, `x`,\n+  `foo`.)\n+* `expr` (an expression. Examples: `2 + 2`; `if true then { 1 } else { 2 }`;\n+  `f(42)`.)\n+* `ty` (a type. Examples: `int`, `~[(char, ~str)]`, `&T`.)\n+* `pat` (a pattern, usually appearing in a `match` or on the left-hand side of\n+  a declaration. Examples: `Some(t)`; `(17, 'a')`; `_`.)\n+* `block` (a sequence of actions. Example: `{ log(error, \"hi\"); return 12; }`)\n+ \n+The parser interprets any token that's not preceded by a `$` literally. Rust's usual\n rules of tokenization apply,\n \n-So `($x:ident => (($e:expr)))`, though excessively fancy, would create a macro\n-that could be invoked like `my_macro!(i=>(( 2+2 )))`.\n+So `($x:ident -> (($e:expr)))`, though excessively fancy, would designate a macro\n+that could be invoked like: `my_macro!(i->(( 2+2 )))`.\n \n # Transcription syntax\n \n The right-hand side of the `=>` follows the same rules as the left-hand side,\n-except that `$` need only be followed by the name of the syntactic fragment\n-to transcribe.\n+except that a `$` need only be followed by the name of the syntactic fragment\n+to transcribe into the macro expansion; its type need not be repeated.\n \n-The right-hand side must be surrounded by delimiters of some kind, and must be\n-an expression; currently, user-defined macros can only be invoked in\n-expression position (even though `macro_rules!` itself can be in item\n-position).\n+The right-hand side must be enclosed by delimiters, and must be\n+an expression. Currently, invocations of user-defined macros can only appear in a context\n+where the Rust grammar requires an expression, even though `macro_rules!` itself can appear\n+in a context where the grammar requires an item.\n \n # Multiplicity\n \n ## Invocation\n \n-Going back to the motivating example, suppose that we wanted each invocation\n-of `early_return` to potentially accept multiple \"special\" identifiers. The\n-syntax `$(...)*` accepts zero or more occurrences of its contents, much like\n-the Kleene star operator in regular expressions. It also supports a separator\n-token (a comma-separated list could be written `$(...),*`), and `+` instead of\n-`*` to mean \"at least one\".\n+Going back to the motivating example, recall that `early_return` expanded into\n+a `match` that would `return` if the `match`'s scrutinee matched the\n+\"special case\" identifier provided as the second argument to `early_return`,\n+and do nothing otherwise. Now suppose that we wanted to write a\n+version of `early_return` that could handle a variable number of \"special\"\n+cases.\n+\n+The syntax `$(...)*` on the left-hand side of the `=>` in a macro definition\n+accepts zero or more occurrences of its contents. It works much\n+like the `*` operator in regular expressions. It also supports a\n+separator token (a comma-separated list could be written `$(...),*`), and `+`\n+instead of `*` to mean \"at least one\".\n \n ~~~~\n # enum t { special_a(uint),special_b(uint),special_c(uint),special_d(uint)};\n@@ -118,37 +144,40 @@ early_return!(input_2, [special_b]);\n ### Transcription\n \n As the above example demonstrates, `$(...)*` is also valid on the right-hand\n-side of a macro definition. The behavior of Kleene star in transcription,\n-especially in cases where multiple stars are nested, and multiple different\n+side of a macro definition. The behavior of `*` in transcription,\n+especially in cases where multiple `*`s are nested, and multiple different\n names are involved, can seem somewhat magical and intuitive at first. The\n system that interprets them is called \"Macro By Example\". The two rules to\n keep in mind are (1) the behavior of `$(...)*` is to walk through one \"layer\"\n of repetitions for all of the `$name`s it contains in lockstep, and (2) each\n `$name` must be under at least as many `$(...)*`s as it was matched against.\n-If it is under more, it'll will be repeated, as appropriate.\n+If it is under more, it'll be repeated, as appropriate.\n \n ## Parsing limitations\n \n-The parser used by the macro system is reasonably powerful, but the parsing of\n-Rust syntax is restricted in two ways:\n \n-1. The parser will always parse as much as possible. For example, if the comma\n-were omitted from the syntax of `early_return!` above, `input_1 [` would've\n-been interpreted as the beginning of an array index. In fact, invoking the\n-macro would have been impossible.\n-2. The parser must have eliminated all ambiguity by the time it reaches a\n-`$name:fragment_specifier`. This most often affects them when they occur in\n-the beginning of, or immediately after, a `$(...)*`; requiring a distinctive\n-token in front can solve the problem.\n+For technical reasons, there are two limitations to the treatment of syntax\n+fragments by the macro parser:\n+\n+1. The parser will always parse as much as possible of a Rust syntactic\n+fragment. For example, if the comma were omitted from the syntax of\n+`early_return!` above, `input_1 [` would've been interpreted as the beginning\n+of an array index. In fact, invoking the macro would have been impossible.\n+2. The parser must have eliminated all ambiguity by the time it reaches a \n+`$name:fragment_specifier` declaration. This limitation can result in parse\n+errors when declarations occur at the beginning of, or immediately after,\n+a `$(...)*`. For example, the grammar `$($t:ty)* $e:expr` will always fail to\n+parse because the parser would be forced to choose between parsing `t` and\n+parsing `e`. Changing the invocation syntax to require a distinctive token in\n+front can solve the problem. In the above example, `$(T $t:ty)* E $e:exp`\n+solves the problem.\n \n ## A final note\n \n Macros, as currently implemented, are not for the faint of heart. Even\n-ordinary syntax errors can be more difficult to debug when they occur inside\n-a macro, and errors caused by parse problems in generated code can be very\n+ordinary syntax errors can be more difficult to debug when they occur inside a\n+macro, and errors caused by parse problems in generated code can be very\n tricky. Invoking the `log_syntax!` macro can help elucidate intermediate\n-states, using `trace_macros!(true)` will automatically print those\n-intermediate states out, and using `--pretty expanded` as an argument to the\n-compiler will show the result of expansion.\n-\n-\n+states, invoking `trace_macros!(true)` will automatically print those\n+intermediate states out, and passing the flag `--pretty expanded` as a\n+command-line argument to the compiler will show the result of expansion."}, {"sha": "2d203400dda8e20186053625b5edb65c6771d32c", "filename": "doc/tutorial-tasks.md", "status": "modified", "additions": 135, "deletions": 137, "changes": 272, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/doc%2Ftutorial-tasks.md", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/doc%2Ftutorial-tasks.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-tasks.md?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820", "patch": "@@ -2,64 +2,65 @@\n \n # Introduction\n \n-The Rust language is designed from the ground up to support pervasive\n+The designers of Rust designed the language from the ground up to support pervasive\n and safe concurrency through lightweight, memory-isolated tasks and\n message passing.\n \n-Rust tasks are not the same as traditional threads - they are what are\n-often referred to as _green threads_, cooperatively scheduled by the\n-Rust runtime onto a small number of operating system threads.  Being\n-significantly cheaper to create than traditional threads, Rust can\n-create hundreds of thousands of concurrent tasks on a typical 32-bit\n-system.\n-\n-Tasks provide failure isolation and recovery. When an exception occurs\n-in rust code (either by calling `fail` explicitly or by otherwise performing\n-an invalid operation) the entire task is destroyed - there is no way\n-to `catch` an exception as in other languages. Instead tasks may monitor\n-each other to detect when failure has occurred.\n-\n-Rust tasks have dynamically sized stacks. When a task is first created\n-it starts off with a small amount of stack (currently in the low\n-thousands of bytes, depending on platform) and more stack is acquired as\n-needed. A Rust task will never run off the end of the stack as is\n-possible in many other languages, but they do have a stack budget, and\n-if a Rust task exceeds its stack budget then it will fail safely.\n-\n-Tasks make use of Rust's type system to provide strong memory safety\n-guarantees, disallowing shared mutable state. Communication between\n-tasks is facilitated by the transfer of _owned_ data through the\n-global _exchange heap_.\n-\n-This tutorial will explain the basics of tasks and communication in Rust,\n-explore some typical patterns in concurrent Rust code, and finally\n-discuss some of the more exotic synchronization types in the standard\n+Rust tasks are not the same as traditional threads: rather, they are more like\n+_green threads_. The Rust runtime system schedules tasks cooperatively onto a\n+small number of operating system threads. Because tasks are significantly\n+cheaper to create than traditional threads, Rust can create hundreds of\n+thousands of concurrent tasks on a typical 32-bit system.\n+\n+Tasks provide failure isolation and recovery. When an exception occurs in Rust\n+code (as a result of an explicit call to `fail`, an assertion failure, or\n+another invalid operation), the runtime system destroys the entire\n+task. Unlike in languages such as Java and C++, there is no way to `catch` an\n+exception. Instead, tasks may monitor each other for failure.\n+\n+Rust tasks have dynamically sized stacks. A task begins its life with a small\n+amount of stack space (currently in the low thousands of bytes, depending on\n+platform), and acquires more stack as needed. Unlike in languages such as C, a\n+Rust task cannot run off the end of the stack. However, tasks do have a stack\n+budget. If a Rust task exceeds its stack budget, then it will fail safely:\n+with a checked exception.\n+\n+Tasks use Rust's type system to provide strong memory safety guarantees. In\n+particular, the type system guarantees that tasks cannot share mutable state\n+with each other. Tasks communicate with each other by transferring _owned_\n+data through the global _exchange heap_.\n+\n+This tutorial explains the basics of tasks and communication in Rust,\n+explores some typical patterns in concurrent Rust code, and finally\n+discusses some of the more unusual synchronization types in the standard\n library.\n \n+> ***Warning:*** This tutorial is incomplete\n+\n ## A note about the libraries\n \n While Rust's type system provides the building blocks needed for safe\n and efficient tasks, all of the task functionality itself is implemented\n in the core and standard libraries, which are still under development\n and do not always present a consistent interface.\n \n-In particular, there are currently two independent modules that provide\n-a message passing interface to Rust code: `core::comm` and `core::pipes`.\n-`core::comm` is an older, less efficient system that is being phased out\n-in favor of `pipes`. At some point the existing `core::comm` API will\n-be removed and the user-facing portions of `core::pipes` will be moved\n-to `core::comm`. In this tutorial we will discuss `pipes` and ignore\n-the `comm` API.\n+In particular, there are currently two independent modules that provide a\n+message passing interface to Rust code: `core::comm` and `core::pipes`.\n+`core::comm` is an older, less efficient system that is being phased out in\n+favor of `pipes`. At some point, we will remove the existing `core::comm` API\n+and move the user-facing portions of `core::pipes` to `core::comm`. In this\n+tutorial, we discuss `pipes` and ignore the `comm` API.\n \n For your reference, these are the standard modules involved in Rust\n-concurrency at the moment.\n+concurrency at this writing.\n \n * [`core::task`] - All code relating to tasks and task scheduling\n * [`core::comm`] - The deprecated message passing API\n * [`core::pipes`] - The new message passing infrastructure and API\n * [`std::comm`] - Higher level messaging types based on `core::pipes`\n * [`std::sync`] - More exotic synchronization tools, including locks\n-* [`std::arc`] - The ARC type, for safely sharing immutable data\n+* [`std::arc`] - The ARC (atomic reference counted) type, for safely sharing\n+  immutable data\n * [`std::par`] - Some basic tools for implementing parallel algorithms\n \n [`core::task`]: core/task.html\n@@ -72,11 +73,11 @@ concurrency at the moment.\n \n # Basics\n \n-The programming interface for creating and managing tasks is contained\n-in the `task` module of the `core` library, making it available to all\n-Rust code by default. At it's simplest, creating a task is a matter of\n-calling the `spawn` function, passing a closure to run in the new\n-task.\n+The programming interface for creating and managing tasks lives\n+in the `task` module of the `core` library, and is thus available to all\n+Rust code by default. At its simplest, creating a task is a matter of\n+calling the `spawn` function with a closure argument. `spawn` executes the\n+closure in the new task.\n \n ~~~~\n # use io::println;\n@@ -95,17 +96,17 @@ do spawn {\n }\n ~~~~\n \n-In Rust, there is nothing special about creating tasks - the language\n-itself doesn't know what a 'task' is. Instead, Rust provides in the\n-type system all the tools necessary to implement safe concurrency,\n-_owned types_ in particular, and leaves the dirty work up to the\n-core library.\n+In Rust, there is nothing special about creating tasks: a task is not a\n+concept that appears in the language semantics. Instead, Rust's type system\n+provides all the tools necessary to implement safe concurrency: particularly,\n+_owned types_. The language leaves the implementation details to the core\n+library.\n \n The `spawn` function has a very simple type signature: `fn spawn(f:\n ~fn())`. Because it accepts only owned closures, and owned closures\n-contained only owned data, `spawn` can safely move the entire closure\n+contain only owned data, `spawn` can safely move the entire closure\n and all its associated state into an entirely different task for\n-execution. Like any closure, the function passed to spawn may capture\n+execution. Like any closure, the function passed to `spawn` may capture\n an environment that it carries across tasks.\n \n ~~~\n@@ -121,8 +122,8 @@ do spawn {\n }\n ~~~\n \n-By default tasks will be multiplexed across the available cores, running\n-in parallel, thus on a multicore machine, running the following code\n+By default, the scheduler multiplexes tasks across the available cores, running\n+in parallel. Thus, on a multicore machine, running the following code\n should interleave the output in vaguely random order.\n \n ~~~\n@@ -143,25 +144,24 @@ communicate with it. Recall that Rust does not have shared mutable\n state, so one task may not manipulate variables owned by another task.\n Instead we use *pipes*.\n \n-Pipes are simply a pair of endpoints, with one for sending messages\n-and another for receiving messages. Pipes are low-level communication\n-building-blocks and so come in a variety of forms, appropriate for\n-different use cases, but there are just a few varieties that are most\n-commonly used, which we will cover presently.\n+A pipe is simply a pair of endpoints: one for sending messages and another for\n+receiving messages. Pipes are low-level communication building-blocks and so\n+come in a variety of forms, each one appropriate for a different use case. In\n+what follows, we cover the most commonly used varieties.\n \n The simplest way to create a pipe is to use the `pipes::stream`\n-function to create a `(Chan, Port)` pair. In Rust parlance a 'channel'\n-is a sending endpoint of a pipe, and a 'port' is the receiving\n-endpoint. Consider the following example of performing two calculations\n-concurrently.\n+function to create a `(Chan, Port)` pair. In Rust parlance, a *channel*\n+is a sending endpoint of a pipe, and a *port* is the receiving\n+endpoint. Consider the following example of calculating two results\n+concurrently:\n \n ~~~~\n use task::spawn;\n use pipes::{stream, Port, Chan};\n \n let (chan, port): (Chan<int>, Port<int>) = stream();\n \n-do spawn {\n+do spawn |move chan| {\n     let result = some_expensive_computation();\n     chan.send(result);\n }\n@@ -172,17 +172,17 @@ let result = port.recv();\n # fn some_other_expensive_computation() {}\n ~~~~\n \n-Let's examine this example in detail. The `let` statement first creates a\n-stream for sending and receiving integers (recall that `let` can be\n-used for destructuring patterns, in this case separating a tuple into\n-its component parts).\n+Let's examine this example in detail. First, the `let` statement creates a\n+stream for sending and receiving integers (the left-hand side of the `let`,\n+`(chan, port)`, is an example of a *destructuring let*: the pattern separates\n+a tuple into its component parts).\n \n ~~~~\n # use pipes::{stream, Chan, Port};\n let (chan, port): (Chan<int>, Port<int>) = stream();\n ~~~~\n \n-The channel will be used by the child task to send data to the parent task,\n+The child task will use the channel to send data to the parent task,\n which will wait to receive the data on the port. The next statement\n spawns the child task.\n \n@@ -192,20 +192,20 @@ spawns the child task.\n # use pipes::{stream, Port, Chan};\n # fn some_expensive_computation() -> int { 42 }\n # let (chan, port) = stream();\n-do spawn {\n+do spawn |move chan| {\n     let result = some_expensive_computation();\n     chan.send(result);\n }\n ~~~~\n \n-Notice that `chan` was transferred to the child task implicitly by\n-capturing it in the task closure. Both `Chan` and `Port` are sendable\n-types and may be captured into tasks or otherwise transferred between\n-them. In the example, the child task performs an expensive computation\n-then sends the result over the captured channel.\n+Notice that the creation of the task closure transfers `chan` to the child\n+task implicitly: the closure captures `chan` in its environment. Both `Chan`\n+and `Port` are sendable types and may be captured into tasks or otherwise\n+transferred between them. In the example, the child task runs an expensive\n+computation, then sends the result over the captured channel.\n \n-Finally, the parent continues by performing some other expensive\n-computation and then waiting for the child's result to arrive on the\n+Finally, the parent continues with some other expensive\n+computation, then waits for the child's result to arrive on the\n port:\n \n ~~~~\n@@ -217,20 +217,19 @@ some_other_expensive_computation();\n let result = port.recv();\n ~~~~\n \n-The `Port` and `Chan` pair created by `stream` enable efficient\n-communication between a single sender and a single receiver, but\n-multiple senders cannot use a single `Chan`, nor can multiple\n-receivers use a single `Port`.  What if our example needed to perform\n-multiple computations across a number of tasks? The following cannot\n-be written:\n+The `Port` and `Chan` pair created by `stream` enables efficient communication\n+between a single sender and a single receiver, but multiple senders cannot use\n+a single `Chan`, and multiple receivers cannot use a single `Port`.  What if our\n+example needed to computer multiple results across a number of tasks? The\n+following program is ill-typed:\n \n ~~~ {.xfail-test}\n # use task::{spawn};\n # use pipes::{stream, Port, Chan};\n # fn some_expensive_computation() -> int { 42 }\n let (chan, port) = stream();\n \n-do spawn {\n+do spawn |move chan| {\n     chan.send(some_expensive_computation());\n }\n \n@@ -254,7 +253,7 @@ let chan = SharedChan(move chan);\n for uint::range(0, 3) |init_val| {\n     // Create a new channel handle to distribute to the child task\n     let child_chan = chan.clone();\n-    do spawn {\n+    do spawn |move child_chan| {\n         child_chan.send(some_expensive_computation(init_val));\n     }\n }\n@@ -263,18 +262,18 @@ let result = port.recv() + port.recv() + port.recv();\n # fn some_expensive_computation(_i: uint) -> int { 42 }\n ~~~\n \n-Here we transfer ownership of the channel into a new `SharedChan`\n-value.  Like `Chan`, `SharedChan` is a non-copyable, owned type\n-(sometimes also referred to as an 'affine' or 'linear' type). Unlike\n-`Chan` though, `SharedChan` may be duplicated with the `clone()`\n-method.  A cloned `SharedChan` produces a new handle to the same\n-channel, allowing multiple tasks to send data to a single port.\n-Between `spawn`, `stream` and `SharedChan` we have enough tools\n-to implement many useful concurrency patterns.\n+Here we transfer ownership of the channel into a new `SharedChan` value.  Like\n+`Chan`, `SharedChan` is a non-copyable, owned type (sometimes also referred to\n+as an *affine* or *linear* type). Unlike with `Chan`, though, the programmer\n+may duplicate a `SharedChan`, with the `clone()` method.  A cloned\n+`SharedChan` produces a new handle to the same channel, allowing multiple\n+tasks to send data to a single port.  Between `spawn`, `stream` and\n+`SharedChan`, we have enough tools to implement many useful concurrency\n+patterns.\n \n Note that the above `SharedChan` example is somewhat contrived since\n you could also simply use three `stream` pairs, but it serves to\n-illustrate the point. For reference, written with multiple streams it\n+illustrate the point. For reference, written with multiple streams, it\n might look like the example below.\n \n ~~~\n@@ -284,30 +283,30 @@ might look like the example below.\n // Create a vector of ports, one for each child task\n let ports = do vec::from_fn(3) |init_val| {\n     let (chan, port) = stream();\n-    do spawn {\n+    do spawn |move chan| {\n         chan.send(some_expensive_computation(init_val));\n     }\n-    port\n+    move port\n };\n \n // Wait on each port, accumulating the results\n let result = ports.foldl(0, |accum, port| *accum + port.recv() );\n # fn some_expensive_computation(_i: uint) -> int { 42 }\n ~~~\n \n-# TODO\n-\n # Handling task failure\n \n-Rust has a built-in mechanism for raising exceptions, written `fail`\n-(or `fail ~\"reason\"`, or sometimes `assert expr`), and it causes the\n-task to unwind its stack, running destructors and freeing memory along\n-the way, and then exit itself. Unlike C++, exceptions in Rust are\n-unrecoverable within a single task - once a task fails there is no way\n-to \"catch\" the exception.\n+Rust has a built-in mechanism for raising exceptions. The `fail` construct\n+(which can also be written with an error string as an argument: `fail\n+~reason`) and the `assert` construct (which effectively calls `fail` if a\n+boolean expression is false) are both ways to raise exceptions. When a task\n+raises an exception the task unwinds its stack---running destructors and\n+freeing memory along the way---and then exits. Unlike exceptions in C++,\n+exceptions in Rust are unrecoverable within a single task: once a task fails,\n+there is no way to \"catch\" the exception.\n \n-All tasks are, by default, _linked_ to each other, meaning their fate\n-is intertwined, and if one fails so do all of them.\n+All tasks are, by default, _linked_ to each other. That means that the fates\n+of all tasks are intertwined: if one fails, so do all the others.\n \n ~~~\n # use task::spawn;\n@@ -321,11 +320,15 @@ do_some_work();\n # };\n ~~~\n \n-While it isn't possible for a task to recover from failure,\n-tasks may be notified when _other_ tasks fail. The simplest way\n-of handling task failure is with the `try` function, which is\n-similar to spawn, but immediately blocks waiting for the child\n-task to finish.\n+While it isn't possible for a task to recover from failure, tasks may notify\n+each other of failure. The simplest way of handling task failure is with the\n+`try` function, which is similar to `spawn`, but immediately blocks waiting\n+for the child task to finish. `try` returns a value of type `Result<int,\n+()>`. `Result` is an `enum` type with two variants: `Ok` and `Err`. In this\n+case, because the type arguments to `Result` are `int` and `()`, callers can\n+pattern-match on a result to check whether it's an `Ok` result with an `int`\n+field (representing a successful result) or an `Err` result (representing\n+termination with an error).\n \n ~~~\n # fn some_condition() -> bool { false }\n@@ -349,8 +352,8 @@ an `Error` result.\n [`Result`]: core/result.html\n \n > ***Note:*** A failed task does not currently produce a useful error\n-> value (all error results from `try` are equal to `Err(())`). In the\n-> future it may be possible for tasks to intercept the value passed to\n+> value (`try` always returns `Err(())`). In the\n+> future, it may be possible for tasks to intercept the value passed to\n > `fail`.\n \n TODO: Need discussion of `future_result` in order to make failure\n@@ -362,11 +365,11 @@ it trips, indicates an unrecoverable logic error); in other cases you\n might want to contain the failure at a certain boundary (perhaps a\n small piece of input from the outside world, which you happen to be\n processing in parallel, is malformed and its processing task can't\n-proceed). Hence the need for different _linked failure modes_.\n+proceed). Hence, you will need different _linked failure modes_.\n \n ## Failure modes\n \n-By default, task failure is _bidirectionally linked_, which means if\n+By default, task failure is _bidirectionally linked_, which means that if\n either task dies, it kills the other one.\n \n ~~~\n@@ -382,8 +385,8 @@ sleep_forever();  // Will get woken up by force, then fail\n # };\n ~~~\n \n-If you want parent tasks to kill their children, but not for a child\n-task's failure to kill the parent, you can call\n+If you want parent tasks to be able to kill their children, but do not want a\n+parent to die automatically if one of its child task dies, you can call\n `task::spawn_supervised` for _unidirectionally linked_ failure. The\n function `task::try`, which we saw previously, uses `spawn_supervised`\n internally, with additional logic to wait for the child task to finish\n@@ -395,13 +398,13 @@ before returning. Hence:\n # fn sleep_forever() { loop { task::yield() } }\n # do task::try {\n let (sender, receiver): (Chan<int>, Port<int>) = stream();\n-do spawn {  // Bidirectionally linked\n+do spawn |move receiver| {  // Bidirectionally linked\n     // Wait for the supervised child task to exist.\n     let message = receiver.recv();\n     // Kill both it and the parent task.\n     assert message != 42;\n }\n-do try {  // Unidirectionally linked\n+do try |move sender| {  // Unidirectionally linked\n     sender.send(42);\n     sleep_forever();  // Will get woken up by force\n }\n@@ -411,7 +414,7 @@ do try {  // Unidirectionally linked\n \n Supervised failure is useful in any situation where one task manages\n multiple fallible child tasks, and the parent task can recover\n-if any child files. On the other hand, if the _parent_ (supervisor) fails\n+if any child fails. On the other hand, if the _parent_ (supervisor) fails,\n then there is nothing the children can do to recover, so they should\n also fail.\n \n@@ -451,23 +454,16 @@ fail;\n # };\n ~~~\n \n-\n-# Unfinished notes\n-\n-## Actor patterns\n-\n-## Linearity, option dancing, owned closures\n-\n ## Creating a task with a bi-directional communication path\n \n A very common thing to do is to spawn a child task where the parent\n and child both need to exchange messages with each other. The\n function `std::comm::DuplexStream()` supports this pattern.  We'll\n-look briefly at how it is used.\n+look briefly at how to use it.\n \n To see how `spawn_conversation()` works, we will create a child task\n-that receives `uint` messages, converts them to a string, and sends\n-the string in response.  The child terminates when `0` is received.\n+that repeatedly receives a `uint` message, converts it to a string, and sends\n+the string in response.  The child terminates when it receives `0`.\n Here is the function that implements the child task:\n \n ~~~~\n@@ -477,8 +473,8 @@ fn stringifier(channel: &DuplexStream<~str, uint>) {\n     let mut value: uint;\n     loop {\n         value = channel.recv();\n-        channel.send(uint::to_str(value, 10u));\n-        if value == 0u { break; }\n+        channel.send(uint::to_str(value, 10));\n+        if value == 0 { break; }\n     }\n }\n ~~~~\n@@ -488,7 +484,7 @@ receiving. The `stringifier` function takes a `DuplexStream` that can\n send strings (the first type parameter) and receive `uint` messages\n (the second type parameter). The body itself simply loops, reading\n from the channel and then sending its response back.  The actual\n-response itself is simply the strified version of the received value,\n+response itself is simply the stringified version of the received value,\n `uint::to_str(value)`.\n \n Here is the code for the parent task:\n@@ -509,22 +505,24 @@ Here is the code for the parent task:\n \n let (from_child, to_child) = DuplexStream();\n \n-do spawn || {\n+do spawn |move to_child| {\n     stringifier(&to_child);\n };\n \n-from_child.send(22u);\n+from_child.send(22);\n assert from_child.recv() == ~\"22\";\n \n-from_child.send(23u);\n-from_child.send(0u);\n+from_child.send(23);\n+from_child.send(0);\n \n assert from_child.recv() == ~\"23\";\n assert from_child.recv() == ~\"0\";\n \n # }\n ~~~~\n \n-The parent task first calls `DuplexStream` to create a pair of bidirectional endpoints. It then uses `task::spawn` to create the child task, which captures one end of the communication channel.  As a result, both parent\n-and child can send and receive data to and from the other.\n+The parent task first calls `DuplexStream` to create a pair of bidirectional\n+endpoints. It then uses `task::spawn` to create the child task, which captures\n+one end of the communication channel.  As a result, both parent and child can\n+send and receive data to and from the other.\n "}, {"sha": "02927c4ddd1b5a5b320ee899f0e310ce7a5a116f", "filename": "doc/tutorial.md", "status": "modified", "additions": 636, "deletions": 620, "changes": 1256, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820", "patch": "@@ -1,10 +1,10 @@\n-% Rust Language Tutorial\n+% The Rust Language Tutorial\n \n # Introduction\n \n Rust is a programming language with a focus on type safety, memory\n safety, concurrency and performance. It is intended for writing\n-large-scale, high-performance software while preventing several\n+large-scale, high-performance software that is free from several\n classes of common errors. Rust has a sophisticated memory model that\n encourages efficient data structures and safe concurrency patterns,\n forbidding invalid memory accesses that would otherwise cause\n@@ -15,47 +15,44 @@ As a multi-paradigm language, Rust supports writing code in\n procedural, functional and object-oriented styles. Some of its\n pleasant high-level features include:\n \n-* **Pattern matching and algebraic data types (enums).** As\n-  popularized by functional languages, pattern matching on ADTs\n-  provides a compact and expressive way to encode program logic.\n-* **Type inference.** Type annotations on local variable\n-  declarations are optional.\n-* **Task-based concurrency.** Rust uses lightweight tasks that do\n-  not share memory.\n-* **Higher-order functions.** Rust's efficient and flexible closures\n-  are heavily relied on to provide iteration and other control\n-  structures\n-* **Parametric polymorphism (generics).** Functions and types can be\n-  parameterized over type variables with optional trait-based type\n-  constraints.\n-* **Trait polymorphism.** Rust's type system features a unique\n-  combination of type classes and object-oriented interfaces.\n+* **Type inference.** Type annotations on local variable declarations\n+  are optional.\n+* **Safe task-based concurrency.** Rust's lightweight tasks do not share\n+  memory, instead communicating through messages.\n+* **Higher-order functions.** Efficient and flexible closures provide\n+  iteration and other control structures\n+* **Pattern matching and algebraic data types.** Pattern matching on\n+  Rust's enumeration types (a more powerful version of C's enums,\n+  similar to algebraic data types in functional languages) is a\n+  compact and expressive way to encode program logic.\n+* **Polymorphism.** Rust has type-parametric functions and\n+  types, type classes and OO-style interfaces.\n \n ## Scope\n \n This is an introductory tutorial for the Rust programming language. It\n covers the fundamentals of the language, including the syntax, the\n-type system and memory model, and generics.  [Additional\n+type system and memory model, generics, and modules. [Additional\n tutorials](#what-next) cover specific language features in greater\n depth.\n \n-It assumes the reader is familiar with the basic concepts of\n+This tutorial assumes that the reader is familiar with the basic concepts of\n programming, and has programmed in one or more other languages\n-before. It will often make comparisons to other languages,\n+before. We will often compare Rust to other languages,\n particularly those in the C family.\n \n ## Conventions\n \n-Throughout the tutorial, words that indicate language keywords or\n-identifiers defined in example code are displayed in `code font`.\n+Throughout the tutorial, language keywords and identifiers defined in\n+example code are displayed in `code font`.\n \n Code snippets are indented, and also shown in a monospaced font. Not\n all snippets constitute whole programs. For brevity, we'll often show\n fragments of programs that don't compile on their own. To try them\n out, you might have to wrap them in `fn main() { ... }`, and make sure\n-they don't contain references to things that aren't actually defined.\n+they don't contain references to names that aren't actually defined.\n \n-> ***Warning:*** Rust is a language under heavy development. Notes\n+> ***Warning:*** Rust is a language under ongoing development. Notes\n > about potential changes to the language, implementation\n > deficiencies, and other caveats appear offset in blockquotes.\n \n@@ -75,15 +72,20 @@ Snapshot binaries are currently built and tested on several platforms:\n \n * Windows (7, Server 2008 R2), x86 only\n * Linux (various distributions), x86 and x86-64\n-* OSX 10.6 (\"Snow Leopard\") or 10.7 (\"Lion\"), x86 and x86-64\n+* OSX 10.6 (\"Snow Leopard\") or greater, x86 and x86-64\n \n You may find that other platforms work, but these are our \"tier 1\"\n supported build environments that are most likely to work.\n \n > ***Note:*** Windows users should read the detailed\n-> [getting started][wiki-start] notes on the wiki. Even when using\n-> the binary installer the Windows build requires a MinGW installation,\n-> the precise details of which are not discussed in this tutorial.\n+> \"[getting started][wiki-start]\" notes on the wiki. Even when using\n+> the binary installer, the Windows build requires a MinGW installation,\n+> the precise details of which are not discussed here. Finally, `rustc` may\n+> need to be [referred to as `rustc.exe`][bug-3319]. It's a bummer, I\n+> know.\n+\n+[bug-3319]: https://github.com/mozilla/rust/issues/3319\n+[wiki-start]:\thttps://github.com/mozilla/rust/wiki/Note-getting-started-developing-Rust\n \n To build from source you will also need the following prerequisite\n packages:\n@@ -94,8 +96,8 @@ packages:\n * gnu make 3.81 or later\n * curl\n \n-Assuming you're on a relatively modern *nix system and have met the\n-prerequisites, something along these lines should work.\n+If you've fulfilled those prerequisites, something along these lines\n+should work.\n \n ~~~~ {.notrust}\n $ wget http://dl.rust-lang.org/dist/rust-0.4.tar.gz\n@@ -108,7 +110,7 @@ $ make && make install\n You may need to use `sudo make install` if you do not normally have\n permission to modify the destination directory. The install locations\n can be adjusted by passing a `--prefix` argument to\n-`configure`. Various other options are also supported, pass `--help`\n+`configure`. Various other options are also supported: pass `--help`\n for more information on them.\n \n When complete, `make install` will place several programs into\n@@ -132,24 +134,12 @@ fn main() {\n \n If the Rust compiler was installed successfully, running `rustc\n hello.rs` will produce an executable called `hello` (or `hello.exe` on\n-Windows) which, upon running, will likely do exactly what you expect\n-(unless you are on Windows, in which case what it does is subject\n-to local weather conditions).\n-\n-> ***Note:*** That may or may not be hyperbole, but there are some\n-> 'gotchas' to be aware of on Windows. First, the MinGW environment\n-> must be set up perfectly. Please read [the\n-> wiki][wiki-started]. Second, `rustc` may need to be [referred to as\n-> `rustc.exe`][bug-3319]. It's a bummer, I know, and I am so very\n-> sorry.\n-\n-[bug-3319]: https://github.com/mozilla/rust/issues/3319\n-[wiki-started]:\thttps://github.com/mozilla/rust/wiki/Note-getting-started-developing-Rust\n+Windows) which, upon running, will likely do exactly what you expect.\n \n-The Rust compiler tries to provide useful information when it runs\n-into an error. If you modify the program to make it invalid (for\n-example, by changing `io::println` to some nonexistent function), and\n-then compile it, you'll see an error message like this:\n+The Rust compiler tries to provide useful information when it encounters an\n+error. If you introduce an error into the program (for example, by changing\n+`io::println` to some nonexistent function), and then compile it, you'll see\n+an error message like this:\n \n ~~~~ {.notrust}\n hello.rs:2:4: 2:16 error: unresolved name: io::print_with_unicorns\n@@ -160,7 +150,7 @@ hello.rs:2     io::print_with_unicorns(\"hello? yes, this is rust\");\n In its simplest form, a Rust program is a `.rs` file with some types\n and functions defined in it. If it has a `main` function, it can be\n compiled to an executable. Rust does not allow code that's not a\n-declaration to appear at the top level of the file\u2014all statements must\n+declaration to appear at the top level of the file: all statements must\n live inside a function.  Rust programs can also be compiled as\n libraries, and included in other programs.\n \n@@ -177,13 +167,13 @@ Sublime Text 2, available both [standalone][sublime] and through\n under `src/etc/kate`.\n \n There is ctags support via `src/etc/ctags.rust`, but many other\n-tools and editors are not provided for yet. If you end up writing a Rust\n+tools and editors are not yet supported. If you end up writing a Rust\n mode for your favorite editor, let us know so that we can link to it.\n \n [sublime]: http://github.com/dbp/sublime-rust\n [sublime-pkg]: http://wbond.net/sublime_packages/package_control\n \n-# Syntax Basics\n+# Syntax basics\n \n Assuming you've programmed in any C-family language (C++, Java,\n JavaScript, C#, or PHP), Rust will feel familiar. Code is arranged\n@@ -194,8 +184,8 @@ and mostly have the same precedence as in C; comments are again like C.\n \n The main surface difference to be aware of is that the condition at\n the head of control structures like `if` and `while` do not require\n-paretheses, while their bodies *must* be wrapped in\n-brackets. Single-statement, bracket-less bodies are not allowed.\n+parentheses, while their bodies *must* be wrapped in\n+braces. Single-statement, unbraced bodies are not allowed.\n \n ~~~~\n # fn recalibrate_universe() -> bool { true }\n@@ -210,9 +200,9 @@ fn main() {\n }\n ~~~~\n \n-The `let` keyword introduces a local variable. Variables are immutable\n-by default, so `let mut` can be used to introduce a local variable\n-that can be reassigned.\n+The `let` keyword introduces a local variable. Variables are immutable by\n+default. To introduce a local variable that you can re-assign later, use `let\n+mut` instead.\n \n ~~~~\n let hi = \"hi\";\n@@ -226,22 +216,22 @@ while count < 10 {\n \n Although Rust can almost always infer the types of local variables, you\n can specify a variable's type by following it with a colon, then the type\n-name. \n+name.\n \n ~~~~\n let monster_size: float = 57.8;\n let imaginary_size = monster_size * 10.0;\n let monster_size: int = 50;\n ~~~~\n \n-Local variables may shadow earlier declarations, as in the previous\n-example in which `monster_size` is first declared as a `float`\n-then a second `monster_size` is declared as an int. If you were to actually\n-compile this example though, the compiler will see that the second\n-`monster_size` is unused, assume that you have made a mistake, and issue\n-a warning. For occasions where unused variables are intentional, their\n-name may be prefixed with an underscore to silence the warning, like\n-`let _monster_size = 50;`.\n+Local variables may shadow earlier declarations, as in the previous example:\n+`monster_size` was first declared as a `float`, and then then a second\n+`monster_size` was declared as an int. If you were to actually compile this\n+example, though, the compiler will determine that the second `monster_size` is\n+unused and issue a warning (because this situation is likely to indicate a\n+programmer error). For occasions where unused variables are intentional, their\n+name may be prefixed with an underscore to silence the warning, like `let\n+_monster_size = 50;`.\n \n Rust identifiers follow the same rules as C; they start with an alphabetic\n character or an underscore, and after that may contain any sequence of\n@@ -288,10 +278,10 @@ let price =\n     };\n ~~~~\n \n-Both pieces of code are exactly equivalent\u2014they assign a value to\n+Both pieces of code are exactly equivalent: they assign a value to\n `price` depending on the condition that holds. Note that there\n-are not semicolons in the blocks of the second snippet. This is\n-important; the lack of a semicolon after the last statement in a\n+are no semicolons in the blocks of the second snippet. This is\n+important: the lack of a semicolon after the last statement in a\n braced block gives the whole block the value of that last expression.\n \n Put another way, the semicolon in Rust *ignores the value of an expression*.\n@@ -300,8 +290,10 @@ would simply assign `()` (nil or void) to `price`. But without the semicolon, ea\n branch has a different value, and `price` gets the value of the branch that\n was taken.\n \n-In short, everything that's not a declaration (`let` for variables,\n-`fn` for functions, et cetera) is an expression, including function bodies.\n+In short, everything that's not a declaration (declarations are `let` for\n+variables, `fn` for functions, and any top-level named items such as\n+[traits](#traits), [enum types](#enums), and [constants](#constants)) is an\n+expression, including function bodies.\n \n ~~~~\n fn is_four(x: int) -> bool {\n@@ -324,7 +316,7 @@ something\u2014in which case you'll have embedded it in a bigger statement.\n # fn foo() -> bool { true }\n # fn bar() -> bool { true }\n # fn baz() -> bool { true }\n-// `let` is not an expression, so it is semi-colon terminated;\n+// `let` is not an expression, so it is semicolon-terminated;\n let x = foo();\n \n // When used in statement position, bracy expressions do not\n@@ -356,7 +348,7 @@ This may sound intricate, but it is super-useful and will grow on you.\n The basic types include the usual boolean, integral, and floating-point types.\n \n ------------------------- -----------------------------------------------\n-`()`                      Nil, the type that has only a single value\n+`()`                      Unit, the type that has only a single value\n `bool`                    Boolean type, with values `true` and `false`\n `int`, `uint`             Machine-pointer-sized signed and unsigned integers\n `i8`, `i16`, `i32`, `i64` Signed integers with a specific size (in bits)\n@@ -389,6 +381,10 @@ of:\n `[mut T]`                 Mutable vector with unknown size\n ------------------------- -----------------------------------------------\n \n+> ***Note***: In the future, mutability for vectors may be defined by\n+> the slot that contains the vector, not the type of the vector itself,\n+> deprecating [mut T] syntax.\n+\n In function types, the return type is specified with an arrow, as in\n the type `fn() -> bool` or the function declaration `fn foo() -> bool\n { }`.  For functions that do not return a meaningful value, you can\n@@ -404,10 +400,15 @@ type MonsterSize = uint;\n This will provide a synonym, `MonsterSize`, for unsigned integers. It will not\n actually create a new, incompatible type\u2014`MonsterSize` and `uint` can be used\n interchangeably, and using one where the other is expected is not a type\n-error.\n+error. In that sense, types declared with `type` are *structural*: their\n+meaning follows from their structure, and their names are irrelevant in the\n+type system.\n \n-To create data types which are not synonyms, `struct` and `enum`\n-can be used. They're described in more detail below, but they look like this:\n+Sometimes, you want your data types to be *nominal* instead of structural: you\n+want their name to be part of their meaning, so that types with the same\n+structure but different names are not interchangeable. Rust has two ways to\n+create nominal data types: `struct` and `enum`. They're described in more\n+detail below, but they look like this:\n \n ~~~~\n enum HidingPlaces {\n@@ -426,12 +427,12 @@ enum MonsterSize = uint;      // a single-variant enum\n \n ## Literals\n \n-Integers can be written in decimal (`144`), hexadecimal (`0x90`), and\n+Integers can be written in decimal (`144`), hexadecimal (`0x90`), or\n binary (`0b10010000`) base. Each integral type has a corresponding literal\n suffix that can be used to indicate the type of a literal: `i` for `int`,\n `u` for `uint`, and `i8` for the `i8` type, etc.\n \n-In the absense of an integer literal suffix, Rust will infer the\n+In the absence of an integer literal suffix, Rust will infer the\n integer type based on type annotations and function signatures in the\n surrounding program. In the absence of any type information at all,\n Rust will assume that an unsuffixed integer literal has type\n@@ -449,24 +450,24 @@ a suffix, the literal is assumed to be of type `float`. Suffixes `f32`\n (32-bit) and `f64` (64-bit) can be used to create literals of a\n specific type.\n \n-The nil literal is written just like the type: `()`. The keywords\n+The unit literal is written just like the type: `()`. The keywords\n `true` and `false` produce the boolean literals.\n \n-Character literals are written between single quotes, as in `'x'`. Just as in\n+Character literals are written between single quotes, as in `'x'`. Just like\n C, Rust understands a number of character escapes, using the backslash\n character, such as `\\n`, `\\r`, and `\\t`. String literals,\n written between double quotes, allow the same escape sequences. Rust strings\n may contain newlines.\n \n ## Constants\n \n-Compile-time constants are declared with `const`. All scalar types,\n-like integers and floats, may be declared `const`, as well as fixed\n-length vectors, static strings (more on this later), and structs.\n-Constants may be declared in any scope and may refer to other\n-constants. Constant declarations are not type inferred, so must always\n-have a type annotation.  By convention they are written in all capital\n-letters.\n+Compile-time constants are declared with `const`. A constant may have any\n+scalar type (for example, integer or float). Other allowable constant types\n+are fixed-length vectors, static strings (more on this later), and\n+structs. Constants may be declared in any scope and may refer to other\n+constants. The compiler does not infer types for constants, so constants must\n+always be declared with a type annotation. By convention, they are written in\n+all capital letters.\n \n ~~~\n // Scalars can be constants\n@@ -490,7 +491,7 @@ const MY_STRUCTY_PASSWORD: Password = Password { value: MY_PASSWORD };\n \n Rust's set of operators contains very few surprises. Arithmetic is done with\n `*`, `/`, `%`, `+`, and `-` (multiply, divide, remainder, plus, minus). `-` is\n-also a unary prefix operator that does negation. As in C, the bit operators\n+also a unary prefix operator that negates numbers. As in C, the bit operators\n `>>`, `<<`, `&`, `|`, and `^` are also supported.\n \n Note that, if applied to an integer value, `!` flips all the bits (like `~` in\n@@ -512,21 +513,21 @@ assert y == 4u;\n ~~~~\n \n The main difference with C is that `++` and `--` are missing, and that\n-the logical bitwise operators have higher precedence \u2014 in C, `x & 2 > 0`\n+the logical bitwise operators have higher precedence\u2014in C, `x & 2 > 0`\n means `x & (2 > 0)`, but in Rust, it means `(x & 2) > 0`, which is\n-more likely what a novice expects.\n+more likely to be what a novice expects.\n \n ## Syntax extensions\n \n *Syntax extensions* are special forms that are not built into the language,\n but are instead provided by the libraries. To make it clear to the reader when\n-a syntax extension is being used, the names of all syntax extensions end with\n-`!`. The standard library defines a few syntax extensions, the most useful of\n-which is `fmt!`, a `sprintf`-style text formatter that is expanded at compile\n-time.\n+a name refers to a syntax extension, the names of all syntax extensions end\n+with `!`. The standard library defines a few syntax extensions, the most\n+useful of which is `fmt!`, a `sprintf`-style text formatter that an early\n+compiler phase expands statically.\n \n-`fmt!` supports most of the directives that [printf][pf] supports, but\n-will give you a compile-time error when the types of the directives\n+`fmt!` supports most of the directives that [printf][pf] supports, but unlike\n+printf, will give you a compile-time error when the types of the directives\n don't match the types of the arguments.\n \n ~~~~\n@@ -540,15 +541,16 @@ io::println(fmt!(\"what is this thing: %?\", mystery_object));\n \n [pf]: http://en.cppreference.com/w/cpp/io/c/fprintf\n \n-You can define your own syntax extensions with the macro system, which is out\n-of scope of this tutorial.\n+You can define your own syntax extensions with the macro system. For details, see the [macro tutorial][macros].\n+\n+[macros]: tutorial-macros.html\n \n # Control structures\n \n ## Conditionals\n \n-We've seen `if` pass by a few times already. To recap, braces are\n-compulsory, an optional `else` clause can be appended, and multiple\n+We've seen `if` expressions a few times already. To recap, braces are\n+compulsory, an `if` can have an optional `else` clause, and multiple\n `if`/`else` constructs can be chained together:\n \n ~~~~\n@@ -561,10 +563,10 @@ if false {\n }\n ~~~~\n \n-The condition given to an `if` construct *must* be of type boolean (no\n-implicit conversion happens). If the arms return a value, this value\n-must be of the same type for every arm in which control reaches the\n-end of the block:\n+The condition given to an `if` construct *must* be of type `bool` (no\n+implicit conversion happens). If the arms are blocks that have a\n+value, this value must be of the same type for every arm in which\n+control reaches the end of the block:\n \n ~~~~\n fn signum(x: int) -> int {\n@@ -577,9 +579,10 @@ fn signum(x: int) -> int {\n ## Pattern matching\n \n Rust's `match` construct is a generalized, cleaned-up version of C's\n-`switch` construct. You provide it with a value and a number of *arms*,\n-each labelled with a pattern, and the code will attempt to match each pattern\n-in order. For the first one that matches, the arm is executed.\n+`switch` construct. You provide it with a value and a number of\n+*arms*, each labelled with a pattern, and the code compares the value\n+against each pattern in order until one matches. The matching pattern\n+executes its corresponding arm.\n \n ~~~~\n # let my_number = 1;\n@@ -591,15 +594,19 @@ match my_number {\n }\n ~~~~\n \n-There is no 'falling through' between arms, as in C\u2014only one arm is\n-executed, and it doesn't have to explicitly `break` out of the\n+Unlike in C, there is no 'falling through' between arms: only one arm\n+executes, and it doesn't have to explicitly `break` out of the\n construct when it is finished.\n \n-The part to the left of the arrow `=>` is called the *pattern*. Literals are\n-valid patterns and will match only their own value. The pipe operator\n-(`|`) can be used to assign multiple patterns to a single arm. Ranges\n-of numeric literal patterns can be expressed with two dots, as in `M..N`. The\n-underscore (`_`) is a wildcard pattern that matches everything.\n+A `match` arm consists of a *pattern*, then an arrow `=>`, followed by\n+an *action* (expression). Literals are valid patterns and match only\n+their own value. A single arm may match multiple different patterns by\n+combining them with the pipe operator (`|`), so long as every pattern\n+binds the same set of variables. Ranges of numeric literal patterns\n+can be expressed with two dots, as in `M..N`. The underscore (`_`) is\n+a wildcard pattern that matches any single value. The asterisk (`*`)\n+is a different wildcard that can match one or more fields in an `enum`\n+variant.\n \n The patterns in an match arm are followed by a fat arrow, `=>`, then an\n expression to evaluate. Each case is separated by commas. It's often\n@@ -614,13 +621,14 @@ match my_number {\n }\n ~~~\n \n-`match` constructs must be *exhaustive*: they must have an arm covering every\n-possible case. For example, if the arm with the wildcard pattern was left off\n-in the above example, the typechecker would reject it.\n+`match` constructs must be *exhaustive*: they must have an arm\n+covering every possible case. For example, the typechecker would\n+reject the previous example if the arm with the wildcard pattern was\n+omitted.\n \n-A powerful application of pattern matching is *destructuring*, where\n-you use the matching to get at the contents of data types. Remember\n-that `(float, float)` is a tuple of two floats:\n+A powerful application of pattern matching is *destructuring*:\n+matching in order to bind names to the contents of data\n+types. Remember that `(float, float)` is a tuple of two floats:\n \n ~~~~\n fn angle(vector: (float, float)) -> float {\n@@ -633,37 +641,39 @@ fn angle(vector: (float, float)) -> float {\n }\n ~~~~\n \n-A variable name in a pattern matches everything, *and* binds that name\n-to the value of the matched thing inside of the arm block. Thus, `(0f,\n+A variable name in a pattern matches any value, *and* binds that name\n+to the value of the matched value inside of the arm's action. Thus, `(0f,\n y)` matches any tuple whose first element is zero, and binds `y` to\n the second element. `(x, y)` matches any tuple, and binds both\n-elements to a variable.\n+elements to variables.\n \n-Any `match` arm can have a guard clause (written `if EXPR`), which is\n-an expression of type `bool` that determines, after the pattern is\n-found to match, whether the arm is taken or not. The variables bound\n-by the pattern are available in this guard expression.\n+Any `match` arm can have a guard clause (written `if EXPR`), called a\n+*pattern guard*, which is an expression of type `bool` that\n+determines, after the pattern is found to match, whether the arm is\n+taken or not. The variables bound by the pattern are in scope in this\n+guard expression. The first arm in the `angle` example shows an\n+example of a pattern guard.\n \n You've already seen simple `let` bindings, but `let` is a little\n-fancier than you've been led to believe. It too supports destructuring\n-patterns. For example, you can say this to extract the fields from a\n-tuple, introducing two variables, `a` and `b`.\n+fancier than you've been led to believe. It, too, supports destructuring\n+patterns. For example, you can write this to extract the fields from a\n+tuple, introducing two variables at once: `a` and `b`.\n \n ~~~~\n # fn get_tuple_of_two_ints() -> (int, int) { (1, 1) }\n let (a, b) = get_tuple_of_two_ints();\n ~~~~\n \n-Let bindings only work with _irrefutable_ patterns, that is, patterns\n+Let bindings only work with _irrefutable_ patterns: that is, patterns\n that can never fail to match. This excludes `let` from matching\n-literals and most enum variants.\n+literals and most `enum` variants.\n \n ## Loops\n \n-`while` produces a loop that runs as long as its given condition\n-(which must have type `bool`) evaluates to true. Inside a loop, the\n-keyword `break` can be used to abort the loop, and `loop` can be used\n-to abort the current iteration and continue with the next.\n+`while` denotes a loop that iterates as long as its given condition\n+(which must have type `bool`) evaluates to `true`. Inside a loop, the\n+keyword `break` aborts the loop, and `loop` aborts the current\n+iteration and continues with the next.\n \n ~~~~\n let mut cake_amount = 8;\n@@ -672,7 +682,7 @@ while cake_amount > 0 {\n }\n ~~~~\n \n-`loop` is the preferred way of writing `while true`:\n+`loop` denotes an infinite loop, and is the preferred way of writing `while true`:\n \n ~~~~\n let mut x = 5;\n@@ -686,34 +696,21 @@ loop {\n This code prints out a weird sequence of numbers and stops as soon as\n it finds one that can be divided by five.\n \n-For more involved iteration, such as going over the elements of a\n-collection, Rust uses higher-order functions. We'll come back to those\n-in a moment.\n+For more involved iteration, such as enumerating the elements of a\n+collection, Rust uses [higher-order functions](#closures).\n \n-# Basic datatypes\n-\n-The core datatypes of Rust are structs, enums (tagged unions, algebraic data\n-types), and tuples. They are immutable by default.\n-\n-~~~~\n-struct Point { x: float, y: float }\n-\n-enum Shape {\n-    Circle(Point, float),\n-    Rectangle(Point, Point)\n-}\n-~~~~\n+# Data structures\n \n ## Structs\n \n Rust struct types must be declared before they are used using the `struct`\n syntax: `struct Name { field1: T1, field2: T2 [, ...] }`, where `T1`, `T2`,\n ... denote types. To construct a struct, use the same syntax, but leave off\n-the `struct`; for example: `Point { x: 1.0, y: 2.0 }`.\n+the `struct`: for example: `Point { x: 1.0, y: 2.0 }`.\n \n Structs are quite similar to C structs and are even laid out the same way in\n-memory (so you can read from a Rust struct in C, and vice-versa). The dot\n-operator is used to access struct fields (`mypoint.x`).\n+memory (so you can read from a Rust struct in C, and vice-versa). Use the dot\n+operator to access struct fields, as in `mypoint.x`.\n \n Fields that you want to mutate must be explicitly marked `mut`.\n \n@@ -727,7 +724,7 @@ struct Stack {\n With a value of such a type, you can do `mystack.head += 1`. If `mut` were\n omitted from the type, such an assignment would result in a type error.\n \n-Structs can be destructured in `match` patterns. The basic syntax is\n+`match` patterns destructure structs. The basic syntax is\n `Name {fieldname: pattern, ...}`:\n \n ~~~~\n@@ -754,9 +751,9 @@ match mypoint {\n }\n ~~~\n \n-Structs are the only type in Rust that may have user-defined destructors,\n-using `drop` blocks, inside of which the struct's value may be referred\n-to with the name `self`.\n+Structs are the only type in Rust that may have user-defined\n+destructors, defined with `drop` blocks. Inside a `drop`, the name\n+`self` refers to the struct's value.\n \n ~~~\n struct TimeBomb {\n@@ -790,16 +787,16 @@ A value of this type is either a `Circle`, in which case it contains a\n `Point` struct and a float, or a `Rectangle`, in which case it contains\n two `Point` structs. The run-time representation of such a value\n includes an identifier of the actual form that it holds, much like the\n-'tagged union' pattern in C, but with better ergonomics.\n+'tagged union' pattern in C, but with better static guarantees.\n \n-The above declaration will define a type `Shape` that can be used to\n-refer to such shapes, and two functions, `Circle` and `Rectangle`,\n-which can be used to construct values of the type (taking arguments of\n-the specified types). So `Circle(Point {x: 0f, y: 0f}, 10f)` is the way to\n+The above declaration will define a type `Shape` that can refer to\n+such shapes, and two functions, `Circle` and `Rectangle`, which can be\n+used to construct values of the type (taking arguments of the\n+specified types). So `Circle(Point {x: 0f, y: 0f}, 10f)` is the way to\n create a new circle.\n \n-Enum variants need not have type parameters. This, for example, is\n-equivalent to a C enum:\n+Enum variants need not have type parameters. This `enum` declaration,\n+for example, is equivalent to a C enum:\n \n ~~~~\n enum Direction {\n@@ -810,12 +807,12 @@ enum Direction {\n }\n ~~~~\n \n-This will define `North`, `East`, `South`, and `West` as constants,\n+This declaration defines `North`, `East`, `South`, and `West` as constants,\n all of which have type `Direction`.\n \n-When an enum is C-like, that is, when none of the variants have\n-parameters, it is possible to explicitly set the discriminator values\n-to an integer value:\n+When an enum is C-like (that is, when none of the variants have\n+parameters), it is possible to explicitly set the discriminator values\n+to a constant value:\n \n ~~~~\n enum Color {\n@@ -828,16 +825,19 @@ enum Color {\n If an explicit discriminator is not specified for a variant, the value\n defaults to the value of the previous variant plus one. If the first\n variant does not have a discriminator, it defaults to 0. For example,\n-the value of `North` is 0, `East` is 1, etc.\n+the value of `North` is 0, `East` is 1, `South` is 2, and `West` is 3.\n \n-When an enum is C-like the `as` cast operator can be used to get the\n-discriminator's value.\n+When an enum is C-like, you can apply the `as` cast operator to\n+convert it to its discriminator value as an int.\n \n <a name=\"single_variant_enum\"></a>\n \n-There is a special case for enums with a single variant. These are\n-used to define new types in such a way that the new name is not just a\n-synonym for an existing type, but its own distinct type. If you say:\n+There is a special case for enums with a single variant, which are\n+sometimes called \"newtype-style enums\" (after Haskell's \"newtype\"\n+feature). These are used to define new types in such a way that the\n+new name is not just a synonym for an existing type, but its own\n+distinct type: `type` creates a structural synonym, while this form of\n+`enum` creates a nominal synonym. If you say:\n \n ~~~~\n enum GizmoId = int;\n@@ -849,7 +849,7 @@ That is a shorthand for this:\n enum GizmoId { GizmoId(int) }\n ~~~~\n \n-Enum types like this can have their content extracted with the\n+You can extract the contents of such an enum type with the\n dereference (`*`) unary operator:\n \n ~~~~\n@@ -858,45 +858,56 @@ let my_gizmo_id: GizmoId = GizmoId(10);\n let id_int: int = *my_gizmo_id;\n ~~~~\n \n+Types like this can be useful to differentiate between data that have\n+the same type but must be used in different ways.\n+\n+~~~~\n+enum Inches = int;\n+enum Centimeters = int;\n+~~~~\n+\n+The above definitions allow for a simple way for programs to avoid\n+confusing numbers that correspond to different units.\n+\n For enum types with multiple variants, destructuring is the only way to\n get at their contents. All variant constructors can be used as\n patterns, as in this definition of `area`:\n \n ~~~~\n-# type Point = {x: float, y: float};\n+# struct Point {x: float, y: float}\n # enum Shape { Circle(Point, float), Rectangle(Point, Point) }\n fn area(sh: Shape) -> float {\n     match sh {\n         Circle(_, size) => float::consts::pi * size * size,\n-        Rectangle({x, y}, {x: x2, y: y2}) => (x2 - x) * (y2 - y)\n+        Rectangle(Point {x, y}, Point {x: x2, y: y2}) => (x2 - x) * (y2 - y)\n     }\n }\n ~~~~\n \n-Like other patterns, a lone underscore ignores individual fields.\n-Ignoring all fields of a variant can be written `Circle(*)`. As in\n-their introductory form, nullary enum patterns are written without\n+You can write a lone `_` to ignore an individual fields, and can\n+ignore all fields of a variant like: `Circle(*)`. As in their\n+introduction form, nullary enum patterns are written without\n parentheses.\n \n ~~~~\n-# type Point = {x: float, y: float};\n+# struct Point {x: float, y: float}\n # enum Direction { North, East, South, West }\n fn point_from_direction(dir: Direction) -> Point {\n     match dir {\n-        North => {x:  0f, y:  1f},\n-        East  => {x:  1f, y:  0f},\n-        South => {x:  0f, y: -1f},\n-        West  => {x: -1f, y:  0f}\n+        North => Point {x:  0f, y:  1f},\n+        East  => Point {x:  1f, y:  0f},\n+        South => Point {x:  0f, y: -1f},\n+        West  => Point {x: -1f, y:  0f}\n     }\n }\n ~~~~\n \n ## Tuples\n \n Tuples in Rust behave exactly like structs, except that their fields\n-do not have names (and can thus not be accessed with dot notation).\n+do not have names. Thus, you cannot access their fields with dot notation.\n Tuples can have any arity except for 0 or 1 (though you may consider\n-nil, `()`, as the empty tuple if you like).\n+unit, `()`, as the empty tuple if you like).\n \n ~~~~\n let mytup: (int, int, float) = (10, 20, 30.0);\n@@ -909,10 +920,11 @@ match mytup {\n \n We've already seen several function definitions. Like all other static\n declarations, such as `type`, functions can be declared both at the\n-top level and inside other functions (or modules, which we'll come\n-back to [later](#modules-and-crates)). They are introduced with the\n-`fn` keyword, the type of arguments are specified following colons and\n-the return type follows the arrow.\n+top level and inside other functions (or in modules, which we'll come\n+back to [later](#modules-and-crates)). The `fn` keyword introduces a\n+function. A function has an argument list, which is a parenthesized\n+list of `expr: type` pairs separated by commas. An arrow `->`\n+separates the argument list and the function's return type.\n \n ~~~~\n fn line(a: int, b: int, x: int) -> int {\n@@ -931,9 +943,12 @@ fn line(a: int, b: int, x: int) -> int {\n }\n ~~~~\n \n-Functions that do not return a value are said to return nil, `()`,\n-and both the return type and the return value may be omitted from\n-the definition. The following two functions are equivalent.\n+It's better Rust style to write a return value this way instead of\n+writing an explicit `return`. The utility of `return` comes in when\n+returning early from a function. Functions that do not return a value\n+are said to return nil, `()`, and both the return type and the return\n+value may be omitted from the definition. The following two functions\n+are equivalent.\n \n ~~~~\n fn do_nothing_the_hard_way() -> () { return (); }\n@@ -951,10 +966,12 @@ assert 8  == line(5, 3, 1);\n assert () == oops(5, 3, 1);\n ~~~~\n \n-Methods are like functions, except that they are defined for a specific\n-'self' type (like 'this' in C++). Calling a method is done with\n-dot notation, as in `my_vec.len()`. Methods may be defined on most\n-Rust types with the `impl` keyword. As an example, lets define a draw\n+Methods are like functions, except that they have an implicit argument\n+called `self`, which has the type that the method's receiver has. The\n+`self` argument is like 'this' in C++. An expression with dot\n+notation, as in `my_vec.len()`, denotes a method\n+call. Implementations, written with the `impl` keyword, can define\n+methods on most Rust types. As an example, let's define a `draw`\n method on our `Shape` enum.\n \n ~~~\n@@ -984,43 +1001,44 @@ s.draw();\n ~~~\n \n This defines an _implementation_ for `Shape` containing a single\n-method, `draw`. In most most respects the `draw` method is defined\n-like any other function, with the exception of the name `self`. `self`\n-is a special value that is automatically defined in each method,\n+method, `draw`. In most respects the `draw` method is defined\n+like any other function, except for the name `self`. `self`\n+is a special value that is automatically in scope inside each method,\n referring to the value being operated on. If we wanted we could add\n additional methods to the same impl, or multiple impls for the same\n type. We'll discuss methods more in the context of [traits and\n generics](#generics).\n \n-> ***Note:*** The method definition syntax will change to require\n-> declaring the self type explicitly, as the first argument.\n+> ***Note:*** In the future, the method definition syntax will change to\n+> require declaring the `self` type explicitly, as the first argument.\n \n # The Rust memory model\n \n-At this junction let's take a detour to explain the concepts involved\n+At this junction, let's take a detour to explain the concepts involved\n in Rust's memory model. We've seen some of Rust's pointer sigils (`@`,\n `~`, and `&`) float by in a few examples, and we aren't going to get\n much further without explaining them. Rust has a very particular\n approach to memory management that plays a significant role in shaping\n-the \"feel\" of the language. Understanding the memory landscape will\n-illuminate several of Rust's unique features as we encounter them.\n+the subjective experience of programming in the\n+language. Understanding the memory landscape will illuminate several\n+of Rust's unique features as we encounter them.\n \n Rust has three competing goals that inform its view of memory:\n \n-* Memory safety: memory that is managed by and is accessible to the\n-  Rust language must be guaranteed to be valid; under normal\n-  circumstances it must be impossible for Rust to trigger a\n-  segmentation fault or leak memory\n-* Performance: high-performance low-level code must be able to employ\n-  a number of allocation strategies; low-performance high-level code\n-  must be able to employ a single, garbage-collection-based, heap\n-  allocation strategy\n-* Concurrency: Rust must maintain memory safety guarantees, even for\n-  code running in parallel\n+* Memory safety: Memory that the Rust language can observe must be\n+  guaranteed to be valid. Under normal circumstances, it must be\n+  impossible for Rust to trigger a segmentation fault or leak memory.\n+* Performance: High-performance low-level code must be able to use\n+  a number of different allocation strategies. Tracing garbage collection must be\n+  optional and, if it is not desired, memory safety must not be compromised.\n+  Less performance-critical, high-level code should be able to employ a single,\n+  garbage-collection-based, heap allocation strategy.\n+* Concurrency: Rust code must be free of in-memory data races. (Note that other\n+  types of races are still possible.)\n \n ## How performance considerations influence the memory model\n \n-Most languages that offer strong memory safety guarantees rely upon a\n+Most languages that offer strong memory safety guarantees rely on a\n garbage-collected heap to manage all of the objects. This approach is\n straightforward both in concept and in implementation, but has\n significant costs. Languages that follow this path tend to\n@@ -1030,18 +1048,20 @@ boxes_: memory allocated on the heap whose lifetime is managed\n by the garbage collector.\n \n By comparison, languages like C++ offer very precise control over\n-where objects are allocated. In particular, it is common to put them\n+where objects are allocated. In particular, it is common to allocate them\n directly on the stack, avoiding expensive heap allocation. In Rust\n-this is possible as well, and the compiler will use a clever _pointer\n-lifetime analysis_ to ensure that no variable can refer to stack\n+this is possible as well, and the compiler uses a [clever _pointer\n+lifetime analysis_][borrow] to ensure that no variable can refer to stack\n objects after they are destroyed.\n \n+[borrow]: tutorial-borrowed-ptr.html\n+\n ## How concurrency considerations influence the memory model\n \n Memory safety in a concurrent environment involves avoiding race\n conditions between two threads of execution accessing the same\n-memory. Even high-level languages often require programmers to\n-correctly employ locking to ensure that a program is free of races.\n+memory. Even high-level languages often require programmers to make\n+correct use of locking to ensure that a program is free of races.\n \n Rust starts from the position that memory cannot be shared between\n tasks. Experience in other languages has proven that isolating each\n@@ -1050,30 +1070,32 @@ easy for programmers to reason about. Heap isolation has the\n additional benefit that garbage collection must only be done\n per-heap. Rust never \"stops the world\" to reclaim memory.\n \n-Complete isolation of heaps between tasks would, however, mean that any data\n-transferred between tasks must be copied. While this is a fine and\n-useful way to implement communication between tasks, it is also very\n-inefficient for large data structures.  Because of this, Rust also\n-employs a global _exchange heap_. Objects allocated in the exchange\n-heap have _ownership semantics_, meaning that there is only a single\n-variable that refers to them. For this reason, they are referred to as\n-_owned boxes_. All tasks may allocate objects on the exchange heap,\n-then transfer ownership of those objects to other tasks, avoiding\n-expensive copies.\n+Complete isolation of heaps between tasks would, however, mean that\n+any data transferred between tasks must be copied. While this is a\n+fine and useful way to implement communication between tasks, it is\n+also very inefficient for large data structures. To reduce the amount\n+of copying, Rust also uses a global _exchange heap_. Objects allocated\n+in the exchange heap have _ownership semantics_, meaning that there is\n+only a single variable that refers to them. For this reason, they are\n+referred to as _owned boxes_. All tasks may allocate objects on the\n+exchange heap, then transfer ownership of those objects to other\n+tasks, avoiding expensive copies.\n \n # Boxes and pointers\n \n-In contrast to a lot of modern languages, aggregate types like structs\n-and enums are _not_ represented as pointers to allocated memory in\n-Rust. They are, as in C and C++, represented directly. This means that\n-if you `let x = Point {x: 1f, y: 1f};`, you are creating a struct on the\n-stack. If you then copy it into a data structure, the whole struct is\n-copied, not just a pointer.\n+Many modern languages have a so-called \"uniform representation\" for\n+aggregate types like structs and enums, so as to represent these types\n+as pointers to heap memory by default. In contrast, Rust, like C and\n+C++, represents such types directly. Another way to say this is that\n+aggregate data in Rust are *unboxed*. This means that if you `let x =\n+Point {x: 1f, y: 1f};`, you are creating a struct on the stack. If you\n+then copy it into a data structure, you copy the entire struct, not\n+just a pointer.\n \n For small structs like `Point`, this is usually more efficient than\n-allocating memory and going through a pointer. But for big structs, or\n+allocating memory and indirecting through a pointer. But for big structs, or\n those with mutable fields, it can be useful to have a single copy on\n-the heap, and refer to that through a pointer.\n+the stack or on the heap, and refer to that through a pointer.\n \n Rust supports several types of pointers. The safe pointer types are\n `@T` for managed boxes allocated on the local heap, `~T`, for\n@@ -1086,16 +1108,15 @@ All pointer types can be dereferenced with the `*` unary operator.\n > ***Note***: You may also hear managed boxes referred to as 'shared\n > boxes' or 'shared pointers', and owned boxes as 'unique boxes/pointers'.\n > Borrowed pointers are sometimes called 'region pointers'. The preferred\n-> terminology is as presented here.\n+> terminology is what we present here.\n \n ## Managed boxes\n \n-Managed boxes are pointers to heap-allocated, garbage collected memory.\n-Creating a managed box is done by simply applying the unary `@`\n-operator to an expression. The result of the expression will be boxed,\n-resulting in a box of the right type. Copying a shared box, as happens\n-during assignment, only copies a pointer, never the contents of the\n-box.\n+Managed boxes are pointers to heap-allocated, garbage collected\n+memory.  Applying the unary `@` operator to an expression creates a\n+managed box. The resulting box contains the result of the\n+expression. Copying a shared box, as happens during assignment, only\n+copies a pointer, never the contents of the box.\n \n ~~~~\n let x: @int = @10; // New box\n@@ -1105,9 +1126,8 @@ let y = x; // Copy of a pointer to the same box\n // then the allocation will be freed.\n ~~~~\n \n-Any type that contains managed boxes or other managed types is\n-considered _managed_. Managed types are the only types that can\n-construct cyclic data structures in Rust, such as doubly-linked lists.\n+A _managed_ type is either of the form `@T` for some type `T`, or any\n+type that contains managed boxes or other managed types.\n \n ~~~\n // A linked list node\n@@ -1135,19 +1155,19 @@ node3.prev = SomeNode(node2);\n \n Managed boxes never cross task boundaries.\n \n-> ***Note:*** managed boxes are currently reclaimed through reference\n-> counting and cycle collection, but we will switch to a tracing\n-> garbage collector eventually.\n+> ***Note:*** Currently, the Rust compiler generates code to reclaim\n+> managed boxes through reference counting and a cycle collector, but\n+> we will switch to a tracing garbage collector eventually.\n \n ## Owned boxes\n \n-In contrast to managed boxes, owned boxes have a single owning memory\n-slot and thus two owned boxes may not refer to the same memory. All\n-owned boxes across all tasks are allocated on a single _exchange\n-heap_, where their uniquely owned nature allows them to be passed\n-between tasks efficiently.\n+In contrast with managed boxes, owned boxes have a single owning\n+memory slot and thus two owned boxes may not refer to the same\n+memory. All owned boxes across all tasks are allocated on a single\n+_exchange heap_, where their uniquely owned nature allows tasks to\n+exchange them efficiently.\n \n-Because owned boxes are uniquely owned, copying them involves allocating\n+Because owned boxes are uniquely owned, copying them requires allocating\n a new owned box and duplicating the contents. Copying owned boxes\n is expensive so the compiler will complain if you do so without writing\n the word `copy`.\n@@ -1167,11 +1187,11 @@ let z = *x + *y;\n assert z == 20;\n ~~~~\n \n-This is where the 'move' operator comes in. It is similar to\n-`copy`, but it de-initializes its source. Thus, the owned box can move\n-from `x` to `y`, without violating the constraint that it only has a\n-single owner (if you used assignment instead of the move operator, the\n-box would, in principle, be copied).\n+This is where the 'move' operator comes in. It is similar to `copy`,\n+but it de-initializes its source. Thus, the owned box can move from\n+`x` to `y`, without violating the constraint that it only has a single\n+owner (using assignment instead of the move operator would, in\n+principle, copy the box).\n \n ~~~~ {.xfail-test}\n let x = ~10;\n@@ -1185,16 +1205,16 @@ to other tasks. The sending task will give up ownership of the box,\n and won't be able to access it afterwards. The receiving task will\n become the sole owner of the box.\n \n-> ***Note:*** this discussion of copying vs moving does not account\n+> ***Note:*** This discussion of copying vs. moving does not account\n > for the \"last use\" rules that automatically promote copy operations\n-> to moves. Last use is expected to be removed from the language in\n+> to moves. We plan to remove last use from the language in\n > favor of explicit moves.\n \n ## Borrowed pointers\n \n Rust borrowed pointers are a general purpose reference/pointer type,\n similar to the C++ reference type, but guaranteed to point to valid\n-memory. In contrast to owned pointers, where the holder of a unique\n+memory. In contrast with owned pointers, where the holder of a unique\n pointer is the owner of the pointed-to memory, borrowed pointers never\n imply ownership. Pointers may be borrowed from any type, in which case\n the pointer is guaranteed not to outlive the value it points to.\n@@ -1207,9 +1227,9 @@ struct Point {\n }\n ~~~~\n \n-We can use this simple definition to allocate points in many ways. For\n-example, in this code, each of these three local variables contains a\n-point, but allocated in a different place:\n+We can use this simple definition to allocate points in many different\n+ways. For example, in this code, each of these three local variables\n+contains a point, but allocated in a different location:\n \n ~~~\n # struct Point { x: float, y: float }\n@@ -1293,7 +1313,8 @@ let sum = *managed + *owned + *borrowed;\n ~~~\n \n Dereferenced mutable pointers may appear on the left hand side of\n-assignments, in which case the value they point to is modified.\n+assignments. Such an assignment modifies the value that the pointer\n+points to.\n \n ~~~\n let managed = @mut 10;\n@@ -1308,8 +1329,8 @@ let borrowed = &mut value;\n ~~~\n \n Pointers have high operator precedence, but lower precedence than the\n-dot operator used for field and method access. This can lead to some\n-awkward code filled with parenthesis.\n+dot operator used for field and method access. This precedence order\n+can sometimes make code awkward and parenthesis-filled.\n \n ~~~\n # struct Point { x: float, y: float }\n@@ -1321,9 +1342,9 @@ let rect = &Rectangle(*start, *end);\n let area = (*rect).area();\n ~~~\n \n-To combat this ugliness the dot operator performs _automatic pointer\n-dereferencing_ on the receiver (the value on the left hand side of the\n-dot), so in most cases dereferencing the receiver is not necessary.\n+To combat this ugliness the dot operator applies _automatic pointer\n+dereferencing_ to the receiver (the value on the left hand side of the\n+dot), so in most cases, explicitly dereferencing the receiver is not necessary.\n \n ~~~\n # struct Point { x: float, y: float }\n@@ -1335,32 +1356,32 @@ let rect = &Rectangle(*start, *end);\n let area = rect.area();\n ~~~\n \n-Auto-dereferencing is performed through any number of pointers. If you\n-felt inclined you could write something silly like\n+You can write an expression that dereferences any number of pointers\n+automatically. For example, if you felt inclined, you could write\n+something silly like\n \n ~~~\n # struct Point { x: float, y: float }\n let point = &@~Point { x: 10f, y: 20f };\n io::println(fmt!(\"%f\", point.x));\n ~~~\n \n-The indexing operator (`[]`) is also auto-dereferencing.\n+The indexing operator (`[]`) also auto-dereferences.\n \n # Vectors and strings\n \n-Vectors are a contiguous section of memory containing zero or more\n+A vector is a contiguous section of memory containing zero or more\n values of the same type. Like other types in Rust, vectors can be\n stored on the stack, the local heap, or the exchange heap. Borrowed\n pointers to vectors are also called 'slices'.\n \n ~~~\n-enum Crayon {\n-    Almond, AntiqueBrass, Apricot,\n-    Aquamarine, Asparagus, AtomicTangerine,\n-    BananaMania, Beaver, Bittersweet,\n-    Black, BlizzardBlue, Blue\n-}\n-\n+# enum Crayon {\n+#     Almond, AntiqueBrass, Apricot,\n+#     Aquamarine, Asparagus, AtomicTangerine,\n+#     BananaMania, Beaver, Bittersweet,\n+#     Black, BlizzardBlue, Blue\n+# }\n // A fixed-size stack vector\n let stack_crayons: [Crayon * 3] = [Almond, AntiqueBrass, Apricot];\n \n@@ -1387,18 +1408,17 @@ let your_crayons = ~[BananaMania, Beaver, Bittersweet];\n // Add two vectors to create a new one\n let our_crayons = my_crayons + your_crayons;\n \n-// += will append to a vector, provided it leves\n-// in a mutable slot\n+// += will append to a vector, provided it lives in a mutable slot\n let mut my_crayons = move my_crayons;\n my_crayons += your_crayons;\n ~~~~\n \n > ***Note:*** The above examples of vector addition use owned\n > vectors. Some operations on slices and stack vectors are\n-> not well supported yet, owned vectors are often the most\n+> not yet well-supported. Owned vectors are often the most\n > usable.\n \n-Indexing into vectors is done with square brackets:\n+Square brackets denote indexing into a vector:\n \n ~~~~\n # enum Crayon { Almond, AntiqueBrass, Apricot,\n@@ -1413,7 +1433,7 @@ match crayons[0] {\n ~~~~\n \n The elements of a vector _inherit the mutability of the vector_,\n-and as such individual elements may not be reassigned when the\n+and as such, individual elements may not be reassigned when the\n vector lives in an immutable slot.\n \n ~~~ {.xfail-test}\n@@ -1443,13 +1463,13 @@ mutable_crayons[0] = Apricot;\n This is a simple example of Rust's _dual-mode data structures_, also\n referred to as _freezing and thawing_.\n \n-Strings are implemented with vectors of `u8`, though they have a distinct\n-type. They support most of the same allocation options as\n-vectors, though the string literal without a storage sigil, e.g.\n-`\"foo\"` is treated differently than a comparable vector (`[foo]`).\n-Whereas plain vectors are stack-allocated fixed-length vectors,\n-plain strings are region pointers to read-only memory. Strings\n-are always immutable.\n+Strings are implemented with vectors of `u8`, though they have a\n+distinct type. They support most of the same allocation options as\n+vectors, though the string literal without a storage sigil (for\n+example, `\"foo\"`) is treated differently than a comparable vector\n+(`[foo]`).  Whereas plain vectors are stack-allocated fixed-length\n+vectors, plain strings are region pointers to read-only\n+memory. All strings are immutable.\n \n ~~~\n // A plain string is a slice to read-only (static) memory\n@@ -1482,9 +1502,9 @@ and [`core::str`]. Here are some examples.\n # fn unwrap_crayon(c: Crayon) -> int { 0 }\n # fn eat_crayon_wax(i: int) { }\n # fn store_crayon_in_nasal_cavity(i: uint, c: Crayon) { }\n-# fn crayon_to_str(c: Crayon) -> ~str { ~\"\" }\n+# fn crayon_to_str(c: Crayon) -> &str { \"\" }\n \n-let crayons = &[Almond, AntiqueBrass, Apricot];\n+let crayons = [Almond, AntiqueBrass, Apricot];\n \n // Check the length of the vector\n assert crayons.len() == 3;\n@@ -1512,8 +1532,9 @@ if favorite_crayon_name.len() > 5 {\n # Closures\n \n Named functions, like those we've seen so far, may not refer to local\n-variables declared outside the function - they do not \"close over\n-their environment\". For example, you couldn't write the following:\n+variables declared outside the function: they do not close over their\n+environment (sometimes referred to as \"capturing\" variables in their\n+environment). For example, you couldn't write the following:\n \n ~~~~ {.ignore}\n let foo = 10;\n@@ -1536,10 +1557,10 @@ let closure = |arg| println(fmt!(\"captured_var=%d, arg=%d\", captured_var, arg));\n call_closure_with_ten(closure);\n ~~~~\n \n-Closures begin with the argument list between bars and are followed by\n+Closures begin with the argument list between vertical bars and are followed by\n a single expression. The types of the arguments are generally omitted,\n as is the return type, because the compiler can almost always infer\n-them. In the rare case where the compiler needs assistance though, the\n+them. In the rare case where the compiler needs assistance, though, the\n arguments and return types may be annotated.\n \n ~~~~\n@@ -1548,7 +1569,7 @@ let bloop = |well, oh: mygoodness| -> what_the { fail oh(well) };\n ~~~~\n \n There are several forms of closure, each with its own role. The most\n-common, called a _stack closure_, has type `fn&` and can directly\n+common, called a _stack closure_, has type `&fn` and can directly\n access local variables in the enclosing scope.\n \n ~~~~\n@@ -1559,31 +1580,33 @@ let mut max = 0;\n Stack closures are very efficient because their environment is\n allocated on the call stack and refers by pointer to captured\n locals. To ensure that stack closures never outlive the local\n-variables to which they refer, they can only be used in argument\n-position and cannot be stored in structures nor returned from\n-functions. Despite the limitations stack closures are used\n+variables to which they refer, stack closures are not\n+first-class. That is, they can only be used in argument position; they\n+cannot be stored in data structures or returned from\n+functions. Despite these limitations, stack closures are used\n pervasively in Rust code.\n \n ## Managed closures\n \n When you need to store a closure in a data structure, a stack closure\n will not do, since the compiler will refuse to let you store it. For\n this purpose, Rust provides a type of closure that has an arbitrary\n-lifetime, written `fn@` (boxed closure, analogous to the `@` pointer\n-type described earlier).\n+lifetime, written `@fn` (boxed closure, analogous to the `@` pointer\n+type described earlier). This type of closure *is* first-class.\n \n A managed closure does not directly access its environment, but merely\n copies out the values that it closes over into a private data\n structure. This means that it can not assign to these variables, and\n-will not 'see' updates to them.\n+cannot observe updates to them.\n \n This code creates a closure that adds a given string to its argument,\n returns it from a function, and then calls it:\n \n ~~~~\n # extern mod std;\n-fn mk_appender(suffix: ~str) -> fn@(~str) -> ~str {\n-    return fn@(s: ~str) -> ~str { s + suffix };\n+fn mk_appender(suffix: ~str) -> @fn(~str) -> ~str {\n+    // The compiler knows that we intend this closure to be of type @fn\n+    return |s| s + suffix;\n }\n \n fn main() {\n@@ -1592,59 +1615,44 @@ fn main() {\n }\n ~~~~\n \n-This example uses the long closure syntax, `fn@(s: ~str) ...`,\n-making the fact that we are declaring a box closure explicit. In\n-practice boxed closures are usually defined with the short closure\n-syntax introduced earlier, in which case the compiler will infer\n-the type of closure. Thus our managed closure example could also\n-be written:\n-\n-~~~~\n-fn mk_appender(suffix: ~str) -> fn@(~str) -> ~str {\n-    return |s| s + suffix;\n-}\n-~~~~\n-\n ## Owned closures\n \n-Owned closures, written `fn~` in analogy to the `~` pointer type,\n+Owned closures, written `~fn` in analogy to the `~` pointer type,\n hold on to things that can safely be sent between\n processes. They copy the values they close over, much like managed\n-closures, but they also 'own' them\u2014meaning no other code can access\n+closures, but they also own them: that is, no other code can access\n them. Owned closures are used in concurrent code, particularly\n-for spawning [tasks](#tasks).\n+for spawning [tasks][tasks].\n+\n+[tasks]: tutorial-tasks.html\n \n ## Closure compatibility\n \n-A nice property of Rust closures is that you can pass any kind of\n+Rust closures have a convenient subtyping property: you can pass any kind of\n closure (as long as the arguments and return types match) to functions\n that expect a `fn()`. Thus, when writing a higher-order function that\n-wants to do nothing with its function argument beyond calling it, you\n-should almost always specify the type of that argument as `fn()`, so\n-that callers have the flexibility to pass whatever they want.\n+only calls its function argument, and does nothing else with it, you\n+should almost always declare the type of that argument as `fn()`. That way,\n+callers may pass any kind of closure.\n \n ~~~~\n fn call_twice(f: fn()) { f(); f(); }\n-call_twice(|| { ~\"I am an inferred stack closure\"; } );\n-call_twice(fn&() { ~\"I am also a stack closure\"; } );\n-call_twice(fn@() { ~\"I am a managed closure\"; });\n-call_twice(fn~() { ~\"I am an owned closure\"; });\n-fn bare_function() { ~\"I am a plain function\"; }\n-call_twice(bare_function);\n+let closure = || { \"I'm a closure, and it doesn't matter what type I am\"; };\n+fn function() { \"I'm a normal function\"; }\n+call_twice(closure);\n+call_twice(function);\n ~~~~\n \n > ***Note:*** Both the syntax and the semantics will be changing\n-> in small ways. At the moment they can be unsound in multiple\n+> in small ways. At the moment they can be unsound in some\n > scenarios, particularly with non-copyable types.\n \n ## Do syntax\n \n-The `do` expression is syntactic sugar for use with functions which\n-take a closure as a final argument, because closures in Rust\n-are so frequently used in combination with higher-order\n-functions.\n+The `do` expression provides a way to treat higher-order functions\n+(functions that take closures as arguments) as control structures.\n \n-Consider this function which iterates over a vector of\n+Consider this function that iterates over a vector of\n integers, passing in a pointer to each integer in the vector:\n \n ~~~~\n@@ -1657,20 +1665,22 @@ fn each(v: &[int], op: fn(v: &int)) {\n }\n ~~~~\n \n-The reason we pass in a *pointer* to an integer rather than the\n-integer itself is that this is how the actual `each()` function for\n-vectors works.  Using a pointer means that the function can be used\n-for vectors of any type, even large structs that would be impractical\n-to copy out of the vector on each iteration.  As a caller, if we use a\n-closure to provide the final operator argument, we can write it in a\n-way that has a pleasant, block-like structure.\n+As an aside, the reason we pass in a *pointer* to an integer rather\n+than the integer itself is that this is how the actual `each()`\n+function for vectors works. `vec::each` though is a\n+[generic](#generics) function, so must be efficient to use for all\n+types. Passing the elements by pointer avoids copying potentially\n+large objects.\n+\n+As a caller, if we use a closure to provide the final operator\n+argument, we can write it in a way that has a pleasant, block-like\n+structure.\n \n ~~~~\n # fn each(v: &[int], op: fn(v: &int)) { }\n-# fn do_some_work(i: int) { }\n-each(&[1, 2, 3], |n| {\n-    debug!(\"%i\", *n);\n-    do_some_work(*n);\n+# fn do_some_work(i: &int) { }\n+each([1, 2, 3], |n| {\n+    do_some_work(n);\n });\n ~~~~\n \n@@ -1679,19 +1689,21 @@ call that can be written more like a built-in control structure:\n \n ~~~~\n # fn each(v: &[int], op: fn(v: &int)) { }\n-# fn do_some_work(i: int) { }\n-do each(&[1, 2, 3]) |n| {\n-    debug!(\"%i\", *n);\n-    do_some_work(*n);\n+# fn do_some_work(i: &int) { }\n+do each([1, 2, 3]) |n| {\n+    do_some_work(n);\n }\n ~~~~\n \n The call is prefixed with the keyword `do` and, instead of writing the\n-final closure inside the argument list it is moved outside of the\n-parenthesis where it looks visually more like a typical block of\n+final closure inside the argument list, it appears outside of the\n+parentheses, where it looks more like a typical block of\n code.\n \n-`do` is often used for task spawning.\n+`do` is a convenient way to create tasks with the `task::spawn`\n+function.  `spawn` has the signature `spawn(fn: ~fn())`. In other\n+words, it is a function that takes an owned closure that takes no\n+arguments.\n \n ~~~~\n use task::spawn;\n@@ -1701,9 +1713,9 @@ do spawn() || {\n }\n ~~~~\n \n-That's nice, but look at all those bars and parentheses - that's two empty\n-argument lists back to back. Wouldn't it be great if they weren't\n-there?\n+Look at all those bars and parentheses - that's two empty argument\n+lists back to back. Since that is so unsightly, empty argument lists\n+may be omitted from `do` expressions.\n \n ~~~~\n # use task::spawn;\n@@ -1712,14 +1724,12 @@ do spawn {\n }\n ~~~~\n \n-Empty argument lists can be omitted from `do` expressions.\n-\n ## For loops\n \n-Most iteration in Rust is done with `for` loops. Like `do`,\n-`for` is a nice syntax for doing control flow with closures.\n-Additionally, within a `for` loop, `break`, `loop`, and `return`\n-work just as they do with `while` and `loop`.\n+The most common way to express iteration in Rust is with a `for`\n+loop. Like `do`, `for` is a nice syntax for describing control flow\n+with closures.  Additionally, within a `for` loop, `break`, `loop`,\n+and `return` work just as they do with `while` and `loop`.\n \n Consider again our `each` function, this time improved to\n break early when the iteratee returns `false`:\n@@ -1741,35 +1751,35 @@ And using this function to iterate over a vector:\n ~~~~\n # use each = vec::each;\n # use println = io::println;\n-each(&[2, 4, 8, 5, 16], |n| {\n+each([2, 4, 8, 5, 16], |n| {\n     if *n % 2 != 0 {\n-        println(~\"found odd number!\");\n+        println(\"found odd number!\");\n         false\n     } else { true }\n });\n ~~~~\n \n With `for`, functions like `each` can be treated more\n-like builtin looping structures. When calling `each`\n+like built-in looping structures. When calling `each`\n in a `for` loop, instead of returning `false` to break\n out of the loop, you just write `break`. To skip ahead\n to the next iteration, write `loop`.\n \n ~~~~\n # use each = vec::each;\n # use println = io::println;\n-for each(&[2, 4, 8, 5, 16]) |n| {\n+for each([2, 4, 8, 5, 16]) |n| {\n     if *n % 2 != 0 {\n-        println(~\"found odd number!\");\n+        println(\"found odd number!\");\n         break;\n     }\n }\n ~~~~\n \n As an added bonus, you can use the `return` keyword, which is not\n normally allowed in closures, in a block that appears as the body of a\n-`for` loop \u2014 this will cause a return to happen from the outer\n-function, not just the loop body.\n+`for` loop: the meaning of `return` in such a block is to return from\n+the enclosing function, not just the loop body.\n \n ~~~~\n # use each = vec::each;\n@@ -1789,34 +1799,38 @@ fn contains(v: &[int], elt: int) -> bool {\n \n # Generics\n \n-Throughout this tutorial, we've been defining functions that act only on\n-specific data types. With type parameters we can also define functions whose\n-arguments represent generic types, and which can be invoked with a variety\n-of types. Consider a generic `map` function.\n+Throughout this tutorial, we've been defining functions that act only\n+on specific data types. With type parameters we can also define\n+functions whose arguments have generic types, and which can be invoked\n+with a variety of types. Consider a generic `map` function, which\n+takes a function `function` and a vector `vector` and returns a new\n+vector consisting of the result of applying `function` to each element\n+of `vector`:\n \n ~~~~\n fn map<T, U>(vector: &[T], function: fn(v: &T) -> U) -> ~[U] {\n     let mut accumulator = ~[];\n     for vec::each(vector) |element| {\n         accumulator.push(function(element));\n     }\n-    return accumulator;\n+    return (move accumulator);\n }\n ~~~~\n \n When defined with type parameters, as denoted by `<T, U>`, this\n function can be applied to any type of vector, as long as the type of\n-`function`'s argument and the type of the vector's content agree with\n+`function`'s argument and the type of the vector's contents agree with\n each other.\n \n Inside a generic function, the names of the type parameters\n-(capitalized by convention) stand for opaque types. You can't look\n-inside them, but you can pass them around.  Note that instances of\n-generic types are often passed by pointer.  For example, the\n-parameter `function()` is supplied with a pointer to a value of type\n-`T` and not a value of type `T` itself.  This ensures that the\n-function works with the broadest set of types possible, since some\n-types are expensive or illegal to copy and pass by value.\n+(capitalized by convention) stand for opaque types. All you can do\n+with instances of these types is pass them around: you can't apply any\n+operations to them or pattern-match on them. Note that instances of\n+generic types are often passed by pointer.  For example, the parameter\n+`function()` is supplied with a pointer to a value of type `T` and not\n+a value of type `T` itself.  This ensures that the function works with\n+the broadest set of types possible, since some types are expensive or\n+illegal to copy and pass by value.\n \n Generic `type`, `struct`, and `enum` declarations follow the same pattern:\n \n@@ -1834,15 +1848,16 @@ enum Maybe<T> {\n }\n ~~~~\n \n-These declarations produce valid types like `Set<int>`, `Stack<int>`\n-and `Maybe<int>`.\n+These declarations can be instantiated to valid types like `Set<int>`,\n+`Stack<int>` and `Maybe<int>`.\n \n-Generic functions in Rust are compiled to very efficient runtime code\n-through a process called _monomorphisation_. This is a fancy way of\n-saying that, for each generic function you call, the compiler\n-generates a specialized version that is optimized specifically for the\n-argument types. In this respect Rust's generics have similar\n-performance characteristics to C++ templates.\n+The Rust compiler compiles generic functions very efficiently by\n+*monomorphizing* them. *Monomorphization* is a fancy name for a simple\n+idea: generate a separate copy of each generic function at each call\n+site where it is called, a copy that is specialized to the argument\n+types and can thus be optimized specifically for them. In this\n+respect, Rust's generics have similar performance characteristics to\n+C++ templates.\n \n ## Traits\n \n@@ -1851,15 +1866,19 @@ are very limited. After all, since the function doesn't know what\n types it is operating on, it can't safely modify or query their\n values. This is where _traits_ come into play. Traits are Rust's most\n powerful tool for writing polymorphic code. Java developers will see\n-in them aspects of Java interfaces, and Haskellers will notice their\n-similarities to type classes.\n-\n-As motivation, let us consider copying in Rust. Perhaps surprisingly,\n-the copy operation is not defined for all Rust types. In\n-particular, types with user-defined destructors cannot be copied,\n-either implicitly or explicitly, and neither can types that own other\n-types containing destructors (the actual mechanism for defining\n-destructors will be discussed elsewhere).\n+them as similar to Java interfaces, and Haskellers will notice their\n+similarities to type classes. Rust's traits are a form of *bounded\n+polymorphism*: a trait is a way of limiting the set of possible types\n+that a type parameter could refer to.\n+\n+As motivation, let us consider copying in Rust. The `copy` operation\n+is not defined for all Rust types. One reason is user-defined\n+destructors: copying a type that has a destructor could result in the\n+destructor running multiple times. Therefore, types with user-defined\n+destructors cannot be copied, either implicitly or explicitly, and\n+neither can types that own other types containing destructors (see the\n+section on [structs](#structs) for the actual mechanism for defining\n+destructors).\n \n This complicates handling of generic functions. If you have a type\n parameter `T`, can you copy values of that type? In Rust, you can't,\n@@ -1872,8 +1891,8 @@ fn head_bad<T>(v: &[T]) -> T {\n }\n ~~~~\n \n-We can tell the compiler though that the `head` function is only for\n-copyable types with the `Copy` trait.\n+However, we can tell the compiler that the `head` function is only for\n+copyable types: that is, those that have the `Copy` trait.\n \n ~~~~\n // This does\n@@ -1885,14 +1904,17 @@ fn head<T: Copy>(v: &[T]) -> T {\n This says that we can call `head` on any type `T` as long as that type\n implements the `Copy` trait. When instantiating a generic function,\n you can only instantiate it with types that implement the correct\n-trait, so you could not apply `head` to a type with a destructor.\n+trait, so you could not apply `head` to a type with a\n+destructor. (`Copy` is a special trait that is built in to the\n+compiler, making it possible for the compiler to enforce this\n+restriction.)\n \n While most traits can be defined and implemented by user code, three\n traits are automatically derived and implemented for all applicable\n types by the compiler, and may not be overridden:\n \n-* `Copy` - Types that can be copied, either implicitly, or using the\n-  `copy` expression. All types are copyable unless they are classes\n+* `Copy` - Types that can be copied: either implicitly, or explicitly with the\n+  `copy` operator. All types are copyable unless they are classes\n   with destructors or otherwise contain classes with destructors.\n \n * `Send` - Sendable (owned) types. All types are sendable unless they\n@@ -1919,7 +1941,7 @@ trait Printable {\n ~~~~\n \n Traits may be implemented for specific types with [impls]. An impl\n-that implements a trait includes the name of the trait at the start of \n+that implements a trait includes the name of the trait at the start of\n the definition, as in the following impls of `Printable` for `int`\n and `~str`.\n \n@@ -1931,15 +1953,15 @@ impl int: Printable {\n     fn print() { io::println(fmt!(\"%d\", self)) }\n }\n \n-impl ~str: Printable {\n+impl &str: Printable {\n     fn print() { io::println(self) }\n }\n \n # 1.print();\n-# (~\"foo\").print();\n+# (\"foo\").print();\n ~~~~\n \n-Methods defined in an implementation of a trait may be called just as\n+Methods defined in an implementation of a trait may be called just like\n any other method, using dot notation, as in `1.print()`. Traits may\n themselves contain type parameters. A trait for generalized sequence\n types might look like the following:\n@@ -1961,14 +1983,14 @@ impl<T> ~[T]: Seq<T> {\n The implementation has to explicitly declare the type parameter that\n it binds, `T`, before using it to specify its trait type. Rust\n requires this declaration because the `impl` could also, for example,\n-specify an implementation of `Seq<int>`. The trait type -- appearing\n-after the colon in the `impl` -- *refers* to a type, rather than\n+specify an implementation of `Seq<int>`. The trait type (appearing\n+after the colon in the `impl`) *refers* to a type, rather than\n defining one.\n \n The type parameters bound by a trait are in scope in each of the\n method declarations. So, re-declaring the type parameter\n-`T` as an explicit type parameter for `len` -- in either the trait or\n-the impl -- would be a compile-time error.\n+`T` as an explicit type parameter for `len`, in either the trait or\n+the impl, would be a compile-time error.\n \n Within a trait definition, `self` is a special type that you can think\n of as a type parameter. An implementation of the trait for any given\n@@ -1988,16 +2010,17 @@ impl int: Eq {\n }\n ~~~~\n \n-Notice that in the trait definition, `equals` takes a `self` type\n-argument, whereas, in the impl, `equals` takes an `int` type argument,\n-and uses `self` as the name of the receiver (analogous to the `this` pointer\n-in C++).\n+Notice that in the trait definition, `equals` takes a parameter of\n+type `self`. In contrast, in the `impl`, `equals` takes a parameter of\n+type `int`, and uses `self` as the name of the receiver (analogous to\n+the `this` pointer in C++).\n \n ## Bounded type parameters and static method dispatch\n \n-Traits give us a language for talking about the abstract capabilities\n-of types, and we can use this to place _bounds_ on type parameters,\n-so that we can then operate on generic types.\n+Traits give us a language for defining predicates on types, or\n+abstract properties that types can have. We can use this language to\n+define _bounds_ on type parameters, so that we can then operate on\n+generic types.\n \n ~~~~\n # trait Printable { fn print(); }\n@@ -2008,14 +2031,14 @@ fn print_all<T: Printable>(printable_things: ~[T]) {\n }\n ~~~~\n \n-By declaring `T` as conforming to the `Printable` trait (as we earlier\n-did with `Copy`), it becomes possible to call methods from that trait\n-on values of that type inside the function. It will also cause a\n+Declaring `T` as conforming to the `Printable` trait (as we earlier\n+did with `Copy`) makes it possible to call methods from that trait\n+on values of type `T` inside the function. It will also cause a\n compile-time error when anyone tries to call `print_all` on an array\n whose element type does not have a `Printable` implementation.\n \n Type parameters can have multiple bounds by separating them with spaces,\n-as in this version of `print_all` that makes copies of elements.\n+as in this version of `print_all` that copies elements.\n \n ~~~\n # trait Printable { fn print(); }\n@@ -2044,13 +2067,11 @@ However, consider this function:\n # type Circle = int; type Rectangle = int;\n # impl int: Drawable { fn draw() {} }\n # fn new_circle() -> int { 1 }\n-\n trait Drawable { fn draw(); }\n \n fn draw_all<T: Drawable>(shapes: ~[T]) {\n     for shapes.each |shape| { shape.draw(); }\n }\n-\n # let c: Circle = new_circle();\n # draw_all(~[c]);\n ~~~~\n@@ -2062,36 +2083,38 @@ needed, a trait name can alternately be used as a type.\n \n ~~~~\n # trait Drawable { fn draw(); }\n-fn draw_all(shapes: ~[@Drawable]) {\n+fn draw_all(shapes: &[@Drawable]) {\n     for shapes.each |shape| { shape.draw(); }\n }\n ~~~~\n \n-In this example there is no type parameter. Instead, the `@Drawable`\n-type is used to refer to any managed box value that implements the\n-`Drawable` trait. To construct such a value, you use the `as` operator\n-to cast a value to a trait type:\n+In this example, there is no type parameter. Instead, the `@Drawable`\n+type denotes any managed box value that implements the `Drawable`\n+trait. To construct such a value, you use the `as` operator to cast a\n+value to a trait type:\n \n ~~~~\n # type Circle = int; type Rectangle = bool;\n # trait Drawable { fn draw(); }\n # fn new_circle() -> Circle { 1 }\n # fn new_rectangle() -> Rectangle { true }\n-# fn draw_all(shapes: ~[Drawable]) {}\n+# fn draw_all(shapes: &[@Drawable]) {}\n \n impl @Circle: Drawable { fn draw() { ... } }\n \n impl @Rectangle: Drawable { fn draw() { ... } }\n \n let c: @Circle = @new_circle();\n let r: @Rectangle = @new_rectangle();\n-draw_all(~[c as @Drawable, r as @Drawable]);\n+draw_all([c as @Drawable, r as @Drawable]);\n ~~~~\n \n-Note that, like strings and vectors, trait types have dynamic size\n-and may only be used via one of the pointer types. In turn, the\n-`impl` is defined for `@Circle` and `@Rectangle` instead of for\n-just `Circle` and `Rectangle`. Other pointer types work as well.\n+We omit the code for `new_circle` and `new_rectangle`; imagine that\n+these just return `Circle`s and `Rectangle`s with a default size. Note\n+that, like strings and vectors, trait types have dynamic size and may\n+only be referred to via one of the pointer types. That's why the `impl` is\n+defined for `@Circle` and `@Rectangle` instead of for just `Circle`\n+and `Rectangle`. Other pointer types work as well.\n \n ~~~{.xfail-test}\n # type Circle = int; type Rectangle = int;\n@@ -2107,74 +2130,136 @@ let owny: ~Drawable = ~new_circle() as ~Drawable;\n let stacky: &Drawable = &new_circle() as &Drawable;\n ~~~\n \n-> ***Note:*** Other pointer types actually _do not_ work here. This is\n+> ***Note:*** Other pointer types actually _do not_ work here yet. This is\n > an evolving corner of the language.\n \n Method calls to trait types are _dynamically dispatched_. Since the\n compiler doesn't know specifically which functions to call at compile\n-time it uses a lookup table (vtable) to decide at runtime which\n-method to call.\n+time it uses a lookup table (also known as a vtable or dictionary) to\n+select the method to call at runtime.\n \n This usage of traits is similar to Java interfaces.\n \n # Modules and crates\n \n-The Rust namespace is divided into modules. Each source file starts\n-with its own module.\n-\n-## Local modules\n-\n-The `mod` keyword can be used to open a new, local module. In the\n-example below, `chicken` lives in the module `farm`, so, unless you\n-explicitly import it, you must refer to it by its long name,\n-`farm::chicken`.\n+The Rust namespace is arranged in a hierarchy of modules. Each source\n+(.rs) file represents a single module and may in turn contain\n+additional modules.\n \n ~~~~\n-#[legacy_exports]\n mod farm {\n-    fn chicken() -> ~str { ~\"cluck cluck\" }\n-    fn cow() -> ~str { ~\"mooo\" }\n+    pub fn chicken() -> &str { \"cluck cluck\" }\n+    pub fn cow() -> &str { \"mooo\" }\n }\n+\n fn main() {\n     io::println(farm::chicken());\n }\n ~~~~\n \n-Modules can be nested to arbitrary depth.\n+The contents of modules can be imported into the current scope\n+with the `use` keyword, optionally giving it an alias. `use`\n+may appear at the beginning of crates, `mod`s, `fn`s, and other\n+blocks.\n+\n+~~~\n+# mod farm { pub fn chicken() { } }\n+# fn main() {\n+// Bring `chicken` into scope\n+use farm::chicken;\n+\n+fn chicken_farmer() {\n+    // The same, but name it `my_chicken`\n+    use my_chicken = farm::chicken;\n+    ...\n+}\n+# }\n+~~~\n+\n+These farm animal functions have a new keyword, `pub`, attached to\n+them.  The `pub` keyword modifies an item's visibility, making it\n+visible outside its containing module. An expression with `::`, like\n+`farm::chicken`, can name an item outside of its containing\n+module. Items, such as those declared with `fn`, `struct`, `enum`,\n+`type`, or `const`, are module-private by default.\n+\n+Visibility restrictions in Rust exist only at module boundaries. This\n+is quite different from most object-oriented languages that also\n+enforce restrictions on objects themselves. That's not to say that\n+Rust doesn't support encapsulation: both struct fields and methods can\n+be private.  But this encapsulation is at the module level, not the\n+struct level. Note that fields and methods are _public_ by default.\n+\n+~~~\n+mod farm {\n+# pub fn make_me_a_farm() -> farm::Farm { farm::Farm { chickens: ~[], cows: ~[], farmer: Human(0) } }\n+    pub struct Farm {\n+        priv mut chickens: ~[Chicken],\n+        priv mut cows: ~[Cow],\n+        farmer: Human\n+    }\n+\n+    // Note - visibility modifiers on impls currently have no effect\n+    impl Farm {\n+        priv fn feed_chickens() { ... }\n+        priv fn feed_cows() { ... }\n+        fn add_chicken(c: Chicken) { ... }\n+    }\n+\n+    pub fn feed_animals(farm: &Farm) {\n+        farm.feed_chickens();\n+        farm.feed_cows();\n+    }\n+}\n+\n+fn main() {\n+     let f = make_me_a_farm();\n+     f.add_chicken(make_me_a_chicken());\n+     farm::feed_animals(&f);\n+     f.farmer.rest();\n+}\n+# type Chicken = int;\n+# type Cow = int;\n+# enum Human = int;\n+# fn make_me_a_farm() -> farm::Farm { farm::make_me_a_farm() }\n+# fn make_me_a_chicken() -> Chicken { 0 }\n+# impl Human { fn rest() { } }\n+~~~\n \n ## Crates\n \n-The unit of independent compilation in Rust is the crate. Libraries\n-tend to be packaged as crates, and your own programs may consist of\n-one or more crates.\n+The unit of independent compilation in Rust is the crate: rustc\n+compiles a single crate at a time, from which it produces either a\n+library or executable.\n \n When compiling a single `.rs` file, the file acts as the whole crate.\n You can compile it with the `--lib` compiler switch to create a shared\n library, or without, provided that your file contains a `fn main`\n somewhere, to create an executable.\n \n-It is also possible to include multiple files in a crate. For this\n-purpose, you create a `.rc` crate file, which references any number of\n-`.rs` code files. A crate file could look like this:\n+Larger crates typically span multiple files and are compiled from\n+a crate (.rc) file. Crate files contain their own syntax for loading\n+modules from .rs files and typically include metadata about the crate.\n \n-~~~~ {.ignore}\n+~~~~ { .xfail-test }\n #[link(name = \"farm\", vers = \"2.5\", author = \"mjh\")];\n #[crate_type = \"lib\"];\n+\n mod cow;\n mod chicken;\n mod horse;\n ~~~~\n \n Compiling this file will cause `rustc` to look for files named\n-`cow.rs`, `chicken.rs`, `horse.rs` in the same directory as the `.rc`\n-file, compile them all together, and, depending on the presence of the\n-`crate_type = \"lib\"` attribute, output a shared library or an executable.\n-(If the line `#[crate_type = \"lib\"];` was omitted, `rustc` would create an\n-executable.)\n+`cow.rs`, `chicken.rs`, and `horse.rs` in the same directory as the\n+`.rc` file, compile them all together, and, based on the presence of\n+the `crate_type = \"lib\"` attribute, output a shared library or an\n+executable.  (If the line `#[crate_type = \"lib\"];` was omitted,\n+`rustc` would create an executable.)\n \n-The `#[link(...)]` part provides meta information about the module,\n-which other crates can use to load the right module. More about that\n-later.\n+The `#[link(...)]` attribute provides meta information about the\n+module, which other crates can use to load the right module. More\n+about that later.\n \n To have a nested directory structure for your source files, you can\n nest mods in your `.rc` file:\n@@ -2191,56 +2276,67 @@ The compiler will now look for `poultry/chicken.rs` and\n and `poultry::turkey`. You can also provide a `poultry.rs` to add\n content to the `poultry` module itself.\n \n-The compiler then builds the crate as a platform-specific shared library or\n-executable which can be distributed.\n+When compiling .rc files, if rustc finds a .rs file with the same\n+name, then that .rs file provides the top-level content of the crate.\n \n-## Using other crates\n+~~~ {.xfail-test}\n+// foo.rc\n+#[link(name = \"foo\", vers=\"1.0\")];\n \n-Having compiled a crate that contains the `#[crate_type = \"lib\"]`\n-attribute, you can use it in another crate with a `use`\n-directive. We've already seen `extern mod std` in several of the\n-examples, which loads in the [standard library][std].\n+mod bar;\n+~~~\n \n-[std]: http://doc.rust-lang.org/doc/std/index/General.html\n+~~~ {.xfail-test}\n+// foo.rs\n+fn main() { bar::baz(); }\n+~~~\n \n-`use` directives can appear in a crate file, or at the top level of a\n-single-file `.rs` crate. They will cause the compiler to search its\n-library search path (which you can extend with `-L` switch) for a Rust\n-crate library with the right name.\n+> ***Note***: The way rustc looks for .rs files to pair with .rc\n+> files is a major source of confusion and will change. It's likely\n+> that the crate and source file grammars will merge.\n \n-It is possible to provide more specific information when using an\n-external crate.\n+> ***Note***: The way that directory modules are handled will also\n+> change. The code for directory modules currently lives in a .rs\n+> file with the same name as the directory, _next to_ the directory.\n+> A new scheme will make that file live _inside_ the directory.\n \n-~~~~ {.ignore}\n-extern mod myfarm (name = \"farm\", vers = \"2.7\");\n-~~~~\n+## Using other crates\n+\n+The `extern mod` directive lets you use a crate (once it's been\n+compiled into a library) from inside another crate. `extern mod` can\n+appear at the top of a crate file or at the top of modules. It will\n+cause the compiler to look in the library search path (which you can\n+extend with the `-L` switch) for a compiled Rust library with the\n+right name, then add a module with that crate's name into the local\n+scope.\n+\n+For example, `extern mod std` links the [standard library].\n+\n+[standard library]: std/index.html\n \n-When a comma-separated list of name/value pairs is given after `use`,\n-these are matched against the attributes provided in the `link`\n-attribute of the crate file, and a crate is only used when the two\n-match. A `name` value can be given to override the name used to search\n-for the crate. So the above would import the `farm` crate under the\n-local name `myfarm`.\n+When a comma-separated list of name/value pairs appears after `extern\n+mod`, the compiler front-end matches these pairs against the\n+attributes provided in the `link` attribute of the crate file. The\n+front-end will only select this crate for use if the actual pairs\n+match the declared attributes. You can provide a `name` value to\n+override the name used to search for the crate.\n \n Our example crate declared this set of `link` attributes:\n \n-~~~~ {.ignore}\n+~~~~ {.xfail-test}\n #[link(name = \"farm\", vers = \"2.5\", author = \"mjh\")];\n ~~~~\n \n-The version does not match the one provided in the `use` directive, so\n-unless the compiler can find another crate with the right version\n-somewhere, it will complain that no matching crate was found.\n-\n-## The core library\n-\n-A set of basic library routines, mostly related to built-in datatypes\n-and the task system, are always implicitly linked and included in any\n-Rust program.\n+Which you can then link with any (or all) of the following:\n \n-This library is documented [here][core].\n+~~~~ {.xfail-test}\n+extern mod farm;\n+extern mod my_farm (name = \"farm\", vers = \"2.5\");\n+extern mod my_auxiliary_farm (name = \"farm\", author = \"mjh\");\n+~~~~\n \n-[core]: core/index.html\n+If any of the requested metadata do not match, then the crate\n+will not be compiled successfully.\n \n ## A minimal example\n \n@@ -2250,13 +2346,13 @@ these two files:\n ~~~~\n // world.rs\n #[link(name = \"world\", vers = \"1.0\")];\n-fn explore() -> ~str { ~\"world\" }\n+pub fn explore() -> &str { \"world\" }\n ~~~~\n \n-~~~~ {.ignore}\n+~~~~ {.xfail-test}\n // main.rs\n extern mod world;\n-fn main() { io::println(~\"hello \" + world::explore()); }\n+fn main() { io::println(\"hello \" + world::explore()); }\n ~~~~\n \n Now compile and run like this (adjust to your platform if necessary):\n@@ -2268,113 +2364,33 @@ Now compile and run like this (adjust to your platform if necessary):\n \"hello world\"\n ~~~~\n \n-## Importing\n-\n-When using identifiers from other modules, it can get tiresome to\n-qualify them with the full module path every time (especially when\n-that path is several modules deep). Rust allows you to import\n-identifiers at the top of a file, module, or block.\n+Notice that the library produced contains the version in the filename\n+as well as an inscrutable string of alphanumerics. These are both\n+part of Rust's library versioning scheme. The alphanumerics are\n+a hash representing the crate metadata.\n \n-~~~~\n-extern mod std;\n-use io::println;\n-fn main() {\n-    println(~\"that was easy\");\n-}\n-~~~~\n-\n-\n-It is also possible to import just the name of a module (`use\n-std::list;`, then use `list::find`), to import all identifiers exported\n-by a given module (`use io::*`), or to import a specific set\n-of identifiers (`use math::{min, max, pi}`).\n-\n-Rust uses different namespaces for modules, types, and values.  You\n-can also rename an identifier when importing using the `=` operator:\n-\n-~~~~\n-use prnt = io::println;\n-~~~~\n-\n-## Exporting\n-\n-By default, a module exports everything that it defines. This can be\n-restricted with `export` directives at the top of the module or file.\n-\n-~~~~\n-mod enc {\n-    export encrypt, decrypt;\n-    const SUPER_SECRET_NUMBER: int = 10;\n-    fn encrypt(n: int) -> int { n + SUPER_SECRET_NUMBER }\n-    fn decrypt(n: int) -> int { n - SUPER_SECRET_NUMBER }\n-}\n-~~~~\n-\n-This defines a rock-solid encryption algorithm. Code outside of the\n-module can refer to the `enc::encrypt` and `enc::decrypt` identifiers\n-just fine, but it does not have access to `enc::super_secret_number`.\n-\n-## Resolution\n-\n-The resolution process in Rust simply goes up the chain of contexts,\n-looking for the name in each context. Nested functions and modules\n-create new contexts inside their parent function or module. A file\n-that's part of a bigger crate will have that crate's context as its\n-parent context.\n-\n-Identifiers can shadow each other. In this program, `x` is of type\n-`int`:\n-\n-~~~~\n-type MyType = ~str;\n-fn main() {\n-    type MyType = int;\n-    let x: MyType = 17;\n-}\n-~~~~\n-\n-An `use` directive will only import into the namespaces for which\n-identifiers are actually found. Consider this example:\n-\n-~~~~\n-mod foo {\n-   fn bar() {}\n-}\n-\n-fn main() {\n-    let bar = 10;\n-\n-    {\n-        use foo::bar;\n-        let quux = bar;\n-        assert quux == 10;\n-    }\n-}\n-~~~~\n+## The core library\n \n-When resolving the type name `bar` in the `quux` definition, the\n-resolver will first look at local block context for `baz`. This has an\n-import named `bar`, but that's function, not a value, So it continues\n-to the `baz` function context and finds a value named `bar` defined\n-there.\n+The Rust [core] library is the language runtime and contains\n+required memory management and task scheduling code as well as a\n+number of modules necessary for effective usage of the primitive\n+types. Methods on [vectors] and [strings], implementations of most\n+comparison and math operators, and pervasive types like [`Option`]\n+and [`Result`] live in core.\n \n-Normally, multiple definitions of the same identifier in a scope are\n-disallowed. Local variables defined with `let` are an exception to\n-this\u2014multiple `let` directives can redefine the same variable in a\n-single scope. When resolving the name of such a variable, the most\n-recent definition is used.\n+All Rust programs link to the core library and import its contents,\n+as if the following were written at the top of the crate.\n \n-~~~~\n-fn main() {\n-    let x = 10;\n-    let x = x + 10;\n-    assert x == 20;\n-}\n-~~~~\n+~~~ {.xfail-test}\n+extern mod core;\n+use core::*;\n+~~~\n \n-This makes it possible to rebind a variable without actually mutating\n-it, which is mostly useful for destructuring (which can rebind, but\n-not assign).\n+[core]: core/index.html\n+[vectors]: core/vec.html\n+[strings]: core/str.html\n+[`Option`]: core/option.html\n+[`Result`]: core/result.html\n \n # What next?\n "}, {"sha": "bb6457dd493e78b0e7f94868e44e359fed64e8de", "filename": "man/rustc.1", "status": "modified", "additions": 20, "deletions": 23, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/man%2Frustc.1", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/man%2Frustc.1", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/man%2Frustc.1?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820", "patch": "@@ -1,4 +1,4 @@\n-.TH RUSTC \"1\" \"July 2012\" \"rustc 0.3\" \"User Commands\"\n+.TH RUSTC \"1\" \"October 2012\" \"rustc 0.4\" \"User Commands\"\n .SH NAME\n rustc \\- rust compiler\n .SH SYNOPSIS\n@@ -42,6 +42,9 @@ Compile a library crate\n \\fB\\-\\-ls\\fR\n List the symbols defined by a compiled library crate\n .TP\n+\\fB\\-\\-jit\\fR\n+Execute using JIT (experimental)\n+.TP\n \\fB\\-\\-no\\-trans\\fR\n Run all passes except translation; no output\n .TP\n@@ -62,9 +65,9 @@ Parse only; do not compile, assemble, or link\n .TP\n \\fB\\-\\-pretty\\fR [type]\n Pretty\\-print the input instead of compiling;\n-valid types are: \\fBnormal\\fR (un\\-annotated source),\n-\\fBexpanded\\fR (crates expanded), \\fBtyped\\fR (crates expanded,\n-with type annotations), or \\fBidentified\\fR (fully\n+valid types are: normal (un\\-annotated source),\n+expanded (crates expanded), typed (crates expanded,\n+with type annotations), or identified (fully\n parenthesized, AST nodes and blocks with IDs)\n .TP\n \\fB\\-S\\fR\n@@ -75,7 +78,8 @@ Write intermediate files (.bc, .opt.bc, .o)\n in addition to normal output\n .TP\n \\fB\\-\\-static\\fR\n-Use or produce static libraries or binaries (experimental)\n+Use or produce static libraries or binaries\n+(experimental)\n .TP\n \\fB\\-\\-sysroot\\fR <path>\n Override the system root\n@@ -84,24 +88,16 @@ Override the system root\n Build a test harness\n .TP\n \\fB\\-\\-target\\fR <triple>\n-Target cpu\\-manufacturer\\-kernel[\\-os] to compile for (default: host triple)\n-(see <\\fBhttp://sources.redhat.com/autobook/autobook/autobook_17.html\\fR> for\n-detail)\n-.TP\n-\\fB\\-W\\fR <foo>\n-enable warning <foo>\n-.TP\n-\\fB\\-W\\fR no\\-<foo>\n-disable warning <foo>\n-.TP\n-\\fB\\-W\\fR err\\-<foo>\n-enable warning <foo> as an error\n+Target cpu\\-manufacturer\\-kernel[\\-os] to compile for\n+(default: host triple)\n+(see http://sources.redhat.com/autobook/autobook/\n+autobook_17.html for detail)\n .TP\n-\\fB\\-W\\fR help\n-Print available warnings and default settings\n+\\fB\\-W help\\fR\n+Print 'lint' options and default settings\n .TP\n-\\fB\\-Z\\fR help\n-list internal options for debugging rustc\n+\\fB\\-Z help\\fR\n+Print internal options for debugging rustc\n .TP\n \\fB\\-v\\fR \\fB\\-\\-version\\fR\n Print version info and exit\n@@ -117,11 +113,12 @@ To build either with a crate (.rc) file:\n     $ rustc hello.rc\n \n .SH \"BUGS\"\n-See <\\fBhttps://github.com/mozilla/rust/issues\\fR> for a list of known bugs.\n+See <\\fBhttps://github.com/mozilla/rust/issues\\fR> for issues.\n \n .SH \"AUTHOR\"\n See \\fBAUTHORS.txt\\fR in the rust source distribution. Graydon Hoare\n <\\fIgraydon@mozilla.com\\fR> is the project leader.\n \n .SH \"COPYRIGHT\"\n-See \\fBLICENSE.txt\\fR in the rust source distribution.\n+This work is licensed under MIT-like terms.  See \\fBLICENSE.txt\\fR\n+in the rust source distribution."}, {"sha": "67eaa1b878b3346f2420a0a21e6d03a8c0cdfd7c", "filename": "mk/platform.mk", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/mk%2Fplatform.mk", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/mk%2Fplatform.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fplatform.mk?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820", "patch": "@@ -19,6 +19,10 @@ CFG_GCCISH_CFLAGS += -fno-omit-frame-pointer\n # embedded into the executable, so use a no-op command.\n CFG_DSYMUTIL := true\n \n+# Add a dSYM glob for all platforms, even though it will do nothing on\n+# non-Darwin platforms; omitting it causes a full -R copy of lib/\n+CFG_LIB_DSYM_GLOB=lib$(1)-*.dylib.dSYM\n+\n ifneq ($(findstring freebsd,$(CFG_OSTYPE)),)\n   CFG_LIB_NAME=lib$(1).so\n   CFG_LIB_GLOB=lib$(1)-*.so\n@@ -77,7 +81,6 @@ endif\n ifneq ($(findstring darwin,$(CFG_OSTYPE)),)\n   CFG_LIB_NAME=lib$(1).dylib\n   CFG_LIB_GLOB=lib$(1)-*.dylib\n-  CFG_LIB_DSYM_GLOB=lib$(1)-*.dylib.dSYM\n   CFG_UNIXY := 1\n   CFG_LDENV := DYLD_LIBRARY_PATH\n   CFG_GCCISH_LINK_FLAGS += -dynamiclib -lpthread -framework CoreServices -Wl,-no_compact_unwind"}, {"sha": "76c15146310e887503728bebe48b67536fa3ef34", "filename": "src/cargo/cargo.rc", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Fcargo%2Fcargo.rc", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Fcargo%2Fcargo.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcargo%2Fcargo.rc?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820", "patch": "@@ -10,7 +10,7 @@\n // End:\n \n #[link(name = \"cargo\",\n-       vers = \"0.4\",\n+       vers = \"0.5\",\n        uuid = \"9ff87a04-8fed-4295-9ff8-f99bb802650b\",\n        url = \"https://github.com/mozilla/rust/tree/master/src/cargo\")];\n \n@@ -27,10 +27,10 @@\n #[allow(deprecated_mode)];\n #[allow(deprecated_pattern)];\n \n-extern mod core(vers = \"0.4\");\n-extern mod std(vers = \"0.4\");\n-extern mod rustc(vers = \"0.4\");\n-extern mod syntax(vers = \"0.4\");\n+extern mod core(vers = \"0.5\");\n+extern mod std(vers = \"0.5\");\n+extern mod rustc(vers = \"0.5\");\n+extern mod syntax(vers = \"0.5\");\n \n use core::*;\n "}, {"sha": "6f4e54080ca75f2f3f1c4831f8e0abe3df5f8c03", "filename": "src/cargo/cargo.rs", "status": "modified", "additions": 21, "deletions": 22, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Fcargo%2Fcargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Fcargo%2Fcargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcargo%2Fcargo.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820", "patch": "@@ -705,7 +705,7 @@ fn configure(opts: Options) -> Cargo {\n              ~\" or package manager to get it to work correctly\");\n     }\n \n-    c\n+    move c\n }\n \n fn for_each_package(c: &Cargo, b: fn(s: @Source, p: &Package)) {\n@@ -1162,20 +1162,20 @@ fn sync_one_file(c: &Cargo, dir: &Path, src: @Source) -> bool {\n     }\n     match (src.key, src.keyfp) {\n         (Some(_), Some(f)) => {\n-            let r = pgp::verify(&c.root, &pkgfile, &sigfile, f);\n+            let r = pgp::verify(&c.root, &pkgfile, &sigfile);\n \n             if !r {\n-                error(fmt!(\"signature verification failed for source %s\",\n-                          name));\n+                error(fmt!(\"signature verification failed for source %s with \\\n+                            key %s\", name, f));\n                 return false;\n             }\n \n             if has_src_file {\n-                let e = pgp::verify(&c.root, &srcfile, &srcsigfile, f);\n+                let e = pgp::verify(&c.root, &srcfile, &srcsigfile);\n \n                 if !e {\n-                    error(fmt!(\"signature verification failed for source %s\",\n-                              name));\n+                    error(fmt!(\"signature verification failed for source %s \\\n+                                with key %s\", name, f));\n                     return false;\n                 }\n             }\n@@ -1273,21 +1273,21 @@ fn sync_one_git(c: &Cargo, dir: &Path, src: @Source) -> bool {\n     }\n     match (src.key, src.keyfp) {\n         (Some(_), Some(f)) => {\n-            let r = pgp::verify(&c.root, &pkgfile, &sigfile, f);\n+            let r = pgp::verify(&c.root, &pkgfile, &sigfile);\n \n             if !r {\n-                error(fmt!(\"signature verification failed for source %s\",\n-                          name));\n+                error(fmt!(\"signature verification failed for source %s with \\\n+                            key %s\", name, f));\n                 rollback(name, dir, false);\n                 return false;\n             }\n \n             if has_src_file {\n-                let e = pgp::verify(&c.root, &srcfile, &srcsigfile, f);\n+                let e = pgp::verify(&c.root, &srcfile, &srcsigfile);\n \n                 if !e {\n-                    error(fmt!(\"signature verification failed for source %s\",\n-                              name));\n+                    error(fmt!(\"signature verification failed for source %s \\\n+                                with key %s\", name, f));\n                     rollback(name, dir, false);\n                     return false;\n                 }\n@@ -1370,11 +1370,11 @@ fn sync_one_curl(c: &Cargo, dir: &Path, src: @Source) -> bool {\n                 return false;\n             }\n \n-            let r = pgp::verify(&c.root, &pkgfile, &sigfile, f);\n+            let r = pgp::verify(&c.root, &pkgfile, &sigfile);\n \n             if !r {\n-                error(fmt!(\"signature verification failed for source %s\",\n-                          name));\n+                error(fmt!(\"signature verification failed for source %s with \\\n+                            key %s\", name, f));\n                 return false;\n             }\n \n@@ -1390,11 +1390,11 @@ fn sync_one_curl(c: &Cargo, dir: &Path, src: @Source) -> bool {\n                     return false;\n                 }\n \n-                let e = pgp::verify(&c.root, &srcfile, &srcsigfile, f);\n+                let e = pgp::verify(&c.root, &srcfile, &srcsigfile);\n \n                 if !e {\n                     error(~\"signature verification failed for \" +\n-                          ~\"source \" + name);\n+                          ~\"source \" + name + ~\" with key \" + f);\n                     return false;\n                 }\n             }\n@@ -1463,8 +1463,7 @@ fn cmd_init(c: &Cargo) {\n         return;\n     }\n \n-    let r = pgp::verify(&c.root, &srcfile, &sigfile,\n-                        pgp::signing_key_fp());\n+    let r = pgp::verify(&c.root, &srcfile, &sigfile);\n     if !r {\n         error(fmt!(\"signature verification failed for '%s'\",\n                    srcfile.to_str()));\n@@ -1615,10 +1614,10 @@ fn dump_sources(c: &Cargo) {\n                     _ => ()\n                 }\n \n-                hash.insert(copy k, json::Object(chash));\n+                hash.insert(copy k, json::Object(move chash));\n             }\n \n-            json::to_writer(writer, &json::Object(hash))\n+            json::to_writer(writer, &json::Object(move hash))\n         }\n         result::Err(e) => {\n             error(fmt!(\"could not dump sources: %s\", e));"}, {"sha": "5fbfa55838c8efb529d47d7b343fd9992ac92be0", "filename": "src/cargo/pgp.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Fcargo%2Fpgp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Fcargo%2Fpgp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcargo%2Fpgp.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820", "patch": "@@ -1,5 +1,5 @@\n-fn gpg(args: ~[~str]) -> { status: int, out: ~str, err: ~str } {\n-    return run::program_output(~\"gpg\", args);\n+fn gpgv(args: ~[~str]) -> { status: int, out: ~str, err: ~str } {\n+    return run::program_output(~\"gpgv\", args);\n }\n \n fn signing_key() -> ~str {\n@@ -59,7 +59,7 @@ fn signing_key_fp() -> ~str {\n }\n \n fn supported() -> bool {\n-    let r = gpg(~[~\"--version\"]);\n+    let r = gpgv(~[~\"--version\"]);\n     r.status == 0\n }\n \n@@ -88,15 +88,14 @@ fn add(root: &Path, key: &Path) {\n     }\n }\n \n-fn verify(root: &Path, data: &Path, sig: &Path, keyfp: ~str) -> bool {\n+fn verify(root: &Path, data: &Path, sig: &Path) -> bool {\n     let path = root.push(\"gpg\");\n-    let p = gpg(~[~\"--homedir\", path.to_str(),\n-                  ~\"--with-fingerprint\",\n-                  ~\"--verify\", sig.to_str(),\n-                 data.to_str()]);\n-    let res = ~\"Primary key fingerprint: \" + keyfp;\n-    for str::split_char_each(p.err, '\\n') |line| {\n-        if line == res { return true; }\n+    let res = gpgv(~[~\"--homedir\", path.to_str(),\n+                  ~\"--keyring\", ~\"pubring.gpg\",\n+                  ~\"--verbose\",\n+                 sig.to_str(), data.to_str()]);\n+    if res.status != 0 {\n+        return false;\n     }\n-    return false;\n+    return true;\n }"}, {"sha": "db605c3caa4c34b172d0999df19313bc6828226a", "filename": "src/compiletest/compiletest.rc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Fcompiletest%2Fcompiletest.rc", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Fcompiletest%2Fcompiletest.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rc?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820", "patch": "@@ -8,8 +8,8 @@\n #[allow(deprecated_mode)];\n #[allow(deprecated_pattern)];\n \n-extern mod core(vers = \"0.4\");\n-extern mod std(vers = \"0.4\");\n+extern mod core(vers = \"0.5\");\n+extern mod std(vers = \"0.5\");\n \n use core::*;\n "}, {"sha": "e147ddc3ed7f440e73448c418c8b591fa1e025a3", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820", "patch": "@@ -145,7 +145,7 @@ fn make_tests(config: config) -> ~[test::TestDesc] {\n             tests.push(make_test(config, file))\n         }\n     }\n-    return tests;\n+    move tests\n }\n \n fn is_test(config: config, testfile: &Path) -> bool {"}, {"sha": "38102e9af35bebc19957aa74571b963b084ed610", "filename": "src/compiletest/procsrv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fprocsrv.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820", "patch": "@@ -60,12 +60,12 @@ fn run(lib_path: ~str,\n     writeclose(pipe_in.out, input);\n     let p = pipes::PortSet();\n     let ch = p.chan();\n-    do task::spawn_sched(task::SingleThreaded) {\n+    do task::spawn_sched(task::SingleThreaded) |move ch| {\n         let errput = readclose(pipe_err.in);\n         ch.send((2, errput));\n     }\n     let ch = p.chan();\n-    do task::spawn_sched(task::SingleThreaded) {\n+    do task::spawn_sched(task::SingleThreaded) |move ch| {\n         let output = readclose(pipe_out.in);\n         ch.send((1, output));\n     }"}, {"sha": "16a205ddc161b3ab191364c29f6b38bf8b15b3f5", "filename": "src/etc/kate/rust.xml", "status": "modified", "additions": 19, "deletions": 38, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Fetc%2Fkate%2Frust.xml", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Fetc%2Fkate%2Frust.xml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fkate%2Frust.xml?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820", "patch": "@@ -1,6 +1,6 @@\n <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n <!DOCTYPE language SYSTEM \"language.dtd\">\n-<language name=\"Rust\" version=\"0.3.1\" kateversion=\"2.4\" section=\"Sources\" extensions=\"*.rs;*.rc\" mimetype=\"text/x-rust\" priority=\"15\">\n+<language name=\"Rust\" version=\"0.4.0\" kateversion=\"2.4\" section=\"Sources\" extensions=\"*.rs;*.rc\" mimetype=\"text/x-rust\" priority=\"15\">\n <highlighting>\n \t<list name=\"fn\">\n \t\t<item> fn </item>\n@@ -9,59 +9,39 @@\n \t\t<item> type </item>\n \t</list>\n \t<list name=\"keywords\">\n-\t\t<item> alt </item>\n-\t\t<item> again </item>\n \t\t<item> as </item>\n \t\t<item> assert </item>\n \t\t<item> break </item>\n-\t\t<item> check </item>\n-\t\t<item> claim </item>\n \t\t<item> const </item>\n \t\t<item> copy </item>\n \t\t<item> do </item>\n \t\t<item> drop </item>\n \t\t<item> else </item>\n+\t\t<item> enum </item>\n \t\t<item> export </item>\n \t\t<item> extern </item>\n-\t\t<item> f16 </item>\n-\t\t<item> f80 </item>\n-\t\t<item> f128 </item>\n \t\t<item> fail </item>\n \t\t<item> for </item>\n \t\t<item> if </item>\n \t\t<item> impl </item>\n-\t\t<item> import </item>\n-\t\t<item> in </item>\n \t\t<item> let </item>\n \t\t<item> log </item>\n \t\t<item> loop </item>\n-\t\t<item> m32 </item>\n-\t\t<item> m64 </item>\n-\t\t<item> m128 </item>\n \t\t<item> match </item>\n \t\t<item> mod </item>\n-\t\t<item> module </item>\n \t\t<item> move </item>\n \t\t<item> mut </item>\n-\t\t<item> new </item>\n-\t\t<item> of </item>\n-\t\t<item> owned </item>\n \t\t<item> priv </item>\n \t\t<item> pub </item>\n \t\t<item> pure </item>\n-\t\t<item> ret </item>\n+\t\t<item> ref </item>\n \t\t<item> return </item>\n-\t\t<item> to </item>\n-\t\t<item> unchecked </item>\n+\t\t<item> static </item>\n+\t\t<item> struct </item>\n+\t\t<item> trait </item>\n \t\t<item> unsafe </item>\n \t\t<item> use </item>\n \t\t<item> while </item>\n-\t\t<item> with </item>\n-\t\t<item> mod </item>\n-\t\t<item> trait </item>\n-\t\t<item> class </item>\n-\t\t<item> struct </item>\n-\t\t<item> enum </item>\n \t</list>\n \t<list name=\"types\">\n \t\t<item> bool </item>\n@@ -80,8 +60,9 @@\n \t\t<item> float </item>\n \t\t<item> char </item>\n \t\t<item> str </item>\n-\t\t<item> option </item>\n-\t\t<item> either </item>\n+\t\t<item> Either </item>\n+\t\t<item> Option </item>\n+\t\t<item> Result </item>\n \t</list>\n \t<list name=\"ctypes\">\n \t\t<item> c_float </item>\n@@ -121,16 +102,16 @@\n \t<list name=\"constants\">\n \t\t<item> true </item>\n \t\t<item> false </item>\n-\t\t<item> some </item>\n-\t\t<item> none </item>\n-\t\t<item> left </item>\n-\t\t<item> right </item>\n-\t\t<item> ok </item>\n-\t\t<item> err </item>\n-\t\t<item> success </item>\n-\t\t<item> failure </item>\n-\t\t<item> cons </item>\n-\t\t<item> nil </item>\n+\t\t<item> Some </item>\n+\t\t<item> None </item>\n+\t\t<item> Left </item>\n+\t\t<item> Right </item>\n+\t\t<item> Ok </item>\n+\t\t<item> Err </item>\n+\t\t<item> Success </item>\n+\t\t<item> Failure </item>\n+\t\t<item> Cons </item>\n+\t\t<item> Nil </item>\n \t</list>\n \t<list name=\"cconstants\">\n \t\t<item> EXIT_FAILURE </item>"}, {"sha": "b38294d5405a4032ff776fb81c82f7fb47078100", "filename": "src/etc/snapshot.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Fetc%2Fsnapshot.py", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Fetc%2Fsnapshot.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fsnapshot.py?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820", "patch": "@@ -68,7 +68,7 @@ def parse_line(n, line):\n \n   match = re.match(r\"([ST]) (\\d{4}-\\d{2}-\\d{2}) ([a-fA-F\\d]+)\\s*$\", line);\n   if (not match):\n-    raise Exception(\"%s:%d:E syntax error\" % (snapshotfile, n))\n+    raise Exception(\"%s:%d:E syntax error: \" % (snapshotfile, n))\n   return {\"type\": \"snapshot\",\n           \"date\": match.group(2),\n           \"rev\": match.group(3)}"}, {"sha": "c4d37d904344280e50dfae832dfe1cac445fca8c", "filename": "src/fuzzer/fuzzer.rc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ffuzzer%2Ffuzzer.rc", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ffuzzer%2Ffuzzer.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Ffuzzer.rc?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820", "patch": "@@ -12,9 +12,9 @@\n #[allow(deprecated_mode)];\n #[allow(deprecated_pattern)];\n \n-extern mod core(vers = \"0.4\");\n-extern mod std(vers = \"0.4\");\n-extern mod syntax(vers = \"0.4\");\n+extern mod core(vers = \"0.5\");\n+extern mod std(vers = \"0.5\");\n+extern mod syntax(vers = \"0.5\");\n \n use core::*;\n "}, {"sha": "a4968382cf478f4ef1f45b6596d0131e03c81643", "filename": "src/fuzzer/fuzzer.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ffuzzer%2Ffuzzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ffuzzer%2Ffuzzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Ffuzzer.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820", "patch": "@@ -104,7 +104,7 @@ pure fn safe_to_use_expr(e: ast::expr, tm: test_mode) -> bool {\n     }\n }\n \n-fn safe_to_steal_ty(t: @ast::ty, tm: test_mode) -> bool {\n+fn safe_to_steal_ty(t: @ast::Ty, tm: test_mode) -> bool {\n     // Restrictions happen to be the same.\n     safe_to_replace_ty(t.node, tm)\n }\n@@ -119,16 +119,16 @@ fn stash_expr_if(c: fn@(@ast::expr, test_mode)->bool,\n     } else {/* now my indices are wrong :( */ }\n }\n \n-fn stash_ty_if(c: fn@(@ast::ty, test_mode)->bool,\n-               es: @mut ~[ast::ty],\n-               e: @ast::ty,\n+fn stash_ty_if(c: fn@(@ast::Ty, test_mode)->bool,\n+               es: @mut ~[ast::Ty],\n+               e: @ast::Ty,\n                tm: test_mode) {\n     if c(e, tm) {\n         es.push(*e);\n     } else {/* now my indices are wrong :( */ }\n }\n \n-type stolen_stuff = {exprs: ~[ast::expr], tys: ~[ast::ty]};\n+type stolen_stuff = {exprs: ~[ast::expr], tys: ~[ast::Ty]};\n \n fn steal(crate: ast::crate, tm: test_mode) -> stolen_stuff {\n     let exprs = @mut ~[];\n@@ -195,7 +195,7 @@ fn replace_expr_in_crate(crate: ast::crate, i: uint,\n \n \n // Replace the |i|th ty (in fold order) of |crate| with |newty|.\n-fn replace_ty_in_crate(crate: ast::crate, i: uint, newty: ast::ty,\n+fn replace_ty_in_crate(crate: ast::crate, i: uint, newty: ast::Ty,\n                        tm: test_mode) -> ast::crate {\n     let j: @mut uint = @mut 0u;\n     fn fold_ty_rep(j_: @mut uint, i_: uint, newty_: ast::ty_,\n@@ -225,7 +225,7 @@ fn as_str(f: fn@(+x: io::Writer)) -> ~str {\n     io::with_str_writer(f)\n }\n \n-fn check_variants_of_ast(crate: ast::crate, codemap: codemap::codemap,\n+fn check_variants_of_ast(crate: ast::crate, codemap: codemap::CodeMap,\n                          filename: &Path, cx: context) {\n     let stolen = steal(crate, cx.mode);\n     let extra_exprs = vec::filter(common_exprs(),\n@@ -239,7 +239,7 @@ fn check_variants_of_ast(crate: ast::crate, codemap: codemap::codemap,\n \n fn check_variants_T<T: Copy>(\n   crate: ast::crate,\n-  codemap: codemap::codemap,\n+  codemap: codemap::CodeMap,\n   filename: &Path,\n   thing_label: ~str,\n   things: ~[T],\n@@ -296,7 +296,7 @@ fn check_variants_T<T: Copy>(\n }\n \n fn last_part(filename: ~str) -> ~str {\n-  let ix = option::get(&str::rfind_char(filename, '/'));\n+  let ix = option::get(str::rfind_char(filename, '/'));\n   str::slice(filename, ix + 1u, str::len(filename) - 3u)\n }\n \n@@ -444,7 +444,7 @@ fn parse_and_print(code: @~str) -> ~str {\n \n fn has_raw_pointers(c: ast::crate) -> bool {\n     let has_rp = @mut false;\n-    fn visit_ty(flag: @mut bool, t: @ast::ty) {\n+    fn visit_ty(flag: @mut bool, t: @ast::Ty) {\n         match t.node {\n           ast::ty_ptr(_) => { *flag = true; }\n           _ => { }"}, {"sha": "9aaf373869c869b67adf74d99ba16a6ee837838c", "filename": "src/libcore/cast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibcore%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibcore%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcast.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820", "patch": "@@ -122,9 +122,9 @@ pub mod tests {\n     pub fn test_transmute() {\n         unsafe {\n             let x = @1;\n-            let x: *int = transmute(x);\n+            let x: *int = transmute(move x);\n             assert *x == 1;\n-            let _x: @int = transmute(x);\n+            let _x: @int = transmute(move x);\n         }\n     }\n "}, {"sha": "9a3b40757a703bf2ee4fa8bb17c1be36ba050f27", "filename": "src/libcore/cleanup.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibcore%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibcore%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcleanup.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820", "patch": "@@ -142,7 +142,7 @@ pub unsafe fn annihilate() {\n         assert (*box).header.prev == null();\n \n         debug!(\"freeing box: %x\", box as uint);\n-        rt_free(transmute(box));\n+        rt_free(transmute(move box));\n     }\n }\n "}, {"sha": "46ac90413a6489367f6ad78f46f9f57d4ad84984", "filename": "src/libcore/cmath.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibcore%2Fcmath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibcore%2Fcmath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmath.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820", "patch": "@@ -12,7 +12,7 @@ use libc::c_double;\n \n #[link_name = \"m\"]\n #[abi = \"cdecl\"]\n-pub extern mod c_double {\n+pub extern mod c_double_utils {\n \n     // Alpabetically sorted by link_name\n \n@@ -87,7 +87,7 @@ pub extern mod c_double {\n \n #[link_name = \"m\"]\n #[abi = \"cdecl\"]\n-pub extern mod c_float {\n+pub extern mod c_float_utils {\n \n     // Alpabetically sorted by link_name\n "}, {"sha": "77bd88e04d786e0f1b8b72ffd00655fe8a121931", "filename": "src/libcore/condition.rs", "status": "added", "additions": 300, "deletions": 0, "changes": 300, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibcore%2Fcondition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibcore%2Fcondition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcondition.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820", "patch": "@@ -0,0 +1,300 @@\n+// helper for transmutation, shown below.\n+type RustClosure = (int,int);\n+\n+struct Condition<T, U:Copy> {\n+    key: task::local_data::LocalDataKey<Handler<T,U>>\n+}\n+\n+struct Handler<T, U:Copy> {\n+    handle: RustClosure\n+}\n+\n+\n+struct ProtectBlock<T, U:Copy> {\n+    cond: &Condition<T, U>,\n+    inner: RustClosure\n+}\n+\n+struct Guard<T, U:Copy> {\n+    cond: &Condition<T,U>,\n+    prev: Option<@Handler<T, U>>,\n+    drop {\n+        match self.prev {\n+            None => (),\n+            Some(p) =>\n+            unsafe {\n+                debug!(\"Guard: popping handler from TLS\");\n+                task::local_data::local_data_set(self.cond.key, p)\n+            }\n+        }\n+    }\n+}\n+\n+struct HandleBlock<T, U:Copy> {\n+    pb: &ProtectBlock<T,U>,\n+    prev: Option<@Handler<T,U>>,\n+    handler: @Handler<T,U>,\n+    drop {\n+        unsafe {\n+            debug!(\"HandleBlock: pushing handler to TLS\");\n+            let _g = Guard { cond: self.pb.cond,\n+                             prev: self.prev };\n+            task::local_data::local_data_set(self.pb.cond.key,\n+                                             self.handler);\n+            // transmutation to avoid copying non-copyable, should\n+            // be fixable by tracking closure pointees in regionck.\n+            let f : &fn() = ::cast::transmute(self.pb.inner);\n+            debug!(\"HandleBlock: invoking protected code\");\n+            f();\n+            debug!(\"HandleBlock: returned from protected code\");\n+        }\n+    }\n+}\n+\n+struct Trap<T, U:Copy> {\n+    cond: &Condition<T,U>,\n+    handler: @Handler<T, U>\n+}\n+\n+impl<T, U: Copy> ProtectBlock<T,U> {\n+    fn handle(&self, h: &self/fn(&T) ->U) -> HandleBlock/&self<T,U> {\n+        unsafe {\n+            debug!(\"ProtectBlock.handle: setting up handler block\");\n+            let p : *RustClosure = ::cast::transmute(&h);\n+            let prev = task::local_data::local_data_get(self.cond.key);\n+            HandleBlock { pb: self,\n+                          prev: prev,\n+                          handler: @Handler{handle: *p} }\n+        }\n+    }\n+}\n+\n+\n+\n+impl<T, U: Copy> Trap<T,U> {\n+    fn in<V: Copy>(&self, inner: &self/fn() -> V) -> V {\n+        unsafe {\n+            let prev = task::local_data::local_data_get(self.cond.key);\n+            let _g = Guard { cond: self.cond,\n+                             prev: prev };\n+            debug!(\"Trap: pushing handler to TLS\");\n+            task::local_data::local_data_set(self.cond.key, self.handler);\n+            inner()\n+        }\n+    }\n+}\n+\n+impl<T, U: Copy>  Condition<T,U> {\n+\n+    fn guard(&self, h: &self/fn(&T) ->U) -> Guard/&self<T,U> {\n+        unsafe {\n+            let prev = task::local_data::local_data_get(self.key);\n+            let g = Guard { cond: self, prev: prev };\n+            debug!(\"Guard: pushing handler to TLS\");\n+            let p : *RustClosure = ::cast::transmute(&h);\n+            let h = @Handler{handle: *p};\n+            task::local_data::local_data_set(self.key, h);\n+            move g\n+        }\n+    }\n+\n+    fn trap(&self, h: &self/fn(&T) ->U) -> Trap/&self<T,U> {\n+        unsafe {\n+            let p : *RustClosure = ::cast::transmute(&h);\n+            let h = @Handler{handle: *p};\n+            move Trap { cond: self, handler: h }\n+        }\n+    }\n+\n+    fn protect(&self, inner: &self/fn()) -> ProtectBlock/&self<T,U> {\n+        unsafe {\n+            // transmutation to avoid copying non-copyable, should\n+            // be fixable by tracking closure pointees in regionck.\n+            debug!(\"Condition.protect: setting up protected block\");\n+            let p : *RustClosure = ::cast::transmute(&inner);\n+            ProtectBlock { cond: self,\n+                           inner: *p }\n+        }\n+    }\n+\n+    fn raise(t:&T) -> U {\n+        unsafe {\n+            match task::local_data::local_data_get(self.key) {\n+                None => {\n+                    debug!(\"Condition.raise: found no handler\");\n+                    fail\n+                }\n+\n+                Some(handler) => {\n+                    debug!(\"Condition.raise: found handler\");\n+                    let f : &fn(&T) -> U = ::cast::transmute(handler.handle);\n+                    f(t)\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+\n+#[cfg(test)]\n+fn sadness_key(_x: @Handler<int,int>) { }\n+\n+#[cfg(test)]\n+fn trouble(i: int) {\n+    // Condition should work as a const, just limitations in consts.\n+    let sadness_condition : Condition<int,int> =\n+        Condition { key: sadness_key };\n+    debug!(\"trouble: raising conition\");\n+    let j = sadness_condition.raise(&i);\n+    debug!(\"trouble: handler recovered with %d\", j);\n+}\n+\n+#[test]\n+fn test1() {\n+\n+    let sadness_condition : Condition<int,int> =\n+        Condition { key: sadness_key };\n+\n+    let mut i = 10;\n+\n+    let b = do sadness_condition.protect {\n+        debug!(\"test1: in protected block\");\n+        trouble(1);\n+        trouble(2);\n+        trouble(3);\n+    };\n+\n+    do b.handle |j| {\n+        debug!(\"test1: in handler\");\n+        i += *j;\n+        i\n+    };\n+\n+    assert i == 16;\n+}\n+#[cfg(test)]\n+fn nested_test_inner() {\n+    let sadness_condition : Condition<int,int> =\n+        Condition { key: sadness_key };\n+\n+    let mut inner_trapped = false;\n+\n+    let b = do sadness_condition.protect {\n+        debug!(\"nested_test_inner: in protected block\");\n+        trouble(1);\n+    };\n+\n+    do b.handle |_j| {\n+        debug!(\"nested_test_inner: in handler\");\n+        inner_trapped = true;\n+        0\n+    };\n+\n+    assert inner_trapped;\n+}\n+\n+#[test]\n+fn nested_test_outer() {\n+\n+    let sadness_condition : Condition<int,int> =\n+        Condition { key: sadness_key };\n+\n+    let mut outer_trapped = false;\n+\n+    let b = do sadness_condition.protect {\n+        debug!(\"nested_test_outer: in protected block\");\n+        nested_test_inner();\n+        trouble(1);\n+    };\n+\n+    do b.handle |_j| {\n+        debug!(\"nested_test_outer: in handler\");\n+        outer_trapped = true;\n+        0\n+    };\n+\n+    assert outer_trapped;\n+}\n+\n+\n+#[cfg(test)]\n+fn nested_guard_test_inner() {\n+    let sadness_condition : Condition<int,int> =\n+        Condition { key: sadness_key };\n+\n+    let mut inner_trapped = false;\n+\n+    let _g = do sadness_condition.guard |_j| {\n+        debug!(\"nested_guard_test_inner: in handler\");\n+        inner_trapped = true;\n+        0\n+    };\n+\n+    debug!(\"nested_guard_test_inner: in protected block\");\n+    trouble(1);\n+\n+    assert inner_trapped;\n+}\n+\n+#[test]\n+fn nested_guard_test_outer() {\n+\n+    let sadness_condition : Condition<int,int> =\n+        Condition { key: sadness_key };\n+\n+    let mut outer_trapped = false;\n+\n+    let _g = do sadness_condition.guard |_j| {\n+        debug!(\"nested_guard_test_outer: in handler\");\n+        outer_trapped = true;\n+        0\n+    };\n+\n+    debug!(\"nested_guard_test_outer: in protected block\");\n+    nested_guard_test_inner();\n+    trouble(1);\n+\n+    assert outer_trapped;\n+}\n+\n+\n+\n+#[cfg(test)]\n+fn nested_trap_test_inner() {\n+    let sadness_condition : Condition<int,int> =\n+        Condition { key: sadness_key };\n+\n+    let mut inner_trapped = false;\n+\n+    do sadness_condition.trap(|_j| {\n+        debug!(\"nested_trap_test_inner: in handler\");\n+        inner_trapped = true;\n+        0\n+    }).in {\n+        debug!(\"nested_trap_test_inner: in protected block\");\n+        trouble(1);\n+    }\n+\n+    assert inner_trapped;\n+}\n+\n+#[test]\n+fn nested_trap_test_outer() {\n+\n+    let sadness_condition : Condition<int,int> =\n+        Condition { key: sadness_key };\n+\n+    let mut outer_trapped = false;\n+\n+    do sadness_condition.trap(|_j| {\n+        debug!(\"nested_trap_test_outer: in handler\");\n+        outer_trapped = true; 0\n+    }).in {\n+        debug!(\"nested_guard_test_outer: in protected block\");\n+        nested_trap_test_inner();\n+        trouble(1);\n+    }\n+\n+\n+    assert outer_trapped;\n+}"}, {"sha": "9ebdad3521e53e7ebc57878083fe68d62d7c0778", "filename": "src/libcore/core.rc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820", "patch": "@@ -25,7 +25,7 @@ Implicitly, all crates behave as if they included the following prologue:\n */\n \n #[link(name = \"core\",\n-       vers = \"0.4\",\n+       vers = \"0.5\",\n        uuid = \"c70c24a7-5551-4f73-8e37-380b11d80be8\",\n        url = \"https://github.com/mozilla/rust/tree/master/src/libcore\")];\n \n@@ -200,6 +200,7 @@ pub mod flate;\n pub mod repr;\n pub mod cleanup;\n pub mod reflect;\n+pub mod condition;\n \n // Modules supporting compiler-generated code\n // Exported but not part of the public interface"}, {"sha": "35131e561d95357bfe767ce3c41e0ebca11f07a5", "filename": "src/libcore/core.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibcore%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibcore%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820", "patch": "@@ -11,8 +11,8 @@ pub use GenericPath = path::GenericPath;\n pub use WindowsPath = path::WindowsPath;\n pub use PosixPath = path::PosixPath;\n \n-pub use tuple::{TupleOps, ExtendedTupleOps};\n-pub use str::{StrSlice, UniqueStr};\n+pub use tuple::{CopyableTuple, ImmutableTuple, ExtendedTupleOps};\n+pub use str::{StrSlice, Trimmable};\n pub use vec::{ConstVector, CopyableVector, ImmutableVector};\n pub use vec::{ImmutableEqVector, ImmutableCopyableVector};\n pub use vec::{MutableVector, MutableCopyableVector};\n@@ -33,7 +33,7 @@ pub use ops::{Add, Sub, Mul, Div, Modulo, Neg, BitAnd, BitOr, BitXor};\n pub use ops::{Shl, Shr, Index};\n \n #[cfg(test)]\n-extern mod coreops(name = \"core\", vers = \"0.4\");\n+extern mod coreops(name = \"core\", vers = \"0.5\");\n \n #[cfg(test)]\n pub use coreops::ops::{Const, Copy, Send, Owned};\n@@ -72,6 +72,6 @@ mod core {\n // Similar to above. Some magic to make core testable.\n #[cfg(test)]\n mod std {\n-    extern mod std(vers = \"0.4\");\n+    extern mod std(vers = \"0.5\");\n     pub use std::test;\n }"}, {"sha": "35399878e2614945816080d3ea6bd7d2b370f4d3", "filename": "src/libcore/dlist.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibcore%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibcore%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdlist.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820", "patch": "@@ -208,7 +208,7 @@ impl<T> DList<T> {\n     fn push_head_n(data: T) -> DListNode<T> {\n         let mut nobe = self.new_link(move data);\n         self.add_head(nobe);\n-        option::get(&nobe)\n+        option::get(nobe)\n     }\n     /// Add data to the tail of the list. O(1).\n     fn push(data: T) {\n@@ -221,7 +221,7 @@ impl<T> DList<T> {\n     fn push_n(data: T) -> DListNode<T> {\n         let mut nobe = self.new_link(move data);\n         self.add_tail(nobe);\n-        option::get(&nobe)\n+        option::get(nobe)\n     }\n     /**\n      * Insert data into the middle of the list, left of the given node.\n@@ -245,7 +245,7 @@ impl<T> DList<T> {\n     fn insert_before_n(data: T, neighbour: DListNode<T>) -> DListNode<T> {\n         let mut nobe = self.new_link(move data);\n         self.insert_left(nobe, neighbour);\n-        option::get(&nobe)\n+        option::get(nobe)\n     }\n     /**\n      * Insert data into the middle of the list, right of the given node.\n@@ -269,7 +269,7 @@ impl<T> DList<T> {\n     fn insert_after_n(data: T, neighbour: DListNode<T>) -> DListNode<T> {\n         let mut nobe = self.new_link(move data);\n         self.insert_right(neighbour, nobe);\n-        option::get(&nobe)\n+        option::get(nobe)\n     }\n \n     /// Remove a node from the head of the list. O(1).\n@@ -385,17 +385,17 @@ impl<T> DList<T> {\n         let mut link = self.peek_n();\n         let mut rabbit = link;\n         while option::is_some(&link) {\n-            let nobe = option::get(&link);\n+            let nobe = option::get(link);\n             assert nobe.linked;\n             // check cycle\n             if option::is_some(&rabbit) {\n-                rabbit = option::get(&rabbit).next;\n+                rabbit = option::get(rabbit).next;\n             }\n             if option::is_some(&rabbit) {\n-                rabbit = option::get(&rabbit).next;\n+                rabbit = option::get(rabbit).next;\n             }\n             if option::is_some(&rabbit) {\n-                assert !box::ptr_eq(*option::get(&rabbit), *nobe);\n+                assert !box::ptr_eq(*option::get(rabbit), *nobe);\n             }\n             // advance\n             link = nobe.next_link();\n@@ -406,17 +406,17 @@ impl<T> DList<T> {\n         link = self.peek_tail_n();\n         rabbit = link;\n         while option::is_some(&link) {\n-            let nobe = option::get(&link);\n+            let nobe = option::get(link);\n             assert nobe.linked;\n             // check cycle\n             if option::is_some(&rabbit) {\n-                rabbit = option::get(&rabbit).prev;\n+                rabbit = option::get(rabbit).prev;\n             }\n             if option::is_some(&rabbit) {\n-                rabbit = option::get(&rabbit).prev;\n+                rabbit = option::get(rabbit).prev;\n             }\n             if option::is_some(&rabbit) {\n-                assert !box::ptr_eq(*option::get(&rabbit), *nobe);\n+                assert !box::ptr_eq(*option::get(rabbit), *nobe);\n             }\n             // advance\n             link = nobe.prev_link();"}, {"sha": "1b6a7522864efc5ed412023dbb9b9c4ad8d2bb1b", "filename": "src/libcore/dvec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibcore%2Fdvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibcore%2Fdvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdvec.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820", "patch": "@@ -56,7 +56,7 @@ pub enum DVec<A> {\n }\n \n /// Creates a new, empty dvec\n-pub fn DVec<A>() -> DVec<A> {\n+pub pure fn DVec<A>() -> DVec<A> {\n     DVec_({mut data: ~[]})\n }\n "}, {"sha": "d41393c23934c10e4c24b1453c0058bd9b8c1d28", "filename": "src/libcore/extfmt.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibcore%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibcore%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fextfmt.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820", "patch": "@@ -301,7 +301,7 @@ pub mod rt {\n                 unsafe { str::unshift_char(&mut s, ' ') };\n             }\n         }\n-        return unsafe { pad(cv, s, PadSigned) };\n+        return unsafe { pad(cv, move s, PadSigned) };\n     }\n     pub pure fn conv_uint(cv: Conv, u: uint) -> ~str {\n         let prec = get_int_precision(cv);\n@@ -313,7 +313,7 @@ pub mod rt {\n               TyBits => uint_to_str_prec(u, 2u, prec),\n               TyOctal => uint_to_str_prec(u, 8u, prec)\n             };\n-        return unsafe { pad(cv, rs, PadUnsigned) };\n+        return unsafe { pad(cv, move rs, PadUnsigned) };\n     }\n     pub pure fn conv_bool(cv: Conv, b: bool) -> ~str {\n         let s = if b { ~\"true\" } else { ~\"false\" };\n@@ -323,20 +323,20 @@ pub mod rt {\n     }\n     pub pure fn conv_char(cv: Conv, c: char) -> ~str {\n         let mut s = str::from_char(c);\n-        return unsafe { pad(cv, s, PadNozero) };\n+        return unsafe { pad(cv, move s, PadNozero) };\n     }\n     pub pure fn conv_str(cv: Conv, s: &str) -> ~str {\n         // For strings, precision is the maximum characters\n         // displayed\n         let mut unpadded = match cv.precision {\n-          CountImplied => s.to_unique(),\n+          CountImplied => s.to_owned(),\n           CountIs(max) => if max as uint < str::char_len(s) {\n             str::substr(s, 0u, max as uint)\n           } else {\n-            s.to_unique()\n+            s.to_owned()\n           }\n         };\n-        return unsafe { pad(cv, unpadded, PadNozero) };\n+        return unsafe { pad(cv, move unpadded, PadNozero) };\n     }\n     pub pure fn conv_float(cv: Conv, f: float) -> ~str {\n         let (to_str, digits) = match cv.precision {\n@@ -351,7 +351,7 @@ pub mod rt {\n                 s = ~\" \" + s;\n             }\n         }\n-        return unsafe { pad(cv, s, PadFloat) };\n+        return unsafe { pad(cv, move s, PadFloat) };\n     }\n     pub pure fn conv_poly<T>(cv: Conv, v: &T) -> ~str {\n         let s = sys::log_str(v);\n@@ -411,14 +411,14 @@ pub mod rt {\n     pub fn pad(cv: Conv, s: ~str, mode: PadMode) -> ~str {\n         let mut s = move s; // sadtimes\n         let uwidth : uint = match cv.width {\n-          CountImplied => return s,\n+          CountImplied => return (move s),\n           CountIs(width) => {\n               // FIXME: width should probably be uint (see Issue #1996)\n               width as uint\n           }\n         };\n         let strlen = str::char_len(s);\n-        if uwidth <= strlen { return s; }\n+        if uwidth <= strlen { return (move s); }\n         let mut padchar = ' ';\n         let diff = uwidth - strlen;\n         if have_flag(cv.flags, flag_left_justify) {"}, {"sha": "ed6908d110d6d505de7d992c6f6e76c1be2b8ac9", "filename": "src/libcore/f32.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibcore%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibcore%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ff32.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820", "patch": "@@ -4,7 +4,7 @@\n \n //! Operations and constants for `f32`\n \n-pub use cmath::c_float::*;\n+pub use cmath::c_float_utils::*;\n pub use cmath::c_float_targ_consts::*;\n \n // These are not defined inside consts:: for consistency with"}, {"sha": "2d13dc86e2fa57727d22fd2101d16ba864e94ad9", "filename": "src/libcore/f64.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibcore%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibcore%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ff64.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820", "patch": "@@ -4,7 +4,7 @@\n \n //! Operations and constants for `f64`\n \n-pub use cmath::c_double::*;\n+pub use cmath::c_double_utils::*;\n pub use cmath::c_double_targ_consts::*;\n \n // FIXME (#1433): obtain these in a different way\n@@ -59,7 +59,7 @@ pub pure fn ge(x: f64, y: f64) -> bool { return x >= y; }\n pub pure fn gt(x: f64, y: f64) -> bool { return x > y; }\n \n pub pure fn sqrt(x: f64) -> f64 {\n-    cmath::c_double::sqrt(x as libc::c_double) as f64\n+    cmath::c_double_utils::sqrt(x as libc::c_double) as f64\n }\n \n /// Returns true if `x` is a positive number, including +0.0f640 and +Infinity"}, {"sha": "b2dd468236a6d10ae142b790ed7b514b840a373a", "filename": "src/libcore/flate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibcore%2Fflate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibcore%2Fflate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fflate.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820", "patch": "@@ -37,7 +37,7 @@ pub fn deflate_bytes(bytes: &[const u8]) -> ~[u8] {\n                                                    ptr::addr_of(&outsz),\n                                                    lz_norm);\n             assert res as int != 0;\n-            let out = vec::raw::from_buf(res as *u8,\n+            let out = vec::raw::from_buf_raw(res as *u8,\n                                             outsz as uint);\n             libc::free(res);\n             move out\n@@ -55,7 +55,7 @@ pub fn inflate_bytes(bytes: &[const u8]) -> ~[u8] {\n                                                      ptr::addr_of(&outsz),\n                                                      0);\n             assert res as int != 0;\n-            let out = vec::raw::from_buf(res as *u8,\n+            let out = vec::raw::from_buf_raw(res as *u8,\n                                             outsz as uint);\n             libc::free(res);\n             move out"}, {"sha": "dd46d30d6bad6d521bcafd690d9958962daa234d", "filename": "src/libcore/float.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibcore%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibcore%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffloat.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820", "patch": "@@ -91,7 +91,7 @@ pub mod consts {\n  * * digits - The number of significant digits\n  * * exact - Whether to enforce the exact number of significant digits\n  */\n-pub fn to_str_common(num: float, digits: uint, exact: bool) -> ~str {\n+pub pure fn to_str_common(num: float, digits: uint, exact: bool) -> ~str {\n     if is_NaN(num) { return ~\"NaN\"; }\n     if num == infinity { return ~\"inf\"; }\n     if num == neg_infinity { return ~\"-inf\"; }\n@@ -125,7 +125,8 @@ pub fn to_str_common(num: float, digits: uint, exact: bool) -> ~str {\n         // store the next digit\n         frac *= 10.0;\n         let digit = frac as uint;\n-        fractionalParts.push(digit);\n+        // Bleh: not really unsafe.\n+        unsafe { fractionalParts.push(digit); }\n \n         // calculate the next frac\n         frac -= digit as float;\n@@ -140,7 +141,8 @@ pub fn to_str_common(num: float, digits: uint, exact: bool) -> ~str {\n     // turn digits into string\n     // using stack of digits\n     while fractionalParts.is_not_empty() {\n-        let mut adjusted_digit = carry + fractionalParts.pop();\n+        // Bleh; shouldn't need to be unsafe\n+        let mut adjusted_digit = carry + unsafe { fractionalParts.pop() };\n \n         if adjusted_digit == 10 {\n             carry = 1;\n@@ -196,7 +198,7 @@ pub fn test_to_str_exact_do_decimal() {\n  * * num - The float value\n  * * digits - The number of significant digits\n  */\n-pub fn to_str(num: float, digits: uint) -> ~str {\n+pub pure fn to_str(num: float, digits: uint) -> ~str {\n     to_str_common(num, digits, false)\n }\n \n@@ -361,7 +363,7 @@ pub fn from_str(num: &str) -> Option<float> {\n  *\n  * `NaN` if both `x` and `pow` are `0u`, otherwise `x^pow`\n  */\n-pub fn pow_with_uint(base: uint, pow: uint) -> float {\n+pub pure fn pow_with_uint(base: uint, pow: uint) -> float {\n     if base == 0u {\n         if pow == 0u {\n             return NaN as float;"}, {"sha": "bc35dafde3526ec0f0eea151d2aba643c5a54453", "filename": "src/libcore/future.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibcore%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibcore%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffuture.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820", "patch": "@@ -179,8 +179,8 @@ pub mod test {\n     #[test]\n     pub fn test_from_port() {\n         let (po, ch) = future_pipe::init();\n-        future_pipe::server::completed(ch, ~\"whale\");\n-        let f = from_port(po);\n+        future_pipe::server::completed(move ch, ~\"whale\");\n+        let f = from_port(move po);\n         assert get(&f) == ~\"whale\";\n     }\n \n@@ -238,7 +238,7 @@ pub mod test {\n     pub fn test_sendable_future() {\n         let expected = ~\"schlorf\";\n         let f = do spawn |copy expected| { copy expected };\n-        do task::spawn {\n+        do task::spawn |move f, move expected| {\n             let actual = get(&f);\n             assert actual == expected;\n         }"}, {"sha": "e3bbfbc4129de587c1a7be218a09fa850865eb61", "filename": "src/libcore/hash.rs", "status": "modified", "additions": 69, "deletions": 69, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibcore%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibcore%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820", "patch": "@@ -156,7 +156,7 @@ struct SipState {\n     mut v1: u64,\n     mut v2: u64,\n     mut v3: u64,\n-    tail: [mut u8]/8, // unprocessed bytes\n+    tail: [mut u8 * 8], // unprocessed bytes\n     mut ntail: uint,  // how many bytes in tail are valid\n }\n \n@@ -359,72 +359,72 @@ impl &SipState : Streaming {\n \n #[test]\n pub fn test_siphash() {\n-    let vecs : [[u8]/8]/64 = [\n-        [ 0x31, 0x0e, 0x0e, 0xdd, 0x47, 0xdb, 0x6f, 0x72, ]/_,\n-        [ 0xfd, 0x67, 0xdc, 0x93, 0xc5, 0x39, 0xf8, 0x74, ]/_,\n-        [ 0x5a, 0x4f, 0xa9, 0xd9, 0x09, 0x80, 0x6c, 0x0d, ]/_,\n-        [ 0x2d, 0x7e, 0xfb, 0xd7, 0x96, 0x66, 0x67, 0x85, ]/_,\n-        [ 0xb7, 0x87, 0x71, 0x27, 0xe0, 0x94, 0x27, 0xcf, ]/_,\n-        [ 0x8d, 0xa6, 0x99, 0xcd, 0x64, 0x55, 0x76, 0x18, ]/_,\n-        [ 0xce, 0xe3, 0xfe, 0x58, 0x6e, 0x46, 0xc9, 0xcb, ]/_,\n-        [ 0x37, 0xd1, 0x01, 0x8b, 0xf5, 0x00, 0x02, 0xab, ]/_,\n-        [ 0x62, 0x24, 0x93, 0x9a, 0x79, 0xf5, 0xf5, 0x93, ]/_,\n-        [ 0xb0, 0xe4, 0xa9, 0x0b, 0xdf, 0x82, 0x00, 0x9e, ]/_,\n-        [ 0xf3, 0xb9, 0xdd, 0x94, 0xc5, 0xbb, 0x5d, 0x7a, ]/_,\n-        [ 0xa7, 0xad, 0x6b, 0x22, 0x46, 0x2f, 0xb3, 0xf4, ]/_,\n-        [ 0xfb, 0xe5, 0x0e, 0x86, 0xbc, 0x8f, 0x1e, 0x75, ]/_,\n-        [ 0x90, 0x3d, 0x84, 0xc0, 0x27, 0x56, 0xea, 0x14, ]/_,\n-        [ 0xee, 0xf2, 0x7a, 0x8e, 0x90, 0xca, 0x23, 0xf7, ]/_,\n-        [ 0xe5, 0x45, 0xbe, 0x49, 0x61, 0xca, 0x29, 0xa1, ]/_,\n-        [ 0xdb, 0x9b, 0xc2, 0x57, 0x7f, 0xcc, 0x2a, 0x3f, ]/_,\n-        [ 0x94, 0x47, 0xbe, 0x2c, 0xf5, 0xe9, 0x9a, 0x69, ]/_,\n-        [ 0x9c, 0xd3, 0x8d, 0x96, 0xf0, 0xb3, 0xc1, 0x4b, ]/_,\n-        [ 0xbd, 0x61, 0x79, 0xa7, 0x1d, 0xc9, 0x6d, 0xbb, ]/_,\n-        [ 0x98, 0xee, 0xa2, 0x1a, 0xf2, 0x5c, 0xd6, 0xbe, ]/_,\n-        [ 0xc7, 0x67, 0x3b, 0x2e, 0xb0, 0xcb, 0xf2, 0xd0, ]/_,\n-        [ 0x88, 0x3e, 0xa3, 0xe3, 0x95, 0x67, 0x53, 0x93, ]/_,\n-        [ 0xc8, 0xce, 0x5c, 0xcd, 0x8c, 0x03, 0x0c, 0xa8, ]/_,\n-        [ 0x94, 0xaf, 0x49, 0xf6, 0xc6, 0x50, 0xad, 0xb8, ]/_,\n-        [ 0xea, 0xb8, 0x85, 0x8a, 0xde, 0x92, 0xe1, 0xbc, ]/_,\n-        [ 0xf3, 0x15, 0xbb, 0x5b, 0xb8, 0x35, 0xd8, 0x17, ]/_,\n-        [ 0xad, 0xcf, 0x6b, 0x07, 0x63, 0x61, 0x2e, 0x2f, ]/_,\n-        [ 0xa5, 0xc9, 0x1d, 0xa7, 0xac, 0xaa, 0x4d, 0xde, ]/_,\n-        [ 0x71, 0x65, 0x95, 0x87, 0x66, 0x50, 0xa2, 0xa6, ]/_,\n-        [ 0x28, 0xef, 0x49, 0x5c, 0x53, 0xa3, 0x87, 0xad, ]/_,\n-        [ 0x42, 0xc3, 0x41, 0xd8, 0xfa, 0x92, 0xd8, 0x32, ]/_,\n-        [ 0xce, 0x7c, 0xf2, 0x72, 0x2f, 0x51, 0x27, 0x71, ]/_,\n-        [ 0xe3, 0x78, 0x59, 0xf9, 0x46, 0x23, 0xf3, 0xa7, ]/_,\n-        [ 0x38, 0x12, 0x05, 0xbb, 0x1a, 0xb0, 0xe0, 0x12, ]/_,\n-        [ 0xae, 0x97, 0xa1, 0x0f, 0xd4, 0x34, 0xe0, 0x15, ]/_,\n-        [ 0xb4, 0xa3, 0x15, 0x08, 0xbe, 0xff, 0x4d, 0x31, ]/_,\n-        [ 0x81, 0x39, 0x62, 0x29, 0xf0, 0x90, 0x79, 0x02, ]/_,\n-        [ 0x4d, 0x0c, 0xf4, 0x9e, 0xe5, 0xd4, 0xdc, 0xca, ]/_,\n-        [ 0x5c, 0x73, 0x33, 0x6a, 0x76, 0xd8, 0xbf, 0x9a, ]/_,\n-        [ 0xd0, 0xa7, 0x04, 0x53, 0x6b, 0xa9, 0x3e, 0x0e, ]/_,\n-        [ 0x92, 0x59, 0x58, 0xfc, 0xd6, 0x42, 0x0c, 0xad, ]/_,\n-        [ 0xa9, 0x15, 0xc2, 0x9b, 0xc8, 0x06, 0x73, 0x18, ]/_,\n-        [ 0x95, 0x2b, 0x79, 0xf3, 0xbc, 0x0a, 0xa6, 0xd4, ]/_,\n-        [ 0xf2, 0x1d, 0xf2, 0xe4, 0x1d, 0x45, 0x35, 0xf9, ]/_,\n-        [ 0x87, 0x57, 0x75, 0x19, 0x04, 0x8f, 0x53, 0xa9, ]/_,\n-        [ 0x10, 0xa5, 0x6c, 0xf5, 0xdf, 0xcd, 0x9a, 0xdb, ]/_,\n-        [ 0xeb, 0x75, 0x09, 0x5c, 0xcd, 0x98, 0x6c, 0xd0, ]/_,\n-        [ 0x51, 0xa9, 0xcb, 0x9e, 0xcb, 0xa3, 0x12, 0xe6, ]/_,\n-        [ 0x96, 0xaf, 0xad, 0xfc, 0x2c, 0xe6, 0x66, 0xc7, ]/_,\n-        [ 0x72, 0xfe, 0x52, 0x97, 0x5a, 0x43, 0x64, 0xee, ]/_,\n-        [ 0x5a, 0x16, 0x45, 0xb2, 0x76, 0xd5, 0x92, 0xa1, ]/_,\n-        [ 0xb2, 0x74, 0xcb, 0x8e, 0xbf, 0x87, 0x87, 0x0a, ]/_,\n-        [ 0x6f, 0x9b, 0xb4, 0x20, 0x3d, 0xe7, 0xb3, 0x81, ]/_,\n-        [ 0xea, 0xec, 0xb2, 0xa3, 0x0b, 0x22, 0xa8, 0x7f, ]/_,\n-        [ 0x99, 0x24, 0xa4, 0x3c, 0xc1, 0x31, 0x57, 0x24, ]/_,\n-        [ 0xbd, 0x83, 0x8d, 0x3a, 0xaf, 0xbf, 0x8d, 0xb7, ]/_,\n-        [ 0x0b, 0x1a, 0x2a, 0x32, 0x65, 0xd5, 0x1a, 0xea, ]/_,\n-        [ 0x13, 0x50, 0x79, 0xa3, 0x23, 0x1c, 0xe6, 0x60, ]/_,\n-        [ 0x93, 0x2b, 0x28, 0x46, 0xe4, 0xd7, 0x06, 0x66, ]/_,\n-        [ 0xe1, 0x91, 0x5f, 0x5c, 0xb1, 0xec, 0xa4, 0x6c, ]/_,\n-        [ 0xf3, 0x25, 0x96, 0x5c, 0xa1, 0x6d, 0x62, 0x9f, ]/_,\n-        [ 0x57, 0x5f, 0xf2, 0x8e, 0x60, 0x38, 0x1b, 0xe5, ]/_,\n-        [ 0x72, 0x45, 0x06, 0xeb, 0x4c, 0x32, 0x8a, 0x95, ]/_\n-    ]/_;\n+    let vecs : [[u8 * 8] * 64] = [\n+        [ 0x31, 0x0e, 0x0e, 0xdd, 0x47, 0xdb, 0x6f, 0x72, ],\n+        [ 0xfd, 0x67, 0xdc, 0x93, 0xc5, 0x39, 0xf8, 0x74, ],\n+        [ 0x5a, 0x4f, 0xa9, 0xd9, 0x09, 0x80, 0x6c, 0x0d, ],\n+        [ 0x2d, 0x7e, 0xfb, 0xd7, 0x96, 0x66, 0x67, 0x85, ],\n+        [ 0xb7, 0x87, 0x71, 0x27, 0xe0, 0x94, 0x27, 0xcf, ],\n+        [ 0x8d, 0xa6, 0x99, 0xcd, 0x64, 0x55, 0x76, 0x18, ],\n+        [ 0xce, 0xe3, 0xfe, 0x58, 0x6e, 0x46, 0xc9, 0xcb, ],\n+        [ 0x37, 0xd1, 0x01, 0x8b, 0xf5, 0x00, 0x02, 0xab, ],\n+        [ 0x62, 0x24, 0x93, 0x9a, 0x79, 0xf5, 0xf5, 0x93, ],\n+        [ 0xb0, 0xe4, 0xa9, 0x0b, 0xdf, 0x82, 0x00, 0x9e, ],\n+        [ 0xf3, 0xb9, 0xdd, 0x94, 0xc5, 0xbb, 0x5d, 0x7a, ],\n+        [ 0xa7, 0xad, 0x6b, 0x22, 0x46, 0x2f, 0xb3, 0xf4, ],\n+        [ 0xfb, 0xe5, 0x0e, 0x86, 0xbc, 0x8f, 0x1e, 0x75, ],\n+        [ 0x90, 0x3d, 0x84, 0xc0, 0x27, 0x56, 0xea, 0x14, ],\n+        [ 0xee, 0xf2, 0x7a, 0x8e, 0x90, 0xca, 0x23, 0xf7, ],\n+        [ 0xe5, 0x45, 0xbe, 0x49, 0x61, 0xca, 0x29, 0xa1, ],\n+        [ 0xdb, 0x9b, 0xc2, 0x57, 0x7f, 0xcc, 0x2a, 0x3f, ],\n+        [ 0x94, 0x47, 0xbe, 0x2c, 0xf5, 0xe9, 0x9a, 0x69, ],\n+        [ 0x9c, 0xd3, 0x8d, 0x96, 0xf0, 0xb3, 0xc1, 0x4b, ],\n+        [ 0xbd, 0x61, 0x79, 0xa7, 0x1d, 0xc9, 0x6d, 0xbb, ],\n+        [ 0x98, 0xee, 0xa2, 0x1a, 0xf2, 0x5c, 0xd6, 0xbe, ],\n+        [ 0xc7, 0x67, 0x3b, 0x2e, 0xb0, 0xcb, 0xf2, 0xd0, ],\n+        [ 0x88, 0x3e, 0xa3, 0xe3, 0x95, 0x67, 0x53, 0x93, ],\n+        [ 0xc8, 0xce, 0x5c, 0xcd, 0x8c, 0x03, 0x0c, 0xa8, ],\n+        [ 0x94, 0xaf, 0x49, 0xf6, 0xc6, 0x50, 0xad, 0xb8, ],\n+        [ 0xea, 0xb8, 0x85, 0x8a, 0xde, 0x92, 0xe1, 0xbc, ],\n+        [ 0xf3, 0x15, 0xbb, 0x5b, 0xb8, 0x35, 0xd8, 0x17, ],\n+        [ 0xad, 0xcf, 0x6b, 0x07, 0x63, 0x61, 0x2e, 0x2f, ],\n+        [ 0xa5, 0xc9, 0x1d, 0xa7, 0xac, 0xaa, 0x4d, 0xde, ],\n+        [ 0x71, 0x65, 0x95, 0x87, 0x66, 0x50, 0xa2, 0xa6, ],\n+        [ 0x28, 0xef, 0x49, 0x5c, 0x53, 0xa3, 0x87, 0xad, ],\n+        [ 0x42, 0xc3, 0x41, 0xd8, 0xfa, 0x92, 0xd8, 0x32, ],\n+        [ 0xce, 0x7c, 0xf2, 0x72, 0x2f, 0x51, 0x27, 0x71, ],\n+        [ 0xe3, 0x78, 0x59, 0xf9, 0x46, 0x23, 0xf3, 0xa7, ],\n+        [ 0x38, 0x12, 0x05, 0xbb, 0x1a, 0xb0, 0xe0, 0x12, ],\n+        [ 0xae, 0x97, 0xa1, 0x0f, 0xd4, 0x34, 0xe0, 0x15, ],\n+        [ 0xb4, 0xa3, 0x15, 0x08, 0xbe, 0xff, 0x4d, 0x31, ],\n+        [ 0x81, 0x39, 0x62, 0x29, 0xf0, 0x90, 0x79, 0x02, ],\n+        [ 0x4d, 0x0c, 0xf4, 0x9e, 0xe5, 0xd4, 0xdc, 0xca, ],\n+        [ 0x5c, 0x73, 0x33, 0x6a, 0x76, 0xd8, 0xbf, 0x9a, ],\n+        [ 0xd0, 0xa7, 0x04, 0x53, 0x6b, 0xa9, 0x3e, 0x0e, ],\n+        [ 0x92, 0x59, 0x58, 0xfc, 0xd6, 0x42, 0x0c, 0xad, ],\n+        [ 0xa9, 0x15, 0xc2, 0x9b, 0xc8, 0x06, 0x73, 0x18, ],\n+        [ 0x95, 0x2b, 0x79, 0xf3, 0xbc, 0x0a, 0xa6, 0xd4, ],\n+        [ 0xf2, 0x1d, 0xf2, 0xe4, 0x1d, 0x45, 0x35, 0xf9, ],\n+        [ 0x87, 0x57, 0x75, 0x19, 0x04, 0x8f, 0x53, 0xa9, ],\n+        [ 0x10, 0xa5, 0x6c, 0xf5, 0xdf, 0xcd, 0x9a, 0xdb, ],\n+        [ 0xeb, 0x75, 0x09, 0x5c, 0xcd, 0x98, 0x6c, 0xd0, ],\n+        [ 0x51, 0xa9, 0xcb, 0x9e, 0xcb, 0xa3, 0x12, 0xe6, ],\n+        [ 0x96, 0xaf, 0xad, 0xfc, 0x2c, 0xe6, 0x66, 0xc7, ],\n+        [ 0x72, 0xfe, 0x52, 0x97, 0x5a, 0x43, 0x64, 0xee, ],\n+        [ 0x5a, 0x16, 0x45, 0xb2, 0x76, 0xd5, 0x92, 0xa1, ],\n+        [ 0xb2, 0x74, 0xcb, 0x8e, 0xbf, 0x87, 0x87, 0x0a, ],\n+        [ 0x6f, 0x9b, 0xb4, 0x20, 0x3d, 0xe7, 0xb3, 0x81, ],\n+        [ 0xea, 0xec, 0xb2, 0xa3, 0x0b, 0x22, 0xa8, 0x7f, ],\n+        [ 0x99, 0x24, 0xa4, 0x3c, 0xc1, 0x31, 0x57, 0x24, ],\n+        [ 0xbd, 0x83, 0x8d, 0x3a, 0xaf, 0xbf, 0x8d, 0xb7, ],\n+        [ 0x0b, 0x1a, 0x2a, 0x32, 0x65, 0xd5, 0x1a, 0xea, ],\n+        [ 0x13, 0x50, 0x79, 0xa3, 0x23, 0x1c, 0xe6, 0x60, ],\n+        [ 0x93, 0x2b, 0x28, 0x46, 0xe4, 0xd7, 0x06, 0x66, ],\n+        [ 0xe1, 0x91, 0x5f, 0x5c, 0xb1, 0xec, 0xa4, 0x6c, ],\n+        [ 0xf3, 0x25, 0x96, 0x5c, 0xa1, 0x6d, 0x62, 0x9f, ],\n+        [ 0x57, 0x5f, 0xf2, 0x8e, 0x60, 0x38, 0x1b, 0xe5, ],\n+        [ 0x72, 0x45, 0x06, 0xeb, 0x4c, 0x32, 0x8a, 0x95, ]\n+    ];\n \n     let k0 = 0x_07_06_05_04_03_02_01_00_u64;\n     let k1 = 0x_0f_0e_0d_0c_0b_0a_09_08_u64;\n@@ -433,12 +433,12 @@ pub fn test_siphash() {\n     let stream_inc = &State(k0,k1);\n     let stream_full = &State(k0,k1);\n \n-    fn to_hex_str(r:  &[u8]/8) -> ~str {\n+    fn to_hex_str(r:  &[u8 * 8]) -> ~str {\n         let mut s = ~\"\";\n         for vec::each(*r) |b| {\n             s += uint::to_str(*b as uint, 16u);\n         }\n-        return s;\n+        move s\n     }\n \n     while t < 64 {"}, {"sha": "5a2b054dd3e83de1790d3e7ac650d8eb16097ef5", "filename": "src/libcore/int-template.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibcore%2Fint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibcore%2Fint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fint-template.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820", "patch": "@@ -50,7 +50,6 @@ pub pure fn compl(i: T) -> T {\n }\n \n /// Computes the absolute value\n-// FIXME: abs should return an unsigned int (#2353)\n pub pure fn abs(i: T) -> T {\n     if is_negative(i) { -i } else { i }\n }\n@@ -154,15 +153,15 @@ impl T : FromStr {\n }\n \n /// Convert to a string in a given base\n-pub fn to_str(n: T, radix: uint) -> ~str {\n+pub pure fn to_str(n: T, radix: uint) -> ~str {\n     do to_str_bytes(n, radix) |slice| {\n         do vec::as_imm_buf(slice) |p, len| {\n             unsafe { str::raw::from_buf_len(p, len) }\n         }\n     }\n }\n \n-pub fn to_str_bytes<U>(n: T, radix: uint, f: fn(v: &[u8]) -> U) -> U {\n+pub pure fn to_str_bytes<U>(n: T, radix: uint, f: fn(v: &[u8]) -> U) -> U {\n     if n < 0 as T {\n         uint::to_str_bytes(true, -n as uint, radix, f)\n     } else {\n@@ -171,7 +170,7 @@ pub fn to_str_bytes<U>(n: T, radix: uint, f: fn(v: &[u8]) -> U) -> U {\n }\n \n /// Convert to a string\n-pub fn str(i: T) -> ~str { return to_str(i, 10u); }\n+pub pure fn str(i: T) -> ~str { return to_str(i, 10u); }\n \n // FIXME: Has alignment issues on windows and 32-bit linux (#2609)\n #[test]"}, {"sha": "77f7b5023dfa97839cba366780738bbc51b3d750", "filename": "src/libcore/io.rs", "status": "modified", "additions": 77, "deletions": 67, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820", "patch": "@@ -37,7 +37,7 @@ pub trait Reader {\n     // FIXME (#2004): Seekable really should be orthogonal.\n \n     // FIXME (#2982): This should probably return an error.\n-    fn read(buf: &[mut u8], len: uint) -> uint;\n+    fn read(bytes: &[mut u8], len: uint) -> uint;\n     fn read_byte() -> int;\n     fn unread_byte(int);\n     fn eof() -> bool;\n@@ -65,32 +65,32 @@ pub trait ReaderUtil {\n \n impl<T: Reader> T : ReaderUtil {\n     fn read_bytes(len: uint) -> ~[u8] {\n-        let mut buf = vec::with_capacity(len);\n-        unsafe { vec::raw::set_len(&mut buf, len); }\n+        let mut bytes = vec::with_capacity(len);\n+        unsafe { vec::raw::set_len(&mut bytes, len); }\n \n-        let count = self.read(buf, len);\n+        let count = self.read(bytes, len);\n \n-        unsafe { vec::raw::set_len(&mut buf, count); }\n-        move buf\n+        unsafe { vec::raw::set_len(&mut bytes, count); }\n+        move bytes\n     }\n     fn read_line() -> ~str {\n-        let mut buf = ~[];\n+        let mut bytes = ~[];\n         loop {\n             let ch = self.read_byte();\n             if ch == -1 || ch == 10 { break; }\n-            buf.push(ch as u8);\n+            bytes.push(ch as u8);\n         }\n-        str::from_bytes(buf)\n+        str::from_bytes(bytes)\n     }\n \n     fn read_chars(n: uint) -> ~[char] {\n         // returns the (consumed offset, n_req), appends characters to &chars\n-        fn chars_from_bytes<T: Reader>(buf: &~[u8], chars: &mut ~[char])\n+        fn chars_from_bytes<T: Reader>(bytes: &~[u8], chars: &mut ~[char])\n             -> (uint, uint) {\n             let mut i = 0;\n-            let buf_len = buf.len();\n-            while i < buf_len {\n-                let b0 = buf[i];\n+            let bytes_len = bytes.len();\n+            while i < bytes_len {\n+                let b0 = bytes[i];\n                 let w = str::utf8_char_width(b0);\n                 let end = i + w;\n                 i += 1;\n@@ -100,12 +100,12 @@ impl<T: Reader> T : ReaderUtil {\n                     loop;\n                 }\n                 // can't satisfy this char with the existing data\n-                if end > buf_len {\n-                    return (i - 1, end - buf_len);\n+                if end > bytes_len {\n+                    return (i - 1, end - bytes_len);\n                 }\n                 let mut val = 0;\n                 while i < end {\n-                    let next = buf[i] as int;\n+                    let next = bytes[i] as int;\n                     i += 1;\n                     assert (next > -1);\n                     assert (next & 192 == 128);\n@@ -119,8 +119,8 @@ impl<T: Reader> T : ReaderUtil {\n             }\n             return (i, 0);\n         }\n-        let mut buf: ~[u8] = ~[];\n-        let mut chars: ~[char] = ~[];\n+        let mut bytes = ~[];\n+        let mut chars = ~[];\n         // might need more bytes, but reading n will never over-read\n         let mut nbread = n;\n         while nbread > 0 {\n@@ -130,15 +130,15 @@ impl<T: Reader> T : ReaderUtil {\n                 // we're split in a unicode char?\n                 break;\n             }\n-            buf.push_all(data);\n-            let (offset, nbreq) = chars_from_bytes::<T>(&buf, &mut chars);\n+            bytes.push_all(data);\n+            let (offset, nbreq) = chars_from_bytes::<T>(&bytes, &mut chars);\n             let ncreq = n - chars.len();\n             // again we either know we need a certain number of bytes\n             // to complete a character, or we make sure we don't\n             // over-read by reading 1-byte per char needed\n             nbread = if ncreq > nbreq { ncreq } else { nbreq };\n             if nbread > 0 {\n-                buf = vec::slice(buf, offset, buf.len());\n+                bytes = vec::slice(bytes, offset, bytes.len());\n             }\n         }\n         move chars\n@@ -154,12 +154,12 @@ impl<T: Reader> T : ReaderUtil {\n     }\n \n     fn read_c_str() -> ~str {\n-        let mut buf: ~[u8] = ~[];\n+        let mut bytes: ~[u8] = ~[];\n         loop {\n             let ch = self.read_byte();\n-            if ch < 1 { break; } else { buf.push(ch as u8); }\n+            if ch < 1 { break; } else { bytes.push(ch as u8); }\n         }\n-        str::from_bytes(buf)\n+        str::from_bytes(bytes)\n     }\n \n     // FIXME deal with eof? // #2004\n@@ -191,9 +191,9 @@ impl<T: Reader> T : ReaderUtil {\n     }\n \n     fn read_whole_stream() -> ~[u8] {\n-        let mut buf: ~[u8] = ~[];\n-        while !self.eof() { buf.push_all(self.read_bytes(2048u)); }\n-        move buf\n+        let mut bytes: ~[u8] = ~[];\n+        while !self.eof() { bytes.push_all(self.read_bytes(2048u)); }\n+        move bytes\n     }\n \n     fn each_byte(it: fn(int) -> bool) {\n@@ -226,8 +226,8 @@ fn convert_whence(whence: SeekStyle) -> i32 {\n }\n \n impl *libc::FILE: Reader {\n-    fn read(buf: &[mut u8], len: uint) -> uint {\n-        do vec::as_mut_buf(buf) |buf_p, buf_len| {\n+    fn read(bytes: &[mut u8], len: uint) -> uint {\n+        do vec::as_mut_buf(bytes) |buf_p, buf_len| {\n             assert buf_len <= len;\n \n             let count = libc::fread(buf_p as *mut c_void, 1u as size_t,\n@@ -250,7 +250,9 @@ impl *libc::FILE: Reader {\n // duration of its lifetime.\n // FIXME there really should be a better way to do this // #2004\n impl<T: Reader, C> {base: T, cleanup: C}: Reader {\n-    fn read(buf: &[mut u8], len: uint) -> uint { self.base.read(buf, len) }\n+    fn read(bytes: &[mut u8], len: uint) -> uint {\n+        self.base.read(bytes, len)\n+    }\n     fn read_byte() -> int { self.base.read_byte() }\n     fn unread_byte(byte: int) { self.base.unread_byte(byte); }\n     fn eof() -> bool { self.base.eof() }\n@@ -297,39 +299,41 @@ pub fn file_reader(path: &Path) -> Result<Reader, ~str> {\n }\n \n \n-// Byte buffer readers\n-\n-pub type ByteBuf = {buf: &[const u8], mut pos: uint};\n+// Byte readers\n+pub struct BytesReader {\n+    bytes: &[u8],\n+    mut pos: uint\n+}\n \n-impl ByteBuf: Reader {\n-    fn read(buf: &[mut u8], len: uint) -> uint {\n-        let count = uint::min(len, self.buf.len() - self.pos);\n+impl BytesReader: Reader {\n+    fn read(bytes: &[mut u8], len: uint) -> uint {\n+        let count = uint::min(len, self.bytes.len() - self.pos);\n \n-        let view = vec::const_view(self.buf, self.pos, self.buf.len());\n-        vec::bytes::memcpy(buf, view, count);\n+        let view = vec::view(self.bytes, self.pos, self.bytes.len());\n+        vec::bytes::memcpy(bytes, view, count);\n \n         self.pos += count;\n \n         count\n     }\n     fn read_byte() -> int {\n-        if self.pos == self.buf.len() { return -1; }\n-        let b = self.buf[self.pos];\n+        if self.pos == self.bytes.len() { return -1; }\n+        let b = self.bytes[self.pos];\n         self.pos += 1u;\n         return b as int;\n     }\n     // FIXME (#2738): implement this\n     fn unread_byte(_byte: int) { error!(\"Unimplemented: unread_byte\"); fail; }\n-    fn eof() -> bool { self.pos == self.buf.len() }\n+    fn eof() -> bool { self.pos == self.bytes.len() }\n     fn seek(offset: int, whence: SeekStyle) {\n         let pos = self.pos;\n-        self.pos = seek_in_buf(offset, pos, self.buf.len(), whence);\n+        self.pos = seek_in_buf(offset, pos, self.bytes.len(), whence);\n     }\n     fn tell() -> uint { self.pos }\n }\n \n-pub fn with_bytes_reader<t>(bytes: &[u8], f: fn(Reader) -> t) -> t {\n-    f({buf: bytes, mut pos: 0u} as Reader)\n+pub pure fn with_bytes_reader<t>(bytes: &[u8], f: fn(Reader) -> t) -> t {\n+    f(BytesReader { bytes: bytes, pos: 0u } as Reader)\n }\n \n pub fn with_str_reader<T>(s: &str, f: fn(Reader) -> T) -> T {\n@@ -602,10 +606,10 @@ impl<T: Writer> T : WriterUtil {\n         self.write_str(&\"\\n\");\n     }\n     fn write_int(n: int) {\n-        int::to_str_bytes(n, 10u, |buf| self.write(buf))\n+        int::to_str_bytes(n, 10u, |bytes| self.write(bytes))\n     }\n     fn write_uint(n: uint) {\n-        uint::to_str_bytes(false, n, 10u, |buf| self.write(buf))\n+        uint::to_str_bytes(false, n, 10u, |bytes| self.write(bytes))\n     }\n     fn write_le_uint(n: uint) {\n         u64_to_le_bytes(n as u64, uint::bytes, |v| self.write(v))\n@@ -687,34 +691,34 @@ pub fn print(s: &str) { stdout().write_str(s); }\n pub fn println(s: &str) { stdout().write_line(s); }\n \n pub struct BytesWriter {\n-    buf: DVec<u8>,\n+    bytes: DVec<u8>,\n     mut pos: uint,\n }\n \n impl BytesWriter: Writer {\n     fn write(v: &[const u8]) {\n-        do self.buf.swap |buf| {\n-            let mut buf <- buf;\n+        do self.bytes.swap |bytes| {\n+            let mut bytes <- bytes;\n             let v_len = v.len();\n-            let buf_len = buf.len();\n+            let bytes_len = bytes.len();\n \n-            let count = uint::max(buf_len, self.pos + v_len);\n-            vec::reserve(&mut buf, count);\n-            unsafe { vec::raw::set_len(&mut buf, count); }\n+            let count = uint::max(bytes_len, self.pos + v_len);\n+            vec::reserve(&mut bytes, count);\n+            unsafe { vec::raw::set_len(&mut bytes, count); }\n \n             {\n-                let view = vec::mut_view(buf, self.pos, count);\n+                let view = vec::mut_view(bytes, self.pos, count);\n                 vec::bytes::memcpy(view, v, v_len);\n             }\n \n             self.pos += v_len;\n \n-            move buf\n+            move bytes\n         }\n     }\n     fn seek(offset: int, whence: SeekStyle) {\n         let pos = self.pos;\n-        let len = self.buf.len();\n+        let len = self.bytes.len();\n         self.pos = seek_in_buf(offset, pos, len, whence);\n     }\n     fn tell() -> uint { self.pos }\n@@ -730,24 +734,28 @@ impl @BytesWriter : Writer {\n     fn get_type() -> WriterType { (*self).get_type() }\n }\n \n-pub fn BytesWriter() -> BytesWriter {\n-    BytesWriter { buf: DVec(), mut pos: 0u }\n+pub pure fn BytesWriter() -> BytesWriter {\n+    BytesWriter { bytes: DVec(), mut pos: 0u }\n }\n \n-pub fn with_bytes_writer(f: fn(Writer)) -> ~[u8] {\n+pub pure fn with_bytes_writer(f: fn(Writer)) -> ~[u8] {\n     let wr = @BytesWriter();\n     f(wr as Writer);\n-    wr.buf.check_out(|buf| buf)\n+    // FIXME (#3758): This should not be needed.\n+    unsafe { wr.bytes.check_out(|bytes| move bytes) }\n }\n \n-pub fn with_str_writer(f: fn(Writer)) -> ~str {\n+pub pure fn with_str_writer(f: fn(Writer)) -> ~str {\n     let mut v = with_bytes_writer(f);\n \n-    // Make sure the vector has a trailing null and is proper utf8.\n-    v.push(0);\n+    // FIXME (#3758): This should not be needed.\n+    unsafe {\n+        // Make sure the vector has a trailing null and is proper utf8.\n+        v.push(0);\n+    }\n     assert str::is_utf8(v);\n \n-    unsafe { move ::cast::transmute(v) }\n+    unsafe { move ::cast::transmute(move v) }\n }\n \n // Utility functions\n@@ -975,15 +983,17 @@ mod tests {\n     fn bytes_buffer_overwrite() {\n         let wr = BytesWriter();\n         wr.write(~[0u8, 1u8, 2u8, 3u8]);\n-        assert wr.buf.borrow(|buf| buf == ~[0u8, 1u8, 2u8, 3u8]);\n+        assert wr.bytes.borrow(|bytes| bytes == ~[0u8, 1u8, 2u8, 3u8]);\n         wr.seek(-2, SeekCur);\n         wr.write(~[4u8, 5u8, 6u8, 7u8]);\n-        assert wr.buf.borrow(|buf| buf == ~[0u8, 1u8, 4u8, 5u8, 6u8, 7u8]);\n+        assert wr.bytes.borrow(|bytes| bytes ==\n+            ~[0u8, 1u8, 4u8, 5u8, 6u8, 7u8]);\n         wr.seek(-2, SeekEnd);\n         wr.write(~[8u8]);\n         wr.seek(1, SeekSet);\n         wr.write(~[9u8]);\n-        assert wr.buf.borrow(|buf| buf == ~[0u8, 9u8, 4u8, 5u8, 8u8, 7u8]);\n+        assert wr.bytes.borrow(|bytes| bytes ==\n+            ~[0u8, 9u8, 4u8, 5u8, 8u8, 7u8]);\n     }\n }\n "}, {"sha": "1b5f11569c37d825d292308ed4b9c75dd5241b16", "filename": "src/libcore/iter-trait/dlist.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibcore%2Fiter-trait%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibcore%2Fiter-trait%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter-trait%2Fdlist.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820", "patch": "@@ -11,7 +11,7 @@ pub type IMPL_T<A> = dlist::DList<A>;\n pub pure fn EACH<A>(self: &IMPL_T<A>, f: fn(v: &A) -> bool) {\n     let mut link = self.peek_n();\n     while option::is_some(&link) {\n-        let nobe = option::get(&link);\n+        let nobe = option::get(link);\n         assert nobe.linked;\n         if !f(&nobe.data) { break; }\n         // Check (weakly) that the user didn't do a remove."}, {"sha": "7ed43f619e13e2cad1bbb3336fcdff892f0a023a", "filename": "src/libcore/libc.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibcore%2Flibc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibcore%2Flibc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flibc.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820", "patch": "@@ -42,8 +42,6 @@\n // Initial glob-exports mean that all the contents of all the modules\n // wind up exported, if you're interested in writing platform-specific code.\n \n-// FIXME (#2006): change these to glob-exports when sufficiently supported.\n-\n pub use types::common::c95::*;\n pub use types::common::c99::*;\n pub use types::common::posix88::*;\n@@ -89,7 +87,7 @@ pub use funcs::extra::*;\n \n pub use size_t;\n pub use c_float, c_double, c_void, FILE, fpos_t;\n-pub use DIR, dirent;\n+pub use DIR, dirent_t;\n pub use c_char, c_schar, c_uchar;\n pub use c_short, c_ushort, c_int, c_uint, c_long, c_ulong;\n pub use size_t, ptrdiff_t, clock_t, time_t;\n@@ -149,7 +147,7 @@ mod types {\n         }\n         pub mod posix88 {\n             pub enum DIR {}\n-            pub enum dirent {}\n+            pub enum dirent_t {}\n         }\n         pub mod posix01 {}\n         pub mod posix08 {}\n@@ -1021,7 +1019,7 @@ pub mod funcs {\n         pub extern mod dirent {\n             fn opendir(dirname: *c_char) -> *DIR;\n             fn closedir(dirp: *DIR) -> c_int;\n-            fn readdir(dirp: *DIR) -> *dirent;\n+            fn readdir(dirp: *DIR) -> *dirent_t;\n             fn rewinddir(dirp: *DIR);\n             fn seekdir(dirp: *DIR, loc: c_long);\n             fn telldir(dirp: *DIR) -> c_long;"}, {"sha": "958d1ac56ea78101e7911f5f542c7b28b90ac6cd", "filename": "src/libcore/logging.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibcore%2Flogging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibcore%2Flogging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flogging.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820", "patch": "@@ -32,7 +32,7 @@ pub fn console_off() {\n #[cfg(notest)]\n #[lang=\"log_type\"]\n pub fn log_type<T>(level: u32, object: &T) {\n-    let bytes = do io::with_bytes_writer() |writer| {\n+    let bytes = do io::with_bytes_writer |writer| {\n         repr::write_repr(writer, object);\n     };\n     unsafe {"}, {"sha": "56a6df2c4ddf159510808d92fcae9e0a56d66d25", "filename": "src/libcore/mutable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibcore%2Fmutable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibcore%2Fmutable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmutable.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820", "patch": "@@ -24,15 +24,15 @@ struct Data<T> {\n pub type Mut<T> = Data<T>;\n \n pub fn Mut<T>(t: T) -> Mut<T> {\n-    Data {value: t, mode: ReadOnly}\n+    Data {value: move t, mode: ReadOnly}\n }\n \n pub fn unwrap<T>(m: Mut<T>) -> T {\n     // Borrowck should prevent us from calling unwrap while the value\n     // is in use, as that would be a move from a borrowed value.\n     assert (m.mode as uint) == (ReadOnly as uint);\n     let Data {value: move value, mode: _} = move m;\n-    return value;\n+    move value\n }\n \n impl<T> Data<T> {"}, {"sha": "baabc35b428c2c1fc92fb6cb597438a1c0f5426b", "filename": "src/libcore/option.rs", "status": "modified", "additions": 17, "deletions": 19, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820", "patch": "@@ -42,7 +42,7 @@ pub enum Option<T> {\n     Some(T),\n }\n \n-pub pure fn get<T: Copy>(opt: &Option<T>) -> T {\n+pub pure fn get<T: Copy>(opt: Option<T>) -> T {\n     /*!\n     Gets the value out of an option\n \n@@ -58,7 +58,7 @@ pub pure fn get<T: Copy>(opt: &Option<T>) -> T {\n     case explicitly.\n     */\n \n-    match *opt {\n+    match opt {\n       Some(copy x) => return x,\n       None => fail ~\"option::get none\"\n     }\n@@ -85,7 +85,7 @@ pub pure fn get_ref<T>(opt: &r/Option<T>) -> &r/T {\n     }\n }\n \n-pub pure fn expect<T: Copy>(opt: &Option<T>, reason: ~str) -> T {\n+pub pure fn expect<T: Copy>(opt: Option<T>, reason: ~str) -> T {\n     /*!\n      * Gets the value out of an option, printing a specified message on\n      * failure\n@@ -94,7 +94,7 @@ pub pure fn expect<T: Copy>(opt: &Option<T>, reason: ~str) -> T {\n      *\n      * Fails if the value equals `none`\n      */\n-    match *opt { Some(copy x) => x, None => fail reason }\n+    match opt { Some(copy x) => x, None => fail reason }\n }\n \n pub pure fn map<T, U>(opt: &Option<T>, f: fn(x: &T) -> U) -> Option<U> {\n@@ -119,11 +119,9 @@ pub pure fn chain<T, U>(opt: Option<T>,\n      * function that returns an option.\n      */\n \n-    // XXX write with move match\n-    if opt.is_some() {\n-        f(unwrap(opt))\n-    } else {\n-        None\n+    match move opt {\n+        Some(move t) => f(move t),\n+        None => None\n     }\n }\n \n@@ -169,10 +167,10 @@ pub pure fn is_some<T>(opt: &Option<T>) -> bool {\n     !is_none(opt)\n }\n \n-pub pure fn get_default<T: Copy>(opt: &Option<T>, def: T) -> T {\n+pub pure fn get_default<T: Copy>(opt: Option<T>, def: T) -> T {\n     //! Returns the contained value or a default\n \n-    match *opt { Some(copy x) => x, None => def }\n+    match opt { Some(copy x) => x, None => def }\n }\n \n pub pure fn map_default<T, U>(opt: &Option<T>, def: U,\n@@ -227,7 +225,7 @@ pub fn swap_unwrap<T>(opt: &mut Option<T>) -> T {\n \n pub pure fn unwrap_expect<T>(opt: Option<T>, reason: &str) -> T {\n     //! As unwrap, but with a specified failure message.\n-    if opt.is_none() { fail reason.to_unique(); }\n+    if opt.is_none() { fail reason.to_owned(); }\n     unwrap(move opt)\n }\n \n@@ -286,8 +284,8 @@ impl<T: Copy> Option<T> {\n     Instead, prefer to use pattern matching and handle the `None`\n     case explicitly.\n     */\n-    pure fn get() -> T { get(&self) }\n-    pure fn get_default(def: T) -> T { get_default(&self, def) }\n+    pure fn get() -> T { get(self) }\n+    pure fn get_default(def: T) -> T { get_default(self, def) }\n     /**\n      * Gets the value out of an option, printing a specified message on\n      * failure\n@@ -296,7 +294,7 @@ impl<T: Copy> Option<T> {\n      *\n      * Fails if the value equals `none`\n      */\n-    pure fn expect(reason: ~str) -> T { expect(&self, reason) }\n+    pure fn expect(reason: ~str) -> T { expect(self, move reason) }\n     /// Applies a function zero or more times until the result is none.\n     pure fn while_some(blk: fn(v: T) -> Option<T>) { while_some(self, blk) }\n }\n@@ -326,8 +324,8 @@ impl<T: Eq> Option<T> : Eq {\n fn test_unwrap_ptr() {\n     let x = ~0;\n     let addr_x = ptr::addr_of(&(*x));\n-    let opt = Some(x);\n-    let y = unwrap(opt);\n+    let opt = Some(move x);\n+    let y = unwrap(move opt);\n     let addr_y = ptr::addr_of(&(*y));\n     assert addr_x == addr_y;\n }\n@@ -358,8 +356,8 @@ fn test_unwrap_resource() {\n     let i = @mut 0;\n     {\n         let x = R(i);\n-        let opt = Some(x);\n-        let _y = unwrap(opt);\n+        let opt = Some(move x);\n+        let _y = unwrap(move opt);\n     }\n     assert *i == 1;\n }"}, {"sha": "a834bb84f8d8777131e6a39d81ac16b6779cfe56", "filename": "src/libcore/os.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820", "patch": "@@ -473,15 +473,15 @@ pub fn tmpdir() -> Path {\n     #[cfg(unix)]\n     #[allow(non_implicitly_copyable_typarams)]\n     fn lookup() -> Path {\n-        option::get_default(&getenv_nonempty(\"TMPDIR\"),\n+        option::get_default(getenv_nonempty(\"TMPDIR\"),\n                             Path(\"/tmp\"))\n     }\n \n     #[cfg(windows)]\n     #[allow(non_implicitly_copyable_typarams)]\n     fn lookup() -> Path {\n         option::get_default(\n-                    &option::or(getenv_nonempty(\"TMP\"),\n+                    option::or(getenv_nonempty(\"TMP\"),\n                     option::or(getenv_nonempty(\"TEMP\"),\n                     option::or(getenv_nonempty(\"USERPROFILE\"),\n                                getenv_nonempty(\"WINDIR\")))),\n@@ -739,7 +739,7 @@ unsafe fn load_argc_and_argv(argc: c_int, argv: **c_char) -> ~[~str] {\n     for uint::range(0, argc as uint) |i| {\n         vec::push(&mut args, str::raw::from_c_str(*argv.offset(i)));\n     }\n-    return args;\n+    move args\n }\n \n /**\n@@ -903,7 +903,7 @@ mod tests {\n         let rng: rand::Rng = rand::Rng();\n         let n = ~\"TEST\" + rng.gen_str(10u);\n         assert getenv(n).is_none();\n-        n\n+        move n\n     }\n \n     #[test]\n@@ -937,7 +937,7 @@ mod tests {\n         let n = make_rand_name();\n         setenv(n, s);\n         log(debug, s);\n-        assert getenv(n) == option::Some(s);\n+        assert getenv(n) == option::Some(move s);\n     }\n \n     #[test]\n@@ -963,7 +963,7 @@ mod tests {\n             // MingW seems to set some funky environment variables like\n             // \"=C:=C:\\MinGW\\msys\\1.0\\bin\" and \"!::=::\\\" that are returned\n             // from env() but not visible from getenv().\n-            assert v2.is_none() || v2 == option::Some(v);\n+            assert v2.is_none() || v2 == option::Some(move v);\n         }\n     }\n \n@@ -976,7 +976,7 @@ mod tests {\n         assert !vec::contains(e, &(copy n, ~\"VALUE\"));\n \n         e = env();\n-        assert vec::contains(e, &(n, ~\"VALUE\"));\n+        assert vec::contains(e, &(move n, ~\"VALUE\"));\n     }\n \n     #[test]"}, {"sha": "871e803ff1a5a1a1109e8235b8fa48c99de56658", "filename": "src/libcore/path.rs", "status": "modified", "additions": 35, "deletions": 16, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibcore%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibcore%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpath.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820", "patch": "@@ -61,7 +61,7 @@ pub pure fn Path(s: &str) -> Path {\n }\n \n impl PosixPath : ToStr {\n-    fn to_str() -> ~str {\n+    pure fn to_str() -> ~str {\n         let mut s = ~\"\";\n         if self.is_absolute {\n             s += \"/\";\n@@ -96,7 +96,7 @@ impl PosixPath : GenericPath {\n         let mut components = str::split_nonempty(s, |c| c == '/');\n         let is_absolute = (s.len() != 0 && s[0] == '/' as u8);\n         return PosixPath { is_absolute: is_absolute,\n-                           components: components }\n+                           components: move components }\n     }\n \n     pure fn dirname() -> ~str {\n@@ -192,7 +192,7 @@ impl PosixPath : GenericPath {\n           Some(ref f) => ~[copy *f]\n         };\n         return PosixPath { is_absolute: false,\n-                           components: cs }\n+                           components: move cs }\n     }\n \n     pure fn push_rel(other: &PosixPath) -> PosixPath {\n@@ -208,7 +208,8 @@ impl PosixPath : GenericPath {\n                 |c| windows::is_sep(c as u8));\n             unsafe { v.push_all_move(move ss); }\n         }\n-        PosixPath { components: move v, ..self }\n+        PosixPath { is_absolute: self.is_absolute,\n+                    components: move v }\n     }\n \n     pure fn push(s: &str) -> PosixPath {\n@@ -223,20 +224,25 @@ impl PosixPath : GenericPath {\n         if cs.len() != 0 {\n             unsafe { cs.pop(); }\n         }\n-        return PosixPath { components: move cs, ..self }\n+        return PosixPath {\n+            is_absolute: self.is_absolute,\n+            components: move cs\n+        }\n+                          //..self }\n     }\n \n     pure fn normalize() -> PosixPath {\n         return PosixPath {\n-            components: normalize(self.components),\n-            ..self\n+            is_absolute: self.is_absolute,\n+            components: normalize(self.components)\n+          //  ..self\n         }\n     }\n }\n \n \n impl WindowsPath : ToStr {\n-    fn to_str() -> ~str {\n+    pure fn to_str() -> ~str {\n         let mut s = ~\"\";\n         match self.host {\n           Some(ref h) => { s += \"\\\\\\\\\"; s += *h; }\n@@ -286,10 +292,10 @@ impl WindowsPath : GenericPath {\n         let mut components =\n             str::split_nonempty(rest, |c| windows::is_sep(c as u8));\n         let is_absolute = (rest.len() != 0 && windows::is_sep(rest[0]));\n-        return WindowsPath { host: host,\n-                             device: device,\n+        return WindowsPath { host: move host,\n+                             device: move device,\n                              is_absolute: is_absolute,\n-                             components: components }\n+                             components: move components }\n     }\n \n     pure fn dirname() -> ~str {\n@@ -386,7 +392,7 @@ impl WindowsPath : GenericPath {\n         return WindowsPath { host: None,\n                              device: None,\n                              is_absolute: false,\n-                             components: cs }\n+                             components: move cs }\n     }\n \n     pure fn push_rel(other: &WindowsPath) -> WindowsPath {\n@@ -402,7 +408,13 @@ impl WindowsPath : GenericPath {\n                 |c| windows::is_sep(c as u8));\n             unsafe { v.push_all_move(move ss); }\n         }\n-        return WindowsPath { components: move v, ..self }\n+        // tedious, but as-is, we can't use ..self\n+        return WindowsPath {\n+            host: copy self.host,\n+            device: copy self.device,\n+            is_absolute: self.is_absolute,\n+            components: move v\n+        }\n     }\n \n     pure fn push(s: &str) -> WindowsPath {\n@@ -417,13 +429,20 @@ impl WindowsPath : GenericPath {\n         if cs.len() != 0 {\n             unsafe { cs.pop(); }\n         }\n-        return WindowsPath { components: move cs, ..self }\n+        return WindowsPath {\n+            host: copy self.host,\n+            device: copy self.device,\n+            is_absolute: self.is_absolute,\n+            components: move cs\n+        }\n     }\n \n     pure fn normalize() -> WindowsPath {\n         return WindowsPath {\n-            components: normalize(self.components),\n-            ..self\n+            host: copy self.host,\n+            device: copy self.device,\n+            is_absolute: self.is_absolute,\n+            components: normalize(self.components)\n         }\n     }\n }"}, {"sha": "3f8de19498f628c0a7ef662b739d4b8867c22ab4", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820", "patch": "@@ -350,7 +350,8 @@ fn BufferResource<T: Send>(b: ~Buffer<T>) -> BufferResource<T> {\n     atomic_add_acq(&mut b.header.ref_count, 1);\n \n     BufferResource {\n-        buffer: b\n+        // tjc: ????\n+        buffer: move b\n     }\n }\n \n@@ -448,7 +449,12 @@ pub fn try_recv<T: Send, Tbuffer: Send>(p: RecvPacketBuffered<T, Tbuffer>)\n     let this = rustrt::rust_get_task();\n     rustrt::task_clear_event_reject(this);\n     rustrt::rust_task_ref(this);\n+    debug!(\"blocked = %x this = %x\", p.header.blocked_task as uint,\n+           this as uint);\n     let old_task = swap_task(&mut p.header.blocked_task, this);\n+    debug!(\"blocked = %x this = %x old_task = %x\",\n+           p.header.blocked_task as uint,\n+           this as uint, old_task as uint);\n     assert old_task.is_null();\n     let mut first = true;\n     let mut count = SPIN_COUNT;\n@@ -661,7 +667,7 @@ pub fn select2<A: Send, Ab: Send, B: Send, Bb: Send>(\n     -> Either<(Option<A>, RecvPacketBuffered<B, Bb>),\n               (RecvPacketBuffered<A, Ab>, Option<B>)>\n {\n-    let i = wait_many([a.header(), b.header()]/_);\n+    let i = wait_many([a.header(), b.header()]);\n \n     match i {\n       0 => Left((try_recv(move a), move b)),\n@@ -687,7 +693,7 @@ pub fn selecti<T: Selectable>(endpoints: &[T]) -> uint {\n /// Returns 0 or 1 depending on which endpoint is ready to receive\n pub fn select2i<A: Selectable, B: Selectable>(a: &A, b: &B) ->\n         Either<(), ()> {\n-    match wait_many([a.header(), b.header()]/_) {\n+    match wait_many([a.header(), b.header()]) {\n       0 => Left(()),\n       1 => Right(()),\n       _ => fail ~\"wait returned unexpected index\"\n@@ -1212,7 +1218,7 @@ pub mod test {\n \n         c1.send(~\"abc\");\n \n-        match (p1, p2).select() {\n+        match (move p1, move p2).select() {\n           Right(_) => fail,\n           _ => ()\n         }\n@@ -1224,8 +1230,8 @@ pub mod test {\n     pub fn test_oneshot() {\n         let (c, p) = oneshot::init();\n \n-        oneshot::client::send(c, ());\n+        oneshot::client::send(move c, ());\n \n-        recv_one(p)\n+        recv_one(move p)\n     }\n }"}, {"sha": "a54db3fa759b93e4fd269f992aade5fb07a9e642", "filename": "src/libcore/private.rs", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibcore%2Fprivate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibcore%2Fprivate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprivate.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820", "patch": "@@ -374,7 +374,7 @@ pub unsafe fn unwrap_shared_mutable_state<T: Send>(rc: SharedMutableState<T>)\n             rc.data = ptr::null();\n             // Step 1 - drop our own reference.\n             let new_count = rustrt::rust_atomic_decrement(&mut ptr.count);\n-            assert new_count >= 0;\n+        //    assert new_count >= 0;\n             if new_count == 0 {\n                 // We were the last owner. Can unwrap immediately.\n                 // Also we have to free the server endpoints.\n@@ -505,7 +505,7 @@ pub struct Exclusive<T: Send> { x: SharedMutableState<ExData<T>> }\n \n pub fn exclusive<T:Send >(user_data: T) -> Exclusive<T> {\n     let data = ExData {\n-        lock: LittleLock(), mut failed: false, mut data: user_data\n+        lock: LittleLock(), mut failed: false, mut data: move user_data\n     };\n     Exclusive { x: unsafe { shared_mutable_state(move data) } }\n }\n@@ -544,7 +544,7 @@ impl<T: Send> Exclusive<T> {\n     }\n }\n \n-// FIXME(#2585) make this a by-move method on the exclusive\n+// FIXME(#3724) make this a by-move method on the exclusive\n pub fn unwrap_exclusive<T: Send>(arc: Exclusive<T>) -> T {\n     let Exclusive { x: x } <- arc;\n     let inner = unsafe { unwrap_shared_mutable_state(move x) };\n@@ -558,17 +558,17 @@ pub mod tests {\n     pub fn exclusive_arc() {\n         let mut futures = ~[];\n \n-        let num_tasks = 10u;\n-        let count = 10u;\n+        let num_tasks = 10;\n+        let count = 10;\n \n-        let total = exclusive(~mut 0u);\n+        let total = exclusive(~mut 0);\n \n-        for uint::range(0u, num_tasks) |_i| {\n+        for uint::range(0, num_tasks) |_i| {\n             let total = total.clone();\n-            futures.push(future::spawn(|| {\n-                for uint::range(0u, count) |_i| {\n+            futures.push(future::spawn(|move total| {\n+                for uint::range(0, count) |_i| {\n                     do total.with |count| {\n-                        **count += 1u;\n+                        **count += 1;\n                     }\n                 }\n             }));\n@@ -587,7 +587,7 @@ pub mod tests {\n         // accesses will also fail.\n         let x = exclusive(1);\n         let x2 = x.clone();\n-        do task::try {\n+        do task::try |move x2| {\n             do x2.with |one| {\n                 assert *one == 2;\n             }\n@@ -600,27 +600,28 @@ pub mod tests {\n     #[test]\n     pub fn exclusive_unwrap_basic() {\n         let x = exclusive(~~\"hello\");\n-        assert unwrap_exclusive(x) == ~~\"hello\";\n+        assert unwrap_exclusive(move x) == ~~\"hello\";\n     }\n \n     #[test]\n     pub fn exclusive_unwrap_contended() {\n         let x = exclusive(~~\"hello\");\n         let x2 = ~mut Some(x.clone());\n-        do task::spawn {\n+        do task::spawn |move x2| {\n             let x2 = option::swap_unwrap(x2);\n             do x2.with |_hello| { }\n             task::yield();\n         }\n-        assert unwrap_exclusive(x) == ~~\"hello\";\n+        assert unwrap_exclusive(move x) == ~~\"hello\";\n \n         // Now try the same thing, but with the child task blocking.\n         let x = exclusive(~~\"hello\");\n         let x2 = ~mut Some(x.clone());\n         let mut res = None;\n-        do task::task().future_result(|+r| res = Some(r)).spawn {\n+        do task::task().future_result(|+r| res = Some(move r)).spawn\n+              |move x2| {\n             let x2 = option::swap_unwrap(x2);\n-            assert unwrap_exclusive(x2) == ~~\"hello\";\n+            assert unwrap_exclusive(move x2) == ~~\"hello\";\n         }\n         // Have to get rid of our reference before blocking.\n         { let _x = move x; } // FIXME(#3161) util::ignore doesn't work here\n@@ -633,11 +634,12 @@ pub mod tests {\n         let x = exclusive(~~\"hello\");\n         let x2 = ~mut Some(x.clone());\n         let mut res = None;\n-        do task::task().future_result(|+r| res = Some(r)).spawn {\n+        do task::task().future_result(|+r| res = Some(move r)).spawn\n+           |move x2| {\n             let x2 = option::swap_unwrap(x2);\n-            assert unwrap_exclusive(x2) == ~~\"hello\";\n+            assert unwrap_exclusive(move x2) == ~~\"hello\";\n         }\n-        assert unwrap_exclusive(x) == ~~\"hello\";\n+        assert unwrap_exclusive(move x) == ~~\"hello\";\n         let res = option::swap_unwrap(&mut res);\n         future::get(&res);\n     }\n@@ -656,7 +658,7 @@ pub mod tests {\n                 for 10.times { task::yield(); } // try to let the unwrapper go\n                 fail; // punt it awake from its deadlock\n             }\n-            let _z = unwrap_exclusive(x);\n+            let _z = unwrap_exclusive(move x);\n             do x2.with |_hello| { }\n         };\n         assert result.is_err();"}, {"sha": "3fa37a2fb8e5d89efcff66fbfb76cb0987fd72d2", "filename": "src/libcore/reflect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibcore%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibcore%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Freflect.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820", "patch": "@@ -246,7 +246,7 @@ impl<V: TyVisitor MovePtr> MovePtrAdaptor<V>: TyVisitor {\n     }\n \n     fn visit_unboxed_vec(mtbl: uint, inner: *TyDesc) -> bool {\n-        self.align_to::<vec::raw::UnboxedVecRepr>();\n+        self.align_to::<vec::UnboxedVecRepr>();\n         if ! self.inner.visit_vec(mtbl, inner) { return false; }\n         true\n     }"}, {"sha": "b246adcb1d7cddb6bc0a452c2596239ac80d5fd7", "filename": "src/libcore/repr.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibcore%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibcore%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frepr.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820", "patch": "@@ -15,7 +15,8 @@ use to_str::ToStr;\n use cast::transmute;\n use intrinsic::{TyDesc, TyVisitor, visit_tydesc};\n use reflect::{MovePtr, MovePtrAdaptor};\n-use vec::raw::{VecRepr, UnboxedVecRepr, SliceRepr};\n+use vec::UnboxedVecRepr;\n+use vec::raw::{VecRepr, SliceRepr};\n pub use box::raw::BoxRepr;\n use box::raw::BoxHeaderRepr;\n \n@@ -155,7 +156,7 @@ impl ReprVisitor {\n     fn visit_ptr_inner(ptr: *c_void, inner: *TyDesc) -> bool {\n         let mut u = ReprVisitor(ptr, self.writer);\n         let v = reflect::MovePtrAdaptor(move u);\n-        visit_tydesc(inner, v as @TyVisitor);\n+        visit_tydesc(inner, (move v) as @TyVisitor);\n         true\n     }\n \n@@ -303,7 +304,7 @@ impl ReprVisitor : TyVisitor {\n \n \n     fn visit_unboxed_vec(mtbl: uint, inner: *TyDesc) -> bool {\n-        do self.get::<vec::raw::UnboxedVecRepr> |b| {\n+        do self.get::<vec::UnboxedVecRepr> |b| {\n             self.write_unboxed_vec_repr(mtbl, b, inner);\n         }\n     }\n@@ -452,7 +453,7 @@ pub fn write_repr2<T>(writer: @Writer, object: &T) {\n     let tydesc = intrinsic::get_tydesc::<T>();\n     let mut u = ReprVisitor(ptr, writer);\n     let v = reflect::MovePtrAdaptor(move u);\n-    visit_tydesc(tydesc, v as @TyVisitor)\n+    visit_tydesc(tydesc, (move v) as @TyVisitor)\n }\n \n #[test]\n@@ -558,7 +559,7 @@ impl ReprPrinter {\n         unsafe {\n             self.align(sys::min_align_of::<T>());\n             let value_addr: &T = transmute(copy self.ptr);\n-            (*value_addr).write_repr(self.writer);\n+            value_addr.write_repr(self.writer);\n             self.bump(sys::size_of::<T>());\n             true\n         }\n@@ -991,7 +992,7 @@ pub fn write_repr<T>(writer: @Writer, object: &T) {\n     unsafe {\n         let ptr = ptr::to_unsafe_ptr(object) as *c_void;\n         let tydesc = sys::get_type_desc::<T>();\n-        let tydesc = cast::transmute(tydesc);\n+        let tydesc = cast::transmute(move tydesc);\n \n         let repr_printer = @ReprPrinter {\n             ptr: ptr,"}, {"sha": "06d8c0da0d0134ea622c51c07be5fd9d3fbb7763", "filename": "src/libcore/result.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820", "patch": "@@ -105,11 +105,9 @@ pub pure fn to_either<T: Copy, U: Copy>(res: &Result<U, T>)\n  */\n pub fn chain<T, U: Copy, V: Copy>(res: Result<T, V>, op: fn(t: T)\n     -> Result<U, V>) -> Result<U, V> {\n-    // XXX: Should be writable with move + match\n-    if res.is_ok() {\n-        op(unwrap(res))\n-    } else {\n-        Err(unwrap_err(res))\n+    match move res {\n+        Ok(move t) => op(move t),\n+        Err(move e) => Err(e)\n     }\n }\n "}, {"sha": "cb6a7f737f989d61372e7c518d804420bf767770", "filename": "src/libcore/run.rs", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibcore%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibcore%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frun.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820", "patch": "@@ -226,7 +226,7 @@ pub fn start_program(prog: &str, args: &[~str]) -> Program {\n \n     fn ProgRes(r: ProgRepr) -> ProgRes {\n         ProgRes {\n-            r: r\n+            r: move r\n         }\n     }\n \n@@ -248,12 +248,14 @@ pub fn start_program(prog: &str, args: &[~str]) -> Program {\n }\n \n fn read_all(rd: io::Reader) -> ~str {\n-    let mut buf = ~\"\";\n-    while !rd.eof() {\n-        let bytes = rd.read_bytes(4096u);\n-        buf += str::from_bytes(bytes);\n-    }\n-    move buf\n+    let buf = io::with_bytes_writer(|wr| {\n+        let mut bytes = [mut 0, ..4096];\n+        while !rd.eof() {\n+            let nread = rd.read(bytes, bytes.len());\n+            wr.write(bytes.view(0, nread));\n+        }\n+    });\n+    str::from_bytes(buf)\n }\n \n /**\n@@ -313,10 +315,10 @@ pub fn program_output(prog: &str, args: &[~str]) ->\n         let stream = comm::recv(p);\n         match stream {\n             (1, copy s) => {\n-                outs = s;\n+                outs = move s;\n             }\n             (2, copy s) => {\n-                errs = s;\n+                errs = move s;\n             }\n             (n, _) => {\n                 fail(fmt!(\"program_output received an unexpected file \\\n@@ -341,13 +343,15 @@ fn writeclose(fd: c_int, s: ~str) {\n fn readclose(fd: c_int) -> ~str {\n     let file = os::fdopen(fd);\n     let reader = io::FILE_reader(file, false);\n-    let mut buf = ~\"\";\n-    while !reader.eof() {\n-        let bytes = reader.read_bytes(4096u);\n-        buf += str::from_bytes(bytes);\n-    }\n+    let buf = io::with_bytes_writer(|writer| {\n+        let mut bytes = [mut 0, ..4096];\n+        while !reader.eof() {\n+            let nread = reader.read(bytes, bytes.len());\n+            writer.write(bytes.view(0, nread));\n+        }\n+    });\n     os::fclose(file);\n-    move buf\n+    str::from_bytes(buf)\n }\n \n /// Waits for a process to exit and returns the exit code"}, {"sha": "58b35b82a31fa5f6297b78248a9c1ee51ec73640", "filename": "src/libcore/send_map.rs", "status": "modified", "additions": 130, "deletions": 33, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibcore%2Fsend_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibcore%2Fsend_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsend_map.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820", "patch": "@@ -17,6 +17,9 @@ pub trait SendMap<K:Eq Hash, V: Copy> {\n \n     fn insert(&mut self, k: K, +v: V) -> bool;\n     fn remove(&mut self, k: &K) -> bool;\n+    fn pop(&mut self, k: &K) -> Option<V>;\n+    fn swap(&mut self, k: K, +v: V) -> Option<V>;\n+    fn consume(&mut self, f: fn(K, V));\n     fn clear(&mut self);\n     pure fn len(&const self) -> uint;\n     pure fn is_empty(&const self) -> bool;\n@@ -182,22 +185,68 @@ pub mod linear {\n                     debug!(\"insert fresh (%?->%?) at idx %?, hash %?\",\n                            k, v, idx, hash);\n                     self.buckets[idx] = Some(Bucket {hash: hash,\n-                                                     key: k,\n-                                                     value: v});\n+                                                     key: move k,\n+                                                     value: move v});\n                     self.size += 1;\n                     true\n                 }\n                 FoundEntry(idx) => {\n                     debug!(\"insert overwrite (%?->%?) at idx %?, hash %?\",\n                            k, v, idx, hash);\n                     self.buckets[idx] = Some(Bucket {hash: hash,\n-                                                     key: k,\n-                                                     value: v});\n+                                                     key: move k,\n+                                                     value: move v});\n                     false\n                 }\n             }\n         }\n \n+        fn pop_internal(&mut self, hash: uint, k: &K) -> Option<V> {\n+            // Removing from an open-addressed hashtable\n+            // is, well, painful.  The problem is that\n+            // the entry may lie on the probe path for other\n+            // entries, so removing it would make you think that\n+            // those probe paths are empty.\n+            //\n+            // To address this we basically have to keep walking,\n+            // re-inserting entries we find until we reach an empty\n+            // bucket.  We know we will eventually reach one because\n+            // we insert one ourselves at the beginning (the removed\n+            // entry).\n+            //\n+            // I found this explanation elucidating:\n+            // http://www.maths.lse.ac.uk/Courses/MA407/del-hash.pdf\n+            let mut idx = match self.bucket_for_key_with_hash(self.buckets,\n+                                                              hash, k) {\n+                TableFull | FoundHole(_) => return None,\n+                FoundEntry(idx) => idx\n+            };\n+\n+            let len_buckets = self.buckets.len();\n+            let mut bucket = None;\n+            self.buckets[idx] <-> bucket;\n+\n+            let value = match move bucket {\n+                None => None,\n+                Some(move bucket) => {\n+                    let Bucket { value: move value, _ } = move bucket;\n+                    Some(move value)\n+                },\n+            };\n+\n+            idx = self.next_bucket(idx, len_buckets);\n+            while self.buckets[idx].is_some() {\n+                let mut bucket = None;\n+                bucket <-> self.buckets[idx];\n+                self.insert_opt_bucket(move bucket);\n+                idx = self.next_bucket(idx, len_buckets);\n+            }\n+            self.size -= 1;\n+\n+            move value\n+\n+        }\n+\n         fn search(&self,\n                   hash: uint,\n                   op: fn(x: &Option<Bucket<K,V>>) -> bool) {\n@@ -222,37 +271,55 @@ pub mod linear {\n         }\n \n         fn remove(&mut self, k: &K) -> bool {\n-            // Removing from an open-addressed hashtable\n-            // is, well, painful.  The problem is that\n-            // the entry may lie on the probe path for other\n-            // entries, so removing it would make you think that\n-            // those probe paths are empty.\n-            //\n-            // To address this we basically have to keep walking,\n-            // re-inserting entries we find until we reach an empty\n-            // bucket.  We know we will eventually reach one because\n-            // we insert one ourselves at the beginning (the removed\n-            // entry).\n-            //\n-            // I found this explanation elucidating:\n-            // http://www.maths.lse.ac.uk/Courses/MA407/del-hash.pdf\n+            match self.pop(k) {\n+                Some(_) => true,\n+                None => false,\n+            }\n+        }\n \n-            let mut idx = match self.bucket_for_key(self.buckets, k) {\n-                TableFull | FoundHole(_) => return false,\n-                FoundEntry(idx) => idx\n-            };\n+        fn pop(&mut self, k: &K) -> Option<V> {\n+            let hash = k.hash_keyed(self.k0, self.k1) as uint;\n+            self.pop_internal(hash, k)\n+        }\n \n-            let len_buckets = self.buckets.len();\n-            self.buckets[idx] = None;\n-            idx = self.next_bucket(idx, len_buckets);\n-            while self.buckets[idx].is_some() {\n-                let mut bucket = None;\n-                bucket <-> self.buckets[idx];\n-                self.insert_opt_bucket(move bucket);\n-                idx = self.next_bucket(idx, len_buckets);\n+        fn swap(&mut self, k: K, v: V) -> Option<V> {\n+            // this could be faster.\n+            let hash = k.hash_keyed(self.k0, self.k1) as uint;\n+            let old_value = self.pop_internal(hash, &k);\n+\n+            if self.size >= self.resize_at {\n+                // n.b.: We could also do this after searching, so\n+                // that we do not resize if this call to insert is\n+                // simply going to update a key in place.  My sense\n+                // though is that it's worse to have to search through\n+                // buckets to find the right spot twice than to just\n+                // resize in this corner case.\n+                self.expand();\n+            }\n+\n+            self.insert_internal(hash, move k, move v);\n+\n+            move old_value\n+        }\n+\n+        fn consume(&mut self, f: fn(K, V)) {\n+            let mut buckets = ~[];\n+            self.buckets <-> buckets;\n+            self.size = 0;\n+\n+            do vec::consume(move buckets) |_i, bucket| {\n+                match move bucket {\n+                    None => { },\n+                    Some(move bucket) => {\n+                        let Bucket {\n+                            key: move key,\n+                            value: move value,\n+                            _\n+                        } = move bucket;\n+                        f(move key, move value)\n+                    }\n+                }\n             }\n-            self.size -= 1;\n-            return true;\n         }\n \n         fn clear(&mut self) {\n@@ -350,7 +417,6 @@ pub mod linear {\n             }\n             option::unwrap(move value)\n         }\n-\n     }\n }\n \n@@ -407,6 +473,37 @@ pub mod test {\n         assert m.is_empty();\n     }\n \n+    #[test]\n+    pub fn pops() {\n+        let mut m = ~LinearMap();\n+        m.insert(1, 2);\n+        assert m.pop(&1) == Some(2);\n+        assert m.pop(&1) == None;\n+    }\n+\n+    #[test]\n+    pub fn swaps() {\n+        let mut m = ~LinearMap();\n+        assert m.swap(1, 2) == None;\n+        assert m.swap(1, 3) == Some(2);\n+        assert m.swap(1, 4) == Some(3);\n+    }\n+\n+    #[test]\n+    pub fn consumes() {\n+        let mut m = ~LinearMap();\n+        assert m.insert(1, 2);\n+        assert m.insert(2, 3);\n+        let mut m2 = ~LinearMap();\n+        do m.consume |k, v| {\n+            m2.insert(k, v);\n+        }\n+        assert m.len() == 0;\n+        assert m2.len() == 2;\n+        assert m2.find(&1) == Some(2);\n+        assert m2.find(&2) == Some(3);\n+    }\n+\n     #[test]\n     pub fn iterate() {\n         let mut m = linear::linear_map_with_capacity(4);"}, {"sha": "0c722c437ee58a46f3be60a749752056cff78294", "filename": "src/libcore/str.rs", "status": "modified", "additions": 177, "deletions": 79, "changes": 256, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820", "patch": "@@ -49,7 +49,7 @@ pub pure fn from_byte(b: u8) -> ~str {\n }\n \n /// Appends a character at the end of a string\n-pub fn push_char(s: &const ~str, ch: char) {\n+pub fn push_char(s: &mut ~str, ch: char) {\n     unsafe {\n         let code = ch as uint;\n         let nb = if code < max_one_b { 1u }\n@@ -140,7 +140,7 @@ pub pure fn from_chars(chs: &[char]) -> ~str {\n \n /// Appends a string slice to the back of a string, without overallocating\n #[inline(always)]\n-pub fn push_str_no_overallocate(lhs: &const ~str, rhs: &str) {\n+pub fn push_str_no_overallocate(lhs: &mut ~str, rhs: &str) {\n     unsafe {\n         let llen = lhs.len();\n         let rlen = rhs.len();\n@@ -157,7 +157,7 @@ pub fn push_str_no_overallocate(lhs: &const ~str, rhs: &str) {\n }\n /// Appends a string slice to the back of a string\n #[inline(always)]\n-pub fn push_str(lhs: &const ~str, rhs: &str) {\n+pub fn push_str(lhs: &mut ~str, rhs: &str) {\n     unsafe {\n         let llen = lhs.len();\n         let rlen = rhs.len();\n@@ -203,6 +203,13 @@ pub pure fn connect(v: &[~str], sep: &str) -> ~str {\n     move s\n }\n \n+/// Given a string, make a new string with repeated copies of it\n+pub fn repeat(ss: &str, nn: uint) -> ~str {\n+    let mut acc = ~\"\";\n+    for nn.times { acc += ss; }\n+    move acc\n+}\n+\n /*\n Section: Adding to and removing from a string\n */\n@@ -214,7 +221,7 @@ Section: Adding to and removing from a string\n  *\n  * If the string does not contain any characters\n  */\n-pub fn pop_char(s: &const ~str) -> char {\n+pub fn pop_char(s: &mut ~str) -> char {\n     let end = len(*s);\n     assert end > 0u;\n     let {ch, prev} = char_range_at_reverse(*s, end);\n@@ -573,6 +580,40 @@ pub pure fn words(s: &str) -> ~[~str] {\n     split_nonempty(s, |c| char::is_whitespace(c))\n }\n \n+/** Split a string into a vector of substrings,\n+ *  each of which is less than a limit\n+ */\n+pub fn split_within(ss: &str, lim: uint) -> ~[~str] {\n+    let words = str::words(ss);\n+\n+    // empty?\n+    if words == ~[] { return ~[]; }\n+\n+    let mut rows : ~[~str] = ~[];\n+    let mut row  : ~str    = ~\"\";\n+\n+    for words.each |wptr| {\n+        let word = copy *wptr;\n+\n+        // if adding this word to the row would go over the limit,\n+        // then start a new row\n+        if row.len() + word.len() + 1 > lim {\n+            rows.push(copy row); // save previous row\n+            row = move word;    // start a new one\n+        } else {\n+            if row.len() > 0 { row += ~\" \" } // separate words\n+            row += word;  // append to this row\n+        }\n+    }\n+\n+    // save the last row\n+    if row != ~\"\" { rows.push(move row); }\n+\n+    move rows\n+}\n+\n+\n+\n /// Convert a string to lowercase. ASCII only\n pub pure fn to_lower(s: &str) -> ~str {\n     map(s,\n@@ -1361,7 +1402,7 @@ pub pure fn is_whitespace(s: &str) -> bool {\n  *\n  * Alphanumeric characters are determined by `char::is_alphanumeric`\n  */\n-fn is_alphanumeric(s: &str) -> bool {\n+pure fn is_alphanumeric(s: &str) -> bool {\n     return all(s, char::is_alphanumeric);\n }\n \n@@ -1473,6 +1514,11 @@ pub pure fn from_utf16(v: &[u16]) -> ~str {\n     move buf\n }\n \n+pub pure fn with_capacity(capacity: uint) -> ~str {\n+    let mut buf = ~\"\";\n+    unsafe { reserve(&mut buf, capacity); }\n+    move buf\n+}\n \n /**\n  * As char_len but for a slice of a string\n@@ -1802,9 +1848,9 @@ pub pure fn as_buf<T>(s: &str, f: fn(*u8, uint) -> T) -> T {\n  * * s - A string\n  * * n - The number of bytes to reserve space for\n  */\n-pub fn reserve(s: &const ~str, n: uint) {\n+pub fn reserve(s: &mut ~str, n: uint) {\n     unsafe {\n-        let v: *mut ~[u8] = cast::transmute(copy s);\n+        let v: *mut ~[u8] = cast::transmute(s);\n         vec::reserve(&mut *v, n + 1);\n     }\n }\n@@ -1829,7 +1875,7 @@ pub fn reserve(s: &const ~str, n: uint) {\n  * * s - A string\n  * * n - The number of bytes to reserve space for\n  */\n-pub fn reserve_at_least(s: &const ~str, n: uint) {\n+pub fn reserve_at_least(s: &mut ~str, n: uint) {\n     reserve(s, uint::next_power_of_two(n + 1u) - 1u)\n }\n \n@@ -1906,7 +1952,7 @@ pub mod raw {\n     }\n \n     /// Converts a vector of bytes to a string.\n-    pub pub unsafe fn from_bytes(v: &[const u8]) -> ~str {\n+    pub unsafe fn from_bytes(v: &[const u8]) -> ~str {\n         do vec::as_const_buf(v) |buf, len| {\n             from_buf_len(buf, len)\n         }\n@@ -1974,7 +2020,7 @@ pub mod raw {\n     }\n \n     /// Appends a byte to a string. (Not UTF-8 safe).\n-    pub unsafe fn push_byte(s: &const ~str, b: u8) {\n+    pub unsafe fn push_byte(s: &mut ~str, b: u8) {\n         reserve_at_least(s, s.len() + 1);\n         do as_buf(*s) |buf, len| {\n             let buf: *mut u8 = ::cast::reinterpret_cast(&buf);\n@@ -1984,13 +2030,13 @@ pub mod raw {\n     }\n \n     /// Appends a vector of bytes to a string. (Not UTF-8 safe).\n-    unsafe fn push_bytes(s: &const ~str, bytes: &[u8]) {\n+    unsafe fn push_bytes(s: &mut ~str, bytes: &[u8]) {\n         reserve_at_least(s, s.len() + bytes.len());\n         for vec::each(bytes) |byte| { push_byte(s, *byte); }\n     }\n \n     /// Removes the last byte from a string and returns it. (Not UTF-8 safe).\n-    pub unsafe fn pop_byte(s: &const ~str) -> u8 {\n+    pub unsafe fn pop_byte(s: &mut ~str) -> u8 {\n         let len = len(*s);\n         assert (len > 0u);\n         let b = s[len - 1u];\n@@ -2008,7 +2054,7 @@ pub mod raw {\n     }\n \n     /// Sets the length of the string and adds the null terminator\n-    pub unsafe fn set_len(v: &const ~str, new_len: uint) {\n+    pub unsafe fn set_len(v: &mut ~str, new_len: uint) {\n         let v: **vec::raw::VecRepr = cast::transmute(copy v);\n         let repr: *vec::raw::VecRepr = *v;\n         (*repr).unboxed.fill = new_len + 1u;\n@@ -2029,23 +2075,23 @@ pub mod raw {\n \n }\n \n-pub trait UniqueStr {\n-    fn trim() -> self;\n-    fn trim_left() -> self;\n-    fn trim_right() -> self;\n+pub trait Trimmable {\n+    pure fn trim() -> self;\n+    pure fn trim_left() -> self;\n+    pure fn trim_right() -> self;\n }\n \n /// Extension methods for strings\n-impl ~str: UniqueStr {\n+impl ~str: Trimmable {\n     /// Returns a string with leading and trailing whitespace removed\n     #[inline]\n-    fn trim() -> ~str { trim(self) }\n+    pure fn trim() -> ~str { trim(self) }\n     /// Returns a string with leading whitespace removed\n     #[inline]\n-    fn trim_left() -> ~str { trim_left(self) }\n+    pure fn trim_left() -> ~str { trim_left(self) }\n     /// Returns a string with trailing whitespace removed\n     #[inline]\n-    fn trim_right() -> ~str { trim_right(self) }\n+    pure fn trim_right() -> ~str { trim_right(self) }\n }\n \n #[cfg(notest)]\n@@ -2062,31 +2108,35 @@ pub mod traits {\n pub mod traits {}\n \n pub trait StrSlice {\n-    fn all(it: fn(char) -> bool) -> bool;\n-    fn any(it: fn(char) -> bool) -> bool;\n-    fn contains(needle: &a/str) -> bool;\n-    fn contains_char(needle: char) -> bool;\n-    fn each(it: fn(u8) -> bool);\n-    fn eachi(it: fn(uint, u8) -> bool);\n-    fn each_char(it: fn(char) -> bool);\n-    fn each_chari(it: fn(uint, char) -> bool);\n-    fn ends_with(needle: &str) -> bool;\n-    fn is_empty() -> bool;\n-    fn is_not_empty() -> bool;\n-    fn is_whitespace() -> bool;\n-    fn is_alphanumeric() -> bool;\n+    pure fn all(it: fn(char) -> bool) -> bool;\n+    pure fn any(it: fn(char) -> bool) -> bool;\n+    pure fn contains(needle: &a/str) -> bool;\n+    pure fn contains_char(needle: char) -> bool;\n+    pure fn each(it: fn(u8) -> bool);\n+    pure fn eachi(it: fn(uint, u8) -> bool);\n+    pure fn each_char(it: fn(char) -> bool);\n+    pure fn each_chari(it: fn(uint, char) -> bool);\n+    pure fn ends_with(needle: &str) -> bool;\n+    pure fn is_empty() -> bool;\n+    pure fn is_not_empty() -> bool;\n+    pure fn is_whitespace() -> bool;\n+    pure fn is_alphanumeric() -> bool;\n     pure fn len() -> uint;\n     pure fn slice(begin: uint, end: uint) -> ~str;\n-    fn split(sepfn: fn(char) -> bool) -> ~[~str];\n-    fn split_char(sep: char) -> ~[~str];\n-    fn split_str(sep: &a/str) -> ~[~str];\n-    fn starts_with(needle: &a/str) -> bool;\n-    fn substr(begin: uint, n: uint) -> ~str;\n+    pure fn split(sepfn: fn(char) -> bool) -> ~[~str];\n+    pure fn split_char(sep: char) -> ~[~str];\n+    pure fn split_str(sep: &a/str) -> ~[~str];\n+    pure fn starts_with(needle: &a/str) -> bool;\n+    pure fn substr(begin: uint, n: uint) -> ~str;\n     pure fn to_lower() -> ~str;\n     pure fn to_upper() -> ~str;\n-    fn escape_default() -> ~str;\n-    fn escape_unicode() -> ~str;\n-    pure fn to_unique() -> ~str;\n+    pure fn escape_default() -> ~str;\n+    pure fn escape_unicode() -> ~str;\n+    pure fn trim() -> ~str;\n+    pure fn trim_left() -> ~str;\n+    pure fn trim_right() -> ~str;\n+    pure fn to_owned() -> ~str;\n+    pure fn to_managed() -> @str;\n     pure fn char_at(i: uint) -> char;\n }\n \n@@ -2097,54 +2147,56 @@ impl &str: StrSlice {\n      * contains no characters\n      */\n     #[inline]\n-    fn all(it: fn(char) -> bool) -> bool { all(self, it) }\n+    pure fn all(it: fn(char) -> bool) -> bool { all(self, it) }\n     /**\n      * Return true if a predicate matches any character (and false if it\n      * matches none or there are no characters)\n      */\n     #[inline]\n-    fn any(it: fn(char) -> bool) -> bool { any(self, it) }\n+    pure fn any(it: fn(char) -> bool) -> bool { any(self, it) }\n     /// Returns true if one string contains another\n     #[inline]\n-    fn contains(needle: &a/str) -> bool { contains(self, needle) }\n+    pure fn contains(needle: &a/str) -> bool { contains(self, needle) }\n     /// Returns true if a string contains a char\n     #[inline]\n-    fn contains_char(needle: char) -> bool { contains_char(self, needle) }\n+    pure fn contains_char(needle: char) -> bool {\n+        contains_char(self, needle)\n+    }\n     /// Iterate over the bytes in a string\n     #[inline]\n-    fn each(it: fn(u8) -> bool) { each(self, it) }\n+    pure fn each(it: fn(u8) -> bool) { each(self, it) }\n     /// Iterate over the bytes in a string, with indices\n     #[inline]\n-    fn eachi(it: fn(uint, u8) -> bool) { eachi(self, it) }\n+    pure fn eachi(it: fn(uint, u8) -> bool) { eachi(self, it) }\n     /// Iterate over the chars in a string\n     #[inline]\n-    fn each_char(it: fn(char) -> bool) { each_char(self, it) }\n+    pure fn each_char(it: fn(char) -> bool) { each_char(self, it) }\n     /// Iterate over the chars in a string, with indices\n     #[inline]\n-    fn each_chari(it: fn(uint, char) -> bool) { each_chari(self, it) }\n+    pure fn each_chari(it: fn(uint, char) -> bool) { each_chari(self, it) }\n     /// Returns true if one string ends with another\n     #[inline]\n-    fn ends_with(needle: &str) -> bool { ends_with(self, needle) }\n+    pure fn ends_with(needle: &str) -> bool { ends_with(self, needle) }\n     /// Returns true if the string has length 0\n     #[inline]\n-    fn is_empty() -> bool { is_empty(self) }\n+    pure fn is_empty() -> bool { is_empty(self) }\n     /// Returns true if the string has length greater than 0\n     #[inline]\n-    fn is_not_empty() -> bool { is_not_empty(self) }\n+    pure fn is_not_empty() -> bool { is_not_empty(self) }\n     /**\n      * Returns true if the string contains only whitespace\n      *\n      * Whitespace characters are determined by `char::is_whitespace`\n      */\n     #[inline]\n-    fn is_whitespace() -> bool { is_whitespace(self) }\n+    pure fn is_whitespace() -> bool { is_whitespace(self) }\n     /**\n      * Returns true if the string contains only alphanumerics\n      *\n      * Alphanumeric characters are determined by `char::is_alphanumeric`\n      */\n     #[inline]\n-    fn is_alphanumeric() -> bool { is_alphanumeric(self) }\n+    pure fn is_alphanumeric() -> bool { is_alphanumeric(self) }\n     #[inline]\n     /// Returns the size in bytes not counting the null terminator\n     pure fn len() -> uint { len(self) }\n@@ -2159,29 +2211,29 @@ impl &str: StrSlice {\n     pure fn slice(begin: uint, end: uint) -> ~str { slice(self, begin, end) }\n     /// Splits a string into substrings using a character function\n     #[inline]\n-    fn split(sepfn: fn(char) -> bool) -> ~[~str] { split(self, sepfn) }\n+    pure fn split(sepfn: fn(char) -> bool) -> ~[~str] { split(self, sepfn) }\n     /**\n      * Splits a string into substrings at each occurrence of a given character\n      */\n     #[inline]\n-    fn split_char(sep: char) -> ~[~str] { split_char(self, sep) }\n+    pure fn split_char(sep: char) -> ~[~str] { split_char(self, sep) }\n     /**\n      * Splits a string into a vector of the substrings separated by a given\n      * string\n      */\n     #[inline]\n-    fn split_str(sep: &a/str) -> ~[~str] { split_str(self, sep) }\n+    pure fn split_str(sep: &a/str) -> ~[~str] { split_str(self, sep) }\n     /// Returns true if one string starts with another\n     #[inline]\n-    fn starts_with(needle: &a/str) -> bool { starts_with(self, needle) }\n+    pure fn starts_with(needle: &a/str) -> bool { starts_with(self, needle) }\n     /**\n      * Take a substring of another.\n      *\n      * Returns a string containing `n` characters starting at byte offset\n      * `begin`.\n      */\n     #[inline]\n-    fn substr(begin: uint, n: uint) -> ~str { substr(self, begin, n) }\n+    pure fn substr(begin: uint, n: uint) -> ~str { substr(self, begin, n) }\n     /// Convert a string to lowercase\n     #[inline]\n     pure fn to_lower() -> ~str { to_lower(self) }\n@@ -2190,13 +2242,31 @@ impl &str: StrSlice {\n     pure fn to_upper() -> ~str { to_upper(self) }\n     /// Escape each char in `s` with char::escape_default.\n     #[inline]\n-    fn escape_default() -> ~str { escape_default(self) }\n+    pure fn escape_default() -> ~str { escape_default(self) }\n     /// Escape each char in `s` with char::escape_unicode.\n     #[inline]\n-    fn escape_unicode() -> ~str { escape_unicode(self) }\n+    pure fn escape_unicode() -> ~str { escape_unicode(self) }\n \n+    /// Returns a string with leading and trailing whitespace removed\n+    #[inline]\n+    pure fn trim() -> ~str { trim(self) }\n+    /// Returns a string with leading whitespace removed\n     #[inline]\n-    pure fn to_unique() -> ~str { self.slice(0, self.len()) }\n+    pure fn trim_left() -> ~str { trim_left(self) }\n+    /// Returns a string with trailing whitespace removed\n+    #[inline]\n+    pure fn trim_right() -> ~str { trim_right(self) }\n+\n+    #[inline]\n+    pure fn to_owned() -> ~str { self.slice(0, self.len()) }\n+\n+    #[inline]\n+    pure fn to_managed() -> @str {\n+        let v = at_vec::from_fn(self.len() + 1, |i| {\n+            if i == self.len() { 0 } else { self[i] }\n+        });\n+        unsafe { ::cast::transmute(v) }\n+    }\n \n     #[inline]\n     pure fn char_at(i: uint) -> char { char_at(self, i) }\n@@ -2450,6 +2520,19 @@ mod tests {\n         assert ~[] == words(~\"\");\n     }\n \n+    #[test]\n+    fn test_split_within() {\n+        assert split_within(~\"\", 0) == ~[];\n+        assert split_within(~\"\", 15) == ~[];\n+        assert split_within(~\"hello\", 15) == ~[~\"hello\"];\n+\n+        let data = ~\"\\nMary had a little lamb\\nLittle lamb\\n\";\n+        error!(\"~~~~ %?\", split_within(data, 15));\n+        assert split_within(data, 15) == ~[~\"Mary had a\",\n+                                           ~\"little lamb\",\n+                                           ~\"Little lamb\"];\n+    }\n+\n     #[test]\n     fn test_find_str() {\n         // byte positions\n@@ -2525,6 +2608,15 @@ mod tests {\n         t(~[~\"hi\"], ~\" \", ~\"hi\");\n     }\n \n+    #[test]\n+    fn test_repeat() {\n+        assert repeat(~\"x\", 4) == ~\"xxxx\";\n+        assert repeat(~\"hi\", 4) == ~\"hihihihi\";\n+        assert repeat(~\"\u0e44\u0e17\u534e\", 3) == ~\"\u0e44\u0e17\u534e\u0e44\u0e17\u534e\u0e44\u0e17\u534e\";\n+        assert repeat(~\"\", 4) == ~\"\";\n+        assert repeat(~\"hi\", 0) == ~\"\";\n+    }\n+\n     #[test]\n     fn test_to_upper() {\n         // libc::toupper, and hence str::to_upper\n@@ -2547,23 +2639,23 @@ mod tests {\n     #[test]\n     fn test_unsafe_slice() {\n         unsafe {\n-            assert ~\"ab\" == raw::slice_bytes(~\"abc\", 0u, 2u);\n-            assert ~\"bc\" == raw::slice_bytes(~\"abc\", 1u, 3u);\n-            assert ~\"\" == raw::slice_bytes(~\"abc\", 1u, 1u);\n+            assert ~\"ab\" == raw::slice_bytes(~\"abc\", 0, 2);\n+            assert ~\"bc\" == raw::slice_bytes(~\"abc\", 1, 3);\n+            assert ~\"\" == raw::slice_bytes(~\"abc\", 1, 1);\n             fn a_million_letter_a() -> ~str {\n                 let mut i = 0;\n                 let mut rs = ~\"\";\n                 while i < 100000 { push_str(&mut rs, ~\"aaaaaaaaaa\"); i += 1; }\n-                return rs;\n+                move rs\n             }\n             fn half_a_million_letter_a() -> ~str {\n                 let mut i = 0;\n                 let mut rs = ~\"\";\n                 while i < 100000 { push_str(&mut rs, ~\"aaaaa\"); i += 1; }\n-                return rs;\n+                move rs\n             }\n             assert half_a_million_letter_a() ==\n-                raw::slice_bytes(a_million_letter_a(), 0u, 500000u);\n+                raw::slice_bytes(a_million_letter_a(), 0u, 500000);\n         }\n     }\n \n@@ -2649,16 +2741,16 @@ mod tests {\n \n     #[test]\n     fn test_slice() {\n-        assert ~\"ab\" == slice(~\"abc\", 0u, 2u);\n-        assert ~\"bc\" == slice(~\"abc\", 1u, 3u);\n-        assert ~\"\" == slice(~\"abc\", 1u, 1u);\n-        assert ~\"\\u65e5\" == slice(~\"\\u65e5\\u672c\", 0u, 3u);\n+        assert ~\"ab\" == slice(~\"abc\", 0, 2);\n+        assert ~\"bc\" == slice(~\"abc\", 1, 3);\n+        assert ~\"\" == slice(~\"abc\", 1, 1);\n+        assert ~\"\\u65e5\" == slice(~\"\\u65e5\\u672c\", 0, 3);\n \n         let data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n-        assert ~\"\u0e1b\" == slice(data, 0u, 3u);\n-        assert ~\"\u0e23\" == slice(data, 3u, 6u);\n-        assert ~\"\" == slice(data, 3u, 3u);\n-        assert ~\"\u534e\" == slice(data, 30u, 33u);\n+        assert ~\"\u0e1b\" == slice(data, 0, 3);\n+        assert ~\"\u0e23\" == slice(data, 3, 6);\n+        assert ~\"\" == slice(data, 3, 3);\n+        assert ~\"\u534e\" == slice(data, 30, 33);\n \n         fn a_million_letter_X() -> ~str {\n             let mut i = 0;\n@@ -2667,13 +2759,13 @@ mod tests {\n                 push_str(&mut rs, ~\"\u534e\u534e\u534e\u534e\u534e\u534e\u534e\u534e\u534e\u534e\");\n                 i += 1;\n             }\n-            return rs;\n+            move rs\n         }\n         fn half_a_million_letter_X() -> ~str {\n             let mut i = 0;\n             let mut rs = ~\"\";\n             while i < 100000 { push_str(&mut rs, ~\"\u534e\u534e\u534e\u534e\u534e\"); i += 1; }\n-            return rs;\n+            move rs\n         }\n         assert half_a_million_letter_X() ==\n             slice(a_million_letter_X(), 0u, 3u * 500000u);\n@@ -3175,4 +3267,10 @@ mod tests {\n         assert escape_default(~\"\\U0001d4ea\\r\") == ~\"\\\\U0001d4ea\\\\r\";\n     }\n \n+    #[test]\n+    fn test_to_managed() {\n+        assert (~\"abc\").to_managed() == @\"abc\";\n+        assert view(\"abcdef\", 1, 5).to_managed() == @\"bcde\";\n+    }\n+\n }"}, {"sha": "32a6987a672aaad227eb02f989e518244ff8a8a7", "filename": "src/libcore/sys.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibcore%2Fsys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibcore%2Fsys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsys.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820", "patch": "@@ -153,7 +153,7 @@ pub mod tests {\n \n         assert f(20) == 30;\n \n-        let original_closure: Closure = cast::transmute(f);\n+        let original_closure: Closure = cast::transmute(move f);\n \n         let actual_function_pointer = original_closure.code;\n         let environment = original_closure.env;\n@@ -163,7 +163,7 @@ pub mod tests {\n             env: environment\n         };\n \n-        let new_f: fn(int) -> int = cast::transmute(new_closure);\n+        let new_f: fn(int) -> int = cast::transmute(move new_closure);\n         assert new_f(20) == 30;\n     }\n }"}, {"sha": "d9e213c7f55e8bc33ed9a1257b7cd8da4f75bf44", "filename": "src/libcore/task.rs", "status": "modified", "additions": 31, "deletions": 26, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibcore%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibcore%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820", "patch": "@@ -217,7 +217,7 @@ pub type TaskOpts = {\n // sidestep that whole issue by making builders uncopyable and making\n // the run function move them in.\n \n-// FIXME (#2585): Replace the 'consumed' bit with move mode on self\n+// FIXME (#3724): Replace the 'consumed' bit with move mode on self\n pub enum TaskBuilder = {\n     opts: TaskOpts,\n     gen_body: fn@(v: fn~()) -> fn~(),\n@@ -349,7 +349,7 @@ impl TaskBuilder {\n      * Fails if a future_result was already set for this task.\n      */\n     fn future_result(blk: fn(v: future::Future<TaskResult>)) -> TaskBuilder {\n-        // FIXME (#1087, #1857): Once linked failure and notification are\n+        // FIXME (#3725): Once linked failure and notification are\n         // handled in the library, I can imagine implementing this by just\n         // registering an arbitrary number of task::on_exit handlers and\n         // sending out messages.\n@@ -424,7 +424,11 @@ impl TaskBuilder {\n                 mut notify_chan: move notify_chan,\n                 sched: self.opts.sched\n             },\n-            gen_body: |body| { wrapper(prev_gen_body(move body)) },\n+            // tjc: I think this is the line that gets miscompiled\n+            // w/ last-use off, if we leave out the move prev_gen_body?\n+            // that makes no sense, though...\n+            gen_body: |move prev_gen_body,\n+                       body| { wrapper(prev_gen_body(move body)) },\n             can_not_copy: None,\n             .. *self.consume()\n         })\n@@ -758,9 +762,9 @@ pub unsafe fn atomically<U>(f: fn() -> U) -> U {\n fn test_cant_dup_task_builder() {\n     let b = task().unlinked();\n     do b.spawn { }\n-    // FIXME(#2585): For now, this is a -runtime- failure, because we haven't\n-    // got modes on self. When 2585 is fixed, this test should fail to compile\n-    // instead, and should go in tests/compile-fail.\n+    // FIXME(#3724): For now, this is a -runtime- failure, because we haven't\n+    // got move mode on self. When 3724 is fixed, this test should fail to\n+    // compile instead, and should go in tests/compile-fail.\n     do b.spawn { } // b should have been consumed by the previous call\n }\n \n@@ -931,7 +935,7 @@ fn test_add_wrapper() {\n     let ch = comm::Chan(&po);\n     let b0 = task();\n     let b1 = do b0.add_wrapper |body| {\n-        fn~() {\n+        fn~(move body) {\n             body();\n             comm::send(ch, ());\n         }\n@@ -944,14 +948,15 @@ fn test_add_wrapper() {\n #[ignore(cfg(windows))]\n fn test_future_result() {\n     let mut result = None;\n-    do task().future_result(|+r| { result = Some(r); }).spawn { }\n-    assert future::get(&option::unwrap(result)) == Success;\n+    do task().future_result(|+r| { result = Some(move r); }).spawn { }\n+    assert future::get(&option::unwrap(move result)) == Success;\n \n     result = None;\n-    do task().future_result(|+r| { result = Some(r); }).unlinked().spawn {\n+    do task().future_result(|+r|\n+        { result = Some(move r); }).unlinked().spawn {\n         fail;\n     }\n-    assert future::get(&option::unwrap(result)) == Failure;\n+    assert future::get(&option::unwrap(move result)) == Failure;\n }\n \n #[test] #[should_fail] #[ignore(cfg(windows))]\n@@ -981,7 +986,7 @@ fn test_spawn_conversation() {\n     let (recv_str, send_int) = do spawn_conversation |recv_int, send_str| {\n         let input = comm::recv(recv_int);\n         let output = int::str(input);\n-        comm::send(send_str, output);\n+        comm::send(send_str, move output);\n     };\n     comm::send(send_int, 1);\n     assert comm::recv(recv_str) == ~\"1\";\n@@ -1134,7 +1139,7 @@ fn avoid_copying_the_body(spawnfn: fn(v: fn~())) {\n     let x = ~1;\n     let x_in_parent = ptr::addr_of(&(*x)) as uint;\n \n-    do spawnfn {\n+    do spawnfn |move x| {\n         let x_in_child = ptr::addr_of(&(*x)) as uint;\n         comm::send(ch, x_in_child);\n     }\n@@ -1160,7 +1165,7 @@ fn test_avoid_copying_the_body_spawn_listener() {\n #[test]\n fn test_avoid_copying_the_body_task_spawn() {\n     do avoid_copying_the_body |f| {\n-        do task().spawn {\n+        do task().spawn |move f| {\n             f();\n         }\n     }\n@@ -1178,7 +1183,7 @@ fn test_avoid_copying_the_body_spawn_listener_1() {\n #[test]\n fn test_avoid_copying_the_body_try() {\n     do avoid_copying_the_body |f| {\n-        do try {\n+        do try |move f| {\n             f()\n         };\n     }\n@@ -1187,7 +1192,7 @@ fn test_avoid_copying_the_body_try() {\n #[test]\n fn test_avoid_copying_the_body_unlinked() {\n     do avoid_copying_the_body |f| {\n-        do spawn_unlinked {\n+        do spawn_unlinked |move f| {\n             f();\n         }\n     }\n@@ -1212,7 +1217,7 @@ fn test_unkillable() {\n \n     // We want to do this after failing\n     do spawn_unlinked {\n-        for iter::repeat(10u) { yield() }\n+        for iter::repeat(10) { yield() }\n         ch.send(());\n     }\n \n@@ -1226,12 +1231,12 @@ fn test_unkillable() {\n     unsafe {\n         do unkillable {\n             let p = ~0;\n-            let pp: *uint = cast::transmute(p);\n+            let pp: *uint = cast::transmute(move p);\n \n             // If we are killed here then the box will leak\n             po.recv();\n \n-            let _p: ~int = cast::transmute(pp);\n+            let _p: ~int = cast::transmute(move pp);\n         }\n     }\n \n@@ -1246,8 +1251,8 @@ fn test_unkillable_nested() {\n     let (ch, po) = pipes::stream();\n \n     // We want to do this after failing\n-    do spawn_unlinked {\n-        for iter::repeat(10u) { yield() }\n+    do spawn_unlinked |move ch| {\n+        for iter::repeat(10) { yield() }\n         ch.send(());\n     }\n \n@@ -1262,12 +1267,12 @@ fn test_unkillable_nested() {\n         do unkillable {\n             do unkillable {} // Here's the difference from the previous test.\n             let p = ~0;\n-            let pp: *uint = cast::transmute(p);\n+            let pp: *uint = cast::transmute(move p);\n \n             // If we are killed here then the box will leak\n             po.recv();\n \n-            let _p: ~int = cast::transmute(pp);\n+            let _p: ~int = cast::transmute(move pp);\n         }\n     }\n \n@@ -1311,7 +1316,7 @@ fn test_child_doesnt_ref_parent() {\n fn test_sched_thread_per_core() {\n     let (chan, port) = pipes::stream();\n \n-    do spawn_sched(ThreadPerCore) {\n+    do spawn_sched(ThreadPerCore) |move chan| {\n         let cores = rt::rust_num_threads();\n         let reported_threads = rt::rust_sched_threads();\n         assert(cores as uint == reported_threads as uint);\n@@ -1325,15 +1330,15 @@ fn test_sched_thread_per_core() {\n fn test_spawn_thread_on_demand() {\n     let (chan, port) = pipes::stream();\n \n-    do spawn_sched(ManualThreads(2)) {\n+    do spawn_sched(ManualThreads(2)) |move chan| {\n         let max_threads = rt::rust_sched_threads();\n         assert(max_threads as int == 2);\n         let running_threads = rt::rust_sched_current_nonlazy_threads();\n         assert(running_threads as int == 1);\n \n         let (chan2, port2) = pipes::stream();\n \n-        do spawn() {\n+        do spawn() |move chan2| {\n             chan2.send(());\n         }\n "}, {"sha": "533e98514924ae78359342552600911935bdaaee", "filename": "src/libcore/task/spawn.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibcore%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibcore%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fspawn.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820", "patch": "@@ -312,8 +312,8 @@ fn TCB(me: *rust_task, tasks: TaskGroupArc, ancestors: AncestorList,\n \n     TCB {\n         me: me,\n-        tasks: tasks,\n-        ancestors: ancestors,\n+        tasks: move tasks,\n+        ancestors: move ancestors,\n         is_main: is_main,\n         notifier: move notifier\n     }\n@@ -330,7 +330,7 @@ struct AutoNotify {\n \n fn AutoNotify(chan: Chan<Notification>) -> AutoNotify {\n     AutoNotify {\n-        notify_chan: chan,\n+        notify_chan: move chan,\n         failed: true // Un-set above when taskgroup successfully made.\n     }\n }\n@@ -652,7 +652,7 @@ fn test_spawn_raw_unsupervise() {\n         mut notify_chan: None,\n         .. default_task_opts()\n     };\n-    do spawn_raw(opts) {\n+    do spawn_raw(move opts) {\n         fail;\n     }\n }\n@@ -667,7 +667,7 @@ fn test_spawn_raw_notify_success() {\n         notify_chan: Some(move notify_ch),\n         .. default_task_opts()\n     };\n-    do spawn_raw(opts) |move task_ch| {\n+    do spawn_raw(move opts) |move task_ch| {\n         task_ch.send(get_task());\n     }\n     let task_ = task_po.recv();\n@@ -683,10 +683,10 @@ fn test_spawn_raw_notify_failure() {\n \n     let opts = {\n         linked: false,\n-        notify_chan: Some(notify_ch),\n+        notify_chan: Some(move notify_ch),\n         .. default_task_opts()\n     };\n-    do spawn_raw(opts) {\n+    do spawn_raw(move opts) |move task_ch| {\n         task_ch.send(get_task());\n         fail;\n     }"}, {"sha": "fb0608906a115318f7bd9847f205d1f9d0c92f4a", "filename": "src/libcore/to_str.rs", "status": "modified", "additions": 27, "deletions": 25, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibcore%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibcore%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fto_str.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820", "patch": "@@ -8,80 +8,82 @@ The `ToStr` trait for converting to strings\n #[forbid(deprecated_mode)];\n #[forbid(deprecated_pattern)];\n \n-pub trait ToStr { fn to_str() -> ~str; }\n+pub trait ToStr { pure fn to_str() -> ~str; }\n \n impl int: ToStr {\n-    fn to_str() -> ~str { int::str(self) }\n+    pure fn to_str() -> ~str { int::str(self) }\n }\n impl i8: ToStr {\n-    fn to_str() -> ~str { i8::str(self) }\n+    pure fn to_str() -> ~str { i8::str(self) }\n }\n impl i16: ToStr {\n-    fn to_str() -> ~str { i16::str(self) }\n+    pure fn to_str() -> ~str { i16::str(self) }\n }\n impl i32: ToStr {\n-    fn to_str() -> ~str { i32::str(self) }\n+    pure fn to_str() -> ~str { i32::str(self) }\n }\n impl i64: ToStr {\n-    fn to_str() -> ~str { i64::str(self) }\n+    pure fn to_str() -> ~str { i64::str(self) }\n }\n impl uint: ToStr {\n-    fn to_str() -> ~str { uint::str(self) }\n+    pure fn to_str() -> ~str { uint::str(self) }\n }\n impl u8: ToStr {\n-    fn to_str() -> ~str { u8::str(self) }\n+    pure fn to_str() -> ~str { u8::str(self) }\n }\n impl u16: ToStr {\n-    fn to_str() -> ~str { u16::str(self) }\n+    pure fn to_str() -> ~str { u16::str(self) }\n }\n impl u32: ToStr {\n-    fn to_str() -> ~str { u32::str(self) }\n+    pure fn to_str() -> ~str { u32::str(self) }\n }\n impl u64: ToStr {\n-    fn to_str() -> ~str { u64::str(self) }\n+    pure fn to_str() -> ~str { u64::str(self) }\n }\n impl float: ToStr {\n-    fn to_str() -> ~str { float::to_str(self, 4u) }\n+    pure fn to_str() -> ~str { float::to_str(self, 4u) }\n }\n impl f32: ToStr {\n-    fn to_str() -> ~str { float::to_str(self as float, 4u) }\n+    pure fn to_str() -> ~str { float::to_str(self as float, 4u) }\n }\n impl f64: ToStr {\n-    fn to_str() -> ~str { float::to_str(self as float, 4u) }\n+    pure fn to_str() -> ~str { float::to_str(self as float, 4u) }\n }\n impl bool: ToStr {\n-    fn to_str() -> ~str { bool::to_str(self) }\n+    pure fn to_str() -> ~str { bool::to_str(self) }\n }\n impl (): ToStr {\n-    fn to_str() -> ~str { ~\"()\" }\n+    pure fn to_str() -> ~str { ~\"()\" }\n }\n impl ~str: ToStr {\n-    fn to_str() -> ~str { copy self }\n+    pure fn to_str() -> ~str { copy self }\n }\n impl &str: ToStr {\n-    fn to_str() -> ~str { str::from_slice(self) }\n+    pure fn to_str() -> ~str { str::from_slice(self) }\n }\n impl @str: ToStr {\n-    fn to_str() -> ~str { str::from_slice(self) }\n+    pure fn to_str() -> ~str { str::from_slice(self) }\n }\n \n impl<A: ToStr Copy, B: ToStr Copy> (A, B): ToStr {\n-    fn to_str() -> ~str {\n+    pure fn to_str() -> ~str {\n         let (a, b) = self;\n         ~\"(\" + a.to_str() + ~\", \" + b.to_str() + ~\")\"\n     }\n }\n impl<A: ToStr Copy, B: ToStr Copy, C: ToStr Copy> (A, B, C): ToStr {\n-    fn to_str() -> ~str {\n+    pure fn to_str() -> ~str {\n         let (a, b, c) = self;\n         ~\"(\" + a.to_str() + ~\", \" + b.to_str() + ~\", \" + c.to_str() + ~\")\"\n     }\n }\n \n impl<A: ToStr> ~[A]: ToStr {\n-    fn to_str() -> ~str {\n+    pure fn to_str() -> ~str unsafe {\n+        // Bleh -- not really unsafe\n+        // push_str and push_char\n         let mut acc = ~\"[\", first = true;\n-        for vec::each(self) |elt| {\n+        for vec::each(self) |elt| unsafe {\n             if first { first = false; }\n             else { str::push_str(&mut acc, ~\", \"); }\n             str::push_str(&mut acc, elt.to_str());\n@@ -92,10 +94,10 @@ impl<A: ToStr> ~[A]: ToStr {\n }\n \n impl<A: ToStr> @A: ToStr {\n-    fn to_str() -> ~str { ~\"@\" + (*self).to_str() }\n+    pure fn to_str() -> ~str { ~\"@\" + (*self).to_str() }\n }\n impl<A: ToStr> ~A: ToStr {\n-    fn to_str() -> ~str { ~\"~\" + (*self).to_str() }\n+    pure fn to_str() -> ~str { ~\"~\" + (*self).to_str() }\n }\n \n #[cfg(test)]"}, {"sha": "ee9e0c84be6dd34f79ebf8d01293e0b802c7e0fb", "filename": "src/libcore/tuple.rs", "status": "modified", "additions": 27, "deletions": 2, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibcore%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibcore%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftuple.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820", "patch": "@@ -6,13 +6,13 @@\n \n use cmp::{Eq, Ord};\n \n-pub trait TupleOps<T,U> {\n+pub trait CopyableTuple<T, U> {\n     pure fn first() -> T;\n     pure fn second() -> U;\n     pure fn swap() -> (U, T);\n }\n \n-impl<T: Copy, U: Copy> (T, U): TupleOps<T,U> {\n+impl<T: Copy, U: Copy> (T, U): CopyableTuple<T, U> {\n \n     /// Return the first element of self\n     pure fn first() -> T {\n@@ -34,6 +34,24 @@ impl<T: Copy, U: Copy> (T, U): TupleOps<T,U> {\n \n }\n \n+pub trait ImmutableTuple<T, U> {\n+    pure fn first_ref(&self) -> &self/T;\n+    pure fn second_ref(&self) -> &self/U;\n+}\n+\n+impl<T, U> (T, U): ImmutableTuple<T, U> {\n+    pure fn first_ref(&self) -> &self/T {\n+        match *self {\n+            (ref t, _) => t,\n+        }\n+    }\n+    pure fn second_ref(&self) -> &self/U {\n+        match *self {\n+            (_, ref u) => u,\n+        }\n+    }\n+}\n+\n pub trait ExtendedTupleOps<A,B> {\n     fn zip(&self) -> ~[(A, B)];\n     fn map<C>(&self, f: &fn(a: &A, b: &B) -> C) -> ~[C];\n@@ -145,6 +163,13 @@ impl<A: Ord, B: Ord, C: Ord> (A, B, C) : Ord {\n     pure fn gt(other: &(A, B, C)) -> bool { (*other).lt(&self)  }\n }\n \n+#[test]\n+fn test_tuple_ref() {\n+    let x = (~\"foo\", ~\"bar\");\n+    assert x.first_ref() == &~\"foo\";\n+    assert x.second_ref() == &~\"bar\";\n+}\n+\n #[test]\n #[allow(non_implicitly_copyable_typarams)]\n fn test_tuple() {"}, {"sha": "3199262ae163f3e48753a4a2275e69c88b8c748f", "filename": "src/libcore/uint-template.rs", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibcore%2Fuint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibcore%2Fuint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fuint-template.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820", "patch": "@@ -187,19 +187,7 @@ pub pure fn to_str_bytes<U>(neg: bool, num: T, radix: uint,\n     // Enough room to hold any number in any radix.\n     // Worst case: 64-bit number, binary-radix, with\n     // a leading negative sign = 65 bytes.\n-    let buf : [mut u8]/65 =\n-        [mut\n-         0u8,0u8,0u8,0u8,0u8, 0u8,0u8,0u8,0u8,0u8,\n-         0u8,0u8,0u8,0u8,0u8, 0u8,0u8,0u8,0u8,0u8,\n-\n-         0u8,0u8,0u8,0u8,0u8, 0u8,0u8,0u8,0u8,0u8,\n-         0u8,0u8,0u8,0u8,0u8, 0u8,0u8,0u8,0u8,0u8,\n-\n-         0u8,0u8,0u8,0u8,0u8, 0u8,0u8,0u8,0u8,0u8,\n-         0u8,0u8,0u8,0u8,0u8, 0u8,0u8,0u8,0u8,0u8,\n-\n-         0u8,0u8,0u8,0u8,0u8\n-         ]/65;\n+    let buf : [mut u8 * 65] = [mut 0u8, ..65];\n \n     // FIXME (#2649): post-snapshot, you can do this without the raw\n     // pointers and unsafe bits, and the codegen will prove it's all\n@@ -232,7 +220,7 @@ pub pure fn to_str_bytes<U>(neg: bool, num: T, radix: uint,\n }\n \n /// Convert to a string\n-pub fn str(i: T) -> ~str { return to_str(i, 10u); }\n+pub pure fn str(i: T) -> ~str { return to_str(i, 10u); }\n \n #[test]\n pub fn test_to_str() {"}, {"sha": "8380cbf6b638ed03df241bbdc44b4911bcacdb31", "filename": "src/libcore/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibcore%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibcore%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Futil.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820", "patch": "@@ -100,7 +100,7 @@ mod tests {\n         let x = ~[(5, false)];\n         //FIXME #3387 assert x.eq(id(copy x));\n         let y = copy x;\n-        assert x.eq(&id(y));\n+        assert x.eq(&id(move y));\n     }\n     #[test]\n     fn test_swap() {"}, {"sha": "2e91c4b22c43f61482795e6a702f5011a17c3c22", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 57, "deletions": 43, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820", "patch": "@@ -340,15 +340,15 @@ pub fn splitn<T: Copy>(v: &[T], n: uint, f: fn(t: &T) -> bool) -> ~[~[T]] {\n  */\n pub fn rsplit<T: Copy>(v: &[T], f: fn(t: &T) -> bool) -> ~[~[T]] {\n     let ln = len(v);\n-    if (ln == 0u) { return ~[] }\n+    if (ln == 0) { return ~[] }\n \n     let mut end = ln;\n     let mut result = ~[];\n-    while end > 0u {\n-        match rposition_between(v, 0u, end, f) {\n+    while end > 0 {\n+        match rposition_between(v, 0, end, f) {\n             None => break,\n             Some(i) => {\n-                result.push(slice(v, i + 1u, end));\n+                result.push(slice(v, i + 1, end));\n                 end = i;\n             }\n         }\n@@ -416,7 +416,7 @@ pub fn shift<T>(v: &mut ~[T]) -> T {\n pub fn unshift<T>(v: &mut ~[T], x: T) {\n     let mut vv = ~[move x];\n     *v <-> vv;\n-    v.push_all_move(vv);\n+    v.push_all_move(move vv);\n }\n \n pub fn consume<T>(v: ~[T], f: fn(uint, v: T)) unsafe {\n@@ -433,7 +433,7 @@ pub fn consume<T>(v: ~[T], f: fn(uint, v: T)) unsafe {\n }\n \n pub fn consume_mut<T>(v: ~[mut T], f: fn(uint, v: T)) {\n-    consume(vec::from_mut(v), f)\n+    consume(vec::from_mut(move v), f)\n }\n \n /// Remove the last element from a vector and return it\n@@ -591,7 +591,7 @@ pub pure fn append_one<T>(lhs: ~[T], x: T) -> ~[T] {\n \n #[inline(always)]\n pure fn append_mut<T: Copy>(lhs: ~[mut T], rhs: &[const T]) -> ~[mut T] {\n-    to_mut(append(from_mut(lhs), rhs))\n+    to_mut(append(from_mut(move lhs), rhs))\n }\n \n /**\n@@ -1621,7 +1621,7 @@ impl<T> ~[T]: MutableVector<T> {\n     }\n \n     fn unshift(&mut self, x: T) {\n-        unshift(self, x)\n+        unshift(self, move x)\n     }\n \n     fn swap_remove(&mut self, index: uint) -> T {\n@@ -1657,44 +1657,41 @@ impl<T: Eq> ~[T]: MutableEqVector<T> {\n     }\n }\n \n+\n+/**\n+* Constructs a vector from an unsafe pointer to a buffer\n+*\n+* # Arguments\n+*\n+* * ptr - An unsafe pointer to a buffer of `T`\n+* * elts - The number of elements in the buffer\n+*/\n+// Wrapper for fn in raw: needs to be called by net_tcp::on_tcp_read_cb\n+pub unsafe fn from_buf<T>(ptr: *T, elts: uint) -> ~[T] {\n+    raw::from_buf_raw(ptr, elts)\n+}\n+\n+/// The internal 'unboxed' representation of a vector\n+pub struct UnboxedVecRepr {\n+    mut fill: uint,\n+    mut alloc: uint,\n+    data: u8\n+}\n+\n /// Unsafe operations\n-pub mod raw {\n-    // FIXME: This should have crate visibility (#1893 blocks that)\n+mod raw {\n \n     /// The internal representation of a (boxed) vector\n     pub struct VecRepr {\n         box_header: box::raw::BoxHeaderRepr,\n         unboxed: UnboxedVecRepr\n     }\n \n-    /// The internal 'unboxed' representation of a vector\n-    pub struct UnboxedVecRepr {\n-        mut fill: uint,\n-        mut alloc: uint,\n-        data: u8\n-    }\n-\n     pub type SliceRepr = {\n         mut data: *u8,\n         mut len: uint\n     };\n \n-    /**\n-     * Constructs a vector from an unsafe pointer to a buffer\n-     *\n-     * # Arguments\n-     *\n-     * * ptr - An unsafe pointer to a buffer of `T`\n-     * * elts - The number of elements in the buffer\n-     */\n-    #[inline(always)]\n-    pub unsafe fn from_buf<T>(ptr: *T, elts: uint) -> ~[T] {\n-        let mut dst = with_capacity(elts);\n-        set_len(&mut dst, elts);\n-        as_mut_buf(dst, |p_dst, _len_dst| ptr::memcpy(p_dst, ptr, elts));\n-        move dst\n-    }\n-\n     /**\n      * Sets the length of a vector\n      *\n@@ -1775,6 +1772,23 @@ pub mod raw {\n         }\n     }\n \n+    /**\n+    * Constructs a vector from an unsafe pointer to a buffer\n+    *\n+    * # Arguments\n+    *\n+    * * ptr - An unsafe pointer to a buffer of `T`\n+    * * elts - The number of elements in the buffer\n+    */\n+    // Was in raw, but needs to be called by net_tcp::on_tcp_read_cb\n+    #[inline(always)]\n+    pub unsafe fn from_buf_raw<T>(ptr: *T, elts: uint) -> ~[T] {\n+        let mut dst = with_capacity(elts);\n+        set_len(&mut dst, elts);\n+        as_mut_buf(dst, |p_dst, _len_dst| ptr::memcpy(p_dst, ptr, elts));\n+        move dst\n+    }\n+\n     /**\n       * Copies data from one vector to another.\n       *\n@@ -1959,7 +1973,7 @@ mod tests {\n             // Test on-stack copy-from-buf.\n             let a = ~[1, 2, 3];\n             let mut ptr = raw::to_ptr(a);\n-            let b = raw::from_buf(ptr, 3u);\n+            let b = from_buf(ptr, 3u);\n             assert (len(b) == 3u);\n             assert (b[0] == 1);\n             assert (b[1] == 2);\n@@ -1968,7 +1982,7 @@ mod tests {\n             // Test on-heap copy-from-buf.\n             let c = ~[1, 2, 3, 4, 5];\n             ptr = raw::to_ptr(c);\n-            let d = raw::from_buf(ptr, 5u);\n+            let d = from_buf(ptr, 5u);\n             assert (len(d) == 5u);\n             assert (d[0] == 1);\n             assert (d[1] == 2);\n@@ -2194,7 +2208,7 @@ mod tests {\n     #[test]\n     fn test_dedup() {\n         fn case(a: ~[uint], b: ~[uint]) {\n-            let mut v = a;\n+            let mut v = move a;\n             v.dedup();\n             assert(v == b);\n         }\n@@ -2450,13 +2464,13 @@ mod tests {\n         let v1 = ~[1, 2, 3];\n         let v2 = ~[4, 5, 6];\n \n-        let z1 = zip(v1, v2);\n+        let z1 = zip(move v1, move v2);\n \n         assert ((1, 4) == z1[0]);\n         assert ((2, 5) == z1[1]);\n         assert ((3, 6) == z1[2]);\n \n-        let (left, right) = unzip(z1);\n+        let (left, right) = unzip(move z1);\n \n         assert ((1, 4) == (left[0], right[0]));\n         assert ((2, 5) == (left[1], right[1]));\n@@ -2754,7 +2768,7 @@ mod tests {\n         unsafe {\n             let x = ~[1, 2, 3];\n             let addr = raw::to_ptr(x);\n-            let x_mut = to_mut(x);\n+            let x_mut = to_mut(move x);\n             let addr_mut = raw::to_ptr(x_mut);\n             assert addr == addr_mut;\n         }\n@@ -2765,7 +2779,7 @@ mod tests {\n         unsafe {\n             let x = ~[mut 1, 2, 3];\n             let addr = raw::to_ptr(x);\n-            let x_imm = from_mut(x);\n+            let x_imm = from_mut(move x);\n             let addr_imm = raw::to_ptr(x_imm);\n             assert addr == addr_imm;\n         }\n@@ -2963,7 +2977,7 @@ mod tests {\n     fn test_consume_fail() {\n         let v = ~[(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n         let mut i = 0;\n-        do consume(v) |_i, _elt| {\n+        do consume(move v) |_i, _elt| {\n             if i == 2 {\n                 fail\n             }\n@@ -2977,7 +2991,7 @@ mod tests {\n     fn test_consume_mut_fail() {\n         let v = ~[mut (~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n         let mut i = 0;\n-        do consume_mut(v) |_i, _elt| {\n+        do consume_mut(move v) |_i, _elt| {\n             if i == 2 {\n                 fail\n             }\n@@ -3020,7 +3034,7 @@ mod tests {\n     fn test_map_consume_fail() {\n         let v = ~[(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n         let mut i = 0;\n-        do map_consume(v) |_elt| {\n+        do map_consume(move v) |_elt| {\n             if i == 2 {\n                 fail\n             }"}, {"sha": "9c793028a52d04b458ec368f573d840a0a3a4c02", "filename": "src/libstd/arc.rs", "status": "modified", "additions": 25, "deletions": 24, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibstd%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibstd%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farc.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820", "patch": "@@ -124,7 +124,7 @@ pub fn mutex_arc_with_condvars<T: Send>(user_data: T,\n                                     num_condvars: uint) -> MutexARC<T> {\n     let data =\n         MutexARCInner { lock: mutex_with_condvars(num_condvars),\n-                          failed: false, data: user_data };\n+                          failed: false, data: move user_data };\n     MutexARC { x: unsafe { shared_mutable_state(move data) } }\n }\n \n@@ -190,7 +190,7 @@ impl<T: Send> &MutexARC<T> {\n  *\n  * Will additionally fail if another task has failed while accessing the arc.\n  */\n-// FIXME(#2585) make this a by-move method on the arc\n+// FIXME(#3724) make this a by-move method on the arc\n pub fn unwrap_mutex_arc<T: Send>(arc: MutexARC<T>) -> T {\n     let MutexARC { x: x } <- arc;\n     let inner = unsafe { unwrap_shared_mutable_state(move x) };\n@@ -258,7 +258,7 @@ pub fn rw_arc_with_condvars<T: Const Send>(user_data: T,\n                                        num_condvars: uint) -> RWARC<T> {\n     let data =\n         RWARCInner { lock: rwlock_with_condvars(num_condvars),\n-                     failed: false, data: user_data };\n+                     failed: false, data: move user_data };\n     RWARC { x: unsafe { shared_mutable_state(move data) }, cant_nest: () }\n }\n \n@@ -368,7 +368,7 @@ impl<T: Const Send> &RWARC<T> {\n  * Will additionally fail if another task has failed while accessing the arc\n  * in write mode.\n  */\n-// FIXME(#2585) make this a by-move method on the arc\n+// FIXME(#3724) make this a by-move method on the arc\n pub fn unwrap_rw_arc<T: Const Send>(arc: RWARC<T>) -> T {\n     let RWARC { x: x, _ } <- arc;\n     let inner = unsafe { unwrap_shared_mutable_state(move x) };\n@@ -448,7 +448,7 @@ mod tests {\n \n         let (c, p) = pipes::stream();\n \n-        do task::spawn() {\n+        do task::spawn() |move c| {\n             let p = pipes::PortSet();\n             c.send(p.chan());\n \n@@ -471,8 +471,8 @@ mod tests {\n         let arc = ~MutexARC(false);\n         let arc2 = ~arc.clone();\n         let (c,p) = pipes::oneshot();\n-        let (c,p) = (~mut Some(c), ~mut Some(p));\n-        do task::spawn {\n+        let (c,p) = (~mut Some(move c), ~mut Some(move p));\n+        do task::spawn |move arc2, move p| {\n             // wait until parent gets in\n             pipes::recv_one(option::swap_unwrap(p));\n             do arc2.access_cond |state, cond| {\n@@ -494,7 +494,7 @@ mod tests {\n         let arc2 = ~arc.clone();\n         let (c,p) = pipes::stream();\n \n-        do task::spawn_unlinked {\n+        do task::spawn_unlinked |move arc2, move p| {\n             let _ = p.recv();\n             do arc2.access_cond |one, cond| {\n                 cond.signal();\n@@ -513,7 +513,7 @@ mod tests {\n     fn test_mutex_arc_poison() {\n         let arc = ~MutexARC(1);\n         let arc2 = ~arc.clone();\n-        do task::try {\n+        do task::try |move arc2| {\n             do arc2.access |one| {\n                 assert *one == 2;\n             }\n@@ -527,21 +527,21 @@ mod tests {\n         let arc = MutexARC(1);\n         let arc2 = ~(&arc).clone();\n         let (c,p) = pipes::stream();\n-        do task::spawn {\n+        do task::spawn |move c, move arc2| {\n             do arc2.access |one| {\n                 c.send(());\n                 assert *one == 2;\n             }\n         }\n         let _ = p.recv();\n-        let one = unwrap_mutex_arc(arc);\n+        let one = unwrap_mutex_arc(move arc);\n         assert one == 1;\n     }\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n     fn test_rw_arc_poison_wr() {\n         let arc = ~RWARC(1);\n         let arc2 = ~arc.clone();\n-        do task::try {\n+        do task::try |move arc2| {\n             do arc2.write |one| {\n                 assert *one == 2;\n             }\n@@ -554,7 +554,7 @@ mod tests {\n     fn test_rw_arc_poison_ww() {\n         let arc = ~RWARC(1);\n         let arc2 = ~arc.clone();\n-        do task::try {\n+        do task::try |move arc2| {\n             do arc2.write |one| {\n                 assert *one == 2;\n             }\n@@ -567,7 +567,7 @@ mod tests {\n     fn test_rw_arc_poison_dw() {\n         let arc = ~RWARC(1);\n         let arc2 = ~arc.clone();\n-        do task::try {\n+        do task::try |move arc2| {\n             do arc2.write_downgrade |write_mode| {\n                 do (&write_mode).write |one| {\n                     assert *one == 2;\n@@ -582,7 +582,7 @@ mod tests {\n     fn test_rw_arc_no_poison_rr() {\n         let arc = ~RWARC(1);\n         let arc2 = ~arc.clone();\n-        do task::try {\n+        do task::try |move arc2| {\n             do arc2.read |one| {\n                 assert *one == 2;\n             }\n@@ -595,7 +595,7 @@ mod tests {\n     fn test_rw_arc_no_poison_rw() {\n         let arc = ~RWARC(1);\n         let arc2 = ~arc.clone();\n-        do task::try {\n+        do task::try |move arc2| {\n             do arc2.read |one| {\n                 assert *one == 2;\n             }\n@@ -608,9 +608,9 @@ mod tests {\n     fn test_rw_arc_no_poison_dr() {\n         let arc = ~RWARC(1);\n         let arc2 = ~arc.clone();\n-        do task::try {\n+        do task::try |move arc2| {\n             do arc2.write_downgrade |write_mode| {\n-                let read_mode = arc2.downgrade(write_mode);\n+                let read_mode = arc2.downgrade(move write_mode);\n                 do (&read_mode).read |one| {\n                     assert *one == 2;\n                 }\n@@ -626,7 +626,7 @@ mod tests {\n         let arc2 = ~arc.clone();\n         let (c,p) = pipes::stream();\n \n-        do task::spawn {\n+        do task::spawn |move arc2, move c| {\n             do arc2.write |num| {\n                 for 10.times {\n                     let tmp = *num;\n@@ -642,7 +642,8 @@ mod tests {\n         let mut children = ~[];\n         for 5.times {\n             let arc3 = ~arc.clone();\n-            do task::task().future_result(|+r| children.push(r)).spawn {\n+            do task::task().future_result(|+r| children.push(move r)).spawn\n+                |move arc3| {\n                 do arc3.read |num| {\n                     assert *num >= 0;\n                 }\n@@ -670,9 +671,9 @@ mod tests {\n         let mut reader_convos = ~[];\n         for 10.times {\n             let ((rc1,rp1),(rc2,rp2)) = (pipes::stream(),pipes::stream());\n-            reader_convos.push((rc1,rp2));\n+            reader_convos.push((move rc1, move rp2));\n             let arcn = ~arc.clone();\n-            do task::spawn {\n+            do task::spawn |move rp1, move rc2, move arcn| {\n                 rp1.recv(); // wait for downgrader to give go-ahead\n                 do arcn.read |state| {\n                     assert *state == 31337;\n@@ -684,7 +685,7 @@ mod tests {\n         // Writer task\n         let arc2 = ~arc.clone();\n         let ((wc1,wp1),(wc2,wp2)) = (pipes::stream(),pipes::stream());\n-        do task::spawn {\n+        do task::spawn |move arc2, move wc2, move wp1| {\n             wp1.recv();\n             do arc2.write_cond |state, cond| {\n                 assert *state == 0;\n@@ -717,7 +718,7 @@ mod tests {\n                     }\n                 }\n             }\n-            let read_mode = arc.downgrade(write_mode);\n+            let read_mode = arc.downgrade(move write_mode);\n             do (&read_mode).read |state| {\n                 // complete handshake with other readers\n                 for vec::each(reader_convos) |x| {"}, {"sha": "9f40794b28a7915cfef45d2f4abfb9c2859a909f", "filename": "src/libstd/arena.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibstd%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibstd%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farena.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820", "patch": "@@ -244,7 +244,7 @@ fn test_arena_destructors() {\n         do arena.alloc { @i };\n         // Allocate something with funny size and alignment, to keep\n         // things interesting.\n-        do arena.alloc { [0u8, 1u8, 2u8]/3 };\n+        do arena.alloc { [0u8, 1u8, 2u8] };\n     }\n }\n \n@@ -258,7 +258,7 @@ fn test_arena_destructors_fail() {\n         do arena.alloc { @i };\n         // Allocate something with funny size and alignment, to keep\n         // things interesting.\n-        do arena.alloc { [0u8, 1u8, 2u8]/3 };\n+        do arena.alloc { [0u8, 1u8, 2u8] };\n     }\n     // Now, fail while allocating\n     do arena.alloc::<@int> {"}, {"sha": "2b8e9b6bbd9642361ade00ab4aab602ed1e00bc8", "filename": "src/libstd/bitv.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibstd%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibstd%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitv.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820", "patch": "@@ -96,7 +96,7 @@ struct BigBitv {\n }\n \n fn BigBitv(storage: ~[mut uint]) -> BigBitv {\n-    BigBitv {storage: storage}\n+    BigBitv {storage: move storage}\n }\n \n /**\n@@ -223,7 +223,7 @@ pub fn Bitv (nbits: uint, init: bool) -> Bitv {\n         let s = to_mut(from_elem(nelems, elem));\n         Big(~BigBitv(move s))\n     };\n-    Bitv {rep: rep, nbits: nbits}\n+    Bitv {rep: move rep, nbits: nbits}\n }\n \n priv impl Bitv {\n@@ -301,7 +301,7 @@ impl Bitv {\n             let st = to_mut(from_elem(self.nbits / uint_bits + 1, 0));\n             let len = st.len();\n             for uint::range(0, len) |i| { st[i] = b.storage[i]; };\n-            Bitv{nbits: self.nbits, rep: Big(~BigBitv{storage: st})}\n+            Bitv{nbits: self.nbits, rep: Big(~BigBitv{storage: move st})}\n           }\n         }\n     }"}, {"sha": "4f79bf2b31698a8886d1125937f80ea33c96bc47", "filename": "src/libstd/cell.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibstd%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibstd%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcell.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820", "patch": "@@ -57,7 +57,7 @@ fn test_basic() {\n     let value = value_cell.take();\n     assert value == ~10;\n     assert value_cell.is_empty();\n-    value_cell.put_back(value);\n+    value_cell.put_back(move value);\n     assert !value_cell.is_empty();\n }\n "}, {"sha": "e604b87b2afdabc49eaaaee0cb229fa6a179890e", "filename": "src/libstd/comm.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibstd%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibstd%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820", "patch": "@@ -52,12 +52,12 @@ pub fn DuplexStream<T: Send, U: Send>()\n     let (c2, p1) = pipes::stream();\n     let (c1, p2) = pipes::stream();\n     (DuplexStream {\n-        chan: c1,\n-        port: p1\n+        chan: move c1,\n+        port: move p1\n     },\n      DuplexStream {\n-         chan: c2,\n-         port: p2\n+         chan: move c2,\n+         port: move p2\n      })\n }\n "}, {"sha": "79e491e309bc1e0ceee646fa32dc5523cf51e426", "filename": "src/libstd/ebml.rs", "status": "modified", "additions": 207, "deletions": 187, "changes": 394, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibstd%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibstd%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Febml.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820", "patch": "@@ -1,21 +1,35 @@\n #[forbid(deprecated_mode)];\n+use serialization;\n+\n // Simple Extensible Binary Markup Language (ebml) reader and writer on a\n // cursor model. See the specification here:\n //     http://www.matroska.org/technical/specs/rfc/index.html\n-use core::Option;\n-use option::{Some, None};\n \n-type EbmlTag = {id: uint, size: uint};\n+struct EbmlTag {\n+    id: uint,\n+    size: uint,\n+}\n \n-type EbmlState = {ebml_tag: EbmlTag, tag_pos: uint, data_pos: uint};\n+struct EbmlState {\n+    ebml_tag: EbmlTag,\n+    tag_pos: uint,\n+    data_pos: uint,\n+}\n \n // FIXME (#2739): When we have module renaming, make \"reader\" and \"writer\"\n // separate modules within this file.\n \n // ebml reading\n-pub type Doc = {data: @~[u8], start: uint, end: uint};\n+struct Doc {\n+    data: @~[u8],\n+    start: uint,\n+    end: uint,\n+}\n \n-type TaggedDoc = {tag: uint, doc: Doc};\n+struct TaggedDoc {\n+    tag: uint,\n+    doc: Doc,\n+}\n \n impl Doc: ops::Index<uint,Doc> {\n     pure fn index(tag: uint) -> Doc {\n@@ -49,15 +63,17 @@ fn vuint_at(data: &[u8], start: uint) -> {val: uint, next: uint} {\n }\n \n pub fn Doc(data: @~[u8]) -> Doc {\n-    return {data: data, start: 0u, end: vec::len::<u8>(*data)};\n+    Doc { data: data, start: 0u, end: vec::len::<u8>(*data) }\n }\n \n pub fn doc_at(data: @~[u8], start: uint) -> TaggedDoc {\n     let elt_tag = vuint_at(*data, start);\n     let elt_size = vuint_at(*data, elt_tag.next);\n     let end = elt_size.next + elt_size.val;\n-    return {tag: elt_tag.val,\n-         doc: {data: data, start: elt_size.next, end: end}};\n+    TaggedDoc {\n+        tag: elt_tag.val,\n+        doc: Doc { data: data, start: elt_size.next, end: end }\n+    }\n }\n \n pub fn maybe_get_doc(d: Doc, tg: uint) -> Option<Doc> {\n@@ -67,19 +83,15 @@ pub fn maybe_get_doc(d: Doc, tg: uint) -> Option<Doc> {\n         let elt_size = vuint_at(*d.data, elt_tag.next);\n         pos = elt_size.next + elt_size.val;\n         if elt_tag.val == tg {\n-            return Some::<Doc>({\n-                data: d.data,\n-                start: elt_size.next,\n-                end: pos\n-            });\n+            return Some(Doc { data: d.data, start: elt_size.next, end: pos });\n         }\n     }\n-    return None::<Doc>;\n+    None\n }\n \n pub fn get_doc(d: Doc, tg: uint) -> Doc {\n     match maybe_get_doc(d, tg) {\n-      Some(d) => return d,\n+      Some(d) => d,\n       None => {\n         error!(\"failed to find block with tag %u\", tg);\n         fail;\n@@ -93,7 +105,8 @@ pub fn docs(d: Doc, it: fn(uint, Doc) -> bool) {\n         let elt_tag = vuint_at(*d.data, pos);\n         let elt_size = vuint_at(*d.data, elt_tag.next);\n         pos = elt_size.next + elt_size.val;\n-        if !it(elt_tag.val, {data: d.data, start: elt_size.next, end: pos}) {\n+        let doc = Doc { data: d.data, start: elt_size.next, end: pos };\n+        if !it(elt_tag.val, doc) {\n             break;\n         }\n     }\n@@ -106,7 +119,8 @@ pub fn tagged_docs(d: Doc, tg: uint, it: fn(Doc) -> bool) {\n         let elt_size = vuint_at(*d.data, elt_tag.next);\n         pos = elt_size.next + elt_size.val;\n         if elt_tag.val == tg {\n-            if !it({data: d.data, start: elt_size.next, end: pos}) {\n+            let doc = Doc { data: d.data, start: elt_size.next, end: pos };\n+            if !it(doc) {\n                 break;\n             }\n         }\n@@ -116,29 +130,29 @@ pub fn tagged_docs(d: Doc, tg: uint, it: fn(Doc) -> bool) {\n pub fn doc_data(d: Doc) -> ~[u8] { vec::slice::<u8>(*d.data, d.start, d.end) }\n \n pub fn with_doc_data<T>(d: Doc, f: fn(x: &[u8]) -> T) -> T {\n-    return f(vec::view(*d.data, d.start, d.end));\n+    f(vec::view(*d.data, d.start, d.end))\n }\n \n-pub fn doc_as_str(d: Doc) -> ~str { return str::from_bytes(doc_data(d)); }\n+pub fn doc_as_str(d: Doc) -> ~str { str::from_bytes(doc_data(d)) }\n \n pub fn doc_as_u8(d: Doc) -> u8 {\n     assert d.end == d.start + 1u;\n-    return (*d.data)[d.start];\n+    (*d.data)[d.start]\n }\n \n pub fn doc_as_u16(d: Doc) -> u16 {\n     assert d.end == d.start + 2u;\n-    return io::u64_from_be_bytes(*d.data, d.start, 2u) as u16;\n+    io::u64_from_be_bytes(*d.data, d.start, 2u) as u16\n }\n \n pub fn doc_as_u32(d: Doc) -> u32 {\n     assert d.end == d.start + 4u;\n-    return io::u64_from_be_bytes(*d.data, d.start, 4u) as u32;\n+    io::u64_from_be_bytes(*d.data, d.start, 4u) as u32\n }\n \n pub fn doc_as_u64(d: Doc) -> u64 {\n     assert d.end == d.start + 8u;\n-    return io::u64_from_be_bytes(*d.data, d.start, 8u);\n+    io::u64_from_be_bytes(*d.data, d.start, 8u)\n }\n \n pub fn doc_as_i8(d: Doc) -> i8 { doc_as_u8(d) as i8 }\n@@ -147,10 +161,9 @@ pub fn doc_as_i32(d: Doc) -> i32 { doc_as_u32(d) as i32 }\n pub fn doc_as_i64(d: Doc) -> i64 { doc_as_u64(d) as i64 }\n \n // ebml writing\n-type Writer_ = {writer: io::Writer, mut size_positions: ~[uint]};\n-\n-pub enum Writer {\n-    Writer_(Writer_)\n+struct Serializer {\n+    writer: io::Writer,\n+    priv mut size_positions: ~[uint],\n }\n \n fn write_sized_vuint(w: io::Writer, n: uint, size: uint) {\n@@ -173,13 +186,13 @@ fn write_vuint(w: io::Writer, n: uint) {\n     fail fmt!(\"vint to write too big: %?\", n);\n }\n \n-pub fn Writer(w: io::Writer) -> Writer {\n+pub fn Serializer(w: io::Writer) -> Serializer {\n     let size_positions: ~[uint] = ~[];\n-    return Writer_({writer: w, mut size_positions: size_positions});\n+    Serializer { writer: w, mut size_positions: size_positions }\n }\n \n // FIXME (#2741): Provide a function to write the standard ebml header.\n-impl Writer {\n+impl Serializer {\n     fn start_tag(tag_id: uint) {\n         debug!(\"Start tag %u\", tag_id);\n \n@@ -295,12 +308,7 @@ enum EbmlSerializerTag {\n     EsLabel // Used only when debugging\n }\n \n-trait SerializerPriv {\n-    fn _emit_tagged_uint(t: EbmlSerializerTag, v: uint);\n-    fn _emit_label(label: &str);\n-}\n-\n-impl ebml::Writer: SerializerPriv {\n+priv impl Serializer {\n     // used internally to emit things like the vector length and so on\n     fn _emit_tagged_uint(t: EbmlSerializerTag, v: uint) {\n         assert v <= 0xFFFF_FFFF_u;\n@@ -318,103 +326,137 @@ impl ebml::Writer: SerializerPriv {\n     }\n }\n \n-impl ebml::Writer {\n-    fn emit_opaque(f: fn()) {\n+impl Serializer {\n+    fn emit_opaque(&self, f: fn()) {\n         do self.wr_tag(EsOpaque as uint) {\n             f()\n         }\n     }\n }\n \n-impl ebml::Writer: serialization::Serializer {\n-    fn emit_nil() {}\n+impl Serializer: serialization::Serializer {\n+    fn emit_nil(&self) {}\n \n-    fn emit_uint(v: uint) { self.wr_tagged_u64(EsUint as uint, v as u64); }\n-    fn emit_u64(v: u64) { self.wr_tagged_u64(EsU64 as uint, v); }\n-    fn emit_u32(v: u32) { self.wr_tagged_u32(EsU32 as uint, v); }\n-    fn emit_u16(v: u16) { self.wr_tagged_u16(EsU16 as uint, v); }\n-    fn emit_u8(v: u8)   { self.wr_tagged_u8 (EsU8  as uint, v); }\n+    fn emit_uint(&self, v: uint) {\n+        self.wr_tagged_u64(EsUint as uint, v as u64);\n+    }\n+    fn emit_u64(&self, v: u64) { self.wr_tagged_u64(EsU64 as uint, v); }\n+    fn emit_u32(&self, v: u32) { self.wr_tagged_u32(EsU32 as uint, v); }\n+    fn emit_u16(&self, v: u16) { self.wr_tagged_u16(EsU16 as uint, v); }\n+    fn emit_u8(&self, v: u8)   { self.wr_tagged_u8 (EsU8  as uint, v); }\n \n-    fn emit_int(v: int) { self.wr_tagged_i64(EsInt as uint, v as i64); }\n-    fn emit_i64(v: i64) { self.wr_tagged_i64(EsI64 as uint, v); }\n-    fn emit_i32(v: i32) { self.wr_tagged_i32(EsI32 as uint, v); }\n-    fn emit_i16(v: i16) { self.wr_tagged_i16(EsI16 as uint, v); }\n-    fn emit_i8(v: i8)   { self.wr_tagged_i8 (EsI8  as uint, v); }\n+    fn emit_int(&self, v: int) {\n+        self.wr_tagged_i64(EsInt as uint, v as i64);\n+    }\n+    fn emit_i64(&self, v: i64) { self.wr_tagged_i64(EsI64 as uint, v); }\n+    fn emit_i32(&self, v: i32) { self.wr_tagged_i32(EsI32 as uint, v); }\n+    fn emit_i16(&self, v: i16) { self.wr_tagged_i16(EsI16 as uint, v); }\n+    fn emit_i8(&self, v: i8)   { self.wr_tagged_i8 (EsI8  as uint, v); }\n \n-    fn emit_bool(v: bool) { self.wr_tagged_u8(EsBool as uint, v as u8) }\n+    fn emit_bool(&self, v: bool) {\n+        self.wr_tagged_u8(EsBool as uint, v as u8)\n+    }\n \n     // FIXME (#2742): implement these\n-    fn emit_f64(_v: f64) { fail ~\"Unimplemented: serializing an f64\"; }\n-    fn emit_f32(_v: f32) { fail ~\"Unimplemented: serializing an f32\"; }\n-    fn emit_float(_v: float) { fail ~\"Unimplemented: serializing a float\"; }\n+    fn emit_f64(&self, _v: f64) { fail ~\"Unimplemented: serializing an f64\"; }\n+    fn emit_f32(&self, _v: f32) { fail ~\"Unimplemented: serializing an f32\"; }\n+    fn emit_float(&self, _v: float) {\n+        fail ~\"Unimplemented: serializing a float\";\n+    }\n+\n+    fn emit_char(&self, _v: char) {\n+        fail ~\"Unimplemented: serializing a char\";\n+    }\n \n-    fn emit_str(v: &str) { self.wr_tagged_str(EsStr as uint, v) }\n+    fn emit_borrowed_str(&self, v: &str) {\n+        self.wr_tagged_str(EsStr as uint, v)\n+    }\n \n-    fn emit_enum(name: &str, f: fn()) {\n+    fn emit_owned_str(&self, v: &str) {\n+        self.emit_borrowed_str(v)\n+    }\n+\n+    fn emit_managed_str(&self, v: &str) {\n+        self.emit_borrowed_str(v)\n+    }\n+\n+    fn emit_borrowed(&self, f: fn()) { f() }\n+    fn emit_owned(&self, f: fn()) { f() }\n+    fn emit_managed(&self, f: fn()) { f() }\n+\n+    fn emit_enum(&self, name: &str, f: fn()) {\n         self._emit_label(name);\n         self.wr_tag(EsEnum as uint, f)\n     }\n-    fn emit_enum_variant(_v_name: &str, v_id: uint, _cnt: uint, f: fn()) {\n+    fn emit_enum_variant(&self, _v_name: &str, v_id: uint, _cnt: uint,\n+                         f: fn()) {\n         self._emit_tagged_uint(EsEnumVid, v_id);\n         self.wr_tag(EsEnumBody as uint, f)\n     }\n-    fn emit_enum_variant_arg(_idx: uint, f: fn()) { f() }\n+    fn emit_enum_variant_arg(&self, _idx: uint, f: fn()) { f() }\n \n-    fn emit_vec(len: uint, f: fn()) {\n+    fn emit_borrowed_vec(&self, len: uint, f: fn()) {\n         do self.wr_tag(EsVec as uint) {\n             self._emit_tagged_uint(EsVecLen, len);\n             f()\n         }\n     }\n \n-    fn emit_vec_elt(_idx: uint, f: fn()) {\n+    fn emit_owned_vec(&self, len: uint, f: fn()) {\n+        self.emit_borrowed_vec(len, f)\n+    }\n+\n+    fn emit_managed_vec(&self, len: uint, f: fn()) {\n+        self.emit_borrowed_vec(len, f)\n+    }\n+\n+    fn emit_vec_elt(&self, _idx: uint, f: fn()) {\n         self.wr_tag(EsVecElt as uint, f)\n     }\n \n-    fn emit_box(f: fn()) { f() }\n-    fn emit_uniq(f: fn()) { f() }\n-    fn emit_rec(f: fn()) { f() }\n-    fn emit_rec_field(f_name: &str, _f_idx: uint, f: fn()) {\n-        self._emit_label(f_name);\n+    fn emit_rec(&self, f: fn()) { f() }\n+    fn emit_struct(&self, _name: &str, f: fn()) { f() }\n+    fn emit_field(&self, name: &str, _idx: uint, f: fn()) {\n+        self._emit_label(name);\n         f()\n     }\n-    fn emit_tup(_sz: uint, f: fn()) { f() }\n-    fn emit_tup_elt(_idx: uint, f: fn()) { f() }\n-}\n \n-type EbmlDeserializer_ = {mut parent: ebml::Doc,\n-                          mut pos: uint};\n+    fn emit_tup(&self, _len: uint, f: fn()) { f() }\n+    fn emit_tup_elt(&self, _idx: uint, f: fn()) { f() }\n+}\n \n-pub enum EbmlDeserializer {\n-    EbmlDeserializer_(EbmlDeserializer_)\n+struct Deserializer {\n+    priv mut parent: Doc,\n+    priv mut pos: uint,\n }\n \n-pub fn ebml_deserializer(d: ebml::Doc) -> EbmlDeserializer {\n-    EbmlDeserializer_({mut parent: d, mut pos: d.start})\n+pub fn Deserializer(d: Doc) -> Deserializer {\n+    Deserializer { mut parent: d, mut pos: d.start }\n }\n \n-priv impl EbmlDeserializer {\n+priv impl Deserializer {\n     fn _check_label(lbl: &str) {\n         if self.pos < self.parent.end {\n-            let {tag: r_tag, doc: r_doc} =\n-                ebml::doc_at(self.parent.data, self.pos);\n+            let TaggedDoc { tag: r_tag, doc: r_doc } =\n+                doc_at(self.parent.data, self.pos);\n+\n             if r_tag == (EsLabel as uint) {\n                 self.pos = r_doc.end;\n-                let str = ebml::doc_as_str(r_doc);\n+                let str = doc_as_str(r_doc);\n                 if lbl != str {\n                     fail fmt!(\"Expected label %s but found %s\", lbl, str);\n                 }\n             }\n         }\n     }\n \n-    fn next_doc(exp_tag: EbmlSerializerTag) -> ebml::Doc {\n+    fn next_doc(exp_tag: EbmlSerializerTag) -> Doc {\n         debug!(\". next_doc(exp_tag=%?)\", exp_tag);\n         if self.pos >= self.parent.end {\n             fail ~\"no more documents in current node!\";\n         }\n-        let {tag: r_tag, doc: r_doc} =\n-            ebml::doc_at(self.parent.data, self.pos);\n+        let TaggedDoc { tag: r_tag, doc: r_doc } =\n+            doc_at(self.parent.data, self.pos);\n         debug!(\"self.parent=%?-%? self.pos=%? r_tag=%? r_doc=%?-%?\",\n                copy self.parent.start, copy self.parent.end,\n                copy self.pos, r_tag, r_doc.start, r_doc.end);\n@@ -427,10 +469,10 @@ priv impl EbmlDeserializer {\n                       r_doc.end, self.parent.end);\n         }\n         self.pos = r_doc.end;\n-        return r_doc;\n+        r_doc\n     }\n \n-    fn push_doc<T>(d: ebml::Doc, f: fn() -> T) -> T{\n+    fn push_doc<T>(d: Doc, f: fn() -> T) -> T{\n         let old_parent = self.parent;\n         let old_pos = self.pos;\n         self.parent = d;\n@@ -442,63 +484,76 @@ priv impl EbmlDeserializer {\n     }\n \n     fn _next_uint(exp_tag: EbmlSerializerTag) -> uint {\n-        let r = ebml::doc_as_u32(self.next_doc(exp_tag));\n+        let r = doc_as_u32(self.next_doc(exp_tag));\n         debug!(\"_next_uint exp_tag=%? result=%?\", exp_tag, r);\n-        return r as uint;\n+        r as uint\n     }\n }\n \n-impl EbmlDeserializer {\n-    fn read_opaque<R>(op: fn(ebml::Doc) -> R) -> R {\n+impl Deserializer {\n+    fn read_opaque<R>(&self, op: fn(Doc) -> R) -> R {\n         do self.push_doc(self.next_doc(EsOpaque)) {\n             op(copy self.parent)\n         }\n     }\n }\n \n-impl EbmlDeserializer: serialization::Deserializer {\n-    fn read_nil() -> () { () }\n+impl Deserializer: serialization::Deserializer {\n+    fn read_nil(&self) -> () { () }\n \n-    fn read_u64() -> u64 { ebml::doc_as_u64(self.next_doc(EsU64)) }\n-    fn read_u32() -> u32 { ebml::doc_as_u32(self.next_doc(EsU32)) }\n-    fn read_u16() -> u16 { ebml::doc_as_u16(self.next_doc(EsU16)) }\n-    fn read_u8 () -> u8  { ebml::doc_as_u8 (self.next_doc(EsU8 )) }\n-    fn read_uint() -> uint {\n-        let v = ebml::doc_as_u64(self.next_doc(EsUint));\n+    fn read_u64(&self) -> u64 { doc_as_u64(self.next_doc(EsU64)) }\n+    fn read_u32(&self) -> u32 { doc_as_u32(self.next_doc(EsU32)) }\n+    fn read_u16(&self) -> u16 { doc_as_u16(self.next_doc(EsU16)) }\n+    fn read_u8 (&self) -> u8  { doc_as_u8 (self.next_doc(EsU8 )) }\n+    fn read_uint(&self) -> uint {\n+        let v = doc_as_u64(self.next_doc(EsUint));\n         if v > (core::uint::max_value as u64) {\n             fail fmt!(\"uint %? too large for this architecture\", v);\n         }\n-        return v as uint;\n+        v as uint\n     }\n \n-    fn read_i64() -> i64 { ebml::doc_as_u64(self.next_doc(EsI64)) as i64 }\n-    fn read_i32() -> i32 { ebml::doc_as_u32(self.next_doc(EsI32)) as i32 }\n-    fn read_i16() -> i16 { ebml::doc_as_u16(self.next_doc(EsI16)) as i16 }\n-    fn read_i8 () -> i8  { ebml::doc_as_u8 (self.next_doc(EsI8 )) as i8  }\n-    fn read_int() -> int {\n-        let v = ebml::doc_as_u64(self.next_doc(EsInt)) as i64;\n+    fn read_i64(&self) -> i64 { doc_as_u64(self.next_doc(EsI64)) as i64 }\n+    fn read_i32(&self) -> i32 { doc_as_u32(self.next_doc(EsI32)) as i32 }\n+    fn read_i16(&self) -> i16 { doc_as_u16(self.next_doc(EsI16)) as i16 }\n+    fn read_i8 (&self) -> i8  { doc_as_u8 (self.next_doc(EsI8 )) as i8  }\n+    fn read_int(&self) -> int {\n+        let v = doc_as_u64(self.next_doc(EsInt)) as i64;\n         if v > (int::max_value as i64) || v < (int::min_value as i64) {\n             fail fmt!(\"int %? out of range for this architecture\", v);\n         }\n-        return v as int;\n+        v as int\n     }\n \n-    fn read_bool() -> bool { ebml::doc_as_u8(self.next_doc(EsBool)) as bool }\n+    fn read_bool(&self) -> bool { doc_as_u8(self.next_doc(EsBool)) as bool }\n+\n+    fn read_f64(&self) -> f64 { fail ~\"read_f64()\"; }\n+    fn read_f32(&self) -> f32 { fail ~\"read_f32()\"; }\n+    fn read_float(&self) -> float { fail ~\"read_float()\"; }\n \n-    fn read_f64() -> f64 { fail ~\"read_f64()\"; }\n-    fn read_f32() -> f32 { fail ~\"read_f32()\"; }\n-    fn read_float() -> float { fail ~\"read_float()\"; }\n+    fn read_char(&self) -> char { fail ~\"read_char()\"; }\n \n-    fn read_str() -> ~str { ebml::doc_as_str(self.next_doc(EsStr)) }\n+    fn read_owned_str(&self) -> ~str { doc_as_str(self.next_doc(EsStr)) }\n+    fn read_managed_str(&self) -> @str { fail ~\"read_managed_str()\"; }\n \n     // Compound types:\n-    fn read_enum<T>(name: &str, f: fn() -> T) -> T {\n+    fn read_owned<T>(&self, f: fn() -> T) -> T {\n+        debug!(\"read_owned()\");\n+        f()\n+    }\n+\n+    fn read_managed<T>(&self, f: fn() -> T) -> T {\n+        debug!(\"read_managed()\");\n+        f()\n+    }\n+\n+    fn read_enum<T>(&self, name: &str, f: fn() -> T) -> T {\n         debug!(\"read_enum(%s)\", name);\n         self._check_label(name);\n         self.push_doc(self.next_doc(EsEnum), f)\n     }\n \n-    fn read_enum_variant<T>(f: fn(uint) -> T) -> T {\n+    fn read_enum_variant<T>(&self, f: fn(uint) -> T) -> T {\n         debug!(\"read_enum_variant()\");\n         let idx = self._next_uint(EsEnumVid);\n         debug!(\"  idx=%u\", idx);\n@@ -507,118 +562,83 @@ impl EbmlDeserializer: serialization::Deserializer {\n         }\n     }\n \n-    fn read_enum_variant_arg<T>(idx: uint, f: fn() -> T) -> T {\n+    fn read_enum_variant_arg<T>(&self, idx: uint, f: fn() -> T) -> T {\n         debug!(\"read_enum_variant_arg(idx=%u)\", idx);\n         f()\n     }\n \n-    fn read_vec<T>(f: fn(uint) -> T) -> T {\n-        debug!(\"read_vec()\");\n+    fn read_owned_vec<T>(&self, f: fn(uint) -> T) -> T {\n+        debug!(\"read_owned_vec()\");\n         do self.push_doc(self.next_doc(EsVec)) {\n             let len = self._next_uint(EsVecLen);\n             debug!(\"  len=%u\", len);\n             f(len)\n         }\n     }\n \n-    fn read_vec_elt<T>(idx: uint, f: fn() -> T) -> T {\n-        debug!(\"read_vec_elt(idx=%u)\", idx);\n-        self.push_doc(self.next_doc(EsVecElt), f)\n+    fn read_managed_vec<T>(&self, f: fn(uint) -> T) -> T {\n+        debug!(\"read_managed_vec()\");\n+        do self.push_doc(self.next_doc(EsVec)) {\n+            let len = self._next_uint(EsVecLen);\n+            debug!(\"  len=%u\", len);\n+            f(len)\n+        }\n     }\n \n-    fn read_box<T>(f: fn() -> T) -> T {\n-        debug!(\"read_box()\");\n-        f()\n+    fn read_vec_elt<T>(&self, idx: uint, f: fn() -> T) -> T {\n+        debug!(\"read_vec_elt(idx=%u)\", idx);\n+        self.push_doc(self.next_doc(EsVecElt), f)\n     }\n \n-    fn read_uniq<T>(f: fn() -> T) -> T {\n-        debug!(\"read_uniq()\");\n+    fn read_rec<T>(&self, f: fn() -> T) -> T {\n+        debug!(\"read_rec()\");\n         f()\n     }\n \n-    fn read_rec<T>(f: fn() -> T) -> T {\n-        debug!(\"read_rec()\");\n+    fn read_struct<T>(&self, name: &str, f: fn() -> T) -> T {\n+        debug!(\"read_struct(name=%s)\", name);\n         f()\n     }\n \n-    fn read_rec_field<T>(f_name: &str, f_idx: uint, f: fn() -> T) -> T {\n-        debug!(\"read_rec_field(%s, idx=%u)\", f_name, f_idx);\n-        self._check_label(f_name);\n+    fn read_field<T>(&self, name: &str, idx: uint, f: fn() -> T) -> T {\n+        debug!(\"read_field(name=%s, idx=%u)\", name, idx);\n+        self._check_label(name);\n         f()\n     }\n \n-    fn read_tup<T>(sz: uint, f: fn() -> T) -> T {\n-        debug!(\"read_tup(sz=%u)\", sz);\n+    fn read_tup<T>(&self, len: uint, f: fn() -> T) -> T {\n+        debug!(\"read_tup(len=%u)\", len);\n         f()\n     }\n \n-    fn read_tup_elt<T>(idx: uint, f: fn() -> T) -> T {\n+    fn read_tup_elt<T>(&self, idx: uint, f: fn() -> T) -> T {\n         debug!(\"read_tup_elt(idx=%u)\", idx);\n         f()\n     }\n }\n \n-\n // ___________________________________________________________________________\n // Testing\n \n-#[test]\n-fn test_option_int() {\n-    fn serialize_1<S: serialization::Serializer>(s: &S, v: int) {\n-        s.emit_i64(v as i64);\n-    }\n-\n-    fn serialize_0<S: serialization::Serializer>(s: &S, v: Option<int>) {\n-        do s.emit_enum(~\"core::option::t\") {\n-            match v {\n-              None => s.emit_enum_variant(\n-                  ~\"core::option::None\", 0u, 0u, || { } ),\n-              Some(v0) => {\n-                do s.emit_enum_variant(~\"core::option::some\", 1u, 1u) {\n-                    s.emit_enum_variant_arg(0u, || serialize_1(s, v0));\n-                }\n-              }\n-            }\n+#[cfg(test)]\n+mod tests {\n+    #[test]\n+    fn test_option_int() {\n+        fn test_v(v: Option<int>) {\n+            debug!(\"v == %?\", v);\n+            let bytes = do io::with_bytes_writer |wr| {\n+                let ebml_w = Serializer(wr);\n+                v.serialize(&ebml_w)\n+            };\n+            let ebml_doc = Doc(@bytes);\n+            let deser = Deserializer(ebml_doc);\n+            let v1 = serialization::deserialize(&deser);\n+            debug!(\"v1 == %?\", v1);\n+            assert v == v1;\n         }\n-    }\n \n-    fn deserialize_1<S: serialization::Deserializer>(s: &S) -> int {\n-        s.read_i64() as int\n-    }\n-\n-    fn deserialize_0<S: serialization::Deserializer>(s: &S) -> Option<int> {\n-        do s.read_enum(~\"core::option::t\") {\n-            do s.read_enum_variant |i| {\n-                match i {\n-                  0 => None,\n-                  1 => {\n-                    let v0 = do s.read_enum_variant_arg(0u) {\n-                        deserialize_1(s)\n-                    };\n-                    Some(v0)\n-                  }\n-                  _ => {\n-                    fail #fmt(\"deserialize_0: unexpected variant %u\", i);\n-                  }\n-                }\n-            }\n-        }\n+        test_v(Some(22));\n+        test_v(None);\n+        test_v(Some(3));\n     }\n-\n-    fn test_v(v: Option<int>) {\n-        debug!(\"v == %?\", v);\n-        let bytes = do io::with_bytes_writer |wr| {\n-            let ebml_w = ebml::Writer(wr);\n-            serialize_0(&ebml_w, v);\n-        };\n-        let ebml_doc = ebml::Doc(@bytes);\n-        let deser = ebml_deserializer(ebml_doc);\n-        let v1 = deserialize_0(&deser);\n-        debug!(\"v1 == %?\", v1);\n-        assert v == v1;\n-    }\n-\n-    test_v(Some(22));\n-    test_v(None);\n-    test_v(Some(3));\n }"}, {"sha": "f88aad1ac633afdbe51f01fb999f2f21d5f73213", "filename": "src/libstd/ebml2.rs", "status": "removed", "additions": 0, "deletions": 644, "changes": 644, "blob_url": "https://github.com/rust-lang/rust/blob/9aec7a3e85c5b07923eab05d3ebe9d031bf258f3/src%2Flibstd%2Febml2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aec7a3e85c5b07923eab05d3ebe9d031bf258f3/src%2Flibstd%2Febml2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Febml2.rs?ref=9aec7a3e85c5b07923eab05d3ebe9d031bf258f3", "patch": "@@ -1,644 +0,0 @@\n-#[forbid(deprecated_mode)];\n-use serialization2;\n-\n-// Simple Extensible Binary Markup Language (ebml) reader and writer on a\n-// cursor model. See the specification here:\n-//     http://www.matroska.org/technical/specs/rfc/index.html\n-\n-struct EbmlTag {\n-    id: uint,\n-    size: uint,\n-}\n-\n-struct EbmlState {\n-    ebml_tag: EbmlTag,\n-    tag_pos: uint,\n-    data_pos: uint,\n-}\n-\n-// FIXME (#2739): When we have module renaming, make \"reader\" and \"writer\"\n-// separate modules within this file.\n-\n-// ebml reading\n-struct Doc {\n-    data: @~[u8],\n-    start: uint,\n-    end: uint,\n-}\n-\n-struct TaggedDoc {\n-    tag: uint,\n-    doc: Doc,\n-}\n-\n-impl Doc: ops::Index<uint,Doc> {\n-    pure fn index(tag: uint) -> Doc {\n-        unsafe {\n-            get_doc(self, tag)\n-        }\n-    }\n-}\n-\n-fn vuint_at(data: &[u8], start: uint) -> {val: uint, next: uint} {\n-    let a = data[start];\n-    if a & 0x80u8 != 0u8 {\n-        return {val: (a & 0x7fu8) as uint, next: start + 1u};\n-    }\n-    if a & 0x40u8 != 0u8 {\n-        return {val: ((a & 0x3fu8) as uint) << 8u |\n-                 (data[start + 1u] as uint),\n-             next: start + 2u};\n-    } else if a & 0x20u8 != 0u8 {\n-        return {val: ((a & 0x1fu8) as uint) << 16u |\n-                 (data[start + 1u] as uint) << 8u |\n-                 (data[start + 2u] as uint),\n-             next: start + 3u};\n-    } else if a & 0x10u8 != 0u8 {\n-        return {val: ((a & 0x0fu8) as uint) << 24u |\n-                 (data[start + 1u] as uint) << 16u |\n-                 (data[start + 2u] as uint) << 8u |\n-                 (data[start + 3u] as uint),\n-             next: start + 4u};\n-    } else { error!(\"vint too big\"); fail; }\n-}\n-\n-pub fn Doc(data: @~[u8]) -> Doc {\n-    Doc { data: data, start: 0u, end: vec::len::<u8>(*data) }\n-}\n-\n-pub fn doc_at(data: @~[u8], start: uint) -> TaggedDoc {\n-    let elt_tag = vuint_at(*data, start);\n-    let elt_size = vuint_at(*data, elt_tag.next);\n-    let end = elt_size.next + elt_size.val;\n-    TaggedDoc {\n-        tag: elt_tag.val,\n-        doc: Doc { data: data, start: elt_size.next, end: end }\n-    }\n-}\n-\n-pub fn maybe_get_doc(d: Doc, tg: uint) -> Option<Doc> {\n-    let mut pos = d.start;\n-    while pos < d.end {\n-        let elt_tag = vuint_at(*d.data, pos);\n-        let elt_size = vuint_at(*d.data, elt_tag.next);\n-        pos = elt_size.next + elt_size.val;\n-        if elt_tag.val == tg {\n-            return Some(Doc { data: d.data, start: elt_size.next, end: pos });\n-        }\n-    }\n-    None\n-}\n-\n-pub fn get_doc(d: Doc, tg: uint) -> Doc {\n-    match maybe_get_doc(d, tg) {\n-      Some(d) => d,\n-      None => {\n-        error!(\"failed to find block with tag %u\", tg);\n-        fail;\n-      }\n-    }\n-}\n-\n-pub fn docs(d: Doc, it: fn(uint, Doc) -> bool) {\n-    let mut pos = d.start;\n-    while pos < d.end {\n-        let elt_tag = vuint_at(*d.data, pos);\n-        let elt_size = vuint_at(*d.data, elt_tag.next);\n-        pos = elt_size.next + elt_size.val;\n-        let doc = Doc { data: d.data, start: elt_size.next, end: pos };\n-        if !it(elt_tag.val, doc) {\n-            break;\n-        }\n-    }\n-}\n-\n-pub fn tagged_docs(d: Doc, tg: uint, it: fn(Doc) -> bool) {\n-    let mut pos = d.start;\n-    while pos < d.end {\n-        let elt_tag = vuint_at(*d.data, pos);\n-        let elt_size = vuint_at(*d.data, elt_tag.next);\n-        pos = elt_size.next + elt_size.val;\n-        if elt_tag.val == tg {\n-            let doc = Doc { data: d.data, start: elt_size.next, end: pos };\n-            if !it(doc) {\n-                break;\n-            }\n-        }\n-    }\n-}\n-\n-pub fn doc_data(d: Doc) -> ~[u8] { vec::slice::<u8>(*d.data, d.start, d.end) }\n-\n-pub fn with_doc_data<T>(d: Doc, f: fn(x: &[u8]) -> T) -> T {\n-    f(vec::view(*d.data, d.start, d.end))\n-}\n-\n-pub fn doc_as_str(d: Doc) -> ~str { str::from_bytes(doc_data(d)) }\n-\n-pub fn doc_as_u8(d: Doc) -> u8 {\n-    assert d.end == d.start + 1u;\n-    (*d.data)[d.start]\n-}\n-\n-pub fn doc_as_u16(d: Doc) -> u16 {\n-    assert d.end == d.start + 2u;\n-    io::u64_from_be_bytes(*d.data, d.start, 2u) as u16\n-}\n-\n-pub fn doc_as_u32(d: Doc) -> u32 {\n-    assert d.end == d.start + 4u;\n-    io::u64_from_be_bytes(*d.data, d.start, 4u) as u32\n-}\n-\n-pub fn doc_as_u64(d: Doc) -> u64 {\n-    assert d.end == d.start + 8u;\n-    io::u64_from_be_bytes(*d.data, d.start, 8u)\n-}\n-\n-pub fn doc_as_i8(d: Doc) -> i8 { doc_as_u8(d) as i8 }\n-pub fn doc_as_i16(d: Doc) -> i16 { doc_as_u16(d) as i16 }\n-pub fn doc_as_i32(d: Doc) -> i32 { doc_as_u32(d) as i32 }\n-pub fn doc_as_i64(d: Doc) -> i64 { doc_as_u64(d) as i64 }\n-\n-// ebml writing\n-struct Serializer {\n-    writer: io::Writer,\n-    priv mut size_positions: ~[uint],\n-}\n-\n-fn write_sized_vuint(w: io::Writer, n: uint, size: uint) {\n-    match size {\n-      1u => w.write(&[0x80u8 | (n as u8)]),\n-      2u => w.write(&[0x40u8 | ((n >> 8_u) as u8), n as u8]),\n-      3u => w.write(&[0x20u8 | ((n >> 16_u) as u8), (n >> 8_u) as u8,\n-                      n as u8]),\n-      4u => w.write(&[0x10u8 | ((n >> 24_u) as u8), (n >> 16_u) as u8,\n-                      (n >> 8_u) as u8, n as u8]),\n-      _ => fail fmt!(\"vint to write too big: %?\", n)\n-    };\n-}\n-\n-fn write_vuint(w: io::Writer, n: uint) {\n-    if n < 0x7f_u { write_sized_vuint(w, n, 1u); return; }\n-    if n < 0x4000_u { write_sized_vuint(w, n, 2u); return; }\n-    if n < 0x200000_u { write_sized_vuint(w, n, 3u); return; }\n-    if n < 0x10000000_u { write_sized_vuint(w, n, 4u); return; }\n-    fail fmt!(\"vint to write too big: %?\", n);\n-}\n-\n-pub fn Serializer(w: io::Writer) -> Serializer {\n-    let size_positions: ~[uint] = ~[];\n-    Serializer { writer: w, mut size_positions: size_positions }\n-}\n-\n-// FIXME (#2741): Provide a function to write the standard ebml header.\n-impl Serializer {\n-    fn start_tag(tag_id: uint) {\n-        debug!(\"Start tag %u\", tag_id);\n-\n-        // Write the enum ID:\n-        write_vuint(self.writer, tag_id);\n-\n-        // Write a placeholder four-byte size.\n-        self.size_positions.push(self.writer.tell());\n-        let zeroes: &[u8] = &[0u8, 0u8, 0u8, 0u8];\n-        self.writer.write(zeroes);\n-    }\n-\n-    fn end_tag() {\n-        let last_size_pos = self.size_positions.pop();\n-        let cur_pos = self.writer.tell();\n-        self.writer.seek(last_size_pos as int, io::SeekSet);\n-        let size = (cur_pos - last_size_pos - 4u);\n-        write_sized_vuint(self.writer, size, 4u);\n-        self.writer.seek(cur_pos as int, io::SeekSet);\n-\n-        debug!(\"End tag (size = %u)\", size);\n-    }\n-\n-    fn wr_tag(tag_id: uint, blk: fn()) {\n-        self.start_tag(tag_id);\n-        blk();\n-        self.end_tag();\n-    }\n-\n-    fn wr_tagged_bytes(tag_id: uint, b: &[u8]) {\n-        write_vuint(self.writer, tag_id);\n-        write_vuint(self.writer, vec::len(b));\n-        self.writer.write(b);\n-    }\n-\n-    fn wr_tagged_u64(tag_id: uint, v: u64) {\n-        do io::u64_to_be_bytes(v, 8u) |v| {\n-            self.wr_tagged_bytes(tag_id, v);\n-        }\n-    }\n-\n-    fn wr_tagged_u32(tag_id: uint, v: u32) {\n-        do io::u64_to_be_bytes(v as u64, 4u) |v| {\n-            self.wr_tagged_bytes(tag_id, v);\n-        }\n-    }\n-\n-    fn wr_tagged_u16(tag_id: uint, v: u16) {\n-        do io::u64_to_be_bytes(v as u64, 2u) |v| {\n-            self.wr_tagged_bytes(tag_id, v);\n-        }\n-    }\n-\n-    fn wr_tagged_u8(tag_id: uint, v: u8) {\n-        self.wr_tagged_bytes(tag_id, &[v]);\n-    }\n-\n-    fn wr_tagged_i64(tag_id: uint, v: i64) {\n-        do io::u64_to_be_bytes(v as u64, 8u) |v| {\n-            self.wr_tagged_bytes(tag_id, v);\n-        }\n-    }\n-\n-    fn wr_tagged_i32(tag_id: uint, v: i32) {\n-        do io::u64_to_be_bytes(v as u64, 4u) |v| {\n-            self.wr_tagged_bytes(tag_id, v);\n-        }\n-    }\n-\n-    fn wr_tagged_i16(tag_id: uint, v: i16) {\n-        do io::u64_to_be_bytes(v as u64, 2u) |v| {\n-            self.wr_tagged_bytes(tag_id, v);\n-        }\n-    }\n-\n-    fn wr_tagged_i8(tag_id: uint, v: i8) {\n-        self.wr_tagged_bytes(tag_id, &[v as u8]);\n-    }\n-\n-    fn wr_tagged_str(tag_id: uint, v: &str) {\n-        str::byte_slice(v, |b| self.wr_tagged_bytes(tag_id, b));\n-    }\n-\n-    fn wr_bytes(b: &[u8]) {\n-        debug!(\"Write %u bytes\", vec::len(b));\n-        self.writer.write(b);\n-    }\n-\n-    fn wr_str(s: &str) {\n-        debug!(\"Write str: %?\", s);\n-        self.writer.write(str::to_bytes(s));\n-    }\n-}\n-\n-// FIXME (#2743): optionally perform \"relaxations\" on end_tag to more\n-// efficiently encode sizes; this is a fixed point iteration\n-\n-// Set to true to generate more debugging in EBML serialization.\n-// Totally lame approach.\n-const debug: bool = false;\n-\n-enum EbmlSerializerTag {\n-    EsUint, EsU64, EsU32, EsU16, EsU8,\n-    EsInt, EsI64, EsI32, EsI16, EsI8,\n-    EsBool,\n-    EsStr,\n-    EsF64, EsF32, EsFloat,\n-    EsEnum, EsEnumVid, EsEnumBody,\n-    EsVec, EsVecLen, EsVecElt,\n-\n-    EsOpaque,\n-\n-    EsLabel // Used only when debugging\n-}\n-\n-priv impl Serializer {\n-    // used internally to emit things like the vector length and so on\n-    fn _emit_tagged_uint(t: EbmlSerializerTag, v: uint) {\n-        assert v <= 0xFFFF_FFFF_u;\n-        self.wr_tagged_u32(t as uint, v as u32);\n-    }\n-\n-    fn _emit_label(label: &str) {\n-        // There are various strings that we have access to, such as\n-        // the name of a record field, which do not actually appear in\n-        // the serialized EBML (normally).  This is just for\n-        // efficiency.  When debugging, though, we can emit such\n-        // labels and then they will be checked by deserializer to\n-        // try and check failures more quickly.\n-        if debug { self.wr_tagged_str(EsLabel as uint, label) }\n-    }\n-}\n-\n-impl Serializer {\n-    fn emit_opaque(&self, f: fn()) {\n-        do self.wr_tag(EsOpaque as uint) {\n-            f()\n-        }\n-    }\n-}\n-\n-impl Serializer: serialization2::Serializer {\n-    fn emit_nil(&self) {}\n-\n-    fn emit_uint(&self, v: uint) {\n-        self.wr_tagged_u64(EsUint as uint, v as u64);\n-    }\n-    fn emit_u64(&self, v: u64) { self.wr_tagged_u64(EsU64 as uint, v); }\n-    fn emit_u32(&self, v: u32) { self.wr_tagged_u32(EsU32 as uint, v); }\n-    fn emit_u16(&self, v: u16) { self.wr_tagged_u16(EsU16 as uint, v); }\n-    fn emit_u8(&self, v: u8)   { self.wr_tagged_u8 (EsU8  as uint, v); }\n-\n-    fn emit_int(&self, v: int) {\n-        self.wr_tagged_i64(EsInt as uint, v as i64);\n-    }\n-    fn emit_i64(&self, v: i64) { self.wr_tagged_i64(EsI64 as uint, v); }\n-    fn emit_i32(&self, v: i32) { self.wr_tagged_i32(EsI32 as uint, v); }\n-    fn emit_i16(&self, v: i16) { self.wr_tagged_i16(EsI16 as uint, v); }\n-    fn emit_i8(&self, v: i8)   { self.wr_tagged_i8 (EsI8  as uint, v); }\n-\n-    fn emit_bool(&self, v: bool) {\n-        self.wr_tagged_u8(EsBool as uint, v as u8)\n-    }\n-\n-    // FIXME (#2742): implement these\n-    fn emit_f64(&self, _v: f64) { fail ~\"Unimplemented: serializing an f64\"; }\n-    fn emit_f32(&self, _v: f32) { fail ~\"Unimplemented: serializing an f32\"; }\n-    fn emit_float(&self, _v: float) {\n-        fail ~\"Unimplemented: serializing a float\";\n-    }\n-\n-    fn emit_char(&self, _v: char) {\n-        fail ~\"Unimplemented: serializing a char\";\n-    }\n-\n-    fn emit_borrowed_str(&self, v: &str) {\n-        self.wr_tagged_str(EsStr as uint, v)\n-    }\n-\n-    fn emit_owned_str(&self, v: &str) {\n-        self.emit_borrowed_str(v)\n-    }\n-\n-    fn emit_managed_str(&self, v: &str) {\n-        self.emit_borrowed_str(v)\n-    }\n-\n-    fn emit_borrowed(&self, f: fn()) { f() }\n-    fn emit_owned(&self, f: fn()) { f() }\n-    fn emit_managed(&self, f: fn()) { f() }\n-\n-    fn emit_enum(&self, name: &str, f: fn()) {\n-        self._emit_label(name);\n-        self.wr_tag(EsEnum as uint, f)\n-    }\n-    fn emit_enum_variant(&self, _v_name: &str, v_id: uint, _cnt: uint,\n-                         f: fn()) {\n-        self._emit_tagged_uint(EsEnumVid, v_id);\n-        self.wr_tag(EsEnumBody as uint, f)\n-    }\n-    fn emit_enum_variant_arg(&self, _idx: uint, f: fn()) { f() }\n-\n-    fn emit_borrowed_vec(&self, len: uint, f: fn()) {\n-        do self.wr_tag(EsVec as uint) {\n-            self._emit_tagged_uint(EsVecLen, len);\n-            f()\n-        }\n-    }\n-\n-    fn emit_owned_vec(&self, len: uint, f: fn()) {\n-        self.emit_borrowed_vec(len, f)\n-    }\n-\n-    fn emit_managed_vec(&self, len: uint, f: fn()) {\n-        self.emit_borrowed_vec(len, f)\n-    }\n-\n-    fn emit_vec_elt(&self, _idx: uint, f: fn()) {\n-        self.wr_tag(EsVecElt as uint, f)\n-    }\n-\n-    fn emit_rec(&self, f: fn()) { f() }\n-    fn emit_struct(&self, _name: &str, f: fn()) { f() }\n-    fn emit_field(&self, name: &str, _idx: uint, f: fn()) {\n-        self._emit_label(name);\n-        f()\n-    }\n-\n-    fn emit_tup(&self, _len: uint, f: fn()) { f() }\n-    fn emit_tup_elt(&self, _idx: uint, f: fn()) { f() }\n-}\n-\n-struct Deserializer {\n-    priv mut parent: Doc,\n-    priv mut pos: uint,\n-}\n-\n-pub fn Deserializer(d: Doc) -> Deserializer {\n-    Deserializer { mut parent: d, mut pos: d.start }\n-}\n-\n-priv impl Deserializer {\n-    fn _check_label(lbl: &str) {\n-        if self.pos < self.parent.end {\n-            let TaggedDoc { tag: r_tag, doc: r_doc } =\n-                doc_at(self.parent.data, self.pos);\n-\n-            if r_tag == (EsLabel as uint) {\n-                self.pos = r_doc.end;\n-                let str = doc_as_str(r_doc);\n-                if lbl != str {\n-                    fail fmt!(\"Expected label %s but found %s\", lbl, str);\n-                }\n-            }\n-        }\n-    }\n-\n-    fn next_doc(exp_tag: EbmlSerializerTag) -> Doc {\n-        debug!(\". next_doc(exp_tag=%?)\", exp_tag);\n-        if self.pos >= self.parent.end {\n-            fail ~\"no more documents in current node!\";\n-        }\n-        let TaggedDoc { tag: r_tag, doc: r_doc } =\n-            doc_at(self.parent.data, self.pos);\n-        debug!(\"self.parent=%?-%? self.pos=%? r_tag=%? r_doc=%?-%?\",\n-               copy self.parent.start, copy self.parent.end,\n-               copy self.pos, r_tag, r_doc.start, r_doc.end);\n-        if r_tag != (exp_tag as uint) {\n-            fail fmt!(\"expected EMBL doc with tag %? but found tag %?\",\n-                      exp_tag, r_tag);\n-        }\n-        if r_doc.end > self.parent.end {\n-            fail fmt!(\"invalid EBML, child extends to 0x%x, parent to 0x%x\",\n-                      r_doc.end, self.parent.end);\n-        }\n-        self.pos = r_doc.end;\n-        r_doc\n-    }\n-\n-    fn push_doc<T>(d: Doc, f: fn() -> T) -> T{\n-        let old_parent = self.parent;\n-        let old_pos = self.pos;\n-        self.parent = d;\n-        self.pos = d.start;\n-        let r = f();\n-        self.parent = old_parent;\n-        self.pos = old_pos;\n-        move r\n-    }\n-\n-    fn _next_uint(exp_tag: EbmlSerializerTag) -> uint {\n-        let r = doc_as_u32(self.next_doc(exp_tag));\n-        debug!(\"_next_uint exp_tag=%? result=%?\", exp_tag, r);\n-        r as uint\n-    }\n-}\n-\n-impl Deserializer {\n-    fn read_opaque<R>(&self, op: fn(Doc) -> R) -> R {\n-        do self.push_doc(self.next_doc(EsOpaque)) {\n-            op(copy self.parent)\n-        }\n-    }\n-}\n-\n-impl Deserializer: serialization2::Deserializer {\n-    fn read_nil(&self) -> () { () }\n-\n-    fn read_u64(&self) -> u64 { doc_as_u64(self.next_doc(EsU64)) }\n-    fn read_u32(&self) -> u32 { doc_as_u32(self.next_doc(EsU32)) }\n-    fn read_u16(&self) -> u16 { doc_as_u16(self.next_doc(EsU16)) }\n-    fn read_u8 (&self) -> u8  { doc_as_u8 (self.next_doc(EsU8 )) }\n-    fn read_uint(&self) -> uint {\n-        let v = doc_as_u64(self.next_doc(EsUint));\n-        if v > (core::uint::max_value as u64) {\n-            fail fmt!(\"uint %? too large for this architecture\", v);\n-        }\n-        v as uint\n-    }\n-\n-    fn read_i64(&self) -> i64 { doc_as_u64(self.next_doc(EsI64)) as i64 }\n-    fn read_i32(&self) -> i32 { doc_as_u32(self.next_doc(EsI32)) as i32 }\n-    fn read_i16(&self) -> i16 { doc_as_u16(self.next_doc(EsI16)) as i16 }\n-    fn read_i8 (&self) -> i8  { doc_as_u8 (self.next_doc(EsI8 )) as i8  }\n-    fn read_int(&self) -> int {\n-        let v = doc_as_u64(self.next_doc(EsInt)) as i64;\n-        if v > (int::max_value as i64) || v < (int::min_value as i64) {\n-            fail fmt!(\"int %? out of range for this architecture\", v);\n-        }\n-        v as int\n-    }\n-\n-    fn read_bool(&self) -> bool { doc_as_u8(self.next_doc(EsBool)) as bool }\n-\n-    fn read_f64(&self) -> f64 { fail ~\"read_f64()\"; }\n-    fn read_f32(&self) -> f32 { fail ~\"read_f32()\"; }\n-    fn read_float(&self) -> float { fail ~\"read_float()\"; }\n-\n-    fn read_char(&self) -> char { fail ~\"read_char()\"; }\n-\n-    fn read_owned_str(&self) -> ~str { doc_as_str(self.next_doc(EsStr)) }\n-    fn read_managed_str(&self) -> @str { fail ~\"read_managed_str()\"; }\n-\n-    // Compound types:\n-    fn read_owned<T>(&self, f: fn() -> T) -> T {\n-        debug!(\"read_owned()\");\n-        f()\n-    }\n-\n-    fn read_managed<T>(&self, f: fn() -> T) -> T {\n-        debug!(\"read_managed()\");\n-        f()\n-    }\n-\n-    fn read_enum<T>(&self, name: &str, f: fn() -> T) -> T {\n-        debug!(\"read_enum(%s)\", name);\n-        self._check_label(name);\n-        self.push_doc(self.next_doc(EsEnum), f)\n-    }\n-\n-    fn read_enum_variant<T>(&self, f: fn(uint) -> T) -> T {\n-        debug!(\"read_enum_variant()\");\n-        let idx = self._next_uint(EsEnumVid);\n-        debug!(\"  idx=%u\", idx);\n-        do self.push_doc(self.next_doc(EsEnumBody)) {\n-            f(idx)\n-        }\n-    }\n-\n-    fn read_enum_variant_arg<T>(&self, idx: uint, f: fn() -> T) -> T {\n-        debug!(\"read_enum_variant_arg(idx=%u)\", idx);\n-        f()\n-    }\n-\n-    fn read_owned_vec<T>(&self, f: fn(uint) -> T) -> T {\n-        debug!(\"read_owned_vec()\");\n-        do self.push_doc(self.next_doc(EsVec)) {\n-            let len = self._next_uint(EsVecLen);\n-            debug!(\"  len=%u\", len);\n-            f(len)\n-        }\n-    }\n-\n-    fn read_managed_vec<T>(&self, f: fn(uint) -> T) -> T {\n-        debug!(\"read_managed_vec()\");\n-        do self.push_doc(self.next_doc(EsVec)) {\n-            let len = self._next_uint(EsVecLen);\n-            debug!(\"  len=%u\", len);\n-            f(len)\n-        }\n-    }\n-\n-    fn read_vec_elt<T>(&self, idx: uint, f: fn() -> T) -> T {\n-        debug!(\"read_vec_elt(idx=%u)\", idx);\n-        self.push_doc(self.next_doc(EsVecElt), f)\n-    }\n-\n-    fn read_rec<T>(&self, f: fn() -> T) -> T {\n-        debug!(\"read_rec()\");\n-        f()\n-    }\n-\n-    fn read_struct<T>(&self, name: &str, f: fn() -> T) -> T {\n-        debug!(\"read_struct(name=%s)\", name);\n-        f()\n-    }\n-\n-    fn read_field<T>(&self, name: &str, idx: uint, f: fn() -> T) -> T {\n-        debug!(\"read_field(name=%s, idx=%u)\", name, idx);\n-        self._check_label(name);\n-        f()\n-    }\n-\n-    fn read_tup<T>(&self, len: uint, f: fn() -> T) -> T {\n-        debug!(\"read_tup(len=%u)\", len);\n-        f()\n-    }\n-\n-    fn read_tup_elt<T>(&self, idx: uint, f: fn() -> T) -> T {\n-        debug!(\"read_tup_elt(idx=%u)\", idx);\n-        f()\n-    }\n-}\n-\n-// ___________________________________________________________________________\n-// Testing\n-\n-#[cfg(test)]\n-mod tests {\n-    #[test]\n-    fn test_option_int() {\n-        fn test_v(v: Option<int>) {\n-            debug!(\"v == %?\", v);\n-            let bytes = do io::with_bytes_writer |wr| {\n-                let ebml_w = Serializer(wr);\n-                v.serialize(&ebml_w)\n-            };\n-            let ebml_doc = Doc(@bytes);\n-            let deser = Deserializer(ebml_doc);\n-            let v1 = serialization2::deserialize(&deser);\n-            debug!(\"v1 == %?\", v1);\n-            assert v == v1;\n-        }\n-\n-        test_v(Some(22));\n-        test_v(None);\n-        test_v(Some(3));\n-    }\n-}"}, {"sha": "8d77b88aba23083b0870600006a3d08e4e1a7053", "filename": "src/libstd/getopts.rs", "status": "modified", "additions": 409, "deletions": 3, "changes": 412, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibstd%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibstd%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgetopts.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820", "patch": "@@ -82,7 +82,7 @@ pub type Opt = {name: Name, hasarg: HasArg, occur: Occur};\n \n fn mkname(nm: &str) -> Name {\n     let unm = str::from_slice(nm);\n-    return if str::len(nm) == 1u {\n+    return if nm.len() == 1u {\n             Short(str::char_at(unm, 0u))\n         } else { Long(unm) };\n }\n@@ -114,6 +114,22 @@ impl Occur : Eq {\n     pure fn ne(other: &Occur) -> bool { !self.eq(other) }\n }\n \n+impl HasArg : Eq {\n+    pure fn eq(other: &HasArg) -> bool {\n+        (self as uint) == ((*other) as uint)\n+    }\n+    pure fn ne(other: &HasArg) -> bool { !self.eq(other) }\n+}\n+\n+impl Opt : Eq {\n+    pure fn eq(other: &Opt) -> bool {\n+        self.name   == (*other).name   &&\n+        self.hasarg == (*other).hasarg &&\n+        self.occur  == (*other).occur\n+    }\n+    pure fn ne(other: &Opt) -> bool { !self.eq(other) }\n+}\n+\n /// Create an option that is required and takes an argument\n pub fn reqopt(name: &str) -> Opt {\n     return {name: mkname(name), hasarg: Yes, occur: Req};\n@@ -150,8 +166,29 @@ enum Optval { Val(~str), Given, }\n  */\n pub type Matches = {opts: ~[Opt], vals: ~[~[Optval]], free: ~[~str]};\n \n+impl Optval : Eq {\n+    pure fn eq(other: &Optval) -> bool {\n+        match self {\n+            Val(ref s) => match *other { Val (ref os) => s == os,\n+                                          Given => false },\n+            Given       => match *other { Val(_) => false,\n+                                          Given => true }\n+        }\n+    }\n+    pure fn ne(other: &Optval) -> bool { !self.eq(other) }\n+}\n+\n+impl Matches : Eq {\n+    pure fn eq(other: &Matches) -> bool {\n+        self.opts == (*other).opts &&\n+        self.vals == (*other).vals &&\n+        self.free == (*other).free\n+    }\n+    pure fn ne(other: &Matches) -> bool { !self.eq(other) }\n+}\n+\n fn is_arg(arg: &str) -> bool {\n-    return str::len(arg) > 1u && arg[0] == '-' as u8;\n+    return arg.len() > 1u && arg[0] == '-' as u8;\n }\n \n fn name_str(nm: &Name) -> ~str {\n@@ -177,6 +214,35 @@ pub enum Fail_ {\n     UnexpectedArgument(~str),\n }\n \n+impl Fail_ : Eq {\n+    // this whole thing should be easy to infer...\n+    pure fn eq(other: &Fail_) -> bool {\n+        match self {\n+            ArgumentMissing(ref s) => {\n+                match *other { ArgumentMissing(ref so)    => s == so,\n+                               _                          => false }\n+            }\n+            UnrecognizedOption(ref s) => {\n+                match *other { UnrecognizedOption(ref so) => s == so,\n+                               _                          => false }\n+            }\n+            OptionMissing(ref s) => {\n+                match *other { OptionMissing(ref so)      => s == so,\n+                               _                          => false }\n+            }\n+            OptionDuplicated(ref s) => {\n+                match *other { OptionDuplicated(ref so)   => s == so,\n+                               _                          => false }\n+            }\n+            UnexpectedArgument(ref s) => {\n+                match *other { UnexpectedArgument(ref so) => s == so,\n+                               _                          => false }\n+            }\n+        }\n+    }\n+    pure fn ne(other: &Fail_) -> bool { !self.eq(other) }\n+}\n+\n /// Convert a `fail_` enum into an error string\n pub fn fail_str(f: Fail_) -> ~str {\n     return match f {\n@@ -220,7 +286,7 @@ pub fn getopts(args: &[~str], opts: &[Opt]) -> Result unsafe {\n     let mut i = 0u;\n     while i < l {\n         let cur = args[i];\n-        let curlen = str::len(cur);\n+        let curlen = cur.len();\n         if !is_arg(cur) {\n             free.push(cur);\n         } else if cur == ~\"--\" {\n@@ -444,6 +510,194 @@ impl FailType : Eq {\n     pure fn ne(other: &FailType) -> bool { !self.eq(other) }\n }\n \n+/** A module which provides a way to specify descriptions and\n+ *  groups of short and long option names, together.\n+ */\n+pub mod groups {\n+\n+    /** one group of options, e.g., both -h and --help, along with\n+     * their shared description and properties\n+     */\n+    pub type OptGroup = {\n+        short_name: ~str,\n+        long_name: ~str,\n+        hint: ~str,\n+        desc: ~str,\n+        hasarg: HasArg,\n+        occur: Occur\n+    };\n+\n+    impl OptGroup : Eq {\n+        pure fn eq(other: &OptGroup) -> bool {\n+            self.short_name == (*other).short_name &&\n+            self.long_name  == (*other).long_name  &&\n+            self.hint       == (*other).hint       &&\n+            self.desc       == (*other).desc       &&\n+            self.hasarg     == (*other).hasarg     &&\n+            self.occur      == (*other).occur\n+        }\n+        pure fn ne(other: &OptGroup) -> bool { !self.eq(other) }\n+    }\n+\n+    /// Create a long option that is required and takes an argument\n+    pub fn reqopt(short_name: &str, long_name: &str,\n+                  desc: &str, hint: &str) -> OptGroup {\n+        let len = short_name.len();\n+        assert len == 1 || len == 0;\n+        return {short_name: str::from_slice(short_name),\n+                long_name: str::from_slice(long_name),\n+                hint: str::from_slice(hint),\n+                desc: str::from_slice(desc),\n+                hasarg: Yes,\n+                occur: Req};\n+    }\n+\n+    /// Create a long option that is optional and takes an argument\n+    pub fn optopt(short_name: &str, long_name: &str,\n+                  desc: &str, hint: &str) -> OptGroup {\n+        let len = short_name.len();\n+        assert len == 1 || len == 0;\n+        return {short_name: str::from_slice(short_name),\n+                long_name: str::from_slice(long_name),\n+                hint: str::from_slice(hint),\n+                desc: str::from_slice(desc),\n+                hasarg: Yes,\n+                occur: Optional};\n+    }\n+\n+    /// Create a long option that is optional and does not take an argument\n+    pub fn optflag(short_name: &str, long_name: &str,\n+                   desc: &str) -> OptGroup {\n+        let len = short_name.len();\n+        assert len == 1 || len == 0;\n+        return {short_name: str::from_slice(short_name),\n+                long_name: str::from_slice(long_name),\n+                hint: ~\"\",\n+                desc: str::from_slice(desc),\n+                hasarg: No,\n+                occur: Optional};\n+    }\n+\n+    /// Create a long option that is optional and takes an optional argument\n+    pub fn optflagopt(short_name: &str, long_name: &str,\n+                      desc: &str, hint: &str) -> OptGroup {\n+        let len = short_name.len();\n+        assert len == 1 || len == 0;\n+        return {short_name: str::from_slice(short_name),\n+                long_name: str::from_slice(long_name),\n+                hint: str::from_slice(hint),\n+                desc: str::from_slice(desc),\n+                hasarg: Maybe,\n+                occur: Optional};\n+    }\n+\n+    /**\n+     * Create a long option that is optional, takes an argument, and may occur\n+     * multiple times\n+     */\n+    pub fn optmulti(short_name: &str, long_name: &str,\n+                    desc: &str, hint: &str) -> OptGroup {\n+        let len = short_name.len();\n+        assert len == 1 || len == 0;\n+        return {short_name: str::from_slice(short_name),\n+                long_name: str::from_slice(long_name),\n+                hint: str::from_slice(hint),\n+                desc: str::from_slice(desc),\n+                hasarg: Yes,\n+                occur: Multi};\n+    }\n+\n+    // translate OptGroup into Opt\n+    // (both short and long names correspond to different Opts)\n+    pub fn long_to_short(lopt: &OptGroup) -> ~[Opt] {\n+        match ((*lopt).short_name.len(),\n+               (*lopt).long_name.len()) {\n+\n+           (0,0) => fail ~\"this long-format option was given no name\",\n+\n+           (0,_) => ~[{name:   Long(((*lopt).long_name)),\n+                       hasarg: (*lopt).hasarg,\n+                       occur:  (*lopt).occur}],\n+\n+           (1,0) => ~[{name:  Short(str::char_at((*lopt).short_name, 0)),\n+                       hasarg: (*lopt).hasarg,\n+                       occur:  (*lopt).occur}],\n+\n+           (1,_) => ~[{name:   Short(str::char_at((*lopt).short_name, 0)),\n+                       hasarg: (*lopt).hasarg,\n+                       occur:  (*lopt).occur},\n+                      {name:   Long(((*lopt).long_name)),\n+                       hasarg: (*lopt).hasarg,\n+                       occur:  (*lopt).occur}],\n+\n+           (_,_) => fail ~\"something is wrong with the long-form opt\"\n+        }\n+    }\n+\n+    /*\n+     * Parse command line args with the provided long format options\n+     */\n+    pub fn getopts(args: &[~str], opts: &[OptGroup]) -> Result {\n+        ::getopts::getopts(args, vec::flat_map(opts, long_to_short))\n+    }\n+\n+    /**\n+     * Derive a usage message from a set of long options\n+     */\n+    pub fn usage(brief: &str, opts: &[OptGroup]) -> ~str {\n+\n+        let desc_sep = ~\"\\n\" + str::repeat(~\" \", 24);\n+\n+        let rows = vec::map(opts, |optref| {\n+            let short_name = (*optref).short_name;\n+            let long_name = (*optref).long_name;\n+            let hint = (*optref).hint;\n+            let desc = (*optref).desc;\n+            let hasarg = (*optref).hasarg;\n+\n+            let mut row = str::repeat(~\" \", 4);\n+\n+            // short option\n+            row += match short_name.len() {\n+                0 => ~\"\",\n+                1 => ~\"-\" + short_name + \" \",\n+                _ => fail ~\"the short name should only be 1 char long\",\n+            };\n+\n+            // long option\n+            row += match long_name.len() {\n+                0 => ~\"\",\n+                _ => ~\"--\" + long_name + \" \",\n+            };\n+\n+            // arg\n+            row += match hasarg {\n+                No    => ~\"\",\n+                Yes   => hint,\n+                Maybe => ~\"[\" + hint + ~\"]\",\n+            };\n+\n+            // here we just need to indent the start of the description\n+            let rowlen = row.len();\n+            row += if rowlen < 24 {\n+                str::repeat(~\" \", 24 - rowlen)\n+            } else {\n+                desc_sep\n+            };\n+\n+            // wrapped description\n+            row += str::connect(str::split_within(desc, 54), desc_sep);\n+\n+            row\n+        });\n+\n+        return str::from_slice(brief)    +\n+               ~\"\\n\\nOptions:\\n\"         +\n+               str::connect(rows, ~\"\\n\") +\n+               ~\"\\n\\n\";\n+    }\n+} // end groups module\n+\n #[cfg(test)]\n mod tests {\n     #[legacy_exports];\n@@ -943,6 +1197,158 @@ mod tests {\n         assert opts_present(matches, ~[~\"L\"]);\n         assert opts_str(matches, ~[~\"L\"]) == ~\"foo\";\n     }\n+\n+    #[test]\n+    fn test_groups_reqopt() {\n+        let opt = groups::reqopt(~\"b\", ~\"banana\", ~\"some bananas\", ~\"VAL\");\n+        assert opt == { short_name: ~\"b\",\n+                        long_name: ~\"banana\",\n+                        hint: ~\"VAL\",\n+                        desc: ~\"some bananas\",\n+                        hasarg: Yes,\n+                        occur: Req }\n+    }\n+\n+    #[test]\n+    fn test_groups_optopt() {\n+        let opt = groups::optopt(~\"a\", ~\"apple\", ~\"some apples\", ~\"VAL\");\n+        assert opt == { short_name: ~\"a\",\n+                        long_name: ~\"apple\",\n+                        hint: ~\"VAL\",\n+                        desc: ~\"some apples\",\n+                        hasarg: Yes,\n+                        occur: Optional }\n+    }\n+\n+    #[test]\n+    fn test_groups_optflag() {\n+        let opt = groups::optflag(~\"k\", ~\"kiwi\", ~\"some kiwis\");\n+        assert opt == { short_name: ~\"k\",\n+                        long_name: ~\"kiwi\",\n+                        hint: ~\"\",\n+                        desc: ~\"some kiwis\",\n+                        hasarg: No,\n+                        occur: Optional }\n+    }\n+\n+    #[test]\n+    fn test_groups_optflagopt() {\n+        let opt = groups::optflagopt(~\"p\", ~\"pineapple\",\n+                                       ~\"some pineapples\", ~\"VAL\");\n+        assert opt == { short_name: ~\"p\",\n+                        long_name: ~\"pineapple\",\n+                        hint: ~\"VAL\",\n+                        desc: ~\"some pineapples\",\n+                        hasarg: Maybe,\n+                        occur: Optional }\n+    }\n+\n+    #[test]\n+    fn test_groups_optmulti() {\n+        let opt = groups::optmulti(~\"l\", ~\"lime\",\n+                                     ~\"some limes\", ~\"VAL\");\n+        assert opt == { short_name: ~\"l\",\n+                        long_name: ~\"lime\",\n+                        hint: ~\"VAL\",\n+                        desc: ~\"some limes\",\n+                        hasarg: Yes,\n+                        occur: Multi }\n+    }\n+\n+    #[test]\n+    fn test_groups_long_to_short() {\n+        let short = ~[reqopt(~\"b\"), reqopt(~\"banana\")];\n+        let verbose = groups::reqopt(~\"b\", ~\"banana\",\n+                                       ~\"some bananas\", ~\"VAL\");\n+\n+        assert groups::long_to_short(&verbose) == short;\n+    }\n+\n+    #[test]\n+    fn test_groups_getopts() {\n+        let short = ~[\n+            reqopt(~\"b\"), reqopt(~\"banana\"),\n+            optopt(~\"a\"), optopt(~\"apple\"),\n+            optflag(~\"k\"), optflagopt(~\"kiwi\"),\n+            optflagopt(~\"p\"),\n+            optmulti(~\"l\")\n+        ];\n+\n+        let verbose = ~[\n+            groups::reqopt(~\"b\", ~\"banana\", ~\"Desc\", ~\"VAL\"),\n+            groups::optopt(~\"a\", ~\"apple\", ~\"Desc\", ~\"VAL\"),\n+            groups::optflag(~\"k\", ~\"kiwi\", ~\"Desc\"),\n+            groups::optflagopt(~\"p\", ~\"\", ~\"Desc\", ~\"VAL\"),\n+            groups::optmulti(~\"l\", ~\"\", ~\"Desc\", ~\"VAL\"),\n+        ];\n+\n+        let sample_args = ~[~\"-k\", ~\"15\", ~\"--apple\", ~\"1\", ~\"k\",\n+                            ~\"-p\", ~\"16\", ~\"l\", ~\"35\"];\n+\n+        // NOTE: we should sort before comparing\n+        assert getopts(sample_args, short)\n+            == groups::getopts(sample_args, verbose);\n+    }\n+\n+    #[test]\n+    fn test_groups_usage() {\n+        let optgroups = ~[\n+            groups::reqopt(~\"b\", ~\"banana\", ~\"Desc\", ~\"VAL\"),\n+            groups::optopt(~\"a\", ~\"012345678901234567890123456789\",\n+                             ~\"Desc\", ~\"VAL\"),\n+            groups::optflag(~\"k\", ~\"kiwi\", ~\"Desc\"),\n+            groups::optflagopt(~\"p\", ~\"\", ~\"Desc\", ~\"VAL\"),\n+            groups::optmulti(~\"l\", ~\"\", ~\"Desc\", ~\"VAL\"),\n+        ];\n+\n+        let expected =\n+~\"Usage: fruits\n+\n+Options:\n+    -b --banana VAL     Desc\n+    -a --012345678901234567890123456789 VAL\n+                        Desc\n+    -k --kiwi           Desc\n+    -p [VAL]            Desc\n+    -l VAL              Desc\n+\n+\";\n+\n+        let generated_usage = groups::usage(~\"Usage: fruits\", optgroups);\n+\n+        debug!(\"expected: <<%s>>\", expected);\n+        debug!(\"generated: <<%s>>\", generated_usage);\n+        assert generated_usage == expected;\n+    }\n+\n+    #[test]\n+    fn test_groups_usage_description_wrapping() {\n+        // indentation should be 24 spaces\n+        // lines wrap after 78: or rather descriptions wrap after 54\n+\n+        let optgroups = ~[\n+           groups::optflag(~\"k\", ~\"kiwi\",\n+           ~\"This is a long description which won't be wrapped..+..\"), // 54\n+           groups::optflag(~\"a\", ~\"apple\",\n+           ~\"This is a long description which _will_ be wrapped..+..\"), // 55\n+        ];\n+\n+        let expected =\n+~\"Usage: fruits\n+\n+Options:\n+    -k --kiwi           This is a long description which won't be wrapped..+..\n+    -a --apple          This is a long description which _will_ be\n+                        wrapped..+..\n+\n+\";\n+\n+        let usage = groups::usage(~\"Usage: fruits\", optgroups);\n+\n+        debug!(\"expected: <<%s>>\", expected);\n+        debug!(\"generated: <<%s>>\", usage);\n+        assert usage == expected\n+    }\n }\n \n // Local Variables:"}, {"sha": "5f64389e58329a7245c0b853dbc97c302bab145c", "filename": "src/libstd/json.rs", "status": "modified", "additions": 66, "deletions": 37, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820", "patch": "@@ -51,7 +51,7 @@ fn escape_str(s: &str) -> ~str {\n \n fn spaces(n: uint) -> ~str {\n     let mut ss = ~\"\";\n-    for n.times { str::push_str(&ss, \" \"); }\n+    for n.times { str::push_str(&mut ss, \" \"); }\n     return ss;\n }\n \n@@ -63,7 +63,7 @@ pub fn Serializer(wr: io::Writer) -> Serializer {\n     Serializer { wr: wr }\n }\n \n-pub impl Serializer: serialization2::Serializer {\n+pub impl Serializer: serialization::Serializer {\n     fn emit_nil(&self) { self.wr.write_str(\"null\") }\n \n     fn emit_uint(&self, v: uint) { self.emit_float(v as float); }\n@@ -167,7 +167,7 @@ pub fn PrettySerializer(wr: io::Writer) -> PrettySerializer {\n     PrettySerializer { wr: wr, indent: 0 }\n }\n \n-pub impl PrettySerializer: serialization2::Serializer {\n+pub impl PrettySerializer: serialization::Serializer {\n     fn emit_nil(&self) { self.wr.write_str(\"null\") }\n \n     fn emit_uint(&self, v: uint) { self.emit_float(v as float); }\n@@ -273,8 +273,36 @@ pub impl PrettySerializer: serialization2::Serializer {\n     }\n }\n \n-pub impl Json: serialization2::Serializable {\n-    fn serialize<S: serialization2::Serializer>(&self, s: &S) {\n+#[cfg(stage0)]\n+pub impl Json: serialization::Serializable {\n+    fn serialize<S: serialization::Serializer>(&self, s: &S) {\n+        match *self {\n+            Number(v) => v.serialize(s),\n+            String(ref v) => v.serialize(s),\n+            Boolean(v) => v.serialize(s),\n+            List(v) => v.serialize(s),\n+            Object(ref v) => {\n+                do s.emit_rec || {\n+                    let mut idx = 0;\n+                    for v.each |key, value| {\n+                        do s.emit_field(*key, idx) {\n+                            value.serialize(s);\n+                        }\n+                        idx += 1;\n+                    }\n+                }\n+            },\n+            Null => s.emit_nil(),\n+        }\n+    }\n+}\n+\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+pub impl<\n+    S: serialization::Serializer\n+> Json: serialization::Serializable<S> {\n+    fn serialize(&self, s: &S) {\n         match *self {\n             Number(v) => v.serialize(s),\n             String(ref v) => v.serialize(s),\n@@ -302,7 +330,8 @@ pub fn to_writer(wr: io::Writer, json: &Json) {\n }\n \n /// Serializes a json value into a string\n-pub fn to_str(json: &Json) -> ~str {\n+pub pure fn to_str(json: &Json) -> ~str unsafe {\n+    // ugh, should be safe\n     io::with_str_writer(|wr| to_writer(wr, json))\n }\n \n@@ -328,8 +357,8 @@ pub fn Parser(rdr: io::Reader) -> Parser {\n     Parser {\n         rdr: rdr,\n         ch: rdr.read_char(),\n-        line: 1u,\n-        col: 1u,\n+        line: 1,\n+        col: 1,\n     }\n }\n \n@@ -341,7 +370,7 @@ pub impl Parser {\n             self.parse_whitespace();\n             // Make sure there is no trailing characters.\n             if self.eof() {\n-                Ok(value)\n+                Ok(move value)\n             } else {\n                 self.error(~\"trailing characters\")\n             }\n@@ -546,14 +575,14 @@ priv impl Parser {\n \n             if (escape) {\n                 match self.ch {\n-                  '\"' => str::push_char(&res, '\"'),\n-                  '\\\\' => str::push_char(&res, '\\\\'),\n-                  '/' => str::push_char(&res, '/'),\n-                  'b' => str::push_char(&res, '\\x08'),\n-                  'f' => str::push_char(&res, '\\x0c'),\n-                  'n' => str::push_char(&res, '\\n'),\n-                  'r' => str::push_char(&res, '\\r'),\n-                  't' => str::push_char(&res, '\\t'),\n+                  '\"' => str::push_char(&mut res, '\"'),\n+                  '\\\\' => str::push_char(&mut res, '\\\\'),\n+                  '/' => str::push_char(&mut res, '/'),\n+                  'b' => str::push_char(&mut res, '\\x08'),\n+                  'f' => str::push_char(&mut res, '\\x0c'),\n+                  'n' => str::push_char(&mut res, '\\n'),\n+                  'r' => str::push_char(&mut res, '\\r'),\n+                  't' => str::push_char(&mut res, '\\t'),\n                   'u' => {\n                       // Parse \\u1234.\n                       let mut i = 0u;\n@@ -582,7 +611,7 @@ priv impl Parser {\n                             ~\"invalid \\\\u escape (not four digits)\");\n                       }\n \n-                      str::push_char(&res, n as char);\n+                      str::push_char(&mut res, n as char);\n                   }\n                   _ => return self.error(~\"invalid escape\")\n                 }\n@@ -594,7 +623,7 @@ priv impl Parser {\n                     self.bump();\n                     return Ok(res);\n                 }\n-                str::push_char(&res, self.ch);\n+                str::push_char(&mut res, self.ch);\n             }\n         }\n \n@@ -609,12 +638,12 @@ priv impl Parser {\n \n         if self.ch == ']' {\n             self.bump();\n-            return Ok(List(values));\n+            return Ok(List(move values));\n         }\n \n         loop {\n             match move self.parse_value() {\n-              Ok(move v) => values.push(v),\n+              Ok(move v) => values.push(move v),\n               Err(move e) => return Err(e)\n             }\n \n@@ -625,7 +654,7 @@ priv impl Parser {\n \n             match self.ch {\n               ',' => self.bump(),\n-              ']' => { self.bump(); return Ok(List(values)); }\n+              ']' => { self.bump(); return Ok(List(move values)); }\n               _ => return self.error(~\"expected `,` or `]`\")\n             }\n         };\n@@ -639,7 +668,7 @@ priv impl Parser {\n \n         if self.ch == '}' {\n           self.bump();\n-          return Ok(Object(values));\n+          return Ok(Object(move values));\n         }\n \n         while !self.eof() {\n@@ -663,14 +692,14 @@ priv impl Parser {\n             self.bump();\n \n             match move self.parse_value() {\n-              Ok(move value) => { values.insert(key, value); }\n+              Ok(move value) => { values.insert(key, move value); }\n               Err(move e) => return Err(e)\n             }\n             self.parse_whitespace();\n \n             match self.ch {\n               ',' => self.bump(),\n-              '}' => { self.bump(); return Ok(Object(values)); }\n+              '}' => { self.bump(); return Ok(Object(move values)); }\n               _ => {\n                   if self.eof() { break; }\n                   return self.error(~\"expected `,` or `}`\");\n@@ -702,7 +731,7 @@ pub struct Deserializer {\n pub fn Deserializer(rdr: io::Reader) -> Result<Deserializer, Error> {\n     match move from_reader(rdr) {\n         Ok(move json) => {\n-            let des = Deserializer { json: json, stack: ~[] };\n+            let des = Deserializer { json: move json, stack: ~[] };\n             Ok(move des)\n         }\n         Err(move e) => Err(e)\n@@ -721,7 +750,7 @@ priv impl Deserializer {\n     }\n }\n \n-pub impl Deserializer: serialization2::Deserializer {\n+pub impl Deserializer: serialization::Deserializer {\n     fn read_nil(&self) -> () {\n         debug!(\"read_nil\");\n         match *self.pop() {\n@@ -818,7 +847,7 @@ pub impl Deserializer: serialization2::Deserializer {\n         };\n         let res = f(len);\n         self.pop();\n-        res\n+        move res\n     }\n \n     fn read_managed_vec<T>(&self, f: fn(uint) -> T) -> T {\n@@ -829,7 +858,7 @@ pub impl Deserializer: serialization2::Deserializer {\n         };\n         let res = f(len);\n         self.pop();\n-        res\n+        move res\n     }\n \n     fn read_vec_elt<T>(&self, idx: uint, f: fn() -> T) -> T {\n@@ -850,14 +879,14 @@ pub impl Deserializer: serialization2::Deserializer {\n         debug!(\"read_rec()\");\n         let value = f();\n         self.pop();\n-        value\n+        move value\n     }\n \n     fn read_struct<T>(&self, _name: &str, f: fn() -> T) -> T {\n         debug!(\"read_struct()\");\n         let value = f();\n         self.pop();\n-        value\n+        move value\n     }\n \n     fn read_field<T>(&self, name: &str, idx: uint, f: fn() -> T) -> T {\n@@ -868,7 +897,7 @@ pub impl Deserializer: serialization2::Deserializer {\n                 // FIXME(#3148) This hint should not be necessary.\n                 let obj: &self/~Object = obj;\n \n-                match obj.find_ref(&name.to_unique()) {\n+                match obj.find_ref(&name.to_owned()) {\n                     None => fail fmt!(\"no such field: %s\", name),\n                     Some(json) => {\n                         self.stack.push(json);\n@@ -890,7 +919,7 @@ pub impl Deserializer: serialization2::Deserializer {\n         debug!(\"read_tup(len=%u)\", len);\n         let value = f();\n         self.pop();\n-        value\n+        move value\n     }\n \n     fn read_tup_elt<T>(&self, idx: uint, f: fn() -> T) -> T {\n@@ -1166,11 +1195,11 @@ impl <A: ToJson> Option<A>: ToJson {\n }\n \n impl Json: to_str::ToStr {\n-    fn to_str() -> ~str { to_str(&self) }\n+    pure fn to_str() -> ~str { to_str(&self) }\n }\n \n impl Error: to_str::ToStr {\n-    fn to_str() -> ~str {\n+    pure fn to_str() -> ~str {\n         fmt!(\"%u:%u: %s\", self.line, self.col, *self.msg)\n     }\n }\n@@ -1182,11 +1211,11 @@ mod tests {\n \n         for items.each |item| {\n             match *item {\n-                (copy key, copy value) => { d.insert(key, value); },\n+                (copy key, copy value) => { d.insert(key, move value); },\n             }\n         };\n \n-        Object(d)\n+        Object(move d)\n     }\n \n     #[test]"}, {"sha": "e49f1abd02b4d599cd04a72260df938aa705cc6f", "filename": "src/libstd/map.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibstd%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibstd%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmap.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820", "patch": "@@ -341,7 +341,8 @@ pub mod chained {\n             wr.write_str(~\" }\");\n         }\n \n-        fn to_str() -> ~str {\n+        pure fn to_str() -> ~str unsafe {\n+            // Meh -- this should be safe\n             do io::with_str_writer |wr| { self.to_writer(wr) }\n         }\n     }\n@@ -722,7 +723,7 @@ mod tests {\n         let map = map::HashMap::<~str, ~str>();\n         assert (option::is_none(&map.find(key)));\n         map.insert(key, ~\"val\");\n-        assert (option::get(&map.find(key)) == ~\"val\");\n+        assert (option::get(map.find(key)) == ~\"val\");\n     }\n \n     #[test]"}, {"sha": "5d78fb19bab390d11488ca51bc1cf114c02c5d84", "filename": "src/libstd/net_ip.rs", "status": "modified", "additions": 25, "deletions": 6, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibstd%2Fnet_ip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibstd%2Fnet_ip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_ip.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820", "patch": "@@ -10,8 +10,10 @@ use addrinfo = uv::ll::addrinfo;\n use uv_getaddrinfo_t = uv::ll::uv_getaddrinfo_t;\n use uv_ip4_addr = uv::ll::ip4_addr;\n use uv_ip4_name = uv::ll::ip4_name;\n+use uv_ip4_port = uv::ll::ip4_port;\n use uv_ip6_addr = uv::ll::ip6_addr;\n use uv_ip6_name = uv::ll::ip6_name;\n+use uv_ip6_port = uv::ll::ip6_port;\n use uv_getaddrinfo = uv::ll::getaddrinfo;\n use uv_freeaddrinfo = uv::ll::freeaddrinfo;\n use create_uv_getaddrinfo_t = uv::ll::getaddrinfo_t;\n@@ -33,11 +35,11 @@ type ParseAddrErr = {\n };\n \n /**\n- * Convert a `ip_addr` to a str\n+ * Convert a `IpAddr` to a str\n  *\n  * # Arguments\n  *\n- * * ip - a `std::net::ip::ip_addr`\n+ * * ip - a `std::net::ip::IpAddr`\n  */\n pub fn format_addr(ip: &IpAddr) -> ~str {\n     match *ip {\n@@ -58,6 +60,23 @@ pub fn format_addr(ip: &IpAddr) -> ~str {\n     }\n }\n \n+/**\n+ * Get the associated port\n+ *\n+ * # Arguments\n+ * * ip - a `std::net::ip::IpAddr`\n+ */\n+pub fn get_port(ip: &IpAddr) -> uint {\n+    match *ip {\n+        Ipv4(ref addr) => unsafe {\n+            uv_ip4_port(addr)\n+        },\n+        Ipv6(ref addr) => unsafe {\n+            uv_ip6_port(addr)\n+        }\n+    }\n+}\n+\n /// Represents errors returned from `net::ip::get_addr()`\n enum IpGetAddrErr {\n     GetAddrUnknownError\n@@ -128,7 +147,7 @@ pub mod v4 {\n      */\n     pub fn parse_addr(ip: &str) -> IpAddr {\n         match try_parse_addr(ip) {\n-          result::Ok(copy addr) => addr,\n+          result::Ok(move addr) => move addr,\n           result::Err(ref err_data) => fail err_data.err_msg\n         }\n     }\n@@ -214,7 +233,7 @@ pub mod v6 {\n      */\n     pub fn parse_addr(ip: &str) -> IpAddr {\n         match try_parse_addr(ip) {\n-          result::Ok(copy addr) => addr,\n+          result::Ok(move addr) => move addr,\n           result::Err(copy err_data) => fail err_data.err_msg\n         }\n     }\n@@ -353,7 +372,7 @@ mod test {\n         }\n         // note really sure how to realiably test/assert\n         // this.. mostly just wanting to see it work, atm.\n-        let results = result::unwrap(ga_result);\n+        let results = result::unwrap(move ga_result);\n         log(debug, fmt!(\"test_get_addr: Number of results for %s: %?\",\n                         localhost_name, vec::len(results)));\n         for vec::each(results) |r| {\n@@ -366,7 +385,7 @@ mod test {\n         }\n         // at least one result.. this is going to vary from system\n         // to system, based on stuff like the contents of /etc/hosts\n-        assert vec::len(results) > 0;\n+        assert !results.is_empty();\n     }\n     #[test]\n     #[ignore(reason = \"valgrind says it's leaky\")]"}, {"sha": "942d52a3ad6b7b3887ab951ce3ea84752e006360", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 90, "deletions": 6, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820", "patch": "@@ -6,9 +6,7 @@ use ip = net_ip;\n use uv::iotask;\n use uv::iotask::IoTask;\n use future_spawn = future::spawn;\n-// FIXME #1935\n-// should be able to, but can't atm, replace w/ result::{result, extensions};\n-use result::*;\n+use result::{Result};\n use libc::size_t;\n use io::{Reader, ReaderUtil, Writer};\n use comm = core::comm;\n@@ -136,6 +134,10 @@ pub fn connect(input_ip: ip::IpAddr, port: uint,\n         stream_handle_ptr: stream_handle_ptr,\n         connect_req: uv::ll::connect_t(),\n         write_req: uv::ll::write_t(),\n+        ipv6: match input_ip {\n+            ip::Ipv4(_) => { false }\n+            ip::Ipv6(_) => { true }\n+        },\n         iotask: iotask\n     };\n     let socket_data_ptr = ptr::addr_of(&(*socket_data));\n@@ -477,6 +479,7 @@ pub fn accept(new_conn: TcpNewConnection)\n             stream_handle_ptr : stream_handle_ptr,\n             connect_req : uv::ll::connect_t(),\n             write_req : uv::ll::write_t(),\n+            ipv6: (*server_data_ptr).ipv6,\n             iotask : iotask\n         };\n         let client_socket_data_ptr = ptr::addr_of(&(*client_socket_data));\n@@ -564,7 +567,8 @@ pub fn listen(host_ip: ip::IpAddr, port: uint, backlog: uint,\n           new_connect_cb: fn~(TcpNewConnection,\n                                comm::Chan<Option<TcpErrData>>))\n     -> result::Result<(), TcpListenErrData> unsafe {\n-    do listen_common(move host_ip, port, backlog, iotask, on_establish_cb)\n+    do listen_common(move host_ip, port, backlog, iotask,\n+                     move on_establish_cb)\n         // on_connect_cb\n         |move new_connect_cb, handle| unsafe {\n             let server_data_ptr = uv::ll::get_data_for_uv_handle(handle)\n@@ -591,6 +595,10 @@ fn listen_common(host_ip: ip::IpAddr, port: uint, backlog: uint,\n         kill_ch: kill_ch,\n         on_connect_cb: move on_connect_cb,\n         iotask: iotask,\n+        ipv6: match host_ip {\n+            ip::Ipv4(_) => { false }\n+            ip::Ipv6(_) => { true }\n+        },\n         mut active: true\n     };\n     let server_data_ptr = ptr::addr_of(&server_data);\n@@ -747,6 +755,21 @@ impl TcpSocket {\n         -> future::Future<result::Result<(), TcpErrData>> {\n         write_future(&self, raw_write_data)\n     }\n+    pub fn get_peer_addr() -> ip::IpAddr {\n+        unsafe {\n+            if self.socket_data.ipv6 {\n+                let addr = uv::ll::ip6_addr(\"\", 0);\n+                uv::ll::tcp_getpeername6(self.socket_data.stream_handle_ptr,\n+                                         ptr::addr_of(&addr));\n+                ip::Ipv6(move addr)\n+            } else {\n+                let addr = uv::ll::ip4_addr(\"\", 0);\n+                uv::ll::tcp_getpeername(self.socket_data.stream_handle_ptr,\n+                                        ptr::addr_of(&addr));\n+                ip::Ipv4(move addr)\n+            }\n+        }\n+    }\n }\n \n /// Implementation of `io::reader` trait for a buffered `net::tcp::tcp_socket`\n@@ -1004,6 +1027,7 @@ type TcpListenFcData = {\n     kill_ch: comm::Chan<Option<TcpErrData>>,\n     on_connect_cb: fn~(*uv::ll::uv_tcp_t),\n     iotask: IoTask,\n+    ipv6: bool,\n     mut active: bool\n };\n \n@@ -1093,7 +1117,7 @@ extern fn on_tcp_read_cb(stream: *uv::ll::uv_stream_t,\n         log(debug, fmt!(\"tcp on_read_cb nread: %d\", nread as int));\n         let reader_ch = (*socket_data_ptr).reader_ch;\n         let buf_base = uv::ll::get_base_from_buf(buf);\n-        let new_bytes = vec::raw::from_buf(buf_base, nread as uint);\n+        let new_bytes = vec::from_buf(buf_base, nread as uint);\n         core::comm::send(reader_ch, result::Ok(new_bytes));\n       }\n     }\n@@ -1202,6 +1226,7 @@ type TcpSocketData = {\n     stream_handle_ptr: *uv::ll::uv_tcp_t,\n     connect_req: uv::ll::uv_connect_t,\n     write_req: uv::ll::uv_write_t,\n+    ipv6: bool,\n     iotask: IoTask\n };\n \n@@ -1224,6 +1249,10 @@ mod test {\n                 impl_gl_tcp_ipv4_server_and_client();\n             }\n             #[test]\n+            fn test_gl_tcp_get_peer_addr() unsafe {\n+                impl_gl_tcp_ipv4_get_peer_addr();\n+            }\n+            #[test]\n             fn test_gl_tcp_ipv4_client_error_connection_refused() unsafe {\n                 impl_gl_tcp_ipv4_client_error_connection_refused();\n             }\n@@ -1250,6 +1279,11 @@ mod test {\n             }\n             #[test]\n             #[ignore(cfg(target_os = \"linux\"))]\n+            fn test_gl_tcp_get_peer_addr() unsafe {\n+                impl_gl_tcp_ipv4_get_peer_addr();\n+            }\n+            #[test]\n+            #[ignore(cfg(target_os = \"linux\"))]\n             fn test_gl_tcp_ipv4_client_error_connection_refused() unsafe {\n                 impl_gl_tcp_ipv4_client_error_connection_refused();\n             }\n@@ -1317,6 +1351,53 @@ mod test {\n         assert str::contains(actual_req, expected_req);\n         assert str::contains(actual_resp, expected_resp);\n     }\n+    fn impl_gl_tcp_ipv4_get_peer_addr() {\n+        let hl_loop = uv::global_loop::get();\n+        let server_ip = ~\"127.0.0.1\";\n+        let server_port = 8887u;\n+        let expected_resp = ~\"pong\";\n+\n+        let server_result_po = core::comm::Port::<~str>();\n+        let server_result_ch = core::comm::Chan(&server_result_po);\n+\n+        let cont_po = core::comm::Port::<()>();\n+        let cont_ch = core::comm::Chan(&cont_po);\n+        // server\n+        do task::spawn_sched(task::ManualThreads(1u)) {\n+            let actual_req = do comm::listen |server_ch| {\n+                run_tcp_test_server(\n+                    server_ip,\n+                    server_port,\n+                    expected_resp,\n+                    server_ch,\n+                    cont_ch,\n+                    hl_loop)\n+            };\n+            server_result_ch.send(actual_req);\n+        };\n+        core::comm::recv(cont_po);\n+        // client\n+        log(debug, ~\"server started, firing up client..\");\n+        do core::comm::listen |client_ch| {\n+            let server_ip_addr = ip::v4::parse_addr(server_ip);\n+            let iotask = uv::global_loop::get();\n+            let connect_result = connect(move server_ip_addr, server_port,\n+                                         iotask);\n+\n+            let sock = result::unwrap(move connect_result);\n+\n+            // This is what we are actually testing!\n+            assert net::ip::format_addr(&sock.get_peer_addr()) ==\n+                ~\"127.0.0.1\";\n+            assert net::ip::get_port(&sock.get_peer_addr()) == 8887;\n+\n+            // Fulfill the protocol the test server expects\n+            let resp_bytes = str::to_bytes(~\"ping\");\n+            tcp_write_single(&sock, resp_bytes);\n+            let read_result = sock.read(0u);\n+            client_ch.send(str::from_bytes(read_result.get()));\n+        };\n+    }\n     fn impl_gl_tcp_ipv4_client_error_connection_refused() {\n         let hl_loop = uv::global_loop::get();\n         let server_ip = ~\"127.0.0.1\";\n@@ -1512,8 +1593,11 @@ mod test {\n                             ~\"SERVER/WORKER: send on cont ch\");\n                         cont_ch.send(());\n                         let sock = result::unwrap(move accept_result);\n+                        let peer_addr = sock.get_peer_addr();\n                         log(debug, ~\"SERVER: successfully accepted\"+\n-                            ~\"connection!\");\n+                            fmt!(\" connection from %s:%u\",\n+                                 ip::format_addr(&peer_addr),\n+                                 ip::get_port(&peer_addr)));\n                         let received_req_bytes = read(&sock, 0u);\n                         match move received_req_bytes {\n                           result::Ok(move data) => {"}, {"sha": "8ea9513d15518eac5f407f101e012526f4f85a71", "filename": "src/libstd/net_url.rs", "status": "modified", "additions": 19, "deletions": 13, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibstd%2Fnet_url.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibstd%2Fnet_url.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_url.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820", "patch": "@@ -65,10 +65,10 @@ fn encode_inner(s: &str, full_url: bool) -> ~str {\n                         str::push_char(&mut out, ch);\n                       }\n \n-                      _ => out += #fmt(\"%%%X\", ch as uint)\n+                      _ => out += fmt!(\"%%%X\", ch as uint)\n                     }\n                 } else {\n-                    out += #fmt(\"%%%X\", ch as uint);\n+                    out += fmt!(\"%%%X\", ch as uint);\n                 }\n               }\n             }\n@@ -94,6 +94,7 @@ pub fn encode(s: &str) -> ~str {\n  *\n  * This function is compliant with RFC 3986.\n  */\n+\n pub fn encode_component(s: &str) -> ~str {\n     encode_inner(s, false)\n }\n@@ -163,7 +164,7 @@ fn encode_plus(s: &str) -> ~str {\n                 str::push_char(&mut out, ch);\n               }\n               ' ' => str::push_char(&mut out, '+'),\n-              _ => out += #fmt(\"%%%X\", ch as uint)\n+              _ => out += fmt!(\"%%%X\", ch as uint)\n             }\n         }\n \n@@ -189,7 +190,7 @@ pub fn encode_form_urlencoded(m: HashMap<~str, @DVec<@~str>>) -> ~str {\n                 first = false;\n             }\n \n-            out += #fmt(\"%s=%s\", key, encode_plus(**value));\n+            out += fmt!(\"%s=%s\", key, encode_plus(**value));\n         }\n     }\n \n@@ -297,7 +298,7 @@ fn userinfo_from_str(uinfo: &str) -> UserInfo {\n     return UserInfo(user, pass);\n }\n \n-fn userinfo_to_str(userinfo: UserInfo) -> ~str {\n+pure fn userinfo_to_str(userinfo: UserInfo) -> ~str {\n     if option::is_some(&userinfo.pass) {\n         return str::concat(~[copy userinfo.user, ~\":\",\n                           option::unwrap(copy userinfo.pass),\n@@ -325,11 +326,15 @@ fn query_from_str(rawquery: &str) -> Query {\n     return query;\n }\n \n-pub fn query_to_str(query: Query) -> ~str {\n+pub pure fn query_to_str(query: Query) -> ~str {\n     let mut strvec = ~[];\n     for query.each |kv| {\n         let (k, v) = copy *kv;\n-        strvec += ~[#fmt(\"%s=%s\", encode_component(k), encode_component(v))];\n+        // This is really safe...\n+        unsafe {\n+          strvec += ~[fmt!(\"%s=%s\",\n+                           encode_component(k), encode_component(v))];\n+        }\n     };\n     return str::connect(strvec, ~\"&\");\n }\n@@ -672,7 +677,7 @@ impl Url : FromStr {\n  * result in just \"http://somehost.com\".\n  *\n  */\n-pub fn to_str(url: Url) -> ~str {\n+pub pure fn to_str(url: Url) -> ~str {\n     let user = if url.user.is_some() {\n       userinfo_to_str(option::unwrap(copy url.user))\n     } else {\n@@ -688,7 +693,8 @@ pub fn to_str(url: Url) -> ~str {\n     } else {\n         str::concat(~[~\"?\", query_to_str(url.query)])\n     };\n-    let fragment = if url.fragment.is_some() {\n+    // ugh, this really is safe\n+    let fragment = if url.fragment.is_some() unsafe {\n         str::concat(~[~\"#\", encode_component(\n             option::unwrap(copy url.fragment))])\n     } else {\n@@ -704,7 +710,7 @@ pub fn to_str(url: Url) -> ~str {\n }\n \n impl Url: to_str::ToStr {\n-    pub fn to_str() -> ~str {\n+    pub pure fn to_str() -> ~str {\n         to_str(self)\n     }\n }\n@@ -844,7 +850,7 @@ mod tests {\n     fn test_url_parse_host_slash() {\n         let urlstr = ~\"http://0.42.42.42/\";\n         let url = from_str(urlstr).get();\n-        #debug(\"url: %?\", url);\n+        debug!(\"url: %?\", url);\n         assert url.host == ~\"0.42.42.42\";\n         assert url.path == ~\"/\";\n     }\n@@ -853,15 +859,15 @@ mod tests {\n     fn test_url_with_underscores() {\n         let urlstr = ~\"http://dotcom.com/file_name.html\";\n         let url = from_str(urlstr).get();\n-        #debug(\"url: %?\", url);\n+        debug!(\"url: %?\", url);\n         assert url.path == ~\"/file_name.html\";\n     }\n \n     #[test]\n     fn test_url_with_dashes() {\n         let urlstr = ~\"http://dotcom.com/file-name.html\";\n         let url = from_str(urlstr).get();\n-        #debug(\"url: %?\", url);\n+        debug!(\"url: %?\", url);\n         assert url.path == ~\"/file-name.html\";\n     }\n "}, {"sha": "6119c03cdcaf0dd4c30f44d1018feea7e4e58732", "filename": "src/libstd/prettyprint.rs", "status": "modified", "additions": 106, "deletions": 62, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibstd%2Fprettyprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibstd%2Fprettyprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprettyprint.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820", "patch": "@@ -2,131 +2,175 @@\n \n use io::Writer;\n use io::WriterUtil;\n-use serialization::Serializer;\n+use serialization;\n \n-impl Writer: Serializer {\n-    fn emit_nil() {\n-        self.write_str(~\"()\")\n+pub struct Serializer {\n+    wr: io::Writer,\n+}\n+\n+pub fn Serializer(wr: io::Writer) -> Serializer {\n+    Serializer { wr: wr }\n+}\n+\n+pub impl Serializer: serialization::Serializer {\n+    fn emit_nil(&self) {\n+        self.wr.write_str(~\"()\")\n+    }\n+\n+    fn emit_uint(&self, v: uint) {\n+        self.wr.write_str(fmt!(\"%?u\", v));\n+    }\n+\n+    fn emit_u64(&self, v: u64) {\n+        self.wr.write_str(fmt!(\"%?_u64\", v));\n+    }\n+\n+    fn emit_u32(&self, v: u32) {\n+        self.wr.write_str(fmt!(\"%?_u32\", v));\n+    }\n+\n+    fn emit_u16(&self, v: u16) {\n+        self.wr.write_str(fmt!(\"%?_u16\", v));\n+    }\n+\n+    fn emit_u8(&self, v: u8) {\n+        self.wr.write_str(fmt!(\"%?_u8\", v));\n     }\n \n-    fn emit_uint(v: uint) {\n-        self.write_str(fmt!(\"%?u\", v));\n+    fn emit_int(&self, v: int) {\n+        self.wr.write_str(fmt!(\"%?\", v));\n     }\n \n-    fn emit_u64(v: u64) {\n-        self.write_str(fmt!(\"%?_u64\", v));\n+    fn emit_i64(&self, v: i64) {\n+        self.wr.write_str(fmt!(\"%?_i64\", v));\n     }\n \n-    fn emit_u32(v: u32) {\n-        self.write_str(fmt!(\"%?_u32\", v));\n+    fn emit_i32(&self, v: i32) {\n+        self.wr.write_str(fmt!(\"%?_i32\", v));\n     }\n \n-    fn emit_u16(v: u16) {\n-        self.write_str(fmt!(\"%?_u16\", v));\n+    fn emit_i16(&self, v: i16) {\n+        self.wr.write_str(fmt!(\"%?_i16\", v));\n     }\n \n-    fn emit_u8(v: u8) {\n-        self.write_str(fmt!(\"%?_u8\", v));\n+    fn emit_i8(&self, v: i8) {\n+        self.wr.write_str(fmt!(\"%?_i8\", v));\n     }\n \n-    fn emit_int(v: int) {\n-        self.write_str(fmt!(\"%?\", v));\n+    fn emit_bool(&self, v: bool) {\n+        self.wr.write_str(fmt!(\"%b\", v));\n     }\n \n-    fn emit_i64(v: i64) {\n-        self.write_str(fmt!(\"%?_i64\", v));\n+    fn emit_float(&self, v: float) {\n+        self.wr.write_str(fmt!(\"%?_f\", v));\n     }\n \n-    fn emit_i32(v: i32) {\n-        self.write_str(fmt!(\"%?_i32\", v));\n+    fn emit_f64(&self, v: f64) {\n+        self.wr.write_str(fmt!(\"%?_f64\", v));\n     }\n \n-    fn emit_i16(v: i16) {\n-        self.write_str(fmt!(\"%?_i16\", v));\n+    fn emit_f32(&self, v: f32) {\n+        self.wr.write_str(fmt!(\"%?_f32\", v));\n     }\n \n-    fn emit_i8(v: i8) {\n-        self.write_str(fmt!(\"%?_i8\", v));\n+    fn emit_char(&self, v: char) {\n+        self.wr.write_str(fmt!(\"%?\", v));\n     }\n \n-    fn emit_bool(v: bool) {\n-        self.write_str(fmt!(\"%b\", v));\n+    fn emit_borrowed_str(&self, v: &str) {\n+        self.wr.write_str(fmt!(\"&%?\", v));\n     }\n \n-    fn emit_float(v: float) {\n-        self.write_str(fmt!(\"%?_f\", v));\n+    fn emit_owned_str(&self, v: &str) {\n+        self.wr.write_str(fmt!(\"~%?\", v));\n     }\n \n-    fn emit_f64(v: f64) {\n-        self.write_str(fmt!(\"%?_f64\", v));\n+    fn emit_managed_str(&self, v: &str) {\n+        self.wr.write_str(fmt!(\"@%?\", v));\n     }\n \n-    fn emit_f32(v: f32) {\n-        self.write_str(fmt!(\"%?_f32\", v));\n+    fn emit_borrowed(&self, f: fn()) {\n+        self.wr.write_str(~\"&\");\n+        f();\n     }\n \n-    fn emit_str(v: &str) {\n-        self.write_str(fmt!(\"%?\", v));\n+    fn emit_owned(&self, f: fn()) {\n+        self.wr.write_str(~\"~\");\n+        f();\n+    }\n+\n+    fn emit_managed(&self, f: fn()) {\n+        self.wr.write_str(~\"@\");\n+        f();\n+    }\n+\n+    fn emit_enum(&self, _name: &str, f: fn()) {\n+        f();\n     }\n \n-    fn emit_enum(_name: &str, f: fn()) {\n+    fn emit_enum_variant(&self, v_name: &str, _v_id: uint, sz: uint,\n+                         f: fn()) {\n+        self.wr.write_str(v_name);\n+        if sz > 0u { self.wr.write_str(~\"(\"); }\n         f();\n+        if sz > 0u { self.wr.write_str(~\")\"); }\n     }\n \n-    fn emit_enum_variant(v_name: &str, _v_id: uint, sz: uint, f: fn()) {\n-        self.write_str(v_name);\n-        if sz > 0u { self.write_str(~\"(\"); }\n+    fn emit_enum_variant_arg(&self, idx: uint, f: fn()) {\n+        if idx > 0u { self.wr.write_str(~\", \"); }\n         f();\n-        if sz > 0u { self.write_str(~\")\"); }\n     }\n \n-    fn emit_enum_variant_arg(idx: uint, f: fn()) {\n-        if idx > 0u { self.write_str(~\", \"); }\n+    fn emit_borrowed_vec(&self, _len: uint, f: fn()) {\n+        self.wr.write_str(~\"&[\");\n         f();\n+        self.wr.write_str(~\"]\");\n     }\n \n-    fn emit_vec(_len: uint, f: fn()) {\n-        self.write_str(~\"[\");\n+    fn emit_owned_vec(&self, _len: uint, f: fn()) {\n+        self.wr.write_str(~\"~[\");\n         f();\n-        self.write_str(~\"]\");\n+        self.wr.write_str(~\"]\");\n     }\n \n-    fn emit_vec_elt(idx: uint, f: fn()) {\n-        if idx > 0u { self.write_str(~\", \"); }\n+    fn emit_managed_vec(&self, _len: uint, f: fn()) {\n+        self.wr.write_str(~\"@[\");\n         f();\n+        self.wr.write_str(~\"]\");\n     }\n \n-    fn emit_box(f: fn()) {\n-        self.write_str(~\"@\");\n+    fn emit_vec_elt(&self, idx: uint, f: fn()) {\n+        if idx > 0u { self.wr.write_str(~\", \"); }\n         f();\n     }\n \n-    fn emit_uniq(f: fn()) {\n-        self.write_str(~\"~\");\n+    fn emit_rec(&self, f: fn()) {\n+        self.wr.write_str(~\"{\");\n         f();\n+        self.wr.write_str(~\"}\");\n     }\n \n-    fn emit_rec(f: fn()) {\n-        self.write_str(~\"{\");\n+    fn emit_struct(&self, name: &str, f: fn()) {\n+        self.wr.write_str(fmt!(\"%s {\", name));\n         f();\n-        self.write_str(~\"}\");\n+        self.wr.write_str(~\"}\");\n     }\n \n-    fn emit_rec_field(f_name: &str, f_idx: uint, f: fn()) {\n-        if f_idx > 0u { self.write_str(~\", \"); }\n-        self.write_str(f_name);\n-        self.write_str(~\": \");\n+    fn emit_field(&self, name: &str, idx: uint, f: fn()) {\n+        if idx > 0u { self.wr.write_str(~\", \"); }\n+        self.wr.write_str(name);\n+        self.wr.write_str(~\": \");\n         f();\n     }\n \n-    fn emit_tup(_sz: uint, f: fn()) {\n-        self.write_str(~\"(\");\n+    fn emit_tup(&self, _len: uint, f: fn()) {\n+        self.wr.write_str(~\"(\");\n         f();\n-        self.write_str(~\")\");\n+        self.wr.write_str(~\")\");\n     }\n \n-    fn emit_tup_elt(idx: uint, f: fn()) {\n-        if idx > 0u { self.write_str(~\", \"); }\n+    fn emit_tup_elt(&self, idx: uint, f: fn()) {\n+        if idx > 0u { self.wr.write_str(~\", \"); }\n         f();\n     }\n }"}, {"sha": "87af519eb123d98ed16b8216944806aa574d6c8d", "filename": "src/libstd/prettyprint2.rs", "status": "removed", "additions": 0, "deletions": 176, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/9aec7a3e85c5b07923eab05d3ebe9d031bf258f3/src%2Flibstd%2Fprettyprint2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aec7a3e85c5b07923eab05d3ebe9d031bf258f3/src%2Flibstd%2Fprettyprint2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprettyprint2.rs?ref=9aec7a3e85c5b07923eab05d3ebe9d031bf258f3", "patch": "@@ -1,176 +0,0 @@\n-#[forbid(deprecated_mode)];\n-\n-use io::Writer;\n-use io::WriterUtil;\n-use serialization2;\n-\n-pub struct Serializer {\n-    wr: io::Writer,\n-}\n-\n-pub fn Serializer(wr: io::Writer) -> Serializer {\n-    Serializer { wr: wr }\n-}\n-\n-pub impl Serializer: serialization2::Serializer {\n-    fn emit_nil(&self) {\n-        self.wr.write_str(~\"()\")\n-    }\n-\n-    fn emit_uint(&self, v: uint) {\n-        self.wr.write_str(fmt!(\"%?u\", v));\n-    }\n-\n-    fn emit_u64(&self, v: u64) {\n-        self.wr.write_str(fmt!(\"%?_u64\", v));\n-    }\n-\n-    fn emit_u32(&self, v: u32) {\n-        self.wr.write_str(fmt!(\"%?_u32\", v));\n-    }\n-\n-    fn emit_u16(&self, v: u16) {\n-        self.wr.write_str(fmt!(\"%?_u16\", v));\n-    }\n-\n-    fn emit_u8(&self, v: u8) {\n-        self.wr.write_str(fmt!(\"%?_u8\", v));\n-    }\n-\n-    fn emit_int(&self, v: int) {\n-        self.wr.write_str(fmt!(\"%?\", v));\n-    }\n-\n-    fn emit_i64(&self, v: i64) {\n-        self.wr.write_str(fmt!(\"%?_i64\", v));\n-    }\n-\n-    fn emit_i32(&self, v: i32) {\n-        self.wr.write_str(fmt!(\"%?_i32\", v));\n-    }\n-\n-    fn emit_i16(&self, v: i16) {\n-        self.wr.write_str(fmt!(\"%?_i16\", v));\n-    }\n-\n-    fn emit_i8(&self, v: i8) {\n-        self.wr.write_str(fmt!(\"%?_i8\", v));\n-    }\n-\n-    fn emit_bool(&self, v: bool) {\n-        self.wr.write_str(fmt!(\"%b\", v));\n-    }\n-\n-    fn emit_float(&self, v: float) {\n-        self.wr.write_str(fmt!(\"%?_f\", v));\n-    }\n-\n-    fn emit_f64(&self, v: f64) {\n-        self.wr.write_str(fmt!(\"%?_f64\", v));\n-    }\n-\n-    fn emit_f32(&self, v: f32) {\n-        self.wr.write_str(fmt!(\"%?_f32\", v));\n-    }\n-\n-    fn emit_char(&self, v: char) {\n-        self.wr.write_str(fmt!(\"%?\", v));\n-    }\n-\n-    fn emit_borrowed_str(&self, v: &str) {\n-        self.wr.write_str(fmt!(\"&%?\", v));\n-    }\n-\n-    fn emit_owned_str(&self, v: &str) {\n-        self.wr.write_str(fmt!(\"~%?\", v));\n-    }\n-\n-    fn emit_managed_str(&self, v: &str) {\n-        self.wr.write_str(fmt!(\"@%?\", v));\n-    }\n-\n-    fn emit_borrowed(&self, f: fn()) {\n-        self.wr.write_str(~\"&\");\n-        f();\n-    }\n-\n-    fn emit_owned(&self, f: fn()) {\n-        self.wr.write_str(~\"~\");\n-        f();\n-    }\n-\n-    fn emit_managed(&self, f: fn()) {\n-        self.wr.write_str(~\"@\");\n-        f();\n-    }\n-\n-    fn emit_enum(&self, _name: &str, f: fn()) {\n-        f();\n-    }\n-\n-    fn emit_enum_variant(&self, v_name: &str, _v_id: uint, sz: uint,\n-                         f: fn()) {\n-        self.wr.write_str(v_name);\n-        if sz > 0u { self.wr.write_str(~\"(\"); }\n-        f();\n-        if sz > 0u { self.wr.write_str(~\")\"); }\n-    }\n-\n-    fn emit_enum_variant_arg(&self, idx: uint, f: fn()) {\n-        if idx > 0u { self.wr.write_str(~\", \"); }\n-        f();\n-    }\n-\n-    fn emit_borrowed_vec(&self, _len: uint, f: fn()) {\n-        self.wr.write_str(~\"&[\");\n-        f();\n-        self.wr.write_str(~\"]\");\n-    }\n-\n-    fn emit_owned_vec(&self, _len: uint, f: fn()) {\n-        self.wr.write_str(~\"~[\");\n-        f();\n-        self.wr.write_str(~\"]\");\n-    }\n-\n-    fn emit_managed_vec(&self, _len: uint, f: fn()) {\n-        self.wr.write_str(~\"@[\");\n-        f();\n-        self.wr.write_str(~\"]\");\n-    }\n-\n-    fn emit_vec_elt(&self, idx: uint, f: fn()) {\n-        if idx > 0u { self.wr.write_str(~\", \"); }\n-        f();\n-    }\n-\n-    fn emit_rec(&self, f: fn()) {\n-        self.wr.write_str(~\"{\");\n-        f();\n-        self.wr.write_str(~\"}\");\n-    }\n-\n-    fn emit_struct(&self, name: &str, f: fn()) {\n-        self.wr.write_str(fmt!(\"%s {\", name));\n-        f();\n-        self.wr.write_str(~\"}\");\n-    }\n-\n-    fn emit_field(&self, name: &str, idx: uint, f: fn()) {\n-        if idx > 0u { self.wr.write_str(~\", \"); }\n-        self.wr.write_str(name);\n-        self.wr.write_str(~\": \");\n-        f();\n-    }\n-\n-    fn emit_tup(&self, _len: uint, f: fn()) {\n-        self.wr.write_str(~\"(\");\n-        f();\n-        self.wr.write_str(~\")\");\n-    }\n-\n-    fn emit_tup_elt(&self, idx: uint, f: fn()) {\n-        if idx > 0u { self.wr.write_str(~\", \"); }\n-        f();\n-    }\n-}"}, {"sha": "9df2a326a8474b52bf69eacdcc47c824a42646c4", "filename": "src/libstd/serialization.rs", "status": "modified", "additions": 933, "deletions": 154, "changes": 1087, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibstd%2Fserialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibstd%2Fserialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fserialization.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820", "patch": "@@ -1,271 +1,1050 @@\n //! Support code for serialization.\n \n-#[allow(deprecated_mode)];\n-\n /*\n Core serialization interfaces.\n */\n \n+#[forbid(deprecated_mode)];\n+#[forbid(non_camel_case_types)];\n+\n pub trait Serializer {\n     // Primitive types:\n-    fn emit_nil();\n-    fn emit_uint(v: uint);\n-    fn emit_u64(v: u64);\n-    fn emit_u32(v: u32);\n-    fn emit_u16(v: u16);\n-    fn emit_u8(v: u8);\n-    fn emit_int(v: int);\n-    fn emit_i64(v: i64);\n-    fn emit_i32(v: i32);\n-    fn emit_i16(v: i16);\n-    fn emit_i8(v: i8);\n-    fn emit_bool(v: bool);\n-    fn emit_float(v: float);\n-    fn emit_f64(v: f64);\n-    fn emit_f32(v: f32);\n-    fn emit_str(v: &str);\n+    fn emit_nil(&self);\n+    fn emit_uint(&self, v: uint);\n+    fn emit_u64(&self, v: u64);\n+    fn emit_u32(&self, v: u32);\n+    fn emit_u16(&self, v: u16);\n+    fn emit_u8(&self, v: u8);\n+    fn emit_int(&self, v: int);\n+    fn emit_i64(&self, v: i64);\n+    fn emit_i32(&self, v: i32);\n+    fn emit_i16(&self, v: i16);\n+    fn emit_i8(&self, v: i8);\n+    fn emit_bool(&self, v: bool);\n+    fn emit_float(&self, v: float);\n+    fn emit_f64(&self, v: f64);\n+    fn emit_f32(&self, v: f32);\n+    fn emit_char(&self, v: char);\n+    fn emit_borrowed_str(&self, v: &str);\n+    fn emit_owned_str(&self, v: &str);\n+    fn emit_managed_str(&self, v: &str);\n \n     // Compound types:\n-    fn emit_enum(name: &str, f: fn());\n-    fn emit_enum_variant(v_name: &str, v_id: uint, sz: uint, f: fn());\n-    fn emit_enum_variant_arg(idx: uint, f: fn());\n-    fn emit_vec(len: uint, f: fn());\n-    fn emit_vec_elt(idx: uint, f: fn());\n-    fn emit_box(f: fn());\n-    fn emit_uniq(f: fn());\n-    fn emit_rec(f: fn());\n-    fn emit_rec_field(f_name: &str, f_idx: uint, f: fn());\n-    fn emit_tup(sz: uint, f: fn());\n-    fn emit_tup_elt(idx: uint, f: fn());\n+    fn emit_borrowed(&self, f: fn());\n+    fn emit_owned(&self, f: fn());\n+    fn emit_managed(&self, f: fn());\n+\n+    fn emit_enum(&self, name: &str, f: fn());\n+    fn emit_enum_variant(&self, v_name: &str, v_id: uint, sz: uint, f: fn());\n+    fn emit_enum_variant_arg(&self, idx: uint, f: fn());\n+\n+    fn emit_borrowed_vec(&self, len: uint, f: fn());\n+    fn emit_owned_vec(&self, len: uint, f: fn());\n+    fn emit_managed_vec(&self, len: uint, f: fn());\n+    fn emit_vec_elt(&self, idx: uint, f: fn());\n+\n+    fn emit_rec(&self, f: fn());\n+    fn emit_struct(&self, name: &str, f: fn());\n+    fn emit_field(&self, f_name: &str, f_idx: uint, f: fn());\n+\n+    fn emit_tup(&self, len: uint, f: fn());\n+    fn emit_tup_elt(&self, idx: uint, f: fn());\n }\n \n pub trait Deserializer {\n     // Primitive types:\n-    fn read_nil() -> ();\n+    fn read_nil(&self) -> ();\n+    fn read_uint(&self) -> uint;\n+    fn read_u64(&self) -> u64;\n+    fn read_u32(&self) -> u32;\n+    fn read_u16(&self) -> u16;\n+    fn read_u8(&self) -> u8;\n+    fn read_int(&self) -> int;\n+    fn read_i64(&self) -> i64;\n+    fn read_i32(&self) -> i32;\n+    fn read_i16(&self) -> i16;\n+    fn read_i8(&self) -> i8;\n+    fn read_bool(&self) -> bool;\n+    fn read_f64(&self) -> f64;\n+    fn read_f32(&self) -> f32;\n+    fn read_float(&self) -> float;\n+    fn read_char(&self) -> char;\n+    fn read_owned_str(&self) -> ~str;\n+    fn read_managed_str(&self) -> @str;\n \n-    fn read_uint() -> uint;\n-    fn read_u64() -> u64;\n-    fn read_u32() -> u32;\n-    fn read_u16() -> u16;\n-    fn read_u8() -> u8;\n+    // Compound types:\n+    fn read_enum<T>(&self, name: &str, f: fn() -> T) -> T;\n+    fn read_enum_variant<T>(&self, f: fn(uint) -> T) -> T;\n+    fn read_enum_variant_arg<T>(&self, idx: uint, f: fn() -> T) -> T;\n \n-    fn read_int() -> int;\n-    fn read_i64() -> i64;\n-    fn read_i32() -> i32;\n-    fn read_i16() -> i16;\n-    fn read_i8() -> i8;\n+    fn read_owned<T>(&self, f: fn() -> T) -> T;\n+    fn read_managed<T>(&self, f: fn() -> T) -> T;\n \n+    fn read_owned_vec<T>(&self, f: fn(uint) -> T) -> T;\n+    fn read_managed_vec<T>(&self, f: fn(uint) -> T) -> T;\n+    fn read_vec_elt<T>(&self, idx: uint, f: fn() -> T) -> T;\n \n-    fn read_bool() -> bool;\n+    fn read_rec<T>(&self, f: fn() -> T) -> T;\n+    fn read_struct<T>(&self, name: &str, f: fn() -> T) -> T;\n+    fn read_field<T>(&self, name: &str, idx: uint, f: fn() -> T) -> T;\n \n-    fn read_str() -> ~str;\n+    fn read_tup<T>(&self, sz: uint, f: fn() -> T) -> T;\n+    fn read_tup_elt<T>(&self, idx: uint, f: fn() -> T) -> T;\n+}\n \n-    fn read_f64() -> f64;\n-    fn read_f32() -> f32;\n-    fn read_float() -> float;\n+#[cfg(stage0)]\n+pub mod traits {\n+pub trait Serializable {\n+    fn serialize<S: Serializer>(&self, s: &S);\n+}\n \n-    // Compound types:\n-    fn read_enum<T>(name: &str, f: fn() -> T) -> T;\n-    fn read_enum_variant<T>(f: fn(uint) -> T) -> T;\n-    fn read_enum_variant_arg<T>(idx: uint, f: fn() -> T) -> T;\n-    fn read_vec<T>(f: fn(uint) -> T) -> T;\n-    fn read_vec_elt<T>(idx: uint, f: fn() -> T) -> T;\n-    fn read_box<T>(f: fn() -> T) -> T;\n-    fn read_uniq<T>(f: fn() -> T) -> T;\n-    fn read_rec<T>(f: fn() -> T) -> T;\n-    fn read_rec_field<T>(f_name: &str, f_idx: uint, f: fn() -> T) -> T;\n-    fn read_tup<T>(sz: uint, f: fn() -> T) -> T;\n-    fn read_tup_elt<T>(idx: uint, f: fn() -> T) -> T;\n+pub trait Deserializable {\n+    static fn deserialize<D: Deserializer>(&self, d: &D) -> self;\n+}\n+\n+pub impl uint: Serializable {\n+    fn serialize<S: Serializer>(&self, s: &S) { s.emit_uint(*self) }\n+}\n+\n+pub impl uint: Deserializable {\n+    static fn deserialize<D: Deserializer>(&self, d: &D) -> uint {\n+        d.read_uint()\n+    }\n+}\n+\n+pub impl u8: Serializable {\n+    fn serialize<S: Serializer>(&self, s: &S) { s.emit_u8(*self) }\n+}\n+\n+pub impl u8: Deserializable {\n+    static fn deserialize<D: Deserializer>(&self, d: &D) -> u8 {\n+        d.read_u8()\n+    }\n+}\n+\n+pub impl u16: Serializable {\n+    fn serialize<S: Serializer>(&self, s: &S) { s.emit_u16(*self) }\n+}\n+\n+pub impl u16: Deserializable {\n+    static fn deserialize<D: Deserializer>(&self, d: &D) -> u16 {\n+        d.read_u16()\n+    }\n+}\n+\n+pub impl u32: Serializable {\n+    fn serialize<S: Serializer>(&self, s: &S) { s.emit_u32(*self) }\n+}\n+\n+pub impl u32: Deserializable {\n+    static fn deserialize<D: Deserializer>(&self, d: &D) -> u32 {\n+        d.read_u32()\n+    }\n+}\n+\n+pub impl u64: Serializable {\n+    fn serialize<S: Serializer>(&self, s: &S) { s.emit_u64(*self) }\n+}\n+\n+pub impl u64: Deserializable {\n+    static fn deserialize<D: Deserializer>(&self, d: &D) -> u64 {\n+        d.read_u64()\n+    }\n+}\n+\n+pub impl int: Serializable {\n+    fn serialize<S: Serializer>(&self, s: &S) { s.emit_int(*self) }\n+}\n+\n+pub impl int: Deserializable {\n+    static fn deserialize<D: Deserializer>(&self, d: &D) -> int {\n+        d.read_int()\n+    }\n+}\n+\n+pub impl i8: Serializable {\n+    fn serialize<S: Serializer>(&self, s: &S) { s.emit_i8(*self) }\n+}\n+\n+pub impl i8: Deserializable {\n+    static fn deserialize<D: Deserializer>(&self, d: &D) -> i8 {\n+        d.read_i8()\n+    }\n+}\n+\n+pub impl i16: Serializable {\n+    fn serialize<S: Serializer>(&self, s: &S) { s.emit_i16(*self) }\n+}\n+\n+pub impl i16: Deserializable {\n+    static fn deserialize<D: Deserializer>(&self, d: &D) -> i16 {\n+        d.read_i16()\n+    }\n+}\n+\n+pub impl i32: Serializable {\n+    fn serialize<S: Serializer>(&self, s: &S) { s.emit_i32(*self) }\n+}\n+\n+pub impl i32: Deserializable {\n+    static fn deserialize<D: Deserializer>(&self, d: &D) -> i32 {\n+        d.read_i32()\n+    }\n+}\n+\n+pub impl i64: Serializable {\n+    fn serialize<S: Serializer>(&self, s: &S) { s.emit_i64(*self) }\n+}\n+\n+pub impl i64: Deserializable {\n+    static fn deserialize<D: Deserializer>(&self, d: &D) -> i64 {\n+        d.read_i64()\n+    }\n+}\n+\n+pub impl &str: Serializable {\n+    fn serialize<S: Serializer>(&self, s: &S) { s.emit_borrowed_str(*self) }\n+}\n+\n+pub impl ~str: Serializable {\n+    fn serialize<S: Serializer>(&self, s: &S) { s.emit_owned_str(*self) }\n+}\n+\n+pub impl ~str: Deserializable {\n+    static fn deserialize<D: Deserializer>(&self, d: &D) -> ~str {\n+        d.read_owned_str()\n+    }\n+}\n+\n+pub impl @str: Serializable {\n+    fn serialize<S: Serializer>(&self, s: &S) { s.emit_managed_str(*self) }\n+}\n+\n+pub impl @str: Deserializable {\n+    static fn deserialize<D: Deserializer>(&self, d: &D) -> @str {\n+        d.read_managed_str()\n+    }\n+}\n+\n+pub impl float: Serializable {\n+    fn serialize<S: Serializer>(&self, s: &S) { s.emit_float(*self) }\n+}\n+\n+pub impl float: Deserializable {\n+    static fn deserialize<D: Deserializer>(&self, d: &D) -> float {\n+        d.read_float()\n+    }\n+}\n+\n+pub impl f32: Serializable {\n+    fn serialize<S: Serializer>(&self, s: &S) { s.emit_f32(*self) }\n+}\n+\n+pub impl f32: Deserializable {\n+    static fn deserialize<D: Deserializer>(&self, d: &D) -> f32 {\n+        d.read_f32() }\n+}\n+\n+pub impl f64: Serializable {\n+    fn serialize<S: Serializer>(&self, s: &S) { s.emit_f64(*self) }\n+}\n+\n+pub impl f64: Deserializable {\n+    static fn deserialize<D: Deserializer>(&self, d: &D) -> f64 {\n+        d.read_f64()\n+    }\n+}\n+\n+pub impl bool: Serializable {\n+    fn serialize<S: Serializer>(&self, s: &S) { s.emit_bool(*self) }\n+}\n+\n+pub impl bool: Deserializable {\n+    static fn deserialize<D: Deserializer>(&self, d: &D) -> bool {\n+        d.read_bool()\n+    }\n+}\n+\n+pub impl (): Serializable {\n+    fn serialize<S: Serializer>(&self, s: &S) { s.emit_nil() }\n+}\n+\n+pub impl (): Deserializable {\n+    static fn deserialize<D: Deserializer>(&self, d: &D) -> () {\n+        d.read_nil()\n+    }\n+}\n+\n+pub impl<T: Serializable> &T: Serializable {\n+    fn serialize<S: Serializer>(&self, s: &S) {\n+        s.emit_borrowed(|| (**self).serialize(s))\n+    }\n+}\n+\n+pub impl<T: Serializable> ~T: Serializable {\n+    fn serialize<S: Serializer>(&self, s: &S) {\n+        s.emit_owned(|| (**self).serialize(s))\n+    }\n+}\n+\n+pub impl<T: Deserializable> ~T: Deserializable {\n+    static fn deserialize<D: Deserializer>(&self, d: &D) -> ~T {\n+        d.read_owned(|| ~deserialize(d))\n+    }\n+}\n+\n+pub impl<T: Serializable> @T: Serializable {\n+    fn serialize<S: Serializer>(&self, s: &S) {\n+        s.emit_managed(|| (**self).serialize(s))\n+    }\n+}\n+\n+pub impl<T: Deserializable> @T: Deserializable {\n+    static fn deserialize<D: Deserializer>(&self, d: &D) -> @T {\n+        d.read_managed(|| @deserialize(d))\n+    }\n+}\n+\n+pub impl<T: Serializable> &[T]: Serializable {\n+    fn serialize<S: Serializer>(&self, s: &S) {\n+        do s.emit_borrowed_vec(self.len()) {\n+            for self.eachi |i, e| {\n+                s.emit_vec_elt(i, || e.serialize(s))\n+            }\n+        }\n+    }\n+}\n+\n+pub impl<T: Serializable> ~[T]: Serializable {\n+    fn serialize<S: Serializer>(&self, s: &S) {\n+        do s.emit_owned_vec(self.len()) {\n+            for self.eachi |i, e| {\n+                s.emit_vec_elt(i, || e.serialize(s))\n+            }\n+        }\n+    }\n+}\n+\n+pub impl<T: Deserializable> ~[T]: Deserializable {\n+    static fn deserialize<D: Deserializer>(&self, d: &D) -> ~[T] {\n+        do d.read_owned_vec |len| {\n+            do vec::from_fn(len) |i| {\n+                d.read_vec_elt(i, || deserialize(d))\n+            }\n+        }\n+    }\n+}\n+\n+pub impl<T: Serializable> @[T]: Serializable {\n+    fn serialize<S: Serializer>(&self, s: &S) {\n+        do s.emit_managed_vec(self.len()) {\n+            for self.eachi |i, e| {\n+                s.emit_vec_elt(i, || e.serialize(s))\n+            }\n+        }\n+    }\n+}\n+\n+pub impl<T: Deserializable> @[T]: Deserializable {\n+    static fn deserialize<D: Deserializer>(&self, d: &D) -> @[T] {\n+        do d.read_managed_vec |len| {\n+            do at_vec::from_fn(len) |i| {\n+                d.read_vec_elt(i, || deserialize(d))\n+            }\n+        }\n+    }\n+}\n+\n+pub impl<T: Serializable> Option<T>: Serializable {\n+    fn serialize<S: Serializer>(&self, s: &S) {\n+        do s.emit_enum(~\"option\") {\n+            match *self {\n+              None => do s.emit_enum_variant(~\"none\", 0u, 0u) {\n+              },\n+\n+              Some(ref v) => do s.emit_enum_variant(~\"some\", 1u, 1u) {\n+                s.emit_enum_variant_arg(0u, || v.serialize(s))\n+              }\n+            }\n+        }\n+    }\n+}\n+\n+pub impl<T: Deserializable> Option<T>: Deserializable {\n+    static fn deserialize<D: Deserializer>(&self, d: &D) -> Option<T> {\n+        do d.read_enum(~\"option\") {\n+            do d.read_enum_variant |i| {\n+                match i {\n+                  0 => None,\n+                  1 => Some(d.read_enum_variant_arg(0u, || deserialize(d))),\n+                  _ => fail(fmt!(\"Bad variant for option: %u\", i))\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+pub impl<\n+    T0: Serializable,\n+    T1: Serializable\n+> (T0, T1): Serializable {\n+    fn serialize<S: Serializer>(&self, s: &S) {\n+        match *self {\n+            (ref t0, ref t1) => {\n+                do s.emit_tup(2) {\n+                    s.emit_tup_elt(0, || t0.serialize(s));\n+                    s.emit_tup_elt(1, || t1.serialize(s));\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+pub impl<\n+    T0: Deserializable,\n+    T1: Deserializable\n+> (T0, T1): Deserializable {\n+    static fn deserialize<D: Deserializer>(&self, d: &D) -> (T0, T1) {\n+        do d.read_tup(2) {\n+            (\n+                d.read_tup_elt(0, || deserialize(d)),\n+                d.read_tup_elt(1, || deserialize(d))\n+            )\n+        }\n+    }\n+}\n+\n+pub impl<\n+    T0: Serializable,\n+    T1: Serializable,\n+    T2: Serializable\n+> (T0, T1, T2): Serializable {\n+    fn serialize<S: Serializer>(&self, s: &S) {\n+        match *self {\n+            (ref t0, ref t1, ref t2) => {\n+                do s.emit_tup(3) {\n+                    s.emit_tup_elt(0, || t0.serialize(s));\n+                    s.emit_tup_elt(1, || t1.serialize(s));\n+                    s.emit_tup_elt(2, || t2.serialize(s));\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+pub impl<\n+    T0: Deserializable,\n+    T1: Deserializable,\n+    T2: Deserializable\n+> (T0, T1, T2): Deserializable {\n+    static fn deserialize<D: Deserializer>(&self, d: &D) -> (T0, T1, T2) {\n+        do d.read_tup(3) {\n+            (\n+                d.read_tup_elt(0, || deserialize(d)),\n+                d.read_tup_elt(1, || deserialize(d)),\n+                d.read_tup_elt(2, || deserialize(d))\n+            )\n+        }\n+    }\n+}\n+\n+pub impl<\n+    T0: Serializable,\n+    T1: Serializable,\n+    T2: Serializable,\n+    T3: Serializable\n+> (T0, T1, T2, T3): Serializable {\n+    fn serialize<S: Serializer>(&self, s: &S) {\n+        match *self {\n+            (ref t0, ref t1, ref t2, ref t3) => {\n+                do s.emit_tup(4) {\n+                    s.emit_tup_elt(0, || t0.serialize(s));\n+                    s.emit_tup_elt(1, || t1.serialize(s));\n+                    s.emit_tup_elt(2, || t2.serialize(s));\n+                    s.emit_tup_elt(3, || t3.serialize(s));\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+pub impl<\n+    T0: Deserializable,\n+    T1: Deserializable,\n+    T2: Deserializable,\n+    T3: Deserializable\n+> (T0, T1, T2, T3): Deserializable {\n+    static fn deserialize<D: Deserializer>(&self, d: &D) -> (T0, T1, T2, T3) {\n+        do d.read_tup(4) {\n+            (\n+                d.read_tup_elt(0, || deserialize(d)),\n+                d.read_tup_elt(1, || deserialize(d)),\n+                d.read_tup_elt(2, || deserialize(d)),\n+                d.read_tup_elt(3, || deserialize(d))\n+            )\n+        }\n+    }\n+}\n+\n+pub impl<\n+    T0: Serializable,\n+    T1: Serializable,\n+    T2: Serializable,\n+    T3: Serializable,\n+    T4: Serializable\n+> (T0, T1, T2, T3, T4): Serializable {\n+    fn serialize<S: Serializer>(&self, s: &S) {\n+        match *self {\n+            (ref t0, ref t1, ref t2, ref t3, ref t4) => {\n+                do s.emit_tup(5) {\n+                    s.emit_tup_elt(0, || t0.serialize(s));\n+                    s.emit_tup_elt(1, || t1.serialize(s));\n+                    s.emit_tup_elt(2, || t2.serialize(s));\n+                    s.emit_tup_elt(3, || t3.serialize(s));\n+                    s.emit_tup_elt(4, || t4.serialize(s));\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+pub impl<\n+    T0: Deserializable,\n+    T1: Deserializable,\n+    T2: Deserializable,\n+    T3: Deserializable,\n+    T4: Deserializable\n+> (T0, T1, T2, T3, T4): Deserializable {\n+    static fn deserialize<D: Deserializer>(&self, d: &D)\n+      -> (T0, T1, T2, T3, T4) {\n+        do d.read_tup(5) {\n+            (\n+                d.read_tup_elt(0, || deserialize(d)),\n+                d.read_tup_elt(1, || deserialize(d)),\n+                d.read_tup_elt(2, || deserialize(d)),\n+                d.read_tup_elt(3, || deserialize(d)),\n+                d.read_tup_elt(4, || deserialize(d))\n+            )\n+        }\n+    }\n }\n \n // ___________________________________________________________________________\n // Helper routines\n //\n // In some cases, these should eventually be coded as traits.\n \n-pub fn emit_from_vec<S: Serializer, T>(&&s: S, &&v: ~[T], f: fn(&&x: T)) {\n-    do s.emit_vec(vec::len(v)) {\n-        for vec::eachi(v) |i,e| {\n-            do s.emit_vec_elt(i) {\n-                f(*e)\n+pub trait SerializerHelpers {\n+    fn emit_from_vec<T>(&self, v: &[T], f: fn(&T));\n+}\n+\n+pub impl<S: Serializer> S: SerializerHelpers {\n+    fn emit_from_vec<T>(&self, v: &[T], f: fn(&T)) {\n+        do self.emit_owned_vec(v.len()) {\n+            for v.eachi |i, e| {\n+                do self.emit_vec_elt(i) {\n+                    f(e)\n+                }\n             }\n         }\n     }\n }\n \n-pub fn read_to_vec<D: Deserializer, T: Copy>(&&d: D, f: fn() -> T) -> ~[T] {\n-    do d.read_vec |len| {\n-        do vec::from_fn(len) |i| {\n-            d.read_vec_elt(i, || f())\n+pub trait DeserializerHelpers {\n+    fn read_to_vec<T>(&self, f: fn() -> T) -> ~[T];\n+}\n+\n+pub impl<D: Deserializer> D: DeserializerHelpers {\n+    fn read_to_vec<T>(&self, f: fn() -> T) -> ~[T] {\n+        do self.read_owned_vec |len| {\n+            do vec::from_fn(len) |i| {\n+                self.read_vec_elt(i, || f())\n+            }\n         }\n     }\n }\n+}\n \n-pub trait SerializerHelpers {\n-    fn emit_from_vec<T>(&&v: ~[T], f: fn(&&x: T));\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+pub mod traits {\n+pub trait Serializable<S: Serializer> {\n+    fn serialize(&self, s: &S);\n+}\n+\n+pub trait Deserializable<D: Deserializer> {\n+    static fn deserialize(&self, d: &D) -> self;\n+}\n+\n+pub impl<S: Serializer> uint: Serializable<S> {\n+    fn serialize(&self, s: &S) { s.emit_uint(*self) }\n }\n \n-impl<S: Serializer> S: SerializerHelpers {\n-    fn emit_from_vec<T>(&&v: ~[T], f: fn(&&x: T)) {\n-        emit_from_vec(self, v, f)\n+pub impl<D: Deserializer> uint: Deserializable<D> {\n+    static fn deserialize(&self, d: &D) -> uint {\n+        d.read_uint()\n     }\n }\n \n-pub trait DeserializerHelpers {\n-    fn read_to_vec<T: Copy>(f: fn() -> T) -> ~[T];\n+pub impl<S: Serializer> u8: Serializable<S> {\n+    fn serialize(&self, s: &S) { s.emit_u8(*self) }\n+}\n+\n+pub impl<D: Deserializer> u8: Deserializable<D> {\n+    static fn deserialize(&self, d: &D) -> u8 {\n+        d.read_u8()\n+    }\n+}\n+\n+pub impl<S: Serializer> u16: Serializable<S> {\n+    fn serialize(&self, s: &S) { s.emit_u16(*self) }\n+}\n+\n+pub impl<D: Deserializer> u16: Deserializable<D> {\n+    static fn deserialize(&self, d: &D) -> u16 {\n+        d.read_u16()\n+    }\n+}\n+\n+pub impl<S: Serializer> u32: Serializable<S> {\n+    fn serialize(&self, s: &S) { s.emit_u32(*self) }\n+}\n+\n+pub impl<D: Deserializer> u32: Deserializable<D> {\n+    static fn deserialize(&self, d: &D) -> u32 {\n+        d.read_u32()\n+    }\n+}\n+\n+pub impl<S: Serializer> u64: Serializable<S> {\n+    fn serialize(&self, s: &S) { s.emit_u64(*self) }\n+}\n+\n+pub impl<D: Deserializer> u64: Deserializable<D> {\n+    static fn deserialize(&self, d: &D) -> u64 {\n+        d.read_u64()\n+    }\n+}\n+\n+pub impl<S: Serializer> int: Serializable<S> {\n+    fn serialize(&self, s: &S) { s.emit_int(*self) }\n+}\n+\n+pub impl<D: Deserializer> int: Deserializable<D> {\n+    static fn deserialize(&self, d: &D) -> int {\n+        d.read_int()\n+    }\n+}\n+\n+pub impl<S: Serializer> i8: Serializable<S> {\n+    fn serialize(&self, s: &S) { s.emit_i8(*self) }\n+}\n+\n+pub impl<D: Deserializer> i8: Deserializable<D> {\n+    static fn deserialize(&self, d: &D) -> i8 {\n+        d.read_i8()\n+    }\n+}\n+\n+pub impl<S: Serializer> i16: Serializable<S> {\n+    fn serialize(&self, s: &S) { s.emit_i16(*self) }\n+}\n+\n+pub impl<D: Deserializer> i16: Deserializable<D> {\n+    static fn deserialize(&self, d: &D) -> i16 {\n+        d.read_i16()\n+    }\n+}\n+\n+pub impl<S: Serializer> i32: Serializable<S> {\n+    fn serialize(&self, s: &S) { s.emit_i32(*self) }\n+}\n+\n+pub impl<D: Deserializer> i32: Deserializable<D> {\n+    static fn deserialize(&self, d: &D) -> i32 {\n+        d.read_i32()\n+    }\n+}\n+\n+pub impl<S: Serializer> i64: Serializable<S> {\n+    fn serialize(&self, s: &S) { s.emit_i64(*self) }\n }\n \n-impl<D: Deserializer> D: DeserializerHelpers {\n-    fn read_to_vec<T: Copy>(f: fn() -> T) -> ~[T] {\n-        read_to_vec(self, f)\n+pub impl<D: Deserializer> i64: Deserializable<D> {\n+    static fn deserialize(&self, d: &D) -> i64 {\n+        d.read_i64()\n     }\n }\n \n-pub fn serialize_uint<S: Serializer>(&&s: S, v: uint) {\n-    s.emit_uint(v);\n+pub impl<S: Serializer> &str: Serializable<S> {\n+    fn serialize(&self, s: &S) { s.emit_borrowed_str(*self) }\n+}\n+\n+pub impl<S: Serializer> ~str: Serializable<S> {\n+    fn serialize(&self, s: &S) { s.emit_owned_str(*self) }\n }\n \n-pub fn deserialize_uint<D: Deserializer>(&&d: D) -> uint {\n-    d.read_uint()\n+pub impl<D: Deserializer> ~str: Deserializable<D> {\n+    static fn deserialize(&self, d: &D) -> ~str {\n+        d.read_owned_str()\n+    }\n }\n \n-pub fn serialize_u8<S: Serializer>(&&s: S, v: u8) {\n-    s.emit_u8(v);\n+pub impl<S: Serializer> @str: Serializable<S> {\n+    fn serialize(&self, s: &S) { s.emit_managed_str(*self) }\n }\n \n-pub fn deserialize_u8<D: Deserializer>(&&d: D) -> u8 {\n-    d.read_u8()\n+pub impl<D: Deserializer> @str: Deserializable<D> {\n+    static fn deserialize(&self, d: &D) -> @str {\n+        d.read_managed_str()\n+    }\n }\n \n-pub fn serialize_u16<S: Serializer>(&&s: S, v: u16) {\n-    s.emit_u16(v);\n+pub impl<S: Serializer> float: Serializable<S> {\n+    fn serialize(&self, s: &S) { s.emit_float(*self) }\n }\n \n-pub fn deserialize_u16<D: Deserializer>(&&d: D) -> u16 {\n-    d.read_u16()\n+pub impl<D: Deserializer> float: Deserializable<D> {\n+    static fn deserialize(&self, d: &D) -> float {\n+        d.read_float()\n+    }\n }\n \n-pub fn serialize_u32<S: Serializer>(&&s: S, v: u32) {\n-    s.emit_u32(v);\n+pub impl<S: Serializer> f32: Serializable<S> {\n+    fn serialize(&self, s: &S) { s.emit_f32(*self) }\n }\n \n-pub fn deserialize_u32<D: Deserializer>(&&d: D) -> u32 {\n-    d.read_u32()\n+pub impl<D: Deserializer> f32: Deserializable<D> {\n+    static fn deserialize(&self, d: &D) -> f32 {\n+        d.read_f32() }\n }\n \n-pub fn serialize_u64<S: Serializer>(&&s: S, v: u64) {\n-    s.emit_u64(v);\n+pub impl<S: Serializer> f64: Serializable<S> {\n+    fn serialize(&self, s: &S) { s.emit_f64(*self) }\n }\n \n-pub fn deserialize_u64<D: Deserializer>(&&d: D) -> u64 {\n-    d.read_u64()\n+pub impl<D: Deserializer> f64: Deserializable<D> {\n+    static fn deserialize(&self, d: &D) -> f64 {\n+        d.read_f64()\n+    }\n }\n \n-pub fn serialize_int<S: Serializer>(&&s: S, v: int) {\n-    s.emit_int(v);\n+pub impl<S: Serializer> bool: Serializable<S> {\n+    fn serialize(&self, s: &S) { s.emit_bool(*self) }\n }\n \n-pub fn deserialize_int<D: Deserializer>(&&d: D) -> int {\n-    d.read_int()\n+pub impl<D: Deserializer> bool: Deserializable<D> {\n+    static fn deserialize(&self, d: &D) -> bool {\n+        d.read_bool()\n+    }\n }\n \n-pub fn serialize_i8<S: Serializer>(&&s: S, v: i8) {\n-    s.emit_i8(v);\n+pub impl<S: Serializer> (): Serializable<S> {\n+    fn serialize(&self, s: &S) { s.emit_nil() }\n }\n \n-pub fn deserialize_i8<D: Deserializer>(&&d: D) -> i8 {\n-    d.read_i8()\n+pub impl<D: Deserializer> (): Deserializable<D> {\n+    static fn deserialize(&self, d: &D) -> () {\n+        d.read_nil()\n+    }\n }\n \n-pub fn serialize_i16<S: Serializer>(&&s: S, v: i16) {\n-    s.emit_i16(v);\n+pub impl<S: Serializer, T: Serializable<S>> &T: Serializable<S> {\n+    fn serialize(&self, s: &S) {\n+        s.emit_borrowed(|| (**self).serialize(s))\n+    }\n }\n \n-pub fn deserialize_i16<D: Deserializer>(&&d: D) -> i16 {\n-    d.read_i16()\n+pub impl<S: Serializer, T: Serializable<S>> ~T: Serializable<S> {\n+    fn serialize(&self, s: &S) {\n+        s.emit_owned(|| (**self).serialize(s))\n+    }\n }\n \n-pub fn serialize_i32<S: Serializer>(&&s: S, v: i32) {\n-    s.emit_i32(v);\n+pub impl<D: Deserializer, T: Deserializable<D>> ~T: Deserializable<D> {\n+    static fn deserialize(&self, d: &D) -> ~T {\n+        d.read_owned(|| ~deserialize(d))\n+    }\n }\n \n-pub fn deserialize_i32<D: Deserializer>(&&d: D) -> i32 {\n-    d.read_i32()\n+pub impl<S: Serializer, T: Serializable<S>> @T: Serializable<S> {\n+    fn serialize(&self, s: &S) {\n+        s.emit_managed(|| (**self).serialize(s))\n+    }\n }\n \n-pub fn serialize_i64<S: Serializer>(&&s: S, v: i64) {\n-    s.emit_i64(v);\n+pub impl<D: Deserializer, T: Deserializable<D>> @T: Deserializable<D> {\n+    static fn deserialize(&self, d: &D) -> @T {\n+        d.read_managed(|| @deserialize(d))\n+    }\n }\n \n-pub fn deserialize_i64<D: Deserializer>(&&d: D) -> i64 {\n-    d.read_i64()\n+pub impl<S: Serializer, T: Serializable<S>> &[T]: Serializable<S> {\n+    fn serialize(&self, s: &S) {\n+        do s.emit_borrowed_vec(self.len()) {\n+            for self.eachi |i, e| {\n+                s.emit_vec_elt(i, || e.serialize(s))\n+            }\n+        }\n+    }\n+}\n+\n+pub impl<S: Serializer, T: Serializable<S>> ~[T]: Serializable<S> {\n+    fn serialize(&self, s: &S) {\n+        do s.emit_owned_vec(self.len()) {\n+            for self.eachi |i, e| {\n+                s.emit_vec_elt(i, || e.serialize(s))\n+            }\n+        }\n+    }\n+}\n+\n+pub impl<D: Deserializer, T: Deserializable<D>> ~[T]: Deserializable<D> {\n+    static fn deserialize(&self, d: &D) -> ~[T] {\n+        do d.read_owned_vec |len| {\n+            do vec::from_fn(len) |i| {\n+                d.read_vec_elt(i, || deserialize(d))\n+            }\n+        }\n+    }\n+}\n+\n+pub impl<S: Serializer, T: Serializable<S>> @[T]: Serializable<S> {\n+    fn serialize(&self, s: &S) {\n+        do s.emit_managed_vec(self.len()) {\n+            for self.eachi |i, e| {\n+                s.emit_vec_elt(i, || e.serialize(s))\n+            }\n+        }\n+    }\n+}\n+\n+pub impl<D: Deserializer, T: Deserializable<D>> @[T]: Deserializable<D> {\n+    static fn deserialize(&self, d: &D) -> @[T] {\n+        do d.read_managed_vec |len| {\n+            do at_vec::from_fn(len) |i| {\n+                d.read_vec_elt(i, || deserialize(d))\n+            }\n+        }\n+    }\n }\n \n-pub fn serialize_str<S: Serializer>(&&s: S, v: &str) {\n-    s.emit_str(v);\n+pub impl<S: Serializer, T: Serializable<S>> Option<T>: Serializable<S> {\n+    fn serialize(&self, s: &S) {\n+        do s.emit_enum(~\"option\") {\n+            match *self {\n+              None => do s.emit_enum_variant(~\"none\", 0u, 0u) {\n+              },\n+\n+              Some(ref v) => do s.emit_enum_variant(~\"some\", 1u, 1u) {\n+                s.emit_enum_variant_arg(0u, || v.serialize(s))\n+              }\n+            }\n+        }\n+    }\n }\n \n-pub fn deserialize_str<D: Deserializer>(&&d: D) -> ~str {\n-    d.read_str()\n+pub impl<D: Deserializer, T: Deserializable<D>> Option<T>: Deserializable<D> {\n+    static fn deserialize(&self, d: &D) -> Option<T> {\n+        do d.read_enum(~\"option\") {\n+            do d.read_enum_variant |i| {\n+                match i {\n+                  0 => None,\n+                  1 => Some(d.read_enum_variant_arg(0u, || deserialize(d))),\n+                  _ => fail(#fmt(\"Bad variant for option: %u\", i))\n+                }\n+            }\n+        }\n+    }\n }\n \n-pub fn serialize_float<S: Serializer>(&&s: S, v: float) {\n-    s.emit_float(v);\n+pub impl<\n+    S: Serializer,\n+    T0: Serializable<S>,\n+    T1: Serializable<S>\n+> (T0, T1): Serializable<S> {\n+    fn serialize(&self, s: &S) {\n+        match *self {\n+            (ref t0, ref t1) => {\n+                do s.emit_tup(2) {\n+                    s.emit_tup_elt(0, || t0.serialize(s));\n+                    s.emit_tup_elt(1, || t1.serialize(s));\n+                }\n+            }\n+        }\n+    }\n }\n \n-pub fn deserialize_float<D: Deserializer>(&&d: D) -> float {\n-    d.read_float()\n+pub impl<\n+    D: Deserializer,\n+    T0: Deserializable<D>,\n+    T1: Deserializable<D>\n+> (T0, T1): Deserializable<D> {\n+    static fn deserialize(&self, d: &D) -> (T0, T1) {\n+        do d.read_tup(2) {\n+            (\n+                d.read_tup_elt(0, || deserialize(d)),\n+                d.read_tup_elt(1, || deserialize(d))\n+            )\n+        }\n+    }\n }\n \n-pub fn serialize_f32<S: Serializer>(&&s: S, v: f32) {\n-    s.emit_f32(v);\n+pub impl<\n+    S: Serializer,\n+    T0: Serializable<S>,\n+    T1: Serializable<S>,\n+    T2: Serializable<S>\n+> (T0, T1, T2): Serializable<S> {\n+    fn serialize(&self, s: &S) {\n+        match *self {\n+            (ref t0, ref t1, ref t2) => {\n+                do s.emit_tup(3) {\n+                    s.emit_tup_elt(0, || t0.serialize(s));\n+                    s.emit_tup_elt(1, || t1.serialize(s));\n+                    s.emit_tup_elt(2, || t2.serialize(s));\n+                }\n+            }\n+        }\n+    }\n }\n \n-pub fn deserialize_f32<D: Deserializer>(&&d: D) -> f32 {\n-    d.read_f32()\n+pub impl<\n+    D: Deserializer,\n+    T0: Deserializable<D>,\n+    T1: Deserializable<D>,\n+    T2: Deserializable<D>\n+> (T0, T1, T2): Deserializable<D> {\n+    static fn deserialize(&self, d: &D) -> (T0, T1, T2) {\n+        do d.read_tup(3) {\n+            (\n+                d.read_tup_elt(0, || deserialize(d)),\n+                d.read_tup_elt(1, || deserialize(d)),\n+                d.read_tup_elt(2, || deserialize(d))\n+            )\n+        }\n+    }\n }\n \n-pub fn serialize_f64<S: Serializer>(&&s: S, v: f64) {\n-    s.emit_f64(v);\n+pub impl<\n+    S: Serializer,\n+    T0: Serializable<S>,\n+    T1: Serializable<S>,\n+    T2: Serializable<S>,\n+    T3: Serializable<S>\n+> (T0, T1, T2, T3): Serializable<S> {\n+    fn serialize(&self, s: &S) {\n+        match *self {\n+            (ref t0, ref t1, ref t2, ref t3) => {\n+                do s.emit_tup(4) {\n+                    s.emit_tup_elt(0, || t0.serialize(s));\n+                    s.emit_tup_elt(1, || t1.serialize(s));\n+                    s.emit_tup_elt(2, || t2.serialize(s));\n+                    s.emit_tup_elt(3, || t3.serialize(s));\n+                }\n+            }\n+        }\n+    }\n }\n \n-pub fn deserialize_f64<D: Deserializer>(&&d: D) -> f64 {\n-    d.read_f64()\n+pub impl<\n+    D: Deserializer,\n+    T0: Deserializable<D>,\n+    T1: Deserializable<D>,\n+    T2: Deserializable<D>,\n+    T3: Deserializable<D>\n+> (T0, T1, T2, T3): Deserializable<D> {\n+    static fn deserialize(&self, d: &D) -> (T0, T1, T2, T3) {\n+        do d.read_tup(4) {\n+            (\n+                d.read_tup_elt(0, || deserialize(d)),\n+                d.read_tup_elt(1, || deserialize(d)),\n+                d.read_tup_elt(2, || deserialize(d)),\n+                d.read_tup_elt(3, || deserialize(d))\n+            )\n+        }\n+    }\n }\n \n-pub fn serialize_bool<S: Serializer>(&&s: S, v: bool) {\n-    s.emit_bool(v);\n+pub impl<\n+    S: Serializer,\n+    T0: Serializable<S>,\n+    T1: Serializable<S>,\n+    T2: Serializable<S>,\n+    T3: Serializable<S>,\n+    T4: Serializable<S>\n+> (T0, T1, T2, T3, T4): Serializable<S> {\n+    fn serialize(&self, s: &S) {\n+        match *self {\n+            (ref t0, ref t1, ref t2, ref t3, ref t4) => {\n+                do s.emit_tup(5) {\n+                    s.emit_tup_elt(0, || t0.serialize(s));\n+                    s.emit_tup_elt(1, || t1.serialize(s));\n+                    s.emit_tup_elt(2, || t2.serialize(s));\n+                    s.emit_tup_elt(3, || t3.serialize(s));\n+                    s.emit_tup_elt(4, || t4.serialize(s));\n+                }\n+            }\n+        }\n+    }\n }\n \n-pub fn deserialize_bool<D: Deserializer>(&&d: D) -> bool {\n-    d.read_bool()\n+pub impl<\n+    D: Deserializer,\n+    T0: Deserializable<D>,\n+    T1: Deserializable<D>,\n+    T2: Deserializable<D>,\n+    T3: Deserializable<D>,\n+    T4: Deserializable<D>\n+> (T0, T1, T2, T3, T4): Deserializable<D> {\n+    static fn deserialize(&self, d: &D)\n+      -> (T0, T1, T2, T3, T4) {\n+        do d.read_tup(5) {\n+            (\n+                d.read_tup_elt(0, || deserialize(d)),\n+                d.read_tup_elt(1, || deserialize(d)),\n+                d.read_tup_elt(2, || deserialize(d)),\n+                d.read_tup_elt(3, || deserialize(d)),\n+                d.read_tup_elt(4, || deserialize(d))\n+            )\n+        }\n+    }\n }\n \n-pub fn serialize_Option<S: Serializer,T>(&&s: S, &&v: Option<T>,\n-                                         st: fn(&&x: T)) {\n-    do s.emit_enum(~\"option\") {\n-        match v {\n-          None => do s.emit_enum_variant(~\"none\", 0u, 0u) {\n-          },\n+// ___________________________________________________________________________\n+// Helper routines\n+//\n+// In some cases, these should eventually be coded as traits.\n \n-          Some(ref v) => do s.emit_enum_variant(~\"some\", 1u, 1u) {\n-            do s.emit_enum_variant_arg(0u) {\n-                st(*v)\n+pub trait SerializerHelpers {\n+    fn emit_from_vec<T>(&self, v: ~[T], f: fn(v: &T));\n+}\n+\n+pub impl<S: Serializer> S: SerializerHelpers {\n+    fn emit_from_vec<T>(&self, v: ~[T], f: fn(v: &T)) {\n+        do self.emit_owned_vec(v.len()) {\n+            for v.eachi |i, e| {\n+                do self.emit_vec_elt(i) {\n+                    f(e)\n+                }\n             }\n-          }\n         }\n     }\n }\n \n-pub fn deserialize_Option<D: Deserializer,T: Copy>(&&d: D, st: fn() -> T)\n-    -> Option<T> {\n-    do d.read_enum(~\"option\") {\n-        do d.read_enum_variant |i| {\n-            match i {\n-              0 => None,\n-              1 => Some(d.read_enum_variant_arg(0u, || st() )),\n-              _ => fail(#fmt(\"Bad variant for option: %u\", i))\n+pub trait DeserializerHelpers {\n+    fn read_to_vec<T>(&self, f: fn() -> T) -> ~[T];\n+}\n+\n+pub impl<D: Deserializer> D: DeserializerHelpers {\n+    fn read_to_vec<T>(&self, f: fn() -> T) -> ~[T] {\n+        do self.read_owned_vec |len| {\n+            do vec::from_fn(len) |i| {\n+                self.read_vec_elt(i, || f())\n             }\n         }\n     }\n }\n+}\n+\n+pub use traits::*;"}, {"sha": "5173ef163a22aef06ea3fd6787bea0dbcaa8efa9", "filename": "src/libstd/serialization2.rs", "status": "removed", "additions": 0, "deletions": 563, "changes": 563, "blob_url": "https://github.com/rust-lang/rust/blob/9aec7a3e85c5b07923eab05d3ebe9d031bf258f3/src%2Flibstd%2Fserialization2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aec7a3e85c5b07923eab05d3ebe9d031bf258f3/src%2Flibstd%2Fserialization2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fserialization2.rs?ref=9aec7a3e85c5b07923eab05d3ebe9d031bf258f3", "patch": "@@ -1,563 +0,0 @@\n-//! Support code for serialization.\n-\n-/*\n-Core serialization interfaces.\n-*/\n-\n-#[forbid(deprecated_mode)];\n-#[forbid(non_camel_case_types)];\n-\n-pub trait Serializer {\n-    // Primitive types:\n-    fn emit_nil(&self);\n-    fn emit_uint(&self, v: uint);\n-    fn emit_u64(&self, v: u64);\n-    fn emit_u32(&self, v: u32);\n-    fn emit_u16(&self, v: u16);\n-    fn emit_u8(&self, v: u8);\n-    fn emit_int(&self, v: int);\n-    fn emit_i64(&self, v: i64);\n-    fn emit_i32(&self, v: i32);\n-    fn emit_i16(&self, v: i16);\n-    fn emit_i8(&self, v: i8);\n-    fn emit_bool(&self, v: bool);\n-    fn emit_float(&self, v: float);\n-    fn emit_f64(&self, v: f64);\n-    fn emit_f32(&self, v: f32);\n-    fn emit_char(&self, v: char);\n-    fn emit_borrowed_str(&self, v: &str);\n-    fn emit_owned_str(&self, v: &str);\n-    fn emit_managed_str(&self, v: &str);\n-\n-    // Compound types:\n-    fn emit_borrowed(&self, f: fn());\n-    fn emit_owned(&self, f: fn());\n-    fn emit_managed(&self, f: fn());\n-\n-    fn emit_enum(&self, name: &str, f: fn());\n-    fn emit_enum_variant(&self, v_name: &str, v_id: uint, sz: uint, f: fn());\n-    fn emit_enum_variant_arg(&self, idx: uint, f: fn());\n-\n-    fn emit_borrowed_vec(&self, len: uint, f: fn());\n-    fn emit_owned_vec(&self, len: uint, f: fn());\n-    fn emit_managed_vec(&self, len: uint, f: fn());\n-    fn emit_vec_elt(&self, idx: uint, f: fn());\n-\n-    fn emit_rec(&self, f: fn());\n-    fn emit_struct(&self, name: &str, f: fn());\n-    fn emit_field(&self, f_name: &str, f_idx: uint, f: fn());\n-\n-    fn emit_tup(&self, len: uint, f: fn());\n-    fn emit_tup_elt(&self, idx: uint, f: fn());\n-}\n-\n-pub trait Deserializer {\n-    // Primitive types:\n-    fn read_nil(&self) -> ();\n-    fn read_uint(&self) -> uint;\n-    fn read_u64(&self) -> u64;\n-    fn read_u32(&self) -> u32;\n-    fn read_u16(&self) -> u16;\n-    fn read_u8(&self) -> u8;\n-    fn read_int(&self) -> int;\n-    fn read_i64(&self) -> i64;\n-    fn read_i32(&self) -> i32;\n-    fn read_i16(&self) -> i16;\n-    fn read_i8(&self) -> i8;\n-    fn read_bool(&self) -> bool;\n-    fn read_f64(&self) -> f64;\n-    fn read_f32(&self) -> f32;\n-    fn read_float(&self) -> float;\n-    fn read_char(&self) -> char;\n-    fn read_owned_str(&self) -> ~str;\n-    fn read_managed_str(&self) -> @str;\n-\n-    // Compound types:\n-    fn read_enum<T>(&self, name: &str, f: fn() -> T) -> T;\n-    fn read_enum_variant<T>(&self, f: fn(uint) -> T) -> T;\n-    fn read_enum_variant_arg<T>(&self, idx: uint, f: fn() -> T) -> T;\n-\n-    fn read_owned<T>(&self, f: fn() -> T) -> T;\n-    fn read_managed<T>(&self, f: fn() -> T) -> T;\n-\n-    fn read_owned_vec<T>(&self, f: fn(uint) -> T) -> T;\n-    fn read_managed_vec<T>(&self, f: fn(uint) -> T) -> T;\n-    fn read_vec_elt<T>(&self, idx: uint, f: fn() -> T) -> T;\n-\n-    fn read_rec<T>(&self, f: fn() -> T) -> T;\n-    fn read_struct<T>(&self, name: &str, f: fn() -> T) -> T;\n-    fn read_field<T>(&self, name: &str, idx: uint, f: fn() -> T) -> T;\n-\n-    fn read_tup<T>(&self, sz: uint, f: fn() -> T) -> T;\n-    fn read_tup_elt<T>(&self, idx: uint, f: fn() -> T) -> T;\n-}\n-\n-pub trait Serializable {\n-    fn serialize<S: Serializer>(&self, s: &S);\n-}\n-\n-pub trait Deserializable {\n-    static fn deserialize<D: Deserializer>(&self, d: &D) -> self;\n-}\n-\n-pub impl uint: Serializable {\n-    fn serialize<S: Serializer>(&self, s: &S) { s.emit_uint(*self) }\n-}\n-\n-pub impl uint: Deserializable {\n-    static fn deserialize<D: Deserializer>(&self, d: &D) -> uint {\n-        d.read_uint()\n-    }\n-}\n-\n-pub impl u8: Serializable {\n-    fn serialize<S: Serializer>(&self, s: &S) { s.emit_u8(*self) }\n-}\n-\n-pub impl u8: Deserializable {\n-    static fn deserialize<D: Deserializer>(&self, d: &D) -> u8 {\n-        d.read_u8()\n-    }\n-}\n-\n-pub impl u16: Serializable {\n-    fn serialize<S: Serializer>(&self, s: &S) { s.emit_u16(*self) }\n-}\n-\n-pub impl u16: Deserializable {\n-    static fn deserialize<D: Deserializer>(&self, d: &D) -> u16 {\n-        d.read_u16()\n-    }\n-}\n-\n-pub impl u32: Serializable {\n-    fn serialize<S: Serializer>(&self, s: &S) { s.emit_u32(*self) }\n-}\n-\n-pub impl u32: Deserializable {\n-    static fn deserialize<D: Deserializer>(&self, d: &D) -> u32 {\n-        d.read_u32()\n-    }\n-}\n-\n-pub impl u64: Serializable {\n-    fn serialize<S: Serializer>(&self, s: &S) { s.emit_u64(*self) }\n-}\n-\n-pub impl u64: Deserializable {\n-    static fn deserialize<D: Deserializer>(&self, d: &D) -> u64 {\n-        d.read_u64()\n-    }\n-}\n-\n-pub impl int: Serializable {\n-    fn serialize<S: Serializer>(&self, s: &S) { s.emit_int(*self) }\n-}\n-\n-pub impl int: Deserializable {\n-    static fn deserialize<D: Deserializer>(&self, d: &D) -> int {\n-        d.read_int()\n-    }\n-}\n-\n-pub impl i8: Serializable {\n-    fn serialize<S: Serializer>(&self, s: &S) { s.emit_i8(*self) }\n-}\n-\n-pub impl i8: Deserializable {\n-    static fn deserialize<D: Deserializer>(&self, d: &D) -> i8 {\n-        d.read_i8()\n-    }\n-}\n-\n-pub impl i16: Serializable {\n-    fn serialize<S: Serializer>(&self, s: &S) { s.emit_i16(*self) }\n-}\n-\n-pub impl i16: Deserializable {\n-    static fn deserialize<D: Deserializer>(&self, d: &D) -> i16 {\n-        d.read_i16()\n-    }\n-}\n-\n-pub impl i32: Serializable {\n-    fn serialize<S: Serializer>(&self, s: &S) { s.emit_i32(*self) }\n-}\n-\n-pub impl i32: Deserializable {\n-    static fn deserialize<D: Deserializer>(&self, d: &D) -> i32 {\n-        d.read_i32()\n-    }\n-}\n-\n-pub impl i64: Serializable {\n-    fn serialize<S: Serializer>(&self, s: &S) { s.emit_i64(*self) }\n-}\n-\n-pub impl i64: Deserializable {\n-    static fn deserialize<D: Deserializer>(&self, d: &D) -> i64 {\n-        d.read_i64()\n-    }\n-}\n-\n-pub impl &str: Serializable {\n-    fn serialize<S: Serializer>(&self, s: &S) { s.emit_borrowed_str(*self) }\n-}\n-\n-pub impl ~str: Serializable {\n-    fn serialize<S: Serializer>(&self, s: &S) { s.emit_owned_str(*self) }\n-}\n-\n-pub impl ~str: Deserializable {\n-    static fn deserialize<D: Deserializer>(&self, d: &D) -> ~str {\n-        d.read_owned_str()\n-    }\n-}\n-\n-pub impl @str: Serializable {\n-    fn serialize<S: Serializer>(&self, s: &S) { s.emit_managed_str(*self) }\n-}\n-\n-pub impl @str: Deserializable {\n-    static fn deserialize<D: Deserializer>(&self, d: &D) -> @str {\n-        d.read_managed_str()\n-    }\n-}\n-\n-pub impl float: Serializable {\n-    fn serialize<S: Serializer>(&self, s: &S) { s.emit_float(*self) }\n-}\n-\n-pub impl float: Deserializable {\n-    static fn deserialize<D: Deserializer>(&self, d: &D) -> float {\n-        d.read_float()\n-    }\n-}\n-\n-pub impl f32: Serializable {\n-    fn serialize<S: Serializer>(&self, s: &S) { s.emit_f32(*self) }\n-}\n-\n-pub impl f32: Deserializable {\n-    static fn deserialize<D: Deserializer>(&self, d: &D) -> f32 {\n-        d.read_f32() }\n-}\n-\n-pub impl f64: Serializable {\n-    fn serialize<S: Serializer>(&self, s: &S) { s.emit_f64(*self) }\n-}\n-\n-pub impl f64: Deserializable {\n-    static fn deserialize<D: Deserializer>(&self, d: &D) -> f64 {\n-        d.read_f64()\n-    }\n-}\n-\n-pub impl bool: Serializable {\n-    fn serialize<S: Serializer>(&self, s: &S) { s.emit_bool(*self) }\n-}\n-\n-pub impl bool: Deserializable {\n-    static fn deserialize<D: Deserializer>(&self, d: &D) -> bool {\n-        d.read_bool()\n-    }\n-}\n-\n-pub impl (): Serializable {\n-    fn serialize<S: Serializer>(&self, s: &S) { s.emit_nil() }\n-}\n-\n-pub impl (): Deserializable {\n-    static fn deserialize<D: Deserializer>(&self, d: &D) -> () {\n-        d.read_nil()\n-    }\n-}\n-\n-pub impl<T: Serializable> &T: Serializable {\n-    fn serialize<S: Serializer>(&self, s: &S) {\n-        s.emit_borrowed(|| (**self).serialize(s))\n-    }\n-}\n-\n-pub impl<T: Serializable> ~T: Serializable {\n-    fn serialize<S: Serializer>(&self, s: &S) {\n-        s.emit_owned(|| (**self).serialize(s))\n-    }\n-}\n-\n-pub impl<T: Deserializable> ~T: Deserializable {\n-    static fn deserialize<D: Deserializer>(&self, d: &D) -> ~T {\n-        d.read_owned(|| ~deserialize(d))\n-    }\n-}\n-\n-pub impl<T: Serializable> @T: Serializable {\n-    fn serialize<S: Serializer>(&self, s: &S) {\n-        s.emit_managed(|| (**self).serialize(s))\n-    }\n-}\n-\n-pub impl<T: Deserializable> @T: Deserializable {\n-    static fn deserialize<D: Deserializer>(&self, d: &D) -> @T {\n-        d.read_managed(|| @deserialize(d))\n-    }\n-}\n-\n-pub impl<T: Serializable> &[T]: Serializable {\n-    fn serialize<S: Serializer>(&self, s: &S) {\n-        do s.emit_borrowed_vec(self.len()) {\n-            for self.eachi |i, e| {\n-                s.emit_vec_elt(i, || e.serialize(s))\n-            }\n-        }\n-    }\n-}\n-\n-pub impl<T: Serializable> ~[T]: Serializable {\n-    fn serialize<S: Serializer>(&self, s: &S) {\n-        do s.emit_owned_vec(self.len()) {\n-            for self.eachi |i, e| {\n-                s.emit_vec_elt(i, || e.serialize(s))\n-            }\n-        }\n-    }\n-}\n-\n-pub impl<T: Deserializable> ~[T]: Deserializable {\n-    static fn deserialize<D: Deserializer>(&self, d: &D) -> ~[T] {\n-        do d.read_owned_vec |len| {\n-            do vec::from_fn(len) |i| {\n-                d.read_vec_elt(i, || deserialize(d))\n-            }\n-        }\n-    }\n-}\n-\n-pub impl<T: Serializable> @[T]: Serializable {\n-    fn serialize<S: Serializer>(&self, s: &S) {\n-        do s.emit_managed_vec(self.len()) {\n-            for self.eachi |i, e| {\n-                s.emit_vec_elt(i, || e.serialize(s))\n-            }\n-        }\n-    }\n-}\n-\n-pub impl<T: Deserializable> @[T]: Deserializable {\n-    static fn deserialize<D: Deserializer>(&self, d: &D) -> @[T] {\n-        do d.read_managed_vec |len| {\n-            do at_vec::from_fn(len) |i| {\n-                d.read_vec_elt(i, || deserialize(d))\n-            }\n-        }\n-    }\n-}\n-\n-pub impl<T: Serializable> Option<T>: Serializable {\n-    fn serialize<S: Serializer>(&self, s: &S) {\n-        do s.emit_enum(~\"option\") {\n-            match *self {\n-              None => do s.emit_enum_variant(~\"none\", 0u, 0u) {\n-              },\n-\n-              Some(ref v) => do s.emit_enum_variant(~\"some\", 1u, 1u) {\n-                s.emit_enum_variant_arg(0u, || v.serialize(s))\n-              }\n-            }\n-        }\n-    }\n-}\n-\n-pub impl<T: Deserializable> Option<T>: Deserializable {\n-    static fn deserialize<D: Deserializer>(&self, d: &D) -> Option<T> {\n-        do d.read_enum(~\"option\") {\n-            do d.read_enum_variant |i| {\n-                match i {\n-                  0 => None,\n-                  1 => Some(d.read_enum_variant_arg(0u, || deserialize(d))),\n-                  _ => fail(#fmt(\"Bad variant for option: %u\", i))\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-pub impl<\n-    T0: Serializable,\n-    T1: Serializable\n-> (T0, T1): Serializable {\n-    fn serialize<S: Serializer>(&self, s: &S) {\n-        match *self {\n-            (ref t0, ref t1) => {\n-                do s.emit_tup(2) {\n-                    s.emit_tup_elt(0, || t0.serialize(s));\n-                    s.emit_tup_elt(1, || t1.serialize(s));\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-pub impl<\n-    T0: Deserializable,\n-    T1: Deserializable\n-> (T0, T1): Deserializable {\n-    static fn deserialize<D: Deserializer>(&self, d: &D) -> (T0, T1) {\n-        do d.read_tup(2) {\n-            (\n-                d.read_tup_elt(0, || deserialize(d)),\n-                d.read_tup_elt(1, || deserialize(d))\n-            )\n-        }\n-    }\n-}\n-\n-pub impl<\n-    T0: Serializable,\n-    T1: Serializable,\n-    T2: Serializable\n-> (T0, T1, T2): Serializable {\n-    fn serialize<S: Serializer>(&self, s: &S) {\n-        match *self {\n-            (ref t0, ref t1, ref t2) => {\n-                do s.emit_tup(3) {\n-                    s.emit_tup_elt(0, || t0.serialize(s));\n-                    s.emit_tup_elt(1, || t1.serialize(s));\n-                    s.emit_tup_elt(2, || t2.serialize(s));\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-pub impl<\n-    T0: Deserializable,\n-    T1: Deserializable,\n-    T2: Deserializable\n-> (T0, T1, T2): Deserializable {\n-    static fn deserialize<D: Deserializer>(&self, d: &D) -> (T0, T1, T2) {\n-        do d.read_tup(3) {\n-            (\n-                d.read_tup_elt(0, || deserialize(d)),\n-                d.read_tup_elt(1, || deserialize(d)),\n-                d.read_tup_elt(2, || deserialize(d))\n-            )\n-        }\n-    }\n-}\n-\n-pub impl<\n-    T0: Serializable,\n-    T1: Serializable,\n-    T2: Serializable,\n-    T3: Serializable\n-> (T0, T1, T2, T3): Serializable {\n-    fn serialize<S: Serializer>(&self, s: &S) {\n-        match *self {\n-            (ref t0, ref t1, ref t2, ref t3) => {\n-                do s.emit_tup(4) {\n-                    s.emit_tup_elt(0, || t0.serialize(s));\n-                    s.emit_tup_elt(1, || t1.serialize(s));\n-                    s.emit_tup_elt(2, || t2.serialize(s));\n-                    s.emit_tup_elt(3, || t3.serialize(s));\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-pub impl<\n-    T0: Deserializable,\n-    T1: Deserializable,\n-    T2: Deserializable,\n-    T3: Deserializable\n-> (T0, T1, T2, T3): Deserializable {\n-    static fn deserialize<D: Deserializer>(&self, d: &D) -> (T0, T1, T2, T3) {\n-        do d.read_tup(4) {\n-            (\n-                d.read_tup_elt(0, || deserialize(d)),\n-                d.read_tup_elt(1, || deserialize(d)),\n-                d.read_tup_elt(2, || deserialize(d)),\n-                d.read_tup_elt(3, || deserialize(d))\n-            )\n-        }\n-    }\n-}\n-\n-pub impl<\n-    T0: Serializable,\n-    T1: Serializable,\n-    T2: Serializable,\n-    T3: Serializable,\n-    T4: Serializable\n-> (T0, T1, T2, T3, T4): Serializable {\n-    fn serialize<S: Serializer>(&self, s: &S) {\n-        match *self {\n-            (ref t0, ref t1, ref t2, ref t3, ref t4) => {\n-                do s.emit_tup(5) {\n-                    s.emit_tup_elt(0, || t0.serialize(s));\n-                    s.emit_tup_elt(1, || t1.serialize(s));\n-                    s.emit_tup_elt(2, || t2.serialize(s));\n-                    s.emit_tup_elt(3, || t3.serialize(s));\n-                    s.emit_tup_elt(4, || t4.serialize(s));\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-pub impl<\n-    T0: Deserializable,\n-    T1: Deserializable,\n-    T2: Deserializable,\n-    T3: Deserializable,\n-    T4: Deserializable\n-> (T0, T1, T2, T3, T4): Deserializable {\n-    static fn deserialize<D: Deserializer>(&self, d: &D)\n-      -> (T0, T1, T2, T3, T4) {\n-        do d.read_tup(5) {\n-            (\n-                d.read_tup_elt(0, || deserialize(d)),\n-                d.read_tup_elt(1, || deserialize(d)),\n-                d.read_tup_elt(2, || deserialize(d)),\n-                d.read_tup_elt(3, || deserialize(d)),\n-                d.read_tup_elt(4, || deserialize(d))\n-            )\n-        }\n-    }\n-}\n-\n-// ___________________________________________________________________________\n-// Helper routines\n-//\n-// In some cases, these should eventually be coded as traits.\n-\n-pub trait SerializerHelpers {\n-    fn emit_from_vec<T>(&self, v: &[T], f: fn(&T));\n-}\n-\n-pub impl<S: Serializer> S: SerializerHelpers {\n-    fn emit_from_vec<T>(&self, v: &[T], f: fn(&T)) {\n-        do self.emit_owned_vec(v.len()) {\n-            for v.eachi |i, e| {\n-                do self.emit_vec_elt(i) {\n-                    f(e)\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-pub trait DeserializerHelpers {\n-    fn read_to_vec<T>(&self, f: fn() -> T) -> ~[T];\n-}\n-\n-pub impl<D: Deserializer> D: DeserializerHelpers {\n-    fn read_to_vec<T>(&self, f: fn() -> T) -> ~[T] {\n-        do self.read_owned_vec |len| {\n-            do vec::from_fn(len) |i| {\n-                self.read_vec_elt(i, || f())\n-            }\n-        }\n-    }\n-}"}, {"sha": "946a3e1155dd520ce67eb9c5b4912105454ef12d", "filename": "src/libstd/sort.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibstd%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibstd%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsort.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820", "patch": "@@ -899,7 +899,7 @@ mod test_qsort {\n \n         do sort::quick_sort(names) |x, y| { int::le(*x, *y) };\n \n-        let immut_names = vec::from_mut(names);\n+        let immut_names = vec::from_mut(move names);\n \n         let pairs = vec::zip(expected, immut_names);\n         for vec::each(pairs) |p| {"}, {"sha": "bbffde409484e021d89bca7fcb3d6b04d779fc62", "filename": "src/libstd/std.rc", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibstd%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibstd%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rc?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820", "patch": "@@ -8,7 +8,7 @@ not required in or otherwise suitable for the core library.\n */\n \n #[link(name = \"std\",\n-       vers = \"0.4\",\n+       vers = \"0.5\",\n        uuid = \"122bed0b-c19b-4b82-b0b7-7ae8aead7297\",\n        url = \"https://github.com/mozilla/rust/tree/master/src/libstd\")];\n \n@@ -25,7 +25,7 @@ not required in or otherwise suitable for the core library.\n #[allow(deprecated_mode)];\n #[forbid(deprecated_pattern)];\n \n-extern mod core(vers = \"0.4\");\n+extern mod core(vers = \"0.5\");\n use core::*;\n \n // General io and system-services modules\n@@ -69,7 +69,6 @@ pub mod treemap;\n // And ... other stuff\n \n pub mod ebml;\n-pub mod ebml2;\n pub mod dbg;\n pub mod getopts;\n pub mod json;\n@@ -79,7 +78,6 @@ pub mod tempfile;\n pub mod term;\n pub mod time;\n pub mod prettyprint;\n-pub mod prettyprint2;\n pub mod arena;\n pub mod par;\n pub mod cmp;\n@@ -93,7 +91,6 @@ mod unicode;\n \n pub mod test;\n pub mod serialization;\n-pub mod serialization2;\n \n // Local Variables:\n // mode: rust;"}, {"sha": "73fc78a091a4fd89e8ca7d022628f6581f96d165", "filename": "src/libstd/sync.rs", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibstd%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibstd%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820", "patch": "@@ -25,7 +25,7 @@ struct Waitqueue { head: pipes::Port<SignalEnd>,\n \n fn new_waitqueue() -> Waitqueue {\n     let (block_tail, block_head) = pipes::stream();\n-    Waitqueue { head: block_head, tail: block_tail }\n+    Waitqueue { head: move block_head, tail: move block_tail }\n }\n \n // Signals one live task from the queue.\n@@ -71,7 +71,7 @@ enum Sem<Q: Send> = Exclusive<SemInner<Q>>;\n #[doc(hidden)]\n fn new_sem<Q: Send>(count: int, q: Q) -> Sem<Q> {\n     Sem(exclusive(SemInner {\n-        mut count: count, waiters: new_waitqueue(), blocked: q }))\n+        mut count: count, waiters: new_waitqueue(), blocked: move q }))\n }\n #[doc(hidden)]\n fn new_sem_and_signal(count: int, num_condvars: uint)\n@@ -146,7 +146,7 @@ impl &Sem<~[mut Waitqueue]> {\n     }\n }\n \n-// FIXME(#3136) should go inside of access()\n+// FIXME(#3588) should go inside of access()\n #[doc(hidden)]\n struct SemRelease {\n     sem: &Sem<()>,\n@@ -577,7 +577,7 @@ impl &RWlock {\n     }\n }\n \n-// FIXME(#3136) should go inside of read()\n+// FIXME(#3588) should go inside of read()\n #[doc(hidden)]\n struct RWlockReleaseRead {\n     lock: &RWlock,\n@@ -606,7 +606,7 @@ fn RWlockReleaseRead(lock: &r/RWlock) -> RWlockReleaseRead/&r {\n     }\n }\n \n-// FIXME(#3136) should go inside of downgrade()\n+// FIXME(#3588) should go inside of downgrade()\n #[doc(hidden)]\n struct RWlockReleaseDowngrade {\n     lock: &RWlock,\n@@ -686,7 +686,7 @@ mod tests {\n     fn test_sem_as_mutex() {\n         let s = ~semaphore(1);\n         let s2 = ~s.clone();\n-        do task::spawn {\n+        do task::spawn |move s2| {\n             do s2.access {\n                 for 5.times { task::yield(); }\n             }\n@@ -701,7 +701,7 @@ mod tests {\n         let (c,p) = pipes::stream();\n         let s = ~semaphore(0);\n         let s2 = ~s.clone();\n-        do task::spawn {\n+        do task::spawn |move s2, move c| {\n             s2.acquire();\n             c.send(());\n         }\n@@ -713,7 +713,7 @@ mod tests {\n         let (c,p) = pipes::stream();\n         let s = ~semaphore(0);\n         let s2 = ~s.clone();\n-        do task::spawn {\n+        do task::spawn |move s2, move p| {\n             for 5.times { task::yield(); }\n             s2.release();\n             let _ = p.recv();\n@@ -729,7 +729,7 @@ mod tests {\n         let s2 = ~s.clone();\n         let (c1,p1) = pipes::stream();\n         let (c2,p2) = pipes::stream();\n-        do task::spawn {\n+        do task::spawn |move s2, move c1, move p2| {\n             do s2.access {\n                 let _ = p2.recv();\n                 c1.send(());\n@@ -748,10 +748,10 @@ mod tests {\n             let s = ~semaphore(1);\n             let s2 = ~s.clone();\n             let (c,p) = pipes::stream();\n-            let child_data = ~mut Some((s2,c));\n+            let child_data = ~mut Some((move s2, move c));\n             do s.access {\n                 let (s2,c) = option::swap_unwrap(child_data);\n-                do task::spawn {\n+                do task::spawn |move c, move s2| {\n                     c.send(());\n                     do s2.access { }\n                     c.send(());\n@@ -774,7 +774,7 @@ mod tests {\n         let m2 = ~m.clone();\n         let mut sharedstate = ~0;\n         let ptr = ptr::addr_of(&(*sharedstate));\n-        do task::spawn {\n+        do task::spawn |move m2, move c| {\n             let sharedstate: &mut int =\n                 unsafe { cast::reinterpret_cast(&ptr) };\n             access_shared(sharedstate, m2, 10);\n@@ -803,7 +803,7 @@ mod tests {\n         // Child wakes up parent\n         do m.lock_cond |cond| {\n             let m2 = ~m.clone();\n-            do task::spawn {\n+            do task::spawn |move m2| {\n                 do m2.lock_cond |cond| {\n                     let woken = cond.signal();\n                     assert woken;\n@@ -814,7 +814,7 @@ mod tests {\n         // Parent wakes up child\n         let (chan,port) = pipes::stream();\n         let m3 = ~m.clone();\n-        do task::spawn {\n+        do task::spawn |move chan, move m3| {\n             do m3.lock_cond |cond| {\n                 chan.send(());\n                 cond.wait();\n@@ -836,8 +836,8 @@ mod tests {\n         for num_waiters.times {\n             let mi = ~m.clone();\n             let (chan, port) = pipes::stream();\n-            ports.push(port);\n-            do task::spawn {\n+            ports.push(move port);\n+            do task::spawn |move chan, move mi| {\n                 do mi.lock_cond |cond| {\n                     chan.send(());\n                     cond.wait();\n@@ -867,7 +867,7 @@ mod tests {\n     fn test_mutex_cond_no_waiter() {\n         let m = ~Mutex();\n         let m2 = ~m.clone();\n-        do task::try {\n+        do task::try |move m| {\n             do m.lock_cond |_x| { }\n         };\n         do m2.lock_cond |cond| {\n@@ -880,7 +880,7 @@ mod tests {\n         let m = ~Mutex();\n         let m2 = ~m.clone();\n \n-        let result: result::Result<(),()> = do task::try {\n+        let result: result::Result<(),()> = do task::try |move m2| {\n             do m2.lock {\n                 fail;\n             }\n@@ -896,9 +896,9 @@ mod tests {\n         let m = ~Mutex();\n         let m2 = ~m.clone();\n \n-        let result: result::Result<(),()> = do task::try {\n+        let result: result::Result<(),()> = do task::try |move m2| {\n             let (c,p) = pipes::stream();\n-            do task::spawn { // linked\n+            do task::spawn |move p| { // linked\n                 let _ = p.recv(); // wait for sibling to get in the mutex\n                 task::yield();\n                 fail;\n@@ -921,19 +921,19 @@ mod tests {\n         let m2 = ~m.clone();\n         let (c,p) = pipes::stream();\n \n-        let result: result::Result<(),()> = do task::try {\n+        let result: result::Result<(),()> = do task::try |move c, move m2| {\n             let mut sibling_convos = ~[];\n             for 2.times {\n                 let (c,p) = pipes::stream();\n-                let c = ~mut Some(c);\n-                sibling_convos.push(p);\n+                let c = ~mut Some(move c);\n+                sibling_convos.push(move p);\n                 let mi = ~m2.clone();\n                 // spawn sibling task\n-                do task::spawn { // linked\n+                do task::spawn |move mi, move c| { // linked\n                     do mi.lock_cond |cond| {\n                         let c = option::swap_unwrap(c);\n                         c.send(()); // tell sibling to go ahead\n-                        let _z = SendOnFailure(c);\n+                        let _z = SendOnFailure(move c);\n                         cond.wait(); // block forever\n                     }\n                 }\n@@ -942,7 +942,7 @@ mod tests {\n                 let _ = p.recv(); // wait for sibling to get in the mutex\n             }\n             do m2.lock { }\n-            c.send(sibling_convos); // let parent wait on all children\n+            c.send(move sibling_convos); // let parent wait on all children\n             fail;\n         };\n         assert result.is_err();\n@@ -959,7 +959,7 @@ mod tests {\n \n         fn SendOnFailure(c: pipes::Chan<()>) -> SendOnFailure {\n             SendOnFailure {\n-                c: c\n+                c: move c\n             }\n         }\n     }\n@@ -969,7 +969,7 @@ mod tests {\n         let m = ~Mutex();\n         do m.lock_cond |cond| {\n             let m2 = ~m.clone();\n-            do task::spawn {\n+            do task::spawn |move m2| {\n                 do m2.lock_cond |cond| {\n                     cond.signal_on(0);\n                 }\n@@ -983,7 +983,7 @@ mod tests {\n             let m = ~mutex_with_condvars(2);\n             let m2 = ~m.clone();\n             let (c,p) = pipes::stream();\n-            do task::spawn {\n+            do task::spawn |move m2, move c| {\n                 do m2.lock_cond |cond| {\n                     c.send(());\n                     cond.wait_on(1);\n@@ -1032,7 +1032,7 @@ mod tests {\n                 },\n             DowngradeRead =>\n                 do x.write_downgrade |mode| {\n-                    let mode = x.downgrade(mode);\n+                    let mode = x.downgrade(move mode);\n                     (&mode).read(blk);\n                 },\n         }\n@@ -1046,7 +1046,7 @@ mod tests {\n         let x2 = ~x.clone();\n         let mut sharedstate = ~0;\n         let ptr = ptr::addr_of(&(*sharedstate));\n-        do task::spawn {\n+        do task::spawn |move c, move x2| {\n             let sharedstate: &mut int =\n                 unsafe { cast::reinterpret_cast(&ptr) };\n             access_shared(sharedstate, x2, mode1, 10);\n@@ -1089,7 +1089,7 @@ mod tests {\n         let x2 = ~x.clone();\n         let (c1,p1) = pipes::stream();\n         let (c2,p2) = pipes::stream();\n-        do task::spawn {\n+        do task::spawn |move c1, move x2, move p2| {\n             if !make_mode2_go_first {\n                 let _ = p2.recv(); // parent sends to us once it locks, or ...\n             }\n@@ -1126,10 +1126,10 @@ mod tests {\n         // Tests that downgrade can unlock the lock in both modes\n         let x = ~RWlock();\n         do lock_rwlock_in_mode(x, Downgrade) { }\n-        test_rwlock_handshake(x, Read, Read, false);\n+        test_rwlock_handshake(move x, Read, Read, false);\n         let y = ~RWlock();\n         do lock_rwlock_in_mode(y, DowngradeRead) { }\n-        test_rwlock_exclusion(y, Write, Write);\n+        test_rwlock_exclusion(move y, Write, Write);\n     }\n     #[test]\n     fn test_rwlock_read_recursive() {\n@@ -1144,7 +1144,7 @@ mod tests {\n         // Child wakes up parent\n         do x.write_cond |cond| {\n             let x2 = ~x.clone();\n-            do task::spawn {\n+            do task::spawn |move x2| {\n                 do x2.write_cond |cond| {\n                     let woken = cond.signal();\n                     assert woken;\n@@ -1155,7 +1155,7 @@ mod tests {\n         // Parent wakes up child\n         let (chan,port) = pipes::stream();\n         let x3 = ~x.clone();\n-        do task::spawn {\n+        do task::spawn |move x3, move chan| {\n             do x3.write_cond |cond| {\n                 chan.send(());\n                 cond.wait();\n@@ -1190,8 +1190,8 @@ mod tests {\n         for num_waiters.times {\n             let xi = ~x.clone();\n             let (chan, port) = pipes::stream();\n-            ports.push(port);\n-            do task::spawn {\n+            ports.push(move port);\n+            do task::spawn |move chan, move xi| {\n                 do lock_cond(xi, dg1) |cond| {\n                     chan.send(());\n                     cond.wait();\n@@ -1226,7 +1226,7 @@ mod tests {\n         let x = ~RWlock();\n         let x2 = ~x.clone();\n \n-        let result: result::Result<(),()> = do task::try {\n+        let result: result::Result<(),()> = do task::try |move x2| {\n             do lock_rwlock_in_mode(x2, mode1) {\n                 fail;\n             }\n@@ -1264,7 +1264,7 @@ mod tests {\n         let x = ~RWlock();\n         let y = ~RWlock();\n         do x.write_downgrade |xwrite| {\n-            let mut xopt = Some(xwrite);\n+            let mut xopt = Some(move xwrite);\n             do y.write_downgrade |_ywrite| {\n                 y.downgrade(option::swap_unwrap(&mut xopt));\n                 error!(\"oops, y.downgrade(x) should have failed!\");"}, {"sha": "a10997d7c3545d34c46ff9e027def0688048a5ad", "filename": "src/libstd/test.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820", "patch": "@@ -130,7 +130,7 @@ pub fn run_tests_console(opts: &TestOpts,\n                 st.failed += 1u;\n                 write_failed(st.out, st.use_color);\n                 st.out.write_line(~\"\");\n-                st.failures.push(test);\n+                st.failures.push(move test);\n               }\n               TrIgnored => {\n                 st.ignored += 1u;\n@@ -249,7 +249,7 @@ fn should_sort_failures_before_printing_them() {\n               mut passed: 0u,\n               mut failed: 0u,\n               mut ignored: 0u,\n-              mut failures: ~[test_b, test_a]};\n+              mut failures: ~[move test_b, move test_a]};\n \n         print_failures(st);\n     };\n@@ -534,9 +534,9 @@ mod tests {\n             for vec::each(names) |name| {\n                 let test = {name: *name, testfn: copy testfn, ignore: false,\n                             should_fail: false};\n-                tests.push(test);\n+                tests.push(move test);\n             }\n-            tests\n+            move tests\n         };\n         let filtered = filter_tests(&opts, tests);\n \n@@ -549,7 +549,7 @@ mod tests {\n               ~\"test::parse_ignored_flag\",\n               ~\"test::sort_tests\"];\n \n-        let pairs = vec::zip(expected, filtered);\n+        let pairs = vec::zip(expected, move filtered);\n \n         for vec::each(pairs) |p| {\n             match *p {"}, {"sha": "75909273392f4f56d4145e2e6c9cb83f562085a3", "filename": "src/libstd/time.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibstd%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibstd%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820", "patch": "@@ -595,8 +595,7 @@ pub fn strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n fn strftime(format: &str, tm: Tm) -> ~str {\n     fn parse_type(ch: char, tm: &Tm) -> ~str {\n         //FIXME (#2350): Implement missing types.\n-      let die = || #fmt(\"strftime: can't understand this format %c \",\n-                             ch);\n+      let die = || fmt!(\"strftime: can't understand this format %c \", ch);\n         match ch {\n           'A' => match tm.tm_wday as int {\n             0 => ~\"Sunday\","}, {"sha": "199fba4591444cb7f5dc99274219962a69d43578", "filename": "src/libstd/timer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibstd%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibstd%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftimer.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820", "patch": "@@ -23,7 +23,7 @@ use comm = core::comm;\n  * * ch - a channel of type T to send a `val` on\n  * * val - a value of type T to send over the provided `ch`\n  */\n-pub fn delayed_send<T: Copy Send>(iotask: IoTask,\n+pub fn delayed_send<T: Send>(iotask: IoTask,\n                                   msecs: uint, ch: comm::Chan<T>, val: T) {\n         unsafe {\n             let timer_done_po = core::comm::Port::<()>();\n@@ -55,7 +55,7 @@ pub fn delayed_send<T: Copy Send>(iotask: IoTask,\n             // delayed_send_cb has been processed by libuv\n             core::comm::recv(timer_done_po);\n             // notify the caller immediately\n-            core::comm::send(ch, copy(val));\n+            core::comm::send(ch, move(val));\n             // uv_close for this timer has been processed\n             core::comm::recv(timer_done_po);\n     };"}, {"sha": "e4b6c9b5b9a956f680cdeabc727ffc3d05c170d6", "filename": "src/libstd/treemap.rs", "status": "modified", "additions": 46, "deletions": 10, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibstd%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibstd%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftreemap.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820", "patch": "@@ -11,28 +11,28 @@ use core::cmp::{Eq, Ord};\n use core::option::{Some, None};\n use Option = core::Option;\n \n-pub type TreeMap<K, V> = @mut TreeEdge<K, V>;\n+pub type TreeMap<K: Copy Eq Ord, V: Copy> = @mut TreeEdge<K, V>;\n \n-type TreeEdge<K, V> = Option<@TreeNode<K, V>>;\n+type TreeEdge<K: Copy Eq Ord, V: Copy> = Option<@TreeNode<K, V>>;\n \n-enum TreeNode<K, V> = {\n+struct TreeNode<K: Copy Eq Ord, V: Copy> {\n     key: K,\n     mut value: V,\n     mut left: TreeEdge<K, V>,\n     mut right: TreeEdge<K, V>\n-};\n+}\n \n /// Create a treemap\n-pub fn TreeMap<K, V>() -> TreeMap<K, V> { @mut None }\n+pub fn TreeMap<K: Copy Eq Ord, V: Copy>() -> TreeMap<K, V> { @mut None }\n \n /// Insert a value into the map\n pub fn insert<K: Copy Eq Ord, V: Copy>(m: &mut TreeEdge<K, V>, k: K, v: V) {\n     match copy *m {\n       None => {\n-        *m = Some(@TreeNode({key: k,\n-                              mut value: v,\n-                              mut left: None,\n-                              mut right: None}));\n+        *m = Some(@TreeNode {key: k,\n+                             mut value: v,\n+                             mut left: None,\n+                             mut right: None});\n         return;\n       }\n       Some(node) => {\n@@ -67,7 +67,8 @@ pub fn find<K: Copy Eq Ord, V: Copy>(m: &const TreeEdge<K, V>, k: K)\n }\n \n /// Visit all pairs in the map in order.\n-pub fn traverse<K, V: Copy>(m: &const TreeEdge<K, V>, f: fn((&K), (&V))) {\n+pub fn traverse<K: Copy Eq Ord, V: Copy>(m: &const TreeEdge<K, V>,\n+                                         f: fn((&K), (&V))) {\n     match copy *m {\n       None => (),\n       Some(node) => {\n@@ -79,6 +80,19 @@ pub fn traverse<K, V: Copy>(m: &const TreeEdge<K, V>, f: fn((&K), (&V))) {\n     }\n }\n \n+/// Compare two treemaps and return true iff\n+/// they contain same keys and values\n+pub fn equals<K: Copy Eq Ord, V: Copy Eq>(t1: &const TreeEdge<K, V>,\n+                                          t2: &const TreeEdge<K, V>)\n+                                        -> bool {\n+    let mut v1 = ~[];\n+    let mut v2 = ~[];\n+    traverse(t1, |k,v| { v1.push((copy *k, copy *v)) });\n+    traverse(t2, |k,v| { v2.push((copy *k, copy *v)) });\n+    return v1 == v2;\n+}\n+\n+\n #[cfg(test)]\n mod tests {\n     #[legacy_exports];\n@@ -127,6 +141,28 @@ mod tests {\n         traverse(m, |x,y| t(n, *x, *y));\n     }\n \n+    #[test]\n+    fn equality() {\n+        let m1 = TreeMap();\n+        insert(m1, 3, ());\n+        insert(m1, 0, ());\n+        insert(m1, 4, ());\n+        insert(m1, 2, ());\n+        insert(m1, 1, ());\n+        let m2 = TreeMap();\n+        insert(m2, 2, ());\n+        insert(m2, 1, ());\n+        insert(m2, 3, ());\n+        insert(m2, 0, ());\n+        insert(m2, 4, ());\n+\n+        assert equals(m1, m2);\n+\n+        let m3 = TreeMap();\n+        assert !equals(m1,m3);\n+\n+    }\n+\n     #[test]\n     fn u8_map() {\n         let m = TreeMap();"}, {"sha": "8bf4e9ed3afc08174f1919fa935f7b8605711cb0", "filename": "src/libstd/uv_ll.rs", "status": "modified", "additions": 25, "deletions": 3, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibstd%2Fuv_ll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibstd%2Fuv_ll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_ll.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820", "patch": "@@ -590,6 +590,8 @@ extern mod rustrt {\n         -> libc::c_int;\n     fn rust_uv_ip6_name(src: *sockaddr_in6, dst: *u8, size: libc::size_t)\n         -> libc::c_int;\n+    fn rust_uv_ip4_port(src: *sockaddr_in) -> libc::c_uint;\n+    fn rust_uv_ip6_port(src: *sockaddr_in6) -> libc::c_uint;\n     // FIXME ref #2064\n     fn rust_uv_tcp_connect(connect_ptr: *uv_connect_t,\n                            tcp_handle_ptr: *uv_tcp_t,\n@@ -606,6 +608,10 @@ extern mod rustrt {\n     // FIXME ref #2064\n     fn rust_uv_tcp_bind6(tcp_server: *uv_tcp_t,\n                         ++addr: *sockaddr_in6) -> libc::c_int;\n+    fn rust_uv_tcp_getpeername(tcp_handle_ptr: *uv_tcp_t,\n+                               ++name: *sockaddr_in) -> libc::c_int;\n+    fn rust_uv_tcp_getpeername6(tcp_handle_ptr: *uv_tcp_t,\n+                                ++name: *sockaddr_in6) ->libc::c_int;\n     fn rust_uv_listen(stream: *libc::c_void, backlog: libc::c_int,\n                       cb: *u8) -> libc::c_int;\n     fn rust_uv_accept(server: *libc::c_void, client: *libc::c_void)\n@@ -736,6 +742,16 @@ pub unsafe fn tcp_bind6(tcp_server_ptr: *uv_tcp_t,\n                                  addr_ptr);\n }\n \n+pub unsafe fn tcp_getpeername(tcp_handle_ptr: *uv_tcp_t,\n+                              name: *sockaddr_in) -> libc::c_int {\n+    return rustrt::rust_uv_tcp_getpeername(tcp_handle_ptr, name);\n+}\n+\n+pub unsafe fn tcp_getpeername6(tcp_handle_ptr: *uv_tcp_t,\n+                               name: *sockaddr_in6) ->libc::c_int {\n+    return rustrt::rust_uv_tcp_getpeername6(tcp_handle_ptr, name);\n+}\n+\n pub unsafe fn listen<T>(stream: *T, backlog: libc::c_int,\n                  cb: *u8) -> libc::c_int {\n     return rustrt::rust_uv_listen(stream as *libc::c_void, backlog, cb);\n@@ -857,6 +873,12 @@ pub unsafe fn ip6_name(src: &sockaddr_in6) -> ~str {\n         }\n     }\n }\n+pub unsafe fn ip4_port(src: &sockaddr_in) -> uint {\n+    rustrt::rust_uv_ip4_port(to_unsafe_ptr(src)) as uint\n+}\n+pub unsafe fn ip6_port(src: &sockaddr_in6) -> uint {\n+    rustrt::rust_uv_ip6_port(to_unsafe_ptr(src)) as uint\n+}\n \n pub unsafe fn timer_init(loop_ptr: *libc::c_void,\n                      timer_ptr: *uv_timer_t) -> libc::c_int {\n@@ -1048,7 +1070,7 @@ pub mod test {\n                   as *request_wrapper;\n             let buf_base = get_base_from_buf(buf);\n             let buf_len = get_len_from_buf(buf);\n-            let bytes = vec::raw::from_buf(buf_base, buf_len as uint);\n+            let bytes = vec::from_buf(buf_base, buf_len as uint);\n             let read_chan = *((*client_data).read_chan);\n             let msg_from_server = str::from_bytes(bytes);\n             core::comm::send(read_chan, msg_from_server);\n@@ -1223,7 +1245,7 @@ pub mod test {\n                             buf_base as uint,\n                             buf_len as uint,\n                             nread));\n-            let bytes = vec::raw::from_buf(buf_base, buf_len);\n+            let bytes = vec::from_buf(buf_base, buf_len);\n             let request_str = str::from_bytes(bytes);\n \n             let client_data = get_data_for_uv_handle(\n@@ -1462,7 +1484,7 @@ pub mod test {\n     fn impl_uv_tcp_server_and_request() unsafe {\n         let bind_ip = ~\"0.0.0.0\";\n         let request_ip = ~\"127.0.0.1\";\n-        let port = 8887;\n+        let port = 8886;\n         let kill_server_msg = ~\"does a dog have buddha nature?\";\n         let server_resp_msg = ~\"mu!\";\n         let client_port = core::comm::Port::<~str>();"}, {"sha": "a3d2fe96b5dcbf37f2c61d6a57ed29939c1da37b", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 190, "deletions": 114, "changes": 304, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820", "patch": "@@ -1,33 +1,14 @@\n // The Rust abstract syntax tree.\n \n+use std::serialization::{Serializable,\n+                         Deserializable,\n+                         Serializer,\n+                         Deserializer};\n use codemap::{span, filename};\n-use std::serialization::{Serializer,\n-                            Deserializer,\n-                            serialize_Option,\n-                            deserialize_Option,\n-                            serialize_uint,\n-                            deserialize_uint,\n-                            serialize_int,\n-                            deserialize_int,\n-                            serialize_i64,\n-                            deserialize_i64,\n-                            serialize_u64,\n-                            deserialize_u64,\n-                            serialize_str,\n-                            deserialize_str,\n-                            serialize_bool,\n-                            deserialize_bool};\n use parse::token;\n \n-/* Note #1972 -- spans are serialized but not deserialized */\n-fn serialize_span<S>(_s: S, _v: span) {\n-}\n-\n-fn deserialize_span<D>(_d: D) -> span {\n-    ast_util::dummy_sp()\n-}\n-\n #[auto_serialize]\n+#[auto_deserialize]\n type spanned<T> = {node: T, span: span};\n \n \n@@ -42,25 +23,62 @@ macro_rules! interner_key (\n // implemented.\n struct ident { repr: uint }\n \n-fn serialize_ident<S: Serializer>(s: S, i: ident) {\n-    let intr = match unsafe{\n-        task::local_data::local_data_get(interner_key!())\n-    } {\n-        None => fail ~\"serialization: TLS interner not set up\",\n-        Some(intr) => intr\n-    };\n+#[cfg(stage0)]\n+impl ident: Serializable {\n+    fn serialize<S: Serializer>(&self, s: &S) {\n+        let intr = match unsafe {\n+            task::local_data::local_data_get(interner_key!())\n+        } {\n+            None => fail ~\"serialization: TLS interner not set up\",\n+            Some(intr) => intr\n+        };\n+\n+        s.emit_owned_str(*(*intr).get(*self));\n+    }\n+}\n+\n+#[cfg(stage0)]\n+impl ident: Deserializable {\n+    static fn deserialize<D: Deserializer>(d: &D) -> ident {\n+        let intr = match unsafe {\n+            task::local_data::local_data_get(interner_key!())\n+        } {\n+            None => fail ~\"deserialization: TLS interner not set up\",\n+            Some(intr) => intr\n+        };\n \n-    s.emit_str(*(*intr).get(i));\n+        (*intr).intern(@d.read_owned_str())\n+    }\n }\n-fn deserialize_ident<D: Deserializer>(d: D) -> ident  {\n-    let intr = match unsafe{\n-        task::local_data::local_data_get(interner_key!())\n-    } {\n-        None => fail ~\"deserialization: TLS interner not set up\",\n-        Some(intr) => intr\n-    };\n \n-    (*intr).intern(@d.read_str())\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl<S: Serializer> ident: Serializable<S> {\n+    fn serialize(&self, s: &S) {\n+        let intr = match unsafe {\n+            task::local_data::local_data_get(interner_key!())\n+        } {\n+            None => fail ~\"serialization: TLS interner not set up\",\n+            Some(intr) => intr\n+        };\n+\n+        s.emit_owned_str(*(*intr).get(*self));\n+    }\n+}\n+\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl<D: Deserializer> ident: Deserializable<D> {\n+    static fn deserialize(d: &D) -> ident {\n+        let intr = match unsafe {\n+            task::local_data::local_data_get(interner_key!())\n+        } {\n+            None => fail ~\"deserialization: TLS interner not set up\",\n+            Some(intr) => intr\n+        };\n+\n+        (*intr).intern(@d.read_owned_str())\n+    }\n }\n \n impl ident: cmp::Eq {\n@@ -75,23 +93,22 @@ impl ident: to_bytes::IterBytes {\n }\n \n // Functions may or may not have names.\n-#[auto_serialize]\n type fn_ident = Option<ident>;\n \n #[auto_serialize]\n+#[auto_deserialize]\n type path = {span: span,\n              global: bool,\n              idents: ~[ident],\n              rp: Option<@region>,\n-             types: ~[@ty]};\n+             types: ~[@Ty]};\n \n-#[auto_serialize]\n type crate_num = int;\n \n-#[auto_serialize]\n type node_id = int;\n \n #[auto_serialize]\n+#[auto_deserialize]\n type def_id = {crate: crate_num, node: node_id};\n \n impl def_id : cmp::Eq {\n@@ -105,21 +122,24 @@ const local_crate: crate_num = 0;\n const crate_node_id: node_id = 0;\n \n #[auto_serialize]\n-enum ty_param_bound {\n-    bound_copy,\n-    bound_send,\n-    bound_const,\n-    bound_owned,\n-    bound_trait(@ty),\n-}\n+#[auto_deserialize]\n+// The AST represents all type param bounds as types.\n+// typeck::collect::compute_bounds matches these against\n+// the \"special\" built-in traits (see middle::lang_items) and\n+// detects Copy, Send, Owned, and Const.\n+enum ty_param_bound = @Ty;\n \n #[auto_serialize]\n+#[auto_deserialize]\n type ty_param = {ident: ident, id: node_id, bounds: @~[ty_param_bound]};\n \n #[auto_serialize]\n+#[auto_deserialize]\n enum def {\n     def_fn(def_id, purity),\n-    def_static_method(def_id, purity),\n+    def_static_method(/* method */ def_id,\n+                      /* trait */  Option<def_id>,\n+                      purity),\n     def_self(node_id),\n     def_mod(def_id),\n     def_foreign_mod(def_id),\n@@ -136,7 +156,7 @@ enum def {\n               @def,     // closed over def\n               node_id,  // expr node that creates the closure\n               node_id), // id for the block/body of the closure expr\n-    def_class(def_id, bool /* has constructor */),\n+    def_class(def_id),\n     def_typaram_binder(node_id), /* class, impl or trait that has ty params */\n     def_region(node_id),\n     def_label(node_id)\n@@ -151,9 +171,10 @@ impl def : cmp::Eq {\n                     _ => false\n                 }\n             }\n-            def_static_method(e0a, e1a) => {\n+            def_static_method(e0a, e1a, e2a) => {\n                 match (*other) {\n-                    def_static_method(e0b, e1b) => e0a == e0b && e1a == e1b,\n+                    def_static_method(e0b, e1b, e2b) =>\n+                    e0a == e0b && e1a == e1b && e2a == e2b,\n                     _ => false\n                 }\n             }\n@@ -236,9 +257,9 @@ impl def : cmp::Eq {\n                     _ => false\n                 }\n             }\n-            def_class(e0a, e1a) => {\n+            def_class(e0a) => {\n                 match (*other) {\n-                    def_class(e0b, e1b) => e0a == e0b && e1a == e1b,\n+                    def_class(e0b) => e0a == e0b,\n                     _ => false\n                 }\n             }\n@@ -293,33 +314,36 @@ enum crate_directive_ {\n \n type crate_directive = spanned<crate_directive_>;\n \n-#[auto_serialize]\n type meta_item = spanned<meta_item_>;\n \n #[auto_serialize]\n+#[auto_deserialize]\n enum meta_item_ {\n     meta_word(~str),\n     meta_list(~str, ~[@meta_item]),\n     meta_name_value(~str, lit),\n }\n \n-#[auto_serialize]\n type blk = spanned<blk_>;\n \n #[auto_serialize]\n+#[auto_deserialize]\n type blk_ = {view_items: ~[@view_item],\n              stmts: ~[@stmt],\n              expr: Option<@expr>,\n              id: node_id,\n              rules: blk_check_mode};\n \n #[auto_serialize]\n+#[auto_deserialize]\n type pat = {id: node_id, node: pat_, span: span};\n \n #[auto_serialize]\n+#[auto_deserialize]\n type field_pat = {ident: ident, pat: @pat};\n \n #[auto_serialize]\n+#[auto_deserialize]\n enum binding_mode {\n     bind_by_value,\n     bind_by_move,\n@@ -376,6 +400,7 @@ impl binding_mode : cmp::Eq {\n }\n \n #[auto_serialize]\n+#[auto_deserialize]\n enum pat_ {\n     pat_wild,\n     // A pat_ident may either be a new bound variable,\n@@ -399,6 +424,7 @@ enum pat_ {\n }\n \n #[auto_serialize]\n+#[auto_deserialize]\n enum mutability { m_mutbl, m_imm, m_const, }\n \n impl mutability : to_bytes::IterBytes {\n@@ -415,6 +441,7 @@ impl mutability : cmp::Eq {\n }\n \n #[auto_serialize]\n+#[auto_deserialize]\n enum proto {\n     proto_bare,    // foreign fn\n     proto_uniq,    // fn~\n@@ -430,18 +457,20 @@ impl proto : cmp::Eq {\n }\n \n #[auto_serialize]\n+#[auto_deserialize]\n enum vstore {\n-    // FIXME (#2112): Change uint to @expr (actually only constant exprs)\n-    vstore_fixed(Option<uint>),   // [1,2,3,4]/_ or 4\n+    // FIXME (#3469): Change uint to @expr (actually only constant exprs)\n+    vstore_fixed(Option<uint>),   // [1,2,3,4]\n     vstore_uniq,                  // ~[1,2,3,4]\n     vstore_box,                   // @[1,2,3,4]\n     vstore_slice(@region)         // &[1,2,3,4](foo)?\n }\n \n #[auto_serialize]\n+#[auto_deserialize]\n enum expr_vstore {\n-    // FIXME (#2112): Change uint to @expr (actually only constant exprs)\n-    expr_vstore_fixed(Option<uint>),   // [1,2,3,4]/_ or 4\n+    // FIXME (#3469): Change uint to @expr (actually only constant exprs)\n+    expr_vstore_fixed(Option<uint>),   // [1,2,3,4]\n     expr_vstore_uniq,                  // ~[1,2,3,4]\n     expr_vstore_box,                   // @[1,2,3,4]\n     expr_vstore_slice                  // &[1,2,3,4]\n@@ -455,6 +484,7 @@ pure fn is_blockish(p: ast::proto) -> bool {\n }\n \n #[auto_serialize]\n+#[auto_deserialize]\n enum binop {\n     add,\n     subtract,\n@@ -484,6 +514,7 @@ impl binop : cmp::Eq {\n }\n \n #[auto_serialize]\n+#[auto_deserialize]\n enum unop {\n     box(mutability),\n     uniq(mutability),\n@@ -535,6 +566,7 @@ impl unop : cmp::Eq {\n // Generally, after typeck you can get the inferred value\n // using ty::resolved_T(...).\n #[auto_serialize]\n+#[auto_deserialize]\n enum inferable<T> {\n     expl(T),\n     infer(node_id)\n@@ -574,6 +606,7 @@ impl<T:cmp::Eq> inferable<T> : cmp::Eq {\n \n // \"resolved\" mode: the real modes.\n #[auto_serialize]\n+#[auto_deserialize]\n enum rmode { by_ref, by_val, by_move, by_copy }\n \n impl rmode : to_bytes::IterBytes {\n@@ -591,13 +624,12 @@ impl rmode : cmp::Eq {\n }\n \n // inferable mode.\n-#[auto_serialize]\n type mode = inferable<rmode>;\n \n-#[auto_serialize]\n type stmt = spanned<stmt_>;\n \n #[auto_serialize]\n+#[auto_deserialize]\n enum stmt_ {\n     stmt_decl(@decl, node_id),\n \n@@ -609,6 +641,7 @@ enum stmt_ {\n }\n \n #[auto_serialize]\n+#[auto_deserialize]\n enum init_op { init_assign, init_move, }\n \n impl init_op : cmp::Eq {\n@@ -632,33 +665,36 @@ impl init_op : cmp::Eq {\n }\n \n #[auto_serialize]\n+#[auto_deserialize]\n type initializer = {op: init_op, expr: @expr};\n \n // FIXME (pending discussion of #1697, #2178...): local should really be\n // a refinement on pat.\n #[auto_serialize]\n-type local_ =  {is_mutbl: bool, ty: @ty, pat: @pat,\n+#[auto_deserialize]\n+type local_ =  {is_mutbl: bool, ty: @Ty, pat: @pat,\n                 init: Option<initializer>, id: node_id};\n \n-#[auto_serialize]\n type local = spanned<local_>;\n \n-#[auto_serialize]\n type decl = spanned<decl_>;\n \n #[auto_serialize]\n+#[auto_deserialize]\n enum decl_ { decl_local(~[@local]), decl_item(@item), }\n \n #[auto_serialize]\n+#[auto_deserialize]\n type arm = {pats: ~[@pat], guard: Option<@expr>, body: blk};\n \n #[auto_serialize]\n+#[auto_deserialize]\n type field_ = {mutbl: mutability, ident: ident, expr: @expr};\n \n-#[auto_serialize]\n type field = spanned<field_>;\n \n #[auto_serialize]\n+#[auto_deserialize]\n enum blk_check_mode { default_blk, unsafe_blk, }\n \n impl blk_check_mode : cmp::Eq {\n@@ -674,17 +710,17 @@ impl blk_check_mode : cmp::Eq {\n }\n \n #[auto_serialize]\n+#[auto_deserialize]\n type expr = {id: node_id, callee_id: node_id, node: expr_, span: span};\n // Extra node ID is only used for index, assign_op, unary, binary\n \n #[auto_serialize]\n+#[auto_deserialize]\n enum log_level { error, debug, other }\n // 0 = error, 1 = debug, 2 = other\n \n #[auto_serialize]\n-enum alt_mode { alt_check, alt_exhaustive, }\n-\n-#[auto_serialize]\n+#[auto_deserialize]\n enum expr_ {\n     expr_vstore(@expr, expr_vstore),\n     expr_vec(~[@expr], mutability),\n@@ -694,7 +730,7 @@ enum expr_ {\n     expr_binary(binop, @expr, @expr),\n     expr_unary(unop, @expr),\n     expr_lit(@lit),\n-    expr_cast(@expr, @ty),\n+    expr_cast(@expr, @Ty),\n     expr_if(@expr, blk, Option<@expr>),\n     expr_while(@expr, blk),\n     /* Conditionless loop (can be exited with break, cont, ret, or fail)\n@@ -718,7 +754,7 @@ enum expr_ {\n     expr_assign(@expr, @expr),\n     expr_swap(@expr, @expr),\n     expr_assign_op(binop, @expr, @expr),\n-    expr_field(@expr, ident, ~[@ty]),\n+    expr_field(@expr, ident, ~[@Ty]),\n     expr_index(@expr, @expr),\n     expr_path(@path),\n     expr_addr_of(mutability, @expr),\n@@ -741,14 +777,16 @@ enum expr_ {\n }\n \n #[auto_serialize]\n-type capture_item = @{\n+#[auto_deserialize]\n+type capture_item_ = {\n     id: int,\n     is_move: bool,\n     name: ident, // Currently, can only capture a local var.\n     span: span\n };\n \n-#[auto_serialize]\n+type capture_item = @capture_item_;\n+\n type capture_clause = @~[capture_item];\n \n //\n@@ -768,12 +806,13 @@ type capture_clause = @~[capture_item];\n // error.\n //\n #[auto_serialize]\n+#[auto_deserialize]\n #[doc=\"For macro invocations; parsing is delegated to the macro\"]\n enum token_tree {\n-    tt_tok(span, token::token),\n+    tt_tok(span, token::Token),\n     tt_delim(~[token_tree]),\n     // These only make sense for right-hand-sides of MBE macros\n-    tt_seq(span, ~[token_tree], Option<token::token>, bool),\n+    tt_seq(span, ~[token_tree], Option<token::Token>, bool),\n     tt_nonterminal(span, ident)\n }\n \n@@ -829,33 +868,32 @@ enum token_tree {\n // If you understand that, you have closed to loop and understand the whole\n // macro system. Congratulations.\n //\n-#[auto_serialize]\n type matcher = spanned<matcher_>;\n \n #[auto_serialize]\n+#[auto_deserialize]\n enum matcher_ {\n     // match one token\n-    match_tok(token::token),\n+    match_tok(token::Token),\n     // match repetitions of a sequence: body, separator, zero ok?,\n     // lo, hi position-in-match-array used:\n-    match_seq(~[matcher], Option<token::token>, bool, uint, uint),\n+    match_seq(~[matcher], Option<token::Token>, bool, uint, uint),\n     // parse a Rust NT: name to bind, name of NT, position in match array:\n     match_nonterminal(ident, ident, uint)\n }\n \n-#[auto_serialize]\n type mac = spanned<mac_>;\n \n-#[auto_serialize]\n type mac_arg = Option<@expr>;\n \n #[auto_serialize]\n+#[auto_deserialize]\n type mac_body_ = {span: span};\n \n-#[auto_serialize]\n type mac_body = Option<mac_body_>;\n \n #[auto_serialize]\n+#[auto_deserialize]\n enum mac_ {\n     mac_invoc(@path, mac_arg, mac_body), // old macro-invocation\n     mac_invoc_tt(@path,~[token_tree]),   // new macro-invocation\n@@ -866,10 +904,10 @@ enum mac_ {\n     mac_var(uint)\n }\n \n-#[auto_serialize]\n type lit = spanned<lit_>;\n \n #[auto_serialize]\n+#[auto_deserialize]\n enum lit_ {\n     lit_str(@~str),\n     lit_int(i64, int_ty),\n@@ -911,20 +949,23 @@ impl ast::lit_: cmp::Eq {\n // NB: If you change this, you'll probably want to change the corresponding\n // type structure in middle/ty.rs as well.\n #[auto_serialize]\n-type mt = {ty: @ty, mutbl: mutability};\n+#[auto_deserialize]\n+type mt = {ty: @Ty, mutbl: mutability};\n \n #[auto_serialize]\n+#[auto_deserialize]\n type ty_field_ = {ident: ident, mt: mt};\n \n-#[auto_serialize]\n type ty_field = spanned<ty_field_>;\n \n #[auto_serialize]\n+#[auto_deserialize]\n type ty_method = {ident: ident, attrs: ~[attribute], purity: purity,\n                   decl: fn_decl, tps: ~[ty_param], self_ty: self_ty,\n                   id: node_id, span: span};\n \n #[auto_serialize]\n+#[auto_deserialize]\n // A trait method is either required (meaning it doesn't have an\n // implementation, just a signature) or provided (meaning it has a default\n // implementation).\n@@ -934,6 +975,7 @@ enum trait_method {\n }\n \n #[auto_serialize]\n+#[auto_deserialize]\n enum int_ty { ty_i, ty_char, ty_i8, ty_i16, ty_i32, ty_i64, }\n \n impl int_ty : to_bytes::IterBytes {\n@@ -963,6 +1005,7 @@ impl int_ty : cmp::Eq {\n }\n \n #[auto_serialize]\n+#[auto_deserialize]\n enum uint_ty { ty_u, ty_u8, ty_u16, ty_u32, ty_u64, }\n \n impl uint_ty : to_bytes::IterBytes {\n@@ -990,6 +1033,7 @@ impl uint_ty : cmp::Eq {\n }\n \n #[auto_serialize]\n+#[auto_deserialize]\n enum float_ty { ty_f, ty_f32, ty_f64, }\n \n impl float_ty : to_bytes::IterBytes {\n@@ -1008,10 +1052,12 @@ impl float_ty : cmp::Eq {\n }\n \n #[auto_serialize]\n-type ty = {id: node_id, node: ty_, span: span};\n+#[auto_deserialize]\n+type Ty = {id: node_id, node: ty_, span: span};\n \n // Not represented directly in the AST, referred to by name through a ty_path.\n #[auto_serialize]\n+#[auto_deserialize]\n enum prim_ty {\n     ty_int(int_ty),\n     ty_uint(uint_ty),\n@@ -1059,9 +1105,11 @@ impl prim_ty : cmp::Eq {\n }\n \n #[auto_serialize]\n+#[auto_deserialize]\n type region = {id: node_id, node: region_};\n \n #[auto_serialize]\n+#[auto_deserialize]\n enum region_ {\n     re_anon,\n     re_static,\n@@ -1070,6 +1118,7 @@ enum region_ {\n }\n \n #[auto_serialize]\n+#[auto_deserialize]\n enum ty_ {\n     ty_nil,\n     ty_bot, /* bottom type */\n@@ -1080,9 +1129,9 @@ enum ty_ {\n     ty_rptr(@region, mt),\n     ty_rec(~[ty_field]),\n     ty_fn(proto, purity, @~[ty_param_bound], fn_decl),\n-    ty_tup(~[@ty]),\n+    ty_tup(~[@Ty]),\n     ty_path(@path, node_id),\n-    ty_fixed_length(@ty, Option<uint>),\n+    ty_fixed_length(@Ty, Option<uint>),\n     ty_mac(mac),\n     // ty_infer means the type should be inferred instead of it having been\n     // specified. This should only appear at the \"top level\" of a type and not\n@@ -1092,32 +1141,35 @@ enum ty_ {\n \n // Equality and byte-iter (hashing) can be quite approximate for AST types.\n // since we only care about this for normalizing them to \"real\" types.\n-impl ty : cmp::Eq {\n-    pure fn eq(other: &ty) -> bool {\n+impl Ty : cmp::Eq {\n+    pure fn eq(other: &Ty) -> bool {\n         ptr::addr_of(&self) == ptr::addr_of(&(*other))\n     }\n-    pure fn ne(other: &ty) -> bool {\n+    pure fn ne(other: &Ty) -> bool {\n         ptr::addr_of(&self) != ptr::addr_of(&(*other))\n     }\n }\n \n-impl ty : to_bytes::IterBytes {\n+impl Ty : to_bytes::IterBytes {\n     pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_2(&self.span.lo, &self.span.hi, lsb0, f);\n     }\n }\n \n \n #[auto_serialize]\n-type arg = {mode: mode, ty: @ty, ident: ident, id: node_id};\n+#[auto_deserialize]\n+type arg = {mode: mode, ty: @Ty, ident: ident, id: node_id};\n \n #[auto_serialize]\n+#[auto_deserialize]\n type fn_decl =\n     {inputs: ~[arg],\n-     output: @ty,\n+     output: @Ty,\n      cf: ret_style};\n \n #[auto_serialize]\n+#[auto_deserialize]\n enum purity {\n     pure_fn, // declared with \"pure fn\"\n     unsafe_fn, // declared with \"unsafe fn\"\n@@ -1139,6 +1191,7 @@ impl purity : cmp::Eq {\n }\n \n #[auto_serialize]\n+#[auto_deserialize]\n enum ret_style {\n     noreturn, // functions with return type _|_ that always\n               // raise an error or exit (i.e. never return to the caller)\n@@ -1164,6 +1217,7 @@ impl ret_style : cmp::Eq {\n }\n \n #[auto_serialize]\n+#[auto_deserialize]\n enum self_ty_ {\n     sty_static,                         // no self: static method\n     sty_by_ref,                         // old by-reference self: ``\n@@ -1217,20 +1271,22 @@ impl self_ty_ : cmp::Eq {\n     pure fn ne(other: &self_ty_) -> bool { !self.eq(other) }\n }\n \n-#[auto_serialize]\n type self_ty = spanned<self_ty_>;\n \n #[auto_serialize]\n+#[auto_deserialize]\n type method = {ident: ident, attrs: ~[attribute],\n                tps: ~[ty_param], self_ty: self_ty,\n                purity: purity, decl: fn_decl, body: blk,\n                id: node_id, span: span, self_id: node_id,\n                vis: visibility};\n \n #[auto_serialize]\n+#[auto_deserialize]\n type _mod = {view_items: ~[@view_item], items: ~[@item]};\n \n #[auto_serialize]\n+#[auto_deserialize]\n enum foreign_abi {\n     foreign_abi_rust_intrinsic,\n     foreign_abi_cdecl,\n@@ -1239,6 +1295,7 @@ enum foreign_abi {\n \n // Foreign mods can be named or anonymous\n #[auto_serialize]\n+#[auto_deserialize]\n enum foreign_mod_sort { named, anonymous }\n \n impl foreign_mod_sort : cmp::Eq {\n@@ -1263,38 +1320,47 @@ impl foreign_abi : cmp::Eq {\n }\n \n #[auto_serialize]\n+#[auto_deserialize]\n type foreign_mod =\n     {sort: foreign_mod_sort,\n      view_items: ~[@view_item],\n      items: ~[@foreign_item]};\n \n #[auto_serialize]\n-type variant_arg = {ty: @ty, id: node_id};\n+#[auto_deserialize]\n+type variant_arg = {ty: @Ty, id: node_id};\n \n #[auto_serialize]\n+#[auto_deserialize]\n enum variant_kind {\n     tuple_variant_kind(~[variant_arg]),\n     struct_variant_kind(@struct_def),\n     enum_variant_kind(enum_def)\n }\n \n #[auto_serialize]\n-enum enum_def = { variants: ~[variant], common: Option<@struct_def> };\n+#[auto_deserialize]\n+type enum_def_ = { variants: ~[variant], common: Option<@struct_def> };\n+\n+#[auto_serialize]\n+#[auto_deserialize]\n+enum enum_def = enum_def_;\n \n #[auto_serialize]\n+#[auto_deserialize]\n type variant_ = {name: ident, attrs: ~[attribute], kind: variant_kind,\n                  id: node_id, disr_expr: Option<@expr>, vis: visibility};\n \n-#[auto_serialize]\n type variant = spanned<variant_>;\n \n #[auto_serialize]\n+#[auto_deserialize]\n type path_list_ident_ = {name: ident, id: node_id};\n \n-#[auto_serialize]\n type path_list_ident = spanned<path_list_ident_>;\n \n #[auto_serialize]\n+#[auto_deserialize]\n enum namespace { module_ns, type_value_ns }\n \n impl namespace : cmp::Eq {\n@@ -1304,10 +1370,10 @@ impl namespace : cmp::Eq {\n     pure fn ne(other: &namespace) -> bool { !self.eq(other) }\n }\n \n-#[auto_serialize]\n type view_path = spanned<view_path_>;\n \n #[auto_serialize]\n+#[auto_deserialize]\n enum view_path_ {\n \n     // quux = foo::bar::baz\n@@ -1325,24 +1391,26 @@ enum view_path_ {\n }\n \n #[auto_serialize]\n+#[auto_deserialize]\n type view_item = {node: view_item_, attrs: ~[attribute],\n                   vis: visibility, span: span};\n \n #[auto_serialize]\n+#[auto_deserialize]\n enum view_item_ {\n     view_item_use(ident, ~[@meta_item], node_id),\n     view_item_import(~[@view_path]),\n     view_item_export(~[@view_path])\n }\n \n // Meta-data associated with an item\n-#[auto_serialize]\n type attribute = spanned<attribute_>;\n \n // Distinguishes between attributes that decorate items and attributes that\n // are contained as statements within items. These two cases need to be\n // distinguished for pretty-printing.\n #[auto_serialize]\n+#[auto_deserialize]\n enum attr_style { attr_outer, attr_inner, }\n \n impl attr_style : cmp::Eq {\n@@ -1354,6 +1422,7 @@ impl attr_style : cmp::Eq {\n \n // doc-comments are promoted to attributes that have is_sugared_doc = true\n #[auto_serialize]\n+#[auto_deserialize]\n type attribute_ = {style: attr_style, value: meta_item, is_sugared_doc: bool};\n \n /*\n@@ -1366,9 +1435,11 @@ type attribute_ = {style: attr_style, value: meta_item, is_sugared_doc: bool};\n   trait)\n  */\n #[auto_serialize]\n+#[auto_deserialize]\n type trait_ref = {path: @path, ref_id: node_id, impl_id: node_id};\n \n #[auto_serialize]\n+#[auto_deserialize]\n enum visibility { public, private, inherited }\n \n impl visibility : cmp::Eq {\n@@ -1386,29 +1457,29 @@ impl visibility : cmp::Eq {\n }\n \n #[auto_serialize]\n+#[auto_deserialize]\n type struct_field_ = {\n     kind: struct_field_kind,\n     id: node_id,\n-    ty: @ty\n+    ty: @Ty\n };\n \n-#[auto_serialize]\n type struct_field = spanned<struct_field_>;\n \n #[auto_serialize]\n+#[auto_deserialize]\n enum struct_field_kind {\n     named_field(ident, class_mutability, visibility),\n     unnamed_field   // element of a tuple-like struct\n }\n \n #[auto_serialize]\n+#[auto_deserialize]\n type struct_def = {\n     traits: ~[@trait_ref],   /* traits this struct implements */\n     fields: ~[@struct_field], /* fields */\n     methods: ~[@method],    /* methods */\n     /* (not including ctor or dtor) */\n-    /* ctor is optional, and will soon go away */\n-    ctor: Option<class_ctor>,\n     /* dtor is optional */\n     dtor: Option<class_dtor>\n };\n@@ -1418,28 +1489,31 @@ type struct_def = {\n   we just use dummy names for anon items.\n  */\n #[auto_serialize]\n+#[auto_deserialize]\n type item = {ident: ident, attrs: ~[attribute],\n              id: node_id, node: item_,\n              vis: visibility, span: span};\n \n #[auto_serialize]\n+#[auto_deserialize]\n enum item_ {\n-    item_const(@ty, @expr),\n+    item_const(@Ty, @expr),\n     item_fn(fn_decl, purity, ~[ty_param], blk),\n     item_mod(_mod),\n     item_foreign_mod(foreign_mod),\n-    item_ty(@ty, ~[ty_param]),\n+    item_ty(@Ty, ~[ty_param]),\n     item_enum(enum_def, ~[ty_param]),\n     item_class(@struct_def, ~[ty_param]),\n     item_trait(~[ty_param], ~[@trait_ref], ~[trait_method]),\n     item_impl(~[ty_param],\n               Option<@trait_ref>, /* (optional) trait this impl implements */\n-              @ty, /* self */\n+              @Ty, /* self */\n               ~[@method]),\n     item_mac(mac),\n }\n \n #[auto_serialize]\n+#[auto_deserialize]\n enum class_mutability { class_mutable, class_immutable }\n \n impl class_mutability : to_bytes::IterBytes {\n@@ -1460,26 +1534,27 @@ impl class_mutability : cmp::Eq {\n     pure fn ne(other: &class_mutability) -> bool { !self.eq(other) }\n }\n \n-#[auto_serialize]\n type class_ctor = spanned<class_ctor_>;\n \n #[auto_serialize]\n+#[auto_deserialize]\n type class_ctor_ = {id: node_id,\n                     attrs: ~[attribute],\n                     self_id: node_id,\n                     dec: fn_decl,\n                     body: blk};\n \n-#[auto_serialize]\n type class_dtor = spanned<class_dtor_>;\n \n #[auto_serialize]\n+#[auto_deserialize]\n type class_dtor_ = {id: node_id,\n                     attrs: ~[attribute],\n                     self_id: node_id,\n                     body: blk};\n \n #[auto_serialize]\n+#[auto_deserialize]\n type foreign_item =\n     {ident: ident,\n      attrs: ~[attribute],\n@@ -1489,20 +1564,21 @@ type foreign_item =\n      vis: visibility};\n \n #[auto_serialize]\n+#[auto_deserialize]\n enum foreign_item_ {\n     foreign_item_fn(fn_decl, purity, ~[ty_param]),\n-    foreign_item_const(@ty)\n+    foreign_item_const(@Ty)\n }\n \n // The data we save and restore about an inlined item or method.  This is not\n // part of the AST that we parse from a file, but it becomes part of the tree\n // that we trans.\n #[auto_serialize]\n+#[auto_deserialize]\n enum inlined_item {\n     ii_item(@item),\n     ii_method(def_id /* impl id */, @method),\n     ii_foreign(@foreign_item),\n-    ii_ctor(class_ctor, ident, ~[ty_param], def_id /* parent id */),\n     ii_dtor(class_dtor, ident, ~[ty_param], def_id /* parent id */)\n }\n "}, {"sha": "8555ceed2dbd62c0923c17e2e25e074d8c68f4ed", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 1, "deletions": 19, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820", "patch": "@@ -71,9 +71,6 @@ enum ast_node {\n     // order they are introduced.\n     node_arg(arg, uint),\n     node_local(uint),\n-    // Constructor for a class\n-    // def_id is parent id\n-    node_ctor(ident, ~[ty_param], @class_ctor, def_id, @path),\n     // Destructor for a class\n     node_dtor(~[ty_param], @class_dtor, def_id, @path),\n     node_block(blk),\n@@ -132,7 +129,7 @@ fn map_decoded_item(diag: span_handler,\n     // don't decode and instantiate the impl, but just the method, we have to\n     // add it to the table now:\n     match ii {\n-      ii_item(*) | ii_ctor(*) | ii_dtor(*) => { /* fallthrough */ }\n+      ii_item(*) | ii_dtor(*) => { /* fallthrough */ }\n       ii_foreign(i) => {\n         cx.map.insert(i.id, node_foreign_item(i, foreign_abi_rust_intrinsic,\n                                              @path));\n@@ -155,18 +152,6 @@ fn map_fn(fk: visit::fn_kind, decl: fn_decl, body: blk,\n         cx.local_id += 1u;\n     }\n     match fk {\n-      visit::fk_ctor(nm, attrs, tps, self_id, parent_id) => {\n-          let ct = @{node: {id: id,\n-                            attrs: attrs,\n-                            self_id: self_id,\n-                            dec: /* FIXME (#2543) */ copy decl,\n-                            body: /* FIXME (#2543) */ copy body},\n-                    span: sp};\n-          cx.map.insert(id, node_ctor(/* FIXME (#2543) */ copy nm,\n-                                      /* FIXME (#2543) */ copy tps,\n-                                      ct, parent_id,\n-                                      @/* FIXME (#2543) */ copy cx.path));\n-      }\n       visit::fk_dtor(tps, attrs, self_id, parent_id) => {\n           let dt = @{node: {id: id, attrs: attrs, self_id: self_id,\n                      body: /* FIXME (#2543) */ copy body}, span: sp};\n@@ -382,9 +367,6 @@ fn node_id_to_str(map: map, id: node_id, itr: @ident_interner) -> ~str {\n       Some(node_local(_)) => { // add more info here\n         fmt!(\"local (id=%?)\", id)\n       }\n-      Some(node_ctor(*)) => { // add more info here\n-        fmt!(\"node_ctor (id=%?)\", id)\n-      }\n       Some(node_dtor(*)) => { // add more info here\n         fmt!(\"node_dtor (id=%?)\", id)\n       }"}, {"sha": "6fd84c3317f72abf55b0a234aa9be80ca0c5d255", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 4, "deletions": 15, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820", "patch": "@@ -54,10 +54,10 @@ fn variant_def_ids(d: def) -> {enm: def_id, var: def_id} {\n \n pure fn def_id_of_def(d: def) -> def_id {\n     match d {\n-      def_fn(id, _) | def_static_method(id, _) | def_mod(id) |\n+      def_fn(id, _) | def_static_method(id, _, _) | def_mod(id) |\n       def_foreign_mod(id) | def_const(id) |\n       def_variant(_, id) | def_ty(id) | def_ty_param(id, _) |\n-      def_use(id) | def_class(id, _) => {\n+      def_use(id) | def_class(id) => {\n         id\n       }\n       def_arg(id, _) | def_local(id, _) | def_self(id) |\n@@ -233,7 +233,6 @@ fn is_exported(i: ident, m: _mod) -> bool {\n                     }\n                   }\n \n-                  // FIXME: glob-exports aren't supported yet. (#2006)\n                   _ => ()\n                 }\n             }\n@@ -339,7 +338,6 @@ impl inlined_item: inlined_item_utils {\n           ii_item(i) => /* FIXME (#2543) */ copy i.ident,\n           ii_foreign(i) => /* FIXME (#2543) */ copy i.ident,\n           ii_method(_, m) => /* FIXME (#2543) */ copy m.ident,\n-          ii_ctor(_, nm, _, _) => /* FIXME (#2543) */ copy nm,\n           ii_dtor(_, nm, _, _) => /* FIXME (#2543) */ copy nm\n         }\n     }\n@@ -349,7 +347,6 @@ impl inlined_item: inlined_item_utils {\n           ii_item(i) => i.id,\n           ii_foreign(i) => i.id,\n           ii_method(_, m) => m.id,\n-          ii_ctor(ctor, _, _, _) => ctor.node.id,\n           ii_dtor(dtor, _, _, _) => dtor.node.id\n         }\n     }\n@@ -359,9 +356,6 @@ impl inlined_item: inlined_item_utils {\n           ii_item(i) => v.visit_item(i, e, v),\n           ii_foreign(i) => v.visit_foreign_item(i, e, v),\n           ii_method(_, m) => visit::visit_method_helper(m, e, v),\n-          ii_ctor(ctor, nm, tps, parent_id) => {\n-              visit::visit_class_ctor_helper(ctor, nm, tps, parent_id, e, v);\n-          }\n           ii_dtor(dtor, _, tps, parent_id) => {\n               visit::visit_class_dtor_helper(dtor, tps, parent_id, e, v);\n           }\n@@ -407,6 +401,7 @@ fn dtor_dec() -> fn_decl {\n // Enumerating the IDs which appear in an AST\n \n #[auto_serialize]\n+#[auto_deserialize]\n type id_range = {min: node_id, max: node_id};\n \n fn empty(range: id_range) -> bool {\n@@ -476,7 +471,7 @@ fn id_visitor(vfn: fn@(node_id)) -> visit::vt<()> {\n         visit_expr_post: fn@(_e: @expr) {\n         },\n \n-        visit_ty: fn@(t: @ty) {\n+        visit_ty: fn@(t: @Ty) {\n             match t.node {\n               ty_path(_, id) => vfn(id),\n               _ => { /* fall through */ }\n@@ -494,12 +489,6 @@ fn id_visitor(vfn: fn@(node_id)) -> visit::vt<()> {\n             vfn(id);\n \n             match fk {\n-                visit::fk_ctor(_, _, tps, self_id, parent_id) => {\n-                    for vec::each(tps) |tp| { vfn(tp.id); }\n-                    vfn(id);\n-                    vfn(self_id);\n-                    vfn(parent_id.node);\n-                }\n                 visit::fk_dtor(tps, _, self_id, parent_id) => {\n                     for vec::each(tps) |tp| { vfn(tp.id); }\n                     vfn(id);"}, {"sha": "8c19814350ca72cee6b300415df4b5b36cc3e448", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820", "patch": "@@ -90,9 +90,7 @@ fn attr_meta(attr: ast::attribute) -> @ast::meta_item { @attr.node.value }\n \n // Get the meta_items from inside a vector of attributes\n fn attr_metas(attrs: ~[ast::attribute]) -> ~[@ast::meta_item] {\n-    let mut mitems = ~[];\n-    for attrs.each |a| { mitems.push(attr_meta(*a)); }\n-    return mitems;\n+    do attrs.map |a| { attr_meta(*a) }\n }\n \n fn desugar_doc_attr(attr: &ast::attribute) -> ast::attribute {"}, {"sha": "69a80d0bac13a628d609a097357dd3a58f1503f6", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 50, "deletions": 18, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820", "patch": "@@ -1,4 +1,8 @@\n use dvec::DVec;\n+use std::serialization::{Serializable,\n+                         Deserializable,\n+                         Serializer,\n+                         Deserializer};\n \n export filename;\n export filemap;\n@@ -7,7 +11,7 @@ export file_substr;\n export fss_none;\n export fss_internal;\n export fss_external;\n-export codemap;\n+export CodeMap;\n export expn_info;\n export expn_info_;\n export expanded_from;\n@@ -55,11 +59,11 @@ type filemap =\n     @{name: filename, substr: file_substr, src: @~str,\n       start_pos: file_pos, mut lines: ~[file_pos]};\n \n-type codemap = @{files: DVec<filemap>};\n+type CodeMap = @{files: DVec<filemap>};\n \n type loc = {file: filemap, line: uint, col: uint};\n \n-fn new_codemap() -> codemap { @{files: DVec()} }\n+fn new_codemap() -> CodeMap { @{files: DVec()} }\n \n fn new_filemap_w_substr(+filename: filename, +substr: file_substr,\n                         src: @~str,\n@@ -77,7 +81,7 @@ fn new_filemap(+filename: filename, src: @~str,\n                              start_pos_ch, start_pos_byte);\n }\n \n-fn mk_substr_filename(cm: codemap, sp: span) -> ~str\n+fn mk_substr_filename(cm: CodeMap, sp: span) -> ~str\n {\n     let pos = lookup_char_pos(cm, sp.lo);\n     return fmt!(\"<%s:%u:%u>\", pos.file.name, pos.line, pos.col);\n@@ -89,7 +93,7 @@ fn next_line(file: filemap, chpos: uint, byte_pos: uint) {\n \n type lookup_fn = pure fn(file_pos) -> uint;\n \n-fn lookup_line(map: codemap, pos: uint, lookup: lookup_fn)\n+fn lookup_line(map: CodeMap, pos: uint, lookup: lookup_fn)\n     -> {fm: filemap, line: uint}\n {\n     let len = map.files.len();\n@@ -112,22 +116,22 @@ fn lookup_line(map: codemap, pos: uint, lookup: lookup_fn)\n     return {fm: f, line: a};\n }\n \n-fn lookup_pos(map: codemap, pos: uint, lookup: lookup_fn) -> loc {\n+fn lookup_pos(map: CodeMap, pos: uint, lookup: lookup_fn) -> loc {\n     let {fm: f, line: a} = lookup_line(map, pos, lookup);\n     return {file: f, line: a + 1u, col: pos - lookup(f.lines[a])};\n }\n \n-fn lookup_char_pos(map: codemap, pos: uint) -> loc {\n+fn lookup_char_pos(map: CodeMap, pos: uint) -> loc {\n     pure fn lookup(pos: file_pos) -> uint { return pos.ch; }\n     return lookup_pos(map, pos, lookup);\n }\n \n-fn lookup_byte_pos(map: codemap, pos: uint) -> loc {\n+fn lookup_byte_pos(map: CodeMap, pos: uint) -> loc {\n     pure fn lookup(pos: file_pos) -> uint { return pos.byte; }\n     return lookup_pos(map, pos, lookup);\n }\n \n-fn lookup_char_pos_adj(map: codemap, pos: uint)\n+fn lookup_char_pos_adj(map: CodeMap, pos: uint)\n     -> {filename: ~str, line: uint, col: uint, file: Option<filemap>}\n {\n     let loc = lookup_char_pos(map, pos);\n@@ -150,7 +154,7 @@ fn lookup_char_pos_adj(map: codemap, pos: uint)\n     }\n }\n \n-fn adjust_span(map: codemap, sp: span) -> span {\n+fn adjust_span(map: CodeMap, sp: span) -> span {\n     pure fn lookup(pos: file_pos) -> uint { return pos.ch; }\n     let line = lookup_line(map, sp.lo, lookup);\n     match (line.fm.substr) {\n@@ -178,14 +182,42 @@ impl span : cmp::Eq {\n     pure fn ne(other: &span) -> bool { !self.eq(other) }\n }\n \n-fn span_to_str_no_adj(sp: span, cm: codemap) -> ~str {\n+#[cfg(stage0)]\n+impl span: Serializable {\n+    /* Note #1972 -- spans are serialized but not deserialized */\n+    fn serialize<S: Serializer>(&self, _s: &S) { }\n+}\n+\n+#[cfg(stage0)]\n+impl span: Deserializable {\n+    static fn deserialize<D: Deserializer>(_d: &D) -> span {\n+        ast_util::dummy_sp()\n+    }\n+}\n+\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl<S: Serializer> span: Serializable<S> {\n+    /* Note #1972 -- spans are serialized but not deserialized */\n+    fn serialize(&self, _s: &S) { }\n+}\n+\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+impl<D: Deserializer> span: Deserializable<D> {\n+    static fn deserialize(_d: &D) -> span {\n+        ast_util::dummy_sp()\n+    }\n+}\n+\n+fn span_to_str_no_adj(sp: span, cm: CodeMap) -> ~str {\n     let lo = lookup_char_pos(cm, sp.lo);\n     let hi = lookup_char_pos(cm, sp.hi);\n     return fmt!(\"%s:%u:%u: %u:%u\", lo.file.name,\n              lo.line, lo.col, hi.line, hi.col)\n }\n \n-fn span_to_str(sp: span, cm: codemap) -> ~str {\n+fn span_to_str(sp: span, cm: CodeMap) -> ~str {\n     let lo = lookup_char_pos_adj(cm, sp.lo);\n     let hi = lookup_char_pos_adj(cm, sp.hi);\n     return fmt!(\"%s:%u:%u: %u:%u\", lo.filename,\n@@ -194,12 +226,12 @@ fn span_to_str(sp: span, cm: codemap) -> ~str {\n \n type file_lines = {file: filemap, lines: ~[uint]};\n \n-fn span_to_filename(sp: span, cm: codemap::codemap) -> filename {\n+fn span_to_filename(sp: span, cm: codemap::CodeMap) -> filename {\n     let lo = lookup_char_pos(cm, sp.lo);\n     return /* FIXME (#2543) */ copy lo.file.name;\n }\n \n-fn span_to_lines(sp: span, cm: codemap::codemap) -> @file_lines {\n+fn span_to_lines(sp: span, cm: codemap::CodeMap) -> @file_lines {\n     let lo = lookup_char_pos(cm, sp.lo);\n     let hi = lookup_char_pos(cm, sp.hi);\n     let mut lines = ~[];\n@@ -218,7 +250,7 @@ fn get_line(fm: filemap, line: int) -> ~str unsafe {\n     str::slice(*fm.src, begin, end)\n }\n \n-fn lookup_byte_offset(cm: codemap::codemap, chpos: uint)\n+fn lookup_byte_offset(cm: codemap::CodeMap, chpos: uint)\n     -> {fm: filemap, pos: uint} {\n     pure fn lookup(pos: file_pos) -> uint { return pos.ch; }\n     let {fm, line} = lookup_line(cm, chpos, lookup);\n@@ -228,20 +260,20 @@ fn lookup_byte_offset(cm: codemap::codemap, chpos: uint)\n     {fm: fm, pos: line_offset + col_offset}\n }\n \n-fn span_to_snippet(sp: span, cm: codemap::codemap) -> ~str {\n+fn span_to_snippet(sp: span, cm: codemap::CodeMap) -> ~str {\n     let begin = lookup_byte_offset(cm, sp.lo);\n     let end = lookup_byte_offset(cm, sp.hi);\n     assert begin.fm.start_pos == end.fm.start_pos;\n     return str::slice(*begin.fm.src, begin.pos, end.pos);\n }\n \n-fn get_snippet(cm: codemap::codemap, fidx: uint, lo: uint, hi: uint) -> ~str\n+fn get_snippet(cm: codemap::CodeMap, fidx: uint, lo: uint, hi: uint) -> ~str\n {\n     let fm = cm.files[fidx];\n     return str::slice(*fm.src, lo, hi)\n }\n \n-fn get_filemap(cm: codemap, filename: ~str) -> filemap {\n+fn get_filemap(cm: CodeMap, filename: ~str) -> filemap {\n     for cm.files.each |fm| { if fm.name == filename { return *fm; } }\n     //XXjdm the following triggers a mismatched type bug\n     //      (or expected function, found _|_)"}, {"sha": "855b0ca3ef56879a3c17e6c266dfbf91e9b9f0ad", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820", "patch": "@@ -9,7 +9,7 @@ export codemap_span_handler, codemap_handler;\n export ice_msg;\n export expect;\n \n-type emitter = fn@(cmsp: Option<(codemap::codemap, span)>,\n+type emitter = fn@(cmsp: Option<(codemap::CodeMap, span)>,\n                    msg: &str, lvl: level);\n \n \n@@ -33,7 +33,7 @@ trait handler {\n     fn note(msg: &str);\n     fn bug(msg: &str) -> !;\n     fn unimpl(msg: &str) -> !;\n-    fn emit(cmsp: Option<(codemap::codemap, span)>, msg: &str, lvl: level);\n+    fn emit(cmsp: Option<(codemap::CodeMap, span)>, msg: &str, lvl: level);\n }\n \n type handler_t = @{\n@@ -43,7 +43,7 @@ type handler_t = @{\n \n type codemap_t = @{\n     handler: handler,\n-    cm: codemap::codemap\n+    cm: codemap::CodeMap\n };\n \n impl codemap_t: span_handler {\n@@ -107,7 +107,7 @@ impl handler_t: handler {\n         self.fatal(ice_msg(msg));\n     }\n     fn unimpl(msg: &str) -> ! { self.bug(~\"unimplemented \" + msg); }\n-    fn emit(cmsp: Option<(codemap::codemap, span)>, msg: &str, lvl: level) {\n+    fn emit(cmsp: Option<(codemap::CodeMap, span)>, msg: &str, lvl: level) {\n         self.emit(cmsp, msg, lvl);\n     }\n }\n@@ -116,7 +116,7 @@ fn ice_msg(msg: &str) -> ~str {\n     fmt!(\"internal compiler error: %s\", msg)\n }\n \n-fn mk_span_handler(handler: handler, cm: codemap::codemap) -> span_handler {\n+fn mk_span_handler(handler: handler, cm: codemap::CodeMap) -> span_handler {\n     @{ handler: handler, cm: cm } as span_handler\n }\n \n@@ -125,7 +125,7 @@ fn mk_handler(emitter: Option<emitter>) -> handler {\n     let emit = match emitter {\n       Some(e) => e,\n       None => {\n-        let f = fn@(cmsp: Option<(codemap::codemap, span)>,\n+        let f = fn@(cmsp: Option<(codemap::CodeMap, span)>,\n             msg: &str, t: level) {\n             emit(cmsp, msg, t);\n         };\n@@ -189,8 +189,7 @@ fn print_diagnostic(topic: ~str, lvl: level, msg: &str) {\n     io::stderr().write_str(fmt!(\" %s\\n\", msg));\n }\n \n-fn emit(cmsp: Option<(codemap::codemap, span)>,\n-        msg: &str, lvl: level) {\n+fn emit(cmsp: Option<(codemap::CodeMap, span)>, msg: &str, lvl: level) {\n     match cmsp {\n       Some((cm, sp)) => {\n         let sp = codemap::adjust_span(cm,sp);\n@@ -206,7 +205,7 @@ fn emit(cmsp: Option<(codemap::codemap, span)>,\n     }\n }\n \n-fn highlight_lines(cm: codemap::codemap, sp: span,\n+fn highlight_lines(cm: codemap::CodeMap, sp: span,\n                    lines: @codemap::file_lines) {\n \n     let fm = lines.file;\n@@ -261,12 +260,12 @@ fn highlight_lines(cm: codemap::codemap, sp: span,\n     }\n }\n \n-fn print_macro_backtrace(cm: codemap::codemap, sp: span) {\n+fn print_macro_backtrace(cm: codemap::CodeMap, sp: span) {\n     do option::iter(&sp.expn_info) |ei| {\n         let ss = option::map_default(&ei.callie.span, @~\"\",\n                                      |span| @codemap::span_to_str(*span, cm));\n         print_diagnostic(*ss, note,\n-                         fmt!(\"in expansion of #%s\", ei.callie.name));\n+                         fmt!(\"in expansion of %s!\", ei.callie.name));\n         let ss = codemap::span_to_str(ei.call_site, cm);\n         print_diagnostic(ss, note, ~\"expansion site\");\n         print_macro_backtrace(cm, ei.call_site);"}, {"sha": "47e61c26f38d2c4b5c7e442ece0b47b94898fb39", "filename": "src/libsyntax/ext/auto_serialize.rs", "status": "modified", "additions": 952, "deletions": 779, "changes": 1731, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibsyntax%2Fext%2Fauto_serialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibsyntax%2Fext%2Fauto_serialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_serialize.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820", "patch": "@@ -1,62 +1,70 @@\n /*\n \n-The compiler code necessary to implement the #[auto_serialize]\n-extension.  The idea here is that type-defining items may be tagged\n-with #[auto_serialize], which will cause us to generate a little\n-companion module with the same name as the item.\n+The compiler code necessary to implement the #[auto_serialize] and\n+#[auto_deserialize] extension.  The idea here is that type-defining items may\n+be tagged with #[auto_serialize] and #[auto_deserialize], which will cause\n+us to generate a little companion module with the same name as the item.\n \n For example, a type like:\n \n-    type node_id = uint;\n+    #[auto_serialize]\n+    #[auto_deserialize]\n+    struct Node {id: uint}\n \n-would generate two functions like:\n+would generate two implementations like:\n \n-    fn serialize_node_id<S: serializer>(s: S, v: node_id) {\n-        s.emit_uint(v);\n+    impl<S: Serializer> node_id: Serializable<S> {\n+        fn serialize(s: &S) {\n+            do s.emit_struct(\"Node\") {\n+                s.emit_field(\"id\", 0, || s.emit_uint(self))\n+            }\n+        }\n     }\n-    fn deserialize_node_id<D: deserializer>(d: D) -> node_id {\n-        d.read_uint()\n+\n+    impl<D: Deserializer> node_id: Deserializable {\n+        static fn deserialize(d: &D) -> Node {\n+            do d.read_struct(\"Node\") {\n+                Node {\n+                    id: d.read_field(~\"x\", 0, || deserialize(d))\n+                }\n+            }\n+        }\n     }\n \n Other interesting scenarios are whe the item has type parameters or\n references other non-built-in types.  A type definition like:\n \n+    #[auto_serialize]\n+    #[auto_deserialize]\n     type spanned<T> = {node: T, span: span};\n \n would yield functions like:\n \n-    fn serialize_spanned<S: serializer,T>(s: S, v: spanned<T>, t: fn(T)) {\n-         s.emit_rec(2u) {||\n-             s.emit_rec_field(\"node\", 0u) {||\n-                 t(s.node);\n-             };\n-             s.emit_rec_field(\"span\", 1u) {||\n-                 serialize_span(s, s.span);\n-             };\n-         }\n-    }\n-    fn deserialize_spanned<D: deserializer>(d: D, t: fn() -> T) -> node_id {\n-         d.read_rec(2u) {||\n-             {node: d.read_rec_field(\"node\", 0u, t),\n-              span: d.read_rec_field(\"span\", 1u) {||deserialize_span(d)}}\n-         }\n+    impl<\n+        S: Serializer,\n+        T: Serializable<S>\n+    > spanned<T>: Serializable<S> {\n+        fn serialize<S: Serializer>(s: &S) {\n+            do s.emit_rec {\n+                s.emit_field(\"node\", 0, || self.node.serialize(s));\n+                s.emit_field(\"span\", 1, || self.span.serialize(s));\n+            }\n+        }\n     }\n \n-In general, the code to serialize an instance `v` of a non-built-in\n-type a::b::c<T0,...,Tn> looks like:\n-\n-    a::b::serialize_c(s, {|v| c_T0}, ..., {|v| c_Tn}, v)\n-\n-where `c_Ti` is the code to serialize an instance `v` of the type\n-`Ti`.\n-\n-Similarly, the code to deserialize an instance of a non-built-in type\n-`a::b::c<T0,...,Tn>` using the deserializer `d` looks like:\n-\n-    a::b::deserialize_c(d, {|| c_T0}, ..., {|| c_Tn})\n-\n-where `c_Ti` is the code to deserialize an instance of `Ti` using the\n-deserializer `d`.\n+    impl<\n+        D: Deserializer,\n+        T: Deserializable<D>\n+    > spanned<T>: Deserializable<D> {\n+        static fn deserialize(d: &D) -> spanned<T> {\n+            do d.read_rec {\n+                {\n+                    node: d.read_field(~\"node\", 0, || deserialize(d)),\n+                    span: d.read_field(~\"span\", 1, || deserialize(d)),\n+                }\n+            }\n+        }\n+    }\n \n FIXME (#2810)--Hygiene. Search for \"__\" strings.  We also assume \"std\" is the\n standard library.\n@@ -69,164 +77,188 @@ into the tree.  This is intended to prevent us from inserting the same\n node twice.\n \n */\n+\n use base::*;\n use codemap::span;\n use std::map;\n use std::map::HashMap;\n \n-export expand;\n+export expand_auto_serialize;\n+export expand_auto_deserialize;\n \n // Transitional reexports so qquote can find the paths it is looking for\n mod syntax {\n-    #[legacy_exports];\n     pub use ext;\n     pub use parse;\n }\n \n-type ser_tps_map = map::HashMap<ast::ident, fn@(@ast::expr) -> ~[@ast::stmt]>;\n-type deser_tps_map = map::HashMap<ast::ident, fn@() -> @ast::expr>;\n-\n-fn expand(cx: ext_ctxt,\n-          span: span,\n-          _mitem: ast::meta_item,\n-          in_items: ~[@ast::item]) -> ~[@ast::item] {\n-    fn not_auto_serialize(a: &ast::attribute) -> bool {\n-        attr::get_attr_name(*a) != ~\"auto_serialize\"\n+fn expand_auto_serialize(\n+    cx: ext_ctxt,\n+    span: span,\n+    _mitem: ast::meta_item,\n+    in_items: ~[@ast::item]\n+) -> ~[@ast::item] {\n+    fn is_auto_serialize(a: &ast::attribute) -> bool {\n+        attr::get_attr_name(*a) == ~\"auto_serialize\"\n     }\n \n     fn filter_attrs(item: @ast::item) -> @ast::item {\n-        @{attrs: vec::filter(item.attrs, not_auto_serialize),\n+        @{attrs: vec::filter(item.attrs, |a| !is_auto_serialize(a)),\n           .. *item}\n     }\n \n-    do vec::flat_map(in_items) |in_item| {\n-        match in_item.node {\n-          ast::item_ty(ty, tps) => {\n-            vec::append(~[filter_attrs(*in_item)],\n-                        ty_fns(cx, in_item.ident, ty, tps))\n-          }\n-\n-          ast::item_enum(enum_definition, tps) => {\n-            vec::append(~[filter_attrs(*in_item)],\n-                        enum_fns(cx, in_item.ident,\n-                                 in_item.span, enum_definition.variants, tps))\n-          }\n-\n-          _ => {\n-            cx.span_err(span, ~\"#[auto_serialize] can only be \\\n-                               applied to type and enum \\\n-                               definitions\");\n-            ~[*in_item]\n-          }\n+    do vec::flat_map(in_items) |item| {\n+        if item.attrs.any(is_auto_serialize) {\n+            match item.node {\n+                ast::item_ty(@{node: ast::ty_rec(fields), _}, tps) => {\n+                    let ser_impl = mk_rec_ser_impl(\n+                        cx,\n+                        item.span,\n+                        item.ident,\n+                        fields,\n+                        tps\n+                    );\n+\n+                    ~[filter_attrs(*item), ser_impl]\n+                },\n+                ast::item_class(@{ fields, _}, tps) => {\n+                    let ser_impl = mk_struct_ser_impl(\n+                        cx,\n+                        item.span,\n+                        item.ident,\n+                        fields,\n+                        tps\n+                    );\n+\n+                    ~[filter_attrs(*item), ser_impl]\n+                },\n+                ast::item_enum(enum_def, tps) => {\n+                    let ser_impl = mk_enum_ser_impl(\n+                        cx,\n+                        item.span,\n+                        item.ident,\n+                        enum_def,\n+                        tps\n+                    );\n+\n+                    ~[filter_attrs(*item), ser_impl]\n+                },\n+                _ => {\n+                    cx.span_err(span, ~\"#[auto_serialize] can only be \\\n+                                        applied to structs, record types, \\\n+                                        and enum definitions\");\n+                    ~[*item]\n+                }\n+            }\n+        } else {\n+            ~[*item]\n         }\n     }\n }\n \n-trait ext_ctxt_helpers {\n-    fn helper_path(base_path: @ast::path, helper_name: ~str) -> @ast::path;\n-    fn path(span: span, strs: ~[ast::ident]) -> @ast::path;\n-    fn path_tps(span: span, strs: ~[ast::ident],\n-                tps: ~[@ast::ty]) -> @ast::path;\n-    fn ty_path(span: span, strs: ~[ast::ident], tps: ~[@ast::ty]) -> @ast::ty;\n-    fn ty_fn(span: span,\n-             -input_tys: ~[@ast::ty],\n-             -output: @ast::ty) -> @ast::ty;\n-    fn ty_nil(span: span) -> @ast::ty;\n-    fn expr(span: span, node: ast::expr_) -> @ast::expr;\n-    fn var_ref(span: span, name: ast::ident) -> @ast::expr;\n-    fn blk(span: span, stmts: ~[@ast::stmt]) -> ast::blk;\n-    fn expr_blk(expr: @ast::expr) -> ast::blk;\n-    fn binder_pat(span: span, nm: ast::ident) -> @ast::pat;\n-    fn stmt(expr: @ast::expr) -> @ast::stmt;\n-    fn alt_stmt(arms: ~[ast::arm], span: span, -v: @ast::expr) -> @ast::stmt;\n-    fn lit_str(span: span, s: @~str) -> @ast::expr;\n-    fn lit_uint(span: span, i: uint) -> @ast::expr;\n-    fn lambda(blk: ast::blk) -> @ast::expr;\n-    fn clone_folder() -> fold::ast_fold;\n-    fn clone(v: @ast::expr) -> @ast::expr;\n-    fn clone_ty(v: @ast::ty) -> @ast::ty;\n-    fn clone_ty_param(v: ast::ty_param) -> ast::ty_param;\n-    fn at(span: span, expr: @ast::expr) -> @ast::expr;\n-}\n-\n-impl ext_ctxt: ext_ctxt_helpers {\n-    fn helper_path(base_path: @ast::path,\n-                   helper_name: ~str) -> @ast::path {\n-        let head = vec::init(base_path.idents);\n-        let tail = vec::last(base_path.idents);\n-        self.path(base_path.span,\n-                  vec::append(head,\n-                              ~[self.parse_sess().interner.\n-                                intern(@(helper_name + ~\"_\" +\n-                                         *self.parse_sess().interner.get(\n-                                             tail)))]))\n+fn expand_auto_deserialize(\n+    cx: ext_ctxt,\n+    span: span,\n+    _mitem: ast::meta_item,\n+    in_items: ~[@ast::item]\n+) -> ~[@ast::item] {\n+    fn is_auto_deserialize(a: &ast::attribute) -> bool {\n+        attr::get_attr_name(*a) == ~\"auto_deserialize\"\n     }\n \n-    fn path(span: span, strs: ~[ast::ident]) -> @ast::path {\n-        @{span: span, global: false, idents: strs, rp: None, types: ~[]}\n-    }\n-\n-    fn path_tps(span: span, strs: ~[ast::ident],\n-                tps: ~[@ast::ty]) -> @ast::path {\n-        @{span: span, global: false, idents: strs, rp: None, types: tps}\n+    fn filter_attrs(item: @ast::item) -> @ast::item {\n+        @{attrs: vec::filter(item.attrs, |a| !is_auto_deserialize(a)),\n+          .. *item}\n     }\n \n-    fn ty_path(span: span, strs: ~[ast::ident],\n-               tps: ~[@ast::ty]) -> @ast::ty {\n-        @{id: self.next_id(),\n-          node: ast::ty_path(self.path_tps(span, strs, tps), self.next_id()),\n-          span: span}\n+    do vec::flat_map(in_items) |item| {\n+        if item.attrs.any(is_auto_deserialize) {\n+            match item.node {\n+                ast::item_ty(@{node: ast::ty_rec(fields), _}, tps) => {\n+                    let deser_impl = mk_rec_deser_impl(\n+                        cx,\n+                        item.span,\n+                        item.ident,\n+                        fields,\n+                        tps\n+                    );\n+\n+                    ~[filter_attrs(*item), deser_impl]\n+                },\n+                ast::item_class(@{ fields, _}, tps) => {\n+                    let deser_impl = mk_struct_deser_impl(\n+                        cx,\n+                        item.span,\n+                        item.ident,\n+                        fields,\n+                        tps\n+                    );\n+\n+                    ~[filter_attrs(*item), deser_impl]\n+                },\n+                ast::item_enum(enum_def, tps) => {\n+                    let deser_impl = mk_enum_deser_impl(\n+                        cx,\n+                        item.span,\n+                        item.ident,\n+                        enum_def,\n+                        tps\n+                    );\n+\n+                    ~[filter_attrs(*item), deser_impl]\n+                },\n+                _ => {\n+                    cx.span_err(span, ~\"#[auto_deserialize] can only be \\\n+                                        applied to structs, record types, \\\n+                                        and enum definitions\");\n+                    ~[*item]\n+                }\n+            }\n+        } else {\n+            ~[*item]\n+        }\n     }\n+}\n \n-    fn ty_fn(span: span,\n-             -input_tys: ~[@ast::ty],\n-             -output: @ast::ty) -> @ast::ty {\n-        let args = do vec::map(input_tys) |ty| {\n-            {mode: ast::expl(ast::by_ref),\n-             ty: *ty,\n-             ident: parse::token::special_idents::invalid,\n-             id: self.next_id()}\n-        };\n-\n-        @{id: self.next_id(),\n-          node: ast::ty_fn(ast::proto_block,\n-                           ast::impure_fn,\n-                           @~[],\n-                           {inputs: args,\n-                            output: output,\n-                            cf: ast::return_val}),\n-          span: span}\n-    }\n+priv impl ext_ctxt {\n+    fn bind_path(\n+        span: span,\n+        ident: ast::ident,\n+        path: @ast::path,\n+        bounds: @~[ast::ty_param_bound]\n+    ) -> ast::ty_param {\n+        let bound = ast::ty_param_bound(@{\n+            id: self.next_id(),\n+            node: ast::ty_path(path, self.next_id()),\n+            span: span,\n+        });\n \n-    fn ty_nil(span: span) -> @ast::ty {\n-        @{id: self.next_id(), node: ast::ty_nil, span: span}\n+        {\n+            ident: ident,\n+            id: self.next_id(),\n+            bounds: @vec::append(~[bound], *bounds)\n+        }\n     }\n \n     fn expr(span: span, node: ast::expr_) -> @ast::expr {\n         @{id: self.next_id(), callee_id: self.next_id(),\n           node: node, span: span}\n     }\n \n-    fn var_ref(span: span, name: ast::ident) -> @ast::expr {\n-        self.expr(span, ast::expr_path(self.path(span, ~[name])))\n+    fn path(span: span, strs: ~[ast::ident]) -> @ast::path {\n+        @{span: span, global: false, idents: strs, rp: None, types: ~[]}\n     }\n \n-    fn blk(span: span, stmts: ~[@ast::stmt]) -> ast::blk {\n-        {node: {view_items: ~[],\n-                stmts: stmts,\n-                expr: None,\n-                id: self.next_id(),\n-                rules: ast::default_blk},\n-         span: span}\n+    fn path_tps(span: span, strs: ~[ast::ident],\n+                tps: ~[@ast::Ty]) -> @ast::path {\n+        @{span: span, global: false, idents: strs, rp: None, types: tps}\n     }\n \n-    fn expr_blk(expr: @ast::expr) -> ast::blk {\n-        {node: {view_items: ~[],\n-                stmts: ~[],\n-                expr: Some(expr),\n-                id: self.next_id(),\n-                rules: ast::default_blk},\n-         span: expr.span}\n+    fn ty_path(span: span, strs: ~[ast::ident],\n+               tps: ~[@ast::Ty]) -> @ast::Ty {\n+        @{id: self.next_id(),\n+          node: ast::ty_path(self.path_tps(span, strs, tps), self.next_id()),\n+          span: span}\n     }\n \n     fn binder_pat(span: span, nm: ast::ident) -> @ast::pat {\n@@ -244,14 +276,6 @@ impl ext_ctxt: ext_ctxt_helpers {\n           span: expr.span}\n     }\n \n-    fn alt_stmt(arms: ~[ast::arm],\n-                span: span, -v: @ast::expr) -> @ast::stmt {\n-        self.stmt(\n-            self.expr(\n-                span,\n-                ast::expr_match(v, arms)))\n-    }\n-\n     fn lit_str(span: span, s: @~str) -> @ast::expr {\n         self.expr(\n             span,\n@@ -278,686 +302,835 @@ impl ext_ctxt: ext_ctxt_helpers {\n         #ast{ || $(blk_e) }\n     }\n \n-    fn clone_folder() -> fold::ast_fold {\n-        fold::make_fold(@{\n-            new_id: |_id| self.next_id(),\n-            .. *fold::default_ast_fold()\n-        })\n+    fn blk(span: span, stmts: ~[@ast::stmt]) -> ast::blk {\n+        {node: {view_items: ~[],\n+                stmts: stmts,\n+                expr: None,\n+                id: self.next_id(),\n+                rules: ast::default_blk},\n+         span: span}\n     }\n \n-    fn clone(v: @ast::expr) -> @ast::expr {\n-        let fld = self.clone_folder();\n-        fld.fold_expr(v)\n+    fn expr_blk(expr: @ast::expr) -> ast::blk {\n+        {node: {view_items: ~[],\n+                stmts: ~[],\n+                expr: Some(expr),\n+                id: self.next_id(),\n+                rules: ast::default_blk},\n+         span: expr.span}\n     }\n \n-    fn clone_ty(v: @ast::ty) -> @ast::ty {\n-        let fld = self.clone_folder();\n-        fld.fold_ty(v)\n+    fn expr_path(span: span, strs: ~[ast::ident]) -> @ast::expr {\n+        self.expr(span, ast::expr_path(self.path(span, strs)))\n     }\n \n-    fn clone_ty_param(v: ast::ty_param) -> ast::ty_param {\n-        let fld = self.clone_folder();\n-        fold::fold_ty_param(v, fld)\n+    fn expr_var(span: span, var: ~str) -> @ast::expr {\n+        self.expr_path(span, ~[self.ident_of(var)])\n     }\n \n-    fn at(span: span, expr: @ast::expr) -> @ast::expr {\n-        fn repl_sp(old_span: span, repl_span: span, with_span: span) -> span {\n-            if old_span == repl_span {\n-                with_span\n-            } else {\n-                old_span\n-            }\n-        }\n-\n-        let fld = fold::make_fold(@{\n-            new_span: |a| repl_sp(a, ast_util::dummy_sp(), span),\n-            .. *fold::default_ast_fold()\n-        });\n+    fn expr_field(\n+        span: span,\n+        expr: @ast::expr,\n+        ident: ast::ident\n+    ) -> @ast::expr {\n+        self.expr(span, ast::expr_field(expr, ident, ~[]))\n+    }\n \n-        fld.fold_expr(expr)\n+    fn expr_call(\n+        span: span,\n+        expr: @ast::expr,\n+        args: ~[@ast::expr]\n+    ) -> @ast::expr {\n+        self.expr(span, ast::expr_call(expr, args, false))\n     }\n-}\n \n-fn ser_path(cx: ext_ctxt, tps: ser_tps_map, path: @ast::path,\n-                  -s: @ast::expr, -v: @ast::expr)\n-    -> ~[@ast::stmt] {\n-    let ext_cx = cx; // required for #ast{}\n-\n-    // We want to take a path like a::b::c<...> and generate a call\n-    // like a::b::c::serialize(s, ...), as described above.\n-\n-    let callee =\n-        cx.expr(\n-            path.span,\n-            ast::expr_path(\n-                cx.helper_path(path, ~\"serialize\")));\n-\n-    let ty_args = do vec::map(path.types) |ty| {\n-        let sv_stmts = ser_ty(cx, tps, *ty, cx.clone(s), #ast{ __v });\n-        let sv = cx.expr(path.span,\n-                         ast::expr_block(cx.blk(path.span, sv_stmts)));\n-        cx.at(ty.span, #ast{ |__v| $(sv) })\n-    };\n+    fn lambda_expr(expr: @ast::expr) -> @ast::expr {\n+        self.lambda(self.expr_blk(expr))\n+    }\n \n-    ~[cx.stmt(\n-        cx.expr(\n-            path.span,\n-            ast::expr_call(callee, vec::append(~[s, v], ty_args), false)))]\n+    fn lambda_stmts(span: span, stmts: ~[@ast::stmt]) -> @ast::expr {\n+        self.lambda(self.blk(span, stmts))\n+    }\n }\n \n-fn ser_variant(cx: ext_ctxt,\n-               tps: ser_tps_map,\n-               tys: ~[@ast::ty],\n-               span: span,\n-               -s: @ast::expr,\n-               pfn: fn(~[@ast::pat]) -> ast::pat_,\n-               bodyfn: fn(-v: @ast::expr, ast::blk) -> @ast::expr,\n-               argfn: fn(-v: @ast::expr, uint, ast::blk) -> @ast::expr)\n-    -> ast::arm {\n-    let vnames = do vec::from_fn(vec::len(tys)) |i| {\n-        cx.parse_sess().interner.intern(@fmt!(\"__v%u\", i))\n-    };\n-    let pats = do vec::from_fn(vec::len(tys)) |i| {\n-        cx.binder_pat(tys[i].span, vnames[i])\n-    };\n-    let pat: @ast::pat = @{id: cx.next_id(), node: pfn(pats), span: span};\n-    let stmts = do vec::from_fn(vec::len(tys)) |i| {\n-        let v = cx.var_ref(span, vnames[i]);\n-        let arg_blk =\n-            cx.blk(\n-                span,\n-                ser_ty(cx, tps, tys[i], cx.clone(s), move v));\n-        cx.stmt(argfn(cx.clone(s), i, arg_blk))\n-    };\n-\n-    let body_blk = cx.blk(span, stmts);\n-    let body = cx.blk(span, ~[cx.stmt(bodyfn(move s, body_blk))]);\n+fn mk_impl(\n+    cx: ext_ctxt,\n+    span: span,\n+    ident: ast::ident,\n+    ty_param: ast::ty_param,\n+    path: @ast::path,\n+    tps: ~[ast::ty_param],\n+    f: fn(@ast::Ty) -> @ast::method\n+) -> @ast::item {\n+    // All the type parameters need to bound to the trait.\n+    let mut trait_tps = vec::append(\n+        ~[ty_param],\n+         do tps.map |tp| {\n+            let t_bound = ast::ty_param_bound(@{\n+                id: cx.next_id(),\n+                node: ast::ty_path(path, cx.next_id()),\n+                span: span,\n+            });\n \n-    {pats: ~[pat], guard: None, body: body}\n+            {\n+                ident: tp.ident,\n+                id: cx.next_id(),\n+                bounds: @vec::append(~[t_bound], *tp.bounds)\n+            }\n+        }\n+    );\n+\n+    let opt_trait = Some(@{\n+        path: path,\n+        ref_id: cx.next_id(),\n+        impl_id: cx.next_id(),\n+    });\n+\n+    let ty = cx.ty_path(\n+        span,\n+        ~[ident],\n+        tps.map(|tp| cx.ty_path(span, ~[tp.ident], ~[]))\n+    );\n+\n+    @{\n+        // This is a new-style impl declaration.\n+        // XXX: clownshoes\n+        ident: ast::token::special_idents::clownshoes_extensions,\n+        attrs: ~[],\n+        id: cx.next_id(),\n+        node: ast::item_impl(trait_tps, opt_trait, ty, ~[f(ty)]),\n+        vis: ast::public,\n+        span: span,\n+    }\n }\n \n-fn ser_lambda(cx: ext_ctxt, tps: ser_tps_map, ty: @ast::ty,\n-              -s: @ast::expr, -v: @ast::expr) -> @ast::expr {\n-    cx.lambda(cx.blk(ty.span, ser_ty(cx, tps, ty, move s, move v)))\n+fn mk_ser_impl(\n+    cx: ext_ctxt,\n+    span: span,\n+    ident: ast::ident,\n+    tps: ~[ast::ty_param],\n+    body: @ast::expr\n+) -> @ast::item {\n+    // Make a path to the std::serialization::Serializable typaram.\n+    let ty_param = cx.bind_path(\n+        span,\n+        cx.ident_of(~\"__S\"),\n+        cx.path(\n+            span,\n+            ~[\n+                cx.ident_of(~\"std\"),\n+                cx.ident_of(~\"serialization\"),\n+                cx.ident_of(~\"Serializer\"),\n+            ]\n+        ),\n+        @~[]\n+    );\n+\n+    // Make a path to the std::serialization::Serializable trait.\n+    let path = cx.path_tps(\n+        span,\n+        ~[\n+            cx.ident_of(~\"std\"),\n+            cx.ident_of(~\"serialization\"),\n+            cx.ident_of(~\"Serializable\"),\n+        ],\n+        ~[cx.ty_path(span, ~[cx.ident_of(~\"__S\")], ~[])]\n+    );\n+\n+    mk_impl(\n+        cx,\n+        span,\n+        ident,\n+        ty_param,\n+        path,\n+        tps,\n+        |_ty| mk_ser_method(cx, span, cx.expr_blk(body))\n+    )\n }\n \n-fn is_vec_or_str(ty: @ast::ty) -> bool {\n-    match ty.node {\n-      ast::ty_vec(_) => true,\n-      // This may be wrong if the user has shadowed (!) str\n-      ast::ty_path(@{span: _, global: _, idents: ids,\n-                             rp: None, types: _}, _)\n-      if ids == ~[parse::token::special_idents::str] => true,\n-      _ => false\n-    }\n+fn mk_deser_impl(\n+    cx: ext_ctxt,\n+    span: span,\n+    ident: ast::ident,\n+    tps: ~[ast::ty_param],\n+    body: @ast::expr\n+) -> @ast::item {\n+    // Make a path to the std::serialization::Deserializable typaram.\n+    let ty_param = cx.bind_path(\n+        span,\n+        cx.ident_of(~\"__D\"),\n+        cx.path(\n+            span,\n+            ~[\n+                cx.ident_of(~\"std\"),\n+                cx.ident_of(~\"serialization\"),\n+                cx.ident_of(~\"Deserializer\"),\n+            ]\n+        ),\n+        @~[]\n+    );\n+\n+    // Make a path to the std::serialization::Deserializable trait.\n+    let path = cx.path_tps(\n+        span,\n+        ~[\n+            cx.ident_of(~\"std\"),\n+            cx.ident_of(~\"serialization\"),\n+            cx.ident_of(~\"Deserializable\"),\n+        ],\n+        ~[cx.ty_path(span, ~[cx.ident_of(~\"__D\")], ~[])]\n+    );\n+\n+    mk_impl(\n+        cx,\n+        span,\n+        ident,\n+        ty_param,\n+        path,\n+        tps,\n+        |ty| mk_deser_method(cx, span, ty, cx.expr_blk(body))\n+    )\n }\n \n-fn ser_ty(cx: ext_ctxt, tps: ser_tps_map,\n-          ty: @ast::ty, -s: @ast::expr, -v: @ast::expr)\n-    -> ~[@ast::stmt] {\n-\n-    let ext_cx = cx; // required for #ast{}\n-\n-    match ty.node {\n-      ast::ty_nil => {\n-        ~[#ast[stmt]{$(s).emit_nil()}]\n-      }\n-\n-      ast::ty_bot => {\n-        cx.span_err(\n-            ty.span, fmt!(\"Cannot serialize bottom type\"));\n-        ~[]\n-      }\n-\n-      ast::ty_box(mt) => {\n-        let l = ser_lambda(cx, tps, mt.ty, cx.clone(s), #ast{ *$(v) });\n-        ~[#ast[stmt]{$(s).emit_box($(l));}]\n-      }\n-\n-      // For unique evecs/estrs, just pass through to underlying vec or str\n-      ast::ty_uniq(mt) if is_vec_or_str(mt.ty) => {\n-        ser_ty(cx, tps, mt.ty, move s, move v)\n-      }\n-\n-      ast::ty_uniq(mt) => {\n-        let l = ser_lambda(cx, tps, mt.ty, cx.clone(s), #ast{ *$(v) });\n-        ~[#ast[stmt]{$(s).emit_uniq($(l));}]\n-      }\n-\n-      ast::ty_ptr(_) | ast::ty_rptr(_, _) => {\n-        cx.span_err(ty.span, ~\"cannot serialize pointer types\");\n-        ~[]\n-      }\n-\n-      ast::ty_rec(flds) => {\n-        let fld_stmts = do vec::from_fn(vec::len(flds)) |fidx| {\n-            let fld = flds[fidx];\n-            let vf = cx.expr(fld.span,\n-                             ast::expr_field(cx.clone(v),\n-                                             fld.node.ident,\n-                                             ~[]));\n-            let s = cx.clone(s);\n-            let f = cx.lit_str(fld.span, cx.parse_sess().interner.get(\n-                fld.node.ident));\n-            let i = cx.lit_uint(fld.span, fidx);\n-            let l = ser_lambda(cx, tps, fld.node.mt.ty, cx.clone(s), move vf);\n-            #ast[stmt]{$(s).emit_rec_field($(f), $(i), $(l));}\n-        };\n-        let fld_lambda = cx.lambda(cx.blk(ty.span, fld_stmts));\n-        ~[#ast[stmt]{$(s).emit_rec($(fld_lambda));}]\n-      }\n-\n-      ast::ty_fn(*) => {\n-        cx.span_err(ty.span, ~\"cannot serialize function types\");\n-        ~[]\n-      }\n-\n-      ast::ty_tup(tys) => {\n-        // Generate code like\n-        //\n-        // match v {\n-        //    (v1, v2, v3) {\n-        //       .. serialize v1, v2, v3 ..\n-        //    }\n-        // };\n-\n-        let arms = ~[\n-            ser_variant(\n-\n-                cx, tps, tys, ty.span, move s,\n-\n-                // Generate pattern (v1, v2, v3)\n-                |pats| ast::pat_tup(pats),\n-\n-                // Generate body s.emit_tup(3, {|| blk })\n-                |-s, blk| {\n-                    let sz = cx.lit_uint(ty.span, vec::len(tys));\n-                    let body = cx.lambda(blk);\n-                    #ast{ $(s).emit_tup($(sz), $(body)) }\n-                },\n-\n-                // Generate s.emit_tup_elt(i, {|| blk })\n-                |-s, i, blk| {\n-                    let idx = cx.lit_uint(ty.span, i);\n-                    let body = cx.lambda(blk);\n-                    #ast{ $(s).emit_tup_elt($(idx), $(body)) }\n-                })\n-        ];\n-        ~[cx.alt_stmt(arms, ty.span, move v)]\n-      }\n-\n-      ast::ty_path(path, _) => {\n-        if path.idents.len() == 1 && path.types.is_empty() {\n-            let ident = path.idents[0];\n-\n-            match tps.find(ident) {\n-              Some(f) => f(v),\n-              None => ser_path(cx, tps, path, move s, move v)\n+fn mk_ser_method(\n+    cx: ext_ctxt,\n+    span: span,\n+    ser_body: ast::blk\n+) -> @ast::method {\n+    let ty_s = @{\n+        id: cx.next_id(),\n+        node: ast::ty_rptr(\n+            @{\n+                id: cx.next_id(),\n+                node: ast::re_anon,\n+            },\n+            {\n+                ty: cx.ty_path(span, ~[cx.ident_of(~\"__S\")], ~[]),\n+                mutbl: ast::m_imm\n             }\n-        } else {\n-            ser_path(cx, tps, path, move s, move v)\n-        }\n-      }\n+        ),\n+        span: span,\n+    };\n \n-      ast::ty_mac(_) => {\n-        cx.span_err(ty.span, ~\"cannot serialize macro types\");\n-        ~[]\n-      }\n+    let ser_inputs = ~[{\n+        mode: ast::infer(cx.next_id()),\n+        ty: ty_s,\n+        ident: cx.ident_of(~\"__s\"),\n+        id: cx.next_id(),\n+    }];\n+\n+    let ser_output = @{\n+        id: cx.next_id(),\n+        node: ast::ty_nil,\n+        span: span,\n+    };\n \n-      ast::ty_infer => {\n-        cx.span_err(ty.span, ~\"cannot serialize inferred types\");\n-        ~[]\n-      }\n+    let ser_decl = {\n+        inputs: ser_inputs,\n+        output: ser_output,\n+        cf: ast::return_val,\n+    };\n \n-      ast::ty_vec(mt) => {\n-        let ser_e =\n-            cx.expr(\n-                ty.span,\n-                ast::expr_block(\n-                    cx.blk(\n-                        ty.span,\n-                        ser_ty(\n-                            cx, tps, mt.ty,\n-                            cx.clone(s),\n-                            cx.at(ty.span, #ast{ __e })))));\n-\n-        ~[#ast[stmt]{\n-            std::serialization::emit_from_vec($(s), $(v), |__e| $(ser_e))\n-        }]\n-      }\n-\n-      ast::ty_fixed_length(_, _) => {\n-        cx.span_unimpl(ty.span, ~\"serialization for fixed length types\");\n-      }\n+    @{\n+        ident: cx.ident_of(~\"serialize\"),\n+        attrs: ~[],\n+        tps: ~[],\n+        self_ty: { node: ast::sty_region(ast::m_imm), span: span },\n+        purity: ast::impure_fn,\n+        decl: ser_decl,\n+        body: ser_body,\n+        id: cx.next_id(),\n+        span: span,\n+        self_id: cx.next_id(),\n+        vis: ast::public,\n     }\n }\n \n-fn mk_ser_fn(cx: ext_ctxt, span: span, name: ast::ident,\n-             tps: ~[ast::ty_param],\n-             f: fn(ext_ctxt, ser_tps_map,\n-                   -v: @ast::expr, -v: @ast::expr) -> ~[@ast::stmt])\n-    -> @ast::item {\n-    let ext_cx = cx; // required for #ast\n-\n-    let tp_types = vec::map(tps, |tp| cx.ty_path(span, ~[tp.ident], ~[]));\n-    let v_ty = cx.ty_path(span, ~[name], tp_types);\n-\n-    let tp_inputs =\n-        vec::map(tps, |tp|\n-            {mode: ast::expl(ast::by_ref),\n-             ty: cx.ty_fn(span,\n-                          ~[cx.ty_path(span, ~[tp.ident], ~[])],\n-                          cx.ty_nil(span)),\n-             ident: cx.ident_of(~\"__s\" + cx.str_of(tp.ident)),\n-             id: cx.next_id()});\n-\n-    debug!(\"tp_inputs = %?\", tp_inputs);\n-\n-\n-    let ser_inputs: ~[ast::arg] =\n-        vec::append(~[{mode: ast::expl(ast::by_ref),\n-                      ty: cx.ty_path(span, ~[cx.ident_of(~\"__S\")], ~[]),\n-                      ident: cx.ident_of(~\"__s\"),\n-                      id: cx.next_id()},\n-                     {mode: ast::expl(ast::by_ref),\n-                      ty: v_ty,\n-                      ident: cx.ident_of(~\"__v\"),\n-                      id: cx.next_id()}],\n-                    tp_inputs);\n-\n-    let tps_map = map::HashMap();\n-    for vec::each2(tps, tp_inputs) |tp, arg| {\n-        let arg_ident = arg.ident;\n-        tps_map.insert(\n-            tp.ident,\n-            fn@(v: @ast::expr) -> ~[@ast::stmt] {\n-                let f = cx.var_ref(span, arg_ident);\n-                debug!(\"serializing type arg %s\", cx.str_of(arg_ident));\n-                ~[#ast[stmt]{$(f)($(v));}]\n-            });\n-    }\n+fn mk_deser_method(\n+    cx: ext_ctxt,\n+    span: span,\n+    ty: @ast::Ty,\n+    deser_body: ast::blk\n+) -> @ast::method {\n+    let ty_d = @{\n+        id: cx.next_id(),\n+        node: ast::ty_rptr(\n+            @{\n+                id: cx.next_id(),\n+                node: ast::re_anon,\n+            },\n+            {\n+                ty: cx.ty_path(span, ~[cx.ident_of(~\"__D\")], ~[]),\n+                mutbl: ast::m_imm\n+            }\n+        ),\n+        span: span,\n+    };\n \n-    let ser_bnds = @~[\n-        ast::bound_trait(cx.ty_path(span,\n-                                    ~[cx.ident_of(~\"std\"),\n-                                      cx.ident_of(~\"serialization\"),\n-                                      cx.ident_of(~\"Serializer\")],\n-                                    ~[]))];\n-\n-    let ser_tps: ~[ast::ty_param] =\n-        vec::append(~[{ident: cx.ident_of(~\"__S\"),\n-                      id: cx.next_id(),\n-                      bounds: ser_bnds}],\n-                    vec::map(tps, |tp| cx.clone_ty_param(*tp)));\n-\n-    let ser_output: @ast::ty = @{id: cx.next_id(),\n-                                 node: ast::ty_nil,\n-                                 span: span};\n-\n-    let ser_blk = cx.blk(span,\n-                         f(cx, tps_map, #ast{ __s }, #ast{ __v }));\n-\n-    @{ident: cx.ident_of(~\"serialize_\" + cx.str_of(name)),\n-      attrs: ~[],\n-      id: cx.next_id(),\n-      node: ast::item_fn({inputs: ser_inputs,\n-                          output: ser_output,\n-                          cf: ast::return_val},\n-                         ast::impure_fn,\n-                         ser_tps,\n-                         ser_blk),\n-      vis: ast::public,\n-      span: span}\n+    let deser_inputs = ~[{\n+        mode: ast::infer(cx.next_id()),\n+        ty: ty_d,\n+        ident: cx.ident_of(~\"__d\"),\n+        id: cx.next_id(),\n+    }];\n+\n+    let deser_decl = {\n+        inputs: deser_inputs,\n+        output: ty,\n+        cf: ast::return_val,\n+    };\n+\n+    @{\n+        ident: cx.ident_of(~\"deserialize\"),\n+        attrs: ~[],\n+        tps: ~[],\n+        self_ty: { node: ast::sty_static, span: span },\n+        purity: ast::impure_fn,\n+        decl: deser_decl,\n+        body: deser_body,\n+        id: cx.next_id(),\n+        span: span,\n+        self_id: cx.next_id(),\n+        vis: ast::public,\n+    }\n }\n \n-// ______________________________________________________________________\n+fn mk_rec_ser_impl(\n+    cx: ext_ctxt,\n+    span: span,\n+    ident: ast::ident,\n+    fields: ~[ast::ty_field],\n+    tps: ~[ast::ty_param]\n+) -> @ast::item {\n+    let fields = mk_ser_fields(cx, span, mk_rec_fields(fields));\n+\n+    // ast for `__s.emit_rec(|| $(fields))`\n+    let body = cx.expr_call(\n+        span,\n+        cx.expr_field(\n+            span,\n+            cx.expr_var(span, ~\"__s\"),\n+            cx.ident_of(~\"emit_rec\")\n+        ),\n+        ~[cx.lambda_stmts(span, fields)]\n+    );\n \n-fn deser_path(cx: ext_ctxt, tps: deser_tps_map, path: @ast::path,\n-                    -d: @ast::expr) -> @ast::expr {\n-    // We want to take a path like a::b::c<...> and generate a call\n-    // like a::b::c::deserialize(d, ...), as described above.\n+    mk_ser_impl(cx, span, ident, tps, body)\n+}\n \n-    let callee =\n-        cx.expr(\n-            path.span,\n-            ast::expr_path(\n-                cx.helper_path(path, ~\"deserialize\")));\n+fn mk_rec_deser_impl(\n+    cx: ext_ctxt,\n+    span: span,\n+    ident: ast::ident,\n+    fields: ~[ast::ty_field],\n+    tps: ~[ast::ty_param]\n+) -> @ast::item {\n+    let fields = mk_deser_fields(cx, span, mk_rec_fields(fields));\n+\n+    // ast for `read_rec(|| $(fields))`\n+    let body = cx.expr_call(\n+        span,\n+        cx.expr_field(\n+            span,\n+            cx.expr_var(span, ~\"__d\"),\n+            cx.ident_of(~\"read_rec\")\n+        ),\n+        ~[\n+            cx.lambda_expr(\n+                cx.expr(\n+                    span,\n+                    ast::expr_rec(fields, None)\n+                )\n+            )\n+        ]\n+    );\n \n-    let ty_args = do vec::map(path.types) |ty| {\n-        let dv_expr = deser_ty(cx, tps, *ty, cx.clone(d));\n-        cx.lambda(cx.expr_blk(dv_expr))\n-    };\n+    mk_deser_impl(cx, span, ident, tps, body)\n+}\n \n-    cx.expr(path.span, ast::expr_call(callee, vec::append(~[d], ty_args),\n-                                      false))\n+fn mk_struct_ser_impl(\n+    cx: ext_ctxt,\n+    span: span,\n+    ident: ast::ident,\n+    fields: ~[@ast::struct_field],\n+    tps: ~[ast::ty_param]\n+) -> @ast::item {\n+    let fields = mk_ser_fields(cx, span, mk_struct_fields(fields));\n+\n+    // ast for `__s.emit_struct($(name), || $(fields))`\n+    let ser_body = cx.expr_call(\n+        span,\n+        cx.expr_field(\n+            span,\n+            cx.expr_var(span, ~\"__s\"),\n+            cx.ident_of(~\"emit_struct\")\n+        ),\n+        ~[\n+            cx.lit_str(span, @cx.str_of(ident)),\n+            cx.lambda_stmts(span, fields),\n+        ]\n+    );\n+\n+    mk_ser_impl(cx, span, ident, tps, ser_body)\n }\n \n-fn deser_lambda(cx: ext_ctxt, tps: deser_tps_map, ty: @ast::ty,\n-                -d: @ast::expr) -> @ast::expr {\n-    cx.lambda(cx.expr_blk(deser_ty(cx, tps, ty, move d)))\n+fn mk_struct_deser_impl(\n+    cx: ext_ctxt,\n+    span: span,\n+    ident: ast::ident,\n+    fields: ~[@ast::struct_field],\n+    tps: ~[ast::ty_param]\n+) -> @ast::item {\n+    let fields = mk_deser_fields(cx, span, mk_struct_fields(fields));\n+\n+    // ast for `read_struct($(name), || $(fields))`\n+    let body = cx.expr_call(\n+        span,\n+        cx.expr_field(\n+            span,\n+            cx.expr_var(span, ~\"__d\"),\n+            cx.ident_of(~\"read_struct\")\n+        ),\n+        ~[\n+            cx.lit_str(span, @cx.str_of(ident)),\n+            cx.lambda_expr(\n+                cx.expr(\n+                    span,\n+                    ast::expr_struct(\n+                        cx.path(span, ~[ident]),\n+                        fields,\n+                        None\n+                    )\n+                )\n+            ),\n+        ]\n+    );\n+\n+    mk_deser_impl(cx, span, ident, tps, body)\n }\n \n-fn deser_ty(cx: ext_ctxt, tps: deser_tps_map,\n-                  ty: @ast::ty, -d: @ast::expr) -> @ast::expr {\n-\n-    let ext_cx = cx; // required for #ast{}\n-\n-    match ty.node {\n-      ast::ty_nil => {\n-        #ast{ $(d).read_nil() }\n-      }\n-\n-      ast::ty_bot => {\n-        #ast{ fail }\n-      }\n-\n-      ast::ty_box(mt) => {\n-        let l = deser_lambda(cx, tps, mt.ty, cx.clone(d));\n-        #ast{ @$(d).read_box($(l)) }\n-      }\n-\n-      // For unique evecs/estrs, just pass through to underlying vec or str\n-      ast::ty_uniq(mt) if is_vec_or_str(mt.ty) => {\n-        deser_ty(cx, tps, mt.ty, move d)\n-      }\n-\n-      ast::ty_uniq(mt) => {\n-        let l = deser_lambda(cx, tps, mt.ty, cx.clone(d));\n-        #ast{ ~$(d).read_uniq($(l)) }\n-      }\n-\n-      ast::ty_ptr(_) | ast::ty_rptr(_, _) => {\n-        #ast{ fail }\n-      }\n-\n-      ast::ty_rec(flds) => {\n-        let fields = do vec::from_fn(vec::len(flds)) |fidx| {\n-            let fld = flds[fidx];\n-            let d = cx.clone(d);\n-            let f = cx.lit_str(fld.span, @cx.str_of(fld.node.ident));\n-            let i = cx.lit_uint(fld.span, fidx);\n-            let l = deser_lambda(cx, tps, fld.node.mt.ty, cx.clone(d));\n-            {node: {mutbl: fld.node.mt.mutbl,\n-                    ident: fld.node.ident,\n-                    expr: #ast{ $(d).read_rec_field($(f), $(i), $(l))} },\n-             span: fld.span}\n-        };\n-        let fld_expr = cx.expr(ty.span, ast::expr_rec(fields, None));\n-        let fld_lambda = cx.lambda(cx.expr_blk(fld_expr));\n-        #ast{ $(d).read_rec($(fld_lambda)) }\n-      }\n-\n-      ast::ty_fn(*) => {\n-        #ast{ fail }\n-      }\n-\n-      ast::ty_tup(tys) => {\n-        // Generate code like\n-        //\n-        // d.read_tup(3u) {||\n-        //   (d.read_tup_elt(0u, {||...}),\n-        //    d.read_tup_elt(1u, {||...}),\n-        //    d.read_tup_elt(2u, {||...}))\n-        // }\n-\n-        let arg_exprs = do vec::from_fn(vec::len(tys)) |i| {\n-            let idx = cx.lit_uint(ty.span, i);\n-            let body = deser_lambda(cx, tps, tys[i], cx.clone(d));\n-            #ast{ $(d).read_tup_elt($(idx), $(body)) }\n-        };\n-        let body =\n-            cx.lambda(cx.expr_blk(\n-                cx.expr(ty.span, ast::expr_tup(arg_exprs))));\n-        let sz = cx.lit_uint(ty.span, vec::len(tys));\n-        #ast{ $(d).read_tup($(sz), $(body)) }\n-      }\n-\n-      ast::ty_path(path, _) => {\n-        if vec::len(path.idents) == 1u &&\n-            vec::is_empty(path.types) {\n-            let ident = path.idents[0];\n-\n-            match tps.find(ident) {\n-              Some(f) => f(),\n-              None => deser_path(cx, tps, path, move d)\n-            }\n-        } else {\n-            deser_path(cx, tps, path, move d)\n+// Records and structs don't have the same fields types, but they share enough\n+// that if we extract the right subfields out we can share the serialization\n+// generator code.\n+type field = { span: span, ident: ast::ident, mutbl: ast::mutability };\n+\n+fn mk_rec_fields(fields: ~[ast::ty_field]) -> ~[field] {\n+    do fields.map |field| {\n+        {\n+            span: field.span,\n+            ident: field.node.ident,\n+            mutbl: field.node.mt.mutbl,\n         }\n-      }\n-\n-      ast::ty_mac(_) => {\n-        #ast{ fail }\n-      }\n-\n-      ast::ty_infer => {\n-        #ast{ fail }\n-      }\n+    }\n+}\n \n-      ast::ty_vec(mt) => {\n-        let l = deser_lambda(cx, tps, mt.ty, cx.clone(d));\n-        #ast{ std::serialization::read_to_vec($(d), $(l)) }\n-      }\n+fn mk_struct_fields(fields: ~[@ast::struct_field]) -> ~[field] {\n+    do fields.map |field| {\n+        let (ident, mutbl) = match field.node.kind {\n+            ast::named_field(ident, mutbl, _) => (ident, mutbl),\n+            _ => fail ~\"[auto_serialize] does not support \\\n+                        unnamed fields\",\n+        };\n \n-      ast::ty_fixed_length(_, _) => {\n-        cx.span_unimpl(ty.span, ~\"deserialization for fixed length types\");\n-      }\n+        {\n+            span: field.span,\n+            ident: ident,\n+            mutbl: match mutbl {\n+                ast::class_mutable => ast::m_mutbl,\n+                ast::class_immutable => ast::m_imm,\n+            },\n+        }\n     }\n }\n \n-fn mk_deser_fn(cx: ext_ctxt, span: span,\n-               name: ast::ident, tps: ~[ast::ty_param],\n-               f: fn(ext_ctxt, deser_tps_map, -v: @ast::expr) -> @ast::expr)\n-    -> @ast::item {\n-    let ext_cx = cx; // required for #ast\n-\n-    let tp_types = vec::map(tps, |tp| cx.ty_path(span, ~[tp.ident], ~[]));\n-    let v_ty = cx.ty_path(span, ~[name], tp_types);\n-\n-    let tp_inputs =\n-        vec::map(tps, |tp|\n-            {mode: ast::expl(ast::by_ref),\n-             ty: cx.ty_fn(span,\n-                          ~[],\n-                          cx.ty_path(span, ~[tp.ident], ~[])),\n-             ident: cx.ident_of(~\"__d\" + cx.str_of(tp.ident)),\n-             id: cx.next_id()});\n-\n-    debug!(\"tp_inputs = %?\", tp_inputs);\n-\n-    let deser_inputs: ~[ast::arg] =\n-        vec::append(~[{mode: ast::expl(ast::by_ref),\n-                      ty: cx.ty_path(span, ~[cx.ident_of(~\"__D\")], ~[]),\n-                      ident: cx.ident_of(~\"__d\"),\n-                      id: cx.next_id()}],\n-                    tp_inputs);\n-\n-    let tps_map = map::HashMap();\n-    for vec::each2(tps, tp_inputs) |tp, arg| {\n-        let arg_ident = arg.ident;\n-        tps_map.insert(\n-            tp.ident,\n-            fn@() -> @ast::expr {\n-                let f = cx.var_ref(span, arg_ident);\n-                #ast{ $(f)() }\n-            });\n+fn mk_ser_fields(\n+    cx: ext_ctxt,\n+    span: span,\n+    fields: ~[field]\n+) -> ~[@ast::stmt] {\n+    do fields.mapi |idx, field| {\n+        // ast for `|| self.$(name).serialize(__s)`\n+        let expr_lambda = cx.lambda_expr(\n+            cx.expr_call(\n+                span,\n+                cx.expr_field(\n+                    span,\n+                    cx.expr_field(\n+                        span,\n+                        cx.expr_var(span, ~\"self\"),\n+                        field.ident\n+                    ),\n+                    cx.ident_of(~\"serialize\")\n+                ),\n+                ~[cx.expr_var(span, ~\"__s\")]\n+            )\n+        );\n+\n+        // ast for `__s.emit_field($(name), $(idx), $(expr_lambda))`\n+        cx.stmt(\n+            cx.expr_call(\n+                span,\n+                cx.expr_field(\n+                    span,\n+                    cx.expr_var(span, ~\"__s\"),\n+                    cx.ident_of(~\"emit_field\")\n+                ),\n+                ~[\n+                    cx.lit_str(span, @cx.str_of(field.ident)),\n+                    cx.lit_uint(span, idx),\n+                    expr_lambda,\n+                ]\n+            )\n+        )\n     }\n+}\n \n-    let deser_bnds = @~[\n-        ast::bound_trait(cx.ty_path(\n+fn mk_deser_fields(\n+    cx: ext_ctxt,\n+    span: span,\n+    fields: ~[{ span: span, ident: ast::ident, mutbl: ast::mutability }]\n+) -> ~[ast::field] {\n+    do fields.mapi |idx, field| {\n+        // ast for `|| std::serialization::deserialize(__d)`\n+        let expr_lambda = cx.lambda(\n+            cx.expr_blk(\n+                cx.expr_call(\n+                    span,\n+                    cx.expr_path(span, ~[\n+                        cx.ident_of(~\"std\"),\n+                        cx.ident_of(~\"serialization\"),\n+                        cx.ident_of(~\"deserialize\"),\n+                    ]),\n+                    ~[cx.expr_var(span, ~\"__d\")]\n+                )\n+            )\n+        );\n+\n+        // ast for `__d.read_field($(name), $(idx), $(expr_lambda))`\n+        let expr: @ast::expr = cx.expr_call(\n             span,\n-            ~[cx.ident_of(~\"std\"), cx.ident_of(~\"serialization\"),\n-              cx.ident_of(~\"Deserializer\")],\n-            ~[]))];\n-\n-    let deser_tps: ~[ast::ty_param] =\n-        vec::append(~[{ident: cx.ident_of(~\"__D\"),\n-                      id: cx.next_id(),\n-                      bounds: deser_bnds}],\n-                    vec::map(tps, |tp| {\n-                        let cloned = cx.clone_ty_param(*tp);\n-                        {bounds: @(vec::append(*cloned.bounds,\n-                                               ~[ast::bound_copy])),\n-                         .. cloned}\n-                    }));\n-\n-    let deser_blk = cx.expr_blk(f(cx, tps_map, #ast[expr]{__d}));\n-\n-    @{ident: cx.ident_of(~\"deserialize_\" + cx.str_of(name)),\n-      attrs: ~[],\n-      id: cx.next_id(),\n-      node: ast::item_fn({inputs: deser_inputs,\n-                          output: v_ty,\n-                          cf: ast::return_val},\n-                         ast::impure_fn,\n-                         deser_tps,\n-                         deser_blk),\n-      vis: ast::public,\n-      span: span}\n+            cx.expr_field(\n+                span,\n+                cx.expr_var(span, ~\"__d\"),\n+                cx.ident_of(~\"read_field\")\n+            ),\n+            ~[\n+                cx.lit_str(span, @cx.str_of(field.ident)),\n+                cx.lit_uint(span, idx),\n+                expr_lambda,\n+            ]\n+        );\n+\n+        {\n+            node: { mutbl: field.mutbl, ident: field.ident, expr: expr },\n+            span: span,\n+        }\n+    }\n }\n \n-fn ty_fns(cx: ext_ctxt, name: ast::ident,\n-          ty: @ast::ty, tps: ~[ast::ty_param])\n-    -> ~[@ast::item] {\n+fn mk_enum_ser_impl(\n+    cx: ext_ctxt,\n+    span: span,\n+    ident: ast::ident,\n+    enum_def: ast::enum_def,\n+    tps: ~[ast::ty_param]\n+) -> @ast::item {\n+    let body = mk_enum_ser_body(\n+        cx,\n+        span,\n+        ident,\n+        enum_def.variants\n+    );\n+\n+    mk_ser_impl(cx, span, ident, tps, body)\n+}\n \n-    let span = ty.span;\n-    ~[\n-        mk_ser_fn(cx, span, name, tps, |a,b,c,d| ser_ty(a, b, ty, move c,\n-                                                        move d)),\n-        mk_deser_fn(cx, span, name, tps, |a,b,c| deser_ty(a, b, ty, move c))\n-    ]\n+fn mk_enum_deser_impl(\n+    cx: ext_ctxt,\n+    span: span,\n+    ident: ast::ident,\n+    enum_def: ast::enum_def,\n+    tps: ~[ast::ty_param]\n+) -> @ast::item {\n+    let body = mk_enum_deser_body(\n+        cx,\n+        span,\n+        ident,\n+        enum_def.variants\n+    );\n+\n+    mk_deser_impl(cx, span, ident, tps, body)\n }\n \n-fn ser_enum(cx: ext_ctxt, tps: ser_tps_map, e_name: ast::ident,\n-            e_span: span, variants: ~[ast::variant],\n-            -s: @ast::expr, -v: @ast::expr) -> ~[@ast::stmt] {\n-    let ext_cx = cx;\n-    let arms = do vec::from_fn(vec::len(variants)) |vidx| {\n-        let variant = variants[vidx];\n-        let v_span = variant.span;\n-        let v_name = variant.node.name;\n+fn ser_variant(\n+    cx: ext_ctxt,\n+    span: span,\n+    v_name: ast::ident,\n+    v_idx: uint,\n+    args: ~[ast::variant_arg]\n+) -> ast::arm {\n+    // Name the variant arguments.\n+    let names = args.mapi(|i, _arg| cx.ident_of(fmt!(\"__v%u\", i)));\n+\n+    // Bind the names to the variant argument type.\n+    let pats = args.mapi(|i, arg| cx.binder_pat(arg.ty.span, names[i]));\n+\n+    let pat_node = if pats.is_empty() {\n+        ast::pat_ident(\n+            ast::bind_by_implicit_ref,\n+            cx.path(span, ~[v_name]),\n+            None\n+        )\n+    } else {\n+        ast::pat_enum(\n+            cx.path(span, ~[v_name]),\n+            Some(pats)\n+        )\n+    };\n \n-        match variant.node.kind {\n-            ast::tuple_variant_kind(args) => {\n-                let variant_tys = vec::map(args, |a| a.ty);\n-\n-                ser_variant(\n-                    cx, tps, variant_tys, v_span, cx.clone(s),\n-\n-                    // Generate pattern var(v1, v2, v3)\n-                    |pats| {\n-                        if vec::is_empty(pats) {\n-                            ast::pat_ident(ast::bind_by_implicit_ref,\n-                                           cx.path(v_span, ~[v_name]),\n-                                           None)\n-                        } else {\n-                            ast::pat_enum(cx.path(v_span, ~[v_name]),\n-                                                  Some(pats))\n-                        }\n-                    },\n+    let pat = @{\n+        id: cx.next_id(),\n+        node: pat_node,\n+        span: span,\n+    };\n \n-                    // Generate body s.emit_enum_variant(\"foo\", 0u,\n-                    //                                   3u, {|| blk })\n-                    |-s, blk| {\n-                        let v_name = cx.lit_str(v_span, @cx.str_of(v_name));\n-                        let v_id = cx.lit_uint(v_span, vidx);\n-                        let sz = cx.lit_uint(v_span, vec::len(variant_tys));\n-                        let body = cx.lambda(blk);\n-                        #ast[expr]{\n-                            $(s).emit_enum_variant($(v_name), $(v_id),\n-                                                   $(sz), $(body))\n-                        }\n-                    },\n+    let stmts = do args.mapi |a_idx, _arg| {\n+        // ast for `__s.emit_enum_variant_arg`\n+        let expr_emit = cx.expr_field(\n+            span,\n+            cx.expr_var(span, ~\"__s\"),\n+            cx.ident_of(~\"emit_enum_variant_arg\")\n+        );\n \n-                    // Generate s.emit_enum_variant_arg(i, {|| blk })\n-                    |-s, i, blk| {\n-                        let idx = cx.lit_uint(v_span, i);\n-                        let body = cx.lambda(blk);\n-                        #ast[expr]{\n-                            $(s).emit_enum_variant_arg($(idx), $(body))\n-                        }\n-                    })\n-            }\n-            _ =>\n-                fail ~\"struct variants unimplemented for auto serialize\"\n-        }\n+        // ast for `|| $(v).serialize(__s)`\n+        let expr_serialize = cx.lambda_expr(\n+             cx.expr_call(\n+                span,\n+                cx.expr_field(\n+                    span,\n+                    cx.expr_path(span, ~[names[a_idx]]),\n+                    cx.ident_of(~\"serialize\")\n+                ),\n+                ~[cx.expr_var(span, ~\"__s\")]\n+            )\n+        );\n+\n+        // ast for `$(expr_emit)($(a_idx), $(expr_serialize))`\n+        cx.stmt(\n+            cx.expr_call(\n+                span,\n+                expr_emit,\n+                ~[cx.lit_uint(span, a_idx), expr_serialize]\n+            )\n+        )\n     };\n-    let lam = cx.lambda(cx.blk(e_span, ~[cx.alt_stmt(arms, e_span, move v)]));\n-    let e_name = cx.lit_str(e_span, @cx.str_of(e_name));\n-    ~[#ast[stmt]{ $(s).emit_enum($(e_name), $(lam)) }]\n-}\n \n-fn deser_enum(cx: ext_ctxt, tps: deser_tps_map, e_name: ast::ident,\n-              e_span: span, variants: ~[ast::variant],\n-              -d: @ast::expr) -> @ast::expr {\n-    let ext_cx = cx;\n-    let mut arms: ~[ast::arm] = do vec::from_fn(vec::len(variants)) |vidx| {\n-        let variant = variants[vidx];\n-        let v_span = variant.span;\n-        let v_name = variant.node.name;\n+    // ast for `__s.emit_enum_variant($(name), $(idx), $(sz), $(lambda))`\n+    let body = cx.expr_call(\n+        span,\n+        cx.expr_field(\n+            span,\n+            cx.expr_var(span, ~\"__s\"),\n+            cx.ident_of(~\"emit_enum_variant\")\n+        ),\n+        ~[\n+            cx.lit_str(span, @cx.str_of(v_name)),\n+            cx.lit_uint(span, v_idx),\n+            cx.lit_uint(span, stmts.len()),\n+            cx.lambda_stmts(span, stmts),\n+        ]\n+    );\n+\n+    { pats: ~[pat], guard: None, body: cx.expr_blk(body) }\n+}\n \n-        let body;\n+fn mk_enum_ser_body(\n+    cx: ext_ctxt,\n+    span: span,\n+    name: ast::ident,\n+    variants: ~[ast::variant]\n+) -> @ast::expr {\n+    let arms = do variants.mapi |v_idx, variant| {\n         match variant.node.kind {\n-            ast::tuple_variant_kind(args) => {\n-                let tys = vec::map(args, |a| a.ty);\n-\n-                let arg_exprs = do vec::from_fn(vec::len(tys)) |i| {\n-                    let idx = cx.lit_uint(v_span, i);\n-                    let body = deser_lambda(cx, tps, tys[i], cx.clone(d));\n-                    #ast{ $(d).read_enum_variant_arg($(idx), $(body)) }\n-                };\n-\n-                body = {\n-                    if vec::is_empty(tys) {\n-                        // for a nullary variant v, do \"v\"\n-                        cx.var_ref(v_span, v_name)\n-                    } else {\n-                        // for an n-ary variant v, do \"v(a_1, ..., a_n)\"\n-                        cx.expr(v_span, ast::expr_call(\n-                            cx.var_ref(v_span, v_name), arg_exprs, false))\n-                    }\n-                };\n-            }\n+            ast::tuple_variant_kind(args) =>\n+                ser_variant(cx, span, variant.node.name, v_idx, args),\n             ast::struct_variant_kind(*) =>\n                 fail ~\"struct variants unimplemented\",\n             ast::enum_variant_kind(*) =>\n-                fail ~\"enum variants unimplemented\"\n+                fail ~\"enum variants unimplemented\",\n         }\n+    };\n \n-        {pats: ~[@{id: cx.next_id(),\n-                  node: ast::pat_lit(cx.lit_uint(v_span, vidx)),\n-                  span: v_span}],\n-         guard: None,\n-         body: cx.expr_blk(body)}\n+    // ast for `match *self { $(arms) }`\n+    let match_expr = cx.expr(\n+        span,\n+        ast::expr_match(\n+            cx.expr(\n+                span,\n+                ast::expr_unary(ast::deref, cx.expr_var(span, ~\"self\"))\n+            ),\n+            arms\n+        )\n+    );\n+\n+    // ast for `__s.emit_enum($(name), || $(match_expr))`\n+    cx.expr_call(\n+        span,\n+        cx.expr_field(\n+            span,\n+            cx.expr_var(span, ~\"__s\"),\n+            cx.ident_of(~\"emit_enum\")\n+        ),\n+        ~[\n+            cx.lit_str(span, @cx.str_of(name)),\n+            cx.lambda_expr(match_expr),\n+        ]\n+    )\n+}\n+\n+fn mk_enum_deser_variant_nary(\n+    cx: ext_ctxt,\n+    span: span,\n+    name: ast::ident,\n+    args: ~[ast::variant_arg]\n+) -> @ast::expr {\n+    let args = do args.mapi |idx, _arg| {\n+        // ast for `|| std::serialization::deserialize(__d)`\n+        let expr_lambda = cx.lambda_expr(\n+            cx.expr_call(\n+                span,\n+                cx.expr_path(span, ~[\n+                    cx.ident_of(~\"std\"),\n+                    cx.ident_of(~\"serialization\"),\n+                    cx.ident_of(~\"deserialize\"),\n+                ]),\n+                ~[cx.expr_var(span, ~\"__d\")]\n+            )\n+        );\n+\n+        // ast for `__d.read_enum_variant_arg($(a_idx), $(expr_lambda))`\n+        cx.expr_call(\n+            span,\n+            cx.expr_field(\n+                span,\n+                cx.expr_var(span, ~\"__d\"),\n+                cx.ident_of(~\"read_enum_variant_arg\")\n+            ),\n+            ~[cx.lit_uint(span, idx), expr_lambda]\n+        )\n     };\n \n-    let impossible_case = {pats: ~[@{id: cx.next_id(),\n-                                     node: ast::pat_wild,\n-                                     span: e_span}],\n-                        guard: None,\n-                        // FIXME #3198: proper error message\n-                           body: cx.expr_blk(cx.expr(e_span,\n-                                                     ast::expr_fail(None)))};\n-    arms += ~[impossible_case];\n-\n-    // Generate code like:\n-    let e_name = cx.lit_str(e_span, @cx.str_of(e_name));\n-    let alt_expr = cx.expr(e_span,\n-                           ast::expr_match(#ast{__i}, arms));\n-    let var_lambda = #ast{ |__i| $(alt_expr) };\n-    let read_var = #ast{ $(cx.clone(d)).read_enum_variant($(var_lambda)) };\n-    let read_lambda = cx.lambda(cx.expr_blk(read_var));\n-    #ast{ $(d).read_enum($(e_name), $(read_lambda)) }\n+    // ast for `$(name)($(args))`\n+    cx.expr_call(span, cx.expr_path(span, ~[name]), args)\n }\n \n-fn enum_fns(cx: ext_ctxt, e_name: ast::ident, e_span: span,\n-               variants: ~[ast::variant], tps: ~[ast::ty_param])\n-    -> ~[@ast::item] {\n-    ~[\n-        mk_ser_fn(cx, e_span, e_name, tps,\n-                  |a,b,c,d| ser_enum(a, b, e_name, e_span, variants, move c,\n-                                     move d)),\n-        mk_deser_fn(cx, e_span, e_name, tps,\n-          |a,b,c| deser_enum(a, b, e_name, e_span, variants, move c))\n-    ]\n+fn mk_enum_deser_body(\n+    cx: ext_ctxt,\n+    span: span,\n+    name: ast::ident,\n+    variants: ~[ast::variant]\n+) -> @ast::expr {\n+    let mut arms = do variants.mapi |v_idx, variant| {\n+        let body = match variant.node.kind {\n+            ast::tuple_variant_kind(args) => {\n+                if args.is_empty() {\n+                    // for a nullary variant v, do \"v\"\n+                    cx.expr_path(span, ~[variant.node.name])\n+                } else {\n+                    // for an n-ary variant v, do \"v(a_1, ..., a_n)\"\n+                    mk_enum_deser_variant_nary(\n+                        cx,\n+                        span,\n+                        variant.node.name,\n+                        args\n+                    )\n+                }\n+            },\n+            ast::struct_variant_kind(*) =>\n+                fail ~\"struct variants unimplemented\",\n+            ast::enum_variant_kind(*) =>\n+                fail ~\"enum variants unimplemented\",\n+        };\n+\n+        let pat = @{\n+            id: cx.next_id(),\n+            node: ast::pat_lit(cx.lit_uint(span, v_idx)),\n+            span: span,\n+        };\n+\n+        {\n+            pats: ~[pat],\n+            guard: None,\n+            body: cx.expr_blk(body),\n+        }\n+    };\n+\n+    let impossible_case = {\n+        pats: ~[@{ id: cx.next_id(), node: ast::pat_wild, span: span}],\n+        guard: None,\n+\n+        // FIXME(#3198): proper error message\n+        body: cx.expr_blk(cx.expr(span, ast::expr_fail(None))),\n+    };\n+\n+    arms.push(impossible_case);\n+\n+    // ast for `|i| { match i { $(arms) } }`\n+    let expr_lambda = cx.expr(\n+        span,\n+        ast::expr_fn_block(\n+            {\n+                inputs: ~[{\n+                    mode: ast::infer(cx.next_id()),\n+                    ty: @{\n+                        id: cx.next_id(),\n+                        node: ast::ty_infer,\n+                        span: span\n+                    },\n+                    ident: cx.ident_of(~\"i\"),\n+                    id: cx.next_id(),\n+                }],\n+                output: @{\n+                    id: cx.next_id(),\n+                    node: ast::ty_infer,\n+                    span: span,\n+                },\n+                cf: ast::return_val,\n+            },\n+            cx.expr_blk(\n+                cx.expr(\n+                    span,\n+                    ast::expr_match(cx.expr_var(span, ~\"i\"), arms)\n+                )\n+            ),\n+            @~[]\n+        )\n+    );\n+\n+    // ast for `__d.read_enum_variant($(expr_lambda))`\n+    let expr_lambda = cx.lambda_expr(\n+        cx.expr_call(\n+            span,\n+            cx.expr_field(\n+                span,\n+                cx.expr_var(span, ~\"__d\"),\n+                cx.ident_of(~\"read_enum_variant\")\n+            ),\n+            ~[expr_lambda]\n+        )\n+    );\n+\n+    // ast for `__d.read_enum($(e_name), $(expr_lambda))`\n+    cx.expr_call(\n+        span,\n+        cx.expr_field(\n+            span,\n+            cx.expr_var(span, ~\"__d\"),\n+            cx.ident_of(~\"read_enum\")\n+        ),\n+        ~[\n+            cx.lit_str(span, @cx.str_of(name)),\n+            expr_lambda\n+        ]\n+    )\n }"}, {"sha": "99f837a4c8446d61151e631acf5ffe5134ccf9c4", "filename": "src/libsyntax/ext/auto_serialize2.rs", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/9aec7a3e85c5b07923eab05d3ebe9d031bf258f3/src%2Flibsyntax%2Fext%2Fauto_serialize2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aec7a3e85c5b07923eab05d3ebe9d031bf258f3/src%2Flibsyntax%2Fext%2Fauto_serialize2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_serialize2.rs?ref=9aec7a3e85c5b07923eab05d3ebe9d031bf258f3"}, {"sha": "5b4cc23ce09fd8095352ec0ba45e6d7d2acfecb0", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "37fb0f05cbd3e589324c3d7d77410fe9c371d647", "filename": "src/libsyntax/ext/env.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibsyntax%2Fext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibsyntax%2Fext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fenv.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "e24575f6cd327b25e36bba8e07d8ba2f2f74cbad", "filename": "src/libsyntax/ext/fmt.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ffmt.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "4d04552bfa15ae12c014695ec3074e936dfc99c1", "filename": "src/libsyntax/ext/pipes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibsyntax%2Fext%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibsyntax%2Fext%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "f10cbc2a5898a349685559e6b1cbf9fedc330611", "filename": "src/libsyntax/ext/pipes/ast_builder.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "fcc0c84a4ff391ae87a7069a72f2daf87bde4746", "filename": "src/libsyntax/ext/pipes/check.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibsyntax%2Fext%2Fpipes%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibsyntax%2Fext%2Fpipes%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fcheck.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "8f2b92a720c0725d077c9dccd0caadd4571228e8", "filename": "src/libsyntax/ext/pipes/parse_proto.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibsyntax%2Fext%2Fpipes%2Fparse_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibsyntax%2Fext%2Fpipes%2Fparse_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fparse_proto.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "7e1cbe9ad0dbfc4ed9b3e56108bd0675f2fecea3", "filename": "src/libsyntax/ext/pipes/pipec.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "229e55fdfcc6a0462de6bf2bac59ff5b6b46ba16", "filename": "src/libsyntax/ext/pipes/proto.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "af7ffaa73f5bf03ec6b74d260dcf6089c9fff771", "filename": "src/libsyntax/ext/qquote.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibsyntax%2Fext%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibsyntax%2Fext%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fqquote.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "bec29c9a8354013d5138f050f42dc70f39ce149a", "filename": "src/libsyntax/ext/simplext.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibsyntax%2Fext%2Fsimplext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibsyntax%2Fext%2Fsimplext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsimplext.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "0c7d408db7cc3e802e5c8ea8c78083dff21602c1", "filename": "src/libsyntax/ext/trace_macros.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibsyntax%2Fext%2Ftrace_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibsyntax%2Fext%2Ftrace_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftrace_macros.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "17122b85fb3608c282c5211e383a4a5e73334c2e", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "31bc375a76d56cc373f53e5f4a67a56fc2125aac", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "238f9db6ac5371ce9f83c216ed32858d863b0482", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "311928dd4e0c71bf64280639739ca02d9adda0fb", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 3, "deletions": 25, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "e38ee7ff0376335fb4b73cbb9e4167b9610e0e09", "filename": "src/libsyntax/parse.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibsyntax%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibsyntax%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "42101a431d6c63d1b966a6287db10a36ebcddf51", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "50c22c08f4f88a034ddd276a5fc414156bf8a269", "filename": "src/libsyntax/parse/common.rs", "status": "modified", "additions": 47, "deletions": 47, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibsyntax%2Fparse%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibsyntax%2Fparse%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcommon.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "56c9d4de9f3cda71bfd4810ef31f57cbd3c64172", "filename": "src/libsyntax/parse/eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibsyntax%2Fparse%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibsyntax%2Fparse%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Feval.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "8f57d733eb51f9421e6d86a7309268caf0e2d0dc", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "1f607d849d9653cdcf4df1115865e7b31b15bd2d", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 71, "deletions": 4, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "925da063ca62d24cfa1f73b38b046b8316f58012", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 127, "deletions": 175, "changes": 302, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "3fd905cb8ecec44f614c30f18ff202a98d386299", "filename": "src/libsyntax/parse/prec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibsyntax%2Fparse%2Fprec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibsyntax%2Fparse%2Fprec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fprec.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "5151fd1bac8377e3bcab95eef7b723ed3e854d74", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 44, "deletions": 46, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "33915c8c0c93139aaecdabcc2bf19a1b506c44ce", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 40, "deletions": 41, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "7c73deed1a91f57bf0dbc9c148d6f821bc7bc2bd", "filename": "src/libsyntax/syntax.rc", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibsyntax%2Fsyntax.rc", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibsyntax%2Fsyntax.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsyntax.rc?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "f564589cbe0c0d800a22be6c3b8e68b082ca5216", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "b45af2d4ae8721eb81f593f260ccec6732d80037", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 18, "deletions": 34, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "c34fd166baec71bef8bf6157527bd917ccd04fa9", "filename": "src/rt/rust_uv.cpp", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frt%2Frust_uv.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frt%2Frust_uv.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_uv.cpp?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "6a2bdd622cba30b9058a2bd59434a7e0b337fdf5", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "61fd68c193a6a418de2c406dd7b6cc9e5a303a02", "filename": "src/rustc/back/link.rs", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fback%2Flink.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "8038d7bb6ddf98c2c5ec2f9b589b4ea53fce30f3", "filename": "src/rustc/back/rpath.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fback%2Frpath.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "45e7cd4e9d45a47496e9e8ea92a04254ea83643f", "filename": "src/rustc/back/upcall.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fback%2Fupcall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fback%2Fupcall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fback%2Fupcall.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "934a02d6dd3e3a0f0321c37a04afa70c1e41fe3b", "filename": "src/rustc/driver/driver.rs", "status": "modified", "additions": 82, "deletions": 39, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fdriver.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "a6de92ceeb3e1bec306a0572c5289bc51b520f0b", "filename": "src/rustc/driver/rustc.rs", "status": "modified", "additions": 22, "deletions": 56, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Frustc.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "ed73bcb6d725977434d64ae63c26afc463764a55", "filename": "src/rustc/driver/session.rs", "status": "modified", "additions": 18, "deletions": 22, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fsession.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "e9be56e7d48031ddd318899e8ca465274dbefbf1", "filename": "src/rustc/front/core_inject.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Ffront%2Fcore_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Ffront%2Fcore_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Ffront%2Fcore_inject.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "2a87f089c8db4c83583b6c4ef6c1e899efb2df78", "filename": "src/rustc/front/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Ffront%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Ffront%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Ffront%2Fintrinsic.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "ac74bac3f2f169086a5afac3c8671d30a588ad1c", "filename": "src/rustc/front/intrinsic_inject.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Ffront%2Fintrinsic_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Ffront%2Fintrinsic_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Ffront%2Fintrinsic_inject.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "f0c9de4f2a245a585352797ef953c2cb4e8d381f", "filename": "src/rustc/front/test.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Ffront%2Ftest.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "06f1dfdab1aa5b1fe9c1a51057d7c18cf38f8e06", "filename": "src/rustc/metadata/common.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcommon.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "3080426e5319c0aa3dbd727af0755d140c88fb94", "filename": "src/rustc/metadata/creader.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcreader.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "141613c2240d896dbe466c9dd4dea028abf99a5e", "filename": "src/rustc/metadata/csearch.rs", "status": "modified", "additions": 46, "deletions": 11, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcsearch.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "6db3982297e554be938b580402aaf0297319c458", "filename": "src/rustc/metadata/cstore.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcstore.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "4e30132b1a73fd342ae214d9cc939e33a43ae8d3", "filename": "src/rustc/metadata/decoder.rs", "status": "modified", "additions": 170, "deletions": 48, "changes": 218, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fdecoder.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "f7e80e53ed5742d0bf1dfd6affd7734c8c0cc01b", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 101, "deletions": 75, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "b2d20ce56e83883665d92d58dc14aed24767ab3d", "filename": "src/rustc/metadata/filesearch.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ffilesearch.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "61b8bcf9067b580ed8e8ccf2299509b3820fb520", "filename": "src/rustc/metadata/loader.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Floader.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "14aef6db1adbd9a5451dbb5ba59d80dde3e5910d", "filename": "src/rustc/metadata/tydecode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ftydecode.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "941dd35bdf0b4dcbb6eb47da15e5d1533aea8c5c", "filename": "src/rustc/metadata/tyencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ftyencode.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "d264188e65d34168e3d0b08a92cb34f69f7cabc4", "filename": "src/rustc/middle/astencode.rs", "status": "modified", "additions": 82, "deletions": 100, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fastencode.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "db0e092ed83e06758202eb961dd63c78a66552d0", "filename": "src/rustc/middle/borrowck.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "7f95d44fd3b85f85ae10ca4e0fbd01121cb395a4", "filename": "src/rustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 71, "deletions": 74, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "e0eb5519d4da34a4818008ffac231c1b39ea8ea4", "filename": "src/rustc/middle/borrowck/gather_loans.rs", "status": "modified", "additions": 63, "deletions": 51, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "71414e6e72453c334fe8d6ed227a39cf7da8ae19", "filename": "src/rustc/middle/borrowck/loan.rs", "status": "modified", "additions": 89, "deletions": 32, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Fborrowck%2Floan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Fborrowck%2Floan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Floan.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "556ea7867cfcac3ecc44205dda088d806c10c6d8", "filename": "src/rustc/middle/borrowck/preserve.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Fborrowck%2Fpreserve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Fborrowck%2Fpreserve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fpreserve.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "563ea8f84be76960fe09f672d5181cabe4717a8a", "filename": "src/rustc/middle/capture.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Fcapture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Fcapture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fcapture.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "fc040ecc4cd3af80acefef0d6ca6216bddb50f10", "filename": "src/rustc/middle/check_alt.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Fcheck_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Fcheck_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fcheck_alt.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "bdc042fb764e91fc6e86ec234ab089e676a939cc", "filename": "src/rustc/middle/check_const.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fcheck_const.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "3fa7f34fb33e27ef46205d7827207c5a7e86ddec", "filename": "src/rustc/middle/check_loop.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Fcheck_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Fcheck_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fcheck_loop.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "d0296ebd2e5448ceeff398c2d476b4dc0a462d8f", "filename": "src/rustc/middle/const_eval.rs", "status": "modified", "additions": 126, "deletions": 98, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fconst_eval.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "1b42c9bb4b67d6a19fc7a3f3dcab9be2ec878397", "filename": "src/rustc/middle/freevars.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ffreevars.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "e4dc9e8330e88d8cf3e6920c5754a914347f0755", "filename": "src/rustc/middle/kind.rs", "status": "modified", "additions": 57, "deletions": 44, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fkind.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "383fe2db3231c001a88f03df7db3370b16fde391", "filename": "src/rustc/middle/lang_items.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Flang_items.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "0768a09252247f96e955fddaeec4e05c0916d9b9", "filename": "src/rustc/middle/lint.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Flint.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "da3e7b175d0758406a77737ed6dc80020407cc37", "filename": "src/rustc/middle/liveness.rs", "status": "modified", "additions": 192, "deletions": 251, "changes": 443, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fliveness.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "a61cb28c16b1a925de2526f7bd2cda7f1edb1803", "filename": "src/rustc/middle/mem_categorization.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fmem_categorization.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "95280032ae0ab02495aa8cc1e4e311e65ac8b250", "filename": "src/rustc/middle/region.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fregion.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "3d2cd6a621cd540a8844257e94aa603a0c73d9d3", "filename": "src/rustc/middle/resolve.rs", "status": "modified", "additions": 638, "deletions": 431, "changes": 1069, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "6de9ad977c9fbdde78ed08cde2fa117f32249c5d", "filename": "src/rustc/middle/trans/alt.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "bf66ccbfeb5f88af52d4d456b599733764d718b2", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 40, "deletions": 151, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "ea992600ae19b7a537f7ae1f865c366e20589aa4", "filename": "src/rustc/middle/trans/build.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "175381a7bd1eedc9e370d43c2cedfbecb8ffa66e", "filename": "src/rustc/middle/trans/callee.rs", "status": "modified", "additions": 24, "deletions": 11, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "3997076f98713155bed3f0011b02167205806e3e", "filename": "src/rustc/middle/trans/closure.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "7f234349d711fdbc80179d6131fcf19e6e4fdacd", "filename": "src/rustc/middle/trans/common.rs", "status": "modified", "additions": 33, "deletions": 17, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "59a733433bf22b09d6fad00f115b8137d250f6f9", "filename": "src/rustc/middle/trans/controlflow.rs", "status": "modified", "additions": 26, "deletions": 15, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "84a3c81a97803bd1020a915502fdfd798de3fa27", "filename": "src/rustc/middle/trans/datum.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "2db0dd59cf918b8a03c2fb9f9b224ee7bbbc9d19", "filename": "src/rustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "b0702c80b39bf451d53fec79f86795428fe32d35", "filename": "src/rustc/middle/trans/expr.rs", "status": "modified", "additions": 20, "deletions": 30, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "d307fcb5dca0fb0b271cb02f9140cbc8ec2011a8", "filename": "src/rustc/middle/trans/foreign.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "af9f2899a54d019c63360c106ab30b82c0c9ed1a", "filename": "src/rustc/middle/trans/glue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "d3cc23094ee873a211046d1a7b2d540f3970f63b", "filename": "src/rustc/middle/trans/inline.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Finline.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "20dba35b231b75d1fad3d66ff742a6e39c21b0a0", "filename": "src/rustc/middle/trans/meth.rs", "status": "modified", "additions": 113, "deletions": 23, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "c2f106f631b19ae2c7ded27fdeda0110a5ff3a95", "filename": "src/rustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 56, "deletions": 28, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "a99ef96b2544a80e2732dc919402f914615bf601", "filename": "src/rustc/middle/trans/reachable.rs", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "c52b653d536c1408e7d9da6b7944415f1eeb75c1", "filename": "src/rustc/middle/trans/reflect.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "bfc172db3148a79a84ab87a5ffbb8e960795e149", "filename": "src/rustc/middle/trans/tvec.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "8b2efacd4d16a6da4cebd4e86c727c9c0e0c6c3e", "filename": "src/rustc/middle/trans/type_use.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "90527e88bc850d6482626023731a421f6ad47ca5", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 129, "deletions": 112, "changes": 241, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "90aacb4b7ce6145ebc5c6ba5605dac8d76c4bdd4", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "da7a71b3efbf78d85a3dbeca6afa5bf185c190f0", "filename": "src/rustc/middle/typeck/astconv.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "cc542e9f36636d8cca71262ed4770a42e36afcfb", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 69, "deletions": 50, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "caace6051982e69d65f38a006ddb0fb997f12b2c", "filename": "src/rustc/middle/typeck/check/alt.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "eaf1a45afa9c08934b7ca52bec47beb30f2de4b0", "filename": "src/rustc/middle/typeck/check/method.rs", "status": "modified", "additions": 60, "deletions": 18, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "932cdd994da7d0b46b03126e126283a381099592", "filename": "src/rustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "806b234540cdca1e60991706fc7b99931c73a59e", "filename": "src/rustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "345b8246b4278d27391a9f9d0b148146553a5287", "filename": "src/rustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "189e7377d9c3097e4e65c044851e0ac67f73c272", "filename": "src/rustc/middle/typeck/coherence.rs", "status": "modified", "additions": 181, "deletions": 118, "changes": 299, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "e12104a21dadad1a71da87609ae84764e2b86e14", "filename": "src/rustc/middle/typeck/collect.rs", "status": "modified", "additions": 47, "deletions": 49, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "e0465b22c931fe98d99d5e062694397f401cc0b8", "filename": "src/rustc/middle/typeck/infer.rs", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "a5af58904dd77e5542bcfcc56385a259e98888de", "filename": "src/rustc/middle/typeck/infer/assignment.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fassignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fassignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fassignment.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "342a2ce2b76cdd87b9edc26b6871e7b00d2cc54e", "filename": "src/rustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "77e753fa2204f638c28d12210b7d81ba92f4bce4", "filename": "src/rustc/middle/typeck/infer/glb.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "1b23cb52b20c8c101e768399929385e1595c52b9", "filename": "src/rustc/middle/typeck/infer/integral.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fintegral.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fintegral.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fintegral.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "699613e8ae6557ed1b7bc03d8fd60c007ed1b457", "filename": "src/rustc/middle/typeck/infer/lattice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "dcff863a126f0aa080cc01bf8c24d1202da0b14b", "filename": "src/rustc/middle/typeck/infer/lub.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "86a872341f5618ea892ebcc2202d662323c9ccfb", "filename": "src/rustc/middle/typeck/infer/region_var_bindings.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_var_bindings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_var_bindings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_var_bindings.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "5a55fbf9a5dfc7165e34b879165c3e2c4f26c795", "filename": "src/rustc/middle/typeck/infer/resolve.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "0aba993512bb4917a8ebfa3d8e211b69b9a25f42", "filename": "src/rustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "c98a217a7464ef84d3b2004802753ba421c0c07a", "filename": "src/rustc/middle/typeck/infer/to_str.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "f865705563c60e3fac6d46ba4caf703f8e82ae7b", "filename": "src/rustc/middle/typeck/infer/unify.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "d379607d6a81f1d8ce3c689fb081336e0861663e", "filename": "src/rustc/middle/typeck/rscope.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Ftypeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Fmiddle%2Ftypeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Frscope.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "5d1b217e6238c644be09b4f839569275425b16d6", "filename": "src/rustc/rustc.rc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Frustc.rc?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "0448b022602a6a1f2eb52f1bce89efab3c082d4f", "filename": "src/rustc/util/common.rs", "status": "modified", "additions": 14, "deletions": 22, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Futil%2Fcommon.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "8207082cf20e69d87142b07ad409d52da04b9272", "filename": "src/rustc/util/ppaux.rs", "status": "modified", "additions": 9, "deletions": 15, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Futil%2Fppaux.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "7b2c6fe5f0cbc562e050ab3cedf17747df871bfa", "filename": "src/rustdoc/astsrv.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustdoc%2Fastsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustdoc%2Fastsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fastsrv.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "2b16112fe16c75751485b66777ae93c3011c3995", "filename": "src/rustdoc/attr_parser.rs", "status": "modified", "additions": 16, "deletions": 26, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustdoc%2Fattr_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustdoc%2Fattr_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fattr_parser.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "0748f603580b57d8cb2b0a4e56505ec82c8905f4", "filename": "src/rustdoc/attr_pass.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustdoc%2Fattr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustdoc%2Fattr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fattr_pass.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "1223f6b972329198cd67be8f7af179134d6e313b", "filename": "src/rustdoc/demo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustdoc%2Fdemo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustdoc%2Fdemo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fdemo.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "2d5bf5fc3c6935fa8eeb9b00cf29155502119c1a", "filename": "src/rustdoc/doc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustdoc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustdoc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fdoc.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "e8d914bd2cb8a4f99b487b1891c04ed2c5255b11", "filename": "src/rustdoc/fold.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustdoc%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustdoc%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Ffold.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "99357e254a4742b63c51632557702a95fe5d8319", "filename": "src/rustdoc/markdown_pass.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustdoc%2Fmarkdown_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustdoc%2Fmarkdown_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fmarkdown_pass.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "1ed007def6334e09e132a8d722159f050ccf5234", "filename": "src/rustdoc/markdown_writer.rs", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustdoc%2Fmarkdown_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustdoc%2Fmarkdown_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fmarkdown_writer.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "fc911d23e043a66c70fd39e7874cfec266ab6bb9", "filename": "src/rustdoc/page_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustdoc%2Fpage_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustdoc%2Fpage_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fpage_pass.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "7fc17dfe83861f798d3322f740a46ce9a8efbdc3", "filename": "src/rustdoc/parse.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustdoc%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustdoc%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fparse.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "e8f0ec00545259aeef2b7ceacc5b61e8b71c08af", "filename": "src/rustdoc/rustdoc.rc", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustdoc%2Frustdoc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustdoc%2Frustdoc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Frustdoc.rc?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "e09f57339a7c6451a3fbef70bdfd2c49616eed80", "filename": "src/rustdoc/rustdoc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustdoc%2Frustdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustdoc%2Frustdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Frustdoc.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "d4d9e7e5156688128bcaafde34e4ea41f6fb8cfa", "filename": "src/rustdoc/sort_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustdoc%2Fsort_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustdoc%2Fsort_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fsort_pass.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "f5ba9e9a2c9a417c7fb2141398ee22267fc8cfa4", "filename": "src/rustdoc/text_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustdoc%2Ftext_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustdoc%2Ftext_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Ftext_pass.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "498a4e137f0e38de6cdd85142fdf90a0d63b46a3", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "05a4ec10c45de4bb449cf5047dea1949d97a51a7", "filename": "src/snapshots.txt", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Fsnapshots.txt", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Fsnapshots.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsnapshots.txt?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "ec9398dea15ec317fea7fd34a35e290bb27c46a2", "filename": "src/test/auxiliary/anon_trait_static_method_lib.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fauxiliary%2Fanon_trait_static_method_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fauxiliary%2Fanon_trait_static_method_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fanon_trait_static_method_lib.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "da1a8b5f0ed85fa61cb066ef6f5ae71e2f1150c3", "filename": "src/test/auxiliary/cci_class_6.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fauxiliary%2Fcci_class_6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fauxiliary%2Fcci_class_6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_class_6.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "ca2af38758779ae32927f528e96a60975045d85d", "filename": "src/test/auxiliary/cci_class_cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fauxiliary%2Fcci_class_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fauxiliary%2Fcci_class_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_class_cast.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "532c669bd1d207484e144b58a27d5ab295bdfb16", "filename": "src/test/auxiliary/issue_3136_a.rc", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fauxiliary%2Fissue_3136_a.rc", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fauxiliary%2Fissue_3136_a.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue_3136_a.rc?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "b3af68803232603c7b23ec5ceb04ebaeb8bb33fe", "filename": "src/test/auxiliary/issue_3136_a.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fauxiliary%2Fissue_3136_a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fauxiliary%2Fissue_3136_a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue_3136_a.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "18960d0ad8aa2db800123f77905ab6a0313c93ab", "filename": "src/test/auxiliary/test_comm.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fauxiliary%2Ftest_comm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fauxiliary%2Ftest_comm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Ftest_comm.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "c877d1d3657798346fdd4dad299cc1d34e58dae7", "filename": "src/test/bench/graph500-bfs.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fgraph500-bfs.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "88ca0d3e0c2d606fbe12ed1c76924274cdf3239b", "filename": "src/test/bench/msgsend-pipes-shared.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "ce3fd5134ac5670ddc4af6b99385542fdac7076f", "filename": "src/test/bench/msgsend-pipes.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "3ec89567d206b43c72a44d23676001c96ded3935", "filename": "src/test/bench/msgsend-ring-mutex-arcs.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "68429ee01bb7da7224bd732dc921e560ba30e253", "filename": "src/test/bench/msgsend-ring-pipes.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fbench%2Fmsgsend-ring-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fbench%2Fmsgsend-ring-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-pipes.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "5e3d2f7d3e08c9e1a62dee9669773835d57c9e89", "filename": "src/test/bench/msgsend-ring-rw-arcs.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "5cb278b0dd2e3339e42c2a99879cb761fbfddcf1", "filename": "src/test/bench/msgsend-ring.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fbench%2Fmsgsend-ring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fbench%2Fmsgsend-ring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "6ab22779c55f18e43dafad773ad4587cb21186fa", "filename": "src/test/bench/msgsend.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fbench%2Fmsgsend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fbench%2Fmsgsend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "e7f9312ce386e6f6557cd6208f7c9113f0ea6068", "filename": "src/test/bench/pingpong.rs", "status": "modified", "additions": 20, "deletions": 24, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fbench%2Fpingpong.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fbench%2Fpingpong.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fpingpong.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "3a3c609853b37c7f3c9240b6185f00d7ff34abdd", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "a776c1322d380897b011978429b7aecc6a98cce9", "filename": "src/test/bench/shootout-pfib.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "921aa8f0657fd90a173ec16041891431be561f00", "filename": "src/test/bench/sudoku.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fbench%2Fsudoku.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fbench%2Fsudoku.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fsudoku.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "55d75ff7c82d3c9300f6317f4ed80895ac11ad3d", "filename": "src/test/bench/task-perf-alloc-unwind.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "09e6f23004a12a06072a604b4e7e653f138da5d4", "filename": "src/test/bench/task-perf-jargon-metal-smoke.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "f148d595f9d5a0a9df1c26c6e3134b5c868de5a2", "filename": "src/test/bench/task-perf-linked-failure.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fbench%2Ftask-perf-linked-failure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fbench%2Ftask-perf-linked-failure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-linked-failure.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "3fe192ed36391e3be804bfcc843ca1a6a9ea53a6", "filename": "src/test/bench/task-perf-word-count-generic.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "6cd22b7f5350221a1f70daedf2817c5fd67f900f", "filename": "src/test/compile-fail/borrowck-borrowed-uniq-rvalue-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fcompile-fail%2Fborrowck-borrowed-uniq-rvalue-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fcompile-fail%2Fborrowck-borrowed-uniq-rvalue-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-borrowed-uniq-rvalue-2.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "69ff3b103786cf01c269481b5617e49d16f919ac", "filename": "src/test/compile-fail/borrowck-imm-field-imm-base.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fcompile-fail%2Fborrowck-imm-field-imm-base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fcompile-fail%2Fborrowck-imm-field-imm-base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-imm-field-imm-base.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "6b9d93462d94589bad77f80643093624cb5c30a5", "filename": "src/test/compile-fail/borrowck-imm-field-mut-base.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fcompile-fail%2Fborrowck-imm-field-mut-base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fcompile-fail%2Fborrowck-imm-field-mut-base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-imm-field-mut-base.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "e48756bbbeb35a4a8213ec60142f198331dcd968", "filename": "src/test/compile-fail/borrowck-loan-blocks-move.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-move.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "54048ed2fd8cbb768884c0059a27fc43efbf691f", "filename": "src/test/compile-fail/borrowck-loan-local-as-both-mut-and-imm.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-local-as-both-mut-and-imm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-local-as-both-mut-and-imm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-local-as-both-mut-and-imm.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "f13637ab86a8b51934caa4fa8712624d29f357dc", "filename": "src/test/compile-fail/borrowck-mut-field-imm-base.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-field-imm-base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-field-imm-base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-field-imm-base.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "1d1595383ee7f3f0a0a8dda1a1c39540330c8b48", "filename": "src/test/compile-fail/borrowck-unary-move-2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fcompile-fail%2Fborrowck-unary-move-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fcompile-fail%2Fborrowck-unary-move-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-unary-move-2.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "a19dfc9e9f4a30904266c9b6b997c0be376d2b9e", "filename": "src/test/compile-fail/cap-clause-use-after-move.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fcompile-fail%2Fcap-clause-use-after-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fcompile-fail%2Fcap-clause-use-after-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcap-clause-use-after-move.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "51e0934bfe00f1689416675ad92f9b47e8579760", "filename": "src/test/compile-fail/copy-into-closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fcompile-fail%2Fcopy-into-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fcompile-fail%2Fcopy-into-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcopy-into-closure.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "32997fcce31a66ddbb29bd571dbba1ef577733c1", "filename": "src/test/compile-fail/duplicate-visibility.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fcompile-fail%2Fduplicate-visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fcompile-fail%2Fduplicate-visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fduplicate-visibility.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "626e7eff3f7cbf3da6529a0cadeda24ea4cedc97", "filename": "src/test/compile-fail/estr-subtyping.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fcompile-fail%2Festr-subtyping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fcompile-fail%2Festr-subtyping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Festr-subtyping.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "e5e9aa0c2579f8194de6a7ff2a0aaa381c363fca", "filename": "src/test/compile-fail/evec-subtyping.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fcompile-fail%2Fevec-subtyping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fcompile-fail%2Fevec-subtyping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fevec-subtyping.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "1db0e0a39ee1bff1ade2a8c744ac172932e54e5c", "filename": "src/test/compile-fail/extenv-no-args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fcompile-fail%2Fextenv-no-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fcompile-fail%2Fextenv-no-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextenv-no-args.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "4f0df2a090fbdcaa3246e17293d77a1b36a7405c", "filename": "src/test/compile-fail/extenv-too-many-args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fcompile-fail%2Fextenv-too-many-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fcompile-fail%2Fextenv-too-many-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextenv-too-many-args.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "1cca7e5b315b808b37db6cd3e9f71230ed5b68ce", "filename": "src/test/compile-fail/extfmt-no-args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fcompile-fail%2Fextfmt-no-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fcompile-fail%2Fextfmt-no-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextfmt-no-args.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "7255bd84631822857189fb5d1bcdf820f49251c0", "filename": "src/test/compile-fail/extfmt-non-literal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fcompile-fail%2Fextfmt-non-literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fcompile-fail%2Fextfmt-non-literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextfmt-non-literal.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "0196c37c68ee50f1df40abb6004d8f8f14537c15", "filename": "src/test/compile-fail/extfmt-non-literal2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fcompile-fail%2Fextfmt-non-literal2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fcompile-fail%2Fextfmt-non-literal2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextfmt-non-literal2.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "1dd3ed390d51dda01b4ff5751102959974e96c60", "filename": "src/test/compile-fail/extfmt-unsigned-plus.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fcompile-fail%2Fextfmt-unsigned-plus.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fcompile-fail%2Fextfmt-unsigned-plus.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextfmt-unsigned-plus.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "a2ac54bea7d99b4d72dcbc8a1f8940338d998844", "filename": "src/test/compile-fail/extfmt-unsigned-space.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fcompile-fail%2Fextfmt-unsigned-space.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fcompile-fail%2Fextfmt-unsigned-space.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextfmt-unsigned-space.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "8d7913a62faa70da2cff8fecc91fc8dae5a49eeb", "filename": "src/test/compile-fail/functional-struct-update.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fcompile-fail%2Ffunctional-struct-update.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fcompile-fail%2Ffunctional-struct-update.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffunctional-struct-update.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "ee318d7b02caca640593d3c9752ee0fef63914d5", "filename": "src/test/compile-fail/issue-1965.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fcompile-fail%2Fissue-1965.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fcompile-fail%2Fissue-1965.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-1965.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "d911b7db3dd4d90cf4f1076e4bcdcc171d0a8f60", "filename": "src/test/compile-fail/issue-2074.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fcompile-fail%2Fissue-2074.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fcompile-fail%2Fissue-2074.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2074.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "0d491fc8834acce08d84a3dc1967d568bb1dfd03", "filename": "src/test/compile-fail/issue-2548.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fcompile-fail%2Fissue-2548.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fcompile-fail%2Fissue-2548.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2548.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "0f4a4804c751c81b8a1757537752a0e9f3bff849", "filename": "src/test/compile-fail/issue-2590.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fcompile-fail%2Fissue-2590.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fcompile-fail%2Fissue-2590.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2590.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "590ea5e0b7ccf8a5d602bf9b20617f64abb9420b", "filename": "src/test/compile-fail/issue-2766-a.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fcompile-fail%2Fissue-2766-a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fcompile-fail%2Fissue-2766-a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2766-a.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "fd2c17584581c929c1ab6f04971570f20b71622a", "filename": "src/test/compile-fail/issue-2823.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fcompile-fail%2Fissue-2823.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fcompile-fail%2Fissue-2823.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2823.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "fee676ed5e2822870d8f0ce34086e0ea6866b288", "filename": "src/test/compile-fail/issue-3099-a.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fcompile-fail%2Fissue-3099-a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fcompile-fail%2Fissue-3099-a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3099-a.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "dc393eb752070b3e9a8c50e270b659e4503cf3cf", "filename": "src/test/compile-fail/issue-3099-b.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fcompile-fail%2Fissue-3099-b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fcompile-fail%2Fissue-3099-b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3099-b.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "79212686130a21d72e3e4e324204aab02f3ed852", "filename": "src/test/compile-fail/issue-3099.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fcompile-fail%2Fissue-3099.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fcompile-fail%2Fissue-3099.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3099.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "7008f8c4ce29356af1b2b366fde5412a90e6a69a", "filename": "src/test/compile-fail/issue-3214.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fcompile-fail%2Fissue-3214.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fcompile-fail%2Fissue-3214.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3214.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "5af0417af047fe03673b0a1f3374f6a9effab181", "filename": "src/test/compile-fail/issue-3521-2.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fcompile-fail%2Fissue-3521-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fcompile-fail%2Fissue-3521-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3521-2.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "9ad483367fe9134913b050ab630b943f73742289", "filename": "src/test/compile-fail/issue-3521.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fcompile-fail%2Fissue-3521.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fcompile-fail%2Fissue-3521.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3521.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "89c9e2b2e91e1fb0f137f2133c7a73ae1bcd3f1a", "filename": "src/test/compile-fail/issue-3668-2.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fcompile-fail%2Fissue-3668-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fcompile-fail%2Fissue-3668-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3668-2.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "6cbd64c6aa9bd6e7e733113d7c8d255c6ba579f9", "filename": "src/test/compile-fail/issue-3668.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fcompile-fail%2Fissue-3668.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fcompile-fail%2Fissue-3668.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3668.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "48f72dd0d3e8b4c64680fd68014f62ec4c1695b4", "filename": "src/test/compile-fail/liveness-move-from-args.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fcompile-fail%2Fliveness-move-from-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fcompile-fail%2Fliveness-move-from-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-move-from-args.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "959bda4e5834202763fc6db54d4347c2b739c7ed", "filename": "src/test/compile-fail/liveness-move-from-mode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fcompile-fail%2Fliveness-move-from-mode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fcompile-fail%2Fliveness-move-from-mode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-move-from-mode.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "473a133730a4f9103d504812cfe1565116fa38a2", "filename": "src/test/compile-fail/liveness-unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fcompile-fail%2Fliveness-unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fcompile-fail%2Fliveness-unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-unused.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "13952dbe3c1118b58e07b0b9a6fc7487a91a27be", "filename": "src/test/compile-fail/liveness-use-after-send.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fcompile-fail%2Fliveness-use-after-send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fcompile-fail%2Fliveness-use-after-send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-use-after-send.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "c8a8bd859615f96fce990df40f40d011d804ac31", "filename": "src/test/compile-fail/obsolete-syntax.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fcompile-fail%2Fobsolete-syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fcompile-fail%2Fobsolete-syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fobsolete-syntax.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "b163006c50a680a17b8a3998e82622076bbb3a32", "filename": "src/test/compile-fail/regions-freevar.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fcompile-fail%2Fregions-freevar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fcompile-fail%2Fregions-freevar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-freevar.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "e4913f7056e85422ff585bee85860e79228481ec", "filename": "src/test/compile-fail/regions-glb-free-free.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fcompile-fail%2Fregions-glb-free-free.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fcompile-fail%2Fregions-glb-free-free.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-glb-free-free.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "f5bd208f00f0a8dc5f76911635c33ce071f0a792", "filename": "src/test/compile-fail/tag-that-dare-not-speak-its-name.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fcompile-fail%2Ftag-that-dare-not-speak-its-name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fcompile-fail%2Ftag-that-dare-not-speak-its-name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftag-that-dare-not-speak-its-name.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "b31583724d214eb9d34981ac965a49d50f75eec2", "filename": "src/test/compile-fail/unique-unique-kind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fcompile-fail%2Funique-unique-kind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fcompile-fail%2Funique-unique-kind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funique-unique-kind.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "a84c1397319f5502d686c06bb74747cd418cfea2", "filename": "src/test/compile-fail/unsendable-class.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fcompile-fail%2Funsendable-class.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fcompile-fail%2Funsendable-class.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsendable-class.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "d677577e4424027d5567fb69287070870d19975a", "filename": "src/test/pretty/blank-lines.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fpretty%2Fblank-lines.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Fpretty%2Fblank-lines.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fblank-lines.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "37beb7b895ed099a20a659bb5d5a2695b1ce10f3", "filename": "src/test/run-fail/doublefail.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Frun-fail%2Fdoublefail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Frun-fail%2Fdoublefail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fdoublefail.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "9f2974d2cc2703ad556d2cd031b3ed115d670b73", "filename": "src/test/run-fail/port-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Frun-fail%2Fport-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Frun-fail%2Fport-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fport-type.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "ca85aa970173449fc02a57be5d4c1b5df806dda0", "filename": "src/test/run-fail/unwind-box-res.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Frun-fail%2Funwind-box-res.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Frun-fail%2Funwind-box-res.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Funwind-box-res.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}, {"sha": "995edbcc05ba39daca487e6fb0ceaf3e4b0f3673", "filename": "src/test/run-fail/unwind-move.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Frun-fail%2Funwind-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc0f2c6bb26ba38d3487a396fa8625e938af6820/src%2Ftest%2Frun-fail%2Funwind-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Funwind-move.rs?ref=cc0f2c6bb26ba38d3487a396fa8625e938af6820"}]}