{"sha": "5945e85f34067a584800d853f99de84f079f7150", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU5NDVlODVmMzQwNjdhNTg0ODAwZDg1M2Y5OWRlODRmMDc5ZjcxNTA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-03-07T12:04:42Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-03-07T12:04:42Z"}, "message": "Auto merge of #6823 - Jarcho:diagnostic_items, r=phansch\n\nUse diagnostic or language items instead of paths\n\nI think that gets everything except ones used in a list of paths to check.\n\nchangelog: none", "tree": {"sha": "8c8ef7b4fac66d47f44dc16a2e3c20a3a4a634ef", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8c8ef7b4fac66d47f44dc16a2e3c20a3a4a634ef"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5945e85f34067a584800d853f99de84f079f7150", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5945e85f34067a584800d853f99de84f079f7150", "html_url": "https://github.com/rust-lang/rust/commit/5945e85f34067a584800d853f99de84f079f7150", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5945e85f34067a584800d853f99de84f079f7150/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "13271d3344c342aa0b70d96951ad214aad83c46a", "url": "https://api.github.com/repos/rust-lang/rust/commits/13271d3344c342aa0b70d96951ad214aad83c46a", "html_url": "https://github.com/rust-lang/rust/commit/13271d3344c342aa0b70d96951ad214aad83c46a"}, {"sha": "e4ffff9e72f155dfcd1fda6042b725007973835d", "url": "https://api.github.com/repos/rust-lang/rust/commits/e4ffff9e72f155dfcd1fda6042b725007973835d", "html_url": "https://github.com/rust-lang/rust/commit/e4ffff9e72f155dfcd1fda6042b725007973835d"}], "stats": {"total": 194, "additions": 109, "deletions": 85}, "files": [{"sha": "b15fe65352ab1205ff4f517c3f1437ad5d107cd2", "filename": "clippy_lints/src/case_sensitive_file_extension_comparisons.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5945e85f34067a584800d853f99de84f079f7150/clippy_lints%2Fsrc%2Fcase_sensitive_file_extension_comparisons.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5945e85f34067a584800d853f99de84f079f7150/clippy_lints%2Fsrc%2Fcase_sensitive_file_extension_comparisons.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcase_sensitive_file_extension_comparisons.rs?ref=5945e85f34067a584800d853f99de84f079f7150", "patch": "@@ -1,12 +1,11 @@\n-use crate::utils::paths::STRING;\n-use crate::utils::{match_def_path, span_lint_and_help};\n+use crate::utils::span_lint_and_help;\n use if_chain::if_chain;\n use rustc_ast::ast::LitKind;\n use rustc_hir::{Expr, ExprKind, PathSegment};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::{source_map::Spanned, Span};\n+use rustc_span::{source_map::Spanned, symbol::sym, Span};\n \n declare_clippy_lint! {\n     /// **What it does:**\n@@ -59,7 +58,7 @@ fn check_case_sensitive_file_extension_comparison(ctx: &LateContext<'_>, expr: &\n                     return Some(span);\n                 },\n                 ty::Adt(&ty::AdtDef { did, .. }, _) => {\n-                    if match_def_path(ctx, did, &STRING) {\n+                    if ctx.tcx.is_diagnostic_item(sym::string_type, did) {\n                         return Some(span);\n                     }\n                 },"}, {"sha": "382a045a3f7cc761ae1fdc66212726cb880de587", "filename": "clippy_lints/src/derive.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5945e85f34067a584800d853f99de84f079f7150/clippy_lints%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5945e85f34067a584800d853f99de84f079f7150/clippy_lints%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fderive.rs?ref=5945e85f34067a584800d853f99de84f079f7150", "patch": "@@ -1,6 +1,6 @@\n use crate::utils::paths;\n use crate::utils::{\n-    get_trait_def_id, is_allowed, is_automatically_derived, is_copy, match_def_path, match_path, span_lint_and_help,\n+    get_trait_def_id, is_allowed, is_automatically_derived, is_copy, match_def_path, span_lint_and_help,\n     span_lint_and_note, span_lint_and_then,\n };\n use if_chain::if_chain;\n@@ -293,7 +293,7 @@ fn check_ord_partial_ord<'tcx>(\n \n /// Implementation of the `EXPL_IMPL_CLONE_ON_COPY` lint.\n fn check_copy_clone<'tcx>(cx: &LateContext<'tcx>, item: &Item<'_>, trait_ref: &TraitRef<'_>, ty: Ty<'tcx>) {\n-    if match_path(&trait_ref.path, &paths::CLONE_TRAIT) {\n+    if cx.tcx.lang_items().clone_trait() == trait_ref.trait_def_id() {\n         if !is_copy(cx, ty) {\n             return;\n         }"}, {"sha": "3807d346f681683e60a4a2efcc70f3ea2c06efe4", "filename": "clippy_lints/src/lifetimes.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5945e85f34067a584800d853f99de84f079f7150/clippy_lints%2Fsrc%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5945e85f34067a584800d853f99de84f079f7150/clippy_lints%2Fsrc%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flifetimes.rs?ref=5945e85f34067a584800d853f99de84f079f7150", "patch": "@@ -1,5 +1,4 @@\n-use crate::utils::paths;\n-use crate::utils::{get_trait_def_id, in_macro, span_lint, trait_ref_of_method};\n+use crate::utils::{in_macro, span_lint, trait_ref_of_method};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir::intravisit::{\n     walk_fn_decl, walk_generic_param, walk_generics, walk_item, walk_param_bound, walk_poly_trait_ref, walk_ty,\n@@ -8,8 +7,8 @@ use rustc_hir::intravisit::{\n use rustc_hir::FnRetTy::Return;\n use rustc_hir::{\n     BareFnTy, BodyId, FnDecl, GenericArg, GenericBound, GenericParam, GenericParamKind, Generics, ImplItem,\n-    ImplItemKind, Item, ItemKind, Lifetime, LifetimeName, ParamName, PolyTraitRef, TraitBoundModifier, TraitFn,\n-    TraitItem, TraitItemKind, Ty, TyKind, WhereClause, WherePredicate,\n+    ImplItemKind, Item, ItemKind, LangItem, Lifetime, LifetimeName, ParamName, PolyTraitRef, TraitBoundModifier,\n+    TraitFn, TraitItem, TraitItemKind, Ty, TyKind, WhereClause, WherePredicate,\n };\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::hir::map::Map;\n@@ -300,7 +299,7 @@ fn unique_lifetimes(lts: &[RefLt]) -> usize {\n     lts.iter().collect::<FxHashSet<_>>().len()\n }\n \n-const CLOSURE_TRAIT_BOUNDS: [&[&str]; 3] = [&paths::FN, &paths::FN_MUT, &paths::FN_ONCE];\n+const CLOSURE_TRAIT_BOUNDS: [LangItem; 3] = [LangItem::Fn, LangItem::FnMut, LangItem::FnOnce];\n \n /// A visitor usable for `rustc_front::visit::walk_ty()`.\n struct RefVisitor<'a, 'tcx> {\n@@ -361,7 +360,7 @@ impl<'a, 'tcx> Visitor<'tcx> for RefVisitor<'a, 'tcx> {\n         let trait_ref = &poly_tref.trait_ref;\n         if CLOSURE_TRAIT_BOUNDS\n             .iter()\n-            .any(|trait_path| trait_ref.trait_def_id() == get_trait_def_id(self.cx, trait_path))\n+            .any(|&item| trait_ref.trait_def_id() == self.cx.tcx.lang_items().require(item).ok())\n         {\n             let mut sub_visitor = RefVisitor::new(self.cx);\n             sub_visitor.visit_trait_ref(trait_ref);"}, {"sha": "0c358e2e538b19b560aa6dfe0e9b4d0784c10c59", "filename": "clippy_lints/src/map_clone.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5945e85f34067a584800d853f99de84f079f7150/clippy_lints%2Fsrc%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5945e85f34067a584800d853f99de84f079f7150/clippy_lints%2Fsrc%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_clone.rs?ref=5945e85f34067a584800d853f99de84f079f7150", "patch": "@@ -79,7 +79,9 @@ impl<'tcx> LateLintPass<'tcx> for MapClone {\n                             },\n                             hir::ExprKind::MethodCall(ref method, _, [obj], _) => if_chain! {\n                                 if ident_eq(name, obj) && method.ident.name == sym::clone;\n-                                if match_trait_method(cx, closure_expr, &paths::CLONE_TRAIT);\n+                                if let Some(fn_id) = cx.typeck_results().type_dependent_def_id(closure_expr.hir_id);\n+                                if let Some(trait_id) = cx.tcx.trait_of_item(fn_id);\n+                                if Some(trait_id) == cx.tcx.lang_items().clone_trait();\n                                 // no autoderefs\n                                 if !cx.typeck_results().expr_adjustments(obj).iter()\n                                     .any(|a| matches!(a.kind, Adjust::Deref(Some(..))));"}, {"sha": "d74ba10ac506f833a56a78c0377483db276a63a6", "filename": "clippy_lints/src/redundant_clone.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5945e85f34067a584800d853f99de84f079f7150/clippy_lints%2Fsrc%2Fredundant_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5945e85f34067a584800d853f99de84f079f7150/clippy_lints%2Fsrc%2Fredundant_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_clone.rs?ref=5945e85f34067a584800d853f99de84f079f7150", "patch": "@@ -165,7 +165,7 @@ impl<'tcx> LateLintPass<'tcx> for RedundantClone {\n                     if let Some((pred_fn_def_id, pred_arg, pred_arg_ty, res)) =\n                         is_call_with_ref_arg(cx, mir, &pred_terminator.kind);\n                     if res == cloned;\n-                    if match_def_path(cx, pred_fn_def_id, &paths::DEREF_TRAIT_METHOD);\n+                    if cx.tcx.is_diagnostic_item(sym::deref_method, pred_fn_def_id);\n                     if match_type(cx, pred_arg_ty, &paths::PATH_BUF)\n                         || match_type(cx, pred_arg_ty, &paths::OS_STRING);\n                     then {"}, {"sha": "c420be26fc644fbceda0dfc189a7928f09b90679", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 71, "deletions": 62, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/5945e85f34067a584800d853f99de84f079f7150/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5945e85f34067a584800d853f99de84f079f7150/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=5945e85f34067a584800d853f99de84f079f7150", "patch": "@@ -11,8 +11,8 @@ use rustc_hir as hir;\n use rustc_hir::intravisit::{walk_body, walk_expr, walk_ty, FnKind, NestedVisitorMap, Visitor};\n use rustc_hir::{\n     BinOpKind, Block, Body, Expr, ExprKind, FnDecl, FnRetTy, FnSig, GenericArg, GenericBounds, GenericParamKind, HirId,\n-    ImplItem, ImplItemKind, Item, ItemKind, Lifetime, Lit, Local, MatchSource, MutTy, Mutability, Node, QPath, Stmt,\n-    StmtKind, SyntheticTyParamKind, TraitFn, TraitItem, TraitItemKind, TyKind, UnOp,\n+    ImplItem, ImplItemKind, Item, ItemKind, LangItem, Lifetime, Lit, Local, MatchSource, MutTy, Mutability, Node,\n+    QPath, Stmt, StmtKind, SyntheticTyParamKind, TraitFn, TraitItem, TraitItemKind, TyKind, UnOp,\n };\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::hir::map::Map;\n@@ -23,7 +23,7 @@ use rustc_semver::RustcVersion;\n use rustc_session::{declare_lint_pass, declare_tool_lint, impl_lint_pass};\n use rustc_span::hygiene::{ExpnKind, MacroKind};\n use rustc_span::source_map::Span;\n-use rustc_span::symbol::sym;\n+use rustc_span::symbol::{sym, Symbol};\n use rustc_target::abi::LayoutOf;\n use rustc_target::spec::abi::Abi;\n use rustc_typeck::hir_ty_to_ty;\n@@ -32,9 +32,9 @@ use crate::consts::{constant, Constant};\n use crate::utils::paths;\n use crate::utils::sugg::Sugg;\n use crate::utils::{\n-    clip, comparisons, differing_macro_contexts, higher, in_constant, indent_of, int_bits, is_hir_ty_cfg_dependant,\n-    is_type_diagnostic_item, last_path_segment, match_def_path, match_path, meets_msrv, method_chain_args,\n-    multispan_sugg, numeric_literal::NumericLiteral, reindent_multiline, sext, snippet, snippet_opt,\n+    clip, comparisons, differing_macro_contexts, get_qpath_generic_tys, higher, in_constant, indent_of, int_bits,\n+    is_hir_ty_cfg_dependant, is_type_diagnostic_item, last_path_segment, match_def_path, match_path, meets_msrv,\n+    method_chain_args, multispan_sugg, numeric_literal::NumericLiteral, reindent_multiline, sext, snippet, snippet_opt,\n     snippet_with_applicability, snippet_with_macro_callsite, span_lint, span_lint_and_help, span_lint_and_sugg,\n     span_lint_and_then, unsext,\n };\n@@ -287,37 +287,55 @@ impl<'tcx> LateLintPass<'tcx> for Types {\n     }\n }\n \n-/// Checks if `qpath` has last segment with type parameter matching `path`\n-fn match_type_parameter(cx: &LateContext<'_>, qpath: &QPath<'_>, path: &[&str]) -> Option<Span> {\n-    let last = last_path_segment(qpath);\n-    if_chain! {\n-        if let Some(ref params) = last.args;\n-        if !params.parenthesized;\n-        if let Some(ty) = params.args.iter().find_map(|arg| match arg {\n-            GenericArg::Type(ty) => Some(ty),\n-            _ => None,\n-        });\n-        if let TyKind::Path(ref qpath) = ty.kind;\n-        if let Some(did) = cx.qpath_res(qpath, ty.hir_id).opt_def_id();\n-        if match_def_path(cx, did, path);\n-        then {\n-            return Some(ty.span);\n-        }\n+/// Checks if the first type parameter is a lang item.\n+fn is_ty_param_lang_item(cx: &LateContext<'_>, qpath: &QPath<'tcx>, item: LangItem) -> Option<&'tcx hir::Ty<'tcx>> {\n+    let ty = get_qpath_generic_tys(qpath).next()?;\n+\n+    if let TyKind::Path(qpath) = &ty.kind {\n+        cx.qpath_res(qpath, ty.hir_id)\n+            .opt_def_id()\n+            .and_then(|id| (cx.tcx.lang_items().require(item) == Ok(id)).then(|| ty))\n+    } else {\n+        None\n     }\n-    None\n }\n \n-fn match_buffer_type(cx: &LateContext<'_>, qpath: &QPath<'_>) -> Option<&'static str> {\n-    if match_type_parameter(cx, qpath, &paths::STRING).is_some() {\n-        return Some(\"str\");\n+/// Checks if the first type parameter is a diagnostic item.\n+fn is_ty_param_diagnostic_item(cx: &LateContext<'_>, qpath: &QPath<'tcx>, item: Symbol) -> Option<&'tcx hir::Ty<'tcx>> {\n+    let ty = get_qpath_generic_tys(qpath).next()?;\n+\n+    if let TyKind::Path(qpath) = &ty.kind {\n+        cx.qpath_res(qpath, ty.hir_id)\n+            .opt_def_id()\n+            .and_then(|id| cx.tcx.is_diagnostic_item(item, id).then(|| ty))\n+    } else {\n+        None\n     }\n-    if match_type_parameter(cx, qpath, &paths::OS_STRING).is_some() {\n-        return Some(\"std::ffi::OsStr\");\n+}\n+\n+/// Checks if the first type parameter is a given item.\n+fn is_ty_param_path(cx: &LateContext<'_>, qpath: &QPath<'tcx>, path: &[&str]) -> Option<&'tcx hir::Ty<'tcx>> {\n+    let ty = get_qpath_generic_tys(qpath).next()?;\n+\n+    if let TyKind::Path(qpath) = &ty.kind {\n+        cx.qpath_res(qpath, ty.hir_id)\n+            .opt_def_id()\n+            .and_then(|id| match_def_path(cx, id, path).then(|| ty))\n+    } else {\n+        None\n     }\n-    if match_type_parameter(cx, qpath, &paths::PATH_BUF).is_some() {\n-        return Some(\"std::path::Path\");\n+}\n+\n+fn match_buffer_type(cx: &LateContext<'_>, qpath: &QPath<'_>) -> Option<&'static str> {\n+    if is_ty_param_diagnostic_item(cx, qpath, sym::string_type).is_some() {\n+        Some(\"str\")\n+    } else if is_ty_param_path(cx, qpath, &paths::OS_STRING).is_some() {\n+        Some(\"std::ffi::OsStr\")\n+    } else if is_ty_param_path(cx, qpath, &paths::PATH_BUF).is_some() {\n+        Some(\"std::path::Path\")\n+    } else {\n+        None\n     }\n-    None\n }\n \n fn match_borrows_parameter(_cx: &LateContext<'_>, qpath: &QPath<'_>) -> Option<Span> {\n@@ -381,7 +399,7 @@ impl Types {\n                             );\n                             return; // don't recurse into the type\n                         }\n-                        if match_type_parameter(cx, qpath, &paths::VEC).is_some() {\n+                        if is_ty_param_diagnostic_item(cx, qpath, sym::vec_type).is_some() {\n                             span_lint_and_help(\n                                 cx,\n                                 BOX_VEC,\n@@ -393,30 +411,27 @@ impl Types {\n                             return; // don't recurse into the type\n                         }\n                     } else if cx.tcx.is_diagnostic_item(sym::Rc, def_id) {\n-                        if let Some(span) = match_type_parameter(cx, qpath, &paths::RC) {\n+                        if let Some(ty) = is_ty_param_diagnostic_item(cx, qpath, sym::Rc) {\n                             let mut applicability = Applicability::MachineApplicable;\n                             span_lint_and_sugg(\n                                 cx,\n                                 REDUNDANT_ALLOCATION,\n                                 hir_ty.span,\n                                 \"usage of `Rc<Rc<T>>`\",\n                                 \"try\",\n-                                snippet_with_applicability(cx, span, \"..\", &mut applicability).to_string(),\n+                                snippet_with_applicability(cx, ty.span, \"..\", &mut applicability).to_string(),\n                                 applicability,\n                             );\n                             return; // don't recurse into the type\n                         }\n-                        if match_type_parameter(cx, qpath, &paths::BOX).is_some() {\n-                            let box_ty = match &last_path_segment(qpath).args.unwrap().args[0] {\n-                                GenericArg::Type(ty) => match &ty.kind {\n-                                    TyKind::Path(qpath) => qpath,\n-                                    _ => return,\n-                                },\n+                        if let Some(ty) = is_ty_param_lang_item(cx, qpath, LangItem::OwnedBox) {\n+                            let qpath = match &ty.kind {\n+                                TyKind::Path(qpath) => qpath,\n                                 _ => return,\n                             };\n-                            let inner_span = match &last_path_segment(&box_ty).args.unwrap().args[0] {\n-                                GenericArg::Type(ty) => ty.span,\n-                                _ => return,\n+                            let inner_span = match get_qpath_generic_tys(qpath).next() {\n+                                Some(ty) => ty.span,\n+                                None => return,\n                             };\n                             let mut applicability = Applicability::MachineApplicable;\n                             span_lint_and_sugg(\n@@ -445,17 +460,14 @@ impl Types {\n                             );\n                             return; // don't recurse into the type\n                         }\n-                        if match_type_parameter(cx, qpath, &paths::VEC).is_some() {\n-                            let vec_ty = match &last_path_segment(qpath).args.unwrap().args[0] {\n-                                GenericArg::Type(ty) => match &ty.kind {\n-                                    TyKind::Path(qpath) => qpath,\n-                                    _ => return,\n-                                },\n+                        if let Some(ty) = is_ty_param_diagnostic_item(cx, qpath, sym::vec_type) {\n+                            let qpath = match &ty.kind {\n+                                TyKind::Path(qpath) => qpath,\n                                 _ => return,\n                             };\n-                            let inner_span = match &last_path_segment(&vec_ty).args.unwrap().args[0] {\n-                                GenericArg::Type(ty) => ty.span,\n-                                _ => return,\n+                            let inner_span = match get_qpath_generic_tys(qpath).next() {\n+                                Some(ty) => ty.span,\n+                                None => return,\n                             };\n                             let mut applicability = Applicability::MachineApplicable;\n                             span_lint_and_sugg(\n@@ -498,17 +510,14 @@ impl Types {\n                             );\n                             return; // don't recurse into the type\n                         }\n-                        if match_type_parameter(cx, qpath, &paths::VEC).is_some() {\n-                            let vec_ty = match &last_path_segment(qpath).args.unwrap().args[0] {\n-                                GenericArg::Type(ty) => match &ty.kind {\n-                                    TyKind::Path(qpath) => qpath,\n-                                    _ => return,\n-                                },\n+                        if let Some(ty) = is_ty_param_diagnostic_item(cx, qpath, sym::vec_type) {\n+                            let qpath = match &ty.kind {\n+                                TyKind::Path(qpath) => qpath,\n                                 _ => return,\n                             };\n-                            let inner_span = match &last_path_segment(&vec_ty).args.unwrap().args[0] {\n-                                GenericArg::Type(ty) => ty.span,\n-                                _ => return,\n+                            let inner_span = match get_qpath_generic_tys(qpath).next() {\n+                                Some(ty) => ty.span,\n+                                None => return,\n                             };\n                             let mut applicability = Applicability::MachineApplicable;\n                             span_lint_and_sugg(\n@@ -563,7 +572,7 @@ impl Types {\n                             }\n                         }\n                     } else if cx.tcx.is_diagnostic_item(sym::option_type, def_id) {\n-                        if match_type_parameter(cx, qpath, &paths::OPTION).is_some() {\n+                        if is_ty_param_diagnostic_item(cx, qpath, sym::option_type).is_some() {\n                             span_lint(\n                                 cx,\n                                 OPTION_OPTION,"}, {"sha": "daeced6bad483ab9f57208c71154a3b277a4ac63", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/5945e85f34067a584800d853f99de84f079f7150/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5945e85f34067a584800d853f99de84f079f7150/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=5945e85f34067a584800d853f99de84f079f7150", "patch": "@@ -63,8 +63,9 @@ use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_hir::Node;\n use rustc_hir::{\n-    def, Arm, Block, Body, Constness, Crate, Expr, ExprKind, FnDecl, HirId, ImplItem, ImplItemKind, Item, ItemKind,\n-    MatchSource, Param, Pat, PatKind, Path, PathSegment, QPath, TraitItem, TraitItemKind, TraitRef, TyKind, Unsafety,\n+    def, Arm, Block, Body, Constness, Crate, Expr, ExprKind, FnDecl, GenericArgs, HirId, ImplItem, ImplItemKind, Item,\n+    ItemKind, MatchSource, Param, Pat, PatKind, Path, PathSegment, QPath, TraitItem, TraitItemKind, TraitRef, TyKind,\n+    Unsafety,\n };\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_lint::{LateContext, Level, Lint, LintContext};\n@@ -272,6 +273,27 @@ pub fn last_path_segment<'tcx>(path: &QPath<'tcx>) -> &'tcx PathSegment<'tcx> {\n     }\n }\n \n+pub fn get_qpath_generics(path: &QPath<'tcx>) -> Option<&'tcx GenericArgs<'tcx>> {\n+    match path {\n+        QPath::Resolved(_, p) => p.segments.last().and_then(|s| s.args),\n+        QPath::TypeRelative(_, s) => s.args,\n+        QPath::LangItem(..) => None,\n+    }\n+}\n+\n+pub fn get_qpath_generic_tys(path: &QPath<'tcx>) -> impl Iterator<Item = &'tcx hir::Ty<'tcx>> {\n+    get_qpath_generics(path)\n+        .map_or([].as_ref(), |a| a.args)\n+        .iter()\n+        .filter_map(|a| {\n+            if let hir::GenericArg::Type(ty) = a {\n+                Some(ty)\n+            } else {\n+                None\n+            }\n+        })\n+}\n+\n pub fn single_segment_path<'tcx>(path: &QPath<'tcx>) -> Option<&'tcx PathSegment<'tcx>> {\n     match *path {\n         QPath::Resolved(_, ref path) => path.segments.get(0),"}, {"sha": "14c38459ddeaee413d407162763224a9a327e255", "filename": "clippy_utils/src/paths.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5945e85f34067a584800d853f99de84f079f7150/clippy_utils%2Fsrc%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5945e85f34067a584800d853f99de84f079f7150/clippy_utils%2Fsrc%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fpaths.rs?ref=5945e85f34067a584800d853f99de84f079f7150", "patch": "@@ -12,11 +12,9 @@ pub(super) const BEGIN_PANIC: [&str; 3] = [\"std\", \"panicking\", \"begin_panic\"];\n pub(super) const BEGIN_PANIC_FMT: [&str; 3] = [\"std\", \"panicking\", \"begin_panic_fmt\"];\n pub const BINARY_HEAP: [&str; 4] = [\"alloc\", \"collections\", \"binary_heap\", \"BinaryHeap\"];\n pub const BORROW_TRAIT: [&str; 3] = [\"core\", \"borrow\", \"Borrow\"];\n-pub const BOX: [&str; 3] = [\"alloc\", \"boxed\", \"Box\"];\n pub const BTREEMAP: [&str; 5] = [\"alloc\", \"collections\", \"btree\", \"map\", \"BTreeMap\"];\n pub const BTREEMAP_ENTRY: [&str; 6] = [\"alloc\", \"collections\", \"btree\", \"map\", \"entry\", \"Entry\"];\n pub const BTREESET: [&str; 5] = [\"alloc\", \"collections\", \"btree\", \"set\", \"BTreeSet\"];\n-pub const CLONE_TRAIT: [&str; 3] = [\"core\", \"clone\", \"Clone\"];\n pub const CLONE_TRAIT_METHOD: [&str; 4] = [\"core\", \"clone\", \"Clone\", \"clone\"];\n pub const CMP_MAX: [&str; 3] = [\"core\", \"cmp\", \"max\"];\n pub const CMP_MIN: [&str; 3] = [\"core\", \"cmp\", \"min\"];\n@@ -43,9 +41,6 @@ pub const FILE_TYPE: [&str; 3] = [\"std\", \"fs\", \"FileType\"];\n pub const FMT_ARGUMENTS_NEW_V1: [&str; 4] = [\"core\", \"fmt\", \"Arguments\", \"new_v1\"];\n pub const FMT_ARGUMENTS_NEW_V1_FORMATTED: [&str; 4] = [\"core\", \"fmt\", \"Arguments\", \"new_v1_formatted\"];\n pub const FMT_ARGUMENTV1_NEW: [&str; 4] = [\"core\", \"fmt\", \"ArgumentV1\", \"new\"];\n-pub const FN: [&str; 3] = [\"core\", \"ops\", \"Fn\"];\n-pub const FN_MUT: [&str; 3] = [\"core\", \"ops\", \"FnMut\"];\n-pub const FN_ONCE: [&str; 3] = [\"core\", \"ops\", \"FnOnce\"];\n pub const FROM_FROM: [&str; 4] = [\"core\", \"convert\", \"From\", \"from\"];\n pub const FROM_ITERATOR: [&str; 5] = [\"core\", \"iter\", \"traits\", \"collect\", \"FromIterator\"];\n pub const FUTURE_FROM_GENERATOR: [&str; 3] = [\"core\", \"future\", \"from_generator\"];\n@@ -114,7 +109,6 @@ pub const PTR_SLICE_FROM_RAW_PARTS_MUT: [&str; 3] = [\"core\", \"ptr\", \"slice_from_\n pub const PTR_SWAP_NONOVERLAPPING: [&str; 3] = [\"core\", \"ptr\", \"swap_nonoverlapping\"];\n pub const PUSH_STR: [&str; 4] = [\"alloc\", \"string\", \"String\", \"push_str\"];\n pub const RANGE_ARGUMENT_TRAIT: [&str; 3] = [\"core\", \"ops\", \"RangeBounds\"];\n-pub const RC: [&str; 3] = [\"alloc\", \"rc\", \"Rc\"];\n pub const RC_PTR_EQ: [&str; 4] = [\"alloc\", \"rc\", \"Rc\", \"ptr_eq\"];\n pub const RECEIVER: [&str; 4] = [\"std\", \"sync\", \"mpsc\", \"Receiver\"];\n pub const REFCELL_REF: [&str; 3] = [\"core\", \"cell\", \"Ref\"];\n@@ -143,7 +137,6 @@ pub const STD_CONVERT_IDENTITY: [&str; 3] = [\"std\", \"convert\", \"identity\"];\n pub const STD_FS_CREATE_DIR: [&str; 3] = [\"std\", \"fs\", \"create_dir\"];\n pub const STD_MEM_TRANSMUTE: [&str; 3] = [\"std\", \"mem\", \"transmute\"];\n pub const STD_PTR_NULL: [&str; 3] = [\"std\", \"ptr\", \"null\"];\n-pub const STRING: [&str; 3] = [\"alloc\", \"string\", \"String\"];\n pub const STRING_AS_MUT_STR: [&str; 4] = [\"alloc\", \"string\", \"String\", \"as_mut_str\"];\n pub const STRING_AS_STR: [&str; 4] = [\"alloc\", \"string\", \"String\", \"as_str\"];\n pub const STR_ENDS_WITH: [&str; 4] = [\"core\", \"str\", \"<impl str>\", \"ends_with\"];"}]}