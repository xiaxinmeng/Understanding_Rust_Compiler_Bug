{"sha": "becbd81aaa1b8c60eb13fee898163d1a2ac33de3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJlY2JkODFhYWExYjhjNjBlYjEzZmVlODk4MTYzZDFhMmFjMzNkZTM=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-12-26T09:36:04Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-12-30T14:36:21Z"}, "message": "Integrate projection bounds to `ExistentialBounds` but do not use them for anything.", "tree": {"sha": "3b55ff23e273c76a11dc7b363774798bcc2bc888", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3b55ff23e273c76a11dc7b363774798bcc2bc888"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/becbd81aaa1b8c60eb13fee898163d1a2ac33de3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/becbd81aaa1b8c60eb13fee898163d1a2ac33de3", "html_url": "https://github.com/rust-lang/rust/commit/becbd81aaa1b8c60eb13fee898163d1a2ac33de3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/becbd81aaa1b8c60eb13fee898163d1a2ac33de3/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "82787c2252267561777303bcc4e4d0394c34e5c9", "url": "https://api.github.com/repos/rust-lang/rust/commits/82787c2252267561777303bcc4e4d0394c34e5c9", "html_url": "https://github.com/rust-lang/rust/commit/82787c2252267561777303bcc4e4d0394c34e5c9"}], "stats": {"total": 348, "additions": 240, "deletions": 108}, "files": [{"sha": "7dccc49dcbbdac2776f7a21da0a8c50db01259ca", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/becbd81aaa1b8c60eb13fee898163d1a2ac33de3/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/becbd81aaa1b8c60eb13fee898163d1a2ac33de3/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=becbd81aaa1b8c60eb13fee898163d1a2ac33de3", "patch": "@@ -200,9 +200,9 @@ pub fn parse_bounds_data<'tcx>(data: &[u8], crate_num: ast::CrateNum,\n     parse_bounds(&mut st, conv)\n }\n \n-pub fn parse_existential_bounds_data(data: &[u8], crate_num: ast::CrateNum,\n-                                     pos: uint, tcx: &ty::ctxt, conv: conv_did)\n-                                     -> ty::ExistentialBounds {\n+pub fn parse_existential_bounds_data<'tcx>(data: &[u8], crate_num: ast::CrateNum,\n+                                           pos: uint, tcx: &ty::ctxt<'tcx>, conv: conv_did)\n+                                           -> ty::ExistentialBounds<'tcx> {\n     let mut st = parse_state_from_data(data, crate_num, pos, tcx);\n     parse_existential_bounds(&mut st, conv)\n }\n@@ -744,10 +744,18 @@ fn parse_type_param_def<'a, 'tcx>(st: &mut PState<'a, 'tcx>, conv: conv_did)\n     }\n }\n \n-fn parse_existential_bounds(st: &mut PState, conv: conv_did) -> ty::ExistentialBounds {\n-    let r = parse_region(st, |x,y| conv(x,y));\n-    let bb = parse_builtin_bounds(st, conv);\n-    return ty::ExistentialBounds { region_bound: r, builtin_bounds: bb };\n+fn parse_existential_bounds<'a,'tcx>(st: &mut PState<'a,'tcx>,\n+                                     conv: conv_did)\n+                                     -> ty::ExistentialBounds<'tcx>\n+{\n+    let ty::ParamBounds { trait_bounds, mut region_bounds, builtin_bounds, projection_bounds } =\n+         parse_bounds(st, conv);\n+    assert_eq!(region_bounds.len(), 1);\n+    assert_eq!(trait_bounds.len(), 0);\n+    let region_bound = region_bounds.pop().unwrap();\n+    return ty::ExistentialBounds { region_bound: region_bound,\n+                                   builtin_bounds: builtin_bounds,\n+                                   projection_bounds: projection_bounds };\n }\n \n fn parse_builtin_bounds(st: &mut PState, _conv: conv_did) -> ty::BuiltinBounds {"}, {"sha": "b6d05882dce23bff5223a96d463b86f31b6704d0", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/becbd81aaa1b8c60eb13fee898163d1a2ac33de3/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/becbd81aaa1b8c60eb13fee898163d1a2ac33de3/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=becbd81aaa1b8c60eb13fee898163d1a2ac33de3", "patch": "@@ -392,9 +392,14 @@ pub fn enc_builtin_bounds(w: &mut SeekableMemWriter, _cx: &ctxt, bs: &ty::Builti\n     mywrite!(w, \".\");\n }\n \n-pub fn enc_existential_bounds(w: &mut SeekableMemWriter, cx: &ctxt, bs: &ty::ExistentialBounds) {\n-    enc_region(w, cx, bs.region_bound);\n-    enc_builtin_bounds(w, cx, &bs.builtin_bounds);\n+pub fn enc_existential_bounds<'a,'tcx>(w: &mut SeekableMemWriter,\n+                                       cx: &ctxt<'a,'tcx>,\n+                                       bs: &ty::ExistentialBounds<'tcx>) {\n+    let param_bounds = ty::ParamBounds { trait_bounds: vec!(),\n+                                         region_bounds: vec!(bs.region_bound),\n+                                         builtin_bounds: bs.builtin_bounds,\n+                                         projection_bounds: bs.projection_bounds.clone() };\n+    enc_bounds(w, cx, &param_bounds);\n }\n \n pub fn enc_bounds<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>,"}, {"sha": "0b78f2b1cfce9bdefb65f34101cf9d3fc70d9825", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/becbd81aaa1b8c60eb13fee898163d1a2ac33de3/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/becbd81aaa1b8c60eb13fee898163d1a2ac33de3/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=becbd81aaa1b8c60eb13fee898163d1a2ac33de3", "patch": "@@ -842,7 +842,8 @@ trait rbml_writer_helpers<'tcx> {\n                             type_scheme: ty::TypeScheme<'tcx>);\n     fn emit_substs<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n                        substs: &subst::Substs<'tcx>);\n-    fn emit_existential_bounds(&mut self, ecx: &e::EncodeContext, bounds: &ty::ExistentialBounds);\n+    fn emit_existential_bounds<'b>(&mut self, ecx: &e::EncodeContext<'b,'tcx>,\n+                                   bounds: &ty::ExistentialBounds<'tcx>);\n     fn emit_builtin_bounds(&mut self, ecx: &e::EncodeContext, bounds: &ty::BuiltinBounds);\n     fn emit_auto_adjustment<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n                                 adj: &ty::AutoAdjustment<'tcx>);\n@@ -982,7 +983,8 @@ impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n         });\n     }\n \n-    fn emit_existential_bounds(&mut self, ecx: &e::EncodeContext, bounds: &ty::ExistentialBounds) {\n+    fn emit_existential_bounds<'b>(&mut self, ecx: &e::EncodeContext<'b,'tcx>,\n+                                   bounds: &ty::ExistentialBounds<'tcx>) {\n         self.emit_opaque(|this| Ok(tyencode::enc_existential_bounds(this.writer,\n                                                                     &ecx.ty_str_ctxt(),\n                                                                     bounds)));\n@@ -1372,7 +1374,7 @@ trait rbml_decoder_decoder_helpers<'tcx> {\n     fn read_type_scheme<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n                                 -> ty::TypeScheme<'tcx>;\n     fn read_existential_bounds<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n-                                       -> ty::ExistentialBounds;\n+                                       -> ty::ExistentialBounds<'tcx>;\n     fn read_substs<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n                            -> subst::Substs<'tcx>;\n     fn read_auto_adjustment<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n@@ -1626,7 +1628,7 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n     }\n \n     fn read_existential_bounds<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n-                                       -> ty::ExistentialBounds\n+                                       -> ty::ExistentialBounds<'tcx>\n     {\n         self.read_opaque(|this, doc| {\n             Ok(tydecode::parse_existential_bounds_data(doc.data,"}, {"sha": "11ca202971e1d5b77f437585099f345df98049ac", "filename": "src/librustc/middle/infer/coercion.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/becbd81aaa1b8c60eb13fee898163d1a2ac33de3/src%2Flibrustc%2Fmiddle%2Finfer%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/becbd81aaa1b8c60eb13fee898163d1a2ac33de3/src%2Flibrustc%2Fmiddle%2Finfer%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fcoercion.rs?ref=becbd81aaa1b8c60eb13fee898163d1a2ac33de3", "patch": "@@ -351,11 +351,11 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                 (&ty::ty_trait(..), &ty::ty_trait(..)) => {\n                     None\n                 }\n-                (_, &ty::ty_trait(box ty::TyTrait { ref principal, bounds })) => {\n+                (_, &ty::ty_trait(box ty::TyTrait { ref principal, ref bounds })) => {\n                     // FIXME what is the purpose of `ty`?\n-                    let ty = ty::mk_trait(tcx, principal.clone(), bounds);\n-                    Some((ty, ty::UnsizeVtable(ty::TyTrait { principal: (*principal).clone(),\n-                                                             bounds: bounds },\n+                    let ty = ty::mk_trait(tcx, principal.clone(), bounds.clone());\n+                    Some((ty, ty::UnsizeVtable(ty::TyTrait { principal: principal.clone(),\n+                                                             bounds: bounds.clone() },\n                                                ty_a)))\n                 }\n                 (&ty::ty_struct(did_a, substs_a), &ty::ty_struct(did_b, substs_b))\n@@ -458,10 +458,9 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n \n         match a.sty {\n             ty::ty_rptr(_, ty::mt{ty, mutbl}) => match ty.sty {\n-                ty::ty_trait(box ty::TyTrait { ref principal, bounds }) => {\n+                ty::ty_trait(box ty::TyTrait { ref principal, ref bounds }) => {\n                     debug!(\"mutbl={} b_mutbl={}\", mutbl, b_mutbl);\n-                    // FIXME what is purpose of this type `tr`?\n-                    let tr = ty::mk_trait(tcx, principal.clone(), bounds);\n+                    let tr = ty::mk_trait(tcx, principal.clone(), bounds.clone());\n                     try!(self.subtype(mk_ty(tr), b));\n                     Ok(Some(AdjustDerefRef(AutoDerefRef {\n                         autoderefs: 1,"}, {"sha": "e0bcdfc6d8d9375627b5702d13e4411349553548", "filename": "src/librustc/middle/infer/combine.rs", "status": "modified", "additions": 64, "deletions": 12, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/becbd81aaa1b8c60eb13fee898163d1a2ac33de3/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/becbd81aaa1b8c60eb13fee898163d1a2ac33de3/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs?ref=becbd81aaa1b8c60eb13fee898163d1a2ac33de3", "patch": "@@ -222,7 +222,7 @@ pub trait Combine<'tcx> {\n         };\n         let unsafety = try!(self.unsafeties(a.unsafety, b.unsafety));\n         let onceness = try!(self.oncenesses(a.onceness, b.onceness));\n-        let bounds = try!(self.existential_bounds(a.bounds, b.bounds));\n+        let bounds = try!(self.existential_bounds(&a.bounds, &b.bounds));\n         let sig = try!(self.binders(&a.sig, &b.sig));\n         let abi = try!(self.abi(a.abi, b.abi));\n         Ok(ty::ClosureTy {\n@@ -289,15 +289,61 @@ pub trait Combine<'tcx> {\n \n     fn oncenesses(&self, a: Onceness, b: Onceness) -> cres<'tcx, Onceness>;\n \n+    fn projection_tys(&self,\n+                      a: &ty::ProjectionTy<'tcx>,\n+                      b: &ty::ProjectionTy<'tcx>)\n+                      -> cres<'tcx, ty::ProjectionTy<'tcx>>\n+    {\n+        if a.item_name != b.item_name {\n+            Err(ty::terr_projection_name_mismatched(\n+                expected_found(self, a.item_name, b.item_name)))\n+        } else {\n+            let trait_ref = try!(self.trait_refs(&*a.trait_ref, &*b.trait_ref));\n+            Ok(ty::ProjectionTy { trait_ref: Rc::new(trait_ref), item_name: a.item_name })\n+        }\n+    }\n+\n+    fn projection_predicates(&self,\n+                             a: &ty::ProjectionPredicate<'tcx>,\n+                             b: &ty::ProjectionPredicate<'tcx>)\n+                             -> cres<'tcx, ty::ProjectionPredicate<'tcx>>\n+    {\n+        let projection_ty = try!(self.projection_tys(&a.projection_ty, &b.projection_ty));\n+        let ty = try!(self.tys(a.ty, b.ty));\n+        Ok(ty::ProjectionPredicate { projection_ty: projection_ty, ty: ty })\n+    }\n+\n+    fn projection_bounds(&self,\n+                         a: &Vec<ty::PolyProjectionPredicate<'tcx>>,\n+                         b: &Vec<ty::PolyProjectionPredicate<'tcx>>)\n+                         -> cres<'tcx, Vec<ty::PolyProjectionPredicate<'tcx>>>\n+    {\n+        // To be compatible, `a` and `b` must be for precisely the\n+        // same set of traits and item names. We always require that\n+        // projection bounds lists are sorted by trait-def-id and item-name,\n+        // so we can just iterate through the lists pairwise, so long as they are the\n+        // same length.\n+        if a.len() != b.len() {\n+            Err(ty::terr_projection_bounds_length(expected_found(self, a.len(), b.len())))\n+        } else {\n+            a.iter()\n+                .zip(b.iter())\n+                .map(|(a, b)| self.binders(a, b))\n+                .collect()\n+        }\n+    }\n+\n     fn existential_bounds(&self,\n-                          a: ty::ExistentialBounds,\n-                          b: ty::ExistentialBounds)\n-                          -> cres<'tcx, ty::ExistentialBounds>\n+                          a: &ty::ExistentialBounds<'tcx>,\n+                          b: &ty::ExistentialBounds<'tcx>)\n+                          -> cres<'tcx, ty::ExistentialBounds<'tcx>>\n     {\n         let r = try!(self.contraregions(a.region_bound, b.region_bound));\n         let nb = try!(self.builtin_bounds(a.builtin_bounds, b.builtin_bounds));\n+        let pb = try!(self.projection_bounds(&a.projection_bounds, &b.projection_bounds));\n         Ok(ty::ExistentialBounds { region_bound: r,\n-                                   builtin_bounds: nb })\n+                                   builtin_bounds: nb,\n+                                   projection_bounds: pb })\n     }\n \n     fn builtin_bounds(&self,\n@@ -381,6 +427,16 @@ impl<'tcx> Combineable<'tcx> for ty::TraitRef<'tcx> {\n     }\n }\n \n+impl<'tcx> Combineable<'tcx> for ty::ProjectionPredicate<'tcx> {\n+    fn combine<C:Combine<'tcx>>(combiner: &C,\n+                                a: &ty::ProjectionPredicate<'tcx>,\n+                                b: &ty::ProjectionPredicate<'tcx>)\n+                                -> cres<'tcx, ty::ProjectionPredicate<'tcx>>\n+    {\n+        combiner.projection_predicates(a, b)\n+    }\n+}\n+\n impl<'tcx> Combineable<'tcx> for ty::FnSig<'tcx> {\n     fn combine<C:Combine<'tcx>>(combiner: &C,\n                                 a: &ty::FnSig<'tcx>,\n@@ -496,7 +552,7 @@ pub fn super_tys<'tcx, C: Combine<'tcx>>(this: &C,\n        &ty::ty_trait(ref b_)) => {\n           debug!(\"Trying to match traits {} and {}\", a, b);\n           let principal = try!(this.binders(&a_.principal, &b_.principal));\n-          let bounds = try!(this.existential_bounds(a_.bounds, b_.bounds));\n+          let bounds = try!(this.existential_bounds(&a_.bounds, &b_.bounds));\n           Ok(ty::mk_trait(tcx, principal, bounds))\n       }\n \n@@ -595,12 +651,8 @@ pub fn super_tys<'tcx, C: Combine<'tcx>>(this: &C,\n       }\n \n       (&ty::ty_projection(ref a_data), &ty::ty_projection(ref b_data)) => {\n-          if a_data.item_name == b_data.item_name {\n-              let trait_ref = try!(this.trait_refs(&*a_data.trait_ref, &*b_data.trait_ref));\n-              Ok(ty::mk_projection(tcx, Rc::new(trait_ref), a_data.item_name))\n-          } else {\n-              Err(ty::terr_sorts(expected_found(this, a, b)))\n-          }\n+          let projection_ty = try!(this.projection_tys(a_data, b_data));\n+          Ok(ty::mk_projection(tcx, projection_ty.trait_ref, projection_ty.item_name))\n       }\n \n       _ => Err(ty::terr_sorts(expected_found(this, a, b)))"}, {"sha": "e989f5a2cc2b44c9d71c9d900dbcf677732f2126", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 59, "deletions": 19, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/becbd81aaa1b8c60eb13fee898163d1a2ac33de3/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/becbd81aaa1b8c60eb13fee898163d1a2ac33de3/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=becbd81aaa1b8c60eb13fee898163d1a2ac33de3", "patch": "@@ -396,14 +396,14 @@ pub fn type_of_adjust<'tcx>(cx: &ctxt<'tcx>, adj: &AutoAdjustment<'tcx>) -> Opti\n     fn type_of_autoref<'tcx>(cx: &ctxt<'tcx>, autoref: &AutoRef<'tcx>) -> Option<Ty<'tcx>> {\n         match autoref {\n             &AutoUnsize(ref k) => match k {\n-                &UnsizeVtable(TyTrait { ref principal, bounds }, _) => {\n-                    Some(mk_trait(cx, (*principal).clone(), bounds))\n+                &UnsizeVtable(TyTrait { ref principal, ref bounds }, _) => {\n+                    Some(mk_trait(cx, principal.clone(), bounds.clone()))\n                 }\n                 _ => None\n             },\n             &AutoUnsizeUniq(ref k) => match k {\n-                &UnsizeVtable(TyTrait { ref principal, bounds }, _) => {\n-                    Some(mk_uniq(cx, mk_trait(cx, (*principal).clone(), bounds)))\n+                &UnsizeVtable(TyTrait { ref principal, ref bounds }, _) => {\n+                    Some(mk_uniq(cx, mk_trait(cx, principal.clone(), bounds.clone())))\n                 }\n                 _ => None\n             },\n@@ -1040,7 +1040,7 @@ pub struct ClosureTy<'tcx> {\n     pub unsafety: ast::Unsafety,\n     pub onceness: ast::Onceness,\n     pub store: TraitStore,\n-    pub bounds: ExistentialBounds,\n+    pub bounds: ExistentialBounds<'tcx>,\n     pub sig: PolyFnSig<'tcx>,\n     pub abi: abi::Abi,\n }\n@@ -1376,7 +1376,7 @@ pub enum sty<'tcx> {\n #[deriving(Clone, PartialEq, Eq, Hash, Show)]\n pub struct TyTrait<'tcx> {\n     pub principal: ty::PolyTraitRef<'tcx>,\n-    pub bounds: ExistentialBounds\n+    pub bounds: ExistentialBounds<'tcx>,\n }\n \n impl<'tcx> TyTrait<'tcx> {\n@@ -1510,7 +1510,9 @@ pub enum type_err<'tcx> {\n     terr_builtin_bounds(expected_found<BuiltinBounds>),\n     terr_variadic_mismatch(expected_found<bool>),\n     terr_cyclic_ty,\n-    terr_convergence_mismatch(expected_found<bool>)\n+    terr_convergence_mismatch(expected_found<bool>),\n+    terr_projection_name_mismatched(expected_found<ast::Name>),\n+    terr_projection_bounds_length(expected_found<uint>),\n }\n \n /// Bounds suitable for a named type parameter like `A` in `fn foo<A>`\n@@ -1528,10 +1530,11 @@ pub struct ParamBounds<'tcx> {\n /// major difference between this case and `ParamBounds` is that\n /// general purpose trait bounds are omitted and there must be\n /// *exactly one* region.\n-#[deriving(Copy, PartialEq, Eq, Hash, Clone, Show)]\n-pub struct ExistentialBounds {\n+#[deriving(PartialEq, Eq, Hash, Clone, Show)]\n+pub struct ExistentialBounds<'tcx> {\n     pub region_bound: ty::Region,\n-    pub builtin_bounds: BuiltinBounds\n+    pub builtin_bounds: BuiltinBounds,\n+    pub projection_bounds: Vec<PolyProjectionPredicate<'tcx>>,\n }\n \n pub type BuiltinBounds = EnumSet<BuiltinBound>;\n@@ -1559,9 +1562,10 @@ pub fn all_builtin_bounds() -> BuiltinBounds {\n }\n \n /// An existential bound that does not implement any traits.\n-pub fn region_existential_bound(r: ty::Region) -> ExistentialBounds {\n+pub fn region_existential_bound<'tcx>(r: ty::Region) -> ExistentialBounds<'tcx> {\n     ty::ExistentialBounds { region_bound: r,\n-                            builtin_bounds: empty_builtin_bounds() }\n+                            builtin_bounds: empty_builtin_bounds(),\n+                            projection_bounds: Vec::new() }\n }\n \n impl CLike for BuiltinBound {\n@@ -1820,12 +1824,24 @@ pub struct ProjectionPredicate<'tcx> {\n \n pub type PolyProjectionPredicate<'tcx> = Binder<ProjectionPredicate<'tcx>>;\n \n+impl<'tcx> PolyProjectionPredicate<'tcx> {\n+    pub fn sort_key(&self) -> (ast::DefId, ast::Name) {\n+        self.0.projection_ty.sort_key()\n+    }\n+}\n+\n #[deriving(Clone, PartialEq, Eq, Hash, Show)]\n pub struct ProjectionTy<'tcx> {\n     pub trait_ref: Rc<ty::TraitRef<'tcx>>,\n     pub item_name: ast::Name,\n }\n \n+impl<'tcx> ProjectionTy<'tcx> {\n+    pub fn sort_key(&self) -> (ast::DefId, ast::Name) {\n+        (self.trait_ref.def_id, self.item_name)\n+    }\n+}\n+\n pub trait ToPolyTraitRef<'tcx> {\n     fn to_poly_trait_ref(&self) -> PolyTraitRef<'tcx>;\n }\n@@ -2675,15 +2691,28 @@ pub fn mk_ctor_fn<'tcx>(cx: &ctxt<'tcx>,\n \n pub fn mk_trait<'tcx>(cx: &ctxt<'tcx>,\n                       principal: ty::PolyTraitRef<'tcx>,\n-                      bounds: ExistentialBounds)\n-                      -> Ty<'tcx> {\n+                      bounds: ExistentialBounds<'tcx>)\n+                      -> Ty<'tcx>\n+{\n+    assert!(bound_list_is_sorted(bounds.projection_bounds.as_slice()));\n+\n     let inner = box TyTrait {\n         principal: principal,\n         bounds: bounds\n     };\n     mk_t(cx, ty_trait(inner))\n }\n \n+fn bound_list_is_sorted(bounds: &[ty::PolyProjectionPredicate]) -> bool {\n+    bounds.len() == 0 ||\n+        bounds[1..].iter().enumerate().all(\n+            |(index, bound)| bounds[index].sort_key() <= bound.sort_key())\n+}\n+\n+pub fn sort_bounds_list(bounds: &mut [ty::PolyProjectionPredicate]) {\n+    bounds.sort_by(|a, b| a.sort_key().cmp(&b.sort_key()))\n+}\n+\n pub fn mk_projection<'tcx>(cx: &ctxt<'tcx>,\n                            trait_ref: Rc<ty::TraitRef<'tcx>>,\n                            item_name: ast::Name)\n@@ -3226,7 +3255,7 @@ pub fn type_contents<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> TypeContents {\n                 }\n             }\n \n-            ty_trait(box TyTrait { bounds, .. }) => {\n+            ty_trait(box TyTrait { ref bounds, .. }) => {\n                 object_contents(bounds) | TC::ReachesFfiUnsafe | TC::Nonsized\n             }\n \n@@ -3391,7 +3420,7 @@ pub fn type_contents<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> TypeContents {\n     fn closure_contents(cty: &ClosureTy) -> TypeContents {\n         // Closure contents are just like trait contents, but with potentially\n         // even more stuff.\n-        let st = object_contents(cty.bounds);\n+        let st = object_contents(&cty.bounds);\n \n         let st = match cty.store {\n             UniqTraitStore => {\n@@ -3405,7 +3434,7 @@ pub fn type_contents<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> TypeContents {\n         st\n     }\n \n-    fn object_contents(bounds: ExistentialBounds) -> TypeContents {\n+    fn object_contents(bounds: &ExistentialBounds) -> TypeContents {\n         // These are the type contents of the (opaque) interior. We\n         // make no assumptions (other than that it cannot have an\n         // in-scope type parameter within, which makes no sense).\n@@ -4205,6 +4234,7 @@ pub fn adjust_ty<'tcx, F>(cx: &ctxt<'tcx>,\n                             let bounds = ty::ExistentialBounds {\n                                 region_bound: ReStatic,\n                                 builtin_bounds: all_builtin_bounds(),\n+                                projection_bounds: vec!(),\n                             };\n \n                             ty::mk_closure(\n@@ -4339,8 +4369,8 @@ pub fn unsize_ty<'tcx>(cx: &ctxt<'tcx>,\n                                   format!(\"UnsizeStruct with bad sty: {}\",\n                                           ty_to_string(cx, ty))[])\n         },\n-        &UnsizeVtable(TyTrait { ref principal, bounds }, _) => {\n-            mk_trait(cx, (*principal).clone(), bounds)\n+        &UnsizeVtable(TyTrait { ref principal, ref bounds }, _) => {\n+            mk_trait(cx, principal.clone(), bounds.clone())\n         }\n     }\n }\n@@ -4760,6 +4790,16 @@ pub fn type_err_to_str<'tcx>(cx: &ctxt<'tcx>, err: &type_err<'tcx>) -> String {\n                     if values.expected { \"converging\" } else { \"diverging\" },\n                     if values.found { \"converging\" } else { \"diverging\" })\n         }\n+        terr_projection_name_mismatched(ref values) => {\n+            format!(\"expected {}, found {}\",\n+                    token::get_name(values.expected),\n+                    token::get_name(values.found))\n+        }\n+        terr_projection_bounds_length(ref values) => {\n+            format!(\"expected {} associated type bindings, found {}\",\n+                    values.expected,\n+                    values.found)\n+        }\n     }\n }\n "}, {"sha": "3aff69c0178469f380ecbd8b91276bafcf719c25", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/becbd81aaa1b8c60eb13fee898163d1a2ac33de3/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/becbd81aaa1b8c60eb13fee898163d1a2ac33de3/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=becbd81aaa1b8c60eb13fee898163d1a2ac33de3", "patch": "@@ -121,8 +121,8 @@ pub trait TypeFolder<'tcx> {\n         super_fold_trait_store(self, s)\n     }\n \n-    fn fold_existential_bounds(&mut self, s: ty::ExistentialBounds)\n-                               -> ty::ExistentialBounds {\n+    fn fold_existential_bounds(&mut self, s: &ty::ExistentialBounds<'tcx>)\n+                               -> ty::ExistentialBounds<'tcx> {\n         super_fold_existential_bounds(self, s)\n     }\n \n@@ -349,9 +349,9 @@ impl<'tcx> TypeFoldable<'tcx> for ty::BuiltinBounds {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for ty::ExistentialBounds {\n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::ExistentialBounds {\n-        folder.fold_existential_bounds(*self)\n+impl<'tcx> TypeFoldable<'tcx> for ty::ExistentialBounds<'tcx> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::ExistentialBounds<'tcx> {\n+        folder.fold_existential_bounds(self)\n     }\n }\n \n@@ -449,7 +449,7 @@ impl<'tcx> TypeFoldable<'tcx> for ty::UnsizeKind<'tcx> {\n         match *self {\n             ty::UnsizeLength(len) => ty::UnsizeLength(len),\n             ty::UnsizeStruct(box ref k, n) => ty::UnsizeStruct(box k.fold_with(folder), n),\n-            ty::UnsizeVtable(ty::TyTrait{ref principal, bounds}, self_ty) => {\n+            ty::UnsizeVtable(ty::TyTrait{ref principal, ref bounds}, self_ty) => {\n                 ty::UnsizeVtable(\n                     ty::TyTrait {\n                         principal: principal.fold_with(folder),\n@@ -565,9 +565,9 @@ pub fn super_fold_ty<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n             let substs = substs.fold_with(this);\n             ty::ty_enum(tid, this.tcx().mk_substs(substs))\n         }\n-        ty::ty_trait(box ty::TyTrait { ref principal, bounds }) => {\n+        ty::ty_trait(box ty::TyTrait { ref principal, ref bounds }) => {\n             ty::ty_trait(box ty::TyTrait {\n-                principal: (*principal).fold_with(this),\n+                principal: principal.fold_with(this),\n                 bounds: bounds.fold_with(this),\n             })\n         }\n@@ -693,12 +693,15 @@ pub fn super_fold_trait_store<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n     }\n }\n \n-pub fn super_fold_existential_bounds<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n-                                                                bounds: ty::ExistentialBounds)\n-                                                                -> ty::ExistentialBounds {\n+pub fn super_fold_existential_bounds<'tcx, T: TypeFolder<'tcx>>(\n+    this: &mut T,\n+    bounds: &ty::ExistentialBounds<'tcx>)\n+    -> ty::ExistentialBounds<'tcx>\n+{\n     ty::ExistentialBounds {\n         region_bound: bounds.region_bound.fold_with(this),\n         builtin_bounds: bounds.builtin_bounds,\n+        projection_bounds: bounds.projection_bounds.fold_with(this),\n     }\n }\n "}, {"sha": "3e7b24ac93f9e5c314c0f8487b6c566f2c162d1d", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/becbd81aaa1b8c60eb13fee898163d1a2ac33de3/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/becbd81aaa1b8c60eb13fee898163d1a2ac33de3/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=becbd81aaa1b8c60eb13fee898163d1a2ac33de3", "patch": "@@ -739,8 +739,8 @@ impl<'tcx> Repr<'tcx> for ty::BuiltinBounds {\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ty::ExistentialBounds {\n-    fn repr(&self, tcx: &ctxt) -> String {\n+impl<'tcx> Repr<'tcx> for ty::ExistentialBounds<'tcx> {\n+    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n         self.user_string(tcx)\n     }\n }\n@@ -1142,8 +1142,8 @@ impl<'tcx> UserString<'tcx> for ty::ParamBounds<'tcx> {\n     }\n }\n \n-impl<'tcx> UserString<'tcx> for ty::ExistentialBounds {\n-    fn user_string(&self, tcx: &ctxt) -> String {\n+impl<'tcx> UserString<'tcx> for ty::ExistentialBounds<'tcx> {\n+    fn user_string(&self, tcx: &ctxt<'tcx>) -> String {\n         if self.builtin_bounds.contains(&ty::BoundSend) &&\n             self.region_bound == ty::ReStatic\n         { // Region bound is implied by builtin bounds:"}, {"sha": "26fadb0dfb1020d7059990fbee8802ea2324c7a7", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 40, "deletions": 23, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/becbd81aaa1b8c60eb13fee898163d1a2ac33de3/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/becbd81aaa1b8c60eb13fee898163d1a2ac33de3/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=becbd81aaa1b8c60eb13fee898163d1a2ac33de3", "patch": "@@ -810,11 +810,13 @@ pub fn ast_ty_to_builtin_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n     }\n }\n \n+type TraitAndProjections<'tcx> = (ty::PolyTraitRef<'tcx>, Vec<ty::PolyProjectionPredicate<'tcx>>);\n+\n fn ast_ty_to_trait_ref<'tcx,AC,RS>(this: &AC,\n                                    rscope: &RS,\n                                    ty: &ast::Ty,\n                                    bounds: &[ast::TyParamBound])\n-                                   -> Result<ty::PolyTraitRef<'tcx>, ErrorReported>\n+                                   -> Result<TraitAndProjections<'tcx>, ErrorReported>\n     where AC : AstConv<'tcx>, RS : RegionScope\n {\n     /*!\n@@ -832,14 +834,17 @@ fn ast_ty_to_trait_ref<'tcx,AC,RS>(this: &AC,\n         ast::TyPath(ref path, id) => {\n             match this.tcx().def_map.borrow().get(&id) {\n                 Some(&def::DefTrait(trait_def_id)) => {\n-                    // TODO do something with this\n-                    let mut projections = Vec::new();\n-                    Ok(ty::Binder(ast_path_to_trait_ref(this,\n-                                                        rscope,\n-                                                        trait_def_id,\n-                                                        None,\n-                                                        path,\n-                                                        Some(&mut projections))))\n+                    let mut projection_bounds = Vec::new();\n+                    let trait_ref = ty::Binder(ast_path_to_trait_ref(this,\n+                                                                     rscope,\n+                                                                     trait_def_id,\n+                                                                     None,\n+                                                                     path,\n+                                                                     Some(&mut projection_bounds)));\n+                    let projection_bounds = projection_bounds.into_iter()\n+                                                             .map(ty::Binder)\n+                                                             .collect();\n+                    Ok((trait_ref, projection_bounds))\n                 }\n                 _ => {\n                     span_err!(this.tcx().sess, ty.span, E0172, \"expected a reference to a trait\");\n@@ -882,6 +887,7 @@ fn trait_ref_to_object_type<'tcx,AC,RS>(this: &AC,\n                                         rscope: &RS,\n                                         span: Span,\n                                         trait_ref: ty::PolyTraitRef<'tcx>,\n+                                        projection_bounds: Vec<ty::PolyProjectionPredicate<'tcx>>,\n                                         bounds: &[ast::TyParamBound])\n                                         -> Ty<'tcx>\n     where AC : AstConv<'tcx>, RS : RegionScope\n@@ -890,6 +896,7 @@ fn trait_ref_to_object_type<'tcx,AC,RS>(this: &AC,\n                                                      rscope,\n                                                      span,\n                                                      Some(trait_ref.clone()),\n+                                                     projection_bounds,\n                                                      bounds);\n \n     let result = ty::mk_trait(this.tcx(), trait_ref, existential_bounds);\n@@ -1019,9 +1026,9 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n             }\n             ast::TyObjectSum(ref ty, ref bounds) => {\n                 match ast_ty_to_trait_ref(this, rscope, &**ty, bounds[]) {\n-                    Ok(trait_ref) => {\n+                    Ok((trait_ref, projection_bounds)) => {\n                         trait_ref_to_object_type(this, rscope, ast_ty.span,\n-                                                 trait_ref, bounds[])\n+                                                 trait_ref, projection_bounds, bounds[])\n                     }\n                     Err(ErrorReported) => {\n                         this.tcx().types.err\n@@ -1062,13 +1069,15 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                                                      rscope,\n                                                      ast_ty.span,\n                                                      None,\n+                                                     Vec::new(),\n                                                      f.bounds.as_slice());\n+                let region_bound = bounds.region_bound;\n                 let fn_decl = ty_of_closure(this,\n                                             f.unsafety,\n                                             f.onceness,\n                                             bounds,\n                                             ty::RegionTraitStore(\n-                                                bounds.region_bound,\n+                                                region_bound,\n                                                 ast::MutMutable),\n                                             &*f.decl,\n                                             abi::Rust,\n@@ -1092,15 +1101,19 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                     def::DefTrait(trait_def_id) => {\n                         // N.B. this case overlaps somewhat with\n                         // TyObjectSum, see that fn for details\n-                        let mut projections = Vec::new(); // TODO\n+                        let mut projection_bounds = Vec::new();\n                         let trait_ref = ast_path_to_trait_ref(this,\n                                                               rscope,\n                                                               trait_def_id,\n                                                               None,\n                                                               path,\n-                                                              Some(&mut projections));\n+                                                              Some(&mut projection_bounds));\n                         let trait_ref = ty::Binder(trait_ref);\n-                        trait_ref_to_object_type(this, rscope, path.span, trait_ref, &[])\n+                        let projection_bounds = projection_bounds.into_iter()\n+                                                                 .map(ty::Binder)\n+                                                                 .collect();\n+                        trait_ref_to_object_type(this, rscope, path.span,\n+                                                 trait_ref, projection_bounds, &[])\n                     }\n                     def::DefTy(did, _) | def::DefStruct(did) => {\n                         ast_path_to_ty(this, rscope, did, path).ty\n@@ -1437,7 +1450,7 @@ pub fn ty_of_closure<'tcx, AC: AstConv<'tcx>>(\n     this: &AC,\n     unsafety: ast::Unsafety,\n     onceness: ast::Onceness,\n-    bounds: ty::ExistentialBounds,\n+    bounds: ty::ExistentialBounds<'tcx>,\n     store: ty::TraitStore,\n     decl: &ast::FnDecl,\n     abi: abi::Abi,\n@@ -1500,14 +1513,15 @@ pub fn conv_existential_bounds<'tcx, AC: AstConv<'tcx>, RS:RegionScope>(\n     rscope: &RS,\n     span: Span,\n     principal_trait_ref: Option<ty::PolyTraitRef<'tcx>>, // None for boxed closures\n+    projection_bounds: Vec<ty::PolyProjectionPredicate<'tcx>>,\n     ast_bounds: &[ast::TyParamBound])\n-    -> ty::ExistentialBounds\n+    -> ty::ExistentialBounds<'tcx>\n {\n     let partitioned_bounds =\n         partition_bounds(this.tcx(), span, ast_bounds);\n \n     conv_existential_bounds_from_partitioned_bounds(\n-        this, rscope, span, principal_trait_ref, partitioned_bounds)\n+        this, rscope, span, principal_trait_ref, projection_bounds, partitioned_bounds)\n }\n \n fn conv_ty_poly_trait_ref<'tcx, AC, RS>(\n@@ -1520,14 +1534,14 @@ fn conv_ty_poly_trait_ref<'tcx, AC, RS>(\n {\n     let mut partitioned_bounds = partition_bounds(this.tcx(), span, ast_bounds[]);\n \n-    let mut projections = Vec::new();\n+    let mut projection_bounds = Vec::new();\n     let main_trait_bound = match partitioned_bounds.trait_bounds.remove(0) {\n         Some(trait_bound) => {\n             let ptr = instantiate_poly_trait_ref(this,\n                                                  rscope,\n                                                  trait_bound,\n                                                  None,\n-                                                 &mut projections);\n+                                                 &mut projection_bounds);\n             Some(ptr)\n         }\n         None => {\n@@ -1538,13 +1552,12 @@ fn conv_ty_poly_trait_ref<'tcx, AC, RS>(\n         }\n     };\n \n-    // TODO use projections somewhere\n-\n     let bounds =\n         conv_existential_bounds_from_partitioned_bounds(this,\n                                                         rscope,\n                                                         span,\n                                                         main_trait_bound.clone(),\n+                                                        projection_bounds,\n                                                         partitioned_bounds);\n \n     match main_trait_bound {\n@@ -1558,8 +1571,9 @@ pub fn conv_existential_bounds_from_partitioned_bounds<'tcx, AC, RS>(\n     rscope: &RS,\n     span: Span,\n     principal_trait_ref: Option<ty::PolyTraitRef<'tcx>>, // None for boxed closures\n+    mut projection_bounds: Vec<ty::PolyProjectionPredicate<'tcx>>, // Empty for boxed closures\n     partitioned_bounds: PartitionedBounds)\n-    -> ty::ExistentialBounds\n+    -> ty::ExistentialBounds<'tcx>\n     where AC: AstConv<'tcx>, RS:RegionScope\n {\n     let PartitionedBounds { builtin_bounds,\n@@ -1582,9 +1596,12 @@ pub fn conv_existential_bounds_from_partitioned_bounds<'tcx, AC, RS>(\n                                             principal_trait_ref,\n                                             builtin_bounds);\n \n+    ty::sort_bounds_list(projection_bounds.as_mut_slice());\n+\n     ty::ExistentialBounds {\n         region_bound: region_bound,\n         builtin_bounds: builtin_bounds,\n+        projection_bounds: projection_bounds,\n     }\n }\n "}, {"sha": "e737bb1b237fb87dd48a7c6b3ab99ab5b0eb9579", "filename": "src/librustc_typeck/check/assoc.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/becbd81aaa1b8c60eb13fee898163d1a2ac33de3/src%2Flibrustc_typeck%2Fcheck%2Fassoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/becbd81aaa1b8c60eb13fee898163d1a2ac33de3/src%2Flibrustc_typeck%2Fcheck%2Fassoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fassoc.rs?ref=becbd81aaa1b8c60eb13fee898163d1a2ac33de3", "patch": "@@ -15,7 +15,6 @@ use middle::ty::{mod, HasProjectionTypes, Ty};\n use middle::ty_fold::{mod, TypeFoldable, TypeFolder};\n use syntax::ast;\n use syntax::codemap::Span;\n-use std::rc::Rc;\n \n pub fn normalize_associated_types_in<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n                                                 fulfillment_cx: &mut FulfillmentContext<'tcx>,"}, {"sha": "19108ca710bc1a3153f3877794cfe81329aa1140", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/becbd81aaa1b8c60eb13fee898163d1a2ac33de3/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/becbd81aaa1b8c60eb13fee898163d1a2ac33de3/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=becbd81aaa1b8c60eb13fee898163d1a2ac33de3", "patch": "@@ -289,7 +289,7 @@ fn check_boxed_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n                 (&ty::UniqTraitStore, _) => ast::Once,\n                 (&ty::RegionTraitStore(..), _) => ast::Many,\n             };\n-            (Some(sig), onceness, cenv.bounds)\n+            (Some(sig), onceness, cenv.bounds.clone())\n         }\n         _ => {\n             // Not an error! Means we're inferring the closure type"}, {"sha": "1da8852c9b23c827989d4efbc61b57443bbd8cb6", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/becbd81aaa1b8c60eb13fee898163d1a2ac33de3/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/becbd81aaa1b8c60eb13fee898163d1a2ac33de3/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=becbd81aaa1b8c60eb13fee898163d1a2ac33de3", "patch": "@@ -768,7 +768,7 @@ fn constrain_cast(rcx: &mut Rcx,\n             }\n \n             /*From:*/ (_,\n-            /*To:  */  &ty::ty_trait(box ty::TyTrait { bounds, .. })) => {\n+            /*To:  */  &ty::ty_trait(box ty::TyTrait { ref bounds, .. })) => {\n                 // When T is existentially quantified as a trait\n                 // `Foo+'to`, it must outlive the region bound `'to`.\n                 type_must_outlive(rcx, infer::RelateObjectBound(cast_expr.span),\n@@ -851,15 +851,15 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n     }\n \n     match function_type.sty {\n-        ty::ty_closure(box ty::ClosureTy {bounds, ..}) => {\n+        ty::ty_closure(box ty::ClosureTy {ref bounds, ..}) => {\n             ty::with_freevars(tcx, expr.id, |freevars| {\n                 ensure_free_variable_types_outlive_closure_bound(rcx, bounds, expr, freevars);\n             })\n         }\n         ty::ty_unboxed_closure(_, region, _) => {\n             ty::with_freevars(tcx, expr.id, |freevars| {\n                 let bounds = ty::region_existential_bound(*region);\n-                ensure_free_variable_types_outlive_closure_bound(rcx, bounds, expr, freevars);\n+                ensure_free_variable_types_outlive_closure_bound(rcx, &bounds, expr, freevars);\n             })\n         }\n         _ => {}\n@@ -870,7 +870,7 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n     /// over values outliving the object's lifetime bound.\n     fn ensure_free_variable_types_outlive_closure_bound(\n         rcx: &mut Rcx,\n-        bounds: ty::ExistentialBounds,\n+        bounds: &ty::ExistentialBounds,\n         expr: &ast::Expr,\n         freevars: &[ty::Freevar])\n     {"}, {"sha": "5cf759a4dce666f410606c50e115b7ae1b5741ad", "filename": "src/librustc_typeck/check/vtable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/becbd81aaa1b8c60eb13fee898163d1a2ac33de3/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/becbd81aaa1b8c60eb13fee898163d1a2ac33de3/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs?ref=becbd81aaa1b8c60eb13fee898163d1a2ac33de3", "patch": "@@ -244,7 +244,7 @@ pub fn register_object_cast_obligations<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     let object_trait_ty =\n         ty::mk_trait(fcx.tcx(),\n                      object_trait.principal.clone(),\n-                     object_trait.bounds);\n+                     object_trait.bounds.clone());\n \n     debug!(\"register_object_cast_obligations: referent_ty={} object_trait_ty={}\",\n            referent_ty.repr(fcx.tcx()),"}, {"sha": "5063ce36019d11a9acae951ac9a0b1f03e9f43f7", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 18, "deletions": 11, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/becbd81aaa1b8c60eb13fee898163d1a2ac33de3/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/becbd81aaa1b8c60eb13fee898163d1a2ac33de3/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=becbd81aaa1b8c60eb13fee898163d1a2ac33de3", "patch": "@@ -500,13 +500,14 @@ impl Clean<TyParamBound> for ast::TyParamBound {\n     }\n }\n \n-impl Clean<Vec<TyParamBound>> for ty::ExistentialBounds {\n+impl<'tcx> Clean<Vec<TyParamBound>> for ty::ExistentialBounds<'tcx> {\n     fn clean(&self, cx: &DocContext) -> Vec<TyParamBound> {\n         let mut vec = vec![];\n         self.region_bound.clean(cx).map(|b| vec.push(RegionBound(b)));\n         for bb in self.builtin_bounds.iter() {\n             vec.push(bb.clean(cx));\n         }\n+        // TODO projection bounds\n         vec\n     }\n }\n@@ -1441,18 +1442,11 @@ impl<'tcx> Clean<Type> for ty::Ty<'tcx> {\n                 }\n             }\n             ty::ty_struct(did, substs) |\n-            ty::ty_enum(did, substs) |\n-            ty::ty_trait(box ty::TyTrait {\n-                principal: ty::Binder(ty::TraitRef { def_id: did, substs }),\n-                .. }) =>\n-            {\n+            ty::ty_enum(did, substs) => {\n                 let fqn = csearch::get_item_path(cx.tcx(), did);\n-                let fqn: Vec<String> = fqn.into_iter().map(|i| {\n-                    i.to_string()\n-                }).collect();\n+                let fqn: Vec<_> = fqn.into_iter().map(|i| i.to_string()).collect();\n                 let kind = match self.sty {\n                     ty::ty_struct(..) => TypeStruct,\n-                    ty::ty_trait(..) => TypeTrait,\n                     _ => TypeEnum,\n                 };\n                 let path = external_path(cx, fqn.last().unwrap().to_string().as_slice(),\n@@ -1464,11 +1458,24 @@ impl<'tcx> Clean<Type> for ty::Ty<'tcx> {\n                     did: did,\n                 }\n             }\n+            ty::ty_trait(box ty::TyTrait { ref principal, ref bounds }) => {\n+                let did = principal.def_id();\n+                let fqn = csearch::get_item_path(cx.tcx(), did);\n+                let fqn: Vec<_> = fqn.into_iter().map(|i| i.to_string()).collect();\n+                let path = external_path(cx, fqn.last().unwrap().to_string().as_slice(),\n+                                         Some(did), principal.substs());\n+                cx.external_paths.borrow_mut().as_mut().unwrap().insert(did, (fqn, TypeTrait));\n+                ResolvedPath {\n+                    path: path,\n+                    typarams: Some(bounds.clean(cx)),\n+                    did: did,\n+                }\n+            }\n             ty::ty_tup(ref t) => Tuple(t.clean(cx)),\n \n             ty::ty_projection(ref data) => {\n                 let trait_ref = match data.trait_ref.clean(cx) {\n-                    TyParamBound::TraitBound(t) => t,\n+                    TyParamBound::TraitBound(t) => t.trait_,\n                     TyParamBound::RegionBound(_) => panic!(\"cleaning a trait got a region??\"),\n                 };\n                 Type::QPath {"}]}