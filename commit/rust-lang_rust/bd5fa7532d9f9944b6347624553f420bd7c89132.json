{"sha": "bd5fa7532d9f9944b6347624553f420bd7c89132", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJkNWZhNzUzMmQ5Zjk5NDRiNjM0NzYyNDU1M2Y0MjBiZDdjODkxMzI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-10-05T14:17:14Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-11-01T18:04:14Z"}, "message": "cleanup error reporting and add `ui` tests", "tree": {"sha": "4f908ac6e401440013d379bbff2927217e3ae921", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4f908ac6e401440013d379bbff2927217e3ae921"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bd5fa7532d9f9944b6347624553f420bd7c89132", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bd5fa7532d9f9944b6347624553f420bd7c89132", "html_url": "https://github.com/rust-lang/rust/commit/bd5fa7532d9f9944b6347624553f420bd7c89132", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bd5fa7532d9f9944b6347624553f420bd7c89132/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e77cc9c983afdeb8619ba81c20c817e015d664ba", "url": "https://api.github.com/repos/rust-lang/rust/commits/e77cc9c983afdeb8619ba81c20c817e015d664ba", "html_url": "https://github.com/rust-lang/rust/commit/e77cc9c983afdeb8619ba81c20c817e015d664ba"}], "stats": {"total": 285, "additions": 229, "deletions": 56}, "files": [{"sha": "c9850eb650a435521c23a28b7abfaadca1d57f2c", "filename": "src/librustc/infer/error_reporting.rs", "status": "modified", "additions": 66, "deletions": 24, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/bd5fa7532d9f9944b6347624553f420bd7c89132/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd5fa7532d9f9944b6347624553f420bd7c89132/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting.rs?ref=bd5fa7532d9f9944b6347624553f420bd7c89132", "patch": "@@ -245,6 +245,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         debug!(\"report_region_errors: {} errors after preprocessing\", errors.len());\n \n         for error in errors {\n+            debug!(\"report_region_errors: error = {:?}\", error);\n             match error.clone() {\n                 ConcreteFailure(origin, sub, sup) => {\n                     self.report_concrete_failure(origin, sub, sup).emit();\n@@ -299,44 +300,58 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         let mut bound_failures = Vec::new();\n \n         for error in errors {\n+            // Check whether we can process this error into some other\n+            // form; if not, fall through.\n             match *error {\n                 ConcreteFailure(ref origin, sub, sup) => {\n                     debug!(\"processing ConcreteFailure\");\n-                    match free_regions_from_same_fn(self.tcx, sub, sup) {\n-                        Some(ref same_frs) => {\n-                            origins.push(\n-                                ProcessedErrorOrigin::ConcreteFailure(\n-                                    origin.clone(),\n-                                    sub,\n-                                    sup));\n-                            append_to_same_regions(&mut same_regions, same_frs);\n-                        }\n-                        _ => {\n-                            other_errors.push(error.clone());\n-                        }\n+                    if let SubregionOrigin::CompareImplMethodObligation { .. } = *origin {\n+                        // When comparing an impl method against a\n+                        // trait method, it is not helpful to suggest\n+                        // changes to the impl method.  This is\n+                        // because the impl method signature is being\n+                        // checked using the trait's environment, so\n+                        // usually the changes we suggest would\n+                        // actually have to be applied to the *trait*\n+                        // method (and it's not clear that the trait\n+                        // method is even under the user's control).\n+                    } else if let Some(same_frs) = free_regions_from_same_fn(self.tcx, sub, sup) {\n+                        origins.push(\n+                            ProcessedErrorOrigin::ConcreteFailure(\n+                                origin.clone(),\n+                                sub,\n+                                sup));\n+                        append_to_same_regions(&mut same_regions, &same_frs);\n+                        continue;\n                     }\n                 }\n-                SubSupConflict(ref var_origin, _, sub_r, _, sup_r) => {\n-                    debug!(\"processing SubSupConflict sub: {:?} sup: {:?}\", sub_r, sup_r);\n-                    match free_regions_from_same_fn(self.tcx, sub_r, sup_r) {\n-                        Some(ref same_frs) => {\n-                            origins.push(\n-                                ProcessedErrorOrigin::VariableFailure(\n-                                    var_origin.clone()));\n-                            append_to_same_regions(&mut same_regions, same_frs);\n-                        }\n-                        None => {\n-                            other_errors.push(error.clone());\n-                        }\n+                SubSupConflict(ref var_origin, ref sub_origin, sub, ref sup_origin, sup) => {\n+                    debug!(\"processing SubSupConflict sub: {:?} sup: {:?}\", sub, sup);\n+                    if let SubregionOrigin::CompareImplMethodObligation { .. } = *sub_origin {\n+                        // As above, when comparing an impl method\n+                        // against a trait method, it is not helpful\n+                        // to suggest changes to the impl method.\n+                    } else if let SubregionOrigin::CompareImplMethodObligation { .. } = *sup_origin {\n+                        // See above.\n+                    } else if let Some(same_frs) = free_regions_from_same_fn(self.tcx, sub, sup) {\n+                        origins.push(\n+                            ProcessedErrorOrigin::VariableFailure(\n+                                var_origin.clone()));\n+                        append_to_same_regions(&mut same_regions, &same_frs);\n+                        continue;\n                     }\n                 }\n                 GenericBoundFailure(ref origin, ref kind, region) => {\n                     bound_failures.push((origin.clone(), kind.clone(), region));\n+                    continue;\n                 }\n                 ProcessedErrors(..) => {\n                     bug!(\"should not encounter a `ProcessedErrors` yet: {:?}\", error)\n                 }\n             }\n+\n+            // No changes to this error.\n+            other_errors.push(error.clone());\n         }\n \n         // ok, let's pull together the errors, sorted in an order that\n@@ -630,6 +645,18 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 format!(\"the associated type `{}`\", p),\n         };\n \n+        if let SubregionOrigin::CompareImplMethodObligation {\n+            span, item_name, impl_item_def_id, trait_item_def_id\n+        } = origin {\n+            self.report_extra_impl_obligation(span,\n+                                              item_name,\n+                                              impl_item_def_id,\n+                                              trait_item_def_id,\n+                                              &format!(\"`{}: {}`\", bound_kind, sub))\n+                .emit();\n+            return;\n+        }\n+\n         let mut err = match *sub {\n             ty::ReFree(ty::FreeRegion {bound_region: ty::BrNamed(..), ..}) => {\n                 // Does the required lifetime have a nice name we can print?\n@@ -947,6 +974,16 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     \"\");\n                 err\n             }\n+            infer::CompareImplMethodObligation { span,\n+                                                 item_name,\n+                                                 impl_item_def_id,\n+                                                 trait_item_def_id } => {\n+                self.report_extra_impl_obligation(span,\n+                                                  item_name,\n+                                                  impl_item_def_id,\n+                                                  trait_item_def_id,\n+                                                  &format!(\"`{}: {}`\", sup, sub))\n+            }\n         }\n     }\n \n@@ -1792,6 +1829,11 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     \"...so that references are valid when the destructor \\\n                      runs\");\n             }\n+            infer::CompareImplMethodObligation { span, .. } => {\n+                err.span_note(\n+                    span,\n+                    \"...so that the definition in impl matches the definition from the trait\");\n+            }\n         }\n     }\n }"}, {"sha": "9d0d0b063beb662383a4e82fc6671059e2862f53", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 36, "deletions": 3, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/bd5fa7532d9f9944b6347624553f420bd7c89132/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd5fa7532d9f9944b6347624553f420bd7c89132/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=bd5fa7532d9f9944b6347624553f420bd7c89132", "patch": "@@ -360,6 +360,15 @@ pub enum SubregionOrigin<'tcx> {\n \n     // Region constraint arriving from destructor safety\n     SafeDestructor(Span),\n+\n+    // Comparing the signature and requirements of an impl method against\n+    // the containing trait.\n+    CompareImplMethodObligation {\n+        span: Span,\n+        item_name: ast::Name,\n+        impl_item_def_id: DefId,\n+        trait_item_def_id: DefId,\n+    },\n }\n \n /// Places that type/region parameters can appear.\n@@ -1152,16 +1161,16 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn region_outlives_predicate(&self,\n-                                     span: Span,\n+                                     cause: &traits::ObligationCause<'tcx>,\n                                      predicate: &ty::PolyRegionOutlivesPredicate<'tcx>)\n         -> UnitResult<'tcx>\n     {\n         self.commit_if_ok(|snapshot| {\n             let (ty::OutlivesPredicate(r_a, r_b), skol_map) =\n                 self.skolemize_late_bound_regions(predicate, snapshot);\n-            let origin = RelateRegionParamBound(span);\n+            let origin = SubregionOrigin::from_cause(cause, || RelateRegionParamBound(cause.span));\n             self.sub_regions(origin, r_b, r_a); // `b : a` ==> `a <= b`\n-            self.leak_check(false, span, &skol_map, snapshot)?;\n+            self.leak_check(false, cause.span, &skol_map, snapshot)?;\n             Ok(self.pop_skolemized(skol_map, snapshot))\n         })\n     }\n@@ -1792,6 +1801,30 @@ impl<'tcx> SubregionOrigin<'tcx> {\n             AddrOf(a) => a,\n             AutoBorrow(a) => a,\n             SafeDestructor(a) => a,\n+            CompareImplMethodObligation { span, .. } => span,\n+        }\n+    }\n+\n+    pub fn from_cause<F>(cause: &traits::ObligationCause<'tcx>,\n+                         default: F)\n+                         -> Self\n+        where F: FnOnce() -> Self\n+    {\n+        match cause.code {\n+            traits::ObligationCauseCode::ReferenceOutlivesReferent(ref_type) =>\n+                SubregionOrigin::ReferenceOutlivesReferent(ref_type, cause.span),\n+\n+            traits::ObligationCauseCode::CompareImplMethodObligation { item_name,\n+                                                                       impl_item_def_id,\n+                                                                       trait_item_def_id } =>\n+                SubregionOrigin::CompareImplMethodObligation {\n+                    span: cause.span,\n+                    item_name: item_name,\n+                    impl_item_def_id: impl_item_def_id,\n+                    trait_item_def_id: trait_item_def_id,\n+                },\n+\n+            _ => default(),\n         }\n     }\n }"}, {"sha": "56ab8cb22ced8ee80c3497b0303eb3843e7b9583", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 39, "deletions": 8, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/bd5fa7532d9f9944b6347624553f420bd7c89132/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd5fa7532d9f9944b6347624553f420bd7c89132/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=bd5fa7532d9f9944b6347624553f420bd7c89132", "patch": "@@ -36,6 +36,7 @@ use util::nodemap::{FnvHashMap, FnvHashSet};\n \n use std::cmp;\n use std::fmt;\n+use syntax::ast;\n use syntax_pos::Span;\n use errors::DiagnosticBuilder;\n \n@@ -417,19 +418,49 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.report_overflow_error(&cycle[0], false);\n     }\n \n+    pub fn report_extra_impl_obligation(&self,\n+                                        error_span: Span,\n+                                        item_name: ast::Name,\n+                                        _impl_item_def_id: DefId,\n+                                        trait_item_def_id: DefId,\n+                                        requirement: &fmt::Display)\n+                                        -> DiagnosticBuilder<'tcx>\n+    {\n+        let mut err =\n+            struct_span_err!(self.tcx.sess,\n+                             error_span,\n+                             E0276,\n+                             \"impl has stricter requirements than trait\");\n+\n+        if let Some(trait_item_span) = self.tcx.map.span_if_local(trait_item_def_id) {\n+            err.span_label(trait_item_span,\n+                           &format!(\"definition of `{}` from trait\", item_name));\n+        }\n+\n+        err.span_label(\n+            error_span,\n+            &format!(\"impl has extra requirement {}\", requirement));\n+\n+        err\n+    }\n+\n     pub fn report_selection_error(&self,\n                                   obligation: &PredicateObligation<'tcx>,\n                                   error: &SelectionError<'tcx>)\n     {\n         let span = obligation.cause.span;\n         let mut err = match *error {\n             SelectionError::Unimplemented => {\n-                if let ObligationCauseCode::CompareImplMethodObligation = obligation.cause.code {\n-                    span_err!(\n-                        self.tcx.sess, span, E0276,\n-                        \"the requirement `{}` appears on the impl \\\n-                         method but not on the corresponding trait method\",\n-                        obligation.predicate);\n+                if let ObligationCauseCode::CompareImplMethodObligation {\n+                    item_name, impl_item_def_id, trait_item_def_id\n+                } = obligation.cause.code {\n+                    self.report_extra_impl_obligation(\n+                        span,\n+                        item_name,\n+                        impl_item_def_id,\n+                        trait_item_def_id,\n+                        &format!(\"`{}`\", obligation.predicate))\n+                        .emit();\n                     return;\n                 } else {\n                     match obligation.predicate {\n@@ -492,7 +523,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n                         ty::Predicate::RegionOutlives(ref predicate) => {\n                             let predicate = self.resolve_type_vars_if_possible(predicate);\n-                            let err = self.region_outlives_predicate(span,\n+                            let err = self.region_outlives_predicate(&obligation.cause,\n                                                                      &predicate).err().unwrap();\n                             struct_span_err!(self.tcx.sess, span, E0279,\n                                 \"the requirement `{}` is not satisfied (`{}`)\",\n@@ -886,7 +917,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                                 &parent_predicate,\n                                                 &data.parent_code);\n             }\n-            ObligationCauseCode::CompareImplMethodObligation => {\n+            ObligationCauseCode::CompareImplMethodObligation { .. } => {\n                 err.note(\n                     &format!(\"the requirement `{}` appears on the impl method \\\n                               but not on the corresponding trait method\","}, {"sha": "906da4290361e75c0c507b0c2e10c1b096d8b049", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd5fa7532d9f9944b6347624553f420bd7c89132/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd5fa7532d9f9944b6347624553f420bd7c89132/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=bd5fa7532d9f9944b6347624553f420bd7c89132", "patch": "@@ -526,7 +526,7 @@ fn process_predicate<'a, 'gcx, 'tcx>(\n         }\n \n         ty::Predicate::RegionOutlives(ref binder) => {\n-            match selcx.infcx().region_outlives_predicate(obligation.cause.span, binder) {\n+            match selcx.infcx().region_outlives_predicate(&obligation.cause, binder) {\n                 Ok(()) => Ok(Some(Vec::new())),\n                 Err(_) => Err(CodeSelectionError(Unimplemented)),\n             }"}, {"sha": "64016da4de76591470fe485d1468648536da53e4", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bd5fa7532d9f9944b6347624553f420bd7c89132/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd5fa7532d9f9944b6347624553f420bd7c89132/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=bd5fa7532d9f9944b6347624553f420bd7c89132", "patch": "@@ -138,7 +138,11 @@ pub enum ObligationCauseCode<'tcx> {\n \n     ImplDerivedObligation(DerivedObligationCause<'tcx>),\n \n-    CompareImplMethodObligation,\n+    CompareImplMethodObligation {\n+        item_name: ast::Name,\n+        impl_item_def_id: DefId,\n+        trait_item_def_id: DefId\n+    },\n }\n \n #[derive(Clone, Debug, PartialEq, Eq)]"}, {"sha": "57ae176c0e9d39acefbe6bdfb0561ea41cc5f40c", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bd5fa7532d9f9944b6347624553f420bd7c89132/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd5fa7532d9f9944b6347624553f420bd7c89132/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=bd5fa7532d9f9944b6347624553f420bd7c89132", "patch": "@@ -195,8 +195,14 @@ impl<'a, 'tcx> Lift<'tcx> for traits::ObligationCauseCode<'a> {\n             super::ImplDerivedObligation(ref cause) => {\n                 tcx.lift(cause).map(super::ImplDerivedObligation)\n             }\n-            super::CompareImplMethodObligation => {\n-                Some(super::CompareImplMethodObligation)\n+            super::CompareImplMethodObligation { item_name,\n+                                                 impl_item_def_id,\n+                                                 trait_item_def_id } => {\n+                Some(super::CompareImplMethodObligation {\n+                    item_name: item_name,\n+                    impl_item_def_id: impl_item_def_id,\n+                    trait_item_def_id: trait_item_def_id,\n+                })\n             }\n         }\n     }\n@@ -459,7 +465,7 @@ impl<'tcx> TypeFoldable<'tcx> for traits::ObligationCauseCode<'tcx> {\n             super::FieldSized |\n             super::ConstSized |\n             super::SharedStatic |\n-            super::CompareImplMethodObligation => self.clone(),\n+            super::CompareImplMethodObligation { .. } => self.clone(),\n \n             super::ProjectionWf(proj) => super::ProjectionWf(proj.fold_with(folder)),\n             super::ReferenceOutlivesReferent(ty) => {\n@@ -492,7 +498,7 @@ impl<'tcx> TypeFoldable<'tcx> for traits::ObligationCauseCode<'tcx> {\n             super::FieldSized |\n             super::ConstSized |\n             super::SharedStatic |\n-            super::CompareImplMethodObligation => false,\n+            super::CompareImplMethodObligation { .. } => false,\n \n             super::ProjectionWf(proj) => proj.visit_with(visitor),\n             super::ReferenceOutlivesReferent(ty) => ty.visit_with(visitor),"}, {"sha": "a5b3811ec61bc19052b352c9f514773680f11eeb", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bd5fa7532d9f9944b6347624553f420bd7c89132/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd5fa7532d9f9944b6347624553f420bd7c89132/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=bd5fa7532d9f9944b6347624553f420bd7c89132", "patch": "@@ -363,7 +363,11 @@ pub fn compare_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             let cause = traits::ObligationCause {\n                 span: impl_m_span,\n                 body_id: impl_m_body_id,\n-                code: traits::ObligationCauseCode::CompareImplMethodObligation,\n+                code: traits::ObligationCauseCode::CompareImplMethodObligation {\n+                    item_name: impl_m.name,\n+                    impl_item_def_id: impl_m.def_id,\n+                    trait_item_def_id: trait_m.def_id,\n+                },\n             };\n \n             fulfillment_cx.borrow_mut().register_predicate_obligation("}, {"sha": "536c4a9d524d92c6e1c4b6ada5f66e2415c48dee", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bd5fa7532d9f9944b6347624553f420bd7c89132/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd5fa7532d9f9944b6347624553f420bd7c89132/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=bd5fa7532d9f9944b6347624553f420bd7c89132", "patch": "@@ -356,7 +356,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n             debug!(\"visit_region_obligations: r_o={:?} cause={:?}\",\n                    r_o, r_o.cause);\n             let sup_type = self.resolve_type(r_o.sup_type);\n-            let origin = self.code_to_origin(r_o.cause.span, sup_type, &r_o.cause.code);\n+            let origin = self.code_to_origin(&r_o.cause, sup_type);\n             self.type_must_outlive(origin, sup_type, r_o.sub_region);\n         }\n \n@@ -366,16 +366,10 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     fn code_to_origin(&self,\n-                      span: Span,\n-                      sup_type: Ty<'tcx>,\n-                      code: &traits::ObligationCauseCode<'tcx>)\n+                      cause: &traits::ObligationCause<'tcx>,\n+                      sup_type: Ty<'tcx>)\n                       -> SubregionOrigin<'tcx> {\n-        match *code {\n-            traits::ObligationCauseCode::ReferenceOutlivesReferent(ref_type) =>\n-                infer::ReferenceOutlivesReferent(ref_type, span),\n-            _ =>\n-                infer::RelateParamBound(span, sup_type),\n-        }\n+        SubregionOrigin::from_cause(cause, || infer::RelateParamBound(cause.span, sup_type))\n     }\n \n     /// This method populates the region map's `free_region_map`. It walks over the transformed"}, {"sha": "631da7140eadf659e981512fc0556588b909e482", "filename": "src/test/ui/compare-method/proj-outlives-region.rs", "status": "renamed", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bd5fa7532d9f9944b6347624553f420bd7c89132/src%2Ftest%2Fui%2Fcompare-method%2Fproj-outlives-region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd5fa7532d9f9944b6347624553f420bd7c89132/src%2Ftest%2Fui%2Fcompare-method%2Fproj-outlives-region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcompare-method%2Fproj-outlives-region.rs?ref=bd5fa7532d9f9944b6347624553f420bd7c89132", "patch": "@@ -18,8 +18,7 @@ trait Master<'a, T: ?Sized, U> {\n \n // `U::Item: 'a` does not imply that `U: 'a`\n impl<'a, U: Iterator> Master<'a, U::Item, U> for () {\n-    fn foo() where U: 'a { }\n-    //~^ ERROR parameter type `V` may not live long enough\n+    fn foo() where U: 'a { } //~ ERROR E0276\n }\n \n fn main() {", "previous_filename": "src/test/compile-fail/traits-elaborate-type-region-proj.rs"}, {"sha": "b36d64e3b9c97dc706c8102301b99b200d4c2cc0", "filename": "src/test/ui/compare-method/proj-outlives-region.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/bd5fa7532d9f9944b6347624553f420bd7c89132/src%2Ftest%2Fui%2Fcompare-method%2Fproj-outlives-region.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bd5fa7532d9f9944b6347624553f420bd7c89132/src%2Ftest%2Fui%2Fcompare-method%2Fproj-outlives-region.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcompare-method%2Fproj-outlives-region.stderr?ref=bd5fa7532d9f9944b6347624553f420bd7c89132", "patch": "@@ -0,0 +1,11 @@\n+error[E0276]: impl has stricter requirements than trait\n+  --> $DIR/proj-outlives-region.rs:21:5\n+   |\n+16 |     fn foo() where T: 'a;\n+   |     --------------------- definition of `foo` from trait\n+...\n+21 |     fn foo() where U: 'a { } //~ ERROR E0276\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^ impl has extra requirement `U: 'a`\n+\n+error: aborting due to previous error\n+"}, {"sha": "3c11b8bb1ef147b1ce66f954bc41cf73dcb89099", "filename": "src/test/ui/compare-method/region-unrelated.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bd5fa7532d9f9944b6347624553f420bd7c89132/src%2Ftest%2Fui%2Fcompare-method%2Fregion-unrelated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd5fa7532d9f9944b6347624553f420bd7c89132/src%2Ftest%2Fui%2Fcompare-method%2Fregion-unrelated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcompare-method%2Fregion-unrelated.rs?ref=bd5fa7532d9f9944b6347624553f420bd7c89132", "previous_filename": "src/test/compile-fail/traits-elaborate-type-region-unrelated.rs"}, {"sha": "fb3511867e589a665b801dfdf2986b25d14750a9", "filename": "src/test/ui/compare-method/region-unrelated.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/bd5fa7532d9f9944b6347624553f420bd7c89132/src%2Ftest%2Fui%2Fcompare-method%2Fregion-unrelated.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bd5fa7532d9f9944b6347624553f420bd7c89132/src%2Ftest%2Fui%2Fcompare-method%2Fregion-unrelated.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcompare-method%2Fregion-unrelated.stderr?ref=bd5fa7532d9f9944b6347624553f420bd7c89132", "patch": "@@ -0,0 +1,11 @@\n+error[E0276]: impl has stricter requirements than trait\n+  --> $DIR/region-unrelated.rs:21:5\n+   |\n+16 |     fn foo() where T: 'a;\n+   |     --------------------- definition of `foo` from trait\n+...\n+21 |     fn foo() where V: 'a { }\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^ impl has extra requirement `V: 'a`\n+\n+error: aborting due to previous error\n+"}, {"sha": "1942ca9504c88de6a84b4d21777d1add0707040e", "filename": "src/test/ui/compare-method/region.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/bd5fa7532d9f9944b6347624553f420bd7c89132/src%2Ftest%2Fui%2Fcompare-method%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd5fa7532d9f9944b6347624553f420bd7c89132/src%2Ftest%2Fui%2Fcompare-method%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcompare-method%2Fregion.rs?ref=bd5fa7532d9f9944b6347624553f420bd7c89132", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(dead_code)]\n+\n+// Test that we elaborate `Type: 'region` constraints and infer various important things.\n+\n+trait Master<'a, 'b> {\n+    fn foo();\n+}\n+\n+// `U: 'a` does not imply `V: 'a`\n+impl<'a, 'b> Master<'a, 'b> for () {\n+    fn foo() where 'a: 'b { }\n+    //~^ ERROR parameter type `V` may not live long enough\n+}\n+\n+fn main() {\n+    println!(\"Hello, world!\");\n+}"}, {"sha": "78e00e066bd7bce8a91068a7645079596098ebcc", "filename": "src/test/ui/compare-method/region.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/bd5fa7532d9f9944b6347624553f420bd7c89132/src%2Ftest%2Fui%2Fcompare-method%2Fregion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bd5fa7532d9f9944b6347624553f420bd7c89132/src%2Ftest%2Fui%2Fcompare-method%2Fregion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcompare-method%2Fregion.stderr?ref=bd5fa7532d9f9944b6347624553f420bd7c89132", "patch": "@@ -0,0 +1,11 @@\n+error[E0276]: impl has stricter requirements than trait\n+  --> $DIR/region.rs:21:5\n+   |\n+16 |     fn foo();\n+   |     --------- definition of `foo` from trait\n+...\n+21 |     fn foo() where 'a: 'b { }\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^ impl has extra requirement `'a: 'b`\n+\n+error: aborting due to previous error\n+"}, {"sha": "aa99d35f7aa779924dd17c96675ee50449f3343f", "filename": "src/test/ui/update-references.sh", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bd5fa7532d9f9944b6347624553f420bd7c89132/src%2Ftest%2Fui%2Fupdate-references.sh", "raw_url": "https://github.com/rust-lang/rust/raw/bd5fa7532d9f9944b6347624553f420bd7c89132/src%2Ftest%2Fui%2Fupdate-references.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fupdate-references.sh?ref=bd5fa7532d9f9944b6347624553f420bd7c89132", "patch": "@@ -36,12 +36,12 @@ while [[ \"$1\" != \"\" ]]; do\n     STDOUT_NAME=\"${1/%.rs/.stdout}\"\n     shift\n     if [ -f $BUILD_DIR/$STDOUT_NAME ] && \\\n-           ! (diff $BUILD_DIR/$STDOUT_NAME $MYDIR/$STDOUT_NAME > /dev/null); then\n+           ! (diff $BUILD_DIR/$STDOUT_NAME $MYDIR/$STDOUT_NAME >& /dev/null); then\n         echo updating $MYDIR/$STDOUT_NAME\n         cp $BUILD_DIR/$STDOUT_NAME $MYDIR/$STDOUT_NAME\n     fi\n     if [ -f $BUILD_DIR/$STDERR_NAME ] && \\\n-           ! (diff $BUILD_DIR/$STDERR_NAME $MYDIR/$STDERR_NAME > /dev/null); then\n+           ! (diff $BUILD_DIR/$STDERR_NAME $MYDIR/$STDERR_NAME >& /dev/null); then\n         echo updating $MYDIR/$STDERR_NAME\n         cp $BUILD_DIR/$STDERR_NAME $MYDIR/$STDERR_NAME\n     fi"}]}