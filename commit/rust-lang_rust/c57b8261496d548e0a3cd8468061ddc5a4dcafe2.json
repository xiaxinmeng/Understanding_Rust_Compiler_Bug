{"sha": "c57b8261496d548e0a3cd8468061ddc5a4dcafe2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM1N2I4MjYxNDk2ZDU0OGUwYTNjZDg0NjgwNjFkZGM1YTRkY2FmZTI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-11-17T15:43:50Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-11-17T15:43:50Z"}, "message": "Auto merge of #37732 - jseyfried:use_extern_macros, r=nrc\n\nSupport `use`ing externally defined macros behind `#![feature(use_extern_macros)]`\n\nWith `#![feature(use_extern_macros)]`,\n - A name collision between macros from different upstream crates is much less of an issue since we can `use` the macros in different submodules or rename with `as`.\n - We can reexport macros with `pub use`, so `#![feature(macro_reexport)]` is no longer needed.\n - These reexports are allowed in any module, so crates can expose a macro-modular interface.\n\nIf a macro invocation can resolve to both a `use` import and a `macro_rules!` or `#[macro_use]`, it is an ambiguity error.\n\nr? @nrc", "tree": {"sha": "aa6b693f0cda3854318d75b7708f593f52b4f645", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aa6b693f0cda3854318d75b7708f593f52b4f645"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c57b8261496d548e0a3cd8468061ddc5a4dcafe2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c57b8261496d548e0a3cd8468061ddc5a4dcafe2", "html_url": "https://github.com/rust-lang/rust/commit/c57b8261496d548e0a3cd8468061ddc5a4dcafe2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c57b8261496d548e0a3cd8468061ddc5a4dcafe2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5bd1e7f59ffe6126db57ea94b90690d1ac39b932", "url": "https://api.github.com/repos/rust-lang/rust/commits/5bd1e7f59ffe6126db57ea94b90690d1ac39b932", "html_url": "https://github.com/rust-lang/rust/commit/5bd1e7f59ffe6126db57ea94b90690d1ac39b932"}, {"sha": "6cb33a089fc4727bc070899f57aab3be1b215785", "url": "https://api.github.com/repos/rust-lang/rust/commits/6cb33a089fc4727bc070899f57aab3be1b215785", "html_url": "https://github.com/rust-lang/rust/commit/6cb33a089fc4727bc070899f57aab3be1b215785"}], "stats": {"total": 1004, "additions": 618, "deletions": 386}, "files": [{"sha": "5466c8871d49177073442e88de47d83195e82261", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c57b8261496d548e0a3cd8468061ddc5a4dcafe2/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c57b8261496d548e0a3cd8468061ddc5a4dcafe2/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=c57b8261496d548e0a3cd8468061ddc5a4dcafe2", "patch": "@@ -755,8 +755,6 @@ pub fn phase_2_configure_and_expand<'a, F>(sess: &Session,\n          || ast_validation::check_crate(sess, &krate));\n \n     time(sess.time_passes(), \"name resolution\", || -> CompileResult {\n-        resolver.resolve_imports();\n-\n         // Since import resolution will eventually happen in expansion,\n         // don't perform `after_expand` until after import resolution.\n         after_expand(&krate)?;"}, {"sha": "627c72ff8c92572c9169f57423c7eca9387c4fbc", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 92, "deletions": 60, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/c57b8261496d548e0a3cd8468061ddc5a4dcafe2/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c57b8261496d548e0a3cd8468061ddc5a4dcafe2/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=c57b8261496d548e0a3cd8468061ddc5a4dcafe2", "patch": "@@ -15,7 +15,7 @@\n \n use macros::{InvocationData, LegacyScope};\n use resolve_imports::ImportDirective;\n-use resolve_imports::ImportDirectiveSubclass::{self, GlobImport};\n+use resolve_imports::ImportDirectiveSubclass::{self, GlobImport, SingleImport};\n use {Resolver, Module, ModuleS, ModuleKind, NameBinding, NameBindingKind, ToNameBinding};\n use Namespace::{self, TypeNS, ValueNS, MacroNS};\n use ResolveResult::Success;\n@@ -37,6 +37,7 @@ use syntax::ast::{self, Block, ForeignItem, ForeignItemKind, Item, ItemKind};\n use syntax::ast::{Mutability, StmtKind, TraitItem, TraitItemKind};\n use syntax::ast::{Variant, ViewPathGlob, ViewPathList, ViewPathSimple};\n use syntax::ext::base::SyntaxExtension;\n+use syntax::ext::base::Determinacy::Undetermined;\n use syntax::ext::expand::mark_tts;\n use syntax::ext::hygiene::Mark;\n use syntax::ext::tt::macro_rules;\n@@ -45,15 +46,25 @@ use syntax::visit::{self, Visitor};\n \n use syntax_pos::{Span, DUMMY_SP};\n \n-impl<'a> ToNameBinding<'a> for (Module<'a>, Span, ty::Visibility) {\n+impl<'a> ToNameBinding<'a> for (Module<'a>, ty::Visibility, Span, Mark) {\n     fn to_name_binding(self) -> NameBinding<'a> {\n-        NameBinding { kind: NameBindingKind::Module(self.0), span: self.1, vis: self.2 }\n+        NameBinding {\n+            kind: NameBindingKind::Module(self.0),\n+            vis: self.1,\n+            span: self.2,\n+            expansion: self.3,\n+        }\n     }\n }\n \n-impl<'a> ToNameBinding<'a> for (Def, Span, ty::Visibility) {\n+impl<'a> ToNameBinding<'a> for (Def, ty::Visibility, Span, Mark) {\n     fn to_name_binding(self) -> NameBinding<'a> {\n-        NameBinding { kind: NameBindingKind::Def(self.0), span: self.1, vis: self.2 }\n+        NameBinding {\n+            kind: NameBindingKind::Def(self.0),\n+            vis: self.1,\n+            span: self.2,\n+            expansion: self.3,\n+        }\n     }\n }\n \n@@ -147,9 +158,14 @@ impl<'b> Resolver<'b> {\n                                 .emit();\n                         }\n \n-                        let subclass = ImportDirectiveSubclass::single(binding.name, source.name);\n-                        let span = view_path.span;\n-                        self.add_import_directive(module_path, subclass, span, item.id, vis);\n+                        let subclass = SingleImport {\n+                            target: binding.name,\n+                            source: source.name,\n+                            result: self.per_ns(|_, _| Cell::new(Err(Undetermined))),\n+                        };\n+                        self.add_import_directive(\n+                            module_path, subclass, view_path.span, item.id, vis, expansion,\n+                        );\n                     }\n                     ViewPathList(_, ref source_items) => {\n                         // Make sure there's at most one `mod` import in the list.\n@@ -195,18 +211,25 @@ impl<'b> Resolver<'b> {\n                                     (module_path.to_vec(), name, rename)\n                                 }\n                             };\n-                            let subclass = ImportDirectiveSubclass::single(rename, name);\n-                            let (span, id) = (source_item.span, source_item.node.id);\n-                            self.add_import_directive(module_path, subclass, span, id, vis);\n+                            let subclass = SingleImport {\n+                                target: rename,\n+                                source: name,\n+                                result: self.per_ns(|_, _| Cell::new(Err(Undetermined))),\n+                            };\n+                            let id = source_item.node.id;\n+                            self.add_import_directive(\n+                                module_path, subclass, source_item.span, id, vis, expansion,\n+                            );\n                         }\n                     }\n                     ViewPathGlob(_) => {\n                         let subclass = GlobImport {\n                             is_prelude: is_prelude,\n                             max_vis: Cell::new(ty::Visibility::PrivateExternal),\n                         };\n-                        let span = view_path.span;\n-                        self.add_import_directive(module_path, subclass, span, item.id, vis);\n+                        self.add_import_directive(\n+                            module_path, subclass, view_path.span, item.id, vis, expansion,\n+                        );\n                     }\n                 }\n             }\n@@ -217,7 +240,7 @@ impl<'b> Resolver<'b> {\n                 // n.b. we don't need to look at the path option here, because cstore already did\n                 let crate_id = self.session.cstore.extern_mod_stmt_cnum(item.id).unwrap();\n                 let module = self.get_extern_crate_root(crate_id);\n-                let binding = (module, sp, ty::Visibility::Public).to_name_binding();\n+                let binding = (module, ty::Visibility::Public, sp, expansion).to_name_binding();\n                 let binding = self.arenas.alloc_name_binding(binding);\n                 let directive = self.arenas.alloc_import_directive(ImportDirective {\n                     id: item.id,\n@@ -227,6 +250,7 @@ impl<'b> Resolver<'b> {\n                     span: item.span,\n                     module_path: Vec::new(),\n                     vis: Cell::new(vis),\n+                    expansion: expansion,\n                 });\n                 let imported_binding = self.import(binding, directive);\n                 self.define(parent, name, TypeNS, imported_binding);\n@@ -245,7 +269,7 @@ impl<'b> Resolver<'b> {\n                     normal_ancestor_id: Some(item.id),\n                     ..ModuleS::new(Some(parent), ModuleKind::Def(def, name))\n                 });\n-                self.define(parent, name, TypeNS, (module, sp, vis));\n+                self.define(parent, name, TypeNS, (module, vis, sp, expansion));\n                 self.module_map.insert(item.id, module);\n \n                 // Descend into the module.\n@@ -258,45 +282,45 @@ impl<'b> Resolver<'b> {\n             ItemKind::Static(_, m, _) => {\n                 let mutbl = m == Mutability::Mutable;\n                 let def = Def::Static(self.definitions.local_def_id(item.id), mutbl);\n-                self.define(parent, name, ValueNS, (def, sp, vis));\n+                self.define(parent, name, ValueNS, (def, vis, sp, expansion));\n             }\n             ItemKind::Const(..) => {\n                 let def = Def::Const(self.definitions.local_def_id(item.id));\n-                self.define(parent, name, ValueNS, (def, sp, vis));\n+                self.define(parent, name, ValueNS, (def, vis, sp, expansion));\n             }\n             ItemKind::Fn(..) => {\n                 let def = Def::Fn(self.definitions.local_def_id(item.id));\n-                self.define(parent, name, ValueNS, (def, sp, vis));\n+                self.define(parent, name, ValueNS, (def, vis, sp, expansion));\n             }\n \n             // These items live in the type namespace.\n             ItemKind::Ty(..) => {\n                 let def = Def::TyAlias(self.definitions.local_def_id(item.id));\n-                self.define(parent, name, TypeNS, (def, sp, vis));\n+                self.define(parent, name, TypeNS, (def, vis, sp, expansion));\n             }\n \n             ItemKind::Enum(ref enum_definition, _) => {\n                 let def = Def::Enum(self.definitions.local_def_id(item.id));\n                 let module = self.new_module(parent, ModuleKind::Def(def, name), true);\n-                self.define(parent, name, TypeNS, (module, sp, vis));\n+                self.define(parent, name, TypeNS, (module, vis, sp, expansion));\n \n                 for variant in &(*enum_definition).variants {\n-                    self.build_reduced_graph_for_variant(variant, module, vis);\n+                    self.build_reduced_graph_for_variant(variant, module, vis, expansion);\n                 }\n             }\n \n             // These items live in both the type and value namespaces.\n             ItemKind::Struct(ref struct_def, _) => {\n                 // Define a name in the type namespace.\n                 let def = Def::Struct(self.definitions.local_def_id(item.id));\n-                self.define(parent, name, TypeNS, (def, sp, vis));\n+                self.define(parent, name, TypeNS, (def, vis, sp, expansion));\n \n                 // If this is a tuple or unit struct, define a name\n                 // in the value namespace as well.\n                 if !struct_def.is_struct() {\n                     let ctor_def = Def::StructCtor(self.definitions.local_def_id(struct_def.id()),\n                                                    CtorKind::from_ast(struct_def));\n-                    self.define(parent, name, ValueNS, (ctor_def, sp, vis));\n+                    self.define(parent, name, ValueNS, (ctor_def, vis, sp, expansion));\n                 }\n \n                 // Record field names for error reporting.\n@@ -310,7 +334,7 @@ impl<'b> Resolver<'b> {\n \n             ItemKind::Union(ref vdata, _) => {\n                 let def = Def::Union(self.definitions.local_def_id(item.id));\n-                self.define(parent, name, TypeNS, (def, sp, vis));\n+                self.define(parent, name, TypeNS, (def, vis, sp, expansion));\n \n                 // Record field names for error reporting.\n                 let field_names = vdata.fields().iter().filter_map(|field| {\n@@ -329,7 +353,7 @@ impl<'b> Resolver<'b> {\n                 // Add all the items within to a new module.\n                 let module =\n                     self.new_module(parent, ModuleKind::Def(Def::Trait(def_id), name), true);\n-                self.define(parent, name, TypeNS, (module, sp, vis));\n+                self.define(parent, name, TypeNS, (module, vis, sp, expansion));\n                 self.current_module = module;\n             }\n             ItemKind::Mac(_) => panic!(\"unexpanded macro in resolve!\"),\n@@ -341,37 +365,38 @@ impl<'b> Resolver<'b> {\n     fn build_reduced_graph_for_variant(&mut self,\n                                        variant: &Variant,\n                                        parent: Module<'b>,\n-                                       vis: ty::Visibility) {\n+                                       vis: ty::Visibility,\n+                                       expansion: Mark) {\n         let name = variant.node.name.name;\n         let def_id = self.definitions.local_def_id(variant.node.data.id());\n \n         // Define a name in the type namespace.\n         let def = Def::Variant(def_id);\n-        self.define(parent, name, TypeNS, (def, variant.span, vis));\n+        self.define(parent, name, TypeNS, (def, vis, variant.span, expansion));\n \n         // Define a constructor name in the value namespace.\n         // Braced variants, unlike structs, generate unusable names in\n         // value namespace, they are reserved for possible future use.\n         let ctor_kind = CtorKind::from_ast(&variant.node.data);\n         let ctor_def = Def::VariantCtor(def_id, ctor_kind);\n-        self.define(parent, name, ValueNS, (ctor_def, variant.span, vis));\n+        self.define(parent, name, ValueNS, (ctor_def, vis, variant.span, expansion));\n     }\n \n     /// Constructs the reduced graph for one foreign item.\n-    fn build_reduced_graph_for_foreign_item(&mut self, foreign_item: &ForeignItem) {\n+    fn build_reduced_graph_for_foreign_item(&mut self, item: &ForeignItem, expansion: Mark) {\n         let parent = self.current_module;\n-        let name = foreign_item.ident.name;\n+        let name = item.ident.name;\n \n-        let def = match foreign_item.node {\n+        let def = match item.node {\n             ForeignItemKind::Fn(..) => {\n-                Def::Fn(self.definitions.local_def_id(foreign_item.id))\n+                Def::Fn(self.definitions.local_def_id(item.id))\n             }\n             ForeignItemKind::Static(_, m) => {\n-                Def::Static(self.definitions.local_def_id(foreign_item.id), m)\n+                Def::Static(self.definitions.local_def_id(item.id), m)\n             }\n         };\n-        let vis = self.resolve_visibility(&foreign_item.vis);\n-        self.define(parent, name, ValueNS, (def, foreign_item.span, vis));\n+        let vis = self.resolve_visibility(&item.vis);\n+        self.define(parent, name, ValueNS, (def, vis, item.span, expansion));\n     }\n \n     fn build_reduced_graph_for_block(&mut self, block: &Block) {\n@@ -390,8 +415,7 @@ impl<'b> Resolver<'b> {\n     }\n \n     /// Builds the reduced graph for a single item in an external crate.\n-    fn build_reduced_graph_for_external_crate_def(&mut self, parent: Module<'b>,\n-                                                  child: Export) {\n+    fn build_reduced_graph_for_external_crate_def(&mut self, parent: Module<'b>, child: Export) {\n         let name = child.name;\n         let def = child.def;\n         let def_id = def.def_id();\n@@ -404,24 +428,24 @@ impl<'b> Resolver<'b> {\n         match def {\n             Def::Mod(..) | Def::Enum(..) => {\n                 let module = self.new_module(parent, ModuleKind::Def(def, name), false);\n-                self.define(parent, name, TypeNS, (module, DUMMY_SP, vis));\n+                self.define(parent, name, TypeNS, (module, vis, DUMMY_SP, Mark::root()));\n             }\n             Def::Variant(..) => {\n-                self.define(parent, name, TypeNS, (def, DUMMY_SP, vis));\n+                self.define(parent, name, TypeNS, (def, vis, DUMMY_SP, Mark::root()));\n             }\n             Def::VariantCtor(..) => {\n-                self.define(parent, name, ValueNS, (def, DUMMY_SP, vis));\n+                self.define(parent, name, ValueNS, (def, vis, DUMMY_SP, Mark::root()));\n             }\n             Def::Fn(..) |\n             Def::Static(..) |\n             Def::Const(..) |\n             Def::AssociatedConst(..) |\n             Def::Method(..) => {\n-                self.define(parent, name, ValueNS, (def, DUMMY_SP, vis));\n+                self.define(parent, name, ValueNS, (def, vis, DUMMY_SP, Mark::root()));\n             }\n             Def::Trait(..) => {\n                 let module = self.new_module(parent, ModuleKind::Def(def, name), false);\n-                self.define(parent, name, TypeNS, (module, DUMMY_SP, vis));\n+                self.define(parent, name, TypeNS, (module, vis, DUMMY_SP, Mark::root()));\n \n                 // If this is a trait, add all the trait item names to the trait info.\n                 let trait_item_def_ids = self.session.cstore.associated_item_def_ids(def_id);\n@@ -433,27 +457,27 @@ impl<'b> Resolver<'b> {\n                 }\n             }\n             Def::TyAlias(..) | Def::AssociatedTy(..) => {\n-                self.define(parent, name, TypeNS, (def, DUMMY_SP, vis));\n+                self.define(parent, name, TypeNS, (def, vis, DUMMY_SP, Mark::root()));\n             }\n             Def::Struct(..) => {\n-                self.define(parent, name, TypeNS, (def, DUMMY_SP, vis));\n+                self.define(parent, name, TypeNS, (def, vis, DUMMY_SP, Mark::root()));\n \n                 // Record field names for error reporting.\n                 let field_names = self.session.cstore.struct_field_names(def_id);\n                 self.insert_field_names(def_id, field_names);\n             }\n             Def::StructCtor(..) => {\n-                self.define(parent, name, ValueNS, (def, DUMMY_SP, vis));\n+                self.define(parent, name, ValueNS, (def, vis, DUMMY_SP, Mark::root()));\n             }\n             Def::Union(..) => {\n-                self.define(parent, name, TypeNS, (def, DUMMY_SP, vis));\n+                self.define(parent, name, TypeNS, (def, vis, DUMMY_SP, Mark::root()));\n \n                 // Record field names for error reporting.\n                 let field_names = self.session.cstore.struct_field_names(def_id);\n                 self.insert_field_names(def_id, field_names);\n             }\n             Def::Macro(..) => {\n-                self.define(parent, name, MacroNS, (def, DUMMY_SP, vis));\n+                self.define(parent, name, MacroNS, (def, vis, DUMMY_SP, Mark::root()));\n             }\n             Def::Local(..) |\n             Def::PrimTy(..) |\n@@ -479,9 +503,11 @@ impl<'b> Resolver<'b> {\n         })\n     }\n \n-    pub fn get_macro(&mut self, def: Def) -> Rc<SyntaxExtension> {\n-        let def_id = match def {\n-            Def::Macro(def_id) => def_id,\n+    pub fn get_macro(&mut self, binding: &'b NameBinding<'b>) -> Rc<SyntaxExtension> {\n+        let def_id = match binding.kind {\n+            NameBindingKind::Def(Def::Macro(def_id)) => def_id,\n+            NameBindingKind::Import { binding, .. } => return self.get_macro(binding),\n+            NameBindingKind::Ambiguity { b1, .. } => return self.get_macro(b1),\n             _ => panic!(\"Expected Def::Macro(..)\"),\n         };\n         if let Some(ext) = self.macro_map.get(&def_id) {\n@@ -518,10 +544,14 @@ impl<'b> Resolver<'b> {\n         module.populated.set(true)\n     }\n \n-    fn legacy_import_macro(&mut self, name: Name, def: Def, span: Span, allow_shadowing: bool) {\n-        self.used_crates.insert(def.def_id().krate);\n+    fn legacy_import_macro(&mut self,\n+                           name: Name,\n+                           binding: &'b NameBinding<'b>,\n+                           span: Span,\n+                           allow_shadowing: bool) {\n+        self.used_crates.insert(binding.def().def_id().krate);\n         self.macro_names.insert(name);\n-        if self.builtin_macros.insert(name, def.def_id()).is_some() && !allow_shadowing {\n+        if self.builtin_macros.insert(name, binding).is_some() && !allow_shadowing {\n             let msg = format!(\"`{}` is already in scope\", name);\n             let note =\n                 \"macro-expanded `#[macro_use]`s may not shadow existing macros (see RFC 1560)\";\n@@ -548,21 +578,21 @@ impl<'b> Resolver<'b> {\n \n         if let Some(span) = legacy_imports.import_all {\n             module.for_each_child(|name, ns, binding| if ns == MacroNS {\n-                self.legacy_import_macro(name, binding.def(), span, allow_shadowing);\n+                self.legacy_import_macro(name, binding, span, allow_shadowing);\n             });\n         } else {\n             for (name, span) in legacy_imports.imports {\n-                let result = self.resolve_name_in_module(module, name, MacroNS, false, None);\n+                let result = self.resolve_name_in_module(module, name, MacroNS, false, false, None);\n                 if let Success(binding) = result {\n-                    self.legacy_import_macro(name, binding.def(), span, allow_shadowing);\n+                    self.legacy_import_macro(name, binding, span, allow_shadowing);\n                 } else {\n                     span_err!(self.session, span, E0469, \"imported macro not found\");\n                 }\n             }\n         }\n         for (name, span) in legacy_imports.reexports {\n             self.used_crates.insert(module.def_id().unwrap().krate);\n-            let result = self.resolve_name_in_module(module, name, MacroNS, false, None);\n+            let result = self.resolve_name_in_module(module, name, MacroNS, false, false, None);\n             if let Success(binding) = result {\n                 self.macro_exports.push(Export { name: name, def: binding.def() });\n             } else {\n@@ -638,7 +668,9 @@ pub struct BuildReducedGraphVisitor<'a, 'b: 'a> {\n \n impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n     fn visit_invoc(&mut self, id: ast::NodeId) -> &'b InvocationData<'b> {\n-        let invocation = self.resolver.invocations[&Mark::from_placeholder_id(id)];\n+        let mark = Mark::from_placeholder_id(id);\n+        self.resolver.current_module.unresolved_invocations.borrow_mut().insert(mark);\n+        let invocation = self.resolver.invocations[&mark];\n         invocation.module.set(self.resolver.current_module);\n         invocation.legacy_scope.set(self.legacy_scope);\n         invocation\n@@ -691,7 +723,7 @@ impl<'a, 'b> Visitor for BuildReducedGraphVisitor<'a, 'b> {\n     }\n \n     fn visit_foreign_item(&mut self, foreign_item: &ForeignItem) {\n-        self.resolver.build_reduced_graph_for_foreign_item(foreign_item);\n+        self.resolver.build_reduced_graph_for_foreign_item(foreign_item, self.expansion);\n         visit::walk_foreign_item(self, foreign_item);\n     }\n \n@@ -728,7 +760,7 @@ impl<'a, 'b> Visitor for BuildReducedGraphVisitor<'a, 'b> {\n         self.resolver.trait_item_map.insert((item.ident.name, def_id), is_static_method);\n \n         let vis = ty::Visibility::Public;\n-        self.resolver.define(parent, item.ident.name, ns, (def, item.span, vis));\n+        self.resolver.define(parent, item.ident.name, ns, (def, vis, item.span, self.expansion));\n \n         self.resolver.current_module = parent.parent.unwrap(); // nearest normal ancestor\n         visit::walk_trait_item(self, item);"}, {"sha": "492c5e695bbbb5a39740dfa64f69fe4ccb351ebf", "filename": "src/librustc_resolve/check_unused.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c57b8261496d548e0a3cd8468061ddc5a4dcafe2/src%2Flibrustc_resolve%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c57b8261496d548e0a3cd8468061ddc5a4dcafe2/src%2Flibrustc_resolve%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fcheck_unused.rs?ref=c57b8261496d548e0a3cd8468061ddc5a4dcafe2", "patch": "@@ -22,7 +22,6 @@\n use std::ops::{Deref, DerefMut};\n \n use Resolver;\n-use Namespace::{TypeNS, ValueNS};\n \n use rustc::lint;\n use rustc::util::nodemap::NodeMap;\n@@ -56,8 +55,9 @@ impl<'a, 'b> UnusedImportCheckVisitor<'a, 'b> {\n     // We have information about whether `use` (import) directives are actually\n     // used now. If an import is not used at all, we signal a lint error.\n     fn check_import(&mut self, item_id: ast::NodeId, id: ast::NodeId, span: Span) {\n-        if !self.used_imports.contains(&(id, TypeNS)) &&\n-           !self.used_imports.contains(&(id, ValueNS)) {\n+        let mut used = false;\n+        self.per_ns(|this, ns| used |= this.used_imports.contains(&(id, ns)));\n+        if !used {\n             if self.maybe_unused_trait_imports.contains(&id) {\n                 // Check later.\n                 return;"}, {"sha": "a3a60e4f6d7548abe5d2f6787ba0bab13437a381", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 131, "deletions": 100, "changes": 231, "blob_url": "https://github.com/rust-lang/rust/blob/c57b8261496d548e0a3cd8468061ddc5a4dcafe2/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c57b8261496d548e0a3cd8468061ddc5a4dcafe2/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=c57b8261496d548e0a3cd8468061ddc5a4dcafe2", "patch": "@@ -76,7 +76,7 @@ use std::fmt;\n use std::mem::replace;\n use std::rc::Rc;\n \n-use resolve_imports::{ImportDirective, ImportDirectiveSubclass, NameResolution};\n+use resolve_imports::{ImportDirective, ImportDirectiveSubclass, NameResolution, ImportResolver};\n use macros::{InvocationData, LegacyBinding, LegacyScope};\n \n // NB: This module needs to be declared first so diagnostics are\n@@ -536,6 +536,34 @@ pub enum Namespace {\n     MacroNS,\n }\n \n+#[derive(Clone, Default, Debug)]\n+pub struct PerNS<T> {\n+    value_ns: T,\n+    type_ns: T,\n+    macro_ns: Option<T>,\n+}\n+\n+impl<T> ::std::ops::Index<Namespace> for PerNS<T> {\n+    type Output = T;\n+    fn index(&self, ns: Namespace) -> &T {\n+        match ns {\n+            ValueNS => &self.value_ns,\n+            TypeNS => &self.type_ns,\n+            MacroNS => self.macro_ns.as_ref().unwrap(),\n+        }\n+    }\n+}\n+\n+impl<T> ::std::ops::IndexMut<Namespace> for PerNS<T> {\n+    fn index_mut(&mut self, ns: Namespace) -> &mut T {\n+        match ns {\n+            ValueNS => &mut self.value_ns,\n+            TypeNS => &mut self.type_ns,\n+            MacroNS => self.macro_ns.as_mut().unwrap(),\n+        }\n+    }\n+}\n+\n impl<'a> Visitor for Resolver<'a> {\n     fn visit_item(&mut self, item: &Item) {\n         self.resolve_item(item);\n@@ -612,7 +640,7 @@ impl<'a> Visitor for Resolver<'a> {\n         };\n \n         // Create a value rib for the function.\n-        self.value_ribs.push(Rib::new(rib_kind));\n+        self.ribs[ValueNS].push(Rib::new(rib_kind));\n \n         // Create a label rib for the function.\n         self.label_ribs.push(Rib::new(rib_kind));\n@@ -642,28 +670,20 @@ impl<'a> Visitor for Resolver<'a> {\n         debug!(\"(resolving function) leaving function\");\n \n         self.label_ribs.pop();\n-        self.value_ribs.pop();\n+        self.ribs[ValueNS].pop();\n     }\n }\n \n pub type ErrorMessage = Option<(Span, String)>;\n \n-#[derive(Clone, PartialEq, Eq)]\n+#[derive(Clone, PartialEq, Eq, Debug)]\n pub enum ResolveResult<T> {\n     Failed(ErrorMessage), // Failed to resolve the name, optional helpful error message.\n     Indeterminate, // Couldn't determine due to unresolved globs.\n     Success(T), // Successfully resolved the import.\n }\n \n impl<T> ResolveResult<T> {\n-    fn and_then<U, F: FnOnce(T) -> ResolveResult<U>>(self, f: F) -> ResolveResult<U> {\n-        match self {\n-            Failed(msg) => Failed(msg),\n-            Indeterminate => Indeterminate,\n-            Success(t) => f(t),\n-        }\n-    }\n-\n     fn success(self) -> Option<T> {\n         match self {\n             Success(t) => Some(t),\n@@ -798,6 +818,10 @@ pub struct ModuleS<'a> {\n     normal_ancestor_id: Option<NodeId>,\n \n     resolutions: RefCell<FxHashMap<(Name, Namespace), &'a RefCell<NameResolution<'a>>>>,\n+    legacy_macro_resolutions: RefCell<Vec<(Mark, Name, Span)>>,\n+\n+    // Macro invocations that can expand into items in this module.\n+    unresolved_invocations: RefCell<FxHashSet<Mark>>,\n \n     no_implicit_prelude: bool,\n \n@@ -822,6 +846,8 @@ impl<'a> ModuleS<'a> {\n             kind: kind,\n             normal_ancestor_id: None,\n             resolutions: RefCell::new(FxHashMap()),\n+            legacy_macro_resolutions: RefCell::new(Vec::new()),\n+            unresolved_invocations: RefCell::new(FxHashSet()),\n             no_implicit_prelude: false,\n             glob_importers: RefCell::new(Vec::new()),\n             globs: RefCell::new((Vec::new())),\n@@ -877,6 +903,7 @@ impl<'a> fmt::Debug for ModuleS<'a> {\n #[derive(Clone, Debug)]\n pub struct NameBinding<'a> {\n     kind: NameBindingKind<'a>,\n+    expansion: Mark,\n     span: Span,\n     vis: ty::Visibility,\n }\n@@ -911,6 +938,7 @@ struct PrivacyError<'a>(Span, Name, &'a NameBinding<'a>);\n struct AmbiguityError<'a> {\n     span: Span,\n     name: Name,\n+    lexical: bool,\n     b1: &'a NameBinding<'a>,\n     b2: &'a NameBinding<'a>,\n }\n@@ -969,7 +997,7 @@ impl<'a> NameBinding<'a> {\n     fn is_glob_import(&self) -> bool {\n         match self.kind {\n             NameBindingKind::Import { directive, .. } => directive.is_glob(),\n-            NameBindingKind::Ambiguity { .. } => true,\n+            NameBindingKind::Ambiguity { b1, .. } => b1.is_glob_import(),\n             _ => false,\n         }\n     }\n@@ -1044,12 +1072,9 @@ pub struct Resolver<'a> {\n     // The module that represents the current item scope.\n     current_module: Module<'a>,\n \n-    // The current set of local scopes, for values.\n+    // The current set of local scopes for types and values.\n     // FIXME #4948: Reuse ribs to avoid allocation.\n-    value_ribs: Vec<Rib<'a>>,\n-\n-    // The current set of local scopes, for types.\n-    type_ribs: Vec<Rib<'a>>,\n+    ribs: PerNS<Vec<Rib<'a>>>,\n \n     // The current set of local scopes, for labels.\n     label_ribs: Vec<Rib<'a>>,\n@@ -1107,11 +1132,12 @@ pub struct Resolver<'a> {\n     arenas: &'a ResolverArenas<'a>,\n     dummy_binding: &'a NameBinding<'a>,\n     new_import_semantics: bool, // true if `#![feature(item_like_imports)]`\n+    use_extern_macros: bool, // true if `#![feature(use_extern_macros)]`\n \n     pub exported_macros: Vec<ast::MacroDef>,\n     crate_loader: &'a mut CrateLoader,\n     macro_names: FxHashSet<Name>,\n-    builtin_macros: FxHashMap<Name, DefId>,\n+    builtin_macros: FxHashMap<Name, &'a NameBinding<'a>>,\n     lexical_macro_resolutions: Vec<(Name, LegacyScope<'a>)>,\n     macro_map: FxHashMap<DefId, Rc<SyntaxExtension>>,\n     macro_exports: Vec<Export>,\n@@ -1268,8 +1294,11 @@ impl<'a> Resolver<'a> {\n             indeterminate_imports: Vec::new(),\n \n             current_module: graph_root,\n-            value_ribs: vec![Rib::new(ModuleRibKind(graph_root))],\n-            type_ribs: vec![Rib::new(ModuleRibKind(graph_root))],\n+            ribs: PerNS {\n+                value_ns: vec![Rib::new(ModuleRibKind(graph_root))],\n+                type_ns: vec![Rib::new(ModuleRibKind(graph_root))],\n+                macro_ns: None,\n+            },\n             label_ribs: Vec::new(),\n \n             current_trait_ref: None,\n@@ -1300,10 +1329,12 @@ impl<'a> Resolver<'a> {\n             arenas: arenas,\n             dummy_binding: arenas.alloc_name_binding(NameBinding {\n                 kind: NameBindingKind::Def(Def::Err),\n+                expansion: Mark::root(),\n                 span: DUMMY_SP,\n                 vis: ty::Visibility::Public,\n             }),\n             new_import_semantics: session.features.borrow().item_like_imports,\n+            use_extern_macros: session.features.borrow().use_extern_macros,\n \n             exported_macros: Vec::new(),\n             crate_loader: crate_loader,\n@@ -1329,8 +1360,20 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n+    fn per_ns<T, F: FnMut(&mut Self, Namespace) -> T>(&mut self, mut f: F) -> PerNS<T> {\n+        PerNS {\n+            type_ns: f(self, TypeNS),\n+            value_ns: f(self, ValueNS),\n+            macro_ns: match self.use_extern_macros {\n+                true => Some(f(self, MacroNS)),\n+                false => None,\n+            },\n+        }\n+    }\n+\n     /// Entry point to crate resolution.\n     pub fn resolve_crate(&mut self, krate: &Crate) {\n+        ImportResolver { resolver: self }.finalize_imports();\n         self.current_module = self.graph_root;\n         visit::walk_crate(self, krate);\n \n@@ -1347,14 +1390,6 @@ impl<'a> Resolver<'a> {\n         })\n     }\n \n-    fn get_ribs<'b>(&'b mut self, ns: Namespace) -> &'b mut Vec<Rib<'a>> {\n-        match ns {\n-            ValueNS => &mut self.value_ribs,\n-            TypeNS => &mut self.type_ribs,\n-            MacroNS => panic!(\"The macro namespace has no ribs\"),\n-        }\n-    }\n-\n     fn record_use(&mut self, name: Name, ns: Namespace, binding: &'a NameBinding<'a>, span: Span)\n                   -> bool /* true if an error was reported */ {\n         // track extern crates for unused_extern_crate lint\n@@ -1371,8 +1406,9 @@ impl<'a> Resolver<'a> {\n             }\n             NameBindingKind::Import { .. } => false,\n             NameBindingKind::Ambiguity { b1, b2 } => {\n-                let ambiguity_error = AmbiguityError { span: span, name: name, b1: b1, b2: b2 };\n-                self.ambiguity_errors.push(ambiguity_error);\n+                self.ambiguity_errors.push(AmbiguityError {\n+                    span: span, name: name, lexical: false, b1: b1, b2: b2,\n+                });\n                 true\n             }\n             _ => false\n@@ -1406,7 +1442,7 @@ impl<'a> Resolver<'a> {\n                                      -> ResolveResult<Module<'a>> {\n         fn search_parent_externals<'a>(this: &mut Resolver<'a>, needle: Name, module: Module<'a>)\n                                        -> Option<Module<'a>> {\n-            match this.resolve_name_in_module(module, needle, TypeNS, false, None) {\n+            match this.resolve_name_in_module(module, needle, TypeNS, false, false, None) {\n                 Success(binding) if binding.is_extern_crate() => Some(module),\n                 _ => if let (&ModuleKind::Def(..), Some(parent)) = (&module.kind, module.parent) {\n                     search_parent_externals(this, needle, parent)\n@@ -1424,7 +1460,7 @@ impl<'a> Resolver<'a> {\n         // modules as we go.\n         while index < module_path_len {\n             let name = module_path[index].name;\n-            match self.resolve_name_in_module(search_module, name, TypeNS, false, span) {\n+            match self.resolve_name_in_module(search_module, name, TypeNS, false, false, span) {\n                 Failed(_) => {\n                     let segment_name = name.as_str();\n                     let module_name = module_to_string(search_module);\n@@ -1570,18 +1606,18 @@ impl<'a> Resolver<'a> {\n         }\n \n         // Walk backwards up the ribs in scope.\n-        for i in (0 .. self.get_ribs(ns).len()).rev() {\n-            if let Some(def) = self.get_ribs(ns)[i].bindings.get(&ident).cloned() {\n+        for i in (0 .. self.ribs[ns].len()).rev() {\n+            if let Some(def) = self.ribs[ns][i].bindings.get(&ident).cloned() {\n                 // The ident resolves to a type parameter or local variable.\n                 return Some(LexicalScopeBinding::LocalDef(LocalDef {\n                     ribs: Some((ns, i)),\n                     def: def,\n                 }));\n             }\n \n-            if let ModuleRibKind(module) = self.get_ribs(ns)[i].kind {\n+            if let ModuleRibKind(module) = self.ribs[ns][i].kind {\n                 let name = ident.name;\n-                let item = self.resolve_name_in_module(module, name, ns, true, record_used);\n+                let item = self.resolve_name_in_module(module, name, ns, true, false, record_used);\n                 if let Success(binding) = item {\n                     // The ident resolves to an item.\n                     return Some(LexicalScopeBinding::Item(binding));\n@@ -1590,14 +1626,14 @@ impl<'a> Resolver<'a> {\n                 if let ModuleKind::Block(..) = module.kind { // We can see through blocks\n                 } else if !module.no_implicit_prelude {\n                     return self.prelude.and_then(|prelude| {\n-                        self.resolve_name_in_module(prelude, name, ns, false, None).success()\n+                        self.resolve_name_in_module(prelude, name, ns, false, false, None).success()\n                     }).map(LexicalScopeBinding::Item)\n                 } else {\n                     return None;\n                 }\n             }\n \n-            if let MacroDefinition(mac) = self.get_ribs(ns)[i].kind {\n+            if let MacroDefinition(mac) = self.ribs[ns][i].kind {\n                 // If an invocation of this macro created `ident`, give up on `ident`\n                 // and switch to `ident`'s source from the macro definition.\n                 let (source_ctxt, source_macro) = ident.ctxt.source();\n@@ -1682,14 +1718,15 @@ impl<'a> Resolver<'a> {\n         if let Some(module) = module {\n             // Move down in the graph.\n             let orig_module = replace(&mut self.current_module, module);\n-            self.value_ribs.push(Rib::new(ModuleRibKind(module)));\n-            self.type_ribs.push(Rib::new(ModuleRibKind(module)));\n+            self.ribs[ValueNS].push(Rib::new(ModuleRibKind(module)));\n+            self.ribs[TypeNS].push(Rib::new(ModuleRibKind(module)));\n \n+            self.finalize_current_module_macro_resolutions();\n             f(self);\n \n             self.current_module = orig_module;\n-            self.value_ribs.pop();\n-            self.type_ribs.pop();\n+            self.ribs[ValueNS].pop();\n+            self.ribs[TypeNS].pop();\n         } else {\n             f(self);\n         }\n@@ -1864,7 +1901,7 @@ impl<'a> Resolver<'a> {\n                     function_type_rib.bindings.insert(Ident::with_empty_ctxt(name), def);\n                     self.record_def(type_parameter.id, PathResolution::new(def));\n                 }\n-                self.type_ribs.push(function_type_rib);\n+                self.ribs[TypeNS].push(function_type_rib);\n             }\n \n             NoTypeParameters => {\n@@ -1875,7 +1912,7 @@ impl<'a> Resolver<'a> {\n         f(self);\n \n         if let HasTypeParameters(..) = type_parameters {\n-            self.type_ribs.pop();\n+            self.ribs[TypeNS].pop();\n         }\n     }\n \n@@ -1890,11 +1927,11 @@ impl<'a> Resolver<'a> {\n     fn with_constant_rib<F>(&mut self, f: F)\n         where F: FnOnce(&mut Resolver)\n     {\n-        self.value_ribs.push(Rib::new(ConstantItemRibKind));\n-        self.type_ribs.push(Rib::new(ConstantItemRibKind));\n+        self.ribs[ValueNS].push(Rib::new(ConstantItemRibKind));\n+        self.ribs[TypeNS].push(Rib::new(ConstantItemRibKind));\n         f(self);\n-        self.type_ribs.pop();\n-        self.value_ribs.pop();\n+        self.ribs[TypeNS].pop();\n+        self.ribs[ValueNS].pop();\n     }\n \n     fn resolve_trait_reference(&mut self,\n@@ -2004,9 +2041,9 @@ impl<'a> Resolver<'a> {\n \n         // plain insert (no renaming, types are not currently hygienic....)\n         self_type_rib.bindings.insert(keywords::SelfType.ident(), self_def);\n-        self.type_ribs.push(self_type_rib);\n+        self.ribs[TypeNS].push(self_type_rib);\n         f(self);\n-        self.type_ribs.pop();\n+        self.ribs[TypeNS].pop();\n     }\n \n     fn resolve_implementation(&mut self,\n@@ -2160,7 +2197,7 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn resolve_arm(&mut self, arm: &Arm) {\n-        self.value_ribs.push(Rib::new(NormalRibKind));\n+        self.ribs[ValueNS].push(Rib::new(NormalRibKind));\n \n         let mut bindings_list = FxHashMap();\n         for pattern in &arm.pats {\n@@ -2174,7 +2211,7 @@ impl<'a> Resolver<'a> {\n         walk_list!(self, visit_expr, &arm.guard);\n         self.visit_expr(&arm.body);\n \n-        self.value_ribs.pop();\n+        self.ribs[ValueNS].pop();\n     }\n \n     fn resolve_block(&mut self, block: &Block) {\n@@ -2186,19 +2223,20 @@ impl<'a> Resolver<'a> {\n         let mut num_macro_definition_ribs = 0;\n         if let Some(anonymous_module) = anonymous_module {\n             debug!(\"(resolving block) found anonymous module, moving down\");\n-            self.value_ribs.push(Rib::new(ModuleRibKind(anonymous_module)));\n-            self.type_ribs.push(Rib::new(ModuleRibKind(anonymous_module)));\n+            self.ribs[ValueNS].push(Rib::new(ModuleRibKind(anonymous_module)));\n+            self.ribs[TypeNS].push(Rib::new(ModuleRibKind(anonymous_module)));\n             self.current_module = anonymous_module;\n+            self.finalize_current_module_macro_resolutions();\n         } else {\n-            self.value_ribs.push(Rib::new(NormalRibKind));\n+            self.ribs[ValueNS].push(Rib::new(NormalRibKind));\n         }\n \n         // Descend into the block.\n         for stmt in &block.stmts {\n             if let Some(marks) = self.macros_at_scope.remove(&stmt.id) {\n                 num_macro_definition_ribs += marks.len() as u32;\n                 for mark in marks {\n-                    self.value_ribs.push(Rib::new(MacroDefinition(mark)));\n+                    self.ribs[ValueNS].push(Rib::new(MacroDefinition(mark)));\n                     self.label_ribs.push(Rib::new(MacroDefinition(mark)));\n                 }\n             }\n@@ -2209,12 +2247,12 @@ impl<'a> Resolver<'a> {\n         // Move back up.\n         self.current_module = orig_module;\n         for _ in 0 .. num_macro_definition_ribs {\n-            self.value_ribs.pop();\n+            self.ribs[ValueNS].pop();\n             self.label_ribs.pop();\n         }\n-        self.value_ribs.pop();\n+        self.ribs[ValueNS].pop();\n         if let Some(_) = anonymous_module {\n-            self.type_ribs.pop();\n+            self.ribs[TypeNS].pop();\n         }\n         debug!(\"(resolving block) leaving block\");\n     }\n@@ -2333,7 +2371,7 @@ impl<'a> Resolver<'a> {\n             Some(..) if pat_src == PatternSource::Match => {\n                 // `Variant1(a) | Variant2(a)`, ok\n                 // Reuse definition from the first `a`.\n-                def = self.value_ribs.last_mut().unwrap().bindings[&ident.node];\n+                def = self.ribs[ValueNS].last_mut().unwrap().bindings[&ident.node];\n             }\n             Some(..) => {\n                 span_bug!(ident.span, \"two bindings with the same name from \\\n@@ -2343,7 +2381,7 @@ impl<'a> Resolver<'a> {\n                 // A completely fresh binding, add to the lists if it's valid.\n                 if ident.node.name != keywords::Invalid.name() {\n                     bindings.insert(ident.node, outer_pat_id);\n-                    self.value_ribs.last_mut().unwrap().bindings.insert(ident.node, def);\n+                    self.ribs[ValueNS].last_mut().unwrap().bindings.insert(ident.node, def);\n                 }\n             }\n         }\n@@ -2627,9 +2665,8 @@ impl<'a> Resolver<'a> {\n     // Resolve a local definition, potentially adjusting for closures.\n     fn adjust_local_def(&mut self, local_def: LocalDef, span: Span) -> Option<Def> {\n         let ribs = match local_def.ribs {\n-            Some((TypeNS, i)) => &self.type_ribs[i + 1..],\n-            Some((ValueNS, i)) => &self.value_ribs[i + 1..],\n-            _ => &[] as &[_],\n+            Some((ns, i)) => &self.ribs[ns][i + 1..],\n+            None => &[] as &[_],\n         };\n         let mut def = local_def.def;\n         match def {\n@@ -2723,23 +2760,19 @@ impl<'a> Resolver<'a> {\n         let module_path =\n             segments.split_last().unwrap().1.iter().map(|ps| ps.identifier).collect::<Vec<_>>();\n \n-        let containing_module;\n-        match self.resolve_module_path(&module_path, UseLexicalScope, Some(span)) {\n+        let module = match self.resolve_module_path(&module_path, UseLexicalScope, Some(span)) {\n             Failed(err) => {\n                 if let Some((span, msg)) = err {\n                     resolve_error(self, span, ResolutionError::FailedToResolve(&msg));\n                 }\n                 return Err(true);\n             }\n             Indeterminate => return Err(false),\n-            Success(resulting_module) => {\n-                containing_module = resulting_module;\n-            }\n-        }\n+            Success(module) => module,\n+        };\n \n         let name = segments.last().unwrap().identifier.name;\n-        let result =\n-            self.resolve_name_in_module(containing_module, name, namespace, false, Some(span));\n+        let result = self.resolve_name_in_module(module, name, namespace, false, false, Some(span));\n         result.success().ok_or(false)\n     }\n \n@@ -2751,10 +2784,9 @@ impl<'a> Resolver<'a> {\n         where T: Named,\n     {\n         let module_path = segments.split_last().unwrap().1.iter().map(T::ident).collect::<Vec<_>>();\n-        let root_module = self.graph_root;\n+        let root = self.graph_root;\n \n-        let containing_module;\n-        match self.resolve_module_path_from_root(root_module, &module_path, 0, Some(span)) {\n+        let module = match self.resolve_module_path_from_root(root, &module_path, 0, Some(span)) {\n             Failed(err) => {\n                 if let Some((span, msg)) = err {\n                     resolve_error(self, span, ResolutionError::FailedToResolve(&msg));\n@@ -2764,14 +2796,11 @@ impl<'a> Resolver<'a> {\n \n             Indeterminate => return Err(false),\n \n-            Success(resulting_module) => {\n-                containing_module = resulting_module;\n-            }\n-        }\n+            Success(module) => module,\n+        };\n \n         let name = segments.last().unwrap().ident().name;\n-        let result =\n-            self.resolve_name_in_module(containing_module, name, namespace, false, Some(span));\n+        let result = self.resolve_name_in_module(module, name, namespace, false, false, Some(span));\n         result.success().ok_or(false)\n     }\n \n@@ -2791,22 +2820,20 @@ impl<'a> Resolver<'a> {\n         where F: FnOnce(&mut Resolver<'a>) -> T,\n     {\n         self.with_empty_ribs(|this| {\n-            this.value_ribs.push(Rib::new(ModuleRibKind(module)));\n-            this.type_ribs.push(Rib::new(ModuleRibKind(module)));\n+            this.ribs[ValueNS].push(Rib::new(ModuleRibKind(module)));\n+            this.ribs[TypeNS].push(Rib::new(ModuleRibKind(module)));\n             f(this)\n         })\n     }\n \n     fn with_empty_ribs<T, F>(&mut self, f: F) -> T\n         where F: FnOnce(&mut Resolver<'a>) -> T,\n     {\n-        let value_ribs = replace(&mut self.value_ribs, Vec::new());\n-        let type_ribs = replace(&mut self.type_ribs, Vec::new());\n+        let ribs = replace(&mut self.ribs, PerNS::<Vec<Rib>>::default());\n         let label_ribs = replace(&mut self.label_ribs, Vec::new());\n \n         let result = f(self);\n-        self.value_ribs = value_ribs;\n-        self.type_ribs = type_ribs;\n+        self.ribs = ribs;\n         self.label_ribs = label_ribs;\n         result\n     }\n@@ -2858,7 +2885,7 @@ impl<'a> Resolver<'a> {\n             return SuggestionType::Macro(format!(\"{}!\", macro_name));\n         }\n \n-        let names = self.value_ribs\n+        let names = self.ribs[ValueNS]\n                     .iter()\n                     .rev()\n                     .flat_map(|rib| rib.bindings.keys().map(|ident| &ident.name));\n@@ -2961,7 +2988,7 @@ impl<'a> Resolver<'a> {\n                         } else {\n                             let mut method_scope = false;\n                             let mut is_static = false;\n-                            self.value_ribs.iter().rev().all(|rib| {\n+                            self.ribs[ValueNS].iter().rev().all(|rib| {\n                                 method_scope = match rib.kind {\n                                     MethodRibKind(is_static_) => {\n                                         is_static = is_static_;\n@@ -3072,10 +3099,10 @@ impl<'a> Resolver<'a> {\n             ExprKind::IfLet(ref pattern, ref subexpression, ref if_block, ref optional_else) => {\n                 self.visit_expr(subexpression);\n \n-                self.value_ribs.push(Rib::new(NormalRibKind));\n+                self.ribs[ValueNS].push(Rib::new(NormalRibKind));\n                 self.resolve_pattern(pattern, PatternSource::IfLet, &mut FxHashMap());\n                 self.visit_block(if_block);\n-                self.value_ribs.pop();\n+                self.ribs[ValueNS].pop();\n \n                 optional_else.as_ref().map(|expr| self.visit_expr(expr));\n             }\n@@ -3089,22 +3116,22 @@ impl<'a> Resolver<'a> {\n \n             ExprKind::WhileLet(ref pattern, ref subexpression, ref block, label) => {\n                 self.visit_expr(subexpression);\n-                self.value_ribs.push(Rib::new(NormalRibKind));\n+                self.ribs[ValueNS].push(Rib::new(NormalRibKind));\n                 self.resolve_pattern(pattern, PatternSource::WhileLet, &mut FxHashMap());\n \n                 self.resolve_labeled_block(label, expr.id, block);\n \n-                self.value_ribs.pop();\n+                self.ribs[ValueNS].pop();\n             }\n \n             ExprKind::ForLoop(ref pattern, ref subexpression, ref block, label) => {\n                 self.visit_expr(subexpression);\n-                self.value_ribs.push(Rib::new(NormalRibKind));\n+                self.ribs[ValueNS].push(Rib::new(NormalRibKind));\n                 self.resolve_pattern(pattern, PatternSource::For, &mut FxHashMap());\n \n                 self.resolve_labeled_block(label, expr.id, block);\n \n-                self.value_ribs.pop();\n+                self.ribs[ValueNS].pop();\n             }\n \n             ExprKind::Field(ref subexpression, _) => {\n@@ -3354,14 +3381,18 @@ impl<'a> Resolver<'a> {\n         self.report_shadowing_errors();\n         let mut reported_spans = FxHashSet();\n \n-        for &AmbiguityError { span, name, b1, b2 } in &self.ambiguity_errors {\n+        for &AmbiguityError { span, name, b1, b2, lexical } in &self.ambiguity_errors {\n             if !reported_spans.insert(span) { continue }\n             let msg1 = format!(\"`{}` could resolve to the name imported here\", name);\n             let msg2 = format!(\"`{}` could also resolve to the name imported here\", name);\n             self.session.struct_span_err(span, &format!(\"`{}` is ambiguous\", name))\n                 .span_note(b1.span, &msg1)\n                 .span_note(b2.span, &msg2)\n-                .note(&format!(\"Consider adding an explicit import of `{}` to disambiguate\", name))\n+                .note(&if lexical || !b1.is_glob_import() {\n+                    \"macro-expanded macro imports do not shadow\".to_owned()\n+                } else {\n+                    format!(\"consider adding an explicit import of `{}` to disambiguate\", name)\n+                })\n                 .emit();\n         }\n \n@@ -3384,12 +3415,12 @@ impl<'a> Resolver<'a> {\n \n     fn report_shadowing_errors(&mut self) {\n         for (name, scope) in replace(&mut self.lexical_macro_resolutions, Vec::new()) {\n-            self.resolve_macro_name(scope, name);\n+            self.resolve_legacy_scope(scope, name, true);\n         }\n \n         let mut reported_errors = FxHashSet();\n         for binding in replace(&mut self.disallowed_shadowing, Vec::new()) {\n-            if self.resolve_macro_name(binding.parent, binding.name).is_some() &&\n+            if self.resolve_legacy_scope(binding.parent, binding.name, false).is_some() &&\n                reported_errors.insert((binding.name, binding.span)) {\n                 let msg = format!(\"`{}` is already in scope\", binding.name);\n                 self.session.struct_span_err(binding.span, &msg)"}, {"sha": "524d491a464e2525e178cb531e830edd5befa535", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 142, "deletions": 31, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/c57b8261496d548e0a3cd8468061ddc5a4dcafe2/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c57b8261496d548e0a3cd8468061ddc5a4dcafe2/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=c57b8261496d548e0a3cd8468061ddc5a4dcafe2", "patch": "@@ -8,14 +8,18 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use {Module, ModuleKind, Resolver};\n+use {Module, ModuleKind, NameBinding, NameBindingKind, Resolver, AmbiguityError};\n+use Namespace::{self, MacroNS};\n+use ResolveResult::{Success, Indeterminate, Failed};\n use build_reduced_graph::BuildReducedGraphVisitor;\n+use resolve_imports::ImportResolver;\n use rustc::hir::def_id::{DefId, BUILTIN_MACROS_CRATE, CRATE_DEF_INDEX, DefIndex};\n use rustc::hir::def::{Def, Export};\n use rustc::hir::map::{self, DefCollector};\n+use rustc::ty;\n use std::cell::Cell;\n use std::rc::Rc;\n-use syntax::ast;\n+use syntax::ast::{self, Name};\n use syntax::errors::DiagnosticBuilder;\n use syntax::ext::base::{self, Determinacy, MultiModifier, MultiDecorator};\n use syntax::ext::base::{NormalTT, SyntaxExtension};\n@@ -27,7 +31,7 @@ use syntax::parse::token::intern;\n use syntax::ptr::P;\n use syntax::util::lev_distance::find_best_match_for_name;\n use syntax::visit::Visitor;\n-use syntax_pos::Span;\n+use syntax_pos::{Span, DUMMY_SP};\n \n #[derive(Clone)]\n pub struct InvocationData<'a> {\n@@ -83,6 +87,11 @@ pub struct LegacyBinding<'a> {\n     pub span: Span,\n }\n \n+pub enum MacroBinding<'a> {\n+    Legacy(&'a LegacyBinding<'a>),\n+    Modern(&'a NameBinding<'a>),\n+}\n+\n impl<'a> base::Resolver for Resolver<'a> {\n     fn next_node_id(&mut self) -> ast::NodeId {\n         self.session.next_node_id()\n@@ -131,12 +140,14 @@ impl<'a> base::Resolver for Resolver<'a> {\n         self.collect_def_ids(invocation, expansion);\n \n         self.current_module = invocation.module.get();\n+        self.current_module.unresolved_invocations.borrow_mut().remove(&mark);\n         let mut visitor = BuildReducedGraphVisitor {\n             resolver: self,\n             legacy_scope: LegacyScope::Invocation(invocation),\n             expansion: mark,\n         };\n         expansion.visit_with(&mut visitor);\n+        self.current_module.unresolved_invocations.borrow_mut().remove(&mark);\n         invocation.expansion.set(visitor.legacy_scope);\n     }\n \n@@ -177,18 +188,28 @@ impl<'a> base::Resolver for Resolver<'a> {\n             index: DefIndex::new(self.macro_map.len()),\n         };\n         self.macro_map.insert(def_id, ext);\n-        self.builtin_macros.insert(ident.name, def_id);\n+        let binding = self.arenas.alloc_name_binding(NameBinding {\n+            kind: NameBindingKind::Def(Def::Macro(def_id)),\n+            span: DUMMY_SP,\n+            vis: ty::Visibility::PrivateExternal,\n+            expansion: Mark::root(),\n+        });\n+        self.builtin_macros.insert(ident.name, binding);\n     }\n \n     fn add_expansions_at_stmt(&mut self, id: ast::NodeId, macros: Vec<Mark>) {\n         self.macros_at_scope.insert(id, macros);\n     }\n \n+    fn resolve_imports(&mut self) {\n+        ImportResolver { resolver: self }.resolve_imports()\n+    }\n+\n     fn find_attr_invoc(&mut self, attrs: &mut Vec<ast::Attribute>) -> Option<ast::Attribute> {\n         for i in 0..attrs.len() {\n             let name = intern(&attrs[i].name());\n-            match self.builtin_macros.get(&name) {\n-                Some(&def_id) => match *self.get_macro(Def::Macro(def_id)) {\n+            match self.builtin_macros.get(&name).cloned() {\n+                Some(binding) => match *self.get_macro(binding) {\n                     MultiModifier(..) | MultiDecorator(..) | SyntaxExtension::AttrProcMacro(..) => {\n                         return Some(attrs.remove(i))\n                     }\n@@ -212,25 +233,81 @@ impl<'a> base::Resolver for Resolver<'a> {\n         if let LegacyScope::Expansion(parent) = invocation.legacy_scope.get() {\n             invocation.legacy_scope.set(LegacyScope::simplify_expansion(parent));\n         }\n-        self.resolve_macro_name(invocation.legacy_scope.get(), name).ok_or_else(|| {\n-            if force {\n-                let msg = format!(\"macro undefined: '{}!'\", name);\n-                let mut err = self.session.struct_span_err(path.span, &msg);\n-                self.suggest_macro_name(&name.as_str(), &mut err);\n-                err.emit();\n-                Determinacy::Determined\n-            } else {\n-                Determinacy::Undetermined\n-            }\n-        })\n+\n+        self.current_module = invocation.module.get();\n+        let result = match self.resolve_legacy_scope(invocation.legacy_scope.get(), name, false) {\n+            Some(MacroBinding::Legacy(binding)) => Ok(binding.ext.clone()),\n+            Some(MacroBinding::Modern(binding)) => Ok(self.get_macro(binding)),\n+            None => match self.resolve_in_item_lexical_scope(name, MacroNS, None) {\n+                Some(binding) => Ok(self.get_macro(binding)),\n+                None => return Err(if force {\n+                    let msg = format!(\"macro undefined: '{}!'\", name);\n+                    let mut err = self.session.struct_span_err(path.span, &msg);\n+                    self.suggest_macro_name(&name.as_str(), &mut err);\n+                    err.emit();\n+                    Determinacy::Determined\n+                } else {\n+                    Determinacy::Undetermined\n+                }),\n+            },\n+        };\n+\n+        if self.use_extern_macros {\n+            self.current_module.legacy_macro_resolutions.borrow_mut()\n+                .push((scope, name, path.span));\n+        }\n+        result\n     }\n }\n \n impl<'a> Resolver<'a> {\n-    pub fn resolve_macro_name(&mut self, mut scope: LegacyScope<'a>, name: ast::Name)\n-                              -> Option<Rc<SyntaxExtension>> {\n+    // Resolve the name in the module's lexical scope, excluding non-items.\n+    fn resolve_in_item_lexical_scope(&mut self,\n+                                     name: Name,\n+                                     ns: Namespace,\n+                                     record_used: Option<Span>)\n+                                     -> Option<&'a NameBinding<'a>> {\n+        let mut module = self.current_module;\n+        let mut potential_expanded_shadower = None;\n+        loop {\n+            // Since expanded macros may not shadow the lexical scope (enforced below),\n+            // we can ignore unresolved invocations (indicated by the penultimate argument).\n+            match self.resolve_name_in_module(module, name, ns, true, true, record_used) {\n+                Success(binding) => {\n+                    let span = match record_used {\n+                        Some(span) => span,\n+                        None => return Some(binding),\n+                    };\n+                    if let Some(shadower) = potential_expanded_shadower {\n+                        self.ambiguity_errors.push(AmbiguityError {\n+                            span: span, name: name, b1: shadower, b2: binding, lexical: true,\n+                        });\n+                        return Some(shadower);\n+                    } else if binding.expansion == Mark::root() {\n+                        return Some(binding);\n+                    } else {\n+                        potential_expanded_shadower = Some(binding);\n+                    }\n+                },\n+                Indeterminate => return None,\n+                Failed(..) => {}\n+            }\n+\n+            match module.kind {\n+                ModuleKind::Block(..) => module = module.parent.unwrap(),\n+                ModuleKind::Def(..) => return potential_expanded_shadower,\n+            }\n+        }\n+    }\n+\n+    pub fn resolve_legacy_scope(&mut self,\n+                                mut scope: LegacyScope<'a>,\n+                                name: Name,\n+                                record_used: bool)\n+                                -> Option<MacroBinding<'a>> {\n         let mut possible_time_travel = None;\n         let mut relative_depth: u32 = 0;\n+        let mut binding = None;\n         loop {\n             scope = match scope {\n                 LegacyScope::Empty => break,\n@@ -249,25 +326,59 @@ impl<'a> Resolver<'a> {\n                     relative_depth = relative_depth.saturating_sub(1);\n                     invocation.legacy_scope.get()\n                 }\n-                LegacyScope::Binding(binding) => {\n-                    if binding.name == name {\n-                        if let Some(scope) = possible_time_travel {\n-                            // Check for disallowed shadowing later\n-                            self.lexical_macro_resolutions.push((name, scope));\n-                        } else if relative_depth > 0 {\n-                            self.disallowed_shadowing.push(binding);\n+                LegacyScope::Binding(potential_binding) => {\n+                    if potential_binding.name == name {\n+                        if (!self.use_extern_macros || record_used) && relative_depth > 0 {\n+                            self.disallowed_shadowing.push(potential_binding);\n                         }\n-                        return Some(binding.ext.clone());\n+                        binding = Some(potential_binding);\n+                        break\n                     }\n-                    binding.parent\n+                    potential_binding.parent\n                 }\n             };\n         }\n \n-        if let Some(scope) = possible_time_travel {\n-            self.lexical_macro_resolutions.push((name, scope));\n+        let binding = match binding {\n+            Some(binding) => MacroBinding::Legacy(binding),\n+            None => match self.builtin_macros.get(&name).cloned() {\n+                Some(binding) => MacroBinding::Modern(binding),\n+                None => return None,\n+            },\n+        };\n+\n+        if !self.use_extern_macros {\n+            if let Some(scope) = possible_time_travel {\n+                // Check for disallowed shadowing later\n+                self.lexical_macro_resolutions.push((name, scope));\n+            }\n+        }\n+\n+        Some(binding)\n+    }\n+\n+    pub fn finalize_current_module_macro_resolutions(&mut self) {\n+        let module = self.current_module;\n+        for &(mark, name, span) in module.legacy_macro_resolutions.borrow().iter() {\n+            let legacy_scope = self.invocations[&mark].legacy_scope.get();\n+            let legacy_resolution = self.resolve_legacy_scope(legacy_scope, name, true);\n+            let resolution = self.resolve_in_item_lexical_scope(name, MacroNS, Some(span));\n+            let (legacy_resolution, resolution) = match (legacy_resolution, resolution) {\n+                (Some(legacy_resolution), Some(resolution)) => (legacy_resolution, resolution),\n+                _ => continue,\n+            };\n+            let (legacy_span, participle) = match legacy_resolution {\n+                MacroBinding::Modern(binding) if binding.def() == resolution.def() => continue,\n+                MacroBinding::Modern(binding) => (binding.span, \"imported\"),\n+                MacroBinding::Legacy(binding) => (binding.span, \"defined\"),\n+            };\n+            let msg1 = format!(\"`{}` could resolve to the macro {} here\", name, participle);\n+            let msg2 = format!(\"`{}` could also resolve to the macro imported here\", name);\n+            self.session.struct_span_err(span, &format!(\"`{}` is ambiguous\", name))\n+                .span_note(legacy_span, &msg1)\n+                .span_note(resolution.span, &msg2)\n+                .emit();\n         }\n-        self.builtin_macros.get(&name).cloned().map(|def_id| self.get_macro(Def::Macro(def_id)))\n     }\n \n     fn suggest_macro_name(&mut self, name: &str, err: &mut DiagnosticBuilder<'a>) {"}, {"sha": "d0ce1acaadf62128434b5b2f2469f981eec80977", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 161, "deletions": 184, "changes": 345, "blob_url": "https://github.com/rust-lang/rust/blob/c57b8261496d548e0a3cd8468061ddc5a4dcafe2/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c57b8261496d548e0a3cd8468061ddc5a4dcafe2/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=c57b8261496d548e0a3cd8468061ddc5a4dcafe2", "patch": "@@ -10,8 +10,8 @@\n \n use self::ImportDirectiveSubclass::*;\n \n-use Module;\n-use Namespace::{self, TypeNS, ValueNS};\n+use {Module, PerNS};\n+use Namespace::{self, TypeNS, MacroNS};\n use {NameBinding, NameBindingKind, PrivacyError, ToNameBinding};\n use ResolveResult;\n use ResolveResult::*;\n@@ -26,26 +26,20 @@ use rustc::hir::def::*;\n \n use syntax::ast::{Ident, NodeId, Name};\n use syntax::ext::base::Determinacy::{self, Determined, Undetermined};\n+use syntax::ext::hygiene::Mark;\n use syntax::util::lev_distance::find_best_match_for_name;\n use syntax_pos::Span;\n \n use std::cell::{Cell, RefCell};\n use std::mem;\n \n-impl<'a> Resolver<'a> {\n-    pub fn resolve_imports(&mut self) {\n-        ImportResolver { resolver: self }.resolve_imports();\n-    }\n-}\n-\n /// Contains data for specific types of import directives.\n #[derive(Clone, Debug)]\n pub enum ImportDirectiveSubclass<'a> {\n     SingleImport {\n         target: Name,\n         source: Name,\n-        value_result: Cell<Result<&'a NameBinding<'a>, Determinacy>>,\n-        type_result: Cell<Result<&'a NameBinding<'a>, Determinacy>>,\n+        result: PerNS<Cell<Result<&'a NameBinding<'a>, Determinacy>>>,\n     },\n     GlobImport {\n         is_prelude: bool,\n@@ -55,17 +49,6 @@ pub enum ImportDirectiveSubclass<'a> {\n     ExternCrate,\n }\n \n-impl<'a> ImportDirectiveSubclass<'a> {\n-    pub fn single(target: Name, source: Name) -> Self {\n-        SingleImport {\n-            target: target,\n-            source: source,\n-            type_result: Cell::new(Err(Undetermined)),\n-            value_result: Cell::new(Err(Undetermined)),\n-        }\n-    }\n-}\n-\n /// One import directive.\n #[derive(Debug,Clone)]\n pub struct ImportDirective<'a> {\n@@ -76,6 +59,7 @@ pub struct ImportDirective<'a> {\n     pub subclass: ImportDirectiveSubclass<'a>,\n     pub span: Span,\n     pub vis: Cell<ty::Visibility>,\n+    pub expansion: Mark,\n }\n \n impl<'a> ImportDirective<'a> {\n@@ -158,6 +142,7 @@ impl<'a> Resolver<'a> {\n                                   name: Name,\n                                   ns: Namespace,\n                                   allow_private_imports: bool,\n+                                  ignore_unresolved_invocations: bool,\n                                   record_used: Option<Span>)\n                                   -> ResolveResult<&'a NameBinding<'a>> {\n         self.populate_module_if_necessary(module);\n@@ -191,66 +176,65 @@ impl<'a> Resolver<'a> {\n             return resolution.binding.map(Success).unwrap_or(Failed(None));\n         }\n \n-        // If the resolution doesn't depend on glob definability, check privacy and return.\n-        if let Some(result) = self.try_result(&resolution, ns) {\n-            return result.and_then(|binding| {\n-                if self.is_accessible(binding.vis) && !is_disallowed_private_import(binding) ||\n-                   binding.is_extern_crate() { // c.f. issue #37020\n-                    Success(binding)\n-                } else {\n-                    Failed(None)\n-                }\n-            });\n-        }\n+        let check_usable = |this: &mut Self, binding: &'a NameBinding<'a>| {\n+            let usable =\n+                this.is_accessible(binding.vis) && !is_disallowed_private_import(binding) ||\n+                binding.is_extern_crate(); // c.f. issue #37020\n+            if usable { Success(binding) } else { Failed(None) }\n+        };\n \n-        // Check if the globs are determined\n-        for directive in module.globs.borrow().iter() {\n-            if self.is_accessible(directive.vis.get()) {\n-                if let Some(module) = directive.imported_module.get() {\n-                    let result = self.resolve_name_in_module(module, name, ns, true, None);\n-                    if let Indeterminate = result {\n-                        return Indeterminate;\n-                    }\n-                } else {\n-                    return Indeterminate;\n-                }\n+        // Items and single imports are not shadowable.\n+        if let Some(binding) = resolution.binding {\n+            if !binding.is_glob_import() {\n+                return check_usable(self, binding);\n             }\n         }\n \n-        Failed(None)\n-    }\n-\n-    // Returns Some(the resolution of the name), or None if the resolution depends\n-    // on whether more globs can define the name.\n-    fn try_result(&mut self, resolution: &NameResolution<'a>, ns: Namespace)\n-                  -> Option<ResolveResult<&'a NameBinding<'a>>> {\n-        match resolution.binding {\n-            Some(binding) if !binding.is_glob_import() =>\n-                return Some(Success(binding)), // Items and single imports are not shadowable.\n-            _ => {}\n-        };\n-\n         // Check if a single import can still define the name.\n         match resolution.single_imports {\n-            SingleImports::AtLeastOne => return Some(Indeterminate),\n+            SingleImports::AtLeastOne => return Indeterminate,\n             SingleImports::MaybeOne(directive) if self.is_accessible(directive.vis.get()) => {\n                 let module = match directive.imported_module.get() {\n                     Some(module) => module,\n-                    None => return Some(Indeterminate),\n+                    None => return Indeterminate,\n                 };\n                 let name = match directive.subclass {\n                     SingleImport { source, .. } => source,\n                     _ => unreachable!(),\n                 };\n-                match self.resolve_name_in_module(module, name, ns, true, None) {\n+                match self.resolve_name_in_module(module, name, ns, true, false, None) {\n                     Failed(_) => {}\n-                    _ => return Some(Indeterminate),\n+                    _ => return Indeterminate,\n                 }\n             }\n             SingleImports::MaybeOne(_) | SingleImports::None => {},\n         }\n \n-        resolution.binding.map(Success)\n+        let no_unresolved_invocations =\n+            ignore_unresolved_invocations || module.unresolved_invocations.borrow().is_empty();\n+        match resolution.binding {\n+            // In `MacroNS`, expanded bindings do not shadow (enforced in `try_define`).\n+            Some(binding) if no_unresolved_invocations || ns == MacroNS =>\n+                return check_usable(self, binding),\n+            None if no_unresolved_invocations => {}\n+            _ => return Indeterminate,\n+        }\n+\n+        // Check if the globs are determined\n+        for directive in module.globs.borrow().iter() {\n+            if self.is_accessible(directive.vis.get()) {\n+                if let Some(module) = directive.imported_module.get() {\n+                    let result = self.resolve_name_in_module(module, name, ns, true, false, None);\n+                    if let Indeterminate = result {\n+                        return Indeterminate;\n+                    }\n+                } else {\n+                    return Indeterminate;\n+                }\n+            }\n+        }\n+\n+        Failed(None)\n     }\n \n     // Add an import directive to the current module.\n@@ -259,7 +243,8 @@ impl<'a> Resolver<'a> {\n                                 subclass: ImportDirectiveSubclass<'a>,\n                                 span: Span,\n                                 id: NodeId,\n-                                vis: ty::Visibility) {\n+                                vis: ty::Visibility,\n+                                expansion: Mark) {\n         let current_module = self.current_module;\n         let directive = self.arenas.alloc_import_directive(ImportDirective {\n             parent: current_module,\n@@ -269,15 +254,16 @@ impl<'a> Resolver<'a> {\n             span: span,\n             id: id,\n             vis: Cell::new(vis),\n+            expansion: expansion,\n         });\n \n         self.indeterminate_imports.push(directive);\n         match directive.subclass {\n             SingleImport { target, .. } => {\n-                for &ns in &[ValueNS, TypeNS] {\n-                    let mut resolution = self.resolution(current_module, target, ns).borrow_mut();\n+                self.per_ns(|this, ns| {\n+                    let mut resolution = this.resolution(current_module, target, ns).borrow_mut();\n                     resolution.single_imports.add_directive(directive);\n-                }\n+                });\n             }\n             // We don't add prelude imports to the globs since they only affect lexical scopes,\n             // which are not relevant to import resolution.\n@@ -312,6 +298,7 @@ impl<'a> Resolver<'a> {\n             },\n             span: directive.span,\n             vis: vis,\n+            expansion: directive.expansion,\n         }\n     }\n \n@@ -324,28 +311,26 @@ impl<'a> Resolver<'a> {\n         self.update_resolution(module, name, ns, |this, resolution| {\n             if let Some(old_binding) = resolution.binding {\n                 if binding.is_glob_import() {\n-                    if !this.new_import_semantics || !old_binding.is_glob_import() {\n+                    if !this.new_import_semantics {\n                         resolution.duplicate_globs.push(binding);\n+                    } else if !old_binding.is_glob_import() &&\n+                              !(ns == MacroNS && old_binding.expansion != Mark::root()) {\n                     } else if binding.def() != old_binding.def() {\n-                        resolution.binding = Some(this.arenas.alloc_name_binding(NameBinding {\n-                            kind: NameBindingKind::Ambiguity {\n-                                b1: old_binding,\n-                                b2: binding,\n-                            },\n-                            vis: if old_binding.vis.is_at_least(binding.vis, this) {\n-                                old_binding.vis\n-                            } else {\n-                                binding.vis\n-                            },\n-                            span: old_binding.span,\n-                        }));\n+                        resolution.binding = Some(this.ambiguity(old_binding, binding));\n                     } else if !old_binding.vis.is_at_least(binding.vis, this) {\n                         // We are glob-importing the same item but with greater visibility.\n                         resolution.binding = Some(binding);\n                     }\n                 } else if old_binding.is_glob_import() {\n-                    resolution.duplicate_globs.push(old_binding);\n-                    resolution.binding = Some(binding);\n+                    if !this.new_import_semantics {\n+                        resolution.duplicate_globs.push(old_binding);\n+                        resolution.binding = Some(binding);\n+                    } else if ns == MacroNS && binding.expansion != Mark::root() &&\n+                              binding.def() != old_binding.def() {\n+                        resolution.binding = Some(this.ambiguity(binding, old_binding));\n+                    } else {\n+                        resolution.binding = Some(binding);\n+                    }\n                 } else {\n                     return Err(old_binding);\n                 }\n@@ -357,6 +342,16 @@ impl<'a> Resolver<'a> {\n         })\n     }\n \n+    pub fn ambiguity(&mut self, b1: &'a NameBinding<'a>, b2: &'a NameBinding<'a>)\n+                 -> &'a NameBinding<'a> {\n+        self.arenas.alloc_name_binding(NameBinding {\n+            kind: NameBindingKind::Ambiguity { b1: b1, b2: b2 },\n+            vis: if b1.vis.is_at_least(b2.vis, self) { b1.vis } else { b2.vis },\n+            span: b1.span,\n+            expansion: Mark::root(),\n+        })\n+    }\n+\n     // Use `f` to mutate the resolution of the name in the module.\n     // If the resolution becomes a success, define it in the module's glob importers.\n     fn update_resolution<T, F>(&mut self, module: Module<'a>, name: Name, ns: Namespace, f: F) -> T\n@@ -393,10 +388,22 @@ impl<'a> Resolver<'a> {\n \n         t\n     }\n+\n+    // Define a \"dummy\" resolution containing a Def::Err as a placeholder for a\n+    // failed resolution\n+    fn import_dummy_binding(&mut self, directive: &'a ImportDirective<'a>) {\n+        if let SingleImport { target, .. } = directive.subclass {\n+            let dummy_binding = self.dummy_binding;\n+            let dummy_binding = self.import(dummy_binding, directive);\n+            self.per_ns(|this, ns| {\n+                let _ = this.try_define(directive.parent, target, ns, dummy_binding.clone());\n+            });\n+        }\n+    }\n }\n \n-struct ImportResolver<'a, 'b: 'a> {\n-    resolver: &'a mut Resolver<'b>,\n+pub struct ImportResolver<'a, 'b: 'a> {\n+    pub resolver: &'a mut Resolver<'b>,\n }\n \n impl<'a, 'b: 'a> ::std::ops::Deref for ImportResolver<'a, 'b> {\n@@ -429,28 +436,21 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n \n     /// Resolves all imports for the crate. This method performs the fixed-\n     /// point iteration.\n-    fn resolve_imports(&mut self) {\n-        let mut i = 0;\n+    pub fn resolve_imports(&mut self) {\n         let mut prev_num_indeterminates = self.indeterminate_imports.len() + 1;\n-\n         while self.indeterminate_imports.len() < prev_num_indeterminates {\n             prev_num_indeterminates = self.indeterminate_imports.len();\n-            debug!(\"(resolving imports) iteration {}, {} imports left\", i, prev_num_indeterminates);\n-\n-            let mut imports = Vec::new();\n-            ::std::mem::swap(&mut imports, &mut self.indeterminate_imports);\n-\n-            for import in imports {\n+            for import in mem::replace(&mut self.indeterminate_imports, Vec::new()) {\n                 match self.resolve_import(&import) {\n                     Failed(_) => self.determined_imports.push(import),\n                     Indeterminate => self.indeterminate_imports.push(import),\n                     Success(()) => self.determined_imports.push(import),\n                 }\n             }\n-\n-            i += 1;\n         }\n+    }\n \n+    pub fn finalize_imports(&mut self) {\n         for module in self.arenas.local_modules().iter() {\n             self.finalize_resolutions_in(module);\n         }\n@@ -484,17 +484,6 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         }\n     }\n \n-    // Define a \"dummy\" resolution containing a Def::Err as a placeholder for a\n-    // failed resolution\n-    fn import_dummy_binding(&mut self, directive: &'b ImportDirective<'b>) {\n-        if let SingleImport { target, .. } = directive.subclass {\n-            let dummy_binding = self.dummy_binding;\n-            let dummy_binding = self.import(dummy_binding, directive);\n-            let _ = self.try_define(directive.parent, target, ValueNS, dummy_binding.clone());\n-            let _ = self.try_define(directive.parent, target, TypeNS, dummy_binding);\n-        }\n-    }\n-\n     /// Attempts to resolve the given import. The return value indicates\n     /// failure if we're certain the name does not exist, indeterminate if we\n     /// don't know whether the name exists at the moment due to other\n@@ -526,9 +515,8 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         };\n \n         directive.imported_module.set(Some(module));\n-        let (source, target, value_result, type_result) = match directive.subclass {\n-            SingleImport { source, target, ref value_result, ref type_result } =>\n-                (source, target, value_result, type_result),\n+        let (source, target, result) = match directive.subclass {\n+            SingleImport { source, target, ref result } => (source, target, result),\n             GlobImport { .. } => {\n                 self.resolve_glob_import(directive);\n                 return Success(());\n@@ -537,46 +525,45 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         };\n \n         let mut indeterminate = false;\n-        for &(ns, result) in &[(ValueNS, value_result), (TypeNS, type_result)] {\n-            if let Err(Undetermined) = result.get() {\n-                result.set({\n-                    match self.resolve_name_in_module(module, source, ns, false, None) {\n+        self.per_ns(|this, ns| {\n+            if let Err(Undetermined) = result[ns].get() {\n+                result[ns].set({\n+                    match this.resolve_name_in_module(module, source, ns, false, false, None) {\n                         Success(binding) => Ok(binding),\n                         Indeterminate => Err(Undetermined),\n                         Failed(_) => Err(Determined),\n                     }\n                 });\n             } else {\n-                continue\n+                return\n             };\n \n-            match result.get() {\n+            match result[ns].get() {\n                 Err(Undetermined) => indeterminate = true,\n                 Err(Determined) => {\n-                    self.update_resolution(directive.parent, target, ns, |_, resolution| {\n+                    this.update_resolution(directive.parent, target, ns, |_, resolution| {\n                         resolution.single_imports.directive_failed()\n                     });\n                 }\n                 Ok(binding) if !binding.is_importable() => {\n                     let msg = format!(\"`{}` is not directly importable\", target);\n-                    struct_span_err!(self.session, directive.span, E0253, \"{}\", &msg)\n+                    struct_span_err!(this.session, directive.span, E0253, \"{}\", &msg)\n                         .span_label(directive.span, &format!(\"cannot be imported directly\"))\n                         .emit();\n                     // Do not import this illegal binding. Import a dummy binding and pretend\n                     // everything is fine\n-                    self.import_dummy_binding(directive);\n-                    return Success(());\n+                    this.import_dummy_binding(directive);\n                 }\n                 Ok(binding) => {\n-                    let imported_binding = self.import(binding, directive);\n-                    let conflict = self.try_define(directive.parent, target, ns, imported_binding);\n+                    let imported_binding = this.import(binding, directive);\n+                    let conflict = this.try_define(directive.parent, target, ns, imported_binding);\n                     if let Err(old_binding) = conflict {\n-                        let binding = &self.import(binding, directive);\n-                        self.report_conflict(directive.parent, target, ns, binding, old_binding);\n+                        let binding = &this.import(binding, directive);\n+                        this.report_conflict(directive.parent, target, ns, binding, old_binding);\n                     }\n                 }\n             }\n-        }\n+        });\n \n         if indeterminate { Indeterminate } else { Success(()) }\n     }\n@@ -604,9 +591,8 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             },\n         };\n \n-        let (name, value_result, type_result) = match directive.subclass {\n-            SingleImport { source, ref value_result, ref type_result, .. } =>\n-                (source, value_result.get(), type_result.get()),\n+        let (name, result) = match directive.subclass {\n+            SingleImport { source, ref result, .. } => (source, result),\n             GlobImport { .. } if module.def_id() == directive.parent.def_id() => {\n                 // Importing a module into itself is not allowed.\n                 let msg = \"Cannot glob-import a module into itself.\".into();\n@@ -624,21 +610,27 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             _ => unreachable!(),\n         };\n \n-        for &(ns, result) in &[(ValueNS, value_result), (TypeNS, type_result)] {\n-            if let Ok(binding) = result {\n-                if self.record_use(name, ns, binding, directive.span) {\n-                    self.resolution(module, name, ns).borrow_mut().binding =\n-                        Some(self.dummy_binding);\n+        let mut all_ns_err = true;\n+        self.per_ns(|this, ns| {\n+            if let Ok(binding) = result[ns].get() {\n+                all_ns_err = false;\n+                if this.record_use(name, ns, binding, directive.span) {\n+                    this.resolution(module, name, ns).borrow_mut().binding =\n+                        Some(this.dummy_binding);\n                 }\n             }\n-        }\n+        });\n \n-        if value_result.is_err() && type_result.is_err() {\n-            let (value_result, type_result);\n-            value_result = self.resolve_name_in_module(module, name, ValueNS, false, Some(span));\n-            type_result = self.resolve_name_in_module(module, name, TypeNS, false, Some(span));\n+        if all_ns_err {\n+            let mut all_ns_failed = true;\n+            self.per_ns(|this, ns| {\n+                match this.resolve_name_in_module(module, name, ns, false, false, Some(span)) {\n+                    Success(_) => all_ns_failed = false,\n+                    _ => {}\n+                }\n+            });\n \n-            return if let (Failed(_), Failed(_)) = (value_result, type_result) {\n+            return if all_ns_failed {\n                 let resolutions = module.resolutions.borrow();\n                 let names = resolutions.iter().filter_map(|(&(ref n, _), resolution)| {\n                     if *n == name { return None; } // Never suggest the same name\n@@ -666,64 +658,49 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             }\n         }\n \n-        let session = self.session;\n-        let reexport_error = || {\n-            let msg = format!(\"`{}` is private, and cannot be reexported\", name);\n-            let note_msg =\n-                format!(\"consider marking `{}` as `pub` in the imported module\", name);\n-            struct_span_err!(session, directive.span, E0364, \"{}\", &msg)\n-                .span_note(directive.span, &note_msg)\n-                .emit();\n-        };\n-\n-        let extern_crate_lint = || {\n-            let msg = format!(\"extern crate `{}` is private, and cannot be reexported \\\n-                               (error E0364), consider declaring with `pub`\",\n-                               name);\n-            session.add_lint(PRIVATE_IN_PUBLIC, directive.id, directive.span, msg);\n-        };\n-\n-        match (value_result, type_result) {\n-            // All namespaces must be re-exported with extra visibility for an error to occur.\n-            (Ok(value_binding), Ok(type_binding)) => {\n+        let mut reexport_error = None;\n+        let mut any_successful_reexport = false;\n+        self.per_ns(|this, ns| {\n+            if let Ok(binding) = result[ns].get() {\n                 let vis = directive.vis.get();\n-                if !value_binding.pseudo_vis().is_at_least(vis, self) &&\n-                   !type_binding.pseudo_vis().is_at_least(vis, self) {\n-                    reexport_error();\n-                } else if type_binding.is_extern_crate() &&\n-                          !type_binding.vis.is_at_least(vis, self) {\n-                    extern_crate_lint();\n-                }\n-            }\n-\n-            (Ok(binding), _) if !binding.pseudo_vis().is_at_least(directive.vis.get(), self) => {\n-                reexport_error();\n-            }\n-\n-            (_, Ok(binding)) if !binding.pseudo_vis().is_at_least(directive.vis.get(), self) => {\n-                if binding.is_extern_crate() {\n-                    extern_crate_lint();\n+                if !binding.pseudo_vis().is_at_least(vis, this) {\n+                    reexport_error = Some((ns, binding));\n                 } else {\n-                    struct_span_err!(self.session, directive.span, E0365,\n-                                     \"`{}` is private, and cannot be reexported\", name)\n-                        .span_label(directive.span, &format!(\"reexport of private `{}`\", name))\n-                        .note(&format!(\"consider declaring type or module `{}` with `pub`\", name))\n-                        .emit();\n+                    any_successful_reexport = true;\n                 }\n             }\n+        });\n \n-            _ => {}\n+        // All namespaces must be re-exported with extra visibility for an error to occur.\n+        if !any_successful_reexport {\n+            let (ns, binding) = reexport_error.unwrap();\n+            if ns == TypeNS && binding.is_extern_crate() {\n+                let msg = format!(\"extern crate `{}` is private, and cannot be reexported \\\n+                                   (error E0364), consider declaring with `pub`\",\n+                                   name);\n+                self.session.add_lint(PRIVATE_IN_PUBLIC, directive.id, directive.span, msg);\n+            } else if ns == TypeNS {\n+                struct_span_err!(self.session, directive.span, E0365,\n+                                 \"`{}` is private, and cannot be reexported\", name)\n+                    .span_label(directive.span, &format!(\"reexport of private `{}`\", name))\n+                    .note(&format!(\"consider declaring type or module `{}` with `pub`\", name))\n+                    .emit();\n+            } else {\n+                let msg = format!(\"`{}` is private, and cannot be reexported\", name);\n+                let note_msg =\n+                    format!(\"consider marking `{}` as `pub` in the imported module\", name);\n+                struct_span_err!(self.session, directive.span, E0364, \"{}\", &msg)\n+                    .span_note(directive.span, &note_msg)\n+                    .emit();\n+            }\n         }\n \n         // Record what this import resolves to for later uses in documentation,\n         // this may resolve to either a value or a type, but for documentation\n         // purposes it's good enough to just favor one over the other.\n-        let def = match type_result.ok().map(NameBinding::def) {\n-            Some(def) => def,\n-            None => value_result.ok().map(NameBinding::def).unwrap(),\n-        };\n-        let path_resolution = PathResolution::new(def);\n-        self.def_map.insert(directive.id, path_resolution);\n+        self.per_ns(|this, ns| if let Some(binding) = result[ns].get().ok() {\n+            this.def_map.entry(directive.id).or_insert(PathResolution::new(binding.def()));\n+        });\n \n         debug!(\"(resolving single import) successfully resolved import\");\n         return Success(());"}, {"sha": "7f66b060052ea06dd34bafbd4cc714bd1fd934ba", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c57b8261496d548e0a3cd8468061ddc5a4dcafe2/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c57b8261496d548e0a3cd8468061ddc5a4dcafe2/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=c57b8261496d548e0a3cd8468061ddc5a4dcafe2", "patch": "@@ -524,6 +524,7 @@ pub trait Resolver {\n     fn add_ext(&mut self, ident: ast::Ident, ext: Rc<SyntaxExtension>);\n     fn add_expansions_at_stmt(&mut self, id: ast::NodeId, macros: Vec<Mark>);\n \n+    fn resolve_imports(&mut self);\n     fn find_attr_invoc(&mut self, attrs: &mut Vec<Attribute>) -> Option<Attribute>;\n     fn resolve_macro(&mut self, scope: Mark, path: &ast::Path, force: bool)\n                      -> Result<Rc<SyntaxExtension>, Determinacy>;\n@@ -547,6 +548,7 @@ impl Resolver for DummyResolver {\n     fn add_ext(&mut self, _ident: ast::Ident, _ext: Rc<SyntaxExtension>) {}\n     fn add_expansions_at_stmt(&mut self, _id: ast::NodeId, _macros: Vec<Mark>) {}\n \n+    fn resolve_imports(&mut self) {}\n     fn find_attr_invoc(&mut self, _attrs: &mut Vec<Attribute>) -> Option<Attribute> { None }\n     fn resolve_macro(&mut self, _scope: Mark, _path: &ast::Path, _force: bool)\n                      -> Result<Rc<SyntaxExtension>, Determinacy> {"}, {"sha": "8e0c3ce8448da46c983e8ddd186fe2e85c25907b", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c57b8261496d548e0a3cd8468061ddc5a4dcafe2/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c57b8261496d548e0a3cd8468061ddc5a4dcafe2/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=c57b8261496d548e0a3cd8468061ddc5a4dcafe2", "patch": "@@ -222,6 +222,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         self.cx.current_expansion.depth = 0;\n \n         let (expansion, mut invocations) = self.collect_invocations(expansion);\n+        self.resolve_imports();\n         invocations.reverse();\n \n         let mut expansions = Vec::new();\n@@ -230,9 +231,9 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         loop {\n             let invoc = if let Some(invoc) = invocations.pop() {\n                 invoc\n-            } else if undetermined_invocations.is_empty() {\n-                break\n             } else {\n+                self.resolve_imports();\n+                if undetermined_invocations.is_empty() { break }\n                 invocations = mem::replace(&mut undetermined_invocations, Vec::new());\n                 force = !mem::replace(&mut progress, false);\n                 continue\n@@ -292,6 +293,14 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         expansion.fold_with(&mut placeholder_expander)\n     }\n \n+    fn resolve_imports(&mut self) {\n+        if self.monotonic {\n+            let err_count = self.cx.parse_sess.span_diagnostic.err_count();\n+            self.cx.resolver.resolve_imports();\n+            self.cx.resolve_err_count += self.cx.parse_sess.span_diagnostic.err_count() - err_count;\n+        }\n+    }\n+\n     fn collect_invocations(&mut self, expansion: Expansion) -> (Expansion, Vec<Invocation>) {\n         let result = {\n             let mut collector = InvocationCollector {"}, {"sha": "ea66fdc31cf08e7ce59d07a288cb2fb0869799d9", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c57b8261496d548e0a3cd8468061ddc5a4dcafe2/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c57b8261496d548e0a3cd8468061ddc5a4dcafe2/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=c57b8261496d548e0a3cd8468061ddc5a4dcafe2", "patch": "@@ -314,6 +314,8 @@ declare_features! (\n \n     // Allows #[link(..., cfg(..))]\n     (active, link_cfg, \"1.14.0\", Some(37406)),\n+\n+    (active, use_extern_macros, \"1.15.0\", Some(35896)),\n );\n \n declare_features! ("}, {"sha": "2d53aee39e95da6e829e75fb4873d7d2aef542ca", "filename": "src/test/compile-fail/blind-item-block-item-shadow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c57b8261496d548e0a3cd8468061ddc5a4dcafe2/src%2Ftest%2Fcompile-fail%2Fblind-item-block-item-shadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c57b8261496d548e0a3cd8468061ddc5a4dcafe2/src%2Ftest%2Fcompile-fail%2Fblind-item-block-item-shadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fblind-item-block-item-shadow.rs?ref=c57b8261496d548e0a3cd8468061ddc5a4dcafe2", "patch": "@@ -14,6 +14,6 @@ fn main() {\n     {\n         struct Bar;\n         use foo::Bar;\n-        //~^ ERROR a value named `Bar` has already been defined in this block\n+        //~^ ERROR a type named `Bar` has already been defined in this block\n     }\n }"}, {"sha": "760612c05ce49443ffe7b76c6a815360023efec7", "filename": "src/test/compile-fail/double-type-import.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c57b8261496d548e0a3cd8468061ddc5a4dcafe2/src%2Ftest%2Fcompile-fail%2Fdouble-type-import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c57b8261496d548e0a3cd8468061ddc5a4dcafe2/src%2Ftest%2Fcompile-fail%2Fdouble-type-import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdouble-type-import.rs?ref=c57b8261496d548e0a3cd8468061ddc5a4dcafe2", "patch": "@@ -11,7 +11,7 @@\n mod foo {\n     pub use self::bar::X;\n     use self::bar::X;\n-    //~^ ERROR a value named `X` has already been imported in this module\n+    //~^ ERROR a type named `X` has already been imported in this module\n \n     mod bar {\n         pub struct X;"}, {"sha": "2ac8e3ef983da48c0e165dc406c121c1ed00f897", "filename": "src/test/compile-fail/imports/auxiliary/two_macros.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c57b8261496d548e0a3cd8468061ddc5a4dcafe2/src%2Ftest%2Fcompile-fail%2Fimports%2Fauxiliary%2Ftwo_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c57b8261496d548e0a3cd8468061ddc5a4dcafe2/src%2Ftest%2Fcompile-fail%2Fimports%2Fauxiliary%2Ftwo_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimports%2Fauxiliary%2Ftwo_macros.rs?ref=c57b8261496d548e0a3cd8468061ddc5a4dcafe2", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[macro_export]\n+macro_rules! m { ($($t:tt)*) => { $($t)* } }\n+\n+#[macro_export]\n+macro_rules! n { ($($t:tt)*) => { $($t)* } }"}, {"sha": "faf85a523e8fb01fdf33c6b00e45b3ff20fd1037", "filename": "src/test/compile-fail/imports/duplicate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c57b8261496d548e0a3cd8468061ddc5a4dcafe2/src%2Ftest%2Fcompile-fail%2Fimports%2Fduplicate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c57b8261496d548e0a3cd8468061ddc5a4dcafe2/src%2Ftest%2Fcompile-fail%2Fimports%2Fduplicate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimports%2Fduplicate.rs?ref=c57b8261496d548e0a3cd8468061ddc5a4dcafe2", "patch": "@@ -46,9 +46,9 @@ mod g {\n fn main() {\n     e::foo();\n     f::foo(); //~ ERROR `foo` is ambiguous\n-              //~| NOTE Consider adding an explicit import of `foo` to disambiguate\n+              //~| NOTE consider adding an explicit import of `foo` to disambiguate\n     g::foo(); //~ ERROR `foo` is ambiguous\n-              //~| NOTE Consider adding an explicit import of `foo` to disambiguate\n+              //~| NOTE consider adding an explicit import of `foo` to disambiguate\n }\n \n mod ambiguous_module_errors {"}, {"sha": "c11d2aab7c62537f163c171ebf013019cf44edd5", "filename": "src/test/compile-fail/imports/macros.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/c57b8261496d548e0a3cd8468061ddc5a4dcafe2/src%2Ftest%2Fcompile-fail%2Fimports%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c57b8261496d548e0a3cd8468061ddc5a4dcafe2/src%2Ftest%2Fcompile-fail%2Fimports%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimports%2Fmacros.rs?ref=c57b8261496d548e0a3cd8468061ddc5a4dcafe2", "patch": "@@ -0,0 +1,55 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:two_macros.rs\n+\n+#![feature(item_like_imports, use_extern_macros)]\n+\n+extern crate two_macros; // two identity macros `m` and `n`\n+\n+mod foo {\n+    pub use two_macros::n as m;\n+}\n+\n+mod m1 {\n+    m!(use two_macros::*;);\n+    use foo::m; // This shadows the glob import\n+}\n+\n+mod m2 {\n+    use two_macros::*; //~ NOTE could also resolve\n+    m! { //~ ERROR ambiguous\n+         //~| NOTE macro-expanded macro imports do not shadow\n+        use foo::m; //~ NOTE could resolve to the name imported here\n+                    //~^^^ NOTE in this expansion\n+    }\n+}\n+\n+mod m3 {\n+    use two_macros::m; //~ NOTE could also resolve\n+    fn f() {\n+        use two_macros::n as m; // This shadows the above import\n+        m!();\n+    }\n+\n+    fn g() {\n+        m! { //~ ERROR ambiguous\n+             //~| NOTE macro-expanded macro imports do not shadow\n+            use two_macros::n as m; //~ NOTE could resolve to the name imported here\n+                                    //~^^^ NOTE in this expansion\n+        }\n+    }\n+}\n+\n+mod m4 {\n+    macro_rules! m { () => {} } //~ NOTE could resolve to the macro defined here\n+    use two_macros::m; //~ NOTE could also resolve to the macro imported here\n+    m!(); //~ ERROR ambiguous\n+}"}]}