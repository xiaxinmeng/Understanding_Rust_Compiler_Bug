{"sha": "1efcb6ad9abc0ab0c1af8092ee73dce90e7ab8e3", "node_id": "C_kwDOAAsO6NoAKDFlZmNiNmFkOWFiYzBhYjBjMWFmODA5MmVlNzNkY2U5MGU3YWI4ZTM", "commit": {"author": {"name": "Noritada Kobayashi", "email": "noritada.kobayashi@gmail.com", "date": "2022-12-09T14:45:45Z"}, "committer": {"name": "Noritada Kobayashi", "email": "noritada.kobayashi@gmail.com", "date": "2022-12-09T14:45:45Z"}, "message": "Import the initial implementation of AsciiDoc-to-Markdown conversion", "tree": {"sha": "02e8faf96f94c52706e15f5e772b022512a17a19", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/02e8faf96f94c52706e15f5e772b022512a17a19"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1efcb6ad9abc0ab0c1af8092ee73dce90e7ab8e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1efcb6ad9abc0ab0c1af8092ee73dce90e7ab8e3", "html_url": "https://github.com/rust-lang/rust/commit/1efcb6ad9abc0ab0c1af8092ee73dce90e7ab8e3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1efcb6ad9abc0ab0c1af8092ee73dce90e7ab8e3/comments", "author": {"login": "noritada", "id": 20850, "node_id": "MDQ6VXNlcjIwODUw", "avatar_url": "https://avatars.githubusercontent.com/u/20850?v=4", "gravatar_id": "", "url": "https://api.github.com/users/noritada", "html_url": "https://github.com/noritada", "followers_url": "https://api.github.com/users/noritada/followers", "following_url": "https://api.github.com/users/noritada/following{/other_user}", "gists_url": "https://api.github.com/users/noritada/gists{/gist_id}", "starred_url": "https://api.github.com/users/noritada/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/noritada/subscriptions", "organizations_url": "https://api.github.com/users/noritada/orgs", "repos_url": "https://api.github.com/users/noritada/repos", "events_url": "https://api.github.com/users/noritada/events{/privacy}", "received_events_url": "https://api.github.com/users/noritada/received_events", "type": "User", "site_admin": false}, "committer": {"login": "noritada", "id": 20850, "node_id": "MDQ6VXNlcjIwODUw", "avatar_url": "https://avatars.githubusercontent.com/u/20850?v=4", "gravatar_id": "", "url": "https://api.github.com/users/noritada", "html_url": "https://github.com/noritada", "followers_url": "https://api.github.com/users/noritada/followers", "following_url": "https://api.github.com/users/noritada/following{/other_user}", "gists_url": "https://api.github.com/users/noritada/gists{/gist_id}", "starred_url": "https://api.github.com/users/noritada/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/noritada/subscriptions", "organizations_url": "https://api.github.com/users/noritada/orgs", "repos_url": "https://api.github.com/users/noritada/repos", "events_url": "https://api.github.com/users/noritada/events{/privacy}", "received_events_url": "https://api.github.com/users/noritada/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a2beeb8dbb5f4596f8c6f28a09c20355ea4c4628", "url": "https://api.github.com/repos/rust-lang/rust/commits/a2beeb8dbb5f4596f8c6f28a09c20355ea4c4628", "html_url": "https://github.com/rust-lang/rust/commit/a2beeb8dbb5f4596f8c6f28a09c20355ea4c4628"}], "stats": {"total": 371, "additions": 371, "deletions": 0}, "files": [{"sha": "257c30a208bc13075d1545925350d1443524ad63", "filename": "xtask/src/publish/notes.rs", "status": "added", "additions": 371, "deletions": 0, "changes": 371, "blob_url": "https://github.com/rust-lang/rust/blob/1efcb6ad9abc0ab0c1af8092ee73dce90e7ab8e3/xtask%2Fsrc%2Fpublish%2Fnotes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1efcb6ad9abc0ab0c1af8092ee73dce90e7ab8e3/xtask%2Fsrc%2Fpublish%2Fnotes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fpublish%2Fnotes.rs?ref=1efcb6ad9abc0ab0c1af8092ee73dce90e7ab8e3", "patch": "@@ -0,0 +1,371 @@\n+use anyhow::{anyhow, bail};\n+use std::{\n+    io::{BufRead, Lines},\n+    iter::Peekable,\n+};\n+\n+const LISTING_DELIMITER: &'static str = \"----\";\n+\n+struct Converter<'a, 'b, R: BufRead> {\n+    iter: &'a mut Peekable<Lines<R>>,\n+    output: &'b mut String,\n+}\n+\n+impl<'a, 'b, R: BufRead> Converter<'a, 'b, R> {\n+    fn new(iter: &'a mut Peekable<Lines<R>>, output: &'b mut String) -> Self {\n+        Self { iter, output }\n+    }\n+\n+    fn process(&mut self) -> anyhow::Result<()> {\n+        self.process_document_header()?;\n+        self.skip_blank_lines()?;\n+        self.output.push('\\n');\n+\n+        loop {\n+            let line = self.iter.peek().unwrap().as_deref().map_err(|e| anyhow!(\"{e}\"))?;\n+            if get_title(line).is_some() {\n+                let line = self.iter.next().unwrap().unwrap();\n+                let (level, title) = get_title(&line).unwrap();\n+                self.write_title(level, title);\n+            } else if get_list_item(line).is_some() {\n+                self.process_list()?;\n+            } else if line.starts_with('[') {\n+                self.process_source_code_block(0)?;\n+            } else if line.starts_with(LISTING_DELIMITER) {\n+                self.process_listing_block(None, 0)?;\n+            } else {\n+                self.process_paragraph(0)?;\n+            }\n+\n+            self.skip_blank_lines()?;\n+            if self.iter.peek().is_none() {\n+                break;\n+            }\n+            self.output.push('\\n');\n+        }\n+        Ok(())\n+    }\n+\n+    fn process_document_header(&mut self) -> anyhow::Result<()> {\n+        self.process_document_title()?;\n+\n+        while let Some(line) = self.iter.next() {\n+            let line = line?;\n+            if line.is_empty() {\n+                break;\n+            }\n+            if !line.starts_with(':') {\n+                self.write_line(&line, 0)\n+            }\n+        }\n+\n+        Ok(())\n+    }\n+\n+    fn process_document_title(&mut self) -> anyhow::Result<()> {\n+        if let Some(Ok(line)) = self.iter.next() {\n+            if let Some((level, title)) = get_title(&line) {\n+                if level == 1 {\n+                    self.write_title(level, title);\n+                    return Ok(());\n+                }\n+            }\n+        }\n+        bail!(\"document title not found\")\n+    }\n+\n+    fn process_list(&mut self) -> anyhow::Result<()> {\n+        while let Some(line) = self.iter.next() {\n+            let line = line?;\n+            if line.is_empty() {\n+                break;\n+            }\n+\n+            if let Some(item) = get_list_item(&line) {\n+                self.write_list_item(item);\n+            } else if line == \"+\" {\n+                let line = self\n+                    .iter\n+                    .peek()\n+                    .ok_or_else(|| anyhow!(\"list continuation unexpectedly terminated\"))?;\n+                let line = line.as_deref().map_err(|e| anyhow!(\"{e}\"))?;\n+                if line.starts_with('[') {\n+                    self.write_line(\"\", 0);\n+                    self.process_source_code_block(1)?;\n+                } else if line.starts_with(LISTING_DELIMITER) {\n+                    self.write_line(\"\", 0);\n+                    self.process_listing_block(None, 1)?;\n+                } else {\n+                    self.write_line(\"\", 0);\n+                    self.process_paragraph(1)?;\n+                }\n+            } else {\n+                bail!(\"not a list block\")\n+            }\n+        }\n+\n+        Ok(())\n+    }\n+\n+    fn process_source_code_block(&mut self, level: usize) -> anyhow::Result<()> {\n+        if let Some(Ok(line)) = self.iter.next() {\n+            if let Some(styles) = line.strip_prefix(\"[source\").and_then(|s| s.strip_suffix(']')) {\n+                let mut styles = styles.split(',');\n+                if !styles.next().unwrap().is_empty() {\n+                    bail!(\"not a source code block\");\n+                }\n+                let language = styles.next();\n+                return self.process_listing_block(language, level);\n+            }\n+        }\n+        bail!(\"not a source code block\")\n+    }\n+\n+    fn process_listing_block(&mut self, style: Option<&str>, level: usize) -> anyhow::Result<()> {\n+        if let Some(Ok(line)) = self.iter.next() {\n+            if line == LISTING_DELIMITER {\n+                self.write_indent(level);\n+                self.output.push_str(\"```\");\n+                if let Some(style) = style {\n+                    self.output.push_str(style);\n+                }\n+                self.output.push('\\n');\n+                while let Some(line) = self.iter.next() {\n+                    let line = line?;\n+                    if line == LISTING_DELIMITER {\n+                        self.write_line(\"```\", level);\n+                        return Ok(());\n+                    } else {\n+                        self.write_line(&line, level);\n+                    }\n+                }\n+                bail!(\"listing block is not terminated\")\n+            }\n+        }\n+        bail!(\"not a listing block\")\n+    }\n+\n+    fn process_paragraph(&mut self, level: usize) -> anyhow::Result<()> {\n+        while let Some(line) = self.iter.peek() {\n+            let line = line.as_deref().map_err(|e| anyhow!(\"{e}\"))?;\n+            if line.is_empty() || (level > 0 && line == \"+\") {\n+                break;\n+            }\n+\n+            self.write_indent(level);\n+            let line = self.iter.next().unwrap()?;\n+            if line.ends_with('+') {\n+                let line = &line[..(line.len() - 1)];\n+                self.output.push_str(line);\n+                self.output.push('\\\\');\n+            } else {\n+                self.output.push_str(&line);\n+            }\n+            self.output.push('\\n');\n+        }\n+\n+        Ok(())\n+    }\n+\n+    fn skip_blank_lines(&mut self) -> anyhow::Result<()> {\n+        while let Some(line) = self.iter.peek() {\n+            if !line.as_deref().unwrap().is_empty() {\n+                break;\n+            }\n+            self.iter.next().unwrap()?;\n+        }\n+        Ok(())\n+    }\n+\n+    fn write_title(&mut self, level: usize, title: &str) {\n+        for _ in 0..level {\n+            self.output.push('#');\n+        }\n+        self.output.push(' ');\n+        self.output.push_str(title);\n+        self.output.push('\\n');\n+    }\n+\n+    fn write_list_item(&mut self, item: &str) {\n+        self.output.push_str(\"- \");\n+        self.output.push_str(item);\n+        self.output.push('\\n');\n+    }\n+\n+    fn write_indent(&mut self, level: usize) {\n+        for _ in 0..level {\n+            self.output.push_str(\"  \");\n+        }\n+    }\n+\n+    fn write_line(&mut self, line: &str, level: usize) {\n+        self.write_indent(level);\n+        self.output.push_str(line);\n+        self.output.push('\\n');\n+    }\n+}\n+\n+pub(crate) fn convert_asciidoc_to_markdown<R>(input: R) -> anyhow::Result<String>\n+where\n+    R: BufRead,\n+{\n+    let mut output = String::new();\n+    let mut iter = input.lines().peekable();\n+\n+    let mut converter = Converter::new(&mut iter, &mut output);\n+    converter.process()?;\n+\n+    Ok(output)\n+}\n+\n+fn get_title(line: &str) -> Option<(usize, &str)> {\n+    const MARKER: char = '=';\n+    let mut iter = line.chars();\n+    if iter.next()? != MARKER {\n+        return None;\n+    }\n+    let mut count = 1;\n+    loop {\n+        match iter.next() {\n+            Some(MARKER) => {\n+                count += 1;\n+            }\n+            Some(' ') => {\n+                break;\n+            }\n+            _ => return None,\n+        }\n+    }\n+    Some((count, iter.as_str()))\n+}\n+\n+fn get_list_item(line: &str) -> Option<&str> {\n+    const MARKER: &'static str = \"* \";\n+    if line.starts_with(MARKER) {\n+        let item = &line[MARKER.len()..];\n+        Some(item)\n+    } else {\n+        None\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    #[test]\n+    fn test_asciidoc_to_markdown_conversion() {\n+        let input = \"\\\n+= Changelog #256\n+:sectanchors:\n+:page-layout: post\n+\n+Hello!\n+\n+Commit: commit:0123456789abcdef0123456789abcdef01234567[] +\n+Release: release:2022-01-01[]\n+\n+== New Features\n+\n+* pr:1111[] foo bar baz\n+* pr:2222[] foo bar baz\n++\n+image::https://example.com/animation.gif[]\n++\n+video::https://example.com/movie.mp4[options=\\\"autoplay,loop\\\"]\n++\n+[source,bash]\n+----\n+rustup update nightly\n+----\n++\n+----\n+This is a plain listing.\n+----\n++\n+paragraph\n+paragraph\n+\n+== Fixes\n+\n+* pr:3333[] foo bar baz\n+* pr:4444[] foo bar baz\n+\n+== Internal Improvements\n+\n+* pr:5555[] foo bar baz\n+* pr:6666[] foo bar baz\n+\n+The highlight of the month is probably pr:1111[].\n+\n+[source,bash]\n+----\n+rustup update nightly\n+----\n+\n+[source]\n+----\n+rustup update nightly\n+----\n+\n+----\n+This is a plain listing.\n+----\n+\";\n+        let expected = \"\\\n+# Changelog #256\n+\n+Hello!\n+\n+Commit: commit:0123456789abcdef0123456789abcdef01234567[] \\\\\n+Release: release:2022-01-01[]\n+\n+## New Features\n+\n+- pr:1111[] foo bar baz\n+- pr:2222[] foo bar baz\n+\n+  image::https://example.com/animation.gif[]\n+\n+  video::https://example.com/movie.mp4[options=\\\"autoplay,loop\\\"]\n+\n+  ```bash\n+  rustup update nightly\n+  ```\n+\n+  ```\n+  This is a plain listing.\n+  ```\n+\n+  paragraph\n+  paragraph\n+\n+## Fixes\n+\n+- pr:3333[] foo bar baz\n+- pr:4444[] foo bar baz\n+\n+## Internal Improvements\n+\n+- pr:5555[] foo bar baz\n+- pr:6666[] foo bar baz\n+\n+The highlight of the month is probably pr:1111[].\n+\n+```bash\n+rustup update nightly\n+```\n+\n+```\n+rustup update nightly\n+```\n+\n+```\n+This is a plain listing.\n+```\n+\";\n+        let actual = convert_asciidoc_to_markdown(std::io::Cursor::new(input)).unwrap();\n+\n+        assert_eq!(actual, expected);\n+    }\n+}"}]}