{"sha": "7d81e40e36a7b5451785e224a2f16822834f29a3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdkODFlNDBlMzZhN2I1NDUxNzg1ZTIyNGEyZjE2ODIyODM0ZjI5YTM=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-05-22T12:26:40Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-05-22T12:26:40Z"}, "message": "Merge #8901\n\n8901: fix: `fill_match_arms` hangs on a tuple of large enums r=matklad a=iDawer\n\n+ Lazy computation of missing arms.\r\n+ Convenience function to test lazy computation: `ide_assists::tests::check_assist_unresolved`.\r\n\r\nFixes #8835 \n\nCo-authored-by: Dawer <7803845+iDawer@users.noreply.github.com>", "tree": {"sha": "ed5ab1b896294963128bc3f34589634c83d812b6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ed5ab1b896294963128bc3f34589634c83d812b6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7d81e40e36a7b5451785e224a2f16822834f29a3", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgqPiACRBK7hj4Ov3rIwAAI/AIAA+IPGN5G0OsZsfCB8fc3d2W\nviiqv0i+PnMYQvYyXKNObsyeqoWQFLp1QOKYVJZJiKgZj7fK0KVIgF1ES16r3TRv\ng/XFCoK0QI74lTyrJfv+R4tR2HDu5ixg0+MX1HXILasqKzGZvyQui3Zar/fsr10t\n4nTkP4pCJLP5L9u1h8Steb3ajw0U21m7VZMOinlPczNG37Jtj5vgr/NH3hzQggBN\nLHFZy1GFaatZxOPeFvNJiR88bJMUtAJQu2AUCrEF6Xo6WhHFZDdR665IbdvCeDyn\nuDxizs48GmWqhoeNJcybL7iOzKsFg4PI+5TmojFbXi2OHHoPNUa0qwoIbZBmfdY=\n=yZHQ\n-----END PGP SIGNATURE-----\n", "payload": "tree ed5ab1b896294963128bc3f34589634c83d812b6\nparent 3cfe2d0a5d663d29c3d196f9d16e91964780792a\nparent d5c96672aac6fd4ac25474814879af2c04bd798b\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1621686400 +0000\ncommitter GitHub <noreply@github.com> 1621686400 +0000\n\nMerge #8901\n\n8901: fix: `fill_match_arms` hangs on a tuple of large enums r=matklad a=iDawer\n\n+ Lazy computation of missing arms.\r\n+ Convenience function to test lazy computation: `ide_assists::tests::check_assist_unresolved`.\r\n\r\nFixes #8835 \n\nCo-authored-by: Dawer <7803845+iDawer@users.noreply.github.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7d81e40e36a7b5451785e224a2f16822834f29a3", "html_url": "https://github.com/rust-lang/rust/commit/7d81e40e36a7b5451785e224a2f16822834f29a3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7d81e40e36a7b5451785e224a2f16822834f29a3/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3cfe2d0a5d663d29c3d196f9d16e91964780792a", "url": "https://api.github.com/repos/rust-lang/rust/commits/3cfe2d0a5d663d29c3d196f9d16e91964780792a", "html_url": "https://github.com/rust-lang/rust/commit/3cfe2d0a5d663d29c3d196f9d16e91964780792a"}, {"sha": "d5c96672aac6fd4ac25474814879af2c04bd798b", "url": "https://api.github.com/repos/rust-lang/rust/commits/d5c96672aac6fd4ac25474814879af2c04bd798b", "html_url": "https://github.com/rust-lang/rust/commit/d5c96672aac6fd4ac25474814879af2c04bd798b"}], "stats": {"total": 102, "additions": 75, "deletions": 27}, "files": [{"sha": "97435f021137e5279a4a8cbdaddfac3927999924", "filename": "crates/ide_assists/src/handlers/fill_match_arms.rs", "status": "modified", "additions": 56, "deletions": 25, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/7d81e40e36a7b5451785e224a2f16822834f29a3/crates%2Fide_assists%2Fsrc%2Fhandlers%2Ffill_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d81e40e36a7b5451785e224a2f16822834f29a3/crates%2Fide_assists%2Fsrc%2Fhandlers%2Ffill_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Ffill_match_arms.rs?ref=7d81e40e36a7b5451785e224a2f16822834f29a3", "patch": "@@ -1,4 +1,4 @@\n-use std::iter;\n+use std::iter::{self, Peekable};\n \n use either::Either;\n use hir::{Adt, HasSource, ModuleDef, Semantics};\n@@ -63,50 +63,61 @@ pub(crate) fn fill_match_arms(acc: &mut Assists, ctx: &AssistContext) -> Option<\n \n     let module = ctx.sema.scope(expr.syntax()).module()?;\n \n-    let missing_arms: Vec<MatchArm> = if let Some(enum_def) = resolve_enum_def(&ctx.sema, &expr) {\n+    let mut missing_pats: Peekable<Box<dyn Iterator<Item = ast::Pat>>> = if let Some(enum_def) =\n+        resolve_enum_def(&ctx.sema, &expr)\n+    {\n         let variants = enum_def.variants(ctx.db());\n \n-        let mut variants = variants\n+        let missing_pats = variants\n             .into_iter()\n             .filter_map(|variant| build_pat(ctx.db(), module, variant))\n-            .filter(|variant_pat| is_variant_missing(&top_lvl_pats, variant_pat))\n-            .map(|pat| make::match_arm(iter::once(pat), make::expr_empty_block()))\n-            .map(|it| it.clone_for_update())\n-            .collect::<Vec<_>>();\n-        if Some(enum_def)\n-            == FamousDefs(&ctx.sema, Some(module.krate()))\n-                .core_option_Option()\n-                .map(|x| lift_enum(x))\n+            .filter(|variant_pat| is_variant_missing(&top_lvl_pats, variant_pat));\n+\n+        let missing_pats: Box<dyn Iterator<Item = _>> = if Some(enum_def)\n+            == FamousDefs(&ctx.sema, Some(module.krate())).core_option_Option().map(lift_enum)\n         {\n             // Match `Some` variant first.\n             cov_mark::hit!(option_order);\n-            variants.reverse()\n-        }\n-        variants\n+            Box::new(missing_pats.rev())\n+        } else {\n+            Box::new(missing_pats)\n+        };\n+        missing_pats.peekable()\n     } else if let Some(enum_defs) = resolve_tuple_of_enum_def(&ctx.sema, &expr) {\n+        let mut n_arms = 1;\n+        let variants_of_enums: Vec<Vec<ExtendedVariant>> = enum_defs\n+            .into_iter()\n+            .map(|enum_def| enum_def.variants(ctx.db()))\n+            .inspect(|variants| n_arms *= variants.len())\n+            .collect();\n+\n         // When calculating the match arms for a tuple of enums, we want\n         // to create a match arm for each possible combination of enum\n         // values. The `multi_cartesian_product` method transforms\n         // Vec<Vec<EnumVariant>> into Vec<(EnumVariant, .., EnumVariant)>\n         // where each tuple represents a proposed match arm.\n-        enum_defs\n+\n+        // A number of arms grows very fast on even a small tuple of large enums.\n+        // We skip the assist beyond an arbitrary threshold.\n+        if n_arms > 256 {\n+            return None;\n+        }\n+        let missing_pats = variants_of_enums\n             .into_iter()\n-            .map(|enum_def| enum_def.variants(ctx.db()))\n             .multi_cartesian_product()\n+            .inspect(|_| cov_mark::hit!(fill_match_arms_lazy_computation))\n             .map(|variants| {\n                 let patterns =\n                     variants.into_iter().filter_map(|variant| build_pat(ctx.db(), module, variant));\n                 ast::Pat::from(make::tuple_pat(patterns))\n             })\n-            .filter(|variant_pat| is_variant_missing(&top_lvl_pats, variant_pat))\n-            .map(|pat| make::match_arm(iter::once(pat), make::expr_empty_block()))\n-            .map(|it| it.clone_for_update())\n-            .collect()\n+            .filter(|variant_pat| is_variant_missing(&top_lvl_pats, variant_pat));\n+        (Box::new(missing_pats) as Box<dyn Iterator<Item = _>>).peekable()\n     } else {\n         return None;\n     };\n \n-    if missing_arms.is_empty() {\n+    if missing_pats.peek().is_none() {\n         return None;\n     }\n \n@@ -117,6 +128,9 @@ pub(crate) fn fill_match_arms(acc: &mut Assists, ctx: &AssistContext) -> Option<\n         target,\n         |builder| {\n             let new_match_arm_list = match_arm_list.clone_for_update();\n+            let missing_arms = missing_pats\n+                .map(|pat| make::match_arm(iter::once(pat), make::expr_empty_block()))\n+                .map(|it| it.clone_for_update());\n \n             let catch_all_arm = new_match_arm_list\n                 .arms()\n@@ -167,13 +181,13 @@ fn does_pat_match_variant(pat: &Pat, var: &Pat) -> bool {\n     }\n }\n \n-#[derive(Eq, PartialEq, Clone)]\n+#[derive(Eq, PartialEq, Clone, Copy)]\n enum ExtendedEnum {\n     Bool,\n     Enum(hir::Enum),\n }\n \n-#[derive(Eq, PartialEq, Clone)]\n+#[derive(Eq, PartialEq, Clone, Copy)]\n enum ExtendedVariant {\n     True,\n     False,\n@@ -185,7 +199,7 @@ fn lift_enum(e: hir::Enum) -> ExtendedEnum {\n }\n \n impl ExtendedEnum {\n-    fn variants(&self, db: &RootDatabase) -> Vec<ExtendedVariant> {\n+    fn variants(self, db: &RootDatabase) -> Vec<ExtendedVariant> {\n         match self {\n             ExtendedEnum::Enum(e) => {\n                 e.variants(db).into_iter().map(|x| ExtendedVariant::Variant(x)).collect::<Vec<_>>()\n@@ -266,7 +280,9 @@ fn build_pat(db: &RootDatabase, module: hir::Module, var: ExtendedVariant) -> Op\n mod tests {\n     use ide_db::helpers::FamousDefs;\n \n-    use crate::tests::{check_assist, check_assist_not_applicable, check_assist_target};\n+    use crate::tests::{\n+        check_assist, check_assist_not_applicable, check_assist_target, check_assist_unresolved,\n+    };\n \n     use super::fill_match_arms;\n \n@@ -1045,4 +1061,19 @@ fn foo(t: Test) {\n }\"#,\n         );\n     }\n+\n+    #[test]\n+    fn lazy_computation() {\n+        // Computing a single missing arm is enough to determine applicability of the assist.\n+        cov_mark::check_count!(fill_match_arms_lazy_computation, 1);\n+        check_assist_unresolved(\n+            fill_match_arms,\n+            r#\"\n+enum A { One, Two, }\n+fn foo(tuple: (A, A)) {\n+    match $0tuple {};\n+}\n+\"#,\n+        );\n+    }\n }"}, {"sha": "6a9231e07879970fbec81aa96b7f8146bd873c56", "filename": "crates/ide_assists/src/tests.rs", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7d81e40e36a7b5451785e224a2f16822834f29a3/crates%2Fide_assists%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d81e40e36a7b5451785e224a2f16822834f29a3/crates%2Fide_assists%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Ftests.rs?ref=7d81e40e36a7b5451785e224a2f16822834f29a3", "patch": "@@ -65,6 +65,12 @@ pub(crate) fn check_assist_not_applicable(assist: Handler, ra_fixture: &str) {\n     check(assist, ra_fixture, ExpectedResult::NotApplicable, None);\n }\n \n+/// Check assist in unresolved state. Useful to check assists for lazy computation.\n+#[track_caller]\n+pub(crate) fn check_assist_unresolved(assist: Handler, ra_fixture: &str) {\n+    check(assist, ra_fixture, ExpectedResult::Unresolved, None);\n+}\n+\n #[track_caller]\n fn check_doc_test(assist_id: &str, before: &str, after: &str) {\n     let after = trim_indent(after);\n@@ -101,6 +107,7 @@ fn check_doc_test(assist_id: &str, before: &str, after: &str) {\n \n enum ExpectedResult<'a> {\n     NotApplicable,\n+    Unresolved,\n     After(&'a str),\n     Target(&'a str),\n }\n@@ -115,7 +122,11 @@ fn check(handler: Handler, before: &str, expected: ExpectedResult, assist_label:\n     let sema = Semantics::new(&db);\n     let config = TEST_CONFIG;\n     let ctx = AssistContext::new(sema, &config, frange);\n-    let mut acc = Assists::new(&ctx, AssistResolveStrategy::All);\n+    let resolve = match expected {\n+        ExpectedResult::Unresolved => AssistResolveStrategy::None,\n+        _ => AssistResolveStrategy::All,\n+    };\n+    let mut acc = Assists::new(&ctx, resolve);\n     handler(&mut acc, &ctx);\n     let mut res = acc.finish();\n \n@@ -163,8 +174,14 @@ fn check(handler: Handler, before: &str, expected: ExpectedResult, assist_label:\n             let range = assist.target;\n             assert_eq_text!(&text_without_caret[range], target);\n         }\n+        (Some(assist), ExpectedResult::Unresolved) => assert!(\n+            assist.source_change.is_none(),\n+            \"unresolved assist should not contain source changes\"\n+        ),\n         (Some(_), ExpectedResult::NotApplicable) => panic!(\"assist should not be applicable!\"),\n-        (None, ExpectedResult::After(_)) | (None, ExpectedResult::Target(_)) => {\n+        (None, ExpectedResult::After(_))\n+        | (None, ExpectedResult::Target(_))\n+        | (None, ExpectedResult::Unresolved) => {\n             panic!(\"code action is not applicable\")\n         }\n         (None, ExpectedResult::NotApplicable) => (),"}]}