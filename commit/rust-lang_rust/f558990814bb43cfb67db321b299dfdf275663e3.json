{"sha": "f558990814bb43cfb67db321b299dfdf275663e3", "node_id": "C_kwDOAAsO6NoAKGY1NTg5OTA4MTRiYjQzY2ZiNjdkYjMyMWIyOTlkZmRmMjc1NjYzZTM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-27T06:09:45Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-27T06:09:45Z"}, "message": "Auto merge of #97004 - nnethercote:proc-macro-tweaks, r=eddyb\n\nProc macro tweaks\n\nVarious improvements I spotted while looking through the proc macro code.\n\nr? `@eddyb`", "tree": {"sha": "5eb50a9016a8bca98e97ef86b1155b81621efe71", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5eb50a9016a8bca98e97ef86b1155b81621efe71"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f558990814bb43cfb67db321b299dfdf275663e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f558990814bb43cfb67db321b299dfdf275663e3", "html_url": "https://github.com/rust-lang/rust/commit/f558990814bb43cfb67db321b299dfdf275663e3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f558990814bb43cfb67db321b299dfdf275663e3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9a42c6509d399fd205917ebce474b31315c5d3e9", "url": "https://api.github.com/repos/rust-lang/rust/commits/9a42c6509d399fd205917ebce474b31315c5d3e9", "html_url": "https://github.com/rust-lang/rust/commit/9a42c6509d399fd205917ebce474b31315c5d3e9"}, {"sha": "41c10dde95b447b160a39ae2b7ebfd81faad5e0a", "url": "https://api.github.com/repos/rust-lang/rust/commits/41c10dde95b447b160a39ae2b7ebfd81faad5e0a", "html_url": "https://github.com/rust-lang/rust/commit/41c10dde95b447b160a39ae2b7ebfd81faad5e0a"}], "stats": {"total": 287, "additions": 139, "deletions": 148}, "files": [{"sha": "71e98bb447a7c7b2618ea7b1871db83d92385c9f", "filename": "compiler/rustc_builtin_macros/src/proc_macro_harness.rs", "status": "modified", "additions": 17, "deletions": 27, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/f558990814bb43cfb67db321b299dfdf275663e3/compiler%2Frustc_builtin_macros%2Fsrc%2Fproc_macro_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f558990814bb43cfb67db321b299dfdf275663e3/compiler%2Frustc_builtin_macros%2Fsrc%2Fproc_macro_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fproc_macro_harness.rs?ref=f558990814bb43cfb67db321b299dfdf275663e3", "patch": "@@ -22,21 +22,16 @@ struct ProcMacroDerive {\n     attrs: Vec<Symbol>,\n }\n \n-enum ProcMacroDefType {\n-    Attr,\n-    Bang,\n-}\n-\n struct ProcMacroDef {\n     id: NodeId,\n     function_name: Ident,\n     span: Span,\n-    def_type: ProcMacroDefType,\n }\n \n enum ProcMacro {\n     Derive(ProcMacroDerive),\n-    Def(ProcMacroDef),\n+    Attr(ProcMacroDef),\n+    Bang(ProcMacroDef),\n }\n \n struct CollectProcMacros<'a> {\n@@ -128,11 +123,10 @@ impl<'a> CollectProcMacros<'a> {\n \n     fn collect_attr_proc_macro(&mut self, item: &'a ast::Item) {\n         if self.in_root && item.vis.kind.is_pub() {\n-            self.macros.push(ProcMacro::Def(ProcMacroDef {\n+            self.macros.push(ProcMacro::Attr(ProcMacroDef {\n                 id: item.id,\n                 span: item.span,\n                 function_name: item.ident,\n-                def_type: ProcMacroDefType::Attr,\n             }));\n         } else {\n             let msg = if !self.in_root {\n@@ -147,11 +141,10 @@ impl<'a> CollectProcMacros<'a> {\n \n     fn collect_bang_proc_macro(&mut self, item: &'a ast::Item) {\n         if self.in_root && item.vis.kind.is_pub() {\n-            self.macros.push(ProcMacro::Def(ProcMacroDef {\n+            self.macros.push(ProcMacro::Bang(ProcMacroDef {\n                 id: item.id,\n                 span: item.span,\n                 function_name: item.ident,\n-                def_type: ProcMacroDefType::Bang,\n             }));\n         } else {\n             let msg = if !self.in_root {\n@@ -308,6 +301,17 @@ fn mk_decls(cx: &mut ExtCtxt<'_>, macros: &[ProcMacro]) -> P<ast::Item> {\n         let proc_macro_ty_method_path = |cx: &ExtCtxt<'_>, method| {\n             cx.expr_path(cx.path(span, vec![proc_macro, bridge, client, proc_macro_ty, method]))\n         };\n+        let attr_or_bang = |cx: &mut ExtCtxt<'_>, ca: &ProcMacroDef, ident| {\n+            cx.resolver.declare_proc_macro(ca.id);\n+            cx.expr_call(\n+                span,\n+                proc_macro_ty_method_path(cx, ident),\n+                vec![\n+                    cx.expr_str(ca.span, ca.function_name.name),\n+                    local_path(cx, ca.span, ca.function_name),\n+                ],\n+            )\n+        };\n         macros\n             .iter()\n             .map(|m| match m {\n@@ -329,22 +333,8 @@ fn mk_decls(cx: &mut ExtCtxt<'_>, macros: &[ProcMacro]) -> P<ast::Item> {\n                         ],\n                     )\n                 }\n-                ProcMacro::Def(ca) => {\n-                    cx.resolver.declare_proc_macro(ca.id);\n-                    let ident = match ca.def_type {\n-                        ProcMacroDefType::Attr => attr,\n-                        ProcMacroDefType::Bang => bang,\n-                    };\n-\n-                    cx.expr_call(\n-                        span,\n-                        proc_macro_ty_method_path(cx, ident),\n-                        vec![\n-                            cx.expr_str(ca.span, ca.function_name.name),\n-                            local_path(cx, ca.span, ca.function_name),\n-                        ],\n-                    )\n-                }\n+                ProcMacro::Attr(ca) => attr_or_bang(cx, &ca, attr),\n+                ProcMacro::Bang(ca) => attr_or_bang(cx, &ca, bang),\n             })\n             .collect()\n     };"}, {"sha": "bb671b8705eb3d3fcd4ff6bb2ec28f737325ed33", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f558990814bb43cfb67db321b299dfdf275663e3/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f558990814bb43cfb67db321b299dfdf275663e3/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=f558990814bb43cfb67db321b299dfdf275663e3", "patch": "@@ -266,7 +266,7 @@ where\n     }\n }\n \n-pub trait ProcMacro {\n+pub trait BangProcMacro {\n     fn expand<'cx>(\n         &self,\n         ecx: &'cx mut ExtCtxt<'_>,\n@@ -275,7 +275,7 @@ pub trait ProcMacro {\n     ) -> Result<TokenStream, ErrorGuaranteed>;\n }\n \n-impl<F> ProcMacro for F\n+impl<F> BangProcMacro for F\n where\n     F: Fn(TokenStream) -> TokenStream,\n {\n@@ -640,7 +640,7 @@ pub enum SyntaxExtensionKind {\n     /// A token-based function-like macro.\n     Bang(\n         /// An expander with signature TokenStream -> TokenStream.\n-        Box<dyn ProcMacro + sync::Sync + sync::Send>,\n+        Box<dyn BangProcMacro + sync::Sync + sync::Send>,\n     ),\n \n     /// An AST-based function-like macro."}, {"sha": "eb59c5a18549210c2ef99669913b17b9e8ab6996", "filename": "compiler/rustc_expand/src/proc_macro.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f558990814bb43cfb67db321b299dfdf275663e3/compiler%2Frustc_expand%2Fsrc%2Fproc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f558990814bb43cfb67db321b299dfdf275663e3/compiler%2Frustc_expand%2Fsrc%2Fproc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fproc_macro.rs?ref=f558990814bb43cfb67db321b299dfdf275663e3", "patch": "@@ -17,7 +17,7 @@ pub struct BangProcMacro {\n     pub client: pm::bridge::client::Client<fn(pm::TokenStream) -> pm::TokenStream>,\n }\n \n-impl base::ProcMacro for BangProcMacro {\n+impl base::BangProcMacro for BangProcMacro {\n     fn expand<'cx>(\n         &self,\n         ecx: &'cx mut ExtCtxt<'_>,\n@@ -72,11 +72,11 @@ impl base::AttrProcMacro for AttrProcMacro {\n     }\n }\n \n-pub struct ProcMacroDerive {\n+pub struct DeriveProcMacro {\n     pub client: pm::bridge::client::Client<fn(pm::TokenStream) -> pm::TokenStream>,\n }\n \n-impl MultiItemModifier for ProcMacroDerive {\n+impl MultiItemModifier for DeriveProcMacro {\n     fn expand(\n         &self,\n         ecx: &mut ExtCtxt<'_>,"}, {"sha": "7f0b595347f495af8380447bb2ce5962ab956702", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f558990814bb43cfb67db321b299dfdf275663e3/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f558990814bb43cfb67db321b299dfdf275663e3/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=f558990814bb43cfb67db321b299dfdf275663e3", "patch": "@@ -11,7 +11,7 @@ use rustc_data_structures::svh::Svh;\n use rustc_data_structures::sync::{Lock, LockGuard, Lrc, OnceCell};\n use rustc_data_structures::unhash::UnhashMap;\n use rustc_expand::base::{SyntaxExtension, SyntaxExtensionKind};\n-use rustc_expand::proc_macro::{AttrProcMacro, BangProcMacro, ProcMacroDerive};\n+use rustc_expand::proc_macro::{AttrProcMacro, BangProcMacro, DeriveProcMacro};\n use rustc_hir::def::{CtorKind, CtorOf, DefKind, Res};\n use rustc_hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc_hir::definitions::{DefKey, DefPath, DefPathData, DefPathHash};\n@@ -837,7 +837,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n                     attributes.iter().cloned().map(Symbol::intern).collect::<Vec<_>>();\n                 (\n                     trait_name,\n-                    SyntaxExtensionKind::Derive(Box::new(ProcMacroDerive { client })),\n+                    SyntaxExtensionKind::Derive(Box::new(DeriveProcMacro { client })),\n                     helper_attrs,\n                 )\n             }"}, {"sha": "fb05a02dc4571e4cf1ba9215fd8cb93a6a5cc0b9", "filename": "library/proc_macro/src/bridge/buffer.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/f558990814bb43cfb67db321b299dfdf275663e3/library%2Fproc_macro%2Fsrc%2Fbridge%2Fbuffer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f558990814bb43cfb67db321b299dfdf275663e3/library%2Fproc_macro%2Fsrc%2Fbridge%2Fbuffer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Fbridge%2Fbuffer.rs?ref=f558990814bb43cfb67db321b299dfdf275663e3", "patch": "@@ -6,37 +6,37 @@ use std::ops::{Deref, DerefMut};\n use std::slice;\n \n #[repr(C)]\n-pub struct Buffer<T: Copy> {\n-    data: *mut T,\n+pub struct Buffer {\n+    data: *mut u8,\n     len: usize,\n     capacity: usize,\n-    reserve: extern \"C\" fn(Buffer<T>, usize) -> Buffer<T>,\n-    drop: extern \"C\" fn(Buffer<T>),\n+    reserve: extern \"C\" fn(Buffer, usize) -> Buffer,\n+    drop: extern \"C\" fn(Buffer),\n }\n \n-unsafe impl<T: Copy + Sync> Sync for Buffer<T> {}\n-unsafe impl<T: Copy + Send> Send for Buffer<T> {}\n+unsafe impl Sync for Buffer {}\n+unsafe impl Send for Buffer {}\n \n-impl<T: Copy> Default for Buffer<T> {\n+impl Default for Buffer {\n     fn default() -> Self {\n         Self::from(vec![])\n     }\n }\n \n-impl<T: Copy> Deref for Buffer<T> {\n-    type Target = [T];\n-    fn deref(&self) -> &[T] {\n-        unsafe { slice::from_raw_parts(self.data as *const T, self.len) }\n+impl Deref for Buffer {\n+    type Target = [u8];\n+    fn deref(&self) -> &[u8] {\n+        unsafe { slice::from_raw_parts(self.data as *const u8, self.len) }\n     }\n }\n \n-impl<T: Copy> DerefMut for Buffer<T> {\n-    fn deref_mut(&mut self) -> &mut [T] {\n+impl DerefMut for Buffer {\n+    fn deref_mut(&mut self) -> &mut [u8] {\n         unsafe { slice::from_raw_parts_mut(self.data, self.len) }\n     }\n }\n \n-impl<T: Copy> Buffer<T> {\n+impl Buffer {\n     pub(super) fn new() -> Self {\n         Self::default()\n     }\n@@ -53,7 +53,7 @@ impl<T: Copy> Buffer<T> {\n     // because in the case of small arrays, codegen can be more efficient\n     // (avoiding a memmove call). With extend_from_slice, LLVM at least\n     // currently is not able to make that optimization.\n-    pub(super) fn extend_from_array<const N: usize>(&mut self, xs: &[T; N]) {\n+    pub(super) fn extend_from_array<const N: usize>(&mut self, xs: &[u8; N]) {\n         if xs.len() > (self.capacity - self.len) {\n             let b = self.take();\n             *self = (b.reserve)(b, xs.len());\n@@ -64,7 +64,7 @@ impl<T: Copy> Buffer<T> {\n         }\n     }\n \n-    pub(super) fn extend_from_slice(&mut self, xs: &[T]) {\n+    pub(super) fn extend_from_slice(&mut self, xs: &[u8]) {\n         if xs.len() > (self.capacity - self.len) {\n             let b = self.take();\n             *self = (b.reserve)(b, xs.len());\n@@ -75,7 +75,7 @@ impl<T: Copy> Buffer<T> {\n         }\n     }\n \n-    pub(super) fn push(&mut self, v: T) {\n+    pub(super) fn push(&mut self, v: u8) {\n         // The code here is taken from Vec::push, and we know that reserve()\n         // will panic if we're exceeding isize::MAX bytes and so there's no need\n         // to check for overflow.\n@@ -90,7 +90,7 @@ impl<T: Copy> Buffer<T> {\n     }\n }\n \n-impl Write for Buffer<u8> {\n+impl Write for Buffer {\n     fn write(&mut self, xs: &[u8]) -> io::Result<usize> {\n         self.extend_from_slice(xs);\n         Ok(xs.len())\n@@ -106,35 +106,35 @@ impl Write for Buffer<u8> {\n     }\n }\n \n-impl<T: Copy> Drop for Buffer<T> {\n+impl Drop for Buffer {\n     fn drop(&mut self) {\n         let b = self.take();\n         (b.drop)(b);\n     }\n }\n \n-impl<T: Copy> From<Vec<T>> for Buffer<T> {\n-    fn from(mut v: Vec<T>) -> Self {\n+impl From<Vec<u8>> for Buffer {\n+    fn from(mut v: Vec<u8>) -> Self {\n         let (data, len, capacity) = (v.as_mut_ptr(), v.len(), v.capacity());\n         mem::forget(v);\n \n         // This utility function is nested in here because it can *only*\n         // be safely called on `Buffer`s created by *this* `proc_macro`.\n-        fn to_vec<T: Copy>(b: Buffer<T>) -> Vec<T> {\n+        fn to_vec(b: Buffer) -> Vec<u8> {\n             unsafe {\n                 let Buffer { data, len, capacity, .. } = b;\n                 mem::forget(b);\n                 Vec::from_raw_parts(data, len, capacity)\n             }\n         }\n \n-        extern \"C\" fn reserve<T: Copy>(b: Buffer<T>, additional: usize) -> Buffer<T> {\n+        extern \"C\" fn reserve(b: Buffer, additional: usize) -> Buffer {\n             let mut v = to_vec(b);\n             v.reserve(additional);\n             Buffer::from(v)\n         }\n \n-        extern \"C\" fn drop<T: Copy>(b: Buffer<T>) {\n+        extern \"C\" fn drop(b: Buffer) {\n             mem::drop(to_vec(b));\n         }\n "}, {"sha": "54d92ff5767f2b3b19d9255b29d05779233901b1", "filename": "library/proc_macro/src/bridge/client.rs", "status": "modified", "additions": 27, "deletions": 23, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/f558990814bb43cfb67db321b299dfdf275663e3/library%2Fproc_macro%2Fsrc%2Fbridge%2Fclient.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f558990814bb43cfb67db321b299dfdf275663e3/library%2Fproc_macro%2Fsrc%2Fbridge%2Fclient.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Fbridge%2Fclient.rs?ref=f558990814bb43cfb67db321b299dfdf275663e3", "patch": "@@ -49,7 +49,9 @@ macro_rules! define_handles {\n             #[repr(C)]\n             pub(crate) struct $oty {\n                 handle: handle::Handle,\n-                // Prevent Send and Sync impls\n+                // Prevent Send and Sync impls. `!Send`/`!Sync` is the usual\n+                // way of doing this, but that requires unstable features.\n+                // rust-analyzer uses this code and avoids unstable features.\n                 _marker: PhantomData<*mut ()>,\n             }\n \n@@ -133,7 +135,9 @@ macro_rules! define_handles {\n             #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n             pub(crate) struct $ity {\n                 handle: handle::Handle,\n-                // Prevent Send and Sync impls\n+                // Prevent Send and Sync impls. `!Send`/`!Sync` is the usual\n+                // way of doing this, but that requires unstable features.\n+                // rust-analyzer uses this code and avoids unstable features.\n                 _marker: PhantomData<*mut ()>,\n             }\n \n@@ -191,7 +195,7 @@ define_handles! {\n // FIXME(eddyb) generate these impls by pattern-matching on the\n // names of methods - also could use the presence of `fn drop`\n // to distinguish between 'owned and 'interned, above.\n-// Alternatively, special 'modes\" could be listed of types in with_api\n+// Alternatively, special \"modes\" could be listed of types in with_api\n // instead of pattern matching on methods, here and in server decl.\n \n impl Clone for TokenStream {\n@@ -250,17 +254,17 @@ macro_rules! define_client_side {\n         $(impl $name {\n             $(pub(crate) fn $method($($arg: $arg_ty),*) $(-> $ret_ty)* {\n                 Bridge::with(|bridge| {\n-                    let mut b = bridge.cached_buffer.take();\n+                    let mut buf = bridge.cached_buffer.take();\n \n-                    b.clear();\n-                    api_tags::Method::$name(api_tags::$name::$method).encode(&mut b, &mut ());\n-                    reverse_encode!(b; $($arg),*);\n+                    buf.clear();\n+                    api_tags::Method::$name(api_tags::$name::$method).encode(&mut buf, &mut ());\n+                    reverse_encode!(buf; $($arg),*);\n \n-                    b = bridge.dispatch.call(b);\n+                    buf = bridge.dispatch.call(buf);\n \n-                    let r = Result::<_, PanicMessage>::decode(&mut &b[..], &mut ());\n+                    let r = Result::<_, PanicMessage>::decode(&mut &buf[..], &mut ());\n \n-                    bridge.cached_buffer = b;\n+                    bridge.cached_buffer = buf;\n \n                     r.unwrap_or_else(|e| panic::resume_unwind(e.into()))\n                 })\n@@ -367,7 +371,7 @@ pub struct Client<F> {\n     // FIXME(eddyb) use a reference to the `static COUNTERS`, instead of\n     // a wrapper `fn` pointer, once `const fn` can reference `static`s.\n     pub(super) get_handle_counters: extern \"C\" fn() -> &'static HandleCounters,\n-    pub(super) run: extern \"C\" fn(Bridge<'_>, F) -> Buffer<u8>,\n+    pub(super) run: extern \"C\" fn(Bridge<'_>, F) -> Buffer,\n     pub(super) f: F,\n }\n \n@@ -377,22 +381,22 @@ pub struct Client<F> {\n fn run_client<A: for<'a, 's> DecodeMut<'a, 's, ()>, R: Encode<()>>(\n     mut bridge: Bridge<'_>,\n     f: impl FnOnce(A) -> R,\n-) -> Buffer<u8> {\n+) -> Buffer {\n     // The initial `cached_buffer` contains the input.\n-    let mut b = bridge.cached_buffer.take();\n+    let mut buf = bridge.cached_buffer.take();\n \n     panic::catch_unwind(panic::AssertUnwindSafe(|| {\n         bridge.enter(|| {\n-            let reader = &mut &b[..];\n+            let reader = &mut &buf[..];\n             let input = A::decode(reader, &mut ());\n \n             // Put the `cached_buffer` back in the `Bridge`, for requests.\n-            Bridge::with(|bridge| bridge.cached_buffer = b.take());\n+            Bridge::with(|bridge| bridge.cached_buffer = buf.take());\n \n             let output = f(input);\n \n             // Take the `cached_buffer` back out, for the output value.\n-            b = Bridge::with(|bridge| bridge.cached_buffer.take());\n+            buf = Bridge::with(|bridge| bridge.cached_buffer.take());\n \n             // HACK(eddyb) Separate encoding a success value (`Ok(output)`)\n             // from encoding a panic (`Err(e: PanicMessage)`) to avoid\n@@ -403,24 +407,24 @@ fn run_client<A: for<'a, 's> DecodeMut<'a, 's, ()>, R: Encode<()>>(\n             // this is defensively trying to avoid any accidental panicking\n             // reaching the `extern \"C\"` (which should `abort` but might not\n             // at the moment, so this is also potentially preventing UB).\n-            b.clear();\n-            Ok::<_, ()>(output).encode(&mut b, &mut ());\n+            buf.clear();\n+            Ok::<_, ()>(output).encode(&mut buf, &mut ());\n         })\n     }))\n     .map_err(PanicMessage::from)\n     .unwrap_or_else(|e| {\n-        b.clear();\n-        Err::<(), _>(e).encode(&mut b, &mut ());\n+        buf.clear();\n+        Err::<(), _>(e).encode(&mut buf, &mut ());\n     });\n-    b\n+    buf\n }\n \n impl Client<fn(crate::TokenStream) -> crate::TokenStream> {\n     pub const fn expand1(f: fn(crate::TokenStream) -> crate::TokenStream) -> Self {\n         extern \"C\" fn run(\n             bridge: Bridge<'_>,\n             f: impl FnOnce(crate::TokenStream) -> crate::TokenStream,\n-        ) -> Buffer<u8> {\n+        ) -> Buffer {\n             run_client(bridge, |input| f(crate::TokenStream(input)).0)\n         }\n         Client { get_handle_counters: HandleCounters::get, run, f }\n@@ -434,7 +438,7 @@ impl Client<fn(crate::TokenStream, crate::TokenStream) -> crate::TokenStream> {\n         extern \"C\" fn run(\n             bridge: Bridge<'_>,\n             f: impl FnOnce(crate::TokenStream, crate::TokenStream) -> crate::TokenStream,\n-        ) -> Buffer<u8> {\n+        ) -> Buffer {\n             run_client(bridge, |(input, input2)| {\n                 f(crate::TokenStream(input), crate::TokenStream(input2)).0\n             })"}, {"sha": "d371ae3cea0981a01f38cb261fc39e203b495130", "filename": "library/proc_macro/src/bridge/closure.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f558990814bb43cfb67db321b299dfdf275663e3/library%2Fproc_macro%2Fsrc%2Fbridge%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f558990814bb43cfb67db321b299dfdf275663e3/library%2Fproc_macro%2Fsrc%2Fbridge%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Fbridge%2Fclosure.rs?ref=f558990814bb43cfb67db321b299dfdf275663e3", "patch": "@@ -6,7 +6,11 @@ use std::marker::PhantomData;\n pub struct Closure<'a, A, R> {\n     call: unsafe extern \"C\" fn(*mut Env, A) -> R,\n     env: *mut Env,\n-    // Ensure Closure is !Send and !Sync\n+    // Prevent Send and Sync impls. `!Send`/`!Sync` is the usual way of doing\n+    // this, but that requires unstable features. rust-analyzer uses this code\n+    // and avoids unstable features.\n+    //\n+    // The `'a` lifetime parameter represents the lifetime of `Env`.\n     _marker: PhantomData<*mut &'a mut ()>,\n }\n "}, {"sha": "7d6adda48ec6e4f21102937b9c49b810654fb316", "filename": "library/proc_macro/src/bridge/handle.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f558990814bb43cfb67db321b299dfdf275663e3/library%2Fproc_macro%2Fsrc%2Fbridge%2Fhandle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f558990814bb43cfb67db321b299dfdf275663e3/library%2Fproc_macro%2Fsrc%2Fbridge%2Fhandle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Fbridge%2Fhandle.rs?ref=f558990814bb43cfb67db321b299dfdf275663e3", "patch": "@@ -8,6 +8,8 @@ use std::sync::atomic::{AtomicUsize, Ordering};\n \n pub(super) type Handle = NonZeroU32;\n \n+/// A store that associates values of type `T` with numeric handles. A value can\n+/// be looked up using its handle.\n pub(super) struct OwnedStore<T: 'static> {\n     counter: &'static AtomicUsize,\n     data: BTreeMap<Handle, T>,\n@@ -49,6 +51,7 @@ impl<T> IndexMut<Handle> for OwnedStore<T> {\n     }\n }\n \n+/// Like `OwnedStore`, but avoids storing any value more than once.\n pub(super) struct InternedStore<T: 'static> {\n     owned: OwnedStore<T>,\n     interner: HashMap<T, Handle>,"}, {"sha": "babb1cbac70b550eb475de2aeb47c17479ce8be0", "filename": "library/proc_macro/src/bridge/mod.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f558990814bb43cfb67db321b299dfdf275663e3/library%2Fproc_macro%2Fsrc%2Fbridge%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f558990814bb43cfb67db321b299dfdf275663e3/library%2Fproc_macro%2Fsrc%2Fbridge%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Fbridge%2Fmod.rs?ref=f558990814bb43cfb67db321b299dfdf275663e3", "patch": "@@ -176,7 +176,7 @@ macro_rules! with_api {\n }\n \n // FIXME(eddyb) this calls `encode` for each argument, but in reverse,\n-// to avoid borrow conflicts from borrows started by `&mut` arguments.\n+// to match the ordering in `reverse_decode`.\n macro_rules! reverse_encode {\n     ($writer:ident;) => {};\n     ($writer:ident; $first:ident $(, $rest:ident)*) => {\n@@ -224,15 +224,17 @@ use rpc::{Decode, DecodeMut, Encode, Reader, Writer};\n pub struct Bridge<'a> {\n     /// Reusable buffer (only `clear`-ed, never shrunk), primarily\n     /// used for making requests, but also for passing input to client.\n-    cached_buffer: Buffer<u8>,\n+    cached_buffer: Buffer,\n \n     /// Server-side function that the client uses to make requests.\n-    dispatch: closure::Closure<'a, Buffer<u8>, Buffer<u8>>,\n+    dispatch: closure::Closure<'a, Buffer, Buffer>,\n \n     /// If 'true', always invoke the default panic hook\n     force_show_panics: bool,\n \n-    // Prevent Send and Sync impls\n+    // Prevent Send and Sync impls. `!Send`/`!Sync` is the usual way of doing\n+    // this, but that requires unstable features. rust-analyzer uses this code\n+    // and avoids unstable features.\n     _marker: marker::PhantomData<*mut ()>,\n }\n \n@@ -252,7 +254,6 @@ mod api_tags {\n                 rpc_encode_decode!(enum $name { $($method),* });\n             )*\n \n-\n             pub(super) enum Method {\n                 $($name($name)),*\n             }"}, {"sha": "f79e016400fb1a5d30608084665d26a38eada924", "filename": "library/proc_macro/src/bridge/rpc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f558990814bb43cfb67db321b299dfdf275663e3/library%2Fproc_macro%2Fsrc%2Fbridge%2Frpc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f558990814bb43cfb67db321b299dfdf275663e3/library%2Fproc_macro%2Fsrc%2Fbridge%2Frpc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Fbridge%2Frpc.rs?ref=f558990814bb43cfb67db321b299dfdf275663e3", "patch": "@@ -7,7 +7,7 @@ use std::num::NonZeroU32;\n use std::ops::Bound;\n use std::str;\n \n-pub(super) type Writer = super::buffer::Buffer<u8>;\n+pub(super) type Writer = super::buffer::Buffer;\n \n pub(super) trait Encode<S>: Sized {\n     fn encode(self, w: &mut Writer, s: &mut S);"}, {"sha": "12c754682a0ef97eda22f449a541a8609148b788", "filename": "library/proc_macro/src/bridge/server.rs", "status": "modified", "additions": 48, "deletions": 59, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/f558990814bb43cfb67db321b299dfdf275663e3/library%2Fproc_macro%2Fsrc%2Fbridge%2Fserver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f558990814bb43cfb67db321b299dfdf275663e3/library%2Fproc_macro%2Fsrc%2Fbridge%2Fserver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Fbridge%2Fserver.rs?ref=f558990814bb43cfb67db321b299dfdf275663e3", "patch": "@@ -5,50 +5,39 @@ use super::*;\n // FIXME(eddyb) generate the definition of `HandleStore` in `server.rs`.\n use super::client::HandleStore;\n \n-/// Declare an associated item of one of the traits below, optionally\n-/// adjusting it (i.e., adding bounds to types and default bodies to methods).\n-macro_rules! associated_item {\n-    (type FreeFunctions) =>\n-        (type FreeFunctions: 'static;);\n-    (type TokenStream) =>\n-        (type TokenStream: 'static + Clone;);\n-    (type TokenStreamBuilder) =>\n-        (type TokenStreamBuilder: 'static;);\n-    (type TokenStreamIter) =>\n-        (type TokenStreamIter: 'static + Clone;);\n-    (type Group) =>\n-        (type Group: 'static + Clone;);\n-    (type Punct) =>\n-        (type Punct: 'static + Copy + Eq + Hash;);\n-    (type Ident) =>\n-        (type Ident: 'static + Copy + Eq + Hash;);\n-    (type Literal) =>\n-        (type Literal: 'static + Clone;);\n-    (type SourceFile) =>\n-        (type SourceFile: 'static + Clone;);\n-    (type MultiSpan) =>\n-        (type MultiSpan: 'static;);\n-    (type Diagnostic) =>\n-        (type Diagnostic: 'static;);\n-    (type Span) =>\n-        (type Span: 'static + Copy + Eq + Hash;);\n+pub trait Types {\n+    type FreeFunctions: 'static;\n+    type TokenStream: 'static + Clone;\n+    type TokenStreamBuilder: 'static;\n+    type TokenStreamIter: 'static + Clone;\n+    type Group: 'static + Clone;\n+    type Punct: 'static + Copy + Eq + Hash;\n+    type Ident: 'static + Copy + Eq + Hash;\n+    type Literal: 'static + Clone;\n+    type SourceFile: 'static + Clone;\n+    type MultiSpan: 'static;\n+    type Diagnostic: 'static;\n+    type Span: 'static + Copy + Eq + Hash;\n+}\n+\n+/// Declare an associated fn of one of the traits below, adding necessary\n+/// default bodies.\n+macro_rules! associated_fn {\n     (fn drop(&mut self, $arg:ident: $arg_ty:ty)) =>\n         (fn drop(&mut self, $arg: $arg_ty) { mem::drop($arg) });\n+\n     (fn clone(&mut self, $arg:ident: $arg_ty:ty) -> $ret_ty:ty) =>\n         (fn clone(&mut self, $arg: $arg_ty) -> $ret_ty { $arg.clone() });\n+\n     ($($item:tt)*) => ($($item)*;)\n }\n \n macro_rules! declare_server_traits {\n     ($($name:ident {\n         $(fn $method:ident($($arg:ident: $arg_ty:ty),* $(,)?) $(-> $ret_ty:ty)?;)*\n     }),* $(,)?) => {\n-        pub trait Types {\n-            $(associated_item!(type $name);)*\n-        }\n-\n         $(pub trait $name: Types {\n-            $(associated_item!(fn $method(&mut self, $($arg: $arg_ty),*) $(-> $ret_ty)?);)*\n+            $(associated_fn!(fn $method(&mut self, $($arg: $arg_ty),*) $(-> $ret_ty)?);)*\n         })*\n \n         pub trait Server: Types $(+ $name)* {}\n@@ -89,15 +78,15 @@ macro_rules! define_dispatcher_impl {\n         pub trait DispatcherTrait {\n             // HACK(eddyb) these are here to allow `Self::$name` to work below.\n             $(type $name;)*\n-            fn dispatch(&mut self, b: Buffer<u8>) -> Buffer<u8>;\n+            fn dispatch(&mut self, buf: Buffer) -> Buffer;\n         }\n \n         impl<S: Server> DispatcherTrait for Dispatcher<MarkedTypes<S>> {\n             $(type $name = <MarkedTypes<S> as Types>::$name;)*\n-            fn dispatch(&mut self, mut b: Buffer<u8>) -> Buffer<u8> {\n+            fn dispatch(&mut self, mut buf: Buffer) -> Buffer {\n                 let Dispatcher { handle_store, server } = self;\n \n-                let mut reader = &b[..];\n+                let mut reader = &buf[..];\n                 match api_tags::Method::decode(&mut reader, &mut ()) {\n                     $(api_tags::Method::$name(m) => match m {\n                         $(api_tags::$name::$method => {\n@@ -116,12 +105,12 @@ macro_rules! define_dispatcher_impl {\n                                     .map_err(PanicMessage::from)\n                             };\n \n-                            b.clear();\n-                            r.encode(&mut b, handle_store);\n+                            buf.clear();\n+                            r.encode(&mut buf, handle_store);\n                         })*\n                     }),*\n                 }\n-                b\n+                buf\n             }\n         }\n     }\n@@ -132,11 +121,11 @@ pub trait ExecutionStrategy {\n     fn run_bridge_and_client<D: Copy + Send + 'static>(\n         &self,\n         dispatcher: &mut impl DispatcherTrait,\n-        input: Buffer<u8>,\n-        run_client: extern \"C\" fn(Bridge<'_>, D) -> Buffer<u8>,\n+        input: Buffer,\n+        run_client: extern \"C\" fn(Bridge<'_>, D) -> Buffer,\n         client_data: D,\n         force_show_panics: bool,\n-    ) -> Buffer<u8>;\n+    ) -> Buffer;\n }\n \n pub struct SameThread;\n@@ -145,12 +134,12 @@ impl ExecutionStrategy for SameThread {\n     fn run_bridge_and_client<D: Copy + Send + 'static>(\n         &self,\n         dispatcher: &mut impl DispatcherTrait,\n-        input: Buffer<u8>,\n-        run_client: extern \"C\" fn(Bridge<'_>, D) -> Buffer<u8>,\n+        input: Buffer,\n+        run_client: extern \"C\" fn(Bridge<'_>, D) -> Buffer,\n         client_data: D,\n         force_show_panics: bool,\n-    ) -> Buffer<u8> {\n-        let mut dispatch = |b| dispatcher.dispatch(b);\n+    ) -> Buffer {\n+        let mut dispatch = |buf| dispatcher.dispatch(buf);\n \n         run_client(\n             Bridge {\n@@ -173,19 +162,19 @@ impl ExecutionStrategy for CrossThread1 {\n     fn run_bridge_and_client<D: Copy + Send + 'static>(\n         &self,\n         dispatcher: &mut impl DispatcherTrait,\n-        input: Buffer<u8>,\n-        run_client: extern \"C\" fn(Bridge<'_>, D) -> Buffer<u8>,\n+        input: Buffer,\n+        run_client: extern \"C\" fn(Bridge<'_>, D) -> Buffer,\n         client_data: D,\n         force_show_panics: bool,\n-    ) -> Buffer<u8> {\n+    ) -> Buffer {\n         use std::sync::mpsc::channel;\n \n         let (req_tx, req_rx) = channel();\n         let (res_tx, res_rx) = channel();\n \n         let join_handle = thread::spawn(move || {\n-            let mut dispatch = |b| {\n-                req_tx.send(b).unwrap();\n+            let mut dispatch = |buf| {\n+                req_tx.send(buf).unwrap();\n                 res_rx.recv().unwrap()\n             };\n \n@@ -214,11 +203,11 @@ impl ExecutionStrategy for CrossThread2 {\n     fn run_bridge_and_client<D: Copy + Send + 'static>(\n         &self,\n         dispatcher: &mut impl DispatcherTrait,\n-        input: Buffer<u8>,\n-        run_client: extern \"C\" fn(Bridge<'_>, D) -> Buffer<u8>,\n+        input: Buffer,\n+        run_client: extern \"C\" fn(Bridge<'_>, D) -> Buffer,\n         client_data: D,\n         force_show_panics: bool,\n-    ) -> Buffer<u8> {\n+    ) -> Buffer {\n         use std::sync::{Arc, Mutex};\n \n         enum State<T> {\n@@ -285,25 +274,25 @@ fn run_server<\n     handle_counters: &'static client::HandleCounters,\n     server: S,\n     input: I,\n-    run_client: extern \"C\" fn(Bridge<'_>, D) -> Buffer<u8>,\n+    run_client: extern \"C\" fn(Bridge<'_>, D) -> Buffer,\n     client_data: D,\n     force_show_panics: bool,\n ) -> Result<O, PanicMessage> {\n     let mut dispatcher =\n         Dispatcher { handle_store: HandleStore::new(handle_counters), server: MarkedTypes(server) };\n \n-    let mut b = Buffer::new();\n-    input.encode(&mut b, &mut dispatcher.handle_store);\n+    let mut buf = Buffer::new();\n+    input.encode(&mut buf, &mut dispatcher.handle_store);\n \n-    b = strategy.run_bridge_and_client(\n+    buf = strategy.run_bridge_and_client(\n         &mut dispatcher,\n-        b,\n+        buf,\n         run_client,\n         client_data,\n         force_show_panics,\n     );\n \n-    Result::decode(&mut &b[..], &mut dispatcher.handle_store)\n+    Result::decode(&mut &buf[..], &mut dispatcher.handle_store)\n }\n \n impl client::Client<fn(crate::TokenStream) -> crate::TokenStream> {"}]}