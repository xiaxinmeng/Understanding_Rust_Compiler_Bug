{"sha": "ff23ad3179014ba258f2b540fb39dd0f26852b7a", "node_id": "C_kwDOAAsO6NoAKGZmMjNhZDMxNzkwMTRiYTI1OGYyYjU0MGZiMzlkZDBmMjY4NTJiN2E", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-12-02T21:58:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-12-02T21:58:48Z"}, "message": "Auto merge of #91469 - matthiaskrgr:rollup-xom3j55, r=matthiaskrgr\n\nRollup of 12 pull requests\n\nSuccessful merges:\n\n - #89954 (Fix legacy_const_generic doc arguments display)\n - #91321 (Handle placeholder regions in NLL type outlive constraints)\n - #91329 (Fix incorrect usage of `EvaluatedToOk` when evaluating `TypeOutlives`)\n - #91364 (Improve error message for incorrect field accesses through raw pointers)\n - #91387 (Clarify and tidy up explanation of E0038)\n - #91410 (Move `#![feature(const_precise_live_drops)]` checks earlier in the pipeline)\n - #91435 (Improve diagnostic for missing half of binary operator in `if` condition)\n - #91444 (disable tests in Miri that take too long)\n - #91457 (Add additional test from rust issue number 91068)\n - #91460 (Document how `last_os_error` should be used)\n - #91464 (Document file path case sensitivity)\n - #91466 (Improve the comments in `Symbol::interner`.)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "205abbf762b77c2afb3e449dc31783eed1b58c00", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/205abbf762b77c2afb3e449dc31783eed1b58c00"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ff23ad3179014ba258f2b540fb39dd0f26852b7a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ff23ad3179014ba258f2b540fb39dd0f26852b7a", "html_url": "https://github.com/rust-lang/rust/commit/ff23ad3179014ba258f2b540fb39dd0f26852b7a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ff23ad3179014ba258f2b540fb39dd0f26852b7a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "acbe4443cc4c9695c0b74a7b64b60333c990a400", "url": "https://api.github.com/repos/rust-lang/rust/commits/acbe4443cc4c9695c0b74a7b64b60333c990a400", "html_url": "https://github.com/rust-lang/rust/commit/acbe4443cc4c9695c0b74a7b64b60333c990a400"}, {"sha": "f7afd461c7a1e9431a3ce46c23bc7ccd233faa99", "url": "https://api.github.com/repos/rust-lang/rust/commits/f7afd461c7a1e9431a3ce46c23bc7ccd233faa99", "html_url": "https://github.com/rust-lang/rust/commit/f7afd461c7a1e9431a3ce46c23bc7ccd233faa99"}], "stats": {"total": 798, "additions": 712, "deletions": 86}, "files": [{"sha": "a3b39591f8db261891835ea878a1dfc8a5445560", "filename": "compiler/rustc_borrowck/src/type_check/constraint_conversion.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ff23ad3179014ba258f2b540fb39dd0f26852b7a/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fconstraint_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff23ad3179014ba258f2b540fb39dd0f26852b7a/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fconstraint_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fconstraint_conversion.rs?ref=ff23ad3179014ba258f2b540fb39dd0f26852b7a", "patch": "@@ -6,6 +6,7 @@ use rustc_infer::infer::region_constraints::{GenericKind, VerifyBound};\n use rustc_infer::infer::{self, InferCtxt, SubregionOrigin};\n use rustc_middle::mir::ConstraintCategory;\n use rustc_middle::ty::subst::GenericArgKind;\n+use rustc_middle::ty::TypeFoldable;\n use rustc_middle::ty::{self, TyCtxt};\n use rustc_span::DUMMY_SP;\n \n@@ -95,11 +96,23 @@ impl<'a, 'tcx> ConstraintConversion<'a, 'tcx> {\n                 self.add_outlives(r1_vid, r2_vid);\n             }\n \n-            GenericArgKind::Type(t1) => {\n+            GenericArgKind::Type(mut t1) => {\n                 // we don't actually use this for anything, but\n                 // the `TypeOutlives` code needs an origin.\n                 let origin = infer::RelateParamBound(DUMMY_SP, t1, None);\n \n+                // Placeholder regions need to be converted now because it may\n+                // create new region variables, which can't be done later when\n+                // verifying these bounds.\n+                if t1.has_placeholders() {\n+                    t1 = tcx.fold_regions(&t1, &mut false, |r, _| match *r {\n+                        ty::RegionKind::RePlaceholder(placeholder) => {\n+                            self.constraints.placeholder_region(self.infcx, placeholder)\n+                        }\n+                        _ => r,\n+                    });\n+                }\n+\n                 TypeOutlives::new(\n                     &mut *self,\n                     tcx,"}, {"sha": "c1d47baa405311685cde2c10cd5da9c6dbd282ee", "filename": "compiler/rustc_const_eval/src/transform/check_consts/post_drop_elaboration.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ff23ad3179014ba258f2b540fb39dd0f26852b7a/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fpost_drop_elaboration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff23ad3179014ba258f2b540fb39dd0f26852b7a/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fpost_drop_elaboration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fpost_drop_elaboration.rs?ref=ff23ad3179014ba258f2b540fb39dd0f26852b7a", "patch": "@@ -80,7 +80,8 @@ impl Visitor<'tcx> for CheckLiveDrops<'mir, 'tcx> {\n         trace!(\"visit_terminator: terminator={:?} location={:?}\", terminator, location);\n \n         match &terminator.kind {\n-            mir::TerminatorKind::Drop { place: dropped_place, .. } => {\n+            mir::TerminatorKind::Drop { place: dropped_place, .. }\n+            | mir::TerminatorKind::DropAndReplace { place: dropped_place, .. } => {\n                 let dropped_ty = dropped_place.ty(self.body, self.tcx).ty;\n                 if !NeedsNonConstDrop::in_any_value_of_ty(self.ccx, dropped_ty) {\n                     // Instead of throwing a bug, we just return here. This is because we have to\n@@ -104,11 +105,6 @@ impl Visitor<'tcx> for CheckLiveDrops<'mir, 'tcx> {\n                 }\n             }\n \n-            mir::TerminatorKind::DropAndReplace { .. } => span_bug!(\n-                terminator.source_info.span,\n-                \"`DropAndReplace` should be removed by drop elaboration\",\n-            ),\n-\n             mir::TerminatorKind::Abort\n             | mir::TerminatorKind::Call { .. }\n             | mir::TerminatorKind::Assert { .. }"}, {"sha": "ca2eaa54057fabb1f561ebd9631fb9c3f7cccbf1", "filename": "compiler/rustc_error_codes/src/error_codes/E0038.md", "status": "modified", "additions": 65, "deletions": 32, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/ff23ad3179014ba258f2b540fb39dd0f26852b7a/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0038.md", "raw_url": "https://github.com/rust-lang/rust/raw/ff23ad3179014ba258f2b540fb39dd0f26852b7a/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0038.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0038.md?ref=ff23ad3179014ba258f2b540fb39dd0f26852b7a", "patch": "@@ -1,34 +1,64 @@\n-Trait objects like `Box<Trait>` can only be constructed when certain\n-requirements are satisfied by the trait in question.\n-\n-Trait objects are a form of dynamic dispatch and use a dynamically sized type\n-for the inner type. So, for a given trait `Trait`, when `Trait` is treated as a\n-type, as in `Box<Trait>`, the inner type is 'unsized'. In such cases the boxed\n-pointer is a 'fat pointer' that contains an extra pointer to a table of methods\n-(among other things) for dynamic dispatch. This design mandates some\n-restrictions on the types of traits that are allowed to be used in trait\n-objects, which are collectively termed as 'object safety' rules.\n-\n-Attempting to create a trait object for a non object-safe trait will trigger\n-this error.\n-\n-There are various rules:\n-\n-### The trait cannot require `Self: Sized`\n-\n-When `Trait` is treated as a type, the type does not implement the special\n-`Sized` trait, because the type does not have a known size at compile time and\n-can only be accessed behind a pointer. Thus, if we have a trait like the\n-following:\n+For any given trait `Trait` there may be a related _type_ called the _trait\n+object type_ which is typically written as `dyn Trait`. In earlier editions of\n+Rust, trait object types were written as plain `Trait` (just the name of the\n+trait, written in type positions) but this was a bit too confusing, so we now\n+write `dyn Trait`.\n+\n+Some traits are not allowed to be used as trait object types. The traits that\n+are allowed to be used as trait object types are called \"object-safe\" traits.\n+Attempting to use a trait object type for a trait that is not object-safe will\n+trigger error E0038.\n+\n+Two general aspects of trait object types give rise to the restrictions:\n+\n+  1. Trait object types are dynamically sized types (DSTs), and trait objects of\n+     these types can only be accessed through pointers, such as `&dyn Trait` or\n+     `Box<dyn Trait>`. The size of such a pointer is known, but the size of the\n+     `dyn Trait` object pointed-to by the pointer is _opaque_ to code working\n+     with it, and different tait objects with the same trait object type may\n+     have different sizes.\n+\n+  2. The pointer used to access a trait object is paired with an extra pointer\n+     to a \"virtual method table\" or \"vtable\", which is used to implement dynamic\n+     dispatch to the object's implementations of the trait's methods. There is a\n+     single such vtable for each trait implementation, but different trait\n+     objects with the same trait object type may point to vtables from different\n+     implementations.\n+\n+The specific conditions that violate object-safety follow, most of which relate\n+to missing size information and vtable polymorphism arising from these aspects.\n+\n+### The trait requires `Self: Sized`\n+\n+Traits that are declared as `Trait: Sized` or which otherwise inherit a\n+constraint of `Self:Sized` are not object-safe.\n+\n+The reasoning behind this is somewhat subtle. It derives from the fact that Rust\n+requires (and defines) that every trait object type `dyn Trait` automatically\n+implements `Trait`. Rust does this to simplify error reporting and ease\n+interoperation between static and dynamic polymorphism. For example, this code\n+works:\n \n ```\n-trait Foo where Self: Sized {\n+trait Trait {\n+}\n+\n+fn static_foo<T:Trait + ?Sized>(b: &T) {\n+}\n \n+fn dynamic_bar(a: &dyn Trait) {\n+    static_foo(a)\n }\n ```\n \n-We cannot create an object of type `Box<Foo>` or `&Foo` since in this case\n-`Self` would not be `Sized`.\n+This code works because `dyn Trait`, if it exists, always implements `Trait`.\n+\n+However as we know, any `dyn Trait` is also unsized, and so it can never\n+implement a sized trait like `Trait:Sized`. So, rather than allow an exception\n+to the rule that `dyn Trait` always implements `Trait`, Rust chooses to prohibit\n+such a `dyn Trait` from existing at all.\n+\n+Only unsized traits are considered object-safe.\n \n Generally, `Self: Sized` is used to indicate that the trait should not be used\n as a trait object. If the trait comes from your own crate, consider removing\n@@ -67,7 +97,7 @@ trait Trait {\n     fn foo(&self) -> Self;\n }\n \n-fn call_foo(x: Box<Trait>) {\n+fn call_foo(x: Box<dyn Trait>) {\n     let y = x.foo(); // What type is y?\n     // ...\n }\n@@ -76,7 +106,8 @@ fn call_foo(x: Box<Trait>) {\n If only some methods aren't object-safe, you can add a `where Self: Sized` bound\n on them to mark them as explicitly unavailable to trait objects. The\n functionality will still be available to all other implementers, including\n-`Box<Trait>` which is itself sized (assuming you `impl Trait for Box<Trait>`).\n+`Box<dyn Trait>` which is itself sized (assuming you `impl Trait for Box<dyn\n+Trait>`).\n \n ```\n trait Trait {\n@@ -115,7 +146,9 @@ impl Trait for u8 {\n ```\n \n At compile time each implementation of `Trait` will produce a table containing\n-the various methods (and other items) related to the implementation.\n+the various methods (and other items) related to the implementation, which will\n+be used as the virtual method table for a `dyn Trait` object derived from that\n+implementation.\n \n This works fine, but when the method gains generic parameters, we can have a\n problem.\n@@ -174,7 +207,7 @@ Now, if we have the following code:\n # impl Trait for u8 { fn foo<T>(&self, on: T) {} }\n # impl Trait for bool { fn foo<T>(&self, on: T) {} }\n # // etc.\n-fn call_foo(thing: Box<Trait>) {\n+fn call_foo(thing: Box<dyn Trait>) {\n     thing.foo(true); // this could be any one of the 8 types above\n     thing.foo(1);\n     thing.foo(\"hello\");\n@@ -200,7 +233,7 @@ trait Trait {\n ```\n \n If this is not an option, consider replacing the type parameter with another\n-trait object (e.g., if `T: OtherTrait`, use `on: Box<OtherTrait>`). If the\n+trait object (e.g., if `T: OtherTrait`, use `on: Box<dyn OtherTrait>`). If the\n number of types you intend to feed to this method is limited, consider manually\n listing out the methods of different types.\n \n@@ -226,7 +259,7 @@ trait Foo {\n }\n ```\n \n-### The trait cannot contain associated constants\n+### Trait contains associated constants\n \n Just like static functions, associated constants aren't stored on the method\n table. If the trait or any subtrait contain an associated constant, they cannot\n@@ -248,7 +281,7 @@ trait Foo {\n }\n ```\n \n-### The trait cannot use `Self` as a type parameter in the supertrait listing\n+### Trait uses `Self` as a type parameter in the supertrait listing\n \n This is similar to the second sub-error, but subtler. It happens in situations\n like the following:"}, {"sha": "df36b2e4e0b3ed0f239bd17b26fd9b617a2412e6", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ff23ad3179014ba258f2b540fb39dd0f26852b7a/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff23ad3179014ba258f2b540fb39dd0f26852b7a/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=ff23ad3179014ba258f2b540fb39dd0f26852b7a", "patch": "@@ -1803,6 +1803,16 @@ impl<V, T> ProjectionElem<V, T> {\n             | Self::Downcast(_, _) => false,\n         }\n     }\n+\n+    /// Returns `true` if this is a `Downcast` projection with the given `VariantIdx`.\n+    pub fn is_downcast_to(&self, v: VariantIdx) -> bool {\n+        matches!(*self, Self::Downcast(_, x) if x == v)\n+    }\n+\n+    /// Returns `true` if this is a `Field` projection with the given index.\n+    pub fn is_field_to(&self, f: Field) -> bool {\n+        matches!(*self, Self::Field(x, _) if x == f)\n+    }\n }\n \n /// Alias for projections as they appear in places, where the base is a place"}, {"sha": "acbea9bda11e4317b15528445ed5634a022f6daf", "filename": "compiler/rustc_mir_transform/src/lib.rs", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ff23ad3179014ba258f2b540fb39dd0f26852b7a/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff23ad3179014ba258f2b540fb39dd0f26852b7a/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs?ref=ff23ad3179014ba258f2b540fb39dd0f26852b7a", "patch": "@@ -60,8 +60,10 @@ mod match_branches;\n mod multiple_return_terminators;\n mod normalize_array_len;\n mod nrvo;\n+mod remove_false_edges;\n mod remove_noop_landing_pads;\n mod remove_storage_markers;\n+mod remove_uninit_drops;\n mod remove_unneeded_drops;\n mod remove_zsts;\n mod required_consts;\n@@ -75,7 +77,7 @@ mod simplify_try;\n mod uninhabited_enum_branching;\n mod unreachable_prop;\n \n-use rustc_const_eval::transform::check_consts;\n+use rustc_const_eval::transform::check_consts::{self, ConstCx};\n use rustc_const_eval::transform::promote_consts;\n use rustc_const_eval::transform::validate;\n use rustc_mir_dataflow::rustc_peek;\n@@ -444,8 +446,20 @@ fn mir_drops_elaborated_and_const_checked<'tcx>(\n     let (body, _) = tcx.mir_promoted(def);\n     let mut body = body.steal();\n \n+    // IMPORTANT\n+    remove_false_edges::RemoveFalseEdges.run_pass(tcx, &mut body);\n+\n+    // Do a little drop elaboration before const-checking if `const_precise_live_drops` is enabled.\n+    //\n+    // FIXME: Can't use `run_passes` for these, since `run_passes` SILENTLY DOES NOTHING IF THE MIR\n+    // PHASE DOESN'T CHANGE.\n+    if check_consts::post_drop_elaboration::checking_enabled(&ConstCx::new(tcx, &body)) {\n+        simplify::SimplifyCfg::new(\"remove-false-edges\").run_pass(tcx, &mut body);\n+        remove_uninit_drops::RemoveUninitDrops.run_pass(tcx, &mut body);\n+        check_consts::post_drop_elaboration::check_live_drops(tcx, &body);\n+    }\n+\n     run_post_borrowck_cleanup_passes(tcx, &mut body);\n-    check_consts::post_drop_elaboration::check_live_drops(tcx, &body);\n     tcx.alloc_steal_mir(body)\n }\n \n@@ -455,7 +469,7 @@ fn run_post_borrowck_cleanup_passes<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tc\n \n     let post_borrowck_cleanup: &[&dyn MirPass<'tcx>] = &[\n         // Remove all things only needed by analysis\n-        &simplify_branches::SimplifyBranches::new(\"initial\"),\n+        &simplify_branches::SimplifyConstCondition::new(\"initial\"),\n         &remove_noop_landing_pads::RemoveNoopLandingPads,\n         &cleanup_post_borrowck::CleanupNonCodegenStatements,\n         &simplify::SimplifyCfg::new(\"early-opt\"),\n@@ -514,13 +528,13 @@ fn run_optimization_passes<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n         &instcombine::InstCombine,\n         &separate_const_switch::SeparateConstSwitch,\n         &const_prop::ConstProp,\n-        &simplify_branches::SimplifyBranches::new(\"after-const-prop\"),\n+        &simplify_branches::SimplifyConstCondition::new(\"after-const-prop\"),\n         &early_otherwise_branch::EarlyOtherwiseBranch,\n         &simplify_comparison_integral::SimplifyComparisonIntegral,\n         &simplify_try::SimplifyArmIdentity,\n         &simplify_try::SimplifyBranchSame,\n         &dest_prop::DestinationPropagation,\n-        &simplify_branches::SimplifyBranches::new(\"final\"),\n+        &simplify_branches::SimplifyConstCondition::new(\"final\"),\n         &remove_noop_landing_pads::RemoveNoopLandingPads,\n         &simplify::SimplifyCfg::new(\"final\"),\n         &nrvo::RenameReturnPlace,"}, {"sha": "71f5ccf7e2465330252f0f48a69ee033f109c86e", "filename": "compiler/rustc_mir_transform/src/remove_false_edges.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/ff23ad3179014ba258f2b540fb39dd0f26852b7a/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_false_edges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff23ad3179014ba258f2b540fb39dd0f26852b7a/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_false_edges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_false_edges.rs?ref=ff23ad3179014ba258f2b540fb39dd0f26852b7a", "patch": "@@ -0,0 +1,29 @@\n+use rustc_middle::mir::{Body, TerminatorKind};\n+use rustc_middle::ty::TyCtxt;\n+\n+use crate::MirPass;\n+\n+/// Removes `FalseEdge` and `FalseUnwind` terminators from the MIR.\n+///\n+/// These are only needed for borrow checking, and can be removed afterwards.\n+///\n+/// FIXME: This should probably have its own MIR phase.\n+pub struct RemoveFalseEdges;\n+\n+impl<'tcx> MirPass<'tcx> for RemoveFalseEdges {\n+    fn run_pass(&self, _: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n+        for block in body.basic_blocks_mut() {\n+            let terminator = block.terminator_mut();\n+            terminator.kind = match terminator.kind {\n+                TerminatorKind::FalseEdge { real_target, .. } => {\n+                    TerminatorKind::Goto { target: real_target }\n+                }\n+                TerminatorKind::FalseUnwind { real_target, .. } => {\n+                    TerminatorKind::Goto { target: real_target }\n+                }\n+\n+                _ => continue,\n+            }\n+        }\n+    }\n+}"}, {"sha": "c219f2673244144721a172cd4486de71716457a4", "filename": "compiler/rustc_mir_transform/src/remove_uninit_drops.rs", "status": "added", "additions": 171, "deletions": 0, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/ff23ad3179014ba258f2b540fb39dd0f26852b7a/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_uninit_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff23ad3179014ba258f2b540fb39dd0f26852b7a/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_uninit_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_uninit_drops.rs?ref=ff23ad3179014ba258f2b540fb39dd0f26852b7a", "patch": "@@ -0,0 +1,171 @@\n+use rustc_index::bit_set::BitSet;\n+use rustc_middle::mir::{Body, Field, Rvalue, Statement, StatementKind, TerminatorKind};\n+use rustc_middle::ty::subst::SubstsRef;\n+use rustc_middle::ty::{self, ParamEnv, Ty, TyCtxt, VariantDef};\n+use rustc_mir_dataflow::impls::MaybeInitializedPlaces;\n+use rustc_mir_dataflow::move_paths::{LookupResult, MoveData, MovePathIndex};\n+use rustc_mir_dataflow::{self, move_path_children_matching, Analysis, MoveDataParamEnv};\n+\n+use crate::MirPass;\n+\n+/// Removes `Drop` and `DropAndReplace` terminators whose target is known to be uninitialized at\n+/// that point.\n+///\n+/// This is redundant with drop elaboration, but we need to do it prior to const-checking, and\n+/// running const-checking after drop elaboration makes it opimization dependent, causing issues\n+/// like [#90770].\n+///\n+/// [#90770]: https://github.com/rust-lang/rust/issues/90770\n+pub struct RemoveUninitDrops;\n+\n+impl<'tcx> MirPass<'tcx> for RemoveUninitDrops {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n+        let param_env = tcx.param_env(body.source.def_id());\n+        let Ok(move_data) = MoveData::gather_moves(body, tcx, param_env) else {\n+            // We could continue if there are move errors, but there's not much point since our\n+            // init data isn't complete.\n+            return;\n+        };\n+\n+        let mdpe = MoveDataParamEnv { move_data, param_env };\n+        let mut maybe_inits = MaybeInitializedPlaces::new(tcx, body, &mdpe)\n+            .into_engine(tcx, body)\n+            .pass_name(\"remove_uninit_drops\")\n+            .iterate_to_fixpoint()\n+            .into_results_cursor(body);\n+\n+        let mut to_remove = vec![];\n+        for (bb, block) in body.basic_blocks().iter_enumerated() {\n+            let terminator = block.terminator();\n+            let (TerminatorKind::Drop { place, .. } | TerminatorKind::DropAndReplace { place, .. })\n+                = &terminator.kind\n+            else { continue };\n+\n+            maybe_inits.seek_before_primary_effect(body.terminator_loc(bb));\n+\n+            // If there's no move path for the dropped place, it's probably a `Deref`. Let it alone.\n+            let LookupResult::Exact(mpi) = mdpe.move_data.rev_lookup.find(place.as_ref()) else {\n+                continue;\n+            };\n+\n+            let should_keep = is_needs_drop_and_init(\n+                tcx,\n+                param_env,\n+                maybe_inits.get(),\n+                &mdpe.move_data,\n+                place.ty(body, tcx).ty,\n+                mpi,\n+            );\n+            if !should_keep {\n+                to_remove.push(bb)\n+            }\n+        }\n+\n+        for bb in to_remove {\n+            let block = &mut body.basic_blocks_mut()[bb];\n+\n+            let (TerminatorKind::Drop { target, .. } | TerminatorKind::DropAndReplace { target, .. })\n+                = &block.terminator().kind\n+            else { unreachable!() };\n+\n+            // Replace block terminator with `Goto`.\n+            let target = *target;\n+            let old_terminator_kind = std::mem::replace(\n+                &mut block.terminator_mut().kind,\n+                TerminatorKind::Goto { target },\n+            );\n+\n+            // If this is a `DropAndReplace`, we need to emulate the assignment to the return place.\n+            if let TerminatorKind::DropAndReplace { place, value, .. } = old_terminator_kind {\n+                block.statements.push(Statement {\n+                    source_info: block.terminator().source_info,\n+                    kind: StatementKind::Assign(Box::new((place, Rvalue::Use(value)))),\n+                });\n+            }\n+        }\n+    }\n+}\n+\n+fn is_needs_drop_and_init(\n+    tcx: TyCtxt<'tcx>,\n+    param_env: ParamEnv<'tcx>,\n+    maybe_inits: &BitSet<MovePathIndex>,\n+    move_data: &MoveData<'tcx>,\n+    ty: Ty<'tcx>,\n+    mpi: MovePathIndex,\n+) -> bool {\n+    // No need to look deeper if the root is definitely uninit or if it has no `Drop` impl.\n+    if !maybe_inits.contains(mpi) || !ty.needs_drop(tcx, param_env) {\n+        return false;\n+    }\n+\n+    let field_needs_drop_and_init = |(f, f_ty, mpi)| {\n+        let child = move_path_children_matching(move_data, mpi, |x| x.is_field_to(f));\n+        let Some(mpi) = child else {\n+            return f_ty.needs_drop(tcx, param_env);\n+        };\n+\n+        is_needs_drop_and_init(tcx, param_env, maybe_inits, move_data, f_ty, mpi)\n+    };\n+\n+    // This pass is only needed for const-checking, so it doesn't handle as many cases as\n+    // `DropCtxt::open_drop`, since they aren't relevant in a const-context.\n+    match ty.kind() {\n+        ty::Adt(adt, substs) => {\n+            let dont_elaborate = adt.is_union() || adt.is_manually_drop() || adt.has_dtor(tcx);\n+            if dont_elaborate {\n+                return true;\n+            }\n+\n+            // Look at all our fields, or if we are an enum all our variants and their fields.\n+            //\n+            // If a field's projection *is not* present in `MoveData`, it has the same\n+            // initializedness as its parent (maybe init).\n+            //\n+            // If its projection *is* present in `MoveData`, then the field may have been moved\n+            // from separate from its parent. Recurse.\n+            adt.variants.iter_enumerated().any(|(vid, variant)| {\n+                // Enums have multiple variants, which are discriminated with a `Downcast` projection.\n+                // Structs have a single variant, and don't use a `Downcast` projection.\n+                let mpi = if adt.is_enum() {\n+                    let downcast =\n+                        move_path_children_matching(move_data, mpi, |x| x.is_downcast_to(vid));\n+                    let Some(dc_mpi) = downcast else {\n+                        return variant_needs_drop(tcx, param_env, substs, variant);\n+                    };\n+\n+                    dc_mpi\n+                } else {\n+                    mpi\n+                };\n+\n+                variant\n+                    .fields\n+                    .iter()\n+                    .enumerate()\n+                    .map(|(f, field)| (Field::from_usize(f), field.ty(tcx, substs), mpi))\n+                    .any(field_needs_drop_and_init)\n+            })\n+        }\n+\n+        ty::Tuple(_) => ty\n+            .tuple_fields()\n+            .enumerate()\n+            .map(|(f, f_ty)| (Field::from_usize(f), f_ty, mpi))\n+            .any(field_needs_drop_and_init),\n+\n+        _ => true,\n+    }\n+}\n+\n+fn variant_needs_drop(\n+    tcx: TyCtxt<'tcx>,\n+    param_env: ParamEnv<'tcx>,\n+    substs: SubstsRef<'tcx>,\n+    variant: &VariantDef,\n+) -> bool {\n+    variant.fields.iter().any(|field| {\n+        let f_ty = field.ty(tcx, substs);\n+        f_ty.needs_drop(tcx, param_env)\n+    })\n+}"}, {"sha": "39f78e9555e2f6a0d660624dd0094901c0c99d28", "filename": "compiler/rustc_mir_transform/src/remove_unneeded_drops.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ff23ad3179014ba258f2b540fb39dd0f26852b7a/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_unneeded_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff23ad3179014ba258f2b540fb39dd0f26852b7a/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_unneeded_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_unneeded_drops.rs?ref=ff23ad3179014ba258f2b540fb39dd0f26852b7a", "patch": "@@ -1,4 +1,8 @@\n-//! This pass replaces a drop of a type that does not need dropping, with a goto\n+//! This pass replaces a drop of a type that does not need dropping, with a goto.\n+//!\n+//! When the MIR is built, we check `needs_drop` before emitting a `Drop` for a place. This pass is\n+//! useful because (unlike MIR building) it runs after type checking, so it can make use of\n+//! `Reveal::All` to provide more precies type information.\n \n use crate::MirPass;\n use rustc_middle::mir::*;"}, {"sha": "4b261334f3e545d7d4718de15b106861abed1c24", "filename": "compiler/rustc_mir_transform/src/simplify_branches.rs", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ff23ad3179014ba258f2b540fb39dd0f26852b7a/compiler%2Frustc_mir_transform%2Fsrc%2Fsimplify_branches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff23ad3179014ba258f2b540fb39dd0f26852b7a/compiler%2Frustc_mir_transform%2Fsrc%2Fsimplify_branches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fsimplify_branches.rs?ref=ff23ad3179014ba258f2b540fb39dd0f26852b7a", "patch": "@@ -1,22 +1,21 @@\n-//! A pass that simplifies branches when their condition is known.\n-\n use crate::MirPass;\n use rustc_middle::mir::*;\n use rustc_middle::ty::TyCtxt;\n \n use std::borrow::Cow;\n \n-pub struct SimplifyBranches {\n+/// A pass that replaces a branch with a goto when its condition is known.\n+pub struct SimplifyConstCondition {\n     label: String,\n }\n \n-impl SimplifyBranches {\n+impl SimplifyConstCondition {\n     pub fn new(label: &str) -> Self {\n-        SimplifyBranches { label: format!(\"SimplifyBranches-{}\", label) }\n+        SimplifyConstCondition { label: format!(\"SimplifyConstCondition-{}\", label) }\n     }\n }\n \n-impl<'tcx> MirPass<'tcx> for SimplifyBranches {\n+impl<'tcx> MirPass<'tcx> for SimplifyConstCondition {\n     fn name(&self) -> Cow<'_, str> {\n         Cow::Borrowed(&self.label)\n     }\n@@ -53,12 +52,6 @@ impl<'tcx> MirPass<'tcx> for SimplifyBranches {\n                     Some(v) if v == expected => TerminatorKind::Goto { target },\n                     _ => continue,\n                 },\n-                TerminatorKind::FalseEdge { real_target, .. } => {\n-                    TerminatorKind::Goto { target: real_target }\n-                }\n-                TerminatorKind::FalseUnwind { real_target, .. } => {\n-                    TerminatorKind::Goto { target: real_target }\n-                }\n                 _ => continue,\n             };\n         }"}, {"sha": "1dbd7bad0f0236d416885e9b74123d52b9942916", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 41, "deletions": 10, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/ff23ad3179014ba258f2b540fb39dd0f26852b7a/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff23ad3179014ba258f2b540fb39dd0f26852b7a/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=ff23ad3179014ba258f2b540fb39dd0f26852b7a", "patch": "@@ -1988,25 +1988,34 @@ impl<'a> Parser<'a> {\n         let lo = self.prev_token.span;\n         let cond = self.parse_cond_expr()?;\n \n+        let missing_then_block_binop_span = || {\n+            match cond.kind {\n+                ExprKind::Binary(Spanned { span: binop_span, .. }, _, ref right)\n+                    if let ExprKind::Block(..) = right.kind => Some(binop_span),\n+                _ => None\n+            }\n+        };\n+\n         // Verify that the parsed `if` condition makes sense as a condition. If it is a block, then\n         // verify that the last statement is either an implicit return (no `;`) or an explicit\n         // return. This won't catch blocks with an explicit `return`, but that would be caught by\n         // the dead code lint.\n-        let thn = if self.eat_keyword(kw::Else) || !cond.returns() {\n-            self.error_missing_if_cond(lo, cond.span)\n+        let thn = if self.token.is_keyword(kw::Else) || !cond.returns() {\n+            if let Some(binop_span) = missing_then_block_binop_span() {\n+                self.error_missing_if_then_block(lo, None, Some(binop_span)).emit();\n+                self.mk_block_err(cond.span)\n+            } else {\n+                self.error_missing_if_cond(lo, cond.span)\n+            }\n         } else {\n             let attrs = self.parse_outer_attributes()?.take_for_recovery(); // For recovery.\n             let not_block = self.token != token::OpenDelim(token::Brace);\n-            let block = self.parse_block().map_err(|mut err| {\n+            let block = self.parse_block().map_err(|err| {\n                 if not_block {\n-                    err.span_label(lo, \"this `if` expression has a condition, but no block\");\n-                    if let ExprKind::Binary(_, _, ref right) = cond.kind {\n-                        if let ExprKind::Block(_, _) = right.kind {\n-                            err.help(\"maybe you forgot the right operand of the condition?\");\n-                        }\n-                    }\n+                    self.error_missing_if_then_block(lo, Some(err), missing_then_block_binop_span())\n+                } else {\n+                    err\n                 }\n-                err\n             })?;\n             self.error_on_if_block_attrs(lo, false, block.span, &attrs);\n             block\n@@ -2015,6 +2024,28 @@ impl<'a> Parser<'a> {\n         Ok(self.mk_expr(lo.to(self.prev_token.span), ExprKind::If(cond, thn, els), attrs))\n     }\n \n+    fn error_missing_if_then_block(\n+        &self,\n+        if_span: Span,\n+        err: Option<DiagnosticBuilder<'a>>,\n+        binop_span: Option<Span>,\n+    ) -> DiagnosticBuilder<'a> {\n+        let msg = \"this `if` expression has a condition, but no block\";\n+\n+        let mut err = if let Some(mut err) = err {\n+            err.span_label(if_span, msg);\n+            err\n+        } else {\n+            self.struct_span_err(if_span, msg)\n+        };\n+\n+        if let Some(binop_span) = binop_span {\n+            err.span_help(binop_span, \"maybe you forgot the right operand of the condition?\");\n+        }\n+\n+        err\n+    }\n+\n     fn error_missing_if_cond(&self, lo: Span, span: Span) -> P<ast::Block> {\n         let sp = self.sess.source_map().next_point(lo);\n         self.struct_span_err(sp, \"missing condition for `if` expression\")"}, {"sha": "dd6ce60abfb3dd0393c36064f9f58e257af46ac5", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ff23ad3179014ba258f2b540fb39dd0f26852b7a/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff23ad3179014ba258f2b540fb39dd0f26852b7a/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=ff23ad3179014ba258f2b540fb39dd0f26852b7a", "patch": "@@ -1716,8 +1716,9 @@ pub(crate) struct Interner(Lock<InternerInner>);\n // found that to regress performance up to 2% in some cases. This might be\n // revisited after further improvements to `indexmap`.\n //\n-// This type is private to prevent accidentally constructing more than one `Interner` on the same\n-// thread, which makes it easy to mixup `Symbol`s between `Interner`s.\n+// This type is private to prevent accidentally constructing more than one\n+// `Interner` on the same thread, which makes it easy to mixup `Symbol`s\n+// between `Interner`s.\n #[derive(Default)]\n struct InternerInner {\n     arena: DroplessArena,\n@@ -1743,14 +1744,20 @@ impl Interner {\n \n         let name = Symbol::new(inner.strings.len() as u32);\n \n-        // `from_utf8_unchecked` is safe since we just allocated a `&str` which is known to be\n-        // UTF-8.\n+        // SAFETY: we convert from `&str` to `&[u8]`, clone it into the arena,\n+        // and immediately convert the clone back to `&[u8], all because there\n+        // is no `inner.arena.alloc_str()` method. This is clearly safe.\n         let string: &str =\n             unsafe { str::from_utf8_unchecked(inner.arena.alloc_slice(string.as_bytes())) };\n-        // It is safe to extend the arena allocation to `'static` because we only access\n-        // these while the arena is still alive.\n+\n+        // SAFETY: we can extend the arena allocation to `'static` because we\n+        // only access these while the arena is still alive.\n         let string: &'static str = unsafe { &*(string as *const str) };\n         inner.strings.push(string);\n+\n+        // This second hash table lookup can be avoided by using `RawEntryMut`,\n+        // but this code path isn't hot enough for it to be worth it. See\n+        // #91445 for details.\n         inner.names.insert(string, name);\n         name\n     }"}, {"sha": "2b120e855eb5a914b41ab85a46347fb5beea6039", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ff23ad3179014ba258f2b540fb39dd0f26852b7a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff23ad3179014ba258f2b540fb39dd0f26852b7a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=ff23ad3179014ba258f2b540fb39dd0f26852b7a", "patch": "@@ -521,7 +521,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 },\n \n                 ty::PredicateKind::TypeOutlives(pred) => {\n-                    if pred.0.is_known_global() {\n+                    // A global type with no late-bound regions can only\n+                    // contain the \"'static\" lifetime (any other lifetime\n+                    // would either be late-bound or local), so it is guaranteed\n+                    // to outlive any other lifetime\n+                    if pred.0.is_global(self.infcx.tcx) && !pred.0.has_late_bound_regions() {\n                         Ok(EvaluatedToOk)\n                     } else {\n                         Ok(EvaluatedToOkModuloRegions)"}, {"sha": "311106474bea008dff0a8608316965513a02f095", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/ff23ad3179014ba258f2b540fb39dd0f26852b7a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff23ad3179014ba258f2b540fb39dd0f26852b7a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=ff23ad3179014ba258f2b540fb39dd0f26852b7a", "patch": "@@ -46,6 +46,7 @@ use rustc_span::hygiene::DesugaringKind;\n use rustc_span::lev_distance::find_best_match_for_name;\n use rustc_span::source_map::Span;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n+use rustc_span::{BytePos, Pos};\n use rustc_trait_selection::traits::{self, ObligationCauseCode};\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n@@ -2063,7 +2064,36 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 Some(span),\n             );\n         } else {\n-            err.help(\"methods are immutable and cannot be assigned to\");\n+            let mut found = false;\n+\n+            if let ty::RawPtr(ty_and_mut) = expr_t.kind() {\n+                if let ty::Adt(adt_def, _) = ty_and_mut.ty.kind() {\n+                    if adt_def.variants.len() == 1\n+                        && adt_def\n+                            .variants\n+                            .iter()\n+                            .next()\n+                            .unwrap()\n+                            .fields\n+                            .iter()\n+                            .any(|f| f.ident == field)\n+                    {\n+                        if let Some(dot_loc) = expr_snippet.rfind('.') {\n+                            found = true;\n+                            err.span_suggestion(\n+                                expr.span.with_hi(expr.span.lo() + BytePos::from_usize(dot_loc)),\n+                                \"to access the field, dereference first\",\n+                                format!(\"(*{})\", &expr_snippet[0..dot_loc]),\n+                                Applicability::MaybeIncorrect,\n+                            );\n+                        }\n+                    }\n+                }\n+            }\n+\n+            if !found {\n+                err.help(\"methods are immutable and cannot be assigned to\");\n+            }\n         }\n \n         err.emit();"}, {"sha": "281df8a1326d009ecc4042f1897357c004c11207", "filename": "library/core/tests/slice.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff23ad3179014ba258f2b540fb39dd0f26852b7a/library%2Fcore%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff23ad3179014ba258f2b540fb39dd0f26852b7a/library%2Fcore%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fslice.rs?ref=ff23ad3179014ba258f2b540fb39dd0f26852b7a", "patch": "@@ -2330,13 +2330,15 @@ macro_rules! empty_max_mut {\n     };\n }\n \n+#[cfg(not(miri))] // Comparing usize::MAX many elements takes forever in Miri (and in rustc without optimizations)\n take_tests! {\n     slice: &[(); usize::MAX], method: take,\n     (take_in_bounds_max_range_to, (..usize::MAX), Some(EMPTY_MAX), &[(); 0]),\n     (take_oob_max_range_to_inclusive, (..=usize::MAX), None, EMPTY_MAX),\n     (take_in_bounds_max_range_from, (usize::MAX..), Some(&[] as _), EMPTY_MAX),\n }\n \n+#[cfg(not(miri))] // Comparing usize::MAX many elements takes forever in Miri (and in rustc without optimizations)\n take_tests! {\n     slice: &mut [(); usize::MAX], method: take_mut,\n     (take_mut_in_bounds_max_range_to, (..usize::MAX), Some(empty_max_mut!()), &mut [(); 0]),"}, {"sha": "da88c8c9261b41158881982ff3a012009a08e24b", "filename": "library/std/src/io/error.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ff23ad3179014ba258f2b540fb39dd0f26852b7a/library%2Fstd%2Fsrc%2Fio%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff23ad3179014ba258f2b540fb39dd0f26852b7a/library%2Fstd%2Fsrc%2Fio%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Ferror.rs?ref=ff23ad3179014ba258f2b540fb39dd0f26852b7a", "patch": "@@ -440,12 +440,18 @@ impl Error {\n     /// `GetLastError` on Windows) and will return a corresponding instance of\n     /// [`Error`] for the error code.\n     ///\n+    /// This should be called immediately after a call to a platform function,\n+    /// otherwise the state of the error value is indeterminate. In particular,\n+    /// other standard library functions may call platform functions that may\n+    /// (or may not) reset the error value even if they succeed.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n     /// use std::io::Error;\n     ///\n-    /// println!(\"last OS error: {:?}\", Error::last_os_error());\n+    /// let os_error = Error::last_os_error();\n+    /// println!(\"last OS error: {:?}\", os_error);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[must_use]"}, {"sha": "9ade2847e8ea995c06cf0b02616cf26c70049e3d", "filename": "library/std/src/path.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ff23ad3179014ba258f2b540fb39dd0f26852b7a/library%2Fstd%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff23ad3179014ba258f2b540fb39dd0f26852b7a/library%2Fstd%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpath.rs?ref=ff23ad3179014ba258f2b540fb39dd0f26852b7a", "patch": "@@ -12,6 +12,13 @@\n //! [`PathBuf`]; note that the paths may differ syntactically by the\n //! normalization described in the documentation for the [`components`] method.\n //!\n+//! ## Case sensitivity\n+//!\n+//! Unless otherwise indicated path methods that do not access the filesystem,\n+//! such as [`Path::starts_with`] and [`Path::ends_with`], are case sensitive no\n+//! matter the platform or filesystem. An exception to this is made for Windows\n+//! drive letters.\n+//!\n //! ## Simple usage\n //!\n //! Path manipulation includes both parsing components from slices and building"}, {"sha": "9c3484b4a316727e39817871d20fcedd32562c94", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 34, "deletions": 1, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/ff23ad3179014ba258f2b540fb39dd0f26852b7a/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff23ad3179014ba258f2b540fb39dd0f26852b7a/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=ff23ad3179014ba258f2b540fb39dd0f26852b7a", "patch": "@@ -749,11 +749,42 @@ fn clean_fn_or_proc_macro(\n                 } else {\n                     hir::Constness::NotConst\n                 };\n+            clean_fn_decl_legacy_const_generics(&mut func, attrs);\n             FunctionItem(func)\n         }\n     }\n }\n \n+/// This is needed to make it more \"readable\" when documenting functions using\n+/// `rustc_legacy_const_generics`. More information in\n+/// <https://github.com/rust-lang/rust/issues/83167>.\n+fn clean_fn_decl_legacy_const_generics(func: &mut Function, attrs: &[ast::Attribute]) {\n+    for meta_item_list in attrs\n+        .iter()\n+        .filter(|a| a.has_name(sym::rustc_legacy_const_generics))\n+        .filter_map(|a| a.meta_item_list())\n+    {\n+        for (pos, literal) in meta_item_list.iter().filter_map(|meta| meta.literal()).enumerate() {\n+            match literal.kind {\n+                ast::LitKind::Int(a, _) => {\n+                    let gen = func.generics.params.remove(0);\n+                    if let GenericParamDef { name, kind: GenericParamDefKind::Const { ty, .. } } =\n+                        gen\n+                    {\n+                        func.decl\n+                            .inputs\n+                            .values\n+                            .insert(a as _, Argument { name, type_: *ty, is_const: true });\n+                    } else {\n+                        panic!(\"unexpected non const in position {}\", pos);\n+                    }\n+                }\n+                _ => panic!(\"invalid arg index\"),\n+            }\n+        }\n+    }\n+}\n+\n impl<'a> Clean<Function> for (&'a hir::FnSig<'a>, &'a hir::Generics<'a>, hir::BodyId) {\n     fn clean(&self, cx: &mut DocContext<'_>) -> Function {\n         let (generics, decl) = enter_impl_trait(cx, |cx| {\n@@ -779,7 +810,7 @@ impl<'a> Clean<Arguments> for (&'a [hir::Ty<'a>], &'a [Ident]) {\n                     if name.is_empty() {\n                         name = kw::Underscore;\n                     }\n-                    Argument { name, type_: ty.clean(cx) }\n+                    Argument { name, type_: ty.clean(cx), is_const: false }\n                 })\n                 .collect(),\n         }\n@@ -798,6 +829,7 @@ impl<'a> Clean<Arguments> for (&'a [hir::Ty<'a>], hir::BodyId) {\n                 .map(|(i, ty)| Argument {\n                     name: name_from_pat(body.params[i].pat),\n                     type_: ty.clean(cx),\n+                    is_const: false,\n                 })\n                 .collect(),\n         }\n@@ -828,6 +860,7 @@ impl<'tcx> Clean<FnDecl> for (DefId, ty::PolyFnSig<'tcx>) {\n                     .map(|t| Argument {\n                         type_: t.clean(cx),\n                         name: names.next().map_or(kw::Empty, |i| i.name),\n+                        is_const: false,\n                     })\n                     .collect(),\n             },"}, {"sha": "1267e88f358f11c38914b2991c95b9af31ba4d62", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ff23ad3179014ba258f2b540fb39dd0f26852b7a/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff23ad3179014ba258f2b540fb39dd0f26852b7a/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=ff23ad3179014ba258f2b540fb39dd0f26852b7a", "patch": "@@ -1353,6 +1353,9 @@ crate struct Arguments {\n crate struct Argument {\n     crate type_: Type,\n     crate name: Symbol,\n+    /// This field is used to represent \"const\" arguments from the `rustc_legacy_const_generics`\n+    /// feature. More information in <https://github.com/rust-lang/rust/issues/83167>.\n+    crate is_const: bool,\n }\n \n #[derive(Clone, PartialEq, Debug)]"}, {"sha": "25471dd726d6b346429abd24ab44d3935ea01edb", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff23ad3179014ba258f2b540fb39dd0f26852b7a/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff23ad3179014ba258f2b540fb39dd0f26852b7a/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=ff23ad3179014ba258f2b540fb39dd0f26852b7a", "patch": "@@ -1177,6 +1177,10 @@ impl clean::FnDecl {\n                     args.push_str(\" <br>\");\n                     args_plain.push(' ');\n                 }\n+                if input.is_const {\n+                    args.push_str(\"const \");\n+                    args_plain.push_str(\"const \");\n+                }\n                 if !input.name.is_empty() {\n                     args.push_str(&format!(\"{}: \", input.name));\n                     args_plain.push_str(&format!(\"{}: \", input.name));"}, {"sha": "f2b02551146ebff5c1ed98cecdff76a3cb8731cf", "filename": "src/test/mir-opt/const_prop/switch_int.main.SimplifyConstCondition-after-const-prop.diff", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff23ad3179014ba258f2b540fb39dd0f26852b7a/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fswitch_int.main.SimplifyConstCondition-after-const-prop.diff", "raw_url": "https://github.com/rust-lang/rust/raw/ff23ad3179014ba258f2b540fb39dd0f26852b7a/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fswitch_int.main.SimplifyConstCondition-after-const-prop.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fswitch_int.main.SimplifyConstCondition-after-const-prop.diff?ref=ff23ad3179014ba258f2b540fb39dd0f26852b7a", "patch": "@@ -1,5 +1,5 @@\n-- // MIR for `main` before SimplifyBranches-after-const-prop\n-+ // MIR for `main` after SimplifyBranches-after-const-prop\n+- // MIR for `main` before SimplifyConstCondition-after-const-prop\n++ // MIR for `main` after SimplifyConstCondition-after-const-prop\n   \n   fn main() -> () {\n       let mut _0: ();                      // return place in scope 0 at $DIR/switch_int.rs:6:11: 6:11", "previous_filename": "src/test/mir-opt/const_prop/switch_int.main.SimplifyBranches-after-const-prop.diff"}, {"sha": "d7319eca18e2d107b913812a77ae5bfa1a996768", "filename": "src/test/mir-opt/const_prop/switch_int.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff23ad3179014ba258f2b540fb39dd0f26852b7a/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fswitch_int.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff23ad3179014ba258f2b540fb39dd0f26852b7a/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fswitch_int.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fswitch_int.rs?ref=ff23ad3179014ba258f2b540fb39dd0f26852b7a", "patch": "@@ -2,7 +2,7 @@\n fn foo(_: i32) { }\n \n // EMIT_MIR switch_int.main.ConstProp.diff\n-// EMIT_MIR switch_int.main.SimplifyBranches-after-const-prop.diff\n+// EMIT_MIR switch_int.main.SimplifyConstCondition-after-const-prop.diff\n fn main() {\n     match 1 {\n         1 => foo(0),"}, {"sha": "ca298e9211d4864400aa0116975c4c86ad5c9f04", "filename": "src/test/mir-opt/early_otherwise_branch_68867.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff23ad3179014ba258f2b540fb39dd0f26852b7a/src%2Ftest%2Fmir-opt%2Fearly_otherwise_branch_68867.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff23ad3179014ba258f2b540fb39dd0f26852b7a/src%2Ftest%2Fmir-opt%2Fearly_otherwise_branch_68867.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fearly_otherwise_branch_68867.rs?ref=ff23ad3179014ba258f2b540fb39dd0f26852b7a", "patch": "@@ -11,7 +11,7 @@ pub enum ViewportPercentageLength {\n }\n \n // EMIT_MIR early_otherwise_branch_68867.try_sum.EarlyOtherwiseBranch.diff\n-// EMIT_MIR early_otherwise_branch_68867.try_sum EarlyOtherwiseBranch.before SimplifyBranches-final.after\n+// EMIT_MIR early_otherwise_branch_68867.try_sum EarlyOtherwiseBranch.before SimplifyConstCondition-final.after\n #[no_mangle]\n pub extern \"C\" fn try_sum(\n     x: &ViewportPercentageLength,"}, {"sha": "44294030439f3a23b550f771e3405d8a142f90be", "filename": "src/test/mir-opt/early_otherwise_branch_68867.try_sum.EarlyOtherwiseBranch.before-SimplifyConstCondition-final.after.diff", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff23ad3179014ba258f2b540fb39dd0f26852b7a/src%2Ftest%2Fmir-opt%2Fearly_otherwise_branch_68867.try_sum.EarlyOtherwiseBranch.before-SimplifyConstCondition-final.after.diff", "raw_url": "https://github.com/rust-lang/rust/raw/ff23ad3179014ba258f2b540fb39dd0f26852b7a/src%2Ftest%2Fmir-opt%2Fearly_otherwise_branch_68867.try_sum.EarlyOtherwiseBranch.before-SimplifyConstCondition-final.after.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fearly_otherwise_branch_68867.try_sum.EarlyOtherwiseBranch.before-SimplifyConstCondition-final.after.diff?ref=ff23ad3179014ba258f2b540fb39dd0f26852b7a", "patch": "@@ -1,5 +1,5 @@\n - // MIR for `try_sum` before EarlyOtherwiseBranch\n-+ // MIR for `try_sum` after SimplifyBranches-final\n++ // MIR for `try_sum` after SimplifyConstCondition-final\n   \n   fn try_sum(_1: &ViewportPercentageLength, _2: &ViewportPercentageLength) -> Result<ViewportPercentageLength, ()> {\n       debug x => _1;                       // in scope 0 at $DIR/early_otherwise_branch_68867.rs:17:5: 17:6", "previous_filename": "src/test/mir-opt/early_otherwise_branch_68867.try_sum.EarlyOtherwiseBranch.before-SimplifyBranches-final.after.diff"}, {"sha": "d11c70b1efec66a8fd19e41a4b9f472df219d2b4", "filename": "src/test/mir-opt/simplify_if.main.SimplifyConstCondition-after-const-prop.diff", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff23ad3179014ba258f2b540fb39dd0f26852b7a/src%2Ftest%2Fmir-opt%2Fsimplify_if.main.SimplifyConstCondition-after-const-prop.diff", "raw_url": "https://github.com/rust-lang/rust/raw/ff23ad3179014ba258f2b540fb39dd0f26852b7a/src%2Ftest%2Fmir-opt%2Fsimplify_if.main.SimplifyConstCondition-after-const-prop.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fsimplify_if.main.SimplifyConstCondition-after-const-prop.diff?ref=ff23ad3179014ba258f2b540fb39dd0f26852b7a", "patch": "@@ -1,5 +1,5 @@\n-- // MIR for `main` before SimplifyBranches-after-const-prop\n-+ // MIR for `main` after SimplifyBranches-after-const-prop\n+- // MIR for `main` before SimplifyConstCondition-after-const-prop\n++ // MIR for `main` after SimplifyConstCondition-after-const-prop\n   \n   fn main() -> () {\n       let mut _0: ();                      // return place in scope 0 at $DIR/simplify_if.rs:5:11: 5:11", "previous_filename": "src/test/mir-opt/simplify_if.main.SimplifyBranches-after-const-prop.diff"}, {"sha": "2d093d9266bb516667a19505621b36a27aedfcdb", "filename": "src/test/mir-opt/simplify_if.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff23ad3179014ba258f2b540fb39dd0f26852b7a/src%2Ftest%2Fmir-opt%2Fsimplify_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff23ad3179014ba258f2b540fb39dd0f26852b7a/src%2Ftest%2Fmir-opt%2Fsimplify_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fsimplify_if.rs?ref=ff23ad3179014ba258f2b540fb39dd0f26852b7a", "patch": "@@ -1,7 +1,7 @@\n #[inline(never)]\n fn noop() {}\n \n-// EMIT_MIR simplify_if.main.SimplifyBranches-after-const-prop.diff\n+// EMIT_MIR simplify_if.main.SimplifyConstCondition-after-const-prop.diff\n fn main() {\n     if false {\n         noop();"}, {"sha": "46a50e2fc30b4b33e3e9004e53d97d593984cb9c", "filename": "src/test/rustdoc/legacy-const-generic.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ff23ad3179014ba258f2b540fb39dd0f26852b7a/src%2Ftest%2Frustdoc%2Flegacy-const-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff23ad3179014ba258f2b540fb39dd0f26852b7a/src%2Ftest%2Frustdoc%2Flegacy-const-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Flegacy-const-generic.rs?ref=ff23ad3179014ba258f2b540fb39dd0f26852b7a", "patch": "@@ -0,0 +1,16 @@\n+#![crate_name = \"foo\"]\n+#![feature(rustc_attrs)]\n+\n+// @has 'foo/fn.foo.html'\n+// @has - '//*[@class=\"rust fn\"]' 'fn foo(x: usize, const Y: usize, z: usize) -> [usize; 3]'\n+#[rustc_legacy_const_generics(1)]\n+pub fn foo<const Y: usize>(x: usize, z: usize) -> [usize; 3] {\n+    [x, Y, z]\n+}\n+\n+// @has 'foo/fn.bar.html'\n+// @has - '//*[@class=\"rust fn\"]' 'fn bar(x: usize, const Y: usize, const Z: usize) -> [usize; 3]'\n+#[rustc_legacy_const_generics(1, 2)]\n+pub fn bar<const Y: usize, const Z: usize>(x: usize) -> [usize; 3] {\n+    [x, Y, z]\n+}"}, {"sha": "f7c70d3978b7f24922e45e7ef2f0bee815bafcce", "filename": "src/test/ui/consts/drop_zst.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ff23ad3179014ba258f2b540fb39dd0f26852b7a/src%2Ftest%2Fui%2Fconsts%2Fdrop_zst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff23ad3179014ba258f2b540fb39dd0f26852b7a/src%2Ftest%2Fui%2Fconsts%2Fdrop_zst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fdrop_zst.rs?ref=ff23ad3179014ba258f2b540fb39dd0f26852b7a", "patch": "@@ -0,0 +1,17 @@\n+// check-fail\n+\n+#![feature(const_precise_live_drops)]\n+\n+struct S;\n+\n+impl Drop for S {\n+    fn drop(&mut self) {\n+        println!(\"Hello!\");\n+    }\n+}\n+\n+const fn foo() {\n+    let s = S; //~ destructor\n+}\n+\n+fn main() {}"}, {"sha": "d4be5aa56d9af00fda3dccc9899c418d1e0cad35", "filename": "src/test/ui/consts/drop_zst.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ff23ad3179014ba258f2b540fb39dd0f26852b7a/src%2Ftest%2Fui%2Fconsts%2Fdrop_zst.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff23ad3179014ba258f2b540fb39dd0f26852b7a/src%2Ftest%2Fui%2Fconsts%2Fdrop_zst.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fdrop_zst.stderr?ref=ff23ad3179014ba258f2b540fb39dd0f26852b7a", "patch": "@@ -0,0 +1,9 @@\n+error[E0493]: destructors cannot be evaluated at compile-time\n+  --> $DIR/drop_zst.rs:14:9\n+   |\n+LL |     let s = S;\n+   |         ^ constant functions cannot evaluate destructors\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0493`."}, {"sha": "d3f6ca07617f4ced46de000122fe607bb0b65759", "filename": "src/test/ui/expr/if/if-without-block.stderr", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ff23ad3179014ba258f2b540fb39dd0f26852b7a/src%2Ftest%2Fui%2Fexpr%2Fif%2Fif-without-block.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff23ad3179014ba258f2b540fb39dd0f26852b7a/src%2Ftest%2Fui%2Fexpr%2Fif%2Fif-without-block.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexpr%2Fif%2Fif-without-block.stderr?ref=ff23ad3179014ba258f2b540fb39dd0f26852b7a", "patch": "@@ -7,7 +7,11 @@ LL |     if 5 == {\n LL | }\n    | ^ expected `{`\n    |\n-   = help: maybe you forgot the right operand of the condition?\n+help: maybe you forgot the right operand of the condition?\n+  --> $DIR/if-without-block.rs:3:10\n+   |\n+LL |     if 5 == {\n+   |          ^^\n \n error: aborting due to previous error\n "}, {"sha": "5a92bcd37b6eea8e7f96dee471cc3e2167a3980e", "filename": "src/test/ui/fn/implied-bounds-unnorm-associated-type-2.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ff23ad3179014ba258f2b540fb39dd0f26852b7a/src%2Ftest%2Fui%2Ffn%2Fimplied-bounds-unnorm-associated-type-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff23ad3179014ba258f2b540fb39dd0f26852b7a/src%2Ftest%2Fui%2Ffn%2Fimplied-bounds-unnorm-associated-type-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffn%2Fimplied-bounds-unnorm-associated-type-2.rs?ref=ff23ad3179014ba258f2b540fb39dd0f26852b7a", "patch": "@@ -0,0 +1,22 @@\n+// check-pass\n+\n+trait Trait {\n+    type Type;\n+}\n+\n+impl<T> Trait for T {\n+    type Type = ();\n+}\n+\n+fn f<'a, 'b>(_: <&'a &'b () as Trait>::Type)\n+where\n+    'a: 'a,\n+    'b: 'b,\n+{\n+}\n+\n+fn g<'a, 'b>() {\n+    f::<'a, 'b>(());\n+}\n+\n+fn main() {}"}, {"sha": "9366e94c90ff559e28fadab9c1ae74af214d17b0", "filename": "src/test/ui/lifetimes/issue-76168-hr-outlives.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ff23ad3179014ba258f2b540fb39dd0f26852b7a/src%2Ftest%2Fui%2Flifetimes%2Fissue-76168-hr-outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff23ad3179014ba258f2b540fb39dd0f26852b7a/src%2Ftest%2Fui%2Flifetimes%2Fissue-76168-hr-outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetimes%2Fissue-76168-hr-outlives.rs?ref=ff23ad3179014ba258f2b540fb39dd0f26852b7a", "patch": "@@ -0,0 +1,19 @@\n+// edition:2018\n+// check-pass\n+\n+#![feature(unboxed_closures)]\n+use std::future::Future;\n+\n+async fn wrapper<F>(f: F)\n+where for<'a> F: FnOnce<(&'a mut i32,)>,\n+    for<'a> <F as FnOnce<(&'a mut i32,)>>::Output: Future<Output=()> + 'a\n+{\n+    let mut i = 41;\n+    f(&mut i).await;\n+}\n+\n+async fn add_one(i: &mut i32) {\n+    *i = *i + 1;\n+}\n+\n+fn main() {}"}, {"sha": "9959df566383707aae0a5098e92292306ace6263", "filename": "src/test/ui/parser/issue-91421.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ff23ad3179014ba258f2b540fb39dd0f26852b7a/src%2Ftest%2Fui%2Fparser%2Fissue-91421.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff23ad3179014ba258f2b540fb39dd0f26852b7a/src%2Ftest%2Fui%2Fparser%2Fissue-91421.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-91421.rs?ref=ff23ad3179014ba258f2b540fb39dd0f26852b7a", "patch": "@@ -0,0 +1,10 @@\n+// Regression test for issue #91421.\n+\n+fn main() {\n+    let value = if true && {\n+    //~^ ERROR: this `if` expression has a condition, but no block\n+    //~| HELP: maybe you forgot the right operand of the condition?\n+        3\n+        //~^ ERROR: mismatched types [E0308]\n+    } else { 4 };\n+}"}, {"sha": "04284d5e3b2f719941b7eea25398abb261788728", "filename": "src/test/ui/parser/issue-91421.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ff23ad3179014ba258f2b540fb39dd0f26852b7a/src%2Ftest%2Fui%2Fparser%2Fissue-91421.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff23ad3179014ba258f2b540fb39dd0f26852b7a/src%2Ftest%2Fui%2Fparser%2Fissue-91421.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-91421.stderr?ref=ff23ad3179014ba258f2b540fb39dd0f26852b7a", "patch": "@@ -0,0 +1,21 @@\n+error: this `if` expression has a condition, but no block\n+  --> $DIR/issue-91421.rs:4:17\n+   |\n+LL |     let value = if true && {\n+   |                 ^^\n+   |\n+help: maybe you forgot the right operand of the condition?\n+  --> $DIR/issue-91421.rs:4:25\n+   |\n+LL |     let value = if true && {\n+   |                         ^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/issue-91421.rs:7:9\n+   |\n+LL |         3\n+   |         ^ expected `bool`, found integer\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "f0c0dd3ed95788616e4f8f40e7785c3820c6c22d", "filename": "src/test/ui/traits/project-modulo-regions.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/ff23ad3179014ba258f2b540fb39dd0f26852b7a/src%2Ftest%2Fui%2Ftraits%2Fproject-modulo-regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff23ad3179014ba258f2b540fb39dd0f26852b7a/src%2Ftest%2Fui%2Ftraits%2Fproject-modulo-regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fproject-modulo-regions.rs?ref=ff23ad3179014ba258f2b540fb39dd0f26852b7a", "patch": "@@ -0,0 +1,55 @@\n+// revisions: with_clause without_clause\n+// Tests that `EvaluatedToOkModuloRegions` from a projection sub-obligation\n+// is correctly propagated\n+\n+#![feature(rustc_attrs)]\n+\n+trait MyTrait {\n+    type Assoc;\n+}\n+\n+struct MyStruct;\n+\n+impl MyTrait for MyStruct {\n+    // Evaluating this projection will result in `EvaluatedToOkModuloRegions`\n+    // (when `with_clause` is enabled)\n+    type Assoc = <Bar as MyTrait>::Assoc;\n+}\n+\n+struct Bar;\n+\n+// The `where` clause on this impl will cause us to produce `EvaluatedToOkModuloRegions`\n+// when evaluating a projection involving this impl\n+#[cfg(with_clause)]\n+impl MyTrait for Bar where for<'b> &'b (): 'b {\n+    type Assoc = bool;\n+}\n+\n+// This impl tests that the `EvaluatedToOkModuoRegions` result that we get\n+// is really due to the `where` clause on the `with_clause` impl\n+#[cfg(without_clause)]\n+impl MyTrait for Bar {\n+    type Assoc = bool;\n+}\n+\n+// The implementation of `#[rustc_evaluate_where_clauses]` doesn't perform\n+// normalization, so we need to place the projection predicate behind a normal\n+// trait predicate\n+struct Helper {}\n+trait HelperTrait {}\n+impl HelperTrait for Helper where <MyStruct as MyTrait>::Assoc: Sized {}\n+\n+// Evaluating this 'where' clause will (recursively) end up evaluating\n+// `for<'b> &'b (): 'b`, which will produce `EvaluatedToOkModuloRegions`\n+#[rustc_evaluate_where_clauses]\n+fn test(val: MyStruct) where Helper: HelperTrait  {\n+    panic!()\n+}\n+\n+fn foo(val: MyStruct) {\n+    test(val);\n+    //[with_clause]~^     ERROR evaluate(Binder(TraitPredicate(<Helper as HelperTrait>, polarity:Positive), [])) = Ok(EvaluatedToOkModuloRegions)\n+    //[without_clause]~^^ ERROR evaluate(Binder(TraitPredicate(<Helper as HelperTrait>, polarity:Positive), [])) = Ok(EvaluatedToOk)\n+}\n+\n+fn main() {}"}, {"sha": "2434c32c8188266fe99ea9e5e9079135d8cea46f", "filename": "src/test/ui/traits/project-modulo-regions.with_clause.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ff23ad3179014ba258f2b540fb39dd0f26852b7a/src%2Ftest%2Fui%2Ftraits%2Fproject-modulo-regions.with_clause.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff23ad3179014ba258f2b540fb39dd0f26852b7a/src%2Ftest%2Fui%2Ftraits%2Fproject-modulo-regions.with_clause.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fproject-modulo-regions.with_clause.stderr?ref=ff23ad3179014ba258f2b540fb39dd0f26852b7a", "patch": "@@ -0,0 +1,11 @@\n+error: evaluate(Binder(TraitPredicate(<Helper as HelperTrait>, polarity:Positive), [])) = Ok(EvaluatedToOkModuloRegions)\n+  --> $DIR/project-modulo-regions.rs:50:5\n+   |\n+LL | fn test(val: MyStruct) where Helper: HelperTrait  {\n+   |                                      ----------- predicate\n+...\n+LL |     test(val);\n+   |     ^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "9d35690d5f0fe87ea581df6948b5a7ee64a683c3", "filename": "src/test/ui/traits/project-modulo-regions.without_clause.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ff23ad3179014ba258f2b540fb39dd0f26852b7a/src%2Ftest%2Fui%2Ftraits%2Fproject-modulo-regions.without_clause.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff23ad3179014ba258f2b540fb39dd0f26852b7a/src%2Ftest%2Fui%2Ftraits%2Fproject-modulo-regions.without_clause.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fproject-modulo-regions.without_clause.stderr?ref=ff23ad3179014ba258f2b540fb39dd0f26852b7a", "patch": "@@ -0,0 +1,11 @@\n+error: evaluate(Binder(TraitPredicate(<Helper as HelperTrait>, polarity:Positive), [])) = Ok(EvaluatedToOk)\n+  --> $DIR/project-modulo-regions.rs:50:5\n+   |\n+LL | fn test(val: MyStruct) where Helper: HelperTrait  {\n+   |                                      ----------- predicate\n+...\n+LL |     test(val);\n+   |     ^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "94200cce73ec0fb353cd94776115e7424f9de7fb", "filename": "src/test/ui/typeck/issue-91210-ptr-method.fixed", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ff23ad3179014ba258f2b540fb39dd0f26852b7a/src%2Ftest%2Fui%2Ftypeck%2Fissue-91210-ptr-method.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/ff23ad3179014ba258f2b540fb39dd0f26852b7a/src%2Ftest%2Fui%2Ftypeck%2Fissue-91210-ptr-method.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fissue-91210-ptr-method.fixed?ref=ff23ad3179014ba258f2b540fb39dd0f26852b7a", "patch": "@@ -0,0 +1,15 @@\n+// Regression test for issue #91210.\n+\n+// run-rustfix\n+\n+#![allow(unused)]\n+\n+struct Foo { read: i32 }\n+\n+unsafe fn blah(x: *mut Foo) {\n+    (*x).read = 4;\n+    //~^ ERROR: attempted to take value of method\n+    //~| HELP: to access the field, dereference first\n+}\n+\n+fn main() {}"}, {"sha": "ed0ce6effe7d90488f4cc550abfb56fde3cd399d", "filename": "src/test/ui/typeck/issue-91210-ptr-method.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ff23ad3179014ba258f2b540fb39dd0f26852b7a/src%2Ftest%2Fui%2Ftypeck%2Fissue-91210-ptr-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff23ad3179014ba258f2b540fb39dd0f26852b7a/src%2Ftest%2Fui%2Ftypeck%2Fissue-91210-ptr-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fissue-91210-ptr-method.rs?ref=ff23ad3179014ba258f2b540fb39dd0f26852b7a", "patch": "@@ -0,0 +1,15 @@\n+// Regression test for issue #91210.\n+\n+// run-rustfix\n+\n+#![allow(unused)]\n+\n+struct Foo { read: i32 }\n+\n+unsafe fn blah(x: *mut Foo) {\n+    x.read = 4;\n+    //~^ ERROR: attempted to take value of method\n+    //~| HELP: to access the field, dereference first\n+}\n+\n+fn main() {}"}, {"sha": "503a32373d5707fc32b80c4ebc059da7c31fcb31", "filename": "src/test/ui/typeck/issue-91210-ptr-method.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ff23ad3179014ba258f2b540fb39dd0f26852b7a/src%2Ftest%2Fui%2Ftypeck%2Fissue-91210-ptr-method.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff23ad3179014ba258f2b540fb39dd0f26852b7a/src%2Ftest%2Fui%2Ftypeck%2Fissue-91210-ptr-method.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fissue-91210-ptr-method.stderr?ref=ff23ad3179014ba258f2b540fb39dd0f26852b7a", "patch": "@@ -0,0 +1,11 @@\n+error[E0615]: attempted to take value of method `read` on type `*mut Foo`\n+  --> $DIR/issue-91210-ptr-method.rs:10:7\n+   |\n+LL |     x.read = 4;\n+   |     - ^^^^ method, not a field\n+   |     |\n+   |     help: to access the field, dereference first: `(*x)`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0615`."}]}