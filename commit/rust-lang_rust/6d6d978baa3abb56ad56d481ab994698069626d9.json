{"sha": "6d6d978baa3abb56ad56d481ab994698069626d9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZkNmQ5NzhiYWEzYWJiNTZhZDU2ZDQ4MWFiOTk0Njk4MDY5NjI2ZDk=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2019-10-04T00:10:37Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2019-10-09T17:17:29Z"}, "message": "Note when a mutable trait object is needed", "tree": {"sha": "c6d2c8024fadfe080de60afd9bd4d3efeee071c5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c6d2c8024fadfe080de60afd9bd4d3efeee071c5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6d6d978baa3abb56ad56d481ab994698069626d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6d6d978baa3abb56ad56d481ab994698069626d9", "html_url": "https://github.com/rust-lang/rust/commit/6d6d978baa3abb56ad56d481ab994698069626d9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6d6d978baa3abb56ad56d481ab994698069626d9/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ec557aa8180ca08ff749793b3d42383618b96044", "url": "https://api.github.com/repos/rust-lang/rust/commits/ec557aa8180ca08ff749793b3d42383618b96044", "html_url": "https://github.com/rust-lang/rust/commit/ec557aa8180ca08ff749793b3d42383618b96044"}], "stats": {"total": 317, "additions": 271, "deletions": 46}, "files": [{"sha": "f85ba1459f5f24a5e72cd669f9ac146b871dcce7", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 90, "deletions": 21, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/6d6d978baa3abb56ad56d481ab994698069626d9/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d6d978baa3abb56ad56d481ab994698069626d9/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=6d6d978baa3abb56ad56d481ab994698069626d9", "patch": "@@ -453,21 +453,17 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn find_similar_impl_candidates(&self,\n-                                    trait_ref: ty::PolyTraitRef<'tcx>)\n-                                    -> Vec<ty::TraitRef<'tcx>>\n-    {\n-        let simp = fast_reject::simplify_type(self.tcx,\n-                                              trait_ref.skip_binder().self_ty(),\n-                                              true);\n+    fn find_similar_impl_candidates(\n+        &self,\n+        trait_ref: ty::PolyTraitRef<'tcx>,\n+    ) -> Vec<ty::TraitRef<'tcx>> {\n+        let simp = fast_reject::simplify_type(self.tcx, trait_ref.skip_binder().self_ty(), true);\n         let all_impls = self.tcx.all_impls(trait_ref.def_id());\n \n         match simp {\n             Some(simp) => all_impls.iter().filter_map(|&def_id| {\n                 let imp = self.tcx.impl_trait_ref(def_id).unwrap();\n-                let imp_simp = fast_reject::simplify_type(self.tcx,\n-                                                          imp.self_ty(),\n-                                                          true);\n+                let imp_simp = fast_reject::simplify_type(self.tcx, imp.self_ty(), true);\n                 if let Some(imp_simp) = imp_simp {\n                     if simp != imp_simp {\n                         return None\n@@ -482,10 +478,11 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn report_similar_impl_candidates(&self,\n-                                      impl_candidates: Vec<ty::TraitRef<'tcx>>,\n-                                      err: &mut DiagnosticBuilder<'_>)\n-    {\n+    fn report_similar_impl_candidates(\n+        &self,\n+        impl_candidates: Vec<ty::TraitRef<'tcx>>,\n+        err: &mut DiagnosticBuilder<'_>,\n+    ) {\n         if impl_candidates.is_empty() {\n             return;\n         }\n@@ -720,10 +717,18 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                             // which is somewhat confusing.\n                             err.help(&format!(\"consider adding a `where {}` bound\",\n                                               trait_ref.to_predicate()));\n-                        } else if !have_alt_message {\n-                            // Can't show anything else useful, try to find similar impls.\n-                            let impl_candidates = self.find_similar_impl_candidates(trait_ref);\n-                            self.report_similar_impl_candidates(impl_candidates, &mut err);\n+                        } else {\n+                            if !have_alt_message {\n+                                // Can't show anything else useful, try to find similar impls.\n+                                let impl_candidates = self.find_similar_impl_candidates(trait_ref);\n+                                self.report_similar_impl_candidates(impl_candidates, &mut err);\n+                            }\n+                            self.suggest_change_mut(\n+                                &obligation,\n+                                &mut err,\n+                                &trait_ref,\n+                                points_at_arg,\n+                            );\n                         }\n \n                         // If this error is due to `!: Trait` not implemented but `(): Trait` is\n@@ -1081,9 +1086,11 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n                     let substs = self.tcx.mk_substs_trait(trait_type, &[]);\n                     let new_trait_ref = ty::TraitRef::new(trait_ref.def_id, substs);\n-                    let new_obligation = Obligation::new(ObligationCause::dummy(),\n-                                                         obligation.param_env,\n-                                                         new_trait_ref.to_predicate());\n+                    let new_obligation = Obligation::new(\n+                        ObligationCause::dummy(),\n+                        obligation.param_env,\n+                        new_trait_ref.to_predicate(),\n+                    );\n \n                     if self.predicate_may_hold(&new_obligation) {\n                         let sp = self.tcx.sess.source_map()\n@@ -1105,6 +1112,68 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n     }\n \n+    /// Check if the trait bound is implemented for a different mutability and note it in the\n+    /// final error.\n+    fn suggest_change_mut(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+        err: &mut DiagnosticBuilder<'tcx>,\n+        trait_ref: &ty::Binder<ty::TraitRef<'tcx>>,\n+        points_at_arg: bool,\n+    ) {\n+        let span = obligation.cause.span;\n+        if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) {\n+            let refs_number = snippet.chars()\n+                .filter(|c| !c.is_whitespace())\n+                .take_while(|c| *c == '&')\n+                .count();\n+            if let Some('\\'') = snippet.chars()\n+                .filter(|c| !c.is_whitespace())\n+                .skip(refs_number)\n+                .next()\n+            { // Do not suggest removal of borrow from type arguments.\n+                return;\n+            }\n+\n+            if let ty::Ref(region, t_type, mutability) = trait_ref.skip_binder().self_ty().kind {\n+                let trait_type = match mutability {\n+                    hir::Mutability::MutMutable => self.tcx.mk_imm_ref(region, t_type),\n+                    hir::Mutability::MutImmutable => self.tcx.mk_mut_ref(region, t_type),\n+                };\n+\n+                let substs = self.tcx.mk_substs_trait(&trait_type, &[]);\n+                let new_trait_ref = ty::TraitRef::new(trait_ref.skip_binder().def_id, substs);\n+                let new_obligation = Obligation::new(\n+                    ObligationCause::dummy(),\n+                    obligation.param_env,\n+                    new_trait_ref.to_predicate(),\n+                );\n+\n+                if self.predicate_may_hold(&new_obligation) {\n+                    let sp = self.tcx.sess.source_map()\n+                        .span_take_while(span, |c| c.is_whitespace() || *c == '&');\n+                    if points_at_arg &&\n+                        mutability == hir::Mutability::MutImmutable &&\n+                        refs_number > 0\n+                    {\n+                        err.span_suggestion(\n+                            sp,\n+                            \"consider changing this borrow's mutability\",\n+                            \"&mut \".to_string(),\n+                            Applicability::MachineApplicable,\n+                        );\n+                    } else {\n+                        err.note(&format!(\n+                            \"`{}` is implemented for `{:?}`\",\n+                            trait_ref,\n+                            trait_type,\n+                        ));\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n     fn suggest_semicolon_removal(\n         &self,\n         obligation: &PredicateObligation<'tcx>,"}, {"sha": "4522be21cab50769955aa65c33114f523ec67e49", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 40, "deletions": 24, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/6d6d978baa3abb56ad56d481ab994698069626d9/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d6d978baa3abb56ad56d481ab994698069626d9/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=6d6d978baa3abb56ad56d481ab994698069626d9", "patch": "@@ -58,7 +58,7 @@ pub enum MethodError<'tcx> {\n \n     // Found a `Self: Sized` bound where `Self` is a trait object, also the caller may have\n     // forgotten to import a trait.\n-    IllegalSizedBound(Vec<DefId>),\n+    IllegalSizedBound(Vec<DefId>, bool),\n \n     // Found a match, but the return type is wrong\n     BadReturnType,\n@@ -213,33 +213,49 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             segment,\n         );\n \n+        let mut needs_mut = false;\n+        if let ty::Ref(region, t_type, mutability) = self_ty.kind {\n+            let trait_type = match mutability {\n+                hir::Mutability::MutMutable => self.tcx.mk_imm_ref(region, t_type),\n+                hir::Mutability::MutImmutable => self.tcx.mk_mut_ref(region, t_type),\n+            };\n+            match self.lookup_probe(\n+                span,\n+                segment.ident,\n+                trait_type,\n+                call_expr,\n+                ProbeScope::TraitsInScope\n+            ) {\n+                Ok(ref new_pick) if *new_pick != pick => {\n+                    needs_mut = true;\n+                }\n+                _ => {}\n+            }\n+        }\n+\n         if result.illegal_sized_bound {\n             // We probe again, taking all traits into account (not only those in scope).\n-            let candidates =\n-                match self.lookup_probe(span,\n-                                        segment.ident,\n-                                        self_ty,\n-                                        call_expr,\n-                                        ProbeScope::AllTraits) {\n-\n-                    // If we find a different result the caller probably forgot to import a trait.\n-                    Ok(ref new_pick) if *new_pick != pick => vec![new_pick.item.container.id()],\n-                    Err(Ambiguity(ref sources)) => {\n-                        sources.iter()\n-                               .filter_map(|source| {\n-                                   match *source {\n-                                       // Note: this cannot come from an inherent impl,\n-                                       // because the first probing succeeded.\n-                                       ImplSource(def) => self.tcx.trait_id_of_impl(def),\n-                                       TraitSource(_) => None,\n-                                   }\n-                               })\n-                               .collect()\n+            let candidates = match self.lookup_probe(\n+                span,\n+                segment.ident,\n+                self_ty,\n+                call_expr,\n+                ProbeScope::AllTraits,\n+            ) {\n+                // If we find a different result the caller probably forgot to import a trait.\n+                Ok(ref new_pick) if *new_pick != pick => vec![new_pick.item.container.id()],\n+                Err(Ambiguity(ref sources)) => sources.iter().filter_map(|source| {\n+                    match *source {\n+                        // Note: this cannot come from an inherent impl,\n+                        // because the first probing succeeded.\n+                        ImplSource(def) => self.tcx.trait_id_of_impl(def),\n+                        TraitSource(_) => None,\n                     }\n-                    _ => Vec::new(),\n-                };\n+                }).collect(),\n+                _ => Vec::new(),\n+            };\n \n-            return Err(IllegalSizedBound(candidates));\n+            return Err(IllegalSizedBound(candidates, needs_mut));\n         }\n \n         Ok(result.callee)"}, {"sha": "a30b7faca0db31fa4077404fb71f479299e923f2", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6d6d978baa3abb56ad56d481ab994698069626d9/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d6d978baa3abb56ad56d481ab994698069626d9/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=6d6d978baa3abb56ad56d481ab994698069626d9", "patch": "@@ -560,7 +560,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 err.emit();\n             }\n \n-            MethodError::IllegalSizedBound(candidates) => {\n+            MethodError::IllegalSizedBound(candidates, needs_mut) => {\n                 let msg = format!(\"the `{}` method cannot be invoked on a trait object\", item_name);\n                 let mut err = self.sess().struct_span_err(span, &msg);\n                 if !candidates.is_empty() {\n@@ -576,6 +576,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                     });\n                     self.suggest_use_candidates(&mut err, help, candidates);\n                 }\n+                if let ty::Ref(region, t_type, mutability) = rcvr_ty.kind {\n+                    let trait_type = match mutability {\n+                        hir::Mutability::MutMutable => self.tcx.mk_imm_ref(region, t_type),\n+                        hir::Mutability::MutImmutable => self.tcx.mk_mut_ref(region, t_type),\n+                    };\n+                    if needs_mut {\n+                        err.note(&format!(\"you need `{}` instead\", trait_type));\n+                    }\n+                }\n                 err.emit();\n             }\n "}, {"sha": "2ae5ba523a70fe2492408cfa5e622b1eb42f1477", "filename": "src/test/ui/not-panic/not-panic-safe.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6d6d978baa3abb56ad56d481ab994698069626d9/src%2Ftest%2Fui%2Fnot-panic%2Fnot-panic-safe.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6d6d978baa3abb56ad56d481ab994698069626d9/src%2Ftest%2Fui%2Fnot-panic%2Fnot-panic-safe.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnot-panic%2Fnot-panic-safe.stderr?ref=6d6d978baa3abb56ad56d481ab994698069626d9", "patch": "@@ -8,6 +8,7 @@ LL |     assert::<&mut i32>();\n    |     ^^^^^^^^^^^^^^^^^^ `&mut i32` may not be safely transferred across an unwind boundary\n    |\n    = help: the trait `std::panic::UnwindSafe` is not implemented for `&mut i32`\n+   = note: `std::panic::UnwindSafe` is implemented for `&i32`\n \n error: aborting due to previous error\n "}, {"sha": "4792aacefe5e9eedd46daffd4a817d991d70e215", "filename": "src/test/ui/parser/lex-bad-char-literals-6.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d6d978baa3abb56ad56d481ab994698069626d9/src%2Ftest%2Fui%2Fparser%2Flex-bad-char-literals-6.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6d6d978baa3abb56ad56d481ab994698069626d9/src%2Ftest%2Fui%2Fparser%2Flex-bad-char-literals-6.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Flex-bad-char-literals-6.stderr?ref=6d6d978baa3abb56ad56d481ab994698069626d9", "patch": "@@ -35,6 +35,7 @@ LL |     if x == y {}\n    |          ^^ no implementation for `&str == char`\n    |\n    = help: the trait `std::cmp::PartialEq<char>` is not implemented for `&str`\n+   = note: `std::cmp::PartialEq<char>` is implemented for `&mut str`\n \n error[E0308]: mismatched types\n   --> $DIR/lex-bad-char-literals-6.rs:15:20\n@@ -52,6 +53,7 @@ LL |     if x == z {}\n    |          ^^ no implementation for `&str == char`\n    |\n    = help: the trait `std::cmp::PartialEq<char>` is not implemented for `&str`\n+   = note: `std::cmp::PartialEq<char>` is implemented for `&mut str`\n \n error: aborting due to 6 previous errors\n "}, {"sha": "22ca6dde45eee1eac39177ce95cffd5fc5081389", "filename": "src/test/ui/suggestions/imm-ref-trait-object-literal.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6d6d978baa3abb56ad56d481ab994698069626d9/src%2Ftest%2Fui%2Fsuggestions%2Fimm-ref-trait-object-literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d6d978baa3abb56ad56d481ab994698069626d9/src%2Ftest%2Fui%2Fsuggestions%2Fimm-ref-trait-object-literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fimm-ref-trait-object-literal.rs?ref=6d6d978baa3abb56ad56d481ab994698069626d9", "patch": "@@ -0,0 +1,14 @@\n+trait Trait {}\n+\n+struct S;\n+\n+impl<'a> Trait for &'a mut S {}\n+\n+fn foo<X: Trait>(_: X) {}\n+\n+\n+fn main() {\n+  let s = S;\n+  foo(&s); //~ ERROR the trait bound `&S: Trait` is not satisfied\n+  foo(s); //~ ERROR the trait bound `S: Trait` is not satisfied\n+}"}, {"sha": "ccaceefacd739649761db3181773aac6c8c199c3", "filename": "src/test/ui/suggestions/imm-ref-trait-object-literal.stderr", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/6d6d978baa3abb56ad56d481ab994698069626d9/src%2Ftest%2Fui%2Fsuggestions%2Fimm-ref-trait-object-literal.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6d6d978baa3abb56ad56d481ab994698069626d9/src%2Ftest%2Fui%2Fsuggestions%2Fimm-ref-trait-object-literal.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fimm-ref-trait-object-literal.stderr?ref=6d6d978baa3abb56ad56d481ab994698069626d9", "patch": "@@ -0,0 +1,30 @@\n+error[E0277]: the trait bound `&S: Trait` is not satisfied\n+  --> $DIR/imm-ref-trait-object-literal.rs:12:7\n+   |\n+LL | fn foo<X: Trait>(_: X) {}\n+   |    ---    ----- required by this bound in `foo`\n+...\n+LL |   foo(&s);\n+   |       -^\n+   |       |\n+   |       the trait `Trait` is not implemented for `&S`\n+   |       help: consider changing this borrow's mutability: `&mut`\n+   |\n+   = help: the following implementations were found:\n+             <&'a mut S as Trait>\n+\n+error[E0277]: the trait bound `S: Trait` is not satisfied\n+  --> $DIR/imm-ref-trait-object-literal.rs:13:7\n+   |\n+LL | fn foo<X: Trait>(_: X) {}\n+   |    ---    ----- required by this bound in `foo`\n+...\n+LL |   foo(s);\n+   |       ^ the trait `Trait` is not implemented for `S`\n+   |\n+   = help: the following implementations were found:\n+             <&'a mut S as Trait>\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "288d6c699f59a03a38335fea9aef48938e33288b", "filename": "src/test/ui/suggestions/imm-ref-trait-object.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6d6d978baa3abb56ad56d481ab994698069626d9/src%2Ftest%2Fui%2Fsuggestions%2Fimm-ref-trait-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d6d978baa3abb56ad56d481ab994698069626d9/src%2Ftest%2Fui%2Fsuggestions%2Fimm-ref-trait-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fimm-ref-trait-object.rs?ref=6d6d978baa3abb56ad56d481ab994698069626d9", "patch": "@@ -0,0 +1,8 @@\n+fn test(t: &dyn Iterator<Item=&u64>) -> u64 {\n+     t.min().unwrap() //~ ERROR the `min` method cannot be invoked on a trait object\n+}\n+\n+fn main() {\n+     let array = [0u64];\n+     test(&mut array.iter());\n+}"}, {"sha": "e272d2a73f52c29b3b7e7e3c5f8565c0789bf0d9", "filename": "src/test/ui/suggestions/imm-ref-trait-object.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6d6d978baa3abb56ad56d481ab994698069626d9/src%2Ftest%2Fui%2Fsuggestions%2Fimm-ref-trait-object.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6d6d978baa3abb56ad56d481ab994698069626d9/src%2Ftest%2Fui%2Fsuggestions%2Fimm-ref-trait-object.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fimm-ref-trait-object.stderr?ref=6d6d978baa3abb56ad56d481ab994698069626d9", "patch": "@@ -0,0 +1,10 @@\n+error: the `min` method cannot be invoked on a trait object\n+  --> $DIR/imm-ref-trait-object.rs:2:8\n+   |\n+LL |      t.min().unwrap()\n+   |        ^^^\n+   |\n+   = note: you need `&mut dyn std::iter::Iterator<Item = &u64>` instead\n+\n+error: aborting due to previous error\n+"}, {"sha": "6af1267f26faf7073ad861731deff552c04124e5", "filename": "src/test/ui/suggestions/into-str.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6d6d978baa3abb56ad56d481ab994698069626d9/src%2Ftest%2Fui%2Fsuggestions%2Finto-str.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6d6d978baa3abb56ad56d481ab994698069626d9/src%2Ftest%2Fui%2Fsuggestions%2Finto-str.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Finto-str.stderr?ref=6d6d978baa3abb56ad56d481ab994698069626d9", "patch": "@@ -8,6 +8,7 @@ LL |     foo(String::new());\n    |     ^^^ the trait `std::convert::From<std::string::String>` is not implemented for `&str`\n    |\n    = note: to coerce a `std::string::String` into a `&str`, use `&*` as a prefix\n+   = note: `std::convert::From<std::string::String>` is implemented for `&mut str`\n    = note: required because of the requirements on the impl of `std::convert::Into<&str>` for `std::string::String`\n \n error: aborting due to previous error"}, {"sha": "dcef2ada63beac30a15d76f58ef2f085acf908b2", "filename": "src/test/ui/suggestions/mut-borrow-needed-by-trait.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/6d6d978baa3abb56ad56d481ab994698069626d9/src%2Ftest%2Fui%2Fsuggestions%2Fmut-borrow-needed-by-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d6d978baa3abb56ad56d481ab994698069626d9/src%2Ftest%2Fui%2Fsuggestions%2Fmut-borrow-needed-by-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmut-borrow-needed-by-trait.rs?ref=6d6d978baa3abb56ad56d481ab994698069626d9", "patch": "@@ -0,0 +1,23 @@\n+use std::env::args;\n+use std::fs::File;\n+use std::io::{stdout, Write, BufWriter};\n+\n+fn main() {\n+    let mut args = args();\n+    let _ = args.next();\n+    let dest = args.next();\n+\n+    let h1; let h2; let h3;\n+\n+    let fp: &dyn Write = match dest {\n+        Some(path) => { h1 = File::create(path).unwrap(); &h1 },\n+        None => { h2 = stdout(); h3 = h2.lock(); &h3 }\n+    };\n+\n+    let fp = BufWriter::new(fp);\n+    //~^ ERROR the trait bound `&dyn std::io::Write: std::io::Write` is not satisfied\n+    //~| ERROR the trait bound `&dyn std::io::Write: std::io::Write` is not satisfied\n+    //~| ERROR the trait bound `&dyn std::io::Write: std::io::Write` is not satisfied\n+\n+    writeln!(fp, \"hello world\").unwrap(); //~ ERROR no method named `write_fmt` found for type\n+}"}, {"sha": "66dc5b66744bdba1800691727ab57030304609e5", "filename": "src/test/ui/suggestions/mut-borrow-needed-by-trait.stderr", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/6d6d978baa3abb56ad56d481ab994698069626d9/src%2Ftest%2Fui%2Fsuggestions%2Fmut-borrow-needed-by-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6d6d978baa3abb56ad56d481ab994698069626d9/src%2Ftest%2Fui%2Fsuggestions%2Fmut-borrow-needed-by-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmut-borrow-needed-by-trait.stderr?ref=6d6d978baa3abb56ad56d481ab994698069626d9", "patch": "@@ -0,0 +1,41 @@\n+error[E0277]: the trait bound `&dyn std::io::Write: std::io::Write` is not satisfied\n+  --> $DIR/mut-borrow-needed-by-trait.rs:17:29\n+   |\n+LL |     let fp = BufWriter::new(fp);\n+   |                             ^^ the trait `std::io::Write` is not implemented for `&dyn std::io::Write`\n+   |\n+   = note: `std::io::Write` is implemented for `&mut dyn std::io::Write`\n+   = note: required by `std::io::BufWriter::<W>::new`\n+\n+error[E0277]: the trait bound `&dyn std::io::Write: std::io::Write` is not satisfied\n+  --> $DIR/mut-borrow-needed-by-trait.rs:17:14\n+   |\n+LL |     let fp = BufWriter::new(fp);\n+   |              ^^^^^^^^^^^^^^ the trait `std::io::Write` is not implemented for `&dyn std::io::Write`\n+   |\n+   = note: `std::io::Write` is implemented for `&mut dyn std::io::Write`\n+   = note: required by `std::io::BufWriter`\n+\n+error[E0277]: the trait bound `&dyn std::io::Write: std::io::Write` is not satisfied\n+  --> $DIR/mut-borrow-needed-by-trait.rs:17:14\n+   |\n+LL |     let fp = BufWriter::new(fp);\n+   |              ^^^^^^^^^^^^^^^^^^ the trait `std::io::Write` is not implemented for `&dyn std::io::Write`\n+   |\n+   = note: `std::io::Write` is implemented for `&mut dyn std::io::Write`\n+   = note: required by `std::io::BufWriter`\n+\n+error[E0599]: no method named `write_fmt` found for type `std::io::BufWriter<&dyn std::io::Write>` in the current scope\n+  --> $DIR/mut-borrow-needed-by-trait.rs:22:5\n+   |\n+LL |     writeln!(fp, \"hello world\").unwrap();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `std::io::BufWriter<&dyn std::io::Write>`\n+   |\n+   = note: the method `write_fmt` exists but the following trait bounds were not satisfied:\n+           `std::io::BufWriter<&dyn std::io::Write> : std::io::Write`\n+   = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n+\n+error: aborting due to 4 previous errors\n+\n+Some errors have detailed explanations: E0277, E0599.\n+For more information about an error, try `rustc --explain E0277`."}, {"sha": "069b0a4db6c6f51e8974b9c210f543760164954a", "filename": "src/test/ui/suggestions/suggest-remove-refs-1.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6d6d978baa3abb56ad56d481ab994698069626d9/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-remove-refs-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6d6d978baa3abb56ad56d481ab994698069626d9/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-remove-refs-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-remove-refs-1.stderr?ref=6d6d978baa3abb56ad56d481ab994698069626d9", "patch": "@@ -8,6 +8,7 @@ LL |     for (i, n) in &v.iter().enumerate() {\n    |                   help: consider removing 1 leading `&`-references\n    |\n    = help: the trait `std::iter::Iterator` is not implemented for `&std::iter::Enumerate<std::slice::Iter<'_, {integer}>>`\n+   = note: `std::iter::Iterator` is implemented for `&mut std::iter::Enumerate<std::slice::Iter<'_, {integer}>>`\n    = note: required by `std::iter::IntoIterator::into_iter`\n \n error: aborting due to previous error"}]}