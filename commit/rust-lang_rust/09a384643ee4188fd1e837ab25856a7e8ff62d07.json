{"sha": "09a384643ee4188fd1e837ab25856a7e8ff62d07", "node_id": "C_kwDOAAsO6NoAKDA5YTM4NDY0M2VlNDE4OGZkMWU4MzdhYjI1ODU2YTdlOGZmNjJkMDc", "commit": {"author": {"name": "hkalbasi", "email": "hamidrezakalbasi@protonmail.com", "date": "2022-10-28T15:15:55Z"}, "committer": {"name": "hkalbasi", "email": "hamidrezakalbasi@protonmail.com", "date": "2022-11-24T12:56:12Z"}, "message": "make rustc_target usable outside of rustc", "tree": {"sha": "19e82633eeffe94899549fb59b84f16ab0eb91f9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/19e82633eeffe94899549fb59b84f16ab0eb91f9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/09a384643ee4188fd1e837ab25856a7e8ff62d07", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/09a384643ee4188fd1e837ab25856a7e8ff62d07", "html_url": "https://github.com/rust-lang/rust/commit/09a384643ee4188fd1e837ab25856a7e8ff62d07", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/09a384643ee4188fd1e837ab25856a7e8ff62d07/comments", "author": {"login": "HKalbasi", "id": 45197576, "node_id": "MDQ6VXNlcjQ1MTk3NTc2", "avatar_url": "https://avatars.githubusercontent.com/u/45197576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HKalbasi", "html_url": "https://github.com/HKalbasi", "followers_url": "https://api.github.com/users/HKalbasi/followers", "following_url": "https://api.github.com/users/HKalbasi/following{/other_user}", "gists_url": "https://api.github.com/users/HKalbasi/gists{/gist_id}", "starred_url": "https://api.github.com/users/HKalbasi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HKalbasi/subscriptions", "organizations_url": "https://api.github.com/users/HKalbasi/orgs", "repos_url": "https://api.github.com/users/HKalbasi/repos", "events_url": "https://api.github.com/users/HKalbasi/events{/privacy}", "received_events_url": "https://api.github.com/users/HKalbasi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "HKalbasi", "id": 45197576, "node_id": "MDQ6VXNlcjQ1MTk3NTc2", "avatar_url": "https://avatars.githubusercontent.com/u/45197576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HKalbasi", "html_url": "https://github.com/HKalbasi", "followers_url": "https://api.github.com/users/HKalbasi/followers", "following_url": "https://api.github.com/users/HKalbasi/following{/other_user}", "gists_url": "https://api.github.com/users/HKalbasi/gists{/gist_id}", "starred_url": "https://api.github.com/users/HKalbasi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HKalbasi/subscriptions", "organizations_url": "https://api.github.com/users/HKalbasi/orgs", "repos_url": "https://api.github.com/users/HKalbasi/repos", "events_url": "https://api.github.com/users/HKalbasi/events{/privacy}", "received_events_url": "https://api.github.com/users/HKalbasi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1dda298ad39a64e019a3511139c5b13ac0a18e54", "url": "https://api.github.com/repos/rust-lang/rust/commits/1dda298ad39a64e019a3511139c5b13ac0a18e54", "html_url": "https://github.com/rust-lang/rust/commit/1dda298ad39a64e019a3511139c5b13ac0a18e54"}], "stats": {"total": 240, "additions": 163, "deletions": 77}, "files": [{"sha": "e1cda5a9edda30f8b8d4a3154bbe7b467650c66f", "filename": "compiler/rustc_index/Cargo.toml", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/09a384643ee4188fd1e837ab25856a7e8ff62d07/compiler%2Frustc_index%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/09a384643ee4188fd1e837ab25856a7e8ff62d07/compiler%2Frustc_index%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2FCargo.toml?ref=09a384643ee4188fd1e837ab25856a7e8ff62d07", "patch": "@@ -7,6 +7,10 @@ edition = \"2021\"\n \n [dependencies]\n arrayvec = { version = \"0.7\", default-features = false }\n-rustc_serialize = { path = \"../rustc_serialize\" }\n-rustc_macros = { path = \"../rustc_macros\" }\n+rustc_serialize = { path = \"../rustc_serialize\", optional = true }\n+rustc_macros = { path = \"../rustc_macros\", optional = true }\n smallvec = \"1.8.1\"\n+\n+[features]\n+default = [\"nightly\"]\n+nightly = [\"rustc_serialize\", \"rustc_macros\"]"}, {"sha": "03d8ee139188df3b98a1fc248baa4cdb3bf6c18b", "filename": "compiler/rustc_index/src/lib.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/09a384643ee4188fd1e837ab25856a7e8ff62d07/compiler%2Frustc_index%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09a384643ee4188fd1e837ab25856a7e8ff62d07/compiler%2Frustc_index%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2Fsrc%2Flib.rs?ref=09a384643ee4188fd1e837ab25856a7e8ff62d07", "patch": "@@ -1,17 +1,20 @@\n #![deny(rustc::untranslatable_diagnostic)]\n #![deny(rustc::diagnostic_outside_of_impl)]\n-#![feature(allow_internal_unstable)]\n-#![feature(extend_one)]\n-#![feature(min_specialization)]\n-#![feature(new_uninit)]\n-#![feature(step_trait)]\n-#![feature(stmt_expr_attributes)]\n-#![feature(test)]\n+#![cfg_attr(feature = \"nightly\", feature(allow_internal_unstable))]\n+#![cfg_attr(feature = \"nightly\", feature(extend_one))]\n+#![cfg_attr(feature = \"nightly\", feature(min_specialization))]\n+#![cfg_attr(feature = \"nightly\", feature(new_uninit))]\n+#![cfg_attr(feature = \"nightly\", feature(step_trait))]\n+#![cfg_attr(feature = \"nightly\", feature(stmt_expr_attributes))]\n+#![cfg_attr(feature = \"nightly\", feature(test))]\n \n+#[cfg(feature = \"nightly\")]\n pub mod bit_set;\n+#[cfg(feature = \"nightly\")]\n pub mod interval;\n pub mod vec;\n \n+#[cfg(feature = \"rustc_macros\")]\n pub use rustc_macros::newtype_index;\n \n /// Type size assertion. The first argument is a type and the second argument is its expected size."}, {"sha": "39aa27a23c1d2ceeb62825d123893566f57729be", "filename": "compiler/rustc_index/src/vec.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/09a384643ee4188fd1e837ab25856a7e8ff62d07/compiler%2Frustc_index%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09a384643ee4188fd1e837ab25856a7e8ff62d07/compiler%2Frustc_index%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2Fsrc%2Fvec.rs?ref=09a384643ee4188fd1e837ab25856a7e8ff62d07", "patch": "@@ -1,3 +1,4 @@\n+#[cfg(feature = \"rustc_serialize\")]\n use rustc_serialize::{Decodable, Decoder, Encodable, Encoder};\n \n use std::fmt;\n@@ -61,12 +62,14 @@ pub struct IndexVec<I: Idx, T> {\n // not the phantom data.\n unsafe impl<I: Idx, T> Send for IndexVec<I, T> where T: Send {}\n \n+#[cfg(feature = \"rustc_serialize\")]\n impl<S: Encoder, I: Idx, T: Encodable<S>> Encodable<S> for IndexVec<I, T> {\n     fn encode(&self, s: &mut S) {\n         Encodable::encode(&self.raw, s);\n     }\n }\n \n+#[cfg(feature = \"rustc_serialize\")]\n impl<D: Decoder, I: Idx, T: Decodable<D>> Decodable<D> for IndexVec<I, T> {\n     fn decode(d: &mut D) -> Self {\n         IndexVec { raw: Decodable::decode(d), _marker: PhantomData }\n@@ -359,11 +362,13 @@ impl<I: Idx, T> Extend<T> for IndexVec<I, T> {\n     }\n \n     #[inline]\n+    #[cfg(feature = \"nightly\")]\n     fn extend_one(&mut self, item: T) {\n         self.raw.push(item);\n     }\n \n     #[inline]\n+    #[cfg(feature = \"nightly\")]\n     fn extend_reserve(&mut self, additional: usize) {\n         self.raw.reserve(additional);\n     }"}, {"sha": "7bd4b6c0c2767b88da187bceef23f07bc02fe241", "filename": "compiler/rustc_middle/src/arena.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09a384643ee4188fd1e837ab25856a7e8ff62d07/compiler%2Frustc_middle%2Fsrc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09a384643ee4188fd1e837ab25856a7e8ff62d07/compiler%2Frustc_middle%2Fsrc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Farena.rs?ref=09a384643ee4188fd1e837ab25856a7e8ff62d07", "patch": "@@ -6,7 +6,7 @@\n macro_rules! arena_types {\n     ($macro:path) => (\n         $macro!([\n-            [] layout: rustc_target::abi::LayoutS<'tcx>,\n+            [] layout: rustc_target::abi::LayoutS<rustc_target::abi::VariantIdx>,\n             [] fn_abi: rustc_target::abi::call::FnAbi<'tcx, rustc_middle::ty::Ty<'tcx>>,\n             // AdtDef are interned and compared by address\n             [decode] adt_def: rustc_middle::ty::AdtDefData,"}, {"sha": "f298e44e089364b72cca21b3e840241fa00dfbb2", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/09a384643ee4188fd1e837ab25856a7e8ff62d07/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09a384643ee4188fd1e837ab25856a7e8ff62d07/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=09a384643ee4188fd1e837ab25856a7e8ff62d07", "patch": "@@ -148,7 +148,7 @@ pub struct CtxtInterners<'tcx> {\n     const_: InternedSet<'tcx, ConstS<'tcx>>,\n     const_allocation: InternedSet<'tcx, Allocation>,\n     bound_variable_kinds: InternedSet<'tcx, List<ty::BoundVariableKind>>,\n-    layout: InternedSet<'tcx, LayoutS<'tcx>>,\n+    layout: InternedSet<'tcx, LayoutS<VariantIdx>>,\n     adt_def: InternedSet<'tcx, AdtDefData>,\n }\n \n@@ -2244,7 +2244,7 @@ direct_interners! {\n     region: mk_region(RegionKind<'tcx>): Region -> Region<'tcx>,\n     const_: mk_const_internal(ConstS<'tcx>): Const -> Const<'tcx>,\n     const_allocation: intern_const_alloc(Allocation): ConstAllocation -> ConstAllocation<'tcx>,\n-    layout: intern_layout(LayoutS<'tcx>): Layout -> Layout<'tcx>,\n+    layout: intern_layout(LayoutS<VariantIdx>): Layout -> Layout<'tcx>,\n     adt_def: intern_adt_def(AdtDefData): AdtDef -> AdtDef<'tcx>,\n }\n "}, {"sha": "fea2aa8cbf821743c04b3b475e77ab04d6f91607", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09a384643ee4188fd1e837ab25856a7e8ff62d07/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09a384643ee4188fd1e837ab25856a7e8ff62d07/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=09a384643ee4188fd1e837ab25856a7e8ff62d07", "patch": "@@ -610,7 +610,7 @@ where\n                 })\n             }\n \n-            Variants::Multiple { ref variants, .. } => variants[variant_index],\n+            Variants::Multiple { ref variants, .. } => cx.tcx().intern_layout(variants[variant_index].clone()),\n         };\n \n         assert_eq!(*layout.variants(), Variants::Single { index: variant_index });"}, {"sha": "58eb4f69c44f90b84f515b348a7cbac938ec765e", "filename": "compiler/rustc_target/Cargo.toml", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/09a384643ee4188fd1e837ab25856a7e8ff62d07/compiler%2Frustc_target%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/09a384643ee4188fd1e837ab25856a7e8ff62d07/compiler%2Frustc_target%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2FCargo.toml?ref=09a384643ee4188fd1e837ab25856a7e8ff62d07", "patch": "@@ -7,9 +7,20 @@ edition = \"2021\"\n bitflags = \"1.2.1\"\n tracing = \"0.1\"\n serde_json = \"1.0.59\"\n-rustc_data_structures = { path = \"../rustc_data_structures\" }\n-rustc_feature = { path = \"../rustc_feature\" }\n-rustc_index = { path = \"../rustc_index\" }\n-rustc_macros = { path = \"../rustc_macros\" }\n-rustc_serialize = { path = \"../rustc_serialize\" }\n-rustc_span = { path = \"../rustc_span\" }\n+rustc_data_structures = { path = \"../rustc_data_structures\", optional = true  }\n+rustc_feature = { path = \"../rustc_feature\", optional = true }\n+rustc_index = { path = \"../rustc_index\", default-features = false }\n+rustc_macros = { path = \"../rustc_macros\", optional = true }\n+rustc_serialize = { path = \"../rustc_serialize\", optional = true  }\n+rustc_span = { path = \"../rustc_span\", optional = true }\n+\n+[features]\n+default = [\"nightly\"]\n+nightly = [\n+    \"rustc_data_structures\",\n+    \"rustc_feature\",\n+    \"rustc_index/nightly\",\n+    \"rustc_macros\",\n+    \"rustc_serialize\",\n+    \"rustc_span\",\n+]\n\\ No newline at end of file"}, {"sha": "fa6af2ed7f3a039fa9ba6d9109cc9691fef43b6d", "filename": "compiler/rustc_target/src/abi/mod.rs", "status": "modified", "additions": 93, "deletions": 34, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/09a384643ee4188fd1e837ab25856a7e8ff62d07/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09a384643ee4188fd1e837ab25856a7e8ff62d07/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs?ref=09a384643ee4188fd1e837ab25856a7e8ff62d07", "patch": "@@ -2,23 +2,29 @@ pub use Integer::*;\n pub use Primitive::*;\n \n use crate::json::{Json, ToJson};\n+#[cfg(feature = \"nightly\")]\n use crate::spec::Target;\n \n use std::convert::{TryFrom, TryInto};\n use std::fmt;\n+#[cfg(feature = \"nightly\")]\n use std::iter::Step;\n use std::num::{NonZeroUsize, ParseIntError};\n use std::ops::{Add, AddAssign, Deref, Mul, RangeInclusive, Sub};\n use std::str::FromStr;\n \n+#[cfg(feature = \"nightly\")]\n use rustc_data_structures::intern::Interned;\n use rustc_index::vec::{Idx, IndexVec};\n+#[cfg(feature = \"nightly\")]\n use rustc_macros::HashStable_Generic;\n \n+#[cfg(feature = \"nightly\")]\n pub mod call;\n \n /// Parsed [Data layout](https://llvm.org/docs/LangRef.html#data-layout)\n /// for a target, which contains everything needed to compute layouts.\n+#[derive(Debug, PartialEq, Eq)]\n pub struct TargetDataLayout {\n     pub endian: Endian,\n     pub i1_align: AbiAndPrefAlign,\n@@ -80,6 +86,7 @@ pub enum TargetDataLayoutErrors<'a> {\n }\n \n impl TargetDataLayout {\n+    #[cfg(feature = \"nightly\")]\n     pub fn parse<'a>(target: &'a Target) -> Result<TargetDataLayout, TargetDataLayoutErrors<'a>> {\n         // Parse an address space index from a string.\n         let parse_address_space = |s: &'a str, cause: &'a str| {\n@@ -248,7 +255,7 @@ impl HasDataLayout for TargetDataLayout {\n }\n \n /// Endianness of the target, which must match cfg(target-endian).\n-#[derive(Copy, Clone, PartialEq)]\n+#[derive(Copy, Clone, PartialEq, Eq)]\n pub enum Endian {\n     Little,\n     Big,\n@@ -288,8 +295,8 @@ impl ToJson for Endian {\n }\n \n /// Size of a type in bytes.\n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encodable, Decodable)]\n-#[derive(HashStable_Generic)]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+#[cfg_attr(feature = \"nightly\", derive(Encodable, Decodable, HashStable_Generic))]\n pub struct Size {\n     raw: u64,\n }\n@@ -466,6 +473,7 @@ impl AddAssign for Size {\n     }\n }\n \n+#[cfg(feature = \"nightly\")]\n impl Step for Size {\n     #[inline]\n     fn steps_between(start: &Self, end: &Self) -> Option<usize> {\n@@ -504,8 +512,8 @@ impl Step for Size {\n }\n \n /// Alignment of a type in bytes (always a power of two).\n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encodable, Decodable)]\n-#[derive(HashStable_Generic)]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+#[cfg_attr(feature = \"nightly\", derive(Encodable, Decodable, HashStable_Generic))]\n pub struct Align {\n     pow2: u8,\n }\n@@ -588,7 +596,8 @@ impl Align {\n \n /// A pair of alignments, ABI-mandated and preferred.\n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n-#[derive(HashStable_Generic)]\n+#[cfg_attr(feature = \"nightly\", derive(HashStable_Generic))]\n+\n pub struct AbiAndPrefAlign {\n     pub abi: Align,\n     pub pref: Align,\n@@ -612,7 +621,9 @@ impl AbiAndPrefAlign {\n }\n \n /// Integers, also used for enum discriminants.\n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, HashStable_Generic)]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n+#[cfg_attr(feature = \"nightly\", derive(HashStable_Generic))]\n+\n pub enum Integer {\n     I8,\n     I16,\n@@ -710,7 +721,8 @@ impl Integer {\n }\n \n /// Fundamental unit of memory access and layout.\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, HashStable_Generic)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+#[cfg_attr(feature = \"nightly\", derive(HashStable_Generic))]\n pub enum Primitive {\n     /// The `bool` is the signedness of the `Integer` type.\n     ///\n@@ -777,7 +789,7 @@ impl Primitive {\n ///\n /// This is intended specifically to mirror LLVM\u2019s `!range` metadata semantics.\n #[derive(Clone, Copy, PartialEq, Eq, Hash)]\n-#[derive(HashStable_Generic)]\n+#[cfg_attr(feature = \"nightly\", derive(HashStable_Generic))]\n pub struct WrappingRange {\n     pub start: u128,\n     pub end: u128,\n@@ -834,7 +846,7 @@ impl fmt::Debug for WrappingRange {\n \n /// Information about one scalar component of a Rust type.\n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n-#[derive(HashStable_Generic)]\n+#[cfg_attr(feature = \"nightly\", derive(HashStable_Generic))]\n pub enum Scalar {\n     Initialized {\n         value: Primitive,\n@@ -924,7 +936,8 @@ impl Scalar {\n }\n \n /// Describes how the fields of a type are located in memory.\n-#[derive(PartialEq, Eq, Hash, Debug, HashStable_Generic)]\n+#[derive(PartialEq, Eq, Hash, Clone, Debug)]\n+#[cfg_attr(feature = \"nightly\", derive(HashStable_Generic))]\n pub enum FieldsShape {\n     /// Scalar primitives and `!`, which never have fields.\n     Primitive,\n@@ -1058,7 +1071,9 @@ impl AddressSpace {\n \n /// Describes how values of the type are passed by target ABIs,\n /// in terms of categories of C types there are ABI rules for.\n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, HashStable_Generic)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n+#[cfg_attr(feature = \"nightly\", derive(HashStable_Generic))]\n+\n pub enum Abi {\n     Uninhabited,\n     Scalar(Scalar),\n@@ -1113,16 +1128,18 @@ impl Abi {\n     }\n }\n \n+#[cfg(feature = \"nightly\")]\n rustc_index::newtype_index! {\n     pub struct VariantIdx {\n         derive [HashStable_Generic]\n     }\n }\n \n-#[derive(PartialEq, Eq, Hash, Debug, HashStable_Generic)]\n-pub enum Variants<'a> {\n+#[derive(PartialEq, Eq, Hash, Clone, Debug)]\n+#[cfg_attr(feature = \"nightly\", derive(HashStable_Generic))]\n+pub enum Variants<V: Idx> {\n     /// Single enum variants, structs/tuples, unions, and all non-ADTs.\n-    Single { index: VariantIdx },\n+    Single { index: V },\n \n     /// Enum-likes with more than one inhabited variant: each variant comes with\n     /// a *discriminant* (usually the same as the variant index but the user can\n@@ -1132,14 +1149,15 @@ pub enum Variants<'a> {\n     /// For enums, the tag is the sole field of the layout.\n     Multiple {\n         tag: Scalar,\n-        tag_encoding: TagEncoding,\n+        tag_encoding: TagEncoding<V>,\n         tag_field: usize,\n-        variants: IndexVec<VariantIdx, Layout<'a>>,\n+        variants: IndexVec<V, LayoutS<V>>,\n     },\n }\n \n-#[derive(PartialEq, Eq, Hash, Debug, HashStable_Generic)]\n-pub enum TagEncoding {\n+#[derive(PartialEq, Eq, Hash, Clone, Debug)]\n+#[cfg_attr(feature = \"nightly\", derive(HashStable_Generic))]\n+pub enum TagEncoding<V: Idx> {\n     /// The tag directly stores the discriminant, but possibly with a smaller layout\n     /// (so converting the tag to the discriminant can require sign extension).\n     Direct,\n@@ -1155,13 +1173,15 @@ pub enum TagEncoding {\n     /// `None` has a null pointer for the second tuple field, and\n     /// `Some` is the identity function (with a non-null reference).\n     Niche {\n-        untagged_variant: VariantIdx,\n-        niche_variants: RangeInclusive<VariantIdx>,\n+        untagged_variant: V,\n+        #[cfg(feature = \"nightly\")]\n+        niche_variants: RangeInclusive<V>,\n         niche_start: u128,\n     },\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, HashStable_Generic)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n+#[cfg_attr(feature = \"nightly\", derive(HashStable_Generic))]\n pub struct Niche {\n     pub offset: Size,\n     pub value: Primitive,\n@@ -1244,8 +1264,9 @@ impl Niche {\n     }\n }\n \n-#[derive(PartialEq, Eq, Hash, HashStable_Generic)]\n-pub struct LayoutS<'a> {\n+#[derive(PartialEq, Eq, Hash, Clone)]\n+#[cfg_attr(feature = \"nightly\", derive(HashStable_Generic))]\n+pub struct LayoutS<V: Idx> {\n     /// Says where the fields are located within the layout.\n     pub fields: FieldsShape,\n \n@@ -1256,7 +1277,7 @@ pub struct LayoutS<'a> {\n     ///\n     /// To access all fields of this layout, both `fields` and the fields of the active variant\n     /// must be taken into account.\n-    pub variants: Variants<'a>,\n+    pub variants: Variants<V>,\n \n     /// The `abi` defines how this data is passed between functions, and it defines\n     /// value restrictions via `valid_range`.\n@@ -1275,23 +1296,53 @@ pub struct LayoutS<'a> {\n     pub size: Size,\n }\n \n-impl<'a> LayoutS<'a> {\n+impl<V: Idx> LayoutS<V> {\n     pub fn scalar<C: HasDataLayout>(cx: &C, scalar: Scalar) -> Self {\n         let largest_niche = Niche::from_scalar(cx, Size::ZERO, scalar);\n         let size = scalar.size(cx);\n         let align = scalar.align(cx);\n         LayoutS {\n-            variants: Variants::Single { index: VariantIdx::new(0) },\n+            variants: Variants::Single { index: V::new(0) },\n             fields: FieldsShape::Primitive,\n             abi: Abi::Scalar(scalar),\n             largest_niche,\n             size,\n             align,\n         }\n     }\n+\n+    #[inline]\n+    pub fn fields(&self) -> &FieldsShape {\n+        &self.fields\n+    }\n+\n+    #[inline]\n+    pub fn variants(&self) -> &Variants<V> {\n+        &self.variants\n+    }\n+\n+    #[inline]\n+    pub fn abi(&self) -> Abi {\n+        self.abi\n+    }\n+\n+    #[inline]\n+    pub fn largest_niche(&self) -> Option<Niche> {\n+        self.largest_niche\n+    }\n+\n+    #[inline]\n+    pub fn align(&self) -> AbiAndPrefAlign {\n+        self.align\n+    }\n+\n+    #[inline]\n+    pub fn size(&self) -> Size {\n+        self.size\n+    }\n }\n \n-impl<'a> fmt::Debug for LayoutS<'a> {\n+impl<V: Idx> fmt::Debug for LayoutS<V> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         // This is how `Layout` used to print before it become\n         // `Interned<LayoutS>`. We print it like this to avoid having to update\n@@ -1308,23 +1359,26 @@ impl<'a> fmt::Debug for LayoutS<'a> {\n     }\n }\n \n+#[cfg(feature = \"nightly\")]\n #[derive(Copy, Clone, PartialEq, Eq, Hash, HashStable_Generic)]\n #[rustc_pass_by_value]\n-pub struct Layout<'a>(pub Interned<'a, LayoutS<'a>>);\n+pub struct Layout<'a>(pub Interned<'a, LayoutS<VariantIdx>>);\n \n+#[cfg(feature = \"nightly\")]\n impl<'a> fmt::Debug for Layout<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         // See comment on `<LayoutS as Debug>::fmt` above.\n         self.0.0.fmt(f)\n     }\n }\n \n+#[cfg(feature = \"nightly\")]\n impl<'a> Layout<'a> {\n     pub fn fields(self) -> &'a FieldsShape {\n         &self.0.0.fields\n     }\n \n-    pub fn variants(self) -> &'a Variants<'a> {\n+    pub fn variants(self) -> &'a Variants<VariantIdx> {\n         &self.0.0.variants\n     }\n \n@@ -1352,15 +1406,18 @@ impl<'a> Layout<'a> {\n /// to that obtained from `layout_of(ty)`, as we need to produce\n /// layouts for which Rust types do not exist, such as enum variants\n /// or synthetic fields of enums (i.e., discriminants) and fat pointers.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, HashStable_Generic)]\n+#[cfg(feature = \"nightly\")]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+#[cfg_attr(feature = \"nightly\", derive(HashStable_Generic))]\n pub struct TyAndLayout<'a, Ty> {\n     pub ty: Ty,\n     pub layout: Layout<'a>,\n }\n \n+#[cfg(feature = \"nightly\")]\n impl<'a, Ty> Deref for TyAndLayout<'a, Ty> {\n-    type Target = &'a LayoutS<'a>;\n-    fn deref(&self) -> &&'a LayoutS<'a> {\n+    type Target = &'a LayoutS<VariantIdx>;\n+    fn deref(&self) -> &&'a LayoutS<VariantIdx> {\n         &self.layout.0.0\n     }\n }\n@@ -1402,6 +1459,7 @@ pub enum InitKind {\n \n /// Trait that needs to be implemented by the higher-level type representation\n /// (e.g. `rustc_middle::ty::Ty`), to provide `rustc_target::abi` functionality.\n+#[cfg(feature = \"nightly\")]\n pub trait TyAbiInterface<'a, C>: Sized {\n     fn ty_and_layout_for_variant(\n         this: TyAndLayout<'a, Self>,\n@@ -1420,6 +1478,7 @@ pub trait TyAbiInterface<'a, C>: Sized {\n     fn is_unit(this: TyAndLayout<'a, Self>) -> bool;\n }\n \n+#[cfg(feature = \"nightly\")]\n impl<'a, Ty> TyAndLayout<'a, Ty> {\n     pub fn for_variant<C>(self, cx: &C, variant_index: VariantIdx) -> Self\n     where\n@@ -1489,7 +1548,7 @@ impl<'a, Ty> TyAndLayout<'a, Ty> {\n     }\n }\n \n-impl<'a, Ty> TyAndLayout<'a, Ty> {\n+impl<V: Idx> LayoutS<V> {\n     /// Returns `true` if the layout corresponds to an unsized type.\n     pub fn is_unsized(&self) -> bool {\n         self.abi.is_unsized()"}, {"sha": "1065980a26acc3c6aa930eab499c3179d965f6a2", "filename": "compiler/rustc_target/src/lib.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/09a384643ee4188fd1e837ab25856a7e8ff62d07/compiler%2Frustc_target%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09a384643ee4188fd1e837ab25856a7e8ff62d07/compiler%2Frustc_target%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Flib.rs?ref=09a384643ee4188fd1e837ab25856a7e8ff62d07", "patch": "@@ -8,28 +8,32 @@\n //! LLVM.\n \n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n-#![feature(assert_matches)]\n-#![feature(associated_type_bounds)]\n-#![feature(exhaustive_patterns)]\n-#![feature(min_specialization)]\n-#![feature(never_type)]\n-#![feature(rustc_attrs)]\n-#![feature(step_trait)]\n+#![cfg_attr(feature = \"nightly\", feature(assert_matches))]\n+#![cfg_attr(feature = \"nightly\", feature(associated_type_bounds))]\n+#![cfg_attr(feature = \"nightly\", feature(exhaustive_patterns))]\n+#![cfg_attr(feature = \"nightly\", feature(min_specialization))]\n+#![cfg_attr(feature = \"nightly\", feature(never_type))]\n+#![cfg_attr(feature = \"nightly\", feature(rustc_attrs))]\n+#![cfg_attr(feature = \"nightly\", feature(step_trait))]\n #![deny(rustc::untranslatable_diagnostic)]\n #![deny(rustc::diagnostic_outside_of_impl)]\n \n use std::iter::FromIterator;\n use std::path::{Path, PathBuf};\n \n #[macro_use]\n+#[cfg(feature = \"nightly\")]\n extern crate rustc_macros;\n \n #[macro_use]\n+#[cfg(feature = \"nightly\")]\n extern crate tracing;\n \n pub mod abi;\n+#[cfg(feature = \"nightly\")]\n pub mod asm;\n pub mod json;\n+#[cfg(feature = \"nightly\")]\n pub mod spec;\n \n #[cfg(test)]"}, {"sha": "5e77ad4054a5637d24e0f615fba78940f5424104", "filename": "compiler/rustc_ty_utils/src/layout.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/09a384643ee4188fd1e837ab25856a7e8ff62d07/compiler%2Frustc_ty_utils%2Fsrc%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09a384643ee4188fd1e837ab25856a7e8ff62d07/compiler%2Frustc_ty_utils%2Fsrc%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Flayout.rs?ref=09a384643ee4188fd1e837ab25856a7e8ff62d07", "patch": "@@ -89,7 +89,11 @@ fn invert_mapping(map: &[u32]) -> Vec<u32> {\n     inverse\n }\n \n-fn scalar_pair<'tcx>(cx: &LayoutCx<'tcx, TyCtxt<'tcx>>, a: Scalar, b: Scalar) -> LayoutS<'tcx> {\n+fn scalar_pair<'tcx>(\n+    cx: &LayoutCx<'tcx, TyCtxt<'tcx>>,\n+    a: Scalar,\n+    b: Scalar,\n+) -> LayoutS<VariantIdx> {\n     let dl = cx.data_layout();\n     let b_align = b.align(dl);\n     let align = a.align(dl).max(b_align).max(dl.aggregate_align);\n@@ -122,7 +126,7 @@ fn univariant_uninterned<'tcx>(\n     fields: &[TyAndLayout<'_>],\n     repr: &ReprOptions,\n     kind: StructKind,\n-) -> Result<LayoutS<'tcx>, LayoutError<'tcx>> {\n+) -> Result<LayoutS<VariantIdx>, LayoutError<'tcx>> {\n     let dl = cx.data_layout();\n     let pack = repr.pack;\n     if pack.is_some() && repr.align.is_some() {\n@@ -864,13 +868,13 @@ fn layout_of_uncached<'tcx>(\n             // variant layouts, so we can't store them in the\n             // overall LayoutS. Store the overall LayoutS\n             // and the variant LayoutSs here until then.\n-            struct TmpLayout<'tcx> {\n-                layout: LayoutS<'tcx>,\n-                variants: IndexVec<VariantIdx, LayoutS<'tcx>>,\n+            struct TmpLayout {\n+                layout: LayoutS<VariantIdx>,\n+                variants: IndexVec<VariantIdx, LayoutS<VariantIdx>>,\n             }\n \n             let calculate_niche_filling_layout =\n-                || -> Result<Option<TmpLayout<'tcx>>, LayoutError<'tcx>> {\n+                || -> Result<Option<TmpLayout>, LayoutError<'tcx>> {\n                     // The current code for niche-filling relies on variant indices\n                     // instead of actual discriminants, so enums with\n                     // explicit discriminants (RFC #2363) would misbehave.\n@@ -1317,7 +1321,7 @@ fn layout_of_uncached<'tcx>(\n                     // pick the layout with the larger niche; otherwise,\n                     // pick tagged as it has simpler codegen.\n                     use Ordering::*;\n-                    let niche_size = |tmp_l: &TmpLayout<'_>| {\n+                    let niche_size = |tmp_l: &TmpLayout| {\n                         tmp_l.layout.largest_niche.map_or(0, |n| n.available(dl))\n                     };\n                     match (\n@@ -1338,11 +1342,7 @@ fn layout_of_uncached<'tcx>(\n                     tag,\n                     tag_encoding,\n                     tag_field,\n-                    variants: best_layout\n-                        .variants\n-                        .into_iter()\n-                        .map(|layout| tcx.intern_layout(layout))\n-                        .collect(),\n+                    variants: best_layout.variants,\n                 },\n                 _ => bug!(),\n             };\n@@ -1657,7 +1657,7 @@ fn generator_layout<'tcx>(\n \n             size = size.max(variant.size);\n             align = align.max(variant.align);\n-            Ok(tcx.intern_layout(variant))\n+            Ok(variant)\n         })\n         .collect::<Result<IndexVec<VariantIdx, _>, _>>()?;\n "}, {"sha": "daaeee9e84b691f4d303b79fe529bf0ceeb6e7db", "filename": "src/librustdoc/html/render/print_item.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/09a384643ee4188fd1e837ab25856a7e8ff62d07/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09a384643ee4188fd1e837ab25856a7e8ff62d07/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=09a384643ee4188fd1e837ab25856a7e8ff62d07", "patch": "@@ -10,7 +10,7 @@ use rustc_middle::ty::layout::LayoutError;\n use rustc_middle::ty::{self, Adt, TyCtxt};\n use rustc_span::hygiene::MacroKind;\n use rustc_span::symbol::{kw, sym, Symbol};\n-use rustc_target::abi::{Layout, Primitive, TagEncoding, Variants};\n+use rustc_target::abi::{LayoutS, Primitive, TagEncoding, VariantIdx, Variants};\n use std::cmp::Ordering;\n use std::fmt;\n use std::rc::Rc;\n@@ -1892,7 +1892,7 @@ fn document_non_exhaustive(w: &mut Buffer, item: &clean::Item) {\n }\n \n fn document_type_layout(w: &mut Buffer, cx: &Context<'_>, ty_def_id: DefId) {\n-    fn write_size_of_layout(w: &mut Buffer, layout: Layout<'_>, tag_size: u64) {\n+    fn write_size_of_layout(w: &mut Buffer, layout: &LayoutS<VariantIdx>, tag_size: u64) {\n         if layout.abi().is_unsized() {\n             write!(w, \"(unsized)\");\n         } else {\n@@ -1927,7 +1927,7 @@ fn document_type_layout(w: &mut Buffer, cx: &Context<'_>, ty_def_id: DefId) {\n                  chapter for details on type layout guarantees.</p></div>\"\n             );\n             w.write_str(\"<p><strong>Size:</strong> \");\n-            write_size_of_layout(w, ty_layout.layout, 0);\n+            write_size_of_layout(w, &ty_layout.layout.0, 0);\n             writeln!(w, \"</p>\");\n             if let Variants::Multiple { variants, tag, tag_encoding, .. } =\n                 &ty_layout.layout.variants()\n@@ -1953,7 +1953,7 @@ fn document_type_layout(w: &mut Buffer, cx: &Context<'_>, ty_def_id: DefId) {\n                     for (index, layout) in variants.iter_enumerated() {\n                         let name = adt.variant(index).name;\n                         write!(w, \"<li><code>{name}</code>: \", name = name);\n-                        write_size_of_layout(w, *layout, tag_size);\n+                        write_size_of_layout(w, layout, tag_size);\n                         writeln!(w, \"</li>\");\n                     }\n                     w.write_str(\"</ul>\");"}]}