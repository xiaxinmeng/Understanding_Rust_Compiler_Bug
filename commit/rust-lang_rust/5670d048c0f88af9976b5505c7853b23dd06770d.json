{"sha": "5670d048c0f88af9976b5505c7853b23dd06770d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU2NzBkMDQ4YzBmODhhZjk5NzZiNTUwNWM3ODUzYjIzZGQwNjc3MGQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-09-17T01:09:07Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-09-17T01:09:07Z"}, "message": "Auto merge of #64535 - Centril:rollup-wiyxagi, r=Centril\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #64085 (Tweak unsatisfied HRTB errors)\n - #64380 (Update bundled OpenSSL to 1.1.1d)\n - #64416 (Various refactorings to clean up nll diagnostics)\n - #64500 (Various `ObligationForest` improvements)\n - #64530 (Elide lifetimes in `Pin<&(mut) Self>`)\n - #64531 (Use shorthand syntax in the self parameter of methods of Pin)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "aee9d034a7e3fd521a3f1e8314630800e96897aa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aee9d034a7e3fd521a3f1e8314630800e96897aa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5670d048c0f88af9976b5505c7853b23dd06770d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5670d048c0f88af9976b5505c7853b23dd06770d", "html_url": "https://github.com/rust-lang/rust/commit/5670d048c0f88af9976b5505c7853b23dd06770d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5670d048c0f88af9976b5505c7853b23dd06770d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7ac21e7636f7b3c0eb3e31b13c7087b4de7aa5a9", "url": "https://api.github.com/repos/rust-lang/rust/commits/7ac21e7636f7b3c0eb3e31b13c7087b4de7aa5a9", "html_url": "https://github.com/rust-lang/rust/commit/7ac21e7636f7b3c0eb3e31b13c7087b4de7aa5a9"}, {"sha": "a1fd9bae2ca8195456963b6bbbd5eff31d91adbe", "url": "https://api.github.com/repos/rust-lang/rust/commits/a1fd9bae2ca8195456963b6bbbd5eff31d91adbe", "html_url": "https://github.com/rust-lang/rust/commit/a1fd9bae2ca8195456963b6bbbd5eff31d91adbe"}], "stats": {"total": 1085, "additions": 627, "deletions": 458}, "files": [{"sha": "b717460e5d42799c1e004a5463bc6c3dbc9125ba", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5670d048c0f88af9976b5505c7853b23dd06770d/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/5670d048c0f88af9976b5505c7853b23dd06770d/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=5670d048c0f88af9976b5505c7853b23dd06770d", "patch": "@@ -2182,9 +2182,9 @@ checksum = \"77af24da69f9d9341038eba93a073b1fdaaa1b788221b00a69bce9e762cb32de\"\n \n [[package]]\n name = \"openssl-src\"\n-version = \"111.3.0+1.1.1c\"\n+version = \"111.6.0+1.1.1d\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"53ed5f31d294bdf5f7a4ba0a206c2754b0f60e9a63b7e3076babc5317873c797\"\n+checksum = \"b9c2da1de8a7a3f860919c01540b03a6db16de042405a8a07a5e9d0b4b825d9c\"\n dependencies = [\n  \"cc\",\n ]"}, {"sha": "5569d99f8d81ddfe310210ac76b89dfe1bbd9c68", "filename": "src/libcore/option.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5670d048c0f88af9976b5505c7853b23dd06770d/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5670d048c0f88af9976b5505c7853b23dd06770d/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=5670d048c0f88af9976b5505c7853b23dd06770d", "patch": "@@ -295,7 +295,7 @@ impl<T> Option<T> {\n     /// [`Pin`]: ../pin/struct.Pin.html\n     #[inline]\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n-    pub fn as_pin_ref<'a>(self: Pin<&'a Option<T>>) -> Option<Pin<&'a T>> {\n+    pub fn as_pin_ref(self: Pin<&Self>) -> Option<Pin<&T>> {\n         unsafe {\n             Pin::get_ref(self).as_ref().map(|x| Pin::new_unchecked(x))\n         }\n@@ -306,7 +306,7 @@ impl<T> Option<T> {\n     /// [`Pin`]: ../pin/struct.Pin.html\n     #[inline]\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n-    pub fn as_pin_mut<'a>(self: Pin<&'a mut Option<T>>) -> Option<Pin<&'a mut T>> {\n+    pub fn as_pin_mut(self: Pin<&mut Self>) -> Option<Pin<&mut T>> {\n         unsafe {\n             Pin::get_unchecked_mut(self).as_mut().map(|x| Pin::new_unchecked(x))\n         }"}, {"sha": "be59e830beda3adc5d5c83576023b261703a69a4", "filename": "src/libcore/pin.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5670d048c0f88af9976b5505c7853b23dd06770d/src%2Flibcore%2Fpin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5670d048c0f88af9976b5505c7853b23dd06770d/src%2Flibcore%2Fpin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpin.rs?ref=5670d048c0f88af9976b5505c7853b23dd06770d", "patch": "@@ -233,7 +233,7 @@\n //! # type Field = i32;\n //! # struct Struct { field: Field }\n //! impl Struct {\n-//!     fn pin_get_field<'a>(self: Pin<&'a mut Self>) -> &'a mut Field {\n+//!     fn pin_get_field(self: Pin<&mut Self>) -> &mut Field {\n //!         // This is okay because `field` is never considered pinned.\n //!         unsafe { &mut self.get_unchecked_mut().field }\n //!     }\n@@ -257,7 +257,7 @@\n //! # type Field = i32;\n //! # struct Struct { field: Field }\n //! impl Struct {\n-//!     fn pin_get_field<'a>(self: Pin<&'a mut Self>) -> Pin<&'a mut Field> {\n+//!     fn pin_get_field(self: Pin<&mut Self>) -> Pin<&mut Field> {\n //!         // This is okay because `field` is pinned when `self` is.\n //!         unsafe { self.map_unchecked_mut(|s| &mut s.field) }\n //!     }\n@@ -549,7 +549,7 @@ impl<P: Deref> Pin<P> {\n     /// ruled out by the contract of `Pin::new_unchecked`.\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n     #[inline(always)]\n-    pub fn as_ref(self: &Pin<P>) -> Pin<&P::Target> {\n+    pub fn as_ref(&self) -> Pin<&P::Target> {\n         unsafe { Pin::new_unchecked(&*self.pointer) }\n     }\n \n@@ -586,7 +586,7 @@ impl<P: DerefMut> Pin<P> {\n     /// ruled out by the contract of `Pin::new_unchecked`.\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n     #[inline(always)]\n-    pub fn as_mut(self: &mut Pin<P>) -> Pin<&mut P::Target> {\n+    pub fn as_mut(&mut self) -> Pin<&mut P::Target> {\n         unsafe { Pin::new_unchecked(&mut *self.pointer) }\n     }\n \n@@ -596,7 +596,7 @@ impl<P: DerefMut> Pin<P> {\n     /// run before being overwritten, so no pinning guarantee is violated.\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n     #[inline(always)]\n-    pub fn set(self: &mut Pin<P>, value: P::Target)\n+    pub fn set(&mut self, value: P::Target)\n     where\n         P::Target: Sized,\n     {\n@@ -621,7 +621,7 @@ impl<'a, T: ?Sized> Pin<&'a T> {\n     ///\n     /// [`pin` module]: ../../std/pin/index.html#projections-and-structural-pinning\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n-    pub unsafe fn map_unchecked<U, F>(self: Pin<&'a T>, func: F) -> Pin<&'a U> where\n+    pub unsafe fn map_unchecked<U, F>(self, func: F) -> Pin<&'a U> where\n         F: FnOnce(&T) -> &U,\n     {\n         let pointer = &*self.pointer;\n@@ -648,7 +648,7 @@ impl<'a, T: ?Sized> Pin<&'a T> {\n     /// [\"pinning projections\"]: ../../std/pin/index.html#projections-and-structural-pinning\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n     #[inline(always)]\n-    pub fn get_ref(self: Pin<&'a T>) -> &'a T {\n+    pub fn get_ref(self) -> &'a T {\n         self.pointer\n     }\n }\n@@ -657,7 +657,7 @@ impl<'a, T: ?Sized> Pin<&'a mut T> {\n     /// Converts this `Pin<&mut T>` into a `Pin<&T>` with the same lifetime.\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n     #[inline(always)]\n-    pub fn into_ref(self: Pin<&'a mut T>) -> Pin<&'a T> {\n+    pub fn into_ref(self) -> Pin<&'a T> {\n         Pin { pointer: self.pointer }\n     }\n \n@@ -672,7 +672,7 @@ impl<'a, T: ?Sized> Pin<&'a mut T> {\n     /// with the same lifetime as the original `Pin`.\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n     #[inline(always)]\n-    pub fn get_mut(self: Pin<&'a mut T>) -> &'a mut T\n+    pub fn get_mut(self) -> &'a mut T\n         where T: Unpin,\n     {\n         self.pointer\n@@ -690,7 +690,7 @@ impl<'a, T: ?Sized> Pin<&'a mut T> {\n     /// instead.\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n     #[inline(always)]\n-    pub unsafe fn get_unchecked_mut(self: Pin<&'a mut T>) -> &'a mut T {\n+    pub unsafe fn get_unchecked_mut(self) -> &'a mut T {\n         self.pointer\n     }\n \n@@ -710,7 +710,7 @@ impl<'a, T: ?Sized> Pin<&'a mut T> {\n     ///\n     /// [`pin` module]: ../../std/pin/index.html#projections-and-structural-pinning\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n-    pub unsafe fn map_unchecked_mut<U, F>(self: Pin<&'a mut T>, func: F) -> Pin<&'a mut U> where\n+    pub unsafe fn map_unchecked_mut<U, F>(self, func: F) -> Pin<&'a mut U> where\n         F: FnOnce(&mut T) -> &mut U,\n     {\n         let pointer = Pin::get_unchecked_mut(self);"}, {"sha": "19bd38b45b30a9847359a980352659f6c2bc0edf", "filename": "src/librustc/infer/error_reporting/nice_region_error/placeholder_error.rs", "status": "modified", "additions": 31, "deletions": 22, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/5670d048c0f88af9976b5505c7853b23dd06770d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5670d048c0f88af9976b5505c7853b23dd06770d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs?ref=5670d048c0f88af9976b5505c7853b23dd06770d", "patch": "@@ -192,23 +192,28 @@ impl NiceRegionError<'me, 'tcx> {\n             vid, sub_placeholder, sup_placeholder, trait_def_id, expected_substs, actual_substs\n         );\n \n-        let mut err = self.tcx().sess.struct_span_err(\n-            cause.span(self.tcx()),\n-            &format!(\n-                \"implementation of `{}` is not general enough\",\n-                self.tcx().def_path_str(trait_def_id),\n-            ),\n+        let span = cause.span(self.tcx());\n+        let msg = format!(\n+            \"implementation of `{}` is not general enough\",\n+            self.tcx().def_path_str(trait_def_id),\n+        );\n+        let mut err = self.tcx().sess.struct_span_err(span, &msg);\n+        err.span_label(\n+            self.tcx().def_span(trait_def_id),\n+            format!(\"trait `{}` defined here\", self.tcx().def_path_str(trait_def_id)),\n         );\n \n-        match cause.code {\n-            ObligationCauseCode::ItemObligation(def_id) => {\n-                err.note(&format!(\n-                    \"Due to a where-clause on `{}`,\",\n-                    self.tcx().def_path_str(def_id),\n-                ));\n-            }\n-            _ => (),\n-        }\n+        let leading_ellipsis = if let ObligationCauseCode::ItemObligation(def_id) = cause.code {\n+            err.span_label(span, \"doesn't satisfy where-clause\");\n+            err.span_label(\n+                self.tcx().def_span(def_id),\n+                &format!(\"due to a where-clause on `{}`...\", self.tcx().def_path_str(def_id)),\n+            );\n+            true\n+        } else {\n+            err.span_label(span, &msg);\n+            false\n+        };\n \n         let expected_trait_ref = self.infcx.resolve_vars_if_possible(&ty::TraitRef {\n             def_id: trait_def_id,\n@@ -295,6 +300,7 @@ impl NiceRegionError<'me, 'tcx> {\n             expected_has_vid,\n             actual_has_vid,\n             any_self_ty_has_vid,\n+            leading_ellipsis,\n         );\n \n         err\n@@ -318,6 +324,7 @@ impl NiceRegionError<'me, 'tcx> {\n         expected_has_vid: Option<usize>,\n         actual_has_vid: Option<usize>,\n         any_self_ty_has_vid: bool,\n+        leading_ellipsis: bool,\n     ) {\n         // HACK(eddyb) maybe move this in a more central location.\n         #[derive(Copy, Clone)]\n@@ -392,13 +399,15 @@ impl NiceRegionError<'me, 'tcx> {\n \n             let mut note = if passive_voice {\n                 format!(\n-                    \"`{}` would have to be implemented for the type `{}`\",\n+                    \"{}`{}` would have to be implemented for the type `{}`\",\n+                    if leading_ellipsis { \"...\" } else { \"\" },\n                     expected_trait_ref,\n                     expected_trait_ref.map(|tr| tr.self_ty()),\n                 )\n             } else {\n                 format!(\n-                    \"`{}` must implement `{}`\",\n+                    \"{}`{}` must implement `{}`\",\n+                    if leading_ellipsis { \"...\" } else { \"\" },\n                     expected_trait_ref.map(|tr| tr.self_ty()),\n                     expected_trait_ref,\n                 )\n@@ -407,20 +416,20 @@ impl NiceRegionError<'me, 'tcx> {\n             match (has_sub, has_sup) {\n                 (Some(n1), Some(n2)) => {\n                     let _ = write!(note,\n-                        \", for any two lifetimes `'{}` and `'{}`\",\n+                        \", for any two lifetimes `'{}` and `'{}`...\",\n                         std::cmp::min(n1, n2),\n                         std::cmp::max(n1, n2),\n                     );\n                 }\n                 (Some(n), _) | (_, Some(n)) => {\n                     let _ = write!(note,\n-                        \", for any lifetime `'{}`\",\n+                        \", for any lifetime `'{}`...\",\n                         n,\n                     );\n                 }\n                 (None, None) => if let Some(n) = expected_has_vid {\n                     let _ = write!(note,\n-                        \", for some specific lifetime `'{}`\",\n+                        \", for some specific lifetime `'{}`...\",\n                         n,\n                     );\n                 },\n@@ -439,13 +448,13 @@ impl NiceRegionError<'me, 'tcx> {\n \n             let mut note = if passive_voice {\n                 format!(\n-                    \"but `{}` is actually implemented for the type `{}`\",\n+                    \"...but `{}` is actually implemented for the type `{}`\",\n                     actual_trait_ref,\n                     actual_trait_ref.map(|tr| tr.self_ty()),\n                 )\n             } else {\n                 format!(\n-                    \"but `{}` actually implements `{}`\",\n+                    \"...but `{}` actually implements `{}`\",\n                     actual_trait_ref.map(|tr| tr.self_ty()),\n                     actual_trait_ref,\n                 )"}, {"sha": "6e80b48a6856016dadab3a7eb46bb2add06f0d6c", "filename": "src/librustc_data_structures/indexed_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5670d048c0f88af9976b5505c7853b23dd06770d/src%2Flibrustc_data_structures%2Findexed_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5670d048c0f88af9976b5505c7853b23dd06770d/src%2Flibrustc_data_structures%2Findexed_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Findexed_vec.rs?ref=5670d048c0f88af9976b5505c7853b23dd06770d", "patch": "@@ -149,7 +149,7 @@ macro_rules! newtype_index {\n \n             #[inline]\n             $v const unsafe fn from_u32_unchecked(value: u32) -> Self {\n-                unsafe { $type { private: value } }\n+                $type { private: value }\n             }\n \n             /// Extracts the value of this index as an integer."}, {"sha": "b2120b182fa7b72eb08acf7ebb179bfc91b88c07", "filename": "src/librustc_data_structures/obligation_forest/graphviz.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5670d048c0f88af9976b5505c7853b23dd06770d/src%2Flibrustc_data_structures%2Fobligation_forest%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5670d048c0f88af9976b5505c7853b23dd06770d/src%2Flibrustc_data_structures%2Fobligation_forest%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Fgraphviz.rs?ref=5670d048c0f88af9976b5505c7853b23dd06770d", "patch": "@@ -74,9 +74,9 @@ impl<'a, O: ForestObligation + 'a> dot::GraphWalk<'a> for &'a ObligationForest<O\n             .flat_map(|i| {\n                 let node = &self.nodes[i];\n \n-                node.parent.iter().map(|p| p.get())\n-                    .chain(node.dependents.iter().map(|p| p.get()))\n-                    .map(move |p| (p, i))\n+                node.parent.iter()\n+                    .chain(node.dependents.iter())\n+                    .map(move |p| (p.index(), i))\n             })\n             .collect()\n     }"}, {"sha": "189506bf8ab76c5aa2299aca687891567410d023", "filename": "src/librustc_data_structures/obligation_forest/mod.rs", "status": "modified", "additions": 144, "deletions": 143, "changes": 287, "blob_url": "https://github.com/rust-lang/rust/blob/5670d048c0f88af9976b5505c7853b23dd06770d/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5670d048c0f88af9976b5505c7853b23dd06770d/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs?ref=5670d048c0f88af9976b5505c7853b23dd06770d", "patch": "@@ -9,7 +9,7 @@\n //! `ObligationForest` supports two main public operations (there are a\n //! few others not discussed here):\n //!\n-//! 1. Add a new root obligations (`push_tree`).\n+//! 1. Add a new root obligations (`register_obligation`).\n //! 2. Process the pending obligations (`process_obligations`).\n //!\n //! When a new obligation `N` is added, it becomes the root of an\n@@ -20,21 +20,21 @@\n //! with every pending obligation (so that will include `N`, the first\n //! time). The callback also receives a (mutable) reference to the\n //! per-tree state `T`. The callback should process the obligation `O`\n-//! that it is given and return one of three results:\n+//! that it is given and return a `ProcessResult`:\n //!\n-//! - `Ok(None)` -> ambiguous result. Obligation was neither a success\n+//! - `Unchanged` -> ambiguous result. Obligation was neither a success\n //!   nor a failure. It is assumed that further attempts to process the\n //!   obligation will yield the same result unless something in the\n //!   surrounding environment changes.\n-//! - `Ok(Some(C))` - the obligation was *shallowly successful*. The\n+//! - `Changed(C)` - the obligation was *shallowly successful*. The\n //!   vector `C` is a list of subobligations. The meaning of this is that\n //!   `O` was successful on the assumption that all the obligations in `C`\n //!   are also successful. Therefore, `O` is only considered a \"true\"\n //!   success if `C` is empty. Otherwise, `O` is put into a suspended\n //!   state and the obligations in `C` become the new pending\n //!   obligations. They will be processed the next time you call\n //!   `process_obligations`.\n-//! - `Err(E)` -> obligation failed with error `E`. We will collect this\n+//! - `Error(E)` -> obligation failed with error `E`. We will collect this\n //!   error and return it from `process_obligations`, along with the\n //!   \"backtrace\" of obligations (that is, the list of obligations up to\n //!   and including the root of the failed obligation). No further\n@@ -47,55 +47,50 @@\n //! - `completed`: a list of obligations where processing was fully\n //!   completed without error (meaning that all transitive subobligations\n //!   have also been completed). So, for example, if the callback from\n-//!   `process_obligations` returns `Ok(Some(C))` for some obligation `O`,\n+//!   `process_obligations` returns `Changed(C)` for some obligation `O`,\n //!   then `O` will be considered completed right away if `C` is the\n //!   empty vector. Otherwise it will only be considered completed once\n //!   all the obligations in `C` have been found completed.\n //! - `errors`: a list of errors that occurred and associated backtraces\n //!   at the time of error, which can be used to give context to the user.\n //! - `stalled`: if true, then none of the existing obligations were\n-//!   *shallowly successful* (that is, no callback returned `Ok(Some(_))`).\n+//!   *shallowly successful* (that is, no callback returned `Changed(_)`).\n //!   This implies that all obligations were either errors or returned an\n //!   ambiguous result, which means that any further calls to\n //!   `process_obligations` would simply yield back further ambiguous\n //!   results. This is used by the `FulfillmentContext` to decide when it\n //!   has reached a steady state.\n //!\n-//! #### Snapshots\n-//!\n-//! The `ObligationForest` supports a limited form of snapshots; see\n-//! `start_snapshot`, `commit_snapshot`, and `rollback_snapshot`. In\n-//! particular, you can use a snapshot to roll back new root\n-//! obligations. However, it is an error to attempt to\n-//! `process_obligations` during a snapshot.\n-//!\n //! ### Implementation details\n //!\n //! For the most part, comments specific to the implementation are in the\n //! code. This file only contains a very high-level overview. Basically,\n //! the forest is stored in a vector. Each element of the vector is a node\n-//! in some tree. Each node in the vector has the index of an (optional)\n-//! parent and (for convenience) its root (which may be itself). It also\n-//! has a current state, described by `NodeState`. After each\n-//! processing step, we compress the vector to remove completed and error\n-//! nodes, which aren't needed anymore.\n+//! in some tree. Each node in the vector has the index of its dependents,\n+//! including the first dependent which is known as the parent. It also\n+//! has a current state, described by `NodeState`. After each processing\n+//! step, we compress the vector to remove completed and error nodes, which\n+//! aren't needed anymore.\n \n use crate::fx::{FxHashMap, FxHashSet};\n+use crate::indexed_vec::Idx;\n+use crate::newtype_index;\n \n-use std::cell::Cell;\n+use std::cell::{Cell, RefCell};\n use std::collections::hash_map::Entry;\n use std::fmt::Debug;\n use std::hash;\n use std::marker::PhantomData;\n \n-mod node_index;\n-use self::node_index::NodeIndex;\n-\n mod graphviz;\n \n #[cfg(test)]\n mod tests;\n \n+newtype_index! {\n+    pub struct NodeIndex { .. }\n+}\n+\n pub trait ForestObligation : Clone + Debug {\n     type Predicate : Clone + hash::Hash + Eq + Debug;\n \n@@ -148,18 +143,22 @@ pub struct ObligationForest<O: ForestObligation> {\n     /// At the end of processing, those nodes will be removed by a\n     /// call to `compress`.\n     ///\n-    /// At all times we maintain the invariant that every node appears\n-    /// at a higher index than its parent. This is needed by the\n-    /// backtrace iterator (which uses `split_at`).\n+    /// Ideally, this would be an `IndexVec<NodeIndex, Node<O>>`. But that is\n+    /// slower, because this vector is accessed so often that the\n+    /// `u32`-to-`usize` conversions required for accesses are significant.\n     nodes: Vec<Node<O>>,\n \n     /// A cache of predicates that have been successfully completed.\n     done_cache: FxHashSet<O::Predicate>,\n \n-    /// An cache of the nodes in `nodes`, indexed by predicate.\n+    /// A cache of the nodes in `nodes`, indexed by predicate. Unfortunately,\n+    /// its contents are not guaranteed to match those of `nodes`. See the\n+    /// comments in `process_obligation` for details.\n     waiting_cache: FxHashMap<O::Predicate, NodeIndex>,\n \n-    scratch: Option<Vec<usize>>,\n+    /// A scratch vector reused in various operations, to avoid allocating new\n+    /// vectors.\n+    scratch: RefCell<Vec<usize>>,\n \n     obligation_tree_id_generator: ObligationTreeIdGenerator,\n \n@@ -178,19 +177,41 @@ struct Node<O> {\n     obligation: O,\n     state: Cell<NodeState>,\n \n-    /// The parent of a node - the original obligation of\n-    /// which it is a subobligation. Except for error reporting,\n-    /// it is just like any member of `dependents`.\n+    /// The parent of a node - the original obligation of which it is a\n+    /// subobligation. Except for error reporting, it is just like any member\n+    /// of `dependents`.\n+    ///\n+    /// Unlike `ObligationForest::nodes`, this uses `NodeIndex` rather than\n+    /// `usize` for the index, because keeping the size down is more important\n+    /// than the cost of converting to a `usize` for indexing.\n     parent: Option<NodeIndex>,\n \n-    /// Obligations that depend on this obligation for their\n-    /// completion. They must all be in a non-pending state.\n+    /// Obligations that depend on this obligation for their completion. They\n+    /// must all be in a non-pending state.\n+    ///\n+    /// This uses `NodeIndex` for the same reason as `parent`.\n     dependents: Vec<NodeIndex>,\n \n     /// Identifier of the obligation tree to which this node belongs.\n     obligation_tree_id: ObligationTreeId,\n }\n \n+impl<O> Node<O> {\n+    fn new(\n+        parent: Option<NodeIndex>,\n+        obligation: O,\n+        obligation_tree_id: ObligationTreeId\n+    ) -> Node<O> {\n+        Node {\n+            obligation,\n+            state: Cell::new(NodeState::Pending),\n+            parent,\n+            dependents: vec![],\n+            obligation_tree_id,\n+        }\n+    }\n+}\n+\n /// The state of one node in some tree within the forest. This\n /// represents the current state of processing for the obligation (of\n /// type `O`) associated with this node.\n@@ -262,7 +283,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n             nodes: vec![],\n             done_cache: Default::default(),\n             waiting_cache: Default::default(),\n-            scratch: Some(vec![]),\n+            scratch: RefCell::new(vec![]),\n             obligation_tree_id_generator: (0..).map(ObligationTreeId),\n             error_cache: Default::default(),\n         }\n@@ -275,14 +296,12 @@ impl<O: ForestObligation> ObligationForest<O> {\n     }\n \n     /// Registers an obligation.\n-    ///\n-    /// This CAN be done in a snapshot\n     pub fn register_obligation(&mut self, obligation: O) {\n         // Ignore errors here - there is no guarantee of success.\n         let _ = self.register_obligation_at(obligation, None);\n     }\n \n-    // returns Err(()) if we already know this obligation failed.\n+    // Returns Err(()) if we already know this obligation failed.\n     fn register_obligation_at(&mut self, obligation: O, parent: Option<NodeIndex>)\n                               -> Result<(), ()>\n     {\n@@ -294,15 +313,16 @@ impl<O: ForestObligation> ObligationForest<O> {\n             Entry::Occupied(o) => {\n                 debug!(\"register_obligation_at({:?}, {:?}) - duplicate of {:?}!\",\n                        obligation, parent, o.get());\n-                let node = &mut self.nodes[o.get().get()];\n-                if let Some(parent) = parent {\n+                let node = &mut self.nodes[o.get().index()];\n+                if let Some(parent_index) = parent {\n                     // If the node is already in `waiting_cache`, it's already\n                     // been marked with a parent. (It's possible that parent\n                     // has been cleared by `apply_rewrites`, though.) So just\n                     // dump `parent` into `node.dependents`... unless it's\n                     // already in `node.dependents` or `node.parent`.\n-                    if !node.dependents.contains(&parent) && Some(parent) != node.parent {\n-                        node.dependents.push(parent);\n+                    if !node.dependents.contains(&parent_index) &&\n+                       Some(parent_index) != node.parent {\n+                        node.dependents.push(parent_index);\n                     }\n                 }\n                 if let NodeState::Error = node.state.get() {\n@@ -316,9 +336,8 @@ impl<O: ForestObligation> ObligationForest<O> {\n                        obligation, parent, self.nodes.len());\n \n                 let obligation_tree_id = match parent {\n-                    Some(p) => {\n-                        let parent_node = &self.nodes[p.get()];\n-                        parent_node.obligation_tree_id\n+                    Some(parent_index) => {\n+                        self.nodes[parent_index.index()].obligation_tree_id\n                     }\n                     None => self.obligation_tree_id_generator.next().unwrap()\n                 };\n@@ -342,13 +361,11 @@ impl<O: ForestObligation> ObligationForest<O> {\n     }\n \n     /// Converts all remaining obligations to the given error.\n-    ///\n-    /// This cannot be done during a snapshot.\n     pub fn to_errors<E: Clone>(&mut self, error: E) -> Vec<Error<O, E>> {\n         let mut errors = vec![];\n-        for index in 0..self.nodes.len() {\n-            if let NodeState::Pending = self.nodes[index].state.get() {\n-                let backtrace = self.error_at(index);\n+        for (i, node) in self.nodes.iter().enumerate() {\n+            if let NodeState::Pending = node.state.get() {\n+                let backtrace = self.error_at(i);\n                 errors.push(Error {\n                     error: error.clone(),\n                     backtrace,\n@@ -373,7 +390,6 @@ impl<O: ForestObligation> ObligationForest<O> {\n \n     fn insert_into_error_cache(&mut self, node_index: usize) {\n         let node = &self.nodes[node_index];\n-\n         self.error_cache\n             .entry(node.obligation_tree_id)\n             .or_default()\n@@ -393,16 +409,22 @@ impl<O: ForestObligation> ObligationForest<O> {\n         let mut errors = vec![];\n         let mut stalled = true;\n \n-        for index in 0..self.nodes.len() {\n-            debug!(\"process_obligations: node {} == {:?}\", index, self.nodes[index]);\n+        for i in 0..self.nodes.len() {\n+            let node = &mut self.nodes[i];\n \n-            let result = match self.nodes[index] {\n-                Node { ref state, ref mut obligation, .. } if state.get() == NodeState::Pending =>\n-                    processor.process_obligation(obligation),\n+            debug!(\"process_obligations: node {} == {:?}\", i, node);\n+\n+            // `processor.process_obligation` can modify the predicate within\n+            // `node.obligation`, and that predicate is the key used for\n+            // `self.waiting_cache`. This means that `self.waiting_cache` can\n+            // get out of sync with `nodes`. It's not very common, but it does\n+            // happen, and code in `compress` has to allow for it.\n+            let result = match node.state.get() {\n+                NodeState::Pending => processor.process_obligation(&mut node.obligation),\n                 _ => continue\n             };\n \n-            debug!(\"process_obligations: node {} got result {:?}\", index, result);\n+            debug!(\"process_obligations: node {} got result {:?}\", i, result);\n \n             match result {\n                 ProcessResult::Unchanged => {\n@@ -411,23 +433,23 @@ impl<O: ForestObligation> ObligationForest<O> {\n                 ProcessResult::Changed(children) => {\n                     // We are not (yet) stalled.\n                     stalled = false;\n-                    self.nodes[index].state.set(NodeState::Success);\n+                    node.state.set(NodeState::Success);\n \n                     for child in children {\n                         let st = self.register_obligation_at(\n                             child,\n-                            Some(NodeIndex::new(index))\n+                            Some(NodeIndex::new(i))\n                         );\n                         if let Err(()) = st {\n-                            // error already reported - propagate it\n+                            // Error already reported - propagate it\n                             // to our node.\n-                            self.error_at(index);\n+                            self.error_at(i);\n                         }\n                     }\n                 }\n                 ProcessResult::Error(err) => {\n                     stalled = false;\n-                    let backtrace = self.error_at(index);\n+                    let backtrace = self.error_at(i);\n                     errors.push(Error {\n                         error: err,\n                         backtrace,\n@@ -448,8 +470,6 @@ impl<O: ForestObligation> ObligationForest<O> {\n \n         self.mark_as_waiting();\n         self.process_cycles(processor);\n-\n-        // Now we have to compress the result\n         let completed = self.compress(do_completed);\n \n         debug!(\"process_obligations: complete\");\n@@ -465,105 +485,100 @@ impl<O: ForestObligation> ObligationForest<O> {\n     /// report all cycles between them. This should be called\n     /// after `mark_as_waiting` marks all nodes with pending\n     /// subobligations as NodeState::Waiting.\n-    fn process_cycles<P>(&mut self, processor: &mut P)\n+    fn process_cycles<P>(&self, processor: &mut P)\n         where P: ObligationProcessor<Obligation=O>\n     {\n-        let mut stack = self.scratch.take().unwrap();\n+        let mut stack = self.scratch.replace(vec![]);\n         debug_assert!(stack.is_empty());\n \n         debug!(\"process_cycles()\");\n \n-        for index in 0..self.nodes.len() {\n+        for (i, node) in self.nodes.iter().enumerate() {\n             // For rustc-benchmarks/inflate-0.1.0 this state test is extremely\n             // hot and the state is almost always `Pending` or `Waiting`. It's\n             // a win to handle the no-op cases immediately to avoid the cost of\n             // the function call.\n-            let state = self.nodes[index].state.get();\n-            match state {\n+            match node.state.get() {\n                 NodeState::Waiting | NodeState::Pending | NodeState::Done | NodeState::Error => {},\n-                _ => self.find_cycles_from_node(&mut stack, processor, index),\n+                _ => self.find_cycles_from_node(&mut stack, processor, i),\n             }\n         }\n \n         debug!(\"process_cycles: complete\");\n \n         debug_assert!(stack.is_empty());\n-        self.scratch = Some(stack);\n+        self.scratch.replace(stack);\n     }\n \n-    fn find_cycles_from_node<P>(&self, stack: &mut Vec<usize>,\n-                                processor: &mut P, index: usize)\n+    fn find_cycles_from_node<P>(&self, stack: &mut Vec<usize>, processor: &mut P, i: usize)\n         where P: ObligationProcessor<Obligation=O>\n     {\n-        let node = &self.nodes[index];\n-        let state = node.state.get();\n-        match state {\n+        let node = &self.nodes[i];\n+        match node.state.get() {\n             NodeState::OnDfsStack => {\n-                let index =\n-                    stack.iter().rposition(|n| *n == index).unwrap();\n-                processor.process_backedge(stack[index..].iter().map(GetObligation(&self.nodes)),\n+                let i = stack.iter().rposition(|n| *n == i).unwrap();\n+                processor.process_backedge(stack[i..].iter().map(GetObligation(&self.nodes)),\n                                            PhantomData);\n             }\n             NodeState::Success => {\n                 node.state.set(NodeState::OnDfsStack);\n-                stack.push(index);\n-                for dependent in node.parent.iter().chain(node.dependents.iter()) {\n-                    self.find_cycles_from_node(stack, processor, dependent.get());\n+                stack.push(i);\n+                for index in node.parent.iter().chain(node.dependents.iter()) {\n+                    self.find_cycles_from_node(stack, processor, index.index());\n                 }\n                 stack.pop();\n                 node.state.set(NodeState::Done);\n             },\n             NodeState::Waiting | NodeState::Pending => {\n-                // this node is still reachable from some pending node. We\n+                // This node is still reachable from some pending node. We\n                 // will get to it when they are all processed.\n             }\n             NodeState::Done | NodeState::Error => {\n-                // already processed that node\n+                // Already processed that node.\n             }\n         };\n     }\n \n     /// Returns a vector of obligations for `p` and all of its\n     /// ancestors, putting them into the error state in the process.\n-    fn error_at(&mut self, p: usize) -> Vec<O> {\n-        let mut error_stack = self.scratch.take().unwrap();\n+    fn error_at(&self, mut i: usize) -> Vec<O> {\n+        let mut error_stack = self.scratch.replace(vec![]);\n         let mut trace = vec![];\n \n-        let mut n = p;\n         loop {\n-            self.nodes[n].state.set(NodeState::Error);\n-            trace.push(self.nodes[n].obligation.clone());\n-            error_stack.extend(self.nodes[n].dependents.iter().map(|x| x.get()));\n+            let node = &self.nodes[i];\n+            node.state.set(NodeState::Error);\n+            trace.push(node.obligation.clone());\n+            error_stack.extend(node.dependents.iter().map(|index| index.index()));\n \n-            // loop to the parent\n-            match self.nodes[n].parent {\n-                Some(q) => n = q.get(),\n+            // Loop to the parent.\n+            match node.parent {\n+                Some(parent_index) => i = parent_index.index(),\n                 None => break\n             }\n         }\n \n         while let Some(i) = error_stack.pop() {\n-            match self.nodes[i].state.get() {\n+            let node = &self.nodes[i];\n+            match node.state.get() {\n                 NodeState::Error => continue,\n-                _ => self.nodes[i].state.set(NodeState::Error),\n+                _ => node.state.set(NodeState::Error),\n             }\n \n-            let node = &self.nodes[i];\n-\n             error_stack.extend(\n-                node.parent.iter().chain(node.dependents.iter()).map(|x| x.get())\n+                node.parent.iter().chain(node.dependents.iter()).map(|index| index.index())\n             );\n         }\n \n-        self.scratch = Some(error_stack);\n+        self.scratch.replace(error_stack);\n         trace\n     }\n \n     // This always-inlined function is for the hot call site.\n     #[inline(always)]\n     fn inlined_mark_neighbors_as_waiting_from(&self, node: &Node<O>) {\n         for dependent in node.parent.iter().chain(node.dependents.iter()) {\n-            self.mark_as_waiting_from(&self.nodes[dependent.get()]);\n+            self.mark_as_waiting_from(&self.nodes[dependent.index()]);\n         }\n     }\n \n@@ -609,7 +624,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n     #[inline(never)]\n     fn compress(&mut self, do_completed: DoCompleted) -> Option<Vec<O>> {\n         let nodes_len = self.nodes.len();\n-        let mut node_rewrites: Vec<_> = self.scratch.take().unwrap();\n+        let mut node_rewrites: Vec<_> = self.scratch.replace(vec![]);\n         node_rewrites.extend(0..nodes_len);\n         let mut dead_nodes = 0;\n \n@@ -620,21 +635,25 @@ impl<O: ForestObligation> ObligationForest<O> {\n         //     self.nodes[i - dead_nodes..i] are all dead\n         //     self.nodes[i..] are unchanged\n         for i in 0..self.nodes.len() {\n-            match self.nodes[i].state.get() {\n+            let node = &self.nodes[i];\n+            match node.state.get() {\n                 NodeState::Pending | NodeState::Waiting => {\n                     if dead_nodes > 0 {\n                         self.nodes.swap(i, i - dead_nodes);\n                         node_rewrites[i] -= dead_nodes;\n                     }\n                 }\n                 NodeState::Done => {\n-                    // Avoid cloning the key (predicate) in case it exists in the waiting cache\n+                    // This lookup can fail because the contents of\n+                    // `self.waiting_cache` is not guaranteed to match those of\n+                    // `self.nodes`. See the comment in `process_obligation`\n+                    // for more details.\n                     if let Some((predicate, _)) = self.waiting_cache\n-                        .remove_entry(self.nodes[i].obligation.as_predicate())\n+                        .remove_entry(node.obligation.as_predicate())\n                     {\n                         self.done_cache.insert(predicate);\n                     } else {\n-                        self.done_cache.insert(self.nodes[i].obligation.as_predicate().clone());\n+                        self.done_cache.insert(node.obligation.as_predicate().clone());\n                     }\n                     node_rewrites[i] = nodes_len;\n                     dead_nodes += 1;\n@@ -643,7 +662,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n                     // We *intentionally* remove the node from the cache at this point. Otherwise\n                     // tests must come up with a different type on every type error they\n                     // check against.\n-                    self.waiting_cache.remove(self.nodes[i].obligation.as_predicate());\n+                    self.waiting_cache.remove(node.obligation.as_predicate());\n                     node_rewrites[i] = nodes_len;\n                     dead_nodes += 1;\n                     self.insert_into_error_cache(i);\n@@ -655,12 +674,11 @@ impl<O: ForestObligation> ObligationForest<O> {\n         // No compression needed.\n         if dead_nodes == 0 {\n             node_rewrites.truncate(0);\n-            self.scratch = Some(node_rewrites);\n+            self.scratch.replace(node_rewrites);\n             return if do_completed == DoCompleted::Yes { Some(vec![]) } else { None };\n         }\n \n-        // Pop off all the nodes we killed and extract the success\n-        // stories.\n+        // Pop off all the nodes we killed and extract the success stories.\n         let successful = if do_completed == DoCompleted::Yes {\n             Some((0..dead_nodes)\n                 .map(|_| self.nodes.pop().unwrap())\n@@ -679,7 +697,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n         self.apply_rewrites(&node_rewrites);\n \n         node_rewrites.truncate(0);\n-        self.scratch = Some(node_rewrites);\n+        self.scratch.replace(node_rewrites);\n \n         successful\n     }\n@@ -689,58 +707,41 @@ impl<O: ForestObligation> ObligationForest<O> {\n \n         for node in &mut self.nodes {\n             if let Some(index) = node.parent {\n-                let new_index = node_rewrites[index.get()];\n-                if new_index >= nodes_len {\n-                    // parent dead due to error\n+                let new_i = node_rewrites[index.index()];\n+                if new_i >= nodes_len {\n                     node.parent = None;\n                 } else {\n-                    node.parent = Some(NodeIndex::new(new_index));\n+                    node.parent = Some(NodeIndex::new(new_i));\n                 }\n             }\n \n             let mut i = 0;\n             while i < node.dependents.len() {\n-                let new_index = node_rewrites[node.dependents[i].get()];\n-                if new_index >= nodes_len {\n+                let new_i = node_rewrites[node.dependents[i].index()];\n+                if new_i >= nodes_len {\n                     node.dependents.swap_remove(i);\n                 } else {\n-                    node.dependents[i] = NodeIndex::new(new_index);\n+                    node.dependents[i] = NodeIndex::new(new_i);\n                     i += 1;\n                 }\n             }\n         }\n \n-        let mut kill_list = vec![];\n-        for (predicate, index) in &mut self.waiting_cache {\n-            let new_index = node_rewrites[index.get()];\n-            if new_index >= nodes_len {\n-                kill_list.push(predicate.clone());\n+        // This updating of `self.waiting_cache` is necessary because the\n+        // removal of nodes within `compress` can fail. See above.\n+        self.waiting_cache.retain(|_predicate, index| {\n+            let new_i = node_rewrites[index.index()];\n+            if new_i >= nodes_len {\n+                false\n             } else {\n-                *index = NodeIndex::new(new_index);\n+                *index = NodeIndex::new(new_i);\n+                true\n             }\n-        }\n-\n-        for predicate in kill_list { self.waiting_cache.remove(&predicate); }\n-    }\n-}\n-\n-impl<O> Node<O> {\n-    fn new(\n-        parent: Option<NodeIndex>,\n-        obligation: O,\n-        obligation_tree_id: ObligationTreeId\n-    ) -> Node<O> {\n-        Node {\n-            obligation,\n-            state: Cell::new(NodeState::Pending),\n-            parent,\n-            dependents: vec![],\n-            obligation_tree_id,\n-        }\n+        });\n     }\n }\n \n-// I need a Clone closure\n+// I need a Clone closure.\n #[derive(Clone)]\n struct GetObligation<'a, O>(&'a [Node<O>]);\n "}, {"sha": "69ea473e054618dabe8dc437e23c649f42517b5f", "filename": "src/librustc_data_structures/obligation_forest/node_index.rs", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7ac21e7636f7b3c0eb3e31b13c7087b4de7aa5a9/src%2Flibrustc_data_structures%2Fobligation_forest%2Fnode_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac21e7636f7b3c0eb3e31b13c7087b4de7aa5a9/src%2Flibrustc_data_structures%2Fobligation_forest%2Fnode_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Fnode_index.rs?ref=7ac21e7636f7b3c0eb3e31b13c7087b4de7aa5a9", "patch": "@@ -1,20 +0,0 @@\n-use std::num::NonZeroU32;\n-use std::u32;\n-\n-#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n-pub struct NodeIndex {\n-    index: NonZeroU32,\n-}\n-\n-impl NodeIndex {\n-    #[inline]\n-    pub fn new(value: usize) -> NodeIndex {\n-        assert!(value < (u32::MAX as usize));\n-        NodeIndex { index: NonZeroU32::new((value as u32) + 1).unwrap() }\n-    }\n-\n-    #[inline]\n-    pub fn get(self) -> usize {\n-        (self.index.get() - 1) as usize\n-    }\n-}"}, {"sha": "26a89b4e7a8d1ec412b1e0efbb7342ee4cb30452", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/mod.rs", "status": "modified", "additions": 128, "deletions": 115, "changes": 243, "blob_url": "https://github.com/rust-lang/rust/blob/5670d048c0f88af9976b5505c7853b23dd06770d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5670d048c0f88af9976b5505c7853b23dd06770d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs?ref=5670d048c0f88af9976b5505c7853b23dd06770d", "patch": "@@ -13,7 +13,7 @@ use rustc::infer::NLLRegionVariableOrigin;\n use rustc::mir::{ConstraintCategory, Location, Body};\n use rustc::ty::{self, RegionVid};\n use rustc_data_structures::indexed_vec::IndexVec;\n-use rustc_errors::{Diagnostic, DiagnosticBuilder};\n+use rustc_errors::DiagnosticBuilder;\n use std::collections::VecDeque;\n use syntax::errors::Applicability;\n use syntax::symbol::kw;\n@@ -22,7 +22,7 @@ use syntax_pos::Span;\n mod region_name;\n mod var_name;\n \n-crate use self::region_name::{RegionName, RegionNameSource};\n+crate use self::region_name::{RegionName, RegionNameSource, RegionErrorNamingCtx};\n \n impl ConstraintDescription for ConstraintCategory {\n     fn description(&self) -> &'static str {\n@@ -54,6 +54,39 @@ enum Trace {\n     NotVisited,\n }\n \n+/// Various pieces of state used when reporting borrow checker errors.\n+pub struct ErrorReportingCtx<'a, 'b, 'tcx> {\n+    /// The region inference context used for borrow chekcing this MIR body.\n+    #[allow(dead_code)] // FIXME(mark-i-m): used by outlives suggestions\n+    region_infcx: &'b RegionInferenceContext<'tcx>,\n+\n+    /// The inference context used for type checking.\n+    infcx: &'b InferCtxt<'a, 'tcx>,\n+\n+    /// The MIR def we are reporting errors on.\n+    mir_def_id: DefId,\n+\n+    /// The MIR body we are reporting errors on (for convenience).\n+    body: &'b Body<'tcx>,\n+\n+    /// Any upvars for the MIR body we have kept track of during borrow checking.\n+    upvars: &'b [Upvar],\n+}\n+\n+/// Information about the various region constraints involved in a borrow checker error.\n+#[derive(Clone, Debug)]\n+pub struct ErrorConstraintInfo {\n+    // fr: outlived_fr\n+    fr: RegionVid,\n+    fr_is_local: bool,\n+    outlived_fr: RegionVid,\n+    outlived_fr_is_local: bool,\n+\n+    // Category and span for best blame constraint\n+    category: ConstraintCategory,\n+    span: Span,\n+}\n+\n impl<'tcx> RegionInferenceContext<'tcx> {\n     /// Tries to find the best constraint to blame for the fact that\n     /// `R: from_region`, where `R` is some region that meets\n@@ -257,16 +290,16 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// ```\n     ///\n     /// Here we would be invoked with `fr = 'a` and `outlived_fr = `'b`.\n-    pub(super) fn report_error(\n-        &self,\n+    pub(super) fn report_error<'a>(\n+        &'a self,\n         body: &Body<'tcx>,\n         upvars: &[Upvar],\n-        infcx: &InferCtxt<'_, 'tcx>,\n+        infcx: &'a InferCtxt<'a, 'tcx>,\n         mir_def_id: DefId,\n         fr: RegionVid,\n         outlived_fr: RegionVid,\n-        errors_buffer: &mut Vec<Diagnostic>,\n-    ) {\n+        renctx: &mut RegionErrorNamingCtx,\n+    ) -> DiagnosticBuilder<'a> {\n         debug!(\"report_error(fr={:?}, outlived_fr={:?})\", fr, outlived_fr);\n \n         let (category, _, span) = self.best_blame_constraint(body, fr, |r| {\n@@ -279,8 +312,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             let tables = infcx.tcx.typeck_tables_of(mir_def_id);\n             let nice = NiceRegionError::new_from_span(infcx, span, o, f, Some(tables));\n             if let Some(diag) = nice.try_report_from_nll() {\n-                diag.buffer(errors_buffer);\n-                return;\n+                return diag;\n             }\n         }\n \n@@ -293,45 +325,28 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             \"report_error: fr_is_local={:?} outlived_fr_is_local={:?} category={:?}\",\n             fr_is_local, outlived_fr_is_local, category\n         );\n+\n+        let errctx = ErrorReportingCtx {\n+            region_infcx: self,\n+            infcx,\n+            mir_def_id,\n+            body,\n+            upvars,\n+        };\n+\n+        let errci = ErrorConstraintInfo {\n+            fr, outlived_fr, fr_is_local, outlived_fr_is_local, category, span\n+        };\n+\n         match (category, fr_is_local, outlived_fr_is_local) {\n             (ConstraintCategory::Return, true, false) if self.is_closure_fn_mut(infcx, fr) => {\n-                self.report_fnmut_error(\n-                    body,\n-                    upvars,\n-                    infcx,\n-                    mir_def_id,\n-                    fr,\n-                    outlived_fr,\n-                    span,\n-                    errors_buffer,\n-                )\n+                self.report_fnmut_error(&errctx, &errci, renctx)\n             }\n             (ConstraintCategory::Assignment, true, false)\n-            | (ConstraintCategory::CallArgument, true, false) => self.report_escaping_data_error(\n-                body,\n-                upvars,\n-                infcx,\n-                mir_def_id,\n-                fr,\n-                outlived_fr,\n-                category,\n-                span,\n-                errors_buffer,\n-            ),\n-            _ => self.report_general_error(\n-                body,\n-                upvars,\n-                infcx,\n-                mir_def_id,\n-                fr,\n-                fr_is_local,\n-                outlived_fr,\n-                outlived_fr_is_local,\n-                category,\n-                span,\n-                errors_buffer,\n-            ),\n-        };\n+            | (ConstraintCategory::CallArgument, true, false) =>\n+                self.report_escaping_data_error(&errctx, &errci, renctx),\n+            _ => self.report_general_error(&errctx, &errci, renctx),\n+        }\n     }\n \n     /// We have a constraint `fr1: fr2` that is not satisfied, where\n@@ -379,19 +394,19 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// ```\n     fn report_fnmut_error(\n         &self,\n-        body: &Body<'tcx>,\n-        upvars: &[Upvar],\n-        infcx: &InferCtxt<'_, 'tcx>,\n-        mir_def_id: DefId,\n-        _fr: RegionVid,\n-        outlived_fr: RegionVid,\n-        span: Span,\n-        errors_buffer: &mut Vec<Diagnostic>,\n-    ) {\n-        let mut diag = infcx\n+        errctx: &ErrorReportingCtx<'_, '_, 'tcx>,\n+        errci: &ErrorConstraintInfo,\n+        renctx: &mut RegionErrorNamingCtx,\n+    ) -> DiagnosticBuilder<'_> {\n+        let ErrorConstraintInfo {\n+            outlived_fr, span, ..\n+        } = errci;\n+\n+        let mut diag = errctx\n+            .infcx\n             .tcx\n             .sess\n-            .struct_span_err(span, \"captured variable cannot escape `FnMut` closure body\");\n+            .struct_span_err(*span, \"captured variable cannot escape `FnMut` closure body\");\n \n         // We should check if the return type of this closure is in fact a closure - in that\n         // case, we can special case the error further.\n@@ -403,11 +418,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             \"returns a reference to a captured variable which escapes the closure body\"\n         };\n \n-        diag.span_label(span, message);\n+        diag.span_label(*span, message);\n \n-        match self.give_region_a_name(infcx, body, upvars, mir_def_id, outlived_fr, &mut 1)\n-            .unwrap().source\n-        {\n+        match self.give_region_a_name(errctx, renctx, *outlived_fr).unwrap().source {\n             RegionNameSource::NamedEarlyBoundRegion(fr_span)\n             | RegionNameSource::NamedFreeRegion(fr_span)\n             | RegionNameSource::SynthesizedFreeEnvRegion(fr_span, _)\n@@ -427,7 +440,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         );\n         diag.note(\"...therefore, they cannot allow references to captured variables to escape\");\n \n-        diag.buffer(errors_buffer);\n+        diag\n     }\n \n     /// Reports a error specifically for when data is escaping a closure.\n@@ -444,20 +457,22 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// ```\n     fn report_escaping_data_error(\n         &self,\n-        body: &Body<'tcx>,\n-        upvars: &[Upvar],\n-        infcx: &InferCtxt<'_, 'tcx>,\n-        mir_def_id: DefId,\n-        fr: RegionVid,\n-        outlived_fr: RegionVid,\n-        category: ConstraintCategory,\n-        span: Span,\n-        errors_buffer: &mut Vec<Diagnostic>,\n-    ) {\n+        errctx: &ErrorReportingCtx<'_, '_, 'tcx>,\n+        errci: &ErrorConstraintInfo,\n+        renctx: &mut RegionErrorNamingCtx,\n+    ) -> DiagnosticBuilder<'_> {\n+        let ErrorReportingCtx {\n+            infcx, body, upvars, ..\n+        } = errctx;\n+\n+        let ErrorConstraintInfo {\n+            span, category, ..\n+        } = errci;\n+\n         let fr_name_and_span =\n-            self.get_var_name_and_span_for_region(infcx.tcx, body, upvars, fr);\n+            self.get_var_name_and_span_for_region(infcx.tcx, body, upvars, errci.fr);\n         let outlived_fr_name_and_span =\n-            self.get_var_name_and_span_for_region(infcx.tcx, body, upvars, outlived_fr);\n+            self.get_var_name_and_span_for_region(infcx.tcx, body, upvars, errci.outlived_fr);\n \n         let escapes_from = match self.universal_regions.defining_ty {\n             DefiningTy::Closure(..) => \"closure\",\n@@ -469,27 +484,23 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // Revert to the normal error in these cases.\n         // Assignments aren't \"escapes\" in function items.\n         if (fr_name_and_span.is_none() && outlived_fr_name_and_span.is_none())\n-            || (category == ConstraintCategory::Assignment && escapes_from == \"function\")\n+            || (*category == ConstraintCategory::Assignment && escapes_from == \"function\")\n             || escapes_from == \"const\"\n         {\n             return self.report_general_error(\n-                body,\n-                upvars,\n-                infcx,\n-                mir_def_id,\n-                fr,\n-                true,\n-                outlived_fr,\n-                false,\n-                category,\n-                span,\n-                errors_buffer,\n+                errctx,\n+                &ErrorConstraintInfo {\n+                    fr_is_local: true,\n+                    outlived_fr_is_local: false,\n+                    .. *errci\n+                },\n+                renctx,\n             );\n         }\n \n         let mut diag = borrowck_errors::borrowed_data_escapes_closure(\n             infcx.tcx,\n-            span,\n+            *span,\n             escapes_from,\n         );\n \n@@ -513,12 +524,12 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             );\n \n             diag.span_label(\n-                span,\n+                *span,\n                 format!(\"`{}` escapes the {} body here\", fr_name, escapes_from),\n             );\n         }\n \n-        diag.buffer(errors_buffer);\n+        diag\n     }\n \n     /// Reports a region inference error for the general case with named/synthesized lifetimes to\n@@ -538,41 +549,37 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// ```\n     fn report_general_error(\n         &self,\n-        body: &Body<'tcx>,\n-        upvars: &[Upvar],\n-        infcx: &InferCtxt<'_, 'tcx>,\n-        mir_def_id: DefId,\n-        fr: RegionVid,\n-        fr_is_local: bool,\n-        outlived_fr: RegionVid,\n-        outlived_fr_is_local: bool,\n-        category: ConstraintCategory,\n-        span: Span,\n-        errors_buffer: &mut Vec<Diagnostic>,\n-    ) {\n+        errctx: &ErrorReportingCtx<'_, '_, 'tcx>,\n+        errci: &ErrorConstraintInfo,\n+        renctx: &mut RegionErrorNamingCtx,\n+    ) -> DiagnosticBuilder<'_> {\n+        let ErrorReportingCtx {\n+            infcx, mir_def_id, ..\n+        } = errctx;\n+        let ErrorConstraintInfo {\n+            fr, fr_is_local, outlived_fr, outlived_fr_is_local, span, category, ..\n+        } = errci;\n+\n         let mut diag = infcx.tcx.sess.struct_span_err(\n-            span,\n+            *span,\n             \"lifetime may not live long enough\"\n         );\n \n-        let counter = &mut 1;\n-        let fr_name = self.give_region_a_name(\n-            infcx, body, upvars, mir_def_id, fr, counter).unwrap();\n-        fr_name.highlight_region_name(&mut diag);\n-        let outlived_fr_name =\n-            self.give_region_a_name(infcx, body, upvars, mir_def_id, outlived_fr, counter).unwrap();\n-        outlived_fr_name.highlight_region_name(&mut diag);\n-\n-        let mir_def_name = if infcx.tcx.is_closure(mir_def_id) {\n+        let mir_def_name = if infcx.tcx.is_closure(*mir_def_id) {\n             \"closure\"\n         } else {\n             \"function\"\n         };\n \n+        let fr_name = self.give_region_a_name(errctx, renctx, *fr).unwrap();\n+        fr_name.highlight_region_name(&mut diag);\n+        let outlived_fr_name = self.give_region_a_name(errctx, renctx, *outlived_fr).unwrap();\n+        outlived_fr_name.highlight_region_name(&mut diag);\n+\n         match (category, outlived_fr_is_local, fr_is_local) {\n             (ConstraintCategory::Return, true, _) => {\n                 diag.span_label(\n-                    span,\n+                    *span,\n                     format!(\n                         \"{} was supposed to return data with lifetime `{}` but it is returning \\\n                          data with lifetime `{}`\",\n@@ -582,7 +589,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             }\n             _ => {\n                 diag.span_label(\n-                    span,\n+                    *span,\n                     format!(\n                         \"{}requires that `{}` must outlive `{}`\",\n                         category.description(),\n@@ -593,9 +600,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             }\n         }\n \n-        self.add_static_impl_trait_suggestion(infcx, &mut diag, fr, fr_name, outlived_fr);\n+        self.add_static_impl_trait_suggestion(infcx, &mut diag, *fr, fr_name, *outlived_fr);\n \n-        diag.buffer(errors_buffer);\n+        diag\n     }\n \n     /// Adds a suggestion to errors where a `impl Trait` is returned.\n@@ -704,8 +711,14 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             borrow_region,\n             |r| self.provides_universal_region(r, borrow_region, outlived_region)\n         );\n-        let outlived_fr_name =\n-            self.give_region_a_name(infcx, body, upvars, mir_def_id, outlived_region, &mut 1);\n+\n+        let mut renctx = RegionErrorNamingCtx::new();\n+        let errctx = ErrorReportingCtx {\n+            infcx, body, upvars, mir_def_id,\n+            region_infcx: self,\n+        };\n+        let outlived_fr_name = self.give_region_a_name(&errctx, &mut renctx, outlived_region);\n+\n         (category, from_closure, span, outlived_fr_name)\n     }\n "}, {"sha": "6fa94269107f583388ea5f71819150d454983f5f", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/region_name.rs", "status": "modified", "additions": 127, "deletions": 71, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/5670d048c0f88af9976b5505c7853b23dd06770d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5670d048c0f88af9976b5505c7853b23dd06770d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs?ref=5670d048c0f88af9976b5505c7853b23dd06770d", "patch": "@@ -1,5 +1,9 @@\n use std::fmt::{self, Display};\n-use crate::borrow_check::nll::region_infer::RegionInferenceContext;\n+\n+use crate::borrow_check::nll::region_infer::{\n+    RegionInferenceContext,\n+    error_reporting::ErrorReportingCtx,\n+};\n use crate::borrow_check::nll::universal_regions::DefiningTy;\n use crate::borrow_check::nll::ToRegionVid;\n use crate::borrow_check::Upvar;\n@@ -13,29 +17,75 @@ use rustc::ty::{self, RegionKind, RegionVid, Ty, TyCtxt};\n use rustc::ty::print::RegionHighlightMode;\n use rustc_errors::DiagnosticBuilder;\n use syntax::symbol::kw;\n-use syntax_pos::Span;\n-use syntax_pos::symbol::InternedString;\n+use rustc_data_structures::fx::FxHashMap;\n+use syntax_pos::{Span, symbol::InternedString};\n \n-#[derive(Debug)]\n+/// A name for a particular region used in emitting diagnostics. This name could be a generated\n+/// name like `'1`, a name used by the user like `'a`, or a name like `'static`.\n+#[derive(Debug, Clone)]\n crate struct RegionName {\n+    /// The name of the region (interned).\n     crate name: InternedString,\n+    /// Where the region comes from.\n     crate source: RegionNameSource,\n }\n \n-#[derive(Debug)]\n+/// Denotes the source of a region that is named by a `RegionName`. For example, a free region that\n+/// was named by the user would get `NamedFreeRegion` and `'static` lifetime would get `Static`.\n+/// This helps to print the right kinds of diagnostics.\n+#[derive(Debug, Clone)]\n crate enum RegionNameSource {\n+    /// A bound (not free) region that was substituted at the def site (not an HRTB).\n     NamedEarlyBoundRegion(Span),\n+    /// A free region that the user has a name (`'a`) for.\n     NamedFreeRegion(Span),\n+    /// The `'static` region.\n     Static,\n+    /// The free region corresponding to the environment of a closure.\n     SynthesizedFreeEnvRegion(Span, String),\n+    /// The region name corresponds to a region where the type annotation is completely missing\n+    /// from the code, e.g. in a closure arguments `|x| { ... }`, where `x` is a reference.\n     CannotMatchHirTy(Span, String),\n+    /// The region name corresponds a reference that was found by traversing the type in the HIR.\n     MatchedHirTy(Span),\n+    /// A region name from the generics list of a struct/enum/union.\n     MatchedAdtAndSegment(Span),\n+    /// The region corresponding to a closure upvar.\n     AnonRegionFromUpvar(Span, String),\n+    /// The region corresponding to the return type of a closure.\n     AnonRegionFromOutput(Span, String, String),\n     AnonRegionFromYieldTy(Span, String),\n }\n \n+/// Records region names that have been assigned before so that we can use the same ones in later\n+/// diagnostics.\n+#[derive(Debug, Clone)]\n+crate struct RegionErrorNamingCtx {\n+    /// Record the region names generated for each region in the given\n+    /// MIR def so that we can reuse them later in help/error messages.\n+    renctx: FxHashMap<RegionVid, RegionName>,\n+\n+    /// The counter for generating new region names.\n+    counter: usize,\n+}\n+\n+impl RegionErrorNamingCtx {\n+    crate fn new() -> Self {\n+        Self {\n+            counter: 1,\n+            renctx: FxHashMap::default(),\n+        }\n+    }\n+\n+    crate fn get(&self, region: &RegionVid) -> Option<&RegionName> {\n+        self.renctx.get(region)\n+    }\n+\n+    crate fn insert(&mut self, region: RegionVid, name: RegionName) {\n+        self.renctx.insert(region, name);\n+    }\n+}\n+\n impl RegionName {\n     #[allow(dead_code)]\n     crate fn was_named(&self) -> bool {\n@@ -63,43 +113,40 @@ impl RegionName {\n         self.name\n     }\n \n-    crate fn highlight_region_name(\n-        &self,\n-        diag: &mut DiagnosticBuilder<'_>\n-    ) {\n+    crate fn highlight_region_name(&self, diag: &mut DiagnosticBuilder<'_>) {\n         match &self.source {\n-            RegionNameSource::NamedFreeRegion(span) |\n-            RegionNameSource::NamedEarlyBoundRegion(span) => {\n-                diag.span_label(\n-                    *span,\n-                    format!(\"lifetime `{}` defined here\", self),\n-                );\n-            },\n+            RegionNameSource::NamedFreeRegion(span)\n+            | RegionNameSource::NamedEarlyBoundRegion(span) => {\n+                diag.span_label(*span, format!(\"lifetime `{}` defined here\", self));\n+            }\n             RegionNameSource::SynthesizedFreeEnvRegion(span, note) => {\n                 diag.span_label(\n                     *span,\n                     format!(\"lifetime `{}` represents this closure's body\", self),\n                 );\n                 diag.note(&note);\n-            },\n+            }\n             RegionNameSource::CannotMatchHirTy(span, type_name) => {\n                 diag.span_label(*span, format!(\"has type `{}`\", type_name));\n-            },\n+            }\n             RegionNameSource::MatchedHirTy(span) => {\n                 diag.span_label(\n                     *span,\n                     format!(\"let's call the lifetime of this reference `{}`\", self),\n                 );\n-            },\n+            }\n             RegionNameSource::MatchedAdtAndSegment(span) => {\n                 diag.span_label(*span, format!(\"let's call this `{}`\", self));\n-            },\n+            }\n             RegionNameSource::AnonRegionFromUpvar(span, upvar_name) => {\n                 diag.span_label(\n                     *span,\n-                    format!(\"lifetime `{}` appears in the type of `{}`\", self, upvar_name),\n+                    format!(\n+                        \"lifetime `{}` appears in the type of `{}`\",\n+                        self, upvar_name\n+                    ),\n                 );\n-            },\n+            }\n             RegionNameSource::AnonRegionFromOutput(span, mir_description, type_name) => {\n                 diag.span_label(\n                     *span,\n@@ -151,39 +198,49 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// and then return the name `'1` for us to use.\n     crate fn give_region_a_name(\n         &self,\n-        infcx: &InferCtxt<'_, 'tcx>,\n-        body: &Body<'tcx>,\n-        upvars: &[Upvar],\n-        mir_def_id: DefId,\n+        errctx: &ErrorReportingCtx<'_, '_, 'tcx>,\n+        renctx: &mut RegionErrorNamingCtx,\n         fr: RegionVid,\n-        counter: &mut usize,\n     ) -> Option<RegionName> {\n-        debug!(\"give_region_a_name(fr={:?}, counter={})\", fr, counter);\n+        let ErrorReportingCtx {\n+            infcx, body, mir_def_id, upvars, ..\n+        } = errctx;\n+\n+        debug!(\"give_region_a_name(fr={:?}, counter={:?})\", fr, renctx.counter);\n \n         assert!(self.universal_regions.is_universal_region(fr));\n \n-        let value = self.give_name_from_error_region(infcx.tcx, mir_def_id, fr, counter)\n+        if let Some(value) = renctx.get(&fr) {\n+            return Some(value.clone());\n+        }\n+\n+        let value = self\n+            .give_name_from_error_region(infcx.tcx, *mir_def_id, fr, renctx)\n             .or_else(|| {\n                 self.give_name_if_anonymous_region_appears_in_arguments(\n-                    infcx, body, mir_def_id, fr, counter,\n+                    infcx, body, *mir_def_id, fr, renctx,\n                 )\n             })\n             .or_else(|| {\n                 self.give_name_if_anonymous_region_appears_in_upvars(\n-                    infcx.tcx, upvars, fr, counter,\n+                    infcx.tcx, upvars, fr, renctx\n                 )\n             })\n             .or_else(|| {\n                 self.give_name_if_anonymous_region_appears_in_output(\n-                    infcx, body, mir_def_id, fr, counter,\n+                    infcx, body, *mir_def_id, fr, renctx,\n                 )\n             })\n             .or_else(|| {\n                 self.give_name_if_anonymous_region_appears_in_yield_ty(\n-                    infcx, body, mir_def_id, fr, counter,\n+                    infcx, body, *mir_def_id, fr, renctx,\n                 )\n             });\n \n+        if let Some(ref value) = value {\n+            renctx.insert(fr, value.clone());\n+        }\n+\n         debug!(\"give_region_a_name: gave name {:?}\", value);\n         value\n     }\n@@ -197,7 +254,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         tcx: TyCtxt<'tcx>,\n         mir_def_id: DefId,\n         fr: RegionVid,\n-        counter: &mut usize,\n+        renctx: &mut RegionErrorNamingCtx,\n     ) -> Option<RegionName> {\n         let error_region = self.to_error_region(fr)?;\n \n@@ -208,7 +265,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                     let span = self.get_named_span(tcx, error_region, ebr.name);\n                     Some(RegionName {\n                         name: ebr.name,\n-                        source: RegionNameSource::NamedEarlyBoundRegion(span)\n+                        source: RegionNameSource::NamedEarlyBoundRegion(span),\n                     })\n                 } else {\n                     None\n@@ -227,12 +284,10 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                         name,\n                         source: RegionNameSource::NamedFreeRegion(span),\n                     })\n-                },\n+                }\n \n                 ty::BoundRegion::BrEnv => {\n-                    let mir_hir_id = tcx.hir()\n-                                        .as_local_hir_id(mir_def_id)\n-                                        .expect(\"non-local mir\");\n+                    let mir_hir_id = tcx.hir().as_local_hir_id(mir_def_id).expect(\"non-local mir\");\n                     let def_ty = self.universal_regions.defining_ty;\n \n                     if let DefiningTy::Closure(def_id, substs) = def_ty {\n@@ -243,7 +298,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                         } else {\n                             bug!(\"Closure is not defined by a closure expr\");\n                         };\n-                        let region_name = self.synthesize_region_name(counter);\n+                        let region_name = self.synthesize_region_name(renctx);\n \n                         let closure_kind_ty = substs.closure_kind_ty(def_id, tcx);\n                         let note = match closure_kind_ty.to_opt_closure_kind() {\n@@ -265,7 +320,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                             name: region_name,\n                             source: RegionNameSource::SynthesizedFreeEnvRegion(\n                                 args_span,\n-                                note.to_string()\n+                                note.to_string(),\n                             ),\n                         })\n                     } else {\n@@ -335,7 +390,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         body: &Body<'tcx>,\n         mir_def_id: DefId,\n         fr: RegionVid,\n-        counter: &mut usize,\n+        renctx: &mut RegionErrorNamingCtx,\n     ) -> Option<RegionName> {\n         let implicit_inputs = self.universal_regions.defining_ty.implicit_inputs();\n         let argument_index = self.get_argument_index_for_region(infcx.tcx, fr)?;\n@@ -349,12 +404,12 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             fr,\n             arg_ty,\n             argument_index,\n-            counter,\n+            renctx,\n         ) {\n             return Some(region_name);\n         }\n \n-        self.give_name_if_we_cannot_match_hir_ty(infcx, body, fr, arg_ty, counter)\n+        self.give_name_if_we_cannot_match_hir_ty(infcx, body, fr, arg_ty, renctx)\n     }\n \n     fn give_name_if_we_can_match_hir_ty_from_argument(\n@@ -365,7 +420,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         needle_fr: RegionVid,\n         argument_ty: Ty<'tcx>,\n         argument_index: usize,\n-        counter: &mut usize,\n+        renctx: &mut RegionErrorNamingCtx,\n     ) -> Option<RegionName> {\n         let mir_hir_id = infcx.tcx.hir().as_local_hir_id(mir_def_id)?;\n         let fn_decl = infcx.tcx.hir().fn_decl_by_hir_id(mir_hir_id)?;\n@@ -379,15 +434,15 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 body,\n                 needle_fr,\n                 argument_ty,\n-                counter,\n+                renctx,\n             ),\n \n             _ => self.give_name_if_we_can_match_hir_ty(\n                 infcx.tcx,\n                 needle_fr,\n                 argument_ty,\n                 argument_hir_ty,\n-                counter,\n+                renctx,\n             ),\n         }\n     }\n@@ -409,10 +464,11 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         body: &Body<'tcx>,\n         needle_fr: RegionVid,\n         argument_ty: Ty<'tcx>,\n-        counter: &mut usize,\n+        renctx: &mut RegionErrorNamingCtx,\n     ) -> Option<RegionName> {\n+        let counter = renctx.counter;\n         let mut highlight = RegionHighlightMode::default();\n-        highlight.highlighting_region_vid(needle_fr, *counter);\n+        highlight.highlighting_region_vid(needle_fr, counter);\n         let type_name = infcx.extract_type_name(&argument_ty, Some(highlight)).0;\n \n         debug!(\n@@ -428,7 +484,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 // This counter value will already have been used, so this function will increment\n                 // it so the next value will be used next and return the region name that would\n                 // have been used.\n-                name: self.synthesize_region_name(counter),\n+                name: self.synthesize_region_name(renctx),\n                 source: RegionNameSource::CannotMatchHirTy(span, type_name),\n             })\n         } else {\n@@ -455,7 +511,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// type. Once we find that, we can use the span of the `hir::Ty`\n     /// to add the highlight.\n     ///\n-    /// This is a somewhat imperfect process, so long the way we also\n+    /// This is a somewhat imperfect process, so along the way we also\n     /// keep track of the **closest** type we've found. If we fail to\n     /// find the exact `&` or `'_` to highlight, then we may fall back\n     /// to highlighting that closest type instead.\n@@ -465,7 +521,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         needle_fr: RegionVid,\n         argument_ty: Ty<'tcx>,\n         argument_hir_ty: &hir::Ty,\n-        counter: &mut usize,\n+        renctx: &mut RegionErrorNamingCtx,\n     ) -> Option<RegionName> {\n         let search_stack: &mut Vec<(Ty<'tcx>, &hir::Ty)> =\n             &mut vec![(argument_ty, argument_hir_ty)];\n@@ -483,7 +539,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                     hir::TyKind::Rptr(_lifetime, referent_hir_ty),\n                 ) => {\n                     if region.to_region_vid() == needle_fr {\n-                        let region_name = self.synthesize_region_name(counter);\n+                        let region_name = self.synthesize_region_name(renctx);\n \n                         // Just grab the first character, the `&`.\n                         let source_map = tcx.sess.source_map();\n@@ -515,7 +571,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                                 substs,\n                                 needle_fr,\n                                 last_segment,\n-                                counter,\n+                                renctx,\n                                 search_stack,\n                             ) {\n                                 return Some(name);\n@@ -559,18 +615,19 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         substs: SubstsRef<'tcx>,\n         needle_fr: RegionVid,\n         last_segment: &'hir hir::PathSegment,\n-        counter: &mut usize,\n+        renctx: &mut RegionErrorNamingCtx,\n         search_stack: &mut Vec<(Ty<'tcx>, &'hir hir::Ty)>,\n     ) -> Option<RegionName> {\n         // Did the user give explicit arguments? (e.g., `Foo<..>`)\n         let args = last_segment.args.as_ref()?;\n-        let lifetime = self.try_match_adt_and_generic_args(substs, needle_fr, args, search_stack)?;\n+        let lifetime =\n+            self.try_match_adt_and_generic_args(substs, needle_fr, args, search_stack)?;\n         match lifetime.name {\n             hir::LifetimeName::Param(_)\n             | hir::LifetimeName::Error\n             | hir::LifetimeName::Static\n             | hir::LifetimeName::Underscore => {\n-                let region_name = self.synthesize_region_name(counter);\n+                let region_name = self.synthesize_region_name(renctx);\n                 let ampersand_span = lifetime.span;\n                 Some(RegionName {\n                     name: region_name,\n@@ -657,12 +714,12 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         tcx: TyCtxt<'tcx>,\n         upvars: &[Upvar],\n         fr: RegionVid,\n-        counter: &mut usize,\n+        renctx: &mut RegionErrorNamingCtx,\n     ) -> Option<RegionName> {\n         let upvar_index = self.get_upvar_index_for_region(tcx, fr)?;\n         let (upvar_name, upvar_span) =\n             self.get_upvar_name_and_span_for_region(tcx, upvars, upvar_index);\n-        let region_name = self.synthesize_region_name(counter);\n+        let region_name = self.synthesize_region_name(renctx);\n \n         Some(RegionName {\n             name: region_name,\n@@ -680,7 +737,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         body: &Body<'tcx>,\n         mir_def_id: DefId,\n         fr: RegionVid,\n-        counter: &mut usize,\n+        renctx: &mut RegionErrorNamingCtx,\n     ) -> Option<RegionName> {\n         let tcx = infcx.tcx;\n \n@@ -694,7 +751,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         }\n \n         let mut highlight = RegionHighlightMode::default();\n-        highlight.highlighting_region_vid(fr, *counter);\n+        highlight.highlighting_region_vid(fr, renctx.counter);\n         let type_name = infcx.extract_type_name(&return_ty, Some(highlight)).0;\n \n         let mir_hir_id = tcx.hir().as_local_hir_id(mir_def_id).expect(\"non-local mir\");\n@@ -725,11 +782,11 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             // This counter value will already have been used, so this function will increment it\n             // so the next value will be used next and return the region name that would have been\n             // used.\n-            name: self.synthesize_region_name(counter),\n+            name: self.synthesize_region_name(renctx),\n             source: RegionNameSource::AnonRegionFromOutput(\n                 return_span,\n                 mir_description.to_string(),\n-                type_name\n+                type_name,\n             ),\n         })\n     }\n@@ -740,7 +797,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         body: &Body<'tcx>,\n         mir_def_id: DefId,\n         fr: RegionVid,\n-        counter: &mut usize,\n+        renctx: &mut RegionErrorNamingCtx,\n     ) -> Option<RegionName> {\n         // Note: generators from `async fn` yield `()`, so we don't have to\n         // worry about them here.\n@@ -757,7 +814,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         }\n \n         let mut highlight = RegionHighlightMode::default();\n-        highlight.highlighting_region_vid(fr, *counter);\n+        highlight.highlighting_region_vid(fr, renctx.counter);\n         let type_name = infcx.extract_type_name(&yield_ty, Some(highlight)).0;\n \n         let mir_hir_id = tcx.hir().as_local_hir_id(mir_def_id).expect(\"non-local mir\");\n@@ -780,16 +837,15 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         );\n \n         Some(RegionName {\n-            name: self.synthesize_region_name(counter),\n+            name: self.synthesize_region_name(renctx),\n             source: RegionNameSource::AnonRegionFromYieldTy(yield_span, type_name),\n         })\n     }\n \n-    /// Creates a synthetic region named `'1`, incrementing the\n-    /// counter.\n-    fn synthesize_region_name(&self, counter: &mut usize) -> InternedString {\n-        let c = *counter;\n-        *counter += 1;\n+    /// Creates a synthetic region named `'1`, incrementing the counter.\n+    fn synthesize_region_name(&self, renctx: &mut RegionErrorNamingCtx) -> InternedString {\n+        let c = renctx.counter;\n+        renctx.counter += 1;\n \n         InternedString::intern(&format!(\"'{:?}\", c))\n     }"}, {"sha": "78e7943598d68ad7eb8761fe5f3bd935b04ef2c1", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 49, "deletions": 16, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/5670d048c0f88af9976b5505c7853b23dd06770d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5670d048c0f88af9976b5505c7853b23dd06770d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=5670d048c0f88af9976b5505c7853b23dd06770d", "patch": "@@ -1,15 +1,20 @@\n-use super::universal_regions::UniversalRegions;\n-use crate::borrow_check::nll::constraints::graph::NormalConstraintGraph;\n-use crate::borrow_check::nll::constraints::{\n-    ConstraintSccIndex, OutlivesConstraint, OutlivesConstraintSet,\n-};\n-use crate::borrow_check::nll::member_constraints::{MemberConstraintSet, NllMemberConstraintIndex};\n-use crate::borrow_check::nll::region_infer::values::{\n-    PlaceholderIndices, RegionElement, ToElementIndex,\n+use std::rc::Rc;\n+\n+use crate::borrow_check::nll::{\n+    constraints::{\n+        graph::NormalConstraintGraph,\n+        ConstraintSccIndex,\n+        OutlivesConstraint,\n+        OutlivesConstraintSet,\n+    },\n+    member_constraints::{MemberConstraintSet, NllMemberConstraintIndex},\n+    region_infer::values::{\n+        PlaceholderIndices, RegionElement, ToElementIndex\n+    },\n+    type_check::{free_region_relations::UniversalRegionRelations, Locations},\n };\n-use crate::borrow_check::nll::type_check::free_region_relations::UniversalRegionRelations;\n-use crate::borrow_check::nll::type_check::Locations;\n use crate::borrow_check::Upvar;\n+\n use rustc::hir::def_id::DefId;\n use rustc::infer::canonical::QueryOutlivesConstraint;\n use rustc::infer::opaque_types;\n@@ -31,16 +36,16 @@ use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_errors::{Diagnostic, DiagnosticBuilder};\n use syntax_pos::Span;\n \n-use std::rc::Rc;\n+crate use self::error_reporting::{RegionName, RegionNameSource, RegionErrorNamingCtx};\n+use self::values::{LivenessValues, RegionValueElements, RegionValues};\n+use super::universal_regions::UniversalRegions;\n+use super::ToRegionVid;\n \n mod dump_mir;\n mod error_reporting;\n-crate use self::error_reporting::{RegionName, RegionNameSource};\n mod graphviz;\n-pub mod values;\n-use self::values::{LivenessValues, RegionValueElements, RegionValues};\n \n-use super::ToRegionVid;\n+pub mod values;\n \n pub struct RegionInferenceContext<'tcx> {\n     /// Contains the definition for every region variable. Region\n@@ -487,13 +492,20 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             errors_buffer,\n         );\n \n+        // If we produce any errors, we keep track of the names of all regions, so that we can use\n+        // the same error names in any suggestions we produce. Note that we need names to be unique\n+        // across different errors for the same MIR def so that we can make suggestions that fix\n+        // multiple problems.\n+        let mut region_naming = RegionErrorNamingCtx::new();\n+\n         self.check_universal_regions(\n             infcx,\n             body,\n             upvars,\n             mir_def_id,\n             outlives_requirements.as_mut(),\n             errors_buffer,\n+            &mut region_naming,\n         );\n \n         self.check_member_constraints(infcx, mir_def_id, errors_buffer);\n@@ -1312,6 +1324,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         mir_def_id: DefId,\n         mut propagated_outlives_requirements: Option<&mut Vec<ClosureOutlivesRequirement<'tcx>>>,\n         errors_buffer: &mut Vec<Diagnostic>,\n+        region_naming: &mut RegionErrorNamingCtx,\n     ) {\n         for (fr, fr_definition) in self.definitions.iter_enumerated() {\n             match fr_definition.origin {\n@@ -1327,6 +1340,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                         fr,\n                         &mut propagated_outlives_requirements,\n                         errors_buffer,\n+                        region_naming,\n                     );\n                 }\n \n@@ -1358,6 +1372,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         longer_fr: RegionVid,\n         propagated_outlives_requirements: &mut Option<&mut Vec<ClosureOutlivesRequirement<'tcx>>>,\n         errors_buffer: &mut Vec<Diagnostic>,\n+        region_naming: &mut RegionErrorNamingCtx,\n     ) {\n         debug!(\"check_universal_region(fr={:?})\", longer_fr);\n \n@@ -1385,6 +1400,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 mir_def_id,\n                 propagated_outlives_requirements,\n                 errors_buffer,\n+                region_naming,\n             );\n             return;\n         }\n@@ -1401,8 +1417,13 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 mir_def_id,\n                 propagated_outlives_requirements,\n                 errors_buffer,\n+                region_naming,\n             ) {\n                 // continuing to iterate just reports more errors than necessary\n+                //\n+                // FIXME It would also allow us to report more Outlives Suggestions, though, so\n+                // it's not clear that that's a bad thing. Somebody should try commenting out this\n+                // line and see it is actually a regression.\n                 return;\n             }\n         }\n@@ -1418,6 +1439,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         mir_def_id: DefId,\n         propagated_outlives_requirements: &mut Option<&mut Vec<ClosureOutlivesRequirement<'tcx>>>,\n         errors_buffer: &mut Vec<Diagnostic>,\n+        region_naming: &mut RegionErrorNamingCtx,\n     ) -> Option<ErrorReported> {\n         // If it is known that `fr: o`, carry on.\n         if self.universal_region_relations.outlives(longer_fr, shorter_fr) {\n@@ -1466,7 +1488,18 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         //\n         // Note: in this case, we use the unapproximated regions to report the\n         // error. This gives better error messages in some cases.\n-        self.report_error(body, upvars, infcx, mir_def_id, longer_fr, shorter_fr, errors_buffer);\n+        let db = self.report_error(\n+            body,\n+            upvars,\n+            infcx,\n+            mir_def_id,\n+            longer_fr,\n+            shorter_fr,\n+            region_naming,\n+        );\n+\n+        db.buffer(errors_buffer);\n+\n         Some(ErrorReported)\n     }\n "}, {"sha": "ab8398ec5e935c498c4b7479e66974a026ed5e50", "filename": "src/test/ui/c-variadic/variadic-ffi-4.nll.stderr", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5670d048c0f88af9976b5505c7853b23dd06770d/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-4.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5670d048c0f88af9976b5505c7853b23dd06770d/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-4.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-4.nll.stderr?ref=5670d048c0f88af9976b5505c7853b23dd06770d", "patch": "@@ -37,11 +37,11 @@ error: lifetime may not live long enough\n   --> $DIR/variadic-ffi-4.rs:20:5\n    |\n LL | pub unsafe extern \"C\" fn no_escape3(_: usize, mut ap0: &mut VaListImpl, mut ap1: ...) {\n-   |                                               -------                   ------- has type `core::ffi::VaListImpl<'1>`\n+   |                                               -------                   ------- has type `core::ffi::VaListImpl<'2>`\n    |                                               |\n-   |                                               has type `&mut core::ffi::VaListImpl<'2>`\n+   |                                               has type `&mut core::ffi::VaListImpl<'1>`\n LL |     *ap0 = ap1;\n-   |     ^^^^ assignment requires that `'1` must outlive `'2`\n+   |     ^^^^ assignment requires that `'2` must outlive `'1`\n \n error: lifetime may not live long enough\n   --> $DIR/variadic-ffi-4.rs:25:5\n@@ -57,11 +57,11 @@ error: lifetime may not live long enough\n   --> $DIR/variadic-ffi-4.rs:25:5\n    |\n LL | pub unsafe extern \"C\" fn no_escape4(_: usize, ap0: &mut VaListImpl, mut ap1: ...) {\n-   |                                               ---                   ------- has type `core::ffi::VaListImpl<'1>`\n+   |                                               ---                   ------- has type `core::ffi::VaListImpl<'2>`\n    |                                               |\n-   |                                               has type `&mut core::ffi::VaListImpl<'2>`\n+   |                                               has type `&mut core::ffi::VaListImpl<'1>`\n LL |     ap0 = &mut ap1;\n-   |     ^^^^^^^^^^^^^^ assignment requires that `'1` must outlive `'2`\n+   |     ^^^^^^^^^^^^^^ assignment requires that `'2` must outlive `'1`\n \n error[E0384]: cannot assign to immutable argument `ap0`\n   --> $DIR/variadic-ffi-4.rs:25:5\n@@ -99,11 +99,11 @@ error: lifetime may not live long enough\n   --> $DIR/variadic-ffi-4.rs:33:12\n    |\n LL | pub unsafe extern \"C\" fn no_escape5(_: usize, mut ap0: &mut VaListImpl, mut ap1: ...) {\n-   |                                               -------                   ------- has type `core::ffi::VaListImpl<'1>`\n+   |                                               -------                   ------- has type `core::ffi::VaListImpl<'2>`\n    |                                               |\n-   |                                               has type `&mut core::ffi::VaListImpl<'2>`\n+   |                                               has type `&mut core::ffi::VaListImpl<'1>`\n LL |     *ap0 = ap1.clone();\n-   |            ^^^^^^^^^^^ argument requires that `'1` must outlive `'2`\n+   |            ^^^^^^^^^^^ argument requires that `'2` must outlive `'1`\n \n error: aborting due to 11 previous errors\n "}, {"sha": "dab4d348ceb604a03572e4c63b80f62a2359afac", "filename": "src/test/ui/generator/auto-trait-regions.stderr", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5670d048c0f88af9976b5505c7853b23dd06770d/src%2Ftest%2Fui%2Fgenerator%2Fauto-trait-regions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5670d048c0f88af9976b5505c7853b23dd06770d/src%2Ftest%2Fui%2Fgenerator%2Fauto-trait-regions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fauto-trait-regions.stderr?ref=5670d048c0f88af9976b5505c7853b23dd06770d", "patch": "@@ -1,20 +1,26 @@\n error: implementation of `Foo` is not general enough\n   --> $DIR/auto-trait-regions.rs:30:5\n    |\n+LL | auto trait Foo {}\n+   | ----------------- trait `Foo` defined here\n+...\n LL |     assert_foo(gen);\n-   |     ^^^^^^^^^^\n+   |     ^^^^^^^^^^ implementation of `Foo` is not general enough\n    |\n-   = note: `Foo` would have to be implemented for the type `&'0 OnlyFooIfStaticRef`, for any lifetime `'0`\n-   = note: but `Foo` is actually implemented for the type `&'1 OnlyFooIfStaticRef`, for some specific lifetime `'1`\n+   = note: `Foo` would have to be implemented for the type `&'0 OnlyFooIfStaticRef`, for any lifetime `'0`...\n+   = note: ...but `Foo` is actually implemented for the type `&'1 OnlyFooIfStaticRef`, for some specific lifetime `'1`\n \n error: implementation of `Foo` is not general enough\n   --> $DIR/auto-trait-regions.rs:48:5\n    |\n+LL | auto trait Foo {}\n+   | ----------------- trait `Foo` defined here\n+...\n LL |     assert_foo(gen);\n-   |     ^^^^^^^^^^\n+   |     ^^^^^^^^^^ implementation of `Foo` is not general enough\n    |\n-   = note: `Foo` would have to be implemented for the type `A<'0, '1>`, for any two lifetimes `'0` and `'1`\n-   = note: but `Foo` is actually implemented for the type `A<'_, '2>`, for some specific lifetime `'2`\n+   = note: `Foo` would have to be implemented for the type `A<'0, '1>`, for any two lifetimes `'0` and `'1`...\n+   = note: ...but `Foo` is actually implemented for the type `A<'_, '2>`, for some specific lifetime `'2`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "04e2ddd4a6090b122bbc0cfcc169fef7b5fa505a", "filename": "src/test/ui/hrtb/due-to-where-clause.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5670d048c0f88af9976b5505c7853b23dd06770d/src%2Ftest%2Fui%2Fhrtb%2Fdue-to-where-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5670d048c0f88af9976b5505c7853b23dd06770d/src%2Ftest%2Fui%2Fhrtb%2Fdue-to-where-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fdue-to-where-clause.rs?ref=5670d048c0f88af9976b5505c7853b23dd06770d", "patch": "@@ -0,0 +1,16 @@\n+// ignore-compare-mode-nll\n+// ^ This code works in nll mode.\n+\n+fn main() {\n+    test::<FooS>(&mut 42); //~ ERROR implementation of `Foo` is not general enough\n+}\n+\n+trait Foo<'a> {}\n+\n+struct FooS<'a> {\n+    data: &'a mut u32,\n+}\n+\n+impl<'a, 'b: 'a> Foo<'b> for FooS<'a> {}\n+\n+fn test<'a, F>(data: &'a mut u32) where F: for<'b> Foo<'b> {}"}, {"sha": "e698584bb716f8ccd7206dfc86216a91f5d235cc", "filename": "src/test/ui/hrtb/due-to-where-clause.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/5670d048c0f88af9976b5505c7853b23dd06770d/src%2Ftest%2Fui%2Fhrtb%2Fdue-to-where-clause.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5670d048c0f88af9976b5505c7853b23dd06770d/src%2Ftest%2Fui%2Fhrtb%2Fdue-to-where-clause.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fdue-to-where-clause.stderr?ref=5670d048c0f88af9976b5505c7853b23dd06770d", "patch": "@@ -0,0 +1,17 @@\n+error: implementation of `Foo` is not general enough\n+  --> $DIR/due-to-where-clause.rs:5:5\n+   |\n+LL |     test::<FooS>(&mut 42);\n+   |     ^^^^^^^^^^^^ doesn't satisfy where-clause\n+...\n+LL | trait Foo<'a> {}\n+   | ---------------- trait `Foo` defined here\n+...\n+LL | fn test<'a, F>(data: &'a mut u32) where F: for<'b> Foo<'b> {}\n+   | ------------------------------------------------------------- due to a where-clause on `test`...\n+   |\n+   = note: ...`FooS<'_>` must implement `Foo<'0>`, for any lifetime `'0`...\n+   = note: ...but `FooS<'_>` actually implements `Foo<'1>`, for some specific lifetime `'1`\n+\n+error: aborting due to previous error\n+"}, {"sha": "003f32659351f18744c964da3de373b30dbdcaf0", "filename": "src/test/ui/hrtb/hrtb-cache-issue-54302.stderr", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5670d048c0f88af9976b5505c7853b23dd06770d/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-cache-issue-54302.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5670d048c0f88af9976b5505c7853b23dd06770d/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-cache-issue-54302.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-cache-issue-54302.stderr?ref=5670d048c0f88af9976b5505c7853b23dd06770d", "patch": "@@ -1,11 +1,14 @@\n error: implementation of `Deserialize` is not general enough\n   --> $DIR/hrtb-cache-issue-54302.rs:19:5\n    |\n+LL | trait Deserialize<'de> {}\n+   | ------------------------- trait `Deserialize` defined here\n+...\n LL |     assert_deserialize_owned::<&'static str>();\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ implementation of `Deserialize` is not general enough\n    |\n-   = note: `&'static str` must implement `Deserialize<'0>`, for any lifetime `'0`\n-   = note: but `&str` actually implements `Deserialize<'1>`, for some specific lifetime `'1`\n+   = note: `&'static str` must implement `Deserialize<'0>`, for any lifetime `'0`...\n+   = note: ...but `&str` actually implements `Deserialize<'1>`, for some specific lifetime `'1`\n \n error: aborting due to previous error\n "}, {"sha": "c0e3fd3cf4679dc3d8d9b70943d1cfd8f2a7e1c1", "filename": "src/test/ui/hrtb/issue-30786.migrate.stderr", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5670d048c0f88af9976b5505c7853b23dd06770d/src%2Ftest%2Fui%2Fhrtb%2Fissue-30786.migrate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5670d048c0f88af9976b5505c7853b23dd06770d/src%2Ftest%2Fui%2Fhrtb%2Fissue-30786.migrate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fissue-30786.migrate.stderr?ref=5670d048c0f88af9976b5505c7853b23dd06770d", "patch": "@@ -1,11 +1,17 @@\n error: implementation of `Stream` is not general enough\n   --> $DIR/issue-30786.rs:108:22\n    |\n-LL |     let map = source.map(|x: &_| x);\n-   |                      ^^^\n+LL | / pub trait Stream {\n+LL | |     type Item;\n+LL | |     fn next(self) -> Option<Self::Item>;\n+LL | | }\n+   | |_- trait `Stream` defined here\n+...\n+LL |       let map = source.map(|x: &_| x);\n+   |                        ^^^ implementation of `Stream` is not general enough\n    |\n-   = note: `Stream` would have to be implemented for the type `&'0 mut Map<Repeat, [closure@$DIR/issue-30786.rs:108:26: 108:35]>`, for any lifetime `'0`\n-   = note: but `Stream` is actually implemented for the type `&'1 mut Map<Repeat, [closure@$DIR/issue-30786.rs:108:26: 108:35]>`, for some specific lifetime `'1`\n+   = note: `Stream` would have to be implemented for the type `&'0 mut Map<Repeat, [closure@$DIR/issue-30786.rs:108:26: 108:35]>`, for any lifetime `'0`...\n+   = note: ...but `Stream` is actually implemented for the type `&'1 mut Map<Repeat, [closure@$DIR/issue-30786.rs:108:26: 108:35]>`, for some specific lifetime `'1`\n \n error: aborting due to previous error\n "}, {"sha": "1cfd93e59d935695838738acc3f0e345c51d9dea", "filename": "src/test/ui/hrtb/issue-30786.nll.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5670d048c0f88af9976b5505c7853b23dd06770d/src%2Ftest%2Fui%2Fhrtb%2Fissue-30786.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5670d048c0f88af9976b5505c7853b23dd06770d/src%2Ftest%2Fui%2Fhrtb%2Fissue-30786.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fissue-30786.nll.stderr?ref=5670d048c0f88af9976b5505c7853b23dd06770d", "patch": "@@ -1,11 +1,11 @@\n error: higher-ranked subtype error\n-  --> $DIR/issue-30786.rs:112:18\n+  --> $DIR/issue-30786.rs:113:18\n    |\n LL |     let filter = map.filter(|x: &_| true);\n    |                  ^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: higher-ranked subtype error\n-  --> $DIR/issue-30786.rs:114:17\n+  --> $DIR/issue-30786.rs:115:17\n    |\n LL |     let count = filter.count(); // Assert that we still have a valid stream.\n    |                 ^^^^^^^^^^^^^^"}, {"sha": "c42297ca68346a37191cc687aa8987d7d7c01a2f", "filename": "src/test/ui/hrtb/issue-30786.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5670d048c0f88af9976b5505c7853b23dd06770d/src%2Ftest%2Fui%2Fhrtb%2Fissue-30786.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5670d048c0f88af9976b5505c7853b23dd06770d/src%2Ftest%2Fui%2Fhrtb%2Fissue-30786.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fissue-30786.rs?ref=5670d048c0f88af9976b5505c7853b23dd06770d", "patch": "@@ -16,7 +16,7 @@\n \n //[nll]compile-flags: -Z borrowck=mir\n \n-pub trait Stream {\n+pub trait Stream { //[migrate]~ NOTE trait `Stream` defined here\n     type Item;\n     fn next(self) -> Option<Self::Item>;\n }\n@@ -109,6 +109,7 @@ fn main() {\n     //[migrate]~^ ERROR implementation of `Stream` is not general enough\n     //[migrate]~| NOTE  `Stream` would have to be implemented for the type `&'0 mut Map\n     //[migrate]~| NOTE  but `Stream` is actually implemented for the type `&'1\n+    //[migrate]~| NOTE  implementation of `Stream` is not general enough\n     let filter = map.filter(|x: &_| true);\n     //[nll]~^ ERROR higher-ranked subtype error\n     let count = filter.count(); // Assert that we still have a valid stream."}, {"sha": "3ed27791643017ea2686427fb9b58f8dfd6f114a", "filename": "src/test/ui/issues/issue-54302-cases.stderr", "status": "modified", "additions": 37, "deletions": 17, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/5670d048c0f88af9976b5505c7853b23dd06770d/src%2Ftest%2Fui%2Fissues%2Fissue-54302-cases.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5670d048c0f88af9976b5505c7853b23dd06770d/src%2Ftest%2Fui%2Fissues%2Fissue-54302-cases.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-54302-cases.stderr?ref=5670d048c0f88af9976b5505c7853b23dd06770d", "patch": "@@ -1,38 +1,58 @@\n error: implementation of `Foo` is not general enough\n   --> $DIR/issue-54302-cases.rs:63:5\n    |\n-LL |     <u32 as RefFoo<u32>>::ref_foo(a)\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: `Foo<'static, u32>` would have to be implemented for the type `&'0 u32`, for any lifetime `'0`\n-   = note: but `Foo<'_, u32>` is actually implemented for the type `&'1 u32`, for some specific lifetime `'1`\n+LL | / trait Foo<'x, T> {\n+LL | |     fn foo(self) -> &'x T;\n+LL | | }\n+   | |_- trait `Foo` defined here\n+...\n+LL |       <u32 as RefFoo<u32>>::ref_foo(a)\n+   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ implementation of `Foo` is not general enough\n+   |\n+   = note: `Foo<'static, u32>` would have to be implemented for the type `&'0 u32`, for any lifetime `'0`...\n+   = note: ...but `Foo<'_, u32>` is actually implemented for the type `&'1 u32`, for some specific lifetime `'1`\n \n error: implementation of `Foo` is not general enough\n   --> $DIR/issue-54302-cases.rs:69:5\n    |\n-LL |     <i32 as RefFoo<i32>>::ref_foo(a)\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | / trait Foo<'x, T> {\n+LL | |     fn foo(self) -> &'x T;\n+LL | | }\n+   | |_- trait `Foo` defined here\n+...\n+LL |       <i32 as RefFoo<i32>>::ref_foo(a)\n+   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ implementation of `Foo` is not general enough\n    |\n-   = note: `Foo<'static, i32>` would have to be implemented for the type `&'0 i32`, for any lifetime `'0`\n-   = note: but `Foo<'_, i32>` is actually implemented for the type `&'1 i32`, for some specific lifetime `'1`\n+   = note: `Foo<'static, i32>` would have to be implemented for the type `&'0 i32`, for any lifetime `'0`...\n+   = note: ...but `Foo<'_, i32>` is actually implemented for the type `&'1 i32`, for some specific lifetime `'1`\n \n error: implementation of `Foo` is not general enough\n   --> $DIR/issue-54302-cases.rs:75:5\n    |\n-LL |     <u64 as RefFoo<u64>>::ref_foo(a)\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | / trait Foo<'x, T> {\n+LL | |     fn foo(self) -> &'x T;\n+LL | | }\n+   | |_- trait `Foo` defined here\n+...\n+LL |       <u64 as RefFoo<u64>>::ref_foo(a)\n+   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ implementation of `Foo` is not general enough\n    |\n-   = note: `Foo<'static, u64>` would have to be implemented for the type `&'0 u64`, for any lifetime `'0`\n-   = note: but `Foo<'_, u64>` is actually implemented for the type `&'1 u64`, for some specific lifetime `'1`\n+   = note: `Foo<'static, u64>` would have to be implemented for the type `&'0 u64`, for any lifetime `'0`...\n+   = note: ...but `Foo<'_, u64>` is actually implemented for the type `&'1 u64`, for some specific lifetime `'1`\n \n error: implementation of `Foo` is not general enough\n   --> $DIR/issue-54302-cases.rs:81:5\n    |\n-LL |     <i64 as RefFoo<i64>>::ref_foo(a)\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | / trait Foo<'x, T> {\n+LL | |     fn foo(self) -> &'x T;\n+LL | | }\n+   | |_- trait `Foo` defined here\n+...\n+LL |       <i64 as RefFoo<i64>>::ref_foo(a)\n+   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ implementation of `Foo` is not general enough\n    |\n-   = note: `Foo<'static, i64>` would have to be implemented for the type `&'0 i64`, for any lifetime `'0`\n-   = note: but `Foo<'_, i64>` is actually implemented for the type `&'1 i64`, for some specific lifetime `'1`\n+   = note: `Foo<'static, i64>` would have to be implemented for the type `&'0 i64`, for any lifetime `'0`...\n+   = note: ...but `Foo<'_, i64>` is actually implemented for the type `&'1 i64`, for some specific lifetime `'1`\n \n error: aborting due to 4 previous errors\n "}, {"sha": "1b3f57ba188a3d03da8b3145d7bb32ee0b5d514b", "filename": "src/test/ui/issues/issue-54302.stderr", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5670d048c0f88af9976b5505c7853b23dd06770d/src%2Ftest%2Fui%2Fissues%2Fissue-54302.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5670d048c0f88af9976b5505c7853b23dd06770d/src%2Ftest%2Fui%2Fissues%2Fissue-54302.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-54302.stderr?ref=5670d048c0f88af9976b5505c7853b23dd06770d", "patch": "@@ -1,11 +1,14 @@\n error: implementation of `Deserialize` is not general enough\n   --> $DIR/issue-54302.rs:13:5\n    |\n+LL | trait Deserialize<'de> {}\n+   | ------------------------- trait `Deserialize` defined here\n+...\n LL |     assert_deserialize_owned::<&'static str>();\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ implementation of `Deserialize` is not general enough\n    |\n-   = note: `&'static str` must implement `Deserialize<'0>`, for any lifetime `'0`\n-   = note: but `&str` actually implements `Deserialize<'1>`, for some specific lifetime `'1`\n+   = note: `&'static str` must implement `Deserialize<'0>`, for any lifetime `'0`...\n+   = note: ...but `&str` actually implements `Deserialize<'1>`, for some specific lifetime `'1`\n \n error: aborting due to previous error\n "}, {"sha": "f44c842187cc211ea163bc701ac263a9aff21145", "filename": "src/test/ui/issues/issue-55731.stderr", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5670d048c0f88af9976b5505c7853b23dd06770d/src%2Ftest%2Fui%2Fissues%2Fissue-55731.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5670d048c0f88af9976b5505c7853b23dd06770d/src%2Ftest%2Fui%2Fissues%2Fissue-55731.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-55731.stderr?ref=5670d048c0f88af9976b5505c7853b23dd06770d", "patch": "@@ -1,11 +1,16 @@\n error: implementation of `DistributedIteratorMulti` is not general enough\n   --> $DIR/issue-55731.rs:48:5\n    |\n-LL |     multi(Map {\n-   |     ^^^^^\n+LL | / trait DistributedIteratorMulti<Source> {\n+LL | |     type Item;\n+LL | | }\n+   | |_- trait `DistributedIteratorMulti` defined here\n+...\n+LL |       multi(Map {\n+   |       ^^^^^ implementation of `DistributedIteratorMulti` is not general enough\n    |\n-   = note: `DistributedIteratorMulti<&'0 ()>` would have to be implemented for the type `Cloned<&()>`, for any lifetime `'0`\n-   = note: but `DistributedIteratorMulti<&'1 ()>` is actually implemented for the type `Cloned<&'1 ()>`, for some specific lifetime `'1`\n+   = note: `DistributedIteratorMulti<&'0 ()>` would have to be implemented for the type `Cloned<&()>`, for any lifetime `'0`...\n+   = note: ...but `DistributedIteratorMulti<&'1 ()>` is actually implemented for the type `Cloned<&'1 ()>`, for some specific lifetime `'1`\n \n error: aborting due to previous error\n "}, {"sha": "2ed4d6d4401aa194c4b1e2f6b5731dc479a25cf9", "filename": "src/test/ui/lifetimes/lifetime-errors/ex3-both-anon-regions-3.nll.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5670d048c0f88af9976b5505c7853b23dd06770d/src%2Ftest%2Fui%2Flifetimes%2Flifetime-errors%2Fex3-both-anon-regions-3.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5670d048c0f88af9976b5505c7853b23dd06770d/src%2Ftest%2Fui%2Flifetimes%2Flifetime-errors%2Fex3-both-anon-regions-3.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetimes%2Flifetime-errors%2Fex3-both-anon-regions-3.nll.stderr?ref=5670d048c0f88af9976b5505c7853b23dd06770d", "patch": "@@ -12,11 +12,11 @@ error: lifetime may not live long enough\n   --> $DIR/ex3-both-anon-regions-3.rs:2:5\n    |\n LL | fn foo(z: &mut Vec<(&u8,&u8)>, (x, y): (&u8, &u8)) {\n-   |                         -                    - let's call the lifetime of this reference `'1`\n+   |                         -                    - let's call the lifetime of this reference `'3`\n    |                         |\n-   |                         let's call the lifetime of this reference `'2`\n+   |                         let's call the lifetime of this reference `'4`\n LL |     z.push((x,y));\n-   |     ^^^^^^^^^^^^^ argument requires that `'1` must outlive `'2`\n+   |     ^^^^^^^^^^^^^ argument requires that `'3` must outlive `'4`\n \n error: aborting due to 2 previous errors\n "}]}