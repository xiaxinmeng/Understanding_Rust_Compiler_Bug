{"sha": "cc5fcfce89312042e52401eb883160ebf289235f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNjNWZjZmNlODkzMTIwNDJlNTI0MDFlYjg4MzE2MGViZjI4OTIzNWY=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-08-18T00:20:36Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-08-18T00:24:57Z"}, "message": "rt: Use obstacks in lieu of dynamically-sized frames", "tree": {"sha": "7104cd42961f3ec376231814fbe45f4396a49a5e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7104cd42961f3ec376231814fbe45f4396a49a5e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cc5fcfce89312042e52401eb883160ebf289235f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cc5fcfce89312042e52401eb883160ebf289235f", "html_url": "https://github.com/rust-lang/rust/commit/cc5fcfce89312042e52401eb883160ebf289235f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cc5fcfce89312042e52401eb883160ebf289235f/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3ab21e5ee082ff1cc535f23d1be5f153cb80a985", "url": "https://api.github.com/repos/rust-lang/rust/commits/3ab21e5ee082ff1cc535f23d1be5f153cb80a985", "html_url": "https://github.com/rust-lang/rust/commit/3ab21e5ee082ff1cc535f23d1be5f153cb80a985"}], "stats": {"total": 109, "additions": 69, "deletions": 40}, "files": [{"sha": "8959c96343d4feba9a6863bc29b4610d2b002986", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 22, "deletions": 19, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/cc5fcfce89312042e52401eb883160ebf289235f/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc5fcfce89312042e52401eb883160ebf289235f/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=cc5fcfce89312042e52401eb883160ebf289235f", "patch": "@@ -466,17 +466,20 @@ fn alloca(cx: &@block_ctxt, t: TypeRef) -> ValueRef {\n }\n \n fn array_alloca(cx: &@block_ctxt, t: TypeRef, n: ValueRef) -> ValueRef {\n+    let bcx = cx;\n     let builder = new_builder(cx.fcx.lldynamicallocas);\n-    alt bcx_fcx(cx).llobstacktoken {\n-        none. {\n-            let dynastack_mark = bcx_ccx(cx).upcalls.dynastack_mark;\n-            let lltaskptr = bcx_fcx(cx).lltaskptr;\n-            bcx_fcx(cx).llobstacktoken =\n-                some(builder.Call(dynastack_mark, ~[lltaskptr]));\n-        }\n-        some(_) { /* no-op */ }\n-    }\n-    ret builder.ArrayAlloca(t, n);\n+    let lltaskptr = bcx_fcx(bcx).lltaskptr;\n+\n+    let dynastack_alloc = bcx_ccx(bcx).upcalls.dynastack_alloc;\n+    let llsz = builder.Mul(C_uint(llsize_of_real(bcx_ccx(bcx), t)), n);\n+    let llresult = builder.Call(dynastack_alloc, ~[lltaskptr, llsz]);\n+    ret builder.PointerCast(llresult, T_ptr(t));\n+}\n+\n+fn mk_obstack_token(ccx: &@crate_ctxt, lldynamicallocas: BasicBlockRef,\n+                    lltaskptr: ValueRef) -> ValueRef {\n+    let builder = new_builder(lldynamicallocas);\n+    ret builder.Call(ccx.upcalls.dynastack_mark, ~[lltaskptr]);\n }\n \n \n@@ -4407,6 +4410,8 @@ fn trans_bind_thunk(cx: &@local_ctxt, sp: &span, incoming_fty: &ty::t,\n     lltargetfn = bcx.build.PointerCast(lltargetfn, T_ptr(T_ptr(lltargetty)));\n     lltargetfn = bcx.build.Load(lltargetfn);\n     llvm::LLVMSetTailCall(bcx.build.FastCall(lltargetfn, llargs), 1);\n+\n+    bcx = trans_fn_cleanups(bcx);   // TODO: Might break tail call.\n     bcx.build.RetVoid();\n     finish_fn(fcx, lltop);\n     ret {val: llthunk, ty: llthunk_ty};\n@@ -5611,14 +5616,8 @@ fn trans_block_cleanups(cx: &@block_ctxt, cleanup_cx: &@block_ctxt) ->\n }\n \n fn trans_fn_cleanups(bcx: &@block_ctxt) -> @block_ctxt {\n-    alt bcx_fcx(bcx).llobstacktoken {\n-        some(lltoken_) {\n-            let lltoken = lltoken_; // satisfy alias checker\n-            bcx.build.Call(bcx_ccx(bcx).upcalls.dynastack_free,\n-                           ~[bcx_fcx(bcx).lltaskptr, lltoken]);\n-        }\n-        none. { /* nothing to do */ }\n-    }\n+    bcx.build.Call(bcx_ccx(bcx).upcalls.dynastack_free,\n+                   ~[bcx_fcx(bcx).lltaskptr, bcx_fcx(bcx).llobstacktoken]);\n     ret bcx;\n }\n \n@@ -5807,6 +5806,7 @@ fn new_fn_ctxt_w_id(cx: @local_ctxt, sp: &span, llfndecl: ValueRef,\n     let derived_tydescs =\n         map::mk_hashmap::<ty::t, derived_tydesc_info>(ty::hash_ty, ty::eq_ty);\n     let llbbs = mk_standard_basic_blocks(llfndecl);\n+    let llobstacktoken = mk_obstack_token(cx.ccx, llbbs.da, lltaskptr);\n     ret @{llfn: llfndecl,\n           lltaskptr: lltaskptr,\n           llenv: llenv,\n@@ -5816,7 +5816,7 @@ fn new_fn_ctxt_w_id(cx: @local_ctxt, sp: &span, llfndecl: ValueRef,\n           mutable llderivedtydescs_first: llbbs.dt,\n           mutable llderivedtydescs: llbbs.dt,\n           mutable lldynamicallocas: llbbs.da,\n-          mutable llobstacktoken: none::<ValueRef>,\n+          mutable llobstacktoken: llobstacktoken,\n           mutable llself: none::<val_self_pair>,\n           mutable lliterbody: none::<ValueRef>,\n           mutable iterbodyty: none::<ty::t>,\n@@ -6137,6 +6137,7 @@ fn trans_res_ctor(cx: @local_ctxt, sp: &span, dtor: &ast::_fn,\n     let flag = GEP_tup_like(bcx, tup_t, llretptr, ~[0, 0]);\n     bcx = flag.bcx;\n     bcx.build.Store(C_int(1), flag.val);\n+    bcx = trans_fn_cleanups(bcx);\n     bcx.build.RetVoid();\n     finish_fn(fcx, lltop);\n }\n@@ -6433,6 +6434,7 @@ fn create_main_wrapper(ccx: &@crate_ctxt, sp: &span,\n             };\n             bcx.build.FastCall(main_llfn, args);\n         }\n+        bcx = trans_fn_cleanups(bcx);\n         bcx.build.RetVoid();\n \n         let lltop = bcx.llbb;\n@@ -6754,6 +6756,7 @@ fn decl_native_fn_and_pair(ccx: &@crate_ctxt, sp: &span, path: &[str],\n     for d: {val: ValueRef, ty: ty::t} in drop_args {\n         bcx = drop_ty(bcx, d.val, d.ty).bcx;\n     }\n+    bcx = trans_fn_cleanups(bcx);\n     bcx.build.RetVoid();\n     finish_fn(fcx, lltop);\n }"}, {"sha": "1ddefcc73ed8b579de29f1d09b7ee6a8c9a3716c", "filename": "src/comp/middle/trans_common.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cc5fcfce89312042e52401eb883160ebf289235f/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc5fcfce89312042e52401eb883160ebf289235f/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_common.rs?ref=cc5fcfce89312042e52401eb883160ebf289235f", "patch": "@@ -215,8 +215,7 @@ type fn_ctxt = {\n     mutable lldynamicallocas: BasicBlockRef,\n \n     // The token used to clear the dynamic allocas at the end of this frame.\n-    // Will be |none| if there are no dynamic allocas.\n-    mutable llobstacktoken: option::t<ValueRef>,\n+    mutable llobstacktoken: ValueRef,\n \n     // The 'self' object currently in use in this function, if there\n     // is one."}, {"sha": "8d75c78348953c1d46ba9e98bfa1ea8a8c5cdc81", "filename": "src/comp/middle/trans_objects.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc5fcfce89312042e52401eb883160ebf289235f/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc5fcfce89312042e52401eb883160ebf289235f/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs?ref=cc5fcfce89312042e52401eb883160ebf289235f", "patch": "@@ -192,6 +192,8 @@ fn trans_obj(cx: @local_ctxt, sp: &span, ob: &ast::_obj,\n         let p = bcx.build.PointerCast(box.box, llbox_ty);\n         bcx.build.Store(p, pair_box);\n     }\n+\n+    bcx = trans_fn_cleanups(bcx);\n     bcx.build.RetVoid();\n \n     // Insert the mandatory first few basic blocks before lltop.\n@@ -710,6 +712,7 @@ fn process_bkwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n     // And, finally, call the outer method.\n     bcx.build.FastCall(llouter_mthd, llouter_mthd_args);\n \n+    bcx = trans_fn_cleanups(bcx);\n     bcx.build.RetVoid();\n     finish_fn(fcx, lltop);\n \n@@ -882,6 +885,7 @@ fn process_fwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n     // And, finally, call the original (inner) method.\n     bcx.build.FastCall(llorig_mthd, llorig_mthd_args);\n \n+    bcx = trans_fn_cleanups(bcx);\n     bcx.build.RetVoid();\n     finish_fn(fcx, lltop);\n "}, {"sha": "f76a80aada9851de4967a9d66d57a667d4256e19", "filename": "src/rt/rust_obstack.cpp", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/cc5fcfce89312042e52401eb883160ebf289235f/src%2Frt%2Frust_obstack.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/cc5fcfce89312042e52401eb883160ebf289235f/src%2Frt%2Frust_obstack.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_obstack.cpp?ref=cc5fcfce89312042e52401eb883160ebf289235f", "patch": "@@ -14,7 +14,12 @@\n #undef max\n #endif\n \n-const size_t DEFAULT_CHUNK_SIZE = 4096;\n+//#define DPRINT(fmt,...)     fprintf(stderr, fmt, ##__VA_ARGS__)\n+#define DPRINT(fmt,...)\n+\n+//const size_t DEFAULT_CHUNK_SIZE = 4096;\n+const size_t DEFAULT_CHUNK_SIZE = 300000;\n+const size_t DEFAULT_ALIGNMENT = 16;\n \n struct rust_obstack_chunk {\n     rust_obstack_chunk *prev;\n@@ -32,8 +37,13 @@ struct rust_obstack_chunk {\n \n void *\n rust_obstack_chunk::alloc(size_t len) {\n-    if (len > size - alen)\n+    alen = align_to(alen, DEFAULT_ALIGNMENT);\n+\n+    if (len > size - alen) {\n+        DPRINT(\"Not enough space, len=%lu!\\n\", len);\n+        assert(0);\n         return NULL;    // Not enough space.\n+    }\n     void *result = data + alen;\n     alen += len;\n     return result;\n@@ -42,7 +52,7 @@ rust_obstack_chunk::alloc(size_t len) {\n bool\n rust_obstack_chunk::free(void *ptr) {\n     uint8_t *p = (uint8_t *)ptr;\n-    if (p < data || p >= data + size)\n+    if (p < data || p > data + size)\n         return false;\n     assert(p <= data + alen);\n     alen = (size_t)(p - data);\n@@ -54,6 +64,7 @@ void *\n rust_obstack::alloc_new(size_t len) {\n     size_t chunk_size = std::max(len, DEFAULT_CHUNK_SIZE);\n     void *ptr = task->malloc(sizeof(chunk) + chunk_size, \"obstack\");\n+    DPRINT(\"making new chunk at %p, len %lu\\n\", ptr, chunk_size);\n     chunk = new(ptr) rust_obstack_chunk(chunk, chunk_size);\n     return chunk->alloc(len);\n }\n@@ -70,8 +81,12 @@ void *\n rust_obstack::alloc(size_t len) {\n     if (!chunk)\n         return alloc_new(len);\n+\n+    DPRINT(\"alloc sz %u\", (uint32_t)len);\n+\n     void *ptr = chunk->alloc(len);\n     ptr = ptr ? ptr : alloc_new(len);\n+\n     return ptr;\n }\n \n@@ -80,8 +95,11 @@ rust_obstack::free(void *ptr) {\n     if (!ptr)\n         return;\n \n+    DPRINT(\"free ptr %p\\n\", ptr);\n+\n     assert(chunk);\n     while (!chunk->free(ptr)) {\n+        DPRINT(\"deleting chunk at %p\\n\", chunk);\n         rust_obstack_chunk *prev = chunk->prev;\n         task->free(chunk);\n         chunk = prev;"}, {"sha": "e5b96e7e91f7f5ef442f35038bf637ac084cc323", "filename": "src/rt/rust_shape.cpp", "status": "modified", "additions": 10, "deletions": 15, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/cc5fcfce89312042e52401eb883160ebf289235f/src%2Frt%2Frust_shape.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/cc5fcfce89312042e52401eb883160ebf289235f/src%2Frt%2Frust_shape.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_shape.cpp?ref=cc5fcfce89312042e52401eb883160ebf289235f", "patch": "@@ -64,18 +64,6 @@ const uint8_t CMP_LT = 1u;\n const uint8_t CMP_LE = 2u;\n \n \n-// Utility functions\n-\n-// Rounds |size| to the nearest |alignment|. Invariant: |alignment| is a power\n-// of two.\n-template<typename T>\n-static inline T\n-align_to(T size, size_t alignment) {\n-    assert(alignment);\n-    T x = (T)(((uintptr_t)size + alignment - 1) & ~(alignment - 1));\n-    return x;\n-}\n-\n // Utility classes\n \n struct size_align {\n@@ -185,11 +173,18 @@ class ptr_pair {\n     }\n };\n \n-inline ptr_pair\n-align_to(const ptr_pair &pair, size_t n) {\n-    return ptr_pair::make(align_to(pair.fst, n), align_to(pair.snd, n));\n+}   // end namespace shape\n+\n+\n+inline shape::ptr_pair\n+align_to(const shape::ptr_pair &pair, size_t n) {\n+    return shape::ptr_pair::make(align_to(pair.fst, n),\n+                                 align_to(pair.snd, n));\n }\n \n+\n+namespace shape {\n+\n // NB: This function does not align.\n template<typename T>\n inline data_pair<T>"}, {"sha": "ac99f501f25ae6eacebf5d2c1e2308c1f361cc74", "filename": "src/rt/rust_upcall.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc5fcfce89312042e52401eb883160ebf289235f/src%2Frt%2Frust_upcall.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/cc5fcfce89312042e52401eb883160ebf289235f/src%2Frt%2Frust_upcall.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_upcall.cpp?ref=cc5fcfce89312042e52401eb883160ebf289235f", "patch": "@@ -430,7 +430,7 @@ upcall_dynastack_mark(rust_task *task) {\n /** Allocates space in the dynamic stack and returns it. */\n extern \"C\" CDECL void *\n upcall_dynastack_alloc(rust_task *task, size_t sz) {\n-    return task->dynastack.alloc(sz);\n+    return sz ? task->dynastack.alloc(sz) : NULL;\n }\n \n /** Frees space in the dynamic stack. */"}, {"sha": "401c39413b6590960e870661b4d545050efea47c", "filename": "src/rt/rust_util.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cc5fcfce89312042e52401eb883160ebf289235f/src%2Frt%2Frust_util.h", "raw_url": "https://github.com/rust-lang/rust/raw/cc5fcfce89312042e52401eb883160ebf289235f/src%2Frt%2Frust_util.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_util.h?ref=cc5fcfce89312042e52401eb883160ebf289235f", "patch": "@@ -125,6 +125,16 @@ next_power_of_two(size_t s)\n     return tmp + 1;\n }\n \n+// Rounds |size| to the nearest |alignment|. Invariant: |alignment| is a power\n+// of two.\n+template<typename T>\n+static inline T\n+align_to(T size, size_t alignment) {\n+    assert(alignment);\n+    T x = (T)(((uintptr_t)size + alignment - 1) & ~(alignment - 1));\n+    return x;\n+}\n+\n // Initialization helper for ISAAC RNG\n \n template <typename sched_or_kernel>"}]}