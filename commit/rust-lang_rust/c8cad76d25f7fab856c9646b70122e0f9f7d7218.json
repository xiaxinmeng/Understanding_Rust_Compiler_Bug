{"sha": "c8cad76d25f7fab856c9646b70122e0f9f7d7218", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM4Y2FkNzZkMjVmN2ZhYjg1NmM5NjQ2YjcwMTIyZTBmOWY3ZDcyMTg=", "commit": {"author": {"name": "Kirill Bulatov", "email": "mail4score@gmail.com", "date": "2020-08-10T21:55:57Z"}, "committer": {"name": "Kirill Bulatov", "email": "mail4score@gmail.com", "date": "2020-08-11T12:09:08Z"}, "message": "Improve the ide diagnostics trait API", "tree": {"sha": "67091cef7037bbde1fc0d2da599562775a954f49", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/67091cef7037bbde1fc0d2da599562775a954f49"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c8cad76d25f7fab856c9646b70122e0f9f7d7218", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c8cad76d25f7fab856c9646b70122e0f9f7d7218", "html_url": "https://github.com/rust-lang/rust/commit/c8cad76d25f7fab856c9646b70122e0f9f7d7218", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c8cad76d25f7fab856c9646b70122e0f9f7d7218/comments", "author": {"login": "SomeoneToIgnore", "id": 2690773, "node_id": "MDQ6VXNlcjI2OTA3NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/2690773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SomeoneToIgnore", "html_url": "https://github.com/SomeoneToIgnore", "followers_url": "https://api.github.com/users/SomeoneToIgnore/followers", "following_url": "https://api.github.com/users/SomeoneToIgnore/following{/other_user}", "gists_url": "https://api.github.com/users/SomeoneToIgnore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SomeoneToIgnore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SomeoneToIgnore/subscriptions", "organizations_url": "https://api.github.com/users/SomeoneToIgnore/orgs", "repos_url": "https://api.github.com/users/SomeoneToIgnore/repos", "events_url": "https://api.github.com/users/SomeoneToIgnore/events{/privacy}", "received_events_url": "https://api.github.com/users/SomeoneToIgnore/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SomeoneToIgnore", "id": 2690773, "node_id": "MDQ6VXNlcjI2OTA3NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/2690773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SomeoneToIgnore", "html_url": "https://github.com/SomeoneToIgnore", "followers_url": "https://api.github.com/users/SomeoneToIgnore/followers", "following_url": "https://api.github.com/users/SomeoneToIgnore/following{/other_user}", "gists_url": "https://api.github.com/users/SomeoneToIgnore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SomeoneToIgnore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SomeoneToIgnore/subscriptions", "organizations_url": "https://api.github.com/users/SomeoneToIgnore/orgs", "repos_url": "https://api.github.com/users/SomeoneToIgnore/repos", "events_url": "https://api.github.com/users/SomeoneToIgnore/events{/privacy}", "received_events_url": "https://api.github.com/users/SomeoneToIgnore/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "29fbc8e02180aac1f4d7819a9626206aa64028a0", "url": "https://api.github.com/repos/rust-lang/rust/commits/29fbc8e02180aac1f4d7819a9626206aa64028a0", "html_url": "https://github.com/rust-lang/rust/commit/29fbc8e02180aac1f4d7819a9626206aa64028a0"}], "stats": {"total": 363, "additions": 166, "deletions": 197}, "files": [{"sha": "2dfe69039fb72a325130a5df12b2c7affee7ddfa", "filename": "crates/ra_hir/src/semantics.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c8cad76d25f7fab856c9646b70122e0f9f7d7218/crates%2Fra_hir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8cad76d25f7fab856c9646b70122e0f9f7d7218/crates%2Fra_hir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsemantics.rs?ref=c8cad76d25f7fab856c9646b70122e0f9f7d7218", "patch": "@@ -109,10 +109,6 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n         self.imp.parse(file_id)\n     }\n \n-    pub fn cache(&self, root_node: SyntaxNode, file_id: HirFileId) {\n-        self.imp.cache(root_node, file_id)\n-    }\n-\n     pub fn expand(&self, macro_call: &ast::MacroCall) -> Option<SyntaxNode> {\n         self.imp.expand(macro_call)\n     }\n@@ -377,6 +373,7 @@ impl<'db> SemanticsImpl<'db> {\n         let src = diagnostics.presentation();\n         let root = self.db.parse_or_expand(src.file_id).unwrap();\n         let node = src.value.to_node(&root);\n+        self.cache(root, src.file_id);\n         original_range(self.db, src.with_value(&node))\n     }\n "}, {"sha": "e58defa681e692a2eb6cee34bf9829b4b70903d3", "filename": "crates/ra_hir_expand/src/diagnostics.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c8cad76d25f7fab856c9646b70122e0f9f7d7218/crates%2Fra_hir_expand%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8cad76d25f7fab856c9646b70122e0f9f7d7218/crates%2Fra_hir_expand%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fdiagnostics.rs?ref=c8cad76d25f7fab856c9646b70122e0f9f7d7218", "patch": "@@ -72,9 +72,12 @@ impl<'a> DiagnosticSinkBuilder<'a> {\n         self\n     }\n \n-    pub fn on<D: Diagnostic, F: FnMut(&D) -> Option<()> + 'a>(mut self, mut cb: F) -> Self {\n+    pub fn on<D: Diagnostic, F: FnMut(&D) + 'a>(mut self, mut cb: F) -> Self {\n         let cb = move |diag: &dyn Diagnostic| match diag.as_any().downcast_ref::<D>() {\n-            Some(d) => cb(d).ok_or(()),\n+            Some(d) => {\n+                cb(d);\n+                Ok(())\n+            }\n             None => Err(()),\n         };\n         self.callbacks.push(Box::new(cb));"}, {"sha": "165ff5249c610221946f155d8e39dd769fb7b36f", "filename": "crates/ra_ide/src/diagnostics.rs", "status": "modified", "additions": 17, "deletions": 171, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/c8cad76d25f7fab856c9646b70122e0f9f7d7218/crates%2Fra_ide%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8cad76d25f7fab856c9646b70122e0f9f7d7218/crates%2Fra_ide%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fdiagnostics.rs?ref=c8cad76d25f7fab856c9646b70122e0f9f7d7218", "patch": "@@ -7,22 +7,20 @@\n use std::cell::RefCell;\n \n use hir::{\n-    db::AstDatabase,\n-    diagnostics::{Diagnostic as _, DiagnosticSinkBuilder},\n-    HasSource, HirDisplay, Semantics, VariantDef,\n+    diagnostics::{Diagnostic as HirDiagnostics, DiagnosticSinkBuilder},\n+    Semantics,\n };\n use itertools::Itertools;\n-use ra_db::{SourceDatabase, Upcast};\n+use ra_db::SourceDatabase;\n use ra_ide_db::RootDatabase;\n use ra_prof::profile;\n use ra_syntax::{\n-    algo,\n-    ast::{self, edit::IndentLevel, make, AstNode},\n+    ast::{self, AstNode},\n     SyntaxNode, TextRange, T,\n };\n use ra_text_edit::{TextEdit, TextEditBuilder};\n \n-use crate::{Diagnostic, FileId, FileSystemEdit, Fix, SourceFileEdit};\n+use crate::{Diagnostic, FileId, Fix, SourceFileEdit};\n \n mod diagnostics_with_fix;\n use diagnostics_with_fix::DiagnosticWithFix;\n@@ -58,96 +56,16 @@ pub(crate) fn diagnostics(\n     let res = RefCell::new(res);\n     let mut sink = DiagnosticSinkBuilder::new()\n         .on::<hir::diagnostics::UnresolvedModule, _>(|d| {\n-            let fix = Fix::new(\n-                \"Create module\",\n-                FileSystemEdit::CreateFile {\n-                    anchor: d.file.original_file(db),\n-                    dst: d.candidate.clone(),\n-                }\n-                .into(),\n-            );\n-            let fix = diagnostic_fix_source(&sema, d)\n-                .map(|unresolved_module| unresolved_module.syntax().text_range())\n-                .map(|fix_range| (fix, fix_range));\n-\n-            res.borrow_mut().push(Diagnostic {\n-                range: sema.diagnostics_presentation_range(d).range,\n-                message: d.message(),\n-                severity: Severity::Error,\n-                fix,\n-            });\n-            Some(())\n+            res.borrow_mut().push(diagnostic_with_fix(d, &sema));\n         })\n         .on::<hir::diagnostics::MissingFields, _>(|d| {\n-            // Note that although we could add a diagnostics to\n-            // fill the missing tuple field, e.g :\n-            // `struct A(usize);`\n-            // `let a = A { 0: () }`\n-            // but it is uncommon usage and it should not be encouraged.\n-            let fix = if d.missed_fields.iter().any(|it| it.as_tuple_index().is_some()) {\n-                None\n-            } else {\n-                diagnostic_fix_source(&sema, d)\n-                    .and_then(|record_expr| record_expr.record_expr_field_list())\n-                    .map(|old_field_list| {\n-                        let mut new_field_list = old_field_list.clone();\n-                        for f in d.missed_fields.iter() {\n-                            let field = make::record_expr_field(\n-                                make::name_ref(&f.to_string()),\n-                                Some(make::expr_unit()),\n-                            );\n-                            new_field_list = new_field_list.append_field(&field);\n-                        }\n-\n-                        let edit = {\n-                            let mut builder = TextEditBuilder::default();\n-                            algo::diff(&old_field_list.syntax(), &new_field_list.syntax())\n-                                .into_text_edit(&mut builder);\n-                            builder.finish()\n-                        };\n-                        (\n-                            Fix::new(\"Fill struct fields\", SourceFileEdit { file_id, edit }.into()),\n-                            sema.original_range(&old_field_list.syntax()).range,\n-                            // old_field_list.syntax().text_range(),\n-                        )\n-                    })\n-            };\n-\n-            res.borrow_mut().push(Diagnostic {\n-                range: sema.diagnostics_presentation_range(d).range,\n-                message: d.message(),\n-                severity: Severity::Error,\n-                fix,\n-            });\n-            Some(())\n+            res.borrow_mut().push(diagnostic_with_fix(d, &sema));\n         })\n         .on::<hir::diagnostics::MissingOkInTailExpr, _>(|d| {\n-            let fix = diagnostic_fix_source(&sema, d).map(|tail_expr| {\n-                let tail_expr_range = tail_expr.syntax().text_range();\n-                let edit =\n-                    TextEdit::replace(tail_expr_range, format!(\"Ok({})\", tail_expr.syntax()));\n-                let source_change = SourceFileEdit { file_id, edit }.into();\n-                (Fix::new(\"Wrap with ok\", source_change), tail_expr_range)\n-            });\n-\n-            res.borrow_mut().push(Diagnostic {\n-                range: sema.diagnostics_presentation_range(d).range,\n-                message: d.message(),\n-                severity: Severity::Error,\n-                fix,\n-            });\n-            Some(())\n+            res.borrow_mut().push(diagnostic_with_fix(d, &sema));\n         })\n         .on::<hir::diagnostics::NoSuchField, _>(|d| {\n-            res.borrow_mut().push(Diagnostic {\n-                range: sema.diagnostics_presentation_range(d).range,\n-                message: d.message(),\n-                severity: Severity::Error,\n-                fix: missing_struct_field_fix(&sema, file_id, d).and_then(|fix| {\n-                    Some((fix, diagnostic_fix_source(&sema, d)?.syntax().text_range()))\n-                }),\n-            });\n-            Some(())\n+            res.borrow_mut().push(diagnostic_with_fix(d, &sema));\n         })\n         // Only collect experimental diagnostics when they're enabled.\n         .filter(|diag| !diag.is_experimental() || enable_experimental)\n@@ -168,87 +86,15 @@ pub(crate) fn diagnostics(\n     res.into_inner()\n }\n \n-fn diagnostic_fix_source<T: DiagnosticWithFix + hir::diagnostics::Diagnostic>(\n+fn diagnostic_with_fix<D: HirDiagnostics + DiagnosticWithFix>(\n+    d: &D,\n     sema: &Semantics<RootDatabase>,\n-    d: &T,\n-) -> Option<<T as DiagnosticWithFix>::AST> {\n-    let file_id = d.presentation().file_id;\n-    let root = sema.db.parse_or_expand(file_id)?;\n-    sema.cache(root, file_id);\n-    d.fix_source(sema.db.upcast())\n-}\n-\n-fn missing_struct_field_fix(\n-    sema: &Semantics<RootDatabase>,\n-    usage_file_id: FileId,\n-    d: &hir::diagnostics::NoSuchField,\n-) -> Option<Fix> {\n-    let record_expr_field = diagnostic_fix_source(&sema, d)?;\n-\n-    let record_lit = ast::RecordExpr::cast(record_expr_field.syntax().parent()?.parent()?)?;\n-    let def_id = sema.resolve_variant(record_lit)?;\n-    let module;\n-    let def_file_id;\n-    let record_fields = match VariantDef::from(def_id) {\n-        VariantDef::Struct(s) => {\n-            module = s.module(sema.db);\n-            let source = s.source(sema.db);\n-            def_file_id = source.file_id;\n-            let fields = source.value.field_list()?;\n-            record_field_list(fields)?\n-        }\n-        VariantDef::Union(u) => {\n-            module = u.module(sema.db);\n-            let source = u.source(sema.db);\n-            def_file_id = source.file_id;\n-            source.value.record_field_list()?\n-        }\n-        VariantDef::EnumVariant(e) => {\n-            module = e.module(sema.db);\n-            let source = e.source(sema.db);\n-            def_file_id = source.file_id;\n-            let fields = source.value.field_list()?;\n-            record_field_list(fields)?\n-        }\n-    };\n-    let def_file_id = def_file_id.original_file(sema.db);\n-\n-    let new_field_type = sema.type_of_expr(&record_expr_field.expr()?)?;\n-    if new_field_type.is_unknown() {\n-        return None;\n-    }\n-    let new_field = make::record_field(\n-        record_expr_field.field_name()?,\n-        make::ty(&new_field_type.display_source_code(sema.db, module.into()).ok()?),\n-    );\n-\n-    let last_field = record_fields.fields().last()?;\n-    let last_field_syntax = last_field.syntax();\n-    let indent = IndentLevel::from_node(last_field_syntax);\n-\n-    let mut new_field = new_field.to_string();\n-    if usage_file_id != def_file_id {\n-        new_field = format!(\"pub(crate) {}\", new_field);\n-    }\n-    new_field = format!(\"\\n{}{}\", indent, new_field);\n-\n-    let needs_comma = !last_field_syntax.to_string().ends_with(',');\n-    if needs_comma {\n-        new_field = format!(\",{}\", new_field);\n-    }\n-\n-    let source_change = SourceFileEdit {\n-        file_id: def_file_id,\n-        edit: TextEdit::insert(last_field_syntax.text_range().end(), new_field),\n-    };\n-    let fix = Fix::new(\"Create field\", source_change.into());\n-    return Some(fix);\n-\n-    fn record_field_list(field_def_list: ast::FieldList) -> Option<ast::RecordFieldList> {\n-        match field_def_list {\n-            ast::FieldList::RecordFieldList(it) => Some(it),\n-            ast::FieldList::TupleFieldList(_) => None,\n-        }\n+) -> Diagnostic {\n+    Diagnostic {\n+        range: sema.diagnostics_presentation_range(d).range,\n+        message: d.message(),\n+        severity: Severity::Error,\n+        fix: d.fix(&sema),\n     }\n }\n "}, {"sha": "56d454ac61f496b7b9f6a3c5d32c2604360027c1", "filename": "crates/ra_ide/src/diagnostics/diagnostics_with_fix.rs", "status": "modified", "additions": 143, "deletions": 20, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/c8cad76d25f7fab856c9646b70122e0f9f7d7218/crates%2Fra_ide%2Fsrc%2Fdiagnostics%2Fdiagnostics_with_fix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8cad76d25f7fab856c9646b70122e0f9f7d7218/crates%2Fra_ide%2Fsrc%2Fdiagnostics%2Fdiagnostics_with_fix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fdiagnostics%2Fdiagnostics_with_fix.rs?ref=c8cad76d25f7fab856c9646b70122e0f9f7d7218", "patch": "@@ -1,46 +1,169 @@\n+use crate::Fix;\n+use ast::{edit::IndentLevel, make};\n use hir::{\n     db::AstDatabase,\n     diagnostics::{MissingFields, MissingOkInTailExpr, NoSuchField, UnresolvedModule},\n+    HasSource, HirDisplay, Semantics, VariantDef,\n };\n-use ra_syntax::ast;\n+use ra_db::FileId;\n+use ra_ide_db::{\n+    source_change::{FileSystemEdit, SourceFileEdit},\n+    RootDatabase,\n+};\n+use ra_syntax::{algo, ast, AstNode, TextRange};\n+use ra_text_edit::{TextEdit, TextEditBuilder};\n \n // TODO kb\n pub trait DiagnosticWithFix {\n-    type AST;\n-    fn fix_source(&self, db: &dyn AstDatabase) -> Option<Self::AST>;\n+    fn fix(&self, sema: &Semantics<RootDatabase>) -> Option<(Fix, TextRange)>;\n }\n \n impl DiagnosticWithFix for UnresolvedModule {\n-    type AST = ast::Module;\n-    fn fix_source(&self, db: &dyn AstDatabase) -> Option<Self::AST> {\n-        let root = db.parse_or_expand(self.file)?;\n-        Some(self.decl.to_node(&root))\n+    fn fix(&self, sema: &Semantics<RootDatabase>) -> Option<(Fix, TextRange)> {\n+        let fix = Fix::new(\n+            \"Create module\",\n+            FileSystemEdit::CreateFile {\n+                anchor: self.file.original_file(sema.db),\n+                dst: self.candidate.clone(),\n+            }\n+            .into(),\n+        );\n+\n+        let root = sema.db.parse_or_expand(self.file)?;\n+        let unresolved_module = self.decl.to_node(&root);\n+        Some((fix, unresolved_module.syntax().text_range()))\n     }\n }\n \n impl DiagnosticWithFix for NoSuchField {\n-    type AST = ast::RecordExprField;\n-\n-    fn fix_source(&self, db: &dyn AstDatabase) -> Option<Self::AST> {\n-        let root = db.parse_or_expand(self.file)?;\n-        Some(self.field.to_node(&root))\n+    fn fix(&self, sema: &Semantics<RootDatabase>) -> Option<(Fix, TextRange)> {\n+        let root = sema.db.parse_or_expand(self.file)?;\n+        let record_expr_field = self.field.to_node(&root);\n+        let fix =\n+            missing_struct_field_fix(&sema, self.file.original_file(sema.db), &record_expr_field)?;\n+        Some((fix, record_expr_field.syntax().text_range()))\n     }\n }\n \n impl DiagnosticWithFix for MissingFields {\n-    type AST = ast::RecordExpr;\n+    fn fix(&self, sema: &Semantics<RootDatabase>) -> Option<(Fix, TextRange)> {\n+        // Note that although we could add a diagnostics to\n+        // fill the missing tuple field, e.g :\n+        // `struct A(usize);`\n+        // `let a = A { 0: () }`\n+        // but it is uncommon usage and it should not be encouraged.\n+        if self.missed_fields.iter().any(|it| it.as_tuple_index().is_some()) {\n+            None\n+        } else {\n+            let root = sema.db.parse_or_expand(self.file)?;\n+            let old_field_list = self.field_list_parent.to_node(&root).record_expr_field_list()?;\n+            let mut new_field_list = old_field_list.clone();\n+            for f in self.missed_fields.iter() {\n+                let field = make::record_expr_field(\n+                    make::name_ref(&f.to_string()),\n+                    Some(make::expr_unit()),\n+                );\n+                new_field_list = new_field_list.append_field(&field);\n+            }\n \n-    fn fix_source(&self, db: &dyn AstDatabase) -> Option<Self::AST> {\n-        let root = db.parse_or_expand(self.file)?;\n-        Some(self.field_list_parent.to_node(&root))\n+            let edit = {\n+                let mut builder = TextEditBuilder::default();\n+                algo::diff(&old_field_list.syntax(), &new_field_list.syntax())\n+                    .into_text_edit(&mut builder);\n+                builder.finish()\n+            };\n+            Some((\n+                Fix::new(\n+                    \"Fill struct fields\",\n+                    SourceFileEdit { file_id: self.file.original_file(sema.db), edit }.into(),\n+                ),\n+                sema.original_range(&old_field_list.syntax()).range,\n+                // old_field_list.syntax().text_range(),\n+            ))\n+        }\n     }\n }\n \n impl DiagnosticWithFix for MissingOkInTailExpr {\n-    type AST = ast::Expr;\n+    fn fix(&self, sema: &Semantics<RootDatabase>) -> Option<(Fix, TextRange)> {\n+        let root = sema.db.parse_or_expand(self.file)?;\n+        let tail_expr = self.expr.to_node(&root);\n+        let tail_expr_range = tail_expr.syntax().text_range();\n+        let edit = TextEdit::replace(tail_expr_range, format!(\"Ok({})\", tail_expr.syntax()));\n+        let source_change =\n+            SourceFileEdit { file_id: self.file.original_file(sema.db), edit }.into();\n+        Some((Fix::new(\"Wrap with ok\", source_change), tail_expr_range))\n+    }\n+}\n+\n+fn missing_struct_field_fix(\n+    sema: &Semantics<RootDatabase>,\n+    usage_file_id: FileId,\n+    record_expr_field: &ast::RecordExprField,\n+) -> Option<Fix> {\n+    let record_lit = ast::RecordExpr::cast(record_expr_field.syntax().parent()?.parent()?)?;\n+    let def_id = sema.resolve_variant(record_lit)?;\n+    let module;\n+    let def_file_id;\n+    let record_fields = match VariantDef::from(def_id) {\n+        VariantDef::Struct(s) => {\n+            module = s.module(sema.db);\n+            let source = s.source(sema.db);\n+            def_file_id = source.file_id;\n+            let fields = source.value.field_list()?;\n+            record_field_list(fields)?\n+        }\n+        VariantDef::Union(u) => {\n+            module = u.module(sema.db);\n+            let source = u.source(sema.db);\n+            def_file_id = source.file_id;\n+            source.value.record_field_list()?\n+        }\n+        VariantDef::EnumVariant(e) => {\n+            module = e.module(sema.db);\n+            let source = e.source(sema.db);\n+            def_file_id = source.file_id;\n+            let fields = source.value.field_list()?;\n+            record_field_list(fields)?\n+        }\n+    };\n+    let def_file_id = def_file_id.original_file(sema.db);\n+\n+    let new_field_type = sema.type_of_expr(&record_expr_field.expr()?)?;\n+    if new_field_type.is_unknown() {\n+        return None;\n+    }\n+    let new_field = make::record_field(\n+        record_expr_field.field_name()?,\n+        make::ty(&new_field_type.display_source_code(sema.db, module.into()).ok()?),\n+    );\n+\n+    let last_field = record_fields.fields().last()?;\n+    let last_field_syntax = last_field.syntax();\n+    let indent = IndentLevel::from_node(last_field_syntax);\n+\n+    let mut new_field = new_field.to_string();\n+    if usage_file_id != def_file_id {\n+        new_field = format!(\"pub(crate) {}\", new_field);\n+    }\n+    new_field = format!(\"\\n{}{}\", indent, new_field);\n+\n+    let needs_comma = !last_field_syntax.to_string().ends_with(',');\n+    if needs_comma {\n+        new_field = format!(\",{}\", new_field);\n+    }\n+\n+    let source_change = SourceFileEdit {\n+        file_id: def_file_id,\n+        edit: TextEdit::insert(last_field_syntax.text_range().end(), new_field),\n+    };\n+    let fix = Fix::new(\"Create field\", source_change.into());\n+    return Some(fix);\n \n-    fn fix_source(&self, db: &dyn AstDatabase) -> Option<Self::AST> {\n-        let root = db.parse_or_expand(self.file)?;\n-        Some(self.expr.to_node(&root))\n+    fn record_field_list(field_def_list: ast::FieldList) -> Option<ast::RecordFieldList> {\n+        match field_def_list {\n+            ast::FieldList::RecordFieldList(it) => Some(it),\n+            ast::FieldList::TupleFieldList(_) => None,\n+        }\n     }\n }"}]}