{"sha": "af3bd22783e11520554d60df7f6fe4f5aab54748", "node_id": "C_kwDOAAsO6NoAKGFmM2JkMjI3ODNlMTE1MjA1NTRkNjBkZjdmNmZlNGY1YWFiNTQ3NDg", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2023-03-22T18:30:33Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-03-22T18:30:33Z"}, "message": "Rollup merge of #109312 - petrochenkov:docice5, r=GuillaumeGomez\n\nrustdoc: Cleanup parent module tracking for doc links\n\nKeep ids of the documented items themselves, not their parent modules. Parent modules can be retreived from those ids when necessary.\n\nFixes https://github.com/rust-lang/rust/issues/108501.\nThat issue could be fixed in a more local way, but this refactoring is something that I wanted to do since https://github.com/rust-lang/rust/pull/93805 anyway.", "tree": {"sha": "5902bbb510c48a766a9e7667a9765a8109e70b07", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5902bbb510c48a766a9e7667a9765a8109e70b07"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/af3bd22783e11520554d60df7f6fe4f5aab54748", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkG0lJCRBK7hj4Ov3rIwAAhqMIAJam5RS0myZllGt1HXm1QUYT\nI9fE26cF2oYdRPXyTl+qX6o2qQsyhLNxRpKeOuk1AWUwbNpqy3CipWvaCQfetNeK\nIL9FfkZf0nkoXYHdcEHPo8thk6pk2VcbJC+LcMODpLcVrhFuHB+sa8e78/D1PPPJ\nof0ROH9BcSJiVYDYLAMXdQigaWRcCpfsAh5Dkb/lRcD1ridHJMM1u7L4/QWE5nQm\nPqVhOx2ftTmFBrsiJ69Q3Ila6IjkTafc+IDrmPBBWw2DCeduF038KIO673WL8jL0\nWsfNpha2T/TYDO86wJvV2Cd74hrSGv7pU4Fui1Kw6SHa+71IuEvhJxubQ9EEzaM=\n=8rsB\n-----END PGP SIGNATURE-----\n", "payload": "tree 5902bbb510c48a766a9e7667a9765a8109e70b07\nparent 7a57d8883e97bf66cf7dbfd05c43c7355db20e0a\nparent 0f45d855c33aea5e04ea9a1e154bee68fbaa61da\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1679509833 +0530\ncommitter GitHub <noreply@github.com> 1679509833 +0530\n\nRollup merge of #109312 - petrochenkov:docice5, r=GuillaumeGomez\n\nrustdoc: Cleanup parent module tracking for doc links\n\nKeep ids of the documented items themselves, not their parent modules. Parent modules can be retreived from those ids when necessary.\n\nFixes https://github.com/rust-lang/rust/issues/108501.\nThat issue could be fixed in a more local way, but this refactoring is something that I wanted to do since https://github.com/rust-lang/rust/pull/93805 anyway.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/af3bd22783e11520554d60df7f6fe4f5aab54748", "html_url": "https://github.com/rust-lang/rust/commit/af3bd22783e11520554d60df7f6fe4f5aab54748", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/af3bd22783e11520554d60df7f6fe4f5aab54748/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7a57d8883e97bf66cf7dbfd05c43c7355db20e0a", "url": "https://api.github.com/repos/rust-lang/rust/commits/7a57d8883e97bf66cf7dbfd05c43c7355db20e0a", "html_url": "https://github.com/rust-lang/rust/commit/7a57d8883e97bf66cf7dbfd05c43c7355db20e0a"}, {"sha": "0f45d855c33aea5e04ea9a1e154bee68fbaa61da", "url": "https://api.github.com/repos/rust-lang/rust/commits/0f45d855c33aea5e04ea9a1e154bee68fbaa61da", "html_url": "https://github.com/rust-lang/rust/commit/0f45d855c33aea5e04ea9a1e154bee68fbaa61da"}], "stats": {"total": 308, "additions": 123, "deletions": 185}, "files": [{"sha": "0e40f794f18608f6d5ae839cbdfe244680439cab", "filename": "compiler/rustc_resolve/src/rustdoc.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/af3bd22783e11520554d60df7f6fe4f5aab54748/compiler%2Frustc_resolve%2Fsrc%2Frustdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3bd22783e11520554d60df7f6fe4f5aab54748/compiler%2Frustc_resolve%2Fsrc%2Frustdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Frustdoc.rs?ref=af3bd22783e11520554d60df7f6fe4f5aab54748", "patch": "@@ -26,11 +26,13 @@ pub enum DocFragmentKind {\n #[derive(Clone, PartialEq, Eq, Debug)]\n pub struct DocFragment {\n     pub span: Span,\n-    /// The module this doc-comment came from.\n-    ///\n-    /// This allows distinguishing between the original documentation and a pub re-export.\n-    /// If it is `None`, the item was not re-exported.\n-    pub parent_module: Option<DefId>,\n+    /// The item this doc-comment came from.\n+    /// Used to determine the scope in which doc links in this fragment are resolved.\n+    /// Typically filled for reexport docs when they are merged into the docs of the\n+    /// original reexported item.\n+    /// If the id is not filled, which happens for the original reexported item, then\n+    /// it has to be taken from somewhere else during doc link resolution.\n+    pub item_id: Option<DefId>,\n     pub doc: Symbol,\n     pub kind: DocFragmentKind,\n     pub indent: usize,\n@@ -186,15 +188,15 @@ pub fn attrs_to_doc_fragments<'a>(\n ) -> (Vec<DocFragment>, ast::AttrVec) {\n     let mut doc_fragments = Vec::new();\n     let mut other_attrs = ast::AttrVec::new();\n-    for (attr, parent_module) in attrs {\n+    for (attr, item_id) in attrs {\n         if let Some((doc_str, comment_kind)) = attr.doc_str_and_comment_kind() {\n             let doc = beautify_doc_string(doc_str, comment_kind);\n             let kind = if attr.is_doc_comment() {\n                 DocFragmentKind::SugaredDoc\n             } else {\n                 DocFragmentKind::RawDoc\n             };\n-            let fragment = DocFragment { span: attr.span, doc, kind, parent_module, indent: 0 };\n+            let fragment = DocFragment { span: attr.span, doc, kind, item_id, indent: 0 };\n             doc_fragments.push(fragment);\n         } else if !doc_only {\n             other_attrs.push(attr.clone());\n@@ -216,7 +218,7 @@ pub fn prepare_to_doc_link_resolution(\n ) -> FxHashMap<Option<DefId>, String> {\n     let mut res = FxHashMap::default();\n     for fragment in doc_fragments {\n-        let out_str = res.entry(fragment.parent_module).or_default();\n+        let out_str = res.entry(fragment.item_id).or_default();\n         add_doc_fragment(out_str, fragment);\n     }\n     res"}, {"sha": "768f8bb7bc899aa7b42da8b7d6c641da4f05f4d3", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 23, "deletions": 52, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/af3bd22783e11520554d60df7f6fe4f5aab54748/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3bd22783e11520554d60df7f6fe4f5aab54748/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=af3bd22783e11520554d60df7f6fe4f5aab54748", "patch": "@@ -36,15 +36,11 @@ use crate::formats::item_type::ItemType;\n ///\n /// The returned value is `None` if the definition could not be inlined,\n /// and `Some` of a vector of items if it was successfully expanded.\n-///\n-/// `parent_module` refers to the parent of the *re-export*, not the original item.\n pub(crate) fn try_inline(\n     cx: &mut DocContext<'_>,\n-    parent_module: DefId,\n-    import_def_id: Option<DefId>,\n     res: Res,\n     name: Symbol,\n-    attrs: Option<&[ast::Attribute]>,\n+    attrs: Option<(&[ast::Attribute], Option<DefId>)>,\n     visited: &mut DefIdSet,\n ) -> Option<Vec<clean::Item>> {\n     let did = res.opt_def_id()?;\n@@ -55,38 +51,17 @@ pub(crate) fn try_inline(\n \n     debug!(\"attrs={:?}\", attrs);\n \n-    let attrs_without_docs = attrs.map(|attrs| {\n-        attrs.into_iter().filter(|a| a.doc_str().is_none()).cloned().collect::<Vec<_>>()\n+    let attrs_without_docs = attrs.map(|(attrs, def_id)| {\n+        (attrs.into_iter().filter(|a| a.doc_str().is_none()).cloned().collect::<Vec<_>>(), def_id)\n     });\n-    // We need this ugly code because:\n-    //\n-    // ```\n-    // attrs_without_docs.map(|a| a.as_slice())\n-    // ```\n-    //\n-    // will fail because it returns a temporary slice and:\n-    //\n-    // ```\n-    // attrs_without_docs.map(|s| {\n-    //     vec = s.as_slice();\n-    //     vec\n-    // })\n-    // ```\n-    //\n-    // will fail because we're moving an uninitialized variable into a closure.\n-    let vec;\n-    let attrs_without_docs = match attrs_without_docs {\n-        Some(s) => {\n-            vec = s;\n-            Some(vec.as_slice())\n-        }\n-        None => None,\n-    };\n+    let attrs_without_docs =\n+        attrs_without_docs.as_ref().map(|(attrs, def_id)| (&attrs[..], *def_id));\n \n+    let import_def_id = attrs.and_then(|(_, def_id)| def_id);\n     let kind = match res {\n         Res::Def(DefKind::Trait, did) => {\n             record_extern_fqn(cx, did, ItemType::Trait);\n-            build_impls(cx, Some(parent_module), did, attrs_without_docs, &mut ret);\n+            build_impls(cx, did, attrs_without_docs, &mut ret);\n             clean::TraitItem(Box::new(build_external_trait(cx, did)))\n         }\n         Res::Def(DefKind::Fn, did) => {\n@@ -95,27 +70,27 @@ pub(crate) fn try_inline(\n         }\n         Res::Def(DefKind::Struct, did) => {\n             record_extern_fqn(cx, did, ItemType::Struct);\n-            build_impls(cx, Some(parent_module), did, attrs_without_docs, &mut ret);\n+            build_impls(cx, did, attrs_without_docs, &mut ret);\n             clean::StructItem(build_struct(cx, did))\n         }\n         Res::Def(DefKind::Union, did) => {\n             record_extern_fqn(cx, did, ItemType::Union);\n-            build_impls(cx, Some(parent_module), did, attrs_without_docs, &mut ret);\n+            build_impls(cx, did, attrs_without_docs, &mut ret);\n             clean::UnionItem(build_union(cx, did))\n         }\n         Res::Def(DefKind::TyAlias, did) => {\n             record_extern_fqn(cx, did, ItemType::Typedef);\n-            build_impls(cx, Some(parent_module), did, attrs_without_docs, &mut ret);\n+            build_impls(cx, did, attrs_without_docs, &mut ret);\n             clean::TypedefItem(build_type_alias(cx, did))\n         }\n         Res::Def(DefKind::Enum, did) => {\n             record_extern_fqn(cx, did, ItemType::Enum);\n-            build_impls(cx, Some(parent_module), did, attrs_without_docs, &mut ret);\n+            build_impls(cx, did, attrs_without_docs, &mut ret);\n             clean::EnumItem(build_enum(cx, did))\n         }\n         Res::Def(DefKind::ForeignTy, did) => {\n             record_extern_fqn(cx, did, ItemType::ForeignType);\n-            build_impls(cx, Some(parent_module), did, attrs_without_docs, &mut ret);\n+            build_impls(cx, did, attrs_without_docs, &mut ret);\n             clean::ForeignTypeItem\n         }\n         // Never inline enum variants but leave them shown as re-exports.\n@@ -149,7 +124,7 @@ pub(crate) fn try_inline(\n         _ => return None,\n     };\n \n-    let (attrs, cfg) = merge_attrs(cx, Some(parent_module), load_attrs(cx, did), attrs);\n+    let (attrs, cfg) = merge_attrs(cx, load_attrs(cx, did), attrs);\n     cx.inlined.insert(did.into());\n     let mut item =\n         clean::Item::from_def_id_and_attrs_and_parts(did, Some(name), kind, Box::new(attrs), cfg);\n@@ -316,17 +291,16 @@ fn build_type_alias(cx: &mut DocContext<'_>, did: DefId) -> Box<clean::Typedef>\n /// Builds all inherent implementations of an ADT (struct/union/enum) or Trait item/path/reexport.\n pub(crate) fn build_impls(\n     cx: &mut DocContext<'_>,\n-    parent_module: Option<DefId>,\n     did: DefId,\n-    attrs: Option<&[ast::Attribute]>,\n+    attrs: Option<(&[ast::Attribute], Option<DefId>)>,\n     ret: &mut Vec<clean::Item>,\n ) {\n     let _prof_timer = cx.tcx.sess.prof.generic_activity(\"build_inherent_impls\");\n     let tcx = cx.tcx;\n \n     // for each implementation of an item represented by `did`, build the clean::Item for that impl\n     for &did in tcx.inherent_impls(did).iter() {\n-        build_impl(cx, parent_module, did, attrs, ret);\n+        build_impl(cx, did, attrs, ret);\n     }\n \n     // This pretty much exists expressly for `dyn Error` traits that exist in the `alloc` crate.\n@@ -340,28 +314,26 @@ pub(crate) fn build_impls(\n         let type_ =\n             if tcx.is_trait(did) { TraitSimplifiedType(did) } else { AdtSimplifiedType(did) };\n         for &did in tcx.incoherent_impls(type_) {\n-            build_impl(cx, parent_module, did, attrs, ret);\n+            build_impl(cx, did, attrs, ret);\n         }\n     }\n }\n \n-/// `parent_module` refers to the parent of the re-export, not the original item\n pub(crate) fn merge_attrs(\n     cx: &mut DocContext<'_>,\n-    parent_module: Option<DefId>,\n     old_attrs: &[ast::Attribute],\n-    new_attrs: Option<&[ast::Attribute]>,\n+    new_attrs: Option<(&[ast::Attribute], Option<DefId>)>,\n ) -> (clean::Attributes, Option<Arc<clean::cfg::Cfg>>) {\n     // NOTE: If we have additional attributes (from a re-export),\n     // always insert them first. This ensure that re-export\n     // doc comments show up before the original doc comments\n     // when we render them.\n-    if let Some(inner) = new_attrs {\n+    if let Some((inner, item_id)) = new_attrs {\n         let mut both = inner.to_vec();\n         both.extend_from_slice(old_attrs);\n         (\n-            if let Some(new_id) = parent_module {\n-                Attributes::from_ast_with_additional(old_attrs, (inner, new_id))\n+            if let Some(item_id) = item_id {\n+                Attributes::from_ast_with_additional(old_attrs, (inner, item_id))\n             } else {\n                 Attributes::from_ast(&both)\n             },\n@@ -375,9 +347,8 @@ pub(crate) fn merge_attrs(\n /// Inline an `impl`, inherent or of a trait. The `did` must be for an `impl`.\n pub(crate) fn build_impl(\n     cx: &mut DocContext<'_>,\n-    parent_module: Option<DefId>,\n     did: DefId,\n-    attrs: Option<&[ast::Attribute]>,\n+    attrs: Option<(&[ast::Attribute], Option<DefId>)>,\n     ret: &mut Vec<clean::Item>,\n ) {\n     if !cx.inlined.insert(did.into()) {\n@@ -539,7 +510,7 @@ pub(crate) fn build_impl(\n         record_extern_trait(cx, did);\n     }\n \n-    let (merged_attrs, cfg) = merge_attrs(cx, parent_module, load_attrs(cx, did), attrs);\n+    let (merged_attrs, cfg) = merge_attrs(cx, load_attrs(cx, did), attrs);\n     trace!(\"merged_attrs={:?}\", merged_attrs);\n \n     trace!(\n@@ -635,7 +606,7 @@ fn build_module_items(\n                     cfg: None,\n                     inline_stmt_id: None,\n                 });\n-            } else if let Some(i) = try_inline(cx, did, None, res, item.ident.name, None, visited) {\n+            } else if let Some(i) = try_inline(cx, res, item.ident.name, None, visited) {\n                 items.extend(i)\n             }\n         }"}, {"sha": "2e1f456f50e2f4f6c4a65504214b817d6e399771", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 8, "deletions": 18, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/af3bd22783e11520554d60df7f6fe4f5aab54748/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3bd22783e11520554d60df7f6fe4f5aab54748/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=af3bd22783e11520554d60df7f6fe4f5aab54748", "patch": "@@ -2388,12 +2388,12 @@ fn clean_maybe_renamed_item<'tcx>(\n             target_attrs.extend_from_slice(inline::load_attrs(cx, def_id));\n         }\n \n-        let import_parent = import_id.map(|import_id| cx.tcx.local_parent(import_id).to_def_id());\n-        let (attrs, cfg) =  merge_attrs(cx, import_parent, &target_attrs, Some(&import_attrs));\n+        let import_id = import_id.map(|def_id| def_id.to_def_id());\n+        let (attrs, cfg) =  merge_attrs(cx, &target_attrs, Some((&import_attrs, import_id)));\n \n         let mut item =\n             Item::from_def_id_and_attrs_and_parts(def_id, Some(name), kind, Box::new(attrs), cfg);\n-        item.inline_stmt_id = import_id.map(|def_id| def_id.to_def_id());\n+        item.inline_stmt_id = import_id;\n         vec![item]\n     })\n }\n@@ -2478,18 +2478,12 @@ fn clean_extern_crate<'tcx>(\n \n     let krate_owner_def_id = krate.owner_id.to_def_id();\n     if please_inline {\n-        let mut visited = DefIdSet::default();\n-\n-        let res = Res::Def(DefKind::Mod, crate_def_id);\n-\n         if let Some(items) = inline::try_inline(\n             cx,\n-            cx.tcx.parent_module(krate.hir_id()).to_def_id(),\n-            Some(krate_owner_def_id),\n-            res,\n+            Res::Def(DefKind::Mod, crate_def_id),\n             name,\n-            Some(attrs),\n-            &mut visited,\n+            Some((attrs, Some(krate_owner_def_id))),\n+            &mut Default::default(),\n         ) {\n             return items;\n         }\n@@ -2613,17 +2607,13 @@ fn clean_use_statement_inner<'tcx>(\n             denied = true;\n         }\n         if !denied {\n-            let mut visited = DefIdSet::default();\n             let import_def_id = import.owner_id.to_def_id();\n-\n             if let Some(mut items) = inline::try_inline(\n                 cx,\n-                cx.tcx.parent_module(import.hir_id()).to_def_id(),\n-                Some(import_def_id),\n                 path.res,\n                 name,\n-                Some(attrs),\n-                &mut visited,\n+                Some((attrs, Some(import_def_id))),\n+                &mut Default::default(),\n             ) {\n                 items.push(Item::from_def_id_and_parts(\n                     import_def_id,"}, {"sha": "8f2331785f50d6cbce2dac033a8e0ade60c6d534", "filename": "src/librustdoc/clean/types/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af3bd22783e11520554d60df7f6fe4f5aab54748/src%2Flibrustdoc%2Fclean%2Ftypes%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3bd22783e11520554d60df7f6fe4f5aab54748/src%2Flibrustdoc%2Fclean%2Ftypes%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes%2Ftests.rs?ref=af3bd22783e11520554d60df7f6fe4f5aab54748", "patch": "@@ -10,7 +10,7 @@ use rustc_span::symbol::Symbol;\n fn create_doc_fragment(s: &str) -> Vec<DocFragment> {\n     vec![DocFragment {\n         span: DUMMY_SP,\n-        parent_module: None,\n+        item_id: None,\n         doc: Symbol::intern(s),\n         kind: DocFragmentKind::SugaredDoc,\n         indent: 0,"}, {"sha": "cca50df0db2136caf765307222c515d65eb8f097", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af3bd22783e11520554d60df7f6fe4f5aab54748/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3bd22783e11520554d60df7f6fe4f5aab54748/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=af3bd22783e11520554d60df7f6fe4f5aab54748", "patch": "@@ -195,12 +195,12 @@ pub(crate) fn build_deref_target_impls(\n         if let Some(prim) = target.primitive_type() {\n             let _prof_timer = cx.tcx.sess.prof.generic_activity(\"build_primitive_inherent_impls\");\n             for did in prim.impls(tcx).filter(|did| !did.is_local()) {\n-                inline::build_impl(cx, None, did, None, ret);\n+                inline::build_impl(cx, did, None, ret);\n             }\n         } else if let Type::Path { path } = target {\n             let did = path.def_id();\n             if !did.is_local() {\n-                inline::build_impls(cx, None, did, None, ret);\n+                inline::build_impls(cx, did, None, ret);\n             }\n         }\n     }"}, {"sha": "789523c561e57533783113e37ce5ea41ebe72140", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 63, "deletions": 100, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/af3bd22783e11520554d60df7f6fe4f5aab54748/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3bd22783e11520554d60df7f6fe4f5aab54748/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=af3bd22783e11520554d60df7f6fe4f5aab54748", "patch": "@@ -28,7 +28,7 @@ use std::mem;\n use std::ops::Range;\n \n use crate::clean::{self, utils::find_nearest_parent_module};\n-use crate::clean::{Crate, Item, ItemId, ItemLink, PrimitiveType};\n+use crate::clean::{Crate, Item, ItemLink, PrimitiveType};\n use crate::core::DocContext;\n use crate::html::markdown::{markdown_links, MarkdownLink};\n use crate::lint::{BROKEN_INTRA_DOC_LINKS, PRIVATE_INTRA_DOC_LINKS};\n@@ -42,8 +42,7 @@ pub(crate) const COLLECT_INTRA_DOC_LINKS: Pass = Pass {\n };\n \n fn collect_intra_doc_links(krate: Crate, cx: &mut DocContext<'_>) -> Crate {\n-    let mut collector =\n-        LinkCollector { cx, mod_ids: Vec::new(), visited_links: FxHashMap::default() };\n+    let mut collector = LinkCollector { cx, visited_links: FxHashMap::default() };\n     collector.visit_crate(&krate);\n     krate\n }\n@@ -149,7 +148,7 @@ impl TryFrom<ResolveRes> for Res {\n #[derive(Debug)]\n struct UnresolvedPath<'a> {\n     /// Item on which the link is resolved, used for resolving `Self`.\n-    item_id: ItemId,\n+    item_id: DefId,\n     /// The scope the link was resolved in.\n     module_id: DefId,\n     /// If part of the link resolved, this has the `Res`.\n@@ -225,7 +224,7 @@ impl UrlFragment {\n \n #[derive(Clone, Debug, Hash, PartialEq, Eq)]\n struct ResolutionInfo {\n-    item_id: ItemId,\n+    item_id: DefId,\n     module_id: DefId,\n     dis: Option<Disambiguator>,\n     path_str: Box<str>,\n@@ -242,11 +241,6 @@ struct DiagnosticInfo<'a> {\n \n struct LinkCollector<'a, 'tcx> {\n     cx: &'a mut DocContext<'tcx>,\n-    /// A stack of modules used to decide what scope to resolve in.\n-    ///\n-    /// The last module will be used if the parent scope of the current item is\n-    /// unknown.\n-    mod_ids: Vec<DefId>,\n     /// Cache the resolved links so we can avoid resolving (and emitting errors for) the same link.\n     /// The link will be `None` if it could not be resolved (i.e. the error was cached).\n     visited_links: FxHashMap<ResolutionInfo, Option<(Res, Option<UrlFragment>)>>,\n@@ -262,7 +256,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n     fn variant_field<'path>(\n         &self,\n         path_str: &'path str,\n-        item_id: ItemId,\n+        item_id: DefId,\n         module_id: DefId,\n     ) -> Result<(Res, DefId), UnresolvedPath<'path>> {\n         let tcx = self.cx.tcx;\n@@ -333,35 +327,33 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         })\n     }\n \n-    fn resolve_self_ty(&self, path_str: &str, ns: Namespace, item_id: ItemId) -> Option<Res> {\n+    fn resolve_self_ty(&self, path_str: &str, ns: Namespace, item_id: DefId) -> Option<Res> {\n         if ns != TypeNS || path_str != \"Self\" {\n             return None;\n         }\n \n         let tcx = self.cx.tcx;\n-        item_id\n-            .as_def_id()\n-            .map(|def_id| match tcx.def_kind(def_id) {\n-                def_kind @ (DefKind::AssocFn\n-                | DefKind::AssocConst\n-                | DefKind::AssocTy\n-                | DefKind::Variant\n-                | DefKind::Field) => {\n-                    let parent_def_id = tcx.parent(def_id);\n-                    if def_kind == DefKind::Field && tcx.def_kind(parent_def_id) == DefKind::Variant\n-                    {\n-                        tcx.parent(parent_def_id)\n-                    } else {\n-                        parent_def_id\n-                    }\n+        let self_id = match tcx.def_kind(item_id) {\n+            def_kind @ (DefKind::AssocFn\n+            | DefKind::AssocConst\n+            | DefKind::AssocTy\n+            | DefKind::Variant\n+            | DefKind::Field) => {\n+                let parent_def_id = tcx.parent(item_id);\n+                if def_kind == DefKind::Field && tcx.def_kind(parent_def_id) == DefKind::Variant {\n+                    tcx.parent(parent_def_id)\n+                } else {\n+                    parent_def_id\n                 }\n-                _ => def_id,\n-            })\n-            .and_then(|self_id| match tcx.def_kind(self_id) {\n-                DefKind::Impl { .. } => self.def_id_to_res(self_id),\n-                DefKind::Use => None,\n-                def_kind => Some(Res::Def(def_kind, self_id)),\n-            })\n+            }\n+            _ => item_id,\n+        };\n+\n+        match tcx.def_kind(self_id) {\n+            DefKind::Impl { .. } => self.def_id_to_res(self_id),\n+            DefKind::Use => None,\n+            def_kind => Some(Res::Def(def_kind, self_id)),\n+        }\n     }\n \n     /// Convenience wrapper around `doc_link_resolutions`.\n@@ -373,7 +365,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         &self,\n         path_str: &str,\n         ns: Namespace,\n-        item_id: ItemId,\n+        item_id: DefId,\n         module_id: DefId,\n     ) -> Option<Res> {\n         if let res @ Some(..) = self.resolve_self_ty(path_str, ns, item_id) {\n@@ -400,7 +392,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         &mut self,\n         path_str: &'path str,\n         ns: Namespace,\n-        item_id: ItemId,\n+        item_id: DefId,\n         module_id: DefId,\n     ) -> Result<(Res, Option<DefId>), UnresolvedPath<'path>> {\n         if let Some(res) = self.resolve_path(path_str, ns, item_id, module_id) {\n@@ -779,48 +771,8 @@ fn is_derive_trait_collision<T>(ns: &PerNS<Result<(Res, T), ResolutionFailure<'_\n \n impl<'a, 'tcx> DocVisitor for LinkCollector<'a, 'tcx> {\n     fn visit_item(&mut self, item: &Item) {\n-        let parent_node =\n-            item.item_id.as_def_id().and_then(|did| find_nearest_parent_module(self.cx.tcx, did));\n-        if parent_node.is_some() {\n-            trace!(\"got parent node for {:?} {:?}, id {:?}\", item.type_(), item.name, item.item_id);\n-        }\n-\n-        let inner_docs = item.inner_docs(self.cx.tcx);\n-\n-        if item.is_mod() && inner_docs {\n-            self.mod_ids.push(item.item_id.expect_def_id());\n-        }\n-\n-        // We want to resolve in the lexical scope of the documentation.\n-        // In the presence of re-exports, this is not the same as the module of the item.\n-        // Rather than merging all documentation into one, resolve it one attribute at a time\n-        // so we know which module it came from.\n-        for (parent_module, doc) in prepare_to_doc_link_resolution(&item.attrs.doc_strings) {\n-            if !may_have_doc_links(&doc) {\n-                continue;\n-            }\n-            debug!(\"combined_docs={}\", doc);\n-            // NOTE: if there are links that start in one crate and end in another, this will not resolve them.\n-            // This is a degenerate case and it's not supported by rustdoc.\n-            let parent_node = parent_module.or(parent_node);\n-            for md_link in preprocessed_markdown_links(&doc) {\n-                let link = self.resolve_link(item, &doc, parent_node, &md_link);\n-                if let Some(link) = link {\n-                    self.cx.cache.intra_doc_links.entry(item.item_id).or_default().push(link);\n-                }\n-            }\n-        }\n-\n-        if item.is_mod() {\n-            if !inner_docs {\n-                self.mod_ids.push(item.item_id.expect_def_id());\n-            }\n-\n-            self.visit_item_recur(item);\n-            self.mod_ids.pop();\n-        } else {\n-            self.visit_item_recur(item)\n-        }\n+        self.resolve_links(item);\n+        self.visit_item_recur(item)\n     }\n }\n \n@@ -946,14 +898,41 @@ fn preprocessed_markdown_links(s: &str) -> Vec<PreprocessedMarkdownLink> {\n }\n \n impl LinkCollector<'_, '_> {\n+    fn resolve_links(&mut self, item: &Item) {\n+        // We want to resolve in the lexical scope of the documentation.\n+        // In the presence of re-exports, this is not the same as the module of the item.\n+        // Rather than merging all documentation into one, resolve it one attribute at a time\n+        // so we know which module it came from.\n+        for (item_id, doc) in prepare_to_doc_link_resolution(&item.attrs.doc_strings) {\n+            if !may_have_doc_links(&doc) {\n+                continue;\n+            }\n+            debug!(\"combined_docs={}\", doc);\n+            // NOTE: if there are links that start in one crate and end in another, this will not resolve them.\n+            // This is a degenerate case and it's not supported by rustdoc.\n+            let item_id = item_id.unwrap_or_else(|| item.item_id.expect_def_id());\n+            let module_id = match self.cx.tcx.def_kind(item_id) {\n+                DefKind::Mod if item.inner_docs(self.cx.tcx) => item_id,\n+                _ => find_nearest_parent_module(self.cx.tcx, item_id).unwrap(),\n+            };\n+            for md_link in preprocessed_markdown_links(&doc) {\n+                let link = self.resolve_link(item, item_id, module_id, &doc, &md_link);\n+                if let Some(link) = link {\n+                    self.cx.cache.intra_doc_links.entry(item.item_id).or_default().push(link);\n+                }\n+            }\n+        }\n+    }\n+\n     /// This is the entry point for resolving an intra-doc link.\n     ///\n     /// FIXME(jynelson): this is way too many arguments\n     fn resolve_link(\n         &mut self,\n         item: &Item,\n+        item_id: DefId,\n+        module_id: DefId,\n         dox: &str,\n-        parent_node: Option<DefId>,\n         link: &PreprocessedMarkdownLink,\n     ) -> Option<ItemLink> {\n         let PreprocessedMarkdownLink(pp_link, ori_link) = link;\n@@ -970,25 +949,9 @@ impl LinkCollector<'_, '_> {\n             pp_link.as_ref().map_err(|err| err.report(self.cx, diag_info.clone())).ok()?;\n         let disambiguator = *disambiguator;\n \n-        // In order to correctly resolve intra-doc links we need to\n-        // pick a base AST node to work from.  If the documentation for\n-        // this module came from an inner comment (//!) then we anchor\n-        // our name resolution *inside* the module.  If, on the other\n-        // hand it was an outer comment (///) then we anchor the name\n-        // resolution in the parent module on the basis that the names\n-        // used are more likely to be intended to be parent names.  For\n-        // this, we set base_node to None for inner comments since\n-        // we've already pushed this node onto the resolution stack but\n-        // for outer comments we explicitly try and resolve against the\n-        // parent_node first.\n-        let inner_docs = item.inner_docs(self.cx.tcx);\n-        let base_node =\n-            if item.is_mod() && inner_docs { self.mod_ids.last().copied() } else { parent_node };\n-        let module_id = base_node.expect(\"doc link without parent module\");\n-\n         let (mut res, fragment) = self.resolve_with_disambiguator_cached(\n             ResolutionInfo {\n-                item_id: item.item_id,\n+                item_id,\n                 module_id,\n                 dis: disambiguator,\n                 path_str: path_str.clone(),\n@@ -1229,11 +1192,11 @@ impl LinkCollector<'_, '_> {\n         let disambiguator = key.dis;\n         let path_str = &key.path_str;\n         let item_id = key.item_id;\n-        let base_node = key.module_id;\n+        let module_id = key.module_id;\n \n         match disambiguator.map(Disambiguator::ns) {\n             Some(expected_ns) => {\n-                match self.resolve(path_str, expected_ns, item_id, base_node) {\n+                match self.resolve(path_str, expected_ns, item_id, module_id) {\n                     Ok(res) => Some(res),\n                     Err(err) => {\n                         // We only looked in one namespace. Try to give a better error if possible.\n@@ -1243,7 +1206,7 @@ impl LinkCollector<'_, '_> {\n                         for other_ns in [TypeNS, ValueNS, MacroNS] {\n                             if other_ns != expected_ns {\n                                 if let Ok(res) =\n-                                    self.resolve(path_str, other_ns, item_id, base_node)\n+                                    self.resolve(path_str, other_ns, item_id, module_id)\n                                 {\n                                     err = ResolutionFailure::WrongNamespace {\n                                         res: full_res(self.cx.tcx, res),\n@@ -1260,7 +1223,7 @@ impl LinkCollector<'_, '_> {\n             None => {\n                 // Try everything!\n                 let mut candidate = |ns| {\n-                    self.resolve(path_str, ns, item_id, base_node)\n+                    self.resolve(path_str, ns, item_id, module_id)\n                         .map_err(ResolutionFailure::NotResolved)\n                 };\n "}, {"sha": "8d204ddb79e3976f5e63749e0faf5042a3e071d7", "filename": "src/librustdoc/passes/collect_trait_impls.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/af3bd22783e11520554d60df7f6fe4f5aab54748/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3bd22783e11520554d60df7f6fe4f5aab54748/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs?ref=af3bd22783e11520554d60df7f6fe4f5aab54748", "patch": "@@ -49,7 +49,7 @@ pub(crate) fn collect_trait_impls(mut krate: Crate, cx: &mut DocContext<'_>) ->\n         let _prof_timer = cx.tcx.sess.prof.generic_activity(\"build_extern_trait_impls\");\n         for &cnum in cx.tcx.crates(()) {\n             for &impl_def_id in cx.tcx.trait_impls_in_crate(cnum) {\n-                inline::build_impl(cx, None, impl_def_id, None, &mut new_items_external);\n+                inline::build_impl(cx, impl_def_id, None, &mut new_items_external);\n             }\n         }\n     }\n@@ -75,7 +75,7 @@ pub(crate) fn collect_trait_impls(mut krate: Crate, cx: &mut DocContext<'_>) ->\n                 );\n                 parent = cx.tcx.opt_parent(did);\n             }\n-            inline::build_impl(cx, None, impl_def_id, Some(&attr_buf), &mut new_items_local);\n+            inline::build_impl(cx, impl_def_id, Some((&attr_buf, None)), &mut new_items_local);\n             attr_buf.clear();\n         }\n     }\n@@ -84,7 +84,7 @@ pub(crate) fn collect_trait_impls(mut krate: Crate, cx: &mut DocContext<'_>) ->\n         for def_id in PrimitiveType::all_impls(cx.tcx) {\n             // Try to inline primitive impls from other crates.\n             if !def_id.is_local() {\n-                inline::build_impl(cx, None, def_id, None, &mut new_items_external);\n+                inline::build_impl(cx, def_id, None, &mut new_items_external);\n             }\n         }\n         for (prim, did) in PrimitiveType::primitive_locations(cx.tcx) {"}, {"sha": "8a33e51b3beb1acac3dc621db268dd738235787b", "filename": "src/librustdoc/passes/propagate_doc_cfg.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/af3bd22783e11520554d60df7f6fe4f5aab54748/src%2Flibrustdoc%2Fpasses%2Fpropagate_doc_cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3bd22783e11520554d60df7f6fe4f5aab54748/src%2Flibrustdoc%2Fpasses%2Fpropagate_doc_cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fpropagate_doc_cfg.rs?ref=af3bd22783e11520554d60df7f6fe4f5aab54748", "patch": "@@ -57,7 +57,8 @@ impl<'a, 'tcx> CfgPropagator<'a, 'tcx> {\n             next_def_id = parent_def_id;\n         }\n \n-        let (_, cfg) = merge_attrs(self.cx, None, item.attrs.other_attrs.as_slice(), Some(&attrs));\n+        let (_, cfg) =\n+            merge_attrs(self.cx, item.attrs.other_attrs.as_slice(), Some((&attrs, None)));\n         item.cfg = cfg;\n     }\n }"}, {"sha": "15bf51e6f8e2b6319f8ab39ea95955d41b22e1a1", "filename": "tests/rustdoc-ui/intra-doc/auxiliary/inner-crate-doc.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af3bd22783e11520554d60df7f6fe4f5aab54748/tests%2Frustdoc-ui%2Fintra-doc%2Fauxiliary%2Finner-crate-doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3bd22783e11520554d60df7f6fe4f5aab54748/tests%2Frustdoc-ui%2Fintra-doc%2Fauxiliary%2Finner-crate-doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fintra-doc%2Fauxiliary%2Finner-crate-doc.rs?ref=af3bd22783e11520554d60df7f6fe4f5aab54748", "patch": "@@ -0,0 +1 @@\n+//! Inner doc comment"}, {"sha": "4d6a325664578da09545bcadea3df882f133faab", "filename": "tests/rustdoc-ui/intra-doc/import-inline-merge-module.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/af3bd22783e11520554d60df7f6fe4f5aab54748/tests%2Frustdoc-ui%2Fintra-doc%2Fimport-inline-merge-module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af3bd22783e11520554d60df7f6fe4f5aab54748/tests%2Frustdoc-ui%2Fintra-doc%2Fimport-inline-merge-module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fintra-doc%2Fimport-inline-merge-module.rs?ref=af3bd22783e11520554d60df7f6fe4f5aab54748", "patch": "@@ -0,0 +1,10 @@\n+// Test for issue #108501.\n+// Module parent scope doesn't hijack import's parent scope for the import's doc links.\n+\n+// check-pass\n+// aux-build: inner-crate-doc.rs\n+// compile-flags: --extern inner_crate_doc --edition 2018\n+\n+/// Import doc comment [inner_crate_doc]\n+#[doc(inline)]\n+pub use inner_crate_doc;"}]}