{"sha": "5cc4352bc4f9789d7243e79684b2943d3d9ad450", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVjYzQzNTJiYzRmOTc4OWQ3MjQzZTc5Njg0YjI5NDNkM2Q5YWQ0NTA=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-12-27T13:39:43Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2020-02-01T22:10:03Z"}, "message": "Implement general or-patterns in `match` expressions", "tree": {"sha": "d75e4b9b9483626516604273a18d5af5c4fc9b31", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d75e4b9b9483626516604273a18d5af5c4fc9b31"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5cc4352bc4f9789d7243e79684b2943d3d9ad450", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5cc4352bc4f9789d7243e79684b2943d3d9ad450", "html_url": "https://github.com/rust-lang/rust/commit/5cc4352bc4f9789d7243e79684b2943d3d9ad450", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5cc4352bc4f9789d7243e79684b2943d3d9ad450/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "64eab7750bed3d692c90b215c5a3c65030ece3b7", "url": "https://api.github.com/repos/rust-lang/rust/commits/64eab7750bed3d692c90b215c5a3c65030ece3b7", "html_url": "https://github.com/rust-lang/rust/commit/64eab7750bed3d692c90b215c5a3c65030ece3b7"}], "stats": {"total": 469, "additions": 381, "deletions": 88}, "files": [{"sha": "4ac3ced17dbb1b08e04fd46d40e042cd47a65dbc", "filename": "src/librustc_mir_build/build/matches/mod.rs", "status": "modified", "additions": 324, "deletions": 70, "changes": 394, "blob_url": "https://github.com/rust-lang/rust/blob/5cc4352bc4f9789d7243e79684b2943d3d9ad450/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cc4352bc4f9789d7243e79684b2943d3d9ad450/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Fmod.rs?ref=5cc4352bc4f9789d7243e79684b2943d3d9ad450", "patch": "@@ -26,7 +26,9 @@ mod simplify;\n mod test;\n mod util;\n \n+use std::borrow::Borrow;\n use std::convert::TryFrom;\n+use std::mem;\n \n impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// Generates MIR for a `match` expression.\n@@ -95,7 +97,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n         let match_has_guard = arms.iter().any(|arm| arm.guard.is_some());\n         let candidates =\n-            arm_candidates.iter_mut().flat_map(|(_, candidates)| candidates).collect::<Vec<_>>();\n+            arm_candidates.iter_mut().map(|(_, candidate)| candidate).collect::<Vec<_>>();\n \n         let fake_borrow_temps =\n             self.lower_match_tree(block, scrutinee_span, match_has_guard, candidates);\n@@ -145,27 +147,25 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         &mut self,\n         scrutinee: &Place<'tcx>,\n         arms: &'pat [Arm<'tcx>],\n-    ) -> Vec<(&'pat Arm<'tcx>, Vec<Candidate<'pat, 'tcx>>)> {\n+    ) -> Vec<(&'pat Arm<'tcx>, Candidate<'pat, 'tcx>)> {\n         // Assemble a list of candidates: there is one candidate per pattern,\n         // which means there may be more than one candidate *per arm*.\n         arms.iter()\n             .map(|arm| {\n                 let arm_has_guard = arm.guard.is_some();\n-                let arm_candidates: Vec<_> = arm\n-                    .top_pats_hack()\n-                    .iter()\n-                    .map(|pattern| Candidate {\n-                        span: pattern.span,\n-                        has_guard: arm_has_guard,\n-                        match_pairs: smallvec![MatchPair::new(*scrutinee, pattern)],\n-                        bindings: vec![],\n-                        ascriptions: vec![],\n-                        otherwise_block: None,\n-                        pre_binding_block: None,\n-                        next_candidate_pre_binding_block: None,\n-                    })\n-                    .collect();\n-                (arm, arm_candidates)\n+                let arm_candidate = Candidate {\n+                    span: arm.pattern.span,\n+                    match_pairs: smallvec![MatchPair::new(*scrutinee, &arm.pattern),],\n+                    bindings: vec![],\n+                    ascriptions: vec![],\n+                    has_guard: arm_has_guard,\n+                    needs_otherwise_block: arm_has_guard,\n+                    otherwise_block: None,\n+                    pre_binding_block: None,\n+                    next_candidate_pre_binding_block: None,\n+                    subcandidates: vec![],\n+                };\n+                (arm, arm_candidate)\n             })\n             .collect()\n     }\n@@ -205,11 +205,15 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             self.cfg.terminate(otherwise_block, source_info, TerminatorKind::Unreachable);\n         }\n \n-        let mut next_prebinding_block = None;\n+        let mut previous_candidate: Option<&mut Candidate<'_, '_>> = None;\n \n-        for candidate in candidates.iter_mut().rev() {\n-            candidate.next_candidate_pre_binding_block = next_prebinding_block;\n-            next_prebinding_block = candidate.pre_binding_block;\n+        for candidate in candidates.into_iter() {\n+            candidate.visit_leaves(|leaf_candidate| {\n+                if let Some(ref mut prev) = previous_candidate {\n+                    prev.next_candidate_pre_binding_block = leaf_candidate.pre_binding_block;\n+                }\n+                previous_candidate = Some(leaf_candidate);\n+            });\n         }\n \n         if let Some(ref borrows) = fake_borrows {\n@@ -230,16 +234,16 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         destination: &Place<'tcx>,\n         scrutinee_place: Place<'tcx>,\n         scrutinee_span: Span,\n-        arm_candidates: Vec<(&'_ Arm<'tcx>, Vec<Candidate<'_, 'tcx>>)>,\n+        arm_candidates: Vec<(&'_ Arm<'tcx>, Candidate<'_, 'tcx>)>,\n         outer_source_info: SourceInfo,\n         fake_borrow_temps: Vec<(Place<'tcx>, Local)>,\n     ) -> BlockAnd<()> {\n         let match_scope = self.scopes.topmost();\n \n         let arm_end_blocks: Vec<_> = arm_candidates\n             .into_iter()\n-            .map(|(arm, candidates)| {\n-                debug!(\"lowering arm {:?}\\ncanidates = {:?}\", arm, candidates);\n+            .map(|(arm, candidate)| {\n+                debug!(\"lowering arm {:?}\\ncanidate = {:?}\", arm, candidate);\n \n                 let arm_source_info = self.source_info(arm.span);\n                 let arm_scope = (arm.scope, arm_source_info);\n@@ -248,14 +252,14 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     let scope = this.declare_bindings(\n                         None,\n                         arm.span,\n-                        &arm.top_pats_hack()[0],\n+                        &arm.pattern,\n                         ArmHasGuard(arm.guard.is_some()),\n                         Some((Some(&scrutinee_place), scrutinee_span)),\n                     );\n \n                     let arm_block = this.bind_pattern(\n                         outer_source_info,\n-                        candidates,\n+                        candidate,\n                         arm.guard.as_ref().map(|g| (g, match_scope)),\n                         &fake_borrow_temps,\n                         scrutinee_span,\n@@ -289,35 +293,52 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     fn bind_pattern(\n         &mut self,\n         outer_source_info: SourceInfo,\n-        mut candidates: Vec<Candidate<'_, 'tcx>>,\n+        candidate: Candidate<'_, 'tcx>,\n         guard: Option<(&Guard<'tcx>, region::Scope)>,\n         fake_borrow_temps: &Vec<(Place<'tcx>, Local)>,\n         scrutinee_span: Span,\n         arm_scope: region::Scope,\n     ) -> BasicBlock {\n-        if candidates.len() == 1 {\n+        if candidate.subcandidates.is_empty() {\n             // Avoid generating another `BasicBlock` when we only have one\n             // candidate.\n             self.bind_and_guard_matched_candidate(\n-                candidates.pop().unwrap(),\n+                candidate,\n+                &[],\n                 guard,\n                 fake_borrow_temps,\n                 scrutinee_span,\n             )\n         } else {\n-            let arm_block = self.cfg.start_new_block();\n-            for candidate in candidates {\n-                // Avoid scheduling drops multiple times.\n-                self.clear_top_scope(arm_scope);\n-                let binding_end = self.bind_and_guard_matched_candidate(\n-                    candidate,\n-                    guard,\n-                    fake_borrow_temps,\n-                    scrutinee_span,\n-                );\n-                self.cfg.goto(binding_end, outer_source_info, arm_block);\n-            }\n-            arm_block\n+            let target_block = self.cfg.start_new_block();\n+\n+            // We keep a stack of all of the bindings and type asciptions\n+            // from the the parent candidates that we visit, that also need to\n+            // be bound for each candidate.\n+            traverse_candidate(\n+                candidate,\n+                &mut Vec::new(),\n+                &mut |leaf_candidate, parent_bindings| {\n+                    self.clear_top_scope(arm_scope);\n+                    let binding_end = self.bind_and_guard_matched_candidate(\n+                        leaf_candidate,\n+                        parent_bindings,\n+                        guard,\n+                        &fake_borrow_temps,\n+                        scrutinee_span,\n+                    );\n+                    self.cfg.goto(binding_end, outer_source_info, target_block);\n+                },\n+                |inner_candidate, parent_bindings| {\n+                    parent_bindings.push((inner_candidate.bindings, inner_candidate.ascriptions));\n+                    inner_candidate.subcandidates.into_iter()\n+                },\n+                |parent_bindings| {\n+                    parent_bindings.pop();\n+                },\n+            );\n+\n+            target_block\n         }\n     }\n \n@@ -427,6 +448,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let mut candidate = Candidate {\n             span: irrefutable_pat.span,\n             has_guard: false,\n+            needs_otherwise_block: false,\n             match_pairs: smallvec![MatchPair::new(*initializer, &irrefutable_pat)],\n             bindings: vec![],\n             ascriptions: vec![],\n@@ -435,6 +457,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             otherwise_block: None,\n             pre_binding_block: None,\n             next_candidate_pre_binding_block: None,\n+            subcandidates: vec![],\n         };\n \n         // Simplify the candidate. Since the pattern is irrefutable, this should\n@@ -632,38 +655,80 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 }\n             }\n             PatKind::Or { ref pats } => {\n-                for pat in pats {\n-                    self.visit_bindings(&pat, pattern_user_ty.clone(), f);\n-                }\n+                self.visit_bindings(&pats[0], pattern_user_ty.clone(), f);\n             }\n         }\n     }\n }\n \n #[derive(Debug)]\n crate struct Candidate<'pat, 'tcx> {\n-    // span of the original pattern that gave rise to this candidate\n+    /// `Span` of the original pattern that gave rise to this candidate\n     span: Span,\n \n+    /// This `Candidate` has a guard.\n     has_guard: bool,\n \n-    // all of these must be satisfied...\n+    /// This `Candidate` needs and otherwise block, either because it has a\n+    /// guard or it has subcandidates.\n+    needs_otherwise_block: bool,\n+\n+    /// All of these must be satisfied...\n     match_pairs: SmallVec<[MatchPair<'pat, 'tcx>; 1]>,\n \n-    // ...these bindings established...\n+    /// ...these bindings established...\n     bindings: Vec<Binding<'tcx>>,\n \n-    // ...and these types asserted...\n+    /// ...and these types asserted...\n     ascriptions: Vec<Ascription<'tcx>>,\n \n-    // ...and the guard must be evaluated, if false branch to Block...\n+    /// ... and if this is non-empty, one of these subcandidates also has to match ...\n+    subcandidates: Vec<Candidate<'pat, 'tcx>>,\n+\n+    /// ...and the guard must be evaluated, if false branch to Block...\n     otherwise_block: Option<BasicBlock>,\n \n-    // ...and the blocks for add false edges between candidates\n+    /// ...and the blocks for add false edges between candidates\n     pre_binding_block: Option<BasicBlock>,\n     next_candidate_pre_binding_block: Option<BasicBlock>,\n }\n \n+impl Candidate<'_, '_> {\n+    /// Visit the leaf candidates (those with no subcandidates) contained in\n+    /// this candidate.\n+    fn visit_leaves<'a>(&'a mut self, mut visit_leaf: impl FnMut(&'a mut Self)) {\n+        traverse_candidate(\n+            self,\n+            &mut (),\n+            &mut move |c, _| visit_leaf(c),\n+            move |c, _| c.subcandidates.iter_mut(),\n+            |_| {},\n+        );\n+    }\n+}\n+\n+/// A depth-first traversal of the `Candidate` and all of its recursive\n+/// subcandidates.\n+fn traverse_candidate<'pat, 'tcx: 'pat, C, T, I>(\n+    candidate: C,\n+    context: &mut T,\n+    visit_leaf: &mut impl FnMut(C, &mut T),\n+    get_children: impl Copy + Fn(C, &mut T) -> I,\n+    complete_children: impl Copy + Fn(&mut T),\n+) where\n+    C: Borrow<Candidate<'pat, 'tcx>>,\n+    I: Iterator<Item = C>,\n+{\n+    if candidate.borrow().subcandidates.is_empty() {\n+        visit_leaf(candidate, context)\n+    } else {\n+        for child in get_children(candidate, context) {\n+            traverse_candidate(child, context, visit_leaf, get_children, complete_children);\n+        }\n+        complete_children(context)\n+    }\n+}\n+\n #[derive(Clone, Debug)]\n struct Binding<'tcx> {\n     span: Span,\n@@ -793,10 +858,45 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         // Start by simplifying candidates. Once this process is complete, all\n         // the match pairs which remain require some form of test, whether it\n         // be a switch or pattern comparison.\n+        let mut split_or_candidate = false;\n         for candidate in &mut *candidates {\n-            self.simplify_candidate(candidate);\n+            split_or_candidate |= self.simplify_candidate(candidate);\n         }\n \n+        if split_or_candidate {\n+            // At least one of the candidates has been split into subcandidates.\n+            // We need to change the candidate list to include those.\n+            let mut new_candidates = Vec::new();\n+\n+            for candidate in candidates {\n+                candidate.visit_leaves(|leaf_candidate| new_candidates.push(leaf_candidate));\n+            }\n+            self.match_simplified_candidates(\n+                span,\n+                start_block,\n+                otherwise_block,\n+                &mut *new_candidates,\n+                fake_borrows,\n+            );\n+        } else {\n+            self.match_simplified_candidates(\n+                span,\n+                start_block,\n+                otherwise_block,\n+                candidates,\n+                fake_borrows,\n+            );\n+        };\n+    }\n+\n+    fn match_simplified_candidates(\n+        &mut self,\n+        span: Span,\n+        start_block: BasicBlock,\n+        otherwise_block: &mut Option<BasicBlock>,\n+        candidates: &mut [&mut Candidate<_, 'tcx>],\n+        fake_borrows: &mut Option<FxHashSet<Place<'tcx>>>,\n+    ) {\n         // The candidates are sorted by priority. Check to see whether the\n         // higher priority candidates (and hence at the front of the slice)\n         // have satisfied all their match pairs.\n@@ -835,7 +935,13 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n \n         // Test for the remaining candidates.\n-        self.test_candidates(span, unmatched_candidates, block, otherwise_block, fake_borrows);\n+        self.test_candidates_with_or(\n+            span,\n+            unmatched_candidates,\n+            block,\n+            otherwise_block,\n+            fake_borrows,\n+        );\n     }\n \n     /// Link up matched candidates. For example, if we have something like\n@@ -866,6 +972,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             !matched_candidates.is_empty(),\n             \"select_matched_candidates called with no candidates\",\n         );\n+        debug_assert!(\n+            matched_candidates.iter().all(|c| c.subcandidates.is_empty()),\n+            \"subcandidates should be empty in select_matched_candidates\",\n+        );\n \n         // Insert a borrows of prefixes of places that are bound and are\n         // behind a dereference projection.\n@@ -902,7 +1012,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n         let fully_matched_with_guard = matched_candidates\n             .iter()\n-            .position(|c| !c.has_guard)\n+            .position(|c| !c.needs_otherwise_block)\n             .unwrap_or(matched_candidates.len() - 1);\n \n         let (reachable_candidates, unreachable_candidates) =\n@@ -914,7 +1024,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             assert!(candidate.otherwise_block.is_none());\n             assert!(candidate.pre_binding_block.is_none());\n             candidate.pre_binding_block = Some(next_prebinding);\n-            if candidate.has_guard {\n+            if candidate.needs_otherwise_block {\n                 next_prebinding = self.cfg.start_new_block();\n                 candidate.otherwise_block = Some(next_prebinding);\n             }\n@@ -932,6 +1042,120 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         reachable_candidates.last_mut().unwrap().otherwise_block\n     }\n \n+    fn test_candidates_with_or(\n+        &mut self,\n+        span: Span,\n+        candidates: &mut [&mut Candidate<'_, 'tcx>],\n+        block: BasicBlock,\n+        otherwise_block: &mut Option<BasicBlock>,\n+        fake_borrows: &mut Option<FxHashSet<Place<'tcx>>>,\n+    ) {\n+        let (first_candidate, remaining_candidates) = candidates.split_first_mut().unwrap();\n+\n+        if let PatKind::Or { .. } = *first_candidate.match_pairs[0].pattern.kind {\n+            let match_pairs = mem::take(&mut first_candidate.match_pairs);\n+            first_candidate.needs_otherwise_block = true;\n+            first_candidate.pre_binding_block = Some(block);\n+\n+            // We sort or-patterns to the end in `simplify_candidate`, so all\n+            // the remaining match pairs are or-patterns.\n+            for match_pair in match_pairs {\n+                if let PatKind::Or { ref pats } = *match_pair.pattern.kind {\n+                    let or_span = match_pair.pattern.span;\n+                    let place = &match_pair.place;\n+\n+                    first_candidate.visit_leaves(|leaf_candidate| {\n+                        self.test_or_pattern(leaf_candidate, pats, or_span, place, fake_borrows);\n+                    });\n+                } else {\n+                    bug!(\"Or patterns should have been sorted to the end\");\n+                }\n+            }\n+            let remainder_start =\n+                first_candidate.otherwise_block.unwrap_or_else(|| self.cfg.start_new_block());\n+            self.match_candidates(\n+                span,\n+                remainder_start,\n+                otherwise_block,\n+                remaining_candidates,\n+                fake_borrows,\n+            )\n+        } else {\n+            self.test_candidates(span, candidates, block, otherwise_block, fake_borrows)\n+        }\n+    }\n+\n+    fn test_or_pattern<'pat>(\n+        &mut self,\n+        candidate: &mut Candidate<'pat, 'tcx>,\n+        pats: &'pat [Pat<'tcx>],\n+        or_span: Span,\n+        place: &Place<'tcx>,\n+        fake_borrows: &mut Option<FxHashSet<Place<'tcx>>>,\n+    ) {\n+        debug!(\"test_or_pattern:\\ncandidate={:#?}\\npats={:#?}\", candidate, pats);\n+        let mut or_candidates: Vec<_> = pats\n+            .iter()\n+            .map(|pat| {\n+                let new_match_pair = smallvec![MatchPair { pattern: pat, place: place.clone() }];\n+                Candidate {\n+                    span: pat.span,\n+                    has_guard: candidate.has_guard,\n+                    needs_otherwise_block: candidate.needs_otherwise_block,\n+                    match_pairs: new_match_pair,\n+                    bindings: Vec::new(),\n+                    ascriptions: Vec::new(),\n+                    otherwise_block: None,\n+                    pre_binding_block: None,\n+                    next_candidate_pre_binding_block: None,\n+                    subcandidates: Vec::new(),\n+                }\n+            })\n+            .collect();\n+        let mut or_candidate_refs: Vec<_> = or_candidates.iter_mut().collect();\n+        self.match_candidates(\n+            or_span,\n+            candidate.pre_binding_block.unwrap(),\n+            &mut candidate.otherwise_block,\n+            &mut or_candidate_refs,\n+            fake_borrows,\n+        );\n+        candidate.subcandidates = or_candidates;\n+        self.merge_trivial_subcandidates(candidate, self.source_info(or_span));\n+    }\n+\n+    /// Try to merge all of the subcandidates of the given candidate into one.\n+    /// This avoids exponentially large CFGs in cases like `(1 | 2, 3 | 4, ...)`.\n+    fn merge_trivial_subcandidates(\n+        &mut self,\n+        candidate: &mut Candidate<'_, 'tcx>,\n+        source_info: SourceInfo,\n+    ) {\n+        if candidate.subcandidates.is_empty() {\n+            return;\n+        }\n+        let mut can_merge = !candidate.has_guard;\n+\n+        // Not `Iterator::all` because we don't want to short-circuit.\n+        for subcandidate in &mut candidate.subcandidates {\n+            self.merge_trivial_subcandidates(subcandidate, source_info);\n+\n+            // FIXME(or_patterns; matthewjasper) Try to be more aggressive here.\n+            can_merge &= subcandidate.subcandidates.is_empty()\n+                && subcandidate.bindings.is_empty()\n+                && subcandidate.ascriptions.is_empty();\n+        }\n+\n+        if can_merge {\n+            let any_matches = self.cfg.start_new_block();\n+            for subcandidate in mem::take(&mut candidate.subcandidates) {\n+                let or_block = subcandidate.pre_binding_block.unwrap();\n+                self.cfg.goto(or_block, source_info, any_matches);\n+            }\n+            candidate.pre_binding_block = Some(any_matches);\n+        }\n+    }\n+\n     /// This is the most subtle part of the matching algorithm. At\n     /// this point, the input candidates have been fully simplified,\n     /// and so we know that all remaining match-pairs require some\n@@ -1258,6 +1482,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     fn bind_and_guard_matched_candidate<'pat>(\n         &mut self,\n         candidate: Candidate<'pat, 'tcx>,\n+        parent_bindings: &[(Vec<Binding<'tcx>>, Vec<Ascription<'tcx>>)],\n         guard: Option<(&Guard<'tcx>, region::Scope)>,\n         fake_borrows: &Vec<(Place<'tcx>, Local)>,\n         scrutinee_span: Span,\n@@ -1281,7 +1506,13 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             block = fresh_block;\n         }\n \n-        self.ascribe_types(block, &candidate.ascriptions);\n+        self.ascribe_types(\n+            block,\n+            parent_bindings\n+                .iter()\n+                .flat_map(|(_, ascriptions)| ascriptions)\n+                .chain(&candidate.ascriptions),\n+        );\n \n         // rust-lang/rust#27282: The `autoref` business deserves some\n         // explanation here.\n@@ -1365,14 +1596,14 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         //      reference to that.\n         if let Some((guard, region_scope)) = guard {\n             let tcx = self.hir.tcx();\n+            let bindings = parent_bindings\n+                .iter()\n+                .flat_map(|(bindings, _)| bindings)\n+                .chain(&candidate.bindings);\n \n-            self.bind_matched_candidate_for_guard(block, &candidate.bindings);\n+            self.bind_matched_candidate_for_guard(block, bindings.clone());\n             let guard_frame = GuardFrame {\n-                locals: candidate\n-                    .bindings\n-                    .iter()\n-                    .map(|b| GuardFrameLocal::new(b.var_id, b.binding_mode))\n-                    .collect(),\n+                locals: bindings.map(|b| GuardFrameLocal::new(b.var_id, b.binding_mode)).collect(),\n             };\n             debug!(\"entering guard building context: {:?}\", guard_frame);\n             self.guard_context.push(guard_frame);\n@@ -1446,9 +1677,14 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             // ```\n             //\n             // and that is clearly not correct.\n-            let by_value_bindings = candidate.bindings.iter().filter(|binding| {\n-                if let BindingMode::ByValue = binding.binding_mode { true } else { false }\n-            });\n+            let by_value_bindings =\n+                parent_bindings\n+                    .iter()\n+                    .flat_map(|(bindings, _)| bindings)\n+                    .chain(&candidate.bindings)\n+                    .filter(|binding| {\n+                        if let BindingMode::ByValue = binding.binding_mode { true } else { false }\n+                    });\n             // Read all of the by reference bindings to ensure that the\n             // place they refer to can't be modified by the guard.\n             for binding in by_value_bindings.clone() {\n@@ -1460,18 +1696,29 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n             post_guard_block\n         } else {\n-            assert!(candidate.otherwise_block.is_none());\n             // (Here, it is not too early to bind the matched\n             // candidate on `block`, because there is no guard result\n             // that we have to inspect before we bind them.)\n-            self.bind_matched_candidate_for_arm_body(block, &candidate.bindings);\n+            self.bind_matched_candidate_for_arm_body(\n+                block,\n+                parent_bindings\n+                    .iter()\n+                    .flat_map(|(bindings, _)| bindings)\n+                    .chain(&candidate.bindings),\n+            );\n             block\n         }\n     }\n \n     /// Append `AscribeUserType` statements onto the end of `block`\n     /// for each ascription\n-    fn ascribe_types(&mut self, block: BasicBlock, ascriptions: &[Ascription<'tcx>]) {\n+    fn ascribe_types<'b>(\n+        &mut self,\n+        block: BasicBlock,\n+        ascriptions: impl IntoIterator<Item = &'b Ascription<'tcx>>,\n+    ) where\n+        'tcx: 'b,\n+    {\n         for ascription in ascriptions {\n             let source_info = self.source_info(ascription.span);\n \n@@ -1498,14 +1745,21 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n-    fn bind_matched_candidate_for_guard(&mut self, block: BasicBlock, bindings: &[Binding<'tcx>]) {\n-        debug!(\"bind_matched_candidate_for_guard(block={:?}, bindings={:?})\", block, bindings);\n+    fn bind_matched_candidate_for_guard<'b>(\n+        &mut self,\n+        block: BasicBlock,\n+        bindings: impl IntoIterator<Item = &'b Binding<'tcx>>,\n+    ) where\n+        'tcx: 'b,\n+    {\n+        debug!(\"bind_matched_candidate_for_guard(block={:?})\", block);\n \n         // Assign each of the bindings. Since we are binding for a\n         // guard expression, this will never trigger moves out of the\n         // candidate.\n         let re_erased = self.hir.tcx().lifetimes.re_erased;\n         for binding in bindings {\n+            debug!(\"bind_matched_candidate_for_guard(binding={:?})\", binding);\n             let source_info = self.source_info(binding.span);\n \n             // For each pattern ident P of type T, `ref_for_guard` is"}, {"sha": "3a806ab6bff0ae1cfb3abab36156fa4592f08413", "filename": "src/librustc_mir_build/build/matches/simplify.rs", "status": "modified", "additions": 56, "deletions": 2, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/5cc4352bc4f9789d7243e79684b2943d3d9ad450/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cc4352bc4f9789d7243e79684b2943d3d9ad450/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Fsimplify.rs?ref=5cc4352bc4f9789d7243e79684b2943d3d9ad450", "patch": "@@ -16,18 +16,40 @@ use crate::build::matches::{Ascription, Binding, Candidate, MatchPair};\n use crate::build::Builder;\n use crate::hair::{self, *};\n use rustc::mir::interpret::truncate;\n+use rustc::mir::Place;\n use rustc::ty;\n use rustc::ty::layout::{Integer, IntegerExt, Size};\n use rustc_attr::{SignedInt, UnsignedInt};\n use rustc_hir::RangeEnd;\n \n+use smallvec::smallvec;\n use std::mem;\n \n impl<'a, 'tcx> Builder<'a, 'tcx> {\n-    crate fn simplify_candidate<'pat>(&mut self, candidate: &mut Candidate<'pat, 'tcx>) {\n+    /// Simplify a candidate so that all match pairs require a test.\n+    ///\n+    /// This method will also split a candidate where the only match-pair is an\n+    /// or-pattern into multiple candidates. This is so that\n+    ///\n+    /// match x {\n+    ///     0 | 1 => { ... },\n+    ///     2 | 3 => { ... },\n+    /// }\n+    ///\n+    /// only generates a single switch. If this happens this method returns\n+    /// `true`.\n+    crate fn simplify_candidate<'pat>(&mut self, candidate: &mut Candidate<'pat, 'tcx>) -> bool {\n         // repeatedly simplify match pairs until fixed point is reached\n         loop {\n             let match_pairs = mem::take(&mut candidate.match_pairs);\n+\n+            if let [MatchPair { pattern: Pat { kind: box PatKind::Or { pats }, .. }, ref place }] =\n+                *match_pairs\n+            {\n+                candidate.subcandidates = self.create_or_subcanidates(candidate, place, pats);\n+                return true;\n+            }\n+\n             let mut changed = false;\n             for match_pair in match_pairs {\n                 match self.simplify_match_pair(match_pair, candidate) {\n@@ -40,11 +62,43 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 }\n             }\n             if !changed {\n-                return; // if we were not able to simplify any, done.\n+                // Move or-patterns to the end, because they can result in us\n+                // creating additional candidates, so we want to test them as\n+                // late as possible.\n+                candidate\n+                    .match_pairs\n+                    .sort_by_key(|pair| matches!(*pair.pattern.kind, PatKind::Or { .. }));\n+                return false; // if we were not able to simplify any, done.\n             }\n         }\n     }\n \n+    fn create_or_subcanidates<'pat>(\n+        &mut self,\n+        candidate: &Candidate<'pat, 'tcx>,\n+        place: &Place<'tcx>,\n+        pats: &'pat [Pat<'tcx>],\n+    ) -> Vec<Candidate<'pat, 'tcx>> {\n+        pats.iter()\n+            .map(|pat| {\n+                let mut candidate = Candidate {\n+                    span: pat.span,\n+                    has_guard: candidate.has_guard,\n+                    needs_otherwise_block: candidate.needs_otherwise_block,\n+                    match_pairs: smallvec![MatchPair { place: place.clone(), pattern: pat }],\n+                    bindings: vec![],\n+                    ascriptions: vec![],\n+                    subcandidates: vec![],\n+                    otherwise_block: None,\n+                    pre_binding_block: None,\n+                    next_candidate_pre_binding_block: None,\n+                };\n+                self.simplify_candidate(&mut candidate);\n+                candidate\n+            })\n+            .collect()\n+    }\n+\n     /// Tries to simplify `match_pair`, returning `Ok(())` if\n     /// successful. If successful, new match pairs and bindings will\n     /// have been pushed into the candidate. If no simplification is"}, {"sha": "ff95f162257517a6288f0d2acfb890cf116b1712", "filename": "src/librustc_mir_build/build/matches/test.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5cc4352bc4f9789d7243e79684b2943d3d9ad450/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cc4352bc4f9789d7243e79684b2943d3d9ad450/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Ftest.rs?ref=5cc4352bc4f9789d7243e79684b2943d3d9ad450", "patch": "@@ -70,11 +70,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 }\n             }\n \n-            PatKind::Or { .. } => self\n-                .hir\n-                .tcx()\n-                .sess\n-                .span_fatal(match_pair.pattern.span, \"or-patterns are not fully implemented yet\"),\n+            PatKind::Or { .. } => bug!(\"or-patterns should have already been handled\"),\n \n             PatKind::AscribeUserType { .. }\n             | PatKind::Array { .. }"}, {"sha": "cb93ba7c9250f3b31c216b6f48f3d71f972aaca5", "filename": "src/librustc_mir_build/hair/mod.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5cc4352bc4f9789d7243e79684b2943d3d9ad450/src%2Flibrustc_mir_build%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cc4352bc4f9789d7243e79684b2943d3d9ad450/src%2Flibrustc_mir_build%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fmod.rs?ref=5cc4352bc4f9789d7243e79684b2943d3d9ad450", "patch": "@@ -315,17 +315,6 @@ crate struct Arm<'tcx> {\n     crate span: Span,\n }\n \n-impl<'tcx> Arm<'tcx> {\n-    // HACK(or_patterns; Centril | dlrobertson): Remove this and\n-    // correctly handle each case in which this method is used.\n-    crate fn top_pats_hack(&self) -> &[Pat<'tcx>] {\n-        match &*self.pattern.kind {\n-            PatKind::Or { pats } => pats,\n-            _ => std::slice::from_ref(&self.pattern),\n-        }\n-    }\n-}\n-\n #[derive(Clone, Debug)]\n crate enum Guard<'tcx> {\n     If(ExprRef<'tcx>),"}]}