{"sha": "d611800a70e6f620b5f96d8509899377a784b364", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ2MTE4MDBhNzBlNmY2MjBiNWY5NmQ4NTA5ODk5Mzc3YTc4NGIzNjQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-05T05:01:49Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-05T05:01:49Z"}, "message": "auto merge of #15284 : apoelstra/rust/bitv-methods, r=cmr\n\nThe types `Bitv` and `BitvSet` are badly out of date. This PR:\r\n- cleans up the code (primarily, simplifies `Bitv` and implements `BitvSet` in terms of `Bitv`)\r\n- implements several new traits for `Bitv`\r\n- adds new functionality to `Bitv` and `BitvSet`\r\n- replaces internal iterators with external ones\r\n- updates documentation\r\n- minor bug fixes\r\n\r\nThis is a significantly souped-up version of PR #15139 and is the result of the discussion there.", "tree": {"sha": "7e6e1aed74ce36843bb36a545e2c998bfd85b069", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7e6e1aed74ce36843bb36a545e2c998bfd85b069"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d611800a70e6f620b5f96d8509899377a784b364", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d611800a70e6f620b5f96d8509899377a784b364", "html_url": "https://github.com/rust-lang/rust/commit/d611800a70e6f620b5f96d8509899377a784b364", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d611800a70e6f620b5f96d8509899377a784b364/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "29d6a8ecc6f43bac7171267993ef07dfdf528281", "url": "https://api.github.com/repos/rust-lang/rust/commits/29d6a8ecc6f43bac7171267993ef07dfdf528281", "html_url": "https://github.com/rust-lang/rust/commit/29d6a8ecc6f43bac7171267993ef07dfdf528281"}, {"sha": "8ef0165a56bc788968fcec6debb510b58134f0d9", "url": "https://api.github.com/repos/rust-lang/rust/commits/8ef0165a56bc788968fcec6debb510b58134f0d9", "html_url": "https://github.com/rust-lang/rust/commit/8ef0165a56bc788968fcec6debb510b58134f0d9"}], "stats": {"total": 1337, "additions": 692, "deletions": 645}, "files": [{"sha": "6d7c91ccfee775931a47c4d4afa8095d69a2cec0", "filename": "src/libcollections/bitv.rs", "status": "modified", "additions": 689, "deletions": 642, "changes": 1331, "blob_url": "https://github.com/rust-lang/rust/blob/d611800a70e6f620b5f96d8509899377a784b364/src%2Flibcollections%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d611800a70e6f620b5f96d8509899377a784b364/src%2Flibcollections%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbitv.rs?ref=d611800a70e6f620b5f96d8509899377a784b364", "patch": "@@ -15,7 +15,7 @@ use core::prelude::*;\n use core::cmp;\n use core::default::Default;\n use core::fmt;\n-use core::iter::{Enumerate, Repeat, Map, Zip};\n+use core::iter::Take;\n use core::ops;\n use core::slice;\n use core::uint;\n@@ -24,219 +24,14 @@ use std::hash;\n use {Collection, Mutable, Set, MutableSet};\n use vec::Vec;\n \n-#[deriving(Clone)]\n-struct SmallBitv {\n-    /// only the lowest nbits of this value are used. the rest is undefined.\n-    bits: uint\n-}\n-\n-/// a mask that has a 1 for each defined bit in a small_bitv, assuming n bits\n-#[inline]\n-fn small_mask(nbits: uint) -> uint {\n-    (1 << nbits) - 1\n-}\n-\n-impl SmallBitv {\n-    fn new(bits: uint) -> SmallBitv {\n-        SmallBitv {bits: bits}\n-    }\n-\n-    #[inline]\n-    fn bits_op(&mut self,\n-                   right_bits: uint,\n-                   nbits: uint,\n-                   f: |uint, uint| -> uint)\n-                   -> bool {\n-        let mask = small_mask(nbits);\n-        let old_b: uint = self.bits;\n-        let new_b = f(old_b, right_bits);\n-        self.bits = new_b;\n-        mask & old_b != mask & new_b\n-    }\n-\n-    #[inline]\n-    fn union(&mut self, s: &SmallBitv, nbits: uint) -> bool {\n-        self.bits_op(s.bits, nbits, |u1, u2| u1 | u2)\n-    }\n-\n-    #[inline]\n-    fn intersect(&mut self, s: &SmallBitv, nbits: uint) -> bool {\n-        self.bits_op(s.bits, nbits, |u1, u2| u1 & u2)\n-    }\n-\n-    #[inline]\n-    fn become(&mut self, s: &SmallBitv, nbits: uint) -> bool {\n-        self.bits_op(s.bits, nbits, |_u1, u2| u2)\n-    }\n-\n-    #[inline]\n-    fn difference(&mut self, s: &SmallBitv, nbits: uint) -> bool {\n-        self.bits_op(s.bits, nbits, |u1, u2| u1 & !u2)\n-    }\n-\n-    #[inline]\n-    fn get(&self, i: uint) -> bool {\n-        (self.bits & (1 << i)) != 0\n-    }\n-\n-    #[inline]\n-    fn set(&mut self, i: uint, x: bool) {\n-        if x {\n-            self.bits |= 1<<i;\n-        }\n-        else {\n-            self.bits &= !(1<<i);\n-        }\n-    }\n-\n-    #[inline]\n-    fn equals(&self, b: &SmallBitv, nbits: uint) -> bool {\n-        let mask = small_mask(nbits);\n-        mask & self.bits == mask & b.bits\n-    }\n-\n-    #[inline]\n-    fn clear(&mut self) { self.bits = 0; }\n-\n-    #[inline]\n-    fn set_all(&mut self) { self.bits = !0; }\n-\n-    #[inline]\n-    fn all(&self, nbits: uint) -> bool {\n-        small_mask(nbits) & !self.bits == 0\n-    }\n-\n-    #[inline]\n-    fn none(&self, nbits: uint) -> bool {\n-        small_mask(nbits) & self.bits == 0\n-    }\n-\n-    #[inline]\n-    fn negate(&mut self) { self.bits = !self.bits; }\n-}\n-\n-#[deriving(Clone)]\n-struct BigBitv {\n-    storage: Vec<uint>\n-}\n-\n-/**\n- * A mask that has a 1 for each defined bit in the n'th element of a `BigBitv`,\n- * assuming n bits.\n- */\n-#[inline]\n-fn big_mask(nbits: uint, elem: uint) -> uint {\n-    let rmd = nbits % uint::BITS;\n-    let nelems = nbits/uint::BITS + if rmd == 0 {0} else {1};\n-\n-    if elem < nelems - 1 || rmd == 0 {\n-        !0\n-    } else {\n-        (1 << rmd) - 1\n-    }\n-}\n-\n-impl BigBitv {\n-    fn new(storage: Vec<uint>) -> BigBitv {\n-        BigBitv {storage: storage}\n-    }\n-\n-    #[inline]\n-    fn process(&mut self,\n-                   b: &BigBitv,\n-                   nbits: uint,\n-                   op: |uint, uint| -> uint)\n-                   -> bool {\n-        let len = b.storage.len();\n-        assert_eq!(self.storage.len(), len);\n-        let mut changed = false;\n-        for (i, (a, b)) in self.storage.mut_iter()\n-                               .zip(b.storage.iter())\n-                               .enumerate() {\n-            let mask = big_mask(nbits, i);\n-            let w0 = *a & mask;\n-            let w1 = *b & mask;\n-            let w = op(w0, w1) & mask;\n-            if w0 != w {\n-                changed = true;\n-                *a = w;\n-            }\n-        }\n-        changed\n-    }\n-\n-    #[inline]\n-    fn each_storage(&mut self, op: |v: &mut uint| -> bool) -> bool {\n-        self.storage.mut_iter().advance(|elt| op(elt))\n-    }\n-\n-    #[inline]\n-    fn negate(&mut self) {\n-        self.each_storage(|w| { *w = !*w; true });\n-    }\n-\n-    #[inline]\n-    fn union(&mut self, b: &BigBitv, nbits: uint) -> bool {\n-        self.process(b, nbits, |w1, w2| w1 | w2)\n-    }\n-\n-    #[inline]\n-    fn intersect(&mut self, b: &BigBitv, nbits: uint) -> bool {\n-        self.process(b, nbits, |w1, w2| w1 & w2)\n-    }\n-\n-    #[inline]\n-    fn become(&mut self, b: &BigBitv, nbits: uint) -> bool {\n-        self.process(b, nbits, |_, w| w)\n-    }\n-\n-    #[inline]\n-    fn difference(&mut self, b: &BigBitv, nbits: uint) -> bool {\n-        self.process(b, nbits, |w1, w2| w1 & !w2)\n-    }\n-\n-    #[inline]\n-    fn get(&self, i: uint) -> bool {\n-        let w = i / uint::BITS;\n-        let b = i % uint::BITS;\n-        let x = 1 & self.storage.get(w) >> b;\n-        x == 1\n-    }\n-\n-    #[inline]\n-    fn set(&mut self, i: uint, x: bool) {\n-        let w = i / uint::BITS;\n-        let b = i % uint::BITS;\n-        let flag = 1 << b;\n-        *self.storage.get_mut(w) = if x { *self.storage.get(w) | flag }\n-                          else { *self.storage.get(w) & !flag };\n-    }\n-\n-    #[inline]\n-    fn equals(&self, b: &BigBitv, nbits: uint) -> bool {\n-        for (i, elt) in b.storage.iter().enumerate() {\n-            let mask = big_mask(nbits, i);\n-            if mask & *self.storage.get(i) != mask & *elt {\n-                return false;\n-            }\n-        }\n-        true\n-    }\n-}\n-\n-#[deriving(Clone)]\n-enum BitvVariant { Big(BigBitv), Small(SmallBitv) }\n-\n-enum Op {Union, Intersect, Assign, Difference}\n-\n /// The bitvector type\n ///\n /// # Example\n ///\n /// ```rust\n /// use collections::bitv::Bitv;\n ///\n-/// let mut bv = Bitv::new(10, false);\n+/// let mut bv = Bitv::with_capacity(10, false);\n ///\n /// // insert all primes less than 10\n /// bv.set(2, true);\n@@ -256,71 +51,94 @@ enum Op {Union, Intersect, Assign, Difference}\n /// println!(\"{}\", bv.to_str());\n /// println!(\"total bits set to true: {}\", bv.iter().filter(|x| *x).count());\n /// ```\n-#[deriving(Clone)]\n pub struct Bitv {\n-    /// Internal representation of the bit vector (small or large)\n-    rep: BitvVariant,\n+    /// Internal representation of the bit vector\n+    storage: Vec<uint>,\n     /// The number of valid bits in the internal representation\n     nbits: uint\n }\n \n-fn die() -> ! {\n-    fail!(\"Tried to do operation on bit vectors with different sizes\");\n+struct MaskWords<'a> {\n+    iter: slice::Items<'a, uint>,\n+    next_word: Option<&'a uint>,\n+    last_word_mask: uint,\n+    offset: uint\n }\n \n-impl Bitv {\n+impl<'a> Iterator<(uint, uint)> for MaskWords<'a> {\n+    /// Returns (offset, word)\n     #[inline]\n-    fn do_op(&mut self, op: Op, other: &Bitv) -> bool {\n-        if self.nbits != other.nbits {\n-            die();\n-        }\n-        match self.rep {\n-          Small(ref mut s) => match other.rep {\n-            Small(ref s1) => match op {\n-              Union      => s.union(s1,      self.nbits),\n-              Intersect  => s.intersect(s1,  self.nbits),\n-              Assign     => s.become(s1,     self.nbits),\n-              Difference => s.difference(s1, self.nbits)\n+    fn next<'a>(&'a mut self) -> Option<(uint, uint)> {\n+        let ret = self.next_word;\n+        match ret {\n+            Some(&w) => {\n+                self.next_word = self.iter.next();\n+                self.offset += 1;\n+                // The last word may need to be masked\n+                if self.next_word.is_none() {\n+                    Some((self.offset - 1, w & self.last_word_mask))\n+                } else {\n+                    Some((self.offset - 1, w))\n+                }\n             },\n-            Big(_) => die()\n-          },\n-          Big(ref mut s) => match other.rep {\n-            Small(_) => die(),\n-            Big(ref s1) => match op {\n-              Union      => s.union(s1,      self.nbits),\n-              Intersect  => s.intersect(s1,  self.nbits),\n-              Assign     => s.become(s1,     self.nbits),\n-              Difference => s.difference(s1, self.nbits)\n-            }\n-          }\n+            None => None\n         }\n     }\n }\n \n impl Bitv {\n-    /// Creates an empty Bitv that holds `nbits` elements, setting each element\n+    #[inline]\n+    fn process(&mut self, other: &Bitv, op: |uint, uint| -> uint) -> bool {\n+        let len = other.storage.len();\n+        assert_eq!(self.storage.len(), len);\n+        let mut changed = false;\n+        // Notice: `a` is *not* masked here, which is fine as long as\n+        // `op` is a bitwise operation, since any bits that should've\n+        // been masked were fine to change anyway. `b` is masked to\n+        // make sure its unmasked bits do not cause damage.\n+        for (a, (_, b)) in self.storage.mut_iter()\n+                           .zip(other.mask_words(0)) {\n+            let w = op(*a, b);\n+            if *a != w {\n+                changed = true;\n+                *a = w;\n+            }\n+        }\n+        changed\n+    }\n+\n+    #[inline]\n+    fn mask_words<'a>(&'a self, mut start: uint) -> MaskWords<'a> {\n+        if start > self.storage.len() {\n+            start = self.storage.len();\n+        }\n+        let mut iter = self.storage.slice_from(start).iter();\n+        MaskWords {\n+          next_word: iter.next(),\n+          iter: iter,\n+          last_word_mask: {\n+              let rem = self.nbits % uint::BITS;\n+              if rem > 0 {\n+                  (1 << rem) - 1\n+              } else { !0 }\n+          },\n+          offset: start\n+        }\n+    }\n+\n+    /// Creates an empty Bitv\n+    pub fn new() -> Bitv {\n+        Bitv { storage: Vec::new(), nbits: 0 }\n+    }\n+\n+    /// Creates a Bitv that holds `nbits` elements, setting each element\n     /// to `init`.\n-    pub fn new(nbits: uint, init: bool) -> Bitv {\n-        let rep = if nbits < uint::BITS {\n-            Small(SmallBitv::new(if init {(1<<nbits)-1} else {0}))\n-        } else if nbits == uint::BITS {\n-            Small(SmallBitv::new(if init {!0} else {0}))\n-        } else {\n-            let exact = nbits % uint::BITS == 0;\n-            let nelems = nbits/uint::BITS + if exact {0} else {1};\n-            let s =\n-                if init {\n-                    if exact {\n-                        Vec::from_elem(nelems, !0u)\n-                    } else {\n-                        let mut v = Vec::from_elem(nelems-1, !0u);\n-                        v.push((1<<nbits % uint::BITS)-1);\n-                        v\n-                    }\n-                } else { Vec::from_elem(nelems, 0u)};\n-            Big(BigBitv::new(s))\n-        };\n-        Bitv {rep: rep, nbits: nbits}\n+    pub fn with_capacity(nbits: uint, init: bool) -> Bitv {\n+        Bitv {\n+            storage: Vec::from_elem((nbits + uint::BITS - 1) / uint::BITS,\n+                                    if init { !0u } else { 0u }),\n+            nbits: nbits\n+        }\n     }\n \n     /**\n@@ -330,7 +148,9 @@ impl Bitv {\n      * the same length. Returns `true` if `self` changed.\n     */\n     #[inline]\n-    pub fn union(&mut self, v1: &Bitv) -> bool { self.do_op(Union, v1) }\n+    pub fn union(&mut self, other: &Bitv) -> bool {\n+        self.process(other, |w1, w2| w1 | w2)\n+    }\n \n     /**\n      * Calculates the intersection of two bitvectors\n@@ -339,27 +159,18 @@ impl Bitv {\n      * must be the same length. Returns `true` if `self` changed.\n     */\n     #[inline]\n-    pub fn intersect(&mut self, v1: &Bitv) -> bool {\n-        self.do_op(Intersect, v1)\n+    pub fn intersect(&mut self, other: &Bitv) -> bool {\n+        self.process(other, |w1, w2| w1 & w2)\n     }\n \n-    /**\n-     * Assigns the value of `v1` to `self`\n-     *\n-     * Both bitvectors must be the same length. Returns `true` if `self` was\n-     * changed\n-     */\n-    #[inline]\n-    pub fn assign(&mut self, v: &Bitv) -> bool { self.do_op(Assign, v) }\n-\n     /// Retrieve the value at index `i`\n     #[inline]\n     pub fn get(&self, i: uint) -> bool {\n-        assert!((i < self.nbits));\n-        match self.rep {\n-            Big(ref b)   => b.get(i),\n-            Small(ref s) => s.get(i)\n-        }\n+        assert!(i < self.nbits);\n+        let w = i / uint::BITS;\n+        let b = i % uint::BITS;\n+        let x = self.storage.get(w) & (1 << b);\n+        x != 0\n     }\n \n     /**\n@@ -369,42 +180,24 @@ impl Bitv {\n      */\n     #[inline]\n     pub fn set(&mut self, i: uint, x: bool) {\n-      assert!((i < self.nbits));\n-      match self.rep {\n-        Big(ref mut b)   => b.set(i, x),\n-        Small(ref mut s) => s.set(i, x)\n-      }\n-    }\n-\n-    /// Set all bits to 0\n-    #[inline]\n-    pub fn clear(&mut self) {\n-        match self.rep {\n-            Small(ref mut b) => b.clear(),\n-            Big(ref mut s) => {\n-                s.each_storage(|w| { *w = 0u; true });\n-            }\n-        }\n+        assert!(i < self.nbits);\n+        let w = i / uint::BITS;\n+        let b = i % uint::BITS;\n+        let flag = 1 << b;\n+        *self.storage.get_mut(w) = if x { *self.storage.get(w) | flag }\n+                          else { *self.storage.get(w) & !flag };\n     }\n \n     /// Set all bits to 1\n     #[inline]\n     pub fn set_all(&mut self) {\n-        match self.rep {\n-            Small(ref mut b) => b.set_all(),\n-            Big(ref mut s) => {\n-                s.each_storage(|w| { *w = !0u; true });\n-            }\n-        }\n+        for w in self.storage.mut_iter() { *w = !0u; }\n     }\n \n     /// Flip all bits\n     #[inline]\n     pub fn negate(&mut self) {\n-        match self.rep {\n-            Small(ref mut s) => s.negate(),\n-            Big(ref mut b) => b.negate(),\n-        }\n+        for w in self.storage.mut_iter() { *w = !*w; }\n     }\n \n     /**\n@@ -417,17 +210,19 @@ impl Bitv {\n      * Returns `true` if `v0` was changed.\n      */\n     #[inline]\n-    pub fn difference(&mut self, v: &Bitv) -> bool {\n-        self.do_op(Difference, v)\n+    pub fn difference(&mut self, other: &Bitv) -> bool {\n+        self.process(other, |w1, w2| w1 & !w2)\n     }\n \n     /// Returns `true` if all bits are 1\n     #[inline]\n     pub fn all(&self) -> bool {\n-      match self.rep {\n-        Small(ref b) => b.all(self.nbits),\n-        _ => self.iter().all(|x| x)\n-      }\n+        let mut last_word = !0u;\n+        // Check that every word but the last is all-ones...\n+        self.mask_words(0).all(|(_, elem)|\n+            { let tmp = last_word; last_word = elem; tmp == !0u }) &&\n+        // ...and that the last word is ones as far as it needs to be\n+        (last_word == ((1 << self.nbits % uint::BITS) - 1) || last_word == !0u)\n     }\n \n     /// Returns an iterator over the elements of the vector in order.\n@@ -436,7 +231,7 @@ impl Bitv {\n     ///\n     /// ```rust\n     /// use collections::bitv::Bitv;\n-    /// let mut bv = Bitv::new(10, false);\n+    /// let mut bv = Bitv::with_capacity(10, false);\n     /// bv.set(1, true);\n     /// bv.set(2, true);\n     /// bv.set(3, true);\n@@ -452,10 +247,7 @@ impl Bitv {\n \n     /// Returns `true` if all bits are 0\n     pub fn none(&self) -> bool {\n-      match self.rep {\n-        Small(ref b) => b.none(self.nbits),\n-        _ => self.iter().all(|x| !x)\n-      }\n+        self.mask_words(0).all(|(_, w)| w == 0)\n     }\n \n     #[inline]\n@@ -464,15 +256,6 @@ impl Bitv {\n         !self.none()\n     }\n \n-    /**\n-     * Converts `self` to a vector of `uint` with the same length.\n-     *\n-     * Each `uint` in the resulting vector has either value `0u` or `1u`.\n-     */\n-    pub fn to_vec(&self) -> Vec<uint> {\n-        Vec::from_fn(self.nbits, |i| if self.get(i) { 1 } else { 0 })\n-    }\n-\n     /**\n      * Organise the bits into bytes, such that the first bit in the\n      * `Bitv` becomes the high-order bit of the first byte. If the\n@@ -503,13 +286,6 @@ impl Bitv {\n         )\n     }\n \n-    /**\n-     * Transform `self` into a `Vec<bool>` by turning each bit into a `bool`.\n-     */\n-    pub fn to_bools(&self) -> Vec<bool> {\n-        Vec::from_fn(self.nbits, |i| self[i])\n-    }\n-\n     /**\n      * Compare a bitvector to a vector of `bool`.\n      *\n@@ -525,10 +301,131 @@ impl Bitv {\n         true\n     }\n \n-    pub fn ones(&self, f: |uint| -> bool) -> bool {\n-        range(0u, self.nbits).advance(|i| !self.get(i) || f(i))\n+    /// Shorten a Bitv, dropping excess elements.\n+    ///\n+    /// If `len` is greater than the vector's current length, this has no\n+    /// effect.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// use collections::bitv::Bitv;\n+    /// let mut bvec: Bitv = vec![false, true, true, false].iter().map(|n| *n).collect();\n+    /// let expected: Bitv = vec![false, true].iter().map(|n| *n).collect();\n+    /// bvec.truncate(2);\n+    /// assert_eq!(bvec, expected);\n+    /// ```\n+    pub fn truncate(&mut self, len: uint) {\n+        if len < self.len() {\n+            self.nbits = len;\n+            let word_len = (len + uint::BITS - 1) / uint::BITS;\n+            self.storage.truncate(word_len);\n+            if len % uint::BITS > 0 {\n+                let mask = (1 << len % uint::BITS) - 1;\n+                *self.storage.get_mut(word_len - 1) &= mask;\n+            }\n+        }\n+    }\n+\n+    /// Grows the vector to be able to store `size` bits without resizing\n+    pub fn reserve(&mut self, size: uint) {\n+        let old_size = self.storage.len();\n+        let size = (size + uint::BITS - 1) / uint::BITS;\n+        if old_size < size {\n+            self.storage.grow(size - old_size, &0);\n+        }\n+    }\n+\n+    /// Returns the capacity in bits for this bit vector. Inserting any\n+    /// element less than this amount will not trigger a resizing.\n+    #[inline]\n+    pub fn capacity(&self) -> uint {\n+        self.storage.len() * uint::BITS\n     }\n \n+    /// Grows the `Bitv` in-place.\n+    ///\n+    /// Adds `n` copies of `value` to the `Bitv`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// use collections::bitv::Bitv;\n+    /// let mut bvec: Bitv = vec![false, true, true, false].iter().map(|n| *n).collect();\n+    /// bvec.grow(2, true);\n+    /// assert_eq!(bvec, vec![false, true, true, false, true, true].iter().map(|n| *n).collect());\n+    /// ```\n+    pub fn grow(&mut self, n: uint, value: bool) {\n+        let new_nbits = self.nbits + n;\n+        let new_nwords = (new_nbits + uint::BITS - 1) / uint::BITS;\n+        let full_value = if value { !0 } else { 0 };\n+        // Correct the old tail word\n+        let old_last_word = (self.nbits + uint::BITS - 1) / uint::BITS - 1;\n+        if self.nbits % uint::BITS > 0 {\n+            let overhang = self.nbits % uint::BITS; // # of already-used bits\n+            let mask = !((1 << overhang) - 1);  // e.g. 5 unused bits => 111110....0\n+            if value {\n+                *self.storage.get_mut(old_last_word) |= mask;\n+            } else {\n+                *self.storage.get_mut(old_last_word) &= !mask;\n+            }\n+        }\n+        // Fill in words after the old tail word\n+        let stop_idx = cmp::min(self.storage.len(), new_nwords);\n+        for idx in range(old_last_word + 1, stop_idx) {\n+            *self.storage.get_mut(idx) = full_value;\n+        }\n+        // Allocate new words, if needed\n+        if new_nwords > self.storage.len() {\n+          let to_add = new_nwords - self.storage.len();\n+          self.storage.grow(to_add, &full_value);\n+        }\n+        // Adjust internal bit count\n+        self.nbits = new_nbits;\n+    }\n+\n+    /// Shorten a `Bitv` by one, returning the removed element\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// use collections::bitv::Bitv;\n+    /// let mut bvec: Bitv = vec![false, true, true, false].iter().map(|n| *n).collect();\n+    /// let expected: Bitv = vec![false, true, true].iter().map(|n| *n).collect();\n+    /// let popped = bvec.pop();\n+    /// assert_eq!(popped, false);\n+    /// assert_eq!(bvec, expected);\n+    /// ```\n+    pub fn pop(&mut self) -> bool {\n+        let ret = self.get(self.nbits - 1);\n+        // If we are unusing a whole word, make sure it is zeroed out\n+        if self.nbits % uint::BITS == 1 {\n+            *self.storage.get_mut(self.nbits / uint::BITS) = 0;\n+        }\n+        self.nbits -= 1;\n+        ret\n+    }\n+\n+    /// Pushes a `bool` onto the `Bitv`\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// use collections::bitv::Bitv;\n+    /// let prototype: Bitv = vec![false, true, true, false].iter().map(|n| *n).collect();\n+    /// let mut bvec: Bitv = vec![false, true].iter().map(|n| *n).collect();\n+    /// bvec.push(true);\n+    /// bvec.push(false);\n+    /// assert_eq!(prototype, bvec);\n+    /// ```\n+    pub fn push(&mut self, elem: bool) {\n+        let insert_pos = self.nbits;\n+        self.nbits += 1;\n+        if self.storage.len() * uint::BITS < self.nbits {\n+            self.storage.push(0);\n+        }\n+        self.set(insert_pos, elem);\n+    }\n }\n \n /**\n@@ -544,26 +441,71 @@ pub fn from_bytes(bytes: &[u8]) -> Bitv {\n     })\n }\n \n-/**\n- * Transform a `[bool]` into a `Bitv` by converting each `bool` into a bit.\n- */\n-pub fn from_bools(bools: &[bool]) -> Bitv {\n-    from_fn(bools.len(), |i| bools[i])\n-}\n-\n /**\n  * Create a `Bitv` of the specified length where the value at each\n  * index is `f(index)`.\n  */\n pub fn from_fn(len: uint, f: |index: uint| -> bool) -> Bitv {\n-    let mut bitv = Bitv::new(len, false);\n+    let mut bitv = Bitv::with_capacity(len, false);\n     for i in range(0u, len) {\n         bitv.set(i, f(i));\n     }\n     bitv\n }\n \n+impl Default for Bitv {\n+    #[inline]\n+    fn default() -> Bitv { Bitv::new() }\n+}\n+\n+impl Collection for Bitv {\n+    #[inline]\n+    fn len(&self) -> uint { self.nbits }\n+}\n+\n+impl Mutable for Bitv {\n+    #[inline]\n+    fn clear(&mut self) {\n+        for w in self.storage.mut_iter() { *w = 0u; }\n+    }\n+}\n+\n+impl FromIterator<bool> for Bitv {\n+    fn from_iter<I:Iterator<bool>>(iterator: I) -> Bitv {\n+        let mut ret = Bitv::new();\n+        ret.extend(iterator);\n+        ret\n+    }\n+}\n+\n+impl Extendable<bool> for Bitv {\n+    #[inline]\n+    fn extend<I: Iterator<bool>>(&mut self, mut iterator: I) {\n+        let (min, _) = iterator.size_hint();\n+        let nbits = self.nbits;\n+        self.reserve(nbits + min);\n+        for element in iterator {\n+            self.push(element)\n+        }\n+    }\n+}\n+\n+impl Clone for Bitv {\n+    #[inline]\n+    fn clone(&self) -> Bitv {\n+        Bitv { storage: self.storage.clone(), nbits: self.nbits }\n+    }\n+\n+    #[inline]\n+    fn clone_from(&mut self, source: &Bitv) {\n+        self.nbits = source.nbits;\n+        self.storage.reserve(source.storage.len());\n+        for (i, w) in self.storage.mut_iter().enumerate() { *w = *source.storage.get(i); }\n+    }\n+}\n+\n impl ops::Index<uint,bool> for Bitv {\n+    #[inline]\n     fn index(&self, i: &uint) -> bool {\n         self.get(*i)\n     }\n@@ -581,51 +523,24 @@ impl fmt::Show for Bitv {\n impl<S: hash::Writer> hash::Hash<S> for Bitv {\n     fn hash(&self, state: &mut S) {\n         self.nbits.hash(state);\n-        match self.rep {\n-            Small(ref s) => (s.bits & small_mask(self.nbits)).hash(state),\n-            Big(ref b) => {\n-                for (i, ele) in b.storage.iter().enumerate() {\n-                    (ele & big_mask(self.nbits, i)).hash(state);\n-                }\n-            }\n+        for (_, elem) in self.mask_words(0) {\n+            elem.hash(state);\n         }\n     }\n }\n \n impl cmp::PartialEq for Bitv {\n     #[inline]\n     fn eq(&self, other: &Bitv) -> bool {\n-        if self.nbits != other.nbits { return false; }\n-        match self.rep {\n-            Small(ref b) => match other.rep {\n-                Small(ref b1) => b.equals(b1, self.nbits),\n-                _ => false\n-            },\n-            Big(ref s) => match other.rep {\n-                Big(ref s1) => s.equals(s1, self.nbits),\n-                Small(_) => return false\n-            }\n+        if self.nbits != other.nbits {\n+            return false;\n         }\n+        self.mask_words(0).zip(other.mask_words(0)).all(|((_, w1), (_, w2))| w1 == w2)\n     }\n }\n \n impl cmp::Eq for Bitv {}\n \n-#[inline]\n-fn iterate_bits(base: uint, bits: uint, f: |uint| -> bool) -> bool {\n-    if bits == 0 {\n-        return true;\n-    }\n-    for i in range(0u, uint::BITS) {\n-        if bits & (1 << i) != 0 {\n-            if !f(base + i) {\n-                return false;\n-            }\n-        }\n-    }\n-    return true;\n-}\n-\n /// An iterator for `Bitv`.\n pub struct Bits<'a> {\n     bitv: &'a Bitv,\n@@ -687,15 +602,8 @@ impl<'a> RandomAccessIterator<bool> for Bits<'a> {\n /// It should also be noted that the amount of storage necessary for holding a\n /// set of objects is proportional to the maximum of the objects when viewed\n /// as a `uint`.\n-#[deriving(Clone)]\n-pub struct BitvSet {\n-    size: uint,\n-\n-    // In theory this is a `Bitv` instead of always a `BigBitv`, but knowing that\n-    // there's an array of storage makes our lives a whole lot easier when\n-    // performing union/intersection/etc operations\n-    bitv: BigBitv\n-}\n+#[deriving(Clone, PartialEq, Eq)]\n+pub struct BitvSet(Bitv);\n \n impl Default for BitvSet {\n     #[inline]\n@@ -704,143 +612,168 @@ impl Default for BitvSet {\n \n impl BitvSet {\n     /// Creates a new bit vector set with initially no contents\n+    #[inline]\n     pub fn new() -> BitvSet {\n-        BitvSet{ size: 0, bitv: BigBitv::new(vec!(0)) }\n+        BitvSet(Bitv::new())\n+    }\n+\n+    /// Creates a new bit vector set with initially no contents, able to\n+    /// hold `nbits` elements without resizing\n+    #[inline]\n+    pub fn with_capacity(nbits: uint) -> BitvSet {\n+        BitvSet(Bitv::with_capacity(nbits, false))\n     }\n \n     /// Creates a new bit vector set from the given bit vector\n+    #[inline]\n     pub fn from_bitv(bitv: Bitv) -> BitvSet {\n-        let mut size = 0;\n-        bitv.ones(|_| {\n-            size += 1;\n-            true\n-        });\n-        let Bitv{rep, ..} = bitv;\n-        match rep {\n-            Big(b) => BitvSet{ size: size, bitv: b },\n-            Small(SmallBitv{bits}) =>\n-                BitvSet{ size: size, bitv: BigBitv{ storage: vec!(bits) } },\n-        }\n+        BitvSet(bitv)\n     }\n \n     /// Returns the capacity in bits for this bit vector. Inserting any\n     /// element less than this amount will not trigger a resizing.\n-    pub fn capacity(&self) -> uint { self.bitv.storage.len() * uint::BITS }\n+    #[inline]\n+    pub fn capacity(&self) -> uint {\n+        let &BitvSet(ref bitv) = self;\n+        bitv.capacity()\n+    }\n+\n+    /// Grows the underlying vector to be able to store `size` bits\n+    pub fn reserve(&mut self, size: uint) {\n+        let &BitvSet(ref mut bitv) = self;\n+        bitv.reserve(size)\n+    }\n \n     /// Consumes this set to return the underlying bit vector\n+    #[inline]\n     pub fn unwrap(self) -> Bitv {\n-        let cap = self.capacity();\n-        let BitvSet{bitv, ..} = self;\n-        return Bitv{ nbits:cap, rep: Big(bitv) };\n+        let BitvSet(bitv) = self;\n+        bitv\n+    }\n+\n+    /// Returns a reference to the underlying bit vector\n+    #[inline]\n+    pub fn get_ref<'a>(&'a self) -> &'a Bitv {\n+        let &BitvSet(ref bitv) = self;\n+        bitv\n+    }\n+\n+    /// Returns a mutable reference to the underlying bit vector\n+    #[inline]\n+    pub fn get_mut_ref<'a>(&'a mut self) -> &'a mut Bitv {\n+        let &BitvSet(ref mut bitv) = self;\n+        bitv\n     }\n \n     #[inline]\n     fn other_op(&mut self, other: &BitvSet, f: |uint, uint| -> uint) {\n-        fn nbits(mut w: uint) -> uint {\n-            let mut bits = 0;\n-            for _ in range(0u, uint::BITS) {\n-                if w == 0 {\n-                    break;\n-                }\n-                bits += w & 1;\n-                w >>= 1;\n-            }\n-            return bits;\n-        }\n-        if self.capacity() < other.capacity() {\n-            self.bitv.storage.grow(other.capacity() / uint::BITS, &0);\n-        }\n-        for (i, &w) in other.bitv.storage.iter().enumerate() {\n-            let old = *self.bitv.storage.get(i);\n+        // Unwrap Bitvs\n+        let &BitvSet(ref mut self_bitv) = self;\n+        let &BitvSet(ref other_bitv) = other;\n+        // Expand the vector if necessary\n+        self_bitv.reserve(other_bitv.capacity());\n+        // Apply values\n+        for (i, w) in other_bitv.mask_words(0) {\n+            let old = *self_bitv.storage.get(i);\n             let new = f(old, w);\n-            *self.bitv.storage.get_mut(i) = new;\n-            self.size += nbits(new) - nbits(old);\n+            *self_bitv.storage.get_mut(i) = new;\n         }\n     }\n \n+    #[inline]\n+    /// Truncate the underlying vector to the least length required\n+    pub fn shrink_to_fit(&mut self) {\n+        let &BitvSet(ref mut bitv) = self;\n+        // Obtain original length\n+        let old_len = bitv.storage.len();\n+        // Obtain coarse trailing zero length\n+        let n = bitv.storage.iter().rev().take_while(|&&n| n == 0).count();\n+        // Truncate\n+        let trunc_len = cmp::max(old_len - n, 1);\n+        bitv.storage.truncate(trunc_len);\n+        bitv.nbits = trunc_len * uint::BITS;\n+    }\n+\n     /// Union in-place with the specified other bit vector\n+    #[inline]\n     pub fn union_with(&mut self, other: &BitvSet) {\n         self.other_op(other, |w1, w2| w1 | w2);\n     }\n \n     /// Intersect in-place with the specified other bit vector\n+    #[inline]\n     pub fn intersect_with(&mut self, other: &BitvSet) {\n         self.other_op(other, |w1, w2| w1 & w2);\n     }\n \n     /// Difference in-place with the specified other bit vector\n+    #[inline]\n     pub fn difference_with(&mut self, other: &BitvSet) {\n         self.other_op(other, |w1, w2| w1 & !w2);\n     }\n \n     /// Symmetric difference in-place with the specified other bit vector\n+    #[inline]\n     pub fn symmetric_difference_with(&mut self, other: &BitvSet) {\n         self.other_op(other, |w1, w2| w1 ^ w2);\n     }\n \n+    /// Iterator over each uint stored in the BitvSet\n+    #[inline]\n     pub fn iter<'a>(&'a self) -> BitPositions<'a> {\n         BitPositions {set: self, next_idx: 0}\n     }\n \n-    pub fn difference(&self, other: &BitvSet, f: |&uint| -> bool) -> bool {\n-        for (i, w1, w2) in self.commons(other) {\n-            if !iterate_bits(i, w1 & !w2, |b| f(&b)) {\n-                return false\n-            }\n-        };\n-        /* everything we have that they don't also shows up */\n-        self.outliers(other).advance(|(mine, i, w)|\n-            !mine || iterate_bits(i, w, |b| f(&b))\n-        )\n-    }\n-\n-    pub fn symmetric_difference(&self, other: &BitvSet, f: |&uint| -> bool)\n-                                -> bool {\n-        for (i, w1, w2) in self.commons(other) {\n-            if !iterate_bits(i, w1 ^ w2, |b| f(&b)) {\n-                return false\n-            }\n-        };\n-        self.outliers(other).advance(|(_, i, w)| iterate_bits(i, w, |b| f(&b)))\n-    }\n-\n-    pub fn intersection(&self, other: &BitvSet, f: |&uint| -> bool) -> bool {\n-        self.commons(other).advance(|(i, w1, w2)| iterate_bits(i, w1 & w2, |b| f(&b)))\n+    /// Iterator over each uint stored in the `self` setminus `other`\n+    #[inline]\n+    pub fn difference<'a>(&'a self, other: &'a BitvSet) -> TwoBitPositions<'a> {\n+        TwoBitPositions {\n+            set: self,\n+            other: other,\n+            merge: |w1, w2| w1 & !w2,\n+            current_word: 0,\n+            next_idx: 0\n+        }\n     }\n \n-    pub fn union(&self, other: &BitvSet, f: |&uint| -> bool) -> bool {\n-        for (i, w1, w2) in self.commons(other) {\n-            if !iterate_bits(i, w1 | w2, |b| f(&b)) {\n-                return false\n-            }\n-        };\n-        self.outliers(other).advance(|(_, i, w)| iterate_bits(i, w, |b| f(&b)))\n+    /// Iterator over each uint stored in the symmetric difference of `self` and `other`\n+    #[inline]\n+    pub fn symmetric_difference<'a>(&'a self, other: &'a BitvSet) -> TwoBitPositions<'a> {\n+        TwoBitPositions {\n+            set: self,\n+            other: other,\n+            merge: |w1, w2| w1 ^ w2,\n+            current_word: 0,\n+            next_idx: 0\n+        }\n     }\n-}\n \n-impl cmp::PartialEq for BitvSet {\n-    fn eq(&self, other: &BitvSet) -> bool {\n-        if self.size != other.size {\n-            return false;\n-        }\n-        for (_, w1, w2) in self.commons(other) {\n-            if w1 != w2 {\n-                return false;\n-            }\n-        }\n-        for (_, _, w) in self.outliers(other) {\n-            if w != 0 {\n-                return false;\n-            }\n+    /// Iterator over each uint stored in `self` intersect `other`\n+    #[inline]\n+    pub fn intersection<'a>(&'a self, other: &'a BitvSet) -> Take<TwoBitPositions<'a>> {\n+        let min = cmp::min(self.capacity(), other.capacity());\n+        TwoBitPositions {\n+            set: self,\n+            other: other,\n+            merge: |w1, w2| w1 & w2,\n+            current_word: 0,\n+            next_idx: 0\n+        }.take(min)\n+    }\n+\n+    /// Iterator over each uint stored in `self` union `other`\n+    #[inline]\n+    pub fn union<'a>(&'a self, other: &'a BitvSet) -> TwoBitPositions<'a> {\n+        TwoBitPositions {\n+            set: self,\n+            other: other,\n+            merge: |w1, w2| w1 | w2,\n+            current_word: 0,\n+            next_idx: 0\n         }\n-        return true;\n     }\n-\n-    fn ne(&self, other: &BitvSet) -> bool { !self.eq(other) }\n }\n \n-impl cmp::Eq for BitvSet {}\n-\n impl fmt::Show for BitvSet {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(fmt, \"{{\"));\n@@ -866,44 +799,45 @@ impl<S: hash::Writer> hash::Hash<S> for BitvSet {\n \n impl Collection for BitvSet {\n     #[inline]\n-    fn len(&self) -> uint { self.size }\n+    fn len(&self) -> uint  {\n+        let &BitvSet(ref bitv) = self;\n+        bitv.storage.iter().fold(0, |acc, &n| acc + n.count_ones())\n+    }\n }\n \n impl Mutable for BitvSet {\n+    #[inline]\n     fn clear(&mut self) {\n-        self.bitv.each_storage(|w| { *w = 0; true });\n-        self.size = 0;\n+        let &BitvSet(ref mut bitv) = self;\n+        bitv.clear();\n     }\n }\n \n impl Set<uint> for BitvSet {\n+    #[inline]\n     fn contains(&self, value: &uint) -> bool {\n-        *value < self.bitv.storage.len() * uint::BITS && self.bitv.get(*value)\n+        let &BitvSet(ref bitv) = self;\n+        *value < bitv.nbits && bitv.get(*value)\n     }\n \n+    #[inline]\n     fn is_disjoint(&self, other: &BitvSet) -> bool {\n-        self.intersection(other, |_| false)\n+        self.intersection(other).count() > 0\n     }\n \n+    #[inline]\n     fn is_subset(&self, other: &BitvSet) -> bool {\n-        for (_, w1, w2) in self.commons(other) {\n-            if w1 & w2 != w1 {\n-                return false;\n-            }\n-        }\n-        /* If anything is not ours, then everything is not ours so we're\n-           definitely a subset in that case. Otherwise if there's any stray\n-           ones that 'other' doesn't have, we're not a subset. */\n-        for (mine, _, w) in self.outliers(other) {\n-            if !mine {\n-                return true;\n-            } else if w != 0 {\n-                return false;\n-            }\n-        }\n-        return true;\n+        let &BitvSet(ref self_bitv) = self;\n+        let &BitvSet(ref other_bitv) = other;\n+\n+        // Check that `self` intersect `other` is self\n+        self_bitv.mask_words(0).zip(other_bitv.mask_words(0))\n+                               .all(|((_, w1), (_, w2))| w1 & w2 == w1) &&\n+        // Check that `self` setminus `other` is empty\n+        self_bitv.mask_words(other_bitv.storage.len()).all(|(_, w)| w == 0)\n     }\n \n+    #[inline]\n     fn is_superset(&self, other: &BitvSet) -> bool {\n         other.is_subset(self)\n     }\n@@ -914,81 +848,48 @@ impl MutableSet<uint> for BitvSet {\n         if self.contains(&value) {\n             return false;\n         }\n-        let nbits = self.capacity();\n-        if value >= nbits {\n-            let newsize = cmp::max(value, nbits * 2) / uint::BITS + 1;\n-            assert!(newsize > self.bitv.storage.len());\n-            self.bitv.storage.grow(newsize, &0);\n+        if value >= self.capacity() {\n+            let new_cap = cmp::max(value + 1, self.capacity() * 2);\n+            self.reserve(new_cap);\n+        }\n+        let &BitvSet(ref mut bitv) = self;\n+        if value >= bitv.nbits {\n+            // If we are increasing nbits, make sure we mask out any previously-unconsidered bits\n+            let old_rem = bitv.nbits % uint::BITS;\n+            if old_rem != 0 {\n+                let old_last_word = (bitv.nbits + uint::BITS - 1) / uint::BITS - 1;\n+                *bitv.storage.get_mut(old_last_word) &= (1 << old_rem) - 1;\n+            }\n+            bitv.nbits = value + 1;\n         }\n-        self.size += 1;\n-        self.bitv.set(value, true);\n+        bitv.set(value, true);\n         return true;\n     }\n \n     fn remove(&mut self, value: &uint) -> bool {\n         if !self.contains(value) {\n             return false;\n         }\n-        self.size -= 1;\n-        self.bitv.set(*value, false);\n-\n-        // Attempt to truncate our storage\n-        let mut i = self.bitv.storage.len();\n-        while i > 1 && *self.bitv.storage.get(i - 1) == 0 {\n-            i -= 1;\n-        }\n-        self.bitv.storage.truncate(i);\n-\n+        let &BitvSet(ref mut bitv) = self;\n+        bitv.set(*value, false);\n         return true;\n     }\n }\n \n-impl BitvSet {\n-    /// Visits each of the words that the two bit vectors (`self` and `other`)\n-    /// both have in common. The three yielded arguments are (bit location,\n-    /// w1, w2) where the bit location is the number of bits offset so far,\n-    /// and w1/w2 are the words coming from the two vectors self, other.\n-    fn commons<'a>(&'a self, other: &'a BitvSet)\n-        -> Map<'static, ((uint, &'a uint), &'a Vec<uint>), (uint, uint, uint),\n-               Zip<Enumerate<slice::Items<'a, uint>>, Repeat<&'a Vec<uint>>>> {\n-        let min = cmp::min(self.bitv.storage.len(), other.bitv.storage.len());\n-        self.bitv.storage.slice(0, min).iter().enumerate()\n-            .zip(Repeat::new(&other.bitv.storage))\n-            .map(|((i, &w), o_store)| (i * uint::BITS, w, *o_store.get(i)))\n-    }\n-\n-    /// Visits each word in `self` or `other` that extends beyond the other. This\n-    /// will only iterate through one of the vectors, and it only iterates\n-    /// over the portion that doesn't overlap with the other one.\n-    ///\n-    /// The yielded arguments are a `bool`, the bit offset, and a word. The `bool`\n-    /// is true if the word comes from `self`, and `false` if it comes from\n-    /// `other`.\n-    fn outliers<'a>(&'a self, other: &'a BitvSet)\n-        -> Map<'static, ((uint, &'a uint), uint), (bool, uint, uint),\n-               Zip<Enumerate<slice::Items<'a, uint>>, Repeat<uint>>> {\n-        let slen = self.bitv.storage.len();\n-        let olen = other.bitv.storage.len();\n-\n-        if olen < slen {\n-            self.bitv.storage.slice_from(olen).iter().enumerate()\n-                .zip(Repeat::new(olen))\n-                .map(|((i, &w), min)| (true, (i + min) * uint::BITS, w))\n-        } else {\n-            other.bitv.storage.slice_from(slen).iter().enumerate()\n-                .zip(Repeat::new(slen))\n-                .map(|((i, &w), min)| (false, (i + min) * uint::BITS, w))\n-        }\n-    }\n+pub struct BitPositions<'a> {\n+    set: &'a BitvSet,\n+    next_idx: uint\n }\n \n-pub struct BitPositions<'a> {\n+pub struct TwoBitPositions<'a> {\n     set: &'a BitvSet,\n+    other: &'a BitvSet,\n+    merge: |uint, uint|: 'a -> uint,\n+    current_word: uint,\n     next_idx: uint\n }\n \n impl<'a> Iterator<uint> for BitPositions<'a> {\n-    #[inline]\n     fn next(&mut self) -> Option<uint> {\n         while self.next_idx < self.set.capacity() {\n             let idx = self.next_idx;\n@@ -1002,11 +903,47 @@ impl<'a> Iterator<uint> for BitPositions<'a> {\n         return None;\n     }\n \n+    #[inline]\n     fn size_hint(&self) -> (uint, Option<uint>) {\n         (0, Some(self.set.capacity() - self.next_idx))\n     }\n }\n \n+impl<'a> Iterator<uint> for TwoBitPositions<'a> {\n+    fn next(&mut self) -> Option<uint> {\n+        while self.next_idx < self.set.capacity() ||\n+              self.next_idx < self.other.capacity() {\n+            let bit_idx = self.next_idx % uint::BITS;\n+            if bit_idx == 0 {\n+                let &BitvSet(ref s_bitv) = self.set;\n+                let &BitvSet(ref o_bitv) = self.other;\n+                // Merging the two words is a bit of an awkward dance since\n+                // one Bitv might be longer than the other\n+                let word_idx = self.next_idx / uint::BITS;\n+                let w1 = if word_idx < s_bitv.storage.len() {\n+                             *s_bitv.storage.get(word_idx)\n+                         } else { 0 };\n+                let w2 = if word_idx < o_bitv.storage.len() {\n+                             *o_bitv.storage.get(word_idx)\n+                         } else { 0 };\n+                self.current_word = (self.merge)(w1, w2);\n+            }\n+\n+            self.next_idx += 1;\n+            if self.current_word & (1 << bit_idx) != 0 {\n+                return Some(self.next_idx - 1);\n+            }\n+        }\n+        return None;\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        let cap = cmp::max(self.set.capacity(), self.other.capacity());\n+        (0, Some(cap - self.next_idx))\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use std::prelude::*;\n@@ -1016,40 +953,39 @@ mod tests {\n     use test::Bencher;\n \n     use {Set, Mutable, MutableSet};\n-    use bitv::{Bitv, SmallBitv, BigBitv, BitvSet, from_bools, from_fn,\n-               from_bytes};\n+    use bitv::{Bitv, BitvSet, from_fn, from_bytes};\n     use bitv;\n     use vec::Vec;\n \n     static BENCH_BITS : uint = 1 << 14;\n \n     #[test]\n     fn test_to_str() {\n-        let zerolen = Bitv::new(0u, false);\n+        let zerolen = Bitv::new();\n         assert_eq!(zerolen.to_str().as_slice(), \"\");\n \n-        let eightbits = Bitv::new(8u, false);\n+        let eightbits = Bitv::with_capacity(8u, false);\n         assert_eq!(eightbits.to_str().as_slice(), \"00000000\")\n     }\n \n     #[test]\n     fn test_0_elements() {\n-        let act = Bitv::new(0u, false);\n+        let act = Bitv::new();\n         let exp = Vec::from_elem(0u, false);\n         assert!(act.eq_vec(exp.as_slice()));\n     }\n \n     #[test]\n     fn test_1_element() {\n-        let mut act = Bitv::new(1u, false);\n+        let mut act = Bitv::with_capacity(1u, false);\n         assert!(act.eq_vec([false]));\n-        act = Bitv::new(1u, true);\n+        act = Bitv::with_capacity(1u, true);\n         assert!(act.eq_vec([true]));\n     }\n \n     #[test]\n     fn test_2_elements() {\n-        let mut b = bitv::Bitv::new(2, false);\n+        let mut b = bitv::Bitv::with_capacity(2, false);\n         b.set(0, true);\n         b.set(1, false);\n         assert_eq!(b.to_str().as_slice(), \"10\");\n@@ -1060,16 +996,16 @@ mod tests {\n         let mut act;\n         // all 0\n \n-        act = Bitv::new(10u, false);\n+        act = Bitv::with_capacity(10u, false);\n         assert!((act.eq_vec(\n                     [false, false, false, false, false, false, false, false, false, false])));\n         // all 1\n \n-        act = Bitv::new(10u, true);\n+        act = Bitv::with_capacity(10u, true);\n         assert!((act.eq_vec([true, true, true, true, true, true, true, true, true, true])));\n         // mixed\n \n-        act = Bitv::new(10u, false);\n+        act = Bitv::with_capacity(10u, false);\n         act.set(0u, true);\n         act.set(1u, true);\n         act.set(2u, true);\n@@ -1078,7 +1014,7 @@ mod tests {\n         assert!((act.eq_vec([true, true, true, true, true, false, false, false, false, false])));\n         // mixed\n \n-        act = Bitv::new(10u, false);\n+        act = Bitv::with_capacity(10u, false);\n         act.set(5u, true);\n         act.set(6u, true);\n         act.set(7u, true);\n@@ -1087,7 +1023,7 @@ mod tests {\n         assert!((act.eq_vec([false, false, false, false, false, true, true, true, true, true])));\n         // mixed\n \n-        act = Bitv::new(10u, false);\n+        act = Bitv::with_capacity(10u, false);\n         act.set(0u, true);\n         act.set(3u, true);\n         act.set(6u, true);\n@@ -1100,21 +1036,21 @@ mod tests {\n         let mut act;\n         // all 0\n \n-        act = Bitv::new(31u, false);\n+        act = Bitv::with_capacity(31u, false);\n         assert!(act.eq_vec(\n                 [false, false, false, false, false, false, false, false, false, false, false,\n                 false, false, false, false, false, false, false, false, false, false, false, false,\n                 false, false, false, false, false, false, false, false]));\n         // all 1\n \n-        act = Bitv::new(31u, true);\n+        act = Bitv::with_capacity(31u, true);\n         assert!(act.eq_vec(\n                 [true, true, true, true, true, true, true, true, true, true, true, true, true,\n                 true, true, true, true, true, true, true, true, true, true, true, true, true, true,\n                 true, true, true, true]));\n         // mixed\n \n-        act = Bitv::new(31u, false);\n+        act = Bitv::with_capacity(31u, false);\n         act.set(0u, true);\n         act.set(1u, true);\n         act.set(2u, true);\n@@ -1129,7 +1065,7 @@ mod tests {\n                 false, false, false, false, false, false]));\n         // mixed\n \n-        act = Bitv::new(31u, false);\n+        act = Bitv::with_capacity(31u, false);\n         act.set(16u, true);\n         act.set(17u, true);\n         act.set(18u, true);\n@@ -1144,7 +1080,7 @@ mod tests {\n                 false, false, false, false, false, false, false]));\n         // mixed\n \n-        act = Bitv::new(31u, false);\n+        act = Bitv::with_capacity(31u, false);\n         act.set(24u, true);\n         act.set(25u, true);\n         act.set(26u, true);\n@@ -1158,7 +1094,7 @@ mod tests {\n                 false, true, true, true, true, true, true, true]));\n         // mixed\n \n-        act = Bitv::new(31u, false);\n+        act = Bitv::with_capacity(31u, false);\n         act.set(3u, true);\n         act.set(17u, true);\n         act.set(30u, true);\n@@ -1173,21 +1109,21 @@ mod tests {\n         let mut act;\n         // all 0\n \n-        act = Bitv::new(32u, false);\n+        act = Bitv::with_capacity(32u, false);\n         assert!(act.eq_vec(\n                 [false, false, false, false, false, false, false, false, false, false, false,\n                 false, false, false, false, false, false, false, false, false, false, false, false,\n                 false, false, false, false, false, false, false, false, false]));\n         // all 1\n \n-        act = Bitv::new(32u, true);\n+        act = Bitv::with_capacity(32u, true);\n         assert!(act.eq_vec(\n                 [true, true, true, true, true, true, true, true, true, true, true, true, true,\n                 true, true, true, true, true, true, true, true, true, true, true, true, true, true,\n                 true, true, true, true, true]));\n         // mixed\n \n-        act = Bitv::new(32u, false);\n+        act = Bitv::with_capacity(32u, false);\n         act.set(0u, true);\n         act.set(1u, true);\n         act.set(2u, true);\n@@ -1202,7 +1138,7 @@ mod tests {\n                 false, false, false, false, false, false, false]));\n         // mixed\n \n-        act = Bitv::new(32u, false);\n+        act = Bitv::with_capacity(32u, false);\n         act.set(16u, true);\n         act.set(17u, true);\n         act.set(18u, true);\n@@ -1217,7 +1153,7 @@ mod tests {\n                 false, false, false, false, false, false, false, false]));\n         // mixed\n \n-        act = Bitv::new(32u, false);\n+        act = Bitv::with_capacity(32u, false);\n         act.set(24u, true);\n         act.set(25u, true);\n         act.set(26u, true);\n@@ -1232,7 +1168,7 @@ mod tests {\n                 false, true, true, true, true, true, true, true, true]));\n         // mixed\n \n-        act = Bitv::new(32u, false);\n+        act = Bitv::with_capacity(32u, false);\n         act.set(3u, true);\n         act.set(17u, true);\n         act.set(30u, true);\n@@ -1248,21 +1184,21 @@ mod tests {\n         let mut act;\n         // all 0\n \n-        act = Bitv::new(33u, false);\n+        act = Bitv::with_capacity(33u, false);\n         assert!(act.eq_vec(\n                 [false, false, false, false, false, false, false, false, false, false, false,\n                 false, false, false, false, false, false, false, false, false, false, false, false,\n                 false, false, false, false, false, false, false, false, false, false]));\n         // all 1\n \n-        act = Bitv::new(33u, true);\n+        act = Bitv::with_capacity(33u, true);\n         assert!(act.eq_vec(\n                 [true, true, true, true, true, true, true, true, true, true, true, true, true,\n                 true, true, true, true, true, true, true, true, true, true, true, true, true, true,\n                 true, true, true, true, true, true]));\n         // mixed\n \n-        act = Bitv::new(33u, false);\n+        act = Bitv::with_capacity(33u, false);\n         act.set(0u, true);\n         act.set(1u, true);\n         act.set(2u, true);\n@@ -1277,7 +1213,7 @@ mod tests {\n                 false, false, false, false, false, false, false, false]));\n         // mixed\n \n-        act = Bitv::new(33u, false);\n+        act = Bitv::with_capacity(33u, false);\n         act.set(16u, true);\n         act.set(17u, true);\n         act.set(18u, true);\n@@ -1292,7 +1228,7 @@ mod tests {\n                 false, false, false, false, false, false, false, false, false]));\n         // mixed\n \n-        act = Bitv::new(33u, false);\n+        act = Bitv::with_capacity(33u, false);\n         act.set(24u, true);\n         act.set(25u, true);\n         act.set(26u, true);\n@@ -1307,7 +1243,7 @@ mod tests {\n                 false, true, true, true, true, true, true, true, true, false]));\n         // mixed\n \n-        act = Bitv::new(33u, false);\n+        act = Bitv::with_capacity(33u, false);\n         act.set(3u, true);\n         act.set(17u, true);\n         act.set(30u, true);\n@@ -1321,37 +1257,37 @@ mod tests {\n \n     #[test]\n     fn test_equal_differing_sizes() {\n-        let v0 = Bitv::new(10u, false);\n-        let v1 = Bitv::new(11u, false);\n+        let v0 = Bitv::with_capacity(10u, false);\n+        let v1 = Bitv::with_capacity(11u, false);\n         assert!(v0 != v1);\n     }\n \n     #[test]\n     fn test_equal_greatly_differing_sizes() {\n-        let v0 = Bitv::new(10u, false);\n-        let v1 = Bitv::new(110u, false);\n+        let v0 = Bitv::with_capacity(10u, false);\n+        let v1 = Bitv::with_capacity(110u, false);\n         assert!(v0 != v1);\n     }\n \n     #[test]\n     fn test_equal_sneaky_small() {\n-        let mut a = bitv::Bitv::new(1, false);\n+        let mut a = bitv::Bitv::with_capacity(1, false);\n         a.set(0, true);\n \n-        let mut b = bitv::Bitv::new(1, true);\n+        let mut b = bitv::Bitv::with_capacity(1, true);\n         b.set(0, true);\n \n         assert_eq!(a, b);\n     }\n \n     #[test]\n     fn test_equal_sneaky_big() {\n-        let mut a = bitv::Bitv::new(100, false);\n+        let mut a = bitv::Bitv::with_capacity(100, false);\n         for i in range(0u, 100) {\n             a.set(i, true);\n         }\n \n-        let mut b = bitv::Bitv::new(100, true);\n+        let mut b = bitv::Bitv::with_capacity(100, true);\n         for i in range(0u, 100) {\n             b.set(i, true);\n         }\n@@ -1368,32 +1304,33 @@ mod tests {\n \n     #[test]\n     fn test_to_bytes() {\n-        let mut bv = Bitv::new(3, true);\n+        let mut bv = Bitv::with_capacity(3, true);\n         bv.set(1, false);\n         assert_eq!(bv.to_bytes(), vec!(0b10100000));\n \n-        let mut bv = Bitv::new(9, false);\n+        let mut bv = Bitv::with_capacity(9, false);\n         bv.set(2, true);\n         bv.set(8, true);\n         assert_eq!(bv.to_bytes(), vec!(0b00100000, 0b10000000));\n     }\n \n     #[test]\n     fn test_from_bools() {\n-        assert!(from_bools([true, false, true, true]).to_str().as_slice() ==\n-                \"1011\");\n+        let bools = vec![true, false, true, true];\n+        let bitv: Bitv = bools.iter().map(|n| *n).collect();\n+        assert_eq!(bitv.to_str().as_slice(), \"1011\");\n     }\n \n     #[test]\n     fn test_to_bools() {\n         let bools = vec!(false, false, true, false, false, true, true, false);\n-        assert_eq!(from_bytes([0b00100110]).to_bools(), bools);\n+        assert_eq!(from_bytes([0b00100110]).iter().collect::<Vec<bool>>(), bools);\n     }\n \n     #[test]\n     fn test_bitv_iterator() {\n         let bools = [true, false, true, true];\n-        let bitv = from_bools(bools);\n+        let bitv: Bitv = bools.iter().map(|n| *n).collect();\n \n         for (act, &ex) in bitv.iter().zip(bools.iter()) {\n             assert_eq!(ex, act);\n@@ -1403,7 +1340,7 @@ mod tests {\n     #[test]\n     fn test_bitv_set_iterator() {\n         let bools = [true, false, true, true];\n-        let bitv = BitvSet::from_bitv(from_bools(bools));\n+        let bitv = BitvSet::from_bitv(bools.iter().map(|n| *n).collect());\n \n         let idxs: Vec<uint> = bitv.iter().collect();\n         assert_eq!(idxs, vec!(0, 2, 3));\n@@ -1415,7 +1352,7 @@ mod tests {\n         let lengths = [10, 64, 100];\n         for &b in bools.iter() {\n             for &l in lengths.iter() {\n-                let bitset = BitvSet::from_bitv(Bitv::new(l, b));\n+                let bitset = BitvSet::from_bitv(Bitv::with_capacity(l, b));\n                 assert_eq!(bitset.contains(&1u), b)\n                 assert_eq!(bitset.contains(&(l-1u)), b)\n                 assert!(!bitset.contains(&l))\n@@ -1425,8 +1362,8 @@ mod tests {\n \n     #[test]\n     fn test_small_difference() {\n-        let mut b1 = Bitv::new(3, false);\n-        let mut b2 = Bitv::new(3, false);\n+        let mut b1 = Bitv::with_capacity(3, false);\n+        let mut b2 = Bitv::with_capacity(3, false);\n         b1.set(0, true);\n         b1.set(1, true);\n         b2.set(1, true);\n@@ -1439,8 +1376,8 @@ mod tests {\n \n     #[test]\n     fn test_big_difference() {\n-        let mut b1 = Bitv::new(100, false);\n-        let mut b2 = Bitv::new(100, false);\n+        let mut b1 = Bitv::with_capacity(100, false);\n+        let mut b2 = Bitv::with_capacity(100, false);\n         b1.set(0, true);\n         b1.set(40, true);\n         b2.set(40, true);\n@@ -1453,32 +1390,56 @@ mod tests {\n \n     #[test]\n     fn test_small_clear() {\n-        let mut b = Bitv::new(14, true);\n+        let mut b = Bitv::with_capacity(14, true);\n         b.clear();\n-        b.ones(|i| {\n+        BitvSet::from_bitv(b).iter().advance(|i| {\n             fail!(\"found 1 at {:?}\", i)\n         });\n     }\n \n     #[test]\n     fn test_big_clear() {\n-        let mut b = Bitv::new(140, true);\n+        let mut b = Bitv::with_capacity(140, true);\n         b.clear();\n-        b.ones(|i| {\n+        BitvSet::from_bitv(b).iter().advance(|i| {\n             fail!(\"found 1 at {:?}\", i)\n         });\n     }\n \n+    #[test]\n+    fn test_bitv_masking() {\n+        let b = Bitv::with_capacity(140, true);\n+        let mut bs = BitvSet::from_bitv(b);\n+        assert!(bs.contains(&139));\n+        assert!(!bs.contains(&140));\n+        assert!(bs.insert(150));\n+        assert!(!bs.contains(&140));\n+        assert!(!bs.contains(&149));\n+        assert!(bs.contains(&150));\n+        assert!(!bs.contains(&151));\n+    }\n+\n     #[test]\n     fn test_bitv_set_basic() {\n+        // calculate nbits with uint::BITS granularity\n+        fn calc_nbits(bits: uint) -> uint {\n+            uint::BITS * ((bits + uint::BITS - 1) / uint::BITS)\n+        }\n+\n         let mut b = BitvSet::new();\n+        assert_eq!(b.capacity(), calc_nbits(0));\n         assert!(b.insert(3));\n+        assert_eq!(b.capacity(), calc_nbits(3));\n         assert!(!b.insert(3));\n         assert!(b.contains(&3));\n+        assert!(b.insert(4));\n+        assert!(!b.insert(4));\n+        assert!(b.contains(&3));\n         assert!(b.insert(400));\n+        assert_eq!(b.capacity(), calc_nbits(400));\n         assert!(!b.insert(400));\n         assert!(b.contains(&400));\n-        assert_eq!(b.len(), 2);\n+        assert_eq!(b.len(), 3);\n     }\n \n     #[test]\n@@ -1501,8 +1462,8 @@ mod tests {\n \n         let mut i = 0;\n         let expected = [3, 5, 11, 77];\n-        a.intersection(&b, |x| {\n-            assert_eq!(*x, expected[i]);\n+        a.intersection(&b).advance(|x| {\n+            assert_eq!(x, expected[i]);\n             i += 1;\n             true\n         });\n@@ -1525,8 +1486,8 @@ mod tests {\n \n         let mut i = 0;\n         let expected = [1, 5, 500];\n-        a.difference(&b, |x| {\n-            assert_eq!(*x, expected[i]);\n+        a.difference(&b).advance(|x| {\n+            assert_eq!(x, expected[i]);\n             i += 1;\n             true\n         });\n@@ -1551,8 +1512,8 @@ mod tests {\n \n         let mut i = 0;\n         let expected = [1, 5, 11, 14, 220];\n-        a.symmetric_difference(&b, |x| {\n-            assert_eq!(*x, expected[i]);\n+        a.symmetric_difference(&b).advance(|x| {\n+            assert_eq!(x, expected[i]);\n             i += 1;\n             true\n         });\n@@ -1580,14 +1541,40 @@ mod tests {\n \n         let mut i = 0;\n         let expected = [1, 3, 5, 9, 11, 13, 19, 24, 160];\n-        a.union(&b, |x| {\n-            assert_eq!(*x, expected[i]);\n+        a.union(&b).advance(|x| {\n+            assert_eq!(x, expected[i]);\n             i += 1;\n             true\n         });\n         assert_eq!(i, expected.len());\n     }\n \n+    #[test]\n+    fn test_bitv_set_subset() {\n+        let mut set1 = BitvSet::new();\n+        let mut set2 = BitvSet::new();\n+\n+        assert!(set1.is_subset(&set2)); //  {}  {}\n+        set2.insert(100);\n+        assert!(set1.is_subset(&set2)); //  {}  { 1 }\n+        set2.insert(200);\n+        assert!(set1.is_subset(&set2)); //  {}  { 1, 2 }\n+        set1.insert(200);\n+        assert!(set1.is_subset(&set2)); //  { 2 }  { 1, 2 }\n+        set1.insert(300);\n+        assert!(!set1.is_subset(&set2)); // { 2, 3 }  { 1, 2 }\n+        set2.insert(300);\n+        assert!(set1.is_subset(&set2)); // { 2, 3 }  { 1, 2, 3 }\n+        set2.insert(400);\n+        assert!(set1.is_subset(&set2)); // { 2, 3 }  { 1, 2, 3, 4 }\n+        set2.remove(&100);\n+        assert!(set1.is_subset(&set2)); // { 2, 3 }  { 2, 3, 4 }\n+        set2.remove(&300);\n+        assert!(!set1.is_subset(&set2)); // { 2, 3 }  { 2, 4 }\n+        set1.remove(&300);\n+        assert!(set1.is_subset(&set2)); // { 2 }  { 2, 4 }\n+    }\n+\n     #[test]\n     fn test_bitv_remove() {\n         let mut a = BitvSet::new();\n@@ -1600,6 +1587,7 @@ mod tests {\n \n         assert!(a.insert(1000));\n         assert!(a.remove(&1000));\n+        a.shrink_to_fit();\n         assert_eq!(a.capacity(), uint::BITS);\n     }\n \n@@ -1667,6 +1655,97 @@ mod tests {\n         assert!(!v.none());\n     }\n \n+    #[test]\n+    fn test_bitv_push_pop() {\n+        let mut s = Bitv::with_capacity(5 * uint::BITS - 2, false);\n+        assert_eq!(s.len(), 5 * uint::BITS - 2);\n+        assert_eq!(s.get(5 * uint::BITS - 3), false);\n+        s.push(true);\n+        s.push(true);\n+        assert_eq!(s.get(5 * uint::BITS - 2), true);\n+        assert_eq!(s.get(5 * uint::BITS - 1), true);\n+        // Here the internal vector will need to be extended\n+        s.push(false);\n+        assert_eq!(s.get(5 * uint::BITS), false);\n+        s.push(false);\n+        assert_eq!(s.get(5 * uint::BITS + 1), false);\n+        assert_eq!(s.len(), 5 * uint::BITS + 2);\n+        // Pop it all off\n+        assert_eq!(s.pop(), false);\n+        assert_eq!(s.pop(), false);\n+        assert_eq!(s.pop(), true);\n+        assert_eq!(s.pop(), true);\n+        assert_eq!(s.len(), 5 * uint::BITS - 2);\n+    }\n+\n+    #[test]\n+    fn test_bitv_truncate() {\n+        let mut s = Bitv::with_capacity(5 * uint::BITS, true);\n+\n+        assert_eq!(s, Bitv::with_capacity(5 * uint::BITS, true));\n+        assert_eq!(s.len(), 5 * uint::BITS);\n+        s.truncate(4 * uint::BITS);\n+        assert_eq!(s, Bitv::with_capacity(4 * uint::BITS, true));\n+        assert_eq!(s.len(), 4 * uint::BITS);\n+        // Truncating to a size > s.len() should be a noop\n+        s.truncate(5 * uint::BITS);\n+        assert_eq!(s, Bitv::with_capacity(4 * uint::BITS, true));\n+        assert_eq!(s.len(), 4 * uint::BITS);\n+        s.truncate(3 * uint::BITS - 10);\n+        assert_eq!(s, Bitv::with_capacity(3 * uint::BITS - 10, true));\n+        assert_eq!(s.len(), 3 * uint::BITS - 10);\n+        s.truncate(0);\n+        assert_eq!(s, Bitv::with_capacity(0, true));\n+        assert_eq!(s.len(), 0);\n+    }\n+\n+    #[test]\n+    fn test_bitv_reserve() {\n+        let mut s = Bitv::with_capacity(5 * uint::BITS, true);\n+        // Check capacity\n+        assert_eq!(s.capacity(), 5 * uint::BITS);\n+        s.reserve(2 * uint::BITS);\n+        assert_eq!(s.capacity(), 5 * uint::BITS);\n+        s.reserve(7 * uint::BITS);\n+        assert_eq!(s.capacity(), 7 * uint::BITS);\n+        s.reserve(7 * uint::BITS);\n+        assert_eq!(s.capacity(), 7 * uint::BITS);\n+        s.reserve(7 * uint::BITS + 1);\n+        assert_eq!(s.capacity(), 8 * uint::BITS);\n+        // Check that length hasn't changed\n+        assert_eq!(s.len(), 5 * uint::BITS);\n+        s.push(true);\n+        s.push(false);\n+        s.push(true);\n+        assert_eq!(s.get(5 * uint::BITS - 1), true);\n+        assert_eq!(s.get(5 * uint::BITS - 0), true);\n+        assert_eq!(s.get(5 * uint::BITS + 1), false);\n+        assert_eq!(s.get(5 * uint::BITS + 2), true);\n+    }\n+\n+    #[test]\n+    fn test_bitv_grow() {\n+        let mut bitv = from_bytes([0b10110110, 0b00000000, 0b10101010]);\n+        bitv.grow(32, true);\n+        assert_eq!(bitv, from_bytes([0b10110110, 0b00000000, 0b10101010,\n+                                     0xFF, 0xFF, 0xFF, 0xFF]));\n+        bitv.grow(64, false);\n+        assert_eq!(bitv, from_bytes([0b10110110, 0b00000000, 0b10101010,\n+                                     0xFF, 0xFF, 0xFF, 0xFF, 0, 0, 0, 0, 0, 0, 0, 0]));\n+        bitv.grow(16, true);\n+        assert_eq!(bitv, from_bytes([0b10110110, 0b00000000, 0b10101010,\n+                                     0xFF, 0xFF, 0xFF, 0xFF, 0, 0, 0, 0, 0, 0, 0, 0, 0xFF, 0xFF]));\n+    }\n+\n+    #[test]\n+    fn test_bitv_extend() {\n+        let mut bitv = from_bytes([0b10110110, 0b00000000, 0b11111111]);\n+        let ext = from_bytes([0b01001001, 0b10010010, 0b10111101]);\n+        bitv.extend(ext.iter());\n+        assert_eq!(bitv, from_bytes([0b10110110, 0b00000000, 0b11111111,\n+                                     0b01001001, 0b10010010, 0b10111101]));\n+    }\n+\n     #[test]\n     fn test_bitv_set_show() {\n         let mut s = BitvSet::new();\n@@ -1692,42 +1771,10 @@ mod tests {\n         })\n     }\n \n-    #[bench]\n-    fn bench_small_bitv_small(b: &mut Bencher) {\n-        let mut r = rng();\n-        let mut bitv = SmallBitv::new(uint::BITS);\n-        b.iter(|| {\n-            bitv.set((r.next_u32() as uint) % uint::BITS, true);\n-            &bitv\n-        })\n-    }\n-\n-    #[bench]\n-    fn bench_big_bitv_small(b: &mut Bencher) {\n-        let mut r = rng();\n-        let mut bitv = BigBitv::new(vec!(0));\n-        b.iter(|| {\n-            bitv.set((r.next_u32() as uint) % uint::BITS, true);\n-            &bitv\n-        })\n-    }\n-\n-    #[bench]\n-    fn bench_big_bitv_big(b: &mut Bencher) {\n-        let mut r = rng();\n-        let mut storage = vec!();\n-        storage.grow(BENCH_BITS / uint::BITS, &0u);\n-        let mut bitv = BigBitv::new(storage);\n-        b.iter(|| {\n-            bitv.set((r.next_u32() as uint) % BENCH_BITS, true);\n-            &bitv\n-        })\n-    }\n-\n     #[bench]\n     fn bench_bitv_big(b: &mut Bencher) {\n         let mut r = rng();\n-        let mut bitv = Bitv::new(BENCH_BITS, false);\n+        let mut bitv = Bitv::with_capacity(BENCH_BITS, false);\n         b.iter(|| {\n             bitv.set((r.next_u32() as uint) % BENCH_BITS, true);\n             &bitv\n@@ -1737,7 +1784,7 @@ mod tests {\n     #[bench]\n     fn bench_bitv_small(b: &mut Bencher) {\n         let mut r = rng();\n-        let mut bitv = Bitv::new(uint::BITS, false);\n+        let mut bitv = Bitv::with_capacity(uint::BITS, false);\n         b.iter(|| {\n             bitv.set((r.next_u32() as uint) % uint::BITS, true);\n             &bitv\n@@ -1766,16 +1813,16 @@ mod tests {\n \n     #[bench]\n     fn bench_bitv_big_union(b: &mut Bencher) {\n-        let mut b1 = Bitv::new(BENCH_BITS, false);\n-        let b2 = Bitv::new(BENCH_BITS, false);\n+        let mut b1 = Bitv::with_capacity(BENCH_BITS, false);\n+        let b2 = Bitv::with_capacity(BENCH_BITS, false);\n         b.iter(|| {\n             b1.union(&b2);\n         })\n     }\n \n     #[bench]\n     fn bench_btv_small_iter(b: &mut Bencher) {\n-        let bitv = Bitv::new(uint::BITS, false);\n+        let bitv = Bitv::with_capacity(uint::BITS, false);\n         b.iter(|| {\n             let mut _sum = 0;\n             for pres in bitv.iter() {\n@@ -1786,7 +1833,7 @@ mod tests {\n \n     #[bench]\n     fn bench_bitv_big_iter(b: &mut Bencher) {\n-        let bitv = Bitv::new(BENCH_BITS, false);\n+        let bitv = Bitv::with_capacity(BENCH_BITS, false);\n         b.iter(|| {\n             let mut _sum = 0;\n             for pres in bitv.iter() {"}, {"sha": "3823a7033f5a61c536ab9a57ed5a81d5660d8aa7", "filename": "src/test/run-pass/bitv-perf-test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d611800a70e6f620b5f96d8509899377a784b364/src%2Ftest%2Frun-pass%2Fbitv-perf-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d611800a70e6f620b5f96d8509899377a784b364/src%2Ftest%2Frun-pass%2Fbitv-perf-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbitv-perf-test.rs?ref=d611800a70e6f620b5f96d8509899377a784b364", "patch": "@@ -13,8 +13,8 @@ extern crate collections;\n use std::collections::Bitv;\n \n fn bitv_test() {\n-    let mut v1 = box Bitv::new(31, false);\n-    let v2 = box Bitv::new(31, true);\n+    let mut v1 = box Bitv::with_capacity(31, false);\n+    let v2 = box Bitv::with_capacity(31, true);\n     v1.union(v2);\n }\n "}, {"sha": "255807b4c0e6912334626fea79a92ac0edaf8e12", "filename": "src/test/run-pass/issue-11736.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d611800a70e6f620b5f96d8509899377a784b364/src%2Ftest%2Frun-pass%2Fissue-11736.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d611800a70e6f620b5f96d8509899377a784b364/src%2Ftest%2Frun-pass%2Fissue-11736.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-11736.rs?ref=d611800a70e6f620b5f96d8509899377a784b364", "patch": "@@ -16,7 +16,7 @@ use std::collections::Bitv;\n fn main() {\n     // Generate sieve of Eratosthenes for n up to 1e6\n     let n = 1000000u;\n-    let sieve = Bitv::new(n+1, true);\n+    let sieve = Bitv::with_capacity(n+1, true);\n     let limit: uint = (n as f32).sqrt() as uint;\n     for i in range(2, limit+1) {\n         if sieve[i] {"}]}