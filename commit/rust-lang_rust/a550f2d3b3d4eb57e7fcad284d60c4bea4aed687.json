{"sha": "a550f2d3b3d4eb57e7fcad284d60c4bea4aed687", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE1NTBmMmQzYjNkNGViNTdlN2ZjYWQyODRkNjBjNGJlYTRhZWQ2ODc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-11-24T21:50:09Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-11-24T21:50:09Z"}, "message": "Auto merge of #46111 - michaelwoerister:promote-green, r=nikomatsakis\n\nincr.comp.: Make sure we don't lose unused green results from the query cache.\n\nIn its current implementation, the query result cache works by bulk-writing the results of all cacheable queries into a monolithic binary file on disk. Prior to this PR, we would potentially lose query results during this process because only results that had already been loaded into memory were serialized. In contrast, results that were not needed during the given compilation session were not serialized again.\n\nThis PR will do one pass over all green `DepNodes` that represent a cacheable query and execute the corresponding query in order to make sure that the query result gets loaded into memory before cache serialization.\n\nIn the future we might want to look into a serialization format the can be updated in-place so that we don't have to load unchanged results just for immediately storing them again.\n\nr? @nikomatsakis", "tree": {"sha": "a036ae31b754a6c99717680be680bfe5f2bdb5d3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a036ae31b754a6c99717680be680bfe5f2bdb5d3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a550f2d3b3d4eb57e7fcad284d60c4bea4aed687", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a550f2d3b3d4eb57e7fcad284d60c4bea4aed687", "html_url": "https://github.com/rust-lang/rust/commit/a550f2d3b3d4eb57e7fcad284d60c4bea4aed687", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a550f2d3b3d4eb57e7fcad284d60c4bea4aed687/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5f44c653cff61d0f55f53e07a188f755c7acddd1", "url": "https://api.github.com/repos/rust-lang/rust/commits/5f44c653cff61d0f55f53e07a188f755c7acddd1", "html_url": "https://github.com/rust-lang/rust/commit/5f44c653cff61d0f55f53e07a188f755c7acddd1"}, {"sha": "0ea4b476509022def6a546aaa5630f273a6cc1d5", "url": "https://api.github.com/repos/rust-lang/rust/commits/0ea4b476509022def6a546aaa5630f273a6cc1d5", "html_url": "https://github.com/rust-lang/rust/commit/0ea4b476509022def6a546aaa5630f273a6cc1d5"}], "stats": {"total": 92, "additions": 92, "deletions": 0}, "files": [{"sha": "32f40367faba4731b752c2d42130f4b542e6cfbc", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/a550f2d3b3d4eb57e7fcad284d60c4bea4aed687/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a550f2d3b3d4eb57e7fcad284d60c4bea4aed687/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=a550f2d3b3d4eb57e7fcad284d60c4bea4aed687", "patch": "@@ -659,6 +659,39 @@ impl DepGraph {\n         }).unwrap_or(false)\n     }\n \n+    // This method loads all on-disk cacheable query results into memory, so\n+    // they can be written out to the new cache file again. Most query results\n+    // will already be in memory but in the case where we marked something as\n+    // green but then did not need the value, that value will never have been\n+    // loaded from disk.\n+    //\n+    // This method will only load queries that will end up in the disk cache.\n+    // Other queries will not be executed.\n+    pub fn exec_cache_promotions<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+        let green_nodes: Vec<DepNode> = {\n+            let data = self.data.as_ref().unwrap();\n+            data.colors.borrow().iter().filter_map(|(dep_node, color)| match color {\n+                DepNodeColor::Green(_) => {\n+                    if dep_node.cache_on_disk(tcx) {\n+                        Some(*dep_node)\n+                    } else {\n+                        None\n+                    }\n+                }\n+                DepNodeColor::Red => {\n+                    // We can skip red nodes because a node can only be marked\n+                    // as red if the query result was recomputed and thus is\n+                    // already in memory.\n+                    None\n+                }\n+            }).collect()\n+        };\n+\n+        for dep_node in green_nodes {\n+            dep_node.load_from_on_disk_cache(tcx);\n+        }\n+    }\n+\n     pub fn mark_loaded_from_cache(&self, dep_node_index: DepNodeIndex, state: bool) {\n         debug!(\"mark_loaded_from_cache({:?}, {})\",\n                self.data.as_ref().unwrap().current.borrow().nodes[dep_node_index],"}, {"sha": "6f55df76df4a13227bcf6fc42cb252fe5c0b77b8", "filename": "src/librustc/ty/maps/on_disk_cache.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a550f2d3b3d4eb57e7fcad284d60c4bea4aed687/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a550f2d3b3d4eb57e7fcad284d60c4bea4aed687/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs?ref=a550f2d3b3d4eb57e7fcad284d60c4bea4aed687", "patch": "@@ -197,6 +197,10 @@ impl<'sess> OnDiskCache<'sess> {\n \n         encoder.encode_tagged(PREV_DIAGNOSTICS_TAG, &diagnostics)?;\n \n+        // Load everything into memory so we can write it out to the on-disk\n+        // cache. The vast majority of cacheable query results should already\n+        // be in memory, so this should be a cheap operation.\n+        tcx.dep_graph.exec_cache_promotions(tcx);\n \n         // Encode query results\n         let mut query_result_index = EncodedQueryResultIndex::new();"}, {"sha": "c469991d848a898cf8f9b9912da9668cb9d59680", "filename": "src/librustc/ty/maps/plumbing.rs", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/a550f2d3b3d4eb57e7fcad284d60c4bea4aed687/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a550f2d3b3d4eb57e7fcad284d60c4bea4aed687/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs?ref=a550f2d3b3d4eb57e7fcad284d60c4bea4aed687", "patch": "@@ -898,3 +898,58 @@ pub fn force_from_dep_node<'a, 'gcx, 'lcx>(tcx: TyCtxt<'a, 'gcx, 'lcx>,\n \n     true\n }\n+\n+\n+// FIXME(#45015): Another piece of boilerplate code that could be generated in\n+//                a combined define_dep_nodes!()/define_maps!() macro.\n+macro_rules! impl_load_from_cache {\n+    ($($dep_kind:ident => $query_name:ident,)*) => {\n+        impl DepNode {\n+            // Check whether the query invocation corresponding to the given\n+            // DepNode is eligible for on-disk-caching.\n+            pub fn cache_on_disk(&self, tcx: TyCtxt) -> bool {\n+                use ty::maps::queries;\n+                use ty::maps::QueryDescription;\n+\n+                match self.kind {\n+                    $(DepKind::$dep_kind => {\n+                        let def_id = self.extract_def_id(tcx).unwrap();\n+                        queries::$query_name::cache_on_disk(def_id)\n+                    })*\n+                    _ => false\n+                }\n+            }\n+\n+            // This is method will execute the query corresponding to the given\n+            // DepNode. It is only expected to work for DepNodes where the\n+            // above `cache_on_disk` methods returns true.\n+            // Also, as a sanity check, it expects that the corresponding query\n+            // invocation has been marked as green already.\n+            pub fn load_from_on_disk_cache(&self, tcx: TyCtxt) {\n+                match self.kind {\n+                    $(DepKind::$dep_kind => {\n+                        debug_assert!(tcx.dep_graph\n+                                         .node_color(self)\n+                                         .map(|c| c.is_green())\n+                                         .unwrap_or(false));\n+\n+                        let def_id = self.extract_def_id(tcx).unwrap();\n+                        let _ = tcx.$query_name(def_id);\n+                    })*\n+                    _ => {\n+                        bug!()\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl_load_from_cache!(\n+    TypeckTables => typeck_tables_of,\n+    MirOptimized => optimized_mir,\n+    UnsafetyCheckResult => unsafety_check_result,\n+    BorrowCheck => borrowck,\n+    MirBorrowCheck => mir_borrowck,\n+    MirConstQualif => mir_const_qualif,\n+);"}]}