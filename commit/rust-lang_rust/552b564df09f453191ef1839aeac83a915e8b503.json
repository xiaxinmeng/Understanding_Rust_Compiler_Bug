{"sha": "552b564df09f453191ef1839aeac83a915e8b503", "node_id": "C_kwDOAAsO6NoAKDU1MmI1NjRkZjA5ZjQ1MzE5MWVmMTgzOWFlYWM4M2E5MTVlOGI1MDM", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-01-23T19:13:04Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-01-23T19:13:04Z"}, "message": "Rollup merge of #93219 - cr1901:msp430-asm-squashed, r=Amanieu\n\nAdd preliminary support for inline assembly for msp430.\n\nThe `llvm_asm` macro was removed recently, and the MSP430 backend relies on inline assembly to build useful embedded apps. I conveniently \"found\" time to implement basic support for the new inline `asm` macro syntax with the help of `@Amanieu` :D.\n\nIn addition to tests in the compiler, I have tested this locally against deployed MSP430 code and have not found any noticeable differences in firmware operation or `objdump` disassemblies between the old `llvm_asm` and the new `asm` syntax.", "tree": {"sha": "94c4424edb054801afc1a8f6a29f92124a63525a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/94c4424edb054801afc1a8f6a29f92124a63525a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/552b564df09f453191ef1839aeac83a915e8b503", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJh7ajACRBK7hj4Ov3rIwAAXuIIACburX8WF7L23p/pbg39WyYr\nQI8VHcN1kZ/ay6/cRKT6wsa6NCNyp3gFTZA/1GalsvtDmWmuqRL/jrR8pVt8A8vw\nFym37UpUflNMvvXjjOdlElcZGyN0ZpZUCjdCYcIgfRER2sokWG0531HXZzYZmMF8\nHe9OKzfuKion+XZMBa/VHBD8uANW4kUVN7yjOV/goFJ/vguPO/AA5qjMoOn0ydQL\n0yR7AnAT3F9abu9BPAVAHLT3LqvzHTvrV6WLN1oVJjAju2PDAEoEixMEj5EHbYP1\naWU7kPTKHMxvsR1trJFFefORL3sC1gLf0MbHGYk7V3cYnCFkZMjtlo4s5mVob7A=\n=xzqX\n-----END PGP SIGNATURE-----\n", "payload": "tree 94c4424edb054801afc1a8f6a29f92124a63525a\nparent 0f2ff4b2700a37c70f59717ee665567946ac1cad\nparent 19809ed76d97104fced81b22f51d34475228b305\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1642965184 +0100\ncommitter GitHub <noreply@github.com> 1642965184 +0100\n\nRollup merge of #93219 - cr1901:msp430-asm-squashed, r=Amanieu\n\nAdd preliminary support for inline assembly for msp430.\n\nThe `llvm_asm` macro was removed recently, and the MSP430 backend relies on inline assembly to build useful embedded apps. I conveniently \"found\" time to implement basic support for the new inline `asm` macro syntax with the help of `@Amanieu` :D.\n\nIn addition to tests in the compiler, I have tested this locally against deployed MSP430 code and have not found any noticeable differences in firmware operation or `objdump` disassemblies between the old `llvm_asm` and the new `asm` syntax.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/552b564df09f453191ef1839aeac83a915e8b503", "html_url": "https://github.com/rust-lang/rust/commit/552b564df09f453191ef1839aeac83a915e8b503", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/552b564df09f453191ef1839aeac83a915e8b503/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0f2ff4b2700a37c70f59717ee665567946ac1cad", "url": "https://api.github.com/repos/rust-lang/rust/commits/0f2ff4b2700a37c70f59717ee665567946ac1cad", "html_url": "https://github.com/rust-lang/rust/commit/0f2ff4b2700a37c70f59717ee665567946ac1cad"}, {"sha": "19809ed76d97104fced81b22f51d34475228b305", "url": "https://api.github.com/repos/rust-lang/rust/commits/19809ed76d97104fced81b22f51d34475228b305", "html_url": "https://github.com/rust-lang/rust/commit/19809ed76d97104fced81b22f51d34475228b305"}], "stats": {"total": 290, "additions": 289, "deletions": 1}, "files": [{"sha": "8a74c4c07e0cf2ba331aec30a9839942b7ce0d99", "filename": "compiler/rustc_codegen_gcc/src/asm.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/552b564df09f453191ef1839aeac83a915e8b503/compiler%2Frustc_codegen_gcc%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b564df09f453191ef1839aeac83a915e8b503/compiler%2Frustc_codegen_gcc%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fasm.rs?ref=552b564df09f453191ef1839aeac83a915e8b503", "patch": "@@ -560,6 +560,7 @@ fn reg_to_gcc(reg: InlineAsmRegOrRegClass) -> ConstraintOrRegister {\n             InlineAsmRegClass::Hexagon(HexagonInlineAsmRegClass::reg) => unimplemented!(),\n             InlineAsmRegClass::Mips(MipsInlineAsmRegClass::reg) => unimplemented!(),\n             InlineAsmRegClass::Mips(MipsInlineAsmRegClass::freg) => unimplemented!(),\n+            InlineAsmRegClass::Msp430(_) => unimplemented!(),\n             InlineAsmRegClass::Nvptx(NvptxInlineAsmRegClass::reg16) => unimplemented!(),\n             InlineAsmRegClass::Nvptx(NvptxInlineAsmRegClass::reg32) => unimplemented!(),\n             InlineAsmRegClass::Nvptx(NvptxInlineAsmRegClass::reg64) => unimplemented!(),\n@@ -622,6 +623,7 @@ fn dummy_output_type<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, reg: InlineAsmRegCl\n         InlineAsmRegClass::Hexagon(HexagonInlineAsmRegClass::reg) => cx.type_i32(),\n         InlineAsmRegClass::Mips(MipsInlineAsmRegClass::reg) => cx.type_i32(),\n         InlineAsmRegClass::Mips(MipsInlineAsmRegClass::freg) => cx.type_f32(),\n+        InlineAsmRegClass::Msp430(_) => unimplemented!(),\n         InlineAsmRegClass::Nvptx(NvptxInlineAsmRegClass::reg16) => cx.type_i16(),\n         InlineAsmRegClass::Nvptx(NvptxInlineAsmRegClass::reg32) => cx.type_i32(),\n         InlineAsmRegClass::Nvptx(NvptxInlineAsmRegClass::reg64) => cx.type_i64(),\n@@ -729,6 +731,7 @@ fn modifier_to_gcc(arch: InlineAsmArch, reg: InlineAsmRegClass, modifier: Option\n         InlineAsmRegClass::Bpf(_) => unimplemented!(),\n         InlineAsmRegClass::Hexagon(_) => unimplemented!(),\n         InlineAsmRegClass::Mips(_) => unimplemented!(),\n+        InlineAsmRegClass::Msp430(_) => unimplemented!(),\n         InlineAsmRegClass::Nvptx(_) => unimplemented!(),\n         InlineAsmRegClass::PowerPC(_) => unimplemented!(),\n         InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::reg)"}, {"sha": "e22bec249513d1c13d5bdb98672c10def01c2ec5", "filename": "compiler/rustc_codegen_llvm/src/asm.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/552b564df09f453191ef1839aeac83a915e8b503/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b564df09f453191ef1839aeac83a915e8b503/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs?ref=552b564df09f453191ef1839aeac83a915e8b503", "patch": "@@ -232,6 +232,9 @@ impl<'ll, 'tcx> AsmBuilderMethods<'tcx> for Builder<'_, 'll, 'tcx> {\n                 InlineAsmArch::SpirV => {}\n                 InlineAsmArch::Wasm32 | InlineAsmArch::Wasm64 => {}\n                 InlineAsmArch::Bpf => {}\n+                InlineAsmArch::Msp430 => {\n+                    constraints.push(\"~{sr}\".to_string());\n+                }\n             }\n         }\n         if !options.contains(InlineAsmOptions::NOMEM) {\n@@ -580,6 +583,7 @@ fn reg_to_llvm(reg: InlineAsmRegOrRegClass, layout: Option<&TyAndLayout<'_>>) ->\n             InlineAsmRegClass::Avr(AvrInlineAsmRegClass::reg_ptr) => \"e\",\n             InlineAsmRegClass::S390x(S390xInlineAsmRegClass::reg) => \"r\",\n             InlineAsmRegClass::S390x(S390xInlineAsmRegClass::freg) => \"f\",\n+            InlineAsmRegClass::Msp430(Msp430InlineAsmRegClass::reg) => \"r\",\n             InlineAsmRegClass::SpirV(SpirVInlineAsmRegClass::reg) => {\n                 bug!(\"LLVM backend does not support SPIR-V\")\n             }\n@@ -666,6 +670,7 @@ fn modifier_to_llvm(\n         },\n         InlineAsmRegClass::Avr(_) => None,\n         InlineAsmRegClass::S390x(_) => None,\n+        InlineAsmRegClass::Msp430(_) => None,\n         InlineAsmRegClass::SpirV(SpirVInlineAsmRegClass::reg) => {\n             bug!(\"LLVM backend does not support SPIR-V\")\n         }\n@@ -734,6 +739,7 @@ fn dummy_output_type<'ll>(cx: &CodegenCx<'ll, '_>, reg: InlineAsmRegClass) -> &'\n         InlineAsmRegClass::Avr(AvrInlineAsmRegClass::reg_ptr) => cx.type_i16(),\n         InlineAsmRegClass::S390x(S390xInlineAsmRegClass::reg) => cx.type_i32(),\n         InlineAsmRegClass::S390x(S390xInlineAsmRegClass::freg) => cx.type_f64(),\n+        InlineAsmRegClass::Msp430(Msp430InlineAsmRegClass::reg) => cx.type_i16(),\n         InlineAsmRegClass::SpirV(SpirVInlineAsmRegClass::reg) => {\n             bug!(\"LLVM backend does not support SPIR-V\")\n         }"}, {"sha": "8046267a59da6ca8d5c3471de366b8f4db5eecb1", "filename": "compiler/rustc_target/src/asm/mod.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/552b564df09f453191ef1839aeac83a915e8b503/compiler%2Frustc_target%2Fsrc%2Fasm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b564df09f453191ef1839aeac83a915e8b503/compiler%2Frustc_target%2Fsrc%2Fasm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fasm%2Fmod.rs?ref=552b564df09f453191ef1839aeac83a915e8b503", "patch": "@@ -152,6 +152,7 @@ mod avr;\n mod bpf;\n mod hexagon;\n mod mips;\n+mod msp430;\n mod nvptx;\n mod powerpc;\n mod riscv;\n@@ -166,6 +167,7 @@ pub use avr::{AvrInlineAsmReg, AvrInlineAsmRegClass};\n pub use bpf::{BpfInlineAsmReg, BpfInlineAsmRegClass};\n pub use hexagon::{HexagonInlineAsmReg, HexagonInlineAsmRegClass};\n pub use mips::{MipsInlineAsmReg, MipsInlineAsmRegClass};\n+pub use msp430::{Msp430InlineAsmReg, Msp430InlineAsmRegClass};\n pub use nvptx::{NvptxInlineAsmReg, NvptxInlineAsmRegClass};\n pub use powerpc::{PowerPCInlineAsmReg, PowerPCInlineAsmRegClass};\n pub use riscv::{RiscVInlineAsmReg, RiscVInlineAsmRegClass};\n@@ -194,6 +196,7 @@ pub enum InlineAsmArch {\n     Wasm64,\n     Bpf,\n     Avr,\n+    Msp430,\n }\n \n impl FromStr for InlineAsmArch {\n@@ -219,6 +222,7 @@ impl FromStr for InlineAsmArch {\n             \"wasm64\" => Ok(Self::Wasm64),\n             \"bpf\" => Ok(Self::Bpf),\n             \"avr\" => Ok(Self::Avr),\n+            \"msp430\" => Ok(Self::Msp430),\n             _ => Err(()),\n         }\n     }\n@@ -250,6 +254,7 @@ pub enum InlineAsmReg {\n     Wasm(WasmInlineAsmReg),\n     Bpf(BpfInlineAsmReg),\n     Avr(AvrInlineAsmReg),\n+    Msp430(Msp430InlineAsmReg),\n     // Placeholder for invalid register constraints for the current target\n     Err,\n }\n@@ -267,6 +272,7 @@ impl InlineAsmReg {\n             Self::S390x(r) => r.name(),\n             Self::Bpf(r) => r.name(),\n             Self::Avr(r) => r.name(),\n+            Self::Msp430(r) => r.name(),\n             Self::Err => \"<reg>\",\n         }\n     }\n@@ -283,6 +289,7 @@ impl InlineAsmReg {\n             Self::S390x(r) => InlineAsmRegClass::S390x(r.reg_class()),\n             Self::Bpf(r) => InlineAsmRegClass::Bpf(r.reg_class()),\n             Self::Avr(r) => InlineAsmRegClass::Avr(r.reg_class()),\n+            Self::Msp430(r) => InlineAsmRegClass::Msp430(r.reg_class()),\n             Self::Err => InlineAsmRegClass::Err,\n         }\n     }\n@@ -336,6 +343,9 @@ impl InlineAsmReg {\n             InlineAsmArch::Avr => {\n                 Self::Avr(AvrInlineAsmReg::parse(arch, target_features, target, name)?)\n             }\n+            InlineAsmArch::Msp430 => {\n+                Self::Msp430(Msp430InlineAsmReg::parse(arch, target_features, target, name)?)\n+            }\n         })\n     }\n \n@@ -358,6 +368,7 @@ impl InlineAsmReg {\n             Self::S390x(r) => r.emit(out, arch, modifier),\n             Self::Bpf(r) => r.emit(out, arch, modifier),\n             Self::Avr(r) => r.emit(out, arch, modifier),\n+            Self::Msp430(r) => r.emit(out, arch, modifier),\n             Self::Err => unreachable!(\"Use of InlineAsmReg::Err\"),\n         }\n     }\n@@ -374,6 +385,7 @@ impl InlineAsmReg {\n             Self::S390x(_) => cb(self),\n             Self::Bpf(r) => r.overlapping_regs(|r| cb(Self::Bpf(r))),\n             Self::Avr(r) => r.overlapping_regs(|r| cb(Self::Avr(r))),\n+            Self::Msp430(_) => cb(self),\n             Self::Err => unreachable!(\"Use of InlineAsmReg::Err\"),\n         }\n     }\n@@ -405,6 +417,7 @@ pub enum InlineAsmRegClass {\n     Wasm(WasmInlineAsmRegClass),\n     Bpf(BpfInlineAsmRegClass),\n     Avr(AvrInlineAsmRegClass),\n+    Msp430(Msp430InlineAsmRegClass),\n     // Placeholder for invalid register constraints for the current target\n     Err,\n }\n@@ -425,6 +438,7 @@ impl InlineAsmRegClass {\n             Self::Wasm(r) => r.name(),\n             Self::Bpf(r) => r.name(),\n             Self::Avr(r) => r.name(),\n+            Self::Msp430(r) => r.name(),\n             Self::Err => rustc_span::symbol::sym::reg,\n         }\n     }\n@@ -447,6 +461,7 @@ impl InlineAsmRegClass {\n             Self::Wasm(r) => r.suggest_class(arch, ty).map(InlineAsmRegClass::Wasm),\n             Self::Bpf(r) => r.suggest_class(arch, ty).map(InlineAsmRegClass::Bpf),\n             Self::Avr(r) => r.suggest_class(arch, ty).map(InlineAsmRegClass::Avr),\n+            Self::Msp430(r) => r.suggest_class(arch, ty).map(InlineAsmRegClass::Msp430),\n             Self::Err => unreachable!(\"Use of InlineAsmRegClass::Err\"),\n         }\n     }\n@@ -476,6 +491,7 @@ impl InlineAsmRegClass {\n             Self::Wasm(r) => r.suggest_modifier(arch, ty),\n             Self::Bpf(r) => r.suggest_modifier(arch, ty),\n             Self::Avr(r) => r.suggest_modifier(arch, ty),\n+            Self::Msp430(r) => r.suggest_modifier(arch, ty),\n             Self::Err => unreachable!(\"Use of InlineAsmRegClass::Err\"),\n         }\n     }\n@@ -501,6 +517,7 @@ impl InlineAsmRegClass {\n             Self::Wasm(r) => r.default_modifier(arch),\n             Self::Bpf(r) => r.default_modifier(arch),\n             Self::Avr(r) => r.default_modifier(arch),\n+            Self::Msp430(r) => r.default_modifier(arch),\n             Self::Err => unreachable!(\"Use of InlineAsmRegClass::Err\"),\n         }\n     }\n@@ -525,6 +542,7 @@ impl InlineAsmRegClass {\n             Self::Wasm(r) => r.supported_types(arch),\n             Self::Bpf(r) => r.supported_types(arch),\n             Self::Avr(r) => r.supported_types(arch),\n+            Self::Msp430(r) => r.supported_types(arch),\n             Self::Err => unreachable!(\"Use of InlineAsmRegClass::Err\"),\n         }\n     }\n@@ -554,6 +572,7 @@ impl InlineAsmRegClass {\n             }\n             InlineAsmArch::Bpf => Self::Bpf(BpfInlineAsmRegClass::parse(arch, name)?),\n             InlineAsmArch::Avr => Self::Avr(AvrInlineAsmRegClass::parse(arch, name)?),\n+            InlineAsmArch::Msp430 => Self::Msp430(Msp430InlineAsmRegClass::parse(arch, name)?),\n         })\n     }\n \n@@ -574,6 +593,7 @@ impl InlineAsmRegClass {\n             Self::Wasm(r) => r.valid_modifiers(arch),\n             Self::Bpf(r) => r.valid_modifiers(arch),\n             Self::Avr(r) => r.valid_modifiers(arch),\n+            Self::Msp430(r) => r.valid_modifiers(arch),\n             Self::Err => unreachable!(\"Use of InlineAsmRegClass::Err\"),\n         }\n     }\n@@ -764,6 +784,11 @@ pub fn allocatable_registers(\n             avr::fill_reg_map(arch, target_features, target, &mut map);\n             map\n         }\n+        InlineAsmArch::Msp430 => {\n+            let mut map = msp430::regclass_map();\n+            msp430::fill_reg_map(arch, target_features, target, &mut map);\n+            map\n+        }\n     }\n }\n "}, {"sha": "a27d6390a72e861a29fa20ccc0b24d69332ad3d7", "filename": "compiler/rustc_target/src/asm/msp430.rs", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/552b564df09f453191ef1839aeac83a915e8b503/compiler%2Frustc_target%2Fsrc%2Fasm%2Fmsp430.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b564df09f453191ef1839aeac83a915e8b503/compiler%2Frustc_target%2Fsrc%2Fasm%2Fmsp430.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fasm%2Fmsp430.rs?ref=552b564df09f453191ef1839aeac83a915e8b503", "patch": "@@ -0,0 +1,81 @@\n+use super::{InlineAsmArch, InlineAsmType};\n+use rustc_macros::HashStable_Generic;\n+use rustc_span::Symbol;\n+use std::fmt;\n+\n+def_reg_class! {\n+    Msp430 Msp430InlineAsmRegClass {\n+        reg,\n+    }\n+}\n+\n+impl Msp430InlineAsmRegClass {\n+    pub fn valid_modifiers(self, _arch: super::InlineAsmArch) -> &'static [char] {\n+        &[]\n+    }\n+\n+    pub fn suggest_class(self, _arch: InlineAsmArch, _ty: InlineAsmType) -> Option<Self> {\n+        None\n+    }\n+\n+    pub fn suggest_modifier(\n+        self,\n+        _arch: InlineAsmArch,\n+        _ty: InlineAsmType,\n+    ) -> Option<(char, &'static str)> {\n+        None\n+    }\n+\n+    pub fn default_modifier(self, _arch: InlineAsmArch) -> Option<(char, &'static str)> {\n+        None\n+    }\n+\n+    pub fn supported_types(\n+        self,\n+        arch: InlineAsmArch,\n+    ) -> &'static [(InlineAsmType, Option<Symbol>)] {\n+        match (self, arch) {\n+            (Self::reg, _) => types! { _: I8, I16; },\n+        }\n+    }\n+}\n+\n+// The reserved registers are taken from:\n+// https://github.com/llvm/llvm-project/blob/36cb29cbbe1b22dcd298ad65e1fabe899b7d7249/llvm/lib/Target/MSP430/MSP430RegisterInfo.cpp#L73.\n+def_regs! {\n+    Msp430 Msp430InlineAsmReg Msp430InlineAsmRegClass {\n+        r5: reg = [\"r5\"],\n+        r6: reg = [\"r6\"],\n+        r7: reg = [\"r7\"],\n+        r8: reg = [\"r8\"],\n+        r9: reg = [\"r9\"],\n+        r10: reg = [\"r10\"],\n+        r11: reg = [\"r11\"],\n+        r12: reg = [\"r12\"],\n+        r13: reg = [\"r13\"],\n+        r14: reg = [\"r14\"],\n+        r15: reg = [\"r15\"],\n+\n+        #error = [\"r0\", \"pc\"] =>\n+            \"the program counter cannot be used as an operand for inline asm\",\n+        #error = [\"r1\", \"sp\"] =>\n+            \"the stack pointer cannot be used as an operand for inline asm\",\n+        #error = [\"r2\", \"sr\"] =>\n+            \"the status register cannot be used as an operand for inline asm\",\n+        #error = [\"r3\", \"cg\"] =>\n+            \"the constant generator cannot be used as an operand for inline asm\",\n+        #error = [\"r4\", \"fp\"] =>\n+            \"the frame pointer cannot be used as an operand for inline asm\",\n+    }\n+}\n+\n+impl Msp430InlineAsmReg {\n+    pub fn emit(\n+        self,\n+        out: &mut dyn fmt::Write,\n+        _arch: InlineAsmArch,\n+        _modifier: Option<char>,\n+    ) -> fmt::Result {\n+        out.write_str(self.name())\n+    }\n+}"}, {"sha": "37fd67447c1340867ca51fd03e7facf0da993153", "filename": "src/doc/unstable-book/src/language-features/asm-experimental-arch.md", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/552b564df09f453191ef1839aeac83a915e8b503/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fasm-experimental-arch.md", "raw_url": "https://github.com/rust-lang/rust/raw/552b564df09f453191ef1839aeac83a915e8b503/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fasm-experimental-arch.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fasm-experimental-arch.md?ref=552b564df09f453191ef1839aeac83a915e8b503", "patch": "@@ -15,6 +15,7 @@ This feature tracks `asm!` and `global_asm!` support for the following architect\n - BPF\n - SPIR-V\n - AVR\n+- MSP430\n \n ## Register classes\n \n@@ -39,6 +40,7 @@ This feature tracks `asm!` and `global_asm!` support for the following architect\n | AVR          | `reg_pair`     | `r3r2` .. `r25r24`, `X`, `Z`       | `r`                  |\n | AVR          | `reg_iw`       | `r25r24`, `X`, `Z`                 | `w`                  |\n | AVR          | `reg_ptr`      | `X`, `Z`                           | `e`                  |\n+| MSP430       | `reg`          | `r[0-15]`                          | `r`                  |\n \n > **Notes**:\n > - NVPTX doesn't have a fixed register set, so named registers are not supported.\n@@ -67,6 +69,7 @@ This feature tracks `asm!` and `global_asm!` support for the following architect\n | BPF          | `wreg`                          | `alu32`        | `i8` `i16` `i32`                        |\n | AVR          | `reg`, `reg_upper`              | None           | `i8`                                    |\n | AVR          | `reg_pair`, `reg_iw`, `reg_ptr` | None           | `i16`                                   |\n+| MSP430       | `reg`                           | None           | `i8`, `i16`                             |\n \n ## Register aliases\n \n@@ -80,13 +83,22 @@ This feature tracks `asm!` and `global_asm!` support for the following architect\n | AVR          | `XL`          | `r26`     |\n | AVR          | `ZH`          | `r31`     |\n | AVR          | `ZL`          | `r30`     |\n+| MSP430       | `r0`          | `pc`      |\n+| MSP430       | `r1`          | `sp`      |\n+| MSP430       | `r2`          | `sr`      |\n+| MSP430       | `r3`          | `cg`      |\n+| MSP430       | `r4`          | `fp`      |\n+\n+> **Notes**:\n+> - TI does not mandate a frame pointer for MSP430, but toolchains are allowed\n+    to use one; LLVM uses `r4`.\n \n ## Unsupported registers\n \n | Architecture | Unsupported register                    | Reason                                                                                                                                                                              |\n | ------------ | --------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n | All          | `sp`                                    | The stack pointer must be restored to its original value at the end of an asm code block.                                                                                           |\n-| All          | `fr` (Hexagon), `$fp` (MIPS), `Y` (AVR) | The frame pointer cannot be used as an input or output.                                                                                                                             |\n+| All          | `fr` (Hexagon), `$fp` (MIPS), `Y` (AVR), `r4` (MSP430) | The frame pointer cannot be used as an input or output.                                                                                                                             |\n | All          | `r19` (Hexagon)                         | This is used internally by LLVM as a \"base pointer\" for functions with complex stack frames.                                                                                        |\n | MIPS         | `$0` or `$zero`                         | This is a constant zero register which can't be modified.                                                                                                                           |\n | MIPS         | `$1` or `$at`                           | Reserved for assembler.                                                                                                                                                             |\n@@ -95,6 +107,7 @@ This feature tracks `asm!` and `global_asm!` support for the following architect\n | MIPS         | `$ra`                                   | Return address cannot be used as inputs or outputs.                                                                                                                                 |\n | Hexagon      | `lr`                                    | This is the link register which cannot be used as an input or output.                                                                                                               |\n | AVR          | `r0`, `r1`, `r1r0`                      | Due to an issue in LLVM, the `r0` and `r1` registers cannot be used as inputs or outputs.  If modified, they must be restored to their original values before the end of the block. |\n+|MSP430        | `r0`, `r2`, `r3`                        | These are the program counter, status register, and constant generator respectively. Neither the status register nor constant generator can be written to.                          |\n \n ## Template modifiers\n \n@@ -115,3 +128,5 @@ This feature tracks `asm!` and `global_asm!` support for the following architect\n These flags registers must be restored upon exiting the asm block if the `preserves_flags` option is set:\n - AVR\n   - The status register `SREG`.\n+- MSP430\n+  - The status register `r2`."}, {"sha": "6cfb86e276e2306bd93fd8a344b19edc9c25f544", "filename": "src/test/assembly/asm/msp430-types.rs", "status": "added", "additions": 158, "deletions": 0, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/552b564df09f453191ef1839aeac83a915e8b503/src%2Ftest%2Fassembly%2Fasm%2Fmsp430-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/552b564df09f453191ef1839aeac83a915e8b503/src%2Ftest%2Fassembly%2Fasm%2Fmsp430-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fassembly%2Fasm%2Fmsp430-types.rs?ref=552b564df09f453191ef1839aeac83a915e8b503", "patch": "@@ -0,0 +1,158 @@\n+// min-llvm-version: 13.0\n+// assembly-output: emit-asm\n+// compile-flags: --target msp430-none-elf\n+// needs-llvm-components: msp430\n+\n+#![feature(no_core, lang_items, rustc_attrs, asm_sym, asm_experimental_arch, asm_const)]\n+#![crate_type = \"rlib\"]\n+#![no_core]\n+#![allow(non_camel_case_types)]\n+\n+#[rustc_builtin_macro]\n+macro_rules! asm {\n+    () => {};\n+}\n+#[rustc_builtin_macro]\n+macro_rules! concat {\n+    () => {};\n+}\n+\n+#[lang = \"sized\"]\n+trait Sized {}\n+#[lang = \"copy\"]\n+trait Copy {}\n+\n+type ptr = *const i16;\n+\n+impl Copy for i8 {}\n+impl Copy for i16 {}\n+impl Copy for i32 {}\n+impl Copy for i64 {}\n+impl Copy for ptr {}\n+\n+macro_rules! check {\n+    ($func:ident $ty:ident $class:ident) => {\n+        #[no_mangle]\n+        pub unsafe fn $func(x: $ty) -> $ty {\n+            let y;\n+            asm!(\"mov {}, {}\", lateout($class) y, in($class) x);\n+            y\n+        }\n+    };\n+}\n+\n+macro_rules! checkb {\n+    ($func:ident $ty:ident $class:ident) => {\n+        #[no_mangle]\n+        pub unsafe fn $func(x: $ty) -> $ty {\n+            let y;\n+            asm!(\"mov.b {}, {}\", lateout($class) y, in($class) x);\n+            y\n+        }\n+    };\n+}\n+\n+macro_rules! check_reg {\n+    ($func:ident $ty:ident $reg:tt) => {\n+        #[no_mangle]\n+        pub unsafe fn $func(x: $ty) -> $ty {\n+            let y;\n+            asm!(concat!(\"mov \", $reg, \", \", $reg), lateout($reg) y, in($reg) x);\n+            y\n+        }\n+    };\n+}\n+\n+macro_rules! check_regb {\n+    ($func:ident $ty:ident $reg:tt) => {\n+        #[no_mangle]\n+        pub unsafe fn $func(x: $ty) -> $ty {\n+            let y;\n+            asm!(concat!(\"mov.b \", $reg, \", \", $reg), lateout($reg) y, in($reg) x);\n+            y\n+        }\n+    };\n+}\n+\n+extern \"C\" {\n+    fn extern_func();\n+    static extern_static: i8;\n+}\n+\n+// CHECK-LABEL: sym_fn\n+// CHECK: ;APP\n+// CHECK: call extern_func\n+// CHECK: ;NO_APP\n+#[no_mangle]\n+pub unsafe fn sym_fn() {\n+    asm!(\"call {}\", sym extern_func);\n+}\n+\n+// CHECK-LABEL: sym_static\n+// CHECK: ;APP\n+// CHECK: mov.b extern_static, r{{[0-9]+}}\n+// CHECK: ;NO_APP\n+#[no_mangle]\n+pub unsafe fn sym_static() -> i8 {\n+    let y;\n+    asm!(\"mov.b {1}, {0}\", lateout(reg) y, sym extern_static);\n+    y\n+}\n+\n+// CHECK-LABEL: add_const:\n+// CHECK: ;APP\n+// CHECK: add.b #5, r{{[0-9]+}}\n+// CHECK: ;NO_APP\n+#[no_mangle]\n+pub unsafe fn add_const() -> i8 {\n+    let y;\n+    asm!(\"add.b #{number}, {}\", out(reg) y, number = const 5);\n+    y\n+}\n+\n+// CHECK-LABEL: mov_postincrement:\n+// CHECK: ;APP\n+// CHECK: mov @r5+, r{{[0-9]+}}\n+// CHECK: ;NO_APP\n+#[no_mangle]\n+pub unsafe fn mov_postincrement(mut x: *const i16) -> (i16, *const i16) {\n+    let y;\n+    asm!(\"mov @r5+, {0}\", out(reg) y, inlateout(\"r5\") x);\n+    (y, x)\n+}\n+\n+// CHECK-LABEL: reg_i8:\n+// CHECK: ;APP\n+// CHECK: mov r{{[0-9]+}}, r{{[0-9]+}}\n+// CHECK: ;NO_APP\n+check!(reg_i8 i8 reg);\n+\n+// CHECK-LABEL: reg_i16:\n+// CHECK: ;APP\n+// CHECK: mov r{{[0-9]+}}, r{{[0-9]+}}\n+// CHECK: ;NO_APP\n+check!(reg_i16 i16 reg);\n+\n+// CHECK-LABEL: reg_i8b:\n+// CHECK: ;APP\n+// CHECK: mov.b r{{[0-9]+}}, r{{[0-9]+}}\n+// CHECK: ;NO_APP\n+checkb!(reg_i8b i8 reg);\n+\n+// CHECK-LABEL: r5_i8:\n+// CHECK: ;APP\n+// CHECK: mov r5, r5\n+// CHECK: ;NO_APP\n+check_reg!(r5_i8 i8 \"r5\");\n+\n+// CHECK-LABEL: r5_i16:\n+// CHECK: ;APP\n+// CHECK: mov r5, r5\n+// CHECK: ;NO_APP\n+check_reg!(r5_i16 i16 \"r5\");\n+\n+// CHECK-LABEL: r5_i8b:\n+// CHECK: ;APP\n+// CHECK: mov.b r5, r5\n+// CHECK: ;NO_APP\n+check_regb!(r5_i8b i8 \"r5\");"}]}