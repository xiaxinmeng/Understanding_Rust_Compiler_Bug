{"sha": "7e12e67936dd2ad12e529278344dab369ccb75a0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdlMTJlNjc5MzZkZDJhZDEyZTUyOTI3ODM0NGRhYjM2OWNjYjc1YTA=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2014-09-05T02:54:41Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2014-09-05T21:12:20Z"}, "message": "Optimize Slice::reverse\n\nThis makes the completely safe implementation of fannkuchredux perform\nthe same as C++. Yay, Rust.", "tree": {"sha": "326c9ad50a58c80621364dabedfe9105f1dec51b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/326c9ad50a58c80621364dabedfe9105f1dec51b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7e12e67936dd2ad12e529278344dab369ccb75a0", "comment_count": 9, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7e12e67936dd2ad12e529278344dab369ccb75a0", "html_url": "https://github.com/rust-lang/rust/commit/7e12e67936dd2ad12e529278344dab369ccb75a0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7e12e67936dd2ad12e529278344dab369ccb75a0/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fc3b6383ba346dcf243d189fa2d87e2b5f2b9f61", "url": "https://api.github.com/repos/rust-lang/rust/commits/fc3b6383ba346dcf243d189fa2d87e2b5f2b9f61", "html_url": "https://github.com/rust-lang/rust/commit/fc3b6383ba346dcf243d189fa2d87e2b5f2b9f61"}], "stats": {"total": 204, "additions": 7, "deletions": 197}, "files": [{"sha": "de0d5c18766ad2673068e04a05e7b41dabe94699", "filename": "src/etc/licenseck.py", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7e12e67936dd2ad12e529278344dab369ccb75a0/src%2Fetc%2Flicenseck.py", "raw_url": "https://github.com/rust-lang/rust/raw/7e12e67936dd2ad12e529278344dab369ccb75a0/src%2Fetc%2Flicenseck.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Flicenseck.py?ref=7e12e67936dd2ad12e529278344dab369ccb75a0", "patch": "@@ -44,7 +44,6 @@\n     \"libsync/mpsc_intrusive.rs\", # BSD\n     \"test/bench/shootout-binarytrees.rs\", # BSD\n     \"test/bench/shootout-fannkuch-redux.rs\", # BSD\n-    \"test/bench/shootout-fannkuch-redux-safe.rs\", # BSD\n     \"test/bench/shootout-k-nucleotide.rs\", # BSD\n     \"test/bench/shootout-mandelbrot.rs\", # BSD\n     \"test/bench/shootout-meteor.rs\", # BSD"}, {"sha": "cc2b01e3bb58b74dcb3193ea0410c71a8ec621be", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7e12e67936dd2ad12e529278344dab369ccb75a0/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e12e67936dd2ad12e529278344dab369ccb75a0/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=7e12e67936dd2ad12e529278344dab369ccb75a0", "patch": "@@ -806,7 +806,12 @@ impl<'a,T> MutableSlice<'a, T> for &'a mut [T] {\n         let mut i: uint = 0;\n         let ln = self.len();\n         while i < ln / 2 {\n-            self.swap(i, ln - i - 1);\n+            // Unsafe swap to avoid the bounds check in safe swap.\n+            unsafe {\n+                let pa: *mut T = self.unsafe_mut_ref(i);\n+                let pb: *mut T = self.unsafe_mut_ref(ln - i - 1);\n+                ptr::swap(pa, pb);\n+            }\n             i += 1;\n         }\n     }"}, {"sha": "f0798a9e7e82fe1d4f5158005e5803a1d7d24ff6", "filename": "src/test/bench/shootout-fannkuch-redux-safe.rs", "status": "removed", "additions": 0, "deletions": 188, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/fc3b6383ba346dcf243d189fa2d87e2b5f2b9f61/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux-safe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc3b6383ba346dcf243d189fa2d87e2b5f2b9f61/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux-safe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux-safe.rs?ref=fc3b6383ba346dcf243d189fa2d87e2b5f2b9f61", "patch": "@@ -1,188 +0,0 @@\n-// The Computer Language Benchmarks Game\n-// http://benchmarksgame.alioth.debian.org/\n-//\n-// contributed by the Rust Project Developers\n-\n-// Copyright (c) 2014 The Rust Project Developers\n-//\n-// All rights reserved.\n-//\n-// Redistribution and use in source and binary forms, with or without\n-// modification, are permitted provided that the following conditions\n-// are met:\n-//\n-// - Redistributions of source code must retain the above copyright\n-//   notice, this list of conditions and the following disclaimer.\n-//\n-// - Redistributions in binary form must reproduce the above copyright\n-//   notice, this list of conditions and the following disclaimer in\n-//   the documentation and/or other materials provided with the\n-//   distribution.\n-//\n-// - Neither the name of \"The Computer Language Benchmarks Game\" nor\n-//   the name of \"The Computer Language Shootout Benchmarks\" nor the\n-//   names of its contributors may be used to endorse or promote\n-//   products derived from this software without specific prior\n-//   written permission.\n-//\n-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n-// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n-// FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n-// COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n-// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n-// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n-// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n-// STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n-// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n-// OF THE POSSIBILITY OF SUCH DAMAGE.\n-\n-use std::{cmp, iter, mem};\n-use std::sync::Future;\n-\n-fn rotate(x: &mut [i32]) {\n-    let mut prev = x[0];\n-    for place in x.mut_iter().rev() {\n-        prev = mem::replace(place, prev)\n-    }\n-}\n-\n-fn next_permutation(perm: &mut [i32], count: &mut [i32]) {\n-    for i in range(1, perm.len()) {\n-        rotate(perm.mut_slice_to(i + 1));\n-        let count_i = &mut count[i];\n-        if *count_i >= i as i32 {\n-            *count_i = 0;\n-        } else {\n-            *count_i += 1;\n-            break\n-        }\n-    }\n-}\n-\n-struct P {\n-    p: [i32, .. 16],\n-}\n-\n-struct Perm {\n-    cnt: [i32, .. 16],\n-    fact: [u32, .. 16],\n-    n: u32,\n-    permcount: u32,\n-    perm: P,\n-}\n-\n-impl Perm {\n-    fn new(n: u32) -> Perm {\n-        let mut fact = [1, .. 16];\n-        for i in range(1, n as uint + 1) {\n-            fact[i] = fact[i - 1] * i as u32;\n-        }\n-        Perm {\n-            cnt: [0, .. 16],\n-            fact: fact,\n-            n: n,\n-            permcount: 0,\n-            perm: P { p: [0, .. 16 ] }\n-        }\n-    }\n-\n-    fn get(&mut self, mut idx: i32) -> P {\n-        let mut pp = [0u8, .. 16];\n-        self.permcount = idx as u32;\n-        for (i, place) in self.perm.p.mut_iter().enumerate() {\n-            *place = i as i32 + 1;\n-        }\n-\n-        for i in range(1, self.n as uint).rev() {\n-            let d = idx / self.fact[i] as i32;\n-            self.cnt[i] = d;\n-            idx %= self.fact[i] as i32;\n-            for (place, val) in pp.mut_iter().zip(self.perm.p.slice_to(i + 1).iter()) {\n-                *place = (*val) as u8\n-            }\n-\n-            let d = d as uint;\n-            for j in range(0, i + 1) {\n-                self.perm.p[j] = if j + d <= i {pp[j + d]} else {pp[j+d-i-1]} as i32;\n-            }\n-        }\n-\n-        self.perm\n-    }\n-\n-    fn count(&self) -> u32 { self.permcount }\n-    fn max(&self) -> u32 { self.fact[self.n as uint] }\n-\n-    fn next(&mut self) -> P {\n-        next_permutation(self.perm.p, self.cnt);\n-        self.permcount += 1;\n-\n-        self.perm\n-    }\n-}\n-\n-\n-fn reverse(tperm: &mut [i32], mut k: uint) {\n-    tperm.mut_slice_to(k).reverse()\n-}\n-\n-fn work(mut perm: Perm, n: uint, max: uint) -> (i32, i32) {\n-    let mut checksum = 0;\n-    let mut maxflips = 0;\n-\n-    let mut p = perm.get(n as i32);\n-\n-    while perm.count() < max as u32 {\n-        let mut flips = 0;\n-\n-        while p.p[0] != 1 {\n-            let k = p.p[0] as uint;\n-            reverse(p.p, k);\n-            flips += 1;\n-        }\n-\n-        checksum += if perm.count() % 2 == 0 {flips} else {-flips};\n-        maxflips = cmp::max(maxflips, flips);\n-\n-        p = perm.next();\n-    }\n-\n-    (checksum, maxflips)\n-}\n-\n-fn fannkuch(n: i32) -> (i32, i32) {\n-    let perm = Perm::new(n as u32);\n-\n-    let N = 4;\n-    let mut futures = vec![];\n-    let k = perm.max() / N;\n-\n-    for (i, j) in range(0, N).zip(iter::count(0, k)) {\n-        let max = cmp::min(j+k, perm.max());\n-\n-        futures.push(Future::spawn(proc() {\n-            work(perm, j as uint, max as uint)\n-        }))\n-    }\n-\n-    let mut checksum = 0;\n-    let mut maxflips = 0;\n-    for fut in futures.mut_iter() {\n-        let (cs, mf) = fut.get();\n-        checksum += cs;\n-        maxflips = cmp::max(maxflips, mf);\n-    }\n-    (checksum, maxflips)\n-}\n-\n-fn main() {\n-    let n = std::os::args().as_slice()\n-        .get(1)\n-        .and_then(|arg| from_str(arg.as_slice()))\n-        .unwrap_or(2i32);\n-\n-    let (checksum, maxflips) = fannkuch(n);\n-    println!(\"{}\\nPfannkuchen({}) = {}\", checksum, n, maxflips);\n-}"}, {"sha": "f0798a9e7e82fe1d4f5158005e5803a1d7d24ff6", "filename": "src/test/bench/shootout-fannkuch-redux.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7e12e67936dd2ad12e529278344dab369ccb75a0/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e12e67936dd2ad12e529278344dab369ccb75a0/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs?ref=7e12e67936dd2ad12e529278344dab369ccb75a0", "patch": "@@ -125,13 +125,7 @@ impl Perm {\n \n \n fn reverse(tperm: &mut [i32], mut k: uint) {\n-    let p = tperm.as_mut_ptr();\n-\n-    unsafe {\n-        for off in range(0, k as int / 2) {\n-            std::ptr::swap(p.offset(off), p.offset(k as int - 1 - off));\n-        }\n-    }\n+    tperm.mut_slice_to(k).reverse()\n }\n \n fn work(mut perm: Perm, n: uint, max: uint) -> (i32, i32) {"}]}