{"sha": "eef4d42a3f04519af885932de1826cbfebdeeb55", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVlZjRkNDJhM2YwNDUxOWFmODg1OTMyZGUxODI2Y2JmZWJkZWViNTU=", "commit": {"author": {"name": "Scott McMurray", "email": "scottmcm@users.noreply.github.com", "date": "2017-10-23T05:47:27Z"}, "committer": {"name": "Scott McMurray", "email": "scottmcm@users.noreply.github.com", "date": "2017-10-29T22:45:20Z"}, "message": "Fundamental internal iteration with try_fold\n\nThis is the core method in terms of which the other methods (fold, all, any, find, position, nth, ...) can be implemented, allowing Iterator implementors to get the full goodness of internal iteration by only overriding one method (per direction).", "tree": {"sha": "675a20207c732d7cc1af1cf11d072c5859046cec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/675a20207c732d7cc1af1cf11d072c5859046cec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eef4d42a3f04519af885932de1826cbfebdeeb55", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eef4d42a3f04519af885932de1826cbfebdeeb55", "html_url": "https://github.com/rust-lang/rust/commit/eef4d42a3f04519af885932de1826cbfebdeeb55", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eef4d42a3f04519af885932de1826cbfebdeeb55/comments", "author": {"login": "scottmcm", "id": 18526288, "node_id": "MDQ6VXNlcjE4NTI2Mjg4", "avatar_url": "https://avatars.githubusercontent.com/u/18526288?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottmcm", "html_url": "https://github.com/scottmcm", "followers_url": "https://api.github.com/users/scottmcm/followers", "following_url": "https://api.github.com/users/scottmcm/following{/other_user}", "gists_url": "https://api.github.com/users/scottmcm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottmcm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottmcm/subscriptions", "organizations_url": "https://api.github.com/users/scottmcm/orgs", "repos_url": "https://api.github.com/users/scottmcm/repos", "events_url": "https://api.github.com/users/scottmcm/events{/privacy}", "received_events_url": "https://api.github.com/users/scottmcm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "scottmcm", "id": 18526288, "node_id": "MDQ6VXNlcjE4NTI2Mjg4", "avatar_url": "https://avatars.githubusercontent.com/u/18526288?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottmcm", "html_url": "https://github.com/scottmcm", "followers_url": "https://api.github.com/users/scottmcm/followers", "following_url": "https://api.github.com/users/scottmcm/following{/other_user}", "gists_url": "https://api.github.com/users/scottmcm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottmcm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottmcm/subscriptions", "organizations_url": "https://api.github.com/users/scottmcm/orgs", "repos_url": "https://api.github.com/users/scottmcm/repos", "events_url": "https://api.github.com/users/scottmcm/events{/privacy}", "received_events_url": "https://api.github.com/users/scottmcm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d9f124965551e8fb9403def6a715e13dfd5e9c95", "url": "https://api.github.com/repos/rust-lang/rust/commits/d9f124965551e8fb9403def6a715e13dfd5e9c95", "html_url": "https://github.com/rust-lang/rust/commit/d9f124965551e8fb9403def6a715e13dfd5e9c95"}], "stats": {"total": 1115, "additions": 934, "deletions": 181}, "files": [{"sha": "b284d855c45157e984894089a438e242ea6c5bc3", "filename": "src/libcore/benches/iter.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eef4d42a3f04519af885932de1826cbfebdeeb55/src%2Flibcore%2Fbenches%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eef4d42a3f04519af885932de1826cbfebdeeb55/src%2Flibcore%2Fbenches%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbenches%2Fiter.rs?ref=eef4d42a3f04519af885932de1826cbfebdeeb55", "patch": "@@ -275,3 +275,9 @@ bench_sums! {\n     bench_skip_while_chain_ref_sum,\n     (0i64..1000000).chain(0..1000000).skip_while(|&x| x < 1000)\n }\n+\n+bench_sums! {\n+    bench_take_while_chain_sum,\n+    bench_take_while_chain_ref_sum,\n+    (0i64..1000000).chain(1000000..).take_while(|&x| x < 1111111)\n+}"}, {"sha": "8dbb3a98beecdadc0f84e73fa1eea564ba2ab0ce", "filename": "src/libcore/iter/iterator.rs", "status": "modified", "additions": 137, "deletions": 55, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/eef4d42a3f04519af885932de1826cbfebdeeb55/src%2Flibcore%2Fiter%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eef4d42a3f04519af885932de1826cbfebdeeb55/src%2Flibcore%2Fiter%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fiterator.rs?ref=eef4d42a3f04519af885932de1826cbfebdeeb55", "patch": "@@ -9,7 +9,9 @@\n // except according to those terms.\n \n use cmp::Ordering;\n+use ops::Try;\n \n+use super::{AlwaysOk, LoopState};\n use super::{Chain, Cycle, Cloned, Enumerate, Filter, FilterMap, FlatMap, Fuse};\n use super::{Inspect, Map, Peekable, Scan, Skip, SkipWhile, StepBy, Take, TakeWhile, Rev};\n use super::{Zip, Sum, Product};\n@@ -251,12 +253,8 @@ pub trait Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn nth(&mut self, mut n: usize) -> Option<Self::Item> {\n-        for x in self {\n-            if n == 0 { return Some(x) }\n-            n -= 1;\n-        }\n-        None\n+    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n+        self.spec_nth(n)\n     }\n \n     /// Creates an iterator starting at the same point, but stepping by\n@@ -1337,6 +1335,78 @@ pub trait Iterator {\n         (left, right)\n     }\n \n+    /// An iterator method that applies a function as long as it returns\n+    /// successfully, producing a single, final value.\n+    ///\n+    /// `try_fold()` takes two arguments: an initial value, and a closure with\n+    /// two arguments: an 'accumulator', and an element. The closure either\n+    /// returns successfully, with the value that the accumulator should have\n+    /// for the next iteration, or it returns failure, with an error value that\n+    /// is propagated back to the caller immediately (short-circuiting).\n+    ///\n+    /// The initial value is the value the accumulator will have on the first\n+    /// call.  If applying the closure succeeded against every element of the\n+    /// iterator, `try_fold()` returns the final accumulator as success.\n+    ///\n+    /// Folding is useful whenever you have a collection of something, and want\n+    /// to produce a single value from it.\n+    ///\n+    /// # Note to Implementors\n+    ///\n+    /// Most of the other (forward) methods have default implementations in\n+    /// terms of this one, so try to implement this explicitly if it can\n+    /// do something better than the default `for` loop implementation.\n+    ///\n+    /// In particular, try to have this call `try_fold()` on the internal parts\n+    /// from which this iterator is composed.  If multiple calls are needed,\n+    /// the `?` operator be convenient for chaining the accumulator value along,\n+    /// but beware any invariants that need to be upheld before those early\n+    /// returns.  This is a `&mut self` method, so iteration needs to be\n+    /// resumable after hitting an error here.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(iterator_try_fold)]\n+    /// let a = [1, 2, 3];\n+    ///\n+    /// // the checked sum of all of the elements of a\n+    /// let sum = a.iter()\n+    ///            .try_fold(0i8, |acc, &x| acc.checked_add(x));\n+    ///\n+    /// assert_eq!(sum, Some(6));\n+    /// ```\n+    ///\n+    /// Short-circuiting:\n+    ///\n+    /// ```\n+    /// #![feature(iterator_try_fold)]\n+    /// let a = [10, 20, 30, 100, 40, 50];\n+    /// let mut it = a.iter();\n+    ///\n+    /// // This sum overflows when adding the 100 element\n+    /// let sum = it.try_fold(0i8, |acc, &x| acc.checked_add(x));\n+    /// assert_eq!(sum, None);\n+    ///\n+    /// // Because it short-circuited, the remaining elements are still\n+    /// // available through the iterator.\n+    /// assert_eq!(it.len(), 2);\n+    /// assert_eq!(it.next(), Some(&40));\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"iterator_try_fold\", issue = \"45594\")]\n+    fn try_fold<B, F, R>(&mut self, init: B, mut f: F) -> R where\n+        Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n+    {\n+        let mut accum = init;\n+        while let Some(x) = self.next() {\n+            accum = f(accum, x)?;\n+        }\n+        Try::from_ok(accum)\n+    }\n+\n     /// An iterator method that applies a function, producing a single, final value.\n     ///\n     /// `fold()` takes two arguments: an initial value, and a closure with two\n@@ -1403,14 +1473,10 @@ pub trait Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn fold<B, F>(self, init: B, mut f: F) -> B where\n+    fn fold<B, F>(mut self, init: B, mut f: F) -> B where\n         Self: Sized, F: FnMut(B, Self::Item) -> B,\n     {\n-        let mut accum = init;\n-        for x in self {\n-            accum = f(accum, x);\n-        }\n-        accum\n+        self.try_fold(init, move |acc, x| AlwaysOk(f(acc, x))).0\n     }\n \n     /// Tests if every element of the iterator matches a predicate.\n@@ -1455,12 +1521,10 @@ pub trait Iterator {\n     fn all<F>(&mut self, mut f: F) -> bool where\n         Self: Sized, F: FnMut(Self::Item) -> bool\n     {\n-        for x in self {\n-            if !f(x) {\n-                return false;\n-            }\n-        }\n-        true\n+        self.try_fold((), move |(), x| {\n+            if f(x) { LoopState::Continue(()) }\n+            else { LoopState::Break(()) }\n+        }) == LoopState::Continue(())\n     }\n \n     /// Tests if any element of the iterator matches a predicate.\n@@ -1506,12 +1570,10 @@ pub trait Iterator {\n         Self: Sized,\n         F: FnMut(Self::Item) -> bool\n     {\n-        for x in self {\n-            if f(x) {\n-                return true;\n-            }\n-        }\n-        false\n+        self.try_fold((), move |(), x| {\n+            if f(x) { LoopState::Break(()) }\n+            else { LoopState::Continue(()) }\n+        }) == LoopState::Break(())\n     }\n \n     /// Searches for an element of an iterator that satisfies a predicate.\n@@ -1562,10 +1624,10 @@ pub trait Iterator {\n         Self: Sized,\n         P: FnMut(&Self::Item) -> bool,\n     {\n-        for x in self {\n-            if predicate(&x) { return Some(x) }\n-        }\n-        None\n+        self.try_fold((), move |(), x| {\n+            if predicate(&x) { LoopState::Break(x) }\n+            else { LoopState::Continue(()) }\n+        }).break_value()\n     }\n \n     /// Searches for an element in an iterator, returning its index.\n@@ -1623,18 +1685,17 @@ pub trait Iterator {\n     ///\n     /// ```\n     #[inline]\n+    #[rustc_inherit_overflow_checks]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn position<P>(&mut self, mut predicate: P) -> Option<usize> where\n         Self: Sized,\n         P: FnMut(Self::Item) -> bool,\n     {\n-        // `enumerate` might overflow.\n-        for (i, x) in self.enumerate() {\n-            if predicate(x) {\n-                return Some(i);\n-            }\n-        }\n-        None\n+        // The addition might panic on overflow\n+        self.try_fold(0, move |i, x| {\n+            if predicate(x) { LoopState::Break(i) }\n+            else { LoopState::Continue(i + 1) }\n+        }).break_value()\n     }\n \n     /// Searches for an element in an iterator from the right, returning its\n@@ -1681,17 +1742,14 @@ pub trait Iterator {\n         P: FnMut(Self::Item) -> bool,\n         Self: Sized + ExactSizeIterator + DoubleEndedIterator\n     {\n-        let mut i = self.len();\n-\n-        while let Some(v) = self.next_back() {\n-            // No need for an overflow check here, because `ExactSizeIterator`\n-            // implies that the number of elements fits into a `usize`.\n-            i -= 1;\n-            if predicate(v) {\n-                return Some(i);\n-            }\n-        }\n-        None\n+        // No need for an overflow check here, because `ExactSizeIterator`\n+        // implies that the number of elements fits into a `usize`.\n+        let n = self.len();\n+        self.try_rfold(n, move |i, x| {\n+            let i = i - 1;\n+            if predicate(x) { LoopState::Break(i) }\n+            else { LoopState::Continue(i) }\n+        }).break_value()\n     }\n \n     /// Returns the maximum element of an iterator.\n@@ -1922,10 +1980,10 @@ pub trait Iterator {\n         let mut ts: FromA = Default::default();\n         let mut us: FromB = Default::default();\n \n-        for (t, u) in self {\n+        self.for_each(|(t, u)| {\n             ts.extend(Some(t));\n             us.extend(Some(u));\n-        }\n+        });\n \n         (ts, us)\n     }\n@@ -2300,17 +2358,17 @@ fn select_fold1<I, B, FProj, FCmp>(mut it: I,\n     // start with the first element as our selection. This avoids\n     // having to use `Option`s inside the loop, translating to a\n     // sizeable performance gain (6x in one case).\n-    it.next().map(|mut sel| {\n-        let mut sel_p = f_proj(&sel);\n+    it.next().map(|first| {\n+        let first_p = f_proj(&first);\n \n-        for x in it {\n+        it.fold((first_p, first), |(sel_p, sel), x| {\n             let x_p = f_proj(&x);\n             if f_cmp(&sel_p, &sel, &x_p, &x) {\n-                sel = x;\n-                sel_p = x_p;\n+                (x_p, x)\n+            } else {\n+                (sel_p, sel)\n             }\n-        }\n-        (sel_p, sel)\n+        })\n     })\n }\n \n@@ -2323,3 +2381,27 @@ impl<'a, I: Iterator + ?Sized> Iterator for &'a mut I {\n         (**self).nth(n)\n     }\n }\n+\n+\n+trait SpecIterator : Iterator {\n+    fn spec_nth(&mut self, n: usize) -> Option<Self::Item>;\n+}\n+\n+impl<I: Iterator + ?Sized> SpecIterator for I {\n+    default fn spec_nth(&mut self, mut n: usize) -> Option<Self::Item> {\n+        for x in self {\n+            if n == 0 { return Some(x) }\n+            n -= 1;\n+        }\n+        None\n+   }\n+}\n+\n+impl<I: Iterator + Sized> SpecIterator for I {\n+    fn spec_nth(&mut self, n: usize) -> Option<Self::Item> {\n+        self.try_fold(n, move |i, x| {\n+            if i == 0 { LoopState::Break(x) }\n+            else { LoopState::Continue(i - 1) }\n+        }).break_value()\n+   }\n+}"}, {"sha": "ff0f46a7b134ced79bf1c154d0508b16ff402033", "filename": "src/libcore/iter/mod.rs", "status": "modified", "additions": 450, "deletions": 6, "changes": 456, "blob_url": "https://github.com/rust-lang/rust/blob/eef4d42a3f04519af885932de1826cbfebdeeb55/src%2Flibcore%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eef4d42a3f04519af885932de1826cbfebdeeb55/src%2Flibcore%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fmod.rs?ref=eef4d42a3f04519af885932de1826cbfebdeeb55", "patch": "@@ -305,6 +305,7 @@\n use cmp;\n use fmt;\n use iter_private::TrustedRandomAccess;\n+use ops::Try;\n use usize;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -336,6 +337,71 @@ mod range;\n mod sources;\n mod traits;\n \n+/// Transparent newtype used to implement foo methods in terms of try_foo.\n+/// Important until #43278 is fixed; might be better as `Result<T, !>` later.\n+struct AlwaysOk<T>(pub T);\n+\n+impl<T> Try for AlwaysOk<T> {\n+    type Ok = T;\n+    type Error = !;\n+    #[inline]\n+    fn into_result(self) -> Result<Self::Ok, Self::Error> { Ok(self.0) }\n+    #[inline]\n+    fn from_error(v: Self::Error) -> Self { v }\n+    #[inline]\n+    fn from_ok(v: Self::Ok) -> Self { AlwaysOk(v) }\n+}\n+\n+/// Used to make try_fold closures more like normal loops\n+#[derive(PartialEq)]\n+enum LoopState<C, B> {\n+    Continue(C),\n+    Break(B),\n+}\n+\n+impl<C, B> Try for LoopState<C, B> {\n+    type Ok = C;\n+    type Error = B;\n+    #[inline]\n+    fn into_result(self) -> Result<Self::Ok, Self::Error> {\n+        match self {\n+            LoopState::Continue(y) => Ok(y),\n+            LoopState::Break(x) => Err(x),\n+        }\n+    }\n+    #[inline]\n+    fn from_error(v: Self::Error) -> Self { LoopState::Break(v) }\n+    #[inline]\n+    fn from_ok(v: Self::Ok) -> Self { LoopState::Continue(v) }\n+}\n+\n+impl<C, B> LoopState<C, B> {\n+    #[inline]\n+    fn break_value(self) -> Option<B> {\n+        match self {\n+            LoopState::Continue(..) => None,\n+            LoopState::Break(x) => Some(x),\n+        }\n+    }\n+}\n+\n+impl<R: Try> LoopState<R::Ok, R> {\n+    #[inline]\n+    fn from_try(r: R) -> Self {\n+        match Try::into_result(r) {\n+            Ok(v) => LoopState::Continue(v),\n+            Err(v) => LoopState::Break(Try::from_error(v)),\n+        }\n+    }\n+    #[inline]\n+    fn into_try(self) -> R {\n+        match self {\n+            LoopState::Continue(v) => Try::from_ok(v),\n+            LoopState::Break(v) => v,\n+        }\n+    }\n+}\n+\n /// A double-ended iterator with the direction inverted.\n ///\n /// This `struct` is created by the [`rev`] method on [`Iterator`]. See its\n@@ -359,6 +425,12 @@ impl<I> Iterator for Rev<I> where I: DoubleEndedIterator {\n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n \n+    fn try_fold<B, F, R>(&mut self, init: B, f: F) -> R where\n+        Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n+    {\n+        self.iter.try_rfold(init, f)\n+    }\n+\n     fn fold<Acc, F>(self, init: Acc, f: F) -> Acc\n         where F: FnMut(Acc, Self::Item) -> Acc,\n     {\n@@ -385,6 +457,12 @@ impl<I> DoubleEndedIterator for Rev<I> where I: DoubleEndedIterator {\n     #[inline]\n     fn next_back(&mut self) -> Option<<I as Iterator>::Item> { self.iter.next() }\n \n+    fn try_rfold<B, F, R>(&mut self, init: B, f: F) -> R where\n+        Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n+    {\n+        self.iter.try_fold(init, f)\n+    }\n+\n     fn rfold<Acc, F>(self, init: Acc, f: F) -> Acc\n         where F: FnMut(Acc, Self::Item) -> Acc,\n     {\n@@ -447,6 +525,12 @@ impl<'a, I, T: 'a> Iterator for Cloned<I>\n         self.it.size_hint()\n     }\n \n+    fn try_fold<B, F, R>(&mut self, init: B, mut f: F) -> R where\n+        Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n+    {\n+        self.it.try_fold(init, move |acc, elt| f(acc, elt.clone()))\n+    }\n+\n     fn fold<Acc, F>(self, init: Acc, mut f: F) -> Acc\n         where F: FnMut(Acc, Self::Item) -> Acc,\n     {\n@@ -462,6 +546,12 @@ impl<'a, I, T: 'a> DoubleEndedIterator for Cloned<I>\n         self.it.next_back().cloned()\n     }\n \n+    fn try_rfold<B, F, R>(&mut self, init: B, mut f: F) -> R where\n+        Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n+    {\n+        self.it.try_rfold(init, move |acc, elt| f(acc, elt.clone()))\n+    }\n+\n     fn rfold<Acc, F>(self, init: Acc, mut f: F) -> Acc\n         where F: FnMut(Acc, Self::Item) -> Acc,\n     {\n@@ -683,6 +773,28 @@ impl<A, B> Iterator for Chain<A, B> where\n         }\n     }\n \n+    fn try_fold<Acc, F, R>(&mut self, init: Acc, mut f: F) -> R where\n+        Self: Sized, F: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        let mut accum = init;\n+        match self.state {\n+            ChainState::Both | ChainState::Front => {\n+                accum = self.a.try_fold(accum, &mut f)?;\n+                if let ChainState::Both = self.state {\n+                    self.state = ChainState::Back;\n+                }\n+            }\n+            _ => { }\n+        }\n+        match self.state {\n+            ChainState::Both | ChainState::Back => {\n+                accum = self.b.try_fold(accum, &mut f)?;\n+            }\n+            _ => { }\n+        }\n+        Try::from_ok(accum)\n+    }\n+\n     fn fold<Acc, F>(self, init: Acc, mut f: F) -> Acc\n         where F: FnMut(Acc, Self::Item) -> Acc,\n     {\n@@ -792,6 +904,28 @@ impl<A, B> DoubleEndedIterator for Chain<A, B> where\n         }\n     }\n \n+    fn try_rfold<Acc, F, R>(&mut self, init: Acc, mut f: F) -> R where\n+        Self: Sized, F: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        let mut accum = init;\n+        match self.state {\n+            ChainState::Both | ChainState::Back => {\n+                accum = self.b.try_rfold(accum, &mut f)?;\n+                if let ChainState::Both = self.state {\n+                    self.state = ChainState::Front;\n+                }\n+            }\n+            _ => { }\n+        }\n+        match self.state {\n+            ChainState::Both | ChainState::Front => {\n+                accum = self.a.try_rfold(accum, &mut f)?;\n+            }\n+            _ => { }\n+        }\n+        Try::from_ok(accum)\n+    }\n+\n     fn rfold<Acc, F>(self, init: Acc, mut f: F) -> Acc\n         where F: FnMut(Acc, Self::Item) -> Acc,\n     {\n@@ -1128,6 +1262,13 @@ impl<B, I: Iterator, F> Iterator for Map<I, F> where F: FnMut(I::Item) -> B {\n         self.iter.size_hint()\n     }\n \n+    fn try_fold<Acc, G, R>(&mut self, init: Acc, mut g: G) -> R where\n+        Self: Sized, G: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        let f = &mut self.f;\n+        self.iter.try_fold(init, move |acc, elt| g(acc, f(elt)))\n+    }\n+\n     fn fold<Acc, G>(self, init: Acc, mut g: G) -> Acc\n         where G: FnMut(Acc, Self::Item) -> Acc,\n     {\n@@ -1145,6 +1286,13 @@ impl<B, I: DoubleEndedIterator, F> DoubleEndedIterator for Map<I, F> where\n         self.iter.next_back().map(&mut self.f)\n     }\n \n+    fn try_rfold<Acc, G, R>(&mut self, init: Acc, mut g: G) -> R where\n+        Self: Sized, G: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        let f = &mut self.f;\n+        self.iter.try_rfold(init, move |acc, elt| g(acc, f(elt)))\n+    }\n+\n     fn rfold<Acc, G>(self, init: Acc, mut g: G) -> Acc\n         where G: FnMut(Acc, Self::Item) -> Acc,\n     {\n@@ -1251,6 +1399,18 @@ impl<I: Iterator, P> Iterator for Filter<I, P> where P: FnMut(&I::Item) -> bool\n         count\n     }\n \n+    #[inline]\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        let predicate = &mut self.predicate;\n+        self.iter.try_fold(init, move |acc, item| if predicate(&item) {\n+            fold(acc, item)\n+        } else {\n+            Try::from_ok(acc)\n+        })\n+    }\n+\n     #[inline]\n     fn fold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n         where Fold: FnMut(Acc, Self::Item) -> Acc,\n@@ -1278,6 +1438,18 @@ impl<I: DoubleEndedIterator, P> DoubleEndedIterator for Filter<I, P>\n         None\n     }\n \n+    #[inline]\n+    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        let predicate = &mut self.predicate;\n+        self.iter.try_rfold(init, move |acc, item| if predicate(&item) {\n+            fold(acc, item)\n+        } else {\n+            Try::from_ok(acc)\n+        })\n+    }\n+\n     #[inline]\n     fn rfold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n         where Fold: FnMut(Acc, Self::Item) -> Acc,\n@@ -1341,6 +1513,17 @@ impl<B, I: Iterator, F> Iterator for FilterMap<I, F>\n         (0, upper) // can't know a lower bound, due to the predicate\n     }\n \n+    #[inline]\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        let f = &mut self.f;\n+        self.iter.try_fold(init, move |acc, item| match f(item) {\n+            Some(x) => fold(acc, x),\n+            None => Try::from_ok(acc),\n+        })\n+    }\n+\n     #[inline]\n     fn fold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n         where Fold: FnMut(Acc, Self::Item) -> Acc,\n@@ -1367,6 +1550,17 @@ impl<B, I: DoubleEndedIterator, F> DoubleEndedIterator for FilterMap<I, F>\n         None\n     }\n \n+    #[inline]\n+    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        let f = &mut self.f;\n+        self.iter.try_rfold(init, move |acc, item| match f(item) {\n+            Some(x) => fold(acc, x),\n+            None => Try::from_ok(acc),\n+        })\n+    }\n+\n     #[inline]\n     fn rfold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n         where Fold: FnMut(Acc, Self::Item) -> Acc,\n@@ -1442,6 +1636,19 @@ impl<I> Iterator for Enumerate<I> where I: Iterator {\n         self.iter.count()\n     }\n \n+    #[inline]\n+    #[rustc_inherit_overflow_checks]\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        let count = &mut self.count;\n+        self.iter.try_fold(init, move |acc, item| {\n+            let acc = fold(acc, (*count, item));\n+            *count += 1;\n+            acc\n+        })\n+    }\n+\n     #[inline]\n     #[rustc_inherit_overflow_checks]\n     fn fold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n@@ -1470,6 +1677,19 @@ impl<I> DoubleEndedIterator for Enumerate<I> where\n         })\n     }\n \n+    #[inline]\n+    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        // Can safely add and subtract the count, as `ExactSizeIterator` promises\n+        // that the number of elements fits into a `usize`.\n+        let mut count = self.count + self.iter.len();\n+        self.iter.try_rfold(init, move |acc, item| {\n+            count -= 1;\n+            fold(acc, (count, item))\n+        })\n+    }\n+\n     #[inline]\n     fn rfold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n         where Fold: FnMut(Acc, Self::Item) -> Acc,\n@@ -1594,6 +1814,18 @@ impl<I: Iterator> Iterator for Peekable<I> {\n         (lo, hi)\n     }\n \n+    #[inline]\n+    fn try_fold<B, F, R>(&mut self, init: B, mut f: F) -> R where\n+        Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n+    {\n+        let acc = match self.peeked.take() {\n+            Some(None) => return Try::from_ok(init),\n+            Some(Some(v)) => f(init, v)?,\n+            None => init,\n+        };\n+        self.iter.try_fold(acc, f)\n+    }\n+\n     #[inline]\n     fn fold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n         where Fold: FnMut(Acc, Self::Item) -> Acc,\n@@ -1699,13 +1931,16 @@ impl<I: Iterator, P> Iterator for SkipWhile<I, P>\n \n     #[inline]\n     fn next(&mut self) -> Option<I::Item> {\n-        for x in self.iter.by_ref() {\n-            if self.flag || !(self.predicate)(&x) {\n-                self.flag = true;\n-                return Some(x);\n+        let flag = &mut self.flag;\n+        let pred = &mut self.predicate;\n+        self.iter.find(move |x| {\n+            if *flag || !pred(x) {\n+                *flag = true;\n+                true\n+            } else {\n+                false\n             }\n-        }\n-        None\n+        })\n     }\n \n     #[inline]\n@@ -1714,6 +1949,19 @@ impl<I: Iterator, P> Iterator for SkipWhile<I, P>\n         (0, upper) // can't know a lower bound, due to the predicate\n     }\n \n+    #[inline]\n+    fn try_fold<Acc, Fold, R>(&mut self, mut init: Acc, mut fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        if !self.flag {\n+            match self.next() {\n+                Some(v) => init = fold(init, v)?,\n+                None => return Try::from_ok(init),\n+            }\n+        }\n+        self.iter.try_fold(init, fold)\n+    }\n+\n     #[inline]\n     fn fold<Acc, Fold>(mut self, mut init: Acc, mut fold: Fold) -> Acc\n         where Fold: FnMut(Acc, Self::Item) -> Acc,\n@@ -1785,6 +2033,26 @@ impl<I: Iterator, P> Iterator for TakeWhile<I, P>\n         let (_, upper) = self.iter.size_hint();\n         (0, upper) // can't know a lower bound, due to the predicate\n     }\n+\n+    #[inline]\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        if self.flag {\n+            Try::from_ok(init)\n+        } else {\n+            let flag = &mut self.flag;\n+            let p = &mut self.predicate;\n+            self.iter.try_fold(init, move |acc, x|{\n+                if p(&x) {\n+                    LoopState::from_try(fold(acc, x))\n+                } else {\n+                    *flag = true;\n+                    LoopState::Break(Try::from_ok(acc))\n+                }\n+            }).into_try()\n+        }\n+    }\n }\n \n #[unstable(feature = \"fused\", issue = \"35602\")]\n@@ -1867,6 +2135,21 @@ impl<I> Iterator for Skip<I> where I: Iterator {\n         (lower, upper)\n     }\n \n+    #[inline]\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        let n = self.n;\n+        self.n = 0;\n+        if n > 0 {\n+            // nth(n) skips n+1\n+            if self.iter.nth(n - 1).is_none() {\n+                return Try::from_ok(init);\n+            }\n+        }\n+        self.iter.try_fold(init, fold)\n+    }\n+\n     #[inline]\n     fn fold<Acc, Fold>(mut self, init: Acc, fold: Fold) -> Acc\n         where Fold: FnMut(Acc, Self::Item) -> Acc,\n@@ -1893,6 +2176,22 @@ impl<I> DoubleEndedIterator for Skip<I> where I: DoubleEndedIterator + ExactSize\n             None\n         }\n     }\n+\n+    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        let mut n = self.len();\n+        if n == 0 {\n+            Try::from_ok(init)\n+        } else {\n+            self.iter.try_rfold(init, move |acc, x| {\n+                n -= 1;\n+                let r = fold(acc, x);\n+                if n == 0 { LoopState::Break(r) }\n+                else { LoopState::from_try(r) }\n+            }).into_try()\n+        }\n+    }\n }\n \n #[unstable(feature = \"fused\", issue = \"35602\")]\n@@ -1954,6 +2253,23 @@ impl<I> Iterator for Take<I> where I: Iterator{\n \n         (lower, upper)\n     }\n+\n+    #[inline]\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        if self.n == 0 {\n+            Try::from_ok(init)\n+        } else {\n+            let n = &mut self.n;\n+            self.iter.try_fold(init, move |acc, x| {\n+                *n -= 1;\n+                let r = fold(acc, x);\n+                if *n == 0 { LoopState::Break(r) }\n+                else { LoopState::from_try(r) }\n+            }).into_try()\n+        }\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -2005,6 +2321,20 @@ impl<B, I, St, F> Iterator for Scan<I, St, F> where\n         let (_, upper) = self.iter.size_hint();\n         (0, upper) // can't know a lower bound, due to the scan function\n     }\n+\n+    #[inline]\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        let state = &mut self.state;\n+        let f = &mut self.f;\n+        self.iter.try_fold(init, move |acc, x| {\n+            match f(state, x) {\n+                None => LoopState::Break(Try::from_ok(acc)),\n+                Some(x) => LoopState::from_try(fold(acc, x)),\n+            }\n+        }).into_try()\n+    }\n }\n \n /// An iterator that maps each element to an iterator, and yields the elements\n@@ -2070,6 +2400,35 @@ impl<I: Iterator, U: IntoIterator, F> Iterator for FlatMap<I, U, F>\n         }\n     }\n \n+    #[inline]\n+    fn try_fold<Acc, Fold, R>(&mut self, mut init: Acc, mut fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        if let Some(ref mut front) = self.frontiter {\n+            init = front.try_fold(init, &mut fold)?;\n+        }\n+        self.frontiter = None;\n+\n+        {\n+            let f = &mut self.f;\n+            let frontiter = &mut self.frontiter;\n+            init = self.iter.try_fold(init, |acc, x| {\n+                let mut mid = f(x).into_iter();\n+                let r = mid.try_fold(acc, &mut fold);\n+                *frontiter = Some(mid);\n+                r\n+            })?;\n+        }\n+        self.frontiter = None;\n+\n+        if let Some(ref mut back) = self.backiter {\n+            init = back.try_fold(init, &mut fold)?;\n+        }\n+        self.backiter = None;\n+\n+        Try::from_ok(init)\n+    }\n+\n     #[inline]\n     fn fold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n         where Fold: FnMut(Acc, Self::Item) -> Acc,\n@@ -2102,6 +2461,35 @@ impl<I: DoubleEndedIterator, U, F> DoubleEndedIterator for FlatMap<I, U, F> wher\n         }\n     }\n \n+    #[inline]\n+    fn try_rfold<Acc, Fold, R>(&mut self, mut init: Acc, mut fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        if let Some(ref mut back) = self.backiter {\n+            init = back.try_rfold(init, &mut fold)?;\n+        }\n+        self.backiter = None;\n+\n+        {\n+            let f = &mut self.f;\n+            let backiter = &mut self.backiter;\n+            init = self.iter.try_rfold(init, |acc, x| {\n+                let mut mid = f(x).into_iter();\n+                let r = mid.try_rfold(acc, &mut fold);\n+                *backiter = Some(mid);\n+                r\n+            })?;\n+        }\n+        self.backiter = None;\n+\n+        if let Some(ref mut front) = self.frontiter {\n+            init = front.try_rfold(init, &mut fold)?;\n+        }\n+        self.frontiter = None;\n+\n+        Try::from_ok(init)\n+    }\n+\n     #[inline]\n     fn rfold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n         where Fold: FnMut(Acc, Self::Item) -> Acc,\n@@ -2189,6 +2577,19 @@ impl<I> Iterator for Fuse<I> where I: Iterator {\n         }\n     }\n \n+    #[inline]\n+    default fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        if self.done {\n+            Try::from_ok(init)\n+        } else {\n+            let acc = self.iter.try_fold(init, fold)?;\n+            self.done = true;\n+            Try::from_ok(acc)\n+        }\n+    }\n+\n     #[inline]\n     default fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n         where Fold: FnMut(Acc, Self::Item) -> Acc,\n@@ -2214,6 +2615,19 @@ impl<I> DoubleEndedIterator for Fuse<I> where I: DoubleEndedIterator {\n         }\n     }\n \n+    #[inline]\n+    default fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        if self.done {\n+            Try::from_ok(init)\n+        } else {\n+            let acc = self.iter.try_rfold(init, fold)?;\n+            self.done = true;\n+            Try::from_ok(acc)\n+        }\n+    }\n+\n     #[inline]\n     default fn rfold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n         where Fold: FnMut(Acc, Self::Item) -> Acc,\n@@ -2265,6 +2679,13 @@ impl<I> Iterator for Fuse<I> where I: FusedIterator {\n         self.iter.size_hint()\n     }\n \n+    #[inline]\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        self.iter.try_fold(init, fold)\n+    }\n+\n     #[inline]\n     fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n         where Fold: FnMut(Acc, Self::Item) -> Acc,\n@@ -2282,6 +2703,13 @@ impl<I> DoubleEndedIterator for Fuse<I>\n         self.iter.next_back()\n     }\n \n+    #[inline]\n+    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        self.iter.try_rfold(init, fold)\n+    }\n+\n     #[inline]\n     fn rfold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n         where Fold: FnMut(Acc, Self::Item) -> Acc,\n@@ -2353,6 +2781,14 @@ impl<I: Iterator, F> Iterator for Inspect<I, F> where F: FnMut(&I::Item) {\n         self.iter.size_hint()\n     }\n \n+    #[inline]\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        let f = &mut self.f;\n+        self.iter.try_fold(init, move |acc, item| { f(&item); fold(acc, item) })\n+    }\n+\n     #[inline]\n     fn fold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n         where Fold: FnMut(Acc, Self::Item) -> Acc,\n@@ -2372,6 +2808,14 @@ impl<I: DoubleEndedIterator, F> DoubleEndedIterator for Inspect<I, F>\n         self.do_inspect(next)\n     }\n \n+    #[inline]\n+    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        let f = &mut self.f;\n+        self.iter.try_rfold(init, move |acc, item| { f(&item); fold(acc, item) })\n+    }\n+\n     #[inline]\n     fn rfold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n         where Fold: FnMut(Acc, Self::Item) -> Acc,"}, {"sha": "11e668d228c48a1b71ec7925fb7b9208049cf0e8", "filename": "src/libcore/iter/traits.rs", "status": "modified", "additions": 55, "deletions": 10, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/eef4d42a3f04519af885932de1826cbfebdeeb55/src%2Flibcore%2Fiter%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eef4d42a3f04519af885932de1826cbfebdeeb55/src%2Flibcore%2Fiter%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits.rs?ref=eef4d42a3f04519af885932de1826cbfebdeeb55", "patch": "@@ -7,9 +7,11 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n-use ops::{Mul, Add};\n+use ops::{Mul, Add, Try};\n use num::Wrapping;\n \n+use super::{AlwaysOk, LoopState};\n+\n /// Conversion from an `Iterator`.\n ///\n /// By implementing `FromIterator` for a type, you define how it will be\n@@ -415,6 +417,52 @@ pub trait DoubleEndedIterator: Iterator {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn next_back(&mut self) -> Option<Self::Item>;\n \n+    /// This is the reverse version of [`try_fold()`]: it takes elements\n+    /// starting from the back of the iterator.\n+    ///\n+    /// [`try_fold()`]: trait.Iterator.html#method.try_fold\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(iterator_try_fold)]\n+    /// let a = [\"1\", \"2\", \"3\"];\n+    /// let sum = a.iter()\n+    ///     .map(|&s| s.parse::<i32>())\n+    ///     .try_rfold(0, |acc, x| x.and_then(|y| Ok(acc + y)));\n+    /// assert_eq!(sum, Ok(6));\n+    /// ```\n+    ///\n+    /// Short-circuiting:\n+    ///\n+    /// ```\n+    /// #![feature(iterator_try_fold)]\n+    /// let a = [\"1\", \"rust\", \"3\"];\n+    /// let mut it = a.iter();\n+    /// let sum = it\n+    ///     .by_ref()\n+    ///     .map(|&s| s.parse::<i32>())\n+    ///     .try_rfold(0, |acc, x| x.and_then(|y| Ok(acc + y)));\n+    /// assert!(sum.is_err());\n+    ///\n+    /// // Because it short-circuited, the remaining elements are still\n+    /// // available through the iterator.\n+    /// assert_eq!(it.next_back(), Some(&\"1\"));\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"iterator_try_fold\", issue = \"45594\")]\n+    fn try_rfold<B, F, R>(&mut self, init: B, mut f: F) -> R where\n+        Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n+    {\n+        let mut accum = init;\n+        while let Some(x) = self.next_back() {\n+            accum = f(accum, x)?;\n+        }\n+        Try::from_ok(accum)\n+    }\n+\n     /// An iterator method that reduces the iterator's elements to a single,\n     /// final value, starting from the back.\n     ///\n@@ -470,13 +518,10 @@ pub trait DoubleEndedIterator: Iterator {\n     /// ```\n     #[inline]\n     #[unstable(feature = \"iter_rfold\", issue = \"44705\")]\n-    fn rfold<B, F>(mut self, mut accum: B, mut f: F) -> B where\n+    fn rfold<B, F>(mut self, accum: B, mut f: F) -> B where\n         Self: Sized, F: FnMut(B, Self::Item) -> B,\n     {\n-        while let Some(x) = self.next_back() {\n-            accum = f(accum, x);\n-        }\n-        accum\n+        self.try_rfold(accum, move |acc, x| AlwaysOk(f(acc, x))).0\n     }\n \n     /// Searches for an element of an iterator from the right that satisfies a predicate.\n@@ -531,10 +576,10 @@ pub trait DoubleEndedIterator: Iterator {\n         Self: Sized,\n         P: FnMut(&Self::Item) -> bool\n     {\n-        while let Some(x) = self.next_back() {\n-            if predicate(&x) { return Some(x) }\n-        }\n-        None\n+        self.try_rfold((), move |(), x| {\n+            if predicate(&x) { LoopState::Break(x) }\n+            else { LoopState::Continue(()) }\n+        }).break_value()\n     }\n }\n "}, {"sha": "b5e45b5b5585ab2bdc39a2fdf07359086452d75e", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 45, "deletions": 110, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/eef4d42a3f04519af885932de1826cbfebdeeb55/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eef4d42a3f04519af885932de1826cbfebdeeb55/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=eef4d42a3f04519af885932de1826cbfebdeeb55", "patch": "@@ -43,7 +43,7 @@ use cmp;\n use fmt;\n use intrinsics::assume;\n use iter::*;\n-use ops::{FnMut, self};\n+use ops::{FnMut, Try, self};\n use option::Option;\n use option::Option::{None, Some};\n use result::Result;\n@@ -1166,62 +1166,37 @@ macro_rules! iterator {\n                 self.next_back()\n             }\n \n-            fn all<F>(&mut self, mut predicate: F) -> bool\n-                where F: FnMut(Self::Item) -> bool,\n-            {\n-                self.search_while(true, move |elt| {\n-                    if predicate(elt) {\n-                        SearchWhile::Continue\n-                    } else {\n-                        SearchWhile::Done(false)\n-                    }\n-                })\n-            }\n-\n-            fn any<F>(&mut self, mut predicate: F) -> bool\n-                where F: FnMut(Self::Item) -> bool,\n-            {\n-                !self.all(move |elt| !predicate(elt))\n-            }\n-\n-            fn find<F>(&mut self, mut predicate: F) -> Option<Self::Item>\n-                where F: FnMut(&Self::Item) -> bool,\n+            #[inline]\n+            fn try_fold<B, F, R>(&mut self, init: B, mut f: F) -> R where\n+                Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n             {\n-                self.search_while(None, move |elt| {\n-                    if predicate(&elt) {\n-                        SearchWhile::Done(Some(elt))\n-                    } else {\n-                        SearchWhile::Continue\n+                // manual unrolling is needed when there are conditional exits from the loop\n+                let mut accum = init;\n+                unsafe {\n+                    while ptrdistance(self.ptr, self.end) >= 4 {\n+                        accum = f(accum, $mkref!(self.ptr.post_inc()))?;\n+                        accum = f(accum, $mkref!(self.ptr.post_inc()))?;\n+                        accum = f(accum, $mkref!(self.ptr.post_inc()))?;\n+                        accum = f(accum, $mkref!(self.ptr.post_inc()))?;\n                     }\n-                })\n-            }\n-\n-            fn position<F>(&mut self, mut predicate: F) -> Option<usize>\n-                where F: FnMut(Self::Item) -> bool,\n-            {\n-                let mut index = 0;\n-                self.search_while(None, move |elt| {\n-                    if predicate(elt) {\n-                        SearchWhile::Done(Some(index))\n-                    } else {\n-                        index += 1;\n-                        SearchWhile::Continue\n+                    while self.ptr != self.end {\n+                        accum = f(accum, $mkref!(self.ptr.post_inc()))?;\n                     }\n-                })\n+                }\n+                Try::from_ok(accum)\n             }\n \n-            fn rposition<F>(&mut self, mut predicate: F) -> Option<usize>\n-                where F: FnMut(Self::Item) -> bool,\n+            #[inline]\n+            fn fold<Acc, Fold>(mut self, init: Acc, mut f: Fold) -> Acc\n+                where Fold: FnMut(Acc, Self::Item) -> Acc,\n             {\n-                let mut index = self.len();\n-                self.rsearch_while(None, move |elt| {\n-                    index -= 1;\n-                    if predicate(elt) {\n-                        SearchWhile::Done(Some(index))\n-                    } else {\n-                        SearchWhile::Continue\n-                    }\n-                })\n+                // Let LLVM unroll this, rather than using the default\n+                // impl that would force the manual unrolling above\n+                let mut accum = init;\n+                while let Some(x) = self.next() {\n+                    accum = f(accum, x);\n+                }\n+                accum\n             }\n         }\n \n@@ -1243,59 +1218,37 @@ macro_rules! iterator {\n                 }\n             }\n \n-            fn rfind<F>(&mut self, mut predicate: F) -> Option<Self::Item>\n-                where F: FnMut(&Self::Item) -> bool,\n-            {\n-                self.rsearch_while(None, move |elt| {\n-                    if predicate(&elt) {\n-                        SearchWhile::Done(Some(elt))\n-                    } else {\n-                        SearchWhile::Continue\n-                    }\n-                })\n-            }\n-\n-        }\n-\n-        // search_while is a generalization of the internal iteration methods.\n-        impl<'a, T> $name<'a, T> {\n-            // search through the iterator's element using the closure `g`.\n-            // if no element was found, return `default`.\n-            fn search_while<Acc, G>(&mut self, default: Acc, mut g: G) -> Acc\n-                where Self: Sized,\n-                      G: FnMut($elem) -> SearchWhile<Acc>\n+            #[inline]\n+            fn try_rfold<B, F, R>(&mut self, init: B, mut f: F) -> R where\n+                Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n             {\n                 // manual unrolling is needed when there are conditional exits from the loop\n+                let mut accum = init;\n                 unsafe {\n                     while ptrdistance(self.ptr, self.end) >= 4 {\n-                        search_while!(g($mkref!(self.ptr.post_inc())));\n-                        search_while!(g($mkref!(self.ptr.post_inc())));\n-                        search_while!(g($mkref!(self.ptr.post_inc())));\n-                        search_while!(g($mkref!(self.ptr.post_inc())));\n+                        accum = f(accum, $mkref!(self.end.pre_dec()))?;\n+                        accum = f(accum, $mkref!(self.end.pre_dec()))?;\n+                        accum = f(accum, $mkref!(self.end.pre_dec()))?;\n+                        accum = f(accum, $mkref!(self.end.pre_dec()))?;\n                     }\n                     while self.ptr != self.end {\n-                        search_while!(g($mkref!(self.ptr.post_inc())));\n+                        accum = f(accum, $mkref!(self.end.pre_dec()))?;\n                     }\n                 }\n-                default\n+                Try::from_ok(accum)\n             }\n \n-            fn rsearch_while<Acc, G>(&mut self, default: Acc, mut g: G) -> Acc\n-                where Self: Sized,\n-                      G: FnMut($elem) -> SearchWhile<Acc>\n+            #[inline]\n+            fn rfold<Acc, Fold>(mut self, init: Acc, mut f: Fold) -> Acc\n+                where Fold: FnMut(Acc, Self::Item) -> Acc,\n             {\n-                unsafe {\n-                    while ptrdistance(self.ptr, self.end) >= 4 {\n-                        search_while!(g($mkref!(self.end.pre_dec())));\n-                        search_while!(g($mkref!(self.end.pre_dec())));\n-                        search_while!(g($mkref!(self.end.pre_dec())));\n-                        search_while!(g($mkref!(self.end.pre_dec())));\n-                    }\n-                    while self.ptr != self.end {\n-                        search_while!(g($mkref!(self.end.pre_dec())));\n-                    }\n+                // Let LLVM unroll this, rather than using the default\n+                // impl that would force the manual unrolling above\n+                let mut accum = init;\n+                while let Some(x) = self.next_back() {\n+                    accum = f(accum, x);\n                 }\n-                default\n+                accum\n             }\n         }\n     }\n@@ -1329,24 +1282,6 @@ macro_rules! make_mut_slice {\n     }}\n }\n \n-// An enum used for controlling the execution of `.search_while()`.\n-enum SearchWhile<T> {\n-    // Continue searching\n-    Continue,\n-    // Fold is complete and will return this value\n-    Done(T),\n-}\n-\n-// helper macro for search while's control flow\n-macro_rules! search_while {\n-    ($e:expr) => {\n-        match $e {\n-            SearchWhile::Continue => { }\n-            SearchWhile::Done(done) => return done,\n-        }\n-    }\n-}\n-\n /// Immutable slice iterator\n ///\n /// This struct is created by the [`iter`] method on [slices]."}, {"sha": "5cac5b26d88bd238f3eb722885d744a3f2e16f3f", "filename": "src/libcore/tests/iter.rs", "status": "modified", "additions": 223, "deletions": 0, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/eef4d42a3f04519af885932de1826cbfebdeeb55/src%2Flibcore%2Ftests%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eef4d42a3f04519af885932de1826cbfebdeeb55/src%2Flibcore%2Ftests%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fiter.rs?ref=eef4d42a3f04519af885932de1826cbfebdeeb55", "patch": "@@ -664,6 +664,7 @@ fn test_iterator_skip_last() {\n fn test_iterator_skip_fold() {\n     let xs = [0, 1, 2, 3, 5, 13, 15, 16, 17, 19, 20, 30];\n     let ys = [13, 15, 16, 17, 19, 20, 30];\n+\n     let it = xs.iter().skip(5);\n     let i = it.fold(0, |i, &x| {\n         assert_eq!(x, ys[i]);\n@@ -678,6 +679,24 @@ fn test_iterator_skip_fold() {\n         i + 1\n     });\n     assert_eq!(i, ys.len());\n+\n+    let it = xs.iter().skip(5);\n+    let i = it.rfold(ys.len(), |i, &x| {\n+        let i = i - 1;\n+        assert_eq!(x, ys[i]);\n+        i\n+    });\n+    assert_eq!(i, 0);\n+\n+    let mut it = xs.iter().skip(5);\n+    assert_eq!(it.next(), Some(&ys[0])); // process skips before folding\n+    let i = it.rfold(ys.len(), |i, &x| {\n+        let i = i - 1;\n+        assert_eq!(x, ys[i]);\n+        i\n+    });\n+    assert_eq!(i, 1);\n+\n }\n \n #[test]\n@@ -1478,3 +1497,207 @@ fn test_step_replace_no_between() {\n     assert_eq!(x, 1);\n     assert_eq!(y, 5);\n }\n+\n+#[test]\n+fn test_rev_try_folds() {\n+    let f = &|acc, x| i32::checked_add(2*acc, x);\n+    assert_eq!((1..10).rev().try_fold(7, f), (1..10).try_rfold(7, f));\n+    assert_eq!((1..10).rev().try_rfold(7, f), (1..10).try_fold(7, f));\n+\n+    let a = [10, 20, 30, 40, 100, 60, 70, 80, 90];\n+    let mut iter = a.iter().rev();\n+    assert_eq!(iter.try_fold(0_i8, |acc, &x| acc.checked_add(x)), None);\n+    assert_eq!(iter.next(), Some(&70));\n+    let mut iter = a.iter().rev();\n+    assert_eq!(iter.try_rfold(0_i8, |acc, &x| acc.checked_add(x)), None);\n+    assert_eq!(iter.next_back(), Some(&60));\n+}\n+\n+#[test]\n+fn test_cloned_try_folds() {\n+    let a = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n+    let f = &|acc, x| i32::checked_add(2*acc, x);\n+    let f_ref = &|acc, &x| i32::checked_add(2*acc, x);\n+    assert_eq!(a.iter().cloned().try_fold(7, f), a.iter().try_fold(7, f_ref));\n+    assert_eq!(a.iter().cloned().try_rfold(7, f), a.iter().try_rfold(7, f_ref));\n+\n+    let a = [10, 20, 30, 40, 100, 60, 70, 80, 90];\n+    let mut iter = a.iter().cloned();\n+    assert_eq!(iter.try_fold(0_i8, |acc, x| acc.checked_add(x)), None);\n+    assert_eq!(iter.next(), Some(60));\n+    let mut iter = a.iter().cloned();\n+    assert_eq!(iter.try_rfold(0_i8, |acc, x| acc.checked_add(x)), None);\n+    assert_eq!(iter.next_back(), Some(70));\n+}\n+\n+#[test]\n+fn test_chain_try_folds() {\n+    let c = || (0..10).chain(10..20);\n+\n+    let f = &|acc, x| i32::checked_add(2*acc, x);\n+    assert_eq!(c().try_fold(7, f), (0..20).try_fold(7, f));\n+    assert_eq!(c().try_rfold(7, f), (0..20).rev().try_fold(7, f));\n+\n+    let mut iter = c();\n+    assert_eq!(iter.position(|x| x == 5), Some(5));\n+    assert_eq!(iter.next(), Some(6), \"stopped in front, state Both\");\n+    assert_eq!(iter.position(|x| x == 13), Some(6));\n+    assert_eq!(iter.next(), Some(14), \"stopped in back, state Back\");\n+    assert_eq!(iter.try_fold(0, |acc, x| Some(acc+x)), Some((15..20).sum()));\n+\n+    let mut iter = c().rev(); // use rev to access try_rfold\n+    assert_eq!(iter.position(|x| x == 15), Some(4));\n+    assert_eq!(iter.next(), Some(14), \"stopped in back, state Both\");\n+    assert_eq!(iter.position(|x| x == 5), Some(8));\n+    assert_eq!(iter.next(), Some(4), \"stopped in front, state Front\");\n+    assert_eq!(iter.try_fold(0, |acc, x| Some(acc+x)), Some((0..4).sum()));\n+\n+    let mut iter = c();\n+    iter.by_ref().rev().nth(14); // skip the last 15, ending in state Front\n+    assert_eq!(iter.try_fold(7, f), (0..5).try_fold(7, f));\n+\n+    let mut iter = c();\n+    iter.nth(14); // skip the first 15, ending in state Back\n+    assert_eq!(iter.try_rfold(7, f), (15..20).try_rfold(7, f));\n+}\n+\n+#[test]\n+fn test_map_try_folds() {\n+    let f = &|acc, x| i32::checked_add(2*acc, x);\n+    assert_eq!((0..10).map(|x| x+3).try_fold(7, f), (3..13).try_fold(7, f));\n+    assert_eq!((0..10).map(|x| x+3).try_rfold(7, f), (3..13).try_rfold(7, f));\n+\n+    let mut iter = (0..40).map(|x| x+10);\n+    assert_eq!(iter.try_fold(0, i8::checked_add), None);\n+    assert_eq!(iter.next(), Some(20));\n+    assert_eq!(iter.try_rfold(0, i8::checked_add), None);\n+    assert_eq!(iter.next_back(), Some(46));\n+}\n+\n+#[test]\n+fn test_filter_try_folds() {\n+    fn p(&x: &i32) -> bool { 0 <= x && x < 10 }\n+    let f = &|acc, x| i32::checked_add(2*acc, x);\n+    assert_eq!((-10..20).filter(p).try_fold(7, f), (0..10).try_fold(7, f));\n+    assert_eq!((-10..20).filter(p).try_rfold(7, f), (0..10).try_rfold(7, f));\n+\n+    let mut iter = (0..40).filter(|&x| x % 2 == 1);\n+    assert_eq!(iter.try_fold(0, i8::checked_add), None);\n+    assert_eq!(iter.next(), Some(25));\n+    assert_eq!(iter.try_rfold(0, i8::checked_add), None);\n+    assert_eq!(iter.next_back(), Some(31));\n+}\n+\n+#[test]\n+fn test_filter_map_try_folds() {\n+    let mp = &|x| if 0 <= x && x < 10 { Some(x*2) } else { None };\n+    let f = &|acc, x| i32::checked_add(2*acc, x);\n+    assert_eq!((-9..20).filter_map(mp).try_fold(7, f), (0..10).map(|x| 2*x).try_fold(7, f));\n+    assert_eq!((-9..20).filter_map(mp).try_rfold(7, f), (0..10).map(|x| 2*x).try_rfold(7, f));\n+\n+    let mut iter = (0..40).filter_map(|x| if x%2 == 1 { None } else { Some(x*2 + 10) });\n+    assert_eq!(iter.try_fold(0, i8::checked_add), None);\n+    assert_eq!(iter.next(), Some(38));\n+    assert_eq!(iter.try_rfold(0, i8::checked_add), None);\n+    assert_eq!(iter.next_back(), Some(78));\n+}\n+\n+#[test]\n+fn test_enumerate_try_folds() {\n+    let f = &|acc, (i, x)| usize::checked_add(2*acc, x/(i+1) + i);\n+    assert_eq!((9..18).enumerate().try_fold(7, f), (0..9).map(|i| (i, i+9)).try_fold(7, f));\n+    assert_eq!((9..18).enumerate().try_rfold(7, f), (0..9).map(|i| (i, i+9)).try_rfold(7, f));\n+\n+    let mut iter = (100..200).enumerate();\n+    let f = &|acc, (i, x)| u8::checked_add(acc, u8::checked_div(x, i as u8 + 1)?);\n+    assert_eq!(iter.try_fold(0, f), None);\n+    assert_eq!(iter.next(), Some((7, 107)));\n+    assert_eq!(iter.try_rfold(0, f), None);\n+    assert_eq!(iter.next_back(), Some((11, 111)));\n+}\n+\n+#[test]\n+fn test_peek_try_fold() {\n+    let f = &|acc, x| i32::checked_add(2*acc, x);\n+    assert_eq!((1..20).peekable().try_fold(7, f), (1..20).try_fold(7, f));\n+    let mut iter = (1..20).peekable();\n+    assert_eq!(iter.peek(), Some(&1));\n+    assert_eq!(iter.try_fold(7, f), (1..20).try_fold(7, f));\n+\n+    let mut iter = [100, 20, 30, 40, 50, 60, 70].iter().cloned().peekable();\n+    assert_eq!(iter.peek(), Some(&100));\n+    assert_eq!(iter.try_fold(0, i8::checked_add), None);\n+    assert_eq!(iter.peek(), Some(&40));\n+}\n+\n+#[test]\n+fn test_skip_while_try_fold() {\n+    let f = &|acc, x| i32::checked_add(2*acc, x);\n+    fn p(&x: &i32) -> bool { (x % 10) <= 5 }\n+    assert_eq!((1..20).skip_while(p).try_fold(7, f), (6..20).try_fold(7, f));\n+    let mut iter = (1..20).skip_while(p);\n+    assert_eq!(iter.nth(5), Some(11));\n+    assert_eq!(iter.try_fold(7, f), (12..20).try_fold(7, f));\n+\n+    let mut iter = (0..50).skip_while(|&x| (x % 20) < 15);\n+    assert_eq!(iter.try_fold(0, i8::checked_add), None);\n+    assert_eq!(iter.next(), Some(23));\n+}\n+\n+#[test]\n+fn test_take_while_folds() {\n+    let f = &|acc, x| i32::checked_add(2*acc, x);\n+    assert_eq!((1..20).take_while(|&x| x != 10).try_fold(7, f), (1..10).try_fold(7, f));\n+    let mut iter = (1..20).take_while(|&x| x != 10);\n+    assert_eq!(iter.try_fold(0, |x, y| Some(x+y)), Some((1..10).sum()));\n+    assert_eq!(iter.next(), None, \"flag should be set\");\n+    let iter = (1..20).take_while(|&x| x != 10);\n+    assert_eq!(iter.fold(0, |x, y| x+y), (1..10).sum());\n+\n+    let mut iter = (10..50).take_while(|&x| x != 40);\n+    assert_eq!(iter.try_fold(0, i8::checked_add), None);\n+    assert_eq!(iter.next(), Some(20));\n+}\n+\n+#[test]\n+fn test_skip_try_folds() {\n+    let f = &|acc, x| i32::checked_add(2*acc, x);\n+    assert_eq!((1..20).skip(9).try_fold(7, f), (10..20).try_fold(7, f));\n+    assert_eq!((1..20).skip(9).try_rfold(7, f), (10..20).try_rfold(7, f));\n+\n+    let mut iter = (0..30).skip(10);\n+    assert_eq!(iter.try_fold(0, i8::checked_add), None);\n+    assert_eq!(iter.next(), Some(20));\n+    assert_eq!(iter.try_rfold(0, i8::checked_add), None);\n+    assert_eq!(iter.next_back(), Some(24));\n+}\n+\n+#[test]\n+fn test_take_try_folds() {\n+    let f = &|acc, x| i32::checked_add(2*acc, x);\n+    assert_eq!((10..30).take(10).try_fold(7, f), (10..20).try_fold(7, f));\n+    //assert_eq!((10..30).take(10).try_rfold(7, f), (10..20).try_rfold(7, f));\n+\n+    let mut iter = (10..30).take(20);\n+    assert_eq!(iter.try_fold(0, i8::checked_add), None);\n+    assert_eq!(iter.next(), Some(20));\n+    //assert_eq!(iter.try_rfold(0, i8::checked_add), None);\n+    //assert_eq!(iter.next_back(), Some(24));\n+}\n+\n+#[test]\n+fn test_flat_map_try_folds() {\n+    let f = &|acc, x| i32::checked_add(acc*2/3, x);\n+    let mr = &|x| (5*x)..(5*x + 5);\n+    assert_eq!((0..10).flat_map(mr).try_fold(7, f), (0..50).try_fold(7, f));\n+    assert_eq!((0..10).flat_map(mr).try_rfold(7, f), (0..50).try_rfold(7, f));\n+    let mut iter = (0..10).flat_map(mr);\n+    iter.next(); iter.next_back(); // have front and back iters in progress\n+    assert_eq!(iter.try_rfold(7, f), (1..49).try_rfold(7, f));\n+\n+    let mut iter = (0..10).flat_map(|x| (4*x)..(4*x + 4));\n+    assert_eq!(iter.try_fold(0, i8::checked_add), None);\n+    assert_eq!(iter.next(), Some(17));\n+    assert_eq!(iter.try_rfold(0, i8::checked_add), None);\n+    assert_eq!(iter.next_back(), Some(35));\n+}"}, {"sha": "96d83081c8f3039ecf33b229852ad75243468574", "filename": "src/libcore/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/eef4d42a3f04519af885932de1826cbfebdeeb55/src%2Flibcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eef4d42a3f04519af885932de1826cbfebdeeb55/src%2Flibcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flib.rs?ref=eef4d42a3f04519af885932de1826cbfebdeeb55", "patch": "@@ -24,6 +24,7 @@\n #![feature(i128_type)]\n #![feature(inclusive_range)]\n #![feature(inclusive_range_syntax)]\n+#![feature(iterator_try_fold)]\n #![feature(iter_rfind)]\n #![feature(iter_rfold)]\n #![feature(nonzero)]"}, {"sha": "f7899f6036ba3e10611d2f90fad5061840f70ee6", "filename": "src/libcore/tests/slice.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/eef4d42a3f04519af885932de1826cbfebdeeb55/src%2Flibcore%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eef4d42a3f04519af885932de1826cbfebdeeb55/src%2Flibcore%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fslice.rs?ref=eef4d42a3f04519af885932de1826cbfebdeeb55", "patch": "@@ -238,6 +238,23 @@ fn test_find_rfind() {\n     assert_eq!(v.iter().rfind(|&&x| x <= 3), Some(&3));\n }\n \n+#[test]\n+fn test_iter_folds() {\n+    let a = [1, 2, 3, 4, 5]; // len>4 so the unroll is used\n+    assert_eq!(a.iter().fold(0, |acc, &x| 2*acc + x), 57);\n+    assert_eq!(a.iter().rfold(0, |acc, &x| 2*acc + x), 129);\n+    let fold = |acc: i32, &x| acc.checked_mul(2)?.checked_add(x);\n+    assert_eq!(a.iter().try_fold(0, &fold), Some(57));\n+    assert_eq!(a.iter().try_rfold(0, &fold), Some(129));\n+\n+    // short-circuiting try_fold, through other methods\n+    let a = [0, 1, 2, 3, 5, 5, 5, 7, 8, 9];\n+    let mut iter = a.iter();\n+    assert_eq!(iter.position(|&x| x == 3), Some(3));\n+    assert_eq!(iter.rfind(|&&x| x == 5), Some(&5));\n+    assert_eq!(iter.len(), 2);\n+}\n+\n #[test]\n fn test_rotate() {\n     const N: usize = 600;"}]}