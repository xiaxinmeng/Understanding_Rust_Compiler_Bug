{"sha": "75edfe204beeff8b4bb8473c279fd16253e6567f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc1ZWRmZTIwNGJlZWZmOGI0YmI4NDczYzI3OWZkMTYyNTNlNjU2N2Y=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-06-29T09:18:13Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-06-29T09:18:13Z"}, "message": "Rollup merge of #62163 - cuviper:unix-uninit, r=RalfJung\n\nAvoid mem::uninitialized() in std::sys::unix\n\nFor `libc` types that will be initialized in FFI calls, we can just use\n`MaybeUninit` and then pass around raw pointers.\n\nFor `sun_path_offset()`, which really wants `offset_of`, all callers\nhave a real `sockaddr_un` available, so we can use that reference.\n\nr? @RalfJung", "tree": {"sha": "3e1dd57efbd3f73cba4befc0c406d64687612c6f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3e1dd57efbd3f73cba4befc0c406d64687612c6f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/75edfe204beeff8b4bb8473c279fd16253e6567f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdFyzVCRBK7hj4Ov3rIwAAdHIIAJ3j4UDMXlllym/Wv3cmBf+w\nOJjmkjkjEGB7PwK9r2bIcXzasYYXkqL4YYuE0j3Hv1X6lyNvRQqkZKLAWwyAWhET\nsw9eBwk43+/u/Bdlaw0kcStb2smd4D8DJ2Nl9mzSYPhrVCHNOIKDNrfhES9VBL4d\niSv30H/ARk7UTXv4VdE3DvEm42tFwY7y7QJ0rssbRyZjhtZ49Jre+mvGzTvOv1uz\n8K3J3nsHYWLyu9xaDS4hFvMeN7X9e9ITvt68TxN3HoYklw+VU187qXtDUrlzfR6z\nzd+LNsbHENec/52M1iVis4ECYXR4CvhwdKjJ2+9zC0pEgd1rFAVHUcF+oE+QKFc=\n=+8GN\n-----END PGP SIGNATURE-----\n", "payload": "tree 3e1dd57efbd3f73cba4befc0c406d64687612c6f\nparent 94a066e229e2f6f4efbde1ae3caa067b0aaa69a2\nparent b533aff9275aad7cd7dfbf42ca6b387fc93ed1d3\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1561799893 +0200\ncommitter GitHub <noreply@github.com> 1561799893 +0200\n\nRollup merge of #62163 - cuviper:unix-uninit, r=RalfJung\n\nAvoid mem::uninitialized() in std::sys::unix\n\nFor `libc` types that will be initialized in FFI calls, we can just use\n`MaybeUninit` and then pass around raw pointers.\n\nFor `sun_path_offset()`, which really wants `offset_of`, all callers\nhave a real `sockaddr_un` available, so we can use that reference.\n\nr? @RalfJung\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/75edfe204beeff8b4bb8473c279fd16253e6567f", "html_url": "https://github.com/rust-lang/rust/commit/75edfe204beeff8b4bb8473c279fd16253e6567f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/75edfe204beeff8b4bb8473c279fd16253e6567f/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "94a066e229e2f6f4efbde1ae3caa067b0aaa69a2", "url": "https://api.github.com/repos/rust-lang/rust/commits/94a066e229e2f6f4efbde1ae3caa067b0aaa69a2", "html_url": "https://github.com/rust-lang/rust/commit/94a066e229e2f6f4efbde1ae3caa067b0aaa69a2"}, {"sha": "b533aff9275aad7cd7dfbf42ca6b387fc93ed1d3", "url": "https://api.github.com/repos/rust-lang/rust/commits/b533aff9275aad7cd7dfbf42ca6b387fc93ed1d3", "html_url": "https://github.com/rust-lang/rust/commit/b533aff9275aad7cd7dfbf42ca6b387fc93ed1d3"}], "stats": {"total": 119, "additions": 58, "deletions": 61}, "files": [{"sha": "4201de794b70835406a05713122b0816d5e584ea", "filename": "src/libstd/sys/unix/condvar.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/75edfe204beeff8b4bb8473c279fd16253e6567f/src%2Flibstd%2Fsys%2Funix%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75edfe204beeff8b4bb8473c279fd16253e6567f/src%2Flibstd%2Fsys%2Funix%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fcondvar.rs?ref=75edfe204beeff8b4bb8473c279fd16253e6567f", "patch": "@@ -40,15 +40,15 @@ impl Condvar {\n                   target_os = \"android\",\n                   target_os = \"hermit\")))]\n     pub unsafe fn init(&mut self) {\n-        use crate::mem;\n-        let mut attr: libc::pthread_condattr_t = mem::uninitialized();\n-        let r = libc::pthread_condattr_init(&mut attr);\n+        use crate::mem::MaybeUninit;\n+        let mut attr = MaybeUninit::<libc::pthread_condattr_t>::uninit();\n+        let r = libc::pthread_condattr_init(attr.as_mut_ptr());\n         assert_eq!(r, 0);\n-        let r = libc::pthread_condattr_setclock(&mut attr, libc::CLOCK_MONOTONIC);\n+        let r = libc::pthread_condattr_setclock(attr.as_mut_ptr(), libc::CLOCK_MONOTONIC);\n         assert_eq!(r, 0);\n-        let r = libc::pthread_cond_init(self.inner.get(), &attr);\n+        let r = libc::pthread_cond_init(self.inner.get(), attr.as_ptr());\n         assert_eq!(r, 0);\n-        let r = libc::pthread_condattr_destroy(&mut attr);\n+        let r = libc::pthread_condattr_destroy(attr.as_mut_ptr());\n         assert_eq!(r, 0);\n     }\n "}, {"sha": "41090caee8459fea5e08e6ad9054379d9da08da3", "filename": "src/libstd/sys/unix/ext/net.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/75edfe204beeff8b4bb8473c279fd16253e6567f/src%2Flibstd%2Fsys%2Funix%2Fext%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75edfe204beeff8b4bb8473c279fd16253e6567f/src%2Flibstd%2Fsys%2Funix%2Fext%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext%2Fnet.rs?ref=75edfe204beeff8b4bb8473c279fd16253e6567f", "patch": "@@ -40,10 +40,9 @@ use libc::MSG_NOSIGNAL;\n               target_os = \"haiku\")))]\n const MSG_NOSIGNAL: libc::c_int = 0x0;\n \n-fn sun_path_offset() -> usize {\n+fn sun_path_offset(addr: &libc::sockaddr_un) -> usize {\n     // Work with an actual instance of the type since using a null pointer is UB\n-    let addr: libc::sockaddr_un = unsafe { mem::uninitialized() };\n-    let base = &addr as *const _ as usize;\n+    let base = addr as *const _ as usize;\n     let path = &addr.sun_path as *const _ as usize;\n     path - base\n }\n@@ -69,7 +68,7 @@ unsafe fn sockaddr_un(path: &Path) -> io::Result<(libc::sockaddr_un, libc::sockl\n     // null byte for pathname addresses is already there because we zeroed the\n     // struct\n \n-    let mut len = sun_path_offset() + bytes.len();\n+    let mut len = sun_path_offset(&addr) + bytes.len();\n     match bytes.get(0) {\n         Some(&0) | None => {}\n         Some(_) => len += 1,\n@@ -122,7 +121,7 @@ impl SocketAddr {\n         if len == 0 {\n             // When there is a datagram from unnamed unix socket\n             // linux returns zero bytes of address\n-            len = sun_path_offset() as libc::socklen_t;  // i.e., zero-length address\n+            len = sun_path_offset(&addr) as libc::socklen_t;  // i.e., zero-length address\n         } else if addr.sun_family != libc::AF_UNIX as libc::sa_family_t {\n             return Err(io::Error::new(io::ErrorKind::InvalidInput,\n                                       \"file descriptor did not correspond to a Unix socket\"));\n@@ -200,7 +199,7 @@ impl SocketAddr {\n     }\n \n     fn address<'a>(&'a self) -> AddressKind<'a> {\n-        let len = self.len as usize - sun_path_offset();\n+        let len = self.len as usize - sun_path_offset(&self.addr);\n         let path = unsafe { mem::transmute::<&[libc::c_char], &[u8]>(&self.addr.sun_path) };\n \n         // macOS seems to return a len of 16 and a zeroed sun_path for unnamed addresses"}, {"sha": "b43af8fdcaaa12ed392c2b3679464772a53104e6", "filename": "src/libstd/sys/unix/mutex.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/75edfe204beeff8b4bb8473c279fd16253e6567f/src%2Flibstd%2Fsys%2Funix%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75edfe204beeff8b4bb8473c279fd16253e6567f/src%2Flibstd%2Fsys%2Funix%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmutex.rs?ref=75edfe204beeff8b4bb8473c279fd16253e6567f", "patch": "@@ -1,5 +1,5 @@\n use crate::cell::UnsafeCell;\n-use crate::mem;\n+use crate::mem::MaybeUninit;\n \n pub struct Mutex { inner: UnsafeCell<libc::pthread_mutex_t> }\n \n@@ -40,14 +40,14 @@ impl Mutex {\n         // references, we instead create the mutex with type\n         // PTHREAD_MUTEX_NORMAL which is guaranteed to deadlock if we try to\n         // re-lock it from the same thread, thus avoiding undefined behavior.\n-        let mut attr: libc::pthread_mutexattr_t = mem::uninitialized();\n-        let r = libc::pthread_mutexattr_init(&mut attr);\n+        let mut attr = MaybeUninit::<libc::pthread_mutexattr_t>::uninit();\n+        let r = libc::pthread_mutexattr_init(attr.as_mut_ptr());\n         debug_assert_eq!(r, 0);\n-        let r = libc::pthread_mutexattr_settype(&mut attr, libc::PTHREAD_MUTEX_NORMAL);\n+        let r = libc::pthread_mutexattr_settype(attr.as_mut_ptr(), libc::PTHREAD_MUTEX_NORMAL);\n         debug_assert_eq!(r, 0);\n-        let r = libc::pthread_mutex_init(self.inner.get(), &attr);\n+        let r = libc::pthread_mutex_init(self.inner.get(), attr.as_ptr());\n         debug_assert_eq!(r, 0);\n-        let r = libc::pthread_mutexattr_destroy(&mut attr);\n+        let r = libc::pthread_mutexattr_destroy(attr.as_mut_ptr());\n         debug_assert_eq!(r, 0);\n     }\n     #[inline]\n@@ -89,19 +89,19 @@ unsafe impl Sync for ReentrantMutex {}\n \n impl ReentrantMutex {\n     pub unsafe fn uninitialized() -> ReentrantMutex {\n-        ReentrantMutex { inner: mem::uninitialized() }\n+        ReentrantMutex { inner: UnsafeCell::new(libc::PTHREAD_MUTEX_INITIALIZER) }\n     }\n \n     pub unsafe fn init(&mut self) {\n-        let mut attr: libc::pthread_mutexattr_t = mem::uninitialized();\n-        let result = libc::pthread_mutexattr_init(&mut attr as *mut _);\n+        let mut attr = MaybeUninit::<libc::pthread_mutexattr_t>::uninit();\n+        let result = libc::pthread_mutexattr_init(attr.as_mut_ptr());\n         debug_assert_eq!(result, 0);\n-        let result = libc::pthread_mutexattr_settype(&mut attr as *mut _,\n+        let result = libc::pthread_mutexattr_settype(attr.as_mut_ptr(),\n                                                     libc::PTHREAD_MUTEX_RECURSIVE);\n         debug_assert_eq!(result, 0);\n-        let result = libc::pthread_mutex_init(self.inner.get(), &attr as *const _);\n+        let result = libc::pthread_mutex_init(self.inner.get(), attr.as_ptr());\n         debug_assert_eq!(result, 0);\n-        let result = libc::pthread_mutexattr_destroy(&mut attr as *mut _);\n+        let result = libc::pthread_mutexattr_destroy(attr.as_mut_ptr());\n         debug_assert_eq!(result, 0);\n     }\n "}, {"sha": "3ff4f194cd1a913451cfa89f4e1514de05b83c46", "filename": "src/libstd/sys/unix/process/process_common.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/75edfe204beeff8b4bb8473c279fd16253e6567f/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75edfe204beeff8b4bb8473c279fd16253e6567f/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs?ref=75edfe204beeff8b4bb8473c279fd16253e6567f", "patch": "@@ -437,7 +437,7 @@ mod tests {\n \n     #[cfg(target_os = \"android\")]\n     unsafe fn sigemptyset(set: *mut libc::sigset_t) -> libc::c_int {\n-        libc::memset(set as *mut _, 0, mem::size_of::<libc::sigset_t>());\n+        set.write_bytes(0u8, 1);\n         return 0;\n     }\n \n@@ -466,11 +466,11 @@ mod tests {\n             // Test to make sure that a signal mask does not get inherited.\n             let mut cmd = Command::new(OsStr::new(\"cat\"));\n \n-            let mut set: libc::sigset_t = mem::uninitialized();\n-            let mut old_set: libc::sigset_t = mem::uninitialized();\n-            t!(cvt(sigemptyset(&mut set)));\n-            t!(cvt(sigaddset(&mut set, libc::SIGINT)));\n-            t!(cvt(libc::pthread_sigmask(libc::SIG_SETMASK, &set, &mut old_set)));\n+            let mut set = mem::MaybeUninit::<libc::sigset_t>::uninit();\n+            let mut old_set = mem::MaybeUninit::<libc::sigset_t>::uninit();\n+            t!(cvt(sigemptyset(set.as_mut_ptr())));\n+            t!(cvt(sigaddset(set.as_mut_ptr(), libc::SIGINT)));\n+            t!(cvt(libc::pthread_sigmask(libc::SIG_SETMASK, set.as_ptr(), old_set.as_mut_ptr())));\n \n             cmd.stdin(Stdio::MakePipe);\n             cmd.stdout(Stdio::MakePipe);\n@@ -479,7 +479,7 @@ mod tests {\n             let stdin_write = pipes.stdin.take().unwrap();\n             let stdout_read = pipes.stdout.take().unwrap();\n \n-            t!(cvt(libc::pthread_sigmask(libc::SIG_SETMASK, &old_set,\n+            t!(cvt(libc::pthread_sigmask(libc::SIG_SETMASK, old_set.as_ptr(),\n                                          ptr::null_mut())));\n \n             t!(cvt(libc::kill(cat.id() as libc::pid_t, libc::SIGINT)));"}, {"sha": "be38a1334ec32acfa25690b7f9c7f01e39f1e9c6", "filename": "src/libstd/sys/unix/process/process_unix.rs", "status": "modified", "additions": 28, "deletions": 30, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/75edfe204beeff8b4bb8473c279fd16253e6567f/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75edfe204beeff8b4bb8473c279fd16253e6567f/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs?ref=75edfe204beeff8b4bb8473c279fd16253e6567f", "patch": "@@ -202,26 +202,24 @@ impl Command {\n         // emscripten has no signal support.\n         #[cfg(not(any(target_os = \"emscripten\")))]\n         {\n-            use crate::mem;\n+            use crate::mem::MaybeUninit;\n             // Reset signal handling so the child process starts in a\n             // standardized state. libstd ignores SIGPIPE, and signal-handling\n             // libraries often set a mask. Child processes inherit ignored\n             // signals and the signal mask from their parent, but most\n             // UNIX programs do not reset these things on their own, so we\n             // need to clean things up now to avoid confusing the program\n             // we're about to run.\n-            let mut set: libc::sigset_t = mem::uninitialized();\n+            let mut set = MaybeUninit::<libc::sigset_t>::uninit();\n             if cfg!(target_os = \"android\") {\n                 // Implementing sigemptyset allow us to support older Android\n                 // versions. See the comment about Android and sig* functions in\n                 // process_common.rs\n-                libc::memset(&mut set as *mut _ as *mut _,\n-                             0,\n-                             mem::size_of::<libc::sigset_t>());\n+                set.as_mut_ptr().write_bytes(0u8, 1);\n             } else {\n-                cvt(libc::sigemptyset(&mut set))?;\n+                cvt(libc::sigemptyset(set.as_mut_ptr()))?;\n             }\n-            cvt(libc::pthread_sigmask(libc::SIG_SETMASK, &set,\n+            cvt(libc::pthread_sigmask(libc::SIG_SETMASK, set.as_ptr(),\n                                          ptr::null_mut()))?;\n             let ret = sys::signal(libc::SIGPIPE, libc::SIG_DFL);\n             if ret == libc::SIG_ERR {\n@@ -273,7 +271,7 @@ impl Command {\n     fn posix_spawn(&mut self, stdio: &ChildPipes, envp: Option<&CStringArray>)\n         -> io::Result<Option<Process>>\n     {\n-        use crate::mem;\n+        use crate::mem::MaybeUninit;\n         use crate::sys;\n \n         if self.get_gid().is_some() ||\n@@ -315,63 +313,63 @@ impl Command {\n \n         let mut p = Process { pid: 0, status: None };\n \n-        struct PosixSpawnFileActions(libc::posix_spawn_file_actions_t);\n+        struct PosixSpawnFileActions(MaybeUninit<libc::posix_spawn_file_actions_t>);\n \n         impl Drop for PosixSpawnFileActions {\n             fn drop(&mut self) {\n                 unsafe {\n-                    libc::posix_spawn_file_actions_destroy(&mut self.0);\n+                    libc::posix_spawn_file_actions_destroy(self.0.as_mut_ptr());\n                 }\n             }\n         }\n \n-        struct PosixSpawnattr(libc::posix_spawnattr_t);\n+        struct PosixSpawnattr(MaybeUninit<libc::posix_spawnattr_t>);\n \n         impl Drop for PosixSpawnattr {\n             fn drop(&mut self) {\n                 unsafe {\n-                    libc::posix_spawnattr_destroy(&mut self.0);\n+                    libc::posix_spawnattr_destroy(self.0.as_mut_ptr());\n                 }\n             }\n         }\n \n         unsafe {\n-            let mut file_actions = PosixSpawnFileActions(mem::uninitialized());\n-            let mut attrs = PosixSpawnattr(mem::uninitialized());\n+            let mut file_actions = PosixSpawnFileActions(MaybeUninit::uninit());\n+            let mut attrs = PosixSpawnattr(MaybeUninit::uninit());\n \n-            libc::posix_spawnattr_init(&mut attrs.0);\n-            libc::posix_spawn_file_actions_init(&mut file_actions.0);\n+            libc::posix_spawnattr_init(attrs.0.as_mut_ptr());\n+            libc::posix_spawn_file_actions_init(file_actions.0.as_mut_ptr());\n \n             if let Some(fd) = stdio.stdin.fd() {\n-                cvt(libc::posix_spawn_file_actions_adddup2(&mut file_actions.0,\n+                cvt(libc::posix_spawn_file_actions_adddup2(file_actions.0.as_mut_ptr(),\n                                                            fd,\n                                                            libc::STDIN_FILENO))?;\n             }\n             if let Some(fd) = stdio.stdout.fd() {\n-                cvt(libc::posix_spawn_file_actions_adddup2(&mut file_actions.0,\n+                cvt(libc::posix_spawn_file_actions_adddup2(file_actions.0.as_mut_ptr(),\n                                                            fd,\n                                                            libc::STDOUT_FILENO))?;\n             }\n             if let Some(fd) = stdio.stderr.fd() {\n-                cvt(libc::posix_spawn_file_actions_adddup2(&mut file_actions.0,\n+                cvt(libc::posix_spawn_file_actions_adddup2(file_actions.0.as_mut_ptr(),\n                                                            fd,\n                                                            libc::STDERR_FILENO))?;\n             }\n             if let Some((f, cwd)) = addchdir {\n-                cvt(f(&mut file_actions.0, cwd.as_ptr()))?;\n+                cvt(f(file_actions.0.as_mut_ptr(), cwd.as_ptr()))?;\n             }\n \n-            let mut set: libc::sigset_t = mem::uninitialized();\n-            cvt(libc::sigemptyset(&mut set))?;\n-            cvt(libc::posix_spawnattr_setsigmask(&mut attrs.0,\n-                                                 &set))?;\n-            cvt(libc::sigaddset(&mut set, libc::SIGPIPE))?;\n-            cvt(libc::posix_spawnattr_setsigdefault(&mut attrs.0,\n-                                                    &set))?;\n+            let mut set = MaybeUninit::<libc::sigset_t>::uninit();\n+            cvt(libc::sigemptyset(set.as_mut_ptr()))?;\n+            cvt(libc::posix_spawnattr_setsigmask(attrs.0.as_mut_ptr(),\n+                                                 set.as_ptr()))?;\n+            cvt(libc::sigaddset(set.as_mut_ptr(), libc::SIGPIPE))?;\n+            cvt(libc::posix_spawnattr_setsigdefault(attrs.0.as_mut_ptr(),\n+                                                    set.as_ptr()))?;\n \n             let flags = libc::POSIX_SPAWN_SETSIGDEF |\n                 libc::POSIX_SPAWN_SETSIGMASK;\n-            cvt(libc::posix_spawnattr_setflags(&mut attrs.0, flags as _))?;\n+            cvt(libc::posix_spawnattr_setflags(attrs.0.as_mut_ptr(), flags as _))?;\n \n             // Make sure we synchronize access to the global `environ` resource\n             let _env_lock = sys::os::env_lock();\n@@ -380,8 +378,8 @@ impl Command {\n             let ret = libc::posix_spawnp(\n                 &mut p.pid,\n                 self.get_argv()[0],\n-                &file_actions.0,\n-                &attrs.0,\n+                file_actions.0.as_ptr(),\n+                attrs.0.as_ptr(),\n                 self.get_argv().as_ptr() as *const _,\n                 envp as *const _,\n             );"}]}