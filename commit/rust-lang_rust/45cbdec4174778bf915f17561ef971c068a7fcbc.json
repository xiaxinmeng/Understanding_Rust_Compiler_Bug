{"sha": "45cbdec4174778bf915f17561ef971c068a7fcbc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ1Y2JkZWM0MTc0Nzc4YmY5MTVmMTc1NjFlZjk3MWMwNjhhN2ZjYmM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-11-07T00:02:18Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-11-07T00:02:18Z"}, "message": "auto merge of #18719 : alexcrichton/rust/rollup, r=alexcrichton", "tree": {"sha": "9516c60b7323f1233858665501a5029c9c3f90f0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9516c60b7323f1233858665501a5029c9c3f90f0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/45cbdec4174778bf915f17561ef971c068a7fcbc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/45cbdec4174778bf915f17561ef971c068a7fcbc", "html_url": "https://github.com/rust-lang/rust/commit/45cbdec4174778bf915f17561ef971c068a7fcbc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/45cbdec4174778bf915f17561ef971c068a7fcbc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8ed288edb27fc83b15a549af69c82b5bb4f8ac1e", "url": "https://api.github.com/repos/rust-lang/rust/commits/8ed288edb27fc83b15a549af69c82b5bb4f8ac1e", "html_url": "https://github.com/rust-lang/rust/commit/8ed288edb27fc83b15a549af69c82b5bb4f8ac1e"}, {"sha": "d27039d701a3c6e97f19e41436d06ed42c0f5f8a", "url": "https://api.github.com/repos/rust-lang/rust/commits/d27039d701a3c6e97f19e41436d06ed42c0f5f8a", "html_url": "https://github.com/rust-lang/rust/commit/d27039d701a3c6e97f19e41436d06ed42c0f5f8a"}], "stats": {"total": 5949, "additions": 3508, "deletions": 2441}, "files": [{"sha": "771c1821e3802b44d1ce1e332a0dc079a92f2dab", "filename": "mk/crates.mk", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -51,7 +51,7 @@\n \n TARGET_CRATES := libc std green native flate arena term \\\n                  serialize sync getopts collections test time rand \\\n-                 log regex graphviz core rbml rlibc alloc rustrt \\\n+                 log regex graphviz core rbml alloc rustrt \\\n                  unicode\n HOST_CRATES := syntax rustc rustdoc regex_macros fmt_macros \\\n \t       rustc_llvm rustc_back\n@@ -60,7 +60,6 @@ TOOLS := compiletest rustdoc rustc\n \n DEPS_core :=\n DEPS_libc := core\n-DEPS_rlibc := core\n DEPS_unicode := core\n DEPS_alloc := core libc native:jemalloc\n DEPS_rustrt := alloc core libc collections native:rustrt_native\n@@ -104,7 +103,6 @@ TOOL_SOURCE_rustc := $(S)src/driver/driver.rs\n \n ONLY_RLIB_core := 1\n ONLY_RLIB_libc := 1\n-ONLY_RLIB_rlibc := 1\n ONLY_RLIB_alloc := 1\n ONLY_RLIB_rand := 1\n ONLY_RLIB_collections := 1"}, {"sha": "aba02088eabe6fd6928a4d5f192464b83f0fa40e", "filename": "mk/main.mk", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/mk%2Fmain.mk", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/mk%2Fmain.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fmain.mk?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -155,6 +155,7 @@ endif\n RUSTFLAGS_STAGE0 += -C prefer-dynamic\n RUSTFLAGS_STAGE1 += -C prefer-dynamic\n RUST_LIB_FLAGS_ST2 += -C prefer-dynamic\n+RUST_LIB_FLAGS_ST3 += -C prefer-dynamic\n \n # Landing pads require a lot of codegen. We can get through bootstrapping faster\n # by not emitting them."}, {"sha": "4433d780dedf6fd3ef52e42a69bb2bfbd9ad0e5f", "filename": "mk/tests.mk", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -677,7 +677,9 @@ CTEST_DEPS_cfail_$(1)-T-$(2)-H-$(3) = $$(CFAIL_TESTS)\n CTEST_DEPS_bench_$(1)-T-$(2)-H-$(3) = $$(BENCH_TESTS)\n CTEST_DEPS_perf_$(1)-T-$(2)-H-$(3) = $$(PERF_TESTS)\n CTEST_DEPS_debuginfo-gdb_$(1)-T-$(2)-H-$(3) = $$(DEBUGINFO_GDB_TESTS)\n-CTEST_DEPS_debuginfo-lldb_$(1)-T-$(2)-H-$(3) = $$(DEBUGINFO_LLDB_TESTS)\n+CTEST_DEPS_debuginfo-lldb_$(1)-T-$(2)-H-$(3) = $$(DEBUGINFO_LLDB_TESTS) \\\n+                                               $(S)src/etc/lldb_batchmode.py \\\n+                                               $(S)src/etc/lldb_rust_formatters.py\n CTEST_DEPS_codegen_$(1)-T-$(2)-H-$(3) = $$(CODEGEN_TESTS)\n \n endef"}, {"sha": "2a74180393c497d0f1a984e07293e4e159787ed1", "filename": "src/doc/guide.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Fdoc%2Fguide.md", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Fdoc%2Fguide.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide.md?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -1149,7 +1149,7 @@ enum StringResult {\n }\n ```\n Where a `StringResult` is either an `StringOK`, with the result of a computation, or an\n-`ErrorReason` with a `String` explaining what caused the computation to fail. This kind of\n+`ErrorReason` with a `String` explaining what caused the computation to fail. These kinds of\n `enum`s are actually very useful and are even part of the standard library.\n \n As you can see `enum`s with values are quite a powerful tool for data representation,\n@@ -1901,8 +1901,8 @@ result is a link to\n click on that result, we'll be taken to its documentation page.\n \n This page shows us a few things: the type signature of the function, some\n-explanatory text, and then an example. Let's modify our code to add in the\n-`random` function:\n+explanatory text, and then an example. Let's try to modify our code to add in the\n+`random` function and see what happens:\n \n ```{rust,ignore}\n use std::io;"}, {"sha": "1c338aa8118fa7ce7f6abef6e3c16844d9006549", "filename": "src/doc/reference.md", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -1961,8 +1961,10 @@ On an `extern` block, the following attributes are interpreted:\n   name and type. This is feature gated and the exact behavior is\n   implementation-defined (due to variety of linker invocation syntax).\n - `link` - indicate that a native library should be linked to for the\n-  declarations in this block to be linked correctly. See [external\n-  blocks](#external-blocks)\n+  declarations in this block to be linked correctly. `link` supports an optional `kind`\n+  key with three possible values: `dylib`, `static`, and `framework`. See [external blocks](#external-blocks) for more about external blocks. Two\n+  examples: `#[link(name = \"readline\")]` and\n+  `#[link(name = \"CoreFoundation\", kind = \"framework\")]`.\n \n On declarations inside an `extern` block, the following attributes are\n interpreted:"}, {"sha": "25e5661ca49da9291628771e8a22b8fe0551994e", "filename": "src/etc/lldb_batchmode.py", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Fetc%2Flldb_batchmode.py", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Fetc%2Flldb_batchmode.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Flldb_batchmode.py?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -28,8 +28,10 @@\n import os\n import sys\n import threading\n+import thread\n import re\n import atexit\n+import time\n \n # Set this to True for additional output\n DEBUG_OUTPUT = False\n@@ -130,6 +132,22 @@ def listen():\n   target.GetBroadcaster().AddListener(listener, lldb.SBTarget.eBroadcastBitBreakpointChanged)\n \n \n+def start_watchdog():\n+  \"Starts a watchdog thread that will terminate the process after a certain period of time\"\n+  watchdog_start_time = time.clock()\n+  watchdog_max_time = watchdog_start_time + 30\n+\n+  def watchdog():\n+    while time.clock() < watchdog_max_time:\n+      time.sleep(1)\n+    print(\"TIMEOUT: lldb_batchmode.py has been running for too long. Aborting!\")\n+    thread.interrupt_main()\n+\n+  # Start the listener and let it run as a daemon\n+  watchdog_thread = threading.Thread(target = watchdog)\n+  watchdog_thread.daemon = True\n+  watchdog_thread.start()\n+\n ####################################################################################################\n # ~main\n ####################################################################################################\n@@ -147,6 +165,9 @@ def listen():\n print(\"Target executable is '%s'.\" % target_path)\n print(\"Current working directory is '%s'\" % os.getcwd())\n \n+# Start the timeout watchdog\n+start_watchdog()\n+\n # Create a new debugger instance\n debugger = lldb.SBDebugger.Create()\n \n@@ -175,6 +196,10 @@ def listen():\n \n   for line in script_file:\n     command = line.strip()\n+    if command == \"run\" or command == \"r\" or re.match(\"^process\\s+launch.*\", command):\n+      # Before starting to run the program, let the thread sleep a bit, so all\n+      # breakpoint added events can be processed\n+      time.sleep(0.5)\n     if command != '':\n       execute_command(command_interpreter, command)\n "}, {"sha": "980d75b29addabd3fc226dc8300f8420af9138a8", "filename": "src/etc/unicode.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Fetc%2Funicode.py", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Fetc%2Funicode.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Funicode.py?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -34,7 +34,7 @@\n \n // NOTE: The following code was generated by \"src/etc/unicode.py\", do not edit directly\n \n-#![allow(missing_docs, non_uppercase_statics, non_snake_case)]\n+#![allow(missing_docs, non_upper_case_globals, non_snake_case)]\n '''\n \n # Mapping taken from Table 12 from:"}, {"sha": "0a06f7c0005fdd242686dab2b06c970690dd5113", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -48,6 +48,10 @@ impl<T: Default> Default for Box<T> {\n     fn default() -> Box<T> { box Default::default() }\n }\n \n+impl<T> Default for Box<[T]> {\n+    fn default() -> Box<[T]> { box [] }\n+}\n+\n #[unstable]\n impl<T: Clone> Clone for Box<T> {\n     /// Returns a copy of the owned box."}, {"sha": "c9d6007744944b3f50d32a994a9bc5373d249ae1", "filename": "src/libcollections/binary_heap.rs", "status": "modified", "additions": 40, "deletions": 10, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbinary_heap.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -162,6 +162,8 @@ use core::ptr;\n use slice;\n use vec::Vec;\n \n+// FIXME(conventions): implement into_iter\n+\n /// A priority queue implemented with a binary heap.\n ///\n /// This will be a max-heap.\n@@ -184,6 +186,7 @@ impl<T: Ord> BinaryHeap<T> {\n     /// use std::collections::BinaryHeap;\n     /// let pq: BinaryHeap<uint> = BinaryHeap::new();\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn new() -> BinaryHeap<T> { BinaryHeap{data: vec!(),} }\n \n     /// Creates an empty `BinaryHeap` with a specific capacity.\n@@ -197,6 +200,7 @@ impl<T: Ord> BinaryHeap<T> {\n     /// use std::collections::BinaryHeap;\n     /// let pq: BinaryHeap<uint> = BinaryHeap::with_capacity(10u);\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn with_capacity(capacity: uint) -> BinaryHeap<T> {\n         BinaryHeap { data: Vec::with_capacity(capacity) }\n     }\n@@ -234,6 +238,7 @@ impl<T: Ord> BinaryHeap<T> {\n     ///     println!(\"{}\", x);\n     /// }\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn iter<'a>(&'a self) -> Items<'a, T> {\n         Items { iter: self.data.iter() }\n     }\n@@ -268,10 +273,19 @@ impl<T: Ord> BinaryHeap<T> {\n     /// let pq: BinaryHeap<uint> = BinaryHeap::with_capacity(100u);\n     /// assert!(pq.capacity() >= 100u);\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn capacity(&self) -> uint { self.data.capacity() }\n \n-    /// Reserves capacity for exactly `n` elements in the `BinaryHeap`.\n-    /// Do nothing if the capacity is already sufficient.\n+    /// Reserves the minimum capacity for exactly `additional` more elements to be inserted in the\n+    /// given `BinaryHeap`. Does nothing if the capacity is already sufficient.\n+    ///\n+    /// Note that the allocator may give the collection more space than it requests. Therefore\n+    /// capacity can not be relied upon to be precisely minimal. Prefer `reserve` if future\n+    /// insertions are expected.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the new capacity overflows `uint`.\n     ///\n     /// # Example\n     ///\n@@ -280,12 +294,17 @@ impl<T: Ord> BinaryHeap<T> {\n     ///\n     /// let mut pq: BinaryHeap<uint> = BinaryHeap::new();\n     /// pq.reserve_exact(100u);\n-    /// assert!(pq.capacity() == 100u);\n+    /// assert!(pq.capacity() >= 100u);\n     /// ```\n-    pub fn reserve_exact(&mut self, n: uint) { self.data.reserve_exact(n) }\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn reserve_exact(&mut self, additional: uint) { self.data.reserve_exact(additional) }\n \n-    /// Reserves capacity for at least `n` elements in the `BinaryHeap`.\n-    /// Do nothing if the capacity is already sufficient.\n+    /// Reserves capacity for at least `additional` more elements to be inserted in the\n+    /// `BinaryHeap`. The collection may reserve more space to avoid frequent reallocations.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the new capacity overflows `uint`.\n     ///\n     /// # Example\n     ///\n@@ -296,8 +315,15 @@ impl<T: Ord> BinaryHeap<T> {\n     /// pq.reserve(100u);\n     /// assert!(pq.capacity() >= 100u);\n     /// ```\n-    pub fn reserve(&mut self, n: uint) {\n-        self.data.reserve(n)\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn reserve(&mut self, additional: uint) {\n+        self.data.reserve(additional)\n+    }\n+\n+    /// Discards as much additional capacity as possible.\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn shrink_to_fit(&mut self) {\n+        self.data.shrink_to_fit()\n     }\n \n     /// Removes the greatest item from a queue and returns it, or `None` if it\n@@ -314,6 +340,7 @@ impl<T: Ord> BinaryHeap<T> {\n     /// assert_eq!(pq.pop(), Some(1i));\n     /// assert_eq!(pq.pop(), None);\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn pop(&mut self) -> Option<T> {\n         match self.data.pop() {\n             None           => { None }\n@@ -342,6 +369,7 @@ impl<T: Ord> BinaryHeap<T> {\n     /// assert_eq!(pq.len(), 3);\n     /// assert_eq!(pq.top(), Some(&5i));\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn push(&mut self, item: T) {\n         self.data.push(item);\n         let new_len = self.len() - 1;\n@@ -495,12 +523,15 @@ impl<T: Ord> BinaryHeap<T> {\n     }\n \n     /// Returns the length of the queue.\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn len(&self) -> uint { self.data.len() }\n \n     /// Returns true if the queue contains no elements\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn is_empty(&self) -> bool { self.len() == 0 }\n \n     /// Drops all items from the queue.\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn clear(&mut self) { self.data.truncate(0) }\n }\n \n@@ -528,8 +559,7 @@ impl<T: Ord> Extendable<T> for BinaryHeap<T> {\n     fn extend<Iter: Iterator<T>>(&mut self, mut iter: Iter) {\n         let (lower, _) = iter.size_hint();\n \n-        let len = self.capacity();\n-        self.reserve(len + lower);\n+        self.reserve(lower);\n \n         for elem in iter {\n             self.push(elem);"}, {"sha": "833cfc04c552befe8625f05b43e5663d68ded994", "filename": "src/libcollections/bit.rs", "status": "modified", "additions": 26, "deletions": 2, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -75,6 +75,8 @@ use std::hash;\n \n use vec::Vec;\n \n+// FIXME(conventions): look, we just need to refactor this whole thing. Inside and out.\n+\n type MatchWords<'a> = Chain<MaskWords<'a>, Skip<Take<Enumerate<Repeat<u32>>>>>;\n // Take two BitV's, and return iterators of their words, where the shorter one\n // has been padded with 0's\n@@ -216,6 +218,7 @@ impl Bitv {\n     /// use std::collections::Bitv;\n     /// let mut bv = Bitv::new();\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn new() -> Bitv {\n         Bitv { storage: Vec::new(), nbits: 0 }\n     }\n@@ -613,6 +616,7 @@ impl Bitv {\n     /// bv.truncate(2);\n     /// assert!(bv.eq_vec([false, true]));\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn truncate(&mut self, len: uint) {\n         if len < self.len() {\n             self.nbits = len;\n@@ -760,14 +764,17 @@ impl Bitv {\n \n     /// Return the total number of bits in this vector\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn len(&self) -> uint { self.nbits }\n \n     /// Returns true if there are no bits in this vector\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn is_empty(&self) -> bool { self.len() == 0 }\n \n     /// Clears all bits in this vector.\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn clear(&mut self) {\n         for w in self.storage.iter_mut() { *w = 0u32; }\n     }\n@@ -849,8 +856,7 @@ impl Clone for Bitv {\n     #[inline]\n     fn clone_from(&mut self, source: &Bitv) {\n         self.nbits = source.nbits;\n-        self.storage.reserve(source.storage.len());\n-        for (i, w) in self.storage.iter_mut().enumerate() { *w = source.storage[i]; }\n+        self.storage.clone_from(&source.storage);\n     }\n }\n \n@@ -1052,6 +1058,7 @@ impl BitvSet {\n     /// let mut s = BitvSet::new();\n     /// ```\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn new() -> BitvSet {\n         BitvSet(Bitv::new())\n     }\n@@ -1067,6 +1074,7 @@ impl BitvSet {\n     /// assert!(s.capacity() >= 100);\n     /// ```\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn with_capacity(nbits: uint) -> BitvSet {\n         let bitv = Bitv::with_capacity(nbits, false);\n         BitvSet::from_bitv(bitv)\n@@ -1106,6 +1114,7 @@ impl BitvSet {\n     /// assert!(s.capacity() >= 100);\n     /// ```\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn capacity(&self) -> uint {\n         let &BitvSet(ref bitv) = self;\n         bitv.capacity()\n@@ -1212,6 +1221,7 @@ impl BitvSet {\n     /// println!(\"new capacity: {}\", s.capacity());\n     /// ```\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn shrink_to_fit(&mut self) {\n         let &BitvSet(ref mut bitv) = self;\n         // Obtain original length\n@@ -1240,6 +1250,7 @@ impl BitvSet {\n     /// }\n     /// ```\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn iter<'a>(&'a self) -> BitPositions<'a> {\n         BitPositions {set: self, next_idx: 0u}\n     }\n@@ -1262,6 +1273,7 @@ impl BitvSet {\n     /// }\n     /// ```\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn union<'a>(&'a self, other: &'a BitvSet) -> TwoBitPositions<'a> {\n         TwoBitPositions {\n             set: self,\n@@ -1290,6 +1302,7 @@ impl BitvSet {\n     /// }\n     /// ```\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn intersection<'a>(&'a self, other: &'a BitvSet) -> Take<TwoBitPositions<'a>> {\n         let min = cmp::min(self.capacity(), other.capacity());\n         TwoBitPositions {\n@@ -1326,6 +1339,7 @@ impl BitvSet {\n     /// }\n     /// ```\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn difference<'a>(&'a self, other: &'a BitvSet) -> TwoBitPositions<'a> {\n         TwoBitPositions {\n             set: self,\n@@ -1355,6 +1369,7 @@ impl BitvSet {\n     /// }\n     /// ```\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn symmetric_difference<'a>(&'a self, other: &'a BitvSet) -> TwoBitPositions<'a> {\n         TwoBitPositions {\n             set: self,\n@@ -1473,27 +1488,31 @@ impl BitvSet {\n \n     /// Return the number of set bits in this set.\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn len(&self) -> uint  {\n         let &BitvSet(ref bitv) = self;\n         bitv.storage.iter().fold(0, |acc, &n| acc + n.count_ones())\n     }\n \n     /// Returns whether there are no bits set in this set\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn is_empty(&self) -> bool {\n         let &BitvSet(ref bitv) = self;\n         bitv.storage.iter().all(|&n| n == 0)\n     }\n \n     /// Clears all bits in this set\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn clear(&mut self) {\n         let &BitvSet(ref mut bitv) = self;\n         bitv.clear();\n     }\n \n     /// Returns `true` if this set contains the specified integer.\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn contains(&self, value: &uint) -> bool {\n         let &BitvSet(ref bitv) = self;\n         *value < bitv.nbits && bitv.get(*value)\n@@ -1502,12 +1521,14 @@ impl BitvSet {\n     /// Returns `true` if the set has no elements in common with `other`.\n     /// This is equivalent to checking for an empty intersection.\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn is_disjoint(&self, other: &BitvSet) -> bool {\n         self.intersection(other).next().is_none()\n     }\n \n     /// Returns `true` if the set is a subset of another.\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn is_subset(&self, other: &BitvSet) -> bool {\n         let &BitvSet(ref self_bitv) = self;\n         let &BitvSet(ref other_bitv) = other;\n@@ -1521,12 +1542,14 @@ impl BitvSet {\n \n     /// Returns `true` if the set is a superset of another.\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn is_superset(&self, other: &BitvSet) -> bool {\n         other.is_subset(self)\n     }\n \n     /// Adds a value to the set. Returns `true` if the value was not already\n     /// present in the set.\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn insert(&mut self, value: uint) -> bool {\n         if self.contains(&value) {\n             return false;\n@@ -1545,6 +1568,7 @@ impl BitvSet {\n \n     /// Removes a value from the set. Returns `true` if the value was\n     /// present in the set.\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn remove(&mut self, value: &uint) -> bool {\n         if !self.contains(value) {\n             return false;"}, {"sha": "9b644115f301009811b59c1173837dbf556a53db", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 89, "deletions": 87, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -25,6 +25,8 @@ use core::fmt::Show;\n \n use ring_buf::RingBuf;\n \n+// FIXME(conventions): implement bounded iterators\n+\n /// A map based on a B-Tree.\n ///\n /// B-Trees represent a fundamental compromise between cache-efficiency and actually minimizing\n@@ -125,6 +127,7 @@ pub struct OccupiedEntry<'a, K:'a, V:'a> {\n \n impl<K: Ord, V> BTreeMap<K, V> {\n     /// Makes a new empty BTreeMap with a reasonable choice for B.\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn new() -> BTreeMap<K, V> {\n         //FIXME(Gankro): Tune this as a function of size_of<K/V>?\n         BTreeMap::with_b(6)\n@@ -155,12 +158,19 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// a.clear();\n     /// assert!(a.is_empty());\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn clear(&mut self) {\n         let b = self.b;\n         // avoid recursive destructors by manually traversing the tree\n         for _ in mem::replace(self, BTreeMap::with_b(b)).into_iter() {};\n     }\n \n+    /// Deprecated: renamed to `get`.\n+    #[deprecated = \"renamed to `get`\"]\n+    pub fn find(&self, key: &K) -> Option<&V> {\n+        self.get(key)\n+    }\n+\n     // Searching in a B-Tree is pretty straightforward.\n     //\n     // Start at the root. Try to find the key in the current node. If we find it, return it.\n@@ -178,10 +188,11 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     ///\n     /// let mut map = BTreeMap::new();\n     /// map.insert(1u, \"a\");\n-    /// assert_eq!(map.find(&1), Some(&\"a\"));\n-    /// assert_eq!(map.find(&2), None);\n+    /// assert_eq!(map.get(&1), Some(&\"a\"));\n+    /// assert_eq!(map.get(&2), None);\n     /// ```\n-    pub fn find(&self, key: &K) -> Option<&V> {\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn get(&self, key: &K) -> Option<&V> {\n         let mut cur_node = &self.root;\n         loop {\n             match cur_node.search(key) {\n@@ -209,9 +220,15 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(map.contains_key(&1), true);\n     /// assert_eq!(map.contains_key(&2), false);\n     /// ```\n-    #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn contains_key(&self, key: &K) -> bool {\n-        self.find(key).is_some()\n+        self.get(key).is_some()\n+    }\n+\n+    /// Deprecated: renamed to `get_mut`.\n+    #[deprecated = \"renamed to `get_mut`\"]\n+    pub fn find_mut(&mut self, key: &K) -> Option<&mut V> {\n+        self.get_mut(key)\n     }\n \n     /// Returns a mutable reference to the value corresponding to the key.\n@@ -223,14 +240,15 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     ///\n     /// let mut map = BTreeMap::new();\n     /// map.insert(1u, \"a\");\n-    /// match map.find_mut(&1) {\n+    /// match map.get_mut(&1) {\n     ///     Some(x) => *x = \"b\",\n     ///     None => (),\n     /// }\n     /// assert_eq!(map[1], \"b\");\n     /// ```\n-    // See `find` for implementation notes, this is basically a copy-paste with mut's added\n-    pub fn find_mut(&mut self, key: &K) -> Option<&mut V> {\n+    // See `get` for implementation notes, this is basically a copy-paste with mut's added\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn get_mut(&mut self, key: &K) -> Option<&mut V> {\n         // temp_node is a Borrowck hack for having a mutable value outlive a loop iteration\n         let mut temp_node = &mut self.root;\n         loop {\n@@ -248,6 +266,12 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         }\n     }\n \n+    /// Deprecated: renamed to `insert`.\n+    #[deprecated = \"renamed to `insert`\"]\n+    pub fn swap(&mut self, key: K, value: V) -> Option<V> {\n+        self.insert(key, value)\n+    }\n+\n     // Insertion in a B-Tree is a bit complicated.\n     //\n     // First we do the same kind of search described in `find`. But we need to maintain a stack of\n@@ -283,14 +307,15 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// use std::collections::BTreeMap;\n     ///\n     /// let mut map = BTreeMap::new();\n-    /// assert_eq!(map.swap(37u, \"a\"), None);\n+    /// assert_eq!(map.insert(37u, \"a\"), None);\n     /// assert_eq!(map.is_empty(), false);\n     ///\n     /// map.insert(37, \"b\");\n-    /// assert_eq!(map.swap(37, \"c\"), Some(\"b\"));\n+    /// assert_eq!(map.insert(37, \"c\"), Some(\"b\"));\n     /// assert_eq!(map[37], \"c\");\n     /// ```\n-    pub fn swap(&mut self, key: K, mut value: V) -> Option<V> {\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn insert(&mut self, key: K, mut value: V) -> Option<V> {\n         // This is a stack of rawptrs to nodes paired with indices, respectively\n         // representing the nodes and edges of our search path. We have to store rawptrs\n         // because as far as Rust is concerned, we can mutate aliased data with such a\n@@ -338,25 +363,6 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         }\n     }\n \n-    /// Inserts a key-value pair into the map. An existing value for a\n-    /// key is replaced by the new value. Returns `true` if the key did\n-    /// not already exist in the map.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::BTreeMap;\n-    ///\n-    /// let mut map = BTreeMap::new();\n-    /// assert_eq!(map.insert(2u, \"value\"), true);\n-    /// assert_eq!(map.insert(2, \"value2\"), false);\n-    /// assert_eq!(map[2], \"value2\");\n-    /// ```\n-    #[inline]\n-    pub fn insert(&mut self, key: K, value: V) -> bool {\n-        self.swap(key, value).is_none()\n-    }\n-\n     // Deletion is the most complicated operation for a B-Tree.\n     //\n     // First we do the same kind of search described in\n@@ -392,6 +398,12 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     //      the underflow handling process on the parent. If merging merges the last two children\n     //      of the root, then we replace the root with the merged node.\n \n+    /// Deprecated: renamed to `remove`.\n+    #[deprecated = \"renamed to `remove`\"]\n+    pub fn pop(&mut self, key: &K) -> Option<V> {\n+        self.remove(key)\n+    }\n+\n     /// Removes a key from the map, returning the value at the key if the key\n     /// was previously in the map.\n     ///\n@@ -402,10 +414,11 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     ///\n     /// let mut map = BTreeMap::new();\n     /// map.insert(1u, \"a\");\n-    /// assert_eq!(map.pop(&1), Some(\"a\"));\n-    /// assert_eq!(map.pop(&1), None);\n+    /// assert_eq!(map.remove(&1), Some(\"a\"));\n+    /// assert_eq!(map.remove(&1), None);\n     /// ```\n-    pub fn pop(&mut self, key: &K) -> Option<V> {\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn remove(&mut self, key: &K) -> Option<V> {\n         // See `swap` for a more thorough description of the stuff going on in here\n         let mut stack = stack::PartialSearchStack::new(self);\n         loop {\n@@ -426,24 +439,6 @@ impl<K: Ord, V> BTreeMap<K, V> {\n             }\n         }\n     }\n-\n-    /// Removes a key-value pair from the map. Returns `true` if the key\n-    /// was present in the map.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::BTreeMap;\n-    ///\n-    /// let mut map = BTreeMap::new();\n-    /// assert_eq!(map.remove(&1u), false);\n-    /// map.insert(1, \"a\");\n-    /// assert_eq!(map.remove(&1), true);\n-    /// ```\n-    #[inline]\n-    pub fn remove(&mut self, key: &K) -> bool {\n-        self.pop(key).is_some()\n-    }\n }\n \n /// The stack module provides a safe interface for constructing and manipulating a stack of ptrs\n@@ -793,13 +788,13 @@ impl<K: Show, V: Show> Show for BTreeMap<K, V> {\n \n impl<K: Ord, V> Index<K, V> for BTreeMap<K, V> {\n     fn index(&self, key: &K) -> &V {\n-        self.find(key).expect(\"no entry found for key\")\n+        self.get(key).expect(\"no entry found for key\")\n     }\n }\n \n impl<K: Ord, V> IndexMut<K, V> for BTreeMap<K, V> {\n     fn index_mut(&mut self, key: &K) -> &mut V {\n-        self.find_mut(key).expect(\"no entry found for key\")\n+        self.get_mut(key).expect(\"no entry found for key\")\n     }\n }\n \n@@ -891,8 +886,8 @@ impl<K, V, E, T: Traverse<E> + DoubleEndedIterator<TraversalItem<K, V, E>>>\n \n             // Handle any operation on the left stack as necessary\n             match op {\n-                Push(item) => { self.left.push(item); },\n-                Pop => { self.left.pop(); },\n+                Push(item) => { self.left.push_back(item); },\n+                Pop => { self.left.pop_back(); },\n             }\n         }\n     }\n@@ -933,8 +928,8 @@ impl<K, V, E, T: Traverse<E> + DoubleEndedIterator<TraversalItem<K, V, E>>>\n             };\n \n             match op {\n-                Push(item) => { self.right.push(item); },\n-                Pop => { self.right.pop(); }\n+                Push(item) => { self.right.push_back(item); },\n+                Pop => { self.right.pop_back(); }\n             }\n         }\n     }\n@@ -1010,6 +1005,7 @@ impl<'a, K: Ord, V> OccupiedEntry<'a, K, V> {\n \n impl<K, V> BTreeMap<K, V> {\n     /// Gets an iterator over the entries of the map.\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn iter<'a>(&'a self) -> Entries<'a, K, V> {\n         let len = self.len();\n         Entries {\n@@ -1023,6 +1019,7 @@ impl<K, V> BTreeMap<K, V> {\n     }\n \n     /// Gets a mutable iterator over the entries of the map.\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn iter_mut<'a>(&'a mut self) -> MutEntries<'a, K, V> {\n         let len = self.len();\n         MutEntries {\n@@ -1036,6 +1033,7 @@ impl<K, V> BTreeMap<K, V> {\n     }\n \n     /// Gets an owning iterator over the entries of the map.\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn into_iter(self) -> MoveEntries<K, V> {\n         let len = self.len();\n         MoveEntries {\n@@ -1049,11 +1047,13 @@ impl<K, V> BTreeMap<K, V> {\n     }\n \n     /// Gets an iterator over the keys of the map.\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn keys<'a>(&'a self) -> Keys<'a, K, V> {\n         self.iter().map(|(k, _)| k)\n     }\n \n     /// Gets an iterator over the values of the map.\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn values<'a>(&'a self) -> Values<'a, K, V> {\n         self.iter().map(|(_, v)| v)\n     }\n@@ -1070,6 +1070,7 @@ impl<K, V> BTreeMap<K, V> {\n     /// a.insert(1u, \"a\");\n     /// assert_eq!(a.len(), 1);\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn len(&self) -> uint { self.length }\n \n     /// Return true if the map contains no elements.\n@@ -1084,6 +1085,7 @@ impl<K, V> BTreeMap<K, V> {\n     /// a.insert(1u, \"a\");\n     /// assert!(!a.is_empty());\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn is_empty(&self) -> bool { self.len() == 0 }\n }\n \n@@ -1137,58 +1139,58 @@ mod test {\n         assert_eq!(map.len(), 0);\n \n         for i in range(0, size) {\n-            assert_eq!(map.swap(i, 10*i), None);\n+            assert_eq!(map.insert(i, 10*i), None);\n             assert_eq!(map.len(), i + 1);\n         }\n \n         for i in range(0, size) {\n-            assert_eq!(map.find(&i).unwrap(), &(i*10));\n+            assert_eq!(map.get(&i).unwrap(), &(i*10));\n         }\n \n         for i in range(size, size*2) {\n-            assert_eq!(map.find(&i), None);\n+            assert_eq!(map.get(&i), None);\n         }\n \n         for i in range(0, size) {\n-            assert_eq!(map.swap(i, 100*i), Some(10*i));\n+            assert_eq!(map.insert(i, 100*i), Some(10*i));\n             assert_eq!(map.len(), size);\n         }\n \n         for i in range(0, size) {\n-            assert_eq!(map.find(&i).unwrap(), &(i*100));\n+            assert_eq!(map.get(&i).unwrap(), &(i*100));\n         }\n \n         for i in range(0, size/2) {\n-            assert_eq!(map.pop(&(i*2)), Some(i*200));\n+            assert_eq!(map.remove(&(i*2)), Some(i*200));\n             assert_eq!(map.len(), size - i - 1);\n         }\n \n         for i in range(0, size/2) {\n-            assert_eq!(map.find(&(2*i)), None);\n-            assert_eq!(map.find(&(2*i+1)).unwrap(), &(i*200 + 100));\n+            assert_eq!(map.get(&(2*i)), None);\n+            assert_eq!(map.get(&(2*i+1)).unwrap(), &(i*200 + 100));\n         }\n \n         for i in range(0, size/2) {\n-            assert_eq!(map.pop(&(2*i)), None);\n-            assert_eq!(map.pop(&(2*i+1)), Some(i*200 + 100));\n+            assert_eq!(map.remove(&(2*i)), None);\n+            assert_eq!(map.remove(&(2*i+1)), Some(i*200 + 100));\n             assert_eq!(map.len(), size/2 - i - 1);\n         }\n     }\n \n     #[test]\n     fn test_basic_small() {\n         let mut map = BTreeMap::new();\n-        assert_eq!(map.pop(&1), None);\n-        assert_eq!(map.find(&1), None);\n-        assert_eq!(map.swap(1u, 1u), None);\n-        assert_eq!(map.find(&1), Some(&1));\n-        assert_eq!(map.swap(1, 2), Some(1));\n-        assert_eq!(map.find(&1), Some(&2));\n-        assert_eq!(map.swap(2, 4), None);\n-        assert_eq!(map.find(&2), Some(&4));\n-        assert_eq!(map.pop(&1), Some(2));\n-        assert_eq!(map.pop(&2), Some(4));\n-        assert_eq!(map.pop(&1), None);\n+        assert_eq!(map.remove(&1), None);\n+        assert_eq!(map.get(&1), None);\n+        assert_eq!(map.insert(1u, 1u), None);\n+        assert_eq!(map.get(&1), Some(&1));\n+        assert_eq!(map.insert(1, 2), Some(1));\n+        assert_eq!(map.get(&1), Some(&2));\n+        assert_eq!(map.insert(2, 4), None);\n+        assert_eq!(map.get(&2), Some(&4));\n+        assert_eq!(map.remove(&1), Some(2));\n+        assert_eq!(map.remove(&2), Some(4));\n+        assert_eq!(map.remove(&1), None);\n     }\n \n     #[test]\n@@ -1283,7 +1285,7 @@ mod test {\n                 assert_eq!(view.set(100), 10);\n             }\n         }\n-        assert_eq!(map.find(&1).unwrap(), &100);\n+        assert_eq!(map.get(&1).unwrap(), &100);\n         assert_eq!(map.len(), 6);\n \n \n@@ -1295,7 +1297,7 @@ mod test {\n                 *v *= 10;\n             }\n         }\n-        assert_eq!(map.find(&2).unwrap(), &200);\n+        assert_eq!(map.get(&2).unwrap(), &200);\n         assert_eq!(map.len(), 6);\n \n         // Existing key (take)\n@@ -1305,7 +1307,7 @@ mod test {\n                 assert_eq!(view.take(), 30);\n             }\n         }\n-        assert_eq!(map.find(&3), None);\n+        assert_eq!(map.get(&3), None);\n         assert_eq!(map.len(), 5);\n \n \n@@ -1316,7 +1318,7 @@ mod test {\n                 assert_eq!(*view.set(1000), 1000);\n             }\n         }\n-        assert_eq!(map.find(&10).unwrap(), &1000);\n+        assert_eq!(map.get(&10).unwrap(), &1000);\n         assert_eq!(map.len(), 6);\n     }\n }\n@@ -1374,15 +1376,15 @@ mod bench {\n         let mut m : BTreeMap<uint,uint> = BTreeMap::new();\n         find_rand_n(100, &mut m, b,\n                     |m, i| { m.insert(i, 1); },\n-                    |m, i| { m.find(&i); });\n+                    |m, i| { m.get(&i); });\n     }\n \n     #[bench]\n     pub fn find_rand_10_000(b: &mut Bencher) {\n         let mut m : BTreeMap<uint,uint> = BTreeMap::new();\n         find_rand_n(10_000, &mut m, b,\n                     |m, i| { m.insert(i, 1); },\n-                    |m, i| { m.find(&i); });\n+                    |m, i| { m.get(&i); });\n     }\n \n     // Find seq\n@@ -1391,23 +1393,23 @@ mod bench {\n         let mut m : BTreeMap<uint,uint> = BTreeMap::new();\n         find_seq_n(100, &mut m, b,\n                    |m, i| { m.insert(i, 1); },\n-                   |m, i| { m.find(&i); });\n+                   |m, i| { m.get(&i); });\n     }\n \n     #[bench]\n     pub fn find_seq_10_000(b: &mut Bencher) {\n         let mut m : BTreeMap<uint,uint> = BTreeMap::new();\n         find_seq_n(10_000, &mut m, b,\n                    |m, i| { m.insert(i, 1); },\n-                   |m, i| { m.find(&i); });\n+                   |m, i| { m.get(&i); });\n     }\n \n     fn bench_iter(b: &mut Bencher, size: uint) {\n         let mut map = BTreeMap::<uint, uint>::new();\n         let mut rng = weak_rng();\n \n         for _ in range(0, size) {\n-            map.swap(rng.gen(), rng.gen());\n+            map.insert(rng.gen(), rng.gen());\n         }\n \n         b.iter(|| {"}, {"sha": "f6a3de11d13df0d30eb9a0e0698baf0a93a48629", "filename": "src/libcollections/btree/set.rs", "status": "modified", "additions": 22, "deletions": 3, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fset.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -20,6 +20,9 @@ use core::{iter, fmt};\n use core::iter::Peekable;\n use core::fmt::Show;\n \n+// FIXME(conventions): implement bounded iterators\n+// FIXME(conventions): implement BitOr, BitAnd, BitXor, and Sub\n+\n /// A set based on a B-Tree.\n ///\n /// See BTreeMap's documentation for a detailed discussion of this collection's performance\n@@ -61,6 +64,7 @@ pub struct UnionItems<'a, T:'a> {\n \n impl<T: Ord> BTreeSet<T> {\n     /// Makes a new BTreeSet with a reasonable choice of B.\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn new() -> BTreeSet<T> {\n         BTreeSet { map: BTreeMap::new() }\n     }\n@@ -75,35 +79,41 @@ impl<T: Ord> BTreeSet<T> {\n \n impl<T> BTreeSet<T> {\n     /// Gets an iterator over the BTreeSet's contents.\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn iter<'a>(&'a self) -> Items<'a, T> {\n         self.map.keys()\n     }\n \n     /// Gets an iterator for moving out the BtreeSet's contents.\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn into_iter(self) -> MoveItems<T> {\n         self.map.into_iter().map(|(k, _)| k)\n     }\n }\n \n impl<T: Ord> BTreeSet<T> {\n     /// Visits the values representing the difference, in ascending order.\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn difference<'a>(&'a self, other: &'a BTreeSet<T>) -> DifferenceItems<'a, T> {\n         DifferenceItems{a: self.iter().peekable(), b: other.iter().peekable()}\n     }\n \n     /// Visits the values representing the symmetric difference, in ascending order.\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn symmetric_difference<'a>(&'a self, other: &'a BTreeSet<T>)\n         -> SymDifferenceItems<'a, T> {\n         SymDifferenceItems{a: self.iter().peekable(), b: other.iter().peekable()}\n     }\n \n     /// Visits the values representing the intersection, in ascending order.\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn intersection<'a>(&'a self, other: &'a BTreeSet<T>)\n         -> IntersectionItems<'a, T> {\n         IntersectionItems{a: self.iter().peekable(), b: other.iter().peekable()}\n     }\n \n     /// Visits the values representing the union, in ascending order.\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn union<'a>(&'a self, other: &'a BTreeSet<T>) -> UnionItems<'a, T> {\n         UnionItems{a: self.iter().peekable(), b: other.iter().peekable()}\n     }\n@@ -120,6 +130,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// v.insert(1i);\n     /// assert_eq!(v.len(), 1);\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn len(&self) -> uint { self.map.len() }\n \n     /// Returns true if the set contains no elements\n@@ -134,6 +145,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// v.insert(1i);\n     /// assert!(!v.is_empty());\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn is_empty(&self) -> bool { self.len() == 0 }\n \n     /// Clears the set, removing all values.\n@@ -148,6 +160,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// v.clear();\n     /// assert!(v.is_empty());\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn clear(&mut self) {\n         self.map.clear()\n     }\n@@ -163,8 +176,9 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert_eq!(set.contains(&1), true);\n     /// assert_eq!(set.contains(&4), false);\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn contains(&self, value: &T) -> bool {\n-        self.map.find(value).is_some()\n+        self.map.contains_key(value)\n     }\n \n     /// Returns `true` if the set has no elements in common with `other`.\n@@ -184,6 +198,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// b.insert(1);\n     /// assert_eq!(a.is_disjoint(&b), false);\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn is_disjoint(&self, other: &BTreeSet<T>) -> bool {\n         self.intersection(other).next().is_none()\n     }\n@@ -204,6 +219,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// set.insert(4);\n     /// assert_eq!(set.is_subset(&sup), false);\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn is_subset(&self, other: &BTreeSet<T>) -> bool {\n         // Stolen from TreeMap\n         let mut x = self.iter();\n@@ -248,6 +264,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// set.insert(2);\n     /// assert_eq!(set.is_superset(&sub), true);\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn is_superset(&self, other: &BTreeSet<T>) -> bool {\n         other.is_subset(self)\n     }\n@@ -266,8 +283,9 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert_eq!(set.insert(2i), false);\n     /// assert_eq!(set.len(), 1);\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn insert(&mut self, value: T) -> bool {\n-        self.map.insert(value, ())\n+        self.map.insert(value, ()).is_none()\n     }\n \n     /// Removes a value from the set. Returns `true` if the value was\n@@ -284,8 +302,9 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert_eq!(set.remove(&2), true);\n     /// assert_eq!(set.remove(&2), false);\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn remove(&mut self, value: &T) -> bool {\n-        self.map.remove(value)\n+        self.map.remove(value).is_some()\n     }\n }\n "}, {"sha": "9d9955141df15ae4b1c7960657956863efb0fabd", "filename": "src/libcollections/dlist.rs", "status": "modified", "additions": 87, "deletions": 60, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibcollections%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibcollections%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdlist.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -195,6 +195,7 @@ impl<T> Default for DList<T> {\n impl<T> DList<T> {\n     /// Creates an empty `DList`.\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn new() -> DList<T> {\n         DList{list_head: None, list_tail: Rawlink::none(), length: 0}\n     }\n@@ -209,9 +210,9 @@ impl<T> DList<T> {\n     /// use std::collections::DList;\n     ///\n     /// let mut dl = DList::new();\n-    /// dl.push(1i);\n-    /// dl.push(2);\n-    /// dl.push(3);\n+    /// dl.push_back(1i);\n+    /// dl.push_back(2);\n+    /// dl.push_back(3);\n     ///\n     /// dl.rotate_forward();\n     ///\n@@ -236,9 +237,9 @@ impl<T> DList<T> {\n     /// use std::collections::DList;\n     ///\n     /// let mut dl = DList::new();\n-    /// dl.push(1i);\n-    /// dl.push(2);\n-    /// dl.push(3);\n+    /// dl.push_back(1i);\n+    /// dl.push_back(2);\n+    /// dl.push_back(3);\n     ///\n     /// dl.rotate_backward();\n     ///\n@@ -264,10 +265,10 @@ impl<T> DList<T> {\n     ///\n     /// let mut a = DList::new();\n     /// let mut b = DList::new();\n-    /// a.push(1i);\n-    /// a.push(2);\n-    /// b.push(3i);\n-    /// b.push(4);\n+    /// a.push_back(1i);\n+    /// a.push_back(2);\n+    /// b.push_back(3i);\n+    /// b.push_back(4);\n     ///\n     /// a.append(b);\n     ///\n@@ -305,10 +306,10 @@ impl<T> DList<T> {\n     ///\n     /// let mut a = DList::new();\n     /// let mut b = DList::new();\n-    /// a.push(1i);\n-    /// a.push(2);\n-    /// b.push(3i);\n-    /// b.push(4);\n+    /// a.push_back(1i);\n+    /// a.push_back(2);\n+    /// b.push_back(3i);\n+    /// b.push_back(4);\n     ///\n     /// a.prepend(b);\n     ///\n@@ -333,10 +334,10 @@ impl<T> DList<T> {\n     /// use std::collections::DList;\n     ///\n     /// let mut a: DList<int> = DList::new();\n-    /// a.push(2i);\n-    /// a.push(4);\n-    /// a.push(7);\n-    /// a.push(8);\n+    /// a.push_back(2i);\n+    /// a.push_back(4);\n+    /// a.push_back(7);\n+    /// a.push_back(8);\n     ///\n     /// // insert 11 before the first odd number in the list\n     /// a.insert_when(11, |&e, _| e % 2 == 1);\n@@ -387,12 +388,14 @@ impl<T> DList<T> {\n \n     /// Provides a forward iterator.\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn iter<'a>(&'a self) -> Items<'a, T> {\n         Items{nelem: self.len(), head: &self.list_head, tail: self.list_tail}\n     }\n \n     /// Provides a forward iterator with mutable references.\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn iter_mut<'a>(&'a mut self) -> MutItems<'a, T> {\n         let head_raw = match self.list_head {\n             Some(ref mut h) => Rawlink::some(&mut **h),\n@@ -408,6 +411,7 @@ impl<T> DList<T> {\n \n     /// Consumes the list into an iterator yielding elements by value.\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn into_iter(self) -> MoveItems<T> {\n         MoveItems{list: self}\n     }\n@@ -416,6 +420,7 @@ impl<T> DList<T> {\n     ///\n     /// This operation should compute in O(1) time.\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn is_empty(&self) -> bool {\n         self.list_head.is_none()\n     }\n@@ -424,6 +429,7 @@ impl<T> DList<T> {\n     ///\n     /// This operation should compute in O(1) time.\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn len(&self) -> uint {\n         self.length\n     }\n@@ -432,41 +438,47 @@ impl<T> DList<T> {\n     ///\n     /// This operation should compute in O(n) time.\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn clear(&mut self) {\n         *self = DList::new()\n     }\n \n     /// Provides a reference to the front element, or `None` if the list is\n     /// empty.\n     #[inline]\n-    pub fn front<'a>(&'a self) -> Option<&'a T> {\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn front(&self) -> Option<&T> {\n         self.list_head.as_ref().map(|head| &head.value)\n     }\n \n     /// Provides a mutable reference to the front element, or `None` if the list\n     /// is empty.\n     #[inline]\n-    pub fn front_mut<'a>(&'a mut self) -> Option<&'a mut T> {\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn front_mut(&mut self) -> Option<&mut T> {\n         self.list_head.as_mut().map(|head| &mut head.value)\n     }\n \n     /// Provides a reference to the back element, or `None` if the list is\n     /// empty.\n     #[inline]\n-    pub fn back<'a>(&'a self) -> Option<&'a T> {\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn back(&self) -> Option<&T> {\n         self.list_tail.resolve_immut().as_ref().map(|tail| &tail.value)\n     }\n \n     /// Provides a mutable reference to the back element, or `None` if the list\n     /// is empty.\n     #[inline]\n-    pub fn back_mut<'a>(&'a mut self) -> Option<&'a mut T> {\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn back_mut(&mut self) -> Option<&mut T> {\n         self.list_tail.resolve().map(|tail| &mut tail.value)\n     }\n \n     /// Adds an element first in the list.\n     ///\n     /// This operation should compute in O(1) time.\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn push_front(&mut self, elt: T) {\n         self.push_front_node(box Node::new(elt))\n     }\n@@ -475,10 +487,17 @@ impl<T> DList<T> {\n     /// empty.\n     ///\n     /// This operation should compute in O(1) time.\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn pop_front(&mut self) -> Option<T> {\n         self.pop_front_node().map(|box Node{value, ..}| value)\n     }\n \n+    /// Deprecated: Renamed to `push_back`.\n+    #[deprecated = \"Renamed to `push_back`\"]\n+    pub fn push(&mut self, elt: T) {\n+        self.push_back(elt)\n+    }\n+\n     /// Appends an element to the back of a list\n     ///\n     /// # Example\n@@ -487,14 +506,21 @@ impl<T> DList<T> {\n     /// use std::collections::DList;\n     ///\n     /// let mut d = DList::new();\n-    /// d.push(1i);\n-    /// d.push(3);\n+    /// d.push_back(1i);\n+    /// d.push_back(3);\n     /// assert_eq!(3, *d.back().unwrap());\n     /// ```\n-    pub fn push(&mut self, elt: T) {\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn push_back(&mut self, elt: T) {\n         self.push_back_node(box Node::new(elt))\n     }\n \n+    /// Deprecated: Renamed to `pop_back`.\n+    #[deprecated = \"Renamed to `pop_back`\"]\n+    pub fn pop(&mut self) -> Option<T> {\n+        self.pop_back()\n+    }\n+\n     /// Removes the last element from a list and returns it, or `None` if\n     /// it is empty.\n     ///\n@@ -504,12 +530,13 @@ impl<T> DList<T> {\n     /// use std::collections::DList;\n     ///\n     /// let mut d = DList::new();\n-    /// assert_eq!(d.pop(), None);\n-    /// d.push(1i);\n-    /// d.push(3);\n-    /// assert_eq!(d.pop(), Some(3));\n+    /// assert_eq!(d.pop_back(), None);\n+    /// d.push_back(1i);\n+    /// d.push_back(3);\n+    /// assert_eq!(d.pop_back(), Some(3));\n     /// ```\n-    pub fn pop(&mut self) -> Option<T> {\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn pop_back(&mut self) -> Option<T> {\n         self.pop_back_node().map(|box Node{value, ..}| value)\n     }\n }\n@@ -682,7 +709,7 @@ impl<A> Iterator<A> for MoveItems<A> {\n \n impl<A> DoubleEndedIterator<A> for MoveItems<A> {\n     #[inline]\n-    fn next_back(&mut self) -> Option<A> { self.list.pop() }\n+    fn next_back(&mut self) -> Option<A> { self.list.pop_back() }\n }\n \n impl<A> FromIterator<A> for DList<A> {\n@@ -695,7 +722,7 @@ impl<A> FromIterator<A> for DList<A> {\n \n impl<A> Extendable<A> for DList<A> {\n     fn extend<T: Iterator<A>>(&mut self, mut iterator: T) {\n-        for elt in iterator { self.push(elt); }\n+        for elt in iterator { self.push_back(elt); }\n     }\n }\n \n@@ -801,21 +828,21 @@ mod tests {\n     fn test_basic() {\n         let mut m: DList<Box<int>> = DList::new();\n         assert_eq!(m.pop_front(), None);\n-        assert_eq!(m.pop(), None);\n+        assert_eq!(m.pop_back(), None);\n         assert_eq!(m.pop_front(), None);\n         m.push_front(box 1);\n         assert_eq!(m.pop_front(), Some(box 1));\n-        m.push(box 2);\n-        m.push(box 3);\n+        m.push_back(box 2);\n+        m.push_back(box 3);\n         assert_eq!(m.len(), 2);\n         assert_eq!(m.pop_front(), Some(box 2));\n         assert_eq!(m.pop_front(), Some(box 3));\n         assert_eq!(m.len(), 0);\n         assert_eq!(m.pop_front(), None);\n-        m.push(box 1);\n-        m.push(box 3);\n-        m.push(box 5);\n-        m.push(box 7);\n+        m.push_back(box 1);\n+        m.push_back(box 3);\n+        m.push_back(box 5);\n+        m.push_back(box 7);\n         assert_eq!(m.pop_front(), Some(box 1));\n \n         let mut n = DList::new();\n@@ -853,19 +880,19 @@ mod tests {\n         {\n             let mut m = DList::new();\n             let mut n = DList::new();\n-            n.push(2i);\n+            n.push_back(2i);\n             m.append(n);\n             assert_eq!(m.len(), 1);\n-            assert_eq!(m.pop(), Some(2));\n+            assert_eq!(m.pop_back(), Some(2));\n             check_links(&m);\n         }\n         {\n             let mut m = DList::new();\n             let n = DList::new();\n-            m.push(2i);\n+            m.push_back(2i);\n             m.append(n);\n             assert_eq!(m.len(), 1);\n-            assert_eq!(m.pop(), Some(2));\n+            assert_eq!(m.pop_back(), Some(2));\n             check_links(&m);\n         }\n \n@@ -887,10 +914,10 @@ mod tests {\n         {\n             let mut m = DList::new();\n             let mut n = DList::new();\n-            n.push(2i);\n+            n.push_back(2i);\n             m.prepend(n);\n             assert_eq!(m.len(), 1);\n-            assert_eq!(m.pop(), Some(2));\n+            assert_eq!(m.pop_back(), Some(2));\n             check_links(&m);\n         }\n \n@@ -948,9 +975,9 @@ mod tests {\n     #[test]\n     fn test_iterator_clone() {\n         let mut n = DList::new();\n-        n.push(2i);\n-        n.push(3);\n-        n.push(4);\n+        n.push_back(2i);\n+        n.push_back(3);\n+        n.push_back(4);\n         let mut it = n.iter();\n         it.next();\n         let mut jt = it.clone();\n@@ -1005,7 +1032,7 @@ mod tests {\n         let mut n = DList::new();\n         assert!(n.iter_mut().next().is_none());\n         n.push_front(4i);\n-        n.push(5);\n+        n.push_back(5);\n         let mut it = n.iter_mut();\n         assert_eq!(it.size_hint(), (2, Some(2)));\n         assert!(it.next().is_some());\n@@ -1079,8 +1106,8 @@ mod tests {\n         assert_eq!(n.pop_front(), Some(1));\n \n         let mut m = DList::new();\n-        m.push(2i);\n-        m.push(4);\n+        m.push_back(2i);\n+        m.push_back(4);\n         m.insert_ordered(3);\n         check_links(&m);\n         assert_eq!(vec![2,3,4], m.into_iter().collect::<Vec<int>>());\n@@ -1117,7 +1144,7 @@ mod tests {\n         assert!(n == m);\n         n.push_front(1);\n         assert!(n != m);\n-        m.push(1);\n+        m.push_back(1);\n         assert!(n == m);\n \n         let n = list_from([2i,3,4]);\n@@ -1132,9 +1159,9 @@ mod tests {\n \n       assert!(hash::hash(&x) == hash::hash(&y));\n \n-      x.push(1i);\n-      x.push(2);\n-      x.push(3);\n+      x.push_back(1i);\n+      x.push_back(2);\n+      x.push_back(3);\n \n       y.push_front(3i);\n       y.push_front(2);\n@@ -1214,7 +1241,7 @@ mod tests {\n             let r: u8 = rand::random();\n             match r % 6 {\n                 0 => {\n-                    m.pop();\n+                    m.pop_back();\n                     v.pop();\n                 }\n                 1 => {\n@@ -1226,7 +1253,7 @@ mod tests {\n                     v.insert(0, -i);\n                 }\n                 3 | 5 | _ => {\n-                    m.push(i);\n+                    m.push_back(i);\n                     v.push(i);\n                 }\n             }\n@@ -1262,16 +1289,16 @@ mod tests {\n     fn bench_push_back(b: &mut test::Bencher) {\n         let mut m: DList<int> = DList::new();\n         b.iter(|| {\n-            m.push(0);\n+            m.push_back(0);\n         })\n     }\n \n     #[bench]\n     fn bench_push_back_pop_back(b: &mut test::Bencher) {\n         let mut m: DList<int> = DList::new();\n         b.iter(|| {\n-            m.push(0);\n-            m.pop();\n+            m.push_back(0);\n+            m.pop_back();\n         })\n     }\n "}, {"sha": "77eee98ecd8d925310f3ade01851b682993832a2", "filename": "src/libcollections/enum_set.rs", "status": "modified", "additions": 129, "deletions": 68, "changes": 197, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibcollections%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibcollections%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fenum_set.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -16,6 +16,10 @@\n use core::prelude::*;\n use core::fmt;\n \n+// FIXME(conventions): implement BitXor\n+// FIXME(contentions): implement union family of methods? (general design may be wrong here)\n+// FIXME(conventions): implement len\n+\n #[deriving(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n /// A specialized `Set` implementation to use enum types.\n pub struct EnumSet<E> {\n@@ -47,52 +51,104 @@ pub trait CLike {\n     fn from_uint(uint) -> Self;\n }\n \n-fn bit<E:CLike>(e: E) -> uint {\n+fn bit<E:CLike>(e: &E) -> uint {\n     1 << e.to_uint()\n }\n \n impl<E:CLike> EnumSet<E> {\n-    /// Returns an empty `EnumSet`.\n+    /// Deprecated: Renamed to `new`.\n+    #[deprecated = \"Renamed to `new`\"]\n     pub fn empty() -> EnumSet<E> {\n+        EnumSet::new()\n+    }\n+\n+    /// Returns an empty `EnumSet`.\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn new() -> EnumSet<E> {\n         EnumSet {bits: 0}\n     }\n \n     /// Returns true if the `EnumSet` is empty.\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn is_empty(&self) -> bool {\n         self.bits == 0\n     }\n \n+    pub fn clear(&mut self) {\n+        self.bits = 0;\n+    }\n+\n     /// Returns `true` if the `EnumSet` contains any enum of the given `EnumSet`.\n+    /// Deprecated: Use `is_disjoint`.\n+    #[deprecated = \"Use `is_disjoint`\"]\n     pub fn intersects(&self, e: EnumSet<E>) -> bool {\n-        (self.bits & e.bits) != 0\n+        !self.is_disjoint(&e)\n     }\n \n-    /// Returns the intersection of both `EnumSets`.\n-    pub fn intersection(&self, e: EnumSet<E>) -> EnumSet<E> {\n-        EnumSet {bits: self.bits & e.bits}\n+    /// Returns `false` if the `EnumSet` contains any enum of the given `EnumSet`.\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn is_disjoint(&self, other: &EnumSet<E>) -> bool {\n+        (self.bits & other.bits) == 0\n+    }\n+\n+    /// Returns `true` if a given `EnumSet` is included in this `EnumSet`.\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn is_superset(&self, other: &EnumSet<E>) -> bool {\n+        (self.bits & other.bits) == other.bits\n     }\n \n-    /// Returns `true` if a given `EnumSet` is included in an `EnumSet`.\n-    pub fn contains(&self, e: EnumSet<E>) -> bool {\n-        (self.bits & e.bits) == e.bits\n+    /// Returns `true` if this `EnumSet` is included in the given `EnumSet`.\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn is_subset(&self, other: &EnumSet<E>) -> bool {\n+        other.is_superset(self)\n     }\n \n     /// Returns the union of both `EnumSets`.\n     pub fn union(&self, e: EnumSet<E>) -> EnumSet<E> {\n         EnumSet {bits: self.bits | e.bits}\n     }\n \n-    /// Adds an enum to an `EnumSet`.\n+    /// Returns the intersection of both `EnumSets`.\n+    pub fn intersection(&self, e: EnumSet<E>) -> EnumSet<E> {\n+        EnumSet {bits: self.bits & e.bits}\n+    }\n+\n+    /// Deprecated: Use `insert`.\n+    #[deprecated = \"Use `insert`\"]\n     pub fn add(&mut self, e: E) {\n-        self.bits |= bit(e);\n+        self.insert(e);\n     }\n \n-    /// Returns `true` if an `EnumSet` contains a given enum.\n+    /// Adds an enum to the `EnumSet`, and returns `true` if it wasn't there before\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn insert(&mut self, e: E) -> bool {\n+        let result = !self.contains(&e);\n+        self.bits |= bit(&e);\n+        result\n+    }\n+\n+    /// Removes an enum from the EnumSet\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn remove(&mut self, e: &E) -> bool {\n+        let result = self.contains(e);\n+        self.bits &= !bit(e);\n+        result\n+    }\n+\n+    /// Deprecated: use `contains`.\n+    #[deprecated = \"use `contains\"]\n     pub fn contains_elem(&self, e: E) -> bool {\n+        self.contains(&e)\n+    }\n+\n+    /// Returns `true` if an `EnumSet` contains a given enum.\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn contains(&self, e: &E) -> bool {\n         (self.bits & bit(e)) != 0\n     }\n \n     /// Returns an iterator over an `EnumSet`.\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn iter(&self) -> Items<E> {\n         Items::new(self.bits)\n     }\n@@ -174,18 +230,18 @@ mod test {\n     }\n \n     #[test]\n-    fn test_empty() {\n-        let e: EnumSet<Foo> = EnumSet::empty();\n+    fn test_new() {\n+        let e: EnumSet<Foo> = EnumSet::new();\n         assert!(e.is_empty());\n     }\n \n     #[test]\n     fn test_show() {\n-        let mut e = EnumSet::empty();\n+        let mut e = EnumSet::new();\n         assert_eq!(\"{}\", e.to_string().as_slice());\n-        e.add(A);\n+        e.insert(A);\n         assert_eq!(\"{A}\", e.to_string().as_slice());\n-        e.add(C);\n+        e.insert(C);\n         assert_eq!(\"{A, C}\", e.to_string().as_slice());\n     }\n \n@@ -194,100 +250,105 @@ mod test {\n \n     #[test]\n     fn test_two_empties_do_not_intersect() {\n-        let e1: EnumSet<Foo> = EnumSet::empty();\n-        let e2: EnumSet<Foo> = EnumSet::empty();\n-        assert!(!e1.intersects(e2));\n+        let e1: EnumSet<Foo> = EnumSet::new();\n+        let e2: EnumSet<Foo> = EnumSet::new();\n+        assert!(e1.is_disjoint(&e2));\n     }\n \n     #[test]\n     fn test_empty_does_not_intersect_with_full() {\n-        let e1: EnumSet<Foo> = EnumSet::empty();\n+        let e1: EnumSet<Foo> = EnumSet::new();\n \n-        let mut e2: EnumSet<Foo> = EnumSet::empty();\n-        e2.add(A);\n-        e2.add(B);\n-        e2.add(C);\n+        let mut e2: EnumSet<Foo> = EnumSet::new();\n+        e2.insert(A);\n+        e2.insert(B);\n+        e2.insert(C);\n \n-        assert!(!e1.intersects(e2));\n+        assert!(e1.is_disjoint(&e2));\n     }\n \n     #[test]\n     fn test_disjoint_intersects() {\n-        let mut e1: EnumSet<Foo> = EnumSet::empty();\n-        e1.add(A);\n+        let mut e1: EnumSet<Foo> = EnumSet::new();\n+        e1.insert(A);\n \n-        let mut e2: EnumSet<Foo> = EnumSet::empty();\n-        e2.add(B);\n+        let mut e2: EnumSet<Foo> = EnumSet::new();\n+        e2.insert(B);\n \n-        assert!(!e1.intersects(e2));\n+        assert!(e1.is_disjoint(&e2));\n     }\n \n     #[test]\n     fn test_overlapping_intersects() {\n-        let mut e1: EnumSet<Foo> = EnumSet::empty();\n-        e1.add(A);\n+        let mut e1: EnumSet<Foo> = EnumSet::new();\n+        e1.insert(A);\n \n-        let mut e2: EnumSet<Foo> = EnumSet::empty();\n-        e2.add(A);\n-        e2.add(B);\n+        let mut e2: EnumSet<Foo> = EnumSet::new();\n+        e2.insert(A);\n+        e2.insert(B);\n \n-        assert!(e1.intersects(e2));\n+        assert!(!e1.is_disjoint(&e2));\n     }\n \n     ///////////////////////////////////////////////////////////////////////////\n     // contains and contains_elem\n \n     #[test]\n-    fn test_contains() {\n-        let mut e1: EnumSet<Foo> = EnumSet::empty();\n-        e1.add(A);\n+    fn test_superset() {\n+        let mut e1: EnumSet<Foo> = EnumSet::new();\n+        e1.insert(A);\n \n-        let mut e2: EnumSet<Foo> = EnumSet::empty();\n-        e2.add(A);\n-        e2.add(B);\n+        let mut e2: EnumSet<Foo> = EnumSet::new();\n+        e2.insert(A);\n+        e2.insert(B);\n \n-        assert!(!e1.contains(e2));\n-        assert!(e2.contains(e1));\n+        let mut e3: EnumSet<Foo> = EnumSet::new();\n+        e3.insert(C);\n+\n+        assert!(e1.is_subset(&e2));\n+        assert!(e2.is_superset(&e1));\n+        assert!(!e3.is_superset(&e2))\n+        assert!(!e2.is_superset(&e3))\n     }\n \n     #[test]\n-    fn test_contains_elem() {\n-        let mut e1: EnumSet<Foo> = EnumSet::empty();\n-        e1.add(A);\n-        assert!(e1.contains_elem(A));\n-        assert!(!e1.contains_elem(B));\n-        assert!(!e1.contains_elem(C));\n-\n-        e1.add(A);\n-        e1.add(B);\n-        assert!(e1.contains_elem(A));\n-        assert!(e1.contains_elem(B));\n-        assert!(!e1.contains_elem(C));\n+    fn test_contains() {\n+        let mut e1: EnumSet<Foo> = EnumSet::new();\n+        e1.insert(A);\n+        assert!(e1.contains(&A));\n+        assert!(!e1.contains(&B));\n+        assert!(!e1.contains(&C));\n+\n+        e1.insert(A);\n+        e1.insert(B);\n+        assert!(e1.contains(&A));\n+        assert!(e1.contains(&B));\n+        assert!(!e1.contains(&C));\n     }\n \n     ///////////////////////////////////////////////////////////////////////////\n     // iter\n \n     #[test]\n     fn test_iterator() {\n-        let mut e1: EnumSet<Foo> = EnumSet::empty();\n+        let mut e1: EnumSet<Foo> = EnumSet::new();\n \n         let elems: Vec<Foo> = e1.iter().collect();\n         assert!(elems.is_empty())\n \n-        e1.add(A);\n+        e1.insert(A);\n         let elems = e1.iter().collect();\n         assert_eq!(vec![A], elems)\n \n-        e1.add(C);\n+        e1.insert(C);\n         let elems = e1.iter().collect();\n         assert_eq!(vec![A,C], elems)\n \n-        e1.add(C);\n+        e1.insert(C);\n         let elems = e1.iter().collect();\n         assert_eq!(vec![A,C], elems)\n \n-        e1.add(B);\n+        e1.insert(B);\n         let elems = e1.iter().collect();\n         assert_eq!(vec![A,B,C], elems)\n     }\n@@ -297,13 +358,13 @@ mod test {\n \n     #[test]\n     fn test_operators() {\n-        let mut e1: EnumSet<Foo> = EnumSet::empty();\n-        e1.add(A);\n-        e1.add(C);\n+        let mut e1: EnumSet<Foo> = EnumSet::new();\n+        e1.insert(A);\n+        e1.insert(C);\n \n-        let mut e2: EnumSet<Foo> = EnumSet::empty();\n-        e2.add(B);\n-        e2.add(C);\n+        let mut e2: EnumSet<Foo> = EnumSet::new();\n+        e2.insert(B);\n+        e2.insert(C);\n \n         let e_union = e1 | e2;\n         let elems = e_union.iter().collect();"}, {"sha": "549ebb14b3e160c7ef5eb8adff4fbf63268132d2", "filename": "src/libcollections/ring_buf.rs", "status": "modified", "additions": 218, "deletions": 110, "changes": 328, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibcollections%2Fring_buf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibcollections%2Fring_buf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fring_buf.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -27,6 +27,11 @@ use vec::Vec;\n static INITIAL_CAPACITY: uint = 8u; // 2^3\n static MINIMUM_CAPACITY: uint = 2u;\n \n+// FIXME(conventions): implement shrink_to_fit. Awkward with the current design, but it should\n+// be scrapped anyway. Defer to rewrite?\n+// FIXME(conventions): implement into_iter\n+\n+\n /// `RingBuf` is a circular buffer that implements `Deque`.\n #[deriving(Clone)]\n pub struct RingBuf<T> {\n@@ -42,36 +47,65 @@ impl<T> Default for RingBuf<T> {\n \n impl<T> RingBuf<T> {\n     /// Creates an empty `RingBuf`.\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn new() -> RingBuf<T> {\n         RingBuf::with_capacity(INITIAL_CAPACITY)\n     }\n \n     /// Creates an empty `RingBuf` with space for at least `n` elements.\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn with_capacity(n: uint) -> RingBuf<T> {\n         RingBuf{nelts: 0, lo: 0,\n               elts: Vec::from_fn(cmp::max(MINIMUM_CAPACITY, n), |_| None)}\n     }\n \n     /// Retrieves an element in the `RingBuf` by index.\n     ///\n-    /// Fails if there is no element with the given index.\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// use std::collections::RingBuf;\n+    ///\n+    /// let mut buf = RingBuf::new();\n+    /// buf.push_back(3i);\n+    /// buf.push_back(4);\n+    /// buf.push_back(5);\n+    /// assert_eq!(buf.get(1).unwrap(), &4);\n+    /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn get(&self, i: uint) -> Option<&T> {\n+        match self.elts.get(i) {\n+            None => None,\n+            Some(opt) => opt.as_ref(),\n+        }\n+    }\n+\n+    /// Retrieves an element in the `RingBuf` mutably by index.\n     ///\n     /// # Example\n     ///\n     /// ```rust\n-    /// # #![allow(deprecated)]\n     /// use std::collections::RingBuf;\n     ///\n     /// let mut buf = RingBuf::new();\n-    /// buf.push(3i);\n-    /// buf.push(4);\n-    /// buf.push(5);\n-    /// *buf.get_mut(1) = 7;\n+    /// buf.push_back(3i);\n+    /// buf.push_back(4);\n+    /// buf.push_back(5);\n+    /// match buf.get_mut(1) {\n+    ///     None => {}\n+    ///     Some(elem) => {\n+    ///         *elem = 7;\n+    ///     }\n+    /// }\n+    ///\n     /// assert_eq!(buf[1], 7);\n     /// ```\n-    #[deprecated = \"use indexing instead: `buf[index] = value`\"]\n-    pub fn get_mut(&mut self, i: uint) -> &mut T {\n-        &mut self[i]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn get_mut(&mut self, i: uint) -> Option<&mut T> {\n+        match self.elts.get_mut(i) {\n+            None => None,\n+            Some(opt) => opt.as_mut(),\n+        }\n     }\n \n     /// Swaps elements at indices `i` and `j`.\n@@ -86,9 +120,9 @@ impl<T> RingBuf<T> {\n     /// use std::collections::RingBuf;\n     ///\n     /// let mut buf = RingBuf::new();\n-    /// buf.push(3i);\n-    /// buf.push(4);\n-    /// buf.push(5);\n+    /// buf.push_back(3i);\n+    /// buf.push_back(4);\n+    /// buf.push_back(5);\n     /// buf.swap(0, 2);\n     /// assert_eq!(buf[0], 5);\n     /// assert_eq!(buf[2], 3);\n@@ -107,21 +141,70 @@ impl<T> RingBuf<T> {\n         raw_index(self.lo, self.elts.len(), idx)\n     }\n \n-    /// Reserves capacity for exactly `n` elements in the given `RingBuf`,\n-    /// doing nothing if `self`'s capacity is already equal to or greater\n-    /// than the requested capacity.\n-    pub fn reserve_exact(&mut self, n: uint) {\n-        self.elts.reserve_exact(n);\n+    /// Returns the number of elements the `RingBuf` can hold without\n+    /// reallocating.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::RingBuf;\n+    ///\n+    /// let buf: RingBuf<int> = RingBuf::with_capacity(10);\n+    /// assert_eq!(buf.capacity(), 10);\n+    /// ```\n+    #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn capacity(&self) -> uint {\n+        // FXIME(Gankro): not the actual usable capacity if you use reserve/reserve_exact\n+        self.elts.capacity()\n     }\n \n-    /// Reserves capacity for at least `n` elements in the given `RingBuf`,\n-    /// over-allocating in case the caller needs to reserve additional\n-    /// space.\n+    /// Reserves the minimum capacity for exactly `additional` more elements to be inserted in the\n+    /// given `RingBuf`. Does nothing if the capacity is already sufficient.\n+    ///\n+    /// Note that the allocator may give the collection more space than it requests. Therefore\n+    /// capacity can not be relied upon to be precisely minimal. Prefer `reserve` if future\n+    /// insertions are expected.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the new capacity overflows `uint`.\n     ///\n-    /// Do nothing if `self`'s capacity is already equal to or greater\n-    /// than the requested capacity.\n-    pub fn reserve(&mut self, n: uint) {\n-        self.elts.reserve(n);\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::RingBuf;\n+    ///\n+    /// let mut buf: RingBuf<int> = vec![1].into_iter().collect();\n+    /// buf.reserve_exact(10);\n+    /// assert!(buf.capacity() >= 11);\n+    /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn reserve_exact(&mut self, additional: uint) {\n+        // FIXME(Gankro): this is just wrong. The ringbuf won't actually use this space\n+        self.elts.reserve_exact(additional);\n+    }\n+\n+    /// Reserves capacity for at least `additional` more elements to be inserted in the given\n+    /// `Ringbuf`. The collection may reserve more space to avoid frequent reallocations.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the new capacity overflows `uint`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::RingBuf;\n+    ///\n+    /// let mut buf: RingBuf<int> = vec![1].into_iter().collect();\n+    /// buf.reserve(10);\n+    /// assert!(buf.capacity() >= 11);\n+    /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn reserve(&mut self, additional: uint) {\n+        // FIXME(Gankro): this is just wrong. The ringbuf won't actually use this space\n+        self.elts.reserve(additional);\n     }\n \n     /// Returns a front-to-back iterator.\n@@ -132,12 +215,13 @@ impl<T> RingBuf<T> {\n     /// use std::collections::RingBuf;\n     ///\n     /// let mut buf = RingBuf::new();\n-    /// buf.push(5i);\n-    /// buf.push(3);\n-    /// buf.push(4);\n+    /// buf.push_back(5i);\n+    /// buf.push_back(3);\n+    /// buf.push_back(4);\n     /// let b: &[_] = &[&5, &3, &4];\n     /// assert_eq!(buf.iter().collect::<Vec<&int>>().as_slice(), b);\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn iter(&self) -> Items<T> {\n         Items{index: 0, rindex: self.nelts, lo: self.lo, elts: self.elts.as_slice()}\n     }\n@@ -150,15 +234,16 @@ impl<T> RingBuf<T> {\n     /// use std::collections::RingBuf;\n     ///\n     /// let mut buf = RingBuf::new();\n-    /// buf.push(5i);\n-    /// buf.push(3);\n-    /// buf.push(4);\n+    /// buf.push_back(5i);\n+    /// buf.push_back(3);\n+    /// buf.push_back(4);\n     /// for num in buf.iter_mut() {\n     ///     *num = *num - 2;\n     /// }\n     /// let b: &[_] = &[&mut 3, &mut 1, &mut 2];\n     /// assert_eq!(buf.iter_mut().collect::<Vec<&mut int>>()[], b);\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn iter_mut(&mut self) -> MutItems<T> {\n         let start_index = raw_index(self.lo, self.elts.len(), 0);\n         let end_index = raw_index(self.lo, self.elts.len(), self.nelts);\n@@ -197,9 +282,10 @@ impl<T> RingBuf<T> {\n     ///\n     /// let mut v = RingBuf::new();\n     /// assert_eq!(v.len(), 0);\n-    /// v.push(1i);\n+    /// v.push_back(1i);\n     /// assert_eq!(v.len(), 1);\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn len(&self) -> uint { self.nelts }\n \n     /// Returns true if the buffer contains no elements\n@@ -214,6 +300,7 @@ impl<T> RingBuf<T> {\n     /// v.push_front(1i);\n     /// assert!(!v.is_empty());\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn is_empty(&self) -> bool { self.len() == 0 }\n \n     /// Clears the buffer, removing all values.\n@@ -224,10 +311,11 @@ impl<T> RingBuf<T> {\n     /// use std::collections::RingBuf;\n     ///\n     /// let mut v = RingBuf::new();\n-    /// v.push(1i);\n+    /// v.push_back(1i);\n     /// v.clear();\n     /// assert!(v.is_empty());\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn clear(&mut self) {\n         for x in self.elts.iter_mut() { *x = None }\n         self.nelts = 0;\n@@ -245,10 +333,11 @@ impl<T> RingBuf<T> {\n     /// let mut d = RingBuf::new();\n     /// assert_eq!(d.front(), None);\n     ///\n-    /// d.push(1i);\n-    /// d.push(2i);\n+    /// d.push_back(1i);\n+    /// d.push_back(2i);\n     /// assert_eq!(d.front(), Some(&1i));\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn front(&self) -> Option<&T> {\n         if self.nelts > 0 { Some(&self[0]) } else { None }\n     }\n@@ -264,14 +353,15 @@ impl<T> RingBuf<T> {\n     /// let mut d = RingBuf::new();\n     /// assert_eq!(d.front_mut(), None);\n     ///\n-    /// d.push(1i);\n-    /// d.push(2i);\n+    /// d.push_back(1i);\n+    /// d.push_back(2i);\n     /// match d.front_mut() {\n     ///     Some(x) => *x = 9i,\n     ///     None => (),\n     /// }\n     /// assert_eq!(d.front(), Some(&9i));\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn front_mut(&mut self) -> Option<&mut T> {\n         if self.nelts > 0 { Some(&mut self[0]) } else { None }\n     }\n@@ -287,10 +377,11 @@ impl<T> RingBuf<T> {\n     /// let mut d = RingBuf::new();\n     /// assert_eq!(d.back(), None);\n     ///\n-    /// d.push(1i);\n-    /// d.push(2i);\n+    /// d.push_back(1i);\n+    /// d.push_back(2i);\n     /// assert_eq!(d.back(), Some(&2i));\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn back(&self) -> Option<&T> {\n         if self.nelts > 0 { Some(&self[self.nelts - 1]) } else { None }\n     }\n@@ -306,14 +397,15 @@ impl<T> RingBuf<T> {\n     /// let mut d = RingBuf::new();\n     /// assert_eq!(d.back(), None);\n     ///\n-    /// d.push(1i);\n-    /// d.push(2i);\n+    /// d.push_back(1i);\n+    /// d.push_back(2i);\n     /// match d.back_mut() {\n     ///     Some(x) => *x = 9i,\n     ///     None => (),\n     /// }\n     /// assert_eq!(d.back(), Some(&9i));\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn back_mut(&mut self) -> Option<&mut T> {\n         let nelts = self.nelts;\n         if nelts > 0 { Some(&mut self[nelts - 1]) } else { None }\n@@ -328,13 +420,14 @@ impl<T> RingBuf<T> {\n     /// use std::collections::RingBuf;\n     ///\n     /// let mut d = RingBuf::new();\n-    /// d.push(1i);\n-    /// d.push(2i);\n+    /// d.push_back(1i);\n+    /// d.push_back(2i);\n     ///\n     /// assert_eq!(d.pop_front(), Some(1i));\n     /// assert_eq!(d.pop_front(), Some(2i));\n     /// assert_eq!(d.pop_front(), None);\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn pop_front(&mut self) -> Option<T> {\n         let result = self.elts[self.lo].take();\n         if result.is_some() {\n@@ -356,6 +449,7 @@ impl<T> RingBuf<T> {\n     /// d.push_front(2i);\n     /// assert_eq!(d.front(), Some(&2i));\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn push_front(&mut self, t: T) {\n         if self.nelts == self.elts.len() {\n             grow(self.nelts, &mut self.lo, &mut self.elts);\n@@ -367,6 +461,12 @@ impl<T> RingBuf<T> {\n         self.nelts += 1u;\n     }\n \n+    /// Deprecated: Renamed to `push_back`.\n+    #[deprecated = \"Renamed to `push_back`\"]\n+    pub fn push(&mut self, t: T) {\n+        self.push_back(t)\n+    }\n+\n     /// Appends an element to the back of a buffer\n     ///\n     /// # Example\n@@ -375,11 +475,12 @@ impl<T> RingBuf<T> {\n     /// use std::collections::RingBuf;\n     ///\n     /// let mut buf = RingBuf::new();\n-    /// buf.push(1i);\n-    /// buf.push(3);\n+    /// buf.push_back(1i);\n+    /// buf.push_back(3);\n     /// assert_eq!(3, *buf.back().unwrap());\n     /// ```\n-    pub fn push(&mut self, t: T) {\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn push_back(&mut self, t: T) {\n         if self.nelts == self.elts.len() {\n             grow(self.nelts, &mut self.lo, &mut self.elts);\n         }\n@@ -388,6 +489,12 @@ impl<T> RingBuf<T> {\n         self.nelts += 1u;\n     }\n \n+    /// Deprecated: Renamed to `pop_back`.\n+    #[deprecated = \"Renamed to `pop_back`\"]\n+    pub fn pop(&mut self) -> Option<T> {\n+        self.pop_back()\n+    }\n+\n     /// Removes the last element from a buffer and returns it, or `None` if\n     /// it is empty.\n     ///\n@@ -397,12 +504,13 @@ impl<T> RingBuf<T> {\n     /// use std::collections::RingBuf;\n     ///\n     /// let mut buf = RingBuf::new();\n-    /// assert_eq!(buf.pop(), None);\n-    /// buf.push(1i);\n-    /// buf.push(3);\n-    /// assert_eq!(buf.pop(), Some(3));\n+    /// assert_eq!(buf.pop_back(), None);\n+    /// buf.push_back(1i);\n+    /// buf.push_back(3);\n+    /// assert_eq!(buf.pop_back(), Some(3));\n     /// ```\n-    pub fn pop(&mut self) -> Option<T> {\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn pop_back(&mut self) -> Option<T> {\n         if self.nelts > 0 {\n             self.nelts -= 1;\n             let hi = self.raw_index(self.nelts);\n@@ -523,7 +631,7 @@ impl<'a, T> ExactSize<&'a mut T> for MutItems<'a, T> {}\n fn grow<T>(nelts: uint, loptr: &mut uint, elts: &mut Vec<Option<T>>) {\n     assert_eq!(nelts, elts.len());\n     let lo = *loptr;\n-    elts.reserve(nelts * 2);\n+    elts.reserve_exact(nelts);\n     let newlen = elts.capacity();\n \n     /* fill with None */\n@@ -630,7 +738,7 @@ impl<A> FromIterator<A> for RingBuf<A> {\n impl<A> Extendable<A> for RingBuf<A> {\n     fn extend<T: Iterator<A>>(&mut self, mut iterator: T) {\n         for elt in iterator {\n-            self.push(elt);\n+            self.push_back(elt);\n         }\n     }\n }\n@@ -666,9 +774,9 @@ mod tests {\n         assert_eq!(d.len(), 0u);\n         d.push_front(17i);\n         d.push_front(42i);\n-        d.push(137);\n+        d.push_back(137);\n         assert_eq!(d.len(), 3u);\n-        d.push(137);\n+        d.push_back(137);\n         assert_eq!(d.len(), 4u);\n         debug!(\"{}\", d.front());\n         assert_eq!(*d.front().unwrap(), 42);\n@@ -677,21 +785,21 @@ mod tests {\n         let mut i = d.pop_front();\n         debug!(\"{}\", i);\n         assert_eq!(i, Some(42));\n-        i = d.pop();\n+        i = d.pop_back();\n         debug!(\"{}\", i);\n         assert_eq!(i, Some(137));\n-        i = d.pop();\n+        i = d.pop_back();\n         debug!(\"{}\", i);\n         assert_eq!(i, Some(137));\n-        i = d.pop();\n+        i = d.pop_back();\n         debug!(\"{}\", i);\n         assert_eq!(i, Some(17));\n         assert_eq!(d.len(), 0u);\n-        d.push(3);\n+        d.push_back(3);\n         assert_eq!(d.len(), 1u);\n         d.push_front(2);\n         assert_eq!(d.len(), 2u);\n-        d.push(4);\n+        d.push_back(4);\n         assert_eq!(d.len(), 3u);\n         d.push_front(1);\n         assert_eq!(d.len(), 4u);\n@@ -711,22 +819,22 @@ mod tests {\n         assert_eq!(deq.len(), 0);\n         deq.push_front(a.clone());\n         deq.push_front(b.clone());\n-        deq.push(c.clone());\n+        deq.push_back(c.clone());\n         assert_eq!(deq.len(), 3);\n-        deq.push(d.clone());\n+        deq.push_back(d.clone());\n         assert_eq!(deq.len(), 4);\n         assert_eq!((*deq.front().unwrap()).clone(), b.clone());\n         assert_eq!((*deq.back().unwrap()).clone(), d.clone());\n         assert_eq!(deq.pop_front().unwrap(), b.clone());\n-        assert_eq!(deq.pop().unwrap(), d.clone());\n-        assert_eq!(deq.pop().unwrap(), c.clone());\n-        assert_eq!(deq.pop().unwrap(), a.clone());\n+        assert_eq!(deq.pop_back().unwrap(), d.clone());\n+        assert_eq!(deq.pop_back().unwrap(), c.clone());\n+        assert_eq!(deq.pop_back().unwrap(), a.clone());\n         assert_eq!(deq.len(), 0);\n-        deq.push(c.clone());\n+        deq.push_back(c.clone());\n         assert_eq!(deq.len(), 1);\n         deq.push_front(b.clone());\n         assert_eq!(deq.len(), 2);\n-        deq.push(d.clone());\n+        deq.push_back(d.clone());\n         assert_eq!(deq.len(), 3);\n         deq.push_front(a.clone());\n         assert_eq!(deq.len(), 4);\n@@ -750,7 +858,7 @@ mod tests {\n \n         let mut deq = RingBuf::new();\n         for i in range(0u, 66) {\n-            deq.push(i);\n+            deq.push_back(i);\n         }\n \n         for i in range(0u, 66) {\n@@ -788,7 +896,7 @@ mod tests {\n     fn bench_push_back(b: &mut test::Bencher) {\n         let mut deq = RingBuf::new();\n         b.iter(|| {\n-            deq.push(0i);\n+            deq.push_back(0i);\n         })\n     }\n \n@@ -861,17 +969,17 @@ mod tests {\n     #[test]\n     fn test_with_capacity() {\n         let mut d = RingBuf::with_capacity(0);\n-        d.push(1i);\n+        d.push_back(1i);\n         assert_eq!(d.len(), 1);\n         let mut d = RingBuf::with_capacity(50);\n-        d.push(1i);\n+        d.push_back(1i);\n         assert_eq!(d.len(), 1);\n     }\n \n     #[test]\n     fn test_with_capacity_non_power_two() {\n         let mut d3 = RingBuf::with_capacity(3);\n-        d3.push(1i);\n+        d3.push_back(1i);\n \n         // X = None, | = lo\n         // [|1, X, X]\n@@ -880,20 +988,20 @@ mod tests {\n         assert_eq!(d3.front(), None);\n \n         // [X, |3, X]\n-        d3.push(3);\n+        d3.push_back(3);\n         // [X, |3, 6]\n-        d3.push(6);\n+        d3.push_back(6);\n         // [X, X, |6]\n         assert_eq!(d3.pop_front(), Some(3));\n \n         // Pushing the lo past half way point to trigger\n         // the 'B' scenario for growth\n         // [9, X, |6]\n-        d3.push(9);\n+        d3.push_back(9);\n         // [9, 12, |6]\n-        d3.push(12);\n+        d3.push_back(12);\n \n-        d3.push(15);\n+        d3.push_back(15);\n         // There used to be a bug here about how the\n         // RingBuf made growth assumptions about the\n         // underlying Vec which didn't hold and lead\n@@ -912,25 +1020,25 @@ mod tests {\n     #[test]\n     fn test_reserve_exact() {\n         let mut d = RingBuf::new();\n-        d.push(0u64);\n+        d.push_back(0u64);\n         d.reserve_exact(50);\n-        assert_eq!(d.elts.capacity(), 50);\n+        assert!(d.capacity() >= 51);\n         let mut d = RingBuf::new();\n-        d.push(0u32);\n+        d.push_back(0u32);\n         d.reserve_exact(50);\n-        assert_eq!(d.elts.capacity(), 50);\n+        assert!(d.capacity() >= 51);\n     }\n \n     #[test]\n     fn test_reserve() {\n         let mut d = RingBuf::new();\n-        d.push(0u64);\n+        d.push_back(0u64);\n         d.reserve(50);\n-        assert_eq!(d.elts.capacity(), 64);\n+        assert!(d.capacity() >= 64);\n         let mut d = RingBuf::new();\n-        d.push(0u32);\n+        d.push_back(0u32);\n         d.reserve(50);\n-        assert_eq!(d.elts.capacity(), 64);\n+        assert!(d.capacity() >= 64);\n     }\n \n     #[test]\n@@ -948,7 +1056,7 @@ mod tests {\n         assert_eq!(d.iter().size_hint(), (0, Some(0)));\n \n         for i in range(0i, 5) {\n-            d.push(i);\n+            d.push_back(i);\n         }\n         {\n             let b: &[_] = &[&0,&1,&2,&3,&4];\n@@ -979,7 +1087,7 @@ mod tests {\n         assert_eq!(d.iter().rev().next(), None);\n \n         for i in range(0i, 5) {\n-            d.push(i);\n+            d.push_back(i);\n         }\n         {\n             let b: &[_] = &[&4,&3,&2,&1,&0];\n@@ -998,11 +1106,11 @@ mod tests {\n         let mut d = RingBuf::with_capacity(3);\n         assert!(d.iter_mut().rev().next().is_none());\n \n-        d.push(1i);\n-        d.push(2);\n-        d.push(3);\n+        d.push_back(1i);\n+        d.push_back(2);\n+        d.push_back(3);\n         assert_eq!(d.pop_front(), Some(1));\n-        d.push(4);\n+        d.push_back(4);\n \n         assert_eq!(d.iter_mut().rev().map(|x| *x).collect::<Vec<int>>(),\n                    vec!(4, 3, 2));\n@@ -1075,13 +1183,13 @@ mod tests {\n         let mut d = RingBuf::new();\n         d.push_front(17i);\n         d.push_front(42);\n-        d.push(137);\n-        d.push(137);\n+        d.push_back(137);\n+        d.push_back(137);\n         assert_eq!(d.len(), 4u);\n         let mut e = d.clone();\n         assert_eq!(e.len(), 4u);\n         while !d.is_empty() {\n-            assert_eq!(d.pop(), e.pop());\n+            assert_eq!(d.pop_back(), e.pop_back());\n         }\n         assert_eq!(d.len(), 0u);\n         assert_eq!(e.len(), 0u);\n@@ -1094,15 +1202,15 @@ mod tests {\n         d.push_front(137i);\n         d.push_front(17);\n         d.push_front(42);\n-        d.push(137);\n+        d.push_back(137);\n         let mut e = RingBuf::with_capacity(0);\n-        e.push(42);\n-        e.push(17);\n-        e.push(137);\n-        e.push(137);\n+        e.push_back(42);\n+        e.push_back(17);\n+        e.push_back(137);\n+        e.push_back(137);\n         assert!(&e == &d);\n-        e.pop();\n-        e.push(0);\n+        e.pop_back();\n+        e.push_back(0);\n         assert!(e != d);\n         e.clear();\n         assert!(e == RingBuf::new());\n@@ -1113,15 +1221,15 @@ mod tests {\n       let mut x = RingBuf::new();\n       let mut y = RingBuf::new();\n \n-      x.push(1i);\n-      x.push(2);\n-      x.push(3);\n+      x.push_back(1i);\n+      x.push_back(2);\n+      x.push_back(3);\n \n-      y.push(0i);\n-      y.push(1i);\n+      y.push_back(0i);\n+      y.push_back(1i);\n       y.pop_front();\n-      y.push(2);\n-      y.push(3);\n+      y.push_back(2);\n+      y.push_back(3);\n \n       assert!(hash::hash(&x) == hash::hash(&y));\n     }\n@@ -1130,9 +1238,9 @@ mod tests {\n     fn test_ord() {\n         let x = RingBuf::new();\n         let mut y = RingBuf::new();\n-        y.push(1i);\n-        y.push(2);\n-        y.push(3);\n+        y.push_back(1i);\n+        y.push_back(2);\n+        y.push_back(3);\n         assert!(x < y);\n         assert!(y > x);\n         assert!(x <= x);"}, {"sha": "55f37fac2eb8f7834e61d06bf5c556b6888aa2a8", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -1425,10 +1425,10 @@ mod tests {\n     fn test_capacity() {\n         let mut v = vec![0u64];\n         v.reserve_exact(10u);\n-        assert_eq!(v.capacity(), 10u);\n+        assert!(v.capacity() >= 11u);\n         let mut v = vec![0u32];\n         v.reserve_exact(10u);\n-        assert_eq!(v.capacity(), 10u);\n+        assert!(v.capacity() >= 11u);\n     }\n \n     #[test]\n@@ -2220,7 +2220,7 @@ mod bench {\n                 v.set_len(1024);\n             }\n             for i in range(0u, 1024) {\n-                *v.get_mut(i) = 0;\n+                v[i] = 0;\n             }\n         });\n     }"}, {"sha": "04fc85091faa04e0898c30740e5de8a127deef5d", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -76,6 +76,8 @@ pub use core::str::{truncate_utf16_at_nul, utf8_char_width, CharRange};\n pub use core::str::{Str, StrPrelude};\n pub use unicode::str::{UnicodeStrPrelude, Words, Graphemes, GraphemeIndices};\n \n+// FIXME(conventions): ensure bit/char conventions are followed by str's API\n+\n /*\n Section: Creating a string\n */\n@@ -308,7 +310,7 @@ impl<'a> Iterator<char> for Recompositions<'a> {\n                                             self.composee = Some(ch);\n                                             return Some(k);\n                                         }\n-                                        self.buffer.push(ch);\n+                                        self.buffer.push_back(ch);\n                                         self.last_ccc = Some(ch_class);\n                                     }\n                                 }\n@@ -322,7 +324,7 @@ impl<'a> Iterator<char> for Recompositions<'a> {\n                                         self.state = Purging;\n                                         return Some(k);\n                                     }\n-                                    self.buffer.push(ch);\n+                                    self.buffer.push_back(ch);\n                                     self.last_ccc = Some(ch_class);\n                                     continue;\n                                 }\n@@ -332,7 +334,7 @@ impl<'a> Iterator<char> for Recompositions<'a> {\n                                         continue;\n                                     }\n                                     None => {\n-                                        self.buffer.push(ch);\n+                                        self.buffer.push_back(ch);\n                                         self.last_ccc = Some(ch_class);\n                                     }\n                                 }"}, {"sha": "cf98a916bb01a4b8501ec39f63aed2ed94a5b5e4", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 33, "deletions": 25, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -330,8 +330,8 @@ impl String {\n \n         let mut buf = String::new();\n         buf.push(ch);\n-        let size = buf.len() * length;\n-        buf.reserve(size);\n+        let size = buf.len() * (length - 1);\n+        buf.reserve_exact(size);\n         for _ in range(1, length) {\n             buf.push(ch)\n         }\n@@ -379,27 +379,23 @@ impl String {\n     /// assert!(s.capacity() >= 10);\n     /// ```\n     #[inline]\n-    #[unstable = \"just implemented, needs to prove itself\"]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn capacity(&self) -> uint {\n         self.vec.capacity()\n     }\n \n-    /// Reserves capacity for at least `extra` additional bytes in this string buffer.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// let mut s = String::with_capacity(10);\n-    /// let before = s.capacity();\n-    /// s.reserve_additional(100);\n-    /// assert!(s.capacity() - before >= 100);\n-    /// ```\n-    #[inline]\n+    /// Deprecated: Renamed to `reserve`.\n+    #[deprecated = \"Renamed to `reserve`\"]\n     pub fn reserve_additional(&mut self, extra: uint) {\n-        self.vec.reserve_additional(extra)\n+        self.vec.reserve(extra)\n     }\n \n-    /// Reserves capacity for at least `capacity` bytes in this string buffer.\n+    /// Reserves capacity for at least `additional` more bytes to be inserted in the given\n+    /// `String`. The collection may reserve more space to avoid frequent reallocations.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the new capacity overflows `uint`.\n     ///\n     /// # Example\n     ///\n@@ -409,22 +405,33 @@ impl String {\n     /// assert!(s.capacity() >= 10);\n     /// ```\n     #[inline]\n-    pub fn reserve(&mut self, capacity: uint) {\n-        self.vec.reserve(capacity)\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn reserve(&mut self, additional: uint) {\n+        self.vec.reserve(additional)\n     }\n \n-    /// Reserves capacity for exactly `capacity` bytes in this string buffer.\n+    /// Reserves the minimum capacity for exactly `additional` more bytes to be inserted in the\n+    /// given `String`. Does nothing if the capacity is already sufficient.\n+    ///\n+    /// Note that the allocator may give the collection more space than it requests. Therefore\n+    /// capacity can not be relied upon to be precisely minimal. Prefer `reserve` if future\n+    /// insertions are expected.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the new capacity overflows `uint`.\n     ///\n     /// # Example\n     ///\n     /// ```\n     /// let mut s = String::new();\n-    /// s.reserve_exact(10);\n-    /// assert_eq!(s.capacity(), 10);\n+    /// s.reserve(10);\n+    /// assert!(s.capacity() >= 10);\n     /// ```\n     #[inline]\n-    pub fn reserve_exact(&mut self, capacity: uint) {\n-        self.vec.reserve_exact(capacity)\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn reserve_exact(&mut self, additional: uint) {\n+        self.vec.reserve_exact(additional)\n     }\n \n     /// Shrinks the capacity of this string buffer to match its length.\n@@ -439,6 +446,7 @@ impl String {\n     /// assert_eq!(s.capacity(), 3);\n     /// ```\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn shrink_to_fit(&mut self) {\n         self.vec.shrink_to_fit()\n     }\n@@ -459,7 +467,7 @@ impl String {\n     pub fn push(&mut self, ch: char) {\n         let cur_len = self.len();\n         // This may use up to 4 bytes.\n-        self.vec.reserve_additional(4);\n+        self.vec.reserve(4);\n \n         unsafe {\n             // Attempt to not use an intermediate buffer by just pushing bytes\n@@ -590,7 +598,7 @@ impl String {\n         let len = self.len();\n         assert!(idx <= len);\n         assert!(self.as_slice().is_char_boundary(idx));\n-        self.vec.reserve_additional(4);\n+        self.vec.reserve(4);\n         let mut bits = [0, ..4];\n         let amt = ch.encode_utf8(bits).unwrap();\n "}, {"sha": "ea1c37d036ae0cf0aa3ca6a8df43f9519ff02432", "filename": "src/libcollections/tree/map.rs", "status": "modified", "additions": 159, "deletions": 156, "changes": 315, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibcollections%2Ftree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibcollections%2Ftree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftree%2Fmap.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -21,6 +21,9 @@ use std::hash::{Writer, Hash};\n \n use vec::Vec;\n \n+// FIXME(conventions): implement bounded iterators\n+// FIXME(conventions): replace rev_iter(_mut) by making iter(_mut) DoubleEnded\n+\n /// This is implemented as an AA tree, which is a simplified variation of\n /// a red-black tree where red (horizontal) nodes can only be added\n /// as a right child. The time complexity is the same, and re-balancing\n@@ -60,7 +63,7 @@ use vec::Vec;\n /// }\n ///\n /// for key in range(0, 4) {\n-///     match map.find(&key) {\n+///     match map.get(&key) {\n ///         Some(val) => println!(\"{} has a value: {}\", key, val),\n ///         None => println!(\"{} not in map\", key),\n ///     }\n@@ -188,14 +191,14 @@ impl<K: Ord, V> Default for TreeMap<K,V> {\n impl<K: Ord, V> Index<K, V> for TreeMap<K, V> {\n     #[inline]\n     fn index<'a>(&'a self, i: &K) -> &'a V {\n-        self.find(i).expect(\"no entry found for key\")\n+        self.get(i).expect(\"no entry found for key\")\n     }\n }\n \n impl<K: Ord, V> IndexMut<K, V> for TreeMap<K, V> {\n     #[inline]\n     fn index_mut<'a>(&'a mut self, i: &K) -> &'a mut V {\n-        self.find_mut(i).expect(\"no entry found for key\")\n+        self.get_mut(i).expect(\"no entry found for key\")\n     }\n }\n \n@@ -208,6 +211,7 @@ impl<K: Ord, V> TreeMap<K, V> {\n     /// use std::collections::TreeMap;\n     /// let mut map: TreeMap<&str, int> = TreeMap::new();\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn new() -> TreeMap<K, V> { TreeMap{root: None, length: 0} }\n \n     /// Gets a lazy iterator over the keys in the map, in ascending order.\n@@ -226,6 +230,7 @@ impl<K: Ord, V> TreeMap<K, V> {\n     ///     println!(\"{}\", x);\n     /// }\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn keys<'a>(&'a self) -> Keys<'a, K, V> {\n         self.iter().map(|(k, _v)| k)\n     }\n@@ -247,6 +252,7 @@ impl<K: Ord, V> TreeMap<K, V> {\n     ///     println!(\"{}\", x);\n     /// }\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn values<'a>(&'a self) -> Values<'a, K, V> {\n         self.iter().map(|(_k, v)| v)\n     }\n@@ -267,6 +273,7 @@ impl<K: Ord, V> TreeMap<K, V> {\n     ///     println!(\"{}: {}\", key, value);\n     /// }\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn iter<'a>(&'a self) -> Entries<'a, K, V> {\n         Entries {\n             stack: vec!(),\n@@ -314,10 +321,11 @@ impl<K: Ord, V> TreeMap<K, V> {\n     ///     if key == &\"b\" { break }\n     /// }\n     ///\n-    /// assert_eq!(map.find(&\"a\"), Some(&11));\n-    /// assert_eq!(map.find(&\"b\"), Some(&12));\n-    /// assert_eq!(map.find(&\"c\"), Some(&3));\n+    /// assert_eq!(map.get(&\"a\"), Some(&11));\n+    /// assert_eq!(map.get(&\"b\"), Some(&12));\n+    /// assert_eq!(map.get(&\"c\"), Some(&3));\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn iter_mut<'a>(&'a mut self) -> MutEntries<'a, K, V> {\n         MutEntries {\n             stack: vec!(),\n@@ -345,15 +353,15 @@ impl<K: Ord, V> TreeMap<K, V> {\n     ///     if key == &\"b\" { break }\n     /// }\n     ///\n-    /// assert_eq!(map.find(&\"a\"), Some(&1));\n-    /// assert_eq!(map.find(&\"b\"), Some(&12));\n-    /// assert_eq!(map.find(&\"c\"), Some(&13));\n+    /// assert_eq!(map.get(&\"a\"), Some(&1));\n+    /// assert_eq!(map.get(&\"b\"), Some(&12));\n+    /// assert_eq!(map.get(&\"c\"), Some(&13));\n     /// ```\n     pub fn rev_iter_mut<'a>(&'a mut self) -> RevMutEntries<'a, K, V> {\n         RevMutEntries{iter: self.iter_mut()}\n     }\n \n-    /// Gets a lazy iterator that consumes the TreeMap.\n+    /// Gets a lazy iterator that consumes the treemap.\n     ///\n     /// # Example\n     ///\n@@ -368,6 +376,7 @@ impl<K: Ord, V> TreeMap<K, V> {\n     /// let vec: Vec<(&str, int)> = map.into_iter().collect();\n     /// assert_eq!(vec, vec![(\"a\", 1), (\"b\", 2), (\"c\", 3)]);\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn into_iter(self) -> MoveEntries<K, V> {\n         let TreeMap { root, length } = self;\n         let stk = match root {\n@@ -392,6 +401,7 @@ impl<K: Ord, V> TreeMap<K, V> {\n     /// a.insert(1u, \"a\");\n     /// assert_eq!(a.len(), 1);\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn len(&self) -> uint { self.length }\n \n     /// Return true if the map contains no elements.\n@@ -406,6 +416,7 @@ impl<K: Ord, V> TreeMap<K, V> {\n     /// a.insert(1u, \"a\");\n     /// assert!(!a.is_empty());\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     #[inline]\n     pub fn is_empty(&self) -> bool { self.len() == 0 }\n \n@@ -421,11 +432,18 @@ impl<K: Ord, V> TreeMap<K, V> {\n     /// a.clear();\n     /// assert!(a.is_empty());\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn clear(&mut self) {\n         self.root = None;\n         self.length = 0\n     }\n \n+    /// Deprecated: Renamed to `get`.\n+    #[deprecated = \"Renamed to `get`\"]\n+    pub fn find(&self, key: &K) -> Option<&V> {\n+        self.get(key)\n+    }\n+\n     /// Returns a reference to the value corresponding to the key.\n     ///\n     /// # Example\n@@ -435,11 +453,12 @@ impl<K: Ord, V> TreeMap<K, V> {\n     ///\n     /// let mut map = TreeMap::new();\n     /// map.insert(1u, \"a\");\n-    /// assert_eq!(map.find(&1), Some(&\"a\"));\n-    /// assert_eq!(map.find(&2), None);\n+    /// assert_eq!(map.get(&1), Some(&\"a\"));\n+    /// assert_eq!(map.get(&2), None);\n     /// ```\n     #[inline]\n-    pub fn find<'a>(&'a self, key: &K) -> Option<&'a V> {\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn get(&self, key: &K) -> Option<&V> {\n         tree_find_with(&self.root, |k2| key.cmp(k2))\n     }\n \n@@ -456,8 +475,15 @@ impl<K: Ord, V> TreeMap<K, V> {\n     /// assert_eq!(map.contains_key(&2), false);\n     /// ```\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn contains_key(&self, key: &K) -> bool {\n-        self.find(key).is_some()\n+        self.get(key).is_some()\n+    }\n+\n+    /// Deprecated: Renamed to `get_mut`.\n+    #[deprecated = \"Renamed to `get_mut`\"]\n+    pub fn find_mut(&mut self, key: &K) -> Option<&mut V> {\n+        self.get_mut(key)\n     }\n \n     /// Returns a mutable reference to the value corresponding to the key.\n@@ -469,52 +495,22 @@ impl<K: Ord, V> TreeMap<K, V> {\n     ///\n     /// let mut map = TreeMap::new();\n     /// map.insert(1u, \"a\");\n-    /// match map.find_mut(&1) {\n+    /// match map.get_mut(&1) {\n     ///     Some(x) => *x = \"b\",\n     ///     None => (),\n     /// }\n     /// assert_eq!(map[1], \"b\");\n     /// ```\n     #[inline]\n-    pub fn find_mut<'a>(&'a mut self, key: &K) -> Option<&'a mut V> {\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn get_mut(&mut self, key: &K) -> Option<&mut V> {\n         tree_find_with_mut(&mut self.root, |x| key.cmp(x))\n     }\n \n-    /// Inserts a key-value pair into the map. An existing value for a\n-    /// key is replaced by the new value. Returns `true` if the key did\n-    /// not already exist in the map.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::TreeMap;\n-    ///\n-    /// let mut map = TreeMap::new();\n-    /// assert_eq!(map.insert(2u, \"value\"), true);\n-    /// assert_eq!(map.insert(2, \"value2\"), false);\n-    /// assert_eq!(map[2], \"value2\");\n-    /// ```\n-    #[inline]\n-    pub fn insert(&mut self, key: K, value: V) -> bool {\n-        self.swap(key, value).is_none()\n-    }\n-\n-    /// Removes a key-value pair from the map. Returns `true` if the key\n-    /// was present in the map.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::TreeMap;\n-    ///\n-    /// let mut map = TreeMap::new();\n-    /// assert_eq!(map.remove(&1u), false);\n-    /// map.insert(1, \"a\");\n-    /// assert_eq!(map.remove(&1), true);\n-    /// ```\n-    #[inline]\n-    pub fn remove(&mut self, key: &K) -> bool {\n-        self.pop(key).is_some()\n+    /// Deprecated: Renamed to `insert`.\n+    #[deprecated = \"Renamed to `insert`\"]\n+    pub fn swap(&mut self, key: K, value: V) -> Option<V> {\n+        self.insert(key, value)\n     }\n \n     /// Inserts a key-value pair from the map. If the key already had a value\n@@ -526,19 +522,26 @@ impl<K: Ord, V> TreeMap<K, V> {\n     /// use std::collections::TreeMap;\n     ///\n     /// let mut map = TreeMap::new();\n-    /// assert_eq!(map.swap(37u, \"a\"), None);\n+    /// assert_eq!(map.insert(37u, \"a\"), None);\n     /// assert_eq!(map.is_empty(), false);\n     ///\n     /// map.insert(37, \"b\");\n-    /// assert_eq!(map.swap(37, \"c\"), Some(\"b\"));\n+    /// assert_eq!(map.insert(37, \"c\"), Some(\"b\"));\n     /// assert_eq!(map[37], \"c\");\n     /// ```\n-    pub fn swap(&mut self, key: K, value: V) -> Option<V> {\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn insert(&mut self, key: K, value: V) -> Option<V> {\n         let ret = insert(&mut self.root, key, value);\n         if ret.is_none() { self.length += 1 }\n         ret\n     }\n \n+    /// Deprecated: Renamed to `remove`.\n+    #[deprecated = \"Renamed to `remove`\"]\n+    pub fn pop(&mut self, key: &K) -> Option<V> {\n+        self.remove(key)\n+    }\n+\n     /// Removes a key from the map, returning the value at the key if the key\n     /// was previously in the map.\n     ///\n@@ -549,10 +552,11 @@ impl<K: Ord, V> TreeMap<K, V> {\n     ///\n     /// let mut map = TreeMap::new();\n     /// map.insert(1u, \"a\");\n-    /// assert_eq!(map.pop(&1), Some(\"a\"));\n-    /// assert_eq!(map.pop(&1), None);\n+    /// assert_eq!(map.remove(&1), Some(\"a\"));\n+    /// assert_eq!(map.remove(&1), None);\n     /// ```\n-    pub fn pop(&mut self, key: &K) -> Option<V> {\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn remove(&mut self, key: &K) -> Option<V> {\n         let ret = remove(&mut self.root, key);\n         if ret.is_some() { self.length -= 1 }\n         ret\n@@ -567,7 +571,7 @@ impl<K, V> TreeMap<K, V> {\n     /// # Example\n     ///\n     /// ```\n-    /// use std::collections::TreeMap;\n+    /// use collections::tree_map::TreeMap;\n     ///\n     /// fn get_headers() -> TreeMap<String, String> {\n     ///     let mut result = TreeMap::new();\n@@ -585,7 +589,7 @@ impl<K, V> TreeMap<K, V> {\n     /// assert_eq!((*ua.unwrap()).as_slice(), \"Curl-Rust/0.1\");\n     /// ```\n     #[inline]\n-    pub fn find_with<'a>(&'a self, f:|&K| -> Ordering) -> Option<&'a V> {\n+    pub fn find_with(&self, f:|&K| -> Ordering) -> Option<&V> {\n         tree_find_with(&self.root, f)\n     }\n \n@@ -596,9 +600,7 @@ impl<K, V> TreeMap<K, V> {\n     /// # Example\n     ///\n     /// ```\n-    /// use std::collections::TreeMap;\n-    ///\n-    /// let mut t = TreeMap::new();\n+    /// let mut t = collections::tree_map::TreeMap::new();\n     /// t.insert(\"Content-Type\", \"application/xml\");\n     /// t.insert(\"User-Agent\", \"Curl-Rust/0.1\");\n     ///\n@@ -608,7 +610,7 @@ impl<K, V> TreeMap<K, V> {\n     ///    None => panic!(),\n     /// }\n     ///\n-    /// assert_eq!(t.find(&\"User-Agent\"), Some(&new_ua));\n+    /// assert_eq!(t.get(&\"User-Agent\"), Some(&new_ua));\n     /// ```\n     #[inline]\n     pub fn find_with_mut<'a>(&'a mut self, f:|&K| -> Ordering) -> Option<&'a mut V> {\n@@ -742,10 +744,10 @@ impl<K: Ord, V> TreeMap<K, V> {\n     ///     *value = \"changed\";\n     /// }\n     ///\n-    /// assert_eq!(map.find(&2), Some(&\"a\"));\n-    /// assert_eq!(map.find(&4), Some(&\"changed\"));\n-    /// assert_eq!(map.find(&6), Some(&\"changed\"));\n-    /// assert_eq!(map.find(&8), Some(&\"changed\"));\n+    /// assert_eq!(map.get(&2), Some(&\"a\"));\n+    /// assert_eq!(map.get(&4), Some(&\"changed\"));\n+    /// assert_eq!(map.get(&6), Some(&\"changed\"));\n+    /// assert_eq!(map.get(&8), Some(&\"changed\"));\n     /// ```\n     pub fn lower_bound_mut<'a>(&'a mut self, k: &K) -> MutEntries<'a, K, V> {\n         bound_setup!(self.iter_mut_for_traversal(), k, true)\n@@ -776,10 +778,10 @@ impl<K: Ord, V> TreeMap<K, V> {\n     ///     *value = \"changed\";\n     /// }\n     ///\n-    /// assert_eq!(map.find(&2), Some(&\"a\"));\n-    /// assert_eq!(map.find(&4), Some(&\"b\"));\n-    /// assert_eq!(map.find(&6), Some(&\"changed\"));\n-    /// assert_eq!(map.find(&8), Some(&\"changed\"));\n+    /// assert_eq!(map.get(&2), Some(&\"a\"));\n+    /// assert_eq!(map.get(&4), Some(&\"b\"));\n+    /// assert_eq!(map.get(&6), Some(&\"changed\"));\n+    /// assert_eq!(map.get(&8), Some(&\"changed\"));\n     /// ```\n     pub fn upper_bound_mut<'a>(&'a mut self, k: &K) -> MutEntries<'a, K, V> {\n         bound_setup!(self.iter_mut_for_traversal(), k, false)\n@@ -1287,16 +1289,16 @@ mod test_treemap {\n     #[test]\n     fn find_empty() {\n         let m: TreeMap<int,int> = TreeMap::new();\n-        assert!(m.find(&5) == None);\n+        assert!(m.get(&5) == None);\n     }\n \n     #[test]\n     fn find_not_found() {\n         let mut m = TreeMap::new();\n-        assert!(m.insert(1i, 2i));\n-        assert!(m.insert(5i, 3i));\n-        assert!(m.insert(9i, 3i));\n-        assert_eq!(m.find(&2), None);\n+        assert!(m.insert(1i, 2i).is_none());\n+        assert!(m.insert(5i, 3i).is_none());\n+        assert!(m.insert(9i, 3i).is_none());\n+        assert_eq!(m.get(&2), None);\n     }\n \n     #[test]\n@@ -1308,41 +1310,42 @@ mod test_treemap {\n     #[test]\n     fn find_with_not_found() {\n         let mut m = TreeMap::new();\n-        assert!(m.insert(\"test1\", 2i));\n-        assert!(m.insert(\"test2\", 3i));\n-        assert!(m.insert(\"test3\", 3i));\n+        assert!(m.insert(\"test1\", 2i).is_none());\n+        assert!(m.insert(\"test2\", 3i).is_none());\n+        assert!(m.insert(\"test3\", 3i).is_none());\n         assert_eq!(m.find_with(|&k| \"test4\".cmp(k)), None);\n     }\n \n     #[test]\n     fn find_with_found() {\n         let mut m = TreeMap::new();\n-        assert!(m.insert(\"test1\", 2i));\n-        assert!(m.insert(\"test2\", 3i));\n-        assert!(m.insert(\"test3\", 4i));\n+        assert!(m.insert(\"test1\", 2i).is_none());\n+        assert!(m.insert(\"test2\", 3i).is_none());\n+        assert!(m.insert(\"test3\", 4i).is_none());\n         assert_eq!(m.find_with(|&k| \"test2\".cmp(k)), Some(&3i));\n     }\n \n     #[test]\n     fn test_find_mut() {\n         let mut m = TreeMap::new();\n-        assert!(m.insert(1i, 12i));\n-        assert!(m.insert(2, 8));\n-        assert!(m.insert(5, 14));\n+        assert!(m.insert(1i, 12i).is_none());\n+        assert!(m.insert(2, 8).is_none());\n+        assert!(m.insert(5, 14).is_none());\n         let new = 100;\n-        match m.find_mut(&5) {\n+        match m.get_mut(&5) {\n           None => panic!(), Some(x) => *x = new\n         }\n-        assert_eq!(m.find(&5), Some(&new));\n+        assert_eq!(m.get(&5), Some(&new));\n     }\n \n     #[test]\n     fn test_find_with_mut() {\n         let mut m = TreeMap::new();\n-        assert!(m.insert(\"t1\", 12i));\n-        assert!(m.insert(\"t2\", 8));\n-        assert!(m.insert(\"t5\", 14));\n+        assert!(m.insert(\"t1\", 12i).is_none());\n+        assert!(m.insert(\"t2\", 8).is_none());\n+        assert!(m.insert(\"t5\", 14).is_none());\n         let new = 100;\n+\n         match m.find_with_mut(|&k| \"t5\".cmp(k)) {\n           None => panic!(), Some(x) => *x = new\n         }\n@@ -1352,23 +1355,23 @@ mod test_treemap {\n     #[test]\n     fn insert_replace() {\n         let mut m = TreeMap::new();\n-        assert!(m.insert(5i, 2i));\n-        assert!(m.insert(2, 9));\n-        assert!(!m.insert(2, 11));\n-        assert_eq!(m.find(&2).unwrap(), &11);\n+        assert!(m.insert(5i, 2i).is_none());\n+        assert!(m.insert(2, 9).is_none());\n+        assert!(!m.insert(2, 11).is_none());\n+        assert_eq!(m.get(&2).unwrap(), &11);\n     }\n \n     #[test]\n     fn test_clear() {\n         let mut m = TreeMap::new();\n         m.clear();\n-        assert!(m.insert(5i, 11i));\n-        assert!(m.insert(12, -3));\n-        assert!(m.insert(19, 2));\n+        assert!(m.insert(5i, 11i).is_none());\n+        assert!(m.insert(12, -3).is_none());\n+        assert!(m.insert(19, 2).is_none());\n         m.clear();\n-        assert!(m.find(&5).is_none());\n-        assert!(m.find(&12).is_none());\n-        assert!(m.find(&19).is_none());\n+        assert!(m.get(&5).is_none());\n+        assert!(m.get(&12).is_none());\n+        assert!(m.get(&19).is_none());\n         assert!(m.is_empty());\n     }\n \n@@ -1384,16 +1387,16 @@ mod test_treemap {\n         m.insert(k1.clone(), v1.clone());\n         m.insert(k2.clone(), v2.clone());\n \n-        assert_eq!(m.find(&k2), Some(&v2));\n-        assert_eq!(m.find(&k1), Some(&v1));\n+        assert_eq!(m.get(&k2), Some(&v2));\n+        assert_eq!(m.get(&k1), Some(&v1));\n     }\n \n     fn check_equal<K: PartialEq + Ord, V: PartialEq>(ctrl: &[(K, V)],\n                                             map: &TreeMap<K, V>) {\n         assert_eq!(ctrl.is_empty(), map.is_empty());\n         for x in ctrl.iter() {\n             let &(ref k, ref v) = x;\n-            assert!(map.find(k).unwrap() == v)\n+            assert!(map.get(k).unwrap() == v)\n         }\n         for (map_k, map_v) in map.iter() {\n             let mut found = false;\n@@ -1455,7 +1458,7 @@ mod test_treemap {\n         let mut ctrl = vec![];\n \n         check_equal(ctrl.as_slice(), &map);\n-        assert!(map.find(&5).is_none());\n+        assert!(map.get(&5).is_none());\n \n         let seed: &[_] = &[42];\n         let mut rng: rand::IsaacRng = rand::SeedableRng::from_seed(seed);\n@@ -1465,7 +1468,7 @@ mod test_treemap {\n                 let k = rng.gen();\n                 let v = rng.gen();\n                 if !ctrl.iter().any(|x| x == &(k, v)) {\n-                    assert!(map.insert(k, v));\n+                    assert!(map.insert(k, v).is_none());\n                     ctrl.push((k, v));\n                     check_structure(&map);\n                     check_equal(ctrl.as_slice(), &map);\n@@ -1475,7 +1478,7 @@ mod test_treemap {\n             for _ in range(0u, 30) {\n                 let r = rng.gen_range(0, ctrl.len());\n                 let (key, _) = ctrl.remove(r).unwrap();\n-                assert!(map.remove(&key));\n+                assert!(map.remove(&key).is_some());\n                 check_structure(&map);\n                 check_equal(ctrl.as_slice(), &map);\n             }\n@@ -1485,31 +1488,31 @@ mod test_treemap {\n     #[test]\n     fn test_len() {\n         let mut m = TreeMap::new();\n-        assert!(m.insert(3i, 6i));\n+        assert!(m.insert(3i, 6i).is_none());\n         assert_eq!(m.len(), 1);\n-        assert!(m.insert(0, 0));\n+        assert!(m.insert(0, 0).is_none());\n         assert_eq!(m.len(), 2);\n-        assert!(m.insert(4, 8));\n+        assert!(m.insert(4, 8).is_none());\n         assert_eq!(m.len(), 3);\n-        assert!(m.remove(&3));\n+        assert!(m.remove(&3).is_some());\n         assert_eq!(m.len(), 2);\n-        assert!(!m.remove(&5));\n+        assert!(!m.remove(&5).is_some());\n         assert_eq!(m.len(), 2);\n-        assert!(m.insert(2, 4));\n+        assert!(m.insert(2, 4).is_none());\n         assert_eq!(m.len(), 3);\n-        assert!(m.insert(1, 2));\n+        assert!(m.insert(1, 2).is_none());\n         assert_eq!(m.len(), 4);\n     }\n \n     #[test]\n     fn test_iterator() {\n         let mut m = TreeMap::new();\n \n-        assert!(m.insert(3i, 6i));\n-        assert!(m.insert(0, 0));\n-        assert!(m.insert(4, 8));\n-        assert!(m.insert(2, 4));\n-        assert!(m.insert(1, 2));\n+        assert!(m.insert(3i, 6i).is_none());\n+        assert!(m.insert(0, 0).is_none());\n+        assert!(m.insert(4, 8).is_none());\n+        assert!(m.insert(2, 4).is_none());\n+        assert!(m.insert(1, 2).is_none());\n \n         let mut n = 0;\n         for (k, v) in m.iter() {\n@@ -1524,7 +1527,7 @@ mod test_treemap {\n     fn test_interval_iteration() {\n         let mut m = TreeMap::new();\n         for i in range(1i, 100i) {\n-            assert!(m.insert(i * 2, i * 4));\n+            assert!(m.insert(i * 2, i * 4).is_none());\n         }\n \n         for i in range(1i, 198i) {\n@@ -1548,11 +1551,11 @@ mod test_treemap {\n     fn test_rev_iter() {\n         let mut m = TreeMap::new();\n \n-        assert!(m.insert(3i, 6i));\n-        assert!(m.insert(0, 0));\n-        assert!(m.insert(4, 8));\n-        assert!(m.insert(2, 4));\n-        assert!(m.insert(1, 2));\n+        assert!(m.insert(3i, 6i).is_none());\n+        assert!(m.insert(0, 0).is_none());\n+        assert!(m.insert(4, 8).is_none());\n+        assert!(m.insert(2, 4).is_none());\n+        assert!(m.insert(1, 2).is_none());\n \n         let mut n = 4;\n         for (k, v) in m.rev_iter() {\n@@ -1566,7 +1569,7 @@ mod test_treemap {\n     fn test_mut_iter() {\n         let mut m = TreeMap::new();\n         for i in range(0u, 10) {\n-            assert!(m.insert(i, 100 * i));\n+            assert!(m.insert(i, 100 * i).is_none());\n         }\n \n         for (i, (&k, v)) in m.iter_mut().enumerate() {\n@@ -1581,7 +1584,7 @@ mod test_treemap {\n     fn test_mut_rev_iter() {\n         let mut m = TreeMap::new();\n         for i in range(0u, 10) {\n-            assert!(m.insert(i, 100 * i));\n+            assert!(m.insert(i, 100 * i).is_none());\n         }\n \n         for (i, (&k, v)) in m.rev_iter_mut().enumerate() {\n@@ -1598,8 +1601,8 @@ mod test_treemap {\n         let mut m_lower = TreeMap::new();\n         let mut m_upper = TreeMap::new();\n         for i in range(1i, 100i) {\n-            assert!(m_lower.insert(i * 2, i * 4));\n-            assert!(m_upper.insert(i * 2, i * 4));\n+            assert!(m_lower.insert(i * 2, i * 4).is_none());\n+            assert!(m_upper.insert(i * 2, i * 4).is_none());\n         }\n \n         for i in range(1i, 199) {\n@@ -1653,15 +1656,15 @@ mod test_treemap {\n         let mut b = TreeMap::new();\n \n         assert!(a == b);\n-        assert!(a.insert(0i, 5i));\n+        assert!(a.insert(0i, 5i).is_none());\n         assert!(a != b);\n-        assert!(b.insert(0, 4));\n+        assert!(b.insert(0, 4).is_none());\n         assert!(a != b);\n-        assert!(a.insert(5, 19));\n+        assert!(a.insert(5, 19).is_none());\n         assert!(a != b);\n-        assert!(!b.insert(0, 5));\n+        assert!(!b.insert(0, 5).is_none());\n         assert!(a != b);\n-        assert!(b.insert(5, 19));\n+        assert!(b.insert(5, 19).is_none());\n         assert!(a == b);\n     }\n \n@@ -1671,15 +1674,15 @@ mod test_treemap {\n         let mut b = TreeMap::new();\n \n         assert!(!(a < b) && !(b < a));\n-        assert!(b.insert(0i, 5i));\n+        assert!(b.insert(0i, 5i).is_none());\n         assert!(a < b);\n-        assert!(a.insert(0, 7));\n+        assert!(a.insert(0, 7).is_none());\n         assert!(!(a < b) && b < a);\n-        assert!(b.insert(-2, 0));\n+        assert!(b.insert(-2, 0).is_none());\n         assert!(b < a);\n-        assert!(a.insert(-5, 2));\n+        assert!(a.insert(-5, 2).is_none());\n         assert!(a < b);\n-        assert!(a.insert(6, 2));\n+        assert!(a.insert(6, 2).is_none());\n         assert!(a < b && !(b < a));\n     }\n \n@@ -1689,10 +1692,10 @@ mod test_treemap {\n         let mut b = TreeMap::new();\n \n         assert!(a <= b && a >= b);\n-        assert!(a.insert(1i, 1i));\n+        assert!(a.insert(1i, 1i).is_none());\n         assert!(a > b && a >= b);\n         assert!(b < a && b <= a);\n-        assert!(b.insert(2, 2));\n+        assert!(b.insert(2, 2).is_none());\n         assert!(b > a && b >= a);\n         assert!(a < b && a <= b);\n     }\n@@ -1720,11 +1723,11 @@ mod test_treemap {\n         let (x4, y4) = (29, 5);\n         let (x5, y5) = (103, 3);\n \n-        assert!(m.insert(x1, y1));\n-        assert!(m.insert(x2, y2));\n-        assert!(m.insert(x3, y3));\n-        assert!(m.insert(x4, y4));\n-        assert!(m.insert(x5, y5));\n+        assert!(m.insert(x1, y1).is_none());\n+        assert!(m.insert(x2, y2).is_none());\n+        assert!(m.insert(x3, y3).is_none());\n+        assert!(m.insert(x4, y4).is_none());\n+        assert!(m.insert(x5, y5).is_none());\n \n         let m = m;\n         let mut a = m.iter();\n@@ -1765,7 +1768,7 @@ mod test_treemap {\n         let map: TreeMap<int, int> = xs.iter().map(|&x| x).collect();\n \n         for &(k, v) in xs.iter() {\n-            assert_eq!(map.find(&k), Some(&v));\n+            assert_eq!(map.get(&k), Some(&v));\n         }\n     }\n \n@@ -1795,17 +1798,17 @@ mod test_treemap {\n     #[test]\n     fn test_swap() {\n         let mut m = TreeMap::new();\n-        assert_eq!(m.swap(1u, 2i), None);\n-        assert_eq!(m.swap(1u, 3i), Some(2));\n-        assert_eq!(m.swap(1u, 4i), Some(3));\n+        assert_eq!(m.insert(1u, 2i), None);\n+        assert_eq!(m.insert(1u, 3i), Some(2));\n+        assert_eq!(m.insert(1u, 4i), Some(3));\n     }\n \n     #[test]\n     fn test_pop() {\n         let mut m = TreeMap::new();\n         m.insert(1u, 2i);\n-        assert_eq!(m.pop(&1), Some(2));\n-        assert_eq!(m.pop(&1), None);\n+        assert_eq!(m.remove(&1), Some(2));\n+        assert_eq!(m.remove(&1), None);\n     }\n }\n \n@@ -1857,15 +1860,15 @@ mod bench {\n         let mut m : TreeMap<uint,uint> = TreeMap::new();\n         find_rand_n(100, &mut m, b,\n                     |m, i| { m.insert(i, 1); },\n-                    |m, i| { m.find(&i); });\n+                    |m, i| { m.get(&i); });\n     }\n \n     #[bench]\n     pub fn find_rand_10_000(b: &mut Bencher) {\n         let mut m : TreeMap<uint,uint> = TreeMap::new();\n         find_rand_n(10_000, &mut m, b,\n                     |m, i| { m.insert(i, 1); },\n-                    |m, i| { m.find(&i); });\n+                    |m, i| { m.get(&i); });\n     }\n \n     // Find seq\n@@ -1874,23 +1877,23 @@ mod bench {\n         let mut m : TreeMap<uint,uint> = TreeMap::new();\n         find_seq_n(100, &mut m, b,\n                    |m, i| { m.insert(i, 1); },\n-                   |m, i| { m.find(&i); });\n+                   |m, i| { m.get(&i); });\n     }\n \n     #[bench]\n     pub fn find_seq_10_000(b: &mut Bencher) {\n         let mut m : TreeMap<uint,uint> = TreeMap::new();\n         find_seq_n(10_000, &mut m, b,\n                    |m, i| { m.insert(i, 1); },\n-                   |m, i| { m.find(&i); });\n+                   |m, i| { m.get(&i); });\n     }\n \n     fn bench_iter(b: &mut Bencher, size: uint) {\n         let mut map = TreeMap::<uint, uint>::new();\n         let mut rng = weak_rng();\n \n         for _ in range(0, size) {\n-            map.swap(rng.gen(), rng.gen());\n+            map.insert(rng.gen(), rng.gen());\n         }\n \n         b.iter(|| {"}, {"sha": "22307a5d376b928e8bf040e7b4c89d6e58761677", "filename": "src/libcollections/tree/set.rs", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibcollections%2Ftree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibcollections%2Ftree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftree%2Fset.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -19,6 +19,10 @@ use std::hash::{Writer, Hash};\n \n use tree_map::{TreeMap, Entries, RevEntries, MoveEntries};\n \n+// FIXME(conventions): implement bounded iterators\n+// FIXME(conventions): implement BitOr, BitAnd, BitXor, and Sub\n+// FIXME(conventions): replace rev_iter(_mut) by making iter(_mut) DoubleEnded\n+\n /// An implementation of the `Set` trait on top of the `TreeMap` container. The\n /// only requirement is that the type of the elements contained ascribes to the\n /// `Ord` trait.\n@@ -145,6 +149,7 @@ impl<T: Ord> TreeSet<T> {\n     /// let mut set: TreeSet<int> = TreeSet::new();\n     /// ```\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn new() -> TreeSet<T> { TreeSet{map: TreeMap::new()} }\n \n     /// Gets a lazy iterator over the values in the set, in ascending order.\n@@ -161,6 +166,7 @@ impl<T: Ord> TreeSet<T> {\n     /// }\n     /// ```\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn iter<'a>(&'a self) -> SetItems<'a, T> {\n         SetItems{iter: self.map.iter()}\n     }\n@@ -197,6 +203,7 @@ impl<T: Ord> TreeSet<T> {\n     /// assert_eq!(v, vec![1, 2, 3, 4, 5]);\n     /// ```\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn into_iter(self) -> MoveSetItems<T> {\n         self.map.into_iter().map(|(value, _)| value)\n     }\n@@ -261,6 +268,7 @@ impl<T: Ord> TreeSet<T> {\n     /// let diff: TreeSet<int> = b.difference(&a).map(|&x| x).collect();\n     /// assert_eq!(diff, [4, 5].iter().map(|&x| x).collect());\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn difference<'a>(&'a self, other: &'a TreeSet<T>) -> DifferenceItems<'a, T> {\n         DifferenceItems{a: self.iter().peekable(), b: other.iter().peekable()}\n     }\n@@ -286,6 +294,7 @@ impl<T: Ord> TreeSet<T> {\n     /// assert_eq!(diff1, diff2);\n     /// assert_eq!(diff1, [1, 2, 4, 5].iter().map(|&x| x).collect());\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn symmetric_difference<'a>(&'a self, other: &'a TreeSet<T>)\n         -> SymDifferenceItems<'a, T> {\n         SymDifferenceItems{a: self.iter().peekable(), b: other.iter().peekable()}\n@@ -309,6 +318,7 @@ impl<T: Ord> TreeSet<T> {\n     /// let diff: TreeSet<int> = a.intersection(&b).map(|&x| x).collect();\n     /// assert_eq!(diff, [2, 3].iter().map(|&x| x).collect());\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn intersection<'a>(&'a self, other: &'a TreeSet<T>)\n         -> IntersectionItems<'a, T> {\n         IntersectionItems{a: self.iter().peekable(), b: other.iter().peekable()}\n@@ -332,6 +342,7 @@ impl<T: Ord> TreeSet<T> {\n     /// let diff: TreeSet<int> = a.union(&b).map(|&x| x).collect();\n     /// assert_eq!(diff, [1, 2, 3, 4, 5].iter().map(|&x| x).collect());\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn union<'a>(&'a self, other: &'a TreeSet<T>) -> UnionItems<'a, T> {\n         UnionItems{a: self.iter().peekable(), b: other.iter().peekable()}\n     }\n@@ -349,6 +360,7 @@ impl<T: Ord> TreeSet<T> {\n     /// assert_eq!(v.len(), 1);\n     /// ```\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn len(&self) -> uint { self.map.len() }\n \n     /// Returns true if the set contains no elements\n@@ -363,6 +375,7 @@ impl<T: Ord> TreeSet<T> {\n     /// v.insert(1i);\n     /// assert!(!v.is_empty());\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn is_empty(&self) -> bool { self.len() == 0 }\n \n     /// Clears the set, removing all values.\n@@ -378,6 +391,7 @@ impl<T: Ord> TreeSet<T> {\n     /// assert!(v.is_empty());\n     /// ```\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn clear(&mut self) { self.map.clear() }\n \n     /// Returns `true` if the set contains a value.\n@@ -392,6 +406,7 @@ impl<T: Ord> TreeSet<T> {\n     /// assert_eq!(set.contains(&4), false);\n     /// ```\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn contains(&self, value: &T) -> bool {\n         self.map.contains_key(value)\n     }\n@@ -413,6 +428,7 @@ impl<T: Ord> TreeSet<T> {\n     /// b.insert(1);\n     /// assert_eq!(a.is_disjoint(&b), false);\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn is_disjoint(&self, other: &TreeSet<T>) -> bool {\n         self.intersection(other).next().is_none()\n     }\n@@ -433,6 +449,7 @@ impl<T: Ord> TreeSet<T> {\n     /// set.insert(4);\n     /// assert_eq!(set.is_subset(&sup), false);\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn is_subset(&self, other: &TreeSet<T>) -> bool {\n         let mut x = self.iter();\n         let mut y = other.iter();\n@@ -476,6 +493,7 @@ impl<T: Ord> TreeSet<T> {\n     /// set.insert(2);\n     /// assert_eq!(set.is_superset(&sub), true);\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn is_superset(&self, other: &TreeSet<T>) -> bool {\n         other.is_subset(self)\n     }\n@@ -495,7 +513,8 @@ impl<T: Ord> TreeSet<T> {\n     /// assert_eq!(set.len(), 1);\n     /// ```\n     #[inline]\n-    pub fn insert(&mut self, value: T) -> bool { self.map.insert(value, ()) }\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn insert(&mut self, value: T) -> bool { self.map.insert(value, ()).is_none() }\n \n     /// Removes a value from the set. Returns `true` if the value was\n     /// present in the set.\n@@ -512,7 +531,8 @@ impl<T: Ord> TreeSet<T> {\n     /// assert_eq!(set.remove(&2), false);\n     /// ```\n     #[inline]\n-    pub fn remove(&mut self, value: &T) -> bool { self.map.remove(value) }\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn remove(&mut self, value: &T) -> bool { self.map.remove(value).is_some() }\n }\n \n /// A lazy forward iterator over a set."}, {"sha": "d604e176a672de74a1857ab5cddc28c21d0085ab", "filename": "src/libcollections/trie/map.rs", "status": "modified", "additions": 106, "deletions": 102, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibcollections%2Ftrie%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibcollections%2Ftrie%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftrie%2Fmap.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -32,6 +32,10 @@ use std::hash::{Writer, Hash};\n use slice::{Items, MutItems};\n use slice;\n \n+// FIXME(conventions): implement bounded iterators\n+// FIXME(conventions): implement into_iter\n+// FIXME(conventions): replace each_reverse by making iter DoubleEnded\n+\n // FIXME: #5244: need to manually update the TrieNode constructor\n const SHIFT: uint = 4;\n const SIZE: uint = 1 << SHIFT;\n@@ -59,14 +63,14 @@ enum Child<T> {\n /// map.insert(1, \"Martin\");\n ///\n /// assert_eq!(map.len(), 3);\n-/// assert_eq!(map.find(&1), Some(&\"Martin\"));\n+/// assert_eq!(map.get(&1), Some(&\"Martin\"));\n ///\n /// if !map.contains_key(&90) {\n ///     println!(\"Nobody is keyed 90\");\n /// }\n ///\n /// // Update a key\n-/// match map.find_mut(&1) {\n+/// match map.get_mut(&1) {\n ///     Some(value) => *value = \"Olga\",\n ///     None => (),\n /// }\n@@ -140,6 +144,7 @@ impl<T> TrieMap<T> {\n     /// let mut map: TrieMap<&str> = TrieMap::new();\n     /// ```\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn new() -> TrieMap<T> {\n         TrieMap{root: TrieNode::new(), length: 0}\n     }\n@@ -169,12 +174,14 @@ impl<T> TrieMap<T> {\n \n     /// Gets an iterator visiting all keys in ascending order by the keys.\n     /// The iterator's element type is `uint`.\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn keys<'r>(&'r self) -> Keys<'r, T> {\n         self.iter().map(|(k, _v)| k)\n     }\n \n     /// Gets an iterator visiting all values in ascending order by the keys.\n     /// The iterator's element type is `&'r T`.\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn values<'r>(&'r self) -> Values<'r, T> {\n         self.iter().map(|(_k, v)| v)\n     }\n@@ -191,6 +198,7 @@ impl<T> TrieMap<T> {\n     ///     println!(\"{}: {}\", key, value);\n     /// }\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn iter<'a>(&'a self) -> Entries<'a, T> {\n         let mut iter = unsafe {Entries::new()};\n         iter.stack[0] = self.root.children.iter();\n@@ -214,10 +222,11 @@ impl<T> TrieMap<T> {\n     ///     *value = -(key as int);\n     /// }\n     ///\n-    /// assert_eq!(map.find(&1), Some(&-1));\n-    /// assert_eq!(map.find(&2), Some(&-2));\n-    /// assert_eq!(map.find(&3), Some(&-3));\n+    /// assert_eq!(map.get(&1), Some(&-1));\n+    /// assert_eq!(map.get(&2), Some(&-2));\n+    /// assert_eq!(map.get(&3), Some(&-3));\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn iter_mut<'a>(&'a mut self) -> MutEntries<'a, T> {\n         let mut iter = unsafe {MutEntries::new()};\n         iter.stack[0] = self.root.children.iter_mut();\n@@ -241,6 +250,7 @@ impl<T> TrieMap<T> {\n     /// assert_eq!(a.len(), 1);\n     /// ```\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn len(&self) -> uint { self.length }\n \n     /// Return true if the map contains no elements.\n@@ -256,6 +266,7 @@ impl<T> TrieMap<T> {\n     /// assert!(!a.is_empty());\n     /// ```\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn is_empty(&self) -> bool { self.len() == 0 }\n \n     /// Clears the map, removing all values.\n@@ -271,11 +282,18 @@ impl<T> TrieMap<T> {\n     /// assert!(a.is_empty());\n     /// ```\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn clear(&mut self) {\n         self.root = TrieNode::new();\n         self.length = 0;\n     }\n \n+    /// Deprecated: renamed to `get`.\n+    #[deprecated = \"renamed to `get`\"]\n+    pub fn find(&self, key: &uint) -> Option<&T> {\n+        self.get(key)\n+    }\n+\n     /// Returns a reference to the value corresponding to the key.\n     ///\n     /// # Example\n@@ -285,12 +303,13 @@ impl<T> TrieMap<T> {\n     ///\n     /// let mut map = TrieMap::new();\n     /// map.insert(1, \"a\");\n-    /// assert_eq!(map.find(&1), Some(&\"a\"));\n-    /// assert_eq!(map.find(&2), None);\n+    /// assert_eq!(map.get(&1), Some(&\"a\"));\n+    /// assert_eq!(map.get(&2), None);\n     /// ```\n     #[inline]\n-    pub fn find<'a>(&'a self, key: &uint) -> Option<&'a T> {\n-        let mut node: &'a TrieNode<T> = &self.root;\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn get(&self, key: &uint) -> Option<&T> {\n+        let mut node = &self.root;\n         let mut idx = 0;\n         loop {\n             match node.children[chunk(*key, idx)] {\n@@ -321,8 +340,15 @@ impl<T> TrieMap<T> {\n     /// assert_eq!(map.contains_key(&2), false);\n     /// ```\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn contains_key(&self, key: &uint) -> bool {\n-        self.find(key).is_some()\n+        self.get(key).is_some()\n+    }\n+\n+    /// Deprecated: renamed to `get_mut`.\n+    #[deprecated = \"renamed to `get_mut`\"]\n+    pub fn find_mut(&mut self, key: &uint) -> Option<&mut T> {\n+        self.get_mut(key)\n     }\n \n     /// Returns a mutable reference to the value corresponding to the key.\n@@ -334,52 +360,22 @@ impl<T> TrieMap<T> {\n     ///\n     /// let mut map = TrieMap::new();\n     /// map.insert(1, \"a\");\n-    /// match map.find_mut(&1) {\n+    /// match map.get_mut(&1) {\n     ///     Some(x) => *x = \"b\",\n     ///     None => (),\n     /// }\n     /// assert_eq!(map[1], \"b\");\n     /// ```\n     #[inline]\n-    pub fn find_mut<'a>(&'a mut self, key: &uint) -> Option<&'a mut T> {\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn get_mut<'a>(&'a mut self, key: &uint) -> Option<&'a mut T> {\n         find_mut(&mut self.root.children[chunk(*key, 0)], *key, 1)\n     }\n \n-    /// Inserts a key-value pair into the map. An existing value for a\n-    /// key is replaced by the new value. Returns `true` if the key did\n-    /// not already exist in the map.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::TrieMap;\n-    ///\n-    /// let mut map = TrieMap::new();\n-    /// assert_eq!(map.insert(2, \"value\"), true);\n-    /// assert_eq!(map.insert(2, \"value2\"), false);\n-    /// assert_eq!(map[2], \"value2\");\n-    /// ```\n-    #[inline]\n-    pub fn insert(&mut self, key: uint, value: T) -> bool {\n-        self.swap(key, value).is_none()\n-    }\n-\n-    /// Removes a key-value pair from the map. Returns `true` if the key\n-    /// was present in the map.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::TrieMap;\n-    ///\n-    /// let mut map = TrieMap::new();\n-    /// assert_eq!(map.remove(&1), false);\n-    /// map.insert(1, \"a\");\n-    /// assert_eq!(map.remove(&1), true);\n-    /// ```\n-    #[inline]\n-    pub fn remove(&mut self, key: &uint) -> bool {\n-        self.pop(key).is_some()\n+    /// Deprecated: Renamed to `insert`.\n+    #[deprecated = \"Renamed to `insert`\"]\n+    pub fn swap(&mut self, key: uint, value: T) -> Option<T> {\n+        self.insert(key, value)\n     }\n \n     /// Inserts a key-value pair from the map. If the key already had a value\n@@ -391,21 +387,28 @@ impl<T> TrieMap<T> {\n     /// use std::collections::TrieMap;\n     ///\n     /// let mut map = TrieMap::new();\n-    /// assert_eq!(map.swap(37, \"a\"), None);\n+    /// assert_eq!(map.insert(37, \"a\"), None);\n     /// assert_eq!(map.is_empty(), false);\n     ///\n     /// map.insert(37, \"b\");\n-    /// assert_eq!(map.swap(37, \"c\"), Some(\"b\"));\n+    /// assert_eq!(map.insert(37, \"c\"), Some(\"b\"));\n     /// assert_eq!(map[37], \"c\");\n     /// ```\n-    pub fn swap(&mut self, key: uint, value: T) -> Option<T> {\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn insert(&mut self, key: uint, value: T) -> Option<T> {\n         let ret = insert(&mut self.root.count,\n                          &mut self.root.children[chunk(key, 0)],\n                          key, value, 1);\n         if ret.is_none() { self.length += 1 }\n         ret\n     }\n \n+    /// Deprecated: Renamed to `remove`.\n+    #[deprecated = \"Renamed to `remove`\"]\n+    pub fn pop(&mut self, key: &uint) -> Option<T> {\n+        self.remove(key)\n+    }\n+\n     /// Removes a key from the map, returning the value at the key if the key\n     /// was previously in the map.\n     ///\n@@ -416,10 +419,11 @@ impl<T> TrieMap<T> {\n     ///\n     /// let mut map = TrieMap::new();\n     /// map.insert(1, \"a\");\n-    /// assert_eq!(map.pop(&1), Some(\"a\"));\n-    /// assert_eq!(map.pop(&1), None);\n+    /// assert_eq!(map.remove(&1), Some(\"a\"));\n+    /// assert_eq!(map.remove(&1), None);\n     /// ```\n-    pub fn pop(&mut self, key: &uint) -> Option<T> {\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn remove(&mut self, key: &uint) -> Option<T> {\n         let ret = remove(&mut self.root.count,\n                          &mut self.root.children[chunk(*key, 0)],\n                          *key, 1);\n@@ -582,9 +586,9 @@ impl<T> TrieMap<T> {\n     ///     *value = \"changed\";\n     /// }\n     ///\n-    /// assert_eq!(map.find(&2), Some(&\"a\"));\n-    /// assert_eq!(map.find(&4), Some(&\"changed\"));\n-    /// assert_eq!(map.find(&6), Some(&\"changed\"));\n+    /// assert_eq!(map.get(&2), Some(&\"a\"));\n+    /// assert_eq!(map.get(&4), Some(&\"changed\"));\n+    /// assert_eq!(map.get(&6), Some(&\"changed\"));\n     /// ```\n     pub fn lower_bound_mut<'a>(&'a mut self, key: uint) -> MutEntries<'a, T> {\n         self.bound_mut(key, false)\n@@ -607,9 +611,9 @@ impl<T> TrieMap<T> {\n     ///     *value = \"changed\";\n     /// }\n     ///\n-    /// assert_eq!(map.find(&2), Some(&\"a\"));\n-    /// assert_eq!(map.find(&4), Some(&\"b\"));\n-    /// assert_eq!(map.find(&6), Some(&\"changed\"));\n+    /// assert_eq!(map.get(&2), Some(&\"a\"));\n+    /// assert_eq!(map.get(&4), Some(&\"b\"));\n+    /// assert_eq!(map.get(&6), Some(&\"changed\"));\n     /// ```\n     pub fn upper_bound_mut<'a>(&'a mut self, key: uint) -> MutEntries<'a, T> {\n         self.bound_mut(key, true)\n@@ -643,14 +647,14 @@ impl<S: Writer, T: Hash<S>> Hash<S> for TrieMap<T> {\n impl<T> Index<uint, T> for TrieMap<T> {\n     #[inline]\n     fn index<'a>(&'a self, i: &uint) -> &'a T {\n-        self.find(i).expect(\"key not present\")\n+        self.get(i).expect(\"key not present\")\n     }\n }\n \n impl<T> IndexMut<uint, T> for TrieMap<T> {\n     #[inline]\n     fn index_mut<'a>(&'a mut self, i: &uint) -> &'a mut T {\n-        self.find_mut(i).expect(\"key not present\")\n+        self.get_mut(i).expect(\"key not present\")\n     }\n }\n \n@@ -957,24 +961,24 @@ mod test {\n     #[test]\n     fn test_find_mut() {\n         let mut m = TrieMap::new();\n-        assert!(m.insert(1u, 12i));\n-        assert!(m.insert(2u, 8i));\n-        assert!(m.insert(5u, 14i));\n+        assert!(m.insert(1u, 12i).is_none());\n+        assert!(m.insert(2u, 8i).is_none());\n+        assert!(m.insert(5u, 14i).is_none());\n         let new = 100;\n-        match m.find_mut(&5) {\n+        match m.get_mut(&5) {\n             None => panic!(), Some(x) => *x = new\n         }\n-        assert_eq!(m.find(&5), Some(&new));\n+        assert_eq!(m.get(&5), Some(&new));\n     }\n \n     #[test]\n     fn test_find_mut_missing() {\n         let mut m = TrieMap::new();\n-        assert!(m.find_mut(&0).is_none());\n-        assert!(m.insert(1u, 12i));\n-        assert!(m.find_mut(&0).is_none());\n-        assert!(m.insert(2, 8));\n-        assert!(m.find_mut(&0).is_none());\n+        assert!(m.get_mut(&0).is_none());\n+        assert!(m.insert(1u, 12i).is_none());\n+        assert!(m.get_mut(&0).is_none());\n+        assert!(m.insert(2, 8).is_none());\n+        assert!(m.get_mut(&0).is_none());\n     }\n \n     #[test]\n@@ -983,32 +987,32 @@ mod test {\n         let n = 300u;\n \n         for x in range_step(1u, n, 2) {\n-            assert!(trie.insert(x, x + 1));\n+            assert!(trie.insert(x, x + 1).is_none());\n             assert!(trie.contains_key(&x));\n             check_integrity(&trie.root);\n         }\n \n         for x in range_step(0u, n, 2) {\n             assert!(!trie.contains_key(&x));\n-            assert!(trie.insert(x, x + 1));\n+            assert!(trie.insert(x, x + 1).is_none());\n             check_integrity(&trie.root);\n         }\n \n         for x in range(0u, n) {\n             assert!(trie.contains_key(&x));\n-            assert!(!trie.insert(x, x + 1));\n+            assert!(!trie.insert(x, x + 1).is_none());\n             check_integrity(&trie.root);\n         }\n \n         for x in range_step(1u, n, 2) {\n-            assert!(trie.remove(&x));\n+            assert!(trie.remove(&x).is_some());\n             assert!(!trie.contains_key(&x));\n             check_integrity(&trie.root);\n         }\n \n         for x in range_step(0u, n, 2) {\n             assert!(trie.contains_key(&x));\n-            assert!(!trie.insert(x, x + 1));\n+            assert!(!trie.insert(x, x + 1).is_none());\n             check_integrity(&trie.root);\n         }\n     }\n@@ -1017,11 +1021,11 @@ mod test {\n     fn test_each_reverse() {\n         let mut m = TrieMap::new();\n \n-        assert!(m.insert(3, 6));\n-        assert!(m.insert(0, 0));\n-        assert!(m.insert(4, 8));\n-        assert!(m.insert(2, 4));\n-        assert!(m.insert(1, 2));\n+        assert!(m.insert(3, 6).is_none());\n+        assert!(m.insert(0, 0).is_none());\n+        assert!(m.insert(4, 8).is_none());\n+        assert!(m.insert(2, 4).is_none());\n+        assert!(m.insert(1, 2).is_none());\n \n         let mut n = 4;\n         m.each_reverse(|k, v| {\n@@ -1054,19 +1058,19 @@ mod test {\n     }\n \n     #[test]\n-    fn test_swap() {\n+    fn test_insert() {\n         let mut m = TrieMap::new();\n-        assert_eq!(m.swap(1u, 2i), None);\n-        assert_eq!(m.swap(1u, 3i), Some(2));\n-        assert_eq!(m.swap(1u, 4i), Some(3));\n+        assert_eq!(m.insert(1u, 2i), None);\n+        assert_eq!(m.insert(1u, 3i), Some(2));\n+        assert_eq!(m.insert(1u, 4i), Some(3));\n     }\n \n     #[test]\n-    fn test_pop() {\n+    fn test_remove() {\n         let mut m = TrieMap::new();\n         m.insert(1u, 2i);\n-        assert_eq!(m.pop(&1), Some(2));\n-        assert_eq!(m.pop(&1), None);\n+        assert_eq!(m.remove(&1), Some(2));\n+        assert_eq!(m.remove(&1), None);\n     }\n \n     #[test]\n@@ -1076,7 +1080,7 @@ mod test {\n         let map: TrieMap<int> = xs.iter().map(|&x| x).collect();\n \n         for &(k, v) in xs.iter() {\n-            assert_eq!(map.find(&k), Some(&v));\n+            assert_eq!(map.get(&k), Some(&v));\n         }\n     }\n \n@@ -1243,15 +1247,15 @@ mod test {\n         let mut b = TrieMap::new();\n \n         assert!(a == b);\n-        assert!(a.insert(0, 5i));\n+        assert!(a.insert(0, 5i).is_none());\n         assert!(a != b);\n-        assert!(b.insert(0, 4i));\n+        assert!(b.insert(0, 4i).is_none());\n         assert!(a != b);\n-        assert!(a.insert(5, 19));\n+        assert!(a.insert(5, 19).is_none());\n         assert!(a != b);\n-        assert!(!b.insert(0, 5));\n+        assert!(!b.insert(0, 5).is_none());\n         assert!(a != b);\n-        assert!(b.insert(5, 19));\n+        assert!(b.insert(5, 19).is_none());\n         assert!(a == b);\n     }\n \n@@ -1261,15 +1265,15 @@ mod test {\n         let mut b = TrieMap::new();\n \n         assert!(!(a < b) && !(b < a));\n-        assert!(b.insert(2u, 5i));\n+        assert!(b.insert(2u, 5i).is_none());\n         assert!(a < b);\n-        assert!(a.insert(2, 7));\n+        assert!(a.insert(2, 7).is_none());\n         assert!(!(a < b) && b < a);\n-        assert!(b.insert(1, 0));\n+        assert!(b.insert(1, 0).is_none());\n         assert!(b < a);\n-        assert!(a.insert(0, 6));\n+        assert!(a.insert(0, 6).is_none());\n         assert!(a < b);\n-        assert!(a.insert(6, 2));\n+        assert!(a.insert(6, 2).is_none());\n         assert!(a < b && !(b < a));\n     }\n \n@@ -1279,10 +1283,10 @@ mod test {\n         let mut b = TrieMap::new();\n \n         assert!(a <= b && a >= b);\n-        assert!(a.insert(1u, 1i));\n+        assert!(a.insert(1u, 1i).is_none());\n         assert!(a > b && a >= b);\n         assert!(b < a && b <= a);\n-        assert!(b.insert(2, 2));\n+        assert!(b.insert(2, 2).is_none());\n         assert!(b > a && b >= a);\n         assert!(a < b && a <= b);\n     }\n@@ -1355,7 +1359,7 @@ mod bench {\n         let mut rng = weak_rng();\n \n         for _ in range(0, size) {\n-            map.swap(rng.gen(), rng.gen());\n+            map.insert(rng.gen(), rng.gen());\n         }\n \n         b.iter(|| {"}, {"sha": "dd5a81fe96ee9f8fd9b0fa8b5a242f925c5a16e5", "filename": "src/libcollections/trie/set.rs", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibcollections%2Ftrie%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibcollections%2Ftrie%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftrie%2Fset.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -8,6 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// FIXME(conventions): implement bounded iterators\n+// FIXME(conventions): implement union family of fns\n+// FIXME(conventions): implement BitOr, BitAnd, BitXor, and Sub\n+// FIXME(conventions): replace each_reverse by making iter DoubleEnded\n+// FIXME(conventions): implement iter_mut and into_iter\n+\n use core::prelude::*;\n \n use core::default::Default;\n@@ -79,6 +85,7 @@ impl TrieSet {\n     /// let mut set = TrieSet::new();\n     /// ```\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn new() -> TrieSet {\n         TrieSet{map: TrieMap::new()}\n     }\n@@ -126,6 +133,7 @@ impl TrieSet {\n     /// }\n     /// ```\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn iter<'a>(&'a self) -> SetItems<'a> {\n         SetItems{iter: self.map.iter()}\n     }\n@@ -177,6 +185,7 @@ impl TrieSet {\n     /// assert_eq!(v.len(), 1);\n     /// ```\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn len(&self) -> uint { self.map.len() }\n \n     /// Returns true if the set contains no elements\n@@ -191,6 +200,7 @@ impl TrieSet {\n     /// v.insert(1);\n     /// assert!(!v.is_empty());\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn is_empty(&self) -> bool { self.len() == 0 }\n \n     /// Clears the set, removing all values.\n@@ -206,6 +216,7 @@ impl TrieSet {\n     /// assert!(v.is_empty());\n     /// ```\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn clear(&mut self) { self.map.clear() }\n \n     /// Returns `true` if the set contains a value.\n@@ -220,6 +231,7 @@ impl TrieSet {\n     /// assert_eq!(set.contains(&4), false);\n     /// ```\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn contains(&self, value: &uint) -> bool {\n         self.map.contains_key(value)\n     }\n@@ -242,6 +254,7 @@ impl TrieSet {\n     /// assert_eq!(a.is_disjoint(&b), false);\n     /// ```\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn is_disjoint(&self, other: &TrieSet) -> bool {\n         self.iter().all(|v| !other.contains(&v))\n     }\n@@ -263,6 +276,7 @@ impl TrieSet {\n     /// assert_eq!(set.is_subset(&sup), false);\n     /// ```\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn is_subset(&self, other: &TrieSet) -> bool {\n         self.iter().all(|v| other.contains(&v))\n     }\n@@ -287,6 +301,7 @@ impl TrieSet {\n     /// assert_eq!(set.is_superset(&sub), true);\n     /// ```\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn is_superset(&self, other: &TrieSet) -> bool {\n         other.is_subset(self)\n     }\n@@ -306,8 +321,9 @@ impl TrieSet {\n     /// assert_eq!(set.len(), 1);\n     /// ```\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn insert(&mut self, value: uint) -> bool {\n-        self.map.insert(value, ())\n+        self.map.insert(value, ()).is_none()\n     }\n \n     /// Removes a value from the set. Returns `true` if the value was\n@@ -325,8 +341,9 @@ impl TrieSet {\n     /// assert_eq!(set.remove(&2), false);\n     /// ```\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn remove(&mut self, value: &uint) -> bool {\n-        self.map.remove(value)\n+        self.map.remove(value).is_some()\n     }\n }\n "}, {"sha": "78ed5e9706947930e5df7b055cc7507ae2497f26", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 74, "deletions": 77, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -312,7 +312,7 @@ impl<T: Clone> Vec<T> {\n     #[inline]\n     #[experimental]\n     pub fn push_all(&mut self, other: &[T]) {\n-        self.reserve_additional(other.len());\n+        self.reserve(other.len());\n \n         for i in range(0, other.len()) {\n             let len = self.len();\n@@ -342,7 +342,7 @@ impl<T: Clone> Vec<T> {\n     /// ```\n     #[stable]\n     pub fn grow(&mut self, n: uint, value: T) {\n-        self.reserve_additional(n);\n+        self.reserve(n);\n         let mut i: uint = 0u;\n \n         while i < n {\n@@ -489,7 +489,7 @@ impl<T> Extendable<T> for Vec<T> {\n     #[inline]\n     fn extend<I: Iterator<T>>(&mut self, mut iterator: I) {\n         let (lower, _) = iterator.size_hint();\n-        self.reserve_additional(lower);\n+        self.reserve(lower);\n         for element in iterator {\n             self.push(element)\n         }\n@@ -578,74 +578,70 @@ impl<T> Vec<T> {\n         self.cap\n     }\n \n-     /// Reserves capacity for at least `n` additional elements in the given\n-     /// vector.\n-     ///\n-     /// # Failure\n-     ///\n-     /// Fails if the new capacity overflows `uint`.\n-     ///\n-     /// # Example\n-     ///\n-     /// ```\n-     /// let mut vec: Vec<int> = vec![1i];\n-     /// vec.reserve_additional(10);\n-     /// assert!(vec.capacity() >= 11);\n-     /// ```\n+    /// Deprecated: Renamed to `reserve`.\n+    #[deprecated = \"Renamed to `reserve`\"]\n     pub fn reserve_additional(&mut self, extra: uint) {\n-        if self.cap - self.len < extra {\n-            match self.len.checked_add(&extra) {\n-                None => panic!(\"Vec::reserve_additional: `uint` overflow\"),\n-                Some(new_cap) => self.reserve(new_cap)\n-            }\n-        }\n+        self.reserve(extra)\n     }\n \n-    /// Reserves capacity for at least `n` elements in the given vector.\n+    /// Reserves capacity for at least `additional` more elements to be inserted in the given\n+    /// `Vec`. The collection may reserve more space to avoid frequent reallocations.\n     ///\n-    /// This function will over-allocate in order to amortize the allocation\n-    /// costs in scenarios where the caller may need to repeatedly reserve\n-    /// additional space.\n+    /// # Panics\n     ///\n-    /// If the capacity for `self` is already equal to or greater than the\n-    /// requested capacity, then no action is taken.\n+    /// Panics if the new capacity overflows `uint`.\n     ///\n     /// # Example\n     ///\n     /// ```\n-    /// let mut vec = vec![1i, 2, 3];\n+    /// let mut vec: Vec<int> = vec![1];\n     /// vec.reserve(10);\n-    /// assert!(vec.capacity() >= 10);\n+    /// assert!(vec.capacity() >= 11);\n     /// ```\n-    pub fn reserve(&mut self, capacity: uint) {\n-        if capacity > self.cap {\n-            self.reserve_exact(num::next_power_of_two(capacity))\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn reserve(&mut self, additional: uint) {\n+        if self.cap - self.len < additional {\n+            match self.len.checked_add(&additional) {\n+                None => panic!(\"Vec::reserve: `uint` overflow\"),\n+                // if the checked_add\n+                Some(new_cap) => {\n+                    let amort_cap = num::next_power_of_two(new_cap);\n+                    // next_power_of_two will overflow to exactly 0 for really big capacities\n+                    if amort_cap == 0 {\n+                        self.grow_capacity(new_cap);\n+                    } else {\n+                        self.grow_capacity(amort_cap);\n+                    }\n+                }\n+            }\n         }\n     }\n \n-    /// Reserves capacity for exactly `capacity` elements in the given vector.\n+    /// Reserves the minimum capacity for exactly `additional` more elements to be inserted in the\n+    /// given `Vec`. Does nothing if the capacity is already sufficient.\n     ///\n-    /// If the capacity for `self` is already equal to or greater than the\n-    /// requested capacity, then no action is taken.\n+    /// Note that the allocator may give the collection more space than it requests. Therefore\n+    /// capacity can not be relied upon to be precisely minimal. Prefer `reserve` if future\n+    /// insertions are expected.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the new capacity overflows `uint`.\n     ///\n     /// # Example\n     ///\n     /// ```\n-    /// let mut vec: Vec<int> = Vec::with_capacity(10);\n-    /// vec.reserve_exact(11);\n-    /// assert_eq!(vec.capacity(), 11);\n+    /// let mut vec: Vec<int> = vec![1];\n+    /// vec.reserve_exact(10);\n+    /// assert!(vec.capacity() >= 11);\n     /// ```\n-    pub fn reserve_exact(&mut self, capacity: uint) {\n-        if mem::size_of::<T>() == 0 { return }\n-\n-        if capacity > self.cap {\n-            let size = capacity.checked_mul(&mem::size_of::<T>())\n-                               .expect(\"capacity overflow\");\n-            unsafe {\n-                self.ptr = alloc_or_realloc(self.ptr, self.cap * mem::size_of::<T>(), size);\n-                if self.ptr.is_null() { ::alloc::oom() }\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn reserve_exact(&mut self, additional: uint) {\n+        if self.cap - self.len < additional {\n+            match self.len.checked_add(&additional) {\n+                None => panic!(\"Vec::reserve: `uint` overflow\"),\n+                Some(new_cap) => self.grow_capacity(new_cap)\n             }\n-            self.cap = capacity;\n         }\n     }\n \n@@ -663,6 +659,7 @@ impl<T> Vec<T> {\n     /// assert!(vec.capacity() >= 3);\n     /// ```\n     #[stable]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn shrink_to_fit(&mut self) {\n         if mem::size_of::<T>() == 0 { return }\n \n@@ -713,7 +710,7 @@ impl<T> Vec<T> {\n     /// vec.truncate(2);\n     /// assert_eq!(vec, vec![1, 2]);\n     /// ```\n-    #[unstable = \"waiting on panic semantics\"]\n+    #[unstable = \"matches collection reform specification; waiting on panic semantics\"]\n     pub fn truncate(&mut self, len: uint) {\n         unsafe {\n             // drop any extra elements\n@@ -761,6 +758,7 @@ impl<T> Vec<T> {\n     /// }\n     /// ```\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn into_iter(self) -> MoveItems<T> {\n         unsafe {\n             let ptr = self.ptr;\n@@ -796,26 +794,6 @@ impl<T> Vec<T> {\n         self.len = len;\n     }\n \n-    /// Returns a mutable reference to the value at index `index`.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Fails if `index` is out of bounds\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// # #![allow(deprecated)]\n-    /// let mut vec = vec![1i, 2, 3];\n-    /// *vec.get_mut(1) = 4;\n-    /// assert_eq!(vec, vec![1i, 4, 3]);\n-    /// ```\n-    #[inline]\n-    #[deprecated = \"use `foo[index] = bar` instead\"]\n-    pub fn get_mut<'a>(&'a mut self, index: uint) -> &'a mut T {\n-        &mut self.as_mut_slice()[index]\n-    }\n-\n     /// Removes an element from anywhere in the vector and return it, replacing\n     /// it with the last element. This does not preserve ordering, but is O(1).\n     ///\n@@ -868,7 +846,7 @@ impl<T> Vec<T> {\n         let len = self.len();\n         assert!(index <= len);\n         // space for the new element\n-        self.reserve(len + 1);\n+        self.reserve(1);\n \n         unsafe { // infallible\n             // The spot to put the new value\n@@ -970,7 +948,7 @@ impl<T> Vec<T> {\n     /// ```\n     #[unstable = \"this function may be renamed or change to unboxed closures\"]\n     pub fn grow_fn(&mut self, n: uint, f: |uint| -> T) {\n-        self.reserve_additional(n);\n+        self.reserve(n);\n         for i in range(0u, n) {\n             self.push(f(i));\n         }\n@@ -1076,7 +1054,26 @@ impl<T> Vec<T> {\n     /// v.push(1i);\n     /// assert!(!v.is_empty());\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn is_empty(&self) -> bool { self.len() == 0 }\n+\n+    /// Reserves capacity for exactly `capacity` elements in the given vector.\n+    ///\n+    /// If the capacity for `self` is already equal to or greater than the\n+    /// requested capacity, then no action is taken.\n+    fn grow_capacity(&mut self, capacity: uint) {\n+        if mem::size_of::<T>() == 0 { return }\n+\n+        if capacity > self.cap {\n+            let size = capacity.checked_mul(&mem::size_of::<T>())\n+                               .expect(\"capacity overflow\");\n+            unsafe {\n+                self.ptr = alloc_or_realloc(self.ptr, self.cap * mem::size_of::<T>(), size);\n+                if self.ptr.is_null() { ::alloc::oom() }\n+            }\n+            self.cap = capacity;\n+        }\n+    }\n }\n \n impl<T: PartialEq> Vec<T> {\n@@ -1742,24 +1739,24 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_reserve_additional() {\n+    fn test_reserve() {\n         let mut v = Vec::new();\n         assert_eq!(v.capacity(), 0);\n \n-        v.reserve_additional(2);\n+        v.reserve(2);\n         assert!(v.capacity() >= 2);\n \n         for i in range(0i, 16) {\n             v.push(i);\n         }\n \n         assert!(v.capacity() >= 16);\n-        v.reserve_additional(16);\n+        v.reserve(16);\n         assert!(v.capacity() >= 32);\n \n         v.push(16);\n \n-        v.reserve_additional(16);\n+        v.reserve(16);\n         assert!(v.capacity() >= 33)\n     }\n "}, {"sha": "38a345272b042db8fddebe73668905b2f4b7dbd9", "filename": "src/libcollections/vec_map.rs", "status": "modified", "additions": 131, "deletions": 135, "changes": 266, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibcollections%2Fvec_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibcollections%2Fvec_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_map.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -26,6 +26,8 @@ use vec::Vec;\n use hash;\n use hash::Hash;\n \n+// FIXME(conventions): capacity management???\n+\n /// A map optimized for small integer keys.\n ///\n /// # Example\n@@ -42,14 +44,14 @@ use hash::Hash;\n ///     println!(\"The end is near!\");\n /// }\n ///\n-/// assert_eq!(months.find(&1), Some(&\"Jan\"));\n+/// assert_eq!(months.get(&1), Some(&\"Jan\"));\n ///\n-/// match months.find_mut(&3) {\n+/// match months.get_mut(&3) {\n ///     Some(value) => *value = \"Venus\",\n ///     None => (),\n /// }\n ///\n-/// assert_eq!(months.find(&3), Some(&\"Venus\"));\n+/// assert_eq!(months.get(&3), Some(&\"Venus\"));\n ///\n /// // Print out all months\n /// for (key, value) in months.iter() {\n@@ -77,10 +79,7 @@ impl<V:Clone> Clone for VecMap<V> {\n \n     #[inline]\n     fn clone_from(&mut self, source: &VecMap<V>) {\n-        self.v.reserve(source.v.len());\n-        for (i, w) in self.v.iter_mut().enumerate() {\n-            *w = source.v[i].clone();\n-        }\n+        self.v.clone_from(&source.v);\n     }\n }\n \n@@ -99,6 +98,7 @@ impl<V> VecMap<V> {\n     /// use std::collections::VecMap;\n     /// let mut map: VecMap<&str> = VecMap::new();\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn new() -> VecMap<V> { VecMap{v: vec!()} }\n \n     /// Creates an empty `VecMap` with space for at least `capacity`\n@@ -110,18 +110,21 @@ impl<V> VecMap<V> {\n     /// use std::collections::VecMap;\n     /// let mut map: VecMap<&str> = VecMap::with_capacity(10);\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn with_capacity(capacity: uint) -> VecMap<V> {\n         VecMap { v: Vec::with_capacity(capacity) }\n     }\n \n     /// Returns an iterator visiting all keys in ascending order by the keys.\n     /// The iterator's element type is `uint`.\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn keys<'r>(&'r self) -> Keys<'r, V> {\n         self.iter().map(|(k, _v)| k)\n     }\n \n     /// Returns an iterator visiting all values in ascending order by the keys.\n     /// The iterator's element type is `&'r V`.\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn values<'r>(&'r self) -> Values<'r, V> {\n         self.iter().map(|(_k, v)| v)\n     }\n@@ -144,6 +147,7 @@ impl<V> VecMap<V> {\n     ///     println!(\"{}: {}\", key, value);\n     /// }\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn iter<'r>(&'r self) -> Entries<'r, V> {\n         Entries {\n             front: 0,\n@@ -174,6 +178,7 @@ impl<V> VecMap<V> {\n     ///     assert_eq!(value, &\"x\");\n     /// }\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn iter_mut<'r>(&'r mut self) -> MutEntries<'r, V> {\n         MutEntries {\n             front: 0,\n@@ -201,6 +206,7 @@ impl<V> VecMap<V> {\n     ///\n     /// assert_eq!(vec, vec![(1, \"a\"), (2, \"b\"), (3, \"c\")]);\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn into_iter(&mut self)\n         -> FilterMap<(uint, Option<V>), (uint, V),\n                 Enumerate<vec::MoveItems<Option<V>>>>\n@@ -223,6 +229,7 @@ impl<V> VecMap<V> {\n     /// a.insert(1, \"a\");\n     /// assert_eq!(a.len(), 1);\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn len(&self) -> uint {\n         self.v.iter().filter(|elt| elt.is_some()).count()\n     }\n@@ -239,6 +246,7 @@ impl<V> VecMap<V> {\n     /// a.insert(1, \"a\");\n     /// assert!(!a.is_empty());\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn is_empty(&self) -> bool {\n         self.v.iter().all(|elt| elt.is_none())\n     }\n@@ -255,8 +263,15 @@ impl<V> VecMap<V> {\n     /// a.clear();\n     /// assert!(a.is_empty());\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn clear(&mut self) { self.v.clear() }\n \n+    /// Deprecated: Renamed to `get`.\n+    #[deprecated = \"Renamed to `get`\"]\n+    pub fn find(&self, key: &uint) -> Option<&V> {\n+        self.get(key)\n+    }\n+\n     /// Returns a reference to the value corresponding to the key.\n     ///\n     /// # Example\n@@ -266,10 +281,11 @@ impl<V> VecMap<V> {\n     ///\n     /// let mut map = VecMap::new();\n     /// map.insert(1, \"a\");\n-    /// assert_eq!(map.find(&1), Some(&\"a\"));\n-    /// assert_eq!(map.find(&2), None);\n+    /// assert_eq!(map.get(&1), Some(&\"a\"));\n+    /// assert_eq!(map.get(&2), None);\n     /// ```\n-    pub fn find<'a>(&'a self, key: &uint) -> Option<&'a V> {\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn get(&self, key: &uint) -> Option<&V> {\n         if *key < self.v.len() {\n             match self.v[*key] {\n               Some(ref value) => Some(value),\n@@ -293,8 +309,15 @@ impl<V> VecMap<V> {\n     /// assert_eq!(map.contains_key(&2), false);\n     /// ```\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn contains_key(&self, key: &uint) -> bool {\n-        self.find(key).is_some()\n+        self.get(key).is_some()\n+    }\n+\n+    /// Deprecated: Renamed to `get_mut`.\n+    #[deprecated = \"Renamed to `get_mut`\"]\n+    pub fn find_mut(&mut self, key: &uint) -> Option<&mut V> {\n+        self.get_mut(key)\n     }\n \n     /// Returns a mutable reference to the value corresponding to the key.\n@@ -306,13 +329,14 @@ impl<V> VecMap<V> {\n     ///\n     /// let mut map = VecMap::new();\n     /// map.insert(1, \"a\");\n-    /// match map.find_mut(&1) {\n+    /// match map.get_mut(&1) {\n     ///     Some(x) => *x = \"b\",\n     ///     None => (),\n     /// }\n     /// assert_eq!(map[1], \"b\");\n     /// ```\n-    pub fn find_mut<'a>(&'a mut self, key: &uint) -> Option<&'a mut V> {\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn get_mut(&mut self, key: &uint) -> Option<&mut V> {\n         if *key < self.v.len() {\n             match *(&mut self.v[*key]) {\n               Some(ref mut value) => Some(value),\n@@ -323,45 +347,10 @@ impl<V> VecMap<V> {\n         }\n     }\n \n-    /// Inserts a key-value pair into the map. An existing value for a\n-    /// key is replaced by the new value. Returns `true` if the key did\n-    /// not already exist in the map.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::VecMap;\n-    ///\n-    /// let mut map = VecMap::new();\n-    /// assert_eq!(map.insert(2, \"value\"), true);\n-    /// assert_eq!(map.insert(2, \"value2\"), false);\n-    /// assert_eq!(map[2], \"value2\");\n-    /// ```\n-    pub fn insert(&mut self, key: uint, value: V) -> bool {\n-        let exists = self.contains_key(&key);\n-        let len = self.v.len();\n-        if len <= key {\n-            self.v.grow_fn(key - len + 1, |_| None);\n-        }\n-        self.v[key] = Some(value);\n-        !exists\n-    }\n-\n-    /// Removes a key-value pair from the map. Returns `true` if the key\n-    /// was present in the map.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::VecMap;\n-    ///\n-    /// let mut map = VecMap::new();\n-    /// assert_eq!(map.remove(&1), false);\n-    /// map.insert(1, \"a\");\n-    /// assert_eq!(map.remove(&1), true);\n-    /// ```\n-    pub fn remove(&mut self, key: &uint) -> bool {\n-        self.pop(key).is_some()\n+    /// Deprecated: Renamed to `insert`.\n+    #[deprecated = \"Renamed to `insert`\"]\n+    pub fn swap(&mut self, key: uint, value: V) -> Option<V> {\n+        self.insert(key, value)\n     }\n \n     /// Inserts a key-value pair from the map. If the key already had a value\n@@ -373,20 +362,26 @@ impl<V> VecMap<V> {\n     /// use std::collections::VecMap;\n     ///\n     /// let mut map = VecMap::new();\n-    /// assert_eq!(map.swap(37, \"a\"), None);\n+    /// assert_eq!(map.insert(37, \"a\"), None);\n     /// assert_eq!(map.is_empty(), false);\n     ///\n     /// map.insert(37, \"b\");\n-    /// assert_eq!(map.swap(37, \"c\"), Some(\"b\"));\n+    /// assert_eq!(map.insert(37, \"c\"), Some(\"b\"));\n     /// assert_eq!(map[37], \"c\");\n     /// ```\n-    pub fn swap(&mut self, key: uint, value: V) -> Option<V> {\n-        match self.find_mut(&key) {\n-            Some(loc) => { return Some(replace(loc, value)); }\n-            None => ()\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn insert(&mut self, key: uint, value: V) -> Option<V> {\n+        let len = self.v.len();\n+        if len <= key {\n+            self.v.grow_fn(key - len + 1, |_| None);\n         }\n-        self.insert(key, value);\n-        return None;\n+        replace(&mut self.v[key], Some(value))\n+    }\n+\n+    /// Deprecated: Renamed to `remove`.\n+    #[deprecated = \"Renamed to `remove`\"]\n+    pub fn pop(&mut self, key: &uint) -> Option<V> {\n+        self.remove(key)\n     }\n \n     /// Removes a key from the map, returning the value at the key if the key\n@@ -399,10 +394,11 @@ impl<V> VecMap<V> {\n     ///\n     /// let mut map = VecMap::new();\n     /// map.insert(1, \"a\");\n-    /// assert_eq!(map.pop(&1), Some(\"a\"));\n-    /// assert_eq!(map.pop(&1), None);\n+    /// assert_eq!(map.remove(&1), Some(\"a\"));\n+    /// assert_eq!(map.remove(&1), None);\n     /// ```\n-    pub fn pop(&mut self, key: &uint) -> Option<V> {\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn remove(&mut self, key: &uint) -> Option<V> {\n         if *key >= self.v.len() {\n             return None;\n         }\n@@ -460,11 +456,11 @@ impl<V:Clone> VecMap<V> {\n                            val: V,\n                            ff: |uint, V, V| -> V)\n                            -> bool {\n-        let new_val = match self.find(&key) {\n+        let new_val = match self.get(&key) {\n             None => val,\n             Some(orig) => ff(key, (*orig).clone(), val)\n         };\n-        self.insert(key, new_val)\n+        self.insert(key, new_val).is_none()\n     }\n }\n \n@@ -514,14 +510,14 @@ impl<V> Extendable<(uint, V)> for VecMap<V> {\n impl<V> Index<uint, V> for VecMap<V> {\n     #[inline]\n     fn index<'a>(&'a self, i: &uint) -> &'a V {\n-        self.find(i).expect(\"key not present\")\n+        self.get(i).expect(\"key not present\")\n     }\n }\n \n impl<V> IndexMut<uint, V> for VecMap<V> {\n     #[inline]\n     fn index_mut<'a>(&'a mut self, i: &uint) -> &'a mut V {\n-        self.find_mut(i).expect(\"key not present\")\n+        self.get_mut(i).expect(\"key not present\")\n     }\n }\n \n@@ -615,45 +611,45 @@ mod test_map {\n     use super::VecMap;\n \n     #[test]\n-    fn test_find_mut() {\n+    fn test_get_mut() {\n         let mut m = VecMap::new();\n-        assert!(m.insert(1, 12i));\n-        assert!(m.insert(2, 8));\n-        assert!(m.insert(5, 14));\n+        assert!(m.insert(1, 12i).is_none());\n+        assert!(m.insert(2, 8).is_none());\n+        assert!(m.insert(5, 14).is_none());\n         let new = 100;\n-        match m.find_mut(&5) {\n+        match m.get_mut(&5) {\n             None => panic!(), Some(x) => *x = new\n         }\n-        assert_eq!(m.find(&5), Some(&new));\n+        assert_eq!(m.get(&5), Some(&new));\n     }\n \n     #[test]\n     fn test_len() {\n         let mut map = VecMap::new();\n         assert_eq!(map.len(), 0);\n         assert!(map.is_empty());\n-        assert!(map.insert(5, 20i));\n+        assert!(map.insert(5, 20i).is_none());\n         assert_eq!(map.len(), 1);\n         assert!(!map.is_empty());\n-        assert!(map.insert(11, 12));\n+        assert!(map.insert(11, 12).is_none());\n         assert_eq!(map.len(), 2);\n         assert!(!map.is_empty());\n-        assert!(map.insert(14, 22));\n+        assert!(map.insert(14, 22).is_none());\n         assert_eq!(map.len(), 3);\n         assert!(!map.is_empty());\n     }\n \n     #[test]\n     fn test_clear() {\n         let mut map = VecMap::new();\n-        assert!(map.insert(5, 20i));\n-        assert!(map.insert(11, 12));\n-        assert!(map.insert(14, 22));\n+        assert!(map.insert(5, 20i).is_none());\n+        assert!(map.insert(11, 12).is_none());\n+        assert!(map.insert(14, 22).is_none());\n         map.clear();\n         assert!(map.is_empty());\n-        assert!(map.find(&5).is_none());\n-        assert!(map.find(&11).is_none());\n-        assert!(map.find(&14).is_none());\n+        assert!(map.get(&5).is_none());\n+        assert!(map.get(&11).is_none());\n+        assert!(map.get(&14).is_none());\n     }\n \n     #[test]\n@@ -678,28 +674,28 @@ mod test_map {\n         map.update_with_key(3, 2, add_more_to_count);\n \n         // check the total counts\n-        assert_eq!(map.find(&3).unwrap(), &10);\n-        assert_eq!(map.find(&5).unwrap(), &3);\n-        assert_eq!(map.find(&9).unwrap(), &1);\n+        assert_eq!(map.get(&3).unwrap(), &10);\n+        assert_eq!(map.get(&5).unwrap(), &3);\n+        assert_eq!(map.get(&9).unwrap(), &1);\n \n         // sadly, no sevens were counted\n-        assert!(map.find(&7).is_none());\n+        assert!(map.get(&7).is_none());\n     }\n \n     #[test]\n-    fn test_swap() {\n+    fn test_insert() {\n         let mut m = VecMap::new();\n-        assert_eq!(m.swap(1, 2i), None);\n-        assert_eq!(m.swap(1, 3i), Some(2));\n-        assert_eq!(m.swap(1, 4i), Some(3));\n+        assert_eq!(m.insert(1, 2i), None);\n+        assert_eq!(m.insert(1, 3i), Some(2));\n+        assert_eq!(m.insert(1, 4i), Some(3));\n     }\n \n     #[test]\n-    fn test_pop() {\n+    fn test_remove() {\n         let mut m = VecMap::new();\n         m.insert(1, 2i);\n-        assert_eq!(m.pop(&1), Some(2));\n-        assert_eq!(m.pop(&1), None);\n+        assert_eq!(m.remove(&1), Some(2));\n+        assert_eq!(m.remove(&1), None);\n     }\n \n     #[test]\n@@ -732,11 +728,11 @@ mod test_map {\n     fn test_iterator() {\n         let mut m = VecMap::new();\n \n-        assert!(m.insert(0, 1i));\n-        assert!(m.insert(1, 2));\n-        assert!(m.insert(3, 5));\n-        assert!(m.insert(6, 10));\n-        assert!(m.insert(10, 11));\n+        assert!(m.insert(0, 1i).is_none());\n+        assert!(m.insert(1, 2).is_none());\n+        assert!(m.insert(3, 5).is_none());\n+        assert!(m.insert(6, 10).is_none());\n+        assert!(m.insert(10, 11).is_none());\n \n         let mut it = m.iter();\n         assert_eq!(it.size_hint(), (0, Some(11)));\n@@ -757,11 +753,11 @@ mod test_map {\n     fn test_iterator_size_hints() {\n         let mut m = VecMap::new();\n \n-        assert!(m.insert(0, 1i));\n-        assert!(m.insert(1, 2));\n-        assert!(m.insert(3, 5));\n-        assert!(m.insert(6, 10));\n-        assert!(m.insert(10, 11));\n+        assert!(m.insert(0, 1i).is_none());\n+        assert!(m.insert(1, 2).is_none());\n+        assert!(m.insert(3, 5).is_none());\n+        assert!(m.insert(6, 10).is_none());\n+        assert!(m.insert(10, 11).is_none());\n \n         assert_eq!(m.iter().size_hint(), (0, Some(11)));\n         assert_eq!(m.iter().rev().size_hint(), (0, Some(11)));\n@@ -773,11 +769,11 @@ mod test_map {\n     fn test_mut_iterator() {\n         let mut m = VecMap::new();\n \n-        assert!(m.insert(0, 1i));\n-        assert!(m.insert(1, 2));\n-        assert!(m.insert(3, 5));\n-        assert!(m.insert(6, 10));\n-        assert!(m.insert(10, 11));\n+        assert!(m.insert(0, 1i).is_none());\n+        assert!(m.insert(1, 2).is_none());\n+        assert!(m.insert(3, 5).is_none());\n+        assert!(m.insert(6, 10).is_none());\n+        assert!(m.insert(10, 11).is_none());\n \n         for (k, v) in m.iter_mut() {\n             *v += k as int;\n@@ -796,11 +792,11 @@ mod test_map {\n     fn test_rev_iterator() {\n         let mut m = VecMap::new();\n \n-        assert!(m.insert(0, 1i));\n-        assert!(m.insert(1, 2));\n-        assert!(m.insert(3, 5));\n-        assert!(m.insert(6, 10));\n-        assert!(m.insert(10, 11));\n+        assert!(m.insert(0, 1i).is_none());\n+        assert!(m.insert(1, 2).is_none());\n+        assert!(m.insert(3, 5).is_none());\n+        assert!(m.insert(6, 10).is_none());\n+        assert!(m.insert(10, 11).is_none());\n \n         let mut it = m.iter().rev();\n         assert_eq!(it.next().unwrap(), (10, &11));\n@@ -815,11 +811,11 @@ mod test_map {\n     fn test_mut_rev_iterator() {\n         let mut m = VecMap::new();\n \n-        assert!(m.insert(0, 1i));\n-        assert!(m.insert(1, 2));\n-        assert!(m.insert(3, 5));\n-        assert!(m.insert(6, 10));\n-        assert!(m.insert(10, 11));\n+        assert!(m.insert(0, 1i).is_none());\n+        assert!(m.insert(1, 2).is_none());\n+        assert!(m.insert(3, 5).is_none());\n+        assert!(m.insert(6, 10).is_none());\n+        assert!(m.insert(10, 11).is_none());\n \n         for (k, v) in m.iter_mut().rev() {\n             *v += k as int;\n@@ -880,15 +876,15 @@ mod test_map {\n         let mut b = VecMap::new();\n \n         assert!(a == b);\n-        assert!(a.insert(0, 5i));\n+        assert!(a.insert(0, 5i).is_none());\n         assert!(a != b);\n-        assert!(b.insert(0, 4i));\n+        assert!(b.insert(0, 4i).is_none());\n         assert!(a != b);\n-        assert!(a.insert(5, 19));\n+        assert!(a.insert(5, 19).is_none());\n         assert!(a != b);\n-        assert!(!b.insert(0, 5));\n+        assert!(!b.insert(0, 5).is_none());\n         assert!(a != b);\n-        assert!(b.insert(5, 19));\n+        assert!(b.insert(5, 19).is_none());\n         assert!(a == b);\n     }\n \n@@ -898,15 +894,15 @@ mod test_map {\n         let mut b = VecMap::new();\n \n         assert!(!(a < b) && !(b < a));\n-        assert!(b.insert(2u, 5i));\n+        assert!(b.insert(2u, 5i).is_none());\n         assert!(a < b);\n-        assert!(a.insert(2, 7));\n+        assert!(a.insert(2, 7).is_none());\n         assert!(!(a < b) && b < a);\n-        assert!(b.insert(1, 0));\n+        assert!(b.insert(1, 0).is_none());\n         assert!(b < a);\n-        assert!(a.insert(0, 6));\n+        assert!(a.insert(0, 6).is_none());\n         assert!(a < b);\n-        assert!(a.insert(6, 2));\n+        assert!(a.insert(6, 2).is_none());\n         assert!(a < b && !(b < a));\n     }\n \n@@ -916,10 +912,10 @@ mod test_map {\n         let mut b = VecMap::new();\n \n         assert!(a <= b && a >= b);\n-        assert!(a.insert(1u, 1i));\n+        assert!(a.insert(1u, 1i).is_none());\n         assert!(a > b && a >= b);\n         assert!(b < a && b <= a);\n-        assert!(b.insert(2, 2));\n+        assert!(b.insert(2, 2).is_none());\n         assert!(b > a && b >= a);\n         assert!(a < b && a <= b);\n     }\n@@ -948,7 +944,7 @@ mod test_map {\n         let map: VecMap<char> = xs.iter().map(|&x| x).collect();\n \n         for &(k, v) in xs.iter() {\n-            assert_eq!(map.find(&k), Some(&v));\n+            assert_eq!(map.get(&k), Some(&v));\n         }\n     }\n \n@@ -1022,15 +1018,15 @@ mod bench {\n         let mut m : VecMap<uint> = VecMap::new();\n         find_rand_n(100, &mut m, b,\n                     |m, i| { m.insert(i, 1); },\n-                    |m, i| { m.find(&i); });\n+                    |m, i| { m.get(&i); });\n     }\n \n     #[bench]\n     pub fn find_rand_10_000(b: &mut Bencher) {\n         let mut m : VecMap<uint> = VecMap::new();\n         find_rand_n(10_000, &mut m, b,\n                     |m, i| { m.insert(i, 1); },\n-                    |m, i| { m.find(&i); });\n+                    |m, i| { m.get(&i); });\n     }\n \n     // Find seq\n@@ -1039,14 +1035,14 @@ mod bench {\n         let mut m : VecMap<uint> = VecMap::new();\n         find_seq_n(100, &mut m, b,\n                    |m, i| { m.insert(i, 1); },\n-                   |m, i| { m.find(&i); });\n+                   |m, i| { m.get(&i); });\n     }\n \n     #[bench]\n     pub fn find_seq_10_000(b: &mut Bencher) {\n         let mut m : VecMap<uint> = VecMap::new();\n         find_seq_n(10_000, &mut m, b,\n                    |m, i| { m.insert(i, 1); },\n-                   |m, i| { m.find(&i); });\n+                   |m, i| { m.get(&i); });\n     }\n }"}, {"sha": "ed394fc0de5f9adf6fbfa4811e2157ee5d2fac45", "filename": "src/libgreen/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibgreen%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibgreen%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Flib.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -417,7 +417,7 @@ impl SchedPool {\n         }\n \n         // Jettison the task away!\n-        self.handles.get_mut(idx).send(TaskFromFriend(task));\n+        self.handles[idx].send(TaskFromFriend(task));\n     }\n \n     /// Spawns a new scheduler into this M:N pool. A handle is returned to the"}, {"sha": "50b10873faf48c95e454f7b3911e0e0c076dfed7", "filename": "src/libgreen/sched.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibgreen%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibgreen%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fsched.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -502,7 +502,7 @@ impl Scheduler {\n         let len = work_queues.len();\n         let start_index = self.rng.gen_range(0, len);\n         for index in range(0, len).map(|i| (i + start_index) % len) {\n-            match work_queues.get_mut(index).steal() {\n+            match work_queues[index].steal() {\n                 deque::Data(task) => {\n                     rtdebug!(\"found task by stealing\");\n                     return Some(task)"}, {"sha": "b849afbbf54e766a8852fee18c87b6ea24a00ecf", "filename": "src/libregex/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibregex%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibregex%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Flib.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -41,7 +41,8 @@\n //! it to match anywhere in the text. Anchors can be used to ensure that the\n //! full text matches an expression.\n //!\n-//! This example also demonstrates the utility of raw strings in Rust, which\n+//! This example also demonstrates the utility of [raw\n+//! strings](../reference.html#character-and-string-literals) in Rust, which\n //! are just like regular strings except they are prefixed with an `r` and do\n //! not process any escape sequences. For example, `\"\\\\d\"` is the same\n //! expression as `r\"\\d\"`."}, {"sha": "128243187757aa9bd8443e93061d14712b94fd2c", "filename": "src/librlibc/lib.rs", "status": "removed", "additions": 0, "deletions": 202, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/8ed288edb27fc83b15a549af69c82b5bb4f8ac1e/src%2Flibrlibc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ed288edb27fc83b15a549af69c82b5bb4f8ac1e/src%2Flibrlibc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrlibc%2Flib.rs?ref=8ed288edb27fc83b15a549af69c82b5bb4f8ac1e", "patch": "@@ -1,202 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! A bare-metal library supplying functions rustc may lower code to\n-//!\n-//! This library is not intended for general use, and is superseded by a system\n-//! libc if one is available. In a freestanding context, however, common\n-//! functions such as memset, memcpy, etc are not implemented. This library\n-//! provides an implementation of these functions which are either required by\n-//! libcore or called by rustc implicitly.\n-//!\n-//! This library is never included by default, and must be manually included if\n-//! necessary. It is an error to include this library when also linking with\n-//! the system libc library.\n-\n-#![crate_name = \"rlibc\"]\n-#![experimental]\n-#![license = \"MIT/ASL2\"]\n-#![crate_type = \"rlib\"]\n-#![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n-       html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n-       html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n-\n-#![feature(import_shadowing, intrinsics, phase)]\n-#![no_std]\n-\n-// This library defines the builtin functions, so it would be a shame for\n-// LLVM to optimize these function calls to themselves!\n-#![no_builtins]\n-\n-#[phase(plugin, link)] extern crate core;\n-\n-#[cfg(test)] extern crate native;\n-#[cfg(test)] extern crate test;\n-\n-#[cfg(test)] #[phase(plugin, link)] extern crate std;\n-\n-// Require the offset intrinsics for LLVM to properly optimize the\n-// implementations below. If pointer arithmetic is done through integers the\n-// optimizations start to break down.\n-extern \"rust-intrinsic\" {\n-    fn offset<T>(dst: *const T, offset: int) -> *const T;\n-}\n-\n-#[no_mangle]\n-pub unsafe extern \"C\" fn memcpy(dest: *mut u8, src: *const u8,\n-                                n: uint) -> *mut u8 {\n-    let mut i = 0;\n-    while i < n {\n-        *(offset(dest as *const u8, i as int) as *mut u8) =\n-            *offset(src, i as int);\n-        i += 1;\n-    }\n-    return dest;\n-}\n-\n-#[no_mangle]\n-pub unsafe extern \"C\" fn memmove(dest: *mut u8, src: *const u8,\n-                                 n: uint) -> *mut u8 {\n-    if src < dest as *const u8 { // copy from end\n-        let mut i = n;\n-        while i != 0 {\n-            i -= 1;\n-            *(offset(dest as *const u8, i as int) as *mut u8) =\n-                *offset(src, i as int);\n-        }\n-    } else { // copy from beginning\n-        let mut i = 0;\n-        while i < n {\n-            *(offset(dest as *const u8, i as int) as *mut u8) =\n-                *offset(src, i as int);\n-            i += 1;\n-        }\n-    }\n-    return dest;\n-}\n-\n-#[no_mangle]\n-pub unsafe extern \"C\" fn memset(s: *mut u8, c: i32, n: uint) -> *mut u8 {\n-    let mut i = 0;\n-    while i < n {\n-        *(offset(s as *const u8, i as int) as *mut u8) = c as u8;\n-        i += 1;\n-    }\n-    return s;\n-}\n-\n-#[no_mangle]\n-pub unsafe extern \"C\" fn memcmp(s1: *const u8, s2: *const u8, n: uint) -> i32 {\n-    let mut i = 0;\n-    while i < n {\n-        let a = *offset(s1, i as int);\n-        let b = *offset(s2, i as int);\n-        if a != b {\n-            return a as i32 - b as i32\n-        }\n-        i += 1;\n-    }\n-    return 0;\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    use core::str::StrPrelude;\n-    use core::slice::{SlicePrelude};\n-\n-    use super::{memcmp, memset, memcpy, memmove};\n-\n-    #[test]\n-    fn memcmp_single_byte_pointers() {\n-        unsafe {\n-            assert_eq!(memcmp(&0xFAu8, &0xFAu8, 1), 0x00);\n-            assert!(memcmp(&0xEFu8, &0xFEu8, 1) < 0x00);\n-        }\n-    }\n-\n-    #[test]\n-    fn memcmp_strings() {\n-        {\n-            let (x, z) = (\"Hello!\", \"Good Bye.\");\n-            let l = x.len();\n-            unsafe {\n-                assert_eq!(memcmp(x.as_ptr(), x.as_ptr(), l), 0);\n-                assert!(memcmp(x.as_ptr(), z.as_ptr(), l) > 0);\n-                assert!(memcmp(z.as_ptr(), x.as_ptr(), l) < 0);\n-            }\n-        }\n-        {\n-            let (x, z) = (\"hey!\", \"hey.\");\n-            let l = x.len();\n-            unsafe {\n-                assert!(memcmp(x.as_ptr(), z.as_ptr(), l) < 0);\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn memset_single_byte_pointers() {\n-        let mut x: u8 = 0xFF;\n-        unsafe {\n-            memset(&mut x, 0xAA, 1);\n-            assert_eq!(x, 0xAA);\n-            memset(&mut x, 0x00, 1);\n-            assert_eq!(x, 0x00);\n-            x = 0x01;\n-            memset(&mut x, 0x12, 0);\n-            assert_eq!(x, 0x01);\n-        }\n-    }\n-\n-    #[test]\n-    fn memset_array() {\n-        let mut buffer = [b'X', .. 100];\n-        unsafe {\n-            memset(buffer.as_mut_ptr(), b'#' as i32, buffer.len());\n-        }\n-        for byte in buffer.iter() { assert_eq!(*byte, b'#'); }\n-    }\n-\n-    #[test]\n-    fn memcpy_and_memcmp_arrays() {\n-        let (src, mut dst) = ([b'X', .. 100], [b'Y', .. 100]);\n-        unsafe {\n-            assert!(memcmp(src.as_ptr(), dst.as_ptr(), 100) != 0);\n-            let _ = memcpy(dst.as_mut_ptr(), src.as_ptr(), 100);\n-            assert_eq!(memcmp(src.as_ptr(), dst.as_ptr(), 100), 0);\n-        }\n-    }\n-\n-    #[test]\n-    fn memmove_overlapping() {\n-        {\n-            let mut buffer = [ b'0', b'1', b'2', b'3', b'4', b'5', b'6', b'7', b'8', b'9' ];\n-            unsafe {\n-                memmove(&mut buffer[4], &buffer[0], 6);\n-                let mut i = 0;\n-                for byte in b\"0123012345\".iter() {\n-                    assert_eq!(buffer[i], *byte);\n-                    i += 1;\n-                }\n-            }\n-        }\n-        {\n-            let mut buffer = [ b'0', b'1', b'2', b'3', b'4', b'5', b'6', b'7', b'8', b'9' ];\n-            unsafe {\n-                memmove(&mut buffer[0], &buffer[4], 6);\n-                let mut i = 0;\n-                for byte in b\"4567896789\".iter() {\n-                    assert_eq!(buffer[i], *byte);\n-                    i += 1;\n-                }\n-            }\n-        }\n-    }\n-}"}, {"sha": "58266f2ea32247ebc743225879275ac51cdfb0e8", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -220,7 +220,7 @@ fn symbol_hash(tcx: &ty::ctxt,\n }\n \n fn get_symbol_hash(ccx: &CrateContext, t: ty::t) -> String {\n-    match ccx.type_hashcodes().borrow().find(&t) {\n+    match ccx.type_hashcodes().borrow().get(&t) {\n         Some(h) => return h.to_string(),\n         None => {}\n     }\n@@ -920,7 +920,7 @@ fn link_args(cmd: &mut Command,\n \n     let used_link_args = sess.cstore.get_used_link_args().borrow();\n \n-    if t.options.position_independant_executables {\n+    if t.options.position_independent_executables {\n         let empty_vec = Vec::new();\n         let empty_str = String::new();\n         let args = sess.opts.cg.link_args.as_ref().unwrap_or(&empty_vec);"}, {"sha": "d5e9c1ef99f111f160310b936b5713de02a886d0", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -57,7 +57,6 @@ register_diagnostics!(\n     E0044,\n     E0045,\n     E0046,\n-    E0047,\n     E0049,\n     E0050,\n     E0051,\n@@ -111,7 +110,6 @@ register_diagnostics!(\n     E0108,\n     E0109,\n     E0110,\n-    E0113,\n     E0116,\n     E0117,\n     E0118,\n@@ -145,5 +143,6 @@ register_diagnostics!(\n     E0163,\n     E0164,\n     E0165,\n-    E0166\n+    E0166,\n+    E0167\n )"}, {"sha": "35ccbb4c7b4103e22eeac6073e4d9c430c774124", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -127,7 +127,7 @@ impl Session {\n                     msg: String) {\n         let lint_id = lint::LintId::of(lint);\n         let mut lints = self.lints.borrow_mut();\n-        match lints.find_mut(&id) {\n+        match lints.get_mut(&id) {\n             Some(arr) => { arr.push((lint_id, sp, msg)); return; }\n             None => {}\n         }"}, {"sha": "2858a830081433762a3ba6b44e1e4b66d0483d55", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 61, "deletions": 34, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -403,7 +403,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                                    libc::c_uint or libc::c_ulong should be used\");\n             }\n             def::DefTy(..) => {\n-                let tty = match self.cx.tcx.ast_ty_to_ty_cache.borrow().find(&ty_id) {\n+                let tty = match self.cx.tcx.ast_ty_to_ty_cache.borrow().get(&ty_id) {\n                     Some(&ty::atttce_resolved(t)) => t,\n                     _ => panic!(\"ast_ty_to_ty_cache was incomplete after typeck!\")\n                 };\n@@ -994,7 +994,7 @@ impl LintPass for NonSnakeCase {\n     fn check_pat(&mut self, cx: &Context, p: &ast::Pat) {\n         match &p.node {\n             &ast::PatIdent(_, ref path1, _) => {\n-                match cx.tcx.def_map.borrow().find(&p.id) {\n+                match cx.tcx.def_map.borrow().get(&p.id) {\n                     Some(&def::DefLocal(_)) => {\n                         self.check_snake_case(cx, \"variable\", path1.node, p.span);\n                     }\n@@ -1051,7 +1051,7 @@ impl LintPass for NonUpperCaseGlobals {\n \n     fn check_pat(&mut self, cx: &Context, p: &ast::Pat) {\n         // Lint for constants that look like binding identifiers (#7526)\n-        match (&p.node, cx.tcx.def_map.borrow().find(&p.id)) {\n+        match (&p.node, cx.tcx.def_map.borrow().get(&p.id)) {\n             (&ast::PatIdent(_, ref path1, _), Some(&def::DefConst(..))) => {\n                 let s = token::get_ident(path1.node);\n                 if s.get().chars().any(|c| c.is_lowercase()) {\n@@ -1211,7 +1211,7 @@ impl LintPass for NonShorthandFieldPatterns {\n             ast::PatStruct(_, ref v, _) => {\n                 for fieldpat in v.iter()\n                                  .filter(|fieldpat| !fieldpat.node.is_shorthand)\n-                                 .filter(|fieldpat| def_map.find(&fieldpat.node.pat.id)\n+                                 .filter(|fieldpat| def_map.get(&fieldpat.node.pat.id)\n                                     == Some(&def::DefLocal(fieldpat.node.pat.id))) {\n                     match fieldpat.node.pat.node {\n                         ast::PatIdent(_, ident, None) if ident.node.as_str()\n@@ -1368,7 +1368,7 @@ impl LintPass for UnusedAllocation {\n             _ => return\n         }\n \n-        match cx.tcx.adjustments.borrow().find(&e.id) {\n+        match cx.tcx.adjustments.borrow().get(&e.id) {\n             Some(adjustment) => {\n                 match *adjustment {\n                     ty::AdjustDerefRef(ty::AutoDerefRef { ref autoref, .. }) => {\n@@ -1581,34 +1581,12 @@ impl Stability {\n \n         cx.span_lint(lint, span, msg.as_slice());\n     }\n-}\n-\n-impl LintPass for Stability {\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(DEPRECATED, EXPERIMENTAL, UNSTABLE)\n-    }\n-\n-    fn check_view_item(&mut self, cx: &Context, item: &ast::ViewItem) {\n-        // compiler-generated `extern crate` statements have a dummy span.\n-        if item.span == DUMMY_SP { return }\n-\n-        let id = match item.node {\n-            ast::ViewItemExternCrate(_, _, id) => id,\n-            ast::ViewItemUse(..) => return,\n-        };\n-        let cnum = match cx.tcx.sess.cstore.find_extern_mod_stmt_cnum(id) {\n-            Some(cnum) => cnum,\n-            None => return,\n-        };\n-        let id = ast::DefId { krate: cnum, node: ast::CRATE_NODE_ID };\n-        self.lint(cx, id, item.span);\n-    }\n \n-    fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n+    fn is_internal(&self, cx: &Context, span: Span) -> bool {\n         // first, check if the given expression was generated by a macro or not\n         // we need to go back the expn_info tree to check only the arguments\n         // of the initial macro call, not the nested ones.\n-        let mut expnid = e.span.expn_id;\n+        let mut expnid = span.expn_id;\n         let mut is_internal = false;\n         while cx.tcx.sess.codemap().with_expn_info(expnid, |expninfo| {\n             match expninfo {\n@@ -1623,29 +1601,55 @@ impl LintPass for Stability {\n                         true // continue looping\n                     } else {\n                         // was this expression from the current macro arguments ?\n-                        is_internal = !( e.span.lo > info.call_site.lo &&\n-                                         e.span.hi < info.call_site.hi );\n+                        is_internal = !( span.lo > info.call_site.lo &&\n+                                         span.hi < info.call_site.hi );\n                         true // continue looping\n                     }\n                 },\n                 _ => false // stop looping\n             }\n         }) { /* empty while loop body */ }\n-        if is_internal { return; }\n+        return is_internal;\n+    }\n+}\n+\n+impl LintPass for Stability {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(DEPRECATED, EXPERIMENTAL, UNSTABLE)\n+    }\n+\n+    fn check_view_item(&mut self, cx: &Context, item: &ast::ViewItem) {\n+        // compiler-generated `extern crate` statements have a dummy span.\n+        if item.span == DUMMY_SP { return }\n+\n+        let id = match item.node {\n+            ast::ViewItemExternCrate(_, _, id) => id,\n+            ast::ViewItemUse(..) => return,\n+        };\n+        let cnum = match cx.tcx.sess.cstore.find_extern_mod_stmt_cnum(id) {\n+            Some(cnum) => cnum,\n+            None => return,\n+        };\n+        let id = ast::DefId { krate: cnum, node: ast::CRATE_NODE_ID };\n+        self.lint(cx, id, item.span);\n+    }\n+\n+    fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n+        if self.is_internal(cx, e.span) { return; }\n \n         let mut span = e.span;\n \n         let id = match e.node {\n             ast::ExprPath(..) | ast::ExprStruct(..) => {\n-                match cx.tcx.def_map.borrow().find(&e.id) {\n+                match cx.tcx.def_map.borrow().get(&e.id) {\n                     Some(&def) => def.def_id(),\n                     None => return\n                 }\n             }\n             ast::ExprMethodCall(i, _, _) => {\n                 span = i.span;\n                 let method_call = typeck::MethodCall::expr(e.id);\n-                match cx.tcx.method_map.borrow().find(&method_call) {\n+                match cx.tcx.method_map.borrow().get(&method_call) {\n                     Some(method) => {\n                         match method.origin {\n                             typeck::MethodStatic(def_id) => {\n@@ -1677,6 +1681,29 @@ impl LintPass for Stability {\n         };\n         self.lint(cx, id, span);\n     }\n+\n+    fn check_item(&mut self, cx: &Context, item: &ast::Item) {\n+        if self.is_internal(cx, item.span) { return }\n+\n+        match item.node {\n+            ast::ItemTrait(_, _, ref supertraits, _) => {\n+                for t in supertraits.iter() {\n+                    match *t {\n+                        ast::TraitTyParamBound(ref t) => {\n+                            let id = ty::trait_ref_to_def_id(cx.tcx, t);\n+                            self.lint(cx, id, t.path.span);\n+                        }\n+                        _ => (/* pass */)\n+                    }\n+                }\n+            }\n+            ast::ItemImpl(_, Some(ref t), _, _) => {\n+                let id = ty::trait_ref_to_def_id(cx.tcx, t);\n+                self.lint(cx, id, t.path.span);\n+            }\n+            _ => (/* pass */)\n+        }\n+    }\n }\n \n declare_lint!(pub UNUSED_IMPORTS, Warn,"}, {"sha": "76187f192c2b9676dc25b08a7479f738ea7f03ca", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -84,7 +84,7 @@ enum TargetLint {\n \n impl LintStore {\n     fn get_level_source(&self, lint: LintId) -> LevelSource {\n-        match self.levels.find(&lint) {\n+        match self.levels.get(&lint) {\n             Some(&s) => s,\n             None => (Allow, Default),\n         }\n@@ -124,7 +124,7 @@ impl LintStore {\n             self.lints.push((*lint, from_plugin));\n \n             let id = LintId::of(*lint);\n-            if !self.by_name.insert(lint.name_lower(), Id(id)) {\n+            if self.by_name.insert(lint.name_lower(), Id(id)).is_some() {\n                 let msg = format!(\"duplicate specification of lint {}\", lint.name_lower());\n                 match (sess, from_plugin) {\n                     // We load builtin lints first, so a duplicate is a compiler bug.\n@@ -147,7 +147,7 @@ impl LintStore {\n     pub fn register_group(&mut self, sess: Option<&Session>,\n                           from_plugin: bool, name: &'static str,\n                           to: Vec<LintId>) {\n-        let new = self.lint_groups.insert(name, (to, from_plugin));\n+        let new = self.lint_groups.insert(name, (to, from_plugin)).is_none();\n \n         if !new {\n             let msg = format!(\"duplicate specification of lint group {}\", name);\n@@ -437,11 +437,11 @@ impl<'a, 'tcx> Context<'a, 'tcx> {\n     /// Get the level of `lint` at the current position of the lint\n     /// traversal.\n     pub fn current_level(&self, lint: &'static Lint) -> Level {\n-        self.lints.levels.find(&LintId::of(lint)).map_or(Allow, |&(lvl, _)| lvl)\n+        self.lints.levels.get(&LintId::of(lint)).map_or(Allow, |&(lvl, _)| lvl)\n     }\n \n     fn lookup_and_emit(&self, lint: &'static Lint, span: Option<Span>, msg: &str) {\n-        let (level, src) = match self.lints.levels.find(&LintId::of(lint)) {\n+        let (level, src) = match self.lints.levels.get(&LintId::of(lint)) {\n             None => return,\n             Some(&(Warn, src)) => {\n                 let lint_id = LintId::of(builtin::WARNINGS);\n@@ -750,7 +750,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Context<'a, 'tcx> {\n // Output any lints that were previously added to the session.\n impl<'a, 'tcx> IdVisitingOperation for Context<'a, 'tcx> {\n     fn visit_id(&mut self, id: ast::NodeId) {\n-        match self.tcx.sess.lints.borrow_mut().pop(&id) {\n+        match self.tcx.sess.lints.borrow_mut().remove(&id) {\n             None => {}\n             Some(lints) => {\n                 for (lint_id, span, msg) in lints.into_iter() {"}, {"sha": "36456b3c4a9a00d7de166d893fe5fab2dee4faa3", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -213,7 +213,7 @@ impl CStore {\n \n     pub fn find_extern_mod_stmt_cnum(&self, emod_id: ast::NodeId)\n                                      -> Option<ast::CrateNum> {\n-        self.extern_mod_crate_map.borrow().find(&emod_id).map(|x| *x)\n+        self.extern_mod_crate_map.borrow().get(&emod_id).map(|x| *x)\n     }\n }\n "}, {"sha": "2fd6e2b47870ef0c9b4e765f287bee9108c76364", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -1209,7 +1209,7 @@ pub fn translate_def_id(cdata: Cmd, did: ast::DefId) -> ast::DefId {\n         return ast::DefId { krate: cdata.cnum, node: did.node };\n     }\n \n-    match cdata.cnum_map.find(&did.krate) {\n+    match cdata.cnum_map.get(&did.krate) {\n         Some(&n) => {\n             ast::DefId {\n                 krate: n,\n@@ -1321,7 +1321,7 @@ pub fn get_dylib_dependency_formats(cdata: Cmd)\n         let cnum = spec.split(':').nth(0).unwrap();\n         let link = spec.split(':').nth(1).unwrap();\n         let cnum = from_str(cnum).unwrap();\n-        let cnum = match cdata.cnum_map.find(&cnum) {\n+        let cnum = match cdata.cnum_map.get(&cnum) {\n             Some(&n) => n,\n             None => panic!(\"didn't find a crate in the cnum_map\")\n         };"}, {"sha": "66b647fabdc8a46a5598793a8ad9647ed1fc4a5c", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -253,7 +253,7 @@ fn encode_symbol(ecx: &EncodeContext,\n                  rbml_w: &mut Encoder,\n                  id: NodeId) {\n     rbml_w.start_tag(tag_items_data_item_symbol);\n-    match ecx.item_symbols.borrow().find(&id) {\n+    match ecx.item_symbols.borrow().get(&id) {\n         Some(x) => {\n             debug!(\"encode_symbol(id={}, str={})\", id, *x);\n             rbml_w.writer.write(x.as_bytes());\n@@ -397,7 +397,7 @@ fn encode_reexported_static_base_methods(ecx: &EncodeContext,\n                                          exp: &middle::resolve::Export2)\n                                          -> bool {\n     let impl_items = ecx.tcx.impl_items.borrow();\n-    match ecx.tcx.inherent_impls.borrow().find(&exp.def_id) {\n+    match ecx.tcx.inherent_impls.borrow().get(&exp.def_id) {\n         Some(implementations) => {\n             for base_impl_did in implementations.iter() {\n                 for &method_did in (*impl_items)[*base_impl_did].iter() {\n@@ -426,7 +426,7 @@ fn encode_reexported_static_trait_methods(ecx: &EncodeContext,\n                                           rbml_w: &mut Encoder,\n                                           exp: &middle::resolve::Export2)\n                                           -> bool {\n-    match ecx.tcx.trait_items_cache.borrow().find(&exp.def_id) {\n+    match ecx.tcx.trait_items_cache.borrow().get(&exp.def_id) {\n         Some(trait_items) => {\n             for trait_item in trait_items.iter() {\n                 match *trait_item {\n@@ -531,7 +531,7 @@ fn encode_reexports(ecx: &EncodeContext,\n                     id: NodeId,\n                     path: PathElems) {\n     debug!(\"(encoding info for module) encoding reexports for {}\", id);\n-    match ecx.reexports2.find(&id) {\n+    match ecx.reexports2.get(&id) {\n         Some(ref exports) => {\n             debug!(\"(encoding info for module) found reexports for {}\", id);\n             for exp in exports.iter() {\n@@ -978,7 +978,7 @@ fn should_inline(attrs: &[Attribute]) -> bool {\n fn encode_inherent_implementations(ecx: &EncodeContext,\n                                    rbml_w: &mut Encoder,\n                                    def_id: DefId) {\n-    match ecx.tcx.inherent_impls.borrow().find(&def_id) {\n+    match ecx.tcx.inherent_impls.borrow().get(&def_id) {\n         None => {}\n         Some(implementations) => {\n             for &impl_def_id in implementations.iter() {\n@@ -994,7 +994,7 @@ fn encode_inherent_implementations(ecx: &EncodeContext,\n fn encode_extension_implementations(ecx: &EncodeContext,\n                                     rbml_w: &mut Encoder,\n                                     trait_def_id: DefId) {\n-    match ecx.tcx.trait_impls.borrow().find(&trait_def_id) {\n+    match ecx.tcx.trait_impls.borrow().get(&trait_def_id) {\n         None => {}\n         Some(implementations) => {\n             for &impl_def_id in implementations.borrow().iter() {\n@@ -1987,7 +1987,7 @@ fn encode_crate_triple(rbml_w: &mut Encoder, triple: &str) {\n \n fn encode_dylib_dependency_formats(rbml_w: &mut Encoder, ecx: &EncodeContext) {\n     rbml_w.start_tag(tag_dylib_dependency_formats);\n-    match ecx.tcx.dependency_formats.borrow().find(&config::CrateTypeDylib) {\n+    match ecx.tcx.dependency_formats.borrow().get(&config::CrateTypeDylib) {\n         Some(arr) => {\n             let s = arr.iter().enumerate().filter_map(|(i, slot)| {\n                 slot.map(|kind| (format!(\"{}:{}\", i + 1, match kind {"}, {"sha": "227a6f71bfda9a9202f7b3955613e60c2ea3b522", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -675,16 +675,16 @@ fn parse_builtin_bounds(st: &mut PState, _conv: conv_did) -> ty::BuiltinBounds {\n     loop {\n         match next(st) {\n             'S' => {\n-                builtin_bounds.add(ty::BoundSend);\n+                builtin_bounds.insert(ty::BoundSend);\n             }\n             'Z' => {\n-                builtin_bounds.add(ty::BoundSized);\n+                builtin_bounds.insert(ty::BoundSized);\n             }\n             'P' => {\n-                builtin_bounds.add(ty::BoundCopy);\n+                builtin_bounds.insert(ty::BoundCopy);\n             }\n             'T' => {\n-                builtin_bounds.add(ty::BoundSync);\n+                builtin_bounds.insert(ty::BoundSync);\n             }\n             '.' => {\n                 return builtin_bounds;"}, {"sha": "027b9980a32b9e4d94a723c57de347a9f9276173", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -50,7 +50,7 @@ pub struct ty_abbrev {\n pub type abbrev_map = RefCell<HashMap<ty::t, ty_abbrev>>;\n \n pub fn enc_ty(w: &mut SeekableMemWriter, cx: &ctxt, t: ty::t) {\n-    match cx.abbrevs.borrow_mut().find(&t) {\n+    match cx.abbrevs.borrow_mut().get(&t) {\n         Some(a) => { w.write(a.s.as_bytes()); return; }\n         None => {}\n     }"}, {"sha": "9268418ef94e9e0e738032267516416c04e3d689", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -1151,14 +1151,14 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n \n     debug!(\"Encoding side tables for id {}\", id);\n \n-    for def in tcx.def_map.borrow().find(&id).iter() {\n+    for def in tcx.def_map.borrow().get(&id).iter() {\n         rbml_w.tag(c::tag_table_def, |rbml_w| {\n             rbml_w.id(id);\n             rbml_w.tag(c::tag_table_val, |rbml_w| (*def).encode(rbml_w).unwrap());\n         })\n     }\n \n-    for &ty in tcx.node_types.borrow().find(&(id as uint)).iter() {\n+    for &ty in tcx.node_types.borrow().get(&(id as uint)).iter() {\n         rbml_w.tag(c::tag_table_node_type, |rbml_w| {\n             rbml_w.id(id);\n             rbml_w.tag(c::tag_table_val, |rbml_w| {\n@@ -1167,7 +1167,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n         })\n     }\n \n-    for &item_substs in tcx.item_substs.borrow().find(&id).iter() {\n+    for &item_substs in tcx.item_substs.borrow().get(&id).iter() {\n         rbml_w.tag(c::tag_table_item_subst, |rbml_w| {\n             rbml_w.id(id);\n             rbml_w.tag(c::tag_table_val, |rbml_w| {\n@@ -1176,7 +1176,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n         })\n     }\n \n-    for &fv in tcx.freevars.borrow().find(&id).iter() {\n+    for &fv in tcx.freevars.borrow().get(&id).iter() {\n         rbml_w.tag(c::tag_table_freevars, |rbml_w| {\n             rbml_w.id(id);\n             rbml_w.tag(c::tag_table_val, |rbml_w| {\n@@ -1209,7 +1209,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n         }\n     }\n \n-    for &cm in tcx.capture_modes.borrow().find(&id).iter() {\n+    for &cm in tcx.capture_modes.borrow().get(&id).iter() {\n         rbml_w.tag(c::tag_table_capture_modes, |rbml_w| {\n             rbml_w.id(id);\n             rbml_w.tag(c::tag_table_val, |rbml_w| {\n@@ -1219,7 +1219,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n     }\n \n     let lid = ast::DefId { krate: ast::LOCAL_CRATE, node: id };\n-    for &pty in tcx.tcache.borrow().find(&lid).iter() {\n+    for &pty in tcx.tcache.borrow().get(&lid).iter() {\n         rbml_w.tag(c::tag_table_tcache, |rbml_w| {\n             rbml_w.id(id);\n             rbml_w.tag(c::tag_table_val, |rbml_w| {\n@@ -1228,7 +1228,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n         })\n     }\n \n-    for &type_param_def in tcx.ty_param_defs.borrow().find(&id).iter() {\n+    for &type_param_def in tcx.ty_param_defs.borrow().get(&id).iter() {\n         rbml_w.tag(c::tag_table_param_defs, |rbml_w| {\n             rbml_w.id(id);\n             rbml_w.tag(c::tag_table_val, |rbml_w| {\n@@ -1238,7 +1238,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n     }\n \n     let method_call = MethodCall::expr(id);\n-    for &method in tcx.method_map.borrow().find(&method_call).iter() {\n+    for &method in tcx.method_map.borrow().get(&method_call).iter() {\n         rbml_w.tag(c::tag_table_method_map, |rbml_w| {\n             rbml_w.id(id);\n             rbml_w.tag(c::tag_table_val, |rbml_w| {\n@@ -1247,7 +1247,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n         })\n     }\n \n-    for &trait_ref in tcx.object_cast_map.borrow().find(&id).iter() {\n+    for &trait_ref in tcx.object_cast_map.borrow().get(&id).iter() {\n         rbml_w.tag(c::tag_table_object_cast_map, |rbml_w| {\n             rbml_w.id(id);\n             rbml_w.tag(c::tag_table_val, |rbml_w| {\n@@ -1256,11 +1256,11 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n         })\n     }\n \n-    for &adjustment in tcx.adjustments.borrow().find(&id).iter() {\n+    for &adjustment in tcx.adjustments.borrow().get(&id).iter() {\n         match *adjustment {\n             _ if ty::adjust_is_object(adjustment) => {\n                 let method_call = MethodCall::autoobject(id);\n-                for &method in tcx.method_map.borrow().find(&method_call).iter() {\n+                for &method in tcx.method_map.borrow().get(&method_call).iter() {\n                     rbml_w.tag(c::tag_table_method_map, |rbml_w| {\n                         rbml_w.id(id);\n                         rbml_w.tag(c::tag_table_val, |rbml_w| {\n@@ -1273,7 +1273,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n                 assert!(!ty::adjust_is_object(adjustment));\n                 for autoderef in range(0, adj.autoderefs) {\n                     let method_call = MethodCall::autoderef(id, autoderef);\n-                    for &method in tcx.method_map.borrow().find(&method_call).iter() {\n+                    for &method in tcx.method_map.borrow().get(&method_call).iter() {\n                         rbml_w.tag(c::tag_table_method_map, |rbml_w| {\n                             rbml_w.id(id);\n                             rbml_w.tag(c::tag_table_val, |rbml_w| {\n@@ -1299,7 +1299,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n \n     for unboxed_closure in tcx.unboxed_closures\n                               .borrow()\n-                              .find(&ast_util::local_def(id))\n+                              .get(&ast_util::local_def(id))\n                               .iter() {\n         rbml_w.tag(c::tag_table_unboxed_closures, |rbml_w| {\n             rbml_w.id(id);"}, {"sha": "2a92db3e7d4ec9e14e20aebcdc6ae5f7078a8b3a", "filename": "src/librustc/middle/borrowck/move_data.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -242,7 +242,7 @@ impl MoveData {\n          * base paths that do not yet have an index.\n          */\n \n-        match self.path_map.borrow().find(&lp) {\n+        match self.path_map.borrow().get(&lp) {\n             Some(&index) => {\n                 return index;\n             }\n@@ -577,7 +577,7 @@ impl<'a, 'tcx> FlowedMoveData<'a, 'tcx> {\n         //! Returns the kind of a move of `loan_path` by `id`, if one exists.\n \n         let mut ret = None;\n-        for loan_path_index in self.move_data.path_map.borrow().find(&*loan_path).iter() {\n+        for loan_path_index in self.move_data.path_map.borrow().get(&*loan_path).iter() {\n             self.dfcx_moves.each_gen_bit(id, |move_index| {\n                 let the_move = self.move_data.moves.borrow();\n                 let the_move = (*the_move)[move_index];"}, {"sha": "1e38250ceb38db8ecb3f87b046d7ab3d542c477f", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -512,7 +512,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             func_or_rcvr: &ast::Expr,\n             args: I) -> CFGIndex {\n         let method_call = typeck::MethodCall::expr(call_expr.id);\n-        let return_ty = ty::ty_fn_ret(match self.tcx.method_map.borrow().find(&method_call) {\n+        let return_ty = ty::ty_fn_ret(match self.tcx.method_map.borrow().get(&method_call) {\n             Some(method) => method.ty,\n             None => ty::expr_ty(self.tcx, func_or_rcvr)\n         });\n@@ -610,7 +610,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             }\n \n             Some(_) => {\n-                match self.tcx.def_map.borrow().find(&expr.id) {\n+                match self.tcx.def_map.borrow().get(&expr.id) {\n                     Some(&def::DefLabel(loop_id)) => {\n                         for l in self.loop_scopes.iter() {\n                             if l.loop_id == loop_id {"}, {"sha": "7a97589b9facb46ebd09c0a52175220b92051c06", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -138,12 +138,12 @@ fn check_expr(v: &mut CheckCrateVisitor, e: &Expr) -> bool {\n             // to handle on-demand instantiation of functions via\n             // foo::<bar> in a const. Currently that is only done on\n             // a path in trans::callee that only works in block contexts.\n-            if !pth.segments.iter().all(|segment| segment.types.is_empty()) {\n+            if !pth.segments.iter().all(|segment| segment.parameters.is_empty()) {\n                 span_err!(v.tcx.sess, e.span, E0013,\n                           \"paths in constants may only refer to items without \\\n                            type parameters\");\n             }\n-            match v.tcx.def_map.borrow().find(&e.id) {\n+            match v.tcx.def_map.borrow().get(&e.id) {\n                 Some(&DefStatic(..)) |\n                 Some(&DefConst(..)) |\n                 Some(&DefFn(..)) |\n@@ -162,7 +162,7 @@ fn check_expr(v: &mut CheckCrateVisitor, e: &Expr) -> bool {\n             }\n         }\n         ExprCall(ref callee, _) => {\n-            match v.tcx.def_map.borrow().find(&callee.id) {\n+            match v.tcx.def_map.borrow().get(&callee.id) {\n                 Some(&DefStruct(..)) |\n                 Some(&DefVariant(..)) => {}    // OK.\n "}, {"sha": "4dcd5d8873ea467cb4dd25fdced4b26ba5aae6ec", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -639,7 +639,7 @@ fn pat_constructors(cx: &MatchCheckCtxt, p: &Pat,\n     let pat = raw_pat(p);\n     match pat.node {\n         PatIdent(..) =>\n-            match cx.tcx.def_map.borrow().find(&pat.id) {\n+            match cx.tcx.def_map.borrow().get(&pat.id) {\n                 Some(&DefConst(..)) =>\n                     cx.tcx.sess.span_bug(pat.span, \"const pattern should've \\\n                                                     been rewritten\"),\n@@ -648,15 +648,15 @@ fn pat_constructors(cx: &MatchCheckCtxt, p: &Pat,\n                 _ => vec!()\n             },\n         PatEnum(..) =>\n-            match cx.tcx.def_map.borrow().find(&pat.id) {\n+            match cx.tcx.def_map.borrow().get(&pat.id) {\n                 Some(&DefConst(..)) =>\n                     cx.tcx.sess.span_bug(pat.span, \"const pattern should've \\\n                                                     been rewritten\"),\n                 Some(&DefVariant(_, id, _)) => vec!(Variant(id)),\n                 _ => vec!(Single)\n             },\n         PatStruct(..) =>\n-            match cx.tcx.def_map.borrow().find(&pat.id) {\n+            match cx.tcx.def_map.borrow().get(&pat.id) {\n                 Some(&DefConst(..)) =>\n                     cx.tcx.sess.span_bug(pat.span, \"const pattern should've \\\n                                                     been rewritten\"),"}, {"sha": "a3738f031a9655329d33d2d8d663896bc5e34843", "filename": "src/librustc/middle/check_static_recursion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -95,7 +95,7 @@ impl<'a, 'ast, 'v> Visitor<'v> for CheckItemRecursionVisitor<'a, 'ast> {\n     fn visit_expr(&mut self, e: &ast::Expr) {\n         match e.node {\n             ast::ExprPath(..) => {\n-                match self.def_map.borrow().find(&e.id) {\n+                match self.def_map.borrow().get(&e.id) {\n                     Some(&DefStatic(def_id, _)) |\n                     Some(&DefConst(def_id)) if\n                             ast_util::is_local(def_id) => {"}, {"sha": "fdda5f1a860e6dce1248bec81427880393582d8a", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -123,7 +123,7 @@ fn lookup_variant_by_id<'a>(tcx: &'a ty::ctxt,\n             Some(_) => None\n         }\n     } else {\n-        match tcx.extern_const_variants.borrow().find(&variant_def) {\n+        match tcx.extern_const_variants.borrow().get(&variant_def) {\n             Some(&ast::DUMMY_NODE_ID) => return None,\n             Some(&expr_id) => {\n                 return Some(tcx.map.expect_expr(expr_id));\n@@ -163,7 +163,7 @@ pub fn lookup_const_by_id<'a>(tcx: &'a ty::ctxt, def_id: ast::DefId)\n             Some(_) => None\n         }\n     } else {\n-        match tcx.extern_const_statics.borrow().find(&def_id) {\n+        match tcx.extern_const_statics.borrow().get(&def_id) {\n             Some(&ast::DUMMY_NODE_ID) => return None,\n             Some(&expr_id) => {\n                 return Some(tcx.map.expect_expr(expr_id));\n@@ -192,7 +192,7 @@ struct ConstEvalVisitor<'a, 'tcx: 'a> {\n impl<'a, 'tcx> ConstEvalVisitor<'a, 'tcx> {\n     fn classify(&mut self, e: &Expr) -> constness {\n         let did = ast_util::local_def(e.id);\n-        match self.ccache.find(&did) {\n+        match self.ccache.get(&did) {\n             Some(&x) => return x,\n             None => {}\n         }"}, {"sha": "97dfa4ecd361a403f9146226c6531abe162a9217", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -86,7 +86,7 @@ struct PropagationContext<'a, 'b: 'a, 'tcx: 'b, O: 'a> {\n }\n \n fn to_cfgidx_or_die(id: ast::NodeId, index: &NodeMap<CFGIndex>) -> CFGIndex {\n-    let opt_cfgindex = index.find(&id).map(|&i|i);\n+    let opt_cfgindex = index.get(&id).map(|&i|i);\n     opt_cfgindex.unwrap_or_else(|| {\n         panic!(\"nodeid_to_index does not have entry for NodeId {}\", id);\n     })\n@@ -397,7 +397,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n \n             let mut changed = false;\n             for &node_id in edge.data.exiting_scopes.iter() {\n-                let opt_cfg_idx = self.nodeid_to_index.find(&node_id).map(|&i|i);\n+                let opt_cfg_idx = self.nodeid_to_index.get(&node_id).map(|&i|i);\n                 match opt_cfg_idx {\n                     Some(cfg_idx) => {\n                         let (start, end) = self.compute_id_range(cfg_idx);"}, {"sha": "2ae2f9bfe7a027fc5f0c0d0dc2cab87e6725b9ea", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -74,7 +74,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n     }\n \n     fn lookup_and_handle_definition(&mut self, id: &ast::NodeId) {\n-        self.tcx.def_map.borrow().find(id).map(|def| {\n+        self.tcx.def_map.borrow().get(id).map(|def| {\n             match def {\n                 &def::DefConst(_) => {\n                     self.check_def_id(def.def_id())\n@@ -95,7 +95,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n     fn lookup_and_handle_method(&mut self, id: ast::NodeId,\n                                 span: codemap::Span) {\n         let method_call = typeck::MethodCall::expr(id);\n-        match self.tcx.method_map.borrow().find(&method_call) {\n+        match self.tcx.method_map.borrow().get(&method_call) {\n             Some(method) => {\n                 match method.origin {\n                     typeck::MethodStatic(def_id) => {\n@@ -493,7 +493,7 @@ impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n         // method of a private type is used, but the type itself is never\n         // called directly.\n         let impl_items = self.tcx.impl_items.borrow();\n-        match self.tcx.inherent_impls.borrow().find(&local_def(id)) {\n+        match self.tcx.inherent_impls.borrow().get(&local_def(id)) {\n             None => (),\n             Some(impl_list) => {\n                 for impl_did in impl_list.iter() {"}, {"sha": "bfabcc958d7c113e9df9235fbd6516caabc3835b", "filename": "src/librustc/middle/dependency_format.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -158,7 +158,7 @@ fn calculate_type(sess: &session::Session,\n \n     // Collect what we've got so far in the return vector.\n     let mut ret = range(1, sess.cstore.next_crate_num()).map(|i| {\n-        match formats.find(&i).map(|v| *v) {\n+        match formats.get(&i).map(|v| *v) {\n             v @ Some(cstore::RequireDynamic) => v,\n             _ => None,\n         }\n@@ -209,7 +209,7 @@ fn add_library(sess: &session::Session,\n                cnum: ast::CrateNum,\n                link: cstore::LinkagePreference,\n                m: &mut HashMap<ast::CrateNum, cstore::LinkagePreference>) {\n-    match m.find(&cnum) {\n+    match m.get(&cnum) {\n         Some(&link2) => {\n             // If the linkages differ, then we'd have two copies of the library\n             // if we continued linking. If the linkages are both static, then we"}, {"sha": "d12b612b03361e331345e3ff104d91ca19e0101b", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -162,7 +162,7 @@ impl OverloadedCallType {\n         let trait_did =\n             tcx.unboxed_closures\n                .borrow()\n-               .find(&closure_did)\n+               .get(&closure_did)\n                .expect(\"OverloadedCallType::from_unboxed_closure: didn't \\\n                         find closure id\")\n                .kind\n@@ -535,7 +535,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {\n                     match self.tcx()\n                               .method_map\n                               .borrow()\n-                              .find(&MethodCall::expr(call.id)) {\n+                              .get(&MethodCall::expr(call.id)) {\n                     Some(ref method_callee) => {\n                         OverloadedCallType::from_method_origin(\n                             self.tcx(),\n@@ -686,7 +686,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {\n     // process.\n     fn walk_adjustment(&mut self, expr: &ast::Expr) {\n         let typer = self.typer;\n-        match typer.adjustments().borrow().find(&expr.id) {\n+        match typer.adjustments().borrow().get(&expr.id) {\n             None => { }\n             Some(adjustment) => {\n                 match *adjustment {"}, {"sha": "1f3473c159f22c0d13100985fdc36c684e0d5936", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -173,7 +173,7 @@ impl<'a> LanguageItemCollector<'a> {\n         }\n \n         // Matched.\n-        *self.items.items.get_mut(item_index) = Some(item_def_id);\n+        self.items.items[item_index] = Some(item_def_id);\n     }\n \n     pub fn collect_local_language_items(&mut self, krate: &ast::Crate) {"}, {"sha": "dff9c45611aa9f634cf6f736e01068a9717921ed", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -322,7 +322,7 @@ impl<'a, 'tcx> IrMaps<'a, 'tcx> {\n     }\n \n     fn variable(&self, node_id: NodeId, span: Span) -> Variable {\n-        match self.variable_map.find(&node_id) {\n+        match self.variable_map.get(&node_id) {\n           Some(&var) => var,\n           None => {\n             self.tcx\n@@ -591,7 +591,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     }\n \n     fn live_node(&self, node_id: NodeId, span: Span) -> LiveNode {\n-        match self.ir.live_node_map.find(&node_id) {\n+        match self.ir.live_node_map.get(&node_id) {\n           Some(&ln) => ln,\n           None => {\n             // This must be a mismatch between the ir_map construction\n@@ -719,7 +719,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             Some(_) => {\n                 // Refers to a labeled loop. Use the results of resolve\n                 // to find with one\n-                match self.ir.tcx.def_map.borrow().find(&id) {\n+                match self.ir.tcx.def_map.borrow().get(&id) {\n                     Some(&DefLabel(loop_id)) => loop_id,\n                     _ => self.ir.tcx.sess.span_bug(sp, \"label on break/loop \\\n                                                         doesn't refer to a loop\")\n@@ -988,7 +988,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n                  // the construction of a closure itself is not important,\n                  // but we have to consider the closed over variables.\n-                 let caps = match this.ir.capture_info_map.find(&expr.id) {\n+                 let caps = match this.ir.capture_info_map.get(&expr.id) {\n                     Some(caps) => caps.clone(),\n                     None => {\n                         this.ir.tcx.sess.span_bug(expr.span, \"no registered caps\");\n@@ -1096,7 +1096,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n               // Now that we know the label we're going to,\n               // look it up in the break loop nodes table\n \n-              match self.break_ln.find(&sc) {\n+              match self.break_ln.get(&sc) {\n                   Some(&b) => b,\n                   None => self.ir.tcx.sess.span_bug(expr.span,\n                                                     \"break to unknown label\")\n@@ -1110,7 +1110,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n               // Now that we know the label we're going to,\n               // look it up in the continue loop nodes table\n \n-              match self.cont_ln.find(&sc) {\n+              match self.cont_ln.get(&sc) {\n                   Some(&b) => b,\n                   None => self.ir.tcx.sess.span_bug(expr.span,\n                                                     \"loop to unknown label\")\n@@ -1167,7 +1167,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n           ExprMethodCall(_, _, ref args) => {\n             let method_call = typeck::MethodCall::expr(expr.id);\n-            let method_ty = self.ir.tcx.method_map.borrow().find(&method_call).unwrap().ty;\n+            let method_ty = self.ir.tcx.method_map.borrow().get(&method_call).unwrap().ty;\n             let diverges = ty::ty_fn_ret(method_ty) == ty::FnDiverging;\n             let succ = if diverges {\n                 self.s.exit_ln\n@@ -1520,7 +1520,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             ty::ty_unboxed_closure(closure_def_id, _, _) =>\n                 self.ir.tcx.unboxed_closures()\n                     .borrow()\n-                    .find(&closure_def_id)\n+                    .get(&closure_def_id)\n                     .unwrap()\n                     .closure_type\n                     .sig"}, {"sha": "4c396a5a2051030c650b61b0db54f71739900fc4", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -389,7 +389,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n     fn expr_ty_adjusted(&self, expr: &ast::Expr) -> McResult<ty::t> {\n         let unadjusted_ty = if_ok!(self.expr_ty(expr));\n         Ok(ty::adjust_ty(self.tcx(), expr.span, expr.id, unadjusted_ty,\n-                         self.typer.adjustments().borrow().find(&expr.id),\n+                         self.typer.adjustments().borrow().get(&expr.id),\n                          |method_call| self.typer.node_method_ty(method_call)))\n     }\n \n@@ -402,7 +402,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n     }\n \n     pub fn cat_expr(&self, expr: &ast::Expr) -> McResult<cmt> {\n-        match self.typer.adjustments().borrow().find(&expr.id) {\n+        match self.typer.adjustments().borrow().get(&expr.id) {\n             None => {\n                 // No adjustments.\n                 self.cat_expr_unadjusted(expr)\n@@ -861,7 +861,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                              deref_cnt: uint,\n                              implicit: bool)\n                              -> cmt {\n-        let adjustment = match self.typer.adjustments().borrow().find(&node.id()) {\n+        let adjustment = match self.typer.adjustments().borrow().get(&node.id()) {\n             Some(adj) if ty::adjust_is_object(adj) => typeck::AutoObject,\n             _ if deref_cnt != 0 => typeck::AutoDeref(deref_cnt),\n             _ => typeck::NoAdjustment\n@@ -1170,7 +1170,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n             // variant(..)\n           }\n           ast::PatEnum(_, Some(ref subpats)) => {\n-            match self.tcx().def_map.borrow().find(&pat.id) {\n+            match self.tcx().def_map.borrow().get(&pat.id) {\n                 Some(&def::DefVariant(enum_did, _, _)) => {\n                     // variant(x, y, z)\n "}, {"sha": "e320f47075e8625ebddb219f9d9b192f7fd49286", "filename": "src/librustc/middle/pat_util.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fpat_util.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -16,7 +16,6 @@ use std::collections::HashMap;\n use syntax::ast::*;\n use syntax::ast_util::{walk_pat};\n use syntax::codemap::{Span, DUMMY_SP};\n-use syntax::owned_slice::OwnedSlice;\n \n pub type PatIdMap = HashMap<Ident, NodeId>;\n \n@@ -34,7 +33,7 @@ pub fn pat_is_refutable(dm: &resolve::DefMap, pat: &Pat) -> bool {\n     match pat.node {\n         PatLit(_) | PatRange(_, _) => true,\n         PatEnum(_, _) | PatIdent(_, _, None) | PatStruct(..) => {\n-            match dm.borrow().find(&pat.id) {\n+            match dm.borrow().get(&pat.id) {\n                 Some(&DefVariant(..)) => true,\n                 _ => false\n             }\n@@ -47,7 +46,7 @@ pub fn pat_is_refutable(dm: &resolve::DefMap, pat: &Pat) -> bool {\n pub fn pat_is_variant_or_struct(dm: &resolve::DefMap, pat: &Pat) -> bool {\n     match pat.node {\n         PatEnum(_, _) | PatIdent(_, _, None) | PatStruct(..) => {\n-            match dm.borrow().find(&pat.id) {\n+            match dm.borrow().get(&pat.id) {\n                 Some(&DefVariant(..)) | Some(&DefStruct(..)) => true,\n                 _ => false\n             }\n@@ -59,7 +58,7 @@ pub fn pat_is_variant_or_struct(dm: &resolve::DefMap, pat: &Pat) -> bool {\n pub fn pat_is_const(dm: &resolve::DefMap, pat: &Pat) -> bool {\n     match pat.node {\n         PatIdent(_, _, None) | PatEnum(..) => {\n-            match dm.borrow().find(&pat.id) {\n+            match dm.borrow().get(&pat.id) {\n                 Some(&DefConst(..)) => true,\n                 _ => false\n             }\n@@ -133,8 +132,7 @@ pub fn def_to_path(tcx: &ty::ctxt, id: DefId) -> Path {\n         global: false,\n         segments: path.last().map(|elem| PathSegment {\n             identifier: Ident::new(elem.name()),\n-            lifetimes: vec!(),\n-            types: OwnedSlice::empty()\n+            parameters: PathParameters::none(),\n         }).into_iter().collect(),\n         span: DUMMY_SP,\n     })"}, {"sha": "21b94babcb6a4b50eda09a0cbb8fd4b754e3c65b", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -27,7 +27,6 @@ use syntax::ast_map;\n use syntax::ast_util::{is_local, local_def, PostExpansionMethod};\n use syntax::codemap::Span;\n use syntax::parse::token;\n-use syntax::owned_slice::OwnedSlice;\n use syntax::visit;\n use syntax::visit::Visitor;\n \n@@ -399,7 +398,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n             }\n             debug!(\"privacy - is {} a public method\", did);\n \n-            return match self.tcx.impl_or_trait_items.borrow().find(&did) {\n+            return match self.tcx.impl_or_trait_items.borrow().get(&did) {\n                 Some(&ty::MethodTraitItem(ref meth)) => {\n                     debug!(\"privacy - well at least it's a method: {}\",\n                            *meth);\n@@ -462,7 +461,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n         debug!(\"privacy - local {} not public all the way down\",\n                self.tcx.map.node_to_string(did.node));\n         // return quickly for things in the same module\n-        if self.parents.find(&did.node) == self.parents.find(&self.curitem) {\n+        if self.parents.get(&did.node) == self.parents.get(&self.curitem) {\n             debug!(\"privacy - same parent, we're done here\");\n             return Allowable;\n         }\n@@ -855,7 +854,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n             }\n             ast::ExprMethodCall(ident, _, _) => {\n                 let method_call = MethodCall::expr(expr.id);\n-                match self.tcx.method_map.borrow().find(&method_call) {\n+                match self.tcx.method_map.borrow().get(&method_call) {\n                     None => {\n                         self.tcx.sess.span_bug(expr.span,\n                                                 \"method call not in \\\n@@ -909,7 +908,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n                              with private fields\");\n                     }\n                 };\n-                match self.tcx.def_map.borrow().find(&expr.id) {\n+                match self.tcx.def_map.borrow().get(&expr.id) {\n                     Some(&def::DefStruct(did)) => {\n                         guard(if is_local(did) {\n                             local_def(self.tcx.map.get_parent(did.node))\n@@ -945,8 +944,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n                                     debug!(\"privacy - ident item {}\", id);\n                                     let seg = ast::PathSegment {\n                                         identifier: name,\n-                                        lifetimes: Vec::new(),\n-                                        types: OwnedSlice::empty(),\n+                                        parameters: ast::PathParameters::none(),\n                                     };\n                                     let segs = vec![seg];\n                                     let path = ast::Path {\n@@ -986,7 +984,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n                         }\n                     }\n                     ty::ty_enum(_, _) => {\n-                        match self.tcx.def_map.borrow().find(&pattern.id) {\n+                        match self.tcx.def_map.borrow().get(&pattern.id) {\n                             Some(&def::DefVariant(_, variant_id, _)) => {\n                                 for field in fields.iter() {\n                                     self.check_field(pattern.span, variant_id,"}, {"sha": "dbeb2e289fb74f4a6a1cf97e8bad8930331bf9b6", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -106,7 +106,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ReachableContext<'a, 'tcx> {\n \n         match expr.node {\n             ast::ExprPath(_) => {\n-                let def = match self.tcx.def_map.borrow().find(&expr.id) {\n+                let def = match self.tcx.def_map.borrow().get(&expr.id) {\n                     Some(&def) => def,\n                     None => {\n                         self.tcx.sess.span_bug(expr.span,"}, {"sha": "d380c35580d181e2f3bacb0f90fdbc9748d6d443", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -103,7 +103,7 @@ struct RegionResolutionVisitor<'a> {\n \n impl RegionMaps {\n     pub fn relate_free_regions(&self, sub: FreeRegion, sup: FreeRegion) {\n-        match self.free_region_map.borrow_mut().find_mut(&sub) {\n+        match self.free_region_map.borrow_mut().get_mut(&sub) {\n             Some(sups) => {\n                 if !sups.iter().any(|x| x == &sup) {\n                     sups.push(sup);\n@@ -149,13 +149,13 @@ impl RegionMaps {\n \n     pub fn opt_encl_scope(&self, id: ast::NodeId) -> Option<ast::NodeId> {\n         //! Returns the narrowest scope that encloses `id`, if any.\n-        self.scope_map.borrow().find(&id).map(|x| *x)\n+        self.scope_map.borrow().get(&id).map(|x| *x)\n     }\n \n     #[allow(dead_code)] // used in middle::cfg\n     pub fn encl_scope(&self, id: ast::NodeId) -> ast::NodeId {\n         //! Returns the narrowest scope that encloses `id`, if any.\n-        match self.scope_map.borrow().find(&id) {\n+        match self.scope_map.borrow().get(&id) {\n             Some(&r) => r,\n             None => { panic!(\"no enclosing scope for id {}\", id); }\n         }\n@@ -165,7 +165,7 @@ impl RegionMaps {\n         /*!\n          * Returns the lifetime of the local variable `var_id`\n          */\n-        match self.var_map.borrow().find(&var_id) {\n+        match self.var_map.borrow().get(&var_id) {\n             Some(&r) => r,\n             None => { panic!(\"no enclosing scope for id {}\", var_id); }\n         }\n@@ -175,7 +175,7 @@ impl RegionMaps {\n         //! Returns the scope when temp created by expr_id will be cleaned up\n \n         // check for a designated rvalue scope\n-        match self.rvalue_scopes.borrow().find(&expr_id) {\n+        match self.rvalue_scopes.borrow().get(&expr_id) {\n             Some(&s) => {\n                 debug!(\"temporary_scope({}) = {} [custom]\", expr_id, s);\n                 return Some(s);\n@@ -232,7 +232,7 @@ impl RegionMaps {\n \n         let mut s = subscope;\n         while superscope != s {\n-            match self.scope_map.borrow().find(&s) {\n+            match self.scope_map.borrow().get(&s) {\n                 None => {\n                     debug!(\"is_subscope_of({}, {}, s={})=false\",\n                            subscope, superscope, s);\n@@ -356,7 +356,7 @@ impl RegionMaps {\n             let mut result = vec!(scope);\n             let mut scope = scope;\n             loop {\n-                match this.scope_map.borrow().find(&scope) {\n+                match this.scope_map.borrow().get(&scope) {\n                     None => return result,\n                     Some(&superscope) => {\n                         result.push(superscope);"}, {"sha": "a1a8cccf55a4bdc52cafd5d2a7c681a4a0eeeb41", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 31, "deletions": 66, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -40,7 +40,7 @@ use syntax::ast::{TupleVariantKind, Ty, TyBool, TyChar, TyClosure, TyF32};\n use syntax::ast::{TyF64, TyFloat, TyI, TyI8, TyI16, TyI32, TyI64, TyInt};\n use syntax::ast::{TyParam, TyParamBound, TyPath, TyPtr, TyProc, TyQPath};\n use syntax::ast::{TyRptr, TyStr, TyU, TyU8, TyU16, TyU32, TyU64, TyUint};\n-use syntax::ast::{TypeImplItem, UnboxedFnTyParamBound, UnnamedField};\n+use syntax::ast::{TypeImplItem, UnnamedField};\n use syntax::ast::{Variant, ViewItem, ViewItemExternCrate};\n use syntax::ast::{ViewItemUse, ViewPathGlob, ViewPathList, ViewPathSimple};\n use syntax::ast::{Visibility};\n@@ -2234,7 +2234,7 @@ impl<'a> Resolver<'a> {\n \n                 let mut import_resolutions = module_.import_resolutions\n                                                     .borrow_mut();\n-                match import_resolutions.find_mut(&target) {\n+                match import_resolutions.get_mut(&target) {\n                     Some(resolution) => {\n                         debug!(\"(building import directive) bumping \\\n                                 reference\");\n@@ -2552,7 +2552,7 @@ impl<'a> Resolver<'a> {\n         // Search for direct children of the containing module.\n         self.populate_module_if_necessary(&containing_module);\n \n-        match containing_module.children.borrow().find(&source) {\n+        match containing_module.children.borrow().get(&source) {\n             None => {\n                 // Continue.\n             }\n@@ -2588,7 +2588,7 @@ impl<'a> Resolver<'a> {\n                 }\n \n                 // Now search the exported imports within the containing module.\n-                match containing_module.import_resolutions.borrow().find(&source) {\n+                match containing_module.import_resolutions.borrow().get(&source) {\n                     None => {\n                         debug!(\"(resolving single import) no import\");\n                         // The containing module definitely doesn't have an\n@@ -2853,7 +2853,7 @@ impl<'a> Resolver<'a> {\n \n             // Here we merge two import resolutions.\n             let mut import_resolutions = module_.import_resolutions.borrow_mut();\n-            match import_resolutions.find_mut(ident) {\n+            match import_resolutions.get_mut(ident) {\n                 Some(dest_import_resolution) => {\n                     // Merge the two import resolutions at a finer-grained\n                     // level.\n@@ -3046,7 +3046,7 @@ impl<'a> Resolver<'a> {\n \n         // Check for item conflicts.\n         let children = module.children.borrow();\n-        let name_bindings = match children.find(&name) {\n+        let name_bindings = match children.get(&name) {\n             None => {\n                 // There can't be any conflicts.\n                 return\n@@ -3432,7 +3432,7 @@ impl<'a> Resolver<'a> {\n         // its immediate children.\n         self.populate_module_if_necessary(&module_);\n \n-        match module_.children.borrow().find(&name) {\n+        match module_.children.borrow().get(&name) {\n             Some(name_bindings)\n                     if name_bindings.defined_in_namespace(namespace) => {\n                 debug!(\"top name bindings succeeded\");\n@@ -3448,7 +3448,7 @@ impl<'a> Resolver<'a> {\n         // all its imports in the usual way; this is because chains of\n         // adjacent import statements are processed as though they mutated the\n         // current scope.\n-        match module_.import_resolutions.borrow().find(&name) {\n+        match module_.import_resolutions.borrow().get(&name) {\n             None => {\n                 // Not found; continue.\n             }\n@@ -3705,7 +3705,7 @@ impl<'a> Resolver<'a> {\n         // First, check the direct children of the module.\n         self.populate_module_if_necessary(&module_);\n \n-        match module_.children.borrow().find(&name) {\n+        match module_.children.borrow().get(&name) {\n             Some(name_bindings)\n                     if name_bindings.defined_in_namespace(namespace) => {\n                 debug!(\"(resolving name in module) found node as child\");\n@@ -3728,7 +3728,7 @@ impl<'a> Resolver<'a> {\n         }\n \n         // Check the list of resolved imports.\n-        match module_.import_resolutions.borrow().find(&name) {\n+        match module_.import_resolutions.borrow().get(&name) {\n             Some(import_resolution) if allow_private_imports ||\n                                        import_resolution.is_public => {\n \n@@ -3967,7 +3967,7 @@ impl<'a> Resolver<'a> {\n             Some(name) => {\n                 self.populate_module_if_necessary(&orig_module);\n \n-                match orig_module.children.borrow().find(&name) {\n+                match orig_module.children.borrow().get(&name) {\n                     None => {\n                         debug!(\"!!! (with scope) didn't find `{}` in `{}`\",\n                                token::get_name(name),\n@@ -4523,41 +4523,6 @@ impl<'a> Resolver<'a> {\n             TraitTyParamBound(ref tref) => {\n                 self.resolve_trait_reference(id, tref, reference_type)\n             }\n-            UnboxedFnTyParamBound(ref unboxed_function) => {\n-                match self.resolve_path(unboxed_function.ref_id,\n-                                        &unboxed_function.path,\n-                                        TypeNS,\n-                                        true) {\n-                    None => {\n-                        let path_str = self.path_names_to_string(\n-                            &unboxed_function.path);\n-                        self.resolve_error(unboxed_function.path.span,\n-                                           format!(\"unresolved trait `{}`\",\n-                                                   path_str).as_slice())\n-                    }\n-                    Some(def) => {\n-                        match def {\n-                            (DefTrait(_), _) => {\n-                                self.record_def(unboxed_function.ref_id, def);\n-                            }\n-                            _ => {\n-                                let msg =\n-                                    format!(\"`{}` is not a trait\",\n-                                            self.path_names_to_string(\n-                                                &unboxed_function.path));\n-                                self.resolve_error(unboxed_function.path.span,\n-                                                   msg.as_slice());\n-                            }\n-                        }\n-                    }\n-                }\n-\n-                for argument in unboxed_function.decl.inputs.iter() {\n-                    self.resolve_type(&*argument.ty);\n-                }\n-\n-                self.resolve_type(&*unboxed_function.decl.output);\n-            }\n             RegionTyParamBound(..) => {}\n         }\n     }\n@@ -4691,7 +4656,7 @@ impl<'a> Resolver<'a> {\n             Some(ref trait_ref) => {\n                 self.resolve_trait_reference(id, trait_ref, TraitImplementation);\n \n-                match self.def_map.borrow().find(&trait_ref.ref_id) {\n+                match self.def_map.borrow().get(&trait_ref.ref_id) {\n                     Some(def) => {\n                         let did = def.def_id();\n                         Some((did, trait_ref.clone()))\n@@ -4767,7 +4732,7 @@ impl<'a> Resolver<'a> {\n                 // a type (shadowing any imported modules or types with this name), leading\n                 // to weird user-visible bugs. So we ward this off here. See #15060.\n                 TyPath(ref path, _, path_id) => {\n-                    match self.def_map.borrow().find(&path_id) {\n+                    match self.def_map.borrow().get(&path_id) {\n                         // FIXME: should we catch other options and give more precise errors?\n                         Some(&DefMod(_)) => {\n                             self.resolve_error(path.span, \"inherent implementations are not \\\n@@ -4785,7 +4750,7 @@ impl<'a> Resolver<'a> {\n     fn check_trait_item(&self, name: Name, span: Span) {\n         // If there is a TraitRef in scope for an impl, then the method must be in the trait.\n         for &(did, ref trait_ref) in self.current_trait_ref.iter() {\n-            if self.trait_item_map.find(&(name, did)).is_none() {\n+            if self.trait_item_map.get(&(name, did)).is_none() {\n                 let path_str = self.path_names_to_string(&trait_ref.path);\n                 self.resolve_error(span,\n                                     format!(\"method `{}` is not a member of trait `{}`\",\n@@ -4849,7 +4814,7 @@ impl<'a> Resolver<'a> {\n             let map_i = self.binding_mode_map(&**p);\n \n             for (&key, &binding_0) in map_0.iter() {\n-                match map_i.find(&key) {\n+                match map_i.get(&key) {\n                   None => {\n                     self.resolve_error(\n                         p.span,\n@@ -4908,7 +4873,7 @@ impl<'a> Resolver<'a> {\n \n         // Move down in the graph, if there's an anonymous module rooted here.\n         let orig_module = self.current_module.clone();\n-        match orig_module.anonymous_children.borrow().find(&block.id) {\n+        match orig_module.anonymous_children.borrow().get(&block.id) {\n             None => { /* Nothing to do. */ }\n             Some(anonymous_module) => {\n                 debug!(\"(resolving block) found anonymous module, moving \\\n@@ -4943,20 +4908,20 @@ impl<'a> Resolver<'a> {\n \n                     match self.primitive_type_table\n                             .primitive_types\n-                            .find(&id.name) {\n+                            .get(&id.name) {\n \n                         Some(&primitive_type) => {\n                             result_def =\n                                 Some((DefPrimTy(primitive_type), LastMod(AllPublic)));\n \n                             if path.segments\n                                    .iter()\n-                                   .any(|s| !s.lifetimes.is_empty()) {\n+                                   .any(|s| s.parameters.has_lifetimes()) {\n                                 span_err!(self.session, path.span, E0157,\n                                     \"lifetime parameters are not allowed on this type\");\n                             } else if path.segments\n                                           .iter()\n-                                          .any(|s| s.types.len() > 0) {\n+                                          .any(|s| !s.parameters.is_empty()) {\n                                 span_err!(self.session, path.span, E0153,\n                                     \"type parameters are not allowed on this type\");\n                             }\n@@ -5181,7 +5146,7 @@ impl<'a> Resolver<'a> {\n                                                            token::get_ident(\n                                                                ident))\n                                                    .as_slice())\n-                            } else if bindings_list.find(&renamed) ==\n+                            } else if bindings_list.get(&renamed) ==\n                                     Some(&pat_id) {\n                                 // Then this is a duplicate variable in the\n                                 // same disjunction, which is an error.\n@@ -5234,7 +5199,7 @@ impl<'a> Resolver<'a> {\n                     // Check the types in the path pattern.\n                     for ty in path.segments\n                                   .iter()\n-                                  .flat_map(|s| s.types.iter()) {\n+                                  .flat_map(|s| s.parameters.types().into_iter()) {\n                         self.resolve_type(&**ty);\n                     }\n                 }\n@@ -5340,7 +5305,7 @@ impl<'a> Resolver<'a> {\n                     namespace: Namespace,\n                     check_ribs: bool) -> Option<(Def, LastPrivate)> {\n         // First, resolve the types.\n-        for ty in path.segments.iter().flat_map(|s| s.types.iter()) {\n+        for ty in path.segments.iter().flat_map(|s| s.parameters.types().into_iter()) {\n             self.resolve_type(&**ty);\n         }\n \n@@ -5407,7 +5372,7 @@ impl<'a> Resolver<'a> {\n         // First, search children.\n         self.populate_module_if_necessary(&containing_module);\n \n-        match containing_module.children.borrow().find(&name) {\n+        match containing_module.children.borrow().get(&name) {\n             Some(child_name_bindings) => {\n                 match child_name_bindings.def_for_namespace(namespace) {\n                     Some(def) => {\n@@ -5426,7 +5391,7 @@ impl<'a> Resolver<'a> {\n         }\n \n         // Next, search import resolutions.\n-        match containing_module.import_resolutions.borrow().find(&name) {\n+        match containing_module.import_resolutions.borrow().get(&name) {\n             Some(import_resolution) if import_resolution.is_public => {\n                 match (*import_resolution).target_for_namespace(namespace) {\n                     Some(target) => {\n@@ -5715,10 +5680,10 @@ impl<'a> Resolver<'a> {\n             let last_name = name_path.last().unwrap();\n \n             if name_path.len() == 1 {\n-                match this.primitive_type_table.primitive_types.find(last_name) {\n+                match this.primitive_type_table.primitive_types.get(last_name) {\n                     Some(_) => None,\n                     None => {\n-                        match this.current_module.children.borrow().find(last_name) {\n+                        match this.current_module.children.borrow().get(last_name) {\n                             Some(child) => child.get_module_if_available(),\n                             None => None\n                         }\n@@ -5746,10 +5711,10 @@ impl<'a> Resolver<'a> {\n \n         if allowed == Everything {\n             // Look for a field with the same name in the current self_type.\n-            match self.def_map.borrow().find(&node_id) {\n+            match self.def_map.borrow().get(&node_id) {\n                  Some(&DefTy(did, _))\n                 | Some(&DefStruct(did))\n-                | Some(&DefVariant(_, did, _)) => match self.structs.find(&did) {\n+                | Some(&DefVariant(_, did, _)) => match self.structs.get(&did) {\n                     None => {}\n                     Some(fields) => {\n                         if fields.iter().any(|&field_name| name == field_name) {\n@@ -5765,7 +5730,7 @@ impl<'a> Resolver<'a> {\n \n         // Look for a method in the current self type's impl module.\n         match get_module(self, path.span, name_path.as_slice()) {\n-            Some(module) => match module.children.borrow().find(&name) {\n+            Some(module) => match module.children.borrow().get(&name) {\n                 Some(binding) => {\n                     let p_str = self.path_names_to_string(&path);\n                     match binding.def_for_namespace(ValueNS) {\n@@ -5790,7 +5755,7 @@ impl<'a> Resolver<'a> {\n             Some((did, ref trait_ref)) => {\n                 let path_str = self.path_names_to_string(&trait_ref.path);\n \n-                match self.trait_item_map.find(&(name, did)) {\n+                match self.trait_item_map.get(&(name, did)) {\n                     Some(&StaticMethodTraitItemKind) => {\n                         return TraitMethod(path_str)\n                     }\n@@ -6270,7 +6235,7 @@ impl<'a> Resolver<'a> {\n                                   \"unused import\".to_string());\n         }\n \n-        let (v_priv, t_priv) = match self.last_private.find(&id) {\n+        let (v_priv, t_priv) = match self.last_private.get(&id) {\n             Some(&LastImport {\n                 value_priv: v,\n                 value_used: _,"}, {"sha": "8246970c24ad7695ad37943603cbbdb42ed2930a", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -204,9 +204,6 @@ impl<'a> LifetimeContext<'a> {\n                 ast::TraitTyParamBound(ref trait_ref) => {\n                     self.visit_trait_ref(trait_ref);\n                 }\n-                ast::UnboxedFnTyParamBound(ref fn_decl) => {\n-                    self.visit_unboxed_fn_ty_param_bound(&**fn_decl);\n-                }\n                 ast::RegionTyParamBound(ref lifetime) => {\n                     self.visit_lifetime_ref(lifetime);\n                 }\n@@ -226,18 +223,6 @@ impl<'a> LifetimeContext<'a> {\n         })\n     }\n \n-    fn visit_unboxed_fn_ty_param_bound(&mut self,\n-                                       bound: &ast::UnboxedFnBound) {\n-        self.with(|scope, f| {\n-            f(LateScope(bound.ref_id, &bound.lifetimes, scope))\n-        }, |v| {\n-            for argument in bound.decl.inputs.iter() {\n-                v.visit_ty(&*argument.ty);\n-            }\n-            v.visit_ty(&*bound.decl.output);\n-        })\n-    }\n-\n     /// Visits self by adding a scope and handling recursive walk over the contents with `walk`.\n     fn visit_fn_decl(&mut self,\n                      n: ast::NodeId,"}, {"sha": "b64a160ab1f28c915aab829310be1bf3fa21d981", "filename": "src/librustc/middle/save/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -705,7 +705,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                 ast::TraitTyParamBound(ref trait_ref) => {\n                     trait_ref\n                 }\n-                ast::UnboxedFnTyParamBound(..) | ast::RegionTyParamBound(..) => {\n+                ast::RegionTyParamBound(..) => {\n                     continue;\n                 }\n             };"}, {"sha": "7fcc58d8f4e4b4ff75fc10494669ccf77bdf6b1c", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -906,7 +906,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     {\n         let cache = self.pick_candidate_cache(&cache_skol_trait_ref);\n         let hashmap = cache.hashmap.borrow();\n-        hashmap.find(&cache_skol_trait_ref).map(|c| (*c).clone())\n+        hashmap.get(&cache_skol_trait_ref).map(|c| (*c).clone())\n     }\n \n     fn insert_candidate_cache(&mut self,\n@@ -1032,7 +1032,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                self_ty.repr(self.tcx()),\n                obligation.repr(self.tcx()));\n \n-        let closure_kind = match self.typer.unboxed_closures().borrow().find(&closure_def_id) {\n+        let closure_kind = match self.typer.unboxed_closures().borrow().get(&closure_def_id) {\n             Some(closure) => closure.kind,\n             None => {\n                 self.tcx().sess.span_bug(\n@@ -1282,7 +1282,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n                             ty::BoundSync |\n                             ty::BoundSend => {\n-                                if c.bounds.builtin_bounds.contains_elem(bound) {\n+                                if c.bounds.builtin_bounds.contains(&bound) {\n                                     Ok(If(Vec::new()))\n                                 } else {\n                                     Err(Unimplemented)\n@@ -1306,7 +1306,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n                             ty::BoundSync |\n                             ty::BoundSend => {\n-                                if c.bounds.builtin_bounds.contains_elem(bound) {\n+                                if c.bounds.builtin_bounds.contains(&bound) {\n                                     Ok(If(Vec::new()))\n                                 } else {\n                                     Err(Unimplemented)\n@@ -1323,7 +1323,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                         Err(Unimplemented)\n                     }\n                     ty::BoundCopy | ty::BoundSync | ty::BoundSend => {\n-                        if bounds.builtin_bounds.contains_elem(bound) {\n+                        if bounds.builtin_bounds.contains(&bound) {\n                             Ok(If(Vec::new()))\n                         } else {\n                             Err(Unimplemented)\n@@ -1428,7 +1428,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 // is reserve judgement and then intertwine this\n                 // analysis with closure inference.\n                 assert_eq!(def_id.krate, ast::LOCAL_CRATE);\n-                match self.tcx().freevars.borrow().find(&def_id.node) {\n+                match self.tcx().freevars.borrow().get(&def_id.node) {\n                     None => {\n                         // No upvars.\n                         Ok(If(Vec::new()))\n@@ -1690,7 +1690,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                closure_def_id.repr(self.tcx()),\n                substs.repr(self.tcx()));\n \n-        let closure_type = match self.typer.unboxed_closures().borrow().find(&closure_def_id) {\n+        let closure_type = match self.typer.unboxed_closures().borrow().get(&closure_def_id) {\n             Some(closure) => closure.closure_type.clone(),\n             None => {\n                 self.tcx().sess.span_bug(\n@@ -1973,7 +1973,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         ty::populate_implementations_for_trait_if_necessary(self.tcx(),\n                                                             trait_def_id);\n-        match self.tcx().trait_impls.borrow().find(&trait_def_id) {\n+        match self.tcx().trait_impls.borrow().get(&trait_def_id) {\n             None => Vec::new(),\n             Some(impls) => impls.borrow().clone()\n         }"}, {"sha": "e148261b1bf265c0065cef050fbfae08345306cc", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -696,13 +696,13 @@ fn any_irrefutable_adt_pat(tcx: &ty::ctxt, m: &[Match], col: uint) -> bool {\n         match pat.node {\n             ast::PatTup(_) => true,\n             ast::PatStruct(..) => {\n-                match tcx.def_map.borrow().find(&pat.id) {\n+                match tcx.def_map.borrow().get(&pat.id) {\n                     Some(&def::DefVariant(..)) => false,\n                     _ => true,\n                 }\n             }\n             ast::PatEnum(..) | ast::PatIdent(_, _, None) => {\n-                match tcx.def_map.borrow().find(&pat.id) {\n+                match tcx.def_map.borrow().get(&pat.id) {\n                     Some(&def::DefStruct(..)) => true,\n                     _ => false\n                 }"}, {"sha": "0d3a84eb8bcf341219242a2697a7267f17923059", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 20, "deletions": 27, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -49,6 +49,7 @@ use std::num::Int;\n use std::rc::Rc;\n \n use llvm::{ValueRef, True, IntEQ, IntNE};\n+use back::abi::slice_elt_base;\n use middle::subst;\n use middle::subst::Subst;\n use middle::trans::_match;\n@@ -147,7 +148,7 @@ pub fn represent_node(bcx: Block, node: ast::NodeId) -> Rc<Repr> {\n /// Decides how to represent a given type.\n pub fn represent_type(cx: &CrateContext, t: ty::t) -> Rc<Repr> {\n     debug!(\"Representing: {}\", ty_to_string(cx.tcx(), t));\n-    match cx.adt_reprs().borrow().find(&t) {\n+    match cx.adt_reprs().borrow().get(&t) {\n         Some(repr) => return repr.clone(),\n         None => {}\n     }\n@@ -235,7 +236,7 @@ fn represent_type_uncached(cx: &CrateContext, t: ty::t) -> Repr {\n                     if cases[1 - discr].is_zerolen(cx, t) {\n                         let st = mk_struct(cx, cases[discr].tys.as_slice(),\n                                            false, t);\n-                        match cases[discr].find_ptr() {\n+                        match cases[discr].find_ptr(cx) {\n                             Some(ThinPointer(_)) if st.fields.len() == 1 => {\n                                 return RawNullablePointer {\n                                     nndiscr: discr as Disr,\n@@ -290,47 +291,38 @@ struct Case {\n #[deriving(Eq, PartialEq, Show)]\n pub enum PointerField {\n     ThinPointer(uint),\n-    FatPointer(uint, uint)\n+    FatPointer(uint)\n }\n \n impl Case {\n     fn is_zerolen(&self, cx: &CrateContext, scapegoat: ty::t) -> bool {\n         mk_struct(cx, self.tys.as_slice(), false, scapegoat).size == 0\n     }\n \n-    fn find_ptr(&self) -> Option<PointerField> {\n-        use back::abi::{fn_field_code, slice_elt_base, trt_field_box};\n-\n+    fn find_ptr(&self, cx: &CrateContext) -> Option<PointerField> {\n         for (i, &ty) in self.tys.iter().enumerate() {\n             match ty::get(ty).sty {\n-                // &T/&mut T could either be a thin or fat pointer depending on T\n-                ty::ty_rptr(_, ty::mt { ty, .. }) => match ty::get(ty).sty {\n+                // &T/&mut T/Box<T> could either be a thin or fat pointer depending on T\n+                ty::ty_rptr(_, ty::mt { ty, .. }) | ty::ty_uniq(ty) => match ty::get(ty).sty {\n                     // &[T] and &str are a pointer and length pair\n-                    ty::ty_vec(_, None) | ty::ty_str => return Some(FatPointer(i, slice_elt_base)),\n-\n-                    // &Trait/&mut Trait are a pair of pointers: the actual object and a vtable\n-                    ty::ty_trait(..) => return Some(FatPointer(i, trt_field_box)),\n-\n-                    // Any other &T/&mut T is just a pointer\n-                    _ => return Some(ThinPointer(i))\n-                },\n+                    ty::ty_vec(_, None) | ty::ty_str => return Some(FatPointer(i)),\n \n-                // Box<T> could either be a thin or fat pointer depending on T\n-                ty::ty_uniq(t) => match ty::get(t).sty {\n-                    ty::ty_vec(_, None) => return Some(FatPointer(i, slice_elt_base)),\n+                    // &Trait is a pair of pointers: the actual object and a vtable\n+                    ty::ty_trait(..) => return Some(FatPointer(i)),\n \n-                    // Box<Trait> is a pair of pointers: the actual object and a vtable\n-                    ty::ty_trait(..) => return Some(FatPointer(i, trt_field_box)),\n+                    ty::ty_struct(..) if !ty::type_is_sized(cx.tcx(), ty) => {\n+                        return Some(FatPointer(i))\n+                    }\n \n-                    // Any other Box<T> is just a pointer\n+                    // Any other &T is just a pointer\n                     _ => return Some(ThinPointer(i))\n                 },\n \n                 // Functions are just pointers\n                 ty::ty_bare_fn(..) => return Some(ThinPointer(i)),\n \n                 // Closures are a pair of pointers: the code and environment\n-                ty::ty_closure(..) => return Some(FatPointer(i, fn_field_code)),\n+                ty::ty_closure(..) => return Some(FatPointer(i)),\n \n                 // Anything else is not a pointer\n                 _ => continue\n@@ -636,6 +628,7 @@ pub fn trans_get_discr(bcx: Block, r: &Repr, scrutinee: ValueRef, cast_to: Optio\n     -> ValueRef {\n     let signed;\n     let val;\n+    debug!(\"trans_get_discr r: {}\", r);\n     match *r {\n         CEnum(ity, min, max) => {\n             val = load_discr(bcx, ity, scrutinee, min, max);\n@@ -671,7 +664,7 @@ fn struct_wrapped_nullable_bitdiscr(bcx: Block, nndiscr: Disr, ptrfield: Pointer\n                                     scrutinee: ValueRef) -> ValueRef {\n     let llptrptr = match ptrfield {\n         ThinPointer(field) => GEPi(bcx, scrutinee, [0, field]),\n-        FatPointer(field, pair) => GEPi(bcx, scrutinee, [0, field, pair])\n+        FatPointer(field) => GEPi(bcx, scrutinee, [0, field, slice_elt_base])\n     };\n     let llptr = Load(bcx, llptrptr);\n     let cmp = if nndiscr == 0 { IntEQ } else { IntNE };\n@@ -767,8 +760,8 @@ pub fn trans_set_discr(bcx: Block, r: &Repr, val: ValueRef, discr: Disr) {\n                     ThinPointer(field) =>\n                         (GEPi(bcx, val, [0, field]),\n                          type_of::type_of(bcx.ccx(), nonnull.fields[field])),\n-                    FatPointer(field, pair) => {\n-                        let v = GEPi(bcx, val, [0, field, pair]);\n+                    FatPointer(field) => {\n+                        let v = GEPi(bcx, val, [0, field, slice_elt_base]);\n                         (v, val_ty(v).element_type())\n                     }\n                 };\n@@ -1102,7 +1095,7 @@ pub fn const_get_discrim(ccx: &CrateContext, r: &Repr, val: ValueRef)\n         StructWrappedNullablePointer { nndiscr, ptrfield, .. } => {\n             let (idx, sub_idx) = match ptrfield {\n                 ThinPointer(field) => (field, None),\n-                FatPointer(field, pair) => (field, Some(pair))\n+                FatPointer(field) => (field, Some(slice_elt_base))\n             };\n             if is_null(const_struct_field(ccx, val, idx, sub_idx)) {\n                 /* subtraction as uint is ok because nndiscr is either 0 or 1 */"}, {"sha": "0d8ef560c7d57c3f8fad5617eebf4b71224a340d", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -316,7 +316,7 @@ pub fn get_extern_const(ccx: &CrateContext, did: ast::DefId,\n                         t: ty::t) -> ValueRef {\n     let name = csearch::get_symbol(&ccx.sess().cstore, did);\n     let ty = type_of(ccx, t);\n-    match ccx.externs().borrow_mut().find(&name) {\n+    match ccx.externs().borrow_mut().get(&name) {\n         Some(n) => return *n,\n         None => ()\n     }\n@@ -409,7 +409,7 @@ pub fn malloc_raw_dyn_proc<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: ty::t) -> Resu\n // Type descriptor and type glue stuff\n \n pub fn get_tydesc(ccx: &CrateContext, t: ty::t) -> Rc<tydesc_info> {\n-    match ccx.tydescs().borrow().find(&t) {\n+    match ccx.tydescs().borrow().get(&t) {\n         Some(inf) => return inf.clone(),\n         _ => { }\n     }\n@@ -1836,11 +1836,7 @@ pub fn trans_closure(ccx: &CrateContext,\n         NotUnboxedClosure => monomorphized_arg_types,\n \n         // Tuple up closure argument types for the \"rust-call\" ABI.\n-        IsUnboxedClosure => vec![if monomorphized_arg_types.is_empty() {\n-            ty::mk_nil()\n-        } else {\n-            ty::mk_tup(ccx.tcx(), monomorphized_arg_types)\n-        }]\n+        IsUnboxedClosure => vec![ty::mk_tup_or_nil(ccx.tcx(), monomorphized_arg_types)]\n     };\n     for monomorphized_arg_type in monomorphized_arg_types.iter() {\n         debug!(\"trans_closure: monomorphized_arg_type: {}\",\n@@ -2100,7 +2096,7 @@ fn enum_variant_size_lint(ccx: &CrateContext, enum_def: &ast::EnumDef, sp: Span,\n \n     let levels = ccx.tcx().node_lint_levels.borrow();\n     let lint_id = lint::LintId::of(lint::builtin::VARIANT_SIZE_DIFFERENCES);\n-    let lvlsrc = match levels.find(&(id, lint_id)) {\n+    let lvlsrc = match levels.get(&(id, lint_id)) {\n         None | Some(&(lint::Allow, _)) => return,\n         Some(&lvlsrc) => lvlsrc,\n     };\n@@ -2645,7 +2641,7 @@ pub fn create_entry_wrapper(ccx: &CrateContext,\n \n fn exported_name(ccx: &CrateContext, id: ast::NodeId,\n                  ty: ty::t, attrs: &[ast::Attribute]) -> String {\n-    match ccx.external_srcs().borrow().find(&id) {\n+    match ccx.external_srcs().borrow().get(&id) {\n         Some(&did) => {\n             let sym = csearch::get_symbol(&ccx.sess().cstore, did);\n             debug!(\"found item {} in other crate...\", sym);\n@@ -3123,7 +3119,7 @@ pub fn trans_crate<'tcx>(analysis: CrateAnalysis<'tcx>)\n         .collect();\n \n     let mut reachable: Vec<String> = shared_ccx.reachable().iter().filter_map(|id| {\n-        shared_ccx.item_symbols().borrow().find(id).map(|s| s.to_string())\n+        shared_ccx.item_symbols().borrow().get(id).map(|s| s.to_string())\n     }).collect();\n \n     // For the purposes of LTO, we add to the reachable set all of the upstream"}, {"sha": "3ae4fdf0838e8ebd368cb646622a8043a1de4191", "filename": "src/librustc/middle/trans/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -655,7 +655,7 @@ pub fn _UndefReturn(cx: Block, fn_: ValueRef) -> ValueRef {\n     unsafe {\n         let ccx = cx.fcx.ccx;\n         let ty = val_ty(fn_);\n-        let retty = if ty.kind() == llvm::Integer {\n+        let retty = if ty.kind() == llvm::Function {\n             ty.return_type()\n         } else {\n             ccx.int_type()"}, {"sha": "b692b01f765d51f9526b413967158b42cfccac74", "filename": "src/librustc/middle/trans/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -81,7 +81,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 s.push('/');\n                 s.push_str(category);\n \n-                let n = match h.find(&s) {\n+                let n = match h.get(&s) {\n                     Some(&n) => n,\n                     _ => 0u\n                 };"}, {"sha": "16db4daba46b8ba767aa99ebef481f1f192dfcfc", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -438,7 +438,7 @@ pub fn get_or_create_declaration_if_unboxed_closure<'blk, 'tcx>(bcx: Block<'blk,\n         params: params\n     };\n \n-    match ccx.unboxed_closure_vals().borrow().find(&mono_id) {\n+    match ccx.unboxed_closure_vals().borrow().get(&mono_id) {\n         Some(llfn) => {\n             debug!(\"get_or_create_declaration_if_unboxed_closure(): found \\\n                     closure\");\n@@ -564,7 +564,7 @@ pub fn get_wrapper_for_bare_fn(ccx: &CrateContext,\n         }\n     };\n \n-    match ccx.closure_bare_wrapper_cache().borrow().find(&fn_ptr) {\n+    match ccx.closure_bare_wrapper_cache().borrow().get(&fn_ptr) {\n         Some(&llval) => return llval,\n         None => {}\n     }"}, {"sha": "18501dd9e34cb23c266ef8e4b07a8f7970491361", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -466,7 +466,7 @@ impl<'blk, 'tcx> BlockS<'blk, 'tcx> {\n     }\n \n     pub fn def(&self, nid: ast::NodeId) -> def::Def {\n-        match self.tcx().def_map.borrow().find(&nid) {\n+        match self.tcx().def_map.borrow().get(&nid) {\n             Some(v) => v.clone(),\n             None => {\n                 self.tcx().sess.bug(format!(\n@@ -505,7 +505,7 @@ impl<'blk, 'tcx> mc::Typer<'tcx> for BlockS<'blk, 'tcx> {\n         self.tcx()\n             .method_map\n             .borrow()\n-            .find(&method_call)\n+            .get(&method_call)\n             .map(|method| monomorphize_type(self, method.ty))\n     }\n \n@@ -647,7 +647,7 @@ pub fn C_u8(ccx: &CrateContext, i: uint) -> ValueRef {\n // our boxed-and-length-annotated strings.\n pub fn C_cstr(cx: &CrateContext, s: InternedString, null_terminated: bool) -> ValueRef {\n     unsafe {\n-        match cx.const_cstr_cache().borrow().find(&s) {\n+        match cx.const_cstr_cache().borrow().get(&s) {\n             Some(&llval) => return llval,\n             None => ()\n         }\n@@ -813,7 +813,7 @@ pub fn fulfill_obligation(ccx: &CrateContext,\n     let trait_ref = ty_fold::erase_regions(tcx, trait_ref);\n \n     // First check the cache.\n-    match ccx.trait_cache().borrow().find(&trait_ref) {\n+    match ccx.trait_cache().borrow().get(&trait_ref) {\n         Some(vtable) => {\n             info!(\"Cache hit: {}\", trait_ref.repr(ccx.tcx()));\n             return (*vtable).clone();"}, {"sha": "409809e0cb33b006324e2ec9683c7b385c822ff3", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -90,7 +90,7 @@ pub fn const_lit(cx: &CrateContext, e: &ast::Expr, lit: &ast::Lit)\n pub fn const_ptrcast(cx: &CrateContext, a: ValueRef, t: Type) -> ValueRef {\n     unsafe {\n         let b = llvm::LLVMConstPointerCast(a, t.ptr_to().to_ref());\n-        assert!(cx.const_globals().borrow_mut().insert(b as int, a));\n+        assert!(cx.const_globals().borrow_mut().insert(b as int, a).is_none());\n         b\n     }\n }\n@@ -125,7 +125,7 @@ pub fn const_addr_of(cx: &CrateContext, cv: ValueRef, mutbl: ast::Mutability) ->\n }\n \n fn const_deref_ptr(cx: &CrateContext, v: ValueRef) -> ValueRef {\n-    let v = match cx.const_globals().borrow().find(&(v as int)) {\n+    let v = match cx.const_globals().borrow().get(&(v as int)) {\n         Some(&v) => v,\n         None => v\n     };\n@@ -625,7 +625,7 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr) -> ValueRef {\n           }\n           ast::ExprPath(ref pth) => {\n             // Assert that there are no type parameters in this path.\n-            assert!(pth.segments.iter().all(|seg| seg.types.is_empty()));\n+            assert!(pth.segments.iter().all(|seg| !seg.parameters.has_types()));\n \n             let opt_def = cx.tcx().def_map.borrow().find_copy(&e.id);\n             match opt_def {"}, {"sha": "714d5ab248d5ede123622e48867934f012eeaf90", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -421,7 +421,7 @@ pub fn trans_break_cont<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let loop_id = match opt_label {\n         None => fcx.top_loop_scope(),\n         Some(_) => {\n-            match bcx.tcx().def_map.borrow().find(&expr_id) {\n+            match bcx.tcx().def_map.borrow().get(&expr_id) {\n                 Some(&def::DefLabel(loop_id)) => loop_id,\n                 ref r => {\n                     bcx.tcx().sess.bug(format!(\"{} in def-map for label\","}, {"sha": "8309811cf0b45afaa470a4a0b946d605ca77ee60", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -282,7 +282,7 @@ impl TypeMap {\n                                    cx: &CrateContext,\n                                    type_: ty::t,\n                                    metadata: DIType) {\n-        if !self.type_to_metadata.insert(ty::type_id(type_), metadata) {\n+        if self.type_to_metadata.insert(ty::type_id(type_), metadata).is_some() {\n             cx.sess().bug(format!(\"Type metadata for ty::t '{}' is already in the TypeMap!\",\n                                    ppaux::ty_to_string(cx.tcx(), type_)).as_slice());\n         }\n@@ -294,7 +294,7 @@ impl TypeMap {\n                                         cx: &CrateContext,\n                                         unique_type_id: UniqueTypeId,\n                                         metadata: DIType) {\n-        if !self.unique_id_to_metadata.insert(unique_type_id, metadata) {\n+        if self.unique_id_to_metadata.insert(unique_type_id, metadata).is_some() {\n             let unique_type_id_str = self.get_unique_type_id_as_string(unique_type_id);\n             cx.sess().bug(format!(\"Type metadata for unique id '{}' is already in the TypeMap!\",\n                                   unique_type_id_str.as_slice()).as_slice());\n@@ -468,7 +468,7 @@ impl TypeMap {\n             },\n             ty::ty_unboxed_closure(ref def_id, _, ref substs) => {\n                 let closure_ty = cx.tcx().unboxed_closures.borrow()\n-                                   .find(def_id).unwrap().closure_type.subst(cx.tcx(), substs);\n+                                   .get(def_id).unwrap().closure_type.subst(cx.tcx(), substs);\n                 self.get_unique_type_id_of_closure_type(cx,\n                                                         closure_ty,\n                                                         &mut unique_type_id);\n@@ -2255,7 +2255,7 @@ impl EnumMemberDescriptionFactory {\n                 let null_variant_name = token::get_name((*self.variants)[null_variant_index].name);\n                 let discrfield = match ptrfield {\n                     adt::ThinPointer(field) => format!(\"{}\", field),\n-                    adt::FatPointer(field, pair) => format!(\"{}${}\", field, pair)\n+                    adt::FatPointer(field) => format!(\"{}\", field)\n                 };\n                 let union_member_name = format!(\"RUST$ENCODED$ENUM${}${}\",\n                                                 discrfield,\n@@ -2939,7 +2939,7 @@ fn type_metadata(cx: &CrateContext,\n         }\n         ty::ty_unboxed_closure(ref def_id, _, ref substs) => {\n             let sig = cx.tcx().unboxed_closures.borrow()\n-                        .find(def_id).unwrap().closure_type.sig.subst(cx.tcx(), substs);\n+                        .get(def_id).unwrap().closure_type.sig.subst(cx.tcx(), substs);\n             subroutine_type_metadata(cx, unique_type_id, &sig, usage_site_span)\n         }\n         ty::ty_struct(def_id, ref substs) => {"}, {"sha": "399be73329bd51d4371f5fa88c65ec2d2688fdf9", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 36, "deletions": 15, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -212,7 +212,7 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                         // Don't skip a conversion from Box<T> to &T, etc.\n                         ty::ty_rptr(..) => {\n                             let method_call = MethodCall::autoderef(expr.id, adj.autoderefs-1);\n-                            let method = bcx.tcx().method_map.borrow().find(&method_call).is_some();\n+                            let method = bcx.tcx().method_map.borrow().get(&method_call).is_some();\n                             if method {\n                                 // Don't skip an overloaded deref.\n                                 (adj.autoderefs, true)\n@@ -601,7 +601,7 @@ fn trans_datum_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let method_ty = ccx.tcx()\n                                .method_map\n                                .borrow()\n-                               .find(&method_call)\n+                               .get(&method_call)\n                                .map(|method| method.ty);\n             let base_datum = unpack_datum!(bcx, trans(bcx, &**base));\n \n@@ -736,7 +736,7 @@ fn trans_index<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let method_ty = ccx.tcx()\n                        .method_map\n                        .borrow()\n-                       .find(&method_call)\n+                       .get(&method_call)\n                        .map(|method| method.ty);\n     let elt_datum = match method_ty {\n         Some(method_ty) => {\n@@ -1114,7 +1114,7 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             if ty::type_is_trait(node_id_type(bcx, expr.id)) {\n                 let trait_ref =\n                     bcx.tcx().object_cast_map.borrow()\n-                                             .find(&expr.id)\n+                                             .get(&expr.id)\n                                              .map(|t| (*t).clone())\n                                              .unwrap();\n                 let trait_ref =\n@@ -1232,7 +1232,7 @@ pub fn trans_local_var<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         def::DefUpvar(nid, _, _) => {\n             // Can't move upvars, so this is never a ZeroMemLastUse.\n             let local_ty = node_id_type(bcx, nid);\n-            match bcx.fcx.llupvars.borrow().find(&nid) {\n+            match bcx.fcx.llupvars.borrow().get(&nid) {\n                 Some(&val) => Datum::new(val, local_ty, Lvalue),\n                 None => {\n                     bcx.sess().bug(format!(\n@@ -1242,7 +1242,7 @@ pub fn trans_local_var<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             }\n         }\n         def::DefLocal(nid) => {\n-            let datum = match bcx.fcx.lllocals.borrow().find(&nid) {\n+            let datum = match bcx.fcx.lllocals.borrow().get(&nid) {\n                 Some(&v) => v,\n                 None => {\n                     bcx.sess().bug(format!(\n@@ -1461,14 +1461,35 @@ pub fn trans_adt<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         None => {}\n     };\n \n-    // Now, we just overwrite the fields we've explicitly specified\n-    for &(i, ref e) in fields.iter() {\n-        let dest = adt::trans_field_ptr(bcx, &*repr, addr, discr, i);\n-        let e_ty = expr_ty_adjusted(bcx, &**e);\n-        bcx = trans_into(bcx, &**e, SaveIn(dest));\n-        let scope = cleanup::CustomScope(custom_cleanup_scope);\n-        fcx.schedule_lifetime_end(scope, dest);\n-        fcx.schedule_drop_mem(scope, dest, e_ty);\n+    if ty::type_is_simd(bcx.tcx(), ty) {\n+        // This is the constructor of a SIMD type, such types are\n+        // always primitive machine types and so do not have a\n+        // destructor or require any clean-up.\n+        let llty = type_of::type_of(bcx.ccx(), ty);\n+\n+        // keep a vector as a register, and running through the field\n+        // `insertelement`ing them directly into that register\n+        // (i.e. avoid GEPi and `store`s to an alloca) .\n+        let mut vec_val = C_undef(llty);\n+\n+        for &(i, ref e) in fields.iter() {\n+            let block_datum = trans(bcx, &**e);\n+            bcx = block_datum.bcx;\n+            let position = C_uint(bcx.ccx(), i);\n+            let value = block_datum.datum.to_llscalarish(bcx);\n+            vec_val = InsertElement(bcx, vec_val, value, position);\n+        }\n+        Store(bcx, vec_val, addr);\n+    } else {\n+        // Now, we just overwrite the fields we've explicitly specified\n+        for &(i, ref e) in fields.iter() {\n+            let dest = adt::trans_field_ptr(bcx, &*repr, addr, discr, i);\n+            let e_ty = expr_ty_adjusted(bcx, &**e);\n+            bcx = trans_into(bcx, &**e, SaveIn(dest));\n+            let scope = cleanup::CustomScope(custom_cleanup_scope);\n+            fcx.schedule_lifetime_end(scope, dest);\n+            fcx.schedule_drop_mem(scope, dest, e_ty);\n+        }\n     }\n \n     adt::trans_set_discr(bcx, &*repr, addr, discr);\n@@ -2089,7 +2110,7 @@ fn deref_once<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     // Check for overloaded deref.\n     let method_ty = ccx.tcx().method_map.borrow()\n-                       .find(&method_call).map(|method| method.ty);\n+                       .get(&method_call).map(|method| method.ty);\n     let datum = match method_ty {\n         Some(method_ty) => {\n             // Overloaded. Evaluate `trans_overloaded_op`, which will"}, {"sha": "eb6e67efd49a6d598208e81de5e7ccf3f62ce176", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -144,7 +144,7 @@ pub fn get_drop_glue(ccx: &CrateContext, t: ty::t) -> ValueRef {\n     debug!(\"make drop glue for {}\", ppaux::ty_to_string(ccx.tcx(), t));\n     let t = get_drop_glue_type(ccx, t);\n     debug!(\"drop glue type {}\", ppaux::ty_to_string(ccx.tcx(), t));\n-    match ccx.drop_glues().borrow().find(&t) {\n+    match ccx.drop_glues().borrow().get(&t) {\n         Some(&glue) => return glue,\n         _ => { }\n     }\n@@ -157,7 +157,7 @@ pub fn get_drop_glue(ccx: &CrateContext, t: ty::t) -> ValueRef {\n \n     let llfnty = Type::glue_fn(ccx, llty);\n \n-    let (glue, new_sym) = match ccx.available_drop_glues().borrow().find(&t) {\n+    let (glue, new_sym) = match ccx.available_drop_glues().borrow().get(&t) {\n         Some(old_sym) => {\n             let glue = decl_cdecl_fn(ccx, old_sym.as_slice(), llfnty, ty::mk_nil());\n             (glue, None)"}, {"sha": "65d7749b489272d5304d49f9edd403a294dae0f1", "filename": "src/librustc/middle/trans/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -21,7 +21,7 @@ use syntax::ast_util::{local_def, PostExpansionMethod};\n fn instantiate_inline(ccx: &CrateContext, fn_id: ast::DefId)\n     -> Option<ast::DefId> {\n     let _icx = push_ctxt(\"maybe_instantiate_inline\");\n-    match ccx.external().borrow().find(&fn_id) {\n+    match ccx.external().borrow().get(&fn_id) {\n         Some(&Some(node_id)) => {\n             // Already inline\n             debug!(\"maybe_instantiate_inline({}): already inline as node id {}\","}, {"sha": "0ae728c71ee63dcf827c538efd8111d219febffb", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -116,7 +116,7 @@ pub fn trans_method_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let (origin, method_ty) =\n         bcx.tcx().method_map\n                  .borrow()\n-                 .find(&method_call)\n+                 .get(&method_call)\n                  .map(|method| (method.origin.clone(), method.ty))\n                  .unwrap();\n \n@@ -308,7 +308,7 @@ fn method_with_name(ccx: &CrateContext, impl_id: ast::DefId, name: ast::Name)\n \n     let impl_items = ccx.tcx().impl_items.borrow();\n     let impl_items =\n-        impl_items.find(&impl_id)\n+        impl_items.get(&impl_id)\n                   .expect(\"could not find impl while translating\");\n     let meth_did = impl_items.iter()\n                              .find(|&did| {\n@@ -559,7 +559,7 @@ pub fn get_vtable(bcx: Block,\n \n     // Check the cache.\n     let cache_key = (box_ty, trait_ref.clone());\n-    match ccx.vtables().borrow().find(&cache_key) {\n+    match ccx.vtables().borrow().get(&cache_key) {\n         Some(&val) => { return val }\n         None => { }\n     }\n@@ -599,7 +599,7 @@ pub fn get_vtable(bcx: Block,\n                                               .unboxed_closures\n                                               .borrow();\n                     let closure_info =\n-                        unboxed_closures.find(&closure_def_id)\n+                        unboxed_closures.get(&closure_def_id)\n                                         .expect(\"get_vtable(): didn't find \\\n                                                  unboxed closure\");\n                     if closure_info.kind == ty::FnOnceUnboxedClosureKind {"}, {"sha": "f9d42240f35b7bcb37232982f2c7baf8f961cb7b", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -54,7 +54,7 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n         params: real_substs.types.clone()\n     };\n \n-    match ccx.monomorphized().borrow().find(&hash_id) {\n+    match ccx.monomorphized().borrow().get(&hash_id) {\n         Some(&val) => {\n             debug!(\"leaving monomorphic fn {}\",\n             ty::item_path_str(ccx.tcx(), fn_id));\n@@ -106,7 +106,7 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n     let depth;\n     {\n         let mut monomorphizing = ccx.monomorphizing().borrow_mut();\n-        depth = match monomorphizing.find(&fn_id) {\n+        depth = match monomorphizing.get(&fn_id) {\n             Some(&d) => d, None => 0\n         };\n "}, {"sha": "175b0d7adde0a5494fa9feb861fd217a895ace0e", "filename": "src/librustc/middle/trans/type_.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -332,7 +332,7 @@ impl TypeNames {\n \n     pub fn associate_type(&self, s: &str, t: &Type) {\n         assert!(self.named_types.borrow_mut().insert(s.to_string(),\n-                                                     t.to_ref()));\n+                                                     t.to_ref()).is_none());\n     }\n \n     pub fn find_type(&self, s: &str) -> Option<Type> {"}, {"sha": "d1b8f767bc85018e312b2e028b743b7d80f22332", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -272,7 +272,7 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n     }\n \n     // Check the cache.\n-    match cx.lltypes().borrow().find(&t) {\n+    match cx.lltypes().borrow().get(&t) {\n         Some(&llty) => return llty,\n         None => ()\n     }"}, {"sha": "d1baeac81ab3a89b38466a228c1ff362b9cff13d", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 36, "deletions": 28, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -1080,14 +1080,14 @@ pub enum BuiltinBound {\n }\n \n pub fn empty_builtin_bounds() -> BuiltinBounds {\n-    EnumSet::empty()\n+    EnumSet::new()\n }\n \n pub fn all_builtin_bounds() -> BuiltinBounds {\n-    let mut set = EnumSet::empty();\n-    set.add(BoundSend);\n-    set.add(BoundSized);\n-    set.add(BoundSync);\n+    let mut set = EnumSet::new();\n+    set.insert(BoundSend);\n+    set.insert(BoundSized);\n+    set.insert(BoundSync);\n     set\n }\n \n@@ -1584,7 +1584,7 @@ pub fn mk_t(cx: &ctxt, st: sty) -> t {\n \n     let key = intern_key { sty: &st };\n \n-    match cx.interner.borrow().find(&key) {\n+    match cx.interner.borrow().get(&key) {\n         Some(t) => unsafe { return mem::transmute(&t.sty); },\n         _ => ()\n     }\n@@ -1838,6 +1838,14 @@ pub fn mk_slice(cx: &ctxt, r: Region, tm: mt) -> t {\n \n pub fn mk_tup(cx: &ctxt, ts: Vec<t>) -> t { mk_t(cx, ty_tup(ts)) }\n \n+pub fn mk_tup_or_nil(cx: &ctxt, ts: Vec<t>) -> t {\n+    if ts.len() == 0 {\n+        ty::mk_nil()\n+    } else {\n+        mk_t(cx, ty_tup(ts))\n+    }\n+}\n+\n pub fn mk_closure(cx: &ctxt, fty: ClosureTy) -> t {\n     mk_t(cx, ty_closure(box fty))\n }\n@@ -2418,11 +2426,11 @@ pub fn type_contents(cx: &ctxt, ty: t) -> TypeContents {\n         // value for the type contents of list.  The correct value is\n         // TC::OwnsOwned.  This manifested as issue #4821.\n         let ty_id = type_id(ty);\n-        match cache.find(&ty_id) {\n+        match cache.get(&ty_id) {\n             Some(tc) => { return *tc; }\n             None => {}\n         }\n-        match cx.tc_cache.borrow().find(&ty_id) {    // Must check both caches!\n+        match cx.tc_cache.borrow().get(&ty_id) {    // Must check both caches!\n             Some(tc) => { return *tc; }\n             None => {}\n         }\n@@ -3192,7 +3200,7 @@ pub fn array_element_ty(t: t) -> Option<t> {\n }\n \n pub fn node_id_to_trait_ref(cx: &ctxt, id: ast::NodeId) -> Rc<ty::TraitRef> {\n-    match cx.trait_refs.borrow().find(&id) {\n+    match cx.trait_refs.borrow().get(&id) {\n         Some(t) => t.clone(),\n         None => cx.sess.bug(\n             format!(\"node_id_to_trait_ref: no trait ref for node `{}`\",\n@@ -3214,14 +3222,14 @@ pub fn node_id_to_type(cx: &ctxt, id: ast::NodeId) -> t {\n }\n \n pub fn node_id_to_type_opt(cx: &ctxt, id: ast::NodeId) -> Option<t> {\n-    match cx.node_types.borrow().find(&(id as uint)) {\n+    match cx.node_types.borrow().get(&(id as uint)) {\n        Some(&t) => Some(t),\n        None => None\n     }\n }\n \n pub fn node_id_item_substs(cx: &ctxt, id: ast::NodeId) -> ItemSubsts {\n-    match cx.item_substs.borrow().find(&id) {\n+    match cx.item_substs.borrow().get(&id) {\n       None => ItemSubsts::empty(),\n       Some(ts) => ts.clone(),\n     }\n@@ -3361,8 +3369,8 @@ pub fn expr_ty_adjusted(cx: &ctxt, expr: &ast::Expr) -> t {\n      */\n \n     adjust_ty(cx, expr.span, expr.id, expr_ty(cx, expr),\n-              cx.adjustments.borrow().find(&expr.id),\n-              |method_call| cx.method_map.borrow().find(&method_call).map(|method| method.ty))\n+              cx.adjustments.borrow().get(&expr.id),\n+              |method_call| cx.method_map.borrow().get(&method_call).map(|method| method.ty))\n }\n \n pub fn expr_span(cx: &ctxt, id: NodeId) -> Span {\n@@ -3553,7 +3561,7 @@ pub fn unsize_ty(cx: &ctxt,\n }\n \n pub fn resolve_expr(tcx: &ctxt, expr: &ast::Expr) -> def::Def {\n-    match tcx.def_map.borrow().find(&expr.id) {\n+    match tcx.def_map.borrow().get(&expr.id) {\n         Some(&def) => def,\n         None => {\n             tcx.sess.span_bug(expr.span, format!(\n@@ -3690,7 +3698,7 @@ pub fn expr_kind(tcx: &ctxt, expr: &ast::Expr) -> ExprKind {\n         }\n \n         ast::ExprCast(..) => {\n-            match tcx.node_types.borrow().find(&(expr.id as uint)) {\n+            match tcx.node_types.borrow().get(&(expr.id as uint)) {\n                 Some(&t) => {\n                     if type_is_trait(t) {\n                         RvalueDpsExpr\n@@ -3736,7 +3744,7 @@ pub fn expr_kind(tcx: &ctxt, expr: &ast::Expr) -> ExprKind {\n \n         ast::ExprBox(ref place, _) => {\n             // Special case `Box<T>` for now:\n-            let definition = match tcx.def_map.borrow().find(&place.id) {\n+            let definition = match tcx.def_map.borrow().get(&place.id) {\n                 Some(&def) => def,\n                 None => panic!(\"no def for place\"),\n             };\n@@ -4003,7 +4011,7 @@ pub fn note_and_explain_type_err(cx: &ctxt, err: &type_err) {\n }\n \n pub fn provided_source(cx: &ctxt, id: ast::DefId) -> Option<ast::DefId> {\n-    cx.provided_method_sources.borrow().find(&id).map(|x| *x)\n+    cx.provided_method_sources.borrow().get(&id).map(|x| *x)\n }\n \n pub fn provided_trait_methods(cx: &ctxt, id: ast::DefId) -> Vec<Rc<Method>> {\n@@ -4113,7 +4121,7 @@ pub fn impl_or_trait_item(cx: &ctxt, id: ast::DefId) -> ImplOrTraitItem {\n pub fn is_associated_type(cx: &ctxt, id: ast::DefId) -> bool {\n     memoized(&cx.associated_types, id, |id: ast::DefId| {\n         if id.krate == ast::LOCAL_CRATE {\n-            match cx.impl_or_trait_items.borrow().find(&id) {\n+            match cx.impl_or_trait_items.borrow().get(&id) {\n                 Some(ref item) => {\n                     match **item {\n                         TypeTraitItem(_) => true,\n@@ -4198,7 +4206,7 @@ pub fn impl_trait_ref(cx: &ctxt, id: ast::DefId) -> Option<Rc<TraitRef>> {\n \n pub fn trait_ref_to_def_id(tcx: &ctxt, tr: &ast::TraitRef) -> ast::DefId {\n     let def = *tcx.def_map.borrow()\n-                     .find(&tr.ref_id)\n+                     .get(&tr.ref_id)\n                      .expect(\"no def-map entry for trait\");\n     def.def_id()\n }\n@@ -4215,7 +4223,7 @@ pub fn try_add_builtin_trait(\n     //! is a builtin trait.\n \n     match tcx.lang_items.to_builtin_kind(trait_def_id) {\n-        Some(bound) => { builtin_bounds.add(bound); true }\n+        Some(bound) => { builtin_bounds.insert(bound); true }\n         None => false\n     }\n }\n@@ -4346,7 +4354,7 @@ impl DtorKind {\n /* If struct_id names a struct with a dtor, return Some(the dtor's id).\n    Otherwise return none. */\n pub fn ty_dtor(cx: &ctxt, struct_id: DefId) -> DtorKind {\n-    match cx.destructor_for_type.borrow().find(&struct_id) {\n+    match cx.destructor_for_type.borrow().get(&struct_id) {\n         Some(&method_def_id) => {\n             let flag = !has_attr(cx, struct_id, \"unsafe_no_drop_flag\");\n \n@@ -4569,7 +4577,7 @@ pub fn lookup_field_type(tcx: &ctxt,\n pub fn lookup_struct_fields(cx: &ctxt, did: ast::DefId) -> Vec<field_ty> {\n     if did.krate == ast::LOCAL_CRATE {\n         let struct_fields = cx.struct_fields.borrow();\n-        match struct_fields.find(&did) {\n+        match struct_fields.get(&did) {\n             Some(fields) => (**fields).clone(),\n             _ => {\n                 cx.sess.bug(\n@@ -4632,7 +4640,7 @@ pub fn unboxed_closure_upvars(tcx: &ctxt, closure_id: ast::DefId, substs: &Subst\n     // implemented.\n     assert!(closure_id.krate == ast::LOCAL_CRATE);\n     let capture_mode = tcx.capture_modes.borrow().get_copy(&closure_id.node);\n-    match tcx.freevars.borrow().find(&closure_id.node) {\n+    match tcx.freevars.borrow().get(&closure_id.node) {\n         None => vec![],\n         Some(ref freevars) => {\n             freevars.iter().map(|freevar| {\n@@ -4898,7 +4906,7 @@ pub fn required_region_bounds(tcx: &ctxt,\n                           all_bounds: &mut Vec<ty::Region>) {\n         all_bounds.push_all(region_bounds.as_slice());\n \n-        if builtin_bounds.contains_elem(ty::BoundSend) {\n+        if builtin_bounds.contains(&ty::BoundSend) {\n             all_bounds.push(ty::ReStatic);\n         }\n     }\n@@ -4921,7 +4929,7 @@ pub fn item_variances(tcx: &ctxt, item_id: ast::DefId) -> Rc<ItemVariances> {\n pub fn record_trait_implementation(tcx: &ctxt,\n                                    trait_def_id: DefId,\n                                    impl_def_id: DefId) {\n-    match tcx.trait_impls.borrow().find(&trait_def_id) {\n+    match tcx.trait_impls.borrow().get(&trait_def_id) {\n         Some(impls_for_trait) => {\n             impls_for_trait.borrow_mut().push(impl_def_id);\n             return;\n@@ -5094,7 +5102,7 @@ pub fn trait_of_item(tcx: &ctxt, def_id: ast::DefId) -> Option<ast::DefId> {\n /// Otherwise, return `None`.\n pub fn trait_item_of_item(tcx: &ctxt, def_id: ast::DefId)\n                           -> Option<ImplOrTraitItemId> {\n-    let impl_item = match tcx.impl_or_trait_items.borrow().find(&def_id) {\n+    let impl_item = match tcx.impl_or_trait_items.borrow().get(&def_id) {\n         Some(m) => m.clone(),\n         None => return None,\n     };\n@@ -5449,7 +5457,7 @@ impl<'tcx> mc::Typer<'tcx> for ty::ctxt<'tcx> {\n     }\n \n     fn node_method_ty(&self, method_call: typeck::MethodCall) -> Option<ty::t> {\n-        self.method_map.borrow().find(&method_call).map(|method| method.ty)\n+        self.method_map.borrow().get(&method_call).map(|method| method.ty)\n     }\n \n     fn adjustments<'a>(&'a self) -> &'a RefCell<NodeMap<ty::AutoAdjustment>> {\n@@ -5561,7 +5569,7 @@ pub type FreevarMap = NodeMap<Vec<Freevar>>;\n pub type CaptureModeMap = NodeMap<ast::CaptureClause>;\n \n pub fn with_freevars<T>(tcx: &ty::ctxt, fid: ast::NodeId, f: |&[Freevar]| -> T) -> T {\n-    match tcx.freevars.borrow().find(&fid) {\n+    match tcx.freevars.borrow().get(&fid) {\n         None => f(&[]),\n         Some(d) => f(d.as_slice())\n     }"}, {"sha": "ae0bbd617e23343f2d8cb22a70377c8efc03ac4e", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 148, "deletions": 153, "changes": 301, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -59,7 +59,7 @@ use middle::subst::{VecPerParamSpace};\n use middle::ty;\n use middle::typeck::lookup_def_tcx;\n use middle::typeck::infer;\n-use middle::typeck::rscope::{UnelidableRscope, RegionScope, SpecificRscope};\n+use middle::typeck::rscope::{UnelidableRscope, RegionScope, SpecificRscope, BindingRscope};\n use middle::typeck::rscope;\n use middle::typeck::TypeAndSubsts;\n use middle::typeck;\n@@ -99,7 +99,7 @@ pub trait AstConv<'tcx> {\n \n pub fn ast_region_to_region(tcx: &ty::ctxt, lifetime: &ast::Lifetime)\n                             -> ty::Region {\n-    let r = match tcx.named_region_map.find(&lifetime.id) {\n+    let r = match tcx.named_region_map.get(&lifetime.id) {\n         None => {\n             // should have been recorded by the `resolve_lifetime` pass\n             tcx.sess.span_bug(lifetime.span, \"unresolved lifetime\");\n@@ -207,15 +207,16 @@ pub fn opt_ast_region_to_region<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n }\n \n fn ast_path_substs<'tcx,AC,RS>(\n-                   this: &AC,\n-                   rscope: &RS,\n-                   decl_def_id: ast::DefId,\n-                   decl_generics: &ty::Generics,\n-                   self_ty: Option<ty::t>,\n-                   associated_ty: Option<ty::t>,\n-                   path: &ast::Path)\n-                   -> Substs\n-                   where AC: AstConv<'tcx>, RS: RegionScope\n+    this: &AC,\n+    rscope: &RS,\n+    decl_def_id: ast::DefId,\n+    decl_generics: &ty::Generics,\n+    self_ty: Option<ty::t>,\n+    associated_ty: Option<ty::t>,\n+    path: &ast::Path,\n+    binder_id: ast::NodeId)\n+    -> Substs\n+    where AC: AstConv<'tcx>, RS: RegionScope\n {\n     /*!\n      * Given a path `path` that refers to an item `I` with the\n@@ -236,67 +237,73 @@ fn ast_path_substs<'tcx,AC,RS>(\n     assert!(decl_generics.regions.all(|d| d.space == TypeSpace));\n     assert!(decl_generics.types.all(|d| d.space != FnSpace));\n \n+    let (regions, types) = match path.segments.last().unwrap().parameters {\n+        ast::AngleBracketedParameters(ref data) =>\n+            angle_bracketed_parameters(this, rscope, data),\n+        ast::ParenthesizedParameters(ref data) =>\n+            parenthesized_parameters(this, binder_id, data),\n+    };\n+\n     // If the type is parameterized by the this region, then replace this\n     // region with the current anon region binding (in other words,\n     // whatever & would get replaced with).\n     let expected_num_region_params = decl_generics.regions.len(TypeSpace);\n-    let supplied_num_region_params = path.segments.last().unwrap().lifetimes.len();\n+    let supplied_num_region_params = regions.len();\n     let regions = if expected_num_region_params == supplied_num_region_params {\n-        path.segments.last().unwrap().lifetimes.iter().map(\n-            |l| ast_region_to_region(this.tcx(), l)).collect::<Vec<_>>()\n+        regions\n     } else {\n         let anon_regions =\n             rscope.anon_regions(path.span, expected_num_region_params);\n \n         if supplied_num_region_params != 0 || anon_regions.is_err() {\n             span_err!(tcx.sess, path.span, E0107,\n-                \"wrong number of lifetime parameters: expected {}, found {}\",\n-                expected_num_region_params, supplied_num_region_params);\n+                      \"wrong number of lifetime parameters: expected {}, found {}\",\n+                      expected_num_region_params, supplied_num_region_params);\n         }\n \n         match anon_regions {\n             Ok(v) => v.into_iter().collect(),\n             Err(_) => Vec::from_fn(expected_num_region_params,\n-                                    |_| ty::ReStatic) // hokey\n+                                   |_| ty::ReStatic) // hokey\n         }\n     };\n \n     // Convert the type parameters supplied by the user.\n     let ty_param_defs = decl_generics.types.get_slice(TypeSpace);\n-    let supplied_ty_param_count = path.segments.iter().flat_map(|s| s.types.iter()).count();\n+    let supplied_ty_param_count = types.len();\n     let formal_ty_param_count =\n         ty_param_defs.iter()\n-                     .take_while(|x| !ty::is_associated_type(tcx, x.def_id))\n-                     .count();\n+        .take_while(|x| !ty::is_associated_type(tcx, x.def_id))\n+        .count();\n     let required_ty_param_count =\n         ty_param_defs.iter()\n-                     .take_while(|x| {\n-                        x.default.is_none() &&\n-                        !ty::is_associated_type(tcx, x.def_id)\n-                     })\n-                     .count();\n+        .take_while(|x| {\n+            x.default.is_none() &&\n+                !ty::is_associated_type(tcx, x.def_id)\n+        })\n+        .count();\n     if supplied_ty_param_count < required_ty_param_count {\n         let expected = if required_ty_param_count < formal_ty_param_count {\n             \"expected at least\"\n         } else {\n             \"expected\"\n         };\n         this.tcx().sess.span_fatal(path.span,\n-            format!(\"wrong number of type arguments: {} {}, found {}\",\n-                    expected,\n-                    required_ty_param_count,\n-                    supplied_ty_param_count).as_slice());\n+                                   format!(\"wrong number of type arguments: {} {}, found {}\",\n+                                           expected,\n+                                           required_ty_param_count,\n+                                           supplied_ty_param_count).as_slice());\n     } else if supplied_ty_param_count > formal_ty_param_count {\n         let expected = if required_ty_param_count < formal_ty_param_count {\n             \"expected at most\"\n         } else {\n             \"expected\"\n         };\n         this.tcx().sess.span_fatal(path.span,\n-            format!(\"wrong number of type arguments: {} {}, found {}\",\n-                    expected,\n-                    formal_ty_param_count,\n-                    supplied_ty_param_count).as_slice());\n+                                   format!(\"wrong number of type arguments: {} {}, found {}\",\n+                                           expected,\n+                                           formal_ty_param_count,\n+                                           supplied_ty_param_count).as_slice());\n     }\n \n     if supplied_ty_param_count > required_ty_param_count\n@@ -307,13 +314,7 @@ fn ast_path_substs<'tcx,AC,RS>(\n             \"add #![feature(default_type_params)] to the crate attributes to enable\");\n     }\n \n-    let tps = path.segments\n-                  .iter()\n-                  .flat_map(|s| s.types.iter())\n-                  .map(|a_t| ast_ty_to_ty(this, rscope, &**a_t))\n-                  .collect();\n-\n-    let mut substs = Substs::new_type(tps, regions);\n+    let mut substs = Substs::new_type(types, regions);\n \n     match self_ty {\n         None => {\n@@ -354,15 +355,56 @@ fn ast_path_substs<'tcx,AC,RS>(\n                                          param.def_id))\n     }\n \n-    substs\n+    return substs;\n+\n+    fn angle_bracketed_parameters<'tcx, AC, RS>(this: &AC,\n+                                                rscope: &RS,\n+                                                data: &ast::AngleBracketedParameterData)\n+                                                -> (Vec<ty::Region>, Vec<ty::t>)\n+        where AC: AstConv<'tcx>, RS: RegionScope\n+    {\n+        let regions: Vec<_> =\n+            data.lifetimes.iter()\n+            .map(|l| ast_region_to_region(this.tcx(), l))\n+            .collect();\n+\n+        let types: Vec<_> =\n+            data.types.iter()\n+            .map(|t| ast_ty_to_ty(this, rscope, &**t))\n+            .collect();\n+\n+        (regions, types)\n+    }\n+\n+    fn parenthesized_parameters<'tcx,AC>(this: &AC,\n+                                         binder_id: ast::NodeId,\n+                                         data: &ast::ParenthesizedParameterData)\n+                                         -> (Vec<ty::Region>, Vec<ty::t>)\n+        where AC: AstConv<'tcx>\n+    {\n+        let binding_rscope = BindingRscope::new(binder_id);\n+\n+        let inputs = data.inputs.iter()\n+                                .map(|a_t| ast_ty_to_ty(this, &binding_rscope, &**a_t))\n+                                .collect();\n+        let input_ty = ty::mk_tup_or_nil(this.tcx(), inputs);\n+\n+        let output = match data.output {\n+            Some(ref output_ty) => ast_ty_to_ty(this, &binding_rscope, &**output_ty),\n+            None => ty::mk_nil()\n+        };\n+\n+        (Vec::new(), vec![input_ty, output])\n+    }\n }\n \n pub fn ast_path_to_trait_ref<'tcx,AC,RS>(this: &AC,\n                                          rscope: &RS,\n                                          trait_def_id: ast::DefId,\n                                          self_ty: Option<ty::t>,\n                                          associated_type: Option<ty::t>,\n-                                         path: &ast::Path)\n+                                         path: &ast::Path,\n+                                         binder_id: ast::NodeId)\n                                          -> Rc<ty::TraitRef>\n                                          where AC: AstConv<'tcx>,\n                                                RS: RegionScope {\n@@ -375,16 +417,19 @@ pub fn ast_path_to_trait_ref<'tcx,AC,RS>(this: &AC,\n                                 &trait_def.generics,\n                                 self_ty,\n                                 associated_type,\n-                                path)\n+                                path,\n+                                binder_id)\n     })\n }\n \n pub fn ast_path_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n     this: &AC,\n     rscope: &RS,\n     did: ast::DefId,\n-    path: &ast::Path)\n-    -> TypeAndSubsts {\n+    path: &ast::Path,\n+    binder_id: ast::NodeId)\n+    -> TypeAndSubsts\n+{\n     let tcx = this.tcx();\n     let ty::Polytype {\n         generics,\n@@ -397,7 +442,8 @@ pub fn ast_path_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                                  &generics,\n                                  None,\n                                  None,\n-                                 path);\n+                                 path,\n+                                 binder_id);\n     let ty = decl_ty.subst(tcx, &substs);\n     TypeAndSubsts { substs: substs, ty: ty }\n }\n@@ -407,24 +453,29 @@ pub fn ast_path_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n /// and/or region variables are substituted.\n ///\n /// This is used when checking the constructor in struct literals.\n-pub fn ast_path_to_ty_relaxed<'tcx, AC: AstConv<'tcx>,\n-                              RS:RegionScope>(\n-                              this: &AC,\n-                              rscope: &RS,\n-                              did: ast::DefId,\n-                              path: &ast::Path)\n-                              -> TypeAndSubsts {\n+pub fn ast_path_to_ty_relaxed<'tcx,AC,RS>(\n+    this: &AC,\n+    rscope: &RS,\n+    did: ast::DefId,\n+    path: &ast::Path,\n+    binder_id: ast::NodeId)\n+    -> TypeAndSubsts\n+    where AC : AstConv<'tcx>, RS : RegionScope\n+{\n     let tcx = this.tcx();\n     let ty::Polytype {\n         generics,\n         ty: decl_ty\n     } = this.get_item_ty(did);\n \n-    let substs = if (generics.has_type_params(TypeSpace) ||\n-        generics.has_region_params(TypeSpace)) &&\n-            path.segments.iter().all(|s| {\n-                s.lifetimes.len() == 0 && s.types.len() == 0\n-            }) {\n+    let wants_params =\n+        generics.has_type_params(TypeSpace) || generics.has_region_params(TypeSpace);\n+\n+    let needs_defaults =\n+        wants_params &&\n+        path.segments.iter().all(|s| s.parameters.is_empty());\n+\n+    let substs = if needs_defaults {\n         let type_params = Vec::from_fn(generics.types.len(TypeSpace),\n                                        |_| this.ty_infer(path.span));\n         let region_params =\n@@ -433,7 +484,7 @@ pub fn ast_path_to_ty_relaxed<'tcx, AC: AstConv<'tcx>,\n         Substs::new(VecPerParamSpace::params_from_type(type_params),\n                     VecPerParamSpace::params_from_type(region_params))\n     } else {\n-        ast_path_substs(this, rscope, did, &generics, None, None, path)\n+        ast_path_substs(this, rscope, did, &generics, None, None, path, binder_id)\n     };\n \n     let ty = decl_ty.subst(tcx, &substs);\n@@ -450,14 +501,14 @@ fn check_path_args(tcx: &ty::ctxt,\n                    path: &ast::Path,\n                    flags: uint) {\n     if (flags & NO_TPS) != 0u {\n-        if !path.segments.iter().all(|s| s.types.is_empty()) {\n+        if path.segments.iter().any(|s| s.parameters.has_types()) {\n             span_err!(tcx.sess, path.span, E0109,\n                 \"type parameters are not allowed on this type\");\n         }\n     }\n \n     if (flags & NO_REGIONS) != 0u {\n-        if !path.segments.last().unwrap().lifetimes.is_empty() {\n+        if path.segments.iter().any(|s| s.parameters.has_lifetimes()) {\n             span_err!(tcx.sess, path.span, E0110,\n                 \"region parameters are not allowed on this type\");\n         }\n@@ -467,7 +518,7 @@ fn check_path_args(tcx: &ty::ctxt,\n pub fn ast_ty_to_prim_ty(tcx: &ty::ctxt, ast_ty: &ast::Ty) -> Option<ty::t> {\n     match ast_ty.node {\n         ast::TyPath(ref path, _, id) => {\n-            let a_def = match tcx.def_map.borrow().find(&id) {\n+            let a_def = match tcx.def_map.borrow().get(&id) {\n                 None => {\n                     tcx.sess.span_bug(ast_ty.span,\n                                       format!(\"unbound path {}\",\n@@ -524,7 +575,7 @@ pub fn ast_ty_to_builtin_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n \n     match ast_ty.node {\n         ast::TyPath(ref path, _, id) => {\n-            let a_def = match this.tcx().def_map.borrow().find(&id) {\n+            let a_def = match this.tcx().def_map.borrow().get(&id) {\n                 None => {\n                     this.tcx()\n                         .sess\n@@ -538,29 +589,23 @@ pub fn ast_ty_to_builtin_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n             // FIXME(#12938): This is a hack until we have full support for\n             // DST.\n             match a_def {\n-                def::DefTy(did, _) | def::DefStruct(did)\n-                        if Some(did) == this.tcx().lang_items.owned_box() => {\n-                    if path.segments\n-                           .iter()\n-                           .flat_map(|s| s.types.iter())\n-                           .count() > 1 {\n-                        span_err!(this.tcx().sess, path.span, E0047,\n-                                  \"`Box` has only one type parameter\");\n-                    }\n-\n-                    for inner_ast_type in path.segments\n-                                              .iter()\n-                                              .flat_map(|s| s.types.iter()) {\n-                        return Some(mk_pointer(this,\n-                                               rscope,\n-                                               ast::MutImmutable,\n-                                               &**inner_ast_type,\n-                                               Uniq,\n-                                               |typ| ty::mk_uniq(this.tcx(), typ)));\n+                def::DefTy(did, _) |\n+                def::DefStruct(did) if Some(did) == this.tcx().lang_items.owned_box() => {\n+                    let ty = ast_path_to_ty(this, rscope, did, path, id).ty;\n+                    match ty::get(ty).sty {\n+                        ty::ty_struct(struct_def_id, ref substs) => {\n+                            assert_eq!(struct_def_id, did);\n+                            assert_eq!(substs.types.len(TypeSpace), 1);\n+                            let referent_ty = *substs.types.get(TypeSpace, 0);\n+                            Some(ty::mk_uniq(this.tcx(), referent_ty))\n+                        }\n+                        _ => {\n+                            this.tcx().sess.span_bug(\n+                                path.span,\n+                                format!(\"converting `Box` to `{}`\",\n+                                        ty.repr(this.tcx()))[]);\n+                        }\n                     }\n-                    span_err!(this.tcx().sess, path.span, E0113,\n-                              \"not enough type parameters supplied to `Box<T>`\");\n-                    Some(ty::mk_err())\n                 }\n                 _ => None\n             }\n@@ -575,15 +620,6 @@ enum PointerTy {\n     Uniq\n }\n \n-impl PointerTy {\n-    fn default_region(&self) -> ty::Region {\n-        match *self {\n-            Uniq => ty::ReStatic,\n-            RPtr(r) => r,\n-        }\n-    }\n-}\n-\n pub fn trait_ref_for_unboxed_function<'tcx, AC: AstConv<'tcx>,\n                                       RS:RegionScope>(\n                                       this: &AC,\n@@ -603,11 +639,7 @@ pub fn trait_ref_for_unboxed_function<'tcx, AC: AstConv<'tcx>,\n                           .map(|input| {\n                             ast_ty_to_ty(this, rscope, &*input.ty)\n                           }).collect::<Vec<_>>();\n-    let input_tuple = if input_types.len() == 0 {\n-        ty::mk_nil()\n-    } else {\n-        ty::mk_tup(this.tcx(), input_types)\n-    };\n+    let input_tuple = ty::mk_tup_or_nil(this.tcx(), input_types);\n     let output_type = ast_ty_to_ty(this, rscope, &*decl.output);\n     let mut substs = Substs::new_type(vec!(input_tuple, output_type),\n                                       Vec::new());\n@@ -646,36 +678,11 @@ fn mk_pointer<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n             let ty = ast_ty_to_ty(this, rscope, &**ty);\n             return constr(ty::mk_vec(tcx, ty, None));\n         }\n-        ast::TyUnboxedFn(ref unboxed_function) => {\n-            let ty::TraitRef {\n-                def_id,\n-                substs\n-            } = trait_ref_for_unboxed_function(this,\n-                                               rscope,\n-                                               unboxed_function.kind,\n-                                               &*unboxed_function.decl,\n-                                               None);\n-            let r = ptr_ty.default_region();\n-            let tr = ty::mk_trait(this.tcx(),\n-                                  def_id,\n-                                  substs,\n-                                  ty::region_existential_bound(r));\n-            match ptr_ty {\n-                Uniq => {\n-                    return ty::mk_uniq(this.tcx(), tr);\n-                }\n-                RPtr(r) => {\n-                    return ty::mk_rptr(this.tcx(),\n-                                       r,\n-                                       ty::mt {mutbl: a_seq_mutbl, ty: tr});\n-                }\n-            }\n-        }\n         ast::TyPath(ref path, ref opt_bounds, id) => {\n             // Note that the \"bounds must be empty if path is not a trait\"\n             // restriction is enforced in the below case for ty_path, which\n             // will run after this as long as the path isn't a trait.\n-            match tcx.def_map.borrow().find(&id) {\n+            match tcx.def_map.borrow().get(&id) {\n                 Some(&def::DefPrimTy(ast::TyStr)) => {\n                     check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n                     match ptr_ty {\n@@ -693,7 +700,8 @@ fn mk_pointer<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                                                        trait_def_id,\n                                                        None,\n                                                        None,\n-                                                       path);\n+                                                       path,\n+                                                       id);\n                     let bounds = match *opt_bounds {\n                         None => {\n                             conv_existential_bounds(this,\n@@ -771,7 +779,12 @@ fn associated_ty_to_ty<'tcx,AC,RS>(this: &AC,\n                                           trait_did,\n                                           None,\n                                           Some(for_type),\n-                                          trait_path);\n+                                          trait_path,\n+                                          ast::DUMMY_NODE_ID); // *see below\n+\n+    // * The trait in a qualified path cannot be \"higher-ranked\" and\n+    // hence cannot use the parenthetical sugar, so the binder-id is\n+    // irrelevant.\n \n     debug!(\"associated_ty_to_ty(trait_ref={})\",\n            trait_ref.repr(this.tcx()));\n@@ -802,7 +815,7 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n     let tcx = this.tcx();\n \n     let mut ast_ty_to_ty_cache = tcx.ast_ty_to_ty_cache.borrow_mut();\n-    match ast_ty_to_ty_cache.find(&ast_ty.id) {\n+    match ast_ty_to_ty_cache.get(&ast_ty.id) {\n         Some(&ty::atttce_resolved(ty)) => return ty,\n         Some(&ty::atttce_unresolved) => {\n             tcx.sess.span_fatal(ast_ty.span,\n@@ -894,13 +907,8 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n \n                 ty::mk_closure(tcx, fn_decl)\n             }\n-            ast::TyUnboxedFn(..) => {\n-                tcx.sess.span_err(ast_ty.span,\n-                                  \"cannot use unboxed functions here\");\n-                ty::mk_err()\n-            }\n             ast::TyPath(ref path, ref bounds, id) => {\n-                let a_def = match tcx.def_map.borrow().find(&id) {\n+                let a_def = match tcx.def_map.borrow().get(&id) {\n                     None => {\n                         tcx.sess\n                            .span_bug(ast_ty.span,\n@@ -925,7 +933,8 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                                                            trait_def_id,\n                                                            None,\n                                                            None,\n-                                                           path);\n+                                                           path,\n+                                                           id);\n                         let empty_bounds: &[ast::TyParamBound] = &[];\n                         let ast_bounds = match *bounds {\n                             Some(ref b) => b.as_slice(),\n@@ -942,7 +951,7 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                                      bounds)\n                     }\n                     def::DefTy(did, _) | def::DefStruct(did) => {\n-                        ast_path_to_ty(this, rscope, did, path).ty\n+                        ast_path_to_ty(this, rscope, did, path, id).ty\n                     }\n                     def::DefTyParam(space, id, n) => {\n                         check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n@@ -990,7 +999,7 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                 }\n             }\n             ast::TyQPath(ref qpath) => {\n-                match tcx.def_map.borrow().find(&ast_ty.id) {\n+                match tcx.def_map.borrow().get(&ast_ty.id) {\n                     None => {\n                         tcx.sess.span_bug(ast_ty.span,\n                                           \"unbound qualified path\")\n@@ -1377,8 +1386,7 @@ pub fn conv_existential_bounds<'tcx, AC: AstConv<'tcx>, RS:RegionScope>(\n \n     let PartitionedBounds { builtin_bounds,\n                             trait_bounds,\n-                            region_bounds,\n-                            unboxed_fn_ty_bounds } =\n+                            region_bounds } =\n         partition_bounds(this.tcx(), span, ast_bound_refs.as_slice());\n \n     if !trait_bounds.is_empty() {\n@@ -1389,13 +1397,6 @@ pub fn conv_existential_bounds<'tcx, AC: AstConv<'tcx>, RS:RegionScope>(\n                      as closure or object bounds\").as_slice());\n     }\n \n-    if !unboxed_fn_ty_bounds.is_empty() {\n-        this.tcx().sess.span_err(\n-            span,\n-            format!(\"only the builtin traits can be used \\\n-                     as closure or object bounds\").as_slice());\n-    }\n-\n     // The \"main trait refs\", rather annoyingly, have no type\n     // specified for the `Self` parameter of the trait. The reason for\n     // this is that they are, after all, *existential* types, and\n@@ -1524,7 +1525,6 @@ fn compute_region_bound<'tcx, AC: AstConv<'tcx>, RS:RegionScope>(\n pub struct PartitionedBounds<'a> {\n     pub builtin_bounds: ty::BuiltinBounds,\n     pub trait_bounds: Vec<&'a ast::TraitRef>,\n-    pub unboxed_fn_ty_bounds: Vec<&'a ast::UnboxedFnBound>,\n     pub region_bounds: Vec<&'a ast::Lifetime>,\n }\n \n@@ -1542,14 +1542,13 @@ pub fn partition_bounds<'a>(tcx: &ty::ctxt,\n     let mut builtin_bounds = ty::empty_builtin_bounds();\n     let mut region_bounds = Vec::new();\n     let mut trait_bounds = Vec::new();\n-    let mut unboxed_fn_ty_bounds = Vec::new();\n     let mut trait_def_ids = HashMap::new();\n     for &ast_bound in ast_bounds.iter() {\n         match *ast_bound {\n             ast::TraitTyParamBound(ref b) => {\n                 match lookup_def_tcx(tcx, b.path.span, b.ref_id) {\n                     def::DefTrait(trait_did) => {\n-                        match trait_def_ids.find(&trait_did) {\n+                        match trait_def_ids.get(&trait_did) {\n                             // Already seen this trait. We forbid\n                             // duplicates in the list (for some\n                             // reason).\n@@ -1587,17 +1586,13 @@ pub fn partition_bounds<'a>(tcx: &ty::ctxt,\n             ast::RegionTyParamBound(ref l) => {\n                 region_bounds.push(l);\n             }\n-            ast::UnboxedFnTyParamBound(ref unboxed_function) => {\n-                unboxed_fn_ty_bounds.push(&**unboxed_function);\n-            }\n         }\n     }\n \n     PartitionedBounds {\n         builtin_bounds: builtin_bounds,\n         trait_bounds: trait_bounds,\n         region_bounds: region_bounds,\n-        unboxed_fn_ty_bounds: unboxed_fn_ty_bounds\n     }\n }\n "}, {"sha": "7070f16da3bfd25e18eee82ff37018050bc30a86", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -324,7 +324,7 @@ pub fn check_pat_struct(pcx: &pat_ctxt, pat: &ast::Pat,\n \n     let item_substs = fcx\n         .item_substs()\n-        .find(&pat.id)\n+        .get(&pat.id)\n         .map(|substs| substs.substs.clone())\n         .unwrap_or_else(|| Substs::empty());\n "}, {"sha": "557b92d439d917a6081da56ae3a559015d490ddc", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -678,7 +678,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n         debug!(\"push_extension_candidates(expr_id={})\", expr_id);\n \n         let mut duplicates = HashSet::new();\n-        let opt_applicable_traits = self.fcx.ccx.trait_map.find(&expr_id);\n+        let opt_applicable_traits = self.fcx.ccx.trait_map.get(&expr_id);\n         for applicable_traits in opt_applicable_traits.into_iter() {\n             for &trait_did in applicable_traits.iter() {\n                 if duplicates.insert(trait_did) {\n@@ -912,7 +912,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n         // metadata if necessary.\n         ty::populate_implementations_for_type_if_necessary(self.tcx(), did);\n \n-        for impl_infos in self.tcx().inherent_impls.borrow().find(&did).iter() {\n+        for impl_infos in self.tcx().inherent_impls.borrow().get(&did).iter() {\n             for impl_did in impl_infos.iter() {\n                 self.push_candidates_from_inherent_impl(*impl_did);\n             }\n@@ -1627,7 +1627,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n                                             .inh\n                                             .adjustments\n                                             .borrow()\n-                                            .find(&expr.id) {\n+                                            .get(&expr.id) {\n                 Some(&ty::AdjustDerefRef(ty::AutoDerefRef {\n                     autoderefs: autoderef_count,\n                     autoref: _\n@@ -1658,7 +1658,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n                 match expr.node {\n                     ast::ExprIndex(ref base_expr, _) => {\n                         let mut base_adjustment =\n-                            match self.fcx.inh.adjustments.borrow().find(&base_expr.id) {\n+                            match self.fcx.inh.adjustments.borrow().get(&base_expr.id) {\n                                 Some(&ty::AdjustDerefRef(ref adr)) => (*adr).clone(),\n                                 None => ty::AutoDerefRef { autoderefs: 0, autoref: None },\n                                 Some(_) => {\n@@ -1839,7 +1839,7 @@ fn impl_method(tcx: &ty::ctxt,\n                -> Option<Rc<ty::Method>>\n {\n     let impl_items = tcx.impl_items.borrow();\n-    let impl_items = impl_items.find(&impl_def_id).unwrap();\n+    let impl_items = impl_items.get(&impl_def_id).unwrap();\n     impl_items\n         .iter()\n         .map(|&did| ty::impl_or_trait_item(tcx, did.def_id()))"}, {"sha": "ccd6a8103b9b46aa5210d7499b320e8b67577f57", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 89, "deletions": 23, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -298,7 +298,7 @@ impl<'a, 'tcx> mem_categorization::Typer<'tcx> for FnCtxt<'a, 'tcx> {\n     }\n     fn node_method_ty(&self, method_call: typeck::MethodCall)\n                       -> Option<ty::t> {\n-        self.inh.method_map.borrow().find(&method_call).map(|m| m.ty)\n+        self.inh.method_map.borrow().get(&method_call).map(|m| m.ty)\n     }\n     fn adjustments<'a>(&'a self) -> &'a RefCell<NodeMap<ty::AutoAdjustment>> {\n         &self.inh.adjustments\n@@ -1556,7 +1556,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     pub fn local_ty(&self, span: Span, nid: ast::NodeId) -> ty::t {\n-        match self.inh.locals.borrow().find(&nid) {\n+        match self.inh.locals.borrow().get(&nid) {\n             Some(&t) => t,\n             None => {\n                 self.tcx().sess.span_bug(\n@@ -1808,7 +1808,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     pub fn expr_ty(&self, ex: &ast::Expr) -> ty::t {\n-        match self.inh.node_types.borrow().find(&ex.id) {\n+        match self.inh.node_types.borrow().get(&ex.id) {\n             Some(&t) => t,\n             None => {\n                 self.tcx().sess.bug(format!(\"no type for expr in fcx {}\",\n@@ -1824,7 +1824,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n          */\n \n         let adjustments = self.inh.adjustments.borrow();\n-        let adjustment = adjustments.find(&expr.id);\n+        let adjustment = adjustments.get(&expr.id);\n         self.adjust_expr_ty(expr, adjustment)\n     }\n \n@@ -1845,12 +1845,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                       raw_ty,\n                       adjustment,\n                       |method_call| self.inh.method_map.borrow()\n-                                                       .find(&method_call)\n+                                                       .get(&method_call)\n                                                        .map(|method| method.ty))\n     }\n \n     pub fn node_ty(&self, id: ast::NodeId) -> ty::t {\n-        match self.inh.node_types.borrow().find(&id) {\n+        match self.inh.node_types.borrow().get(&id) {\n             Some(&t) => t,\n             None => {\n                 self.tcx().sess.bug(\n@@ -1868,7 +1868,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn opt_node_ty_substs(&self,\n                               id: ast::NodeId,\n                               f: |&ty::ItemSubsts|) {\n-        match self.inh.item_substs.borrow().find(&id) {\n+        match self.inh.item_substs.borrow().get(&id) {\n             Some(s) => { f(s) }\n             None => { }\n         }\n@@ -3481,11 +3481,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n \n         // Tuple up the arguments and insert the resulting function type into\n         // the `unboxed_closures` table.\n-        fn_ty.sig.inputs = if fn_ty.sig.inputs.len() == 0 {\n-            vec![ty::mk_nil()]\n-        } else {\n-            vec![ty::mk_tup(fcx.tcx(), fn_ty.sig.inputs)]\n-        };\n+        fn_ty.sig.inputs = vec![ty::mk_tup_or_nil(fcx.tcx(), fn_ty.sig.inputs)];\n \n         let kind = match kind {\n             ast::FnUnboxedClosureKind => ty::FnUnboxedClosureKind,\n@@ -3554,7 +3550,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                     let (bounds, onceness) = match expr.node {\n                         ast::ExprProc(..) => {\n                             let mut bounds = ty::region_existential_bound(ty::ReStatic);\n-                            bounds.builtin_bounds.add(ty::BoundSend); // FIXME\n+                            bounds.builtin_bounds.insert(ty::BoundSend); // FIXME\n                             (bounds, ast::Once)\n                         }\n                         _ => {\n@@ -3763,7 +3759,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         for field in ast_fields.iter() {\n             let mut expected_field_type = ty::mk_err();\n \n-            let pair = class_field_map.find(&field.ident.node.name).map(|x| *x);\n+            let pair = class_field_map.get(&field.ident.node.name).map(|x| *x);\n             match pair {\n                 None => {\n                     fcx.type_error_message(\n@@ -4422,7 +4418,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n       }\n       ast::ExprStruct(ref path, ref fields, ref base_expr) => {\n         // Resolve the path.\n-        let def = tcx.def_map.borrow().find(&id).map(|i| *i);\n+        let def = tcx.def_map.borrow().get(&id).map(|i| *i);\n         let struct_id = match def {\n             Some(def::DefVariant(enum_id, variant_id, true)) => {\n                 check_struct_enum_variant(fcx, id, expr.span, enum_id,\n@@ -4478,7 +4474,8 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n             let type_and_substs = astconv::ast_path_to_ty_relaxed(fcx,\n                                                                   fcx.infcx(),\n                                                                   struct_id,\n-                                                                  path);\n+                                                                  path,\n+                                                                  expr.id);\n             match fcx.mk_subty(false,\n                                infer::Misc(path.span),\n                                actual_structure_type,\n@@ -5339,6 +5336,7 @@ pub fn instantiate_path(fcx: &FnCtxt,\n             Some(space) => {\n                 push_explicit_parameters_from_segment_to_substs(fcx,\n                                                                 space,\n+                                                                path.span,\n                                                                 type_defs,\n                                                                 region_defs,\n                                                                 segment,\n@@ -5374,13 +5372,13 @@ pub fn instantiate_path(fcx: &FnCtxt,\n         fcx: &FnCtxt,\n         segment: &ast::PathSegment)\n     {\n-        for typ in segment.types.iter() {\n+        for typ in segment.parameters.types().iter() {\n             span_err!(fcx.tcx().sess, typ.span, E0085,\n                 \"type parameters may not appear here\");\n             break;\n         }\n \n-        for lifetime in segment.lifetimes.iter() {\n+        for lifetime in segment.parameters.lifetimes().iter() {\n             span_err!(fcx.tcx().sess, lifetime.span, E0086,\n                 \"lifetime parameters may not appear here\");\n             break;\n@@ -5390,6 +5388,7 @@ pub fn instantiate_path(fcx: &FnCtxt,\n     fn push_explicit_parameters_from_segment_to_substs(\n         fcx: &FnCtxt,\n         space: subst::ParamSpace,\n+        span: Span,\n         type_defs: &VecPerParamSpace<ty::TypeParameterDef>,\n         region_defs: &VecPerParamSpace<ty::RegionParameterDef>,\n         segment: &ast::PathSegment,\n@@ -5412,10 +5411,31 @@ pub fn instantiate_path(fcx: &FnCtxt,\n          * span of the N+1'th parameter.\n          */\n \n+        match segment.parameters {\n+            ast::AngleBracketedParameters(ref data) => {\n+                push_explicit_angle_bracketed_parameters_from_segment_to_substs(\n+                    fcx, space, type_defs, region_defs, data, substs);\n+            }\n+\n+            ast::ParenthesizedParameters(ref data) => {\n+                push_explicit_parenthesized_parameters_from_segment_to_substs(\n+                    fcx, space, span, type_defs, data, substs);\n+            }\n+        }\n+    }\n+\n+    fn push_explicit_angle_bracketed_parameters_from_segment_to_substs(\n+        fcx: &FnCtxt,\n+        space: subst::ParamSpace,\n+        type_defs: &VecPerParamSpace<ty::TypeParameterDef>,\n+        region_defs: &VecPerParamSpace<ty::RegionParameterDef>,\n+        data: &ast::AngleBracketedParameterData,\n+        substs: &mut Substs)\n+    {\n         {\n             let type_count = type_defs.len(space);\n             assert_eq!(substs.types.len(space), 0);\n-            for (i, typ) in segment.types.iter().enumerate() {\n+            for (i, typ) in data.types.iter().enumerate() {\n                 let t = fcx.to_ty(&**typ);\n                 if i < type_count {\n                     substs.types.push(space, t);\n@@ -5424,7 +5444,7 @@ pub fn instantiate_path(fcx: &FnCtxt,\n                         \"too many type parameters provided: \\\n                          expected at most {} parameter(s), \\\n                          found {} parameter(s)\",\n-                         type_count, segment.types.len());\n+                         type_count, data.types.len());\n                     substs.types.truncate(space, 0);\n                 }\n             }\n@@ -5433,7 +5453,7 @@ pub fn instantiate_path(fcx: &FnCtxt,\n         {\n             let region_count = region_defs.len(space);\n             assert_eq!(substs.regions().len(space), 0);\n-            for (i, lifetime) in segment.lifetimes.iter().enumerate() {\n+            for (i, lifetime) in data.lifetimes.iter().enumerate() {\n                 let r = ast_region_to_region(fcx.tcx(), lifetime);\n                 if i < region_count {\n                     substs.mut_regions().push(space, r);\n@@ -5442,13 +5462,59 @@ pub fn instantiate_path(fcx: &FnCtxt,\n                         \"too many lifetime parameters provided: \\\n                          expected {} parameter(s), found {} parameter(s)\",\n                         region_count,\n-                        segment.lifetimes.len());\n+                        data.lifetimes.len());\n                     substs.mut_regions().truncate(space, 0);\n                 }\n             }\n         }\n     }\n \n+    fn push_explicit_parenthesized_parameters_from_segment_to_substs(\n+        fcx: &FnCtxt,\n+        space: subst::ParamSpace,\n+        span: Span,\n+        type_defs: &VecPerParamSpace<ty::TypeParameterDef>,\n+        data: &ast::ParenthesizedParameterData,\n+        substs: &mut Substs)\n+    {\n+        /*!\n+         * As with\n+         * `push_explicit_angle_bracketed_parameters_from_segment_to_substs`,\n+         * but intended for `Foo(A,B) -> C` form. This expands to\n+         * roughly the same thing as `Foo<(A,B),C>`. One important\n+         * difference has to do with the treatment of anonymous\n+         * regions, which are translated into bound regions (NYI).\n+         */\n+\n+        let type_count = type_defs.len(space);\n+        if type_count < 2 {\n+            span_err!(fcx.tcx().sess, span, E0167,\n+                      \"parenthesized form always supplies 2 type parameters, \\\n+                      but only {} parameter(s) were expected\",\n+                      type_count);\n+        }\n+\n+        let input_tys: Vec<ty::t> =\n+            data.inputs.iter().map(|ty| fcx.to_ty(&**ty)).collect();\n+\n+        let tuple_ty =\n+            ty::mk_tup_or_nil(fcx.tcx(), input_tys);\n+\n+        if type_count >= 1 {\n+            substs.types.push(space, tuple_ty);\n+        }\n+\n+        let output_ty: Option<ty::t> =\n+            data.output.as_ref().map(|ty| fcx.to_ty(&**ty));\n+\n+        let output_ty =\n+            output_ty.unwrap_or(ty::mk_nil());\n+\n+        if type_count >= 2 {\n+            substs.types.push(space, output_ty);\n+        }\n+    }\n+\n     fn adjust_type_parameters(\n         fcx: &FnCtxt,\n         span: Span,\n@@ -5603,7 +5669,7 @@ pub fn may_break(cx: &ty::ctxt, id: ast::NodeId, b: &ast::Block) -> bool {\n     (block_query(b, |e| {\n         match e.node {\n             ast::ExprBreak(Some(_)) => {\n-                match cx.def_map.borrow().find(&e.id) {\n+                match cx.def_map.borrow().get(&e.id) {\n                     Some(&def::DefLabel(loop_id)) if id == loop_id => true,\n                     _ => false,\n                 }"}, {"sha": "014180a11553ab93389e684b9854fa3eaf1c09ae", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -327,7 +327,7 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n \n     fn resolve_method_type(&self, method_call: MethodCall) -> Option<ty::t> {\n         let method_ty = self.fcx.inh.method_map.borrow()\n-                            .find(&method_call).map(|method| method.ty);\n+                            .get(&method_call).map(|method| method.ty);\n         method_ty.map(|method_ty| self.resolve_type(method_ty))\n     }\n \n@@ -339,7 +339,7 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n         } else {\n             let tcx = self.fcx.tcx();\n             ty::adjust_ty(tcx, expr.span, expr.id, ty_unadjusted,\n-                          self.fcx.inh.adjustments.borrow().find(&expr.id),\n+                          self.fcx.inh.adjustments.borrow().get(&expr.id),\n                           |method_call| self.resolve_method_type(method_call))\n         }\n     }\n@@ -351,7 +351,7 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n         // When we enter a function, we can derive\n \n         let fn_sig_map = self.fcx.inh.fn_sig_map.borrow();\n-        let fn_sig = match fn_sig_map.find(&id) {\n+        let fn_sig = match fn_sig_map.get(&id) {\n             Some(f) => f,\n             None => {\n                 self.tcx().sess.bug(\n@@ -370,7 +370,7 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n     {\n         debug!(\"visit_region_obligations: node_id={}\", node_id);\n         let region_obligations = self.fcx.inh.region_obligations.borrow();\n-        match region_obligations.find(&node_id) {\n+        match region_obligations.get(&node_id) {\n             None => { }\n             Some(vec) => {\n                 for r_o in vec.iter() {\n@@ -594,7 +594,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n     let has_method_map = rcx.fcx.inh.method_map.borrow().contains_key(&method_call);\n \n     // Check any autoderefs or autorefs that appear.\n-    for &adjustment in rcx.fcx.inh.adjustments.borrow().find(&expr.id).iter() {\n+    for &adjustment in rcx.fcx.inh.adjustments.borrow().get(&expr.id).iter() {\n         debug!(\"adjustment={}\", adjustment);\n         match *adjustment {\n             ty::AdjustDerefRef(ty::AutoDerefRef {autoderefs, autoref: ref opt_autoref}) => {\n@@ -686,7 +686,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n         ast::ExprUnary(ast::UnDeref, ref base) => {\n             // For *a, the lifetime of a must enclose the deref\n             let method_call = MethodCall::expr(expr.id);\n-            let base_ty = match rcx.fcx.inh.method_map.borrow().find(&method_call) {\n+            let base_ty = match rcx.fcx.inh.method_map.borrow().get(&method_call) {\n                 Some(method) => {\n                     constrain_call(rcx, expr, Some(&**base),\n                                    None::<ast::Expr>.iter(), true);\n@@ -950,7 +950,7 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n             let raw_var_ty = rcx.resolve_node_type(var_node_id);\n             let upvar_id = ty::UpvarId { var_id: var_node_id,\n                                          closure_expr_id: expr.id };\n-            let var_ty = match rcx.fcx.inh.upvar_borrow_map.borrow().find(&upvar_id) {\n+            let var_ty = match rcx.fcx.inh.upvar_borrow_map.borrow().get(&upvar_id) {\n                 Some(upvar_borrow) => {\n                     ty::mk_rptr(rcx.tcx(),\n                                 upvar_borrow.region,\n@@ -1195,7 +1195,7 @@ fn constrain_autoderefs(rcx: &mut Rcx,\n                i, derefs);\n \n         let method_call = MethodCall::autoderef(deref_expr.id, i);\n-        derefd_ty = match rcx.fcx.inh.method_map.borrow().find(&method_call) {\n+        derefd_ty = match rcx.fcx.inh.method_map.borrow().get(&method_call) {\n             Some(method) => {\n                 // Treat overloaded autoderefs as if an AutoRef adjustment\n                 // was applied on the base type, as that is always the case.\n@@ -1301,7 +1301,7 @@ fn type_of_node_must_outlive(\n     // report errors later on in the writeback phase.\n     let ty0 = rcx.resolve_node_type(id);\n     let ty = ty::adjust_ty(tcx, origin.span(), id, ty0,\n-                           rcx.fcx.inh.adjustments.borrow().find(&id),\n+                           rcx.fcx.inh.adjustments.borrow().get(&id),\n                            |method_call| rcx.resolve_method_type(method_call));\n     debug!(\"constrain_regions_in_type_of_node(\\\n             ty={}, ty0={}, id={}, minimum_lifetime={})\",\n@@ -1582,7 +1582,7 @@ fn link_reborrowed_region(rcx: &Rcx,\n         mc::NoteUpvarRef(ref upvar_id) => {\n             let mut upvar_borrow_map =\n                 rcx.fcx.inh.upvar_borrow_map.borrow_mut();\n-            match upvar_borrow_map.find_mut(upvar_id) {\n+            match upvar_borrow_map.get_mut(upvar_id) {\n                 Some(upvar_borrow) => {\n                     // Adjust mutability that we infer for the upvar\n                     // so it can accommodate being borrowed with\n@@ -1845,7 +1845,7 @@ fn link_upvar_borrow_kind_for_nested_closures(rcx: &mut Rcx,\n \n     let mut upvar_borrow_map = rcx.fcx.inh.upvar_borrow_map.borrow_mut();\n     let inner_borrow = upvar_borrow_map.get_copy(&inner_upvar_id);\n-    match upvar_borrow_map.find_mut(&outer_upvar_id) {\n+    match upvar_borrow_map.get_mut(&outer_upvar_id) {\n         Some(outer_borrow) => {\n             adjust_upvar_borrow_kind(rcx, outer_upvar_id, outer_borrow, inner_borrow.kind);\n         }"}, {"sha": "cf78ef1621986de1d57bf55e4d11f1caf581a713", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -263,7 +263,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n     }\n \n     fn visit_adjustments(&self, reason: ResolveReason, id: ast::NodeId) {\n-        match self.fcx.inh.adjustments.borrow_mut().pop(&id) {\n+        match self.fcx.inh.adjustments.borrow_mut().remove(&id) {\n             None => {\n                 debug!(\"No adjustments for node {}\", id);\n             }\n@@ -275,7 +275,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n                         // FIXME(eddyb) #2190 Allow only statically resolved\n                         // bare functions to coerce to a closure to avoid\n                         // constructing (slower) indirect call wrappers.\n-                        match self.tcx().def_map.borrow().find(&id) {\n+                        match self.tcx().def_map.borrow().get(&id) {\n                             Some(&def::DefFn(..)) |\n                             Some(&def::DefStaticMethod(..)) |\n                             Some(&def::DefVariant(..)) |\n@@ -320,7 +320,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n                               reason: ResolveReason,\n                               method_call: MethodCall) {\n         // Resolve any method map entry\n-        match self.fcx.inh.method_map.borrow_mut().pop(&method_call) {\n+        match self.fcx.inh.method_map.borrow_mut().remove(&method_call) {\n             Some(method) => {\n                 debug!(\"writeback::resolve_method_map_entry(call={}, entry={})\",\n                        method_call,"}, {"sha": "19ff82469b5155906df2bdadf2c473fc8e04d681", "filename": "src/librustc/middle/typeck/coherence/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Fmod.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -294,7 +294,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n     }\n \n     fn add_inherent_impl(&self, base_def_id: DefId, impl_def_id: DefId) {\n-        match self.inherent_impls.borrow().find(&base_def_id) {\n+        match self.inherent_impls.borrow().get(&base_def_id) {\n             Some(implementation_list) => {\n                 implementation_list.borrow_mut().push(impl_def_id);\n                 return;"}, {"sha": "933c2c81ac269380b0ad7a04070ad31e00a7fdd2", "filename": "src/librustc/middle/typeck/coherence/overlap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Foverlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Foverlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Foverlap.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -114,7 +114,7 @@ impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> {\n     fn push_impls_of_trait(&self,\n                            trait_def_id: ast::DefId,\n                            out: &mut Vec<ast::DefId>) {\n-        match self.tcx.trait_impls.borrow().find(&trait_def_id) {\n+        match self.tcx.trait_impls.borrow().get(&trait_def_id) {\n             Some(impls) => { out.push_all(impls.borrow().as_slice()); }\n             None => { /* no impls */ }\n         }"}, {"sha": "ae2073f6316ea969d5275290f076ad39b81b724b", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 12, "deletions": 64, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -638,7 +638,7 @@ pub fn ensure_no_ty_param_bounds(ccx: &CrateCtxt,\n         let mut bounds = bounds.chain(ty_param.unbound.iter());\n         for bound in bounds {\n             match *bound {\n-                ast::TraitTyParamBound(..) | ast::UnboxedFnTyParamBound(..) => {\n+                ast::TraitTyParamBound(..) => {\n                     // According to accepted RFC #XXX, we should\n                     // eventually accept these, but it will not be\n                     // part of this PR. Still, convert to warning to\n@@ -1243,7 +1243,7 @@ pub fn convert_struct(ccx: &CrateCtxt,\n         let result = convert_field(ccx, &pty.generics, f, local_def(id));\n \n         if result.name != special_idents::unnamed_field.name {\n-            let dup = match seen_fields.find(&result.name) {\n+            let dup = match seen_fields.get(&result.name) {\n                 Some(prev_span) => {\n                     span_err!(tcx.sess, f.span, E0124,\n                               \"field `{}` is already declared\",\n@@ -1340,7 +1340,8 @@ pub fn instantiate_trait_ref<'tcx,AC>(this: &AC,\n                                                trait_did,\n                                                Some(self_ty),\n                                                associated_type,\n-                                               &ast_trait_ref.path);\n+                                               &ast_trait_ref.path,\n+                                               ast_trait_ref.ref_id);\n \n             this.tcx().trait_refs.borrow_mut().insert(ast_trait_ref.ref_id,\n                                                       trait_ref.clone());\n@@ -1355,20 +1356,6 @@ pub fn instantiate_trait_ref<'tcx,AC>(this: &AC,\n     }\n }\n \n-pub fn instantiate_unboxed_fn_ty<'tcx,AC>(this: &AC,\n-                                          unboxed_function: &ast::UnboxedFnTy,\n-                                          param_ty: ty::ParamTy)\n-                                          -> Rc<ty::TraitRef>\n-                                          where AC: AstConv<'tcx> {\n-    let rscope = ExplicitRscope;\n-    let param_ty = param_ty.to_ty(this.tcx());\n-    Rc::new(astconv::trait_ref_for_unboxed_function(this,\n-                                                    &rscope,\n-                                                    unboxed_function.kind,\n-                                                    &*unboxed_function.decl,\n-                                                    Some(param_ty)))\n-}\n-\n fn get_trait_def(ccx: &CrateCtxt, trait_id: ast::DefId) -> Rc<ty::TraitDef> {\n     if trait_id.krate != ast::LOCAL_CRATE {\n         return ty::lookup_trait_def(ccx.tcx, trait_id)\n@@ -1386,7 +1373,7 @@ fn get_trait_def(ccx: &CrateCtxt, trait_id: ast::DefId) -> Rc<ty::TraitDef> {\n pub fn trait_def_of_item(ccx: &CrateCtxt, it: &ast::Item) -> Rc<ty::TraitDef> {\n     let def_id = local_def(it.id);\n     let tcx = ccx.tcx;\n-    match tcx.trait_defs.borrow().find(&def_id) {\n+    match tcx.trait_defs.borrow().get(&def_id) {\n         Some(def) => return def.clone(),\n         _ => {}\n     }\n@@ -1486,7 +1473,7 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: &ast::Item)\n                   -> ty::Polytype {\n     let def_id = local_def(it.id);\n     let tcx = ccx.tcx;\n-    match tcx.tcache.borrow().find(&def_id) {\n+    match tcx.tcache.borrow().get(&def_id) {\n         Some(pty) => return pty.clone(),\n         _ => {}\n     }\n@@ -1528,7 +1515,7 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: &ast::Item)\n             return pty;\n         }\n         ast::ItemTy(ref t, ref generics) => {\n-            match tcx.tcache.borrow_mut().find(&local_def(it.id)) {\n+            match tcx.tcache.borrow_mut().get(&local_def(it.id)) {\n                 Some(pty) => return pty.clone(),\n                 None => { }\n             }\n@@ -1878,7 +1865,6 @@ fn ty_generics<'tcx,AC>(this: &AC,\n                 // In the above example, `ast_trait_ref` is `Iterator`.\n                 let ast_trait_ref = match *bound {\n                     ast::TraitTyParamBound(ref r) => r,\n-                    ast::UnboxedFnTyParamBound(..) => { continue; }\n                     ast::RegionTyParamBound(..) => { continue; }\n                 };\n \n@@ -1933,7 +1919,7 @@ fn get_or_create_type_parameter_def<'tcx,AC>(this: &AC,\n                                              -> ty::TypeParameterDef\n     where AC: AstConv<'tcx>\n {\n-    match this.tcx().ty_param_defs.borrow().find(&param.id) {\n+    match this.tcx().ty_param_defs.borrow().get(&param.id) {\n         Some(d) => { return (*d).clone(); }\n         None => { }\n     }\n@@ -2027,13 +2013,13 @@ fn check_bounds_compatible(tcx: &ty::ctxt,\n                            span: Span) {\n     // Currently the only bound which is incompatible with other bounds is\n     // Sized/Unsized.\n-    if !param_bounds.builtin_bounds.contains_elem(ty::BoundSized) {\n+    if !param_bounds.builtin_bounds.contains(&ty::BoundSized) {\n         ty::each_bound_trait_and_supertraits(\n             tcx,\n             param_bounds.trait_bounds.as_slice(),\n             |trait_ref| {\n                 let trait_def = ty::lookup_trait_def(tcx, trait_ref.def_id);\n-                if trait_def.bounds.builtin_bounds.contains_elem(ty::BoundSized) {\n+                if trait_def.bounds.builtin_bounds.contains(&ty::BoundSized) {\n                     span_err!(tcx.sess, span, E0129,\n                               \"incompatible bounds on type parameter `{}`, \\\n                                bound `{}` does not allow unsized type\",\n@@ -2056,45 +2042,8 @@ fn conv_param_bounds<'tcx,AC>(this: &AC,\n         merge_param_bounds(this.tcx(), param_ty, ast_bounds, where_clause);\n     let astconv::PartitionedBounds { builtin_bounds,\n                                      trait_bounds,\n-                                     region_bounds,\n-                                     unboxed_fn_ty_bounds } =\n+                                     region_bounds } =\n         astconv::partition_bounds(this.tcx(), span, all_bounds.as_slice());\n-\n-    let unboxed_fn_ty_bounds = unboxed_fn_ty_bounds.into_iter().map(|b| {\n-        let trait_id = (*this.tcx().def_map.borrow())[b.ref_id].def_id();\n-        let mut kind = None;\n-        for &(lang_item, this_kind) in [\n-            (this.tcx().lang_items.fn_trait(), ast::FnUnboxedClosureKind),\n-            (this.tcx().lang_items.fn_mut_trait(),\n-             ast::FnMutUnboxedClosureKind),\n-            (this.tcx().lang_items.fn_once_trait(),\n-             ast::FnOnceUnboxedClosureKind)\n-        ].iter() {\n-            if Some(trait_id) == lang_item {\n-                kind = Some(this_kind);\n-                break\n-            }\n-        }\n-\n-        let kind = match kind {\n-            Some(kind) => kind,\n-            None => {\n-                this.tcx().sess.span_err(b.path.span,\n-                                         \"unboxed function trait must be one \\\n-                                          of `Fn`, `FnMut`, or `FnOnce`\");\n-                ast::FnMutUnboxedClosureKind\n-            }\n-        };\n-\n-        let rscope = ExplicitRscope;\n-        let param_ty = param_ty.to_ty(this.tcx());\n-        Rc::new(astconv::trait_ref_for_unboxed_function(this,\n-                                                        &rscope,\n-                                                        kind,\n-                                                        &*b.decl,\n-                                                        Some(param_ty)))\n-    });\n-\n     let trait_bounds: Vec<Rc<ty::TraitRef>> =\n         trait_bounds.into_iter()\n         .map(|b| {\n@@ -2103,7 +2052,6 @@ fn conv_param_bounds<'tcx,AC>(this: &AC,\n                                   param_ty.to_ty(this.tcx()),\n                                   Some(param_ty.to_ty(this.tcx())))\n         })\n-        .chain(unboxed_fn_ty_bounds)\n         .collect();\n     let region_bounds: Vec<ty::Region> =\n         region_bounds.into_iter()\n@@ -2136,7 +2084,7 @@ fn merge_param_bounds<'a>(tcx: &ty::ctxt,\n         let predicate_param_id =\n             tcx.def_map\n                .borrow()\n-               .find(&predicate.id)\n+               .get(&predicate.id)\n                .expect(\"compute_bounds(): resolve didn't resolve the type \\\n                         parameter identifier in a `where` clause\")\n                .def_id();"}, {"sha": "4ca62253467917ec5dbed668492b926f691e37be", "filename": "src/librustc/middle/typeck/infer/error_reporting.rs", "status": "modified", "additions": 43, "deletions": 33, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -1102,21 +1102,19 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                     // be passing down a map.\n                     ast::RegionTyParamBound(lt)\n                 }\n-                &ast::UnboxedFnTyParamBound(ref unboxed_function_type) => {\n-                    ast::UnboxedFnTyParamBound((*unboxed_function_type).clone())\n-                }\n                 &ast::TraitTyParamBound(ref tr) => {\n                     let last_seg = tr.path.segments.last().unwrap();\n                     let mut insert = Vec::new();\n-                    for (i, lt) in last_seg.lifetimes.iter().enumerate() {\n+                    let lifetimes = last_seg.parameters.lifetimes();\n+                    for (i, lt) in lifetimes.iter().enumerate() {\n                         if region_names.contains(&lt.name) {\n                             insert.push(i);\n                         }\n                     }\n                     let rebuild_info = RebuildPathInfo {\n                         path: &tr.path,\n                         indexes: insert,\n-                        expected: last_seg.lifetimes.len(),\n+                        expected: lifetimes.len(),\n                         anon_nums: &HashSet::new(),\n                         region_names: region_names\n                     };\n@@ -1240,7 +1238,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                     ty_queue.push(&*mut_ty.ty);\n                 }\n                 ast::TyPath(ref path, ref bounds, id) => {\n-                    let a_def = match self.tcx.def_map.borrow().find(&id) {\n+                    let a_def = match self.tcx.def_map.borrow().get(&id) {\n                         None => {\n                             self.tcx\n                                 .sess\n@@ -1257,7 +1255,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                             let expected =\n                                 generics.regions.len(subst::TypeSpace);\n                             let lifetimes =\n-                                &path.segments.last().unwrap().lifetimes;\n+                                path.segments.last().unwrap().parameters.lifetimes();\n                             let mut insert = Vec::new();\n                             if lifetimes.len() == 0 {\n                                 let anon = self.cur_anon.get();\n@@ -1357,7 +1355,8 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n     fn rebuild_path(&self,\n                     rebuild_info: RebuildPathInfo,\n                     lifetime: ast::Lifetime)\n-                    -> ast::Path {\n+                    -> ast::Path\n+    {\n         let RebuildPathInfo {\n             path,\n             indexes,\n@@ -1367,37 +1366,48 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n         } = rebuild_info;\n \n         let last_seg = path.segments.last().unwrap();\n-        let mut new_lts = Vec::new();\n-        if last_seg.lifetimes.len() == 0 {\n-            // traverse once to see if there's a need to insert lifetime\n-            let need_insert = range(0, expected).any(|i| {\n-                indexes.contains(&i)\n-            });\n-            if need_insert {\n-                for i in range(0, expected) {\n-                    if indexes.contains(&i) {\n-                        new_lts.push(lifetime);\n-                    } else {\n-                        new_lts.push(self.life_giver.give_lifetime());\n+        let new_parameters = match last_seg.parameters {\n+            ast::ParenthesizedParameters(..) => {\n+                last_seg.parameters.clone()\n+            }\n+\n+            ast::AngleBracketedParameters(ref data) => {\n+                let mut new_lts = Vec::new();\n+                if data.lifetimes.len() == 0 {\n+                    // traverse once to see if there's a need to insert lifetime\n+                    let need_insert = range(0, expected).any(|i| {\n+                        indexes.contains(&i)\n+                    });\n+                    if need_insert {\n+                        for i in range(0, expected) {\n+                            if indexes.contains(&i) {\n+                                new_lts.push(lifetime);\n+                            } else {\n+                                new_lts.push(self.life_giver.give_lifetime());\n+                            }\n+                        }\n                     }\n-                }\n-            }\n-        } else {\n-            for (i, lt) in last_seg.lifetimes.iter().enumerate() {\n-                if indexes.contains(&i) {\n-                    new_lts.push(lifetime);\n                 } else {\n-                    new_lts.push(*lt);\n+                    for (i, lt) in data.lifetimes.iter().enumerate() {\n+                        if indexes.contains(&i) {\n+                            new_lts.push(lifetime);\n+                        } else {\n+                            new_lts.push(*lt);\n+                        }\n+                    }\n                 }\n+                let new_types = data.types.map(|t| {\n+                    self.rebuild_arg_ty_or_output(&**t, lifetime, anon_nums, region_names)\n+                });\n+                ast::AngleBracketedParameters(ast::AngleBracketedParameterData {\n+                    lifetimes: new_lts,\n+                    types: new_types\n+                })\n             }\n-        }\n-        let new_types = last_seg.types.map(|t| {\n-            self.rebuild_arg_ty_or_output(&**t, lifetime, anon_nums, region_names)\n-        });\n+        };\n         let new_seg = ast::PathSegment {\n             identifier: last_seg.identifier,\n-            lifetimes: new_lts,\n-            types: new_types,\n+            parameters: new_parameters\n         };\n         let mut new_segs = Vec::new();\n         new_segs.push_all(path.segments.init());"}, {"sha": "70c4a245b2c269fa1e667d90e69605d90ff9e96f", "filename": "src/librustc/middle/typeck/infer/region_inference/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -367,7 +367,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         debug!(\"RegionVarBindings: add_constraint({})\",\n                constraint.repr(self.tcx));\n \n-        if self.constraints.borrow_mut().insert(constraint, origin) {\n+        if self.constraints.borrow_mut().insert(constraint, origin).is_none() {\n             if self.in_snapshot() {\n                 self.undo_log.borrow_mut().push(AddConstraint(constraint));\n             }\n@@ -559,7 +559,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                                  new_r: Region|)\n                         -> Region {\n         let vars = TwoRegions { a: a, b: b };\n-        match self.combine_map(t).borrow().find(&vars) {\n+        match self.combine_map(t).borrow().get(&vars) {\n             Some(&c) => {\n                 return ReInfer(ReVar(c));\n             }\n@@ -991,7 +991,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n             debug!(\"expansion: constraint={} origin={}\",\n                    constraint.repr(self.tcx),\n                    self.constraints.borrow()\n-                                   .find(constraint)\n+                                   .get(constraint)\n                                    .unwrap()\n                                    .repr(self.tcx));\n             match *constraint {\n@@ -1075,7 +1075,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n             debug!(\"contraction: constraint={} origin={}\",\n                    constraint.repr(self.tcx),\n                    self.constraints.borrow()\n-                                   .find(constraint)\n+                                   .get(constraint)\n                                    .unwrap()\n                                    .repr(self.tcx));\n             match *constraint {"}, {"sha": "d2f315f2a4b608a13f0aeb5271b0e6db79a1cd8c", "filename": "src/librustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -113,7 +113,7 @@ impl<'f, 'tcx> Combine<'tcx> for Sub<'f, 'tcx> {\n         // e.g., fn:Copy() <: fn(), because the former is a function\n         // that only closes over copyable things, but the latter is\n         // any function at all.\n-        if a.contains(b) {\n+        if a.is_superset(&b) {\n             Ok(a)\n         } else {\n             Err(ty::terr_builtin_bounds(expected_found(self, a, b)))"}, {"sha": "5ca0de47ad500b7dc5910e835ce34ffea590fbee", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -301,7 +301,7 @@ pub fn write_substs_to_tcx(tcx: &ty::ctxt,\n     }\n }\n pub fn lookup_def_tcx(tcx:&ty::ctxt, sp: Span, id: ast::NodeId) -> def::Def {\n-    match tcx.def_map.borrow().find(&id) {\n+    match tcx.def_map.borrow().get(&id) {\n         Some(x) => x.clone(),\n         _ => {\n             tcx.sess.span_fatal(sp, \"internal error looking up a definition\")"}, {"sha": "4227cc521b48b8d95bb2cba7cd97c7d4691b408e", "filename": "src/librustc/middle/typeck/variance.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -322,7 +322,7 @@ impl<'a, 'tcx> TermsContext<'a, 'tcx> {\n                                                 index: index,\n                                                 param_id: param_id,\n                                                 term: term });\n-        let newly_added = self.inferred_map.insert(param_id, inf_index);\n+        let newly_added = self.inferred_map.insert(param_id, inf_index).is_none();\n         assert!(newly_added);\n \n         debug!(\"add_inferred(item_id={}, \\\n@@ -376,7 +376,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for TermsContext<'a, 'tcx> {\n                 if self.num_inferred() == inferreds_on_entry {\n                     let newly_added = self.tcx.item_variance_map.borrow_mut().insert(\n                         ast_util::local_def(item.id),\n-                        self.empty_variances.clone());\n+                        self.empty_variances.clone()).is_none();\n                     assert!(newly_added);\n                 }\n \n@@ -556,7 +556,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n     }\n \n     fn inferred_index(&self, param_id: ast::NodeId) -> InferredIndex {\n-        match self.terms_cx.inferred_map.find(&param_id) {\n+        match self.terms_cx.inferred_map.get(&param_id) {\n             Some(&index) => index,\n             None => {\n                 self.tcx().sess.bug(format!(\n@@ -569,7 +569,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n     fn find_binding_for_lifetime(&self, param_id: ast::NodeId) -> ast::NodeId {\n         let tcx = self.terms_cx.tcx;\n         assert!(is_lifetime(&tcx.map, param_id));\n-        match tcx.named_region_map.find(&param_id) {\n+        match tcx.named_region_map.get(&param_id) {\n             Some(&rl::DefEarlyBoundRegion(_, _, lifetime_decl_id))\n                 => lifetime_decl_id,\n             Some(_) => panic!(\"should not encounter non early-bound cases\"),\n@@ -810,7 +810,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n \n             ty::ty_param(ty::ParamTy { ref def_id, .. }) => {\n                 assert_eq!(def_id.krate, ast::LOCAL_CRATE);\n-                match self.terms_cx.inferred_map.find(&def_id.node) {\n+                match self.terms_cx.inferred_map.get(&def_id.node) {\n                     Some(&index) => {\n                         self.add_constraint(index, variance);\n                     }\n@@ -1060,7 +1060,7 @@ impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n             }\n \n             let newly_added = tcx.item_variance_map.borrow_mut()\n-                                 .insert(item_def_id, Rc::new(item_variances));\n+                                 .insert(item_def_id, Rc::new(item_variances)).is_none();\n             assert!(newly_added);\n         }\n     }"}, {"sha": "577d92744e6dcc7cbbe1c0de9cd2d31d1b24e3cf", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -139,7 +139,7 @@ pub fn can_reach<S,H:Hasher<S>,T:Eq+Clone+Hash<S>>(\n     let mut queue = vec!(source);\n     let mut i = 0;\n     while i < queue.len() {\n-        match edges_map.find(&queue[i]) {\n+        match edges_map.get(&queue[i]) {\n             Some(edges) => {\n                 for target in edges.iter() {\n                     if *target == destination {\n@@ -200,7 +200,7 @@ pub fn memoized_with_key<T, K: Hash<S> + Eq, U: Clone, S, H: Hasher<S>>(\n     k: |&T| -> K\n ) -> U {\n     let key = k(&arg);\n-    let result = cache.borrow().find(&key).map(|result| result.clone());\n+    let result = cache.borrow().get(&key).map(|result| result.clone());\n     match result {\n         Some(result) => result,\n         None => {"}, {"sha": "9080b12c5436abfb0f701ad684a2cddfbfd48b57", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -451,7 +451,7 @@ pub fn ty_to_string(cx: &ctxt, typ: t) -> String {\n         ty_str => \"str\".to_string(),\n         ty_unboxed_closure(ref did, _, ref substs) => {\n             let unboxed_closures = cx.unboxed_closures.borrow();\n-            unboxed_closures.find(did).map(|cl| {\n+            unboxed_closures.get(did).map(|cl| {\n                 closure_to_string(cx, &cl.closure_type.subst(cx, substs))\n             }).unwrap_or_else(|| \"closure\".to_string())\n         }\n@@ -1108,7 +1108,7 @@ impl UserString for ty::ParamBounds {\n \n impl UserString for ty::ExistentialBounds {\n     fn user_string(&self, tcx: &ctxt) -> String {\n-        if self.builtin_bounds.contains_elem(ty::BoundSend) &&\n+        if self.builtin_bounds.contains(&ty::BoundSend) &&\n             self.region_bound == ty::ReStatic\n         { // Region bound is implied by builtin bounds:\n             return self.builtin_bounds.repr(tcx);\n@@ -1277,7 +1277,7 @@ impl UserString for ParamTy {\n     fn user_string(&self, tcx: &ctxt) -> String {\n         let id = self.idx;\n         let did = self.def_id;\n-        let ident = match tcx.ty_param_defs.borrow().find(&did.node) {\n+        let ident = match tcx.ty_param_defs.borrow().get(&did.node) {\n             Some(def) => token::get_name(def.name).get().to_string(),\n \n             // This can only happen when a type mismatch error happens and"}, {"sha": "335317be4b419a0753b97977d7f6a175246c40ca", "filename": "src/librustc_back/abi.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc_back%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc_back%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fabi.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -14,6 +14,9 @@ pub const box_field_refcnt: uint = 0u;\n pub const box_field_drop_glue: uint = 1u;\n pub const box_field_body: uint = 4u;\n \n+// FIXME(18590) although we have three different layouts here, the compiler relies on\n+// them being the same. We should replace them with one set of constants.\n+\n // The two halves of a closure: code and environment.\n pub const fn_field_code: uint = 0u;\n pub const fn_field_box: uint = 1u;"}, {"sha": "97bc747916d03415a91772dbfbc9f7186758075d", "filename": "src/librustc_back/target/arm_linux_androideabi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc_back%2Ftarget%2Farm_linux_androideabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc_back%2Ftarget%2Farm_linux_androideabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Farm_linux_androideabi.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -17,7 +17,7 @@ pub fn target() -> Target {\n     // linker doesn't like that by default.\n     base.pre_link_args.push(\"-Wl,--allow-multiple-definition\".to_string());\n     // FIXME #17437 (and #17448): Android doesn't support position dependant executables anymore.\n-    base.position_independant_executables = false;\n+    base.position_independent_executables = false;\n \n     Target {\n         data_layout: \"e-p:32:32:32\\"}, {"sha": "305862d357a49367ca94fc19871137edd2288745", "filename": "src/librustc_back/target/arm_unknown_linux_gnueabihf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc_back%2Ftarget%2Farm_unknown_linux_gnueabihf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc_back%2Ftarget%2Farm_unknown_linux_gnueabihf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Farm_unknown_linux_gnueabihf.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -18,7 +18,7 @@ pub fn target() -> Target {\n                       -f32:32:32-f64:64:64\\\n                       -v64:64:64-v128:64:128\\\n                       -a0:0:64-n32\".to_string(),\n-        llvm_target: \"arm-unknown-linux-gnueabi\".to_string(),\n+        llvm_target: \"arm-unknown-linux-gnueabihf\".to_string(),\n         target_endian: \"little\".to_string(),\n         target_word_size: \"32\".to_string(),\n         arch: \"arm\".to_string(),"}, {"sha": "a12657ff4dcdcc763f4e1c7f2919e239fe60f1e7", "filename": "src/librustc_back/target/i686_unknown_dragonfly.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_dragonfly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_dragonfly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_dragonfly.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -11,7 +11,7 @@\n use target::Target;\n \n pub fn target() -> Target {\n-    let mut base = super::draginfly_base::opts();\n+    let mut base = super::dragonfly_base::opts();\n     base.pre_link_args.push(\"-m32\".to_string());\n \n     Target {"}, {"sha": "d267bc77e4975d52aca8dd8a8488aad6b1691aa0", "filename": "src/librustc_back/target/linux_base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc_back%2Ftarget%2Flinux_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc_back%2Ftarget%2Flinux_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Flinux_base.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -25,7 +25,7 @@ pub fn opts() -> TargetOptions {\n             // follow this flag. Thus, use it before specifying libraries to link to.\n             \"-Wl,--as-needed\".to_string(),\n         ),\n-        position_independant_executables: true,\n+        position_independent_executables: true,\n         .. Default::default()\n     }\n }"}, {"sha": "d7b4285cdb0aba53d04c335416a645c446266dfe", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -63,6 +63,7 @@ mod arm_unknown_linux_gnueabihf;\n mod i686_apple_darwin;\n mod i386_apple_ios;\n mod i686_pc_windows_gnu;\n+mod i686_unknown_dragonfly;\n mod i686_unknown_linux_gnu;\n mod mips_unknown_linux_gnu;\n mod mipsel_unknown_linux_gnu;\n@@ -158,7 +159,7 @@ pub struct TargetOptions {\n     /// relocation model of position independent code is not changed. This is a requirement to take\n     /// advantage of ASLR, as otherwise the functions in the executable are not randomized and can\n     /// be used during an exploit of a vulnerability in any code.\n-    pub position_independant_executables: bool,\n+    pub position_independent_executables: bool,\n }\n \n impl Default for TargetOptions {\n@@ -189,7 +190,7 @@ impl Default for TargetOptions {\n             linker_is_gnu: false,\n             has_rpath: false,\n             no_compiler_rt: false,\n-            position_independant_executables: false,\n+            position_independent_executables: false,\n         }\n     }\n }\n@@ -338,6 +339,7 @@ impl Target {\n \n             x86_64_unknown_freebsd,\n \n+            i686_unknown_dragonfly,\n             x86_64_unknown_dragonfly,\n \n             x86_64_apple_darwin,"}, {"sha": "bcbd09d7b119e190fe3200ff7d836d1067ab0a50", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -45,7 +45,7 @@ pub fn try_inline(cx: &DocContext, id: ast::NodeId, into: Option<ast::Ident>)\n         Some(tcx) => tcx,\n         None => return None,\n     };\n-    let def = match tcx.def_map.borrow().find(&id) {\n+    let def = match tcx.def_map.borrow().get(&id) {\n         Some(def) => *def,\n         None => return None,\n     };\n@@ -223,7 +223,7 @@ fn build_impls(cx: &DocContext, tcx: &ty::ctxt,\n     ty::populate_implementations_for_type_if_necessary(tcx, did);\n     let mut impls = Vec::new();\n \n-    match tcx.inherent_impls.borrow().find(&did) {\n+    match tcx.inherent_impls.borrow().get(&did) {\n         None => {}\n         Some(i) => {\n             impls.extend(i.iter().map(|&did| { build_impl(cx, tcx, did) }));\n@@ -323,7 +323,6 @@ fn build_impl(cx: &DocContext, tcx: &ty::ctxt,\n             trait_: associated_trait.clean(cx).map(|bound| {\n                 match bound {\n                     clean::TraitBound(ty) => ty,\n-                    clean::UnboxedFnBound(..) |\n                     clean::RegionBound(..) => unreachable!(),\n                 }\n             }),"}, {"sha": "4478c29f66a48f2668eaf072ab7c9cb44647352b", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 18, "deletions": 22, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -476,15 +476,13 @@ impl Clean<TyParam> for ty::TypeParameterDef {\n #[deriving(Clone, Encodable, Decodable, PartialEq)]\n pub enum TyParamBound {\n     RegionBound(Lifetime),\n-    UnboxedFnBound(UnboxedFnType),\n     TraitBound(Type)\n }\n \n impl Clean<TyParamBound> for ast::TyParamBound {\n     fn clean(&self, cx: &DocContext) -> TyParamBound {\n         match *self {\n             ast::RegionTyParamBound(lt) => RegionBound(lt.clean(cx)),\n-            ast::UnboxedFnTyParamBound(ref ty) => { UnboxedFnBound(ty.clean(cx)) },\n             ast::TraitTyParamBound(ref t) => TraitBound(t.clean(cx)),\n         }\n     }\n@@ -599,21 +597,6 @@ impl Clean<Option<Vec<TyParamBound>>> for subst::Substs {\n     }\n }\n \n-#[deriving(Clone, Encodable, Decodable, PartialEq)]\n-pub struct UnboxedFnType {\n-    pub path: Path,\n-    pub decl: FnDecl\n-}\n-\n-impl Clean<UnboxedFnType> for ast::UnboxedFnBound {\n-    fn clean(&self, cx: &DocContext) -> UnboxedFnType {\n-        UnboxedFnType {\n-            path: self.path.clean(cx),\n-            decl: self.decl.clean(cx)\n-        }\n-    }\n-}\n-\n #[deriving(Clone, Encodable, Decodable, PartialEq)]\n pub struct Lifetime(String);\n \n@@ -1395,7 +1378,7 @@ impl Clean<Item> for ty::field_ty {\n         let (name, attrs) = if self.name == unnamed_field.name {\n             (None, None)\n         } else {\n-            (Some(self.name), Some(attr_map.find(&self.id.node).unwrap()))\n+            (Some(self.name), Some(attr_map.get(&self.id.node).unwrap()))\n         };\n \n         let ty = ty::lookup_item_type(cx.tcx(), self.id);\n@@ -1641,10 +1624,23 @@ pub struct PathSegment {\n \n impl Clean<PathSegment> for ast::PathSegment {\n     fn clean(&self, cx: &DocContext) -> PathSegment {\n+        let (lifetimes, types) = match self.parameters {\n+            ast::AngleBracketedParameters(ref data) => {\n+                (data.lifetimes.clean(cx), data.types.clean(cx))\n+            }\n+\n+            ast::ParenthesizedParameters(ref data) => {\n+                // FIXME -- rustdoc should be taught about Foo() notation\n+                let inputs = Tuple(data.inputs.clean(cx));\n+                let output = data.output.as_ref().map(|t| t.clean(cx)).unwrap_or(Tuple(Vec::new()));\n+                (Vec::new(), vec![inputs, output])\n+            }\n+        };\n+\n         PathSegment {\n             name: self.identifier.clean(cx),\n-            lifetimes: self.lifetimes.clean(cx),\n-            types: self.types.clean(cx),\n+            lifetimes: lifetimes,\n+            types: types,\n         }\n     }\n }\n@@ -2090,7 +2086,7 @@ fn resolve_type(cx: &DocContext, path: Path,\n         None => return Primitive(Bool),\n     };\n     debug!(\"searching for {} in defmap\", id);\n-    let def = match tcx.def_map.borrow().find(&id) {\n+    let def = match tcx.def_map.borrow().get(&id) {\n         Some(&k) => k,\n         None => panic!(\"unresolved id not in defmap\")\n     };\n@@ -2159,7 +2155,7 @@ fn resolve_use_source(cx: &DocContext, path: Path, id: ast::NodeId) -> ImportSou\n \n fn resolve_def(cx: &DocContext, id: ast::NodeId) -> Option<ast::DefId> {\n     cx.tcx_opt().and_then(|tcx| {\n-        tcx.def_map.borrow().find(&id).map(|&def| register_def(cx, def))\n+        tcx.def_map.borrow().get(&id).map(|&def| register_def(cx, def))\n     })\n }\n "}, {"sha": "fe96c9b3a9f6a07b090d20a97d20fd0851c9d60b", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -143,9 +143,6 @@ impl fmt::Show for clean::TyParamBound {\n             clean::RegionBound(ref lt) => {\n                 write!(f, \"{}\", *lt)\n             }\n-            clean::UnboxedFnBound(ref ty) => {\n-                write!(f, \"{}{}\", ty.path, ty.decl)\n-            }\n             clean::TraitBound(ref ty) => {\n                 write!(f, \"{}\", *ty)\n             }\n@@ -208,7 +205,7 @@ fn resolved_path(w: &mut fmt::Formatter, did: ast::DefId, p: &clean::Path,\n             }\n         },\n         |cache| {\n-            match cache.paths.find(&did) {\n+            match cache.paths.get(&did) {\n                 None => None,\n                 Some(&(ref fqp, shortty)) => Some((fqp.clone(), shortty))\n             }\n@@ -313,7 +310,7 @@ fn primitive_link(f: &mut fmt::Formatter,\n                   name: &str) -> fmt::Result {\n     let m = cache_key.get().unwrap();\n     let mut needs_termination = false;\n-    match m.primitive_locations.find(&prim) {\n+    match m.primitive_locations.get(&prim) {\n         Some(&ast::LOCAL_CRATE) => {\n             let loc = current_location_key.get().unwrap();\n             let len = if loc.len() == 0 {0} else {loc.len() - 1};\n@@ -404,8 +401,7 @@ impl fmt::Show for clean::Type {\n                            let mut ret = String::new();\n                            for bound in decl.bounds.iter() {\n                                 match *bound {\n-                                    clean::RegionBound(..) |\n-                                    clean::UnboxedFnBound(..) => {}\n+                                    clean::RegionBound(..) => {}\n                                     clean::TraitBound(ref t) => {\n                                         if ret.len() == 0 {\n                                             ret.push_str(\": \");"}, {"sha": "9dacee1652a4a235f4f4c997d19305dc44a46813", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -242,7 +242,7 @@ pub fn render(w: &mut fmt::Formatter, s: &str, print_toc: bool) -> fmt::Result {\n \n         // Make sure our hyphenated ID is unique for this page\n         let map = used_header_map.get().unwrap();\n-        let id = match map.borrow_mut().find_mut(&id) {\n+        let id = match map.borrow_mut().get_mut(&id) {\n             None => id,\n             Some(a) => { *a += 1; format!(\"{}-{}\", id, *a - 1) }\n         };"}, {"sha": "fbd2611acb92d444e8f6c49002917e08e4d2e8d9", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -389,7 +389,7 @@ fn build_index(krate: &clean::Crate, cache: &mut Cache) -> io::IoResult<String>\n         // has since been learned.\n         for &(pid, ref item) in orphan_methods.iter() {\n             let did = ast_util::local_def(pid);\n-            match paths.find(&did) {\n+            match paths.get(&did) {\n                 Some(&(ref fqp, _)) => {\n                     search_index.push(IndexItem {\n                         ty: shortty(item),\n@@ -443,7 +443,7 @@ fn build_index(krate: &clean::Crate, cache: &mut Cache) -> io::IoResult<String>\n                     item.desc.to_json().to_string()));\n         match item.parent {\n             Some(nodeid) => {\n-                let pathid = *nodeid_to_pathid.find(&nodeid).unwrap();\n+                let pathid = *nodeid_to_pathid.get(&nodeid).unwrap();\n                 try!(write!(&mut w, \",{}\", pathid));\n             }\n             None => {}\n@@ -454,7 +454,7 @@ fn build_index(krate: &clean::Crate, cache: &mut Cache) -> io::IoResult<String>\n     try!(write!(&mut w, r#\"],\"paths\":[\"#));\n \n     for (i, &did) in pathid_to_nodeid.iter().enumerate() {\n-        let &(ref fqp, short) = cache.paths.find(&did).unwrap();\n+        let &(ref fqp, short) = cache.paths.get(&did).unwrap();\n         if i > 0 {\n             try!(write!(&mut w, \",\"));\n         }\n@@ -543,7 +543,7 @@ fn write_shared(cx: &Context,\n         //\n         // FIXME: this is a vague explanation for why this can't be a `get`, in\n         //        theory it should be...\n-        let &(ref remote_path, remote_item_type) = match cache.paths.find(&did) {\n+        let &(ref remote_path, remote_item_type) = match cache.paths.get(&did) {\n             Some(p) => p,\n             None => continue,\n         };\n@@ -838,7 +838,7 @@ impl DocFolder for Cache {\n                         } else {\n                             let last = self.parent_stack.last().unwrap();\n                             let did = *last;\n-                            let path = match self.paths.find(&did) {\n+                            let path = match self.paths.get(&did) {\n                                 Some(&(_, item_type::Trait)) =>\n                                     Some(self.stack[..self.stack.len() - 1]),\n                                 // The current stack not necessarily has correlation for\n@@ -1170,7 +1170,7 @@ impl Context {\n                                     &Item{ cx: cx, item: it }));\n             } else {\n                 let mut url = \"../\".repeat(cx.current.len());\n-                match cache_key.get().unwrap().paths.find(&it.def_id) {\n+                match cache_key.get().unwrap().paths.get(&it.def_id) {\n                     Some(&(ref names, _)) => {\n                         for name in names[..names.len() - 1].iter() {\n                             url.push_str(name.as_slice());\n@@ -1735,7 +1735,7 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n         <h2 id='implementors'>Implementors</h2>\n         <ul class='item-list' id='implementors-list'>\n     \"));\n-    match cache.implementors.find(&it.def_id) {\n+    match cache.implementors.get(&it.def_id) {\n         Some(implementors) => {\n             for i in implementors.iter() {\n                 try!(writeln!(w, \"<li>{}<code>impl{} {} for {}{}</code></li>\",\n@@ -1992,7 +1992,7 @@ fn render_struct(w: &mut fmt::Formatter, it: &clean::Item,\n }\n \n fn render_methods(w: &mut fmt::Formatter, it: &clean::Item) -> fmt::Result {\n-    match cache_key.get().unwrap().impls.find(&it.def_id) {\n+    match cache_key.get().unwrap().impls.get(&it.def_id) {\n         Some(v) => {\n             let (non_trait, traits) = v.partitioned(|i| i.impl_.trait_.is_none());\n             if non_trait.len() > 0 {\n@@ -2080,7 +2080,7 @@ fn render_impl(w: &mut fmt::Formatter, i: &Impl) -> fmt::Result {\n     match i.impl_.trait_ {\n         Some(clean::ResolvedPath { did, .. }) => {\n             try!({\n-                match cache_key.get().unwrap().traits.find(&did) {\n+                match cache_key.get().unwrap().traits.get(&did) {\n                     Some(t) => try!(render_default_methods(w, t, &i.impl_)),\n                     None => {}\n                 }"}, {"sha": "5e2f56e00fc0db828fd0f4b45fc33694004d12a1", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -417,7 +417,7 @@ fn json_input(input: &str) -> Result<Output, String> {\n         Ok(json::Object(obj)) => {\n             let mut obj = obj;\n             // Make sure the schema is what we expect\n-            match obj.pop(&\"schema\".to_string()) {\n+            match obj.remove(&\"schema\".to_string()) {\n                 Some(json::String(version)) => {\n                     if version.as_slice() != SCHEMA_VERSION {\n                         return Err(format!(\n@@ -428,7 +428,7 @@ fn json_input(input: &str) -> Result<Output, String> {\n                 Some(..) => return Err(\"malformed json\".to_string()),\n                 None => return Err(\"expected a schema version\".to_string()),\n             }\n-            let krate = match obj.pop(&\"crate\".to_string()) {\n+            let krate = match obj.remove(&\"crate\".to_string()) {\n                 Some(json) => {\n                     let mut d = json::Decoder::new(json);\n                     Decodable::decode(&mut d).unwrap()"}, {"sha": "4a16bcf939e7b32ebed586f223cacbf0bc4c9bf7", "filename": "src/librustrt/local_data.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustrt%2Flocal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibrustrt%2Flocal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Flocal_data.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -186,7 +186,7 @@ impl<T: 'static> KeyValue<T> {\n \n         // The following match takes a mutable borrow on the map. In order to insert\n         // our data if the key isn't present, we need to let the match end first.\n-        let data = match (map.find_mut(&keyval), data) {\n+        let data = match (map.get_mut(&keyval), data) {\n             (None, Some(data)) => {\n                 // The key doesn't exist and we need to insert it. To make borrowck\n                 // happy, return it up a scope and insert it there.\n@@ -266,7 +266,7 @@ impl<T: 'static> KeyValue<T> {\n         };\n         let keyval = key_to_key_value(self);\n \n-        match map.find(&keyval) {\n+        match map.get(&keyval) {\n             Some(slot) => {\n                 let value_box = slot.box_ptr as *mut TLDValueBox<T>;\n                 if unsafe { *(*value_box).refcount.get() } >= 1 {"}, {"sha": "f287fb99750aa6a09b2ac44a054c1ac5eb2be5b9", "filename": "src/libserialize/base64.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibserialize%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibserialize%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fbase64.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -54,13 +54,13 @@ static URLSAFE_CHARS: &'static[u8] = b\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\\n                                        0123456789-_\";\n \n /// A trait for converting a value to base64 encoding.\n-pub trait ToBase64 {\n+pub trait ToBase64 for Sized? {\n     /// Converts the value of `self` to a base64 value following the specified\n     /// format configuration, returning the owned string.\n     fn to_base64(&self, config: Config) -> String;\n }\n \n-impl<'a> ToBase64 for &'a [u8] {\n+impl ToBase64 for [u8] {\n     /**\n      * Turn a vector of `u8` bytes into a base64 string.\n      *\n@@ -155,7 +155,7 @@ impl<'a> ToBase64 for &'a [u8] {\n }\n \n /// A trait for converting from base64 encoded values.\n-pub trait FromBase64 {\n+pub trait FromBase64 for Sized? {\n     /// Converts the value of `self`, interpreted as base64 encoded data, into\n     /// an owned vector of bytes, returning the vector.\n     fn from_base64(&self) -> Result<Vec<u8>, FromBase64Error>;\n@@ -192,7 +192,7 @@ impl error::Error for FromBase64Error {\n     }\n }\n \n-impl<'a> FromBase64 for &'a str {\n+impl FromBase64 for str {\n     /**\n      * Convert any base64 encoded string (literal, `@`, `&`, or `~`)\n      * to the byte values it encodes.\n@@ -227,7 +227,7 @@ impl<'a> FromBase64 for &'a str {\n     }\n }\n \n-impl<'a> FromBase64 for &'a [u8] {\n+impl FromBase64 for [u8] {\n     fn from_base64(&self) -> Result<Vec<u8>, FromBase64Error> {\n         let mut r = Vec::new();\n         let mut buf: u32 = 0;"}, {"sha": "d2d1f5fa8b091e90c74ba82475521c45e1d972b1", "filename": "src/libserialize/collection_impls.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibserialize%2Fcollection_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibserialize%2Fcollection_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fcollection_impls.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -39,7 +39,7 @@ impl<E, D:Decoder<E>,T:Decodable<D, E>> Decodable<D, E> for DList<T> {\n         d.read_seq(|d, len| {\n             let mut list = DList::new();\n             for i in range(0u, len) {\n-                list.push(try!(d.read_seq_elt(i, |d| Decodable::decode(d))));\n+                list.push_back(try!(d.read_seq_elt(i, |d| Decodable::decode(d))));\n             }\n             Ok(list)\n         })\n@@ -66,7 +66,7 @@ impl<E, D:Decoder<E>,T:Decodable<D, E>> Decodable<D, E> for RingBuf<T> {\n         d.read_seq(|d, len| {\n             let mut deque: RingBuf<T> = RingBuf::new();\n             for i in range(0u, len) {\n-                deque.push(try!(d.read_seq_elt(i, |d| Decodable::decode(d))));\n+                deque.push_back(try!(d.read_seq_elt(i, |d| Decodable::decode(d))));\n             }\n             Ok(deque)\n         })\n@@ -165,10 +165,10 @@ impl<\n > Decodable<D, E> for EnumSet<T> {\n     fn decode(d: &mut D) -> Result<EnumSet<T>, E> {\n         let bits = try!(d.read_uint());\n-        let mut set = EnumSet::empty();\n+        let mut set = EnumSet::new();\n         for bit in range(0, uint::BITS) {\n             if bits & (1 << bit) != 0 {\n-                set.add(CLike::from_uint(1 << bit));\n+                set.insert(CLike::from_uint(1 << bit));\n             }\n         }\n         Ok(set)"}, {"sha": "e045f94c08e67b87840609ec7d351a662ab381a7", "filename": "src/libserialize/hex.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibserialize%2Fhex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibserialize%2Fhex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fhex.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -16,15 +16,15 @@ use std::string;\n use std::error;\n \n /// A trait for converting a value to hexadecimal encoding\n-pub trait ToHex {\n+pub trait ToHex for Sized? {\n     /// Converts the value of `self` to a hex value, returning the owned\n     /// string.\n     fn to_hex(&self) -> String;\n }\n \n static CHARS: &'static[u8] = b\"0123456789abcdef\";\n \n-impl<'a> ToHex for &'a [u8] {\n+impl ToHex for [u8] {\n     /**\n      * Turn a vector of `u8` bytes into a hexadecimal string.\n      *\n@@ -54,7 +54,7 @@ impl<'a> ToHex for &'a [u8] {\n }\n \n /// A trait for converting hexadecimal encoded values\n-pub trait FromHex {\n+pub trait FromHex for Sized? {\n     /// Converts the value of `self`, interpreted as hexadecimal encoded data,\n     /// into an owned vector of bytes, returning the vector.\n     fn from_hex(&self) -> Result<Vec<u8>, FromHexError>;\n@@ -92,7 +92,7 @@ impl error::Error for FromHexError {\n }\n \n \n-impl<'a> FromHex for &'a str {\n+impl FromHex for str {\n     /**\n      * Convert any hexadecimal encoded string (literal, `@`, `&`, or `~`)\n      * to the byte values it encodes."}, {"sha": "7731351758558c01d2914ddacd6367ac41ae22ea", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -2113,7 +2113,7 @@ impl ::Decoder<DecoderError> for Decoder {\n         let name = match self.pop() {\n             String(s) => s,\n             Object(mut o) => {\n-                let n = match o.pop(&\"variant\".to_string()) {\n+                let n = match o.remove(&\"variant\".to_string()) {\n                     Some(String(s)) => s,\n                     Some(val) => {\n                         return Err(ExpectedError(\"String\".to_string(), format!(\"{}\", val)))\n@@ -2122,7 +2122,7 @@ impl ::Decoder<DecoderError> for Decoder {\n                         return Err(MissingFieldError(\"variant\".to_string()))\n                     }\n                 };\n-                match o.pop(&\"fields\".to_string()) {\n+                match o.remove(&\"fields\".to_string()) {\n                     Some(List(l)) => {\n                         for field in l.into_iter().rev() {\n                             self.stack.push(field);\n@@ -2192,7 +2192,7 @@ impl ::Decoder<DecoderError> for Decoder {\n         debug!(\"read_struct_field(name={}, idx={})\", name, idx);\n         let mut obj = try!(expect!(self.pop(), Object));\n \n-        let value = match obj.pop(&name.to_string()) {\n+        let value = match obj.remove(&name.to_string()) {\n             None => {\n                 // Add a Null and try to parse it as an Option<_>\n                 // to get None as a default value.\n@@ -2303,7 +2303,7 @@ impl ::Decoder<DecoderError> for Decoder {\n }\n \n /// A trait for converting values to JSON\n-pub trait ToJson {\n+pub trait ToJson for Sized? {\n     /// Converts the value of `self` to an instance of JSON\n     fn to_json(&self) -> Json;\n }\n@@ -2389,7 +2389,7 @@ tuple_impl!{A, B, C, D, E, F, G, H, I, J}\n tuple_impl!{A, B, C, D, E, F, G, H, I, J, K}\n tuple_impl!{A, B, C, D, E, F, G, H, I, J, K, L}\n \n-impl<'a, A: ToJson> ToJson for &'a [A] {\n+impl<A: ToJson> ToJson for [A] {\n     fn to_json(&self) -> Json { List(self.iter().map(|elt| elt.to_json()).collect()) }\n }\n \n@@ -3072,8 +3072,8 @@ mod tests {\n                   \\\"fields\\\":[\\\"Henry\\\", 349]}}\";\n         let mut map: TreeMap<string::String, Animal> = super::decode(s).unwrap();\n \n-        assert_eq!(map.pop(&\"a\".to_string()), Some(Dog));\n-        assert_eq!(map.pop(&\"b\".to_string()), Some(Frog(\"Henry\".to_string(), 349)));\n+        assert_eq!(map.remove(&\"a\".to_string()), Some(Dog));\n+        assert_eq!(map.remove(&\"b\".to_string()), Some(Frog(\"Henry\".to_string(), 349)));\n     }\n \n     #[test]"}, {"sha": "7539a6dc3486b285ea54f31313f8c971c31ef342", "filename": "src/libserialize/serialize.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibserialize%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibserialize%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fserialize.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -169,7 +169,7 @@ pub trait Decoder<E> {\n     fn error(&mut self, err: &str) -> E;\n }\n \n-pub trait Encodable<S:Encoder<E>, E> {\n+pub trait Encodable<S:Encoder<E>, E> for Sized? {\n     fn encode(&self, s: &mut S) -> Result<(), E>;\n }\n \n@@ -297,9 +297,9 @@ impl<E, D:Decoder<E>> Decodable<D, E> for i64 {\n     }\n }\n \n-impl<'a, E, S:Encoder<E>> Encodable<S, E> for &'a str {\n+impl<E, S:Encoder<E>> Encodable<S, E> for str {\n     fn encode(&self, s: &mut S) -> Result<(), E> {\n-        s.emit_str(*self)\n+        s.emit_str(self)\n     }\n }\n \n@@ -375,24 +375,31 @@ impl<E, D:Decoder<E>> Decodable<D, E> for () {\n     }\n }\n \n-impl<'a, E, S:Encoder<E>,T:Encodable<S, E>> Encodable<S, E> for &'a T {\n+impl<'a, E, S: Encoder<E>, Sized? T: Encodable<S, E>> Encodable<S, E> for &'a T {\n     fn encode(&self, s: &mut S) -> Result<(), E> {\n         (**self).encode(s)\n     }\n }\n \n-impl<E, S:Encoder<E>,T:Encodable<S, E>> Encodable<S, E> for Box<T> {\n+impl<E, S: Encoder<E>, Sized? T: Encodable<S, E>> Encodable<S, E> for Box<T> {\n     fn encode(&self, s: &mut S) -> Result<(), E> {\n         (**self).encode(s)\n     }\n }\n \n-impl<E, D:Decoder<E>,T:Decodable<D, E>> Decodable<D, E> for Box<T> {\n+impl<E, D:Decoder<E>, T: Decodable<D, E>> Decodable<D, E> for Box<T> {\n     fn decode(d: &mut D) -> Result<Box<T>, E> {\n         Ok(box try!(Decodable::decode(d)))\n     }\n }\n \n+impl<E, D:Decoder<E>, T: Decodable<D, E>> Decodable<D, E> for Box<[T]> {\n+    fn decode(d: &mut D) -> Result<Box<[T]>, E> {\n+        let v: Vec<T> = try!(Decodable::decode(d));\n+        Ok(v.into_boxed_slice())\n+    }\n+}\n+\n impl<E, S:Encoder<E>,T:Encodable<S, E>> Encodable<S, E> for Rc<T> {\n     #[inline]\n     fn encode(&self, s: &mut S) -> Result<(), E> {\n@@ -407,7 +414,7 @@ impl<E, D:Decoder<E>,T:Decodable<D, E>> Decodable<D, E> for Rc<T> {\n     }\n }\n \n-impl<'a, E, S:Encoder<E>,T:Encodable<S, E>> Encodable<S, E> for &'a [T] {\n+impl<E, S:Encoder<E>,T:Encodable<S, E>> Encodable<S, E> for [T] {\n     fn encode(&self, s: &mut S) -> Result<(), E> {\n         s.emit_seq(self.len(), |s| {\n             for (i, e) in self.iter().enumerate() {"}, {"sha": "87aebb24f987b7c6295c59031a3e3a82dbbda012", "filename": "src/libstd/collections/hash/bench.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibstd%2Fcollections%2Fhash%2Fbench.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibstd%2Fcollections%2Fhash%2Fbench.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fbench.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -102,14 +102,14 @@ fn hashmap_as_queue(b: &mut Bencher) {\n     let mut k = 1i;\n \n     b.iter(|| {\n-        m.pop(&k);\n+        m.remove(&k);\n         m.insert(k + 1000, k + 1000);\n         k += 1;\n     });\n }\n \n #[bench]\n-fn find_pop_insert(b: &mut Bencher) {\n+fn get_remove_insert(b: &mut Bencher) {\n     use super::map::HashMap;\n \n     let mut m = HashMap::new();\n@@ -121,9 +121,9 @@ fn find_pop_insert(b: &mut Bencher) {\n     let mut k = 1i;\n \n     b.iter(|| {\n-        m.find(&(k + 400));\n-        m.find(&(k + 2000));\n-        m.pop(&k);\n+        m.get(&(k + 400));\n+        m.get(&(k + 2000));\n+        m.remove(&k);\n         m.insert(k + 1000, k + 1000);\n         k += 1;\n     })"}, {"sha": "e164128eeb10a86dc9382d7ef8779e55fa1e9f7d", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 110, "deletions": 145, "changes": 255, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -36,6 +36,9 @@ use super::table::{\n     SafeHash\n };\n \n+// FIXME(conventions): update capacity management to match other collections (no auto-shrink)\n+// FIXME(conventions): axe find_copy/get_copy in favour of Option.cloned (also implement that)\n+\n const INITIAL_LOG2_CAP: uint = 5;\n pub const INITIAL_CAPACITY: uint = 1 << INITIAL_LOG2_CAP; // 2^5\n \n@@ -233,7 +236,7 @@ impl DefaultResizePolicy {\n /// // look up the values associated with some keys.\n /// let to_find = [\"Pride and Prejudice\", \"Alice's Adventure in Wonderland\"];\n /// for book in to_find.iter() {\n-///     match book_reviews.find(book) {\n+///     match book_reviews.get(book) {\n ///         Some(review) => println!(\"{}: {}\", *book, *review),\n ///         None => println!(\"{} is unreviewed.\", *book)\n ///     }\n@@ -477,9 +480,10 @@ impl<K: Hash + Eq, V> HashMap<K, V, RandomSipHasher> {\n     ///\n     /// ```\n     /// use std::collections::HashMap;\n-    /// let mut map: HashMap<&str, int> = HashMap::with_capacity(10);\n+    /// let mut map: HashMap<&str, int> = HashMap::new();\n     /// ```\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn new() -> HashMap<K, V, RandomSipHasher> {\n         let hasher = RandomSipHasher::new();\n         HashMap::with_hasher(hasher)\n@@ -494,6 +498,7 @@ impl<K: Hash + Eq, V> HashMap<K, V, RandomSipHasher> {\n     /// let mut map: HashMap<&str, int> = HashMap::with_capacity(10);\n     /// ```\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn with_capacity(capacity: uint) -> HashMap<K, V, RandomSipHasher> {\n         let hasher = RandomSipHasher::new();\n         HashMap::with_capacity_and_hasher(capacity, hasher)\n@@ -741,38 +746,6 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n         }\n     }\n \n-    /// Retrieves a mutable value for the given key.\n-    /// See [`find_mut`](../trait.MutableMap.html#tymethod.find_mut) for a non-panicking\n-    /// alternative.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Fails if the key is not present.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// # #![allow(deprecated)]\n-    /// use std::collections::HashMap;\n-    ///\n-    /// let mut map = HashMap::new();\n-    /// map.insert(\"a\", 1i);\n-    /// {\n-    ///     // val will freeze map to prevent usage during its lifetime\n-    ///     let val = map.get_mut(&\"a\");\n-    ///     *val = 40;\n-    /// }\n-    /// assert_eq!(map[\"a\"], 40);\n-    ///\n-    /// // A more direct way could be:\n-    /// *map.get_mut(&\"a\") = -2;\n-    /// assert_eq!(map[\"a\"], -2);\n-    /// ```\n-    #[deprecated = \"use indexing instead: `&mut map[key]`\"]\n-    pub fn get_mut<'a>(&'a mut self, k: &K) -> &'a mut V {\n-        &mut self[*k]\n-    }\n-\n     /// Return true if the map contains a value for the specified key,\n     /// using equivalence.\n     ///\n@@ -875,6 +848,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     ///     println!(\"{}\", key);\n     /// }\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn keys(&self) -> Keys<K, V> {\n         self.iter().map(|(k, _v)| k)\n     }\n@@ -896,6 +870,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     ///     println!(\"{}\", key);\n     /// }\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn values(&self) -> Values<K, V> {\n         self.iter().map(|(_k, v)| v)\n     }\n@@ -917,6 +892,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     ///     println!(\"key: {} val: {}\", key, val);\n     /// }\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn iter(&self) -> Entries<K, V> {\n         Entries { inner: self.table.iter() }\n     }\n@@ -944,6 +920,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     ///     println!(\"key: {} val: {}\", key, val);\n     /// }\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn iter_mut(&mut self) -> MutEntries<K, V> {\n         MutEntries { inner: self.table.iter_mut() }\n     }\n@@ -965,6 +942,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// // Not possible with .iter()\n     /// let vec: Vec<(&str, int)> = map.into_iter().collect();\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn into_iter(self) -> MoveEntries<K, V> {\n         MoveEntries {\n             inner: self.table.into_iter().map(|(_, k, v)| (k, v))\n@@ -996,6 +974,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// a.insert(1u, \"a\");\n     /// assert_eq!(a.len(), 1);\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn len(&self) -> uint { self.table.size() }\n \n     /// Return true if the map contains no elements.\n@@ -1011,6 +990,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// assert!(!a.is_empty());\n     /// ```\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn is_empty(&self) -> bool { self.len() == 0 }\n \n     /// Clears the map, removing all key-value pairs. Keeps the allocated memory\n@@ -1026,6 +1006,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// a.clear();\n     /// assert!(a.is_empty());\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn clear(&mut self) {\n         // Prevent reallocations from happening from now on. Makes it possible\n         // for the map to be reused but has a downside: reserves permanently.\n@@ -1045,6 +1026,12 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n         }\n     }\n \n+    /// Deprecated: Renamed to `get`.\n+    #[deprecated = \"Renamed to `get`\"]\n+    pub fn find(&self, k: &K) -> Option<&V> {\n+        self.get(k)\n+    }\n+\n     /// Returns a reference to the value corresponding to the key.\n     ///\n     /// # Example\n@@ -1054,10 +1041,11 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     ///\n     /// let mut map = HashMap::new();\n     /// map.insert(1u, \"a\");\n-    /// assert_eq!(map.find(&1), Some(&\"a\"));\n-    /// assert_eq!(map.find(&2), None);\n+    /// assert_eq!(map.get(&1), Some(&\"a\"));\n+    /// assert_eq!(map.get(&2), None);\n     /// ```\n-    pub fn find<'a>(&'a self, k: &K) -> Option<&'a V> {\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn get(&self, k: &K) -> Option<&V> {\n         self.search(k).map(|bucket| {\n             let (_, v) = bucket.into_refs();\n             v\n@@ -1076,10 +1064,17 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// assert_eq!(map.contains_key(&1), true);\n     /// assert_eq!(map.contains_key(&2), false);\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn contains_key(&self, k: &K) -> bool {\n         self.search(k).is_some()\n     }\n \n+    /// Deprecated: Renamed to `get_mut`.\n+    #[deprecated = \"Renamed to `get_mut`\"]\n+    pub fn find_mut(&mut self, k: &K) -> Option<&mut V> {\n+        self.get_mut(k)\n+    }\n+\n     /// Returns a mutable reference to the value corresponding to the key.\n     ///\n     /// # Example\n@@ -1089,13 +1084,14 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     ///\n     /// let mut map = HashMap::new();\n     /// map.insert(1u, \"a\");\n-    /// match map.find_mut(&1) {\n+    /// match map.get_mut(&1) {\n     ///     Some(x) => *x = \"b\",\n     ///     None => (),\n     /// }\n     /// assert_eq!(map[1], \"b\");\n     /// ```\n-    pub fn find_mut<'a>(&'a mut self, k: &K) -> Option<&'a mut V> {\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn get_mut(&mut self, k: &K) -> Option<&mut V> {\n         match self.search_mut(k) {\n             Some(bucket) => {\n                 let (_, v) = bucket.into_mut_refs();\n@@ -1105,41 +1101,10 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n         }\n     }\n \n-    /// Inserts a key-value pair into the map. An existing value for a\n-    /// key is replaced by the new value. Returns `true` if the key did\n-    /// not already exist in the map.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashMap;\n-    ///\n-    /// let mut map = HashMap::new();\n-    /// assert_eq!(map.insert(2u, \"value\"), true);\n-    /// assert_eq!(map.insert(2, \"value2\"), false);\n-    /// assert_eq!(map[2], \"value2\");\n-    /// ```\n-    #[inline]\n-    pub fn insert(&mut self, key: K, value: V) -> bool {\n-        self.swap(key, value).is_none()\n-    }\n-\n-    /// Removes a key-value pair from the map. Returns `true` if the key\n-    /// was present in the map.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// use std::collections::HashMap;\n-    ///\n-    /// let mut map = HashMap::new();\n-    /// assert_eq!(map.remove(&1u), false);\n-    /// map.insert(1, \"a\");\n-    /// assert_eq!(map.remove(&1), true);\n-    /// ```\n-    #[inline]\n-    pub fn remove(&mut self, key: &K) -> bool {\n-        self.pop(key).is_some()\n+    /// Deprecated: Renamed to `insert`.\n+    #[deprecated = \"Renamed to `insert`\"]\n+    pub fn swap(&mut self, k: K, v: V) -> Option<V> {\n+        self.insert(k, v)\n     }\n \n     /// Inserts a key-value pair from the map. If the key already had a value\n@@ -1151,14 +1116,15 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// use std::collections::HashMap;\n     ///\n     /// let mut map = HashMap::new();\n-    /// assert_eq!(map.swap(37u, \"a\"), None);\n+    /// assert_eq!(map.insert(37u, \"a\"), None);\n     /// assert_eq!(map.is_empty(), false);\n     ///\n     /// map.insert(37, \"b\");\n-    /// assert_eq!(map.swap(37, \"c\"), Some(\"b\"));\n+    /// assert_eq!(map.insert(37, \"c\"), Some(\"b\"));\n     /// assert_eq!(map[37], \"c\");\n     /// ```\n-    pub fn swap(&mut self, k: K, v: V) -> Option<V> {\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn insert(&mut self, k: K, v: V) -> Option<V> {\n         let hash = self.make_hash(&k);\n         let potential_new_size = self.table.size() + 1;\n         self.make_some_room(potential_new_size);\n@@ -1170,6 +1136,12 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n         retval\n     }\n \n+    /// Deprecated: Renamed to `remove`.\n+    #[deprecated = \"Renamed to `remove`\"]\n+    pub fn pop(&mut self, k: &K) -> Option<V> {\n+        self.remove(k)\n+    }\n+\n     /// Removes a key from the map, returning the value at the key if the key\n     /// was previously in the map.\n     ///\n@@ -1180,10 +1152,11 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     ///\n     /// let mut map = HashMap::new();\n     /// map.insert(1u, \"a\");\n-    /// assert_eq!(map.pop(&1), Some(\"a\"));\n-    /// assert_eq!(map.pop(&1), None);\n+    /// assert_eq!(map.remove(&1), Some(\"a\"));\n+    /// assert_eq!(map.remove(&1), None);\n     /// ```\n-    pub fn pop(&mut self, k: &K) -> Option<V> {\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn remove(&mut self, k: &K) -> Option<V> {\n         if self.table.size() == 0 {\n             return None\n         }\n@@ -1260,7 +1233,7 @@ impl<K: Eq + Hash<S>, V: Clone, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// let s: String = map.find_copy(&1).unwrap();\n     /// ```\n     pub fn find_copy(&self, k: &K) -> Option<V> {\n-        self.find(k).map(|v| (*v).clone())\n+        self.get(k).map(|v| (*v).clone())\n     }\n \n     /// Return a copy of the value corresponding to the key.\n@@ -1288,7 +1261,7 @@ impl<K: Eq + Hash<S>, V: PartialEq, S, H: Hasher<S>> PartialEq for HashMap<K, V,\n         if self.len() != other.len() { return false; }\n \n         self.iter().all(|(key, value)|\n-            other.find(key).map_or(false, |v| *value == *v)\n+            other.get(key).map_or(false, |v| *value == *v)\n         )\n     }\n }\n@@ -1317,14 +1290,14 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S> + Default> Default for HashMap<K, V, H>\n impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> Index<K, V> for HashMap<K, V, H> {\n     #[inline]\n     fn index<'a>(&'a self, index: &K) -> &'a V {\n-        self.find(index).expect(\"no entry found for key\")\n+        self.get(index).expect(\"no entry found for key\")\n     }\n }\n \n impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> IndexMut<K, V> for HashMap<K, V, H> {\n     #[inline]\n     fn index_mut<'a>(&'a mut self, index: &K) -> &'a mut V {\n-        match self.find_mut(index) {\n+        match self.get_mut(index) {\n             Some(v) => v,\n             None => panic!(\"no entry found for key\")\n         }\n@@ -1514,7 +1487,7 @@ mod test_map {\n     fn test_create_capacity_zero() {\n         let mut m = HashMap::with_capacity(0);\n \n-        assert!(m.insert(1i, 1i));\n+        assert!(m.insert(1i, 1i).is_none());\n \n         assert!(m.contains_key(&1));\n         assert!(!m.contains_key(&0));\n@@ -1524,12 +1497,12 @@ mod test_map {\n     fn test_insert() {\n         let mut m = HashMap::new();\n         assert_eq!(m.len(), 0);\n-        assert!(m.insert(1i, 2i));\n+        assert!(m.insert(1i, 2i).is_none());\n         assert_eq!(m.len(), 1);\n-        assert!(m.insert(2i, 4i));\n+        assert!(m.insert(2i, 4i).is_none());\n         assert_eq!(m.len(), 2);\n-        assert_eq!(*m.find(&1).unwrap(), 2);\n-        assert_eq!(*m.find(&2).unwrap(), 4);\n+        assert_eq!(*m.get(&1).unwrap(), 2);\n+        assert_eq!(*m.get(&2).unwrap(), 4);\n     }\n \n     local_data_key!(drop_vector: RefCell<Vec<int>>)\n@@ -1588,7 +1561,7 @@ mod test_map {\n \n             for i in range(0u, 50) {\n                 let k = Dropable::new(i);\n-                let v = m.pop(&k);\n+                let v = m.remove(&k);\n \n                 assert!(v.is_some());\n \n@@ -1679,7 +1652,7 @@ mod test_map {\n     #[test]\n     fn test_empty_pop() {\n         let mut m: HashMap<int, bool> = HashMap::new();\n-        assert_eq!(m.pop(&0), None);\n+        assert_eq!(m.remove(&0), None);\n     }\n \n     #[test]\n@@ -1692,15 +1665,15 @@ mod test_map {\n             assert!(m.is_empty());\n \n             for i in range_inclusive(1i, 1000) {\n-                assert!(m.insert(i, i));\n+                assert!(m.insert(i, i).is_none());\n \n                 for j in range_inclusive(1, i) {\n-                    let r = m.find(&j);\n+                    let r = m.get(&j);\n                     assert_eq!(r, Some(&j));\n                 }\n \n                 for j in range_inclusive(i+1, 1000) {\n-                    let r = m.find(&j);\n+                    let r = m.get(&j);\n                     assert_eq!(r, None);\n                 }\n             }\n@@ -1711,7 +1684,7 @@ mod test_map {\n \n             // remove forwards\n             for i in range_inclusive(1i, 1000) {\n-                assert!(m.remove(&i));\n+                assert!(m.remove(&i).is_some());\n \n                 for j in range_inclusive(1, i) {\n                     assert!(!m.contains_key(&j));\n@@ -1727,12 +1700,12 @@ mod test_map {\n             }\n \n             for i in range_inclusive(1i, 1000) {\n-                assert!(m.insert(i, i));\n+                assert!(m.insert(i, i).is_none());\n             }\n \n             // remove backwards\n             for i in range_step_inclusive(1000i, 1, -1) {\n-                assert!(m.remove(&i));\n+                assert!(m.remove(&i).is_some());\n \n                 for j in range_inclusive(i, 1000) {\n                     assert!(!m.contains_key(&j));\n@@ -1748,68 +1721,68 @@ mod test_map {\n     #[test]\n     fn test_find_mut() {\n         let mut m = HashMap::new();\n-        assert!(m.insert(1i, 12i));\n-        assert!(m.insert(2i, 8i));\n-        assert!(m.insert(5i, 14i));\n+        assert!(m.insert(1i, 12i).is_none());\n+        assert!(m.insert(2i, 8i).is_none());\n+        assert!(m.insert(5i, 14i).is_none());\n         let new = 100;\n-        match m.find_mut(&5) {\n+        match m.get_mut(&5) {\n             None => panic!(), Some(x) => *x = new\n         }\n-        assert_eq!(m.find(&5), Some(&new));\n+        assert_eq!(m.get(&5), Some(&new));\n     }\n \n     #[test]\n     fn test_insert_overwrite() {\n         let mut m = HashMap::new();\n-        assert!(m.insert(1i, 2i));\n-        assert_eq!(*m.find(&1).unwrap(), 2);\n-        assert!(!m.insert(1i, 3i));\n-        assert_eq!(*m.find(&1).unwrap(), 3);\n+        assert!(m.insert(1i, 2i).is_none());\n+        assert_eq!(*m.get(&1).unwrap(), 2);\n+        assert!(!m.insert(1i, 3i).is_none());\n+        assert_eq!(*m.get(&1).unwrap(), 3);\n     }\n \n     #[test]\n     fn test_insert_conflicts() {\n         let mut m = HashMap::with_capacity(4);\n-        assert!(m.insert(1i, 2i));\n-        assert!(m.insert(5i, 3i));\n-        assert!(m.insert(9i, 4i));\n-        assert_eq!(*m.find(&9).unwrap(), 4);\n-        assert_eq!(*m.find(&5).unwrap(), 3);\n-        assert_eq!(*m.find(&1).unwrap(), 2);\n+        assert!(m.insert(1i, 2i).is_none());\n+        assert!(m.insert(5i, 3i).is_none());\n+        assert!(m.insert(9i, 4i).is_none());\n+        assert_eq!(*m.get(&9).unwrap(), 4);\n+        assert_eq!(*m.get(&5).unwrap(), 3);\n+        assert_eq!(*m.get(&1).unwrap(), 2);\n     }\n \n     #[test]\n     fn test_conflict_remove() {\n         let mut m = HashMap::with_capacity(4);\n-        assert!(m.insert(1i, 2i));\n-        assert_eq!(*m.find(&1).unwrap(), 2);\n-        assert!(m.insert(5, 3));\n-        assert_eq!(*m.find(&1).unwrap(), 2);\n-        assert_eq!(*m.find(&5).unwrap(), 3);\n-        assert!(m.insert(9, 4));\n-        assert_eq!(*m.find(&1).unwrap(), 2);\n-        assert_eq!(*m.find(&5).unwrap(), 3);\n-        assert_eq!(*m.find(&9).unwrap(), 4);\n-        assert!(m.remove(&1));\n-        assert_eq!(*m.find(&9).unwrap(), 4);\n-        assert_eq!(*m.find(&5).unwrap(), 3);\n+        assert!(m.insert(1i, 2i).is_none());\n+        assert_eq!(*m.get(&1).unwrap(), 2);\n+        assert!(m.insert(5, 3).is_none());\n+        assert_eq!(*m.get(&1).unwrap(), 2);\n+        assert_eq!(*m.get(&5).unwrap(), 3);\n+        assert!(m.insert(9, 4).is_none());\n+        assert_eq!(*m.get(&1).unwrap(), 2);\n+        assert_eq!(*m.get(&5).unwrap(), 3);\n+        assert_eq!(*m.get(&9).unwrap(), 4);\n+        assert!(m.remove(&1).is_some());\n+        assert_eq!(*m.get(&9).unwrap(), 4);\n+        assert_eq!(*m.get(&5).unwrap(), 3);\n     }\n \n     #[test]\n     fn test_is_empty() {\n         let mut m = HashMap::with_capacity(4);\n-        assert!(m.insert(1i, 2i));\n+        assert!(m.insert(1i, 2i).is_none());\n         assert!(!m.is_empty());\n-        assert!(m.remove(&1));\n+        assert!(m.remove(&1).is_some());\n         assert!(m.is_empty());\n     }\n \n     #[test]\n     fn test_pop() {\n         let mut m = HashMap::new();\n         m.insert(1i, 2i);\n-        assert_eq!(m.pop(&1), Some(2));\n-        assert_eq!(m.pop(&1), None);\n+        assert_eq!(m.remove(&1), Some(2));\n+        assert_eq!(m.remove(&1), None);\n     }\n \n     #[test]\n@@ -1821,19 +1794,11 @@ mod test_map {\n         assert_eq!(m.pop_equiv(&KindaIntLike(1)), None);\n     }\n \n-    #[test]\n-    fn test_swap() {\n-        let mut m = HashMap::new();\n-        assert_eq!(m.swap(1i, 2i), None);\n-        assert_eq!(m.swap(1i, 3i), Some(2));\n-        assert_eq!(m.swap(1i, 4i), Some(3));\n-    }\n-\n     #[test]\n     fn test_iterate() {\n         let mut m = HashMap::with_capacity(4);\n         for i in range(0u, 32) {\n-            assert!(m.insert(i, i*2));\n+            assert!(m.insert(i, i*2).is_none());\n         }\n         assert_eq!(m.len(), 32);\n \n@@ -1871,9 +1836,9 @@ mod test_map {\n     #[test]\n     fn test_find() {\n         let mut m = HashMap::new();\n-        assert!(m.find(&1i).is_none());\n+        assert!(m.get(&1i).is_none());\n         m.insert(1i, 2i);\n-        match m.find(&1) {\n+        match m.get(&1) {\n             None => panic!(),\n             Some(v) => assert_eq!(*v, 2)\n         }\n@@ -1882,7 +1847,7 @@ mod test_map {\n     #[test]\n     fn test_find_copy() {\n         let mut m = HashMap::new();\n-        assert!(m.find(&1i).is_none());\n+        assert!(m.get(&1i).is_none());\n \n         for i in range(1i, 10000) {\n             m.insert(i, i + 7);\n@@ -2026,7 +1991,7 @@ mod test_map {\n         let map: HashMap<int, int> = xs.iter().map(|&x| x).collect();\n \n         for &(k, v) in xs.iter() {\n-            assert_eq!(map.find(&k), Some(&v));\n+            assert_eq!(map.get(&k), Some(&v));\n         }\n     }\n \n@@ -2093,7 +2058,7 @@ mod test_map {\n                 assert_eq!(view.set(100), 10);\n             }\n         }\n-        assert_eq!(map.find(&1).unwrap(), &100);\n+        assert_eq!(map.get(&1).unwrap(), &100);\n         assert_eq!(map.len(), 6);\n \n \n@@ -2106,7 +2071,7 @@ mod test_map {\n                 *v = new_v;\n             }\n         }\n-        assert_eq!(map.find(&2).unwrap(), &200);\n+        assert_eq!(map.get(&2).unwrap(), &200);\n         assert_eq!(map.len(), 6);\n \n         // Existing key (take)\n@@ -2116,7 +2081,7 @@ mod test_map {\n                 assert_eq!(view.take(), 30);\n             }\n         }\n-        assert_eq!(map.find(&3), None);\n+        assert_eq!(map.get(&3), None);\n         assert_eq!(map.len(), 5);\n \n \n@@ -2127,7 +2092,7 @@ mod test_map {\n                 assert_eq!(*view.set(1000), 1000);\n             }\n         }\n-        assert_eq!(map.find(&10).unwrap(), &1000);\n+        assert_eq!(map.get(&10).unwrap(), &1000);\n         assert_eq!(map.len(), 6);\n     }\n }"}, {"sha": "58386882ac52450f7b9841f4dd75bccc5c6ce105", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 22, "deletions": 8, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -23,6 +23,9 @@ use result::{Ok, Err};\n \n use super::map::{HashMap, Entries, MoveEntries, INITIAL_CAPACITY};\n \n+// FIXME(conventions): implement BitOr, BitAnd, BitXor, and Sub\n+// FIXME(conventions): update capacity management to match other collections (no auto-shrink)\n+\n \n // Future Optimization (FIXME!)\n // =============================\n@@ -103,6 +106,7 @@ impl<T: Hash + Eq> HashSet<T, RandomSipHasher> {\n     /// let mut set: HashSet<int> = HashSet::new();\n     /// ```\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn new() -> HashSet<T, RandomSipHasher> {\n         HashSet::with_capacity(INITIAL_CAPACITY)\n     }\n@@ -117,6 +121,7 @@ impl<T: Hash + Eq> HashSet<T, RandomSipHasher> {\n     /// let mut set: HashSet<int> = HashSet::with_capacity(10);\n     /// ```\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn with_capacity(capacity: uint) -> HashSet<T, RandomSipHasher> {\n         HashSet { map: HashMap::with_capacity(capacity) }\n     }\n@@ -240,16 +245,11 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     ///     println!(\"{}\", x);\n     /// }\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn iter<'a>(&'a self) -> SetItems<'a, T> {\n         self.map.keys()\n     }\n \n-    /// Deprecated: use `into_iter`.\n-    #[deprecated = \"use into_iter\"]\n-    pub fn move_iter(self) -> SetMoveItems<T> {\n-        self.into_iter()\n-    }\n-\n     /// Creates a consuming iterator, that is, one that moves each value out\n     /// of the set in arbitrary order. The set cannot be used after calling\n     /// this.\n@@ -270,6 +270,7 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     ///     println!(\"{}\", x);\n     /// }\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn into_iter(self) -> SetMoveItems<T> {\n         self.map.into_iter().map(|(k, _)| k)\n     }\n@@ -296,6 +297,7 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// let diff: HashSet<int> = b.difference(&a).map(|&x| x).collect();\n     /// assert_eq!(diff, [4i].iter().map(|&x| x).collect());\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn difference<'a>(&'a self, other: &'a HashSet<T, H>) -> SetAlgebraItems<'a, T, H> {\n         Repeat::new(other).zip(self.iter())\n             .filter_map(|(other, elt)| {\n@@ -323,6 +325,7 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// assert_eq!(diff1, diff2);\n     /// assert_eq!(diff1, [1i, 4].iter().map(|&x| x).collect());\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn symmetric_difference<'a>(&'a self, other: &'a HashSet<T, H>)\n         -> Chain<SetAlgebraItems<'a, T, H>, SetAlgebraItems<'a, T, H>> {\n         self.difference(other).chain(other.difference(self))\n@@ -345,6 +348,7 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// let diff: HashSet<int> = a.intersection(&b).map(|&x| x).collect();\n     /// assert_eq!(diff, [2i, 3].iter().map(|&x| x).collect());\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn intersection<'a>(&'a self, other: &'a HashSet<T, H>)\n         -> SetAlgebraItems<'a, T, H> {\n         Repeat::new(other).zip(self.iter())\n@@ -370,6 +374,7 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// let diff: HashSet<int> = a.union(&b).map(|&x| x).collect();\n     /// assert_eq!(diff, [1i, 2, 3, 4].iter().map(|&x| x).collect());\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn union<'a>(&'a self, other: &'a HashSet<T, H>)\n         -> Chain<SetItems<'a, T>, SetAlgebraItems<'a, T, H>> {\n         self.iter().chain(other.difference(self))\n@@ -387,6 +392,7 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// v.insert(1u);\n     /// assert_eq!(v.len(), 1);\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn len(&self) -> uint { self.map.len() }\n \n     /// Returns true if the set contains no elements\n@@ -401,6 +407,7 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// v.insert(1u);\n     /// assert!(!v.is_empty());\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn is_empty(&self) -> bool { self.map.len() == 0 }\n \n     /// Clears the set, removing all values.\n@@ -415,6 +422,7 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// v.clear();\n     /// assert!(v.is_empty());\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn clear(&mut self) { self.map.clear() }\n \n     /// Returns `true` if the set contains a value.\n@@ -428,6 +436,7 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// assert_eq!(set.contains(&1), true);\n     /// assert_eq!(set.contains(&4), false);\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn contains(&self, value: &T) -> bool { self.map.contains_key(value) }\n \n     /// Returns `true` if the set has no elements in common with `other`.\n@@ -447,6 +456,7 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// b.insert(1);\n     /// assert_eq!(a.is_disjoint(&b), false);\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn is_disjoint(&self, other: &HashSet<T, H>) -> bool {\n         self.iter().all(|v| !other.contains(v))\n     }\n@@ -467,6 +477,7 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// set.insert(4);\n     /// assert_eq!(set.is_subset(&sup), false);\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn is_subset(&self, other: &HashSet<T, H>) -> bool {\n         self.iter().all(|v| other.contains(v))\n     }\n@@ -491,6 +502,7 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// assert_eq!(set.is_superset(&sub), true);\n     /// ```\n     #[inline]\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn is_superset(&self, other: &HashSet<T, H>) -> bool {\n         other.is_subset(self)\n     }\n@@ -509,7 +521,8 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// assert_eq!(set.insert(2), false);\n     /// assert_eq!(set.len(), 1);\n     /// ```\n-    pub fn insert(&mut self, value: T) -> bool { self.map.insert(value, ()) }\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn insert(&mut self, value: T) -> bool { self.map.insert(value, ()).is_none() }\n \n     /// Removes a value from the set. Returns `true` if the value was\n     /// present in the set.\n@@ -525,7 +538,8 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// assert_eq!(set.remove(&2), true);\n     /// assert_eq!(set.remove(&2), false);\n     /// ```\n-    pub fn remove(&mut self, value: &T) -> bool { self.map.remove(value) }\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn remove(&mut self, value: &T) -> bool { self.map.remove(value).is_some() }\n }\n \n impl<T: Eq + Hash<S>, S, H: Hasher<S>> PartialEq for HashSet<T, H> {"}, {"sha": "aab0924e7e43973c80a0e2810b8d14dad71ef6f5", "filename": "src/libstd/collections/lru_cache.rs", "status": "modified", "additions": 91, "deletions": 59, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibstd%2Fcollections%2Flru_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibstd%2Fcollections%2Flru_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Flru_cache.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -20,20 +20,20 @@\n //! use std::collections::LruCache;\n //!\n //! let mut cache: LruCache<int, int> = LruCache::new(2);\n-//! cache.put(1, 10);\n-//! cache.put(2, 20);\n-//! cache.put(3, 30);\n+//! cache.insert(1, 10);\n+//! cache.insert(2, 20);\n+//! cache.insert(3, 30);\n //! assert!(cache.get(&1).is_none());\n //! assert_eq!(*cache.get(&2).unwrap(), 20);\n //! assert_eq!(*cache.get(&3).unwrap(), 30);\n //!\n-//! cache.put(2, 22);\n+//! cache.insert(2, 22);\n //! assert_eq!(*cache.get(&2).unwrap(), 22);\n //!\n-//! cache.put(6, 60);\n+//! cache.insert(6, 60);\n //! assert!(cache.get(&3).is_none());\n //!\n-//! cache.change_capacity(1);\n+//! cache.set_capacity(1);\n //! assert!(cache.get(&2).is_none());\n //! ```\n \n@@ -49,6 +49,9 @@ use boxed::Box;\n use ptr;\n use result::{Ok, Err};\n \n+// FIXME(conventions): implement iterators?\n+// FIXME(conventions): implement indexing?\n+\n struct KeyRef<K> { k: *const K }\n \n struct LruEntry<K, V> {\n@@ -99,6 +102,7 @@ impl<K: Hash + Eq, V> LruCache<K, V> {\n     /// use std::collections::LruCache;\n     /// let mut cache: LruCache<int, &str> = LruCache::new(10);\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn new(capacity: uint) -> LruCache<K, V> {\n         let cache = LruCache {\n             map: HashMap::new(),\n@@ -112,30 +116,38 @@ impl<K: Hash + Eq, V> LruCache<K, V> {\n         return cache;\n     }\n \n-    /// Put a key-value pair into cache.\n+    /// Deprecated: Replaced with `insert`.\n+    #[deprecated = \"Replaced with `insert`\"]\n+    pub fn put(&mut self, k: K, v: V) {\n+        self.insert(k, v);\n+    }\n+\n+    /// Inserts a key-value pair into the cache. If the key already existed, the old value is\n+    /// returned.\n     ///\n     /// # Example\n     ///\n     /// ```\n     /// use std::collections::LruCache;\n     /// let mut cache = LruCache::new(2);\n     ///\n-    /// cache.put(1i, \"a\");\n-    /// cache.put(2, \"b\");\n+    /// cache.insert(1i, \"a\");\n+    /// cache.insert(2, \"b\");\n     /// assert_eq!(cache.get(&1), Some(&\"a\"));\n     /// assert_eq!(cache.get(&2), Some(&\"b\"));\n     /// ```\n-    pub fn put(&mut self, k: K, v: V) {\n-        let (node_ptr, node_opt) = match self.map.find_mut(&KeyRef{k: &k}) {\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn insert(&mut self, k: K, v: V) -> Option<V> {\n+        let (node_ptr, node_opt, old_val) = match self.map.get_mut(&KeyRef{k: &k}) {\n             Some(node) => {\n-                node.value = v;\n+                let old_val = mem::replace(&mut node.value, v);\n                 let node_ptr: *mut LruEntry<K, V> = &mut **node;\n-                (node_ptr, None)\n+                (node_ptr, None, Some(old_val))\n             }\n             None => {\n                 let mut node = box LruEntry::new(k, v);\n                 let node_ptr: *mut LruEntry<K, V> = &mut *node;\n-                (node_ptr, Some(node))\n+                (node_ptr, Some(node), None)\n             }\n         };\n         match node_opt {\n@@ -146,13 +158,14 @@ impl<K: Hash + Eq, V> LruCache<K, V> {\n             }\n             Some(node) => {\n                 let keyref = unsafe { &(*node_ptr).key };\n-                self.map.swap(KeyRef{k: keyref}, node);\n+                self.map.insert(KeyRef{k: keyref}, node);\n                 self.attach(node_ptr);\n                 if self.len() > self.capacity() {\n                     self.remove_lru();\n                 }\n             }\n         }\n+        old_val\n     }\n \n     /// Return a value corresponding to the key in the cache.\n@@ -163,16 +176,17 @@ impl<K: Hash + Eq, V> LruCache<K, V> {\n     /// use std::collections::LruCache;\n     /// let mut cache = LruCache::new(2);\n     ///\n-    /// cache.put(1i, \"a\");\n-    /// cache.put(2, \"b\");\n-    /// cache.put(2, \"c\");\n-    /// cache.put(3, \"d\");\n+    /// cache.insert(1i, \"a\");\n+    /// cache.insert(2, \"b\");\n+    /// cache.insert(2, \"c\");\n+    /// cache.insert(3, \"d\");\n     ///\n     /// assert_eq!(cache.get(&1), None);\n     /// assert_eq!(cache.get(&2), Some(&\"c\"));\n     /// ```\n-    pub fn get<'a>(&'a mut self, k: &K) -> Option<&'a V> {\n-        let (value, node_ptr_opt) = match self.map.find_mut(&KeyRef{k: k}) {\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn get(&mut self, k: &K) -> Option<&V> {\n+        let (value, node_ptr_opt) = match self.map.get_mut(&KeyRef{k: k}) {\n             None => (None, None),\n             Some(node) => {\n                 let node_ptr: *mut LruEntry<K, V> = &mut **node;\n@@ -189,6 +203,12 @@ impl<K: Hash + Eq, V> LruCache<K, V> {\n         return value;\n     }\n \n+    /// Deprecated: Renamed to `remove`.\n+    #[deprecated = \"Renamed to `remove`\"]\n+    pub fn pop(&mut self, k: &K) -> Option<V> {\n+        self.remove(k)\n+    }\n+\n     /// Remove and return a value corresponding to the key from the cache.\n     ///\n     /// # Example\n@@ -197,15 +217,16 @@ impl<K: Hash + Eq, V> LruCache<K, V> {\n     /// use std::collections::LruCache;\n     /// let mut cache = LruCache::new(2);\n     ///\n-    /// cache.put(2i, \"a\");\n+    /// cache.insert(2i, \"a\");\n     ///\n-    /// assert_eq!(cache.pop(&1), None);\n-    /// assert_eq!(cache.pop(&2), Some(\"a\"));\n-    /// assert_eq!(cache.pop(&2), None);\n+    /// assert_eq!(cache.remove(&1), None);\n+    /// assert_eq!(cache.remove(&2), Some(\"a\"));\n+    /// assert_eq!(cache.remove(&2), None);\n     /// assert_eq!(cache.len(), 0);\n     /// ```\n-    pub fn pop(&mut self, k: &K) -> Option<V> {\n-        match self.map.pop(&KeyRef{k: k}) {\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn remove(&mut self, k: &K) -> Option<V> {\n+        match self.map.remove(&KeyRef{k: k}) {\n             None => None,\n             Some(lru_entry) => Some(lru_entry.value)\n         }\n@@ -220,10 +241,17 @@ impl<K: Hash + Eq, V> LruCache<K, V> {\n     /// let mut cache: LruCache<int, &str> = LruCache::new(2);\n     /// assert_eq!(cache.capacity(), 2);\n     /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn capacity(&self) -> uint {\n         self.max_size\n     }\n \n+    /// Deprecated: Renamed to `set_capacity`.\n+    #[deprecated = \"Renamed to `set_capacity`\"]\n+    pub fn change_capacity(&mut self, capacity: uint) {\n+        self.set_capacity(capacity)\n+    }\n+\n     /// Change the number of key-value pairs the cache can hold. Remove\n     /// least-recently-used key-value pairs if necessary.\n     ///\n@@ -233,29 +261,30 @@ impl<K: Hash + Eq, V> LruCache<K, V> {\n     /// use std::collections::LruCache;\n     /// let mut cache = LruCache::new(2);\n     ///\n-    /// cache.put(1i, \"a\");\n-    /// cache.put(2, \"b\");\n-    /// cache.put(3, \"c\");\n+    /// cache.insert(1i, \"a\");\n+    /// cache.insert(2, \"b\");\n+    /// cache.insert(3, \"c\");\n     ///\n     /// assert_eq!(cache.get(&1), None);\n     /// assert_eq!(cache.get(&2), Some(&\"b\"));\n     /// assert_eq!(cache.get(&3), Some(&\"c\"));\n     ///\n-    /// cache.change_capacity(3);\n-    /// cache.put(1i, \"a\");\n-    /// cache.put(2, \"b\");\n+    /// cache.set_capacity(3);\n+    /// cache.insert(1i, \"a\");\n+    /// cache.insert(2, \"b\");\n     ///\n     /// assert_eq!(cache.get(&1), Some(&\"a\"));\n     /// assert_eq!(cache.get(&2), Some(&\"b\"));\n     /// assert_eq!(cache.get(&3), Some(&\"c\"));\n     ///\n-    /// cache.change_capacity(1);\n+    /// cache.set_capacity(1);\n     ///\n     /// assert_eq!(cache.get(&1), None);\n     /// assert_eq!(cache.get(&2), None);\n     /// assert_eq!(cache.get(&3), Some(&\"c\"));\n     /// ```\n-    pub fn change_capacity(&mut self, capacity: uint) {\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn set_capacity(&mut self, capacity: uint) {\n         for _ in range(capacity, self.len()) {\n             self.remove_lru();\n         }\n@@ -267,7 +296,7 @@ impl<K: Hash + Eq, V> LruCache<K, V> {\n         if self.len() > 0 {\n             let lru = unsafe { (*self.head).prev };\n             self.detach(lru);\n-            self.map.pop(&KeyRef{k: unsafe { &(*lru).key }});\n+            self.map.remove(&KeyRef{k: unsafe { &(*lru).key }});\n         }\n     }\n \n@@ -290,12 +319,15 @@ impl<K: Hash + Eq, V> LruCache<K, V> {\n     }\n \n     /// Return the number of key-value pairs in the cache.\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn len(&self) -> uint { self.map.len() }\n \n     /// Returns whether the cache is currently empty.\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn is_empty(&self) -> bool { self.len() == 0 }\n \n     /// Clear the cache of all key-value pairs.\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn clear(&mut self) { self.map.clear(); }\n }\n \n@@ -347,8 +379,8 @@ mod tests {\n     #[test]\n     fn test_put_and_get() {\n         let mut cache: LruCache<int, int> = LruCache::new(2);\n-        cache.put(1, 10);\n-        cache.put(2, 20);\n+        cache.insert(1, 10);\n+        cache.insert(2, 20);\n         assert_opt_eq(cache.get(&1), 10);\n         assert_opt_eq(cache.get(&2), 20);\n         assert_eq!(cache.len(), 2);\n@@ -357,31 +389,31 @@ mod tests {\n     #[test]\n     fn test_put_update() {\n         let mut cache: LruCache<String, Vec<u8>> = LruCache::new(1);\n-        cache.put(\"1\".to_string(), vec![10, 10]);\n-        cache.put(\"1\".to_string(), vec![10, 19]);\n+        cache.insert(\"1\".to_string(), vec![10, 10]);\n+        cache.insert(\"1\".to_string(), vec![10, 19]);\n         assert_opt_eq(cache.get(&\"1\".to_string()), vec![10, 19]);\n         assert_eq!(cache.len(), 1);\n     }\n \n     #[test]\n     fn test_expire_lru() {\n         let mut cache: LruCache<String, String> = LruCache::new(2);\n-        cache.put(\"foo1\".to_string(), \"bar1\".to_string());\n-        cache.put(\"foo2\".to_string(), \"bar2\".to_string());\n-        cache.put(\"foo3\".to_string(), \"bar3\".to_string());\n+        cache.insert(\"foo1\".to_string(), \"bar1\".to_string());\n+        cache.insert(\"foo2\".to_string(), \"bar2\".to_string());\n+        cache.insert(\"foo3\".to_string(), \"bar3\".to_string());\n         assert!(cache.get(&\"foo1\".to_string()).is_none());\n-        cache.put(\"foo2\".to_string(), \"bar2update\".to_string());\n-        cache.put(\"foo4\".to_string(), \"bar4\".to_string());\n+        cache.insert(\"foo2\".to_string(), \"bar2update\".to_string());\n+        cache.insert(\"foo4\".to_string(), \"bar4\".to_string());\n         assert!(cache.get(&\"foo3\".to_string()).is_none());\n     }\n \n     #[test]\n     fn test_pop() {\n         let mut cache: LruCache<int, int> = LruCache::new(2);\n-        cache.put(1, 10);\n-        cache.put(2, 20);\n+        cache.insert(1, 10);\n+        cache.insert(2, 20);\n         assert_eq!(cache.len(), 2);\n-        let opt1 = cache.pop(&1);\n+        let opt1 = cache.remove(&1);\n         assert!(opt1.is_some());\n         assert_eq!(opt1.unwrap(), 10);\n         assert!(cache.get(&1).is_none());\n@@ -392,35 +424,35 @@ mod tests {\n     fn test_change_capacity() {\n         let mut cache: LruCache<int, int> = LruCache::new(2);\n         assert_eq!(cache.capacity(), 2);\n-        cache.put(1, 10);\n-        cache.put(2, 20);\n-        cache.change_capacity(1);\n+        cache.insert(1, 10);\n+        cache.insert(2, 20);\n+        cache.set_capacity(1);\n         assert!(cache.get(&1).is_none());\n         assert_eq!(cache.capacity(), 1);\n     }\n \n     #[test]\n     fn test_to_string() {\n         let mut cache: LruCache<int, int> = LruCache::new(3);\n-        cache.put(1, 10);\n-        cache.put(2, 20);\n-        cache.put(3, 30);\n+        cache.insert(1, 10);\n+        cache.insert(2, 20);\n+        cache.insert(3, 30);\n         assert_eq!(cache.to_string(), \"{3: 30, 2: 20, 1: 10}\".to_string());\n-        cache.put(2, 22);\n+        cache.insert(2, 22);\n         assert_eq!(cache.to_string(), \"{2: 22, 3: 30, 1: 10}\".to_string());\n-        cache.put(6, 60);\n+        cache.insert(6, 60);\n         assert_eq!(cache.to_string(), \"{6: 60, 2: 22, 3: 30}\".to_string());\n         cache.get(&3);\n         assert_eq!(cache.to_string(), \"{3: 30, 6: 60, 2: 22}\".to_string());\n-        cache.change_capacity(2);\n+        cache.set_capacity(2);\n         assert_eq!(cache.to_string(), \"{3: 30, 6: 60}\".to_string());\n     }\n \n     #[test]\n     fn test_clear() {\n         let mut cache: LruCache<int, int> = LruCache::new(2);\n-        cache.put(1, 10);\n-        cache.put(2, 20);\n+        cache.insert(1, 10);\n+        cache.insert(2, 20);\n         cache.clear();\n         assert!(cache.get(&1).is_none());\n         assert!(cache.get(&2).is_none());"}, {"sha": "3419a3d98a1545b0b48d1e83805dd91a47bc82ca", "filename": "src/libstd/collections/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibstd%2Fcollections%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibstd%2Fcollections%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fmod.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -278,7 +278,7 @@\n //!     }\n //! }\n //!\n-//! assert_eq!(count.find(&'s'), Some(&8));\n+//! assert_eq!(count.get(&'s'), Some(&8));\n //!\n //! println!(\"Number of occurences of each character\");\n //! for (char, count) in count.iter() {"}, {"sha": "b048ab13968de438f013efe7e216fd44266081d6", "filename": "src/libstd/error.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibstd%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibstd%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ferror.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -33,9 +33,6 @@\n //! particular implementation, but also reveal some of its implementation for\n //! debugging via `cause` chains.\n //!\n-//! The trait inherits from `Any` to allow *downcasting*: converting from a\n-//! trait object to a specific concrete type when applicable.\n-//!\n //! # The `FromError` trait\n //!\n //! `FromError` is a simple trait that expresses conversions between different"}, {"sha": "c404741b7c31ad4aa14302c2f128f905191d5e09", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -627,7 +627,7 @@ pub trait Reader {\n     /// as `Err(IoError)`. See `read()` for more details.\n     fn push(&mut self, len: uint, buf: &mut Vec<u8>) -> IoResult<uint> {\n         let start_len = buf.len();\n-        buf.reserve_additional(len);\n+        buf.reserve(len);\n \n         let n = {\n             let s = unsafe { slice_vec_capacity(buf, start_len, start_len + len) };\n@@ -658,7 +658,7 @@ pub trait Reader {\n         }\n \n         let start_len = buf.len();\n-        buf.reserve_additional(len);\n+        buf.reserve(len);\n \n         // we can't just use self.read_at_least(min, slice) because we need to push\n         // successful reads onto the vector before any returned errors.\n@@ -1737,7 +1737,7 @@ pub enum FileAccess {\n }\n \n /// Different kinds of files which can be identified by a call to stat\n-#[deriving(PartialEq, Show, Hash)]\n+#[deriving(PartialEq, Show, Hash, Clone)]\n pub enum FileType {\n     /// This is a normal file, corresponding to `S_IFREG`\n     TypeFile,"}, {"sha": "698e0a3460f2878946a6b11bc9e59c9b54a53e52", "filename": "src/libstd/io/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibstd%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibstd%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprocess.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -1137,7 +1137,7 @@ mod tests {\n         cmd.env(\"path\", \"foo\");\n         cmd.env(\"Path\", \"bar\");\n         let env = &cmd.env.unwrap();\n-        let val = env.find(&EnvKey(\"PATH\".to_c_str()));\n+        let val = env.get(&EnvKey(\"PATH\".to_c_str()));\n         assert!(val.unwrap() == &\"bar\".to_c_str());\n     }\n }"}, {"sha": "5ef2c2fe23d35a65880933410c78f44c41cacfa0", "filename": "src/libstd/rand/mod.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibstd%2Frand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibstd%2Frand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fmod.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -45,8 +45,12 @@\n //!     so the \"quality\" of `/dev/random` is not better than `/dev/urandom` in most cases.\n //!     However, this means that `/dev/urandom` can yield somewhat predictable randomness\n //!     if the entropy pool is very small, such as immediately after first booting.\n-//!     If an application likely to be run soon after first booting, or on a system with very\n-//!     few entropy sources, one should consider using `/dev/random` via `ReaderRng`.\n+//!     Linux 3,17 added `getrandom(2)` system call which solves the issue: it blocks if entropy\n+//!     pool is not initialized yet, but it does not block once initialized.\n+//!     `OsRng` tries to use `getrandom(2)` if available, and use `/dev/urandom` fallback if not.\n+//!     If an application does not have `getrandom` and likely to be run soon after first booting,\n+//!     or on a system with very few entropy sources, one should consider using `/dev/random` via\n+//!     `ReaderRng`.\n //! -   On some systems (e.g. FreeBSD, OpenBSD and Mac OS X) there is no difference\n //!     between the two sources. (Also note that, on some systems e.g. FreeBSD, both `/dev/random`\n //!     and `/dev/urandom` may block once if the CSPRNG has not seeded yet.)"}, {"sha": "6bf259d201e6c807fc9d0f3c632c4e806ccd20d8", "filename": "src/libstd/rand/os.rs", "status": "modified", "additions": 114, "deletions": 10, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibstd%2Frand%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibstd%2Frand%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fos.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -15,45 +15,149 @@ pub use self::imp::OsRng;\n \n #[cfg(all(unix, not(target_os = \"ios\")))]\n mod imp {\n+    extern crate libc;\n+\n     use io::{IoResult, File};\n     use path::Path;\n     use rand::Rng;\n     use rand::reader::ReaderRng;\n     use result::{Ok, Err};\n+    use slice::SlicePrelude;\n+    use mem;\n+    use os::errno;\n+\n+    #[cfg(all(target_os = \"linux\",\n+              any(target_arch = \"x86_64\", target_arch = \"x86\", target_arch = \"arm\")))]\n+    fn getrandom(buf: &mut [u8]) -> libc::c_long {\n+        extern \"C\" {\n+            fn syscall(number: libc::c_long, ...) -> libc::c_long;\n+        }\n+\n+        #[cfg(target_arch = \"x86_64\")]\n+        const NR_GETRANDOM: libc::c_long = 318;\n+        #[cfg(target_arch = \"x86\")]\n+        const NR_GETRANDOM: libc::c_long = 355;\n+        #[cfg(target_arch = \"arm\")]\n+        const NR_GETRANDOM: libc::c_long = 384;\n+\n+        unsafe {\n+            syscall(NR_GETRANDOM, buf.as_mut_ptr(), buf.len(), 0u)\n+        }\n+    }\n+\n+    #[cfg(not(all(target_os = \"linux\",\n+                  any(target_arch = \"x86_64\", target_arch = \"x86\", target_arch = \"arm\"))))]\n+    fn getrandom(_buf: &mut [u8]) -> libc::c_long { -1 }\n+\n+    fn getrandom_fill_bytes(v: &mut [u8]) {\n+        let mut read = 0;\n+        let len = v.len();\n+        while read < len {\n+            let result = getrandom(v[mut read..]);\n+            if result == -1 {\n+                let err = errno() as libc::c_int;\n+                if err == libc::EINTR {\n+                    continue;\n+                } else {\n+                    panic!(\"unexpected getrandom error: {}\", err);\n+                }\n+            } else {\n+                read += result as uint;\n+            }\n+        }\n+    }\n+\n+    fn getrandom_next_u32() -> u32 {\n+        let mut buf: [u8, ..4] = [0u8, ..4];\n+        getrandom_fill_bytes(&mut buf);\n+        unsafe { mem::transmute::<[u8, ..4], u32>(buf) }\n+    }\n+\n+    fn getrandom_next_u64() -> u64 {\n+        let mut buf: [u8, ..8] = [0u8, ..8];\n+        getrandom_fill_bytes(&mut buf);\n+        unsafe { mem::transmute::<[u8, ..8], u64>(buf) }\n+    }\n+\n+    #[cfg(all(target_os = \"linux\",\n+              any(target_arch = \"x86_64\", target_arch = \"x86\", target_arch = \"arm\")))]\n+    fn is_getrandom_available() -> bool {\n+        use sync::atomic::{AtomicBool, INIT_ATOMIC_BOOL, Relaxed};\n+\n+        static GETRANDOM_CHECKED: AtomicBool = INIT_ATOMIC_BOOL;\n+        static GETRANDOM_AVAILABLE: AtomicBool = INIT_ATOMIC_BOOL;\n+\n+        if !GETRANDOM_CHECKED.load(Relaxed) {\n+            let mut buf: [u8, ..0] = [];\n+            let result = getrandom(&mut buf);\n+            let available = if result == -1 {\n+                let err = errno() as libc::c_int;\n+                err != libc::ENOSYS\n+            } else {\n+                true\n+            };\n+            GETRANDOM_AVAILABLE.store(available, Relaxed);\n+            GETRANDOM_CHECKED.store(true, Relaxed);\n+            available\n+        } else {\n+            GETRANDOM_AVAILABLE.load(Relaxed)\n+        }\n+    }\n+\n+    #[cfg(not(all(target_os = \"linux\",\n+                  any(target_arch = \"x86_64\", target_arch = \"x86\", target_arch = \"arm\"))))]\n+    fn is_getrandom_available() -> bool { false }\n \n     /// A random number generator that retrieves randomness straight from\n     /// the operating system. Platform sources:\n     ///\n     /// - Unix-like systems (Linux, Android, Mac OSX): read directly from\n-    ///   `/dev/urandom`.\n+    ///   `/dev/urandom`, or from `getrandom(2)` system call if available.\n     /// - Windows: calls `CryptGenRandom`, using the default cryptographic\n     ///   service provider with the `PROV_RSA_FULL` type.\n     /// - iOS: calls SecRandomCopyBytes as /dev/(u)random is sandboxed\n     /// This does not block.\n-    #[cfg(unix)]\n     pub struct OsRng {\n-        inner: ReaderRng<File>\n+        inner: OsRngInner,\n+    }\n+\n+    enum OsRngInner {\n+        OsGetrandomRng,\n+        OsReaderRng(ReaderRng<File>),\n     }\n \n     impl OsRng {\n         /// Create a new `OsRng`.\n         pub fn new() -> IoResult<OsRng> {\n+            if is_getrandom_available() {\n+                return Ok(OsRng { inner: OsGetrandomRng });\n+            }\n+\n             let reader = try!(File::open(&Path::new(\"/dev/urandom\")));\n             let reader_rng = ReaderRng::new(reader);\n \n-            Ok(OsRng { inner: reader_rng })\n+            Ok(OsRng { inner: OsReaderRng(reader_rng) })\n         }\n     }\n \n     impl Rng for OsRng {\n         fn next_u32(&mut self) -> u32 {\n-            self.inner.next_u32()\n+            match self.inner {\n+                OsGetrandomRng => getrandom_next_u32(),\n+                OsReaderRng(ref mut rng) => rng.next_u32(),\n+            }\n         }\n         fn next_u64(&mut self) -> u64 {\n-            self.inner.next_u64()\n+            match self.inner {\n+                OsGetrandomRng => getrandom_next_u64(),\n+                OsReaderRng(ref mut rng) => rng.next_u64(),\n+            }\n         }\n         fn fill_bytes(&mut self, v: &mut [u8]) {\n-            self.inner.fill_bytes(v)\n+            match self.inner {\n+                OsGetrandomRng => getrandom_fill_bytes(v),\n+                OsReaderRng(ref mut rng) => rng.fill_bytes(v)\n+            }\n         }\n     }\n }\n@@ -75,7 +179,7 @@ mod imp {\n     /// the operating system. Platform sources:\n     ///\n     /// - Unix-like systems (Linux, Android, Mac OSX): read directly from\n-    ///   `/dev/urandom`.\n+    ///   `/dev/urandom`, or from `getrandom(2)` system call if available.\n     /// - Windows: calls `CryptGenRandom`, using the default cryptographic\n     ///   service provider with the `PROV_RSA_FULL` type.\n     /// - iOS: calls SecRandomCopyBytes as /dev/(u)random is sandboxed\n@@ -145,10 +249,10 @@ mod imp {\n     /// the operating system. Platform sources:\n     ///\n     /// - Unix-like systems (Linux, Android, Mac OSX): read directly from\n-    ///   `/dev/urandom`.\n+    ///   `/dev/urandom`, or from `getrandom(2)` system call if available.\n     /// - Windows: calls `CryptGenRandom`, using the default cryptographic\n     ///   service provider with the `PROV_RSA_FULL` type.\n-    ///\n+    /// - iOS: calls SecRandomCopyBytes as /dev/(u)random is sandboxed\n     /// This does not block.\n     pub struct OsRng {\n         hcryptprov: HCRYPTPROV"}, {"sha": "6a354fa20e1b40bbb88b48d0ea5ee6cac1f11fcb", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 96, "deletions": 17, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -171,7 +171,7 @@ pub struct Path {\n     /// module (like paths in an import).\n     pub global: bool,\n     /// The segments in the path: the things separated by `::`.\n-    pub segments: Vec<PathSegment> ,\n+    pub segments: Vec<PathSegment>,\n }\n \n /// A segment of a path: an identifier, an optional lifetime, and a set of\n@@ -180,12 +180,107 @@ pub struct Path {\n pub struct PathSegment {\n     /// The identifier portion of this path segment.\n     pub identifier: Ident,\n+\n+    /// Type/lifetime parameters attached to this path. They come in\n+    /// two flavors: `Path<A,B,C>` and `Path(A,B) -> C`. Note that\n+    /// this is more than just simple syntactic sugar; the use of\n+    /// parens affects the region binding rules, so we preserve the\n+    /// distinction.\n+    pub parameters: PathParameters,\n+}\n+\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n+pub enum PathParameters {\n+    AngleBracketedParameters(AngleBracketedParameterData),\n+    ParenthesizedParameters(ParenthesizedParameterData),\n+}\n+\n+impl PathParameters {\n+    pub fn none() -> PathParameters {\n+        AngleBracketedParameters(AngleBracketedParameterData {\n+            lifetimes: Vec::new(),\n+            types: OwnedSlice::empty(),\n+        })\n+    }\n+\n+    pub fn is_empty(&self) -> bool {\n+        match *self {\n+            AngleBracketedParameters(ref data) => data.is_empty(),\n+\n+            // Even if the user supplied no types, something like\n+            // `X()` is equivalent to `X<(),()>`.\n+            ParenthesizedParameters(..) => false,\n+        }\n+    }\n+\n+    pub fn has_lifetimes(&self) -> bool {\n+        match *self {\n+            AngleBracketedParameters(ref data) => !data.lifetimes.is_empty(),\n+            ParenthesizedParameters(_) => false,\n+        }\n+    }\n+\n+    pub fn has_types(&self) -> bool {\n+        match *self {\n+            AngleBracketedParameters(ref data) => !data.types.is_empty(),\n+            ParenthesizedParameters(..) => true,\n+        }\n+    }\n+\n+    pub fn types(&self) -> Vec<&P<Ty>> {\n+        /*!\n+         * Returns the types that the user wrote. Note that these do not\n+         * necessarily map to the type parameters in the parenthesized case.\n+         */\n+        match *self {\n+            AngleBracketedParameters(ref data) => {\n+                data.types.iter().collect()\n+            }\n+            ParenthesizedParameters(ref data) => {\n+                data.inputs.iter()\n+                    .chain(data.output.iter())\n+                    .collect()\n+            }\n+        }\n+    }\n+\n+    pub fn lifetimes(&self) -> Vec<&Lifetime> {\n+        match *self {\n+            AngleBracketedParameters(ref data) => {\n+                data.lifetimes.iter().collect()\n+            }\n+            ParenthesizedParameters(_) => {\n+                Vec::new()\n+            }\n+        }\n+    }\n+}\n+\n+/// A path like `Foo<'a, T>`\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n+pub struct AngleBracketedParameterData {\n     /// The lifetime parameters for this path segment.\n     pub lifetimes: Vec<Lifetime>,\n     /// The type parameters for this path segment, if present.\n     pub types: OwnedSlice<P<Ty>>,\n }\n \n+impl AngleBracketedParameterData {\n+    fn is_empty(&self) -> bool {\n+        self.lifetimes.is_empty() && self.types.is_empty()\n+    }\n+}\n+\n+/// A path like `Foo(A,B) -> C`\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n+pub struct ParenthesizedParameterData {\n+    /// `(A,B)`\n+    pub inputs: Vec<P<Ty>>,\n+\n+    /// `C`\n+    pub output: Option<P<Ty>>,\n+}\n+\n pub type CrateNum = u32;\n \n pub type NodeId = u32;\n@@ -213,20 +308,11 @@ pub const DUMMY_NODE_ID: NodeId = -1;\n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum TyParamBound {\n     TraitTyParamBound(TraitRef),\n-    UnboxedFnTyParamBound(P<UnboxedFnBound>),\n     RegionTyParamBound(Lifetime)\n }\n \n pub type TyParamBounds = OwnedSlice<TyParamBound>;\n \n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n-pub struct UnboxedFnBound {\n-    pub path: Path,\n-    pub decl: P<FnDecl>,\n-    pub lifetimes: Vec<LifetimeDef>,\n-    pub ref_id: NodeId,\n-}\n-\n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct TyParam {\n     pub ident: Ident,\n@@ -994,12 +1080,6 @@ pub struct BareFnTy {\n     pub decl: P<FnDecl>\n }\n \n-#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n-pub struct UnboxedFnTy {\n-    pub kind: UnboxedClosureKind,\n-    pub decl: P<FnDecl>,\n-}\n-\n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum Ty_ {\n     TyNil,\n@@ -1012,7 +1092,6 @@ pub enum Ty_ {\n     TyClosure(P<ClosureTy>),\n     TyProc(P<ClosureTy>),\n     TyBareFn(P<BareFnTy>),\n-    TyUnboxedFn(P<UnboxedFnTy>),\n     TyTup(Vec<P<Ty>> ),\n     TyPath(Path, Option<TyParamBounds>, NodeId), // for #7264; see above\n     /// A \"qualified path\", e.g. `<Vec<T> as SomeTrait>::SomeType`"}, {"sha": "3adb062864e1e128ffe207dac5be3702ba254c72", "filename": "src/libsyntax/ast_map/mod.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibsyntax%2Fast_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibsyntax%2Fast_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map%2Fmod.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -848,9 +848,6 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n             TyBareFn(ref fd) => {\n                 self.visit_fn_decl(&*fd.decl);\n             }\n-            TyUnboxedFn(ref fd) => {\n-                self.visit_fn_decl(&*fd.decl);\n-            }\n             _ => {}\n         }\n         visit::walk_ty(self, ty);"}, {"sha": "2e3a15bfd4b4b1826a8cdb654718d04faf380779", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -171,8 +171,10 @@ pub fn ident_to_path(s: Span, identifier: Ident) -> Path {\n         segments: vec!(\n             ast::PathSegment {\n                 identifier: identifier,\n-                lifetimes: Vec::new(),\n-                types: OwnedSlice::empty(),\n+                parameters: ast::AngleBracketedParameters(ast::AngleBracketedParameterData {\n+                    lifetimes: Vec::new(),\n+                    types: OwnedSlice::empty(),\n+                })\n             }\n         ),\n     }\n@@ -681,11 +683,11 @@ pub fn segments_name_eq(a : &[ast::PathSegment], b : &[ast::PathSegment]) -> boo\n         false\n     } else {\n         for (idx,seg) in a.iter().enumerate() {\n-            if (seg.identifier.name != b[idx].identifier.name)\n+            if seg.identifier.name != b[idx].identifier.name\n                 // FIXME #7743: ident -> name problems in lifetime comparison?\n-                || (seg.lifetimes != b[idx].lifetimes)\n                 // can types contain idents?\n-                || (seg.types != b[idx].types) {\n+                || seg.parameters != b[idx].parameters\n+            {\n                 return false;\n             }\n         }\n@@ -747,12 +749,10 @@ impl PostExpansionMethod for Method {\n mod test {\n     use ast::*;\n     use super::*;\n-    use owned_slice::OwnedSlice;\n \n     fn ident_to_segment(id : &Ident) -> PathSegment {\n-        PathSegment {identifier:id.clone(),\n-                     lifetimes: Vec::new(),\n-                     types: OwnedSlice::empty()}\n+        PathSegment {identifier: id.clone(),\n+                     parameters: PathParameters::none()}\n     }\n \n     #[test] fn idents_name_eq_test() {"}, {"sha": "d077fbd7bf00f58cdfec3bd8098c9248a723d623", "filename": "src/libsyntax/diagnostics/plugin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -63,7 +63,7 @@ pub fn expand_diagnostic_used<'cx>(ecx: &'cx mut ExtCtxt,\n         ()\n     });\n     with_used_diagnostics(|diagnostics| {\n-        match diagnostics.swap(code.name, span) {\n+        match diagnostics.insert(code.name, span) {\n             Some(previous_span) => {\n                 ecx.span_warn(span, format!(\n                     \"diagnostic code {} already used\", token::get_ident(code).get()\n@@ -93,7 +93,7 @@ pub fn expand_register_diagnostic<'cx>(ecx: &'cx mut ExtCtxt,\n         _ => unreachable!()\n     };\n     with_registered_diagnostics(|diagnostics| {\n-        if !diagnostics.insert(code.name, description) {\n+        if diagnostics.insert(code.name, description).is_some() {\n             ecx.span_err(span, format!(\n                 \"diagnostic code {} already registered\", token::get_ident(*code).get()\n             ).as_slice());"}, {"sha": "5401da8cd053bf7d6e0b424d677f64df3369a421", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -768,7 +768,7 @@ impl SyntaxEnv {\n \n     pub fn find(&self, k: &Name) -> Option<Rc<SyntaxExtension>> {\n         for frame in self.chain.iter().rev() {\n-            match frame.map.find(k) {\n+            match frame.map.get(k) {\n                 Some(v) => return Some(v.clone()),\n                 None => {}\n             }"}, {"sha": "5921d630b8979c6a44e9f850c6b1bbb2878aa3ce", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -313,14 +313,15 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                                                       .map(|ident| {\n             ast::PathSegment {\n                 identifier: ident,\n-                lifetimes: Vec::new(),\n-                types: OwnedSlice::empty(),\n+                parameters: ast::PathParameters::none(),\n             }\n         }).collect();\n         segments.push(ast::PathSegment {\n             identifier: last_identifier,\n-            lifetimes: lifetimes,\n-            types: OwnedSlice::from_vec(types),\n+            parameters: ast::AngleBracketedParameters(ast::AngleBracketedParameterData {\n+                lifetimes: lifetimes,\n+                types: OwnedSlice::from_vec(types),\n+            })\n         });\n         ast::Path {\n             span: sp,"}, {"sha": "aa18b1be31acc46e9b6615e509e43704efbaa9fd", "filename": "src/libsyntax/ext/concat_idents.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat_idents.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -12,7 +12,6 @@ use ast;\n use codemap::Span;\n use ext::base::*;\n use ext::base;\n-use owned_slice::OwnedSlice;\n use parse::token;\n use parse::token::{str_to_ident};\n use ptr::P;\n@@ -52,8 +51,7 @@ pub fn expand_syntax_ext<'cx>(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree]\n                  segments: vec!(\n                     ast::PathSegment {\n                         identifier: res,\n-                        lifetimes: Vec::new(),\n-                        types: OwnedSlice::empty(),\n+                        parameters: ast::PathParameters::none(),\n                     }\n                 )\n             }"}, {"sha": "a28f24e76635d283235d3de2f4b30f52fd70b6db", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -252,15 +252,15 @@ impl<'a, 'b> Context<'a, 'b> {\n             }\n \n             Named(name) => {\n-                let span = match self.names.find(&name) {\n+                let span = match self.names.get(&name) {\n                     Some(e) => e.span,\n                     None => {\n                         let msg = format!(\"there is no argument named `{}`\", name);\n                         self.ecx.span_err(self.fmtsp, msg.as_slice());\n                         return;\n                     }\n                 };\n-                self.verify_same(span, &ty, self.name_types.find(&name));\n+                self.verify_same(span, &ty, self.name_types.get(&name));\n                 if !self.name_types.contains_key(&name) {\n                     self.name_types.insert(name.clone(), ty);\n                 }\n@@ -555,11 +555,11 @@ impl<'a, 'b> Context<'a, 'b> {\n             heads.push(self.ecx.expr_addr_of(e.span, e));\n         }\n         for name in self.name_ordering.iter() {\n-            let e = match self.names.pop(name) {\n+            let e = match self.names.remove(name) {\n                 Some(e) => e,\n                 None => continue\n             };\n-            let arg_ty = match self.name_types.find(name) {\n+            let arg_ty = match self.name_types.get(name) {\n                 Some(ty) => ty,\n                 None => continue\n             };"}, {"sha": "15fe7fc42b27507b0d80710dedc100e1b892686f", "filename": "src/libsyntax/ext/mtwt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibsyntax%2Fext%2Fmtwt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibsyntax%2Fext%2Fmtwt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fmtwt.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -182,7 +182,7 @@ fn resolve_internal(id: Ident,\n                     resolve_table: &mut ResolveTable) -> Name {\n     let key = (id.name, id.ctxt);\n \n-    match resolve_table.find(&key) {\n+    match resolve_table.get(&key) {\n         Some(&name) => return name,\n         None => {}\n     }"}, {"sha": "80b158a54d36cf90dd8d20fc473044134e3c89fd", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -313,11 +313,6 @@ impl<'a, 'v> Visitor<'v> for Context<'a> {\n                                    experimental and likely to be removed\");\n \n             },\n-            ast::TyUnboxedFn(..) => {\n-                self.gate_feature(\"unboxed_closure_sugar\",\n-                                  t.span,\n-                                  \"unboxed closure trait sugar is experimental\");\n-            }\n             _ => {}\n         }\n "}, {"sha": "cd4a3d10c48825749105d304305b494adcbc94d5", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 47, "deletions": 26, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -166,6 +166,22 @@ pub trait Folder {\n         noop_fold_path(p, self)\n     }\n \n+    fn fold_path_parameters(&mut self, p: PathParameters) -> PathParameters {\n+        noop_fold_path_parameters(p, self)\n+    }\n+\n+    fn fold_angle_bracketed_parameter_data(&mut self, p: AngleBracketedParameterData)\n+                                           -> AngleBracketedParameterData\n+    {\n+        noop_fold_angle_bracketed_parameter_data(p, self)\n+    }\n+\n+    fn fold_parenthesized_parameter_data(&mut self, p: ParenthesizedParameterData)\n+                                         -> ParenthesizedParameterData\n+    {\n+        noop_fold_parenthesized_parameter_data(p, self)\n+    }\n+\n     fn fold_local(&mut self, l: P<Local>) -> P<Local> {\n         noop_fold_local(l, self)\n     }\n@@ -408,12 +424,6 @@ pub fn noop_fold_ty<T: Folder>(t: P<Ty>, fld: &mut T) -> P<Ty> {\n                     decl: fld.fold_fn_decl(decl)\n                 }))\n             }\n-            TyUnboxedFn(f) => {\n-                TyUnboxedFn(f.map(|UnboxedFnTy {decl, kind}| UnboxedFnTy {\n-                    decl: fld.fold_fn_decl(decl),\n-                    kind: kind,\n-                }))\n-            }\n             TyTup(tys) => TyTup(tys.move_map(|ty| fld.fold_ty(ty))),\n             TyParen(ty) => TyParen(fld.fold_ty(ty)),\n             TyPath(path, bounds, id) => {\n@@ -480,15 +490,43 @@ pub fn noop_fold_uint<T: Folder>(i: uint, _: &mut T) -> uint {\n pub fn noop_fold_path<T: Folder>(Path {global, segments, span}: Path, fld: &mut T) -> Path {\n     Path {\n         global: global,\n-        segments: segments.move_map(|PathSegment {identifier, lifetimes, types}| PathSegment {\n+        segments: segments.move_map(|PathSegment {identifier, parameters}| PathSegment {\n             identifier: fld.fold_ident(identifier),\n-            lifetimes: fld.fold_lifetimes(lifetimes),\n-            types: types.move_map(|typ| fld.fold_ty(typ)),\n+            parameters: fld.fold_path_parameters(parameters),\n         }),\n         span: fld.new_span(span)\n     }\n }\n \n+pub fn noop_fold_path_parameters<T: Folder>(path_parameters: PathParameters, fld: &mut T)\n+                                            -> PathParameters\n+{\n+    match path_parameters {\n+        AngleBracketedParameters(data) =>\n+            AngleBracketedParameters(fld.fold_angle_bracketed_parameter_data(data)),\n+        ParenthesizedParameters(data) =>\n+            ParenthesizedParameters(fld.fold_parenthesized_parameter_data(data)),\n+    }\n+}\n+\n+pub fn noop_fold_angle_bracketed_parameter_data<T: Folder>(data: AngleBracketedParameterData,\n+                                                           fld: &mut T)\n+                                                           -> AngleBracketedParameterData\n+{\n+    let AngleBracketedParameterData { lifetimes, types } = data;\n+    AngleBracketedParameterData { lifetimes: fld.fold_lifetimes(lifetimes),\n+                                  types: types.move_map(|ty| fld.fold_ty(ty)) }\n+}\n+\n+pub fn noop_fold_parenthesized_parameter_data<T: Folder>(data: ParenthesizedParameterData,\n+                                                         fld: &mut T)\n+                                                         -> ParenthesizedParameterData\n+{\n+    let ParenthesizedParameterData { inputs, output } = data;\n+    ParenthesizedParameterData { inputs: inputs.move_map(|ty| fld.fold_ty(ty)),\n+                                 output: output.map(|ty| fld.fold_ty(ty)) }\n+}\n+\n pub fn noop_fold_local<T: Folder>(l: P<Local>, fld: &mut T) -> P<Local> {\n     l.map(|Local {id, pat, ty, init, source, span}| Local {\n         id: fld.new_id(id),\n@@ -671,23 +709,6 @@ pub fn noop_fold_ty_param_bound<T>(tpb: TyParamBound, fld: &mut T)\n     match tpb {\n         TraitTyParamBound(ty) => TraitTyParamBound(fld.fold_trait_ref(ty)),\n         RegionTyParamBound(lifetime) => RegionTyParamBound(fld.fold_lifetime(lifetime)),\n-        UnboxedFnTyParamBound(bound) => {\n-            match *bound {\n-                UnboxedFnBound {\n-                    ref path,\n-                    ref decl,\n-                    ref lifetimes,\n-                    ref_id\n-                } => {\n-                    UnboxedFnTyParamBound(P(UnboxedFnBound {\n-                        path: fld.fold_path(path.clone()),\n-                        decl: fld.fold_fn_decl(decl.clone()),\n-                        lifetimes: fld.fold_lifetime_defs(lifetimes.clone()),\n-                        ref_id: fld.new_id(ref_id),\n-                    }))\n-                }\n-            }\n-        }\n     }\n }\n "}, {"sha": "996708b217426d186a5d7b44f39ca3c3850a9252", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 8, "deletions": 16, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -749,8 +749,7 @@ mod test {\n                         segments: vec!(\n                             ast::PathSegment {\n                                 identifier: str_to_ident(\"a\"),\n-                                lifetimes: Vec::new(),\n-                                types: OwnedSlice::empty(),\n+                                parameters: ast::PathParameters::none(),\n                             }\n                         ),\n                     }),\n@@ -768,13 +767,11 @@ mod test {\n                             segments: vec!(\n                                 ast::PathSegment {\n                                     identifier: str_to_ident(\"a\"),\n-                                    lifetimes: Vec::new(),\n-                                    types: OwnedSlice::empty(),\n+                                    parameters: ast::PathParameters::none(),\n                                 },\n                                 ast::PathSegment {\n                                     identifier: str_to_ident(\"b\"),\n-                                    lifetimes: Vec::new(),\n-                                    types: OwnedSlice::empty(),\n+                                    parameters: ast::PathParameters::none(),\n                                 }\n                             )\n                         }),\n@@ -952,8 +949,7 @@ mod test {\n                             segments: vec!(\n                                 ast::PathSegment {\n                                     identifier: str_to_ident(\"d\"),\n-                                    lifetimes: Vec::new(),\n-                                    types: OwnedSlice::empty(),\n+                                    parameters: ast::PathParameters::none(),\n                                 }\n                             ),\n                         }),\n@@ -974,8 +970,7 @@ mod test {\n                                segments: vec!(\n                                 ast::PathSegment {\n                                     identifier: str_to_ident(\"b\"),\n-                                    lifetimes: Vec::new(),\n-                                    types: OwnedSlice::empty(),\n+                                    parameters: ast::PathParameters::none(),\n                                 }\n                                ),\n                             }),\n@@ -1022,8 +1017,7 @@ mod test {\n                                             ast::PathSegment {\n                                                 identifier:\n                                                     str_to_ident(\"int\"),\n-                                                lifetimes: Vec::new(),\n-                                                types: OwnedSlice::empty(),\n+                                                parameters: ast::PathParameters::none(),\n                                             }\n                                         ),\n                                         }, None, ast::DUMMY_NODE_ID),\n@@ -1072,10 +1066,8 @@ mod test {\n                                                                 identifier:\n                                                                 str_to_ident(\n                                                                     \"b\"),\n-                                                                lifetimes:\n-                                                                Vec::new(),\n-                                                                types:\n-                                                                OwnedSlice::empty()\n+                                                                parameters:\n+                                                                ast::PathParameters::none(),\n                                                             }\n                                                         ),\n                                                       }),"}, {"sha": "18dd7074d28b32e8389d4ae3bddc9735b9d28b60", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 154, "deletions": 112, "changes": 266, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -53,9 +53,8 @@ use ast::{TtNonterminal, TupleVariantKind, Ty, Ty_, TyBot};\n use ast::{TypeField, TyFixedLengthVec, TyClosure, TyProc, TyBareFn};\n use ast::{TyTypeof, TyInfer, TypeMethod};\n use ast::{TyNil, TyParam, TyParamBound, TyParen, TyPath, TyPtr, TyQPath};\n-use ast::{TyRptr, TyTup, TyU32, TyUnboxedFn, TyUniq, TyVec, UnUniq};\n+use ast::{TyRptr, TyTup, TyU32, TyUniq, TyVec, UnUniq};\n use ast::{TypeImplItem, TypeTraitItem, Typedef, UnboxedClosureKind};\n-use ast::{UnboxedFnBound, UnboxedFnTy, UnboxedFnTyParamBound};\n use ast::{UnnamedField, UnsafeBlock};\n use ast::{UnsafeFn, ViewItem, ViewItem_, ViewItemExternCrate, ViewItemUse};\n use ast::{ViewPath, ViewPathGlob, ViewPathList, ViewPathSimple};\n@@ -1127,19 +1126,16 @@ impl<'a> Parser<'a> {\n             Vec::new()\n         };\n \n-        let (optional_unboxed_closure_kind, inputs) = if self.eat(&token::OrOr) {\n-            (None, Vec::new())\n+        let inputs = if self.eat(&token::OrOr) {\n+            Vec::new()\n         } else {\n             self.expect_or();\n \n-            let optional_unboxed_closure_kind =\n-                self.parse_optional_unboxed_closure_kind();\n-\n             let inputs = self.parse_seq_to_before_or(\n                 &token::Comma,\n                 |p| p.parse_arg_general(false));\n             self.expect_or();\n-            (optional_unboxed_closure_kind, inputs)\n+            inputs\n         };\n \n         let bounds = self.parse_colon_then_ty_param_bounds();\n@@ -1152,23 +1148,13 @@ impl<'a> Parser<'a> {\n             variadic: false\n         });\n \n-        match optional_unboxed_closure_kind {\n-            Some(unboxed_closure_kind) => {\n-                TyUnboxedFn(P(UnboxedFnTy {\n-                    kind: unboxed_closure_kind,\n-                    decl: decl,\n-                }))\n-            }\n-            None => {\n-                TyClosure(P(ClosureTy {\n-                    fn_style: fn_style,\n-                    onceness: onceness,\n-                    bounds: bounds,\n-                    decl: decl,\n-                    lifetimes: lifetime_defs,\n-                }))\n-            }\n-        }\n+        TyClosure(P(ClosureTy {\n+            fn_style: fn_style,\n+            onceness: onceness,\n+            bounds: bounds,\n+            decl: decl,\n+            lifetimes: lifetime_defs,\n+        }))\n     }\n \n     pub fn parse_unsafety(&mut self) -> FnStyle {\n@@ -1487,9 +1473,9 @@ impl<'a> Parser<'a> {\n                 trait_name: trait_name.path,\n                 item_name: item_name,\n             }))\n-        } else if self.token == token::ModSep\n-            || self.token.is_ident()\n-            || self.token.is_path() {\n+        } else if self.token == token::ModSep ||\n+                  self.token.is_ident() ||\n+                  self.token.is_path() {\n             // NAMED TYPE\n             let mode = if plus_allowed {\n                 LifetimeAndTypesAndBounds\n@@ -1706,50 +1692,18 @@ impl<'a> Parser<'a> {\n         // Parse any number of segments and bound sets. A segment is an\n         // identifier followed by an optional lifetime and a set of types.\n         // A bound set is a set of type parameter bounds.\n-        let mut segments = Vec::new();\n-        loop {\n-            // First, parse an identifier.\n-            let identifier = self.parse_ident();\n-\n-            // Parse the '::' before type parameters if it's required. If\n-            // it is required and wasn't present, then we're done.\n-            if mode == LifetimeAndTypesWithColons &&\n-                    !self.eat(&token::ModSep) {\n-                segments.push(ast::PathSegment {\n-                    identifier: identifier,\n-                    lifetimes: Vec::new(),\n-                    types: OwnedSlice::empty(),\n-                });\n-                break\n+        let segments = match mode {\n+            LifetimeAndTypesWithoutColons |\n+            LifetimeAndTypesAndBounds => {\n+                self.parse_path_segments_without_colons()\n             }\n-\n-            // Parse the `<` before the lifetime and types, if applicable.\n-            let (any_lifetime_or_types, lifetimes, types) = {\n-                if mode != NoTypesAllowed && self.eat_lt(false) {\n-                    let (lifetimes, types) =\n-                        self.parse_generic_values_after_lt();\n-                    (true, lifetimes, OwnedSlice::from_vec(types))\n-                } else {\n-                    (false, Vec::new(), OwnedSlice::empty())\n-                }\n-            };\n-\n-            // Assemble and push the result.\n-            segments.push(ast::PathSegment {\n-                identifier: identifier,\n-                lifetimes: lifetimes,\n-                types: types,\n-            });\n-\n-            // We're done if we don't see a '::', unless the mode required\n-            // a double colon to get here in the first place.\n-            if !(mode == LifetimeAndTypesWithColons &&\n-                    !any_lifetime_or_types) {\n-                if !self.eat(&token::ModSep) {\n-                    break\n-                }\n+            LifetimeAndTypesWithColons => {\n+                self.parse_path_segments_with_colons()\n             }\n-        }\n+            NoTypesAllowed => {\n+                self.parse_path_segments_without_types()\n+            }\n+        };\n \n         // Next, parse a plus and bounded type parameters, if\n         // applicable. We need to remember whether the separate was\n@@ -1792,6 +1746,123 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n+    /// Examples:\n+    /// - `a::b<T,U>::c<V,W>`\n+    /// - `a::b<T,U>::c(V) -> W`\n+    /// - `a::b<T,U>::c(V)`\n+    pub fn parse_path_segments_without_colons(&mut self) -> Vec<ast::PathSegment> {\n+        let mut segments = Vec::new();\n+        loop {\n+            // First, parse an identifier.\n+            let identifier = self.parse_ident();\n+\n+            // Parse types, optionally.\n+            let parameters = if self.eat_lt(false) {\n+                let (lifetimes, types) = self.parse_generic_values_after_lt();\n+\n+                ast::AngleBracketedParameters(ast::AngleBracketedParameterData {\n+                    lifetimes: lifetimes,\n+                    types: OwnedSlice::from_vec(types),\n+                })\n+            } else if self.eat(&token::OpenDelim(token::Paren)) {\n+                let inputs = self.parse_seq_to_end(\n+                    &token::CloseDelim(token::Paren),\n+                    seq_sep_trailing_allowed(token::Comma),\n+                    |p| p.parse_ty(true));\n+\n+                let output_ty = if self.eat(&token::RArrow) {\n+                    Some(self.parse_ty(true))\n+                } else {\n+                    None\n+                };\n+\n+                ast::ParenthesizedParameters(ast::ParenthesizedParameterData {\n+                    inputs: inputs,\n+                    output: output_ty\n+                })\n+            } else {\n+                ast::PathParameters::none()\n+            };\n+\n+            // Assemble and push the result.\n+            segments.push(ast::PathSegment { identifier: identifier,\n+                                             parameters: parameters });\n+\n+            // Continue only if we see a `::`\n+            if !self.eat(&token::ModSep) {\n+                return segments;\n+            }\n+        }\n+    }\n+\n+    /// Examples:\n+    /// - `a::b::<T,U>::c`\n+    pub fn parse_path_segments_with_colons(&mut self) -> Vec<ast::PathSegment> {\n+        let mut segments = Vec::new();\n+        loop {\n+            // First, parse an identifier.\n+            let identifier = self.parse_ident();\n+\n+            // If we do not see a `::`, stop.\n+            if !self.eat(&token::ModSep) {\n+                segments.push(ast::PathSegment {\n+                    identifier: identifier,\n+                    parameters: ast::AngleBracketedParameters(ast::AngleBracketedParameterData {\n+                        lifetimes: Vec::new(),\n+                        types: OwnedSlice::empty(),\n+                    })\n+                });\n+                return segments;\n+            }\n+\n+            // Check for a type segment.\n+            if self.eat_lt(false) {\n+                // Consumed `a::b::<`, go look for types\n+                let (lifetimes, types) = self.parse_generic_values_after_lt();\n+                segments.push(ast::PathSegment {\n+                    identifier: identifier,\n+                    parameters: ast::AngleBracketedParameters(ast::AngleBracketedParameterData {\n+                        lifetimes: lifetimes,\n+                        types: OwnedSlice::from_vec(types),\n+                    }),\n+                });\n+\n+                // Consumed `a::b::<T,U>`, check for `::` before proceeding\n+                if !self.eat(&token::ModSep) {\n+                    return segments;\n+                }\n+            } else {\n+                // Consumed `a::`, go look for `b`\n+                segments.push(ast::PathSegment {\n+                    identifier: identifier,\n+                    parameters: ast::PathParameters::none(),\n+                });\n+            }\n+        }\n+    }\n+\n+\n+    /// Examples:\n+    /// - `a::b::c`\n+    pub fn parse_path_segments_without_types(&mut self) -> Vec<ast::PathSegment> {\n+        let mut segments = Vec::new();\n+        loop {\n+            // First, parse an identifier.\n+            let identifier = self.parse_ident();\n+\n+            // Assemble and push the result.\n+            segments.push(ast::PathSegment {\n+                identifier: identifier,\n+                parameters: ast::PathParameters::none()\n+            });\n+\n+            // If we do not see a `::`, stop.\n+            if !self.eat(&token::ModSep) {\n+                return segments;\n+            }\n+        }\n+    }\n+\n     /// parses 0 or 1 lifetime\n     pub fn parse_opt_lifetime(&mut self) -> Option<ast::Lifetime> {\n         match self.token {\n@@ -3389,13 +3460,9 @@ impl<'a> Parser<'a> {\n                           },\n                           _ => {\n                               if !enum_path.global &&\n-                                    enum_path.segments.len() == 1 &&\n-                                    enum_path.segments[0]\n-                                             .lifetimes\n-                                             .len() == 0 &&\n-                                    enum_path.segments[0]\n-                                             .types\n-                                             .len() == 0 {\n+                                  enum_path.segments.len() == 1 &&\n+                                  enum_path.segments[0].parameters.is_empty()\n+                              {\n                                   // it could still be either an enum\n                                   // or an identifier pattern, resolve\n                                   // will sort it out:\n@@ -3854,31 +3921,11 @@ impl<'a> Parser<'a> {\n                 token::ModSep | token::Ident(..) => {\n                     let path =\n                         self.parse_path(LifetimeAndTypesWithoutColons).path;\n-                    if self.token == token::OpenDelim(token::Paren) {\n-                        self.bump();\n-                        let inputs = self.parse_seq_to_end(\n-                            &token::CloseDelim(token::Paren),\n-                            seq_sep_trailing_allowed(token::Comma),\n-                            |p| p.parse_arg_general(false));\n-                        let (return_style, output) = self.parse_ret_ty();\n-                        result.push(UnboxedFnTyParamBound(P(UnboxedFnBound {\n-                            path: path,\n-                            decl: P(FnDecl {\n-                                inputs: inputs,\n-                                output: output,\n-                                cf: return_style,\n-                                variadic: false,\n-                            }),\n-                            lifetimes: lifetime_defs,\n-                            ref_id: ast::DUMMY_NODE_ID,\n-                        })));\n-                    } else {\n-                        result.push(TraitTyParamBound(ast::TraitRef {\n-                            path: path,\n-                            ref_id: ast::DUMMY_NODE_ID,\n-                            lifetimes: lifetime_defs,\n-                        }))\n-                    }\n+                    result.push(TraitTyParamBound(ast::TraitRef {\n+                        path: path,\n+                        ref_id: ast::DUMMY_NODE_ID,\n+                        lifetimes: lifetime_defs,\n+                    }))\n                 }\n                 _ => break,\n             }\n@@ -3894,8 +3941,7 @@ impl<'a> Parser<'a> {\n     fn trait_ref_from_ident(ident: Ident, span: Span) -> ast::TraitRef {\n         let segment = ast::PathSegment {\n             identifier: ident,\n-            lifetimes: Vec::new(),\n-            types: OwnedSlice::empty(),\n+            parameters: ast::PathParameters::none()\n         };\n         let path = ast::Path {\n             span: span,\n@@ -5611,8 +5657,7 @@ impl<'a> Parser<'a> {\n                 segments: path.into_iter().map(|identifier| {\n                     ast::PathSegment {\n                         identifier: identifier,\n-                        lifetimes: Vec::new(),\n-                        types: OwnedSlice::empty(),\n+                        parameters: ast::PathParameters::none(),\n                     }\n                 }).collect()\n             };\n@@ -5646,8 +5691,7 @@ impl<'a> Parser<'a> {\n                         segments: path.into_iter().map(|identifier| {\n                             ast::PathSegment {\n                                 identifier: identifier,\n-                                lifetimes: Vec::new(),\n-                                types: OwnedSlice::empty(),\n+                                parameters: ast::PathParameters::none(),\n                             }\n                         }).collect()\n                     };\n@@ -5664,8 +5708,7 @@ impl<'a> Parser<'a> {\n                         segments: path.into_iter().map(|identifier| {\n                             ast::PathSegment {\n                                 identifier: identifier,\n-                                lifetimes: Vec::new(),\n-                                types: OwnedSlice::empty(),\n+                                parameters: ast::PathParameters::none(),\n                             }\n                         }).collect()\n                     };\n@@ -5686,8 +5729,7 @@ impl<'a> Parser<'a> {\n             segments: path.into_iter().map(|identifier| {\n                 ast::PathSegment {\n                     identifier: identifier,\n-                    lifetimes: Vec::new(),\n-                    types: OwnedSlice::empty(),\n+                    parameters: ast::PathParameters::none(),\n                 }\n             }).collect()\n         };"}, {"sha": "2448eacbb39986a32e5290cb729d739d9c3574b9", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 51, "deletions": 61, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -13,7 +13,7 @@ use ast::{FnUnboxedClosureKind, FnMutUnboxedClosureKind};\n use ast::{FnOnceUnboxedClosureKind};\n use ast::{MethodImplItem, RegionTyParamBound, TraitTyParamBound};\n use ast::{RequiredMethod, ProvidedMethod, TypeImplItem, TypeTraitItem};\n-use ast::{UnboxedClosureKind, UnboxedFnTyParamBound};\n+use ast::{UnboxedClosureKind};\n use ast;\n use ast_util;\n use owned_slice::OwnedSlice;\n@@ -699,7 +699,6 @@ impl<'a> State<'a> {\n                                       None,\n                                       &OwnedSlice::empty(),\n                                       Some(&generics),\n-                                      None,\n                                       None));\n             }\n             ast::TyClosure(ref f) => {\n@@ -719,7 +718,6 @@ impl<'a> State<'a> {\n                                       None,\n                                       &f.bounds,\n                                       Some(&generics),\n-                                      None,\n                                       None));\n             }\n             ast::TyProc(ref f) => {\n@@ -739,21 +737,8 @@ impl<'a> State<'a> {\n                                       None,\n                                       &f.bounds,\n                                       Some(&generics),\n-                                      None,\n                                       None));\n             }\n-            ast::TyUnboxedFn(ref f) => {\n-                try!(self.print_ty_fn(None,\n-                                      None,\n-                                      ast::NormalFn,\n-                                      ast::Many,\n-                                      &*f.decl,\n-                                      None,\n-                                      &OwnedSlice::empty(),\n-                                      None,\n-                                      None,\n-                                      Some(f.kind)));\n-            }\n             ast::TyPath(ref path, ref bounds, _) => {\n                 try!(self.print_bounded_path(path, bounds));\n             }\n@@ -1212,8 +1197,7 @@ impl<'a> State<'a> {\n                               Some(m.ident),\n                               &OwnedSlice::empty(),\n                               Some(&m.generics),\n-                              Some(&m.explicit_self.node),\n-                              None));\n+                              Some(&m.explicit_self.node)));\n         word(&mut self.s, \";\")\n     }\n \n@@ -1995,39 +1979,73 @@ impl<'a> State<'a> {\n \n             try!(self.print_ident(segment.identifier));\n \n-            if !segment.lifetimes.is_empty() || !segment.types.is_empty() {\n-                if colons_before_params {\n-                    try!(word(&mut self.s, \"::\"))\n-                }\n+            try!(self.print_path_parameters(&segment.parameters, colons_before_params));\n+        }\n+\n+        match *opt_bounds {\n+            None => Ok(()),\n+            Some(ref bounds) => self.print_bounds(\"+\", bounds)\n+        }\n+    }\n+\n+    fn print_path_parameters(&mut self,\n+                             parameters: &ast::PathParameters,\n+                             colons_before_params: bool)\n+                             -> IoResult<()>\n+    {\n+        if parameters.is_empty() {\n+            return Ok(());\n+        }\n+\n+        if colons_before_params {\n+            try!(word(&mut self.s, \"::\"))\n+        }\n+\n+        match *parameters {\n+            ast::AngleBracketedParameters(ref data) => {\n                 try!(word(&mut self.s, \"<\"));\n \n                 let mut comma = false;\n-                for lifetime in segment.lifetimes.iter() {\n+                for lifetime in data.lifetimes.iter() {\n                     if comma {\n                         try!(self.word_space(\",\"))\n                     }\n                     try!(self.print_lifetime(lifetime));\n                     comma = true;\n                 }\n \n-                if !segment.types.is_empty() {\n+                if !data.types.is_empty() {\n                     if comma {\n                         try!(self.word_space(\",\"))\n                     }\n                     try!(self.commasep(\n                         Inconsistent,\n-                        segment.types.as_slice(),\n+                        data.types.as_slice(),\n                         |s, ty| s.print_type(&**ty)));\n                 }\n \n                 try!(word(&mut self.s, \">\"))\n             }\n-        }\n \n-        match *opt_bounds {\n-            None => Ok(()),\n-            Some(ref bounds) => self.print_bounds(\"+\", bounds)\n+            ast::ParenthesizedParameters(ref data) => {\n+                try!(word(&mut self.s, \"(\"));\n+                try!(self.commasep(\n+                    Inconsistent,\n+                    data.inputs.as_slice(),\n+                    |s, ty| s.print_type(&**ty)));\n+                try!(word(&mut self.s, \")\"));\n+\n+                match data.output {\n+                    None => { }\n+                    Some(ref ty) => {\n+                        try!(self.word_space(\"->\"));\n+                        try!(self.print_type(&**ty));\n+                    }\n+                }\n+            }\n         }\n+\n+        Ok(())\n     }\n \n     fn print_path(&mut self, path: &ast::Path,\n@@ -2373,15 +2391,6 @@ impl<'a> State<'a> {\n                     RegionTyParamBound(ref lt) => {\n                         self.print_lifetime(lt)\n                     }\n-                    UnboxedFnTyParamBound(ref unboxed_function_type) => {\n-                        try!(self.print_path(&unboxed_function_type.path,\n-                                             false));\n-                        try!(self.popen());\n-                        try!(self.print_fn_args(&*unboxed_function_type.decl,\n-                                                None));\n-                        try!(self.pclose());\n-                        self.print_fn_output(&*unboxed_function_type.decl)\n-                    }\n                 })\n             }\n             Ok(())\n@@ -2641,9 +2650,7 @@ impl<'a> State<'a> {\n                        id: Option<ast::Ident>,\n                        bounds: &OwnedSlice<ast::TyParamBound>,\n                        generics: Option<&ast::Generics>,\n-                       opt_explicit_self: Option<&ast::ExplicitSelf_>,\n-                       opt_unboxed_closure_kind:\n-                        Option<ast::UnboxedClosureKind>)\n+                       opt_explicit_self: Option<&ast::ExplicitSelf_>)\n                        -> IoResult<()> {\n         try!(self.ibox(indent_unit));\n \n@@ -2660,9 +2667,7 @@ impl<'a> State<'a> {\n             try!(self.print_fn_style(fn_style));\n             try!(self.print_opt_abi_and_extern_if_nondefault(opt_abi));\n             try!(self.print_onceness(onceness));\n-            if opt_unboxed_closure_kind.is_none() {\n-                try!(word(&mut self.s, \"fn\"));\n-            }\n+            try!(word(&mut self.s, \"fn\"));\n         }\n \n         match id {\n@@ -2676,30 +2681,15 @@ impl<'a> State<'a> {\n         match generics { Some(g) => try!(self.print_generics(g)), _ => () }\n         try!(zerobreak(&mut self.s));\n \n-        if opt_unboxed_closure_kind.is_some() || opt_sigil == Some('&') {\n+        if opt_sigil == Some('&') {\n             try!(word(&mut self.s, \"|\"));\n         } else {\n             try!(self.popen());\n         }\n \n-        match opt_unboxed_closure_kind {\n-            Some(ast::FnUnboxedClosureKind) => {\n-                try!(word(&mut self.s, \"&\"));\n-                try!(self.word_space(\":\"));\n-            }\n-            Some(ast::FnMutUnboxedClosureKind) => {\n-                try!(word(&mut self.s, \"&mut\"));\n-                try!(self.word_space(\":\"));\n-            }\n-            Some(ast::FnOnceUnboxedClosureKind) => {\n-                try!(self.word_space(\":\"));\n-            }\n-            None => {}\n-        }\n-\n         try!(self.print_fn_args(decl, opt_explicit_self));\n \n-        if opt_unboxed_closure_kind.is_some() || opt_sigil == Some('&') {\n+        if opt_sigil == Some('&') {\n             try!(word(&mut self.s, \"|\"));\n         } else {\n             if decl.variadic {"}, {"sha": "6a4ab365a50b2930c9870ada96f8d23c2cfe72b3", "filename": "src/libsyntax/std_inject.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibsyntax%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibsyntax%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fstd_inject.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -14,7 +14,6 @@ use codemap::DUMMY_SP;\n use codemap;\n use fold::Folder;\n use fold;\n-use owned_slice::OwnedSlice;\n use parse::token::InternedString;\n use parse::token::special_idents;\n use parse::token;\n@@ -181,13 +180,11 @@ impl<'a> fold::Folder for PreludeInjector<'a> {\n             segments: vec!(\n                 ast::PathSegment {\n                     identifier: token::str_to_ident(\"std\"),\n-                    lifetimes: Vec::new(),\n-                    types: OwnedSlice::empty(),\n+                    parameters: ast::PathParameters::none(),\n                 },\n                 ast::PathSegment {\n                     identifier: token::str_to_ident(\"prelude\"),\n-                    lifetimes: Vec::new(),\n-                    types: OwnedSlice::empty(),\n+                    parameters: ast::PathParameters::none(),\n                 }),\n         };\n "}, {"sha": "a7db8e800a9d0e54503d2b86bc7fca21cc2b1af1", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -453,8 +453,7 @@ fn path_node(ids: Vec<ast::Ident> ) -> ast::Path {\n         global: false,\n         segments: ids.into_iter().map(|identifier| ast::PathSegment {\n             identifier: identifier,\n-            lifetimes: Vec::new(),\n-            types: OwnedSlice::empty(),\n+            parameters: ast::PathParameters::none(),\n         }).collect()\n     }\n }"}, {"sha": "bc6d6d7a5216d091c1a15741747102590a533d80", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -45,7 +45,7 @@ impl<T: Eq + Hash + Clone + 'static> Interner<T> {\n \n     pub fn intern(&self, val: T) -> Name {\n         let mut map = self.map.borrow_mut();\n-        match (*map).find(&val) {\n+        match (*map).get(&val) {\n             Some(&idx) => return idx,\n             None => (),\n         }"}, {"sha": "9751abacbd3ff863bc42cae0f235763e72777e15", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -365,12 +365,6 @@ pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty) {\n             visitor.visit_ty(&*function_declaration.decl.output);\n             walk_lifetime_decls(visitor, &function_declaration.lifetimes);\n         }\n-        TyUnboxedFn(ref function_declaration) => {\n-            for argument in function_declaration.decl.inputs.iter() {\n-                visitor.visit_ty(&*argument.ty)\n-            }\n-            visitor.visit_ty(&*function_declaration.decl.output);\n-        }\n         TyPath(ref path, ref opt_bounds, id) => {\n             visitor.visit_path(path, id);\n             match *opt_bounds {\n@@ -407,11 +401,23 @@ pub fn walk_path<'v, V: Visitor<'v>>(visitor: &mut V, path: &'v Path) {\n     for segment in path.segments.iter() {\n         visitor.visit_ident(path.span, segment.identifier);\n \n-        for typ in segment.types.iter() {\n-            visitor.visit_ty(&**typ);\n-        }\n-        for lifetime in segment.lifetimes.iter() {\n-            visitor.visit_lifetime_ref(lifetime);\n+        match segment.parameters {\n+            ast::AngleBracketedParameters(ref data) => {\n+                for typ in data.types.iter() {\n+                    visitor.visit_ty(&**typ);\n+                }\n+                for lifetime in data.lifetimes.iter() {\n+                    visitor.visit_lifetime_ref(lifetime);\n+                }\n+            }\n+            ast::ParenthesizedParameters(ref data) => {\n+                for typ in data.inputs.iter() {\n+                    visitor.visit_ty(&**typ);\n+                }\n+                for typ in data.output.iter() {\n+                    visitor.visit_ty(&**typ);\n+                }\n+            }\n         }\n     }\n }\n@@ -493,13 +499,6 @@ pub fn walk_ty_param_bounds<'v, V: Visitor<'v>>(visitor: &mut V,\n             TraitTyParamBound(ref typ) => {\n                 walk_trait_ref_helper(visitor, typ)\n             }\n-            UnboxedFnTyParamBound(ref function_declaration) => {\n-                for argument in function_declaration.decl.inputs.iter() {\n-                    visitor.visit_ty(&*argument.ty)\n-                }\n-                visitor.visit_ty(&*function_declaration.decl.output);\n-                walk_lifetime_decls(visitor, &function_declaration.lifetimes);\n-            }\n             RegionTyParamBound(ref lifetime) => {\n                 visitor.visit_lifetime_ref(lifetime);\n             }"}, {"sha": "4d6aefb2a178d466ae5ac16dbc0f19e12335dc13", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -1209,7 +1209,7 @@ impl MetricMap {\n         let MetricMap(ref selfmap) = *self;\n         let MetricMap(ref old) = *old;\n         for (k, vold) in old.iter() {\n-            let r = match selfmap.find(k) {\n+            let r = match selfmap.get(k) {\n                 None => MetricRemoved,\n                 Some(v) => {\n                     let delta = v.value - vold.value;\n@@ -1678,31 +1678,31 @@ mod tests {\n \n         let diff1 = m2.compare_to_old(&m1, None);\n \n-        assert_eq!(*(diff1.find(&\"in-both-noise\".to_string()).unwrap()), LikelyNoise);\n-        assert_eq!(*(diff1.find(&\"in-first-noise\".to_string()).unwrap()), MetricRemoved);\n-        assert_eq!(*(diff1.find(&\"in-second-noise\".to_string()).unwrap()), MetricAdded);\n-        assert_eq!(*(diff1.find(&\"in-both-want-downwards-but-regressed\".to_string()).unwrap()),\n+        assert_eq!(*(diff1.get(&\"in-both-noise\".to_string()).unwrap()), LikelyNoise);\n+        assert_eq!(*(diff1.get(&\"in-first-noise\".to_string()).unwrap()), MetricRemoved);\n+        assert_eq!(*(diff1.get(&\"in-second-noise\".to_string()).unwrap()), MetricAdded);\n+        assert_eq!(*(diff1.get(&\"in-both-want-downwards-but-regressed\".to_string()).unwrap()),\n                    Regression(100.0));\n-        assert_eq!(*(diff1.find(&\"in-both-want-downwards-and-improved\".to_string()).unwrap()),\n+        assert_eq!(*(diff1.get(&\"in-both-want-downwards-and-improved\".to_string()).unwrap()),\n                    Improvement(50.0));\n-        assert_eq!(*(diff1.find(&\"in-both-want-upwards-but-regressed\".to_string()).unwrap()),\n+        assert_eq!(*(diff1.get(&\"in-both-want-upwards-but-regressed\".to_string()).unwrap()),\n                    Regression(50.0));\n-        assert_eq!(*(diff1.find(&\"in-both-want-upwards-and-improved\".to_string()).unwrap()),\n+        assert_eq!(*(diff1.get(&\"in-both-want-upwards-and-improved\".to_string()).unwrap()),\n                    Improvement(100.0));\n         assert_eq!(diff1.len(), 7);\n \n         let diff2 = m2.compare_to_old(&m1, Some(200.0));\n \n-        assert_eq!(*(diff2.find(&\"in-both-noise\".to_string()).unwrap()), LikelyNoise);\n-        assert_eq!(*(diff2.find(&\"in-first-noise\".to_string()).unwrap()), MetricRemoved);\n-        assert_eq!(*(diff2.find(&\"in-second-noise\".to_string()).unwrap()), MetricAdded);\n-        assert_eq!(*(diff2.find(&\"in-both-want-downwards-but-regressed\".to_string()).unwrap()),\n+        assert_eq!(*(diff2.get(&\"in-both-noise\".to_string()).unwrap()), LikelyNoise);\n+        assert_eq!(*(diff2.get(&\"in-first-noise\".to_string()).unwrap()), MetricRemoved);\n+        assert_eq!(*(diff2.get(&\"in-second-noise\".to_string()).unwrap()), MetricAdded);\n+        assert_eq!(*(diff2.get(&\"in-both-want-downwards-but-regressed\".to_string()).unwrap()),\n                    LikelyNoise);\n-        assert_eq!(*(diff2.find(&\"in-both-want-downwards-and-improved\".to_string()).unwrap()),\n+        assert_eq!(*(diff2.get(&\"in-both-want-downwards-and-improved\".to_string()).unwrap()),\n                    LikelyNoise);\n-        assert_eq!(*(diff2.find(&\"in-both-want-upwards-but-regressed\".to_string()).unwrap()),\n+        assert_eq!(*(diff2.get(&\"in-both-want-upwards-but-regressed\".to_string()).unwrap()),\n                    LikelyNoise);\n-        assert_eq!(*(diff2.find(&\"in-both-want-upwards-and-improved\".to_string()).unwrap()),\n+        assert_eq!(*(diff2.get(&\"in-both-want-upwards-and-improved\".to_string()).unwrap()),\n                    LikelyNoise);\n         assert_eq!(diff2.len(), 7);\n     }\n@@ -1727,29 +1727,29 @@ mod tests {\n         let (diff1, ok1) = m2.ratchet(&pth, None);\n         assert_eq!(ok1, false);\n         assert_eq!(diff1.len(), 2);\n-        assert_eq!(*(diff1.find(&\"runtime\".to_string()).unwrap()), Regression(10.0));\n-        assert_eq!(*(diff1.find(&\"throughput\".to_string()).unwrap()), LikelyNoise);\n+        assert_eq!(*(diff1.get(&\"runtime\".to_string()).unwrap()), Regression(10.0));\n+        assert_eq!(*(diff1.get(&\"throughput\".to_string()).unwrap()), LikelyNoise);\n \n         // Check that it was not rewritten.\n         let m3 = MetricMap::load(&pth);\n         let MetricMap(m3) = m3;\n         assert_eq!(m3.len(), 2);\n-        assert_eq!(*(m3.find(&\"runtime\".to_string()).unwrap()), Metric::new(1000.0, 2.0));\n-        assert_eq!(*(m3.find(&\"throughput\".to_string()).unwrap()), Metric::new(50.0, 2.0));\n+        assert_eq!(*(m3.get(&\"runtime\".to_string()).unwrap()), Metric::new(1000.0, 2.0));\n+        assert_eq!(*(m3.get(&\"throughput\".to_string()).unwrap()), Metric::new(50.0, 2.0));\n \n         // Ask for a ratchet with an explicit noise-percentage override,\n         // that should advance.\n         let (diff2, ok2) = m2.ratchet(&pth, Some(10.0));\n         assert_eq!(ok2, true);\n         assert_eq!(diff2.len(), 2);\n-        assert_eq!(*(diff2.find(&\"runtime\".to_string()).unwrap()), LikelyNoise);\n-        assert_eq!(*(diff2.find(&\"throughput\".to_string()).unwrap()), LikelyNoise);\n+        assert_eq!(*(diff2.get(&\"runtime\".to_string()).unwrap()), LikelyNoise);\n+        assert_eq!(*(diff2.get(&\"throughput\".to_string()).unwrap()), LikelyNoise);\n \n         // Check that it was rewritten.\n         let m4 = MetricMap::load(&pth);\n         let MetricMap(m4) = m4;\n         assert_eq!(m4.len(), 2);\n-        assert_eq!(*(m4.find(&\"runtime\".to_string()).unwrap()), Metric::new(1100.0, 2.0));\n-        assert_eq!(*(m4.find(&\"throughput\".to_string()).unwrap()), Metric::new(50.0, 2.0));\n+        assert_eq!(*(m4.get(&\"runtime\".to_string()).unwrap()), Metric::new(1100.0, 2.0));\n+        assert_eq!(*(m4.get(&\"throughput\".to_string()).unwrap()), Metric::new(50.0, 2.0));\n     }\n }"}, {"sha": "797523540492cd8cefe2c393d078db765031f1a9", "filename": "src/libunicode/tables.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibunicode%2Ftables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Flibunicode%2Ftables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Ftables.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -10,7 +10,7 @@\n \n // NOTE: The following code was generated by \"src/etc/unicode.py\", do not edit directly\n \n-#![allow(missing_doc, non_uppercase_statics, non_snake_case)]\n+#![allow(missing_docs, non_upper_case_globals, non_snake_case)]\n \n /// The version of [Unicode](http://www.unicode.org/)\n /// that the `UnicodeChar` and `UnicodeStrPrelude` traits are based on."}, {"sha": "0be2f31e2827fff2e3b777c80977475a9a139851", "filename": "src/test/auxiliary/lint_stability.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Fauxiliary%2Flint_stability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Fauxiliary%2Flint_stability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flint_stability.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -118,6 +118,9 @@ pub trait Trait {\n \n impl Trait for MethodTester {}\n \n+#[experimental]\n+pub trait ExperimentalTrait {}\n+\n #[deprecated]\n pub struct DeprecatedStruct { pub i: int }\n #[experimental]"}, {"sha": "ac6104cc38b0e3ccf3ae9f1a7162785ccf3ee607", "filename": "src/test/bench/core-map.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Fbench%2Fcore-map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Fbench%2Fcore-map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-map.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -30,18 +30,18 @@ trait MutableMap {\n \n impl MutableMap for TreeMap<uint, uint> {\n     fn insert(&mut self, k: uint, v: uint) { self.insert(k, v); }\n-    fn remove(&mut self, k: &uint) -> bool { self.remove(k) }\n-    fn find(&self, k: &uint) -> Option<&uint> { self.find(k) }\n+    fn remove(&mut self, k: &uint) -> bool { self.remove(k).is_some() }\n+    fn find(&self, k: &uint) -> Option<&uint> { self.get(k) }\n }\n impl MutableMap for HashMap<uint, uint> {\n     fn insert(&mut self, k: uint, v: uint) { self.insert(k, v); }\n-    fn remove(&mut self, k: &uint) -> bool { self.remove(k) }\n-    fn find(&self, k: &uint) -> Option<&uint> { self.find(k) }\n+    fn remove(&mut self, k: &uint) -> bool { self.remove(k).is_some() }\n+    fn find(&self, k: &uint) -> Option<&uint> { self.get(k) }\n }\n impl MutableMap for TrieMap<uint> {\n     fn insert(&mut self, k: uint, v: uint) { self.insert(k, v); }\n-    fn remove(&mut self, k: &uint) -> bool { self.remove(k) }\n-    fn find(&self, k: &uint) -> Option<&uint> { self.find(k) }\n+    fn remove(&mut self, k: &uint) -> bool { self.remove(k).is_some() }\n+    fn find(&self, k: &uint) -> Option<&uint> { self.get(k) }\n }\n \n fn ascending<M: MutableMap>(map: &mut M, n_keys: uint) {"}, {"sha": "191f70ac492188d186a5590c4de857d4b58ba29f", "filename": "src/test/bench/shootout-chameneos-redux.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -197,8 +197,8 @@ fn rendezvous(nn: uint, set: Vec<Color>) {\n \n         creatures_met += 2;\n \n-        to_creature.get_mut(fst_creature.name).send(snd_creature);\n-        to_creature.get_mut(snd_creature.name).send(fst_creature);\n+        to_creature[fst_creature.name].send(snd_creature);\n+        to_creature[snd_creature.name].send(fst_creature);\n     }\n \n     // tell each creature to stop"}, {"sha": "0a3370fa487e89c6e95daedd20c8d455fd35165a", "filename": "src/test/bench/shootout-fasta-redux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -100,7 +100,7 @@ fn sum_and_scale(a: &'static [AminoAcid]) -> Vec<AminoAcid> {\n         result.push(a_i);\n     }\n     let result_len = result.len();\n-    result.get_mut(result_len - 1).p = LOOKUP_SCALE;\n+    result[result_len - 1].p = LOOKUP_SCALE;\n     result\n }\n "}, {"sha": "6ada34a5a584d4e8e518c8095a8bc00004b51564", "filename": "src/test/bench/shootout-k-nucleotide.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -171,13 +171,13 @@ impl Table {\n                     next: None,\n                 };\n                 c.f(&mut *entry);\n-                *self.items.get_mut(index as uint) = Some(entry);\n+                self.items[index as uint] = Some(entry);\n                 return;\n             }\n         }\n \n         {\n-            let entry = self.items.get_mut(index as uint).as_mut().unwrap();\n+            let entry = self.items[index as uint].as_mut().unwrap();\n             if entry.code == key {\n                 c.f(&mut **entry);\n                 return;"}, {"sha": "d8df3eea83b0556b44429c08724e4a00b7495158", "filename": "src/test/bench/shootout-meteor.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Fbench%2Fshootout-meteor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Fbench%2Fshootout-meteor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-meteor.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -194,7 +194,7 @@ fn is_board_unfeasible(board: u64, masks: &Vec<Vec<Vec<u64>>>) -> bool {\n fn filter_masks(masks: &mut Vec<Vec<Vec<u64>>>) {\n     for i in range(0, masks.len()) {\n         for j in range(0, (*masks)[i].len()) {\n-            *masks.get_mut(i).get_mut(j) =\n+            masks[i][j] =\n                 (*masks)[i][j].iter().map(|&m| m)\n                 .filter(|&m| !is_board_unfeasible(m, masks))\n                 .collect();\n@@ -217,7 +217,7 @@ fn to_vec(raw_sol: &List<u64>) -> Vec<u8> {\n         let id = '0' as u8 + get_id(m);\n         for i in range(0u, 50) {\n             if m & 1 << i != 0 {\n-                *sol.get_mut(i) = id;\n+                sol[i] = id;\n             }\n         }\n     }"}, {"sha": "81de7a1269067b3d89dfab65ef19ce881532dfd8", "filename": "src/test/bench/shootout-regex-dna.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Fbench%2Fshootout-regex-dna.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Fbench%2Fshootout-regex-dna.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-regex-dna.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -114,7 +114,7 @@ fn main() {\n     }\n \n     for (i, variant) in variant_strs.iter().enumerate() {\n-        println!(\"{} {}\", variant, counts.get_mut(i).get());\n+        println!(\"{} {}\", variant, counts[i].get());\n     }\n     println!(\"\");\n     println!(\"{}\", ilen);"}, {"sha": "d7d8e94c8a7dbd5d468db9641fe8aebbe42b5795", "filename": "src/test/bench/shootout-reverse-complement.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -112,14 +112,15 @@ fn read_to_end<R: Reader>(r: &mut R) -> IoResult<Vec<u8>> {\n     let mut vec = Vec::with_capacity(CHUNK);\n     loop {\n         // workaround: very fast growing\n-        if vec.capacity() - vec.len() < CHUNK {\n+        let len = vec.len();\n+        if vec.capacity() - len < CHUNK {\n             let cap = vec.capacity();\n             let mult = if cap < 256 * 1024 * 1024 {\n                 16\n             } else {\n                 2\n             };\n-            vec.reserve_exact(mult * cap);\n+            vec.reserve_exact(mult * cap - len);\n         }\n         match r.push_at_least(1, CHUNK, &mut vec) {\n             Ok(_) => {}"}, {"sha": "54824d7259fa9b49731a870f5182638676e3832a", "filename": "src/test/bench/sudoku.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Fbench%2Fsudoku.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Fbench%2Fsudoku.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fsudoku.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -79,7 +79,7 @@ impl Sudoku {\n             if comps.len() == 3u {\n                 let row     = from_str::<uint>(comps[0]).unwrap() as u8;\n                 let col     = from_str::<uint>(comps[1]).unwrap() as u8;\n-                *g.get_mut(row as uint).get_mut(col as uint) =\n+                g[row as uint][col as uint] =\n                     from_str::<uint>(comps[2]).unwrap() as u8;\n             }\n             else {\n@@ -139,10 +139,10 @@ impl Sudoku {\n \n             // find first remaining color that is available\n             let next = avail.next();\n-            *self.grid.get_mut(row as uint).get_mut(col as uint) = next;\n+            self.grid[row as uint][col as uint] = next;\n             return 0u8 != next;\n         }\n-        *self.grid.get_mut(row as uint).get_mut(col as uint) = 0u8;\n+        self.grid[row as uint][col as uint] = 0u8;\n         return false;\n     }\n "}, {"sha": "e14911d3508da46ddd106a4cb141152f1efe27e1", "filename": "src/test/compile-fail/borrowck-assign-comp-idx.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-comp-idx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-comp-idx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-comp-idx.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -19,7 +19,7 @@ fn a() {\n     // Create an immutable pointer into p's contents:\n     let q: &int = &p[0];\n \n-    *p.get_mut(0) = 5; //~ ERROR cannot borrow\n+    p[0] = 5; //~ ERROR cannot borrow\n \n     println!(\"{}\", *q);\n }\n@@ -34,15 +34,15 @@ fn b() {\n \n     borrow(\n         p.as_slice(),\n-        || *p.get_mut(0) = 5); //~ ERROR cannot borrow `p` as mutable\n+        || p[0] = 5); //~ ERROR cannot borrow `p` as mutable\n }\n \n fn c() {\n     // Legal because the scope of the borrow does not include the\n     // modification:\n     let mut p = vec!(1);\n     borrow(p.as_slice(), ||{});\n-    *p.get_mut(0) = 5;\n+    p[0] = 5;\n }\n \n fn main() {"}, {"sha": "d712810589200bd2e53e02dd2a09e8d646dc0285", "filename": "src/test/compile-fail/borrowck-for-loop-head-linkage.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Fcompile-fail%2Fborrowck-for-loop-head-linkage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Fcompile-fail%2Fborrowck-for-loop-head-linkage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-for-loop-head-linkage.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -13,7 +13,7 @@ fn main() {\n     for &x in vector.iter() {\n         let cap = vector.capacity();\n         vector.grow(cap, 0u);      //~ ERROR cannot borrow\n-        *vector.get_mut(1u) = 5u;   //~ ERROR cannot borrow\n+        vector[1u] = 5u;   //~ ERROR cannot borrow\n     }\n }\n "}, {"sha": "200d208d140b69a054538222bf1d7d10c8fdf4a0", "filename": "src/test/compile-fail/borrowck-loan-vec-content.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-vec-content.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-vec-content.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-vec-content.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -26,7 +26,7 @@ fn has_mut_vec_but_tries_to_change_it() {\n     takes_imm_elt(\n         &v[0],\n         || { //~ ERROR cannot borrow `v` as mutable\n-            *v.get_mut(1) = 4;\n+            v[1] = 4;\n         })\n }\n "}, {"sha": "44f6cd7719d1db73c917c4c31d4ad8d58cee05b8", "filename": "src/test/compile-fail/issue-11382.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Fcompile-fail%2Fissue-11382.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Fcompile-fail%2Fissue-11382.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-11382.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+panic!(\n+    1.2\n+//~^ ERROR cannot determine the type of this number; add a suffix to specify the type explicitly\n+);\n+}"}, {"sha": "7ce23e1f6ac7971db75d516a2a4d243f92f88487", "filename": "src/test/compile-fail/issue-11771.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Fcompile-fail%2Fissue-11771.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Fcompile-fail%2Fissue-11771.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-11771.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    let x = ();\n+    1 +\n+    x //~ ERROR mismatched types: expected `_`, found `()` (expected integral variable, found ())\n+    ;\n+\n+    let x: () = ();\n+    1 +\n+    x //~ ERROR mismatched types: expected `_`, found `()` (expected integral variable, found ())\n+    ;\n+}"}, {"sha": "5203c91237be845ec3fca3443df84c8702c3e7e2", "filename": "src/test/compile-fail/issue-13058.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Fcompile-fail%2Fissue-13058.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Fcompile-fail%2Fissue-13058.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-13058.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::iter::{Range,range};\n+\n+trait Itble<'r, T, I: Iterator<T>> { fn iter(&'r self) -> I; }\n+\n+impl<'r> Itble<'r, uint, Range<uint>> for (uint, uint) {\n+    fn iter(&'r self) -> Range<uint> {\n+        let &(min, max) = self;\n+        range(min, max)\n+    }\n+}\n+\n+fn check<'r, I: Iterator<uint>, T: Itble<'r, uint, I>>(cont: &T) -> bool\n+//~^ HELP as shown: fn check<'r, I: Iterator<uint>, T: Itble<'r, uint, I>>(cont: &'r T) -> bool\n+{\n+    let cont_iter = cont.iter();\n+//~^ ERROR cannot infer an appropriate lifetime for autoref due to conflicting requirements\n+    let result = cont_iter.fold(Some(0u16), |state, val| {\n+        state.map_or(None, |mask| {\n+            let bit = 1 << val;\n+            if mask & bit == 0 {Some(mask|bit)} else {None}\n+        })\n+    });\n+    result.is_some()\n+}\n+\n+fn main() {\n+    check((3u, 5u));\n+//~^ ERROR mismatched types: expected `&_`, found `(uint, uint)` (expected &-ptr, found tuple)\n+}"}, {"sha": "0ab37a888267f44eed1c158dc69f0ff1d3a3d038", "filename": "src/test/compile-fail/issue-14092.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Fcompile-fail%2Fissue-14092.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Fcompile-fail%2Fissue-14092.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-14092.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn fn1(0: Box) {} //~ ERROR: not enough type parameters supplied to `Box<T>`\n+fn fn1(0: Box) {} //~ ERROR: wrong number of type arguments: expected 1, found 0\n \n fn main() {}\n "}, {"sha": "63b110b5579344901453bcbbbc00bf6b1e182c8d", "filename": "src/test/compile-fail/issue-18423.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Fcompile-fail%2Fissue-18423.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Fcompile-fail%2Fissue-18423.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-18423.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that `Box` cannot be used with a lifetime parameter.\n+\n+struct Foo<'a> {\n+    x: Box<'a, int> //~ ERROR wrong number of lifetime parameters\n+}\n+\n+pub fn main() {\n+}"}, {"sha": "3ba8dd4fefef0109ac6682c5823343a6a8ae9036", "filename": "src/test/compile-fail/issue-2718-a.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Fcompile-fail%2Fissue-2718-a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Fcompile-fail%2Fissue-2718-a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2718-a.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -8,18 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-test\n-\n pub struct send_packet<T> {\n-  p: T\n+    p: T\n }\n \n-\n mod pingpong {\n     use send_packet;\n     pub type ping = send_packet<pong>;\n     pub struct pong(send_packet<ping>);\n-    //~^ ERROR illegal recursive enum type; wrap the inner value in a box to make it representable\n+    //~^ ERROR illegal recursive struct type; wrap the inner value in a box to make it representable\n }\n \n fn main() {}"}, {"sha": "2074d007502304706a2e1ecd0cb064afbdd3e2e0", "filename": "src/test/compile-fail/lint-stability.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Fcompile-fail%2Flint-stability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Fcompile-fail%2Flint-stability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-stability.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -141,6 +141,12 @@ mod cross_crate {\n         foo.trait_unmarked(); //~ ERROR use of unmarked item\n         foo.trait_stable();\n     }\n+\n+    struct S;\n+\n+    impl ExperimentalTrait for S { } //~ ERROR use of experimental item\n+\n+    trait LocalTrait : ExperimentalTrait { } //~ ERROR use of experimental item\n }\n \n mod inheritance {\n@@ -444,6 +450,15 @@ mod this_crate {\n         foo.trait_unmarked();\n         foo.trait_stable();\n     }\n+\n+    #[deprecated]\n+    pub trait DeprecatedTrait {}\n+\n+    struct S;\n+\n+    impl DeprecatedTrait for S { } //~ ERROR use of deprecated item\n+\n+    trait LocalTrait : DeprecatedTrait { } //~ ERROR use of deprecated item\n }\n \n fn main() {}"}, {"sha": "9866a20004527f0520063f680bab36af044057f7", "filename": "src/test/compile-fail/unboxed-closure-sugar-default.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-default.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test interaction between unboxed closure sugar and default type\n+// parameters (should be exactly as if angle brackets were used).\n+\n+#![feature(default_type_params)]\n+#![allow(dead_code)]\n+\n+struct Foo<T,U,V=T> {\n+    t: T, u: U\n+}\n+\n+trait Eq<X> { }\n+impl<X> Eq<X> for X { }\n+fn eq<A,B:Eq<A>>() { }\n+\n+fn test<'a,'b>() {\n+    // Parens are equivalent to omitting default in angle.\n+    eq::< Foo<(int,),()>,               Foo(int)                      >();\n+\n+    // In angle version, we supply something other than the default\n+    eq::< Foo<(int,),(),int>,           Foo(int)                      >();\n+    //~^ ERROR not implemented\n+\n+    // Supply default explicitly.\n+    eq::< Foo<(int,),(),(int,)>,        Foo(int)                      >();\n+}\n+\n+fn main() { }"}, {"sha": "c38010c1ee260a9bb5fcd610bf63d1dd2edc89b9", "filename": "src/test/compile-fail/unboxed-closure-sugar-equiv.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-equiv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-equiv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-equiv.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that the unboxed closure sugar can be used with an arbitrary\n+// struct type and that it is equivalent to the same syntax using\n+// angle brackets. This test covers only simple types and in\n+// particular doesn't test bound regions.\n+\n+#![allow(dead_code)]\n+\n+struct Foo<T,U> {\n+    t: T, u: U\n+}\n+\n+trait Eq<X> { }\n+impl<X> Eq<X> for X { }\n+fn eq<A,B:Eq<A>>() { }\n+\n+fn test<'a,'b>() {\n+    // No errors expected:\n+    eq::< Foo<(),()>,                   Foo()                         >();\n+    eq::< Foo<(int,),()>,               Foo(int)                      >();\n+    eq::< Foo<(int,uint),()>,           Foo(int,uint)                 >();\n+    eq::< Foo<(int,uint),uint>,         Foo(int,uint) -> uint         >();\n+    eq::< Foo<(&'a int,&'b uint),uint>, Foo(&'a int,&'b uint) -> uint >();\n+\n+    // Errors expected:\n+    eq::< Foo<(),()>,                   Foo(char)                     >();\n+    //~^ ERROR not implemented\n+}\n+\n+fn main() { }"}, {"sha": "d89c3802508c593c653330580acb96d7635ee745", "filename": "src/test/compile-fail/unboxed-closure-sugar-nonexistent-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-nonexistent-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-nonexistent-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-nonexistent-trait.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn f<F:Nonexist(int) -> int>(x: F) {} //~ ERROR unresolved trait\n+fn f<F:Nonexist(int) -> int>(x: F) {} //~ ERROR nonexistent trait `Nonexist`\n \n type Typedef = int;\n "}, {"sha": "962e233dea696651ee56bb33753ffc3d02db6423", "filename": "src/test/compile-fail/unboxed-closure-sugar-region.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-region.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -0,0 +1,45 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test interaction between unboxed closure sugar and region\n+// parameters (should be exactly as if angle brackets were used\n+// and regions omitted).\n+\n+#![feature(default_type_params)]\n+#![allow(dead_code)]\n+\n+use std::kinds::marker;\n+\n+struct Foo<'a,T,U> {\n+    t: T,\n+    u: U,\n+    m: marker::InvariantLifetime<'a>\n+}\n+\n+trait Eq<X> { }\n+impl<X> Eq<X> for X { }\n+fn eq<A,B:Eq<A>>() { }\n+fn same_type<A,B:Eq<A>>(a: A, b: B) { }\n+\n+fn test<'a,'b>() {\n+    // Parens are equivalent to omitting default in angle.\n+    eq::< Foo<(int,),()>,               Foo(int)                      >();\n+\n+    // Here we specify 'static explicitly in angle-bracket version.\n+    // Parenthesized winds up getting inferred.\n+    eq::< Foo<'static, (int,),()>,               Foo(int)                      >();\n+}\n+\n+fn test2(x: Foo<(int,),()>, y: Foo(int)) {\n+    // Here, the omitted lifetimes are expanded to distinct things.\n+    same_type(x, y) //~ ERROR cannot infer\n+}\n+\n+fn main() { }"}, {"sha": "e122b87b1e0f04c9b4094d6a764ecb7434b1a9ca", "filename": "src/test/compile-fail/unboxed-closure-sugar-wrong-number-number-type-parameters-1.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-wrong-number-number-type-parameters-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-wrong-number-number-type-parameters-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-wrong-number-number-type-parameters-1.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct One<A>;\n+\n+fn foo(_: One()) //~ ERROR wrong number of type arguments\n+{}\n+\n+fn main() { }"}, {"sha": "7a66abb39df58e1e01da72422c651e1ba6c86291", "filename": "src/test/compile-fail/unboxed-closure-sugar-wrong-number-number-type-parameters-3.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-wrong-number-number-type-parameters-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-wrong-number-number-type-parameters-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-wrong-number-number-type-parameters-3.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Three<A,B,C>;\n+\n+fn foo(_: Three()) //~ ERROR wrong number of type arguments\n+{}\n+\n+fn main() { }"}, {"sha": "e265a3d56b871cc56af5f340fbe1b9c7b10d8b62", "filename": "src/test/compile-fail/unboxed-closure-sugar-wrong-number-number-type-parameters.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-wrong-number-number-type-parameters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-wrong-number-number-type-parameters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-wrong-number-number-type-parameters.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Zero;\n+\n+fn foo(_: Zero()) //~ ERROR wrong number of type arguments\n+{}\n+\n+fn main() { }"}, {"sha": "1394f8fa65fccb9cd0d07f08b4a0de2dd824d89b", "filename": "src/test/compile-fail/unboxed-closure-sugar-wrong-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-wrong-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-wrong-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-wrong-trait.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -11,7 +11,7 @@\n trait Trait {}\n \n fn f<F:Trait(int) -> int>(x: F) {}\n-//~^ ERROR unboxed function trait must be one of `Fn`, `FnMut`, or `FnOnce`\n+//~^ ERROR wrong number of type arguments: expected 0, found 2\n \n fn main() {}\n "}, {"sha": "0b82a0d8d837816848902c00fc000e45bba58708", "filename": "src/test/run-fail/issue-18576.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Frun-fail%2Fissue-18576.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Frun-fail%2Fissue-18576.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fissue-18576.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// error-pattern:stop\n+\n+// #18576\n+// Make sure that an calling extern function pointer in an unreachable\n+// context doesn't cause an LLVM assertion\n+\n+#[allow(unreachable_code)]\n+fn main() {\n+    panic!(\"stop\");\n+    let pointer = other;\n+    pointer();\n+}\n+extern fn other() {}"}, {"sha": "a352bc3a8cceb2885e6658d1d44c97431db0c221", "filename": "src/test/run-make/target-specs/Makefile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Frun-make%2Ftarget-specs%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Frun-make%2Ftarget-specs%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Ftarget-specs%2FMakefile?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -2,7 +2,7 @@\n all:\n \t$(RUSTC) foo.rs --target=my-awesome-platform.json --crate-type=lib --emit=asm\n \tgrep --quiet --invert-match morestack < $(TMPDIR)/foo.s\n-\t$(RUSTC) foo.rs --target=my-invalid-platform.json 2>&1 | grep --quiet --invert-match \"Error loading taget specification\"\n+\t$(RUSTC) foo.rs --target=my-invalid-platform.json 2>&1 | grep --quiet \"Error loading target specification\"\n \t$(RUSTC) foo.rs --target=my-incomplete-platform.json 2>&1 | grep 'Field llvm-target'\n \tRUST_TARGET_PATH=. $(RUSTC) foo.rs --target=my-awesome-platform --crate-type=lib --emit=asm\n \tRUST_TARGET_PATH=. $(RUSTC) foo.rs --target=x86_64-unknown-linux-gnu --crate-type=lib --emit=asm"}, {"sha": "5e0f0f40e67bc8e1c95dc939d5a01d4980f4ed07", "filename": "src/test/run-make/target-specs/x86_64-unknown-linux-gnu.json", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Frun-make%2Ftarget-specs%2Fx86_64-unknown-linux-gnu.json", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Frun-make%2Ftarget-specs%2Fx86_64-unknown-linux-gnu.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Ftarget-specs%2Fx86_64-unknown-linux-gnu.json?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -1,9 +1,10 @@\n {\n-    \"data-layout\": \"e-p:32:32-f64:32:64-i64:32:64-f80:32:32-n8:16:32\",\n-    \"llvm-target\": \"i686-unknown-linux-gnu\",\n+    \"pre-link-args\": [\"-m64\"],\n+    \"data-layout\": \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64-S128\",\n+    \"llvm-target\": \"x86_64-unknown-linux-gnu\",\n     \"target-endian\": \"little\",\n-    \"target-word-size\": \"32\",\n-    \"arch\": \"x86\",\n+    \"target-word-size\": \"64\",\n+    \"arch\": \"x86_64\",\n     \"os\": \"linux\",\n     \"morestack\": false\n }"}, {"sha": "aeef55fbbacd86f4f8b51bd8eb425e0db517df4f", "filename": "src/test/run-pass/deriving-default-box.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Frun-pass%2Fderiving-default-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Frun-pass%2Fderiving-default-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-default-box.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::default::Default;\n+\n+#[deriving(Default)]\n+struct A {\n+    foo: Box<[bool]>,\n+}\n+\n+pub fn main() {\n+    let a: A = Default::default();\n+    let b: Box<[_]> = box [];\n+    assert_eq!(a.foo, b);\n+}"}, {"sha": "e21f64cd74c80bc1bd04b00b4226098f5585ad64", "filename": "src/test/run-pass/deriving-encodable-decodable-box.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Frun-pass%2Fderiving-encodable-decodable-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Frun-pass%2Fderiving-encodable-decodable-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-encodable-decodable-box.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+extern crate serialize;\n+\n+use serialize::{Encodable, Decodable};\n+use serialize::json;\n+\n+#[deriving(Encodable, Decodable)]\n+struct A {\n+    foo: Box<[bool]>,\n+}\n+\n+fn main() {\n+    let obj = A { foo: box [true, false] };\n+    let s = json::encode(&obj);\n+    let obj2: A = json::decode(s.as_slice()).unwrap();\n+    assert!(obj.foo == obj2.foo);\n+}"}, {"sha": "2a54f22ee665b44f843e7deee0c12805c296c5e1", "filename": "src/test/run-pass/foreach-nested.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Frun-pass%2Fforeach-nested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Frun-pass%2Fforeach-nested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeach-nested.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -15,7 +15,7 @@ pub fn main() {\n     let mut a: Vec<int> = vec!(-1, -1, -1, -1);\n     let mut p: int = 0;\n     two(|i| {\n-        two(|j| { *a.get_mut(p as uint) = 10 * i + j; p += 1; })\n+        two(|j| { a[p as uint] = 10 * i + j; p += 1; })\n     });\n     assert_eq!(a[0], 0);\n     assert_eq!(a[1], 1);"}, {"sha": "4a6a6782fb3db5191acce2ffd91cb00249fc60ad", "filename": "src/test/run-pass/hashmap-memory.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -83,7 +83,7 @@ mod map_reduce {\n               mapper_done => { num_mappers -= 1; }\n               find_reducer(k, cc) => {\n                 let mut c;\n-                match reducers.find(&str::from_utf8(\n+                match reducers.get(&str::from_utf8(\n                         k.as_slice()).unwrap().to_string()) {\n                   Some(&_c) => { c = _c; }\n                   None => { c = 0; }"}, {"sha": "ce04f188e341fbe85308da222e9bc4c3df9365ab", "filename": "src/test/run-pass/issue-10396.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Frun-pass%2Fissue-10396.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Frun-pass%2Fissue-10396.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-10396.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[deriving(Show)]\n+enum Foo<'s> {\n+    V(&'s str)\n+}\n+\n+fn f(arr: &[&Foo]) {\n+    for &f in arr.iter() {\n+        println!(\"{}\", f);\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "78f125398edcba56abd35835abeb38107e8e1e70", "filename": "src/test/run-pass/issue-10501.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Frun-pass%2Fissue-10501.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Frun-pass%2Fissue-10501.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-10501.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub type Foo = fn(&int) -> ();\n+#[deriving(Clone)]\n+enum Baz { Bar(Foo) }\n+fn main() {}"}, {"sha": "e41613b4ae3057d4e7f8ad81ecf4b4ce96ca7853", "filename": "src/test/run-pass/issue-12741.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Frun-pass%2Fissue-12741.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Frun-pass%2Fissue-12741.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-12741.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[deriving(Clone)]\n+pub struct Foo {\n+    f: fn(char, |char| -> char) -> char\n+}\n+\n+impl Foo {\n+    fn bar(&self) -> char {\n+        ((*self).f)('a', |c: char| c)\n+    }\n+}\n+\n+fn bla(c: char, cb: |char| -> char) -> char {\n+    cb(c)\n+}\n+\n+pub fn make_foo() -> Foo {\n+    Foo {\n+        f: bla\n+    }\n+}\n+\n+fn main() {\n+    let a = make_foo();\n+    assert_eq!(a.bar(), 'a');\n+}"}, {"sha": "0b7eb41d2aac1b3e4b18ffbf74ea0c09f4aced1e", "filename": "src/test/run-pass/issue-15063.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Frun-pass%2Fissue-15063.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Frun-pass%2Fissue-15063.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-15063.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+enum Two { A, B}\n+impl Drop for Two {\n+    fn drop(&mut self) {\n+        println!(\"Dropping!\");\n+    }\n+}\n+fn main() {\n+    let k = A;\n+}"}, {"sha": "ea5bd550d53da5fa9027f6a4be67f1abd487f169", "filename": "src/test/run-pass/issue-15734.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Frun-pass%2Fissue-15734.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Frun-pass%2Fissue-15734.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-15734.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -0,0 +1,56 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Mat<T> { data: Vec<T>, cols: uint, }\n+\n+impl<T> Mat<T> {\n+    fn new(data: Vec<T>, cols: uint) -> Mat<T> {\n+        Mat { data: data, cols: cols }\n+    }\n+    fn row<'a>(&'a self, row: uint) -> Row<&'a Mat<T>> {\n+        Row { mat: self, row: row, }\n+    }\n+}\n+\n+impl<T> Index<(uint, uint), T> for Mat<T> {\n+    fn index<'a>(&'a self, &(row, col): &(uint, uint)) -> &'a T {\n+        &self.data[row * self.cols + col]\n+    }\n+}\n+\n+impl<'a, T> Index<(uint, uint), T> for &'a Mat<T> {\n+    fn index<'b>(&'b self, index: &(uint, uint)) -> &'b T {\n+        (*self).index(index)\n+    }\n+}\n+\n+struct Row<M> { mat: M, row: uint, }\n+\n+impl<T, M: Index<(uint, uint), T>> Index<uint, T> for Row<M> {\n+    fn index<'a>(&'a self, col: &uint) -> &'a T {\n+        &self.mat[(self.row, *col)]\n+    }\n+}\n+\n+fn main() {\n+    let m = Mat::new(vec!(1u, 2, 3, 4, 5, 6), 3);\n+    let r = m.row(1);\n+\n+    assert!(r.index(&2) == &6);\n+    assert!(r[2] == 6);\n+    assert!(r[2u] == 6u);\n+    assert!(6 == r[2]);\n+\n+    let e = r[2];\n+    assert!(e == 6);\n+\n+    let e: uint = r[2];\n+    assert!(e == 6);\n+}"}, {"sha": "f996f9309c135b0537d1c8b9e8c8aa8c5ab00793", "filename": "src/test/run-pass/issue-16774.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Frun-pass%2Fissue-16774.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Frun-pass%2Fissue-16774.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-16774.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -0,0 +1,50 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(overloaded_calls, unboxed_closures)]\n+\n+struct X(Box<int>);\n+\n+static mut DESTRUCTOR_RAN: bool = false;\n+\n+impl Drop for X {\n+    fn drop(&mut self) {\n+        unsafe {\n+            assert!(!DESTRUCTOR_RAN);\n+            DESTRUCTOR_RAN = true;\n+        }\n+    }\n+}\n+\n+impl Deref<int> for X {\n+    fn deref(&self) -> &int {\n+        let &X(box ref x) = self;\n+        x\n+    }\n+}\n+\n+impl DerefMut<int> for X {\n+    fn deref_mut(&mut self) -> &mut int {\n+        let &X(box ref mut x) = self;\n+        x\n+    }\n+}\n+\n+fn main() {\n+    {\n+        let mut test = X(box 5i);\n+        {\n+            let mut change = |&mut:| { *test = 10 };\n+            change();\n+        }\n+        assert_eq!(*test, 10);\n+    }\n+    assert!(unsafe { DESTRUCTOR_RAN });\n+}"}, {"sha": "3d6b23c8805fc4e96814096db3dbc64595cf0e90", "filename": "src/test/run-pass/issue-18110.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Frun-pass%2Fissue-18110.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Frun-pass%2Fissue-18110.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-18110.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    ({return},);\n+}"}, {"sha": "c734c1a322245c0e516179f1465bfe24ce9be83e", "filename": "src/test/run-pass/issue-18353.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Frun-pass%2Fissue-18353.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Frun-pass%2Fissue-18353.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-18353.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that wrapping an unsized struct in an enum which gets optimised does\n+// not ICE.\n+\n+struct Str {\n+    f: [u8]\n+}\n+\n+fn main() {\n+    let str: Option<&Str> = None;\n+    str.is_some();\n+}"}, {"sha": "70ccc20e01a16468161ad63f1031dbd0c90f1108", "filename": "src/test/run-pass/issue-18619.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Frun-pass%2Fissue-18619.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Frun-pass%2Fissue-18619.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-18619.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::io::FileType;\n+\n+pub fn main() {\n+    let _ = FileType::TypeFile.clone();\n+}"}, {"sha": "4e330b9a0e7dd98ec2b0e76f49dd001993a7b778", "filename": "src/test/run-pass/issue-3563-3.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Frun-pass%2Fissue-3563-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Frun-pass%2Fissue-3563-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3563-3.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -86,8 +86,8 @@ impl AsciiArt {\n                 // element is:\n                 // 1) potentially large\n                 // 2) needs to be modified\n-                let row = self.lines.get_mut(v);\n-                *row.get_mut(h) = self.fill;\n+                let row = &mut self.lines[v];\n+                row[h] = self.fill;\n             }\n         }\n     }"}, {"sha": "37144fb9cce771f62332a09f96cf1a00b672f614", "filename": "src/test/run-pass/issue-3991.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Frun-pass%2Fissue-3991.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Frun-pass%2Fissue-3991.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3991.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -15,7 +15,7 @@ struct HasNested {\n \n impl HasNested {\n     fn method_push_local(&mut self) {\n-        self.nest.get_mut(0).push(0);\n+        self.nest[0].push(0);\n     }\n }\n "}, {"sha": "8aa95927312301e173692511acf7643277cd7fb2", "filename": "src/test/run-pass/issue-7268.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Frun-pass%2Fissue-7268.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Frun-pass%2Fissue-7268.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-7268.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn foo<T: 'static>(_: T) {}\n+\n+fn bar<T>(x: &'static T) {\n+    foo(x);\n+}\n+fn main() {}"}, {"sha": "061f7025527567e24beba0554b5d97dd9761ba8f", "filename": "src/test/run-pass/lint-non-camel-case-types-non-uppercase-statics-unicode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Frun-pass%2Flint-non-camel-case-types-non-uppercase-statics-unicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Frun-pass%2Flint-non-camel-case-types-non-uppercase-statics-unicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flint-non-camel-case-types-non-uppercase-statics-unicode.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -12,7 +12,7 @@\n \n \n #![forbid(non_camel_case_types)]\n-#![forbid(non_uppercase_statics)]\n+#![forbid(non_upper_case_globals)]\n #![feature(non_ascii_idents)]\n \n // Some scripts (e.g. hiragana) don't have a concept of"}, {"sha": "ce3518618d0b475b4b4ca552c74a98df48a98d30", "filename": "src/test/run-pass/lint-non-uppercase-statics-lowercase-mut-statics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Frun-pass%2Flint-non-uppercase-statics-lowercase-mut-statics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Frun-pass%2Flint-non-uppercase-statics-lowercase-mut-statics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flint-non-uppercase-statics-lowercase-mut-statics.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -10,7 +10,7 @@\n \n \n #![forbid(non_camel_case_types)]\n-#![forbid(non_uppercase_statics)]\n+#![forbid(non_upper_case_globals)]\n \n static mut bar: int = 2;\n "}, {"sha": "164cc99e188eaa8cb8fd1d7fd3e0e7555f619843", "filename": "src/test/run-pass/match-static-const-rename.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Frun-pass%2Fmatch-static-const-rename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Frun-pass%2Fmatch-static-const-rename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmatch-static-const-rename.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -16,7 +16,7 @@\n // around this problem locally by renaming the constant in the `use`\n // form to an uppercase identifier that placates the lint.\n \n-#![deny(non_uppercase_statics)]\n+#![deny(non_upper_case_globals)]\n \n pub const A : int = 97;\n \n@@ -34,7 +34,7 @@ fn f() {\n }\n \n mod m {\n-    #[allow(non_uppercase_statics)]\n+    #[allow(non_upper_case_globals)]\n     pub const aha : int = 7;\n }\n "}, {"sha": "ca820830f023f65a1aada2c29f6b96a857d0abc1", "filename": "src/test/run-pass/overloaded-deref.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Frun-pass%2Foverloaded-deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Frun-pass%2Foverloaded-deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverloaded-deref.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -44,8 +44,8 @@ pub fn main() {\n     assert_eq!(*(*p).borrow(), Point {x: 3, y: 5});\n \n     let v = Rc::new(RefCell::new(vec!(1i, 2, 3)));\n-    *(*(*v).borrow_mut()).get_mut(0) = 3;\n-    *(*(*v).borrow_mut()).get_mut(1) += 3;\n+    (*(*v).borrow_mut())[0] = 3;\n+    (*(*v).borrow_mut())[1] += 3;\n     assert_eq!(((*(*v).borrow())[0],\n                 (*(*v).borrow())[1],\n                 (*(*v).borrow())[2]), (3, 5, 3));"}, {"sha": "55003a07b5bbe1a86eecfbcb7b4a64a5bcc3bc15", "filename": "src/test/run-pass/send_str_hashmap.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Frun-pass%2Fsend_str_hashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Frun-pass%2Fsend_str_hashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsend_str_hashmap.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -16,37 +16,37 @@ use std::option::Some;\n \n pub fn main() {\n     let mut map: HashMap<SendStr, uint> = HashMap::new();\n-    assert!(map.insert(Slice(\"foo\"), 42));\n-    assert!(!map.insert(Owned(\"foo\".to_string()), 42));\n-    assert!(!map.insert(Slice(\"foo\"), 42));\n-    assert!(!map.insert(Owned(\"foo\".to_string()), 42));\n+    assert!(map.insert(Slice(\"foo\"), 42).is_none());\n+    assert!(map.insert(Owned(\"foo\".to_string()), 42).is_some());\n+    assert!(map.insert(Slice(\"foo\"), 42).is_some());\n+    assert!(map.insert(Owned(\"foo\".to_string()), 42).is_some());\n \n-    assert!(!map.insert(Slice(\"foo\"), 43));\n-    assert!(!map.insert(Owned(\"foo\".to_string()), 44));\n-    assert!(!map.insert(Slice(\"foo\"), 45));\n-    assert!(!map.insert(Owned(\"foo\".to_string()), 46));\n+    assert!(map.insert(Slice(\"foo\"), 43).is_some());\n+    assert!(map.insert(Owned(\"foo\".to_string()), 44).is_some());\n+    assert!(map.insert(Slice(\"foo\"), 45).is_some());\n+    assert!(map.insert(Owned(\"foo\".to_string()), 46).is_some());\n \n     let v = 46;\n \n-    assert_eq!(map.find(&Owned(\"foo\".to_string())), Some(&v));\n-    assert_eq!(map.find(&Slice(\"foo\")), Some(&v));\n+    assert_eq!(map.get(&Owned(\"foo\".to_string())), Some(&v));\n+    assert_eq!(map.get(&Slice(\"foo\")), Some(&v));\n \n     let (a, b, c, d) = (50, 51, 52, 53);\n \n-    assert!(map.insert(Slice(\"abc\"), a));\n-    assert!(map.insert(Owned(\"bcd\".to_string()), b));\n-    assert!(map.insert(Slice(\"cde\"), c));\n-    assert!(map.insert(Owned(\"def\".to_string()), d));\n+    assert!(map.insert(Slice(\"abc\"), a).is_none());\n+    assert!(map.insert(Owned(\"bcd\".to_string()), b).is_none());\n+    assert!(map.insert(Slice(\"cde\"), c).is_none());\n+    assert!(map.insert(Owned(\"def\".to_string()), d).is_none());\n \n-    assert!(!map.insert(Slice(\"abc\"), a));\n-    assert!(!map.insert(Owned(\"bcd\".to_string()), b));\n-    assert!(!map.insert(Slice(\"cde\"), c));\n-    assert!(!map.insert(Owned(\"def\".to_string()), d));\n+    assert!(map.insert(Slice(\"abc\"), a).is_some());\n+    assert!(map.insert(Owned(\"bcd\".to_string()), b).is_some());\n+    assert!(map.insert(Slice(\"cde\"), c).is_some());\n+    assert!(map.insert(Owned(\"def\".to_string()), d).is_some());\n \n-    assert!(!map.insert(Owned(\"abc\".to_string()), a));\n-    assert!(!map.insert(Slice(\"bcd\"), b));\n-    assert!(!map.insert(Owned(\"cde\".to_string()), c));\n-    assert!(!map.insert(Slice(\"def\"), d));\n+    assert!(map.insert(Owned(\"abc\".to_string()), a).is_some());\n+    assert!(map.insert(Slice(\"bcd\"), b).is_some());\n+    assert!(map.insert(Owned(\"cde\".to_string()), c).is_some());\n+    assert!(map.insert(Slice(\"def\"), d).is_some());\n \n     assert_eq!(map.find_equiv(\"abc\"), Some(&a));\n     assert_eq!(map.find_equiv(\"bcd\"), Some(&b));"}, {"sha": "c52f9458f99d5fb9ced11707b0b23b4239bfc880", "filename": "src/test/run-pass/send_str_treemap.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Frun-pass%2Fsend_str_treemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Frun-pass%2Fsend_str_treemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsend_str_treemap.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -17,49 +17,49 @@ use std::option::Some;\n \n pub fn main() {\n     let mut map: TreeMap<SendStr, uint> = TreeMap::new();\n-    assert!(map.insert(Slice(\"foo\"), 42));\n-    assert!(!map.insert(Owned(\"foo\".to_string()), 42));\n-    assert!(!map.insert(Slice(\"foo\"), 42));\n-    assert!(!map.insert(Owned(\"foo\".to_string()), 42));\n+    assert!(map.insert(Slice(\"foo\"), 42).is_none());\n+    assert!(map.insert(Owned(\"foo\".to_string()), 42).is_some());\n+    assert!(map.insert(Slice(\"foo\"), 42).is_some());\n+    assert!(map.insert(Owned(\"foo\".to_string()), 42).is_some());\n \n-    assert!(!map.insert(Slice(\"foo\"), 43));\n-    assert!(!map.insert(Owned(\"foo\".to_string()), 44));\n-    assert!(!map.insert(Slice(\"foo\"), 45));\n-    assert!(!map.insert(Owned(\"foo\".to_string()), 46));\n+    assert!(map.insert(Slice(\"foo\"), 43).is_some());\n+    assert!(map.insert(Owned(\"foo\".to_string()), 44).is_some());\n+    assert!(map.insert(Slice(\"foo\"), 45).is_some());\n+    assert!(map.insert(Owned(\"foo\".to_string()), 46).is_some());\n \n     let v = 46;\n \n-    assert_eq!(map.find(&Owned(\"foo\".to_string())), Some(&v));\n-    assert_eq!(map.find(&Slice(\"foo\")), Some(&v));\n+    assert_eq!(map.get(&Owned(\"foo\".to_string())), Some(&v));\n+    assert_eq!(map.get(&Slice(\"foo\")), Some(&v));\n \n     let (a, b, c, d) = (50, 51, 52, 53);\n \n-    assert!(map.insert(Slice(\"abc\"), a));\n-    assert!(map.insert(Owned(\"bcd\".to_string()), b));\n-    assert!(map.insert(Slice(\"cde\"), c));\n-    assert!(map.insert(Owned(\"def\".to_string()), d));\n+    assert!(map.insert(Slice(\"abc\"), a).is_none());\n+    assert!(map.insert(Owned(\"bcd\".to_string()), b).is_none());\n+    assert!(map.insert(Slice(\"cde\"), c).is_none());\n+    assert!(map.insert(Owned(\"def\".to_string()), d).is_none());\n \n-    assert!(!map.insert(Slice(\"abc\"), a));\n-    assert!(!map.insert(Owned(\"bcd\".to_string()), b));\n-    assert!(!map.insert(Slice(\"cde\"), c));\n-    assert!(!map.insert(Owned(\"def\".to_string()), d));\n+    assert!(map.insert(Slice(\"abc\"), a).is_some());\n+    assert!(map.insert(Owned(\"bcd\".to_string()), b).is_some());\n+    assert!(map.insert(Slice(\"cde\"), c).is_some());\n+    assert!(map.insert(Owned(\"def\".to_string()), d).is_some());\n \n-    assert!(!map.insert(Owned(\"abc\".to_string()), a));\n-    assert!(!map.insert(Slice(\"bcd\"), b));\n-    assert!(!map.insert(Owned(\"cde\".to_string()), c));\n-    assert!(!map.insert(Slice(\"def\"), d));\n+    assert!(map.insert(Owned(\"abc\".to_string()), a).is_some());\n+    assert!(map.insert(Slice(\"bcd\"), b).is_some());\n+    assert!(map.insert(Owned(\"cde\".to_string()), c).is_some());\n+    assert!(map.insert(Slice(\"def\"), d).is_some());\n \n-    assert_eq!(map.find(&Slice(\"abc\")), Some(&a));\n-    assert_eq!(map.find(&Slice(\"bcd\")), Some(&b));\n-    assert_eq!(map.find(&Slice(\"cde\")), Some(&c));\n-    assert_eq!(map.find(&Slice(\"def\")), Some(&d));\n+    assert_eq!(map.get(&Slice(\"abc\")), Some(&a));\n+    assert_eq!(map.get(&Slice(\"bcd\")), Some(&b));\n+    assert_eq!(map.get(&Slice(\"cde\")), Some(&c));\n+    assert_eq!(map.get(&Slice(\"def\")), Some(&d));\n \n-    assert_eq!(map.find(&Owned(\"abc\".to_string())), Some(&a));\n-    assert_eq!(map.find(&Owned(\"bcd\".to_string())), Some(&b));\n-    assert_eq!(map.find(&Owned(\"cde\".to_string())), Some(&c));\n-    assert_eq!(map.find(&Owned(\"def\".to_string())), Some(&d));\n+    assert_eq!(map.get(&Owned(\"abc\".to_string())), Some(&a));\n+    assert_eq!(map.get(&Owned(\"bcd\".to_string())), Some(&b));\n+    assert_eq!(map.get(&Owned(\"cde\".to_string())), Some(&c));\n+    assert_eq!(map.get(&Owned(\"def\".to_string())), Some(&d));\n \n-    assert!(map.pop(&Slice(\"foo\")).is_some());\n+    assert!(map.remove(&Slice(\"foo\")).is_some());\n     assert_eq!(map.into_iter().map(|(k, v)| format!(\"{}{}\", k, v))\n                               .collect::<Vec<String>>()\n                               .concat(),"}, {"sha": "3c0f9505736a962a0bda461dec549b2b121d65f1", "filename": "src/test/run-pass/swap-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Frun-pass%2Fswap-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Frun-pass%2Fswap-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fswap-2.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -16,7 +16,7 @@ pub fn main() {\n     assert_eq!(a[2], 4);\n     assert_eq!(a[4], 2);\n     let mut n = 42;\n-    swap(&mut n, a.get_mut(0));\n+    swap(&mut n, &mut a[0]);\n     assert_eq!(a[0], 42);\n     assert_eq!(n, 0);\n }"}, {"sha": "8f6cfe0499703ff7c7116c016bff80af6f060744", "filename": "src/test/run-pass/unboxed-closures-manual-impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Frun-pass%2Funboxed-closures-manual-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Frun-pass%2Funboxed-closures-manual-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-manual-impl.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -25,7 +25,7 @@ fn call_it<F:FnMut(int)->int>(mut f: F, x: int) -> int {\n     f.call_mut((x,)) + 3\n }\n \n-fn call_box(f: &mut |&mut: int|->int, x: int) -> int {\n+fn call_box(f: &mut FnMut(int) -> int, x: int) -> int {\n     f.call_mut((x,)) + 3\n }\n "}, {"sha": "f9d2ba02123c464775abab2ca5f52acd0a3b96fa", "filename": "src/test/run-pass/unboxed-closures-prelude.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Frun-pass%2Funboxed-closures-prelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Frun-pass%2Funboxed-closures-prelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-prelude.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -13,7 +13,7 @@\n #![feature(unboxed_closures, unboxed_closure_sugar)]\n \n fn main() {\n-    let task: Box<|: int| -> int> = box |: x| x;\n+    let task: Box<FnOnce(int) -> int> = box |: x| x;\n     task.call_once((0i, ));\n }\n "}, {"sha": "b358e7ce288339f26a6a727dadeb85ac4666d1ad", "filename": "src/test/run-pass/unboxed-closures-sugar-1.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Frun-pass%2Funboxed-closures-sugar-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Frun-pass%2Funboxed-closures-sugar-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-sugar-1.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that the unboxed closure sugar can be used with an arbitrary\n+// struct type and that it is equivalent to the same syntax using\n+// angle brackets. This test covers only simple types and in\n+// particular doesn't test bound regions.\n+\n+#![allow(dead_code)]\n+\n+struct Foo<T,U> {\n+    t: T, u: U\n+}\n+\n+trait Eq<X> { }\n+impl<X> Eq<X> for X { }\n+fn eq<A,B:Eq<A>>() { }\n+\n+fn test<'a,'b>() {\n+    eq::< Foo<(),()>,                   Foo()                         >();\n+    eq::< Foo<(int,),()>,               Foo(int)                      >();\n+    eq::< Foo<(int,uint),()>,           Foo(int,uint)                 >();\n+    eq::< Foo<(int,uint),uint>,         Foo(int,uint) -> uint         >();\n+    eq::< Foo<(&'a int,&'b uint),uint>, Foo(&'a int,&'b uint) -> uint >();\n+}\n+\n+fn main() { }"}, {"sha": "3b38f72432f179c32e9a5320b2396afb5c19f2e7", "filename": "src/test/run-pass/unboxed-closures-sugar-object.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Frun-pass%2Funboxed-closures-sugar-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Frun-pass%2Funboxed-closures-sugar-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-sugar-object.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test unboxed closure sugar used in object types.\n+\n+#![allow(dead_code)]\n+\n+struct Foo<T,U> {\n+    t: T, u: U\n+}\n+\n+trait Getter<A,R> {\n+    fn get(&self, arg: A) -> R;\n+}\n+\n+struct Identity;\n+impl<X> Getter<X,X> for Identity {\n+    fn get(&self, arg: X) -> X {\n+        arg\n+    }\n+}\n+\n+fn main() {\n+    let x: &Getter(int) -> (int,) = &Identity;\n+    let (y,) = x.get((22,));\n+    assert_eq!(y, 22);\n+}"}, {"sha": "426352cadd87fbcf05e312d65a439032a07c28dc", "filename": "src/test/run-pass/unboxed-closures-unboxing-shim.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Frun-pass%2Funboxed-closures-unboxing-shim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Frun-pass%2Funboxed-closures-unboxing-shim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-unboxing-shim.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -13,7 +13,7 @@\n use std::ops::FnOnce;\n \n fn main() {\n-    let task: Box<|: int| -> int> = box |: x| x;\n+    let task: Box<FnOnce(int) -> int> = box |: x| x;\n     assert!(task.call_once((1234i,)) == 1234i);\n }\n "}, {"sha": "577a8f1430b2f9021d7c1ab5776ad931fb3296b8", "filename": "src/test/run-pass/unique-in-vec-copy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Frun-pass%2Funique-in-vec-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45cbdec4174778bf915f17561ef971c068a7fcbc/src%2Ftest%2Frun-pass%2Funique-in-vec-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funique-in-vec-copy.rs?ref=45cbdec4174778bf915f17561ef971c068a7fcbc", "patch": "@@ -17,7 +17,7 @@ pub fn main() {\n     assert_eq!(*b[0], 10);\n \n     // This should only modify the value in a, not b\n-    **a.get_mut(0) = 20;\n+    *a[0] = 20;\n \n     assert_eq!(*a[0], 20);\n     assert_eq!(*b[0], 10);"}]}