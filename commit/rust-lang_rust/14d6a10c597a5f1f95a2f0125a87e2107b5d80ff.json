{"sha": "14d6a10c597a5f1f95a2f0125a87e2107b5d80ff", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE0ZDZhMTBjNTk3YTVmMWY5NWEyZjAxMjVhODdlMjEwN2I1ZDgwZmY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-05-22T00:27:29Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-05-22T00:27:29Z"}, "message": "Auto merge of #33752 - mrhota:internal_docs, r=steveklabnik\n\nInternal docs\n\nThis PR is a rebase of #30621. That PR can be closed.\n\nCC @ticki @Aatch @cyplo", "tree": {"sha": "4c8931ef97b8c66628d56f1752e9ee5d1a2155b2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4c8931ef97b8c66628d56f1752e9ee5d1a2155b2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/14d6a10c597a5f1f95a2f0125a87e2107b5d80ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/14d6a10c597a5f1f95a2f0125a87e2107b5d80ff", "html_url": "https://github.com/rust-lang/rust/commit/14d6a10c597a5f1f95a2f0125a87e2107b5d80ff", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/14d6a10c597a5f1f95a2f0125a87e2107b5d80ff/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "476fe6eefe17db91ff7a60aab34aa67a0a750a18", "url": "https://api.github.com/repos/rust-lang/rust/commits/476fe6eefe17db91ff7a60aab34aa67a0a750a18", "html_url": "https://github.com/rust-lang/rust/commit/476fe6eefe17db91ff7a60aab34aa67a0a750a18"}, {"sha": "da55fd788bb492801bfaba8e5260ef09c0c4812e", "url": "https://api.github.com/repos/rust-lang/rust/commits/da55fd788bb492801bfaba8e5260ef09c0c4812e", "html_url": "https://github.com/rust-lang/rust/commit/da55fd788bb492801bfaba8e5260ef09c0c4812e"}], "stats": {"total": 83, "additions": 54, "deletions": 29}, "files": [{"sha": "bac96c68e4cf82eab0e72aa5970a78df9d19dcda", "filename": "src/librustc/hir/map/blocks.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/14d6a10c597a5f1f95a2f0125a87e2107b5d80ff/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14d6a10c597a5f1f95a2f0125a87e2107b5d80ff/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs?ref=14d6a10c597a5f1f95a2f0125a87e2107b5d80ff", "patch": "@@ -133,7 +133,13 @@ struct ClosureParts<'a> {\n \n impl<'a> ClosureParts<'a> {\n     fn new(d: &'a FnDecl, b: &'a Block, id: NodeId, s: Span, attrs: &'a [Attribute]) -> Self {\n-        ClosureParts { decl: d, body: b, id: id, span: s, attrs: attrs }\n+        ClosureParts {\n+            decl: d,\n+            body: b,\n+            id: id,\n+            span: s,\n+            attrs: attrs,\n+        }\n     }\n }\n "}, {"sha": "99e5f32e263f2544d4a02ba2569bef18483869ff", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/14d6a10c597a5f1f95a2f0125a87e2107b5d80ff/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14d6a10c597a5f1f95a2f0125a87e2107b5d80ff/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=14d6a10c597a5f1f95a2f0125a87e2107b5d80ff", "patch": "@@ -19,10 +19,13 @@ use std::iter::repeat;\n use syntax::ast::{NodeId, CRATE_NODE_ID};\n use syntax::codemap::Span;\n \n-/// A Visitor that walks over the HIR and collects Node's into a HIR map.\n+/// A Visitor that walks over the HIR and collects Nodes into a HIR map\n pub struct NodeCollector<'ast> {\n+    /// The crate\n     pub krate: &'ast Crate,\n+    /// The node map\n     pub map: Vec<MapEntry<'ast>>,\n+    /// The parent of this node\n     pub parent_node: NodeId,\n }\n "}, {"sha": "d66df3e4e8fd274a70a11c0ad65d5e242e493509", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 24, "deletions": 5, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/14d6a10c597a5f1f95a2f0125a87e2107b5d80ff/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14d6a10c597a5f1f95a2f0125a87e2107b5d80ff/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=14d6a10c597a5f1f95a2f0125a87e2107b5d80ff", "patch": "@@ -15,6 +15,7 @@ use syntax::ast;\n use syntax::parse::token::InternedString;\n use util::nodemap::NodeMap;\n \n+/// The definition table containing node definitions\n #[derive(Clone)]\n pub struct Definitions {\n     data: Vec<DefData>,\n@@ -139,31 +140,47 @@ pub struct InlinedRootPath {\n pub enum DefPathData {\n     // Root: these should only be used for the root nodes, because\n     // they are treated specially by the `def_path` function.\n+    /// The crate root (marker)\n     CrateRoot,\n+    /// An inlined root\n     InlinedRoot(Box<InlinedRootPath>),\n \n     // Catch-all for random DefId things like DUMMY_NODE_ID\n     Misc,\n \n     // Different kinds of items and item-like things:\n+    /// An impl\n     Impl,\n-    TypeNs(ast::Name), // something in the type NS\n-    ValueNs(ast::Name), // something in the value NS\n+    /// Something in the type NS\n+    TypeNs(ast::Name),\n+    /// Something in the value NS\n+    ValueNs(ast::Name),\n+    /// A module declaration\n     Module(ast::Name),\n+    /// A macro rule\n     MacroDef(ast::Name),\n+    /// A closure expression\n     ClosureExpr,\n \n     // Subportions of items\n+    /// A type parameter (generic parameter)\n     TypeParam(ast::Name),\n+    /// A lifetime definition\n     LifetimeDef(ast::Name),\n+    /// A variant of a enum\n     EnumVariant(ast::Name),\n+    /// A struct field\n     Field(ast::Name),\n-    StructCtor, // implicit ctor for a tuple-like struct\n-    Initializer, // initializer for a const\n-    Binding(ast::Name), // pattern binding\n+    /// Implicit ctor for a tuple-like struct\n+    StructCtor,\n+    /// Initializer for a const\n+    Initializer,\n+    /// Pattern binding\n+    Binding(ast::Name),\n }\n \n impl Definitions {\n+    /// Create new empty definition map.\n     pub fn new() -> Definitions {\n         Definitions {\n             data: vec![],\n@@ -172,6 +189,7 @@ impl Definitions {\n         }\n     }\n \n+    /// Get the number of definitions.\n     pub fn len(&self) -> usize {\n         self.data.len()\n     }\n@@ -214,6 +232,7 @@ impl Definitions {\n         }\n     }\n \n+    /// Add a definition with a parent definition.\n     pub fn create_def_with_parent(&mut self,\n                                   parent: Option<DefIndex>,\n                                   node_id: ast::NodeId,"}, {"sha": "97fb39c17ea0e58e77aec4bdca3a9ca5cefdd58f", "filename": "src/librustc_back/sha2.rs", "status": "modified", "additions": 19, "deletions": 22, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/14d6a10c597a5f1f95a2f0125a87e2107b5d80ff/src%2Flibrustc_back%2Fsha2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14d6a10c597a5f1f95a2f0125a87e2107b5d80ff/src%2Flibrustc_back%2Fsha2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsha2.rs?ref=14d6a10c597a5f1f95a2f0125a87e2107b5d80ff", "patch": "@@ -25,11 +25,10 @@ fn write_u32_be(dst: &mut[u8], input: u32) {\n \n /// Read the value of a vector of bytes as a u32 value in big-endian format.\n fn read_u32_be(input: &[u8]) -> u32 {\n-    return\n-        (input[0] as u32) << 24 |\n+    (input[0] as u32) << 24 |\n         (input[1] as u32) << 16 |\n         (input[2] as u32) << 8 |\n-        (input[3] as u32);\n+        (input[3] as u32)\n }\n \n /// Read a vector of bytes into a vector of u32s. The values are read in big-endian format.\n@@ -50,7 +49,7 @@ trait ToBits: Sized {\n \n impl ToBits for u64 {\n     fn to_bits(self) -> (u64, u64) {\n-        return (self >> 61, self << 3);\n+        (self >> 61, self << 3)\n     }\n }\n \n@@ -64,7 +63,7 @@ fn add_bytes_to_bits(bits: u64, bytes: u64) -> u64 {\n     }\n \n     match bits.checked_add(new_low_bits) {\n-        Some(x) => return x,\n+        Some(x) => x,\n         None => panic!(\"numeric overflow occurred.\")\n     }\n }\n@@ -113,10 +112,10 @@ struct FixedBuffer64 {\n impl FixedBuffer64 {\n     /// Create a new FixedBuffer64\n     fn new() -> FixedBuffer64 {\n-        return FixedBuffer64 {\n+        FixedBuffer64 {\n             buffer: [0; 64],\n             buffer_idx: 0\n-        };\n+        }\n     }\n }\n \n@@ -175,13 +174,13 @@ impl FixedBuffer for FixedBuffer64 {\n \n     fn next<'s>(&'s mut self, len: usize) -> &'s mut [u8] {\n         self.buffer_idx += len;\n-        return &mut self.buffer[self.buffer_idx - len..self.buffer_idx];\n+        &mut self.buffer[self.buffer_idx - len..self.buffer_idx]\n     }\n \n     fn full_buffer<'s>(&'s mut self) -> &'s [u8] {\n         assert!(self.buffer_idx == 64);\n         self.buffer_idx = 0;\n-        return &self.buffer[..64];\n+        &self.buffer[..64]\n     }\n \n     fn position(&self) -> usize { self.buffer_idx }\n@@ -278,7 +277,7 @@ struct Engine256State {\n \n impl Engine256State {\n     fn new(h: &[u32; 8]) -> Engine256State {\n-        return Engine256State {\n+        Engine256State {\n             h0: h[0],\n             h1: h[1],\n             h2: h[2],\n@@ -287,7 +286,7 @@ impl Engine256State {\n             h5: h[5],\n             h6: h[6],\n             h7: h[7]\n-        };\n+        }\n     }\n \n     fn reset(&mut self, h: &[u32; 8]) {\n@@ -433,7 +432,7 @@ struct Engine256 {\n \n impl Engine256 {\n     fn new(h: &[u32; 8]) -> Engine256 {\n-        return Engine256 {\n+        Engine256 {\n             length_bits: 0,\n             buffer: FixedBuffer64::new(),\n             state: Engine256State::new(h),\n@@ -457,17 +456,15 @@ impl Engine256 {\n     }\n \n     fn finish(&mut self) {\n-        if self.finished {\n-            return;\n+        if !self.finished {\n+            let self_state = &mut self.state;\n+            self.buffer.standard_padding(8, |input: &[u8]| { self_state.process_block(input) });\n+            write_u32_be(self.buffer.next(4), (self.length_bits >> 32) as u32 );\n+            write_u32_be(self.buffer.next(4), self.length_bits as u32);\n+            self_state.process_block(self.buffer.full_buffer());\n+\n+            self.finished = true;\n         }\n-\n-        let self_state = &mut self.state;\n-        self.buffer.standard_padding(8, |input: &[u8]| { self_state.process_block(input) });\n-        write_u32_be(self.buffer.next(4), (self.length_bits >> 32) as u32 );\n-        write_u32_be(self.buffer.next(4), self.length_bits as u32);\n-        self_state.process_block(self.buffer.full_buffer());\n-\n-        self.finished = true;\n     }\n }\n "}]}