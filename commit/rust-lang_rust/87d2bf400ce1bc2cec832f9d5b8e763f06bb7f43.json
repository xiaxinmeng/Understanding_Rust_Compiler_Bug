{"sha": "87d2bf400ce1bc2cec832f9d5b8e763f06bb7f43", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg3ZDJiZjQwMGNlMWJjMmNlYzgzMmY5ZDViOGU3NjNmMDZiYjdmNDM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-08-08T02:01:16Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-08-08T02:01:16Z"}, "message": "auto merge of #16273 : steveklabnik/rust/guide_generics, r=brson", "tree": {"sha": "cbc9b5479b8ebdeec93d2d787710b18d165942e1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cbc9b5479b8ebdeec93d2d787710b18d165942e1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/87d2bf400ce1bc2cec832f9d5b8e763f06bb7f43", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/87d2bf400ce1bc2cec832f9d5b8e763f06bb7f43", "html_url": "https://github.com/rust-lang/rust/commit/87d2bf400ce1bc2cec832f9d5b8e763f06bb7f43", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/87d2bf400ce1bc2cec832f9d5b8e763f06bb7f43/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8888d7c8e93288cf2e07198930cc9f2ae2dc6022", "url": "https://api.github.com/repos/rust-lang/rust/commits/8888d7c8e93288cf2e07198930cc9f2ae2dc6022", "html_url": "https://github.com/rust-lang/rust/commit/8888d7c8e93288cf2e07198930cc9f2ae2dc6022"}, {"sha": "dac73ad3c1b92f51cade8dbac4879ffb951ded3f", "url": "https://api.github.com/repos/rust-lang/rust/commits/dac73ad3c1b92f51cade8dbac4879ffb951ded3f", "html_url": "https://github.com/rust-lang/rust/commit/dac73ad3c1b92f51cade8dbac4879ffb951ded3f"}], "stats": {"total": 492, "additions": 491, "deletions": 1}, "files": [{"sha": "a2b3f22c1554bb34d94552b0c04dfdaaf443e6af", "filename": "src/doc/guide.md", "status": "modified", "additions": 491, "deletions": 1, "changes": 492, "blob_url": "https://github.com/rust-lang/rust/blob/87d2bf400ce1bc2cec832f9d5b8e763f06bb7f43/src%2Fdoc%2Fguide.md", "raw_url": "https://github.com/rust-lang/rust/raw/87d2bf400ce1bc2cec832f9d5b8e763f06bb7f43/src%2Fdoc%2Fguide.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide.md?ref=87d2bf400ce1bc2cec832f9d5b8e763f06bb7f43", "patch": "@@ -3822,9 +3822,499 @@ incredibly powerful.  Next, let's look at one of those things: iterators.\n \n # Generics\n \n+Sometimes, when writing a function or data type, we may want it to work for\n+multiple types of arguments. For example, remember our `OptionalInt` type?\n+\n+```{rust}\n+enum OptionalInt {\n+    Value(int),\n+    Missing,\n+}\n+```\n+\n+If we wanted to also have an `OptionalFloat64`, we would need a new enum:\n+\n+```{rust}\n+enum OptionalFloat64 {\n+    Valuef64(f64),\n+    Missingf64,\n+}\n+```\n+\n+This is really unfortunate. Luckily, Rust has a feature that gives us a better\n+way: generics. Generics are called **parametric polymorphism** in type theory,\n+which means that they are types or functions that have multiple forms (\"poly\"\n+is multiple, \"morph\" is form) over a given parameter (\"parametric\").\n+\n+Anyway, enough with type theory declarations, let's check out the generic form\n+of `OptionalInt`. It is actually provided by Rust itself, and looks like this:\n+\n+```rust\n+enum Option<T> {\n+    Some(T),\n+    None,\n+}\n+```\n+\n+The `<T>` part, which you've seen a few times before, indicates that this is\n+a generic data type. Inside the declaration of our enum, wherever we see a `T`,\n+we substitute that type for the same type used in the generic. Here's an\n+example of using `Option<T>`, with some extra type annotations:\n+\n+```{rust}\n+let x: Option<int> = Some(5i);\n+```\n+\n+In the type declaration, we say `Option<int>`. Note how similar this looks to\n+`Option<T>`. So, in this particular `Option`, `T` has the value of `int`. On\n+the right hand side of the binding, we do make a `Some(T)`, where `T` is `5i`.\n+Since that's an `int`, the two sides match, and Rust is happy. If they didn't\n+match, we'd get an error:\n+\n+```{rust,ignore}\n+let x: Option<f64> = Some(5i);\n+// error: mismatched types: expected `core::option::Option<f64>`\n+// but found `core::option::Option<int>` (expected f64 but found int)\n+```\n+\n+That doesn't mean we can't make `Option<T>`s that hold an `f64`! They just have to\n+match up:\n+\n+```{rust}\n+let x: Option<int> = Some(5i);\n+let y: Option<f64> = Some(5.0f64);\n+```\n+\n+This is just fine. One definition, multiple uses.\n+\n+Generics don't have to only be generic over one type. Consider Rust's built-in\n+`Result<T, E>` type:\n+\n+```{rust}\n+enum Result<T, E> {\n+    Ok(T),\n+    Err(E),\n+}\n+```\n+\n+This type is generic over _two_ types: `T` and `E`. By the way, the capital letters\n+can be any letter you'd like. We could define `Result<T, E>` as:\n+\n+```{rust}\n+enum Result<H, N> {\n+    Ok(H),\n+    Err(N),\n+}\n+```\n+\n+if we wanted to. Convention says that the first generic parameter should be\n+`T`, for 'type,' and that we use `E` for 'error.' Rust doesn't care, however.\n+\n+The `Result<T, E>` type is intended to\n+be used to return the result of a computation, and to have the ability to\n+return an error if it didn't work out. Here's an example:\n+\n+```{rust}\n+let x: Result<f64, String> = Ok(2.3f64);\n+let y: Result<f64, String> = Err(\"There was an error.\".to_string());\n+```\n+\n+This particular Result will return an `f64` if there's a success, and a\n+`String` if there's a failure. Let's write a function that uses `Result<T, E>`:\n+\n+```{rust}\n+fn inverse(x: f64) -> Result<f64, String> {\n+    if x == 0.0f64 { return Err(\"x cannot be zero!\".to_string()); }\n+\n+    Ok(1.0f64 / x)\n+}\n+```\n+\n+We don't want to take the inverse of zero, so we check to make sure that we\n+weren't passed one. If we weren't, then we return an `Err`, with a message. If\n+it's okay, we return an `Ok`, with the answer.\n+\n+Why does this matter? Well, remember how `match` does exhaustive matches?\n+Here's how this function gets used:\n+\n+```{rust}\n+# fn inverse(x: f64) -> Result<f64, String> {\n+#     if x == 0.0f64 { return Err(\"x cannot be zero!\".to_string()); }\n+#     Ok(1.0f64 / x)\n+# }\n+let x = inverse(25.0f64);\n+\n+match x {\n+    Ok(x) => println!(\"The inverse of 25 is {}\", x),\n+    Err(msg) => println!(\"Error: {}\", msg),\n+}\n+```\n+\n+The `match` enforces that we handle the `Err` case. In addition, because the\n+answer is wrapped up in an `Ok`, we can't just use the result without doing\n+the match:\n+\n+```{rust,ignore}\n+let x = inverse(25.0f64);\n+println!(\"{}\", x + 2.0f64); // error: binary operation `+` cannot be applied \n+           // to type `core::result::Result<f64,collections::string::String>`\n+```\n+\n+This function is great, but there's one other problem: it only works for 64 bit\n+floating point values. What if we wanted to handle 32 bit floating point as\n+well? We'd have to write this:\n+\n+```{rust}\n+fn inverse32(x: f32) -> Result<f32, String> {\n+    if x == 0.0f32 { return Err(\"x cannot be zero!\".to_string()); }\n+\n+    Ok(1.0f32 / x)\n+}\n+```\n+\n+Bummer. What we need is a **generic function**. Luckily, we can write one!\n+However, it won't _quite_ work yet. Before we get into that, let's talk syntax.\n+A generic version of `inverse` would look something like this:\n+\n+```{rust,ignore}\n+fn inverse<T>(x: T) -> Result<T, String> {\n+    if x == 0.0 { return Err(\"x cannot be zero!\".to_string()); }\n+\n+    Ok(1.0 / x)\n+}\n+```\n+\n+Just like how we had `Option<T>`, we use a similar syntax for `inverse<T>`.\n+We can then use `T` inside the rest of the signature: `x` has type `T`, and half\n+of the `Result` has type `T`. However, if we try to compile that example, we'll get\n+an error:\n+\n+```{notrust,ignore}\n+error: binary operation `==` cannot be applied to type `T`\n+```\n+\n+Because `T` can be _any_ type, it may be a type that doesn't implement `==`,\n+and therefore, the first line would be wrong. What do we do?\n+\n+To fix this example, we need to learn about another Rust feature: traits.\n+\n # Traits\n \n-# Operators and built-in Traits\n+Do you remember the `impl` keyword, used to call a function with method\n+syntax?\n+\n+```{rust}\n+struct Circle {\n+    x: f64,\n+    y: f64,\n+    radius: f64,\n+}\n+\n+impl Circle {\n+    fn area(&self) -> f64 {\n+        std::f64::consts::PI * (self.radius * self.radius)\n+    }\n+}\n+```\n+\n+Traits are similar, except that we define a trait with just the method\n+signature, then implement the trait for that struct. Like this:\n+\n+```{rust}\n+struct Circle {\n+    x: f64,\n+    y: f64,\n+    radius: f64,\n+}\n+\n+trait HasArea {\n+    fn area(&self) -> f64;\n+}\n+\n+impl HasArea for Circle {\n+    fn area(&self) -> f64 {\n+        std::f64::consts::PI * (self.radius * self.radius)\n+    }\n+}\n+```\n+\n+As you can see, the `trait` block looks very similar to the `impl` block,\n+but we don't define a body, just a type signature. When we `impl` a trait,\n+we use `impl Trait for Item`, rather than just `impl Item`.\n+\n+So what's the big deal? Remember the error we were getting with our generic\n+`inverse` function?\n+\n+```{notrust,ignore}\n+error: binary operation `==` cannot be applied to type `T`\n+```\n+\n+We can use traits to constrain our generics. Consider this function, which\n+does not compile, and gives us a similar error:\n+\n+```{rust,ignore}\n+fn print_area<T>(shape: T) {\n+    println!(\"This shape has an area of {}\", shape.area());\n+}\n+```\n+\n+Rust complains:\n+\n+```{notrust,ignore}\n+error: type `T` does not implement any method in scope named `area`\n+```\n+\n+Because `T` can be any type, we can't be sure that it implements the `area`\n+method. But we can add a **trait constraint** to our generic `T`, ensuring\n+that it does:\n+\n+```{rust}\n+# trait HasArea {\n+#     fn area(&self) -> f64;\n+# }\n+fn print_area<T: HasArea>(shape: T) {\n+    println!(\"This shape has an area of {}\", shape.area());\n+}\n+```\n+\n+The syntax `<T: HasArea>` means `any type that implements the HasArea trait`.\n+Because traits define function type signatures, we can be sure that any type\n+which implements `HasArea` will have an `.area()` method.\n+\n+Here's an extended example of how this works:\n+\n+```{rust}\n+trait HasArea {\n+    fn area(&self) -> f64;\n+}\n+\n+struct Circle {\n+    x: f64,\n+    y: f64,\n+    radius: f64,\n+}\n+\n+impl HasArea for Circle {\n+    fn area(&self) -> f64 {\n+        std::f64::consts::PI * (self.radius * self.radius)\n+    }\n+}\n+\n+struct Square {\n+    x: f64,\n+    y: f64,\n+    side: f64,\n+}\n+\n+impl HasArea for Square {\n+    fn area(&self) -> f64 {\n+        self.side * self.side\n+    }\n+}\n+\n+fn print_area<T: HasArea>(shape: T) {\n+    println!(\"This shape has an area of {}\", shape.area());\n+}\n+\n+fn main() {\n+    let c = Circle {\n+        x: 0.0f64,\n+        y: 0.0f64,\n+        radius: 1.0f64,\n+    };\n+\n+    let s = Square {\n+        x: 0.0f64,\n+        y: 0.0f64,\n+        side: 1.0f64,\n+    };\n+\n+    print_area(c);\n+    print_area(s);\n+}\n+```\n+\n+This program outputs:\n+\n+```{notrust,ignore}\n+This shape has an area of 3.141593\n+This shape has an area of 1\n+```\n+\n+As you can see, `print_area` is now generic, but also ensures that we\n+have passed in the correct types. If we pass in an incorrect type:\n+\n+```{rust,ignore}\n+print_area(5i);\n+```\n+\n+We get a compile-time error:\n+\n+```{notrust,ignore}\n+error: failed to find an implementation of trait main::HasArea for int\n+```\n+\n+So far, we've only added trait implementations to structs, but you can\n+implement a trait for any type. So technically, we _could_ implement\n+`HasArea` for `int`:\n+\n+```{rust}\n+trait HasArea {\n+    fn area(&self) -> f64;\n+}\n+\n+impl HasArea for int {\n+    fn area(&self) -> f64 {\n+        println!(\"this is silly\");\n+\n+        *self as f64\n+    }\n+}\n+\n+5i.area();\n+```\n+\n+It is considered poor style to implement methods on such primitive types, even\n+though it is possible.\n+\n+This may seem like the Wild West, but there are two other restrictions around\n+implementing traits that prevent this from getting out of hand. First, traits\n+must be `use`d in any scope where you wish to use the trait's method. So for\n+example, this does not work:\n+\n+```{rust,ignore}\n+mod shapes {\n+    use std::f64::consts;\n+\n+    trait HasArea {\n+        fn area(&self) -> f64;\n+    }\n+\n+    struct Circle {\n+        x: f64,\n+        y: f64,\n+        radius: f64,\n+    }\n+\n+    impl HasArea for Circle {\n+        fn area(&self) -> f64 {\n+            consts::PI * (self.radius * self.radius)\n+        }\n+    }\n+}\n+\n+fn main() {\n+    let c = shapes::Circle {\n+        x: 0.0f64,\n+        y: 0.0f64,\n+        radius: 1.0f64,\n+    };\n+\n+    println!(\"{}\", c.area());\n+}\n+```\n+\n+Now that we've moved the structs and traits into their own module, we get an\n+error:\n+\n+```{notrust,ignore}\n+error: type `shapes::Circle` does not implement any method in scope named `area`\n+```\n+\n+If we add a `use` line right above `main` and make the right things public,\n+everything is fine:\n+\n+```{rust}\n+use shapes::HasArea;\n+\n+mod shapes {\n+    use std::f64::consts;\n+\n+    pub trait HasArea {\n+        fn area(&self) -> f64;\n+    }\n+\n+    pub struct Circle {\n+        pub x: f64,\n+        pub y: f64,\n+        pub radius: f64,\n+    }\n+\n+    impl HasArea for Circle {\n+        fn area(&self) -> f64 {\n+            consts::PI * (self.radius * self.radius)\n+        }\n+    }\n+}\n+\n+\n+fn main() {\n+    let c = shapes::Circle {\n+        x: 0.0f64,\n+        y: 0.0f64,\n+        radius: 1.0f64,\n+    };\n+\n+    println!(\"{}\", c.area());\n+}\n+```\n+\n+This means that even if someone does something bad like add methods to `int`,\n+it won't affect you, unless you `use` that trait.\n+\n+There's one more restriction on implementing traits. Either the trait or the\n+type you're writing the `impl` for must be inside your crate. So, we could\n+implement the `HasArea` type for `int`, because `HasArea` is in our crate.  But\n+if we tried to implement `Float`, a trait provided by Rust, for `int`, we could\n+not, because both the trait and the type aren't in our crate.\n+\n+One last thing about traits: generic functions with a trait bound use\n+**monomorphization** (\"mono\": one, \"morph\": form), so they are statically\n+dispatched. What's that mean? Well, let's take a look at `print_area` again:\n+\n+```{rust,ignore}\n+fn print_area<T: HasArea>(shape: T) {\n+    println!(\"This shape has an area of {}\", shape.area());\n+}\n+\n+fn main() {\n+    let c = Circle { ... };\n+\n+    let s = Square { ... };\n+\n+    print_area(c);\n+    print_area(s);\n+}\n+```\n+\n+When we use this trait with `Circle` and `Square`, Rust ends up generating\n+two different functions with the concrete type, and replacing the call sites with\n+calls to the concrete implementations. In other words, you get something like\n+this:\n+\n+```{rust,ignore}\n+fn __print_area_circle(shape: Circle) {\n+    println!(\"This shape has an area of {}\", shape.area());\n+}\n+\n+fn __print_area_square(shape: Square) {\n+    println!(\"This shape has an area of {}\", shape.area());\n+}\n+\n+fn main() {\n+    let c = Circle { ... };\n+\n+    let s = Square { ... };\n+\n+    __print_area_circle(c);\n+    __print_area_square(s);\n+}\n+```\n+\n+The names don't actually change to this, it's just for illustration. But\n+as you can see, there's no overhead of deciding which version to call here,\n+hence 'statically dispatched.' The downside is that we have two copies of\n+the same function, so our binary is a little bit larger.\n \n # Tasks\n "}]}