{"sha": "8eee1b44b0ce0d451e4fca5d7c6ca65f4ac53610", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhlZWUxYjQ0YjBjZTBkNDUxZTRmY2E1ZDdjNmNhNjVmNGFjNTM2MTA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-09-10T09:20:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-09-10T09:20:39Z"}, "message": "auto merge of #17095 : thestinger/rust/alloc, r=alexcrichton\n\nPreviously, some parts of this optimization were impossible because the\r\nalignment passed to the free function was not correct. That was fully\r\nfixed by #17012.\r\n\r\nCloses #17092", "tree": {"sha": "285f7ccbbc12a0750a78494ea8304fa6c887ada2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/285f7ccbbc12a0750a78494ea8304fa6c887ada2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8eee1b44b0ce0d451e4fca5d7c6ca65f4ac53610", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8eee1b44b0ce0d451e4fca5d7c6ca65f4ac53610", "html_url": "https://github.com/rust-lang/rust/commit/8eee1b44b0ce0d451e4fca5d7c6ca65f4ac53610", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8eee1b44b0ce0d451e4fca5d7c6ca65f4ac53610/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "370f8df2aed338664d9b73ec44ce271daad99148", "url": "https://api.github.com/repos/rust-lang/rust/commits/370f8df2aed338664d9b73ec44ce271daad99148", "html_url": "https://github.com/rust-lang/rust/commit/370f8df2aed338664d9b73ec44ce271daad99148"}, {"sha": "72a92b2e14927aa2bedcc739aa8de62d66632ed9", "url": "https://api.github.com/repos/rust-lang/rust/commits/72a92b2e14927aa2bedcc739aa8de62d66632ed9", "html_url": "https://github.com/rust-lang/rust/commit/72a92b2e14927aa2bedcc739aa8de62d66632ed9"}], "stats": {"total": 111, "additions": 76, "deletions": 35}, "files": [{"sha": "aae04170ccbfeea620502106b581c3c216cd132a", "filename": "src/jemalloc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fjemalloc?ref=8eee1b44b0ce0d451e4fca5d7c6ca65f4ac53610", "patch": "@@ -1 +1 @@\n-Subproject commit 024c67ad651e1a3ca228936c4cfb13a37329baf2\n+Subproject commit aae04170ccbfeea620502106b581c3c216cd132a"}, {"sha": "62010ca8916d0f686cf5e54f1c44aa79fa0bae97", "filename": "src/liballoc/heap.rs", "status": "modified", "additions": 75, "deletions": 34, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/8eee1b44b0ce0d451e4fca5d7c6ca65f4ac53610/src%2Fliballoc%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eee1b44b0ce0d451e4fca5d7c6ca65f4ac53610/src%2Fliballoc%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fheap.rs?ref=8eee1b44b0ce0d451e4fca5d7c6ca65f4ac53610", "patch": "@@ -149,12 +149,24 @@ unsafe fn closure_exchange_malloc(drop_glue: fn(*mut u8), size: uint,\n     alloc as *mut u8\n }\n \n+// The minimum alignment guaranteed by the architecture. This value is used to\n+// add fast paths for low alignment values. In practice, the alignment is a\n+// constant at the call site and the branch will be optimized out.\n+#[cfg(target_arch = \"arm\")]\n+#[cfg(target_arch = \"mips\")]\n+#[cfg(target_arch = \"mipsel\")]\n+static MIN_ALIGN: uint = 8;\n+#[cfg(target_arch = \"x86\")]\n+#[cfg(target_arch = \"x86_64\")]\n+static MIN_ALIGN: uint = 16;\n+\n #[cfg(jemalloc)]\n mod imp {\n     use core::option::{None, Option};\n     use core::ptr::{RawPtr, mut_null, null};\n     use core::num::Int;\n     use libc::{c_char, c_int, c_void, size_t};\n+    use super::MIN_ALIGN;\n \n     #[link(name = \"jemalloc\", kind = \"static\")]\n     #[cfg(not(test))]\n@@ -166,7 +178,10 @@ mod imp {\n                       flags: c_int) -> *mut c_void;\n         fn je_xallocx(ptr: *mut c_void, size: size_t, extra: size_t,\n                       flags: c_int) -> size_t;\n+        #[cfg(stage0)]\n         fn je_dallocx(ptr: *mut c_void, flags: c_int);\n+        #[cfg(not(stage0))]\n+        fn je_sdallocx(ptr: *mut c_void, size: size_t, flags: c_int);\n         fn je_nallocx(size: size_t, flags: c_int) -> size_t;\n         fn je_malloc_stats_print(write_cb: Option<extern \"C\" fn(cbopaque: *mut c_void,\n                                                                 *const c_char)>,\n@@ -183,9 +198,15 @@ mod imp {\n     #[inline(always)]\n     fn mallocx_align(a: uint) -> c_int { a.trailing_zeros() as c_int }\n \n+    #[inline(always)]\n+    fn align_to_flags(align: uint) -> c_int {\n+        if align <= MIN_ALIGN { 0 } else { mallocx_align(align) }\n+    }\n+\n     #[inline]\n     pub unsafe fn allocate(size: uint, align: uint) -> *mut u8 {\n-        let ptr = je_mallocx(size as size_t, mallocx_align(align)) as *mut u8;\n+        let flags = align_to_flags(align);\n+        let ptr = je_mallocx(size as size_t, flags) as *mut u8;\n         if ptr.is_null() {\n             ::oom()\n         }\n@@ -195,8 +216,8 @@ mod imp {\n     #[inline]\n     pub unsafe fn reallocate(ptr: *mut u8, size: uint, align: uint,\n                              _old_size: uint) -> *mut u8 {\n-        let ptr = je_rallocx(ptr as *mut c_void, size as size_t,\n-                             mallocx_align(align)) as *mut u8;\n+        let flags = align_to_flags(align);\n+        let ptr = je_rallocx(ptr as *mut c_void, size as size_t, flags) as *mut u8;\n         if ptr.is_null() {\n             ::oom()\n         }\n@@ -206,18 +227,28 @@ mod imp {\n     #[inline]\n     pub unsafe fn reallocate_inplace(ptr: *mut u8, size: uint, align: uint,\n                                      _old_size: uint) -> bool {\n-        je_xallocx(ptr as *mut c_void, size as size_t, 0,\n-                   mallocx_align(align)) == size as size_t\n+        let flags = align_to_flags(align);\n+        je_xallocx(ptr as *mut c_void, size as size_t, 0, flags) == size as size_t\n     }\n \n     #[inline]\n+    #[cfg(stage0)]\n     pub unsafe fn deallocate(ptr: *mut u8, _size: uint, align: uint) {\n-        je_dallocx(ptr as *mut c_void, mallocx_align(align))\n+        let flags = align_to_flags(align);\n+        je_dallocx(ptr as *mut c_void, flags)\n+    }\n+\n+    #[inline]\n+    #[cfg(not(stage0))]\n+    pub unsafe fn deallocate(ptr: *mut u8, size: uint, align: uint) {\n+        let flags = align_to_flags(align);\n+        je_sdallocx(ptr as *mut c_void, size as size_t, flags)\n     }\n \n     #[inline]\n     pub fn usable_size(size: uint, align: uint) -> uint {\n-        unsafe { je_nallocx(size as size_t, mallocx_align(align)) as uint }\n+        let flags = align_to_flags(align);\n+        unsafe { je_nallocx(size as size_t, flags) as uint }\n     }\n \n     pub fn stats_print() {\n@@ -234,6 +265,7 @@ mod imp {\n     use core::ptr;\n     use libc;\n     use libc_heap;\n+    use super::MIN_ALIGN;\n \n     extern {\n         fn posix_memalign(memptr: *mut *mut libc::c_void,\n@@ -243,16 +275,7 @@ mod imp {\n \n     #[inline]\n     pub unsafe fn allocate(size: uint, align: uint) -> *mut u8 {\n-        // The posix_memalign manpage states\n-        //\n-        //      alignment [...] must be a power of and a multiple of\n-        //      sizeof(void *)\n-        //\n-        // The `align` parameter to this function is the *minimum* alignment for\n-        // a block of memory, so we special case everything under `*uint` to\n-        // just pass it to malloc, which is guaranteed to align to at least the\n-        // size of `*uint`.\n-        if align < mem::size_of::<uint>() {\n+        if align <= MIN_ALIGN {\n             libc_heap::malloc_raw(size)\n         } else {\n             let mut out = 0 as *mut libc::c_void;\n@@ -269,10 +292,14 @@ mod imp {\n     #[inline]\n     pub unsafe fn reallocate(ptr: *mut u8, size: uint, align: uint,\n                              old_size: uint) -> *mut u8 {\n-        let new_ptr = allocate(size, align);\n-        ptr::copy_memory(new_ptr, ptr as *const u8, cmp::min(size, old_size));\n-        deallocate(ptr, old_size, align);\n-        return new_ptr;\n+        if align <= MIN_ALIGN {\n+            libc_heap::realloc_raw(ptr, size)\n+        } else {\n+            let new_ptr = allocate(size, align);\n+            ptr::copy_memory(new_ptr, ptr as *const u8, cmp::min(size, old_size));\n+            deallocate(ptr, old_size, align);\n+            new_ptr\n+        }\n     }\n \n     #[inline]\n@@ -291,14 +318,16 @@ mod imp {\n         size\n     }\n \n-    pub fn stats_print() {\n-    }\n+    pub fn stats_print() {}\n }\n \n #[cfg(not(jemalloc), windows)]\n mod imp {\n     use libc::{c_void, size_t};\n+    use libc;\n+    use libc_heap;\n     use core::ptr::RawPtr;\n+    use super::MIN_ALIGN;\n \n     extern {\n         fn _aligned_malloc(size: size_t, align: size_t) -> *mut c_void;\n@@ -309,22 +338,30 @@ mod imp {\n \n     #[inline]\n     pub unsafe fn allocate(size: uint, align: uint) -> *mut u8 {\n-        let ptr = _aligned_malloc(size as size_t, align as size_t);\n-        if ptr.is_null() {\n-            ::oom();\n+        if align <= MIN_ALIGN {\n+            libc_heap::malloc_raw(size)\n+        } else {\n+            let ptr = _aligned_malloc(size as size_t, align as size_t);\n+            if ptr.is_null() {\n+                ::oom();\n+            }\n+            ptr as *mut u8\n         }\n-        ptr as *mut u8\n     }\n \n     #[inline]\n     pub unsafe fn reallocate(ptr: *mut u8, size: uint, align: uint,\n                              _old_size: uint) -> *mut u8 {\n-        let ptr = _aligned_realloc(ptr as *mut c_void, size as size_t,\n-                                   align as size_t);\n-        if ptr.is_null() {\n-            ::oom();\n+        if align <= MIN_ALIGN {\n+            libc_heap::realloc_raw(ptr, size)\n+        } else {\n+            let ptr = _aligned_realloc(ptr as *mut c_void, size as size_t,\n+                                       align as size_t);\n+            if ptr.is_null() {\n+                ::oom();\n+            }\n+            ptr as *mut u8\n         }\n-        ptr as *mut u8\n     }\n \n     #[inline]\n@@ -334,8 +371,12 @@ mod imp {\n     }\n \n     #[inline]\n-    pub unsafe fn deallocate(ptr: *mut u8, _size: uint, _align: uint) {\n-        _aligned_free(ptr as *mut c_void)\n+    pub unsafe fn deallocate(ptr: *mut u8, _size: uint, align: uint) {\n+        if align <= MIN_ALIGN {\n+            libc::free(ptr as *mut libc::c_void)\n+        } else {\n+            _aligned_free(ptr as *mut c_void)\n+        }\n     }\n \n     #[inline]"}]}