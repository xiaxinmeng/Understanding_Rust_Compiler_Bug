{"sha": "d594910a2da12f158477b4c7281716f535cfa3de", "node_id": "C_kwDOAAsO6NoAKGQ1OTQ5MTBhMmRhMTJmMTU4NDc3YjRjNzI4MTcxNmY1MzVjZmEzZGU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-12-15T00:23:44Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-12-15T00:23:44Z"}, "message": "Auto merge of #91933 - matthiaskrgr:rollup-cw9qolb, r=matthiaskrgr\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #89825 (Make split_inclusive() on an empty slice yield an empty output)\n - #91239 (regression test for issue 87490)\n - #91597 (Recover on invalid operators `<>` and `<=>`)\n - #91774 (Fix typo for MutVisitor)\n - #91786 (Return an error when `eval_rvalue_with_identities` fails)\n - #91798 (Avoid suggest adding `self` in visibility spec)\n - #91856 (Looser check for overflowing_binary_op)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "3736af2bf5abf5caa6f64e54c609fb9d5ed7237f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3736af2bf5abf5caa6f64e54c609fb9d5ed7237f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d594910a2da12f158477b4c7281716f535cfa3de", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d594910a2da12f158477b4c7281716f535cfa3de", "html_url": "https://github.com/rust-lang/rust/commit/d594910a2da12f158477b4c7281716f535cfa3de", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d594910a2da12f158477b4c7281716f535cfa3de/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2f4da6243f817b26c5c8156408911a01b39f9759", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f4da6243f817b26c5c8156408911a01b39f9759", "html_url": "https://github.com/rust-lang/rust/commit/2f4da6243f817b26c5c8156408911a01b39f9759"}, {"sha": "bae9270989cda75f891c3099383352daa5435404", "url": "https://api.github.com/repos/rust-lang/rust/commits/bae9270989cda75f891c3099383352daa5435404", "html_url": "https://github.com/rust-lang/rust/commit/bae9270989cda75f891c3099383352daa5435404"}], "stats": {"total": 261, "additions": 198, "deletions": 63}, "files": [{"sha": "6bf23af81bf6b87f99fa8890a0fe83cb0d9faf7c", "filename": "compiler/rustc_ast/src/mut_visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d594910a2da12f158477b4c7281716f535cfa3de/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d594910a2da12f158477b4c7281716f535cfa3de/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs?ref=d594910a2da12f158477b4c7281716f535cfa3de", "patch": "@@ -1,5 +1,5 @@\n //! A `MutVisitor` represents an AST modification; it accepts an AST piece and\n-//! and mutates it in place. So, for instance, macro expansion is a `MutVisitor`\n+//! mutates it in place. So, for instance, macro expansion is a `MutVisitor`\n //! that walks over an AST and modifies it.\n //!\n //! Note: using a `MutVisitor` (other than the `MacroExpander` `MutVisitor`) on"}, {"sha": "48c90e1881a9a6adf5c845ba14bd02a8249aedd1", "filename": "compiler/rustc_const_eval/src/interpret/operator.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d594910a2da12f158477b4c7281716f535cfa3de/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d594910a2da12f158477b4c7281716f535cfa3de/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperator.rs?ref=d594910a2da12f158477b4c7281716f535cfa3de", "patch": "@@ -328,9 +328,10 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 self.binary_int_op(bin_op, l, left.layout, r, right.layout)\n             }\n             _ if left.layout.ty.is_any_ptr() => {\n-                // The RHS type must be the same *or an integer type* (for `Offset`).\n+                // The RHS type must be a `pointer` *or an integer type* (for `Offset`).\n+                // (Even when both sides are pointers, their type might differ, see issue #91636)\n                 assert!(\n-                    right.layout.ty == left.layout.ty || right.layout.ty.is_integral(),\n+                    right.layout.ty.is_any_ptr() || right.layout.ty.is_integral(),\n                     \"Unexpected types for BinOp: {:?} {:?} {:?}\",\n                     left.layout.ty,\n                     bin_op,"}, {"sha": "84bdb8eece654383754acdd74df3858fa81f6a06", "filename": "compiler/rustc_mir_transform/src/const_prop.rs", "status": "modified", "additions": 34, "deletions": 52, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/d594910a2da12f158477b4c7281716f535cfa3de/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d594910a2da12f158477b4c7281716f535cfa3de/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs?ref=d594910a2da12f158477b4c7281716f535cfa3de", "patch": "@@ -752,62 +752,44 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         rvalue: &Rvalue<'tcx>,\n         place: Place<'tcx>,\n     ) -> Option<()> {\n-        self.use_ecx(|this| {\n-            match rvalue {\n-                Rvalue::BinaryOp(op, box (left, right))\n-                | Rvalue::CheckedBinaryOp(op, box (left, right)) => {\n-                    let l = this.ecx.eval_operand(left, None);\n-                    let r = this.ecx.eval_operand(right, None);\n-\n-                    let const_arg = match (l, r) {\n-                        (Ok(ref x), Err(_)) | (Err(_), Ok(ref x)) => this.ecx.read_immediate(x)?,\n-                        (Err(e), Err(_)) => return Err(e),\n-                        (Ok(_), Ok(_)) => {\n-                            this.ecx.eval_rvalue_into_place(rvalue, place)?;\n-                            return Ok(());\n-                        }\n-                    };\n-\n-                    let arg_value = const_arg.to_scalar()?.to_bits(const_arg.layout.size)?;\n-                    let dest = this.ecx.eval_place(place)?;\n-\n-                    match op {\n-                        BinOp::BitAnd => {\n-                            if arg_value == 0 {\n-                                this.ecx.write_immediate(*const_arg, &dest)?;\n-                            }\n-                        }\n-                        BinOp::BitOr => {\n-                            if arg_value == const_arg.layout.size.truncate(u128::MAX)\n-                                || (const_arg.layout.ty.is_bool() && arg_value == 1)\n-                            {\n-                                this.ecx.write_immediate(*const_arg, &dest)?;\n-                            }\n-                        }\n-                        BinOp::Mul => {\n-                            if const_arg.layout.ty.is_integral() && arg_value == 0 {\n-                                if let Rvalue::CheckedBinaryOp(_, _) = rvalue {\n-                                    let val = Immediate::ScalarPair(\n-                                        const_arg.to_scalar()?.into(),\n-                                        Scalar::from_bool(false).into(),\n-                                    );\n-                                    this.ecx.write_immediate(val, &dest)?;\n-                                } else {\n-                                    this.ecx.write_immediate(*const_arg, &dest)?;\n-                                }\n-                            }\n-                        }\n-                        _ => {\n-                            this.ecx.eval_rvalue_into_place(rvalue, place)?;\n+        self.use_ecx(|this| match rvalue {\n+            Rvalue::BinaryOp(op, box (left, right))\n+            | Rvalue::CheckedBinaryOp(op, box (left, right)) => {\n+                let l = this.ecx.eval_operand(left, None);\n+                let r = this.ecx.eval_operand(right, None);\n+\n+                let const_arg = match (l, r) {\n+                    (Ok(ref x), Err(_)) | (Err(_), Ok(ref x)) => this.ecx.read_immediate(x)?,\n+                    (Err(e), Err(_)) => return Err(e),\n+                    (Ok(_), Ok(_)) => return this.ecx.eval_rvalue_into_place(rvalue, place),\n+                };\n+\n+                let arg_value = const_arg.to_scalar()?.to_bits(const_arg.layout.size)?;\n+                let dest = this.ecx.eval_place(place)?;\n+\n+                match op {\n+                    BinOp::BitAnd if arg_value == 0 => this.ecx.write_immediate(*const_arg, &dest),\n+                    BinOp::BitOr\n+                        if arg_value == const_arg.layout.size.truncate(u128::MAX)\n+                            || (const_arg.layout.ty.is_bool() && arg_value == 1) =>\n+                    {\n+                        this.ecx.write_immediate(*const_arg, &dest)\n+                    }\n+                    BinOp::Mul if const_arg.layout.ty.is_integral() && arg_value == 0 => {\n+                        if let Rvalue::CheckedBinaryOp(_, _) = rvalue {\n+                            let val = Immediate::ScalarPair(\n+                                const_arg.to_scalar()?.into(),\n+                                Scalar::from_bool(false).into(),\n+                            );\n+                            this.ecx.write_immediate(val, &dest)\n+                        } else {\n+                            this.ecx.write_immediate(*const_arg, &dest)\n                         }\n                     }\n-                }\n-                _ => {\n-                    this.ecx.eval_rvalue_into_place(rvalue, place)?;\n+                    _ => this.ecx.eval_rvalue_into_place(rvalue, place),\n                 }\n             }\n-\n-            Ok(())\n+            _ => this.ecx.eval_rvalue_into_place(rvalue, place),\n         })\n     }\n "}, {"sha": "c62ebb271f4b039290b0d77c71974c6b6a7f3db9", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 33, "deletions": 1, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/d594910a2da12f158477b4c7281716f535cfa3de/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d594910a2da12f158477b4c7281716f535cfa3de/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=d594910a2da12f158477b4c7281716f535cfa3de", "patch": "@@ -213,11 +213,11 @@ impl<'a> Parser<'a> {\n                 }\n             }\n \n+            // Look for JS' `===` and `!==` and recover\n             if (op.node == AssocOp::Equal || op.node == AssocOp::NotEqual)\n                 && self.token.kind == token::Eq\n                 && self.prev_token.span.hi() == self.token.span.lo()\n             {\n-                // Look for JS' `===` and `!==` and recover \ud83d\ude07\n                 let sp = op.span.to(self.token.span);\n                 let sugg = match op.node {\n                     AssocOp::Equal => \"==\",\n@@ -235,6 +235,38 @@ impl<'a> Parser<'a> {\n                 self.bump();\n             }\n \n+            // Look for PHP's `<>` and recover\n+            if op.node == AssocOp::Less\n+                && self.token.kind == token::Gt\n+                && self.prev_token.span.hi() == self.token.span.lo()\n+            {\n+                let sp = op.span.to(self.token.span);\n+                self.struct_span_err(sp, \"invalid comparison operator `<>`\")\n+                    .span_suggestion_short(\n+                        sp,\n+                        \"`<>` is not a valid comparison operator, use `!=`\",\n+                        \"!=\".to_string(),\n+                        Applicability::MachineApplicable,\n+                    )\n+                    .emit();\n+                self.bump();\n+            }\n+\n+            // Look for C++'s `<=>` and recover\n+            if op.node == AssocOp::LessEqual\n+                && self.token.kind == token::Gt\n+                && self.prev_token.span.hi() == self.token.span.lo()\n+            {\n+                let sp = op.span.to(self.token.span);\n+                self.struct_span_err(sp, \"invalid comparison operator `<=>`\")\n+                    .span_label(\n+                        sp,\n+                        \"`<=>` is not a valid comparison operator, use `std::cmp::Ordering`\",\n+                    )\n+                    .emit();\n+                self.bump();\n+            }\n+\n             let op = op.node;\n             // Special cases:\n             if op == AssocOp::As {"}, {"sha": "3e1afdfa9a5c651785bf7760ba6400a3931ffcda", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d594910a2da12f158477b4c7281716f535cfa3de/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d594910a2da12f158477b4c7281716f535cfa3de/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=d594910a2da12f158477b4c7281716f535cfa3de", "patch": "@@ -298,11 +298,16 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                             .get(0)\n                             .map(|p| (p.span.shrink_to_lo(), \"&self, \"))\n                             .unwrap_or_else(|| {\n+                                // Try to look for the \"(\" after the function name, if possible.\n+                                // This avoids placing the suggestion into the visibility specifier.\n+                                let span = fn_kind\n+                                    .ident()\n+                                    .map_or(*span, |ident| span.with_lo(ident.span.hi()));\n                                 (\n                                     self.r\n                                         .session\n                                         .source_map()\n-                                        .span_through_char(*span, '(')\n+                                        .span_through_char(span, '(')\n                                         .shrink_to_hi(),\n                                     \"&self\",\n                                 )"}, {"sha": "18ea6a214137703403e2f36da7bb94ae4bc2310c", "filename": "library/alloc/tests/slice.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d594910a2da12f158477b4c7281716f535cfa3de/library%2Falloc%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d594910a2da12f158477b4c7281716f535cfa3de/library%2Falloc%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fslice.rs?ref=d594910a2da12f158477b4c7281716f535cfa3de", "patch": "@@ -863,7 +863,7 @@ fn test_splitator_inclusive() {\n     assert_eq!(xs.split_inclusive(|_| true).collect::<Vec<&[i32]>>(), splits);\n \n     let xs: &[i32] = &[];\n-    let splits: &[&[i32]] = &[&[]];\n+    let splits: &[&[i32]] = &[];\n     assert_eq!(xs.split_inclusive(|x| *x == 5).collect::<Vec<&[i32]>>(), splits);\n }\n \n@@ -883,7 +883,7 @@ fn test_splitator_inclusive_reverse() {\n     assert_eq!(xs.split_inclusive(|_| true).rev().collect::<Vec<_>>(), splits);\n \n     let xs: &[i32] = &[];\n-    let splits: &[&[i32]] = &[&[]];\n+    let splits: &[&[i32]] = &[];\n     assert_eq!(xs.split_inclusive(|x| *x == 5).rev().collect::<Vec<_>>(), splits);\n }\n \n@@ -903,7 +903,7 @@ fn test_splitator_mut_inclusive() {\n     assert_eq!(xs.split_inclusive_mut(|_| true).collect::<Vec<_>>(), splits);\n \n     let xs: &mut [i32] = &mut [];\n-    let splits: &[&[i32]] = &[&[]];\n+    let splits: &[&[i32]] = &[];\n     assert_eq!(xs.split_inclusive_mut(|x| *x == 5).collect::<Vec<_>>(), splits);\n }\n \n@@ -923,7 +923,7 @@ fn test_splitator_mut_inclusive_reverse() {\n     assert_eq!(xs.split_inclusive_mut(|_| true).rev().collect::<Vec<_>>(), splits);\n \n     let xs: &mut [i32] = &mut [];\n-    let splits: &[&[i32]] = &[&[]];\n+    let splits: &[&[i32]] = &[];\n     assert_eq!(xs.split_inclusive_mut(|x| *x == 5).rev().collect::<Vec<_>>(), splits);\n }\n "}, {"sha": "11a57558f67d7bfb5a8e3586e53633d3f66ae718", "filename": "library/core/src/slice/iter.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d594910a2da12f158477b4c7281716f535cfa3de/library%2Fcore%2Fsrc%2Fslice%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d594910a2da12f158477b4c7281716f535cfa3de/library%2Fcore%2Fsrc%2Fslice%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fiter.rs?ref=d594910a2da12f158477b4c7281716f535cfa3de", "patch": "@@ -481,7 +481,8 @@ where\n impl<'a, T: 'a, P: FnMut(&T) -> bool> SplitInclusive<'a, T, P> {\n     #[inline]\n     pub(super) fn new(slice: &'a [T], pred: P) -> Self {\n-        Self { v: slice, pred, finished: false }\n+        let finished = slice.is_empty();\n+        Self { v: slice, pred, finished }\n     }\n }\n \n@@ -729,7 +730,8 @@ where\n impl<'a, T: 'a, P: FnMut(&T) -> bool> SplitInclusiveMut<'a, T, P> {\n     #[inline]\n     pub(super) fn new(slice: &'a mut [T], pred: P) -> Self {\n-        Self { v: slice, pred, finished: false }\n+        let finished = slice.is_empty();\n+        Self { v: slice, pred, finished }\n     }\n }\n "}, {"sha": "8e20640b58d94898735c73640ba3f3936a90ae0b", "filename": "src/test/ui/binop/binary-op-on-fn-ptr-eq.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d594910a2da12f158477b4c7281716f535cfa3de/src%2Ftest%2Fui%2Fbinop%2Fbinary-op-on-fn-ptr-eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d594910a2da12f158477b4c7281716f535cfa3de/src%2Ftest%2Fui%2Fbinop%2Fbinary-op-on-fn-ptr-eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbinop%2Fbinary-op-on-fn-ptr-eq.rs?ref=d594910a2da12f158477b4c7281716f535cfa3de", "patch": "@@ -0,0 +1,9 @@\n+// run-pass\n+// Tests equality between supertype and subtype of a function\n+// See the issue #91636\n+fn foo(_a: &str) {}\n+\n+fn main() {\n+    let x = foo as fn(&'static str);\n+    let _ = x == foo;\n+}"}, {"sha": "998f61a6bd32de6a57b76889fe3b9ed09e14ee2a", "filename": "src/test/ui/issues/issue-87490.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d594910a2da12f158477b4c7281716f535cfa3de/src%2Ftest%2Fui%2Fissues%2Fissue-87490.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d594910a2da12f158477b4c7281716f535cfa3de/src%2Ftest%2Fui%2Fissues%2Fissue-87490.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-87490.rs?ref=d594910a2da12f158477b4c7281716f535cfa3de", "patch": "@@ -0,0 +1,10 @@\n+fn main() {}\n+trait StreamOnce {\n+    type Position;\n+}\n+impl StreamOnce for &str {\n+    type Position = usize;\n+}\n+fn follow(_: &str) -> <&str as StreamOnce>::Position {\n+    String::new  //~ ERROR mismatched types\n+}"}, {"sha": "f359dd638ad939095aaf76dd45729cca7fd38085", "filename": "src/test/ui/issues/issue-87490.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d594910a2da12f158477b4c7281716f535cfa3de/src%2Ftest%2Fui%2Fissues%2Fissue-87490.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d594910a2da12f158477b4c7281716f535cfa3de/src%2Ftest%2Fui%2Fissues%2Fissue-87490.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-87490.stderr?ref=d594910a2da12f158477b4c7281716f535cfa3de", "patch": "@@ -0,0 +1,14 @@\n+error[E0308]: mismatched types\n+  --> $DIR/issue-87490.rs:9:5\n+   |\n+LL | fn follow(_: &str) -> <&str as StreamOnce>::Position {\n+   |                       ------------------------------ expected `usize` because of return type\n+LL |     String::new\n+   |     ^^^^^^^^^^^ expected `usize`, found fn item\n+   |\n+   = note: expected type `usize`\n+           found fn item `fn() -> String {String::new}`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "25d2202b909d933b9e27c169c1323c86c15f81ab", "filename": "src/test/ui/mir/mir_const_prop_identity.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d594910a2da12f158477b4c7281716f535cfa3de/src%2Ftest%2Fui%2Fmir%2Fmir_const_prop_identity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d594910a2da12f158477b4c7281716f535cfa3de/src%2Ftest%2Fui%2Fmir%2Fmir_const_prop_identity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmir%2Fmir_const_prop_identity.rs?ref=d594910a2da12f158477b4c7281716f535cfa3de", "patch": "@@ -0,0 +1,12 @@\n+// Regression test for issue #91725.\n+//\n+// run-pass\n+// compile-flags: -Zmir-opt-level=4\n+\n+fn main() {\n+    let a = true;\n+    let _ = &a;\n+    let mut b = false;\n+    b |= a;\n+    assert!(b);\n+}"}, {"sha": "2beed528ff1c1949693fce536a57ec9e8c8e15c5", "filename": "src/test/ui/operator-recovery/less-than-greater-than.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d594910a2da12f158477b4c7281716f535cfa3de/src%2Ftest%2Fui%2Foperator-recovery%2Fless-than-greater-than.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d594910a2da12f158477b4c7281716f535cfa3de/src%2Ftest%2Fui%2Foperator-recovery%2Fless-than-greater-than.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Foperator-recovery%2Fless-than-greater-than.rs?ref=d594910a2da12f158477b4c7281716f535cfa3de", "patch": "@@ -0,0 +1,4 @@\n+fn main() {\n+    println!(\"{}\", 1 <> 2);\n+    //~^ERROR invalid comparison operator `<>`\n+}"}, {"sha": "80c921535bd08ee6cd736451dde85ab36f66fef4", "filename": "src/test/ui/operator-recovery/less-than-greater-than.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d594910a2da12f158477b4c7281716f535cfa3de/src%2Ftest%2Fui%2Foperator-recovery%2Fless-than-greater-than.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d594910a2da12f158477b4c7281716f535cfa3de/src%2Ftest%2Fui%2Foperator-recovery%2Fless-than-greater-than.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Foperator-recovery%2Fless-than-greater-than.stderr?ref=d594910a2da12f158477b4c7281716f535cfa3de", "patch": "@@ -0,0 +1,8 @@\n+error: invalid comparison operator `<>`\n+  --> $DIR/less-than-greater-than.rs:2:22\n+   |\n+LL |     println!(\"{}\", 1 <> 2);\n+   |                      ^^ help: `<>` is not a valid comparison operator, use `!=`\n+\n+error: aborting due to previous error\n+"}, {"sha": "a65f9389625fc74afd0dce74cc40dc32a52a612e", "filename": "src/test/ui/operator-recovery/spaceship.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d594910a2da12f158477b4c7281716f535cfa3de/src%2Ftest%2Fui%2Foperator-recovery%2Fspaceship.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d594910a2da12f158477b4c7281716f535cfa3de/src%2Ftest%2Fui%2Foperator-recovery%2Fspaceship.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Foperator-recovery%2Fspaceship.rs?ref=d594910a2da12f158477b4c7281716f535cfa3de", "patch": "@@ -0,0 +1,4 @@\n+fn main() {\n+    println!(\"{}\", 1 <=> 2);\n+    //~^ERROR invalid comparison operator `<=>`\n+}"}, {"sha": "ed6bd74c9b92edbeaf2797c9ec09c6da74a3ed74", "filename": "src/test/ui/operator-recovery/spaceship.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d594910a2da12f158477b4c7281716f535cfa3de/src%2Ftest%2Fui%2Foperator-recovery%2Fspaceship.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d594910a2da12f158477b4c7281716f535cfa3de/src%2Ftest%2Fui%2Foperator-recovery%2Fspaceship.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Foperator-recovery%2Fspaceship.stderr?ref=d594910a2da12f158477b4c7281716f535cfa3de", "patch": "@@ -0,0 +1,8 @@\n+error: invalid comparison operator `<=>`\n+  --> $DIR/spaceship.rs:2:22\n+   |\n+LL |     println!(\"{}\", 1 <=> 2);\n+   |                      ^^^ `<=>` is not a valid comparison operator, use `std::cmp::Ordering`\n+\n+error: aborting due to previous error\n+"}, {"sha": "40692c8df2053524b9320a81c144d2b040929ecb", "filename": "src/test/ui/suggestions/suggest-add-self.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d594910a2da12f158477b4c7281716f535cfa3de/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-add-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d594910a2da12f158477b4c7281716f535cfa3de/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-add-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-add-self.rs?ref=d594910a2da12f158477b4c7281716f535cfa3de", "patch": "@@ -0,0 +1,15 @@\n+struct X(i32);\n+\n+impl X {\n+    pub(crate) fn f() {\n+        self.0\n+        //~^ ERROR expected value, found module `self`\n+    }\n+\n+    pub fn g() {\n+        self.0\n+        //~^ ERROR expected value, found module `self`\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "a5e8f93deb64a7334a42c98d60d0ebd95363d5d3", "filename": "src/test/ui/suggestions/suggest-add-self.stderr", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/d594910a2da12f158477b4c7281716f535cfa3de/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-add-self.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d594910a2da12f158477b4c7281716f535cfa3de/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-add-self.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-add-self.stderr?ref=d594910a2da12f158477b4c7281716f535cfa3de", "patch": "@@ -0,0 +1,29 @@\n+error[E0424]: expected value, found module `self`\n+  --> $DIR/suggest-add-self.rs:5:9\n+   |\n+LL |     pub(crate) fn f() {\n+   |                   - this function doesn't have a `self` parameter\n+LL |         self.0\n+   |         ^^^^ `self` value is a keyword only available in methods with a `self` parameter\n+   |\n+help: add a `self` receiver parameter to make the associated `fn` a method\n+   |\n+LL |     pub(crate) fn f(&self) {\n+   |                     +++++\n+\n+error[E0424]: expected value, found module `self`\n+  --> $DIR/suggest-add-self.rs:10:9\n+   |\n+LL |     pub fn g() {\n+   |            - this function doesn't have a `self` parameter\n+LL |         self.0\n+   |         ^^^^ `self` value is a keyword only available in methods with a `self` parameter\n+   |\n+help: add a `self` receiver parameter to make the associated `fn` a method\n+   |\n+LL |     pub fn g(&self) {\n+   |              +++++\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0424`."}]}