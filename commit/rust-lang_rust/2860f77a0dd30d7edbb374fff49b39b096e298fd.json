{"sha": "2860f77a0dd30d7edbb374fff49b39b096e298fd", "node_id": "C_kwDOAAsO6NoAKDI4NjBmNzdhMGRkMzBkN2VkYmIzNzRmZmY0OWIzOWIwOTZlMjk4ZmQ", "commit": {"author": {"name": "Josh Stone", "email": "jistone@redhat.com", "date": "2022-09-16T23:18:27Z"}, "committer": {"name": "Josh Stone", "email": "jistone@redhat.com", "date": "2022-09-18T20:25:49Z"}, "message": "Remove support for LLVM's legacy pass manager", "tree": {"sha": "2c53e7ff34a77f1d0d58630d59c4117d44b073b0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2c53e7ff34a77f1d0d58630d59c4117d44b073b0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2860f77a0dd30d7edbb374fff49b39b096e298fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2860f77a0dd30d7edbb374fff49b39b096e298fd", "html_url": "https://github.com/rust-lang/rust/commit/2860f77a0dd30d7edbb374fff49b39b096e298fd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2860f77a0dd30d7edbb374fff49b39b096e298fd/comments", "author": {"login": "cuviper", "id": 36186, "node_id": "MDQ6VXNlcjM2MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/36186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cuviper", "html_url": "https://github.com/cuviper", "followers_url": "https://api.github.com/users/cuviper/followers", "following_url": "https://api.github.com/users/cuviper/following{/other_user}", "gists_url": "https://api.github.com/users/cuviper/gists{/gist_id}", "starred_url": "https://api.github.com/users/cuviper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cuviper/subscriptions", "organizations_url": "https://api.github.com/users/cuviper/orgs", "repos_url": "https://api.github.com/users/cuviper/repos", "events_url": "https://api.github.com/users/cuviper/events{/privacy}", "received_events_url": "https://api.github.com/users/cuviper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cuviper", "id": 36186, "node_id": "MDQ6VXNlcjM2MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/36186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cuviper", "html_url": "https://github.com/cuviper", "followers_url": "https://api.github.com/users/cuviper/followers", "following_url": "https://api.github.com/users/cuviper/following{/other_user}", "gists_url": "https://api.github.com/users/cuviper/gists{/gist_id}", "starred_url": "https://api.github.com/users/cuviper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cuviper/subscriptions", "organizations_url": "https://api.github.com/users/cuviper/orgs", "repos_url": "https://api.github.com/users/cuviper/repos", "events_url": "https://api.github.com/users/cuviper/events{/privacy}", "received_events_url": "https://api.github.com/users/cuviper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a37499ae66ec5fc52a93d71493b78fb141c32f6b", "url": "https://api.github.com/repos/rust-lang/rust/commits/a37499ae66ec5fc52a93d71493b78fb141c32f6b", "html_url": "https://github.com/rust-lang/rust/commit/a37499ae66ec5fc52a93d71493b78fb141c32f6b"}], "stats": {"total": 676, "additions": 23, "deletions": 653}, "files": [{"sha": "90dfaef2a0262d55c2ff361469a35350887a199f", "filename": "Cargo.lock", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2860f77a0dd30d7edbb374fff49b39b096e298fd/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/2860f77a0dd30d7edbb374fff49b39b096e298fd/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=2860f77a0dd30d7edbb374fff49b39b096e298fd", "patch": "@@ -3263,7 +3263,6 @@ dependencies = [\n  \"bitflags\",\n  \"cstr\",\n  \"libc\",\n- \"libloading\",\n  \"measureme\",\n  \"object 0.29.0\",\n  \"rustc-demangle\","}, {"sha": "a068aa2ec6244e5bc1f93e880ac80f9016a0117b", "filename": "compiler/rustc_codegen_llvm/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2860f77a0dd30d7edbb374fff49b39b096e298fd/compiler%2Frustc_codegen_llvm%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/2860f77a0dd30d7edbb374fff49b39b096e298fd/compiler%2Frustc_codegen_llvm%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2FCargo.toml?ref=2860f77a0dd30d7edbb374fff49b39b096e298fd", "patch": "@@ -11,7 +11,6 @@ doctest = false\n bitflags = \"1.0\"\n cstr = \"0.2\"\n libc = \"0.2\"\n-libloading = \"0.7.1\"\n measureme = \"10.0.0\"\n object = { version = \"0.29.0\", default-features = false, features = [\"std\", \"read_core\", \"archive\", \"coff\", \"elf\", \"macho\", \"pe\"] }\n tracing = \"0.1\""}, {"sha": "daf58d7152d606ce4e31bbe67ed4f86107758cfa", "filename": "compiler/rustc_codegen_llvm/src/back/lto.rs", "status": "modified", "additions": 6, "deletions": 60, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/2860f77a0dd30d7edbb374fff49b39b096e298fd/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2860f77a0dd30d7edbb374fff49b39b096e298fd/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs?ref=2860f77a0dd30d7edbb374fff49b39b096e298fd", "patch": "@@ -1,8 +1,6 @@\n-use crate::back::write::{\n-    self, save_temp_bitcode, to_llvm_opt_settings, with_llvm_pmb, DiagnosticHandlers,\n-};\n-use crate::llvm::{self, build_string, False, True};\n-use crate::{llvm_util, LlvmCodegenBackend, ModuleLlvm};\n+use crate::back::write::{self, save_temp_bitcode, DiagnosticHandlers};\n+use crate::llvm::{self, build_string};\n+use crate::{LlvmCodegenBackend, ModuleLlvm};\n use object::read::archive::ArchiveFile;\n use rustc_codegen_ssa::back::lto::{LtoModuleCodegen, SerializedModule, ThinModule, ThinShared};\n use rustc_codegen_ssa::back::symbol_export;\n@@ -597,61 +595,9 @@ pub(crate) fn run_pass_manager(\n                 1,\n             );\n         }\n-        if llvm_util::should_use_new_llvm_pass_manager(\n-            &config.new_llvm_pass_manager,\n-            &cgcx.target_arch,\n-        ) {\n-            let opt_stage = if thin { llvm::OptStage::ThinLTO } else { llvm::OptStage::FatLTO };\n-            let opt_level = config.opt_level.unwrap_or(config::OptLevel::No);\n-            write::optimize_with_new_llvm_pass_manager(\n-                cgcx,\n-                diag_handler,\n-                module,\n-                config,\n-                opt_level,\n-                opt_stage,\n-            )?;\n-            debug!(\"lto done\");\n-            return Ok(());\n-        }\n-\n-        let pm = llvm::LLVMCreatePassManager();\n-        llvm::LLVMAddAnalysisPasses(module.module_llvm.tm, pm);\n-\n-        if config.verify_llvm_ir {\n-            let pass = llvm::LLVMRustFindAndCreatePass(\"verify\\0\".as_ptr().cast());\n-            llvm::LLVMRustAddPass(pm, pass.unwrap());\n-        }\n-\n-        let opt_level = config\n-            .opt_level\n-            .map(|x| to_llvm_opt_settings(x).0)\n-            .unwrap_or(llvm::CodeGenOptLevel::None);\n-        with_llvm_pmb(module.module_llvm.llmod(), config, opt_level, false, &mut |b| {\n-            if thin {\n-                llvm::LLVMRustPassManagerBuilderPopulateThinLTOPassManager(b, pm);\n-            } else {\n-                llvm::LLVMRustPassManagerBuilderPopulateLTOPassManager(\n-                    b, pm, /* Internalize = */ False, /* RunInliner = */ True,\n-                );\n-            }\n-        });\n-\n-        // We always generate bitcode through ThinLTOBuffers,\n-        // which do not support anonymous globals\n-        if config.bitcode_needed() {\n-            let pass = llvm::LLVMRustFindAndCreatePass(\"name-anon-globals\\0\".as_ptr().cast());\n-            llvm::LLVMRustAddPass(pm, pass.unwrap());\n-        }\n-\n-        if config.verify_llvm_ir {\n-            let pass = llvm::LLVMRustFindAndCreatePass(\"verify\\0\".as_ptr().cast());\n-            llvm::LLVMRustAddPass(pm, pass.unwrap());\n-        }\n-\n-        llvm::LLVMRunPassManager(pm, module.module_llvm.llmod());\n-\n-        llvm::LLVMDisposePassManager(pm);\n+        let opt_stage = if thin { llvm::OptStage::ThinLTO } else { llvm::OptStage::FatLTO };\n+        let opt_level = config.opt_level.unwrap_or(config::OptLevel::No);\n+        write::optimize(cgcx, diag_handler, module, config, opt_level, opt_stage)?;\n     }\n     debug!(\"lto done\");\n     Ok(())"}, {"sha": "6280bf6cdc2cf04a5fb2ef5d7a2c05a925f83cd5", "filename": "compiler/rustc_codegen_llvm/src/back/write.rs", "status": "modified", "additions": 12, "deletions": 249, "changes": 261, "blob_url": "https://github.com/rust-lang/rust/blob/2860f77a0dd30d7edbb374fff49b39b096e298fd/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2860f77a0dd30d7edbb374fff49b39b096e298fd/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs?ref=2860f77a0dd30d7edbb374fff49b39b096e298fd", "patch": "@@ -21,7 +21,6 @@ use rustc_data_structures::profiling::SelfProfilerRef;\n use rustc_data_structures::small_c_str::SmallCStr;\n use rustc_errors::{FatalError, Handler, Level};\n use rustc_fs_util::{link_or_copy, path_to_c_string};\n-use rustc_middle::bug;\n use rustc_middle::ty::TyCtxt;\n use rustc_session::config::{self, Lto, OutputType, Passes, SplitDwarfKind, SwitchWithOptPath};\n use rustc_session::Session;\n@@ -417,7 +416,7 @@ fn get_instr_profile_output_path(config: &ModuleConfig) -> Option<CString> {\n     }\n }\n \n-pub(crate) unsafe fn optimize_with_new_llvm_pass_manager(\n+pub(crate) unsafe fn optimize(\n     cgcx: &CodegenContext<LlvmCodegenBackend>,\n     diag_handler: &Handler,\n     module: &ModuleCodegen<ModuleLlvm>,\n@@ -465,7 +464,7 @@ pub(crate) unsafe fn optimize_with_new_llvm_pass_manager(\n     // FIXME: NewPM doesn't provide a facility to pass custom InlineParams.\n     // We would have to add upstream support for this first, before we can support\n     // config.inline_threshold and our more aggressive default thresholds.\n-    let result = llvm::LLVMRustOptimizeWithNewPassManager(\n+    let result = llvm::LLVMRustOptimize(\n         module.module_llvm.llmod(),\n         &*module.module_llvm.tm,\n         to_pass_builder_opt_level(opt_level),\n@@ -499,7 +498,7 @@ pub(crate) unsafe fn optimize_with_new_llvm_pass_manager(\n }\n \n // Unsafe due to LLVM calls.\n-pub(crate) unsafe fn optimize(\n+pub(crate) unsafe fn maybe_optimize(\n     cgcx: &CodegenContext<LlvmCodegenBackend>,\n     diag_handler: &Handler,\n     module: &ModuleCodegen<ModuleLlvm>,\n@@ -509,16 +508,13 @@ pub(crate) unsafe fn optimize(\n \n     let llmod = module.module_llvm.llmod();\n     let llcx = &*module.module_llvm.llcx;\n-    let tm = &*module.module_llvm.tm;\n     let _handlers = DiagnosticHandlers::new(cgcx, diag_handler, llcx);\n \n     let module_name = module.name.clone();\n     let module_name = Some(&module_name[..]);\n \n-    if let Some(false) = config.new_llvm_pass_manager && llvm_util::get_version() >= (15, 0, 0) {\n-        diag_handler.warn(\n-            \"ignoring `-Z new-llvm-pass-manager=no`, which is no longer supported with LLVM 15\",\n-        );\n+    if let Some(false) = config.new_llvm_pass_manager {\n+        diag_handler.warn(\"ignoring `-Z new-llvm-pass-manager=no`, which is no longer supported\");\n     }\n \n     if config.emit_no_opt_bc {\n@@ -528,184 +524,17 @@ pub(crate) unsafe fn optimize(\n     }\n \n     if let Some(opt_level) = config.opt_level {\n-        if llvm_util::should_use_new_llvm_pass_manager(\n-            &config.new_llvm_pass_manager,\n-            &cgcx.target_arch,\n-        ) {\n-            let opt_stage = match cgcx.lto {\n-                Lto::Fat => llvm::OptStage::PreLinkFatLTO,\n-                Lto::Thin | Lto::ThinLocal => llvm::OptStage::PreLinkThinLTO,\n-                _ if cgcx.opts.cg.linker_plugin_lto.enabled() => llvm::OptStage::PreLinkThinLTO,\n-                _ => llvm::OptStage::PreLinkNoLTO,\n-            };\n-            return optimize_with_new_llvm_pass_manager(\n-                cgcx,\n-                diag_handler,\n-                module,\n-                config,\n-                opt_level,\n-                opt_stage,\n-            );\n-        }\n-\n-        if cgcx.prof.llvm_recording_enabled() {\n-            diag_handler\n-                .warn(\"`-Z self-profile-events = llvm` requires `-Z new-llvm-pass-manager`\");\n-        }\n-\n-        // Create the two optimizing pass managers. These mirror what clang\n-        // does, and are by populated by LLVM's default PassManagerBuilder.\n-        // Each manager has a different set of passes, but they also share\n-        // some common passes.\n-        let fpm = llvm::LLVMCreateFunctionPassManagerForModule(llmod);\n-        let mpm = llvm::LLVMCreatePassManager();\n-\n-        {\n-            let find_pass = |pass_name: &str| {\n-                let pass_name = SmallCStr::new(pass_name);\n-                llvm::LLVMRustFindAndCreatePass(pass_name.as_ptr())\n-            };\n-\n-            if config.verify_llvm_ir {\n-                // Verification should run as the very first pass.\n-                llvm::LLVMRustAddPass(fpm, find_pass(\"verify\").unwrap());\n-            }\n-\n-            let mut extra_passes = Vec::new();\n-            let mut have_name_anon_globals_pass = false;\n-\n-            for pass_name in &config.passes {\n-                if pass_name == \"lint\" {\n-                    // Linting should also be performed early, directly on the generated IR.\n-                    llvm::LLVMRustAddPass(fpm, find_pass(\"lint\").unwrap());\n-                    continue;\n-                }\n-\n-                if let Some(pass) = find_pass(pass_name) {\n-                    extra_passes.push(pass);\n-                } else {\n-                    diag_handler.warn(&format!(\"unknown pass `{}`, ignoring\", pass_name));\n-                }\n-\n-                if pass_name == \"name-anon-globals\" {\n-                    have_name_anon_globals_pass = true;\n-                }\n-            }\n-\n-            // Instrumentation must be inserted before optimization,\n-            // otherwise LLVM may optimize some functions away which\n-            // breaks llvm-cov.\n-            //\n-            // This mirrors what Clang does in lib/CodeGen/BackendUtil.cpp.\n-            if config.instrument_gcov {\n-                llvm::LLVMRustAddPass(mpm, find_pass(\"insert-gcov-profiling\").unwrap());\n-            }\n-            if config.instrument_coverage {\n-                llvm::LLVMRustAddPass(mpm, find_pass(\"instrprof\").unwrap());\n-            }\n-            if config.debug_info_for_profiling {\n-                llvm::LLVMRustAddPass(mpm, find_pass(\"add-discriminators\").unwrap());\n-            }\n-\n-            add_sanitizer_passes(config, &mut extra_passes);\n-\n-            // Some options cause LLVM bitcode to be emitted, which uses ThinLTOBuffers, so we need\n-            // to make sure we run LLVM's NameAnonGlobals pass when emitting bitcode; otherwise\n-            // we'll get errors in LLVM.\n-            let using_thin_buffers = config.bitcode_needed();\n-            if !config.no_prepopulate_passes {\n-                llvm::LLVMAddAnalysisPasses(tm, fpm);\n-                llvm::LLVMAddAnalysisPasses(tm, mpm);\n-                let opt_level = to_llvm_opt_settings(opt_level).0;\n-                let prepare_for_thin_lto = cgcx.lto == Lto::Thin\n-                    || cgcx.lto == Lto::ThinLocal\n-                    || (cgcx.lto != Lto::Fat && cgcx.opts.cg.linker_plugin_lto.enabled());\n-                with_llvm_pmb(llmod, config, opt_level, prepare_for_thin_lto, &mut |b| {\n-                    llvm::LLVMRustAddLastExtensionPasses(\n-                        b,\n-                        extra_passes.as_ptr(),\n-                        extra_passes.len() as size_t,\n-                    );\n-                    llvm::LLVMRustPassManagerBuilderPopulateFunctionPassManager(b, fpm);\n-                    llvm::LLVMRustPassManagerBuilderPopulateModulePassManager(b, mpm);\n-                });\n-\n-                have_name_anon_globals_pass = have_name_anon_globals_pass || prepare_for_thin_lto;\n-                if using_thin_buffers && !prepare_for_thin_lto {\n-                    llvm::LLVMRustAddPass(mpm, find_pass(\"name-anon-globals\").unwrap());\n-                    have_name_anon_globals_pass = true;\n-                }\n-            } else {\n-                // If we don't use the standard pipeline, directly populate the MPM\n-                // with the extra passes.\n-                for pass in extra_passes {\n-                    llvm::LLVMRustAddPass(mpm, pass);\n-                }\n-            }\n-\n-            if using_thin_buffers && !have_name_anon_globals_pass {\n-                // As described above, this will probably cause an error in LLVM\n-                if config.no_prepopulate_passes {\n-                    diag_handler.err(\n-                        \"The current compilation is going to use thin LTO buffers \\\n-                                      without running LLVM's NameAnonGlobals pass. \\\n-                                      This will likely cause errors in LLVM. Consider adding \\\n-                                      -C passes=name-anon-globals to the compiler command line.\",\n-                    );\n-                } else {\n-                    bug!(\n-                        \"We are using thin LTO buffers without running the NameAnonGlobals pass. \\\n-                          This will likely cause errors in LLVM and should never happen.\"\n-                    );\n-                }\n-            }\n-        }\n-\n-        diag_handler.abort_if_errors();\n-\n-        // Finally, run the actual optimization passes\n-        {\n-            let _timer = cgcx.prof.extra_verbose_generic_activity(\n-                \"LLVM_module_optimize_function_passes\",\n-                &*module.name,\n-            );\n-            llvm::LLVMRustRunFunctionPassManager(fpm, llmod);\n-        }\n-        {\n-            let _timer = cgcx.prof.extra_verbose_generic_activity(\n-                \"LLVM_module_optimize_module_passes\",\n-                &*module.name,\n-            );\n-            llvm::LLVMRunPassManager(mpm, llmod);\n-        }\n-\n-        // Deallocate managers that we're now done with\n-        llvm::LLVMDisposePassManager(fpm);\n-        llvm::LLVMDisposePassManager(mpm);\n+        let opt_stage = match cgcx.lto {\n+            Lto::Fat => llvm::OptStage::PreLinkFatLTO,\n+            Lto::Thin | Lto::ThinLocal => llvm::OptStage::PreLinkThinLTO,\n+            _ if cgcx.opts.cg.linker_plugin_lto.enabled() => llvm::OptStage::PreLinkThinLTO,\n+            _ => llvm::OptStage::PreLinkNoLTO,\n+        };\n+        return optimize(cgcx, diag_handler, module, config, opt_level, opt_stage);\n     }\n     Ok(())\n }\n \n-unsafe fn add_sanitizer_passes(config: &ModuleConfig, passes: &mut Vec<&'static mut llvm::Pass>) {\n-    if config.sanitizer.contains(SanitizerSet::ADDRESS) {\n-        let recover = config.sanitizer_recover.contains(SanitizerSet::ADDRESS);\n-        passes.push(llvm::LLVMRustCreateAddressSanitizerFunctionPass(recover));\n-        passes.push(llvm::LLVMRustCreateModuleAddressSanitizerPass(recover));\n-    }\n-    if config.sanitizer.contains(SanitizerSet::MEMORY) {\n-        let track_origins = config.sanitizer_memory_track_origins as c_int;\n-        let recover = config.sanitizer_recover.contains(SanitizerSet::MEMORY);\n-        passes.push(llvm::LLVMRustCreateMemorySanitizerPass(track_origins, recover));\n-    }\n-    if config.sanitizer.contains(SanitizerSet::THREAD) {\n-        passes.push(llvm::LLVMRustCreateThreadSanitizerPass());\n-    }\n-    if config.sanitizer.contains(SanitizerSet::HWADDRESS) {\n-        let recover = config.sanitizer_recover.contains(SanitizerSet::HWADDRESS);\n-        passes.push(llvm::LLVMRustCreateHWAddressSanitizerPass(recover));\n-    }\n-}\n-\n pub(crate) fn link(\n     cgcx: &CodegenContext<LlvmCodegenBackend>,\n     diag_handler: &Handler,\n@@ -1072,72 +901,6 @@ unsafe fn embed_bitcode(\n     }\n }\n \n-pub unsafe fn with_llvm_pmb(\n-    llmod: &llvm::Module,\n-    config: &ModuleConfig,\n-    opt_level: llvm::CodeGenOptLevel,\n-    prepare_for_thin_lto: bool,\n-    f: &mut dyn FnMut(&llvm::PassManagerBuilder),\n-) {\n-    use std::ptr;\n-\n-    // Create the PassManagerBuilder for LLVM. We configure it with\n-    // reasonable defaults and prepare it to actually populate the pass\n-    // manager.\n-    let builder = llvm::LLVMRustPassManagerBuilderCreate();\n-    let opt_size = config.opt_size.map_or(llvm::CodeGenOptSizeNone, |x| to_llvm_opt_settings(x).1);\n-    let inline_threshold = config.inline_threshold;\n-    let pgo_gen_path = get_pgo_gen_path(config);\n-    let pgo_use_path = get_pgo_use_path(config);\n-    let pgo_sample_use_path = get_pgo_sample_use_path(config);\n-\n-    llvm::LLVMRustConfigurePassManagerBuilder(\n-        builder,\n-        opt_level,\n-        config.merge_functions,\n-        config.vectorize_slp,\n-        config.vectorize_loop,\n-        prepare_for_thin_lto,\n-        pgo_gen_path.as_ref().map_or(ptr::null(), |s| s.as_ptr()),\n-        pgo_use_path.as_ref().map_or(ptr::null(), |s| s.as_ptr()),\n-        pgo_sample_use_path.as_ref().map_or(ptr::null(), |s| s.as_ptr()),\n-        opt_size as c_int,\n-    );\n-\n-    llvm::LLVMRustAddBuilderLibraryInfo(builder, llmod, config.no_builtins);\n-\n-    // Here we match what clang does (kinda). For O0 we only inline\n-    // always-inline functions (but don't add lifetime intrinsics), at O1 we\n-    // inline with lifetime intrinsics, and O2+ we add an inliner with a\n-    // thresholds copied from clang.\n-    match (opt_level, opt_size, inline_threshold) {\n-        (.., Some(t)) => {\n-            llvm::LLVMRustPassManagerBuilderUseInlinerWithThreshold(builder, t);\n-        }\n-        (llvm::CodeGenOptLevel::Aggressive, ..) => {\n-            llvm::LLVMRustPassManagerBuilderUseInlinerWithThreshold(builder, 275);\n-        }\n-        (_, llvm::CodeGenOptSizeDefault, _) => {\n-            llvm::LLVMRustPassManagerBuilderUseInlinerWithThreshold(builder, 75);\n-        }\n-        (_, llvm::CodeGenOptSizeAggressive, _) => {\n-            llvm::LLVMRustPassManagerBuilderUseInlinerWithThreshold(builder, 25);\n-        }\n-        (llvm::CodeGenOptLevel::None, ..) => {\n-            llvm::LLVMRustAddAlwaysInlinePass(builder, config.emit_lifetime_markers);\n-        }\n-        (llvm::CodeGenOptLevel::Less, ..) => {\n-            llvm::LLVMRustAddAlwaysInlinePass(builder, config.emit_lifetime_markers);\n-        }\n-        (llvm::CodeGenOptLevel::Default, ..) => {\n-            llvm::LLVMRustPassManagerBuilderUseInlinerWithThreshold(builder, 225);\n-        }\n-    }\n-\n-    f(builder);\n-    llvm::LLVMRustPassManagerBuilderDispose(builder);\n-}\n-\n // Create a `__imp_<symbol> = &symbol` global for every public static `symbol`.\n // This is required to satisfy `dllimport` references to static data in .rlibs\n // when using MSVC linker.  We do this only for data, as linker can fix up"}, {"sha": "518f9a45733c12f0c5d574c75d799d3076f8eed7", "filename": "compiler/rustc_codegen_llvm/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2860f77a0dd30d7edbb374fff49b39b096e298fd/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2860f77a0dd30d7edbb374fff49b39b096e298fd/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs?ref=2860f77a0dd30d7edbb374fff49b39b096e298fd", "patch": "@@ -207,7 +207,7 @@ impl WriteBackendMethods for LlvmCodegenBackend {\n         module: &ModuleCodegen<Self::Module>,\n         config: &ModuleConfig,\n     ) -> Result<(), FatalError> {\n-        back::write::optimize(cgcx, diag_handler, module, config)\n+        back::write::maybe_optimize(cgcx, diag_handler, module, config)\n     }\n     fn optimize_fat(\n         cgcx: &CodegenContext<Self>,"}, {"sha": "801650c3fb13da629fc9ddf69227dbdf5ed96e3f", "filename": "compiler/rustc_codegen_llvm/src/llvm/ffi.rs", "status": "modified", "additions": 2, "deletions": 72, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/2860f77a0dd30d7edbb374fff49b39b096e298fd/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2860f77a0dd30d7edbb374fff49b39b096e298fd/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs?ref=2860f77a0dd30d7edbb374fff49b39b096e298fd", "patch": "@@ -1810,18 +1810,9 @@ extern \"C\" {\n     /// Writes a module to the specified path. Returns 0 on success.\n     pub fn LLVMWriteBitcodeToFile(M: &Module, Path: *const c_char) -> c_int;\n \n-    /// Creates a pass manager.\n+    /// Creates a legacy pass manager -- only used for final codegen.\n     pub fn LLVMCreatePassManager<'a>() -> &'a mut PassManager<'a>;\n \n-    /// Creates a function-by-function pass manager\n-    pub fn LLVMCreateFunctionPassManagerForModule(M: &Module) -> &mut PassManager<'_>;\n-\n-    /// Disposes a pass manager.\n-    pub fn LLVMDisposePassManager<'a>(PM: &'a mut PassManager<'a>);\n-\n-    /// Runs a pass manager on a module.\n-    pub fn LLVMRunPassManager<'a>(PM: &PassManager<'a>, M: &'a Module) -> Bool;\n-\n     pub fn LLVMInitializePasses();\n \n     pub fn LLVMTimeTraceProfilerInitialize();\n@@ -1832,32 +1823,6 @@ extern \"C\" {\n \n     pub fn LLVMAddAnalysisPasses<'a>(T: &'a TargetMachine, PM: &PassManager<'a>);\n \n-    pub fn LLVMRustPassManagerBuilderCreate() -> &'static mut PassManagerBuilder;\n-    pub fn LLVMRustPassManagerBuilderDispose(PMB: &'static mut PassManagerBuilder);\n-    pub fn LLVMRustPassManagerBuilderUseInlinerWithThreshold(\n-        PMB: &PassManagerBuilder,\n-        threshold: c_uint,\n-    );\n-    pub fn LLVMRustPassManagerBuilderPopulateModulePassManager(\n-        PMB: &PassManagerBuilder,\n-        PM: &PassManager<'_>,\n-    );\n-\n-    pub fn LLVMRustPassManagerBuilderPopulateFunctionPassManager(\n-        PMB: &PassManagerBuilder,\n-        PM: &PassManager<'_>,\n-    );\n-    pub fn LLVMRustPassManagerBuilderPopulateLTOPassManager(\n-        PMB: &PassManagerBuilder,\n-        PM: &PassManager<'_>,\n-        Internalize: Bool,\n-        RunInliner: Bool,\n-    );\n-    pub fn LLVMRustPassManagerBuilderPopulateThinLTOPassManager(\n-        PMB: &PassManagerBuilder,\n-        PM: &PassManager<'_>,\n-    );\n-\n     pub fn LLVMGetHostCPUFeatures() -> *mut c_char;\n \n     pub fn LLVMDisposeMessage(message: *mut c_char);\n@@ -2262,22 +2227,6 @@ extern \"C\" {\n \n     pub fn LLVMIsAConstantInt(value_ref: &Value) -> Option<&ConstantInt>;\n \n-    pub fn LLVMRustFindAndCreatePass(Pass: *const c_char) -> Option<&'static mut Pass>;\n-    pub fn LLVMRustCreateAddressSanitizerFunctionPass(Recover: bool) -> &'static mut Pass;\n-    pub fn LLVMRustCreateModuleAddressSanitizerPass(Recover: bool) -> &'static mut Pass;\n-    pub fn LLVMRustCreateMemorySanitizerPass(\n-        TrackOrigins: c_int,\n-        Recover: bool,\n-    ) -> &'static mut Pass;\n-    pub fn LLVMRustCreateThreadSanitizerPass() -> &'static mut Pass;\n-    pub fn LLVMRustCreateHWAddressSanitizerPass(Recover: bool) -> &'static mut Pass;\n-    pub fn LLVMRustAddPass(PM: &PassManager<'_>, Pass: &'static mut Pass);\n-    pub fn LLVMRustAddLastExtensionPasses(\n-        PMB: &PassManagerBuilder,\n-        Passes: *const &'static mut Pass,\n-        NumPasses: size_t,\n-    );\n-\n     pub fn LLVMRustHasFeature(T: &TargetMachine, s: *const c_char) -> bool;\n \n     pub fn LLVMRustPrintTargetCPUs(T: &TargetMachine);\n@@ -2311,29 +2260,11 @@ extern \"C\" {\n         SplitDwarfFile: *const c_char,\n     ) -> Option<&'static mut TargetMachine>;\n     pub fn LLVMRustDisposeTargetMachine(T: &'static mut TargetMachine);\n-    pub fn LLVMRustAddBuilderLibraryInfo<'a>(\n-        PMB: &'a PassManagerBuilder,\n-        M: &'a Module,\n-        DisableSimplifyLibCalls: bool,\n-    );\n-    pub fn LLVMRustConfigurePassManagerBuilder(\n-        PMB: &PassManagerBuilder,\n-        OptLevel: CodeGenOptLevel,\n-        MergeFunctions: bool,\n-        SLPVectorize: bool,\n-        LoopVectorize: bool,\n-        PrepareForThinLTO: bool,\n-        PGOGenPath: *const c_char,\n-        PGOUsePath: *const c_char,\n-        PGOSampleUsePath: *const c_char,\n-        SizeLevel: c_int,\n-    );\n     pub fn LLVMRustAddLibraryInfo<'a>(\n         PM: &PassManager<'a>,\n         M: &'a Module,\n         DisableSimplifyLibCalls: bool,\n     );\n-    pub fn LLVMRustRunFunctionPassManager<'a>(PM: &PassManager<'a>, M: &'a Module);\n     pub fn LLVMRustWriteOutputFile<'a>(\n         T: &'a TargetMachine,\n         PM: &PassManager<'a>,\n@@ -2342,7 +2273,7 @@ extern \"C\" {\n         DwoOutput: *const c_char,\n         FileType: FileType,\n     ) -> LLVMRustResult;\n-    pub fn LLVMRustOptimizeWithNewPassManager<'a>(\n+    pub fn LLVMRustOptimize<'a>(\n         M: &'a Module,\n         TM: &'a TargetMachine,\n         OptLevel: PassBuilderOptLevel,\n@@ -2380,7 +2311,6 @@ extern \"C\" {\n     pub fn LLVMRustSetLLVMOptions(Argc: c_int, Argv: *const *const c_char);\n     pub fn LLVMRustPrintPasses();\n     pub fn LLVMRustSetNormalizedTarget(M: &Module, triple: *const c_char);\n-    pub fn LLVMRustAddAlwaysInlinePass(P: &PassManagerBuilder, AddLifetimes: bool);\n     pub fn LLVMRustRunRestrictionPass(M: &Module, syms: *const *const c_char, len: size_t);\n \n     pub fn LLVMRustOpenArchive(path: *const c_char) -> Option<&'static mut Archive>;"}, {"sha": "2fd58567c487406d6864849027ddd03ca44ccf07", "filename": "compiler/rustc_codegen_llvm/src/llvm_util.rs", "status": "modified", "additions": 1, "deletions": 35, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/2860f77a0dd30d7edbb374fff49b39b096e298fd/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2860f77a0dd30d7edbb374fff49b39b096e298fd/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs?ref=2860f77a0dd30d7edbb374fff49b39b096e298fd", "patch": "@@ -1,7 +1,6 @@\n use crate::back::write::create_informational_target_machine;\n-use crate::{llvm, llvm_util};\n+use crate::llvm;\n use libc::c_int;\n-use libloading::Library;\n use rustc_codegen_ssa::target_features::{\n     supported_target_features, tied_target_features, RUSTC_SPECIFIC_FEATURES,\n };\n@@ -16,7 +15,6 @@ use rustc_target::spec::{MergeFunctions, PanicStrategy};\n use smallvec::{smallvec, SmallVec};\n use std::ffi::{CStr, CString};\n \n-use std::mem;\n use std::path::Path;\n use std::ptr;\n use std::slice;\n@@ -120,22 +118,6 @@ unsafe fn configure_llvm(sess: &Session) {\n \n     llvm::LLVMInitializePasses();\n \n-    // Use the legacy plugin registration if we don't use the new pass manager\n-    if !should_use_new_llvm_pass_manager(\n-        &sess.opts.unstable_opts.new_llvm_pass_manager,\n-        &sess.target.arch,\n-    ) {\n-        // Register LLVM plugins by loading them into the compiler process.\n-        for plugin in &sess.opts.unstable_opts.llvm_plugins {\n-            let lib = Library::new(plugin).unwrap_or_else(|e| bug!(\"couldn't load plugin: {}\", e));\n-            debug!(\"LLVM plugin loaded successfully {:?} ({})\", lib, plugin);\n-\n-            // Intentionally leak the dynamic library. We can't ever unload it\n-            // since the library can make things that will live arbitrarily long.\n-            mem::forget(lib);\n-        }\n-    }\n-\n     rustc_llvm::initialize_available_targets();\n \n     llvm::LLVMRustSetLLVMOptions(llvm_args.len() as c_int, llvm_args.as_ptr());\n@@ -539,19 +521,3 @@ pub fn tune_cpu(sess: &Session) -> Option<&str> {\n     let name = sess.opts.unstable_opts.tune_cpu.as_ref()?;\n     Some(handle_native(name))\n }\n-\n-pub(crate) fn should_use_new_llvm_pass_manager(user_opt: &Option<bool>, target_arch: &str) -> bool {\n-    // The new pass manager is enabled by default for LLVM >= 13.\n-    // This matches Clang, which also enables it since Clang 13.\n-\n-    // Since LLVM 15, the legacy pass manager is no longer supported.\n-    if llvm_util::get_version() >= (15, 0, 0) {\n-        return true;\n-    }\n-\n-    // There are some perf issues with the new pass manager when targeting\n-    // s390x with LLVM 13, so enable the new pass manager only with LLVM 14.\n-    // See https://github.com/rust-lang/rust/issues/89609.\n-    let min_version = if target_arch == \"s390x\" { 14 } else { 13 };\n-    user_opt.unwrap_or_else(|| llvm_util::get_version() >= (min_version, 0, 0))\n-}"}, {"sha": "4cfdd31973c582697058e0065ad14f7757d9f9db", "filename": "compiler/rustc_llvm/llvm-wrapper/PassWrapper.cpp", "status": "modified", "additions": 1, "deletions": 234, "changes": 235, "blob_url": "https://github.com/rust-lang/rust/blob/2860f77a0dd30d7edbb374fff49b39b096e298fd/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/2860f77a0dd30d7edbb374fff49b39b096e298fd/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp?ref=2860f77a0dd30d7edbb374fff49b39b096e298fd", "patch": "@@ -93,172 +93,6 @@ extern \"C\" void LLVMTimeTraceProfilerFinish(const char* FileName) {\n   timeTraceProfilerCleanup();\n }\n \n-extern \"C\" LLVMPassRef LLVMRustFindAndCreatePass(const char *PassName) {\n-#if LLVM_VERSION_LT(15, 0)\n-  StringRef SR(PassName);\n-  PassRegistry *PR = PassRegistry::getPassRegistry();\n-\n-  const PassInfo *PI = PR->getPassInfo(SR);\n-  if (PI) {\n-    return wrap(PI->createPass());\n-  }\n-  return nullptr;\n-#else\n-  report_fatal_error(\"Legacy PM not supported with LLVM 15\");\n-#endif\n-}\n-\n-extern \"C\" LLVMPassRef LLVMRustCreateAddressSanitizerFunctionPass(bool Recover) {\n-#if LLVM_VERSION_LT(15, 0)\n-  const bool CompileKernel = false;\n-  const bool UseAfterScope = true;\n-\n-  return wrap(createAddressSanitizerFunctionPass(CompileKernel, Recover, UseAfterScope));\n-#else\n-  report_fatal_error(\"Legacy PM not supported with LLVM 15\");\n-#endif\n-}\n-\n-extern \"C\" LLVMPassRef LLVMRustCreateModuleAddressSanitizerPass(bool Recover) {\n-#if LLVM_VERSION_LT(15, 0)\n-  const bool CompileKernel = false;\n-\n-  return wrap(createModuleAddressSanitizerLegacyPassPass(CompileKernel, Recover));\n-#else\n-  report_fatal_error(\"Legacy PM not supported with LLVM 15\");\n-#endif\n-}\n-\n-extern \"C\" LLVMPassRef LLVMRustCreateMemorySanitizerPass(int TrackOrigins, bool Recover) {\n-#if LLVM_VERSION_LT(15, 0)\n-  const bool CompileKernel = false;\n-\n-  return wrap(createMemorySanitizerLegacyPassPass(\n-#if LLVM_VERSION_GE(14, 0)\n-      MemorySanitizerOptions{TrackOrigins, Recover, CompileKernel, /*EagerChecks=*/true}\n-#else\n-      MemorySanitizerOptions{TrackOrigins, Recover, CompileKernel}\n-#endif\n-  ));\n-#else\n-  report_fatal_error(\"Legacy PM not supported with LLVM 15\");\n-#endif\n-}\n-\n-extern \"C\" LLVMPassRef LLVMRustCreateThreadSanitizerPass() {\n-#if LLVM_VERSION_LT(15, 0)\n-  return wrap(createThreadSanitizerLegacyPassPass());\n-#else\n-  report_fatal_error(\"Legacy PM not supported with LLVM 15\");\n-#endif\n-}\n-\n-extern \"C\" LLVMPassRef LLVMRustCreateHWAddressSanitizerPass(bool Recover) {\n-#if LLVM_VERSION_LT(15, 0)\n-  const bool CompileKernel = false;\n-\n-  return wrap(createHWAddressSanitizerLegacyPassPass(CompileKernel, Recover));\n-#else\n-  report_fatal_error(\"Legacy PM not supported with LLVM 15\");\n-#endif\n-}\n-\n-extern \"C\" void LLVMRustAddPass(LLVMPassManagerRef PMR, LLVMPassRef RustPass) {\n-#if LLVM_VERSION_LT(15, 0)\n-  assert(RustPass);\n-  Pass *Pass = unwrap(RustPass);\n-  PassManagerBase *PMB = unwrap(PMR);\n-  PMB->add(Pass);\n-#else\n-  report_fatal_error(\"Legacy PM not supported with LLVM 15\");\n-#endif\n-}\n-\n-extern \"C\" LLVMPassManagerBuilderRef LLVMRustPassManagerBuilderCreate() {\n-#if LLVM_VERSION_LT(15, 0)\n-  return LLVMPassManagerBuilderCreate();\n-#else\n-  report_fatal_error(\"Legacy PM not supported with LLVM 15\");\n-#endif\n-}\n-\n-extern \"C\" void LLVMRustPassManagerBuilderDispose(LLVMPassManagerBuilderRef PMB) {\n-#if LLVM_VERSION_LT(15, 0)\n-  LLVMPassManagerBuilderDispose(PMB);\n-#else\n-  report_fatal_error(\"Legacy PM not supported with LLVM 15\");\n-#endif\n-}\n-\n-extern \"C\" void LLVMRustPassManagerBuilderPopulateFunctionPassManager(\n-  LLVMPassManagerBuilderRef PMB, LLVMPassManagerRef PM) {\n-#if LLVM_VERSION_LT(15, 0)\n-  LLVMPassManagerBuilderPopulateFunctionPassManager(PMB, PM);\n-#else\n-  report_fatal_error(\"Legacy PM not supported with LLVM 15\");\n-#endif\n-}\n-\n-extern \"C\" void LLVMRustPassManagerBuilderPopulateModulePassManager(\n-  LLVMPassManagerBuilderRef PMB, LLVMPassManagerRef PM) {\n-#if LLVM_VERSION_LT(15, 0)\n-  LLVMPassManagerBuilderPopulateModulePassManager(PMB, PM);\n-#else\n-  report_fatal_error(\"Legacy PM not supported with LLVM 15\");\n-#endif\n-}\n-\n-extern \"C\" void LLVMRustPassManagerBuilderPopulateLTOPassManager(\n-  LLVMPassManagerBuilderRef PMB, LLVMPassManagerRef PM, bool Internalize, bool RunInliner) {\n-#if LLVM_VERSION_LT(15, 0)\n-  LLVMPassManagerBuilderPopulateLTOPassManager(PMB, PM, Internalize, RunInliner);\n-#else\n-  report_fatal_error(\"Legacy PM not supported with LLVM 15\");\n-#endif\n-}\n-\n-extern \"C\"\n-void LLVMRustPassManagerBuilderPopulateThinLTOPassManager(\n-  LLVMPassManagerBuilderRef PMBR,\n-  LLVMPassManagerRef PMR\n-) {\n-#if LLVM_VERSION_LT(15, 0)\n-  unwrap(PMBR)->populateThinLTOPassManager(*unwrap(PMR));\n-#else\n-  report_fatal_error(\"Legacy PM not supported with LLVM 15\");\n-#endif\n-}\n-\n-extern \"C\" void LLVMRustPassManagerBuilderUseInlinerWithThreshold(\n-  LLVMPassManagerBuilderRef PMB, unsigned Threshold) {\n-#if LLVM_VERSION_LT(15, 0)\n-  LLVMPassManagerBuilderUseInlinerWithThreshold(PMB, Threshold);\n-#else\n-  report_fatal_error(\"Legacy PM not supported with LLVM 15\");\n-#endif\n-}\n-\n-extern \"C\"\n-void LLVMRustAddLastExtensionPasses(\n-    LLVMPassManagerBuilderRef PMBR, LLVMPassRef *Passes, size_t NumPasses) {\n-#if LLVM_VERSION_LT(15, 0)\n-  auto AddExtensionPasses = [Passes, NumPasses](\n-      const PassManagerBuilder &Builder, PassManagerBase &PM) {\n-    for (size_t I = 0; I < NumPasses; I++) {\n-      PM.add(unwrap(Passes[I]));\n-    }\n-  };\n-  // Add the passes to both of the pre-finalization extension points,\n-  // so they are run for optimized and non-optimized builds.\n-  unwrap(PMBR)->addExtension(PassManagerBuilder::EP_OptimizerLast,\n-                             AddExtensionPasses);\n-  unwrap(PMBR)->addExtension(PassManagerBuilder::EP_EnabledOnOptLevel0,\n-                             AddExtensionPasses);\n-#else\n-  report_fatal_error(\"Legacy PM not supported with LLVM 15\");\n-#endif\n-}\n-\n #ifdef LLVM_COMPONENT_X86\n #define SUBTARGET_X86 SUBTARGET(X86)\n #else\n@@ -604,47 +438,6 @@ extern \"C\" void LLVMRustDisposeTargetMachine(LLVMTargetMachineRef TM) {\n   delete unwrap(TM);\n }\n \n-extern \"C\" void LLVMRustConfigurePassManagerBuilder(\n-    LLVMPassManagerBuilderRef PMBR, LLVMRustCodeGenOptLevel OptLevel,\n-    bool MergeFunctions, bool SLPVectorize, bool LoopVectorize, bool PrepareForThinLTO,\n-    const char* PGOGenPath, const char* PGOUsePath, const char* PGOSampleUsePath,\n-    int SizeLevel) {\n-#if LLVM_VERSION_LT(15, 0)\n-  unwrap(PMBR)->MergeFunctions = MergeFunctions;\n-  unwrap(PMBR)->SLPVectorize = SLPVectorize;\n-  unwrap(PMBR)->OptLevel = fromRust(OptLevel);\n-  unwrap(PMBR)->LoopVectorize = LoopVectorize;\n-  unwrap(PMBR)->PrepareForThinLTO = PrepareForThinLTO;\n-  unwrap(PMBR)->SizeLevel = SizeLevel;\n-  unwrap(PMBR)->DisableUnrollLoops = SizeLevel != 0;\n-\n-  if (PGOGenPath) {\n-    assert(!PGOUsePath && !PGOSampleUsePath);\n-    unwrap(PMBR)->EnablePGOInstrGen = true;\n-    unwrap(PMBR)->PGOInstrGen = PGOGenPath;\n-  } else if (PGOUsePath) {\n-    assert(!PGOSampleUsePath);\n-    unwrap(PMBR)->PGOInstrUse = PGOUsePath;\n-  } else if (PGOSampleUsePath) {\n-    unwrap(PMBR)->PGOSampleUse = PGOSampleUsePath;\n-  }\n-#else\n-  report_fatal_error(\"Legacy PM not supported with LLVM 15\");\n-#endif\n-}\n-\n-// Unfortunately, the LLVM C API doesn't provide a way to set the `LibraryInfo`\n-// field of a PassManagerBuilder, we expose our own method of doing so.\n-extern \"C\" void LLVMRustAddBuilderLibraryInfo(LLVMPassManagerBuilderRef PMBR,\n-                                              LLVMModuleRef M,\n-                                              bool DisableSimplifyLibCalls) {\n-  Triple TargetTriple(unwrap(M)->getTargetTriple());\n-  TargetLibraryInfoImpl *TLI = new TargetLibraryInfoImpl(TargetTriple);\n-  if (DisableSimplifyLibCalls)\n-    TLI->disableAllFunctions();\n-  unwrap(PMBR)->LibraryInfo = TLI;\n-}\n-\n // Unfortunately, the LLVM C API doesn't provide a way to create the\n // TargetLibraryInfo pass, so we use this method to do so.\n extern \"C\" void LLVMRustAddLibraryInfo(LLVMPassManagerRef PMR, LLVMModuleRef M,\n@@ -656,27 +449,6 @@ extern \"C\" void LLVMRustAddLibraryInfo(LLVMPassManagerRef PMR, LLVMModuleRef M,\n   unwrap(PMR)->add(new TargetLibraryInfoWrapperPass(TLII));\n }\n \n-// Unfortunately, the LLVM C API doesn't provide an easy way of iterating over\n-// all the functions in a module, so we do that manually here. You'll find\n-// similar code in clang's BackendUtil.cpp file.\n-extern \"C\" void LLVMRustRunFunctionPassManager(LLVMPassManagerRef PMR,\n-                                               LLVMModuleRef M) {\n-  llvm::legacy::FunctionPassManager *P =\n-      unwrap<llvm::legacy::FunctionPassManager>(PMR);\n-  P->doInitialization();\n-\n-  // Upgrade all calls to old intrinsics first.\n-  for (Module::iterator I = unwrap(M)->begin(), E = unwrap(M)->end(); I != E;)\n-    UpgradeCallsToIntrinsic(&*I++); // must be post-increment, as we remove\n-\n-  for (Module::iterator I = unwrap(M)->begin(), E = unwrap(M)->end(); I != E;\n-       ++I)\n-    if (!I->isDeclaration())\n-      P->run(*I);\n-\n-  P->doFinalization();\n-}\n-\n extern \"C\" void LLVMRustSetLLVMOptions(int Argc, char **Argv) {\n   // Initializing the command-line options more than once is not allowed. So,\n   // check if they've already been initialized.  (This could happen if we're\n@@ -820,7 +592,7 @@ struct LLVMRustSanitizerOptions {\n };\n \n extern \"C\" LLVMRustResult\n-LLVMRustOptimizeWithNewPassManager(\n+LLVMRustOptimize(\n     LLVMModuleRef ModuleRef,\n     LLVMTargetMachineRef TMRef,\n     LLVMRustPassBuilderOptLevel OptLevelRust,\n@@ -1241,11 +1013,6 @@ extern \"C\" void LLVMRustPrintPasses() {\n   PR->enumerateWith(&Listener);\n }\n \n-extern \"C\" void LLVMRustAddAlwaysInlinePass(LLVMPassManagerBuilderRef PMBR,\n-                                            bool AddLifetimes) {\n-  unwrap(PMBR)->Inliner = llvm::createAlwaysInlinerLegacyPass(AddLifetimes);\n-}\n-\n extern \"C\" void LLVMRustRunRestrictionPass(LLVMModuleRef M, char **Symbols,\n                                            size_t Len) {\n   llvm::legacy::PassManager passes;"}]}