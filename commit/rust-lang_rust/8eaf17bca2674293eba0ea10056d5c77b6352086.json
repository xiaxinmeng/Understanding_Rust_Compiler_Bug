{"sha": "8eaf17bca2674293eba0ea10056d5c77b6352086", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhlYWYxN2JjYTI2NzQyOTNlYmEwZWExMDA1NmQ1Yzc3YjYzNTIwODY=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-06-20T08:52:31Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-07-26T10:09:54Z"}, "message": "Introduce built-in macros through libcore", "tree": {"sha": "a726739d50e26b0142be28425b154446f43e4fe5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a726739d50e26b0142be28425b154446f43e4fe5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8eaf17bca2674293eba0ea10056d5c77b6352086", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8eaf17bca2674293eba0ea10056d5c77b6352086", "html_url": "https://github.com/rust-lang/rust/commit/8eaf17bca2674293eba0ea10056d5c77b6352086", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8eaf17bca2674293eba0ea10056d5c77b6352086/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4268e7ee22935f086b856ef0063a9e22b49aeddb", "url": "https://api.github.com/repos/rust-lang/rust/commits/4268e7ee22935f086b856ef0063a9e22b49aeddb", "html_url": "https://github.com/rust-lang/rust/commit/4268e7ee22935f086b856ef0063a9e22b49aeddb"}], "stats": {"total": 1468, "additions": 499, "deletions": 969}, "files": [{"sha": "218c164a7dc35bbfe00625202aaa13795578956b", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8eaf17bca2674293eba0ea10056d5c77b6352086/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eaf17bca2674293eba0ea10056d5c77b6352086/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=8eaf17bca2674293eba0ea10056d5c77b6352086", "patch": "@@ -657,13 +657,13 @@ macro_rules! uninit_array {\n     );\n }\n \n-/// Built-in macros to the compiler itself.\n+/// Definitions of built-in macros.\n ///\n-/// These macros do not have any corresponding definition with a `macro_rules!`\n-/// macro, but are documented here. Their implementations can be found hardcoded\n-/// into libsyntax itself.\n-#[cfg(rustdoc)]\n-mod builtin {\n+/// Most of the macro properties (stability, visibility, etc.) are taken from the source code here,\n+/// with exception of expansion functions transforming macro inputs into outputs,\n+/// those functions are provided by the compiler.\n+#[cfg(not(bootstrap))]\n+pub(crate) mod builtin {\n \n     /// Causes compilation to fail with the given error message when encountered.\n     ///\n@@ -950,7 +950,7 @@ mod builtin {\n \n     /// Same as `column`, but less likely to be shadowed.\n     #[unstable(feature = \"__rust_unstable_column\", issue = \"0\",\n-               reason = \"internal implementation detail of the `column` macro\")]\n+               reason = \"internal implementation detail of the `panic` macro\")]\n     #[rustc_builtin_macro]\n     #[rustc_macro_transparency = \"semitransparent\"]\n     pub macro __rust_unstable_column() { /* compiler built-in */ }"}, {"sha": "de79e2fa260cede4de320f948655411a79476d01", "filename": "src/libcore/prelude/v1.rs", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/8eaf17bca2674293eba0ea10056d5c77b6352086/src%2Flibcore%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eaf17bca2674293eba0ea10056d5c77b6352086/src%2Flibcore%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude%2Fv1.rs?ref=8eaf17bca2674293eba0ea10056d5c77b6352086", "patch": "@@ -44,3 +44,50 @@ pub use crate::option::Option::{self, Some, None};\n #[stable(feature = \"core_prelude\", since = \"1.4.0\")]\n #[doc(no_inline)]\n pub use crate::result::Result::{self, Ok, Err};\n+\n+// Re-exported built-in macros\n+#[cfg(not(bootstrap))]\n+#[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n+#[allow(deprecated)]\n+#[doc(no_inline)]\n+pub use crate::macros::builtin::{\n+    Clone,\n+    Copy,\n+    Debug,\n+    Decodable,\n+    Default,\n+    Encodable,\n+    Eq,\n+    Hash,\n+    Ord,\n+    PartialEq,\n+    PartialOrd,\n+    RustcDecodable,\n+    RustcEncodable,\n+    __rust_unstable_column,\n+    asm,\n+    assert,\n+    bench,\n+    cfg,\n+    column,\n+    compile_error,\n+    concat,\n+    concat_idents,\n+    env,\n+    file,\n+    format_args,\n+    format_args_nl,\n+    global_allocator,\n+    global_asm,\n+    include,\n+    include_bytes,\n+    include_str,\n+    line,\n+    log_syntax,\n+    module_path,\n+    option_env,\n+    stringify,\n+    test,\n+    test_case,\n+    trace_macros,\n+};"}, {"sha": "65e293642874c3ba730e67484a0c1fd474618f79", "filename": "src/libcore/task/wake.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8eaf17bca2674293eba0ea10056d5c77b6352086/src%2Flibcore%2Ftask%2Fwake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eaf17bca2674293eba0ea10056d5c77b6352086/src%2Flibcore%2Ftask%2Fwake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fwake.rs?ref=8eaf17bca2674293eba0ea10056d5c77b6352086", "patch": "@@ -217,7 +217,7 @@ impl fmt::Debug for Context<'_> {\n /// This handle encapsulates a [`RawWaker`] instance, which defines the\n /// executor-specific wakeup behavior.\n ///\n-/// Implements [`Clone`], [`Send`], and [`Sync`].\n+/// Implements [`Clone`], [`trait@Send`], and [`trait@Sync`].\n ///\n /// [`RawWaker`]: struct.RawWaker.html\n #[repr(transparent)]"}, {"sha": "c0a661908a6547e549c2a7101c9d5c1f36e90430", "filename": "src/librustc/hir/def_id.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8eaf17bca2674293eba0ea10056d5c77b6352086/src%2Flibrustc%2Fhir%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eaf17bca2674293eba0ea10056d5c77b6352086/src%2Flibrustc%2Fhir%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef_id.rs?ref=8eaf17bca2674293eba0ea10056d5c77b6352086", "patch": "@@ -12,10 +12,6 @@ newtype_index! {\n \n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub enum CrateNum {\n-    /// Virtual crate for builtin macros\n-    // FIXME(jseyfried): this is also used for custom derives until proc-macro crates get\n-    // `CrateNum`s.\n-    BuiltinMacros,\n     /// A special CrateNum that we use for the tcx.rcache when decoding from\n     /// the incr. comp. cache.\n     ReservedForIncrCompCache,\n@@ -26,7 +22,6 @@ impl ::std::fmt::Debug for CrateNum {\n     fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {\n         match self {\n             CrateNum::Index(id) => write!(fmt, \"crate{}\", id.private),\n-            CrateNum::BuiltinMacros => write!(fmt, \"builtin macros crate\"),\n             CrateNum::ReservedForIncrCompCache => write!(fmt, \"crate for decoding incr comp cache\"),\n         }\n     }\n@@ -86,7 +81,6 @@ impl fmt::Display for CrateNum {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self {\n             CrateNum::Index(id) => fmt::Display::fmt(&id.private, f),\n-            CrateNum::BuiltinMacros => write!(f, \"builtin macros crate\"),\n             CrateNum::ReservedForIncrCompCache => write!(f, \"crate for decoding incr comp cache\"),\n         }\n     }"}, {"sha": "2d1835514d425e95d3152168bd7d8bf8c2e20023", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8eaf17bca2674293eba0ea10056d5c77b6352086/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eaf17bca2674293eba0ea10056d5c77b6352086/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=8eaf17bca2674293eba0ea10056d5c77b6352086", "patch": "@@ -4009,8 +4009,7 @@ impl<'a> LoweringContext<'a> {\n         let mut vis = self.lower_visibility(&i.vis, None);\n         let attrs = self.lower_attrs(&i.attrs);\n         if let ItemKind::MacroDef(ref def) = i.node {\n-            if !def.legacy || attr::contains_name(&i.attrs, sym::macro_export) ||\n-                              attr::contains_name(&i.attrs, sym::rustc_builtin_macro) {\n+            if !def.legacy || attr::contains_name(&i.attrs, sym::macro_export) {\n                 let body = self.lower_token_stream(def.stream());\n                 let hir_id = self.lower_node_id(i.id);\n                 self.exported_macros.push(hir::MacroDef {"}, {"sha": "2754c55ea06853d25c9aa037c4b2e4a3b3f01f43", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8eaf17bca2674293eba0ea10056d5c77b6352086/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eaf17bca2674293eba0ea10056d5c77b6352086/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=8eaf17bca2674293eba0ea10056d5c77b6352086", "patch": "@@ -372,7 +372,10 @@ fn configure_and_expand_inner<'a>(\n         crate_loader,\n         &resolver_arenas,\n     );\n-    syntax_ext::register_builtins(&mut resolver, plugin_info.syntax_exts, sess.edition());\n+    syntax_ext::register_builtin_macros(&mut resolver, sess.edition());\n+    syntax_ext::plugin_macro_defs::inject(\n+        &mut krate, &mut resolver, plugin_info.syntax_exts, sess.edition()\n+    );\n \n     // Expand all macros\n     sess.profiler(|p| p.start_activity(\"macro expansion\"));"}, {"sha": "f52f7d9cfb3c307b88822e45611905956dc4df0d", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/8eaf17bca2674293eba0ea10056d5c77b6352086/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eaf17bca2674293eba0ea10056d5c77b6352086/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=8eaf17bca2674293eba0ea10056d5c77b6352086", "patch": "@@ -13,7 +13,7 @@ use crate::{resolve_error, resolve_struct_error, ResolutionError, Determinacy};\n \n use rustc::bug;\n use rustc::hir::def::{self, *};\n-use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX, LOCAL_CRATE, DefId};\n+use rustc::hir::def_id::{CRATE_DEF_INDEX, LOCAL_CRATE, DefId};\n use rustc::ty;\n use rustc::middle::cstore::CrateStore;\n use rustc_metadata::cstore::LoadedMacro;\n@@ -31,7 +31,6 @@ use syntax::ast::{self, Block, ForeignItem, ForeignItemKind, Item, ItemKind, Nod\n use syntax::ast::{MetaItemKind, StmtKind, TraitItem, TraitItemKind, Variant};\n use syntax::ext::base::SyntaxExtension;\n use syntax::ext::hygiene::ExpnId;\n-use syntax::ext::tt::macro_rules;\n use syntax::feature_gate::is_builtin_attr;\n use syntax::parse::token::{self, Token};\n use syntax::span_err;\n@@ -748,21 +747,24 @@ impl<'a> Resolver<'a> {\n         };\n         if let Some(id) = self.definitions.as_local_node_id(def_id) {\n             self.local_macro_def_scopes[&id]\n-        } else if def_id.krate == CrateNum::BuiltinMacros {\n+        } else if self.is_builtin_macro(Some(def_id)) {\n             self.injected_crate.unwrap_or(self.graph_root)\n         } else {\n             let module_def_id = ty::DefIdTree::parent(&*self, def_id).unwrap();\n             self.get_module(module_def_id)\n         }\n     }\n \n-    pub fn get_macro(&mut self, res: Res) -> Option<Lrc<SyntaxExtension>> {\n-        let def_id = match res {\n-            Res::Def(DefKind::Macro(..), def_id) => def_id,\n+    crate fn get_macro(&mut self, res: Res) -> Option<Lrc<SyntaxExtension>> {\n+        match res {\n+            Res::Def(DefKind::Macro(..), def_id) => self.get_macro_by_def_id(def_id),\n             Res::NonMacroAttr(attr_kind) =>\n-                return Some(self.non_macro_attr(attr_kind == NonMacroAttrKind::Tool)),\n-            _ => return None,\n-        };\n+                Some(self.non_macro_attr(attr_kind == NonMacroAttrKind::Tool)),\n+            _ => None,\n+        }\n+    }\n+\n+    crate fn get_macro_by_def_id(&mut self, def_id: DefId) -> Option<Lrc<SyntaxExtension>> {\n         if let Some(ext) = self.macro_map.get(&def_id) {\n             return Some(ext.clone());\n         }\n@@ -772,10 +774,7 @@ impl<'a> Resolver<'a> {\n             LoadedMacro::ProcMacro(ext) => return Some(ext),\n         };\n \n-        let ext = Lrc::new(macro_rules::compile(&self.session.parse_sess,\n-                                               &self.session.features_untracked(),\n-                                               &macro_def,\n-                                               self.cstore.crate_edition_untracked(def_id.krate)));\n+        let ext = self.compile_macro(&macro_def, self.cstore.crate_edition_untracked(def_id.krate));\n         self.macro_map.insert(def_id, ext.clone());\n         Some(ext)\n     }"}, {"sha": "aeb6f23da5aa628093fd3b11bdc0fae8f117109f", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 12, "deletions": 25, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/8eaf17bca2674293eba0ea10056d5c77b6352086/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eaf17bca2674293eba0ea10056d5c77b6352086/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=8eaf17bca2674293eba0ea10056d5c77b6352086", "patch": "@@ -35,17 +35,12 @@ enum AssocSuggestion {\n \n struct TypoSuggestion {\n     candidate: Symbol,\n-\n-    /// The kind of the binding (\"crate\", \"module\", etc.)\n-    kind: &'static str,\n-\n-    /// An appropriate article to refer to the binding (\"a\", \"an\", etc.)\n-    article: &'static str,\n+    res: Res,\n }\n \n impl TypoSuggestion {\n     fn from_res(candidate: Symbol, res: Res) -> TypoSuggestion {\n-        TypoSuggestion { candidate, kind: res.descr(), article: res.article() }\n+        TypoSuggestion { candidate, res }\n     }\n }\n \n@@ -59,7 +54,9 @@ fn add_typo_suggestion(\n     err: &mut DiagnosticBuilder<'_>, suggestion: Option<TypoSuggestion>, span: Span\n ) -> bool {\n     if let Some(suggestion) = suggestion {\n-        let msg = format!(\"{} {} with a similar name exists\", suggestion.article, suggestion.kind);\n+        let msg = format!(\n+            \"{} {} with a similar name exists\", suggestion.res.article(), suggestion.res.descr()\n+        );\n         err.span_suggestion(\n             span, &msg, suggestion.candidate.to_string(), Applicability::MaybeIncorrect\n         );\n@@ -566,7 +563,7 @@ impl<'a> Resolver<'a> {\n         filter_fn: &impl Fn(Res) -> bool,\n     ) -> Option<TypoSuggestion> {\n         let mut suggestions = Vec::new();\n-        self.visit_scopes(scope_set, parent_scope, ident, |this, scope, _| {\n+        self.visit_scopes(scope_set, parent_scope, ident, |this, scope, use_prelude, _| {\n             match scope {\n                 Scope::DeriveHelpers => {\n                     let res = Res::NonMacroAttr(NonMacroAttrKind::DeriveHelper);\n@@ -611,16 +608,6 @@ impl<'a> Resolver<'a> {\n                         }\n                     }));\n                 }\n-                Scope::BuiltinMacros => {\n-                    suggestions.extend(this.builtin_macros.iter().filter_map(|(name, binding)| {\n-                        let res = binding.res();\n-                        if filter_fn(res) {\n-                            Some(TypoSuggestion::from_res(*name, res))\n-                        } else {\n-                            None\n-                        }\n-                    }));\n-                }\n                 Scope::BuiltinAttrs => {\n                     let res = Res::NonMacroAttr(NonMacroAttrKind::Builtin);\n                     if filter_fn(res) {\n@@ -656,7 +643,11 @@ impl<'a> Resolver<'a> {\n                 }\n                 Scope::StdLibPrelude => {\n                     if let Some(prelude) = this.prelude {\n-                        add_module_candidates(prelude, &mut suggestions, filter_fn);\n+                        let mut tmp_suggestions = Vec::new();\n+                        add_module_candidates(prelude, &mut tmp_suggestions, filter_fn);\n+                        suggestions.extend(tmp_suggestions.into_iter().filter(|s| {\n+                            use_prelude || this.is_builtin_macro(s.res.opt_def_id())\n+                        }));\n                     }\n                 }\n                 Scope::BuiltinTypes => {\n@@ -733,11 +724,7 @@ impl<'a> Resolver<'a> {\n                                         );\n \n                                         if filter_fn(crate_mod) {\n-                                            Some(TypoSuggestion {\n-                                                candidate: ident.name,\n-                                                article: \"a\",\n-                                                kind: \"crate\",\n-                                            })\n+                                            Some(TypoSuggestion::from_res(ident.name, crate_mod))\n                                         } else {\n                                             None\n                                         }"}, {"sha": "a5e498fa75643999e5a4647e6abe48e076d1703f", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8eaf17bca2674293eba0ea10056d5c77b6352086/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eaf17bca2674293eba0ea10056d5c77b6352086/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=8eaf17bca2674293eba0ea10056d5c77b6352086", "patch": "@@ -114,7 +114,6 @@ enum Scope<'a> {\n     CrateRoot,\n     Module(Module<'a>),\n     MacroUsePrelude,\n-    BuiltinMacros,\n     BuiltinAttrs,\n     LegacyPluginHelpers,\n     ExternPrelude,\n@@ -1679,7 +1678,7 @@ pub struct Resolver<'a> {\n \n     crate_loader: &'a mut CrateLoader<'a>,\n     macro_names: FxHashSet<Ident>,\n-    builtin_macros: FxHashMap<Name, &'a NameBinding<'a>>,\n+    builtin_macros: FxHashMap<Name, SyntaxExtension>,\n     macro_use_prelude: FxHashMap<Name, &'a NameBinding<'a>>,\n     pub all_macros: FxHashMap<Name, Res>,\n     macro_map: FxHashMap<DefId, Lrc<SyntaxExtension>>,\n@@ -2021,7 +2020,7 @@ impl<'a> Resolver<'a> {\n \n             crate_loader,\n             macro_names: FxHashSet::default(),\n-            builtin_macros: FxHashMap::default(),\n+            builtin_macros: Default::default(),\n             macro_use_prelude: FxHashMap::default(),\n             all_macros: FxHashMap::default(),\n             macro_map: FxHashMap::default(),\n@@ -2068,6 +2067,11 @@ impl<'a> Resolver<'a> {\n         f(self, MacroNS);\n     }\n \n+    fn is_builtin_macro(&mut self, def_id: Option<DefId>) -> bool {\n+        def_id.and_then(|def_id| self.get_macro_by_def_id(def_id))\n+              .map_or(false, |ext| ext.is_builtin)\n+    }\n+\n     fn macro_def(&self, mut ctxt: SyntaxContext) -> DefId {\n         loop {\n             match self.macro_defs.get(&ctxt.outer_expn()) {\n@@ -2146,7 +2150,7 @@ impl<'a> Resolver<'a> {\n         scope_set: ScopeSet,\n         parent_scope: &ParentScope<'a>,\n         ident: Ident,\n-        mut visitor: impl FnMut(&mut Self, Scope<'a>, Ident) -> Option<T>,\n+        mut visitor: impl FnMut(&mut Self, Scope<'a>, /*use_prelude*/ bool, Ident) -> Option<T>,\n     ) -> Option<T> {\n         // General principles:\n         // 1. Not controlled (user-defined) names should have higher priority than controlled names\n@@ -2185,8 +2189,8 @@ impl<'a> Resolver<'a> {\n         // 4. `macro_use` prelude (open, the open part is from macro expansions, not controlled).\n         // 4a. User-defined prelude from macro-use\n         //    (open, the open part is from macro expansions, not controlled).\n-        // 4b. Standard library prelude is currently implemented as `macro-use` (closed, controlled)\n-        // 5. Language prelude: builtin macros (closed, controlled, except for legacy plugins).\n+        // 4b. \"Standard library prelude\" part implemented through `macro-use` (closed, controlled).\n+        // 4c. Standard library prelude (de-facto closed, controlled).\n         // 6. Language prelude: builtin attributes (closed, controlled).\n         // 4-6. Legacy plugin helpers (open, not controlled). Similar to derive helpers,\n         //    but introduced by legacy plugins using `register_attribute`. Priority is somewhere\n@@ -2214,17 +2218,16 @@ impl<'a> Resolver<'a> {\n                 Scope::CrateRoot => true,\n                 Scope::Module(..) => true,\n                 Scope::MacroUsePrelude => use_prelude || rust_2015,\n-                Scope::BuiltinMacros => true,\n                 Scope::BuiltinAttrs => true,\n                 Scope::LegacyPluginHelpers => use_prelude || rust_2015,\n                 Scope::ExternPrelude => use_prelude || is_absolute_path,\n                 Scope::ToolPrelude => use_prelude,\n-                Scope::StdLibPrelude => use_prelude,\n+                Scope::StdLibPrelude => use_prelude || ns == MacroNS,\n                 Scope::BuiltinTypes => true,\n             };\n \n             if visit {\n-                if let break_result @ Some(..) = visitor(self, scope, ident) {\n+                if let break_result @ Some(..) = visitor(self, scope, use_prelude, ident) {\n                     return break_result;\n                 }\n             }\n@@ -2263,7 +2266,6 @@ impl<'a> Resolver<'a> {\n                     }\n                 }\n                 Scope::MacroUsePrelude => Scope::StdLibPrelude,\n-                Scope::BuiltinMacros => Scope::BuiltinAttrs,\n                 Scope::BuiltinAttrs => Scope::LegacyPluginHelpers,\n                 Scope::LegacyPluginHelpers => break, // nowhere else to search\n                 Scope::ExternPrelude if is_absolute_path => break,\n@@ -2272,7 +2274,7 @@ impl<'a> Resolver<'a> {\n                 Scope::StdLibPrelude => match ns {\n                     TypeNS => Scope::BuiltinTypes,\n                     ValueNS => break, // nowhere else to search\n-                    MacroNS => Scope::BuiltinMacros,\n+                    MacroNS => Scope::BuiltinAttrs,\n                 }\n                 Scope::BuiltinTypes => break, // nowhere else to search\n             };"}, {"sha": "88850c5988b7bb6354e53d96989384a32408f1ec", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 40, "deletions": 30, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/8eaf17bca2674293eba0ea10056d5c77b6352086/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eaf17bca2674293eba0ea10056d5c77b6352086/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=8eaf17bca2674293eba0ea10056d5c77b6352086", "patch": "@@ -1,18 +1,19 @@\n use crate::{AmbiguityError, AmbiguityKind, AmbiguityErrorMisc, Determinacy};\n use crate::{CrateLint, Resolver, ResolutionError, Scope, ScopeSet, ParentScope, Weak};\n-use crate::{Module, ModuleKind, NameBinding, NameBindingKind, PathResult, Segment, ToNameBinding};\n+use crate::{Module, ModuleKind, NameBinding, PathResult, Segment, ToNameBinding};\n use crate::{resolve_error, KNOWN_TOOLS};\n use crate::ModuleOrUniformRoot;\n use crate::Namespace::*;\n use crate::build_reduced_graph::{BuildReducedGraphVisitor, IsMacroExport};\n use crate::resolve_imports::ImportResolver;\n-use rustc::hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX};\n+use rustc::hir::def_id::{DefId, CRATE_DEF_INDEX};\n use rustc::hir::def::{self, DefKind, NonMacroAttrKind};\n use rustc::hir::map::DefCollector;\n use rustc::middle::stability;\n use rustc::{ty, lint, span_bug};\n use syntax::ast::{self, Ident, ItemKind};\n use syntax::attr::{self, StabilityLevel};\n+use syntax::edition::Edition;\n use syntax::ext::base::{self, Indeterminate};\n use syntax::ext::base::{MacroKind, SyntaxExtension};\n use syntax::ext::expand::{AstFragment, Invocation, InvocationKind};\n@@ -182,21 +183,8 @@ impl<'a> base::Resolver for Resolver<'a> {\n         invocation.output_legacy_scope.set(Some(visitor.current_legacy_scope));\n     }\n \n-    fn add_builtin(&mut self, ident: ast::Ident, ext: Lrc<SyntaxExtension>) {\n-        let def_id = DefId {\n-            krate: CrateNum::BuiltinMacros,\n-            index: DefIndex::from(self.macro_map.len()),\n-        };\n-        let kind = ext.macro_kind();\n-        self.macro_map.insert(def_id, ext);\n-        let binding = self.arenas.alloc_name_binding(NameBinding {\n-            kind: NameBindingKind::Res(Res::Def(DefKind::Macro(kind), def_id), false),\n-            ambiguity: None,\n-            span: DUMMY_SP,\n-            vis: ty::Visibility::Public,\n-            expansion: ExpnId::root(),\n-        });\n-        if self.builtin_macros.insert(ident.name, binding).is_some() {\n+    fn register_builtin_macro(&mut self, ident: ast::Ident, ext: SyntaxExtension) {\n+        if self.builtin_macros.insert(ident.name, ext).is_some() {\n             self.session.span_err(ident.span,\n                                   &format!(\"built-in macro `{}` was already defined\", ident));\n         }\n@@ -449,8 +437,8 @@ impl<'a> Resolver<'a> {\n         let mut determinacy = Determinacy::Determined;\n \n         // Go through all the scopes and try to resolve the name.\n-        let break_result =\n-                self.visit_scopes(scope_set, parent_scope, orig_ident, |this, scope, ident| {\n+        let break_result = self.visit_scopes(scope_set, parent_scope, orig_ident,\n+                                             |this, scope, use_prelude, ident| {\n             let result = match scope {\n                 Scope::DeriveHelpers => {\n                     let mut result = Err(Determinacy::Determined);\n@@ -535,10 +523,6 @@ impl<'a> Resolver<'a> {\n                         this.graph_root.unresolved_invocations.borrow().is_empty()\n                     ))\n                 }\n-                Scope::BuiltinMacros => match this.builtin_macros.get(&ident.name).cloned() {\n-                    Some(binding) => Ok((binding, Flags::PRELUDE)),\n-                    None => Err(Determinacy::Determined),\n-                }\n                 Scope::BuiltinAttrs => if is_builtin_attr_name(ident.name) {\n                     let binding = (Res::NonMacroAttr(NonMacroAttrKind::Builtin),\n                                    ty::Visibility::Public, DUMMY_SP, ExpnId::root())\n@@ -579,7 +563,9 @@ impl<'a> Resolver<'a> {\n                             false,\n                             path_span,\n                         ) {\n-                            result = Ok((binding, Flags::PRELUDE | Flags::MISC_FROM_PRELUDE));\n+                            if use_prelude || this.is_builtin_macro(binding.res().opt_def_id()) {\n+                                result = Ok((binding, Flags::PRELUDE | Flags::MISC_FROM_PRELUDE));\n+                            }\n                         }\n                     }\n                     result\n@@ -844,18 +830,42 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n+    /// Compile the macro into a `SyntaxExtension` and possibly replace it with a pre-defined\n+    /// extension partially or entirely for built-in macros and legacy plugin macros.\n+    crate fn compile_macro(&mut self, item: &ast::Item, edition: Edition) -> Lrc<SyntaxExtension> {\n+        let mut result = macro_rules::compile(\n+            &self.session.parse_sess, self.session.features_untracked(), item, edition\n+        );\n+\n+        if result.is_builtin {\n+            // The macro was marked with `#[rustc_builtin_macro]`.\n+            if let Some(ext) = self.builtin_macros.remove(&item.ident.name) {\n+                if ext.is_builtin {\n+                    // The macro is a built-in, replace only the expander function.\n+                    result.kind = ext.kind;\n+                    // Also reset its edition to the global one for compatibility.\n+                    result.edition = self.session.edition();\n+                } else {\n+                    // The macro is from a plugin, the in-source definition is dummy,\n+                    // take all the data from the resolver.\n+                    result = ext;\n+                }\n+            } else {\n+                let msg = format!(\"cannot find a built-in macro with name `{}`\", item.ident);\n+                self.session.span_err(item.span, &msg);\n+            }\n+        }\n+\n+        Lrc::new(result)\n+    }\n+\n     pub fn define_macro(&mut self,\n                         item: &ast::Item,\n                         expansion: ExpnId,\n                         current_legacy_scope: &mut LegacyScope<'a>) {\n         let (ext, ident, span, is_legacy) = match &item.node {\n             ItemKind::MacroDef(def) => {\n-                let ext = Lrc::new(macro_rules::compile(\n-                    &self.session.parse_sess,\n-                    &self.session.features_untracked(),\n-                    item,\n-                    self.session.edition(),\n-                ));\n+                let ext = self.compile_macro(item, self.session.edition());\n                 (ext, item.ident, item.span, def.legacy)\n             }\n             ItemKind::Fn(..) => match proc_macro_stub(item) {"}, {"sha": "59438883d60bc674b87ebf2e0e76a2016eea92d6", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 4, "deletions": 14, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8eaf17bca2674293eba0ea10056d5c77b6352086/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eaf17bca2674293eba0ea10056d5c77b6352086/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=8eaf17bca2674293eba0ea10056d5c77b6352086", "patch": "@@ -21,8 +21,8 @@ use rustc::lint::builtin::{\n     PUB_USE_OF_PRIVATE_EXTERN_CRATE,\n     UNUSED_IMPORTS,\n };\n-use rustc::hir::def_id::{CrateNum, DefId};\n-use rustc::hir::def::{self, DefKind, PartialRes, Export};\n+use rustc::hir::def_id::DefId;\n+use rustc::hir::def::{self, PartialRes, Export};\n use rustc::session::DiagnosticMessageId;\n use rustc::util::nodemap::FxHashSet;\n use rustc::{bug, span_bug};\n@@ -1214,17 +1214,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n         // this may resolve to either a value or a type, but for documentation\n         // purposes it's good enough to just favor one over the other.\n         self.per_ns(|this, ns| if let Some(binding) = source_bindings[ns].get().ok() {\n-            let mut res = binding.res();\n-            if let Res::Def(DefKind::Macro(_), def_id) = res {\n-                // `DefId`s from the \"built-in macro crate\" should not leak from resolve because\n-                // later stages are not ready to deal with them and produce lots of ICEs. Replace\n-                // them with `Res::Err` until some saner scheme is implemented for built-in macros.\n-                if def_id.krate == CrateNum::BuiltinMacros {\n-                    this.session.span_err(directive.span, \"cannot import a built-in macro\");\n-                    res = Res::Err;\n-                }\n-            }\n-            this.import_res_map.entry(directive.id).or_default()[ns] = Some(res);\n+            this.import_res_map.entry(directive.id).or_default()[ns] = Some(binding.res());\n         });\n \n         self.check_for_redundant_imports(\n@@ -1388,7 +1378,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                 let res = binding.res();\n                 if res != Res::Err {\n                     if let Some(def_id) = res.opt_def_id() {\n-                        if !def_id.is_local() && def_id.krate != CrateNum::BuiltinMacros {\n+                        if !def_id.is_local() {\n                             self.cstore.export_macros_untracked(def_id.krate);\n                         }\n                     }"}, {"sha": "117a430eec6b979f936ec00f9d61e3ad679b68e6", "filename": "src/libstd/error.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8eaf17bca2674293eba0ea10056d5c77b6352086/src%2Flibstd%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eaf17bca2674293eba0ea10056d5c77b6352086/src%2Flibstd%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ferror.rs?ref=8eaf17bca2674293eba0ea10056d5c77b6352086", "patch": "@@ -254,8 +254,8 @@ impl<'a, E: Error + 'a> From<E> for Box<dyn Error + 'a> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, E: Error + Send + Sync + 'a> From<E> for Box<dyn Error + Send + Sync + 'a> {\n-    /// Converts a type of [`Error`] + [`Send`] + [`Sync`] into a box of dyn [`Error`] +\n-    /// [`Send`] + [`Sync`].\n+    /// Converts a type of [`Error`] + [`trait@Send`] + [`trait@Sync`] into a box of\n+    /// dyn [`Error`] + [`trait@Send`] + [`trait@Sync`].\n     ///\n     /// [`Error`]: ../error/trait.Error.html\n     ///\n@@ -298,7 +298,7 @@ impl<'a, E: Error + Send + Sync + 'a> From<E> for Box<dyn Error + Send + Sync +\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl From<String> for Box<dyn Error + Send + Sync> {\n-    /// Converts a [`String`] into a box of dyn [`Error`] + [`Send`] + [`Sync`].\n+    /// Converts a [`String`] into a box of dyn [`Error`] + [`trait@Send`] + [`trait@Sync`].\n     ///\n     /// [`Error`]: ../error/trait.Error.html\n     ///\n@@ -362,7 +362,7 @@ impl From<String> for Box<dyn Error> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> From<&str> for Box<dyn Error + Send + Sync + 'a> {\n-    /// Converts a [`str`] into a box of dyn [`Error`] + [`Send`] + [`Sync`].\n+    /// Converts a [`str`] into a box of dyn [`Error`] + [`trait@Send`] + [`trait@Sync`].\n     ///\n     /// [`Error`]: ../error/trait.Error.html\n     ///\n@@ -405,7 +405,7 @@ impl From<&str> for Box<dyn Error> {\n \n #[stable(feature = \"cow_box_error\", since = \"1.22.0\")]\n impl<'a, 'b> From<Cow<'b, str>> for Box<dyn Error + Send + Sync + 'a> {\n-    /// Converts a [`Cow`] into a box of dyn [`Error`] + [`Send`] + [`Sync`].\n+    /// Converts a [`Cow`] into a box of dyn [`Error`] + [`trait@Send`] + [`trait@Sync`].\n     ///\n     /// [`Cow`]: ../borrow/enum.Cow.html\n     /// [`Error`]: ../error/trait.Error.html"}, {"sha": "722c08a22a6b659263363ac7aba79a017a23c358", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 38, "deletions": 2, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/8eaf17bca2674293eba0ea10056d5c77b6352086/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eaf17bca2674293eba0ea10056d5c77b6352086/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=8eaf17bca2674293eba0ea10056d5c77b6352086", "patch": "@@ -221,14 +221,15 @@\n \n #![cfg_attr(test, feature(print_internals, set_stdio, test, update_panic_count))]\n #![cfg_attr(all(target_vendor = \"fortanix\", target_env = \"sgx\"),\n-            feature(global_asm, slice_index_methods,\n-                    decl_macro, coerce_unsized, sgx_platform, ptr_wrapping_offset_from))]\n+            feature(slice_index_methods, decl_macro, coerce_unsized,\n+                    sgx_platform, ptr_wrapping_offset_from))]\n #![cfg_attr(all(test, target_vendor = \"fortanix\", target_env = \"sgx\"),\n             feature(fixed_size_array, maybe_uninit_extra))]\n \n // std is implemented with unstable features, many of which are internal\n // compiler details that will never be stable\n // NB: the following list is sorted to minimize merge conflicts.\n+#![cfg_attr(not(bootstrap), feature(__rust_unstable_column))]\n #![feature(alloc_error_handler)]\n #![feature(alloc_layout_extra)]\n #![feature(allocator_api)]\n@@ -251,6 +252,7 @@\n #![feature(const_cstr_unchecked)]\n #![feature(const_raw_ptr_deref)]\n #![feature(core_intrinsics)]\n+#![feature(custom_test_frameworks)]\n #![feature(doc_alias)]\n #![feature(doc_cfg)]\n #![feature(doc_keyword)]\n@@ -262,7 +264,9 @@\n #![feature(exhaustive_patterns)]\n #![feature(external_doc)]\n #![feature(fn_traits)]\n+#![feature(format_args_nl)]\n #![feature(generator_trait)]\n+#![feature(global_asm)]\n #![feature(hash_raw_entry)]\n #![feature(hashmap_internals)]\n #![feature(int_error_internals)]\n@@ -272,6 +276,7 @@\n #![feature(libc)]\n #![feature(link_args)]\n #![feature(linkage)]\n+#![feature(log_syntax)]\n #![feature(maybe_uninit_ref)]\n #![feature(maybe_uninit_slice)]\n #![feature(mem_take)]\n@@ -303,6 +308,7 @@\n #![feature(thread_local)]\n #![feature(todo_macro)]\n #![feature(toowned_clone_into)]\n+#![feature(trace_macros)]\n #![feature(try_reserve)]\n #![feature(unboxed_closures)]\n #![feature(untagged_unions)]\n@@ -510,6 +516,36 @@ mod std_detect;\n #[cfg(not(test))]\n pub use std_detect::detect;\n \n+// Document built-in macros in the crate root for consistency with libcore and existing tradition.\n+// FIXME: Attribute and derive macros are not reexported because rustdoc renders them\n+// as reexports rather than as macros, and that's not what we want.\n+#[cfg(rustdoc)]\n+#[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n+pub use crate::prelude::v1::{\n+    __rust_unstable_column,\n+    asm,\n+    assert,\n+    cfg,\n+    column,\n+    compile_error,\n+    concat,\n+    concat_idents,\n+    env,\n+    file,\n+    format_args,\n+    format_args_nl,\n+    global_asm,\n+    include,\n+    include_bytes,\n+    include_str,\n+    line,\n+    log_syntax,\n+    module_path,\n+    option_env,\n+    stringify,\n+    trace_macros,\n+};\n+\n // Include a number of private modules that exist solely to provide\n // the rustdoc documentation for primitive types. Using `include!`\n // because rustdoc only looks for these modules at the crate level."}, {"sha": "839b4c5656a09a0f8309adc608c9ad3ed2c1a65f", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 0, "deletions": 531, "changes": 531, "blob_url": "https://github.com/rust-lang/rust/blob/8eaf17bca2674293eba0ea10056d5c77b6352086/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eaf17bca2674293eba0ea10056d5c77b6352086/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=8eaf17bca2674293eba0ea10056d5c77b6352086", "patch": "@@ -365,534 +365,3 @@ macro_rules! assert_approx_eq {\n                 \"{} is not approximately equal to {}\", *a, *b);\n     })\n }\n-\n-/// Built-in macros to the compiler itself.\n-///\n-/// These macros do not have any corresponding definition with a `macro_rules!`\n-/// macro, but are documented here. Their implementations can be found hardcoded\n-/// into libsyntax itself.\n-#[cfg(rustdoc)]\n-mod builtin {\n-\n-    /// Causes compilation to fail with the given error message when encountered.\n-    ///\n-    /// This macro should be used when a crate uses a conditional compilation strategy to provide\n-    /// better error messages for erroneous conditions. It's the compiler-level form of [`panic!`],\n-    /// which emits an error at *runtime*, rather than during compilation.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Two such examples are macros and `#[cfg]` environments.\n-    ///\n-    /// Emit better compiler error if a macro is passed invalid values. Without the final branch,\n-    /// the compiler would still emit an error, but the error's message would not mention the two\n-    /// valid values.\n-    ///\n-    /// ```compile_fail\n-    /// macro_rules! give_me_foo_or_bar {\n-    ///     (foo) => {};\n-    ///     (bar) => {};\n-    ///     ($x:ident) => {\n-    ///         compile_error!(\"This macro only accepts `foo` or `bar`\");\n-    ///     }\n-    /// }\n-    ///\n-    /// give_me_foo_or_bar!(neither);\n-    /// // ^ will fail at compile time with message \"This macro only accepts `foo` or `bar`\"\n-    /// ```\n-    ///\n-    /// Emit compiler error if one of a number of features isn't available.\n-    ///\n-    /// ```compile_fail\n-    /// #[cfg(not(any(feature = \"foo\", feature = \"bar\")))]\n-    /// compile_error!(\"Either feature \\\"foo\\\" or \\\"bar\\\" must be enabled for this crate.\");\n-    /// ```\n-    ///\n-    /// [`panic!`]: ../std/macro.panic.html\n-    #[stable(feature = \"compile_error_macro\", since = \"1.20.0\")]\n-    #[rustc_builtin_macro]\n-    macro_rules! compile_error {\n-        ($msg:expr) => ({ /* compiler built-in */ });\n-        ($msg:expr,) => ({ /* compiler built-in */ });\n-    }\n-\n-    /// Constructs parameters for the other string-formatting macros.\n-    ///\n-    /// This macro functions by taking a formatting string literal containing\n-    /// `{}` for each additional argument passed. `format_args!` prepares the\n-    /// additional parameters to ensure the output can be interpreted as a string\n-    /// and canonicalizes the arguments into a single type. Any value that implements\n-    /// the [`Display`] trait can be passed to `format_args!`, as can any\n-    /// [`Debug`] implementation be passed to a `{:?}` within the formatting string.\n-    ///\n-    /// This macro produces a value of type [`fmt::Arguments`]. This value can be\n-    /// passed to the macros within [`std::fmt`] for performing useful redirection.\n-    /// All other formatting macros ([`format!`], [`write!`], [`println!`], etc) are\n-    /// proxied through this one. `format_args!`, unlike its derived macros, avoids\n-    /// heap allocations.\n-    ///\n-    /// You can use the [`fmt::Arguments`] value that `format_args!` returns\n-    /// in `Debug` and `Display` contexts as seen below. The example also shows\n-    /// that `Debug` and `Display` format to the same thing: the interpolated\n-    /// format string in `format_args!`.\n-    ///\n-    /// ```rust\n-    /// let debug = format!(\"{:?}\", format_args!(\"{} foo {:?}\", 1, 2));\n-    /// let display = format!(\"{}\", format_args!(\"{} foo {:?}\", 1, 2));\n-    /// assert_eq!(\"1 foo 2\", display);\n-    /// assert_eq!(display, debug);\n-    /// ```\n-    ///\n-    /// For more information, see the documentation in [`std::fmt`].\n-    ///\n-    /// [`Display`]: ../std/fmt/trait.Display.html\n-    /// [`Debug`]: ../std/fmt/trait.Debug.html\n-    /// [`fmt::Arguments`]: ../std/fmt/struct.Arguments.html\n-    /// [`std::fmt`]: ../std/fmt/index.html\n-    /// [`format!`]: ../std/macro.format.html\n-    /// [`write!`]: ../std/macro.write.html\n-    /// [`println!`]: ../std/macro.println.html\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::fmt;\n-    ///\n-    /// let s = fmt::format(format_args!(\"hello {}\", \"world\"));\n-    /// assert_eq!(s, format!(\"hello {}\", \"world\"));\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_builtin_macro]\n-    macro_rules! format_args {\n-        ($fmt:expr) => ({ /* compiler built-in */ });\n-        ($fmt:expr, $($args:tt)*) => ({ /* compiler built-in */ });\n-    }\n-\n-    /// Inspects an environment variable at compile time.\n-    ///\n-    /// This macro will expand to the value of the named environment variable at\n-    /// compile time, yielding an expression of type `&'static str`.\n-    ///\n-    /// If the environment variable is not defined, then a compilation error\n-    /// will be emitted. To not emit a compile error, use the [`option_env!`]\n-    /// macro instead.\n-    ///\n-    /// [`option_env!`]: ../std/macro.option_env.html\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let path: &'static str = env!(\"PATH\");\n-    /// println!(\"the $PATH variable at the time of compiling was: {}\", path);\n-    /// ```\n-    ///\n-    /// You can customize the error message by passing a string as the second\n-    /// parameter:\n-    ///\n-    /// ```compile_fail\n-    /// let doc: &'static str = env!(\"documentation\", \"what's that?!\");\n-    /// ```\n-    ///\n-    /// If the `documentation` environment variable is not defined, you'll get\n-    /// the following error:\n-    ///\n-    /// ```text\n-    /// error: what's that?!\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_builtin_macro]\n-    macro_rules! env {\n-        ($name:expr) => ({ /* compiler built-in */ });\n-        ($name:expr,) => ({ /* compiler built-in */ });\n-    }\n-\n-    /// Optionally inspects an environment variable at compile time.\n-    ///\n-    /// If the named environment variable is present at compile time, this will\n-    /// expand into an expression of type `Option<&'static str>` whose value is\n-    /// `Some` of the value of the environment variable. If the environment\n-    /// variable is not present, then this will expand to `None`. See\n-    /// [`Option<T>`][option] for more information on this type.\n-    ///\n-    /// A compile time error is never emitted when using this macro regardless\n-    /// of whether the environment variable is present or not.\n-    ///\n-    /// [option]: ../std/option/enum.Option.html\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let key: Option<&'static str> = option_env!(\"SECRET_KEY\");\n-    /// println!(\"the secret key might be: {:?}\", key);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_builtin_macro]\n-    macro_rules! option_env {\n-        ($name:expr) => ({ /* compiler built-in */ });\n-        ($name:expr,) => ({ /* compiler built-in */ });\n-    }\n-\n-    /// Concatenates identifiers into one identifier.\n-    ///\n-    /// This macro takes any number of comma-separated identifiers, and\n-    /// concatenates them all into one, yielding an expression which is a new\n-    /// identifier. Note that hygiene makes it such that this macro cannot\n-    /// capture local variables. Also, as a general rule, macros are only\n-    /// allowed in item, statement or expression position. That means while\n-    /// you may use this macro for referring to existing variables, functions or\n-    /// modules etc, you cannot define a new one with it.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(concat_idents)]\n-    ///\n-    /// # fn main() {\n-    /// fn foobar() -> u32 { 23 }\n-    ///\n-    /// let f = concat_idents!(foo, bar);\n-    /// println!(\"{}\", f());\n-    ///\n-    /// // fn concat_idents!(new, fun, name) { } // not usable in this way!\n-    /// # }\n-    /// ```\n-    #[unstable(feature = \"concat_idents_macro\", issue = \"29599\")]\n-    #[rustc_builtin_macro]\n-    macro_rules! concat_idents {\n-        ($($e:ident),+) => ({ /* compiler built-in */ });\n-        ($($e:ident,)+) => ({ /* compiler built-in */ });\n-    }\n-\n-    /// Concatenates literals into a static string slice.\n-    ///\n-    /// This macro takes any number of comma-separated literals, yielding an\n-    /// expression of type `&'static str` which represents all of the literals\n-    /// concatenated left-to-right.\n-    ///\n-    /// Integer and floating point literals are stringified in order to be\n-    /// concatenated.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let s = concat!(\"test\", 10, 'b', true);\n-    /// assert_eq!(s, \"test10btrue\");\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_builtin_macro]\n-    macro_rules! concat {\n-        ($($e:expr),*) => ({ /* compiler built-in */ });\n-        ($($e:expr,)*) => ({ /* compiler built-in */ });\n-    }\n-\n-    /// Expands to the line number on which it was invoked.\n-    ///\n-    /// With [`column!`] and [`file!`], these macros provide debugging information for\n-    /// developers about the location within the source.\n-    ///\n-    /// The expanded expression has type `u32` and is 1-based, so the first line\n-    /// in each file evaluates to 1, the second to 2, etc. This is consistent\n-    /// with error messages by common compilers or popular editors.\n-    /// The returned line is *not necessarily* the line of the `line!` invocation itself,\n-    /// but rather the first macro invocation leading up to the invocation\n-    /// of the `line!` macro.\n-    ///\n-    /// [`column!`]: macro.column.html\n-    /// [`file!`]: macro.file.html\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let current_line = line!();\n-    /// println!(\"defined on line: {}\", current_line);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_builtin_macro]\n-    macro_rules! line { () => ({ /* compiler built-in */ }) }\n-\n-    /// Expands to the column number at which it was invoked.\n-    ///\n-    /// With [`line!`] and [`file!`], these macros provide debugging information for\n-    /// developers about the location within the source.\n-    ///\n-    /// The expanded expression has type `u32` and is 1-based, so the first column\n-    /// in each line evaluates to 1, the second to 2, etc. This is consistent\n-    /// with error messages by common compilers or popular editors.\n-    /// The returned column is *not necessarily* the line of the `column!` invocation itself,\n-    /// but rather the first macro invocation leading up to the invocation\n-    /// of the `column!` macro.\n-    ///\n-    /// [`line!`]: macro.line.html\n-    /// [`file!`]: macro.file.html\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let current_col = column!();\n-    /// println!(\"defined on column: {}\", current_col);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_builtin_macro]\n-    macro_rules! column { () => ({ /* compiler built-in */ }) }\n-\n-    /// Expands to the file name in which it was invoked.\n-    ///\n-    /// With [`line!`] and [`column!`], these macros provide debugging information for\n-    /// developers about the location within the source.\n-    ///\n-    ///\n-    /// The expanded expression has type `&'static str`, and the returned file\n-    /// is not the invocation of the `file!` macro itself, but rather the\n-    /// first macro invocation leading up to the invocation of the `file!`\n-    /// macro.\n-    ///\n-    /// [`line!`]: macro.line.html\n-    /// [`column!`]: macro.column.html\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let this_file = file!();\n-    /// println!(\"defined in file: {}\", this_file);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_builtin_macro]\n-    macro_rules! file { () => ({ /* compiler built-in */ }) }\n-\n-    /// Stringifies its arguments.\n-    ///\n-    /// This macro will yield an expression of type `&'static str` which is the\n-    /// stringification of all the tokens passed to the macro. No restrictions\n-    /// are placed on the syntax of the macro invocation itself.\n-    ///\n-    /// Note that the expanded results of the input tokens may change in the\n-    /// future. You should be careful if you rely on the output.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let one_plus_one = stringify!(1 + 1);\n-    /// assert_eq!(one_plus_one, \"1 + 1\");\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_builtin_macro]\n-    macro_rules! stringify { ($($t:tt)*) => ({ /* compiler built-in */ }) }\n-\n-    /// Includes a utf8-encoded file as a string.\n-    ///\n-    /// The file is located relative to the current file. (similarly to how\n-    /// modules are found)\n-    ///\n-    /// This macro will yield an expression of type `&'static str` which is the\n-    /// contents of the file.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Assume there are two files in the same directory with the following\n-    /// contents:\n-    ///\n-    /// File 'spanish.in':\n-    ///\n-    /// ```text\n-    /// adi\u00f3s\n-    /// ```\n-    ///\n-    /// File 'main.rs':\n-    ///\n-    /// ```ignore (cannot-doctest-external-file-dependency)\n-    /// fn main() {\n-    ///     let my_str = include_str!(\"spanish.in\");\n-    ///     assert_eq!(my_str, \"adi\u00f3s\\n\");\n-    ///     print!(\"{}\", my_str);\n-    /// }\n-    /// ```\n-    ///\n-    /// Compiling 'main.rs' and running the resulting binary will print \"adi\u00f3s\".\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_builtin_macro]\n-    macro_rules! include_str {\n-        ($file:expr) => ({ /* compiler built-in */ });\n-        ($file:expr,) => ({ /* compiler built-in */ });\n-    }\n-\n-    /// Includes a file as a reference to a byte array.\n-    ///\n-    /// The file is located relative to the current file. (similarly to how\n-    /// modules are found)\n-    ///\n-    /// This macro will yield an expression of type `&'static [u8; N]` which is\n-    /// the contents of the file.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Assume there are two files in the same directory with the following\n-    /// contents:\n-    ///\n-    /// File 'spanish.in':\n-    ///\n-    /// ```text\n-    /// adi\u00f3s\n-    /// ```\n-    ///\n-    /// File 'main.rs':\n-    ///\n-    /// ```ignore (cannot-doctest-external-file-dependency)\n-    /// fn main() {\n-    ///     let bytes = include_bytes!(\"spanish.in\");\n-    ///     assert_eq!(bytes, b\"adi\\xc3\\xb3s\\n\");\n-    ///     print!(\"{}\", String::from_utf8_lossy(bytes));\n-    /// }\n-    /// ```\n-    ///\n-    /// Compiling 'main.rs' and running the resulting binary will print \"adi\u00f3s\".\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_builtin_macro]\n-    macro_rules! include_bytes {\n-        ($file:expr) => ({ /* compiler built-in */ });\n-        ($file:expr,) => ({ /* compiler built-in */ });\n-    }\n-\n-    /// Expands to a string that represents the current module path.\n-    ///\n-    /// The current module path can be thought of as the hierarchy of modules\n-    /// leading back up to the crate root. The first component of the path\n-    /// returned is the name of the crate currently being compiled.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// mod test {\n-    ///     pub fn foo() {\n-    ///         assert!(module_path!().ends_with(\"test\"));\n-    ///     }\n-    /// }\n-    ///\n-    /// test::foo();\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_builtin_macro]\n-    macro_rules! module_path { () => ({ /* compiler built-in */ }) }\n-\n-    /// Evaluates boolean combinations of configuration flags at compile-time.\n-    ///\n-    /// In addition to the `#[cfg]` attribute, this macro is provided to allow\n-    /// boolean expression evaluation of configuration flags. This frequently\n-    /// leads to less duplicated code.\n-    ///\n-    /// The syntax given to this macro is the same syntax as the [`cfg`]\n-    /// attribute.\n-    ///\n-    /// [`cfg`]: ../reference/conditional-compilation.html#the-cfg-attribute\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let my_directory = if cfg!(windows) {\n-    ///     \"windows-specific-directory\"\n-    /// } else {\n-    ///     \"unix-directory\"\n-    /// };\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_builtin_macro]\n-    macro_rules! cfg { ($($cfg:tt)*) => ({ /* compiler built-in */ }) }\n-\n-    /// Parses a file as an expression or an item according to the context.\n-    ///\n-    /// The file is located relative to the current file (similarly to how\n-    /// modules are found).\n-    ///\n-    /// Using this macro is often a bad idea, because if the file is\n-    /// parsed as an expression, it is going to be placed in the\n-    /// surrounding code unhygienically. This could result in variables\n-    /// or functions being different from what the file expected if\n-    /// there are variables or functions that have the same name in\n-    /// the current file.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Assume there are two files in the same directory with the following\n-    /// contents:\n-    ///\n-    /// File 'monkeys.in':\n-    ///\n-    /// ```ignore (only-for-syntax-highlight)\n-    /// ['\ud83d\ude48', '\ud83d\ude4a', '\ud83d\ude49']\n-    ///     .iter()\n-    ///     .cycle()\n-    ///     .take(6)\n-    ///     .collect::<String>()\n-    /// ```\n-    ///\n-    /// File 'main.rs':\n-    ///\n-    /// ```ignore (cannot-doctest-external-file-dependency)\n-    /// fn main() {\n-    ///     let my_string = include!(\"monkeys.in\");\n-    ///     assert_eq!(\"\ud83d\ude48\ud83d\ude4a\ud83d\ude49\ud83d\ude48\ud83d\ude4a\ud83d\ude49\", my_string);\n-    ///     println!(\"{}\", my_string);\n-    /// }\n-    /// ```\n-    ///\n-    /// Compiling 'main.rs' and running the resulting binary will print\n-    /// \"\ud83d\ude48\ud83d\ude4a\ud83d\ude49\ud83d\ude48\ud83d\ude4a\ud83d\ude49\".\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_builtin_macro]\n-    macro_rules! include {\n-        ($file:expr) => ({ /* compiler built-in */ });\n-        ($file:expr,) => ({ /* compiler built-in */ });\n-    }\n-\n-    /// Asserts that a boolean expression is `true` at runtime.\n-    ///\n-    /// This will invoke the [`panic!`] macro if the provided expression cannot be\n-    /// evaluated to `true` at runtime.\n-    ///\n-    /// # Uses\n-    ///\n-    /// Assertions are always checked in both debug and release builds, and cannot\n-    /// be disabled. See [`debug_assert!`] for assertions that are not enabled in\n-    /// release builds by default.\n-    ///\n-    /// Unsafe code relies on `assert!` to enforce run-time invariants that, if\n-    /// violated could lead to unsafety.\n-    ///\n-    /// Other use-cases of `assert!` include testing and enforcing run-time\n-    /// invariants in safe code (whose violation cannot result in unsafety).\n-    ///\n-    /// # Custom Messages\n-    ///\n-    /// This macro has a second form, where a custom panic message can\n-    /// be provided with or without arguments for formatting. See [`std::fmt`]\n-    /// for syntax for this form.\n-    ///\n-    /// [`panic!`]: macro.panic.html\n-    /// [`debug_assert!`]: macro.debug_assert.html\n-    /// [`std::fmt`]: ../std/fmt/index.html\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// // the panic message for these assertions is the stringified value of the\n-    /// // expression given.\n-    /// assert!(true);\n-    ///\n-    /// fn some_computation() -> bool { true } // a very simple function\n-    ///\n-    /// assert!(some_computation());\n-    ///\n-    /// // assert with a custom message\n-    /// let x = true;\n-    /// assert!(x, \"x wasn't true!\");\n-    ///\n-    /// let a = 3; let b = 27;\n-    /// assert!(a + b == 30, \"a = {}, b = {}\", a, b);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_builtin_macro]\n-    macro_rules! assert {\n-        ($cond:expr) => ({ /* compiler built-in */ });\n-        ($cond:expr,) => ({ /* compiler built-in */ });\n-        ($cond:expr, $($arg:tt)+) => ({ /* compiler built-in */ });\n-    }\n-}"}, {"sha": "7b12d2ee6f0813f6d62eca4a3c8d974885ab0eb6", "filename": "src/libstd/prelude/v1.rs", "status": "modified", "additions": 62, "deletions": 1, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/8eaf17bca2674293eba0ea10056d5c77b6352086/src%2Flibstd%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eaf17bca2674293eba0ea10056d5c77b6352086/src%2Flibstd%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude%2Fv1.rs?ref=8eaf17bca2674293eba0ea10056d5c77b6352086", "patch": "@@ -7,9 +7,13 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n // Re-exported core operators\n+#[cfg(bootstrap)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)]\n-pub use crate::marker::{Copy, Send, Sized, Sync, Unpin};\n+pub use crate::marker::Copy;\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[doc(no_inline)]\n+pub use crate::marker::{Send, Sized, Sync, Unpin};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)]\n pub use crate::ops::{Drop, Fn, FnMut, FnOnce};\n@@ -20,15 +24,18 @@ pub use crate::ops::{Drop, Fn, FnMut, FnOnce};\n pub use crate::mem::drop;\n \n // Re-exported types and traits\n+#[cfg(bootstrap)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)]\n pub use crate::clone::Clone;\n+#[cfg(bootstrap)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)]\n pub use crate::cmp::{PartialEq, PartialOrd, Eq, Ord};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)]\n pub use crate::convert::{AsRef, AsMut, Into, From};\n+#[cfg(bootstrap)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)]\n pub use crate::default::Default;\n@@ -45,6 +52,60 @@ pub use crate::option::Option::{self, Some, None};\n #[doc(no_inline)]\n pub use crate::result::Result::{self, Ok, Err};\n \n+// Re-exported built-in macros\n+#[cfg(not(bootstrap))]\n+#[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n+#[doc(no_inline)]\n+pub use core::prelude::v1::{\n+    __rust_unstable_column,\n+    asm,\n+    assert,\n+    cfg,\n+    column,\n+    compile_error,\n+    concat,\n+    concat_idents,\n+    env,\n+    file,\n+    format_args,\n+    format_args_nl,\n+    global_asm,\n+    include,\n+    include_bytes,\n+    include_str,\n+    line,\n+    log_syntax,\n+    module_path,\n+    option_env,\n+    stringify,\n+    trace_macros,\n+};\n+\n+// FIXME: Attribute and derive macros are not documented because for them rustdoc generates\n+// dead links which fail link checker testing.\n+#[cfg(not(bootstrap))]\n+#[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n+#[allow(deprecated)]\n+#[doc(hidden)]\n+pub use core::prelude::v1::{\n+    Clone,\n+    Copy,\n+    Debug,\n+    Decodable,\n+    Default,\n+    Encodable,\n+    Eq,\n+    Hash,\n+    Ord,\n+    PartialEq,\n+    PartialOrd,\n+    RustcDecodable,\n+    RustcEncodable,\n+    bench,\n+    global_allocator,\n+    test,\n+    test_case,\n+};\n \n // The file so far is equivalent to src/libcore/prelude/v1.rs,\n // and below to src/liballoc/prelude.rs."}, {"sha": "0ab14bee160da7aeacceea42b73eca6146152788", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8eaf17bca2674293eba0ea10056d5c77b6352086/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eaf17bca2674293eba0ea10056d5c77b6352086/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=8eaf17bca2674293eba0ea10056d5c77b6352086", "patch": "@@ -592,6 +592,9 @@ pub struct SyntaxExtension {\n     pub helper_attrs: Vec<Symbol>,\n     /// Edition of the crate in which this macro is defined.\n     pub edition: Edition,\n+    /// Built-in macros have a couple of special properties (meaning of `$crate`,\n+    /// availability in `#[no_implicit_prelude]` modules), so we have to keep this flag.\n+    pub is_builtin: bool,\n }\n \n impl SyntaxExtensionKind {\n@@ -636,6 +639,7 @@ impl SyntaxExtension {\n             deprecation: None,\n             helper_attrs: Vec::new(),\n             edition,\n+            is_builtin: false,\n             kind,\n         }\n     }\n@@ -687,7 +691,7 @@ pub trait Resolver {\n     fn resolve_dollar_crates(&mut self);\n     fn visit_ast_fragment_with_placeholders(&mut self, expn_id: ExpnId, fragment: &AstFragment,\n                                             derives: &[ExpnId]);\n-    fn add_builtin(&mut self, ident: ast::Ident, ext: Lrc<SyntaxExtension>);\n+    fn register_builtin_macro(&mut self, ident: ast::Ident, ext: SyntaxExtension);\n \n     fn resolve_imports(&mut self);\n "}, {"sha": "c76e964b5e7d795a3a39045e7e175691417b866d", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8eaf17bca2674293eba0ea10056d5c77b6352086/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eaf17bca2674293eba0ea10056d5c77b6352086/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=8eaf17bca2674293eba0ea10056d5c77b6352086", "patch": "@@ -437,6 +437,7 @@ pub fn compile(\n         deprecation: attr::find_deprecation(&sess, &def.attrs, def.span),\n         helper_attrs: Vec::new(),\n         edition,\n+        is_builtin: attr::contains_name(&def.attrs, sym::rustc_builtin_macro),\n     }\n }\n "}, {"sha": "1a86509928841f5e6e168b9dd7fd7ca4c7160be8", "filename": "src/libsyntax_ext/deriving/mod.rs", "status": "modified", "additions": 3, "deletions": 83, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/8eaf17bca2674293eba0ea10056d5c77b6352086/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eaf17bca2674293eba0ea10056d5c77b6352086/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs?ref=8eaf17bca2674293eba0ea10056d5c77b6352086", "patch": "@@ -1,11 +1,7 @@\n //! The compiler code necessary to implement the `#[derive]` extensions.\n \n-use rustc_data_structures::sync::Lrc;\n use syntax::ast::{self, MetaItem};\n-use syntax::attr::Deprecation;\n-use syntax::edition::Edition;\n-use syntax::ext::base::{Annotatable, ExtCtxt, Resolver, MultiItemModifier};\n-use syntax::ext::base::{SyntaxExtension, SyntaxExtensionKind};\n+use syntax::ext::base::{Annotatable, ExtCtxt, MultiItemModifier};\n use syntax::ext::build::AstBuilder;\n use syntax::ptr::P;\n use syntax::symbol::{Symbol, sym};\n@@ -43,8 +39,8 @@ pub mod ord;\n \n pub mod generic;\n \n-struct BuiltinDerive(\n-    fn(&mut ExtCtxt<'_>, Span, &MetaItem, &Annotatable, &mut dyn FnMut(Annotatable))\n+crate struct BuiltinDerive(\n+    crate fn(&mut ExtCtxt<'_>, Span, &MetaItem, &Annotatable, &mut dyn FnMut(Annotatable))\n );\n \n impl MultiItemModifier for BuiltinDerive {\n@@ -60,82 +56,6 @@ impl MultiItemModifier for BuiltinDerive {\n     }\n }\n \n-macro_rules! derive_traits {\n-    ($( [$deprecation:expr] $name:ident => $func:path, )+) => {\n-        pub fn is_builtin_trait(name: ast::Name) -> bool {\n-            match name {\n-                $( sym::$name )|+ => true,\n-                _ => false,\n-            }\n-        }\n-\n-        pub fn register_builtin_derives(resolver: &mut dyn Resolver, edition: Edition) {\n-            let allow_internal_unstable = Some([\n-                sym::core_intrinsics,\n-                sym::rustc_attrs,\n-                Symbol::intern(\"derive_clone_copy\"),\n-                Symbol::intern(\"derive_eq\"),\n-                Symbol::intern(\"libstd_sys_internals\"), // RustcDeserialize and RustcSerialize\n-            ][..].into());\n-\n-            $(\n-                resolver.add_builtin(\n-                    ast::Ident::with_empty_ctxt(sym::$name),\n-                    Lrc::new(SyntaxExtension {\n-                        deprecation: $deprecation.map(|msg| Deprecation {\n-                            since: Some(Symbol::intern(\"1.0.0\")),\n-                            note: Some(Symbol::intern(msg)),\n-                        }),\n-                        allow_internal_unstable: allow_internal_unstable.clone(),\n-                        ..SyntaxExtension::default(\n-                            SyntaxExtensionKind::LegacyDerive(Box::new(BuiltinDerive($func))),\n-                            edition,\n-                        )\n-                    }),\n-                );\n-            )+\n-        }\n-    }\n-}\n-\n-derive_traits! {\n-    [None]\n-    Clone => clone::expand_deriving_clone,\n-\n-    [None]\n-    Hash => hash::expand_deriving_hash,\n-\n-    [None]\n-    RustcEncodable => encodable::expand_deriving_rustc_encodable,\n-\n-    [None]\n-    RustcDecodable => decodable::expand_deriving_rustc_decodable,\n-\n-    [None]\n-    PartialEq => partial_eq::expand_deriving_partial_eq,\n-    [None]\n-    Eq => eq::expand_deriving_eq,\n-    [None]\n-    PartialOrd => partial_ord::expand_deriving_partial_ord,\n-    [None]\n-    Ord => ord::expand_deriving_ord,\n-\n-    [None]\n-    Debug => debug::expand_deriving_debug,\n-\n-    [None]\n-    Default => default::expand_deriving_default,\n-\n-    [None]\n-    Copy => bounds::expand_deriving_copy,\n-\n-    // deprecated\n-    [Some(\"derive(Encodable) is deprecated in favor of derive(RustcEncodable)\")]\n-    Encodable => encodable::expand_deriving_encodable,\n-    [Some(\"derive(Decodable) is deprecated in favor of derive(RustcDecodable)\")]\n-    Decodable => decodable::expand_deriving_decodable,\n-}\n-\n /// Construct a name for the inner type parameter that can't collide with any type parameters of\n /// the item. This is achieved by starting with a base and then concatenating the names of all\n /// other type parameters."}, {"sha": "7940abed2459777a8e9d245525a549f28044f6fa", "filename": "src/libsyntax_ext/lib.rs", "status": "modified", "additions": 62, "deletions": 132, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/8eaf17bca2674293eba0ea10056d5c77b6352086/src%2Flibsyntax_ext%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eaf17bca2674293eba0ea10056d5c77b6352086/src%2Flibsyntax_ext%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Flib.rs?ref=8eaf17bca2674293eba0ea10056d5c77b6352086", "patch": "@@ -5,19 +5,25 @@\n #![deny(rust_2018_idioms)]\n #![deny(unused_lifetimes)]\n \n-#![feature(in_band_lifetimes)]\n+#![feature(crate_visibility_modifier)]\n+#![feature(decl_macro)]\n+#![feature(nll)]\n #![feature(proc_macro_diagnostic)]\n #![feature(proc_macro_internals)]\n #![feature(proc_macro_span)]\n-#![feature(decl_macro)]\n-#![feature(nll)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(unicode_internals)]\n \n-#![recursion_limit=\"256\"]\n-\n extern crate proc_macro;\n \n+use crate::deriving::*;\n+\n+use syntax::ast::Ident;\n+use syntax::edition::Edition;\n+use syntax::ext::base::{SyntaxExtension, SyntaxExtensionKind, MacroExpanderFn};\n+use syntax::ext::source_util;\n+use syntax::symbol::sym;\n+\n mod error_codes;\n \n mod asm;\n@@ -38,147 +44,71 @@ mod test_case;\n mod trace_macros;\n \n pub mod deriving;\n+pub mod plugin_macro_defs;\n pub mod proc_macro_decls;\n pub mod proc_macro_impl;\n \n-use rustc_data_structures::sync::Lrc;\n-use syntax::ast;\n-use syntax::attr::Stability;\n-use syntax::ext::base::MacroExpanderFn;\n-use syntax::ext::base::{NamedSyntaxExtension, SyntaxExtension, SyntaxExtensionKind};\n-use syntax::edition::Edition;\n-use syntax::symbol::{sym, Symbol};\n-\n-const EXPLAIN_ASM: &str =\n-    \"inline assembly is not stable enough for use and is subject to change\";\n-const EXPLAIN_GLOBAL_ASM: &str =\n-    \"`global_asm!` is not stable enough for use and is subject to change\";\n-const EXPLAIN_CUSTOM_TEST_FRAMEWORKS: &str =\n-    \"custom test frameworks are an unstable feature\";\n-const EXPLAIN_LOG_SYNTAX: &str =\n-    \"`log_syntax!` is not stable enough for use and is subject to change\";\n-const EXPLAIN_CONCAT_IDENTS: &str =\n-    \"`concat_idents` is not stable enough for use and is subject to change\";\n-const EXPLAIN_FORMAT_ARGS_NL: &str =\n-    \"`format_args_nl` is only for internal language use and is subject to change\";\n-const EXPLAIN_TRACE_MACROS: &str =\n-    \"`trace_macros` is not stable enough for use and is subject to change\";\n-const EXPLAIN_UNSTABLE_COLUMN: &str =\n-    \"internal implementation detail of the `column` macro\";\n-\n-pub fn register_builtins(resolver: &mut dyn syntax::ext::base::Resolver,\n-                         user_exts: Vec<NamedSyntaxExtension>,\n-                         edition: Edition) {\n-    deriving::register_builtin_derives(resolver, edition);\n-\n-    let mut register = |name, ext| {\n-        resolver.add_builtin(ast::Ident::with_empty_ctxt(name), Lrc::new(ext));\n-    };\n-\n-    macro_rules! register {\n-        ($( $name:ident: $f:expr, )*) => { $(\n-            register(sym::$name, SyntaxExtension::default(\n-                SyntaxExtensionKind::LegacyBang(Box::new($f as MacroExpanderFn)), edition\n-            ));\n-        )* }\n+pub fn register_builtin_macros(resolver: &mut dyn syntax::ext::base::Resolver, edition: Edition) {\n+    let mut register = |name, kind| resolver.register_builtin_macro(\n+        Ident::with_empty_ctxt(name), SyntaxExtension {\n+            is_builtin: true, ..SyntaxExtension::default(kind, edition)\n+        },\n+    );\n+    macro register_bang($($name:ident: $f:expr,)*) {\n+        $(register(sym::$name, SyntaxExtensionKind::LegacyBang(Box::new($f as MacroExpanderFn)));)*\n+    }\n+    macro register_attr($($name:ident: $f:expr,)*) {\n+        $(register(sym::$name, SyntaxExtensionKind::LegacyAttr(Box::new($f)));)*\n     }\n-    macro_rules! register_unstable {\n-        ($( [$feature:expr, $reason:expr, $issue:expr] $name:ident: $f:expr, )*) => { $(\n-            register(sym::$name, SyntaxExtension {\n-                stability: Some(Stability::unstable(\n-                    $feature, Some(Symbol::intern($reason)), $issue\n-                )),\n-                ..SyntaxExtension::default(\n-                    SyntaxExtensionKind::LegacyBang(Box::new($f as MacroExpanderFn)), edition\n-                )\n-            });\n-        )* }\n+    macro register_derive($($name:ident: $f:expr,)*) {\n+        $(register(sym::$name, SyntaxExtensionKind::LegacyDerive(Box::new(BuiltinDerive($f))));)*\n     }\n \n-    use syntax::ext::source_util::*;\n-    register! {\n-        line: expand_line,\n-        column: expand_column,\n-        file: expand_file,\n-        stringify: expand_stringify,\n-        include: expand_include,\n-        include_str: expand_include_str,\n-        include_bytes: expand_include_bytes,\n-        module_path: expand_mod,\n+    register_bang! {\n+        __rust_unstable_column: source_util::expand_column,\n+        asm: asm::expand_asm,\n+        assert: assert::expand_assert,\n         cfg: cfg::expand_cfg,\n+        column: source_util::expand_column,\n+        compile_error: compile_error::expand_compile_error,\n+        concat_idents: concat_idents::expand_syntax_ext,\n         concat: concat::expand_syntax_ext,\n         env: env::expand_env,\n-        option_env: env::expand_option_env,\n-        compile_error: compile_error::expand_compile_error,\n-        assert: assert::expand_assert,\n-    }\n-\n-    register_unstable! {\n-        [sym::__rust_unstable_column, EXPLAIN_UNSTABLE_COLUMN, 0]\n-        __rust_unstable_column: expand_column,\n-        [sym::asm, EXPLAIN_ASM, 29722]\n-        asm: asm::expand_asm,\n-        [sym::global_asm, EXPLAIN_GLOBAL_ASM, 35119]\n+        file: source_util::expand_file,\n+        format_args_nl: format::expand_format_args_nl,\n+        format_args: format::expand_format_args,\n         global_asm: global_asm::expand_global_asm,\n-        [sym::concat_idents, EXPLAIN_CONCAT_IDENTS, 29599]\n-        concat_idents: concat_idents::expand_syntax_ext,\n-        [sym::log_syntax, EXPLAIN_LOG_SYNTAX, 29598]\n+        include_bytes: source_util::expand_include_bytes,\n+        include_str: source_util::expand_include_str,\n+        include: source_util::expand_include,\n+        line: source_util::expand_line,\n         log_syntax: log_syntax::expand_syntax_ext,\n-        [sym::trace_macros, EXPLAIN_TRACE_MACROS, 29598]\n+        module_path: source_util::expand_mod,\n+        option_env: env::expand_option_env,\n+        stringify: source_util::expand_stringify,\n         trace_macros: trace_macros::expand_trace_macros,\n     }\n \n-    let allow_internal_unstable = Some([sym::test, sym::rustc_attrs][..].into());\n-    register(sym::test_case, SyntaxExtension {\n-        stability: Some(Stability::unstable(\n-            sym::custom_test_frameworks,\n-            Some(Symbol::intern(EXPLAIN_CUSTOM_TEST_FRAMEWORKS)),\n-            50297,\n-        )),\n-        allow_internal_unstable: allow_internal_unstable.clone(),\n-        ..SyntaxExtension::default(\n-            SyntaxExtensionKind::LegacyAttr(Box::new(test_case::expand)), edition\n-        )\n-    });\n-    register(sym::test, SyntaxExtension {\n-        allow_internal_unstable: allow_internal_unstable.clone(),\n-        ..SyntaxExtension::default(\n-            SyntaxExtensionKind::LegacyAttr(Box::new(test::expand_test)), edition\n-        )\n-    });\n-    register(sym::bench, SyntaxExtension {\n-        allow_internal_unstable,\n-        ..SyntaxExtension::default(\n-            SyntaxExtensionKind::LegacyAttr(Box::new(test::expand_bench)), edition\n-        )\n-    });\n-    register(sym::global_allocator, SyntaxExtension {\n-        allow_internal_unstable: Some([sym::rustc_attrs][..].into()),\n-        ..SyntaxExtension::default(\n-            SyntaxExtensionKind::LegacyAttr(Box::new(global_allocator::expand)), edition\n-        )\n-    });\n-\n-    let allow_internal_unstable = Some([sym::fmt_internals][..].into());\n-    register(sym::format_args, SyntaxExtension {\n-        allow_internal_unstable: allow_internal_unstable.clone(),\n-        ..SyntaxExtension::default(\n-            SyntaxExtensionKind::LegacyBang(Box::new(format::expand_format_args)), edition\n-        )\n-    });\n-    register(sym::format_args_nl, SyntaxExtension {\n-        stability: Some(Stability::unstable(\n-            sym::format_args_nl,\n-            Some(Symbol::intern(EXPLAIN_FORMAT_ARGS_NL)),\n-            0,\n-        )),\n-        allow_internal_unstable,\n-        ..SyntaxExtension::default(\n-            SyntaxExtensionKind::LegacyBang(Box::new(format::expand_format_args_nl)), edition\n-        )\n-    });\n+    register_attr! {\n+        bench: test::expand_bench,\n+        global_allocator: global_allocator::expand,\n+        test: test::expand_test,\n+        test_case: test_case::expand,\n+    }\n \n-    for (name, ext) in user_exts {\n-        register(name, ext);\n+    register_derive! {\n+        Clone: clone::expand_deriving_clone,\n+        Copy: bounds::expand_deriving_copy,\n+        Debug: debug::expand_deriving_debug,\n+        Decodable: decodable::expand_deriving_decodable,\n+        Default: default::expand_deriving_default,\n+        Encodable: encodable::expand_deriving_encodable,\n+        Eq: eq::expand_deriving_eq,\n+        Hash: hash::expand_deriving_hash,\n+        Ord: ord::expand_deriving_ord,\n+        PartialEq: partial_eq::expand_deriving_partial_eq,\n+        PartialOrd: partial_ord::expand_deriving_partial_ord,\n+        RustcDecodable: decodable::expand_deriving_rustc_decodable,\n+        RustcEncodable: encodable::expand_deriving_rustc_encodable,\n     }\n }"}, {"sha": "2fd1a42db95f31e35620cbb5f382ca54e449d3ae", "filename": "src/libsyntax_ext/plugin_macro_defs.rs", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/8eaf17bca2674293eba0ea10056d5c77b6352086/src%2Flibsyntax_ext%2Fplugin_macro_defs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eaf17bca2674293eba0ea10056d5c77b6352086/src%2Flibsyntax_ext%2Fplugin_macro_defs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fplugin_macro_defs.rs?ref=8eaf17bca2674293eba0ea10056d5c77b6352086", "patch": "@@ -0,0 +1,64 @@\n+//! Each macro must have a definition, so `#[plugin]` attributes\n+//! inject a dummy `macro_rules` item for each macro they define.\n+\n+use syntax::ast::*;\n+use syntax::attr;\n+use syntax::edition::Edition;\n+use syntax::ext::base::{Resolver, NamedSyntaxExtension};\n+use syntax::parse::token;\n+use syntax::ptr::P;\n+use syntax::source_map::respan;\n+use syntax::symbol::sym;\n+use syntax::tokenstream::*;\n+use syntax_pos::{Span, DUMMY_SP};\n+use syntax_pos::hygiene::{ExpnId, ExpnInfo, ExpnKind, MacroKind};\n+\n+use std::mem;\n+\n+fn plugin_macro_def(name: Name, span: Span) -> P<Item> {\n+    let rustc_builtin_macro = Attribute {\n+        id: attr::mk_attr_id(),\n+        style: AttrStyle::Outer,\n+        path: Path::from_ident(Ident::new(sym::rustc_builtin_macro, span)),\n+        tokens: TokenStream::empty(),\n+        is_sugared_doc: false,\n+        span,\n+    };\n+\n+    let parens: TreeAndJoint = TokenTree::Delimited(\n+        DelimSpan::from_single(span), token::Paren, TokenStream::empty()\n+    ).into();\n+    let trees = vec![parens.clone(), TokenTree::token(token::FatArrow, span).into(), parens];\n+\n+    P(Item {\n+        ident: Ident::new(name, span),\n+        attrs: vec![rustc_builtin_macro],\n+        id: DUMMY_NODE_ID,\n+        node: ItemKind::MacroDef(MacroDef { tokens: TokenStream::new(trees), legacy: true }),\n+        vis: respan(span, VisibilityKind::Inherited),\n+        span: span,\n+        tokens: None,\n+    })\n+}\n+\n+pub fn inject(\n+    krate: &mut Crate,\n+    resolver: &mut dyn Resolver,\n+    named_exts: Vec<NamedSyntaxExtension>,\n+    edition: Edition,\n+) {\n+    if !named_exts.is_empty() {\n+        let mut extra_items = Vec::new();\n+        let span = DUMMY_SP.fresh_expansion(ExpnId::root(), ExpnInfo::allow_unstable(\n+            ExpnKind::Macro(MacroKind::Attr, sym::plugin), DUMMY_SP, edition,\n+            [sym::rustc_attrs][..].into(),\n+        ));\n+        for (name, ext) in named_exts {\n+            resolver.register_builtin_macro(Ident::with_empty_ctxt(name), ext);\n+            extra_items.push(plugin_macro_def(name, span));\n+        }\n+        // The `macro_rules` items must be inserted before any other items.\n+        mem::swap(&mut extra_items, &mut krate.module.items);\n+        krate.module.items.append(&mut extra_items);\n+    }\n+}"}, {"sha": "303d5f00deb1a59bcd809e694e8c042a711c4827", "filename": "src/libsyntax_ext/proc_macro_decls.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8eaf17bca2674293eba0ea10056d5c77b6352086/src%2Flibsyntax_ext%2Fproc_macro_decls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eaf17bca2674293eba0ea10056d5c77b6352086/src%2Flibsyntax_ext%2Fproc_macro_decls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_decls.rs?ref=8eaf17bca2674293eba0ea10056d5c77b6352086", "patch": "@@ -1,7 +1,5 @@\n use std::mem;\n \n-use crate::deriving;\n-\n use syntax::ast::{self, Ident};\n use syntax::attr;\n use syntax::source_map::{ExpnInfo, ExpnKind, respan};\n@@ -136,10 +134,6 @@ impl<'a> CollectProcMacros<'a> {\n             self.handler.span_err(trait_attr.span,\n                                   &format!(\"`{}` cannot be a name of derive macro\", trait_ident));\n         }\n-        if deriving::is_builtin_trait(trait_ident.name) {\n-            self.handler.span_err(trait_attr.span,\n-                                  \"cannot override a built-in derive macro\");\n-        }\n \n         let attributes_attr = list.get(1);\n         let proc_attrs: Vec<_> = if let Some(attr) = attributes_attr {"}, {"sha": "75d95a4eaf146fc863b68248ee591feb3b3acfcd", "filename": "src/test/run-make-fulldeps/simd-ffi/simd.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8eaf17bca2674293eba0ea10056d5c77b6352086/src%2Ftest%2Frun-make-fulldeps%2Fsimd-ffi%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eaf17bca2674293eba0ea10056d5c77b6352086/src%2Ftest%2Frun-make-fulldeps%2Fsimd-ffi%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fsimd-ffi%2Fsimd.rs?ref=8eaf17bca2674293eba0ea10056d5c77b6352086", "patch": "@@ -5,7 +5,7 @@\n #![feature(no_core, optin_builtin_traits)]\n #![no_core]\n \n-#![feature(repr_simd, simd_ffi, link_llvm_intrinsics, lang_items)]\n+#![feature(repr_simd, simd_ffi, link_llvm_intrinsics, lang_items, rustc_attrs)]\n \n \n #[repr(C)]\n@@ -74,3 +74,7 @@ pub mod marker {\n \n #[lang = \"freeze\"]\n auto trait Freeze {}\n+\n+#[macro_export]\n+#[rustc_builtin_macro]\n+macro_rules! Copy { () => () }"}, {"sha": "4d40eb3b88f1ba1ba7bd9a0f30b8df1fb42da3ea", "filename": "src/test/rustdoc/intra-link-builtin-macros.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8eaf17bca2674293eba0ea10056d5c77b6352086/src%2Ftest%2Frustdoc%2Fintra-link-builtin-macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eaf17bca2674293eba0ea10056d5c77b6352086/src%2Ftest%2Frustdoc%2Fintra-link-builtin-macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-link-builtin-macros.rs?ref=8eaf17bca2674293eba0ea10056d5c77b6352086", "patch": "@@ -0,0 +1,3 @@\n+// @has intra_link_builtin_macros/index.html\n+// @has - '//a/@href' 'https://doc.rust-lang.org/nightly/core/macro.cfg.html'\n+//! [cfg]"}, {"sha": "c2685c7f74c30a0f69d486768c77baecb5985a57", "filename": "src/test/ui-fulldeps/auxiliary/attr-plugin-test.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8eaf17bca2674293eba0ea10056d5c77b6352086/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Fattr-plugin-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eaf17bca2674293eba0ea10056d5c77b6352086/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Fattr-plugin-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Fattr-plugin-test.rs?ref=8eaf17bca2674293eba0ea10056d5c77b6352086", "patch": "@@ -3,20 +3,21 @@\n #![feature(plugin_registrar)]\n #![feature(rustc_private)]\n \n-extern crate syntax;\n-\n-extern crate rustc;\n-extern crate rustc_plugin;\n extern crate rustc_driver;\n+extern crate rustc_plugin;\n+extern crate syntax;\n \n-use syntax::symbol::Symbol;\n-use syntax::feature_gate::AttributeType;\n use rustc_plugin::Registry;\n-\n+use syntax::ext::base::SyntaxExtension;\n+use syntax::feature_gate::AttributeType;\n+use syntax::symbol::Symbol;\n \n #[plugin_registrar]\n pub fn plugin_registrar(reg: &mut Registry) {\n     reg.register_attribute(Symbol::intern(\"foo\"), AttributeType::Normal);\n     reg.register_attribute(Symbol::intern(\"bar\"), AttributeType::CrateLevel);\n     reg.register_attribute(Symbol::intern(\"baz\"), AttributeType::Whitelisted);\n+    reg.register_syntax_extension(\n+        Symbol::intern(\"mac\"), SyntaxExtension::dummy_bang(reg.sess.edition())\n+    );\n }"}, {"sha": "1518c0cc541d24b42f9698c6cd8592503445f125", "filename": "src/test/ui-fulldeps/deprecated-derive.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8eaf17bca2674293eba0ea10056d5c77b6352086/src%2Ftest%2Fui-fulldeps%2Fdeprecated-derive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8eaf17bca2674293eba0ea10056d5c77b6352086/src%2Ftest%2Fui-fulldeps%2Fdeprecated-derive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fdeprecated-derive.stderr?ref=8eaf17bca2674293eba0ea10056d5c77b6352086", "patch": "@@ -2,7 +2,7 @@ warning: use of deprecated item 'Encodable': derive(Encodable) is deprecated in\n   --> $DIR/deprecated-derive.rs:8:10\n    |\n LL | #[derive(Encodable)]\n-   |          ^^^^^^^^^\n+   |          ^^^^^^^^^ help: replace the use of the deprecated item: `RustcEncodable`\n    |\n    = note: `#[warn(deprecated)]` on by default\n "}, {"sha": "4d8ede1680830a163cfab34c229ac0e26943cd2d", "filename": "src/test/ui-fulldeps/plugin-reexport.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8eaf17bca2674293eba0ea10056d5c77b6352086/src%2Ftest%2Fui-fulldeps%2Fplugin-reexport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eaf17bca2674293eba0ea10056d5c77b6352086/src%2Ftest%2Fui-fulldeps%2Fplugin-reexport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fplugin-reexport.rs?ref=8eaf17bca2674293eba0ea10056d5c77b6352086", "patch": "@@ -0,0 +1,10 @@\n+// edition:2018\n+// aux-build:attr-plugin-test.rs\n+// ignore-stage1\n+\n+#![feature(plugin)]\n+#![plugin(attr_plugin_test)]\n+\n+pub use mac as reexport; //~ ERROR `mac` is private, and cannot be re-exported\n+\n+fn main() {}"}, {"sha": "4ac64b8d04b87ea25d759825c7026a9bae6adb8b", "filename": "src/test/ui-fulldeps/plugin-reexport.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8eaf17bca2674293eba0ea10056d5c77b6352086/src%2Ftest%2Fui-fulldeps%2Fplugin-reexport.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8eaf17bca2674293eba0ea10056d5c77b6352086/src%2Ftest%2Fui-fulldeps%2Fplugin-reexport.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fplugin-reexport.stderr?ref=8eaf17bca2674293eba0ea10056d5c77b6352086", "patch": "@@ -0,0 +1,15 @@\n+error[E0364]: `mac` is private, and cannot be re-exported\n+  --> $DIR/plugin-reexport.rs:8:9\n+   |\n+LL | pub use mac as reexport;\n+   |         ^^^^^^^^^^^^^^^\n+   |\n+note: consider marking `mac` as `pub` in the imported module\n+  --> $DIR/plugin-reexport.rs:8:9\n+   |\n+LL | pub use mac as reexport;\n+   |         ^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0364`."}, {"sha": "31eee88d1fac6949195b23feec4aa7cdfbf410da", "filename": "src/test/ui/feature-gate/issue-43106-gating-of-bench.rs", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8eaf17bca2674293eba0ea10056d5c77b6352086/src%2Ftest%2Fui%2Ffeature-gate%2Fissue-43106-gating-of-bench.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eaf17bca2674293eba0ea10056d5c77b6352086/src%2Ftest%2Fui%2Ffeature-gate%2Fissue-43106-gating-of-bench.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate%2Fissue-43106-gating-of-bench.rs?ref=8eaf17bca2674293eba0ea10056d5c77b6352086", "patch": "@@ -1,17 +1,10 @@\n-// error-pattern: `main` function not found\n-\n-// At time of authorship, a crate-level #![bench] with no `--test`\n-// will cause compilation to error unconditionally with \"main function\n-// not found\" (despite having one), similar to #[bench].\n-//\n-// (The non-crate level cases are in\n-// issue-43106-gating-of-builtin-attrs.rs.)\n-\n+// The non-crate level cases are in issue-43106-gating-of-builtin-attrs.rs.\n // See issue-12997-1.rs and issue-12997-2.rs to see how `#[bench]` is\n // handled in \"weird places\" when `--test` is passed.\n \n #![feature(custom_inner_attributes)]\n \n #![bench                   = \"4100\"]\n+//~^ ERROR cannot determine resolution for the attribute macro `bench`\n \n-fn main() { }\n+fn main() {}"}, {"sha": "d0305c5160f7e97241d65bde153a3afd689ff1b6", "filename": "src/test/ui/feature-gate/issue-43106-gating-of-bench.stderr", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8eaf17bca2674293eba0ea10056d5c77b6352086/src%2Ftest%2Fui%2Ffeature-gate%2Fissue-43106-gating-of-bench.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8eaf17bca2674293eba0ea10056d5c77b6352086/src%2Ftest%2Fui%2Ffeature-gate%2Fissue-43106-gating-of-bench.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate%2Fissue-43106-gating-of-bench.stderr?ref=8eaf17bca2674293eba0ea10056d5c77b6352086", "patch": "@@ -1,17 +1,10 @@\n-warning: attribute must be of the form `#[bench]`\n-  --> $DIR/issue-43106-gating-of-bench.rs:15:1\n+error: cannot determine resolution for the attribute macro `bench`\n+  --> $DIR/issue-43106-gating-of-bench.rs:7:4\n    |\n LL | #![bench                   = \"4100\"]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |    ^^^^^\n    |\n-   = note: `#[warn(ill_formed_attribute_input)]` on by default\n-   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-   = note: for more information, see issue #57571 <https://github.com/rust-lang/rust/issues/57571>\n-\n-error[E0601]: `main` function not found in crate `issue_43106_gating_of_bench`\n-   |\n-   = note: consider adding a `main` function to `$DIR/issue-43106-gating-of-bench.rs`\n+   = note: import resolution is stuck, try simplifying macro imports\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0601`."}, {"sha": "d343746955f3974342b2a1641bf9336f2edf0783", "filename": "src/test/ui/feature-gate/issue-43106-gating-of-test.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8eaf17bca2674293eba0ea10056d5c77b6352086/src%2Ftest%2Fui%2Ffeature-gate%2Fissue-43106-gating-of-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eaf17bca2674293eba0ea10056d5c77b6352086/src%2Ftest%2Fui%2Ffeature-gate%2Fissue-43106-gating-of-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate%2Fissue-43106-gating-of-test.rs?ref=8eaf17bca2674293eba0ea10056d5c77b6352086", "patch": "@@ -1,12 +1,6 @@\n-// error-pattern: `main` function not found\n-\n-// At time of authorship, crate-level #[test] attribute with no\n-// `--test` signals unconditional error complaining of missing main\n-// function (despite having one), similar to #[bench].\n-//\n-// (The non-crate level cases are in\n-// issue-43106-gating-of-builtin-attrs.rs.)\n+// The non-crate level cases are in issue-43106-gating-of-builtin-attrs.rs.\n \n #![test                    = \"4200\"]\n+//~^ ERROR cannot determine resolution for the attribute macro `test`\n \n-fn main() { }\n+fn main() {}"}, {"sha": "a7d3a1e16840e39661d6ff27c415c56db1c93f77", "filename": "src/test/ui/feature-gate/issue-43106-gating-of-test.stderr", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8eaf17bca2674293eba0ea10056d5c77b6352086/src%2Ftest%2Fui%2Ffeature-gate%2Fissue-43106-gating-of-test.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8eaf17bca2674293eba0ea10056d5c77b6352086/src%2Ftest%2Fui%2Ffeature-gate%2Fissue-43106-gating-of-test.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate%2Fissue-43106-gating-of-test.stderr?ref=8eaf17bca2674293eba0ea10056d5c77b6352086", "patch": "@@ -1,17 +1,10 @@\n-warning: attribute must be of the form `#[test]`\n-  --> $DIR/issue-43106-gating-of-test.rs:10:1\n+error: cannot determine resolution for the attribute macro `test`\n+  --> $DIR/issue-43106-gating-of-test.rs:3:4\n    |\n LL | #![test                    = \"4200\"]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |    ^^^^\n    |\n-   = note: `#[warn(ill_formed_attribute_input)]` on by default\n-   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-   = note: for more information, see issue #57571 <https://github.com/rust-lang/rust/issues/57571>\n-\n-error[E0601]: `main` function not found in crate `issue_43106_gating_of_test`\n-   |\n-   = note: consider adding a `main` function to `$DIR/issue-43106-gating-of-test.rs`\n+   = note: import resolution is stuck, try simplifying macro imports\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0601`."}, {"sha": "506b21dc7d54488a5e853ac435174f25f6e3c75e", "filename": "src/test/ui/feature-gates/feature-gate-cfg-target-has-atomic.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8eaf17bca2674293eba0ea10056d5c77b6352086/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-cfg-target-has-atomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eaf17bca2674293eba0ea10056d5c77b6352086/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-cfg-target-has-atomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-cfg-target-has-atomic.rs?ref=8eaf17bca2674293eba0ea10056d5c77b6352086", "patch": "@@ -1,4 +1,4 @@\n-#![feature(intrinsics, lang_items, no_core)]\n+#![feature(intrinsics, lang_items, no_core, rustc_attrs)]\n \n #![crate_type=\"rlib\"]\n #![no_core]\n@@ -88,3 +88,7 @@ fn main() {\n     cfg!(target_has_atomic = \"ptr\");\n     //~^ ERROR `cfg(target_has_atomic)` is experimental and subject to change\n }\n+\n+#[macro_export]\n+#[rustc_builtin_macro]\n+macro_rules! cfg { () => () }"}, {"sha": "4ef446f93c860c39430a96685bcef26e4d6b9a47", "filename": "src/test/ui/imports/glob-shadowing.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8eaf17bca2674293eba0ea10056d5c77b6352086/src%2Ftest%2Fui%2Fimports%2Fglob-shadowing.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8eaf17bca2674293eba0ea10056d5c77b6352086/src%2Ftest%2Fui%2Fimports%2Fglob-shadowing.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fglob-shadowing.stderr?ref=8eaf17bca2674293eba0ea10056d5c77b6352086", "patch": "@@ -4,7 +4,7 @@ error[E0659]: `env` is ambiguous (glob import vs any other name from outer scope\n LL |         let x = env!(\"PATH\");\n    |                 ^^^ ambiguous name\n    |\n-   = note: `env` could refer to a built-in macro\n+   = note: `env` could refer to a macro from prelude\n note: `env` could also refer to the macro imported here\n   --> $DIR/glob-shadowing.rs:9:9\n    |\n@@ -19,7 +19,7 @@ error[E0659]: `env` is ambiguous (glob import vs any other name from outer scope\n LL |             let x = env!(\"PATH\");\n    |                     ^^^ ambiguous name\n    |\n-   = note: `env` could refer to a built-in macro\n+   = note: `env` could refer to a macro from prelude\n note: `env` could also refer to the macro imported here\n   --> $DIR/glob-shadowing.rs:17:13\n    |"}, {"sha": "5afdd8889ae7d6a20da4bb04ba865df42e3dbf28", "filename": "src/test/ui/imports/local-modularized-tricky-fail-1.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8eaf17bca2674293eba0ea10056d5c77b6352086/src%2Ftest%2Fui%2Fimports%2Flocal-modularized-tricky-fail-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8eaf17bca2674293eba0ea10056d5c77b6352086/src%2Ftest%2Fui%2Fimports%2Flocal-modularized-tricky-fail-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Flocal-modularized-tricky-fail-1.stderr?ref=8eaf17bca2674293eba0ea10056d5c77b6352086", "patch": "@@ -27,7 +27,7 @@ error[E0659]: `include` is ambiguous (macro-expanded name vs less macro-expanded\n LL | include!();\n    | ^^^^^^^ ambiguous name\n    |\n-   = note: `include` could refer to a built-in macro\n+   = note: `include` could refer to a macro from prelude\n note: `include` could also refer to the macro defined here\n   --> $DIR/local-modularized-tricky-fail-1.rs:17:5\n    |"}, {"sha": "fa692db4bf66ca11af9184361e415ce44ff1f750", "filename": "src/test/ui/issues/issue-28134.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8eaf17bca2674293eba0ea10056d5c77b6352086/src%2Ftest%2Fui%2Fissues%2Fissue-28134.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eaf17bca2674293eba0ea10056d5c77b6352086/src%2Ftest%2Fui%2Fissues%2Fissue-28134.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-28134.rs?ref=8eaf17bca2674293eba0ea10056d5c77b6352086", "patch": "@@ -1,3 +1,3 @@\n // compile-flags: --test\n \n-#![test] //~ ERROR only functions may be used as tests\n+#![test] //~ ERROR cannot determine resolution for the attribute macro `test`"}, {"sha": "5f8d27dd043b1c408512b6f62299b9abe7eae89f", "filename": "src/test/ui/issues/issue-28134.stderr", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8eaf17bca2674293eba0ea10056d5c77b6352086/src%2Ftest%2Fui%2Fissues%2Fissue-28134.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8eaf17bca2674293eba0ea10056d5c77b6352086/src%2Ftest%2Fui%2Fissues%2Fissue-28134.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-28134.stderr?ref=8eaf17bca2674293eba0ea10056d5c77b6352086", "patch": "@@ -1,8 +1,10 @@\n-error: only functions may be used as tests\n-  --> $DIR/issue-28134.rs:3:1\n+error: cannot determine resolution for the attribute macro `test`\n+  --> $DIR/issue-28134.rs:3:4\n    |\n LL | #![test]\n-   | ^^^^^^^^\n+   |    ^^^^\n+   |\n+   = note: import resolution is stuck, try simplifying macro imports\n \n error: aborting due to previous error\n "}, {"sha": "a96b99ae4ff785d778a5115d785b23f12860d997", "filename": "src/test/ui/macros/unknown-builtin.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8eaf17bca2674293eba0ea10056d5c77b6352086/src%2Ftest%2Fui%2Fmacros%2Funknown-builtin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eaf17bca2674293eba0ea10056d5c77b6352086/src%2Ftest%2Fui%2Fmacros%2Funknown-builtin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Funknown-builtin.rs?ref=8eaf17bca2674293eba0ea10056d5c77b6352086", "patch": "@@ -0,0 +1,14 @@\n+// error-pattern: cannot find a built-in macro with name `line`\n+\n+#![feature(rustc_attrs)]\n+\n+#[rustc_builtin_macro]\n+macro_rules! unknown { () => () } //~ ERROR cannot find a built-in macro with name `unknown`\n+\n+#[rustc_builtin_macro]\n+macro_rules! line { () => () }\n+\n+fn main() {\n+    line!();\n+    std::prelude::v1::line!();\n+}"}, {"sha": "33b7b055b4e4b6d27d4fb37c69b6f818ce587f44", "filename": "src/test/ui/macros/unknown-builtin.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8eaf17bca2674293eba0ea10056d5c77b6352086/src%2Ftest%2Fui%2Fmacros%2Funknown-builtin.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8eaf17bca2674293eba0ea10056d5c77b6352086/src%2Ftest%2Fui%2Fmacros%2Funknown-builtin.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Funknown-builtin.stderr?ref=8eaf17bca2674293eba0ea10056d5c77b6352086", "patch": "@@ -0,0 +1,14 @@\n+error: cannot find a built-in macro with name `unknown`\n+  --> $DIR/unknown-builtin.rs:6:1\n+   |\n+LL | macro_rules! unknown { () => () }\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: cannot find a built-in macro with name `line`\n+  --> <::core::macros::builtin::line macros>:1:1\n+   |\n+LL | () => { }\n+   | ^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "5531b32362125b4a4ed227dab4a785b9b3cb08d3", "filename": "src/test/ui/proc-macro/attribute.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8eaf17bca2674293eba0ea10056d5c77b6352086/src%2Ftest%2Fui%2Fproc-macro%2Fattribute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eaf17bca2674293eba0ea10056d5c77b6352086/src%2Ftest%2Fui%2Fproc-macro%2Fattribute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fattribute.rs?ref=8eaf17bca2674293eba0ea10056d5c77b6352086", "patch": "@@ -40,8 +40,7 @@ pub fn foo8(input: TokenStream) -> TokenStream { input }\n //~^ ERROR: `self` cannot be a name of derive macro\n pub fn foo9(input: TokenStream) -> TokenStream { input }\n \n-#[proc_macro_derive(PartialEq)]\n-//~^ ERROR: cannot override a built-in derive macro\n+#[proc_macro_derive(PartialEq)] // OK\n pub fn foo10(input: TokenStream) -> TokenStream { input }\n \n #[proc_macro_derive(d11, a)]"}, {"sha": "1503f62cb6c1a8c0ce3ce09b1125d4d60cf5c184", "filename": "src/test/ui/proc-macro/attribute.stderr", "status": "modified", "additions": 9, "deletions": 15, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8eaf17bca2674293eba0ea10056d5c77b6352086/src%2Ftest%2Fui%2Fproc-macro%2Fattribute.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8eaf17bca2674293eba0ea10056d5c77b6352086/src%2Ftest%2Fui%2Fproc-macro%2Fattribute.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fattribute.stderr?ref=8eaf17bca2674293eba0ea10056d5c77b6352086", "patch": "@@ -40,56 +40,50 @@ error: `self` cannot be a name of derive macro\n LL | #[proc_macro_derive(self)]\n    |                     ^^^^\n \n-error: cannot override a built-in derive macro\n-  --> $DIR/attribute.rs:43:21\n-   |\n-LL | #[proc_macro_derive(PartialEq)]\n-   |                     ^^^^^^^^^\n-\n error: second argument must be `attributes`\n-  --> $DIR/attribute.rs:47:26\n+  --> $DIR/attribute.rs:46:26\n    |\n LL | #[proc_macro_derive(d11, a)]\n    |                          ^\n \n error: attribute must be of form: `attributes(foo, bar)`\n-  --> $DIR/attribute.rs:47:26\n+  --> $DIR/attribute.rs:46:26\n    |\n LL | #[proc_macro_derive(d11, a)]\n    |                          ^\n \n error: attribute must be of form: `attributes(foo, bar)`\n-  --> $DIR/attribute.rs:52:26\n+  --> $DIR/attribute.rs:51:26\n    |\n LL | #[proc_macro_derive(d12, attributes)]\n    |                          ^^^^^^^^^^\n \n error: not a meta item\n-  --> $DIR/attribute.rs:56:37\n+  --> $DIR/attribute.rs:55:37\n    |\n LL | #[proc_macro_derive(d13, attributes(\"a\"))]\n    |                                     ^^^\n \n error: must only be one word\n-  --> $DIR/attribute.rs:60:37\n+  --> $DIR/attribute.rs:59:37\n    |\n LL | #[proc_macro_derive(d14, attributes(a = \"\"))]\n    |                                     ^^^^^^\n \n error: must only be one word\n-  --> $DIR/attribute.rs:64:37\n+  --> $DIR/attribute.rs:63:37\n    |\n LL | #[proc_macro_derive(d15, attributes(m::a))]\n    |                                     ^^^^\n \n error: must only be one word\n-  --> $DIR/attribute.rs:68:37\n+  --> $DIR/attribute.rs:67:37\n    |\n LL | #[proc_macro_derive(d16, attributes(a(b)))]\n    |                                     ^^^^\n \n error: `self` cannot be a name of derive helper attribute\n-  --> $DIR/attribute.rs:72:37\n+  --> $DIR/attribute.rs:71:37\n    |\n LL | #[proc_macro_derive(d17, attributes(self))]\n    |                                     ^^^^\n@@ -106,5 +100,5 @@ error: malformed `proc_macro_derive` attribute input\n LL | #[proc_macro_derive = \"\"]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^ help: must be of the form: `#[proc_macro_derive(TraitName, /*opt*/ attributes(name1, name2, ...))]`\n \n-error: aborting due to 18 previous errors\n+error: aborting due to 17 previous errors\n "}, {"sha": "acb4bbebe7f532a531a9076fb3db4495ea59deef", "filename": "src/test/ui/rfc-2126-extern-absolute-paths/not-whitelisted.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8eaf17bca2674293eba0ea10056d5c77b6352086/src%2Ftest%2Fui%2Frfc-2126-extern-absolute-paths%2Fnot-whitelisted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eaf17bca2674293eba0ea10056d5c77b6352086/src%2Ftest%2Fui%2Frfc-2126-extern-absolute-paths%2Fnot-whitelisted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2126-extern-absolute-paths%2Fnot-whitelisted.rs?ref=8eaf17bca2674293eba0ea10056d5c77b6352086", "patch": "@@ -3,7 +3,7 @@\n // Tests that arbitrary crates (other than `core`, `std` and `meta`)\n // aren't allowed without `--extern`, even if they're in the sysroot.\n use alloc; //~ ERROR unresolved import `alloc`\n-use test; //~ ERROR cannot import a built-in macro\n+use test; // OK, imports the built-in attribute macro `#[test]`, but not the `test` crate.\n use proc_macro; // OK, imports the built-in `proc_macro` attribute, but not the `proc_macro` crate.\n \n fn main() {}"}, {"sha": "f324378d4ca68a5397cd38b02ab5151498b60585", "filename": "src/test/ui/rfc-2126-extern-absolute-paths/not-whitelisted.stderr", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8eaf17bca2674293eba0ea10056d5c77b6352086/src%2Ftest%2Fui%2Frfc-2126-extern-absolute-paths%2Fnot-whitelisted.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8eaf17bca2674293eba0ea10056d5c77b6352086/src%2Ftest%2Fui%2Frfc-2126-extern-absolute-paths%2Fnot-whitelisted.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2126-extern-absolute-paths%2Fnot-whitelisted.stderr?ref=8eaf17bca2674293eba0ea10056d5c77b6352086", "patch": "@@ -1,15 +1,9 @@\n-error: cannot import a built-in macro\n-  --> $DIR/not-whitelisted.rs:6:5\n-   |\n-LL | use test;\n-   |     ^^^^\n-\n error[E0432]: unresolved import `alloc`\n   --> $DIR/not-whitelisted.rs:5:5\n    |\n LL | use alloc;\n    |     ^^^^^ no `alloc` external crate\n \n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0432`."}, {"sha": "48c33d720dcad6808ed0e9582014ecdb0cee21bf", "filename": "src/test/ui/rust-2018/uniform-paths/prelude-fail.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8eaf17bca2674293eba0ea10056d5c77b6352086/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fprelude-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eaf17bca2674293eba0ea10056d5c77b6352086/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fprelude-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fprelude-fail.rs?ref=8eaf17bca2674293eba0ea10056d5c77b6352086", "patch": "@@ -1,11 +1,6 @@\n // edition:2018\n \n-// Built-in macro\n-use env as env_imported; //~ ERROR cannot import a built-in macro\n-\n // Tool attribute\n use rustfmt::skip as imported_rustfmt_skip; //~ ERROR unresolved import `rustfmt`\n \n-fn main() {\n-    env_imported!(\"PATH\");\n-}\n+fn main() {}"}, {"sha": "97d4c736751aae63ac7ed3061a880e54764998eb", "filename": "src/test/ui/rust-2018/uniform-paths/prelude-fail.stderr", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8eaf17bca2674293eba0ea10056d5c77b6352086/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fprelude-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8eaf17bca2674293eba0ea10056d5c77b6352086/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fprelude-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fprelude-fail.stderr?ref=8eaf17bca2674293eba0ea10056d5c77b6352086", "patch": "@@ -1,15 +1,9 @@\n-error: cannot import a built-in macro\n-  --> $DIR/prelude-fail.rs:4:5\n-   |\n-LL | use env as env_imported;\n-   |     ^^^^^^^^^^^^^^^^^^^\n-\n error[E0432]: unresolved import `rustfmt`\n-  --> $DIR/prelude-fail.rs:7:5\n+  --> $DIR/prelude-fail.rs:4:5\n    |\n LL | use rustfmt::skip as imported_rustfmt_skip;\n    |     ^^^^^^^ `rustfmt` is a tool module, not a module\n \n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0432`."}, {"sha": "65763614ce028ef909a646e28058bc8840eecad4", "filename": "src/test/ui/rust-2018/uniform-paths/prelude.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8eaf17bca2674293eba0ea10056d5c77b6352086/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eaf17bca2674293eba0ea10056d5c77b6352086/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fprelude.rs?ref=8eaf17bca2674293eba0ea10056d5c77b6352086", "patch": "@@ -10,9 +10,13 @@ use Vec as ImportedVec;\n // Built-in type\n use u8 as imported_u8;\n \n+// Built-in macro\n+use env as env_imported;\n+\n type A = imported_u8;\n \n fn main() {\n     imported_vec![0];\n     ImportedVec::<u8>::new();\n+    env_imported!(\"PATH\");\n }"}, {"sha": "7db1b01fb0e63053dd036876e4390d84f520febd", "filename": "src/test/ui/rust-unstable-column-gated.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8eaf17bca2674293eba0ea10056d5c77b6352086/src%2Ftest%2Fui%2Frust-unstable-column-gated.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8eaf17bca2674293eba0ea10056d5c77b6352086/src%2Ftest%2Fui%2Frust-unstable-column-gated.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-unstable-column-gated.stderr?ref=8eaf17bca2674293eba0ea10056d5c77b6352086", "patch": "@@ -1,4 +1,4 @@\n-error[E0658]: use of unstable library feature '__rust_unstable_column': internal implementation detail of the `column` macro\n+error[E0658]: use of unstable library feature '__rust_unstable_column': internal implementation detail of the `panic` macro\n   --> $DIR/rust-unstable-column-gated.rs:2:20\n    |\n LL |     println!(\"{}\", __rust_unstable_column!());"}]}