{"sha": "2f44ef282e7495c17c3771732e37621e7377d33e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJmNDRlZjI4MmU3NDk1YzE3YzM3NzE3MzJlMzc2MjFlNzM3N2QzM2U=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2017-11-16T13:09:44Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2017-11-16T13:09:44Z"}, "message": "incr.comp.: Encode DefIds as DefPathHashes instead of recomputing those during deserialization.", "tree": {"sha": "ae194d445cb8d7bcfe4a888385593b0231806ef1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ae194d445cb8d7bcfe4a888385593b0231806ef1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2f44ef282e7495c17c3771732e37621e7377d33e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2f44ef282e7495c17c3771732e37621e7377d33e", "html_url": "https://github.com/rust-lang/rust/commit/2f44ef282e7495c17c3771732e37621e7377d33e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2f44ef282e7495c17c3771732e37621e7377d33e/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "24e54ddefadd3be0fa32f033f9b744cac6a11af6", "url": "https://api.github.com/repos/rust-lang/rust/commits/24e54ddefadd3be0fa32f033f9b744cac6a11af6", "html_url": "https://github.com/rust-lang/rust/commit/24e54ddefadd3be0fa32f033f9b744cac6a11af6"}], "stats": {"total": 138, "additions": 65, "deletions": 73}, "files": [{"sha": "209b89fc03fa2d6c81b42b9c0fb76b6cd24f2620", "filename": "src/librustc/ty/maps/on_disk_cache.rs", "status": "modified", "additions": 65, "deletions": 73, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/2f44ef282e7495c17c3771732e37621e7377d33e/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f44ef282e7495c17c3771732e37621e7377d33e/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs?ref=2f44ef282e7495c17c3771732e37621e7377d33e", "patch": "@@ -11,9 +11,9 @@\n use dep_graph::{DepNodeIndex, SerializedDepNodeIndex};\n use errors::Diagnostic;\n use hir;\n-use hir::def_id::{CrateNum, DefIndex, DefId, RESERVED_FOR_INCR_COMP_CACHE,\n-                  LOCAL_CRATE};\n-use hir::map::definitions::{Definitions, DefPathTable};\n+use hir::def_id::{CrateNum, DefIndex, DefId, LocalDefId,\n+                  RESERVED_FOR_INCR_COMP_CACHE, LOCAL_CRATE};\n+use hir::map::definitions::DefPathHash;\n use middle::const_val::ByteArray;\n use middle::cstore::CrateStore;\n use rustc_data_structures::fx::FxHashMap;\n@@ -37,7 +37,6 @@ use ty::subst::Substs;\n // Some magic values used for verifying that encoding and decoding. These are\n // basically random numbers.\n const PREV_DIAGNOSTICS_TAG: u64 = 0x1234_5678_A1A1_A1A1;\n-const DEF_PATH_TABLE_TAG: u64 = 0x1234_5678_B2B2_B2B2;\n const QUERY_RESULT_INDEX_TAG: u64 = 0x1234_5678_C3C3_C3C3;\n \n /// `OnDiskCache` provides an interface to incr. comp. data cached from the\n@@ -56,10 +55,8 @@ pub struct OnDiskCache<'sess> {\n     // compilation session.\n     current_diagnostics: RefCell<FxHashMap<DepNodeIndex, Vec<Diagnostic>>>,\n \n-\n     prev_cnums: Vec<(u32, String, CrateDisambiguator)>,\n     cnum_map: RefCell<Option<IndexVec<CrateNum, Option<CrateNum>>>>,\n-    prev_def_path_tables: Vec<DefPathTable>,\n \n     prev_filemap_starts: BTreeMap<BytePos, StableFilemapId>,\n     codemap: &'sess CodeMap,\n@@ -92,14 +89,13 @@ impl<'sess> OnDiskCache<'sess> {\n             (header, decoder.position())\n         };\n \n-        let (prev_diagnostics, prev_def_path_tables, query_result_index) = {\n+        let (prev_diagnostics, query_result_index) = {\n             let mut decoder = CacheDecoder {\n                 tcx: None,\n                 opaque: opaque::Decoder::new(&data[..], post_header_pos),\n                 codemap: sess.codemap(),\n                 prev_filemap_starts: &header.prev_filemap_starts,\n                 cnum_map: &IndexVec::new(),\n-                prev_def_path_tables: &Vec::new(),\n             };\n \n             // Decode Diagnostics\n@@ -111,11 +107,6 @@ impl<'sess> OnDiskCache<'sess> {\n                 diagnostics.into_iter().collect()\n             };\n \n-            // Decode DefPathTables\n-            let prev_def_path_tables: Vec<DefPathTable> =\n-                decode_tagged(&mut decoder, DEF_PATH_TABLE_TAG)\n-                    .expect(\"Error while trying to decode cached DefPathTables.\");\n-\n             // Decode the *position* of the query result index\n             let query_result_index_pos = {\n                 let pos_pos = data.len() - IntEncodedWithFixedSize::ENCODED_SIZE;\n@@ -131,7 +122,7 @@ impl<'sess> OnDiskCache<'sess> {\n                     decode_tagged(decoder, QUERY_RESULT_INDEX_TAG)\n                 }).expect(\"Error while trying to decode query result index.\");\n \n-            (prev_diagnostics, prev_def_path_tables, query_result_index)\n+            (prev_diagnostics, query_result_index)\n         };\n \n         OnDiskCache {\n@@ -140,7 +131,6 @@ impl<'sess> OnDiskCache<'sess> {\n             prev_filemap_starts: header.prev_filemap_starts,\n             prev_cnums: header.prev_cnums,\n             cnum_map: RefCell::new(None),\n-            prev_def_path_tables,\n             codemap: sess.codemap(),\n             current_diagnostics: RefCell::new(FxHashMap()),\n             query_result_index: query_result_index.into_iter().collect(),\n@@ -154,7 +144,6 @@ impl<'sess> OnDiskCache<'sess> {\n             prev_filemap_starts: BTreeMap::new(),\n             prev_cnums: vec![],\n             cnum_map: RefCell::new(None),\n-            prev_def_path_tables: Vec::new(),\n             codemap,\n             current_diagnostics: RefCell::new(FxHashMap()),\n             query_result_index: FxHashMap(),\n@@ -172,10 +161,10 @@ impl<'sess> OnDiskCache<'sess> {\n         let _in_ignore = tcx.dep_graph.in_ignore();\n \n         let mut encoder = CacheEncoder {\n+            tcx,\n             encoder,\n             type_shorthands: FxHashMap(),\n             predicate_shorthands: FxHashMap(),\n-            definitions: tcx.hir.definitions(),\n         };\n \n \n@@ -212,22 +201,6 @@ impl<'sess> OnDiskCache<'sess> {\n         encoder.encode_tagged(PREV_DIAGNOSTICS_TAG, &diagnostics)?;\n \n \n-        // Encode all DefPathTables\n-        let upstream_def_path_tables = tcx.all_crate_nums(LOCAL_CRATE)\n-                                          .iter()\n-                                          .map(|&cnum| (cnum, cstore.def_path_table(cnum)))\n-                                          .collect::<FxHashMap<_,_>>();\n-        let def_path_tables: Vec<&DefPathTable> = sorted_cnums.into_iter().map(|cnum| {\n-            if cnum == LOCAL_CRATE {\n-                tcx.hir.definitions().def_path_table()\n-            } else {\n-                &*upstream_def_path_tables[&cnum]\n-            }\n-        }).collect();\n-\n-        encoder.encode_tagged(DEF_PATH_TABLE_TAG, &def_path_tables)?;\n-\n-\n         // Encode query results\n         let mut query_result_index = EncodedQueryResultIndex::new();\n \n@@ -297,7 +270,6 @@ impl<'sess> OnDiskCache<'sess> {\n             codemap: self.codemap,\n             prev_filemap_starts: &self.prev_filemap_starts,\n             cnum_map: cnum_map.as_ref().unwrap(),\n-            prev_def_path_tables: &self.prev_def_path_tables,\n         };\n \n         match decode_tagged(&mut decoder, dep_node_index) {\n@@ -373,7 +345,6 @@ struct CacheDecoder<'a, 'tcx: 'a, 'x> {\n     codemap: &'x CodeMap,\n     prev_filemap_starts: &'x BTreeMap<BytePos, StableFilemapId>,\n     cnum_map: &'x IndexVec<CrateNum, Option<CrateNum>>,\n-    prev_def_path_tables: &'x Vec<DefPathTable>,\n }\n \n impl<'a, 'tcx, 'x> CacheDecoder<'a, 'tcx, 'x> {\n@@ -548,32 +519,24 @@ impl<'a, 'tcx, 'x> SpecializedDecoder<DefIndex> for CacheDecoder<'a, 'tcx, 'x> {\n // sessions, to map the old DefId to the new one.\n impl<'a, 'tcx, 'x> SpecializedDecoder<DefId> for CacheDecoder<'a, 'tcx, 'x> {\n     fn specialized_decode(&mut self) -> Result<DefId, Self::Error> {\n-        // Decode the unmapped CrateNum\n-        let prev_cnum = CrateNum::default_decode(self)?;\n-\n-        // Decode the unmapped DefIndex\n-        let def_index = DefIndex::default_decode(self)?;\n-\n-        // Unmapped CrateNum and DefIndex are valid keys for the *cached*\n-        // DefPathTables, so we use them to look up the DefPathHash.\n-        let def_path_hash = self.prev_def_path_tables[prev_cnum.index()]\n-                                .def_path_hash(def_index);\n+        // Load the DefPathHash which is was we encoded the DefId as.\n+        let def_path_hash = DefPathHash::decode(self)?;\n \n         // Using the DefPathHash, we can lookup the new DefId\n         Ok(self.tcx().def_path_hash_to_def_id.as_ref().unwrap()[&def_path_hash])\n     }\n }\n \n+impl<'a, 'tcx, 'x> SpecializedDecoder<LocalDefId> for CacheDecoder<'a, 'tcx, 'x> {\n+    fn specialized_decode(&mut self) -> Result<LocalDefId, Self::Error> {\n+        Ok(LocalDefId::from_def_id(DefId::decode(self)?))\n+    }\n+}\n+\n impl<'a, 'tcx, 'x> SpecializedDecoder<hir::HirId> for CacheDecoder<'a, 'tcx, 'x> {\n     fn specialized_decode(&mut self) -> Result<hir::HirId, Self::Error> {\n-        // Decode the unmapped DefIndex of the HirId.\n-        let def_index = DefIndex::default_decode(self)?;\n-\n-        // Use the unmapped DefIndex to look up the DefPathHash in the cached\n-        // DefPathTable. For HirIds we know that we always have to look in the\n-        // *local* DefPathTable.\n-        let def_path_hash = self.prev_def_path_tables[LOCAL_CRATE.index()]\n-                                .def_path_hash(def_index);\n+        // Load the DefPathHash which is was we encoded the DefIndex as.\n+        let def_path_hash = DefPathHash::decode(self)?;\n \n         // Use the DefPathHash to map to the current DefId.\n         let def_id = self.tcx()\n@@ -666,16 +629,17 @@ for CacheDecoder<'a, 'tcx, 'x> {\n \n //- ENCODING -------------------------------------------------------------------\n \n-struct CacheEncoder<'enc, 'tcx, E>\n-    where E: 'enc + ty_codec::TyEncoder\n+struct CacheEncoder<'enc, 'a, 'tcx, E>\n+    where E: 'enc + ty_codec::TyEncoder,\n+          'tcx: 'a,\n {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     encoder: &'enc mut E,\n     type_shorthands: FxHashMap<ty::Ty<'tcx>, usize>,\n     predicate_shorthands: FxHashMap<ty::Predicate<'tcx>, usize>,\n-    definitions: &'enc Definitions,\n }\n \n-impl<'enc, 'tcx, E> CacheEncoder<'enc, 'tcx, E>\n+impl<'enc, 'a, 'tcx, E> CacheEncoder<'enc, 'a, 'tcx, E>\n     where E: 'enc + ty_codec::TyEncoder\n {\n     /// Encode something with additional information that allows to do some\n@@ -699,15 +663,15 @@ impl<'enc, 'tcx, E> CacheEncoder<'enc, 'tcx, E>\n     }\n }\n \n-impl<'enc, 'tcx, E> ty_codec::TyEncoder for CacheEncoder<'enc, 'tcx, E>\n+impl<'enc, 'a, 'tcx, E> ty_codec::TyEncoder for CacheEncoder<'enc, 'a, 'tcx, E>\n     where E: 'enc + ty_codec::TyEncoder\n {\n     fn position(&self) -> usize {\n         self.encoder.position()\n     }\n }\n \n-impl<'enc, 'tcx, E> SpecializedEncoder<ty::Ty<'tcx>> for CacheEncoder<'enc, 'tcx, E>\n+impl<'enc, 'a, 'tcx, E> SpecializedEncoder<ty::Ty<'tcx>> for CacheEncoder<'enc, 'a, 'tcx, E>\n     where E: 'enc + ty_codec::TyEncoder\n {\n     fn specialized_encode(&mut self, ty: &ty::Ty<'tcx>) -> Result<(), Self::Error> {\n@@ -716,8 +680,8 @@ impl<'enc, 'tcx, E> SpecializedEncoder<ty::Ty<'tcx>> for CacheEncoder<'enc, 'tcx\n     }\n }\n \n-impl<'enc, 'tcx, E> SpecializedEncoder<ty::GenericPredicates<'tcx>>\n-    for CacheEncoder<'enc, 'tcx, E>\n+impl<'enc, 'a, 'tcx, E> SpecializedEncoder<ty::GenericPredicates<'tcx>>\n+    for CacheEncoder<'enc, 'a, 'tcx, E>\n     where E: 'enc + ty_codec::TyEncoder\n {\n     fn specialized_encode(&mut self,\n@@ -728,7 +692,7 @@ impl<'enc, 'tcx, E> SpecializedEncoder<ty::GenericPredicates<'tcx>>\n     }\n }\n \n-impl<'enc, 'tcx, E> SpecializedEncoder<hir::HirId> for CacheEncoder<'enc, 'tcx, E>\n+impl<'enc, 'a, 'tcx, E> SpecializedEncoder<hir::HirId> for CacheEncoder<'enc, 'a, 'tcx, E>\n     where E: 'enc + ty_codec::TyEncoder\n {\n     fn specialized_encode(&mut self, id: &hir::HirId) -> Result<(), Self::Error> {\n@@ -737,18 +701,46 @@ impl<'enc, 'tcx, E> SpecializedEncoder<hir::HirId> for CacheEncoder<'enc, 'tcx,\n             local_id,\n         } = *id;\n \n-        owner.encode(self)?;\n+        let def_path_hash = self.tcx.hir.definitions().def_path_hash(owner);\n+\n+        def_path_hash.encode(self)?;\n         local_id.encode(self)\n     }\n }\n \n+\n+impl<'enc, 'a, 'tcx, E> SpecializedEncoder<DefId> for CacheEncoder<'enc, 'a, 'tcx, E>\n+    where E: 'enc + ty_codec::TyEncoder\n+{\n+    fn specialized_encode(&mut self, id: &DefId) -> Result<(), Self::Error> {\n+        let def_path_hash = self.tcx.def_path_hash(*id);\n+        def_path_hash.encode(self)\n+    }\n+}\n+\n+impl<'enc, 'a, 'tcx, E> SpecializedEncoder<LocalDefId> for CacheEncoder<'enc, 'a, 'tcx, E>\n+    where E: 'enc + ty_codec::TyEncoder\n+{\n+    fn specialized_encode(&mut self, id: &LocalDefId) -> Result<(), Self::Error> {\n+        id.to_def_id().encode(self)\n+    }\n+}\n+\n+impl<'enc, 'a, 'tcx, E> SpecializedEncoder<DefIndex> for CacheEncoder<'enc, 'a, 'tcx, E>\n+    where E: 'enc + ty_codec::TyEncoder\n+{\n+    fn specialized_encode(&mut self, _: &DefIndex) -> Result<(), Self::Error> {\n+        bug!(\"Encoding DefIndex without context.\")\n+    }\n+}\n+\n // NodeIds are not stable across compilation sessions, so we store them in their\n // HirId representation. This allows use to map them to the current NodeId.\n-impl<'enc, 'tcx, E> SpecializedEncoder<NodeId> for CacheEncoder<'enc, 'tcx, E>\n+impl<'enc, 'a, 'tcx, E> SpecializedEncoder<NodeId> for CacheEncoder<'enc, 'a, 'tcx, E>\n     where E: 'enc + ty_codec::TyEncoder\n {\n     fn specialized_encode(&mut self, node_id: &NodeId) -> Result<(), Self::Error> {\n-        let hir_id = self.definitions.node_to_hir_id(*node_id);\n+        let hir_id = self.tcx.hir.node_to_hir_id(*node_id);\n         hir_id.encode(self)\n     }\n }\n@@ -761,7 +753,7 @@ macro_rules! encoder_methods {\n     }\n }\n \n-impl<'enc, 'tcx, E> Encoder for CacheEncoder<'enc, 'tcx, E>\n+impl<'enc, 'a, 'tcx, E> Encoder for CacheEncoder<'enc, 'a, 'tcx, E>\n     where E: 'enc + ty_codec::TyEncoder\n {\n     type Error = E::Error;\n@@ -803,8 +795,8 @@ impl IntEncodedWithFixedSize {\n impl UseSpecializedEncodable for IntEncodedWithFixedSize {}\n impl UseSpecializedDecodable for IntEncodedWithFixedSize {}\n \n-impl<'enc, 'tcx, E> SpecializedEncoder<IntEncodedWithFixedSize>\n-for CacheEncoder<'enc, 'tcx, E>\n+impl<'enc, 'a, 'tcx, E> SpecializedEncoder<IntEncodedWithFixedSize>\n+for CacheEncoder<'enc, 'a, 'tcx, E>\n     where E: 'enc + ty_codec::TyEncoder\n {\n     fn specialized_encode(&mut self, x: &IntEncodedWithFixedSize) -> Result<(), Self::Error> {\n@@ -836,12 +828,12 @@ for CacheDecoder<'a, 'tcx, 'x> {\n     }\n }\n \n-fn encode_query_results<'x, 'a, 'tcx, Q, E>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                            encoder: &mut CacheEncoder<'x, 'tcx, E>,\n-                                            query_result_index: &mut EncodedQueryResultIndex)\n-                                            -> Result<(), E::Error>\n+fn encode_query_results<'enc, 'a, 'tcx, Q, E>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                              encoder: &mut CacheEncoder<'enc, 'a, 'tcx, E>,\n+                                              query_result_index: &mut EncodedQueryResultIndex)\n+                                              -> Result<(), E::Error>\n     where Q: super::plumbing::GetCacheInternal<'tcx>,\n-          E: 'x + TyEncoder,\n+          E: 'enc + TyEncoder,\n           Q::Value: Encodable,\n {\n     for (key, entry) in Q::get_cache_internal(tcx).map.iter() {"}]}