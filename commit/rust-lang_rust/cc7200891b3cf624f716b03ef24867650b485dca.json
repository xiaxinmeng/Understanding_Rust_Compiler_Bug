{"sha": "cc7200891b3cf624f716b03ef24867650b485dca", "node_id": "C_kwDOAAsO6NoAKGNjNzIwMDg5MWIzY2Y2MjRmNzE2YjAzZWYyNDg2NzY1MGI0ODVkY2E", "commit": {"author": {"name": "Kartavya Vashishtha", "email": "sendtokartavya@gmail.com", "date": "2022-09-10T14:42:47Z"}, "committer": {"name": "Kartavya Vashishtha", "email": "sendtokartavya@gmail.com", "date": "2022-09-10T14:43:46Z"}, "message": "new lint: move_format_string_arg\n\nThe name might need some improving.\n\nextract format_like's parser to it's own module in ide-db\n\nreworked the parser's API to be more direct\n\nadded assist to extract expressions in format args", "tree": {"sha": "a895ea69f6b1717e9ab40c03231cb218748979ae", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a895ea69f6b1717e9ab40c03231cb218748979ae"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cc7200891b3cf624f716b03ef24867650b485dca", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEE+fRQYdEX7Emd36W/pQASwjJOXfAFAmMcoqIACgkQpQASwjJO\nXfCy5A//ajD2uSes9JSZNJM8Chi5QV6j571i6J8HfJ15o7DYbc1Iu7Z/4g+COT0j\n3BZP9O56oCKUN9NU2RTGCc+JGiaObpA58/V2/ZwHB460zlB+Ut6YMr/THfC49vD/\nQTB0ZVqYDwDt3QvcXHXAoaaSOngcmaoUt/ZiPEcUr40+ynnRETPQchcV0D/LyemB\nneMx4oms9El0wGfe5z1sJlwyo0klC3kYdTJUHU6WmFsprqYri7gQcd42hIMqDfcA\npSOQBzrPEdMF1F3Gwv9IY/lfqyzyY/iER1QKL4oH7PXfBqe/fNBZM4roOzGm5R/W\n1rifU4cZ7fWwIpEhKgbK+r72hpx373dn+oYZPrjvjFddWwj+M2GuEyqOSM/A7sRe\ntgDVmx4Gw3CQorT58R1rzCN3mc9DT2UoYNluGThycU+1mIzVX07I8cdhRR1y5fm+\nd7ccHfzoiE/361tibP2ySm6L6NzIib1xhw8UYn56mcEdhFn+NwybnD3StyxOvFT1\nDY9e88+gl7/YnElqc21LZyckdSu8vo4vWHP0/+q0iofrFuTVDFY/6jz3NUZBEU6r\nIAnVVvUxQQzUN+9LIxiZjdhVVly9Tvz2DMZvMO+NtgoHd4XoOMozwT8cPvhK2Qen\nVTeKwrcRkieuSH1PPZzs3TnTSeQlmK4s7V4yTdYpmjqnYOWMX2Q=\n=Ap5s\n-----END PGP SIGNATURE-----", "payload": "tree a895ea69f6b1717e9ab40c03231cb218748979ae\nparent 2584d48508a0a8cef8794eccfe30db583948eb96\nauthor Kartavya Vashishtha <sendtokartavya@gmail.com> 1662820967 +0530\ncommitter Kartavya Vashishtha <sendtokartavya@gmail.com> 1662821026 +0530\n\nnew lint: move_format_string_arg\n\nThe name might need some improving.\n\nextract format_like's parser to it's own module in ide-db\n\nreworked the parser's API to be more direct\n\nadded assist to extract expressions in format args\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cc7200891b3cf624f716b03ef24867650b485dca", "html_url": "https://github.com/rust-lang/rust/commit/cc7200891b3cf624f716b03ef24867650b485dca", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cc7200891b3cf624f716b03ef24867650b485dca/comments", "author": {"login": "DesmondWillowbrook", "id": 51814158, "node_id": "MDQ6VXNlcjUxODE0MTU4", "avatar_url": "https://avatars.githubusercontent.com/u/51814158?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DesmondWillowbrook", "html_url": "https://github.com/DesmondWillowbrook", "followers_url": "https://api.github.com/users/DesmondWillowbrook/followers", "following_url": "https://api.github.com/users/DesmondWillowbrook/following{/other_user}", "gists_url": "https://api.github.com/users/DesmondWillowbrook/gists{/gist_id}", "starred_url": "https://api.github.com/users/DesmondWillowbrook/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DesmondWillowbrook/subscriptions", "organizations_url": "https://api.github.com/users/DesmondWillowbrook/orgs", "repos_url": "https://api.github.com/users/DesmondWillowbrook/repos", "events_url": "https://api.github.com/users/DesmondWillowbrook/events{/privacy}", "received_events_url": "https://api.github.com/users/DesmondWillowbrook/received_events", "type": "User", "site_admin": false}, "committer": {"login": "DesmondWillowbrook", "id": 51814158, "node_id": "MDQ6VXNlcjUxODE0MTU4", "avatar_url": "https://avatars.githubusercontent.com/u/51814158?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DesmondWillowbrook", "html_url": "https://github.com/DesmondWillowbrook", "followers_url": "https://api.github.com/users/DesmondWillowbrook/followers", "following_url": "https://api.github.com/users/DesmondWillowbrook/following{/other_user}", "gists_url": "https://api.github.com/users/DesmondWillowbrook/gists{/gist_id}", "starred_url": "https://api.github.com/users/DesmondWillowbrook/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DesmondWillowbrook/subscriptions", "organizations_url": "https://api.github.com/users/DesmondWillowbrook/orgs", "repos_url": "https://api.github.com/users/DesmondWillowbrook/repos", "events_url": "https://api.github.com/users/DesmondWillowbrook/events{/privacy}", "received_events_url": "https://api.github.com/users/DesmondWillowbrook/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2584d48508a0a8cef8794eccfe30db583948eb96", "url": "https://api.github.com/repos/rust-lang/rust/commits/2584d48508a0a8cef8794eccfe30db583948eb96", "html_url": "https://github.com/rust-lang/rust/commit/2584d48508a0a8cef8794eccfe30db583948eb96"}], "stats": {"total": 324, "additions": 192, "deletions": 132}, "files": [{"sha": "54b5bee9b7b0c561e036dfc6307893991f63a55c", "filename": "crates/ide-assists/src/handlers/move_format_string_arg.rs", "status": "modified", "additions": 143, "deletions": 95, "changes": 238, "blob_url": "https://github.com/rust-lang/rust/blob/cc7200891b3cf624f716b03ef24867650b485dca/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_format_string_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc7200891b3cf624f716b03ef24867650b485dca/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_format_string_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_format_string_arg.rs?ref=cc7200891b3cf624f716b03ef24867650b485dca", "patch": "@@ -1,100 +1,133 @@\n-use ide_db::{syntax_helpers::{format_string::is_format_string, format_string_exprs::{parse_format_exprs, Arg}}, assists::{AssistId, AssistKind}};\n+use crate::{AssistContext, Assists};\n+use ide_db::{\n+    assists::{AssistId, AssistKind},\n+    syntax_helpers::{\n+        format_string::is_format_string,\n+        format_string_exprs::{parse_format_exprs, Arg},\n+    },\n+};\n use itertools::Itertools;\n-use syntax::{ast, AstToken, AstNode, NodeOrToken, SyntaxKind::COMMA, TextRange};\n+use syntax::{ast, AstNode, AstToken, NodeOrToken, SyntaxKind::COMMA, TextRange};\n \n // Assist: move_format_string_arg\n //\n // Move an expression out of a format string.\n //\n // ```\n+// macro_rules! format_args {\n+//     ($lit:literal $(tt:tt)*) => { 0 },\n+// }\n+// macro_rules! print {\n+//     ($($arg:tt)*) => (std::io::_print(format_args!($($arg)*)));\n+// }\n+//\n // fn main() {\n-//     println!(\"{x + 1}$0\");\n+//     print!(\"{x + 1}$0\");\n // }\n // ```\n // ->\n // ```\n+// macro_rules! format_args {\n+//     ($lit:literal $(tt:tt)*) => { 0 },\n+// }\n+// macro_rules! print {\n+//     ($($arg:tt)*) => (std::io::_print(format_args!($($arg)*)));\n+// }\n+//\n // fn main() {\n-//     println!(\"{a}\", a$0 = x + 1);\n+//     print!(\"{}\"$0, x + 1);\n // }\n // ```\n \n-use crate::{AssistContext, /* AssistId, AssistKind, */ Assists};\n-\n-pub(crate) fn move_format_string_arg (acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n-    let t = ctx.find_token_at_offset::<ast::String>()?;\n-    let tt = t.syntax().parent_ancestors().find_map(ast::TokenTree::cast)?;\n-\n-    let expanded_t = ast::String::cast(ctx.sema.descend_into_macros_with_kind_preference(t.syntax().clone()))?;\n+pub(crate) fn move_format_string_arg(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n+    let fmt_string = ctx.find_token_at_offset::<ast::String>()?;\n+    let tt = fmt_string.syntax().parent_ancestors().find_map(ast::TokenTree::cast)?;\n \n+    let expanded_t = ast::String::cast(\n+        ctx.sema.descend_into_macros_with_kind_preference(fmt_string.syntax().clone()),\n+    )?;\n     if !is_format_string(&expanded_t) {\n         return None;\n     }\n \n-    let target = tt.syntax().text_range();\n-    let extracted_args = parse_format_exprs(&t).ok()?;\n-    let str_range = t.syntax().text_range();\n-\n-    let tokens =\n-        tt.token_trees_and_tokens()\n-            .filter_map(NodeOrToken::into_token)\n-            .collect_vec();\n-\n-    acc.add(AssistId(\"move_format_string_arg\", AssistKind::QuickFix), \"Extract format args\", target, |edit| {\n-        let mut existing_args: Vec<String> = vec![];\n-        let mut current_arg = String::new();\n-\n-        if let [_opening_bracket, format_string, _args_start_comma, tokens @ .., end_bracket] = tokens.as_slice() {\n-            for t in tokens {\n-                if t.kind() == COMMA {\n-                    existing_args.push(current_arg.trim().into());\n-                    current_arg.clear();\n-                } else {\n-                    current_arg.push_str(t.text());\n+    let (new_fmt, extracted_args) = parse_format_exprs(fmt_string.text()).ok()?;\n+\n+    acc.add(\n+        AssistId(\"move_format_string_arg\", AssistKind::QuickFix),\n+        \"Extract format args\",\n+        tt.syntax().text_range(),\n+        |edit| {\n+            let fmt_range = fmt_string.syntax().text_range();\n+\n+            // Replace old format string with new format string whose arguments have been extracted\n+            edit.replace(fmt_range, new_fmt);\n+\n+            // Insert cursor at end of format string\n+            edit.insert(fmt_range.end(), \"$0\");\n+\n+            // Extract existing arguments in macro\n+            let tokens =\n+                tt.token_trees_and_tokens().filter_map(NodeOrToken::into_token).collect_vec();\n+\n+            let mut existing_args: Vec<String> = vec![];\n+\n+            let mut current_arg = String::new();\n+            if let [_opening_bracket, format_string, _args_start_comma, tokens @ .., end_bracket] =\n+                tokens.as_slice()\n+            {\n+                for t in tokens {\n+                    if t.kind() == COMMA {\n+                        existing_args.push(current_arg.trim().into());\n+                        current_arg.clear();\n+                    } else {\n+                        current_arg.push_str(t.text());\n+                    }\n                 }\n+                existing_args.push(current_arg.trim().into());\n+\n+                // delete everything after the format string till end bracket\n+                // we're going to insert the new arguments later\n+                edit.delete(TextRange::new(\n+                    format_string.text_range().end(),\n+                    end_bracket.text_range().start(),\n+                ));\n             }\n-            existing_args.push(current_arg.trim().into());\n-\n-            // delete everything after the format string to the end bracket\n-            // we're going to insert the new arguments later\n-            edit.delete(TextRange::new(format_string.text_range().end(), end_bracket.text_range().start()));\n-        }\n-\n-        let mut existing_args = existing_args.into_iter();\n-\n-        // insert cursor at end of format string\n-        edit.insert(str_range.end(), \"$0\");\n-        let mut placeholder_idx = 1;\n-        let mut args = String::new();\n-\n-        for (text, extracted_args) in extracted_args {\n-            // remove expr from format string\n-            edit.delete(text);\n-\n-            args.push_str(\", \");\n-\n-            match extracted_args {\n-                Arg::Expr(s) => {\n-                    // insert arg\n-                    args.push_str(&s);\n-                },\n-                Arg::Placeholder => {\n-                    // try matching with existing argument\n-                    match existing_args.next() {\n-                        Some(ea) => {\n-                            args.push_str(&ea);\n-                        },\n-                        None => {\n-                            // insert placeholder\n-                            args.push_str(&format!(\"${placeholder_idx}\"));\n-                            placeholder_idx += 1;\n+\n+            // Start building the new args\n+            let mut existing_args = existing_args.into_iter();\n+            let mut args = String::new();\n+\n+            let mut placeholder_idx = 1;\n+\n+            for extracted_args in extracted_args {\n+                // remove expr from format string\n+                args.push_str(\", \");\n+\n+                match extracted_args {\n+                    Arg::Expr(s) => {\n+                        // insert arg\n+                        args.push_str(&s);\n+                    }\n+                    Arg::Placeholder => {\n+                        // try matching with existing argument\n+                        match existing_args.next() {\n+                            Some(ea) => {\n+                                args.push_str(&ea);\n+                            }\n+                            None => {\n+                                // insert placeholder\n+                                args.push_str(&format!(\"${placeholder_idx}\"));\n+                                placeholder_idx += 1;\n+                            }\n                         }\n                     }\n                 }\n             }\n-        }\n \n-        edit.insert(str_range.end(), args);\n-    });\n+            // Insert new args\n+            edit.insert(fmt_range.end(), args);\n+        },\n+    );\n \n     Some(())\n }\n@@ -113,97 +146,112 @@ macro_rules! print {\n }\n \"#;\n \n-    fn add_macro_decl (s: &'static str) -> String {\n+    fn add_macro_decl(s: &'static str) -> String {\n         MACRO_DECL.to_string() + s\n     }\n \n     #[test]\n     fn multiple_middle_arg() {\n         check_assist(\n             move_format_string_arg,\n-            &add_macro_decl(r#\"\n+            &add_macro_decl(\n+                r#\"\n fn main() {\n     print!(\"{} {x + 1:b} {}$0\", y + 2, 2);\n }\n-\"#),\n-\n-            &add_macro_decl(r#\"\n+\"#,\n+            ),\n+            &add_macro_decl(\n+                r#\"\n fn main() {\n     print!(\"{} {:b} {}\"$0, y + 2, x + 1, 2);\n }\n-\"#),\n+\"#,\n+            ),\n         );\n     }\n \n     #[test]\n     fn single_arg() {\n         check_assist(\n             move_format_string_arg,\n-            &add_macro_decl(r#\"\n+            &add_macro_decl(\n+                r#\"\n fn main() {\n     print!(\"{obj.value:b}$0\",);\n }\n-\"#),\n-            &add_macro_decl(r#\"\n+\"#,\n+            ),\n+            &add_macro_decl(\n+                r#\"\n fn main() {\n     print!(\"{:b}\"$0, obj.value);\n }\n-\"#),\n+\"#,\n+            ),\n         );\n     }\n \n     #[test]\n     fn multiple_middle_placeholders_arg() {\n         check_assist(\n             move_format_string_arg,\n-            &add_macro_decl(r#\"\n+            &add_macro_decl(\n+                r#\"\n fn main() {\n     print!(\"{} {x + 1:b} {} {}$0\", y + 2, 2);\n }\n-\"#),\n-\n-            &add_macro_decl(r#\"\n+\"#,\n+            ),\n+            &add_macro_decl(\n+                r#\"\n fn main() {\n     print!(\"{} {:b} {} {}\"$0, y + 2, x + 1, 2, $1);\n }\n-\"#),\n+\"#,\n+            ),\n         );\n     }\n \n     #[test]\n     fn multiple_trailing_args() {\n         check_assist(\n             move_format_string_arg,\n-            &add_macro_decl(r#\"\n+            &add_macro_decl(\n+                r#\"\n fn main() {\n     print!(\"{} {x + 1:b} {Struct(1, 2)}$0\", 1);\n }\n-\"#),\n-\n-            &add_macro_decl(r#\"\n+\"#,\n+            ),\n+            &add_macro_decl(\n+                r#\"\n fn main() {\n     print!(\"{} {:b} {}\"$0, 1, x + 1, Struct(1, 2));\n }\n-\"#),\n+\"#,\n+            ),\n         );\n     }\n \n     #[test]\n     fn improper_commas() {\n         check_assist(\n             move_format_string_arg,\n-            &add_macro_decl(r#\"\n+            &add_macro_decl(\n+                r#\"\n fn main() {\n     print!(\"{} {x + 1:b} {Struct(1, 2)}$0\", 1,);\n }\n-\"#),\n-\n-            &add_macro_decl(r#\"\n+\"#,\n+            ),\n+            &add_macro_decl(\n+                r#\"\n fn main() {\n     print!(\"{} {:b} {}\"$0, 1, x + 1, Struct(1, 2));\n }\n-\"#),\n+\"#,\n+            ),\n         );\n     }\n-\n }"}, {"sha": "812d22efbd797c42bc533d20c9a477207481aad6", "filename": "crates/ide-assists/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cc7200891b3cf624f716b03ef24867650b485dca/crates%2Fide-assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc7200891b3cf624f716b03ef24867650b485dca/crates%2Fide-assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Flib.rs?ref=cc7200891b3cf624f716b03ef24867650b485dca", "patch": "@@ -255,6 +255,7 @@ mod handlers {\n             merge_imports::merge_imports,\n             merge_match_arms::merge_match_arms,\n             move_bounds::move_bounds_to_where_clause,\n+            move_format_string_arg::move_format_string_arg,\n             move_guard::move_arm_cond_to_match_guard,\n             move_guard::move_guard_to_arm_body,\n             move_module_to_file::move_module_to_file,"}, {"sha": "3a696635afd275c8830781e30259f5944f71f2d1", "filename": "crates/ide-assists/src/tests/generated.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cc7200891b3cf624f716b03ef24867650b485dca/crates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc7200891b3cf624f716b03ef24867650b485dca/crates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs?ref=cc7200891b3cf624f716b03ef24867650b485dca", "patch": "@@ -1596,13 +1596,27 @@ fn doctest_move_format_string_arg() {\n     check_doc_test(\n         \"move_format_string_arg\",\n         r#####\"\n+macro_rules! format_args {\n+    ($lit:literal $(tt:tt)*) => { 0 },\n+}\n+macro_rules! print {\n+    ($($arg:tt)*) => (std::io::_print(format_args!($($arg)*)));\n+}\n+\n fn main() {\n-    println!(\"{x + 1}$0\");\n+    print!(\"{x + 1}$0\");\n }\n \"#####,\n         r#####\"\n+macro_rules! format_args {\n+    ($lit:literal $(tt:tt)*) => { 0 },\n+}\n+macro_rules! print {\n+    ($($arg:tt)*) => (std::io::_print(format_args!($($arg)*)));\n+}\n+\n fn main() {\n-    println!(\"{a}\", a$0 = x + 1);\n+    print!(\"{}\"$0, x + 1);\n }\n \"#####,\n     )"}, {"sha": "b43bdb9ab9d1a5b861b148195bfdee890c56192e", "filename": "crates/ide-completion/src/completions/postfix/format_like.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/cc7200891b3cf624f716b03ef24867650b485dca/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fpostfix%2Fformat_like.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc7200891b3cf624f716b03ef24867650b485dca/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fpostfix%2Fformat_like.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fpostfix%2Fformat_like.rs?ref=cc7200891b3cf624f716b03ef24867650b485dca", "patch": "@@ -16,8 +16,11 @@\n //\n // image::https://user-images.githubusercontent.com/48062697/113020656-b560f500-917a-11eb-87de-02991f61beb8.gif[]\n \n-use ide_db::{syntax_helpers::format_string_exprs::{parse_format_exprs, add_placeholders}, SnippetCap};\n-use syntax::ast::{self, AstToken};\n+use ide_db::{\n+    syntax_helpers::format_string_exprs::{parse_format_exprs, with_placeholders},\n+    SnippetCap,\n+};\n+use syntax::{ast, AstToken};\n \n use crate::{\n     completions::postfix::build_postfix_snippet_builder, context::CompletionContext, Completions,\n@@ -48,10 +51,10 @@ pub(crate) fn add_format_like_completions(\n         None => return,\n     };\n \n-    if let Ok((out, exprs)) = parse_format_exprs(receiver_text) {\n-        let exprs = add_placeholders(exprs.map(|e| e.1)).collect_vec();\n+    if let Ok((out, exprs)) = parse_format_exprs(receiver_text.text()) {\n+        let exprs = with_placeholders(exprs);\n         for (label, macro_name) in KINDS {\n-            let snippet = format!(r#\"{}(\"{}\", {})\"#, macro_name, out, exprs.join(\", \"));\n+            let snippet = format!(r#\"{}({}, {})\"#, macro_name, out, exprs.join(\", \"));\n \n             postfix_snippet(label, macro_name, &snippet).add_to(acc);\n         }\n@@ -77,7 +80,7 @@ mod tests {\n \n         for (kind, input, output) in test_vector {\n             let (parsed_string, exprs) = parse_format_exprs(input).unwrap();\n-            let exprs = add_placeholders(exprs.map(|e| e.1)).collect_vec();;\n+            let exprs = with_placeholders(exprs);\n             let snippet = format!(r#\"{}(\"{}\", {})\"#, kind, parsed_string, exprs.join(\", \"));\n             assert_eq!(&snippet, output);\n         }"}, {"sha": "e9006e06b110e0541c3cb2cb2765f5749ce50411", "filename": "crates/ide-db/src/syntax_helpers/format_string_exprs.rs", "status": "modified", "additions": 23, "deletions": 29, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/cc7200891b3cf624f716b03ef24867650b485dca/crates%2Fide-db%2Fsrc%2Fsyntax_helpers%2Fformat_string_exprs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc7200891b3cf624f716b03ef24867650b485dca/crates%2Fide-db%2Fsrc%2Fsyntax_helpers%2Fformat_string_exprs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2Fsrc%2Fsyntax_helpers%2Fformat_string_exprs.rs?ref=cc7200891b3cf624f716b03ef24867650b485dca", "patch": "@@ -1,9 +1,13 @@\n-use syntax::{ast, TextRange, AstToken};\n+//! Tools to work with expressions present in format string literals for the `format_args!` family of macros.\n+//! Primarily meant for assists and completions.\n \n+/// Enum for represenging extraced format string args.\n+/// Can either be extracted expressions (which includes identifiers),\n+/// or placeholders `{}`.\n #[derive(Debug)]\n pub enum Arg {\n     Placeholder,\n-    Expr(String)\n+    Expr(String),\n }\n \n /**\n@@ -13,18 +17,18 @@ pub enum Arg {\n  ```\n */\n \n-pub fn add_placeholders (args: impl Iterator<Item = Arg>) -> impl Iterator<Item = String> {\n+pub fn with_placeholders(args: Vec<Arg>) -> Vec<String> {\n     let mut placeholder_id = 1;\n-    args.map(move |a|\n-        match a {\n+    args.into_iter()\n+        .map(move |a| match a {\n             Arg::Expr(s) => s,\n             Arg::Placeholder => {\n                 let s = format!(\"${placeholder_id}\");\n                 placeholder_id += 1;\n                 s\n             }\n-        }\n-    )\n+        })\n+        .collect()\n }\n \n /**\n@@ -39,7 +43,7 @@ pub fn add_placeholders (args: impl Iterator<Item = Arg>) -> impl Iterator<Item\n  assert_eq!(parse(\"{expr} {} {expr} \").unwrap(), (\"{} {} {}\", vec![Arg::Expr(\"expr\"), Arg::Placeholder, Arg::Expr(\"expr\")]));\n  ```\n */\n-pub fn parse_format_exprs(input: &ast::String) -> Result<Vec<(TextRange, Arg)>, ()> {\n+pub fn parse_format_exprs(input: &str) -> Result<(String, Vec<Arg>), ()> {\n     #[derive(Debug, Clone, Copy, PartialEq)]\n     enum State {\n         NotExpr,\n@@ -49,9 +53,6 @@ pub fn parse_format_exprs(input: &ast::String) -> Result<Vec<(TextRange, Arg)>,\n         FormatOpts,\n     }\n \n-    let start = input.syntax().text_range().start();\n-\n-    let mut expr_start = start;\n     let mut current_expr = String::new();\n     let mut state = State::NotExpr;\n     let mut extracted_expressions = Vec::new();\n@@ -62,8 +63,8 @@ pub fn parse_format_exprs(input: &ast::String) -> Result<Vec<(TextRange, Arg)>,\n     // \"{MyStruct { val_a: 0, val_b: 1 }}\".\n     let mut inexpr_open_count = 0;\n \n-    let mut chars = input.text().chars().zip(0u32..).peekable();\n-    while let Some((chr, idx )) = chars.next() {\n+    let mut chars = input.chars().peekable();\n+    while let Some(chr) = chars.next() {\n         match (state, chr) {\n             (State::NotExpr, '{') => {\n                 output.push(chr);\n@@ -95,21 +96,20 @@ pub fn parse_format_exprs(input: &ast::String) -> Result<Vec<(TextRange, Arg)>,\n             (State::MaybeExpr, '}') => {\n                 // This is an empty sequence '{}'. Replace it with placeholder.\n                 output.push(chr);\n-                extracted_expressions.push((TextRange::empty(expr_start), Arg::Placeholder));\n+                extracted_expressions.push(Arg::Placeholder);\n                 state = State::NotExpr;\n             }\n             (State::MaybeExpr, _) => {\n                 if matches!(chr, '\\\\' | '$') {\n                     current_expr.push('\\\\');\n                 }\n                 current_expr.push(chr);\n-                expr_start = start.checked_add(idx.into()).ok_or(())?;\n                 state = State::Expr;\n             }\n             (State::Expr, '}') => {\n                 if inexpr_open_count == 0 {\n                     output.push(chr);\n-                    extracted_expressions.push((TextRange::new(expr_start, start.checked_add(idx.into()).ok_or(())?), Arg::Expr(current_expr.trim().into())));\n+                    extracted_expressions.push(Arg::Expr(current_expr.trim().into()));\n                     current_expr = String::new();\n                     state = State::NotExpr;\n                 } else {\n@@ -118,7 +118,7 @@ pub fn parse_format_exprs(input: &ast::String) -> Result<Vec<(TextRange, Arg)>,\n                     inexpr_open_count -= 1;\n                 }\n             }\n-            (State::Expr, ':') if matches!(chars.peek(), Some((':', _))) => {\n+            (State::Expr, ':') if matches!(chars.peek(), Some(':')) => {\n                 // path separator\n                 current_expr.push_str(\"::\");\n                 chars.next();\n@@ -127,7 +127,7 @@ pub fn parse_format_exprs(input: &ast::String) -> Result<Vec<(TextRange, Arg)>,\n                 if inexpr_open_count == 0 {\n                     // We're outside of braces, thus assume that it's a specifier, like \"{Some(value):?}\"\n                     output.push(chr);\n-                    extracted_expressions.push((TextRange::new(expr_start, start.checked_add(idx.into()).ok_or(())?), Arg::Expr(current_expr.trim().into())));\n+                    extracted_expressions.push(Arg::Expr(current_expr.trim().into()));\n                     current_expr = String::new();\n                     state = State::FormatOpts;\n                 } else {\n@@ -162,7 +162,7 @@ pub fn parse_format_exprs(input: &ast::String) -> Result<Vec<(TextRange, Arg)>,\n         return Err(());\n     }\n \n-    Ok(extracted_expressions)\n+    Ok((output, extracted_expressions))\n }\n \n #[cfg(test)]\n@@ -171,17 +171,11 @@ mod tests {\n     use expect_test::{expect, Expect};\n \n     fn check(input: &str, expect: &Expect) {\n-        let mut parser = FormatStrParser::new((*input).to_owned());\n-        let outcome_repr = if parser.parse().is_ok() {\n-            // Parsing should be OK, expected repr is \"string; expr_1, expr_2\".\n-            if parser.extracted_expressions.is_empty() {\n-                parser.output\n-            } else {\n-                format!(\"{}; {}\", parser.output, parser.extracted_expressions.join(\", \"))\n-            }\n+        let (output, exprs) = parse_format_exprs(input).unwrap_or((\"-\".to_string(), vec![]));\n+        let outcome_repr = if !exprs.is_empty() {\n+            format!(\"{}; {}\", output, with_placeholders(exprs).join(\", \"))\n         } else {\n-            // Parsing should fail, expected repr is \"-\".\n-            \"-\".to_owned()\n+            output\n         };\n \n         expect.assert_eq(&outcome_repr);"}]}