{"sha": "3a709fe7021218b613aa7fdce7794df5a8ff0da5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNhNzA5ZmU3MDIxMjE4YjYxM2FhN2ZkY2U3Nzk0ZGY1YThmZjBkYTU=", "commit": {"author": {"name": "Alexis Bourget", "email": "alexis.bourget@gmail.com", "date": "2020-08-08T13:40:10Z"}, "committer": {"name": "Alexis Bourget", "email": "alexis.bourget@gmail.com", "date": "2020-08-08T13:40:10Z"}, "message": "Add precisions about ZSTs and fix nits raised in review", "tree": {"sha": "705b22125c168779ab14f2e2abbad992bdebd34b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/705b22125c168779ab14f2e2abbad992bdebd34b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3a709fe7021218b613aa7fdce7794df5a8ff0da5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3a709fe7021218b613aa7fdce7794df5a8ff0da5", "html_url": "https://github.com/rust-lang/rust/commit/3a709fe7021218b613aa7fdce7794df5a8ff0da5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3a709fe7021218b613aa7fdce7794df5a8ff0da5/comments", "author": {"login": "poliorcetics", "id": 7951708, "node_id": "MDQ6VXNlcjc5NTE3MDg=", "avatar_url": "https://avatars.githubusercontent.com/u/7951708?v=4", "gravatar_id": "", "url": "https://api.github.com/users/poliorcetics", "html_url": "https://github.com/poliorcetics", "followers_url": "https://api.github.com/users/poliorcetics/followers", "following_url": "https://api.github.com/users/poliorcetics/following{/other_user}", "gists_url": "https://api.github.com/users/poliorcetics/gists{/gist_id}", "starred_url": "https://api.github.com/users/poliorcetics/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/poliorcetics/subscriptions", "organizations_url": "https://api.github.com/users/poliorcetics/orgs", "repos_url": "https://api.github.com/users/poliorcetics/repos", "events_url": "https://api.github.com/users/poliorcetics/events{/privacy}", "received_events_url": "https://api.github.com/users/poliorcetics/received_events", "type": "User", "site_admin": false}, "committer": {"login": "poliorcetics", "id": 7951708, "node_id": "MDQ6VXNlcjc5NTE3MDg=", "avatar_url": "https://avatars.githubusercontent.com/u/7951708?v=4", "gravatar_id": "", "url": "https://api.github.com/users/poliorcetics", "html_url": "https://github.com/poliorcetics", "followers_url": "https://api.github.com/users/poliorcetics/followers", "following_url": "https://api.github.com/users/poliorcetics/following{/other_user}", "gists_url": "https://api.github.com/users/poliorcetics/gists{/gist_id}", "starred_url": "https://api.github.com/users/poliorcetics/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/poliorcetics/subscriptions", "organizations_url": "https://api.github.com/users/poliorcetics/orgs", "repos_url": "https://api.github.com/users/poliorcetics/repos", "events_url": "https://api.github.com/users/poliorcetics/events{/privacy}", "received_events_url": "https://api.github.com/users/poliorcetics/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "92b1975eaaae0891cb8d5ed50fb7a17f37ce0b38", "url": "https://api.github.com/repos/rust-lang/rust/commits/92b1975eaaae0891cb8d5ed50fb7a17f37ce0b38", "html_url": "https://github.com/rust-lang/rust/commit/92b1975eaaae0891cb8d5ed50fb7a17f37ce0b38"}], "stats": {"total": 82, "additions": 62, "deletions": 20}, "files": [{"sha": "4aba53c159b0ccfb86b26272b9178c25a90b2c18", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 62, "deletions": 20, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/3a709fe7021218b613aa7fdce7794df5a8ff0da5/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a709fe7021218b613aa7fdce7794df5a8ff0da5/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=3a709fe7021218b613aa7fdce7794df5a8ff0da5", "patch": "@@ -512,15 +512,15 @@ impl<T> [T] {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn swap(&mut self, a: usize, b: usize) {\n+        // Can't take two mutable loans from one vector, so instead just cast\n+        // them to their raw pointers to do the swap.\n+        let pa: *mut T = &mut self[a];\n+        let pb: *mut T = &mut self[b];\n         // SAFETY: `pa` and `pb` have been created from safe mutable references and refer\n         // to elements in the slice and therefore are guaranteed to be valid and aligned.\n         // Note that accessing the elements behind `a` and `b` is checked and will\n         // panic when out of bounds.\n         unsafe {\n-            // Can't take two mutable loans from one vector, so instead just cast\n-            // them to their raw pointers to do the swap\n-            let pa: *mut T = &mut self[a];\n-            let pb: *mut T = &mut self[b];\n             ptr::swap(pa, pb);\n         }\n     }\n@@ -559,15 +559,21 @@ impl<T> [T] {\n             // Use the llvm.bswap intrinsic to reverse u8s in a usize\n             let chunk = mem::size_of::<usize>();\n             while i + chunk - 1 < ln / 2 {\n-                // SAFETY: An unaligned u32 can be read from `i` if `i + 1 < ln`\n-                // (and obviously `i < ln`), because each element is 2 bytes and\n-                // we're reading 4.\n+                // SAFETY: An unaligned usize can be read from `i` if `i + 1 < ln`\n+                // (and obviously `i < ln`), because each element is 1 byte and\n+                // we're reading 2.\n+                //\n                 // `i + chunk - 1 < ln / 2` # while condition\n                 // `i + 2 - 1 < ln / 2`\n                 // `i + 1 < ln / 2`\n+                //\n                 // Since it's less than the length divided by 2, then it must be\n                 // in bounds.\n                 //\n+                // This also means that the condition `0 < i + chunk <= ln` is\n+                // always respected, ensuring the `pb` pointer can be used\n+                // safely.\n+                //\n                 // Note: when updating this comment, update the others in the\n                 // function too.\n                 unsafe {\n@@ -589,12 +595,18 @@ impl<T> [T] {\n                 // SAFETY: An unaligned u32 can be read from `i` if `i + 1 < ln`\n                 // (and obviously `i < ln`), because each element is 2 bytes and\n                 // we're reading 4.\n+                //\n                 // `i + chunk - 1 < ln / 2` # while condition\n                 // `i + 2 - 1 < ln / 2`\n                 // `i + 1 < ln / 2`\n+                //\n                 // Since it's less than the length divided by 2, then it must be\n                 // in bounds.\n                 //\n+                // This also means that the condition `0 < i + chunk <= ln` is\n+                // always respected, ensuring the `pb` pointer can be used\n+                // safely.\n+                //\n                 // Note: when updating this comment, update the others in the\n                 // function too.\n                 unsafe {\n@@ -641,11 +653,23 @@ impl<T> [T] {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn iter(&self) -> Iter<'_, T> {\n-        // SAFETY: adding `self.len()` to the starting pointer gives a pointer\n-        // at the end of `self`, which fulfills the expectations of `ptr.add()`\n-        // and `NonNull::new_unchecked()`.\n+        let ptr = self.as_ptr();\n+        // SAFETY: There are several things here:\n+        //\n+        // `ptr` has been checked for nullity before being passed to `NonNull` via\n+        // `new_unchecked`.\n+        //\n+        // Adding `self.len()` to the starting pointer gives a pointer\n+        // at the end of `self`. `end` will never be dereferenced, only checked\n+        // for direct pointer equality with `ptr` to check if the iterator is\n+        // done.\n+        //\n+        // In the case of a ZST, the end pointer is just the start pointer plus\n+        // the length, to also allows for the fast `ptr == end` check.\n+        //\n+        // See the `next_unchecked!` and `is_empty!` macros as well as the\n+        // `post_inc_start` method for more informations.\n         unsafe {\n-            let ptr = self.as_ptr();\n             assume(!ptr.is_null());\n \n             let end = if mem::size_of::<T>() == 0 {\n@@ -672,11 +696,23 @@ impl<T> [T] {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn iter_mut(&mut self) -> IterMut<'_, T> {\n-        // SAFETY: adding `self.len()` to the starting pointer gives a pointer\n-        // at the end of `self`, which fulfills the expectations of `ptr.add()`\n-        // and `NonNull::new_unchecked()`.\n+        let ptr = self.as_mut_ptr();\n+        // SAFETY: There are several things here:\n+        //\n+        // `ptr` has been checked for nullity before being passed to `NonNull` via\n+        // `new_unchecked`.\n+        //\n+        // Adding `self.len()` to the starting pointer gives a pointer\n+        // at the end of `self`. `end` will never be dereferenced, only checked\n+        // for direct pointer equality with `ptr` to check if the iterator is\n+        // done.\n+        //\n+        // In the case of a ZST, the end pointer is just the start pointer plus\n+        // the length, to also allows for the fast `ptr == end` check.\n+        //\n+        // See the `next_unchecked!` and `is_empty!` macros as well as the\n+        // `post_inc_start` method for more informations.\n         unsafe {\n-            let ptr = self.as_mut_ptr();\n             assume(!ptr.is_null());\n \n             let end = if mem::size_of::<T>() == 0 {\n@@ -2170,6 +2206,11 @@ impl<T> [T] {\n         //\n         // `next_write` is also incremented at most once per loop at most meaning\n         // no element is skipped when it may need to be swapped.\n+        //\n+        // `ptr_read` and `prev_ptr_write` never point to the same element. This\n+        // is required for `&mut *ptr_read`, `&mut *prev_ptr_write` to be safe.\n+        // The explanation is simply that `next_read >= next_write` is always true,\n+        // thus `next_read > next_write - 1` is too.\n         unsafe {\n             // Avoid bounds checks by using raw pointers.\n             while next_read < len {\n@@ -2253,11 +2294,11 @@ impl<T> [T] {\n     pub fn rotate_left(&mut self, mid: usize) {\n         assert!(mid <= self.len());\n         let k = self.len() - mid;\n+        let p = self.as_mut_ptr();\n \n-        // SAFETY: `[mid - mid;mid+k]` corresponds to the entire\n+        // SAFETY: `[mid; mid+k]` corresponds to the entire\n         // `self` slice, thus is valid for reads and writes.\n         unsafe {\n-            let p = self.as_mut_ptr();\n             rotate::ptr_rotate(mid, p.add(mid), k);\n         }\n     }\n@@ -2296,11 +2337,11 @@ impl<T> [T] {\n     pub fn rotate_right(&mut self, k: usize) {\n         assert!(k <= self.len());\n         let mid = self.len() - k;\n+        let p = self.as_mut_ptr();\n \n-        // SAFETY: `[mid - mid;mid+k]` corresponds to the entire\n+        // SAFETY: `[mid; mid+k]` corresponds to the entire\n         // `self` slice, thus is valid for reads and writes.\n         unsafe {\n-            let p = self.as_mut_ptr();\n             rotate::ptr_rotate(mid, p.add(mid), k);\n         }\n     }\n@@ -2517,7 +2558,8 @@ impl<T> [T] {\n         assert!(src_end <= self.len(), \"src is out of bounds\");\n         let count = src_end - src_start;\n         assert!(dest <= self.len() - count, \"dest is out of bounds\");\n-        // SAFETY: the conditions for `ptr::copy` have all been checked above.\n+        // SAFETY: the conditions for `ptr::copy` have all been checked above,\n+        // as have those for `ptr::add`.\n         unsafe {\n             ptr::copy(self.as_ptr().add(src_start), self.as_mut_ptr().add(dest), count);\n         }"}]}