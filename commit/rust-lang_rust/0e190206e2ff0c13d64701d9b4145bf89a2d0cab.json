{"sha": "0e190206e2ff0c13d64701d9b4145bf89a2d0cab", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBlMTkwMjA2ZTJmZjBjMTNkNjQ3MDFkOWI0MTQ1YmY4OWEyZDBjYWI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-01-28T09:01:33Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-01-28T09:01:33Z"}, "message": "Auto merge of #81461 - JohnTitor:rollup-b0ij25f, r=JohnTitor\n\nRollup of 13 pull requests\n\nSuccessful merges:\n\n - #70904 (Stabilize `Seek::stream_position` (feature `seek_convenience`))\n - #79951 (Refractor a few more types to `rustc_type_ir` )\n - #80868 (Print failure message on all tests that should panic, but don't)\n - #81062 (Improve diagnostics for Precise Capture)\n - #81277 (Make more traits of the From/Into family diagnostic items)\n - #81284 (Make `-Z time-passes` less noisy)\n - #81379 (Improve URLs handling)\n - #81416 (Tweak suggestion for missing field in patterns)\n - #81426 (const_evaluatable: expand abstract consts in try_unify)\n - #81428 (compiletest: Add two more unit tests)\n - #81430 (add const_evaluatable_checked test)\n - #81433 (const_evaluatable: stop looking into type aliases)\n - #81445 (Update cargo)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "f081fe04717328752fade190520b7c3b1579565b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f081fe04717328752fade190520b7c3b1579565b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0e190206e2ff0c13d64701d9b4145bf89a2d0cab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0e190206e2ff0c13d64701d9b4145bf89a2d0cab", "html_url": "https://github.com/rust-lang/rust/commit/0e190206e2ff0c13d64701d9b4145bf89a2d0cab", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e32f372c4203b2527221b313cf63b05ea178e8a9", "url": "https://api.github.com/repos/rust-lang/rust/commits/e32f372c4203b2527221b313cf63b05ea178e8a9", "html_url": "https://github.com/rust-lang/rust/commit/e32f372c4203b2527221b313cf63b05ea178e8a9"}, {"sha": "f3dfbfc8f5f2b17c7f6fe12b4ba48f589d54dc87", "url": "https://api.github.com/repos/rust-lang/rust/commits/f3dfbfc8f5f2b17c7f6fe12b4ba48f589d54dc87", "html_url": "https://github.com/rust-lang/rust/commit/f3dfbfc8f5f2b17c7f6fe12b4ba48f589d54dc87"}], "stats": {"total": 2661, "additions": 1928, "deletions": 733}, "files": [{"sha": "fb5ae6ce663038834a86aa013924900cec0a32a4", "filename": "Cargo.lock", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=0e190206e2ff0c13d64701d9b4145bf89a2d0cab", "patch": "@@ -770,7 +770,7 @@ checksum = \"8aebca1129a03dc6dc2b127edd729435bbc4a37e1d5f4d7513165089ceb02634\"\n \n [[package]]\n name = \"crates-io\"\n-version = \"0.31.1\"\n+version = \"0.33.0\"\n dependencies = [\n  \"anyhow\",\n  \"curl\",\n@@ -1337,9 +1337,9 @@ dependencies = [\n \n [[package]]\n name = \"git2\"\n-version = \"0.13.14\"\n+version = \"0.13.17\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"186dd99cc77576e58344ad614fa9bb27bad9d048f85de3ca850c1f4e8b048260\"\n+checksum = \"1d250f5f82326884bd39c2853577e70a121775db76818ffa452ed1e80de12986\"\n dependencies = [\n  \"bitflags\",\n  \"libc\",\n@@ -1792,9 +1792,9 @@ dependencies = [\n \n [[package]]\n name = \"libgit2-sys\"\n-version = \"0.12.16+1.1.0\"\n+version = \"0.12.18+1.1.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"9f91b2f931ee975a98155195be8cd82d02e8e029d7d793d2bac1b8181ac97020\"\n+checksum = \"3da6a42da88fc37ee1ecda212ffa254c25713532980005d5f7c0b0fbe7e6e885\"\n dependencies = [\n  \"cc\",\n  \"libc\",\n@@ -4345,6 +4345,7 @@ dependencies = [\n  \"bitflags\",\n  \"rustc_data_structures\",\n  \"rustc_index\",\n+ \"rustc_macros\",\n  \"rustc_serialize\",\n ]\n "}, {"sha": "f31c58b92e4079e0d0caf5a3c3f3591632036c6b", "filename": "compiler/rustc_codegen_cranelift/src/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs?ref=0e190206e2ff0c13d64701d9b4145bf89a2d0cab", "patch": "@@ -83,15 +83,14 @@ mod vtable;\n mod prelude {\n     pub(crate) use std::convert::{TryFrom, TryInto};\n \n-    pub(crate) use rustc_ast::ast::{FloatTy, IntTy, UintTy};\n     pub(crate) use rustc_span::Span;\n \n     pub(crate) use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n     pub(crate) use rustc_middle::bug;\n     pub(crate) use rustc_middle::mir::{self, *};\n     pub(crate) use rustc_middle::ty::layout::{self, TyAndLayout};\n     pub(crate) use rustc_middle::ty::{\n-        self, FnSig, Instance, InstanceDef, ParamEnv, Ty, TyCtxt, TypeAndMut, TypeFoldable,\n+        self, FloatTy, FnSig, Instance, InstanceDef, IntTy, ParamEnv, Ty, TyCtxt, TypeAndMut, TypeFoldable, UintTy,\n     };\n     pub(crate) use rustc_target::abi::{Abi, LayoutOf, Scalar, Size, VariantIdx};\n "}, {"sha": "d2f4d3edc2207d4fffdce73c200482eb6cc6df12", "filename": "compiler/rustc_codegen_llvm/src/builder.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs?ref=0e190206e2ff0c13d64701d9b4145bf89a2d0cab", "patch": "@@ -304,9 +304,8 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         lhs: Self::Value,\n         rhs: Self::Value,\n     ) -> (Self::Value, Self::Value) {\n-        use rustc_ast::IntTy::*;\n-        use rustc_ast::UintTy::*;\n         use rustc_middle::ty::{Int, Uint};\n+        use rustc_middle::ty::{IntTy::*, UintTy::*};\n \n         let new_kind = match ty.kind() {\n             Int(t @ Isize) => Int(t.normalize(self.tcx.sess.target.pointer_width)),"}, {"sha": "3a4e1492af3378750372afb487c966151528df58", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata.rs", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs?ref=0e190206e2ff0c13d64701d9b4145bf89a2d0cab", "patch": "@@ -18,7 +18,6 @@ use crate::llvm::debuginfo::{\n };\n use crate::value::Value;\n \n-use rustc_ast as ast;\n use rustc_codegen_ssa::traits::*;\n use rustc_data_structures::const_cstr;\n use rustc_data_structures::fingerprint::Fingerprint;\n@@ -830,37 +829,37 @@ trait MsvcBasicName {\n     fn msvc_basic_name(self) -> &'static str;\n }\n \n-impl MsvcBasicName for ast::IntTy {\n+impl MsvcBasicName for ty::IntTy {\n     fn msvc_basic_name(self) -> &'static str {\n         match self {\n-            ast::IntTy::Isize => \"ptrdiff_t\",\n-            ast::IntTy::I8 => \"__int8\",\n-            ast::IntTy::I16 => \"__int16\",\n-            ast::IntTy::I32 => \"__int32\",\n-            ast::IntTy::I64 => \"__int64\",\n-            ast::IntTy::I128 => \"__int128\",\n+            ty::IntTy::Isize => \"ptrdiff_t\",\n+            ty::IntTy::I8 => \"__int8\",\n+            ty::IntTy::I16 => \"__int16\",\n+            ty::IntTy::I32 => \"__int32\",\n+            ty::IntTy::I64 => \"__int64\",\n+            ty::IntTy::I128 => \"__int128\",\n         }\n     }\n }\n \n-impl MsvcBasicName for ast::UintTy {\n+impl MsvcBasicName for ty::UintTy {\n     fn msvc_basic_name(self) -> &'static str {\n         match self {\n-            ast::UintTy::Usize => \"size_t\",\n-            ast::UintTy::U8 => \"unsigned __int8\",\n-            ast::UintTy::U16 => \"unsigned __int16\",\n-            ast::UintTy::U32 => \"unsigned __int32\",\n-            ast::UintTy::U64 => \"unsigned __int64\",\n-            ast::UintTy::U128 => \"unsigned __int128\",\n+            ty::UintTy::Usize => \"size_t\",\n+            ty::UintTy::U8 => \"unsigned __int8\",\n+            ty::UintTy::U16 => \"unsigned __int16\",\n+            ty::UintTy::U32 => \"unsigned __int32\",\n+            ty::UintTy::U64 => \"unsigned __int64\",\n+            ty::UintTy::U128 => \"unsigned __int128\",\n         }\n     }\n }\n \n-impl MsvcBasicName for ast::FloatTy {\n+impl MsvcBasicName for ty::FloatTy {\n     fn msvc_basic_name(self) -> &'static str {\n         match self {\n-            ast::FloatTy::F32 => \"float\",\n-            ast::FloatTy::F64 => \"double\",\n+            ty::FloatTy::F32 => \"float\",\n+            ty::FloatTy::F64 => \"double\",\n         }\n     }\n }"}, {"sha": "8fd0caae479a8cc2ff4fdecfc2b55e1340f0726d", "filename": "compiler/rustc_codegen_llvm/src/type_.rs", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_.rs?ref=0e190206e2ff0c13d64701d9b4145bf89a2d0cab", "patch": "@@ -7,13 +7,12 @@ use crate::llvm;\n use crate::llvm::{Bool, False, True};\n use crate::type_of::LayoutLlvmExt;\n use crate::value::Value;\n-use rustc_ast as ast;\n use rustc_codegen_ssa::common::TypeKind;\n use rustc_codegen_ssa::traits::*;\n use rustc_data_structures::small_c_str::SmallCStr;\n use rustc_middle::bug;\n use rustc_middle::ty::layout::TyAndLayout;\n-use rustc_middle::ty::Ty;\n+use rustc_middle::ty::{self, Ty};\n use rustc_target::abi::call::{CastTarget, FnAbi, Reg};\n use rustc_target::abi::{AddressSpace, Align, Integer, Size};\n \n@@ -80,32 +79,32 @@ impl CodegenCx<'ll, 'tcx> {\n         self.type_i8()\n     }\n \n-    crate fn type_int_from_ty(&self, t: ast::IntTy) -> &'ll Type {\n+    crate fn type_int_from_ty(&self, t: ty::IntTy) -> &'ll Type {\n         match t {\n-            ast::IntTy::Isize => self.type_isize(),\n-            ast::IntTy::I8 => self.type_i8(),\n-            ast::IntTy::I16 => self.type_i16(),\n-            ast::IntTy::I32 => self.type_i32(),\n-            ast::IntTy::I64 => self.type_i64(),\n-            ast::IntTy::I128 => self.type_i128(),\n+            ty::IntTy::Isize => self.type_isize(),\n+            ty::IntTy::I8 => self.type_i8(),\n+            ty::IntTy::I16 => self.type_i16(),\n+            ty::IntTy::I32 => self.type_i32(),\n+            ty::IntTy::I64 => self.type_i64(),\n+            ty::IntTy::I128 => self.type_i128(),\n         }\n     }\n \n-    crate fn type_uint_from_ty(&self, t: ast::UintTy) -> &'ll Type {\n+    crate fn type_uint_from_ty(&self, t: ty::UintTy) -> &'ll Type {\n         match t {\n-            ast::UintTy::Usize => self.type_isize(),\n-            ast::UintTy::U8 => self.type_i8(),\n-            ast::UintTy::U16 => self.type_i16(),\n-            ast::UintTy::U32 => self.type_i32(),\n-            ast::UintTy::U64 => self.type_i64(),\n-            ast::UintTy::U128 => self.type_i128(),\n+            ty::UintTy::Usize => self.type_isize(),\n+            ty::UintTy::U8 => self.type_i8(),\n+            ty::UintTy::U16 => self.type_i16(),\n+            ty::UintTy::U32 => self.type_i32(),\n+            ty::UintTy::U64 => self.type_i64(),\n+            ty::UintTy::U128 => self.type_i128(),\n         }\n     }\n \n-    crate fn type_float_from_ty(&self, t: ast::FloatTy) -> &'ll Type {\n+    crate fn type_float_from_ty(&self, t: ty::FloatTy) -> &'ll Type {\n         match t {\n-            ast::FloatTy::F32 => self.type_f32(),\n-            ast::FloatTy::F64 => self.type_f64(),\n+            ty::FloatTy::F32 => self.type_f32(),\n+            ty::FloatTy::F64 => self.type_f64(),\n         }\n     }\n "}, {"sha": "c821908167870088f98a72425f2ec1f0e39834fb", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=0e190206e2ff0c13d64701d9b4145bf89a2d0cab", "patch": "@@ -875,20 +875,16 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                             ty::Uint(_) => value.to_string(),\n                             ty::Int(int_ty) => {\n                                 match int_ty.normalize(bx.tcx().sess.target.pointer_width) {\n-                                    ast::IntTy::I8 => (value as i8).to_string(),\n-                                    ast::IntTy::I16 => (value as i16).to_string(),\n-                                    ast::IntTy::I32 => (value as i32).to_string(),\n-                                    ast::IntTy::I64 => (value as i64).to_string(),\n-                                    ast::IntTy::I128 => (value as i128).to_string(),\n-                                    ast::IntTy::Isize => unreachable!(),\n+                                    ty::IntTy::I8 => (value as i8).to_string(),\n+                                    ty::IntTy::I16 => (value as i16).to_string(),\n+                                    ty::IntTy::I32 => (value as i32).to_string(),\n+                                    ty::IntTy::I64 => (value as i64).to_string(),\n+                                    ty::IntTy::I128 => (value as i128).to_string(),\n+                                    ty::IntTy::Isize => unreachable!(),\n                                 }\n                             }\n-                            ty::Float(ast::FloatTy::F32) => {\n-                                f32::from_bits(value as u32).to_string()\n-                            }\n-                            ty::Float(ast::FloatTy::F64) => {\n-                                f64::from_bits(value as u64).to_string()\n-                            }\n+                            ty::Float(ty::FloatTy::F32) => f32::from_bits(value as u32).to_string(),\n+                            ty::Float(ty::FloatTy::F64) => f64::from_bits(value as u64).to_string(),\n                             _ => span_bug!(span, \"asm const has bad type {}\", ty),\n                         };\n                         InlineAsmOperandRef::Const { string }"}, {"sha": "08543d1622a7d4f6fd9d6b43330bb3b6b720017b", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=0e190206e2ff0c13d64701d9b4145bf89a2d0cab", "patch": "@@ -929,15 +929,17 @@ pub struct ExtCtxt<'a> {\n     pub force_mode: bool,\n     pub expansions: FxHashMap<Span, Vec<String>>,\n     /// Called directly after having parsed an external `mod foo;` in expansion.\n-    pub(super) extern_mod_loaded: Option<&'a dyn Fn(&ast::Crate)>,\n+    ///\n+    /// `Ident` is the module name.\n+    pub(super) extern_mod_loaded: Option<&'a dyn Fn(&ast::Crate, Ident)>,\n }\n \n impl<'a> ExtCtxt<'a> {\n     pub fn new(\n         sess: &'a Session,\n         ecfg: expand::ExpansionConfig<'a>,\n         resolver: &'a mut dyn ResolverExpand,\n-        extern_mod_loaded: Option<&'a dyn Fn(&ast::Crate)>,\n+        extern_mod_loaded: Option<&'a dyn Fn(&ast::Crate, Ident)>,\n     ) -> ExtCtxt<'a> {\n         ExtCtxt {\n             sess,"}, {"sha": "50832d5edbfc59b8fa8c6671ee994ec0c2462d45", "filename": "compiler/rustc_expand/src/expand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs?ref=0e190206e2ff0c13d64701d9b4145bf89a2d0cab", "patch": "@@ -1407,7 +1407,7 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n                         proc_macros: vec![],\n                     };\n                     if let Some(extern_mod_loaded) = self.cx.extern_mod_loaded {\n-                        extern_mod_loaded(&krate);\n+                        extern_mod_loaded(&krate, ident);\n                     }\n \n                     *old_mod = krate.module;"}, {"sha": "e034ac5e8fd70c665c86f0bc9d12d736112311dc", "filename": "compiler/rustc_infer/src/infer/combine.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs?ref=0e190206e2ff0c13d64701d9b4145bf89a2d0cab", "patch": "@@ -34,7 +34,6 @@ use super::{InferCtxt, MiscVariable, TypeTrace};\n \n use crate::traits::{Obligation, PredicateObligations};\n \n-use rustc_ast as ast;\n use rustc_data_structures::sso::SsoHashMap;\n use rustc_hir::def_id::DefId;\n use rustc_middle::traits::ObligationCause;\n@@ -281,7 +280,7 @@ impl<'infcx, 'tcx> InferCtxt<'infcx, 'tcx> {\n         &self,\n         vid_is_expected: bool,\n         vid: ty::FloatVid,\n-        val: ast::FloatTy,\n+        val: ty::FloatTy,\n     ) -> RelateResult<'tcx, Ty<'tcx>> {\n         self.inner\n             .borrow_mut()"}, {"sha": "56aa3939b22dca67059741df734b447d47f3110c", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=0e190206e2ff0c13d64701d9b4145bf89a2d0cab", "patch": "@@ -33,7 +33,7 @@ use rustc_session::lint;\n use rustc_session::output::{filename_for_input, filename_for_metadata};\n use rustc_session::search_paths::PathKind;\n use rustc_session::Session;\n-use rustc_span::symbol::Symbol;\n+use rustc_span::symbol::{Ident, Symbol};\n use rustc_span::{FileName, RealFileName};\n use rustc_trait_selection::traits;\n use rustc_typeck as typeck;\n@@ -211,8 +211,13 @@ pub fn register_plugins<'a>(\n     Ok((krate, lint_store))\n }\n \n-fn pre_expansion_lint(sess: &Session, lint_store: &LintStore, krate: &ast::Crate) {\n-    sess.time(\"pre_AST_expansion_lint_checks\", || {\n+fn pre_expansion_lint(\n+    sess: &Session,\n+    lint_store: &LintStore,\n+    krate: &ast::Crate,\n+    crate_name: &str,\n+) {\n+    sess.prof.generic_activity_with_arg(\"pre_AST_expansion_lint_checks\", crate_name).run(|| {\n         rustc_lint::check_ast_crate(\n             sess,\n             lint_store,\n@@ -233,7 +238,7 @@ fn configure_and_expand_inner<'a>(\n     metadata_loader: &'a MetadataLoaderDyn,\n ) -> Result<(ast::Crate, Resolver<'a>)> {\n     tracing::trace!(\"configure_and_expand_inner\");\n-    pre_expansion_lint(sess, lint_store, &krate);\n+    pre_expansion_lint(sess, lint_store, &krate, crate_name);\n \n     let mut resolver = Resolver::new(sess, &krate, crate_name, metadata_loader, &resolver_arenas);\n     rustc_builtin_macros::register_builtin_macros(&mut resolver);\n@@ -295,7 +300,9 @@ fn configure_and_expand_inner<'a>(\n             ..rustc_expand::expand::ExpansionConfig::default(crate_name.to_string())\n         };\n \n-        let extern_mod_loaded = |k: &ast::Crate| pre_expansion_lint(sess, lint_store, k);\n+        let extern_mod_loaded = |k: &ast::Crate, ident: Ident| {\n+            pre_expansion_lint(sess, lint_store, k, &*ident.name.as_str())\n+        };\n         let mut ecx = ExtCtxt::new(&sess, cfg, &mut resolver, Some(&extern_mod_loaded));\n \n         // Expand macros now!"}, {"sha": "1e879d29370607d096f01c27f95a82b09ff90c3c", "filename": "compiler/rustc_lint/src/types.rs", "status": "modified", "additions": 37, "deletions": 23, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs?ref=0e190206e2ff0c13d64701d9b4145bf89a2d0cab", "patch": "@@ -168,25 +168,25 @@ fn lint_overflowing_range_endpoint<'tcx>(\n \n // For `isize` & `usize`, be conservative with the warnings, so that the\n // warnings are consistent between 32- and 64-bit platforms.\n-fn int_ty_range(int_ty: ast::IntTy) -> (i128, i128) {\n+fn int_ty_range(int_ty: ty::IntTy) -> (i128, i128) {\n     match int_ty {\n-        ast::IntTy::Isize => (i64::MIN.into(), i64::MAX.into()),\n-        ast::IntTy::I8 => (i8::MIN.into(), i8::MAX.into()),\n-        ast::IntTy::I16 => (i16::MIN.into(), i16::MAX.into()),\n-        ast::IntTy::I32 => (i32::MIN.into(), i32::MAX.into()),\n-        ast::IntTy::I64 => (i64::MIN.into(), i64::MAX.into()),\n-        ast::IntTy::I128 => (i128::MIN, i128::MAX),\n+        ty::IntTy::Isize => (i64::MIN.into(), i64::MAX.into()),\n+        ty::IntTy::I8 => (i8::MIN.into(), i8::MAX.into()),\n+        ty::IntTy::I16 => (i16::MIN.into(), i16::MAX.into()),\n+        ty::IntTy::I32 => (i32::MIN.into(), i32::MAX.into()),\n+        ty::IntTy::I64 => (i64::MIN.into(), i64::MAX.into()),\n+        ty::IntTy::I128 => (i128::MIN, i128::MAX),\n     }\n }\n \n-fn uint_ty_range(uint_ty: ast::UintTy) -> (u128, u128) {\n+fn uint_ty_range(uint_ty: ty::UintTy) -> (u128, u128) {\n     let max = match uint_ty {\n-        ast::UintTy::Usize => u64::MAX.into(),\n-        ast::UintTy::U8 => u8::MAX.into(),\n-        ast::UintTy::U16 => u16::MAX.into(),\n-        ast::UintTy::U32 => u32::MAX.into(),\n-        ast::UintTy::U64 => u64::MAX.into(),\n-        ast::UintTy::U128 => u128::MAX,\n+        ty::UintTy::Usize => u64::MAX.into(),\n+        ty::UintTy::U8 => u8::MAX.into(),\n+        ty::UintTy::U16 => u16::MAX.into(),\n+        ty::UintTy::U32 => u32::MAX.into(),\n+        ty::UintTy::U64 => u64::MAX.into(),\n+        ty::UintTy::U128 => u128::MAX,\n     };\n     (0, max)\n }\n@@ -258,8 +258,8 @@ fn report_bin_hex_error(\n //\n // No suggestion for: `isize`, `usize`.\n fn get_type_suggestion(t: Ty<'_>, val: u128, negative: bool) -> Option<&'static str> {\n-    use rustc_ast::IntTy::*;\n-    use rustc_ast::UintTy::*;\n+    use ty::IntTy::*;\n+    use ty::UintTy::*;\n     macro_rules! find_fit {\n         ($ty:expr, $val:expr, $negative:expr,\n          $($type:ident => [$($utypes:expr),*] => [$($itypes:expr),*]),+) => {\n@@ -302,7 +302,7 @@ fn lint_int_literal<'tcx>(\n     type_limits: &TypeLimits,\n     e: &'tcx hir::Expr<'tcx>,\n     lit: &hir::Lit,\n-    t: ast::IntTy,\n+    t: ty::IntTy,\n     v: u128,\n ) {\n     let int_type = t.normalize(cx.sess().target.pointer_width);\n@@ -314,7 +314,14 @@ fn lint_int_literal<'tcx>(\n     // avoiding use of -min to prevent overflow/panic\n     if (negative && v > max + 1) || (!negative && v > max) {\n         if let Some(repr_str) = get_bin_hex_repr(cx, lit) {\n-            report_bin_hex_error(cx, e, attr::IntType::SignedInt(t), repr_str, v, negative);\n+            report_bin_hex_error(\n+                cx,\n+                e,\n+                attr::IntType::SignedInt(ty::ast_int_ty(t)),\n+                repr_str,\n+                v,\n+                negative,\n+            );\n             return;\n         }\n \n@@ -351,7 +358,7 @@ fn lint_uint_literal<'tcx>(\n     cx: &LateContext<'tcx>,\n     e: &'tcx hir::Expr<'tcx>,\n     lit: &hir::Lit,\n-    t: ast::UintTy,\n+    t: ty::UintTy,\n ) {\n     let uint_type = t.normalize(cx.sess().target.pointer_width);\n     let (min, max) = uint_ty_range(uint_type);\n@@ -391,7 +398,14 @@ fn lint_uint_literal<'tcx>(\n             }\n         }\n         if let Some(repr_str) = get_bin_hex_repr(cx, lit) {\n-            report_bin_hex_error(cx, e, attr::IntType::UnsignedInt(t), repr_str, lit_val, false);\n+            report_bin_hex_error(\n+                cx,\n+                e,\n+                attr::IntType::UnsignedInt(ty::ast_uint_ty(t)),\n+                repr_str,\n+                lit_val,\n+                false,\n+            );\n             return;\n         }\n         cx.struct_span_lint(OVERFLOWING_LITERALS, e.span, |lint| {\n@@ -430,8 +444,8 @@ fn lint_literal<'tcx>(\n         ty::Float(t) => {\n             let is_infinite = match lit.node {\n                 ast::LitKind::Float(v, _) => match t {\n-                    ast::FloatTy::F32 => v.as_str().parse().map(f32::is_infinite),\n-                    ast::FloatTy::F64 => v.as_str().parse().map(f64::is_infinite),\n+                    ty::FloatTy::F32 => v.as_str().parse().map(f32::is_infinite),\n+                    ty::FloatTy::F64 => v.as_str().parse().map(f64::is_infinite),\n                 },\n                 _ => bug!(),\n             };\n@@ -984,7 +998,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                 help: Some(\"consider using `u32` or `libc::wchar_t` instead\".into()),\n             },\n \n-            ty::Int(ast::IntTy::I128) | ty::Uint(ast::UintTy::U128) => FfiUnsafe {\n+            ty::Int(ty::IntTy::I128) | ty::Uint(ty::UintTy::U128) => FfiUnsafe {\n                 ty,\n                 reason: \"128-bit integers don't currently have a known stable ABI\".into(),\n                 help: None,"}, {"sha": "8318bdefc8e18813b2be2b8ddba50f4bafa069fa", "filename": "compiler/rustc_middle/src/infer/unify_key.rs", "status": "modified", "additions": 3, "deletions": 50, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/compiler%2Frustc_middle%2Fsrc%2Finfer%2Funify_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/compiler%2Frustc_middle%2Fsrc%2Finfer%2Funify_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Finfer%2Funify_key.rs?ref=0e190206e2ff0c13d64701d9b4145bf89a2d0cab", "patch": "@@ -1,4 +1,4 @@\n-use crate::ty::{self, FloatVarValue, InferConst, IntVarValue, Ty, TyCtxt};\n+use crate::ty::{self, InferConst, Ty, TyCtxt};\n use rustc_data_structures::snapshot_vec;\n use rustc_data_structures::undo_log::UndoLogs;\n use rustc_data_structures::unify::{\n@@ -15,36 +15,6 @@ pub trait ToType {\n     fn to_type<'tcx>(&self, tcx: TyCtxt<'tcx>) -> Ty<'tcx>;\n }\n \n-/// Raw `TyVid` are used as the unification key for `sub_relations`;\n-/// they carry no values.\n-impl UnifyKey for ty::TyVid {\n-    type Value = ();\n-    fn index(&self) -> u32 {\n-        self.index\n-    }\n-    fn from_index(i: u32) -> ty::TyVid {\n-        ty::TyVid { index: i }\n-    }\n-    fn tag() -> &'static str {\n-        \"TyVid\"\n-    }\n-}\n-\n-impl UnifyKey for ty::IntVid {\n-    type Value = Option<IntVarValue>;\n-    fn index(&self) -> u32 {\n-        self.index\n-    }\n-    fn from_index(i: u32) -> ty::IntVid {\n-        ty::IntVid { index: i }\n-    }\n-    fn tag() -> &'static str {\n-        \"IntVid\"\n-    }\n-}\n-\n-impl EqUnifyValue for IntVarValue {}\n-\n #[derive(PartialEq, Copy, Clone, Debug)]\n pub struct RegionVidKey {\n     /// The minimum region vid in the unification set. This is needed\n@@ -80,7 +50,7 @@ impl UnifyKey for ty::RegionVid {\n     }\n }\n \n-impl ToType for IntVarValue {\n+impl ToType for ty::IntVarValue {\n     fn to_type<'tcx>(&self, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n         match *self {\n             ty::IntType(i) => tcx.mk_mach_int(i),\n@@ -89,24 +59,7 @@ impl ToType for IntVarValue {\n     }\n }\n \n-// Floating point type keys\n-\n-impl UnifyKey for ty::FloatVid {\n-    type Value = Option<FloatVarValue>;\n-    fn index(&self) -> u32 {\n-        self.index\n-    }\n-    fn from_index(i: u32) -> ty::FloatVid {\n-        ty::FloatVid { index: i }\n-    }\n-    fn tag() -> &'static str {\n-        \"FloatVid\"\n-    }\n-}\n-\n-impl EqUnifyValue for FloatVarValue {}\n-\n-impl ToType for FloatVarValue {\n+impl ToType for ty::FloatVarValue {\n     fn to_type<'tcx>(&self, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n         tcx.mk_mach_float(self.0)\n     }"}, {"sha": "20a6af5f6c13bb0d4207e2ad8f188e1829f8d18d", "filename": "compiler/rustc_middle/src/ty/cast.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcast.rs?ref=0e190206e2ff0c13d64701d9b4145bf89a2d0cab", "patch": "@@ -3,13 +3,12 @@\n \n use crate::ty::{self, Ty};\n \n-use rustc_ast as ast;\n use rustc_macros::HashStable;\n \n /// Types that are represented as ints.\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n pub enum IntTy {\n-    U(ast::UintTy),\n+    U(ty::UintTy),\n     I,\n     CEnum,\n     Bool,"}, {"sha": "1255302f743840359809554d2f062c48db8c9f84", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=0e190206e2ff0c13d64701d9b4145bf89a2d0cab", "patch": "@@ -19,10 +19,10 @@ use crate::ty::subst::{GenericArg, GenericArgKind, InternalSubsts, Subst, Substs\n use crate::ty::TyKind::*;\n use crate::ty::{\n     self, AdtDef, AdtKind, Binder, BindingMode, BoundVar, CanonicalPolyFnSig, Const, ConstVid,\n-    DefIdTree, ExistentialPredicate, FloatVar, FloatVid, GenericParamDefKind, InferConst, InferTy,\n-    IntVar, IntVid, List, ParamConst, ParamTy, PolyFnSig, Predicate, PredicateInner, PredicateKind,\n-    ProjectionTy, Region, RegionKind, ReprOptions, TraitObjectVisitor, Ty, TyKind, TyS, TyVar,\n-    TyVid, TypeAndMut, Visibility,\n+    DefIdTree, ExistentialPredicate, FloatTy, FloatVar, FloatVid, GenericParamDefKind, InferConst,\n+    InferTy, IntTy, IntVar, IntVid, List, ParamConst, ParamTy, PolyFnSig, Predicate,\n+    PredicateInner, PredicateKind, ProjectionTy, Region, RegionKind, ReprOptions,\n+    TraitObjectVisitor, Ty, TyKind, TyS, TyVar, TyVid, TypeAndMut, UintTy, Visibility,\n };\n use rustc_ast as ast;\n use rustc_ast::expand::allocator::AllocatorKind;\n@@ -839,20 +839,20 @@ impl<'tcx> CommonTypes<'tcx> {\n             bool: mk(Bool),\n             char: mk(Char),\n             never: mk(Never),\n-            isize: mk(Int(ast::IntTy::Isize)),\n-            i8: mk(Int(ast::IntTy::I8)),\n-            i16: mk(Int(ast::IntTy::I16)),\n-            i32: mk(Int(ast::IntTy::I32)),\n-            i64: mk(Int(ast::IntTy::I64)),\n-            i128: mk(Int(ast::IntTy::I128)),\n-            usize: mk(Uint(ast::UintTy::Usize)),\n-            u8: mk(Uint(ast::UintTy::U8)),\n-            u16: mk(Uint(ast::UintTy::U16)),\n-            u32: mk(Uint(ast::UintTy::U32)),\n-            u64: mk(Uint(ast::UintTy::U64)),\n-            u128: mk(Uint(ast::UintTy::U128)),\n-            f32: mk(Float(ast::FloatTy::F32)),\n-            f64: mk(Float(ast::FloatTy::F64)),\n+            isize: mk(Int(ty::IntTy::Isize)),\n+            i8: mk(Int(ty::IntTy::I8)),\n+            i16: mk(Int(ty::IntTy::I16)),\n+            i32: mk(Int(ty::IntTy::I32)),\n+            i64: mk(Int(ty::IntTy::I64)),\n+            i128: mk(Int(ty::IntTy::I128)),\n+            usize: mk(Uint(ty::UintTy::Usize)),\n+            u8: mk(Uint(ty::UintTy::U8)),\n+            u16: mk(Uint(ty::UintTy::U16)),\n+            u32: mk(Uint(ty::UintTy::U32)),\n+            u64: mk(Uint(ty::UintTy::U64)),\n+            u128: mk(Uint(ty::UintTy::U128)),\n+            f32: mk(Float(ty::FloatTy::F32)),\n+            f64: mk(Float(ty::FloatTy::F64)),\n             str_: mk(Str),\n             self_param: mk(ty::Param(ty::ParamTy { index: 0, name: kw::SelfUpper })),\n \n@@ -2102,32 +2102,32 @@ impl<'tcx> TyCtxt<'tcx> {\n         if pred.kind() != binder { self.mk_predicate(binder) } else { pred }\n     }\n \n-    pub fn mk_mach_int(self, tm: ast::IntTy) -> Ty<'tcx> {\n+    pub fn mk_mach_int(self, tm: IntTy) -> Ty<'tcx> {\n         match tm {\n-            ast::IntTy::Isize => self.types.isize,\n-            ast::IntTy::I8 => self.types.i8,\n-            ast::IntTy::I16 => self.types.i16,\n-            ast::IntTy::I32 => self.types.i32,\n-            ast::IntTy::I64 => self.types.i64,\n-            ast::IntTy::I128 => self.types.i128,\n+            IntTy::Isize => self.types.isize,\n+            IntTy::I8 => self.types.i8,\n+            IntTy::I16 => self.types.i16,\n+            IntTy::I32 => self.types.i32,\n+            IntTy::I64 => self.types.i64,\n+            IntTy::I128 => self.types.i128,\n         }\n     }\n \n-    pub fn mk_mach_uint(self, tm: ast::UintTy) -> Ty<'tcx> {\n+    pub fn mk_mach_uint(self, tm: UintTy) -> Ty<'tcx> {\n         match tm {\n-            ast::UintTy::Usize => self.types.usize,\n-            ast::UintTy::U8 => self.types.u8,\n-            ast::UintTy::U16 => self.types.u16,\n-            ast::UintTy::U32 => self.types.u32,\n-            ast::UintTy::U64 => self.types.u64,\n-            ast::UintTy::U128 => self.types.u128,\n+            UintTy::Usize => self.types.usize,\n+            UintTy::U8 => self.types.u8,\n+            UintTy::U16 => self.types.u16,\n+            UintTy::U32 => self.types.u32,\n+            UintTy::U64 => self.types.u64,\n+            UintTy::U128 => self.types.u128,\n         }\n     }\n \n-    pub fn mk_mach_float(self, tm: ast::FloatTy) -> Ty<'tcx> {\n+    pub fn mk_mach_float(self, tm: FloatTy) -> Ty<'tcx> {\n         match tm {\n-            ast::FloatTy::F32 => self.types.f32,\n-            ast::FloatTy::F64 => self.types.f64,\n+            FloatTy::F32 => self.types.f32,\n+            FloatTy::F64 => self.types.f64,\n         }\n     }\n "}, {"sha": "e386d973ee447bd2f3b9cf2f90e3e0ea2f14b8d3", "filename": "compiler/rustc_middle/src/ty/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs?ref=0e190206e2ff0c13d64701d9b4145bf89a2d0cab", "patch": "@@ -1,8 +1,7 @@\n //! Diagnostics related methods for `TyS`.\n \n-use crate::ty::sty::InferTy;\n use crate::ty::TyKind::*;\n-use crate::ty::{TyCtxt, TyS};\n+use crate::ty::{InferTy, TyCtxt, TyS};\n use rustc_errors::{Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;"}, {"sha": "c211f07bed8c2f41bf640ac845df95ad52624730", "filename": "compiler/rustc_middle/src/ty/error.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs?ref=0e190206e2ff0c13d64701d9b4145bf89a2d0cab", "patch": "@@ -1,7 +1,6 @@\n use crate::traits::{ObligationCause, ObligationCauseCode};\n use crate::ty::diagnostics::suggest_constraining_type_param;\n use crate::ty::{self, BoundRegionKind, Region, Ty, TyCtxt};\n-use rustc_ast as ast;\n use rustc_errors::Applicability::{MachineApplicable, MaybeIncorrect};\n use rustc_errors::{pluralize, DiagnosticBuilder};\n use rustc_hir as hir;\n@@ -48,7 +47,7 @@ pub enum TypeError<'tcx> {\n \n     Sorts(ExpectedFound<Ty<'tcx>>),\n     IntMismatch(ExpectedFound<ty::IntVarValue>),\n-    FloatMismatch(ExpectedFound<ast::FloatTy>),\n+    FloatMismatch(ExpectedFound<ty::FloatTy>),\n     Traits(ExpectedFound<DefId>),\n     VariadicMismatch(ExpectedFound<bool>),\n "}, {"sha": "94d75a469d3d7527054af67ef8bc18594f077329", "filename": "compiler/rustc_middle/src/ty/fast_reject.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffast_reject.rs?ref=0e190206e2ff0c13d64701d9b4145bf89a2d0cab", "patch": "@@ -1,6 +1,5 @@\n use crate::ich::StableHashingContext;\n use crate::ty::{self, Ty, TyCtxt};\n-use rustc_ast as ast;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_hir::def_id::DefId;\n use std::fmt::Debug;\n@@ -24,9 +23,9 @@ where\n {\n     BoolSimplifiedType,\n     CharSimplifiedType,\n-    IntSimplifiedType(ast::IntTy),\n-    UintSimplifiedType(ast::UintTy),\n-    FloatSimplifiedType(ast::FloatTy),\n+    IntSimplifiedType(ty::IntTy),\n+    UintSimplifiedType(ty::UintTy),\n+    FloatSimplifiedType(ty::FloatTy),\n     AdtSimplifiedType(D),\n     StrSimplifiedType,\n     ArraySimplifiedType,"}, {"sha": "ee837d88b7b25d8b4ab03995b6571b00a1874b9d", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 34, "deletions": 11, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=0e190206e2ff0c13d64701d9b4145bf89a2d0cab", "patch": "@@ -4,7 +4,7 @@ use crate::mir::{GeneratorLayout, GeneratorSavedLocal};\n use crate::ty::subst::Subst;\n use crate::ty::{self, subst::SubstsRef, ReprOptions, Ty, TyCtxt, TypeFoldable};\n \n-use rustc_ast::{self as ast, IntTy, UintTy};\n+use rustc_ast as ast;\n use rustc_attr as attr;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_hir as hir;\n@@ -30,6 +30,8 @@ use std::ops::Bound;\n pub trait IntegerExt {\n     fn to_ty<'tcx>(&self, tcx: TyCtxt<'tcx>, signed: bool) -> Ty<'tcx>;\n     fn from_attr<C: HasDataLayout>(cx: &C, ity: attr::IntType) -> Integer;\n+    fn from_int_ty<C: HasDataLayout>(cx: &C, ity: ty::IntTy) -> Integer;\n+    fn from_uint_ty<C: HasDataLayout>(cx: &C, uty: ty::UintTy) -> Integer;\n     fn repr_discr<'tcx>(\n         tcx: TyCtxt<'tcx>,\n         ty: Ty<'tcx>,\n@@ -60,17 +62,38 @@ impl IntegerExt for Integer {\n         let dl = cx.data_layout();\n \n         match ity {\n-            attr::SignedInt(IntTy::I8) | attr::UnsignedInt(UintTy::U8) => I8,\n-            attr::SignedInt(IntTy::I16) | attr::UnsignedInt(UintTy::U16) => I16,\n-            attr::SignedInt(IntTy::I32) | attr::UnsignedInt(UintTy::U32) => I32,\n-            attr::SignedInt(IntTy::I64) | attr::UnsignedInt(UintTy::U64) => I64,\n-            attr::SignedInt(IntTy::I128) | attr::UnsignedInt(UintTy::U128) => I128,\n-            attr::SignedInt(IntTy::Isize) | attr::UnsignedInt(UintTy::Usize) => {\n+            attr::SignedInt(ast::IntTy::I8) | attr::UnsignedInt(ast::UintTy::U8) => I8,\n+            attr::SignedInt(ast::IntTy::I16) | attr::UnsignedInt(ast::UintTy::U16) => I16,\n+            attr::SignedInt(ast::IntTy::I32) | attr::UnsignedInt(ast::UintTy::U32) => I32,\n+            attr::SignedInt(ast::IntTy::I64) | attr::UnsignedInt(ast::UintTy::U64) => I64,\n+            attr::SignedInt(ast::IntTy::I128) | attr::UnsignedInt(ast::UintTy::U128) => I128,\n+            attr::SignedInt(ast::IntTy::Isize) | attr::UnsignedInt(ast::UintTy::Usize) => {\n                 dl.ptr_sized_integer()\n             }\n         }\n     }\n \n+    fn from_int_ty<C: HasDataLayout>(cx: &C, ity: ty::IntTy) -> Integer {\n+        match ity {\n+            ty::IntTy::I8 => I8,\n+            ty::IntTy::I16 => I16,\n+            ty::IntTy::I32 => I32,\n+            ty::IntTy::I64 => I64,\n+            ty::IntTy::I128 => I128,\n+            ty::IntTy::Isize => cx.data_layout().ptr_sized_integer(),\n+        }\n+    }\n+    fn from_uint_ty<C: HasDataLayout>(cx: &C, ity: ty::UintTy) -> Integer {\n+        match ity {\n+            ty::UintTy::U8 => I8,\n+            ty::UintTy::U16 => I16,\n+            ty::UintTy::U32 => I32,\n+            ty::UintTy::U64 => I64,\n+            ty::UintTy::U128 => I128,\n+            ty::UintTy::Usize => cx.data_layout().ptr_sized_integer(),\n+        }\n+    }\n+\n     /// Finds the appropriate Integer type and signedness for the given\n     /// signed discriminant range and `#[repr]` attribute.\n     /// N.B.: `u128` values above `i128::MAX` will be treated as signed, but\n@@ -487,11 +510,11 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                 self,\n                 Scalar { value: Int(I32, false), valid_range: 0..=0x10FFFF },\n             )),\n-            ty::Int(ity) => scalar(Int(Integer::from_attr(dl, attr::SignedInt(ity)), true)),\n-            ty::Uint(ity) => scalar(Int(Integer::from_attr(dl, attr::UnsignedInt(ity)), false)),\n+            ty::Int(ity) => scalar(Int(Integer::from_int_ty(dl, ity), true)),\n+            ty::Uint(ity) => scalar(Int(Integer::from_uint_ty(dl, ity), false)),\n             ty::Float(fty) => scalar(match fty {\n-                ast::FloatTy::F32 => F32,\n-                ast::FloatTy::F64 => F64,\n+                ty::FloatTy::F32 => F32,\n+                ty::FloatTy::F64 => F64,\n             }),\n             ty::FnPtr(_) => {\n                 let mut ptr = scalar_unit(Pointer);"}, {"sha": "8e8caa46c3802edc8ad0f3964f6f77b6ba895ddf", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 74, "deletions": 83, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=0e190206e2ff0c13d64701d9b4145bf89a2d0cab", "patch": "@@ -65,7 +65,6 @@ use std::ptr;\n use std::str;\n \n pub use self::sty::BoundRegionKind::*;\n-pub use self::sty::InferTy::*;\n pub use self::sty::RegionKind;\n pub use self::sty::RegionKind::*;\n pub use self::sty::TyKind::*;\n@@ -74,13 +73,14 @@ pub use self::sty::{BoundRegion, BoundRegionKind, EarlyBoundRegion, FreeRegion,\n pub use self::sty::{CanonicalPolyFnSig, FnSig, GenSig, PolyFnSig, PolyGenSig};\n pub use self::sty::{ClosureSubsts, GeneratorSubsts, TypeAndMut, UpvarSubsts};\n pub use self::sty::{ClosureSubstsParts, GeneratorSubstsParts};\n-pub use self::sty::{ConstVid, FloatVid, IntVid, RegionVid, TyVid};\n-pub use self::sty::{ExistentialPredicate, InferTy, ParamConst, ParamTy, ProjectionTy};\n+pub use self::sty::{ConstVid, RegionVid};\n+pub use self::sty::{ExistentialPredicate, ParamConst, ParamTy, ProjectionTy};\n pub use self::sty::{ExistentialProjection, PolyExistentialProjection};\n pub use self::sty::{ExistentialTraitRef, PolyExistentialTraitRef};\n pub use self::sty::{PolyTraitRef, TraitRef, TyKind};\n pub use crate::ty::diagnostics::*;\n-pub use rustc_type_ir::{DebruijnIndex, TypeFlags, INNERMOST};\n+pub use rustc_type_ir::InferTy::*;\n+pub use rustc_type_ir::*;\n \n pub use self::binding::BindingMode;\n pub use self::binding::BindingMode::*;\n@@ -421,14 +421,6 @@ impl Visibility {\n     }\n }\n \n-#[derive(Copy, Clone, PartialEq, TyDecodable, TyEncodable, HashStable)]\n-pub enum Variance {\n-    Covariant,     // T<A> <: T<B> iff A <: B -- e.g., function return type\n-    Invariant,     // T<A> <: T<B> iff B == A -- e.g., type of mutable cell\n-    Contravariant, // T<A> <: T<B> iff B <: A -- e.g., function param type\n-    Bivariant,     // T<A> <: T<B>            -- e.g., unused type parameter\n-}\n-\n /// The crate variances map is computed during typeck and contains the\n /// variance of every item in the local crate. You should not use it\n /// directly, because to do so will make your pass dependent on the\n@@ -443,66 +435,6 @@ pub struct CrateVariancesMap<'tcx> {\n     pub variances: FxHashMap<DefId, &'tcx [ty::Variance]>,\n }\n \n-impl Variance {\n-    /// `a.xform(b)` combines the variance of a context with the\n-    /// variance of a type with the following meaning. If we are in a\n-    /// context with variance `a`, and we encounter a type argument in\n-    /// a position with variance `b`, then `a.xform(b)` is the new\n-    /// variance with which the argument appears.\n-    ///\n-    /// Example 1:\n-    ///\n-    ///     *mut Vec<i32>\n-    ///\n-    /// Here, the \"ambient\" variance starts as covariant. `*mut T` is\n-    /// invariant with respect to `T`, so the variance in which the\n-    /// `Vec<i32>` appears is `Covariant.xform(Invariant)`, which\n-    /// yields `Invariant`. Now, the type `Vec<T>` is covariant with\n-    /// respect to its type argument `T`, and hence the variance of\n-    /// the `i32` here is `Invariant.xform(Covariant)`, which results\n-    /// (again) in `Invariant`.\n-    ///\n-    /// Example 2:\n-    ///\n-    ///     fn(*const Vec<i32>, *mut Vec<i32)\n-    ///\n-    /// The ambient variance is covariant. A `fn` type is\n-    /// contravariant with respect to its parameters, so the variance\n-    /// within which both pointer types appear is\n-    /// `Covariant.xform(Contravariant)`, or `Contravariant`. `*const\n-    /// T` is covariant with respect to `T`, so the variance within\n-    /// which the first `Vec<i32>` appears is\n-    /// `Contravariant.xform(Covariant)` or `Contravariant`. The same\n-    /// is true for its `i32` argument. In the `*mut T` case, the\n-    /// variance of `Vec<i32>` is `Contravariant.xform(Invariant)`,\n-    /// and hence the outermost type is `Invariant` with respect to\n-    /// `Vec<i32>` (and its `i32` argument).\n-    ///\n-    /// Source: Figure 1 of \"Taming the Wildcards:\n-    /// Combining Definition- and Use-Site Variance\" published in PLDI'11.\n-    pub fn xform(self, v: ty::Variance) -> ty::Variance {\n-        match (self, v) {\n-            // Figure 1, column 1.\n-            (ty::Covariant, ty::Covariant) => ty::Covariant,\n-            (ty::Covariant, ty::Contravariant) => ty::Contravariant,\n-            (ty::Covariant, ty::Invariant) => ty::Invariant,\n-            (ty::Covariant, ty::Bivariant) => ty::Bivariant,\n-\n-            // Figure 1, column 2.\n-            (ty::Contravariant, ty::Covariant) => ty::Contravariant,\n-            (ty::Contravariant, ty::Contravariant) => ty::Covariant,\n-            (ty::Contravariant, ty::Invariant) => ty::Invariant,\n-            (ty::Contravariant, ty::Bivariant) => ty::Bivariant,\n-\n-            // Figure 1, column 3.\n-            (ty::Invariant, _) => ty::Invariant,\n-\n-            // Figure 1, column 4.\n-            (ty::Bivariant, _) => ty::Bivariant,\n-        }\n-    }\n-}\n-\n // Contains information needed to resolve types and (in the future) look up\n // the types of AST nodes.\n #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n@@ -780,8 +712,20 @@ pub fn place_to_string_for_capture(tcx: TyCtxt<'tcx>, place: &HirPlace<'tcx>) ->\n pub struct CaptureInfo<'tcx> {\n     /// Expr Id pointing to use that resulted in selecting the current capture kind\n     ///\n+    /// Eg:\n+    /// ```rust,no_run\n+    /// let mut t = (0,1);\n+    ///\n+    /// let c = || {\n+    ///     println!(\"{}\",t); // L1\n+    ///     t.1 = 4; // L2\n+    /// };\n+    /// ```\n+    /// `capture_kind_expr_id` will point to the use on L2 and `path_expr_id` will point to the\n+    /// use on L1.\n+    ///\n     /// If the user doesn't enable feature `capture_disjoint_fields` (RFC 2229) then, it is\n-    /// possible that we don't see the use of a particular place resulting in expr_id being\n+    /// possible that we don't see the use of a particular place resulting in capture_kind_expr_id being\n     /// None. In such case we fallback on uvpars_mentioned for span.\n     ///\n     /// Eg:\n@@ -795,7 +739,12 @@ pub struct CaptureInfo<'tcx> {\n     ///\n     /// In this example, if `capture_disjoint_fields` is **not** set, then x will be captured,\n     /// but we won't see it being used during capture analysis, since it's essentially a discard.\n-    pub expr_id: Option<hir::HirId>,\n+    pub capture_kind_expr_id: Option<hir::HirId>,\n+    /// Expr Id pointing to use that resulted the corresponding place being captured\n+    ///\n+    /// See `capture_kind_expr_id` for example.\n+    ///\n+    pub path_expr_id: Option<hir::HirId>,\n \n     /// Capture mode that was selected\n     pub capture_kind: UpvarCapture<'tcx>,\n@@ -804,15 +753,6 @@ pub struct CaptureInfo<'tcx> {\n pub type UpvarListMap = FxHashMap<DefId, FxIndexMap<hir::HirId, UpvarId>>;\n pub type UpvarCaptureMap<'tcx> = FxHashMap<UpvarId, UpvarCapture<'tcx>>;\n \n-#[derive(Clone, Copy, PartialEq, Eq)]\n-pub enum IntVarValue {\n-    IntType(ast::IntTy),\n-    UintType(ast::UintTy),\n-}\n-\n-#[derive(Clone, Copy, PartialEq, Eq)]\n-pub struct FloatVarValue(pub ast::FloatTy);\n-\n impl ty::EarlyBoundRegion {\n     /// Does this early bound region have a name? Early bound regions normally\n     /// always have names except when using anonymous lifetimes (`'_`).\n@@ -3122,6 +3062,57 @@ pub fn is_impl_trait_defn(tcx: TyCtxt<'_>, def_id: DefId) -> Option<DefId> {\n     None\n }\n \n+pub fn int_ty(ity: ast::IntTy) -> IntTy {\n+    match ity {\n+        ast::IntTy::Isize => IntTy::Isize,\n+        ast::IntTy::I8 => IntTy::I8,\n+        ast::IntTy::I16 => IntTy::I16,\n+        ast::IntTy::I32 => IntTy::I32,\n+        ast::IntTy::I64 => IntTy::I64,\n+        ast::IntTy::I128 => IntTy::I128,\n+    }\n+}\n+\n+pub fn uint_ty(uty: ast::UintTy) -> UintTy {\n+    match uty {\n+        ast::UintTy::Usize => UintTy::Usize,\n+        ast::UintTy::U8 => UintTy::U8,\n+        ast::UintTy::U16 => UintTy::U16,\n+        ast::UintTy::U32 => UintTy::U32,\n+        ast::UintTy::U64 => UintTy::U64,\n+        ast::UintTy::U128 => UintTy::U128,\n+    }\n+}\n+\n+pub fn float_ty(fty: ast::FloatTy) -> FloatTy {\n+    match fty {\n+        ast::FloatTy::F32 => FloatTy::F32,\n+        ast::FloatTy::F64 => FloatTy::F64,\n+    }\n+}\n+\n+pub fn ast_int_ty(ity: IntTy) -> ast::IntTy {\n+    match ity {\n+        IntTy::Isize => ast::IntTy::Isize,\n+        IntTy::I8 => ast::IntTy::I8,\n+        IntTy::I16 => ast::IntTy::I16,\n+        IntTy::I32 => ast::IntTy::I32,\n+        IntTy::I64 => ast::IntTy::I64,\n+        IntTy::I128 => ast::IntTy::I128,\n+    }\n+}\n+\n+pub fn ast_uint_ty(uty: UintTy) -> ast::UintTy {\n+    match uty {\n+        UintTy::Usize => ast::UintTy::Usize,\n+        UintTy::U8 => ast::UintTy::U8,\n+        UintTy::U16 => ast::UintTy::U16,\n+        UintTy::U32 => ast::UintTy::U32,\n+        UintTy::U64 => ast::UintTy::U64,\n+        UintTy::U128 => ast::UintTy::U128,\n+    }\n+}\n+\n pub fn provide(providers: &mut ty::query::Providers) {\n     context::provide(providers);\n     erase_regions::provide(providers);"}, {"sha": "4937fdd73144de928d7bbae4bb1e1f06a40cf5c6", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 11, "deletions": 22, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=0e190206e2ff0c13d64701d9b4145bf89a2d0cab", "patch": "@@ -3,7 +3,6 @@ use crate::mir::interpret::{AllocId, ConstValue, GlobalAlloc, Pointer, Scalar};\n use crate::ty::subst::{GenericArg, GenericArgKind, Subst};\n use crate::ty::{self, ConstInt, DefIdTree, ParamConst, ScalarInt, Ty, TyCtxt, TypeFoldable};\n use rustc_apfloat::ieee::{Double, Single};\n-use rustc_ast as ast;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir as hir;\n use rustc_hir::def::{self, CtorKind, DefKind, Namespace};\n@@ -557,14 +556,19 @@ pub trait PrettyPrinter<'tcx>:\n             }\n             ty::FnPtr(ref bare_fn) => p!(print(bare_fn)),\n             ty::Infer(infer_ty) => {\n+                let verbose = self.tcx().sess.verbose();\n                 if let ty::TyVar(ty_vid) = infer_ty {\n                     if let Some(name) = self.infer_ty_name(ty_vid) {\n                         p!(write(\"{}\", name))\n                     } else {\n-                        p!(write(\"{}\", infer_ty))\n+                        if verbose {\n+                            p!(write(\"{:?}\", infer_ty))\n+                        } else {\n+                            p!(write(\"{}\", infer_ty))\n+                        }\n                     }\n                 } else {\n-                    p!(write(\"{}\", infer_ty))\n+                    if verbose { p!(write(\"{:?}\", infer_ty)) } else { p!(write(\"{}\", infer_ty)) }\n                 }\n             }\n             ty::Error(_) => p!(\"[type error]\"),\n@@ -968,7 +972,7 @@ pub trait PrettyPrinter<'tcx>:\n                     ty::TyS {\n                         kind:\n                             ty::Array(\n-                                ty::TyS { kind: ty::Uint(ast::UintTy::U8), .. },\n+                                ty::TyS { kind: ty::Uint(ty::UintTy::U8), .. },\n                                 ty::Const {\n                                     val: ty::ConstKind::Value(ConstValue::Scalar(int)),\n                                     ..\n@@ -997,10 +1001,10 @@ pub trait PrettyPrinter<'tcx>:\n             (Scalar::Int(int), ty::Bool) if int == ScalarInt::FALSE => p!(\"false\"),\n             (Scalar::Int(int), ty::Bool) if int == ScalarInt::TRUE => p!(\"true\"),\n             // Float\n-            (Scalar::Int(int), ty::Float(ast::FloatTy::F32)) => {\n+            (Scalar::Int(int), ty::Float(ty::FloatTy::F32)) => {\n                 p!(write(\"{}f32\", Single::try_from(int).unwrap()))\n             }\n-            (Scalar::Int(int), ty::Float(ast::FloatTy::F64)) => {\n+            (Scalar::Int(int), ty::Float(ty::FloatTy::F64)) => {\n                 p!(write(\"{}f64\", Double::try_from(int).unwrap()))\n             }\n             // Int\n@@ -1246,7 +1250,7 @@ pub struct FmtPrinterData<'a, 'tcx, F> {\n \n     pub region_highlight_mode: RegionHighlightMode,\n \n-    pub name_resolver: Option<Box<&'a dyn Fn(ty::sty::TyVid) -> Option<String>>>,\n+    pub name_resolver: Option<Box<&'a dyn Fn(ty::TyVid) -> Option<String>>>,\n }\n \n impl<F> Deref for FmtPrinter<'a, 'tcx, F> {\n@@ -2007,21 +2011,6 @@ define_print_and_forward_display! {\n         p!(\"fn\", pretty_fn_sig(self.inputs(), self.c_variadic, self.output()));\n     }\n \n-    ty::InferTy {\n-        if cx.tcx().sess.verbose() {\n-            p!(write(\"{:?}\", self));\n-            return Ok(cx);\n-        }\n-        match *self {\n-            ty::TyVar(_) => p!(\"_\"),\n-            ty::IntVar(_) => p!(write(\"{}\", \"{integer}\")),\n-            ty::FloatVar(_) => p!(write(\"{}\", \"{float}\")),\n-            ty::FreshTy(v) => p!(write(\"FreshTy({})\", v)),\n-            ty::FreshIntTy(v) => p!(write(\"FreshIntTy({})\", v)),\n-            ty::FreshFloatTy(v) => p!(write(\"FreshFloatTy({})\", v))\n-        }\n-    }\n-\n     ty::TraitRef<'tcx> {\n         p!(write(\"<{} as {}>\", self.self_ty(), self.print_only_trait_path()))\n     }"}, {"sha": "0ca94a9f1805df88f78008c1e94081b5fd0ea688", "filename": "compiler/rustc_middle/src/ty/structural_impls.rs", "status": "modified", "additions": 1, "deletions": 58, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs?ref=0e190206e2ff0c13d64701d9b4145bf89a2d0cab", "patch": "@@ -111,81 +111,24 @@ impl fmt::Debug for ty::FreeRegion {\n     }\n }\n \n-impl fmt::Debug for ty::Variance {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.write_str(match *self {\n-            ty::Covariant => \"+\",\n-            ty::Contravariant => \"-\",\n-            ty::Invariant => \"o\",\n-            ty::Bivariant => \"*\",\n-        })\n-    }\n-}\n-\n impl fmt::Debug for ty::FnSig<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(f, \"({:?}; c_variadic: {})->{:?}\", self.inputs(), self.c_variadic, self.output())\n     }\n }\n \n-impl fmt::Debug for ty::TyVid {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"_#{}t\", self.index)\n-    }\n-}\n-\n impl<'tcx> fmt::Debug for ty::ConstVid<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(f, \"_#{}c\", self.index)\n     }\n }\n \n-impl fmt::Debug for ty::IntVid {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"_#{}i\", self.index)\n-    }\n-}\n-\n-impl fmt::Debug for ty::FloatVid {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"_#{}f\", self.index)\n-    }\n-}\n-\n impl fmt::Debug for ty::RegionVid {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(f, \"'_#{}r\", self.index())\n     }\n }\n \n-impl fmt::Debug for ty::InferTy {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match *self {\n-            ty::TyVar(ref v) => v.fmt(f),\n-            ty::IntVar(ref v) => v.fmt(f),\n-            ty::FloatVar(ref v) => v.fmt(f),\n-            ty::FreshTy(v) => write!(f, \"FreshTy({:?})\", v),\n-            ty::FreshIntTy(v) => write!(f, \"FreshIntTy({:?})\", v),\n-            ty::FreshFloatTy(v) => write!(f, \"FreshFloatTy({:?})\", v),\n-        }\n-    }\n-}\n-\n-impl fmt::Debug for ty::IntVarValue {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match *self {\n-            ty::IntType(ref v) => v.fmt(f),\n-            ty::UintType(ref v) => v.fmt(f),\n-        }\n-    }\n-}\n-\n-impl fmt::Debug for ty::FloatVarValue {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        self.0.fmt(f)\n-    }\n-}\n-\n impl fmt::Debug for ty::TraitRef<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         with_no_trimmed_paths(|| fmt::Display::fmt(self, f))\n@@ -274,7 +217,7 @@ TrivialTypeFoldableAndLiftImpls! {\n     u64,\n     String,\n     crate::middle::region::Scope,\n-    ::rustc_ast::FloatTy,\n+    crate::ty::FloatTy,\n     ::rustc_ast::InlineAsmOptions,\n     ::rustc_ast::InlineAsmTemplatePiece,\n     ::rustc_ast::NodeId,"}, {"sha": "9cec0eb5be3c508d4ec7fb12aa9e57bdaf7a7fde", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 9, "deletions": 65, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=0e190206e2ff0c13d64701d9b4145bf89a2d0cab", "patch": "@@ -2,17 +2,16 @@\n \n #![allow(rustc::usage_of_ty_tykind)]\n \n-use self::InferTy::*;\n use self::TyKind::*;\n \n use crate::infer::canonical::Canonical;\n use crate::ty::subst::{GenericArg, InternalSubsts, Subst, SubstsRef};\n+use crate::ty::InferTy::{self, *};\n use crate::ty::{\n     self, AdtDef, DefIdTree, Discr, Ty, TyCtxt, TypeFlags, TypeFoldable, WithConstness,\n };\n use crate::ty::{DelaySpanBugEmitted, List, ParamEnv, TyS};\n use polonius_engine::Atom;\n-use rustc_ast as ast;\n use rustc_data_structures::captures::Captures;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n@@ -104,13 +103,13 @@ pub enum TyKind<'tcx> {\n     Char,\n \n     /// A primitive signed integer type. For example, `i32`.\n-    Int(ast::IntTy),\n+    Int(ty::IntTy),\n \n     /// A primitive unsigned integer type. For example, `u32`.\n-    Uint(ast::UintTy),\n+    Uint(ty::UintTy),\n \n     /// A primitive floating-point type. For example, `f64`.\n-    Float(ast::FloatTy),\n+    Float(ty::FloatTy),\n \n     /// Algebraic data types (ADT). For example: structures, enumerations and unions.\n     ///\n@@ -1426,31 +1425,13 @@ pub struct EarlyBoundRegion {\n     pub name: Symbol,\n }\n \n-/// A **ty**pe **v**ariable **ID**.\n-#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, TyEncodable, TyDecodable)]\n-pub struct TyVid {\n-    pub index: u32,\n-}\n-\n /// A **`const`** **v**ariable **ID**.\n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, TyEncodable, TyDecodable)]\n pub struct ConstVid<'tcx> {\n     pub index: u32,\n     pub phantom: PhantomData<&'tcx ()>,\n }\n \n-/// An **int**egral (`u32`, `i32`, `usize`, etc.) type **v**ariable **ID**.\n-#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, TyEncodable, TyDecodable)]\n-pub struct IntVid {\n-    pub index: u32,\n-}\n-\n-/// An **float**ing-point (`f32` or `f64`) type **v**ariable **ID**.\n-#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, TyEncodable, TyDecodable)]\n-pub struct FloatVid {\n-    pub index: u32,\n-}\n-\n rustc_index::newtype_index! {\n     /// A **region** (lifetime) **v**ariable **ID**.\n     pub struct RegionVid {\n@@ -1464,43 +1445,6 @@ impl Atom for RegionVid {\n     }\n }\n \n-/// A placeholder for a type that hasn't been inferred yet.\n-///\n-/// E.g., if we have an empty array (`[]`), then we create a fresh\n-/// type variable for the element type since we won't know until it's\n-/// used what the element type is supposed to be.\n-#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, TyEncodable, TyDecodable)]\n-#[derive(HashStable)]\n-pub enum InferTy {\n-    /// A type variable.\n-    TyVar(TyVid),\n-    /// An integral type variable (`{integer}`).\n-    ///\n-    /// These are created when the compiler sees an integer literal like\n-    /// `1` that could be several different types (`u8`, `i32`, `u32`, etc.).\n-    /// We don't know until it's used what type it's supposed to be, so\n-    /// we create a fresh type variable.\n-    IntVar(IntVid),\n-    /// A floating-point type variable (`{float}`).\n-    ///\n-    /// These are created when the compiler sees an float literal like\n-    /// `1.0` that could be either an `f32` or an `f64`.\n-    /// We don't know until it's used what type it's supposed to be, so\n-    /// we create a fresh type variable.\n-    FloatVar(FloatVid),\n-\n-    /// A [`FreshTy`][Self::FreshTy] is one that is generated as a replacement\n-    /// for an unbound type variable. This is convenient for caching etc. See\n-    /// `rustc_infer::infer::freshen` for more details.\n-    ///\n-    /// Compare with [`TyVar`][Self::TyVar].\n-    FreshTy(u32),\n-    /// Like [`FreshTy`][Self::FreshTy], but as a replacement for [`IntVar`][Self::IntVar].\n-    FreshIntTy(u32),\n-    /// Like [`FreshTy`][Self::FreshTy], but as a replacement for [`FloatVar`][Self::FloatVar].\n-    FreshFloatTy(u32),\n-}\n-\n rustc_index::newtype_index! {\n     pub struct BoundVar { .. }\n }\n@@ -1853,7 +1797,7 @@ impl<'tcx> TyS<'tcx> {\n     pub fn sequence_element_type(&self, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n         match self.kind() {\n             Array(ty, _) | Slice(ty) => ty,\n-            Str => tcx.mk_mach_uint(ast::UintTy::U8),\n+            Str => tcx.mk_mach_uint(ty::UintTy::U8),\n             _ => bug!(\"`sequence_element_type` called on non-sequence value: {}\", self),\n         }\n     }\n@@ -1993,7 +1937,7 @@ impl<'tcx> TyS<'tcx> {\n \n     #[inline]\n     pub fn is_ptr_sized_integral(&self) -> bool {\n-        matches!(self.kind(), Int(ast::IntTy::Isize) | Uint(ast::UintTy::Usize))\n+        matches!(self.kind(), Int(ty::IntTy::Isize) | Uint(ty::UintTy::Usize))\n     }\n \n     #[inline]\n@@ -2181,9 +2125,9 @@ impl<'tcx> TyS<'tcx> {\n     pub fn to_opt_closure_kind(&self) -> Option<ty::ClosureKind> {\n         match self.kind() {\n             Int(int_ty) => match int_ty {\n-                ast::IntTy::I8 => Some(ty::ClosureKind::Fn),\n-                ast::IntTy::I16 => Some(ty::ClosureKind::FnMut),\n-                ast::IntTy::I32 => Some(ty::ClosureKind::FnOnce),\n+                ty::IntTy::I8 => Some(ty::ClosureKind::Fn),\n+                ty::IntTy::I16 => Some(ty::ClosureKind::FnMut),\n+                ty::IntTy::I32 => Some(ty::ClosureKind::FnOnce),\n                 _ => bug!(\"cannot convert type `{:?}` to a closure kind\", self),\n             },\n "}, {"sha": "8edde8794ed27c3de6ef2544acc857c6da7d888e", "filename": "compiler/rustc_middle/src/ty/util.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs?ref=0e190206e2ff0c13d64701d9b4145bf89a2d0cab", "patch": "@@ -34,7 +34,7 @@ impl<'tcx> fmt::Display for Discr<'tcx> {\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match *self.ty.kind() {\n             ty::Int(ity) => {\n-                let size = ty::tls::with(|tcx| Integer::from_attr(&tcx, SignedInt(ity)).size());\n+                let size = ty::tls::with(|tcx| Integer::from_int_ty(&tcx, ity).size());\n                 let x = self.val;\n                 // sign extend the raw representation to be an i128\n                 let x = size.sign_extend(x) as i128;\n@@ -59,8 +59,8 @@ fn unsigned_max(size: Size) -> u128 {\n \n fn int_size_and_signed<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> (Size, bool) {\n     let (int, signed) = match *ty.kind() {\n-        Int(ity) => (Integer::from_attr(&tcx, SignedInt(ity)), true),\n-        Uint(uty) => (Integer::from_attr(&tcx, UnsignedInt(uty)), false),\n+        Int(ity) => (Integer::from_int_ty(&tcx, ity), true),\n+        Uint(uty) => (Integer::from_uint_ty(&tcx, uty), false),\n         _ => bug!(\"non integer discriminant\"),\n     };\n     (int.size(), signed)\n@@ -642,8 +642,8 @@ impl<'tcx> ty::TyS<'tcx> {\n             }\n             ty::Char => Some(std::char::MAX as u128),\n             ty::Float(fty) => Some(match fty {\n-                ast::FloatTy::F32 => rustc_apfloat::ieee::Single::INFINITY.to_bits(),\n-                ast::FloatTy::F64 => rustc_apfloat::ieee::Double::INFINITY.to_bits(),\n+                ty::FloatTy::F32 => rustc_apfloat::ieee::Single::INFINITY.to_bits(),\n+                ty::FloatTy::F64 => rustc_apfloat::ieee::Double::INFINITY.to_bits(),\n             }),\n             _ => None,\n         };\n@@ -661,8 +661,8 @@ impl<'tcx> ty::TyS<'tcx> {\n             }\n             ty::Char => Some(0),\n             ty::Float(fty) => Some(match fty {\n-                ast::FloatTy::F32 => (-::rustc_apfloat::ieee::Single::INFINITY).to_bits(),\n-                ast::FloatTy::F64 => (-::rustc_apfloat::ieee::Double::INFINITY).to_bits(),\n+                ty::FloatTy::F32 => (-::rustc_apfloat::ieee::Single::INFINITY).to_bits(),\n+                ty::FloatTy::F64 => (-::rustc_apfloat::ieee::Double::INFINITY).to_bits(),\n             }),\n             _ => None,\n         };"}, {"sha": "128d8cff95e6b321719e66197a9e1b2f4c7a1c0c", "filename": "compiler/rustc_mir/src/interpret/cast.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fcast.rs?ref=0e190206e2ff0c13d64701d9b4145bf89a2d0cab", "patch": "@@ -2,13 +2,11 @@ use std::convert::TryFrom;\n \n use rustc_apfloat::ieee::{Double, Single};\n use rustc_apfloat::{Float, FloatConvert};\n-use rustc_ast::FloatTy;\n-use rustc_attr as attr;\n use rustc_middle::mir::interpret::{InterpResult, PointerArithmetic, Scalar};\n use rustc_middle::mir::CastKind;\n use rustc_middle::ty::adjustment::PointerCast;\n use rustc_middle::ty::layout::{IntegerExt, TyAndLayout};\n-use rustc_middle::ty::{self, Ty, TypeAndMut};\n+use rustc_middle::ty::{self, FloatTy, Ty, TypeAndMut};\n use rustc_span::symbol::sym;\n use rustc_target::abi::{Integer, LayoutOf, Variants};\n \n@@ -203,8 +201,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         match *cast_ty.kind() {\n             Int(_) | Uint(_) | RawPtr(_) => {\n                 let size = match *cast_ty.kind() {\n-                    Int(t) => Integer::from_attr(self, attr::IntType::SignedInt(t)).size(),\n-                    Uint(t) => Integer::from_attr(self, attr::IntType::UnsignedInt(t)).size(),\n+                    Int(t) => Integer::from_int_ty(self, t).size(),\n+                    Uint(t) => Integer::from_uint_ty(self, t).size(),\n                     RawPtr(_) => self.pointer_size(),\n                     _ => bug!(),\n                 };\n@@ -235,7 +233,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         match *dest_ty.kind() {\n             // float -> uint\n             Uint(t) => {\n-                let size = Integer::from_attr(self, attr::IntType::UnsignedInt(t)).size();\n+                let size = Integer::from_uint_ty(self, t).size();\n                 // `to_u128` is a saturating cast, which is what we need\n                 // (https://doc.rust-lang.org/nightly/nightly-rustc/rustc_apfloat/trait.Float.html#method.to_i128_r).\n                 let v = f.to_u128(size.bits_usize()).value;\n@@ -244,7 +242,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             }\n             // float -> int\n             Int(t) => {\n-                let size = Integer::from_attr(self, attr::IntType::SignedInt(t)).size();\n+                let size = Integer::from_int_ty(self, t).size();\n                 // `to_i128` is a saturating cast, which is what we need\n                 // (https://doc.rust-lang.org/nightly/nightly-rustc/rustc_apfloat/trait.Float.html#method.to_i128_r).\n                 let v = f.to_i128(size.bits_usize()).value;"}, {"sha": "f5081655015b479027e4ddc63d856f7ee21b0fcb", "filename": "compiler/rustc_mir/src/interpret/operator.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperator.rs?ref=0e190206e2ff0c13d64701d9b4145bf89a2d0cab", "patch": "@@ -1,10 +1,9 @@\n use std::convert::TryFrom;\n \n use rustc_apfloat::Float;\n-use rustc_ast::FloatTy;\n use rustc_middle::mir;\n use rustc_middle::mir::interpret::{InterpResult, Scalar};\n-use rustc_middle::ty::{self, layout::TyAndLayout, Ty};\n+use rustc_middle::ty::{self, layout::TyAndLayout, FloatTy, Ty};\n use rustc_target::abi::LayoutOf;\n \n use super::{ImmTy, Immediate, InterpCx, Machine, PlaceTy};"}, {"sha": "ddfaeafc07cf18e7bce59d08d3328cce934a2a3c", "filename": "compiler/rustc_mir_build/src/build/matches/simplify.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fsimplify.rs?ref=0e190206e2ff0c13d64701d9b4145bf89a2d0cab", "patch": "@@ -15,7 +15,6 @@\n use crate::build::matches::{Ascription, Binding, Candidate, MatchPair};\n use crate::build::Builder;\n use crate::thir::{self, *};\n-use rustc_attr::{SignedInt, UnsignedInt};\n use rustc_hir::RangeEnd;\n use rustc_middle::mir::Place;\n use rustc_middle::ty;\n@@ -203,13 +202,13 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         (Some(('\\u{0000}' as u128, '\\u{10FFFF}' as u128, Size::from_bits(32))), 0)\n                     }\n                     ty::Int(ity) => {\n-                        let size = Integer::from_attr(&tcx, SignedInt(ity)).size();\n+                        let size = Integer::from_int_ty(&tcx, ity).size();\n                         let max = size.truncate(u128::MAX);\n                         let bias = 1u128 << (size.bits() - 1);\n                         (Some((0, max, size)), bias)\n                     }\n                     ty::Uint(uty) => {\n-                        let size = Integer::from_attr(&tcx, UnsignedInt(uty)).size();\n+                        let size = Integer::from_uint_ty(&tcx, uty).size();\n                         let max = size.truncate(u128::MAX);\n                         (Some((0, max, size)), 0)\n                     }"}, {"sha": "969f7d1e3a458f92d1329d5b7ac7fc58bc95ffd7", "filename": "compiler/rustc_mir_build/src/thir/constant.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fconstant.rs?ref=0e190206e2ff0c13d64701d9b4145bf89a2d0cab", "patch": "@@ -39,7 +39,7 @@ crate fn lit_to_const<'tcx>(\n             let id = tcx.allocate_bytes(data);\n             ConstValue::Scalar(Scalar::Ptr(id.into()))\n         }\n-        (ast::LitKind::Byte(n), ty::Uint(ast::UintTy::U8)) => {\n+        (ast::LitKind::Byte(n), ty::Uint(ty::UintTy::U8)) => {\n             ConstValue::Scalar(Scalar::from_uint(*n, Size::from_bytes(1)))\n         }\n         (ast::LitKind::Int(n, _), ty::Uint(_)) | (ast::LitKind::Int(n, _), ty::Int(_)) => {\n@@ -56,11 +56,11 @@ crate fn lit_to_const<'tcx>(\n     Ok(ty::Const::from_value(tcx, lit, ty))\n }\n \n-fn parse_float<'tcx>(num: Symbol, fty: ast::FloatTy, neg: bool) -> Result<ConstValue<'tcx>, ()> {\n+fn parse_float<'tcx>(num: Symbol, fty: ty::FloatTy, neg: bool) -> Result<ConstValue<'tcx>, ()> {\n     let num = num.as_str();\n     use rustc_apfloat::ieee::{Double, Single};\n     let scalar = match fty {\n-        ast::FloatTy::F32 => {\n+        ty::FloatTy::F32 => {\n             num.parse::<f32>().map_err(|_| ())?;\n             let mut f = num.parse::<Single>().unwrap_or_else(|e| {\n                 panic!(\"apfloat::ieee::Single failed to parse `{}`: {:?}\", num, e)\n@@ -70,7 +70,7 @@ fn parse_float<'tcx>(num: Symbol, fty: ast::FloatTy, neg: bool) -> Result<ConstV\n             }\n             Scalar::from_f32(f)\n         }\n-        ast::FloatTy::F64 => {\n+        ty::FloatTy::F64 => {\n             num.parse::<f64>().map_err(|_| ())?;\n             let mut f = num.parse::<Double>().unwrap_or_else(|e| {\n                 panic!(\"apfloat::ieee::Double failed to parse `{}`: {:?}\", num, e)"}, {"sha": "e67166c99c8daa08a49104a5b87f6f226833fcbd", "filename": "compiler/rustc_mir_build/src/thir/pattern/deconstruct_pat.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs?ref=0e190206e2ff0c13d64701d9b4145bf89a2d0cab", "patch": "@@ -52,7 +52,6 @@ use super::{FieldPat, Pat, PatKind, PatRange};\n use rustc_data_structures::captures::Captures;\n use rustc_index::vec::Idx;\n \n-use rustc_attr::{SignedInt, UnsignedInt};\n use rustc_hir::def_id::DefId;\n use rustc_hir::{HirId, RangeEnd};\n use rustc_middle::mir::interpret::ConstValue;\n@@ -103,10 +102,10 @@ impl IntRange {\n             ty::Bool => Some((Size::from_bytes(1), 0)),\n             ty::Char => Some((Size::from_bytes(4), 0)),\n             ty::Int(ity) => {\n-                let size = Integer::from_attr(&tcx, SignedInt(ity)).size();\n+                let size = Integer::from_int_ty(&tcx, ity).size();\n                 Some((size, 1u128 << (size.bits() as u128 - 1)))\n             }\n-            ty::Uint(uty) => Some((Integer::from_attr(&tcx, UnsignedInt(uty)).size(), 0)),\n+            ty::Uint(uty) => Some((Integer::from_uint_ty(&tcx, uty).size(), 0)),\n             _ => None,\n         }\n     }\n@@ -167,7 +166,7 @@ impl IntRange {\n     fn signed_bias(tcx: TyCtxt<'_>, ty: Ty<'_>) -> u128 {\n         match *ty.kind() {\n             ty::Int(ity) => {\n-                let bits = Integer::from_attr(&tcx, SignedInt(ity)).size().bits() as u128;\n+                let bits = Integer::from_int_ty(&tcx, ity).size().bits() as u128;\n                 1u128 << (bits - 1)\n             }\n             _ => 0,\n@@ -959,13 +958,13 @@ impl<'tcx> SplitWildcard<'tcx> {\n                 smallvec![NonExhaustive]\n             }\n             &ty::Int(ity) => {\n-                let bits = Integer::from_attr(&cx.tcx, SignedInt(ity)).size().bits() as u128;\n+                let bits = Integer::from_int_ty(&cx.tcx, ity).size().bits() as u128;\n                 let min = 1u128 << (bits - 1);\n                 let max = min - 1;\n                 smallvec![make_range(min, max)]\n             }\n             &ty::Uint(uty) => {\n-                let size = Integer::from_attr(&cx.tcx, UnsignedInt(uty)).size();\n+                let size = Integer::from_uint_ty(&cx.tcx, uty).size();\n                 let max = size.truncate(u128::MAX);\n                 smallvec![make_range(0, max)]\n             }"}, {"sha": "7186e26be800ea12285d13db07698dd9dd1762f1", "filename": "compiler/rustc_mir_build/src/thir/pattern/mod.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs?ref=0e190206e2ff0c13d64701d9b4145bf89a2d0cab", "patch": "@@ -9,7 +9,6 @@ pub(crate) use self::check_match::check_match;\n \n use crate::thir::util::UserAnnotatedTyHelpers;\n \n-use rustc_ast as ast;\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, CtorOf, DefKind, Res};\n@@ -1069,20 +1068,19 @@ crate fn compare_const_vals<'tcx>(\n     if let (Some(a), Some(b)) = (a_bits, b_bits) {\n         use rustc_apfloat::Float;\n         return match *ty.kind() {\n-            ty::Float(ast::FloatTy::F32) => {\n+            ty::Float(ty::FloatTy::F32) => {\n                 let l = rustc_apfloat::ieee::Single::from_bits(a);\n                 let r = rustc_apfloat::ieee::Single::from_bits(b);\n                 l.partial_cmp(&r)\n             }\n-            ty::Float(ast::FloatTy::F64) => {\n+            ty::Float(ty::FloatTy::F64) => {\n                 let l = rustc_apfloat::ieee::Double::from_bits(a);\n                 let r = rustc_apfloat::ieee::Double::from_bits(b);\n                 l.partial_cmp(&r)\n             }\n             ty::Int(ity) => {\n-                use rustc_attr::SignedInt;\n                 use rustc_middle::ty::layout::IntegerExt;\n-                let size = rustc_target::abi::Integer::from_attr(&tcx, SignedInt(ity)).size();\n+                let size = rustc_target::abi::Integer::from_int_ty(&tcx, ity).size();\n                 let a = size.sign_extend(a);\n                 let b = size.sign_extend(b);\n                 Some((a as i128).cmp(&(b as i128)))"}, {"sha": "0f4bb635eeefd87c2c671853210537b3a12713f5", "filename": "compiler/rustc_passes/src/intrinsicck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/compiler%2Frustc_passes%2Fsrc%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/compiler%2Frustc_passes%2Fsrc%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fintrinsicck.rs?ref=0e190206e2ff0c13d64701d9b4145bf89a2d0cab", "patch": "@@ -1,4 +1,4 @@\n-use rustc_ast::{FloatTy, InlineAsmTemplatePiece, IntTy, UintTy};\n+use rustc_ast::InlineAsmTemplatePiece;\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n@@ -7,7 +7,7 @@ use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_index::vec::Idx;\n use rustc_middle::ty::layout::{LayoutError, SizeSkeleton};\n use rustc_middle::ty::query::Providers;\n-use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_middle::ty::{self, FloatTy, IntTy, Ty, TyCtxt, UintTy};\n use rustc_session::lint;\n use rustc_span::{sym, Span, Symbol, DUMMY_SP};\n use rustc_target::abi::{Pointer, VariantIdx};"}, {"sha": "2e7c9701c0c6791bb02a469800abe23713ce5058", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=0e190206e2ff0c13d64701d9b4145bf89a2d0cab", "patch": "@@ -622,6 +622,7 @@ symbols! {\n         intel,\n         into_iter,\n         into_result,\n+        into_trait,\n         intra_doc_pointers,\n         intrinsics,\n         irrefutable_let_patterns,\n@@ -1159,6 +1160,8 @@ symbols! {\n         truncf32,\n         truncf64,\n         try_blocks,\n+        try_from_trait,\n+        try_into_trait,\n         try_trait,\n         tt,\n         tuple,"}, {"sha": "c84e2cb45a6c4ea725ab88a99d89970f76f05d78", "filename": "compiler/rustc_symbol_mangling/src/v0.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs?ref=0e190206e2ff0c13d64701d9b4145bf89a2d0cab", "patch": "@@ -1,12 +1,11 @@\n-use rustc_ast::{FloatTy, IntTy, UintTy};\n use rustc_data_structures::base_n;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir as hir;\n use rustc_hir::def_id::{CrateNum, DefId};\n use rustc_hir::definitions::{DefPathData, DisambiguatedDefPathData};\n use rustc_middle::ty::print::{Print, Printer};\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind, Subst};\n-use rustc_middle::ty::{self, Instance, Ty, TyCtxt, TypeFoldable};\n+use rustc_middle::ty::{self, FloatTy, Instance, IntTy, Ty, TyCtxt, TypeFoldable, UintTy};\n use rustc_target::spec::abi::Abi;\n \n use std::fmt::Write;"}, {"sha": "b587ed6487e3c6929e4ca2349b53c2632d39737a", "filename": "compiler/rustc_trait_selection/src/traits/const_evaluatable.rs", "status": "modified", "additions": 22, "deletions": 4, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs?ref=0e190206e2ff0c13d64701d9b4145bf89a2d0cab", "patch": "@@ -609,9 +609,29 @@ where\n /// Tries to unify two abstract constants using structural equality.\n pub(super) fn try_unify<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    a: AbstractConst<'tcx>,\n-    b: AbstractConst<'tcx>,\n+    mut a: AbstractConst<'tcx>,\n+    mut b: AbstractConst<'tcx>,\n ) -> bool {\n+    // We substitute generics repeatedly to allow AbstractConsts to unify where a\n+    // ConstKind::Unevalated could be turned into an AbstractConst that would unify e.g.\n+    // Param(N) should unify with Param(T), substs: [Unevaluated(\"T2\", [Unevaluated(\"T3\", [Param(N)])])]\n+    while let Node::Leaf(a_ct) = a.root() {\n+        let a_ct = a_ct.subst(tcx, a.substs);\n+        match AbstractConst::from_const(tcx, a_ct) {\n+            Ok(Some(a_act)) => a = a_act,\n+            Ok(None) => break,\n+            Err(_) => return true,\n+        }\n+    }\n+    while let Node::Leaf(b_ct) = b.root() {\n+        let b_ct = b_ct.subst(tcx, b.substs);\n+        match AbstractConst::from_const(tcx, b_ct) {\n+            Ok(Some(b_act)) => b = b_act,\n+            Ok(None) => break,\n+            Err(_) => return true,\n+        }\n+    }\n+\n     match (a.root(), b.root()) {\n         (Node::Leaf(a_ct), Node::Leaf(b_ct)) => {\n             let a_ct = a_ct.subst(tcx, a.substs);\n@@ -632,8 +652,6 @@ pub(super) fn try_unify<'tcx>(\n                 // we do not want to use `assert_eq!(a(), b())` to infer that `N` and `M` have to be `1`. This\n                 // means that we only allow inference variables if they are equal.\n                 (ty::ConstKind::Infer(a_val), ty::ConstKind::Infer(b_val)) => a_val == b_val,\n-                // We may want to instead recurse into unevaluated constants here. That may require some\n-                // care to prevent infinite recursion, so let's just ignore this for now.\n                 (\n                     ty::ConstKind::Unevaluated(a_def, a_substs, None),\n                     ty::ConstKind::Unevaluated(b_def, b_substs, None),"}, {"sha": "bb48ed936188b1f70442f208f08e93e7dbcf17f4", "filename": "compiler/rustc_traits/src/chalk/db.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs?ref=0e190206e2ff0c13d64701d9b4145bf89a2d0cab", "patch": "@@ -346,26 +346,26 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n                 (ty::Char, Scalar(Char)) => true,\n                 (ty::Int(ty1), Scalar(Int(ty2))) => matches!(\n                     (ty1, ty2),\n-                    (ast::IntTy::Isize, chalk_ir::IntTy::Isize)\n-                        | (ast::IntTy::I8, chalk_ir::IntTy::I8)\n-                        | (ast::IntTy::I16, chalk_ir::IntTy::I16)\n-                        | (ast::IntTy::I32, chalk_ir::IntTy::I32)\n-                        | (ast::IntTy::I64, chalk_ir::IntTy::I64)\n-                        | (ast::IntTy::I128, chalk_ir::IntTy::I128)\n+                    (ty::IntTy::Isize, chalk_ir::IntTy::Isize)\n+                        | (ty::IntTy::I8, chalk_ir::IntTy::I8)\n+                        | (ty::IntTy::I16, chalk_ir::IntTy::I16)\n+                        | (ty::IntTy::I32, chalk_ir::IntTy::I32)\n+                        | (ty::IntTy::I64, chalk_ir::IntTy::I64)\n+                        | (ty::IntTy::I128, chalk_ir::IntTy::I128)\n                 ),\n                 (ty::Uint(ty1), Scalar(Uint(ty2))) => matches!(\n                     (ty1, ty2),\n-                    (ast::UintTy::Usize, chalk_ir::UintTy::Usize)\n-                        | (ast::UintTy::U8, chalk_ir::UintTy::U8)\n-                        | (ast::UintTy::U16, chalk_ir::UintTy::U16)\n-                        | (ast::UintTy::U32, chalk_ir::UintTy::U32)\n-                        | (ast::UintTy::U64, chalk_ir::UintTy::U64)\n-                        | (ast::UintTy::U128, chalk_ir::UintTy::U128)\n+                    (ty::UintTy::Usize, chalk_ir::UintTy::Usize)\n+                        | (ty::UintTy::U8, chalk_ir::UintTy::U8)\n+                        | (ty::UintTy::U16, chalk_ir::UintTy::U16)\n+                        | (ty::UintTy::U32, chalk_ir::UintTy::U32)\n+                        | (ty::UintTy::U64, chalk_ir::UintTy::U64)\n+                        | (ty::UintTy::U128, chalk_ir::UintTy::U128)\n                 ),\n                 (ty::Float(ty1), Scalar(Float(ty2))) => matches!(\n                     (ty1, ty2),\n-                    (ast::FloatTy::F32, chalk_ir::FloatTy::F32)\n-                        | (ast::FloatTy::F64, chalk_ir::FloatTy::F64)\n+                    (ty::FloatTy::F32, chalk_ir::FloatTy::F32)\n+                        | (ty::FloatTy::F64, chalk_ir::FloatTy::F64)\n                 ),\n                 (&ty::Tuple(substs), Tuple(len, _)) => substs.len() == *len,\n                 (&ty::Array(..), Array(..)) => true,"}, {"sha": "2a1a3f57e2313f702ba852b465aa1cb4da4e054b", "filename": "compiler/rustc_traits/src/chalk/lowering.rs", "status": "modified", "additions": 28, "deletions": 30, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs?ref=0e190206e2ff0c13d64701d9b4145bf89a2d0cab", "patch": "@@ -233,8 +233,6 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::AliasEq<RustInterner<'tcx>>>\n \n impl<'tcx> LowerInto<'tcx, chalk_ir::Ty<RustInterner<'tcx>>> for Ty<'tcx> {\n     fn lower_into(self, interner: &RustInterner<'tcx>) -> chalk_ir::Ty<RustInterner<'tcx>> {\n-        use rustc_ast as ast;\n-\n         let int = |i| chalk_ir::TyKind::Scalar(chalk_ir::Scalar::Int(i));\n         let uint = |i| chalk_ir::TyKind::Scalar(chalk_ir::Scalar::Uint(i));\n         let float = |f| chalk_ir::TyKind::Scalar(chalk_ir::Scalar::Float(f));\n@@ -243,24 +241,24 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::Ty<RustInterner<'tcx>>> for Ty<'tcx> {\n             ty::Bool => chalk_ir::TyKind::Scalar(chalk_ir::Scalar::Bool),\n             ty::Char => chalk_ir::TyKind::Scalar(chalk_ir::Scalar::Char),\n             ty::Int(ty) => match ty {\n-                ast::IntTy::Isize => int(chalk_ir::IntTy::Isize),\n-                ast::IntTy::I8 => int(chalk_ir::IntTy::I8),\n-                ast::IntTy::I16 => int(chalk_ir::IntTy::I16),\n-                ast::IntTy::I32 => int(chalk_ir::IntTy::I32),\n-                ast::IntTy::I64 => int(chalk_ir::IntTy::I64),\n-                ast::IntTy::I128 => int(chalk_ir::IntTy::I128),\n+                ty::IntTy::Isize => int(chalk_ir::IntTy::Isize),\n+                ty::IntTy::I8 => int(chalk_ir::IntTy::I8),\n+                ty::IntTy::I16 => int(chalk_ir::IntTy::I16),\n+                ty::IntTy::I32 => int(chalk_ir::IntTy::I32),\n+                ty::IntTy::I64 => int(chalk_ir::IntTy::I64),\n+                ty::IntTy::I128 => int(chalk_ir::IntTy::I128),\n             },\n             ty::Uint(ty) => match ty {\n-                ast::UintTy::Usize => uint(chalk_ir::UintTy::Usize),\n-                ast::UintTy::U8 => uint(chalk_ir::UintTy::U8),\n-                ast::UintTy::U16 => uint(chalk_ir::UintTy::U16),\n-                ast::UintTy::U32 => uint(chalk_ir::UintTy::U32),\n-                ast::UintTy::U64 => uint(chalk_ir::UintTy::U64),\n-                ast::UintTy::U128 => uint(chalk_ir::UintTy::U128),\n+                ty::UintTy::Usize => uint(chalk_ir::UintTy::Usize),\n+                ty::UintTy::U8 => uint(chalk_ir::UintTy::U8),\n+                ty::UintTy::U16 => uint(chalk_ir::UintTy::U16),\n+                ty::UintTy::U32 => uint(chalk_ir::UintTy::U32),\n+                ty::UintTy::U64 => uint(chalk_ir::UintTy::U64),\n+                ty::UintTy::U128 => uint(chalk_ir::UintTy::U128),\n             },\n             ty::Float(ty) => match ty {\n-                ast::FloatTy::F32 => float(chalk_ir::FloatTy::F32),\n-                ast::FloatTy::F64 => float(chalk_ir::FloatTy::F64),\n+                ty::FloatTy::F32 => float(chalk_ir::FloatTy::F32),\n+                ty::FloatTy::F64 => float(chalk_ir::FloatTy::F64),\n             },\n             ty::Adt(def, substs) => {\n                 chalk_ir::TyKind::Adt(chalk_ir::AdtId(def), substs.lower_into(interner))\n@@ -347,24 +345,24 @@ impl<'tcx> LowerInto<'tcx, Ty<'tcx>> for &chalk_ir::Ty<RustInterner<'tcx>> {\n                 chalk_ir::Scalar::Bool => ty::Bool,\n                 chalk_ir::Scalar::Char => ty::Char,\n                 chalk_ir::Scalar::Int(int_ty) => match int_ty {\n-                    chalk_ir::IntTy::Isize => ty::Int(ast::IntTy::Isize),\n-                    chalk_ir::IntTy::I8 => ty::Int(ast::IntTy::I8),\n-                    chalk_ir::IntTy::I16 => ty::Int(ast::IntTy::I16),\n-                    chalk_ir::IntTy::I32 => ty::Int(ast::IntTy::I32),\n-                    chalk_ir::IntTy::I64 => ty::Int(ast::IntTy::I64),\n-                    chalk_ir::IntTy::I128 => ty::Int(ast::IntTy::I128),\n+                    chalk_ir::IntTy::Isize => ty::Int(ty::IntTy::Isize),\n+                    chalk_ir::IntTy::I8 => ty::Int(ty::IntTy::I8),\n+                    chalk_ir::IntTy::I16 => ty::Int(ty::IntTy::I16),\n+                    chalk_ir::IntTy::I32 => ty::Int(ty::IntTy::I32),\n+                    chalk_ir::IntTy::I64 => ty::Int(ty::IntTy::I64),\n+                    chalk_ir::IntTy::I128 => ty::Int(ty::IntTy::I128),\n                 },\n                 chalk_ir::Scalar::Uint(int_ty) => match int_ty {\n-                    chalk_ir::UintTy::Usize => ty::Uint(ast::UintTy::Usize),\n-                    chalk_ir::UintTy::U8 => ty::Uint(ast::UintTy::U8),\n-                    chalk_ir::UintTy::U16 => ty::Uint(ast::UintTy::U16),\n-                    chalk_ir::UintTy::U32 => ty::Uint(ast::UintTy::U32),\n-                    chalk_ir::UintTy::U64 => ty::Uint(ast::UintTy::U64),\n-                    chalk_ir::UintTy::U128 => ty::Uint(ast::UintTy::U128),\n+                    chalk_ir::UintTy::Usize => ty::Uint(ty::UintTy::Usize),\n+                    chalk_ir::UintTy::U8 => ty::Uint(ty::UintTy::U8),\n+                    chalk_ir::UintTy::U16 => ty::Uint(ty::UintTy::U16),\n+                    chalk_ir::UintTy::U32 => ty::Uint(ty::UintTy::U32),\n+                    chalk_ir::UintTy::U64 => ty::Uint(ty::UintTy::U64),\n+                    chalk_ir::UintTy::U128 => ty::Uint(ty::UintTy::U128),\n                 },\n                 chalk_ir::Scalar::Float(float_ty) => match float_ty {\n-                    chalk_ir::FloatTy::F32 => ty::Float(ast::FloatTy::F32),\n-                    chalk_ir::FloatTy::F64 => ty::Float(ast::FloatTy::F64),\n+                    chalk_ir::FloatTy::F32 => ty::Float(ty::FloatTy::F32),\n+                    chalk_ir::FloatTy::F64 => ty::Float(ty::FloatTy::F64),\n                 },\n             },\n             TyKind::Array(ty, c) => {"}, {"sha": "3f64bd899979f4db7fc2bbf3ef0cd8880a6b6ab7", "filename": "compiler/rustc_type_ir/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/compiler%2Frustc_type_ir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/compiler%2Frustc_type_ir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2FCargo.toml?ref=0e190206e2ff0c13d64701d9b4145bf89a2d0cab", "patch": "@@ -12,3 +12,4 @@ bitflags = \"1.2.1\"\n rustc_index = { path = \"../rustc_index\" }\n rustc_serialize = { path = \"../rustc_serialize\" }\n rustc_data_structures = { path = \"../rustc_data_structures\" }\n+rustc_macros = { path = \"../rustc_macros\" }"}, {"sha": "7e70af21c03cdbfe1647a512814568dd14c9c941", "filename": "compiler/rustc_type_ir/src/lib.rs", "status": "modified", "additions": 406, "deletions": 0, "changes": 406, "blob_url": "https://github.com/rust-lang/rust/blob/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs?ref=0e190206e2ff0c13d64701d9b4145bf89a2d0cab", "patch": "@@ -4,8 +4,13 @@\n \n #[macro_use]\n extern crate bitflags;\n+#[macro_use]\n+extern crate rustc_macros;\n \n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n+use rustc_data_structures::unify::{EqUnifyValue, UnifyKey};\n+use std::fmt;\n+use std::mem::discriminant;\n \n bitflags! {\n     /// Flags that we track on types. These flags are propagated upwards\n@@ -197,8 +202,409 @@ impl DebruijnIndex {\n     }\n }\n \n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n+#[derive(Encodable, Decodable)]\n+pub enum IntTy {\n+    Isize,\n+    I8,\n+    I16,\n+    I32,\n+    I64,\n+    I128,\n+}\n+\n+impl IntTy {\n+    pub fn name_str(&self) -> &'static str {\n+        match *self {\n+            IntTy::Isize => \"isize\",\n+            IntTy::I8 => \"i8\",\n+            IntTy::I16 => \"i16\",\n+            IntTy::I32 => \"i32\",\n+            IntTy::I64 => \"i64\",\n+            IntTy::I128 => \"i128\",\n+        }\n+    }\n+\n+    pub fn bit_width(&self) -> Option<u64> {\n+        Some(match *self {\n+            IntTy::Isize => return None,\n+            IntTy::I8 => 8,\n+            IntTy::I16 => 16,\n+            IntTy::I32 => 32,\n+            IntTy::I64 => 64,\n+            IntTy::I128 => 128,\n+        })\n+    }\n+\n+    pub fn normalize(&self, target_width: u32) -> Self {\n+        match self {\n+            IntTy::Isize => match target_width {\n+                16 => IntTy::I16,\n+                32 => IntTy::I32,\n+                64 => IntTy::I64,\n+                _ => unreachable!(),\n+            },\n+            _ => *self,\n+        }\n+    }\n+}\n+\n+#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Copy, Debug)]\n+#[derive(Encodable, Decodable)]\n+pub enum UintTy {\n+    Usize,\n+    U8,\n+    U16,\n+    U32,\n+    U64,\n+    U128,\n+}\n+\n+impl UintTy {\n+    pub fn name_str(&self) -> &'static str {\n+        match *self {\n+            UintTy::Usize => \"usize\",\n+            UintTy::U8 => \"u8\",\n+            UintTy::U16 => \"u16\",\n+            UintTy::U32 => \"u32\",\n+            UintTy::U64 => \"u64\",\n+            UintTy::U128 => \"u128\",\n+        }\n+    }\n+\n+    pub fn bit_width(&self) -> Option<u64> {\n+        Some(match *self {\n+            UintTy::Usize => return None,\n+            UintTy::U8 => 8,\n+            UintTy::U16 => 16,\n+            UintTy::U32 => 32,\n+            UintTy::U64 => 64,\n+            UintTy::U128 => 128,\n+        })\n+    }\n+\n+    pub fn normalize(&self, target_width: u32) -> Self {\n+        match self {\n+            UintTy::Usize => match target_width {\n+                16 => UintTy::U16,\n+                32 => UintTy::U32,\n+                64 => UintTy::U64,\n+                _ => unreachable!(),\n+            },\n+            _ => *self,\n+        }\n+    }\n+}\n+\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n+#[derive(Encodable, Decodable)]\n+pub enum FloatTy {\n+    F32,\n+    F64,\n+}\n+\n+impl FloatTy {\n+    pub fn name_str(self) -> &'static str {\n+        match self {\n+            FloatTy::F32 => \"f32\",\n+            FloatTy::F64 => \"f64\",\n+        }\n+    }\n+\n+    pub fn bit_width(self) -> u64 {\n+        match self {\n+            FloatTy::F32 => 32,\n+            FloatTy::F64 => 64,\n+        }\n+    }\n+}\n+\n+#[derive(Clone, Copy, PartialEq, Eq)]\n+pub enum IntVarValue {\n+    IntType(IntTy),\n+    UintType(UintTy),\n+}\n+\n+#[derive(Clone, Copy, PartialEq, Eq)]\n+pub struct FloatVarValue(pub FloatTy);\n+\n+/// A **ty**pe **v**ariable **ID**.\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Encodable, Decodable)]\n+pub struct TyVid {\n+    pub index: u32,\n+}\n+\n+/// An **int**egral (`u32`, `i32`, `usize`, etc.) type **v**ariable **ID**.\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Encodable, Decodable)]\n+pub struct IntVid {\n+    pub index: u32,\n+}\n+\n+/// An **float**ing-point (`f32` or `f64`) type **v**ariable **ID**.\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Encodable, Decodable)]\n+pub struct FloatVid {\n+    pub index: u32,\n+}\n+\n+/// A placeholder for a type that hasn't been inferred yet.\n+///\n+/// E.g., if we have an empty array (`[]`), then we create a fresh\n+/// type variable for the element type since we won't know until it's\n+/// used what the element type is supposed to be.\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Encodable, Decodable)]\n+pub enum InferTy {\n+    /// A type variable.\n+    TyVar(TyVid),\n+    /// An integral type variable (`{integer}`).\n+    ///\n+    /// These are created when the compiler sees an integer literal like\n+    /// `1` that could be several different types (`u8`, `i32`, `u32`, etc.).\n+    /// We don't know until it's used what type it's supposed to be, so\n+    /// we create a fresh type variable.\n+    IntVar(IntVid),\n+    /// A floating-point type variable (`{float}`).\n+    ///\n+    /// These are created when the compiler sees an float literal like\n+    /// `1.0` that could be either an `f32` or an `f64`.\n+    /// We don't know until it's used what type it's supposed to be, so\n+    /// we create a fresh type variable.\n+    FloatVar(FloatVid),\n+\n+    /// A [`FreshTy`][Self::FreshTy] is one that is generated as a replacement\n+    /// for an unbound type variable. This is convenient for caching etc. See\n+    /// `rustc_infer::infer::freshen` for more details.\n+    ///\n+    /// Compare with [`TyVar`][Self::TyVar].\n+    FreshTy(u32),\n+    /// Like [`FreshTy`][Self::FreshTy], but as a replacement for [`IntVar`][Self::IntVar].\n+    FreshIntTy(u32),\n+    /// Like [`FreshTy`][Self::FreshTy], but as a replacement for [`FloatVar`][Self::FloatVar].\n+    FreshFloatTy(u32),\n+}\n+\n+/// Raw `TyVid` are used as the unification key for `sub_relations`;\n+/// they carry no values.\n+impl UnifyKey for TyVid {\n+    type Value = ();\n+    fn index(&self) -> u32 {\n+        self.index\n+    }\n+    fn from_index(i: u32) -> TyVid {\n+        TyVid { index: i }\n+    }\n+    fn tag() -> &'static str {\n+        \"TyVid\"\n+    }\n+}\n+\n+impl EqUnifyValue for IntVarValue {}\n+\n+impl UnifyKey for IntVid {\n+    type Value = Option<IntVarValue>;\n+    fn index(&self) -> u32 {\n+        self.index\n+    }\n+    fn from_index(i: u32) -> IntVid {\n+        IntVid { index: i }\n+    }\n+    fn tag() -> &'static str {\n+        \"IntVid\"\n+    }\n+}\n+\n+impl EqUnifyValue for FloatVarValue {}\n+\n+impl UnifyKey for FloatVid {\n+    type Value = Option<FloatVarValue>;\n+    fn index(&self) -> u32 {\n+        self.index\n+    }\n+    fn from_index(i: u32) -> FloatVid {\n+        FloatVid { index: i }\n+    }\n+    fn tag() -> &'static str {\n+        \"FloatVid\"\n+    }\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Decodable, Encodable)]\n+pub enum Variance {\n+    Covariant,     // T<A> <: T<B> iff A <: B -- e.g., function return type\n+    Invariant,     // T<A> <: T<B> iff B == A -- e.g., type of mutable cell\n+    Contravariant, // T<A> <: T<B> iff B <: A -- e.g., function param type\n+    Bivariant,     // T<A> <: T<B>            -- e.g., unused type parameter\n+}\n+\n+impl Variance {\n+    /// `a.xform(b)` combines the variance of a context with the\n+    /// variance of a type with the following meaning. If we are in a\n+    /// context with variance `a`, and we encounter a type argument in\n+    /// a position with variance `b`, then `a.xform(b)` is the new\n+    /// variance with which the argument appears.\n+    ///\n+    /// Example 1:\n+    ///\n+    ///     *mut Vec<i32>\n+    ///\n+    /// Here, the \"ambient\" variance starts as covariant. `*mut T` is\n+    /// invariant with respect to `T`, so the variance in which the\n+    /// `Vec<i32>` appears is `Covariant.xform(Invariant)`, which\n+    /// yields `Invariant`. Now, the type `Vec<T>` is covariant with\n+    /// respect to its type argument `T`, and hence the variance of\n+    /// the `i32` here is `Invariant.xform(Covariant)`, which results\n+    /// (again) in `Invariant`.\n+    ///\n+    /// Example 2:\n+    ///\n+    ///     fn(*const Vec<i32>, *mut Vec<i32)\n+    ///\n+    /// The ambient variance is covariant. A `fn` type is\n+    /// contravariant with respect to its parameters, so the variance\n+    /// within which both pointer types appear is\n+    /// `Covariant.xform(Contravariant)`, or `Contravariant`. `*const\n+    /// T` is covariant with respect to `T`, so the variance within\n+    /// which the first `Vec<i32>` appears is\n+    /// `Contravariant.xform(Covariant)` or `Contravariant`. The same\n+    /// is true for its `i32` argument. In the `*mut T` case, the\n+    /// variance of `Vec<i32>` is `Contravariant.xform(Invariant)`,\n+    /// and hence the outermost type is `Invariant` with respect to\n+    /// `Vec<i32>` (and its `i32` argument).\n+    ///\n+    /// Source: Figure 1 of \"Taming the Wildcards:\n+    /// Combining Definition- and Use-Site Variance\" published in PLDI'11.\n+    pub fn xform(self, v: Variance) -> Variance {\n+        match (self, v) {\n+            // Figure 1, column 1.\n+            (Variance::Covariant, Variance::Covariant) => Variance::Covariant,\n+            (Variance::Covariant, Variance::Contravariant) => Variance::Contravariant,\n+            (Variance::Covariant, Variance::Invariant) => Variance::Invariant,\n+            (Variance::Covariant, Variance::Bivariant) => Variance::Bivariant,\n+\n+            // Figure 1, column 2.\n+            (Variance::Contravariant, Variance::Covariant) => Variance::Contravariant,\n+            (Variance::Contravariant, Variance::Contravariant) => Variance::Covariant,\n+            (Variance::Contravariant, Variance::Invariant) => Variance::Invariant,\n+            (Variance::Contravariant, Variance::Bivariant) => Variance::Bivariant,\n+\n+            // Figure 1, column 3.\n+            (Variance::Invariant, _) => Variance::Invariant,\n+\n+            // Figure 1, column 4.\n+            (Variance::Bivariant, _) => Variance::Bivariant,\n+        }\n+    }\n+}\n+\n impl<CTX> HashStable<CTX> for DebruijnIndex {\n     fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {\n         self.as_u32().hash_stable(ctx, hasher);\n     }\n }\n+\n+impl<CTX> HashStable<CTX> for IntTy {\n+    fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {\n+        discriminant(self).hash_stable(ctx, hasher);\n+    }\n+}\n+\n+impl<CTX> HashStable<CTX> for UintTy {\n+    fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {\n+        discriminant(self).hash_stable(ctx, hasher);\n+    }\n+}\n+\n+impl<CTX> HashStable<CTX> for FloatTy {\n+    fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {\n+        discriminant(self).hash_stable(ctx, hasher);\n+    }\n+}\n+\n+impl<CTX> HashStable<CTX> for InferTy {\n+    fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {\n+        use InferTy::*;\n+        match self {\n+            TyVar(v) => v.index.hash_stable(ctx, hasher),\n+            IntVar(v) => v.index.hash_stable(ctx, hasher),\n+            FloatVar(v) => v.index.hash_stable(ctx, hasher),\n+            FreshTy(v) | FreshIntTy(v) | FreshFloatTy(v) => v.hash_stable(ctx, hasher),\n+        }\n+    }\n+}\n+\n+impl<CTX> HashStable<CTX> for Variance {\n+    fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {\n+        discriminant(self).hash_stable(ctx, hasher);\n+    }\n+}\n+\n+impl fmt::Debug for IntVarValue {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match *self {\n+            IntVarValue::IntType(ref v) => v.fmt(f),\n+            IntVarValue::UintType(ref v) => v.fmt(f),\n+        }\n+    }\n+}\n+\n+impl fmt::Debug for FloatVarValue {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        self.0.fmt(f)\n+    }\n+}\n+\n+impl fmt::Debug for TyVid {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"_#{}t\", self.index)\n+    }\n+}\n+\n+impl fmt::Debug for IntVid {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"_#{}i\", self.index)\n+    }\n+}\n+\n+impl fmt::Debug for FloatVid {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"_#{}f\", self.index)\n+    }\n+}\n+\n+impl fmt::Debug for InferTy {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        use InferTy::*;\n+        match *self {\n+            TyVar(ref v) => v.fmt(f),\n+            IntVar(ref v) => v.fmt(f),\n+            FloatVar(ref v) => v.fmt(f),\n+            FreshTy(v) => write!(f, \"FreshTy({:?})\", v),\n+            FreshIntTy(v) => write!(f, \"FreshIntTy({:?})\", v),\n+            FreshFloatTy(v) => write!(f, \"FreshFloatTy({:?})\", v),\n+        }\n+    }\n+}\n+\n+impl fmt::Debug for Variance {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.write_str(match *self {\n+            Variance::Covariant => \"+\",\n+            Variance::Contravariant => \"-\",\n+            Variance::Invariant => \"o\",\n+            Variance::Bivariant => \"*\",\n+        })\n+    }\n+}\n+\n+impl fmt::Display for InferTy {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        use InferTy::*;\n+        match *self {\n+            TyVar(_) => write!(f, \"_\"),\n+            IntVar(_) => write!(f, \"{}\", \"{integer}\"),\n+            FloatVar(_) => write!(f, \"{}\", \"{float}\"),\n+            FreshTy(v) => write!(f, \"FreshTy({})\", v),\n+            FreshIntTy(v) => write!(f, \"FreshIntTy({})\", v),\n+            FreshFloatTy(v) => write!(f, \"FreshFloatTy({})\", v),\n+        }\n+    }\n+}"}, {"sha": "437813ea41bd592f13e6ff16c8a2d83b2c1afc21", "filename": "compiler/rustc_typeck/src/astconv/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs?ref=0e190206e2ff0c13d64701d9b4145bf89a2d0cab", "patch": "@@ -2059,9 +2059,9 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 match prim_ty {\n                     hir::PrimTy::Bool => tcx.types.bool,\n                     hir::PrimTy::Char => tcx.types.char,\n-                    hir::PrimTy::Int(it) => tcx.mk_mach_int(it),\n-                    hir::PrimTy::Uint(uit) => tcx.mk_mach_uint(uit),\n-                    hir::PrimTy::Float(ft) => tcx.mk_mach_float(ft),\n+                    hir::PrimTy::Int(it) => tcx.mk_mach_int(ty::int_ty(it)),\n+                    hir::PrimTy::Uint(uit) => tcx.mk_mach_uint(ty::uint_ty(uit)),\n+                    hir::PrimTy::Float(ft) => tcx.mk_mach_float(ty::float_ty(ft)),\n                     hir::PrimTy::Str => tcx.types.str_,\n                 }\n             }"}, {"sha": "7924ffe8a6fd5a133f7b9d1731acd724d25801a5", "filename": "compiler/rustc_typeck/src/check/cast.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcast.rs?ref=0e190206e2ff0c13d64701d9b4145bf89a2d0cab", "patch": "@@ -32,7 +32,6 @@ use super::FnCtxt;\n \n use crate::hir::def_id::DefId;\n use crate::type_error_struct;\n-use rustc_ast as ast;\n use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder, ErrorReported};\n use rustc_hir as hir;\n use rustc_hir::lang_items::LangItem;\n@@ -660,7 +659,7 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n             (_, Int(Bool)) => Err(CastError::CastToBool),\n \n             // * -> Char\n-            (Int(U(ast::UintTy::U8)), Int(Char)) => Ok(CastKind::U8CharCast), // u8-char-cast\n+            (Int(U(ty::UintTy::U8)), Int(Char)) => Ok(CastKind::U8CharCast), // u8-char-cast\n             (_, Int(Char)) => Err(CastError::CastToChar),\n \n             // prim -> float,ptr"}, {"sha": "3326be796cee37831c2c816514d138c4abf61df6", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/checks.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs?ref=0e190206e2ff0c13d64701d9b4145bf89a2d0cab", "patch": "@@ -372,13 +372,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // in C but we just error out instead and require explicit casts.\n                 let arg_ty = self.structurally_resolved_type(arg.span, arg_ty);\n                 match arg_ty.kind() {\n-                    ty::Float(ast::FloatTy::F32) => {\n+                    ty::Float(ty::FloatTy::F32) => {\n                         variadic_error(tcx.sess, arg.span, arg_ty, \"c_double\");\n                     }\n-                    ty::Int(ast::IntTy::I8 | ast::IntTy::I16) | ty::Bool => {\n+                    ty::Int(ty::IntTy::I8 | ty::IntTy::I16) | ty::Bool => {\n                         variadic_error(tcx.sess, arg.span, arg_ty, \"c_int\");\n                     }\n-                    ty::Uint(ast::UintTy::U8 | ast::UintTy::U16) => {\n+                    ty::Uint(ty::UintTy::U8 | ty::UintTy::U16) => {\n                         variadic_error(tcx.sess, arg.span, arg_ty, \"c_uint\");\n                     }\n                     ty::FnDef(..) => {\n@@ -407,8 +407,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n             ast::LitKind::Byte(_) => tcx.types.u8,\n             ast::LitKind::Char(_) => tcx.types.char,\n-            ast::LitKind::Int(_, ast::LitIntType::Signed(t)) => tcx.mk_mach_int(t),\n-            ast::LitKind::Int(_, ast::LitIntType::Unsigned(t)) => tcx.mk_mach_uint(t),\n+            ast::LitKind::Int(_, ast::LitIntType::Signed(t)) => tcx.mk_mach_int(ty::int_ty(t)),\n+            ast::LitKind::Int(_, ast::LitIntType::Unsigned(t)) => tcx.mk_mach_uint(ty::uint_ty(t)),\n             ast::LitKind::Int(_, ast::LitIntType::Unsuffixed) => {\n                 let opt_ty = expected.to_option(self).and_then(|ty| match ty.kind() {\n                     ty::Int(_) | ty::Uint(_) => Some(ty),\n@@ -419,7 +419,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 });\n                 opt_ty.unwrap_or_else(|| self.next_int_var())\n             }\n-            ast::LitKind::Float(_, ast::LitFloatType::Suffixed(t)) => tcx.mk_mach_float(t),\n+            ast::LitKind::Float(_, ast::LitFloatType::Suffixed(t)) => {\n+                tcx.mk_mach_float(ty::float_ty(t))\n+            }\n             ast::LitKind::Float(_, ast::LitFloatType::Unsuffixed) => {\n                 let opt_ty = expected.to_option(self).and_then(|ty| match ty.kind() {\n                     ty::Float(_) => Some(ty),"}, {"sha": "158c214759db27c507c325742742cb15e2a836e4", "filename": "compiler/rustc_typeck/src/check/method/probe.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs?ref=0e190206e2ff0c13d64701d9b4145bf89a2d0cab", "patch": "@@ -8,7 +8,6 @@ use crate::errors::MethodCallOnUnknownType;\n use crate::hir::def::DefKind;\n use crate::hir::def_id::DefId;\n \n-use rustc_ast as ast;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::sync::Lrc;\n use rustc_hir as hir;\n@@ -662,30 +661,30 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n             }\n             ty::Int(i) => {\n                 let lang_def_id = match i {\n-                    ast::IntTy::I8 => lang_items.i8_impl(),\n-                    ast::IntTy::I16 => lang_items.i16_impl(),\n-                    ast::IntTy::I32 => lang_items.i32_impl(),\n-                    ast::IntTy::I64 => lang_items.i64_impl(),\n-                    ast::IntTy::I128 => lang_items.i128_impl(),\n-                    ast::IntTy::Isize => lang_items.isize_impl(),\n+                    ty::IntTy::I8 => lang_items.i8_impl(),\n+                    ty::IntTy::I16 => lang_items.i16_impl(),\n+                    ty::IntTy::I32 => lang_items.i32_impl(),\n+                    ty::IntTy::I64 => lang_items.i64_impl(),\n+                    ty::IntTy::I128 => lang_items.i128_impl(),\n+                    ty::IntTy::Isize => lang_items.isize_impl(),\n                 };\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n             ty::Uint(i) => {\n                 let lang_def_id = match i {\n-                    ast::UintTy::U8 => lang_items.u8_impl(),\n-                    ast::UintTy::U16 => lang_items.u16_impl(),\n-                    ast::UintTy::U32 => lang_items.u32_impl(),\n-                    ast::UintTy::U64 => lang_items.u64_impl(),\n-                    ast::UintTy::U128 => lang_items.u128_impl(),\n-                    ast::UintTy::Usize => lang_items.usize_impl(),\n+                    ty::UintTy::U8 => lang_items.u8_impl(),\n+                    ty::UintTy::U16 => lang_items.u16_impl(),\n+                    ty::UintTy::U32 => lang_items.u32_impl(),\n+                    ty::UintTy::U64 => lang_items.u64_impl(),\n+                    ty::UintTy::U128 => lang_items.u128_impl(),\n+                    ty::UintTy::Usize => lang_items.usize_impl(),\n                 };\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n             ty::Float(f) => {\n                 let (lang_def_id1, lang_def_id2) = match f {\n-                    ast::FloatTy::F32 => (lang_items.f32_impl(), lang_items.f32_runtime_impl()),\n-                    ast::FloatTy::F64 => (lang_items.f64_impl(), lang_items.f64_runtime_impl()),\n+                    ty::FloatTy::F32 => (lang_items.f32_impl(), lang_items.f32_runtime_impl()),\n+                    ty::FloatTy::F64 => (lang_items.f64_impl(), lang_items.f64_runtime_impl()),\n                 };\n                 self.assemble_inherent_impl_for_primitive(lang_def_id1);\n                 self.assemble_inherent_impl_for_primitive(lang_def_id2);"}, {"sha": "1c1f7f7886fcd95053ba9ceb5f174db06d30b51c", "filename": "compiler/rustc_typeck/src/check/pat.rs", "status": "modified", "additions": 7, "deletions": 18, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs?ref=0e190206e2ff0c13d64701d9b4145bf89a2d0cab", "patch": "@@ -1525,24 +1525,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 _ => return err,\n             },\n             [.., field] => {\n-                // if last field has a trailing comma, use the comma\n-                // as the span to avoid trailing comma in ultimate\n-                // suggestion (Issue #78511)\n-                let tail = field.span.shrink_to_hi().until(pat.span.shrink_to_hi());\n-                let tail_through_comma = self.tcx.sess.source_map().span_through_char(tail, ',');\n-                let sp = if tail_through_comma == tail {\n-                    field.span.shrink_to_hi()\n-                } else {\n-                    tail_through_comma\n-                };\n-                (\n-                    match pat.kind {\n-                        PatKind::Struct(_, [_, ..], _) => \", \",\n-                        _ => \"\",\n-                    },\n-                    \"\",\n-                    sp,\n-                )\n+                // Account for last field having a trailing comma or parse recovery at the tail of\n+                // the pattern to avoid invalid suggestion (#78511).\n+                let tail = field.span.shrink_to_hi().with_hi(pat.span.hi());\n+                match &pat.kind {\n+                    PatKind::Struct(..) => (\", \", \" }\", tail),\n+                    _ => return err,\n+                }\n             }\n         };\n         err.span_suggestion("}, {"sha": "6b2cba62fa6b7eca6d531c20042dce460b883792", "filename": "compiler/rustc_typeck/src/check/upvar.rs", "status": "modified", "additions": 124, "deletions": 25, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs?ref=0e190206e2ff0c13d64701d9b4145bf89a2d0cab", "patch": "@@ -42,7 +42,7 @@ use rustc_infer::infer::UpvarRegion;\n use rustc_middle::hir::place::{Place, PlaceBase, PlaceWithHirId, ProjectionKind};\n use rustc_middle::ty::{self, Ty, TyCtxt, UpvarSubsts};\n use rustc_span::sym;\n-use rustc_span::{Span, Symbol};\n+use rustc_span::{MultiSpan, Span, Symbol};\n \n /// Describe the relationship between the paths of two places\n /// eg:\n@@ -135,7 +135,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n                     let upvar_id = ty::UpvarId::new(var_hir_id, local_def_id);\n                     let capture_kind = self.init_capture_kind(capture_clause, upvar_id, span);\n-                    let info = ty::CaptureInfo { expr_id: None, capture_kind };\n+                    let info = ty::CaptureInfo {\n+                        capture_kind_expr_id: None,\n+                        path_expr_id: None,\n+                        capture_kind,\n+                    };\n \n                     capture_information.insert(place, info);\n                 }\n@@ -308,8 +312,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         if let Some(capture_kind) = upvar_capture_map.get(&upvar_id) {\n                             // upvar_capture_map only stores the UpvarCapture (CaptureKind),\n                             // so we create a fake capture info with no expression.\n-                            let fake_capture_info =\n-                                ty::CaptureInfo { expr_id: None, capture_kind: *capture_kind };\n+                            let fake_capture_info = ty::CaptureInfo {\n+                                capture_kind_expr_id: None,\n+                                path_expr_id: None,\n+                                capture_kind: *capture_kind,\n+                            };\n                             determine_capture_info(fake_capture_info, capture_info).capture_kind\n                         } else {\n                             capture_info.capture_kind\n@@ -359,20 +366,44 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ///\n     /// ```\n     /// {\n-    ///       Place(base: hir_id_s, projections: [], ....) -> (hir_id_L5, ByValue),\n-    ///       Place(base: hir_id_p, projections: [Field(0, 0)], ...) -> (hir_id_L2, ByRef(MutBorrow))\n-    ///       Place(base: hir_id_p, projections: [Field(1, 0)], ...) -> (hir_id_L3, ByRef(ImmutBorrow))\n-    ///       Place(base: hir_id_p, projections: [], ...) -> (hir_id_L4, ByRef(ImmutBorrow))\n+    ///       Place(base: hir_id_s, projections: [], ....) -> {\n+    ///                                                            capture_kind_expr: hir_id_L5,\n+    ///                                                            path_expr_id: hir_id_L5,\n+    ///                                                            capture_kind: ByValue\n+    ///                                                       },\n+    ///       Place(base: hir_id_p, projections: [Field(0, 0)], ...) -> {\n+    ///                                                                     capture_kind_expr: hir_id_L2,\n+    ///                                                                     path_expr_id: hir_id_L2,\n+    ///                                                                     capture_kind: ByValue\n+    ///                                                                 },\n+    ///       Place(base: hir_id_p, projections: [Field(1, 0)], ...) -> {\n+    ///                                                                     capture_kind_expr: hir_id_L3,\n+    ///                                                                     path_expr_id: hir_id_L3,\n+    ///                                                                     capture_kind: ByValue\n+    ///                                                                 },\n+    ///       Place(base: hir_id_p, projections: [], ...) -> {\n+    ///                                                          capture_kind_expr: hir_id_L4,\n+    ///                                                          path_expr_id: hir_id_L4,\n+    ///                                                          capture_kind: ByValue\n+    ///                                                      },\n     /// ```\n     ///\n     /// After the min capture analysis, we get:\n     /// ```\n     /// {\n     ///       hir_id_s -> [\n-    ///            Place(base: hir_id_s, projections: [], ....) -> (hir_id_L4, ByValue)\n+    ///            Place(base: hir_id_s, projections: [], ....) -> {\n+    ///                                                                capture_kind_expr: hir_id_L5,\n+    ///                                                                path_expr_id: hir_id_L5,\n+    ///                                                                capture_kind: ByValue\n+    ///                                                            },\n     ///       ],\n     ///       hir_id_p -> [\n-    ///            Place(base: hir_id_p, projections: [], ...) -> (hir_id_L2, ByRef(MutBorrow)),\n+    ///            Place(base: hir_id_p, projections: [], ...) -> {\n+    ///                                                               capture_kind_expr: hir_id_L2,\n+    ///                                                               path_expr_id: hir_id_L4,\n+    ///                                                               capture_kind: ByValue\n+    ///                                                           },\n     ///       ],\n     /// ```\n     fn compute_min_captures(\n@@ -425,8 +456,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     // current place is ancestor of possible_descendant\n                     PlaceAncestryRelation::Ancestor => {\n                         descendant_found = true;\n+                        let backup_path_expr_id = updated_capture_info.path_expr_id;\n+\n                         updated_capture_info =\n                             determine_capture_info(updated_capture_info, possible_descendant.info);\n+\n+                        // we need to keep the ancestor's `path_expr_id`\n+                        updated_capture_info.path_expr_id = backup_path_expr_id;\n                         false\n                     }\n \n@@ -441,9 +477,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         // current place is descendant of possible_ancestor\n                         PlaceAncestryRelation::Descendant => {\n                             ancestor_found = true;\n+                            let backup_path_expr_id = possible_ancestor.info.path_expr_id;\n                             possible_ancestor.info =\n                                 determine_capture_info(possible_ancestor.info, capture_info);\n \n+                            // we need to keep the ancestor's `path_expr_id`\n+                            possible_ancestor.info.path_expr_id = backup_path_expr_id;\n+\n                             // Only one ancestor of the current place will be in the list.\n                             break;\n                         }\n@@ -518,7 +558,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 let capture_str = construct_capture_info_string(self.tcx, place, capture_info);\n                 let output_str = format!(\"Capturing {}\", capture_str);\n \n-                let span = capture_info.expr_id.map_or(closure_span, |e| self.tcx.hir().span(e));\n+                let span =\n+                    capture_info.path_expr_id.map_or(closure_span, |e| self.tcx.hir().span(e));\n                 diag.span_note(span, &output_str);\n             }\n             diag.emit();\n@@ -542,9 +583,32 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             construct_capture_info_string(self.tcx, place, capture_info);\n                         let output_str = format!(\"Min Capture {}\", capture_str);\n \n-                        let span =\n-                            capture_info.expr_id.map_or(closure_span, |e| self.tcx.hir().span(e));\n-                        diag.span_note(span, &output_str);\n+                        if capture.info.path_expr_id != capture.info.capture_kind_expr_id {\n+                            let path_span = capture_info\n+                                .path_expr_id\n+                                .map_or(closure_span, |e| self.tcx.hir().span(e));\n+                            let capture_kind_span = capture_info\n+                                .capture_kind_expr_id\n+                                .map_or(closure_span, |e| self.tcx.hir().span(e));\n+\n+                            let mut multi_span: MultiSpan =\n+                                MultiSpan::from_spans(vec![path_span, capture_kind_span]);\n+\n+                            let capture_kind_label =\n+                                construct_capture_kind_reason_string(self.tcx, place, capture_info);\n+                            let path_label = construct_path_string(self.tcx, place);\n+\n+                            multi_span.push_span_label(path_span, path_label);\n+                            multi_span.push_span_label(capture_kind_span, capture_kind_label);\n+\n+                            diag.span_note(multi_span, &output_str);\n+                        } else {\n+                            let span = capture_info\n+                                .path_expr_id\n+                                .map_or(closure_span, |e| self.tcx.hir().span(e));\n+\n+                            diag.span_note(span, &output_str);\n+                        };\n                     }\n                 }\n                 diag.emit();\n@@ -642,7 +706,8 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n         );\n \n         let capture_info = ty::CaptureInfo {\n-            expr_id: Some(diag_expr_id),\n+            capture_kind_expr_id: Some(diag_expr_id),\n+            path_expr_id: Some(diag_expr_id),\n             capture_kind: ty::UpvarCapture::ByValue(Some(usage_span)),\n         };\n \n@@ -762,7 +827,8 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n             let new_upvar_borrow = ty::UpvarBorrow { kind, region: curr_upvar_borrow.region };\n \n             let capture_info = ty::CaptureInfo {\n-                expr_id: Some(diag_expr_id),\n+                capture_kind_expr_id: Some(diag_expr_id),\n+                path_expr_id: Some(diag_expr_id),\n                 capture_kind: ty::UpvarCapture::ByRef(new_upvar_borrow),\n             };\n             let updated_info = determine_capture_info(curr_capture_info, capture_info);\n@@ -824,7 +890,11 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n                 self.fcx.init_capture_kind(self.capture_clause, upvar_id, self.closure_span);\n \n             let expr_id = Some(diag_expr_id);\n-            let capture_info = ty::CaptureInfo { expr_id, capture_kind };\n+            let capture_info = ty::CaptureInfo {\n+                capture_kind_expr_id: expr_id,\n+                path_expr_id: expr_id,\n+                capture_kind,\n+            };\n \n             debug!(\"Capturing new place {:?}, capture_info={:?}\", place_with_id, capture_info);\n \n@@ -890,11 +960,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'tcx> {\n     }\n }\n \n-fn construct_capture_info_string(\n-    tcx: TyCtxt<'_>,\n-    place: &Place<'tcx>,\n-    capture_info: &ty::CaptureInfo<'tcx>,\n-) -> String {\n+fn construct_place_string(tcx: TyCtxt<'_>, place: &Place<'tcx>) -> String {\n     let variable_name = match place.base {\n         PlaceBase::Upvar(upvar_id) => var_name(tcx, upvar_id.var_path.hir_id).to_string(),\n         _ => bug!(\"Capture_information should only contain upvars\"),\n@@ -914,11 +980,42 @@ fn construct_capture_info_string(\n         projections_str.push_str(proj.as_str());\n     }\n \n+    format!(\"{}[{}]\", variable_name, projections_str)\n+}\n+\n+fn construct_capture_kind_reason_string(\n+    tcx: TyCtxt<'_>,\n+    place: &Place<'tcx>,\n+    capture_info: &ty::CaptureInfo<'tcx>,\n+) -> String {\n+    let place_str = construct_place_string(tcx, &place);\n+\n     let capture_kind_str = match capture_info.capture_kind {\n         ty::UpvarCapture::ByValue(_) => \"ByValue\".into(),\n         ty::UpvarCapture::ByRef(borrow) => format!(\"{:?}\", borrow.kind),\n     };\n-    format!(\"{}[{}] -> {}\", variable_name, projections_str, capture_kind_str)\n+\n+    format!(\"{} captured as {} here\", place_str, capture_kind_str)\n+}\n+\n+fn construct_path_string(tcx: TyCtxt<'_>, place: &Place<'tcx>) -> String {\n+    let place_str = construct_place_string(tcx, &place);\n+\n+    format!(\"{} used here\", place_str)\n+}\n+\n+fn construct_capture_info_string(\n+    tcx: TyCtxt<'_>,\n+    place: &Place<'tcx>,\n+    capture_info: &ty::CaptureInfo<'tcx>,\n+) -> String {\n+    let place_str = construct_place_string(tcx, &place);\n+\n+    let capture_kind_str = match capture_info.capture_kind {\n+        ty::UpvarCapture::ByValue(_) => \"ByValue\".into(),\n+        ty::UpvarCapture::ByRef(borrow) => format!(\"{:?}\", borrow.kind),\n+    };\n+    format!(\"{} -> {}\", place_str, capture_kind_str)\n }\n \n fn var_name(tcx: TyCtxt<'_>, var_hir_id: hir::HirId) -> Symbol {\n@@ -930,7 +1027,9 @@ fn var_name(tcx: TyCtxt<'_>, var_hir_id: hir::HirId) -> Symbol {\n /// (Note: CaptureInfo contains CaptureKind and an expression that led to capture it in that way)\n ///\n /// If both `CaptureKind`s are considered equivalent, then the CaptureInfo is selected based\n-/// on the `CaptureInfo` containing an associated expression id.\n+/// on the `CaptureInfo` containing an associated `capture_kind_expr_id`.\n+///\n+/// It is the caller's duty to figure out which path_expr_id to use.\n ///\n /// If both the CaptureKind and Expression are considered to be equivalent,\n /// then `CaptureInfo` A is preferred. This can be useful in cases where we want to priortize\n@@ -981,7 +1080,7 @@ fn determine_capture_info(\n     };\n \n     if eq_capture_kind {\n-        match (capture_info_a.expr_id, capture_info_b.expr_id) {\n+        match (capture_info_a.capture_kind_expr_id, capture_info_b.capture_kind_expr_id) {\n             (Some(_), _) | (None, None) => capture_info_a,\n             (None, Some(_)) => capture_info_b,\n         }"}, {"sha": "b6d740a4fdb57c8b93e9f579dbbda88153984465", "filename": "compiler/rustc_typeck/src/check/writeback.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs?ref=0e190206e2ff0c13d64701d9b4145bf89a2d0cab", "patch": "@@ -348,7 +348,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n                 let min_list_wb = min_list\n                     .iter()\n                     .map(|captured_place| {\n-                        let locatable = captured_place.info.expr_id.unwrap_or(\n+                        let locatable = captured_place.info.path_expr_id.unwrap_or(\n                             self.tcx().hir().local_def_id_to_hir_id(closure_def_id.expect_local()),\n                         );\n "}, {"sha": "8a500852a03263bc66420a3451e3e50f7e48e18f", "filename": "compiler/rustc_typeck/src/coherence/inherent_impls.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Finherent_impls.rs?ref=0e190206e2ff0c13d64701d9b4145bf89a2d0cab", "patch": "@@ -13,7 +13,6 @@ use rustc_hir::def_id::{CrateNum, DefId, LocalDefId, LOCAL_CRATE};\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n use rustc_middle::ty::{self, CrateInherentImpls, TyCtxt};\n \n-use rustc_ast as ast;\n use rustc_span::Span;\n \n /// On-demand query: yields a map containing all types mapped to their inherent impls.\n@@ -178,7 +177,7 @@ impl ItemLikeVisitor<'v> for InherentCollect<'tcx> {\n                     assoc_items,\n                 );\n             }\n-            ty::Int(ast::IntTy::I8) => {\n+            ty::Int(ty::IntTy::I8) => {\n                 self.check_primitive_impl(\n                     def_id,\n                     lang_items.i8_impl(),\n@@ -189,7 +188,7 @@ impl ItemLikeVisitor<'v> for InherentCollect<'tcx> {\n                     assoc_items,\n                 );\n             }\n-            ty::Int(ast::IntTy::I16) => {\n+            ty::Int(ty::IntTy::I16) => {\n                 self.check_primitive_impl(\n                     def_id,\n                     lang_items.i16_impl(),\n@@ -200,7 +199,7 @@ impl ItemLikeVisitor<'v> for InherentCollect<'tcx> {\n                     assoc_items,\n                 );\n             }\n-            ty::Int(ast::IntTy::I32) => {\n+            ty::Int(ty::IntTy::I32) => {\n                 self.check_primitive_impl(\n                     def_id,\n                     lang_items.i32_impl(),\n@@ -211,7 +210,7 @@ impl ItemLikeVisitor<'v> for InherentCollect<'tcx> {\n                     assoc_items,\n                 );\n             }\n-            ty::Int(ast::IntTy::I64) => {\n+            ty::Int(ty::IntTy::I64) => {\n                 self.check_primitive_impl(\n                     def_id,\n                     lang_items.i64_impl(),\n@@ -222,7 +221,7 @@ impl ItemLikeVisitor<'v> for InherentCollect<'tcx> {\n                     assoc_items,\n                 );\n             }\n-            ty::Int(ast::IntTy::I128) => {\n+            ty::Int(ty::IntTy::I128) => {\n                 self.check_primitive_impl(\n                     def_id,\n                     lang_items.i128_impl(),\n@@ -233,7 +232,7 @@ impl ItemLikeVisitor<'v> for InherentCollect<'tcx> {\n                     assoc_items,\n                 );\n             }\n-            ty::Int(ast::IntTy::Isize) => {\n+            ty::Int(ty::IntTy::Isize) => {\n                 self.check_primitive_impl(\n                     def_id,\n                     lang_items.isize_impl(),\n@@ -244,7 +243,7 @@ impl ItemLikeVisitor<'v> for InherentCollect<'tcx> {\n                     assoc_items,\n                 );\n             }\n-            ty::Uint(ast::UintTy::U8) => {\n+            ty::Uint(ty::UintTy::U8) => {\n                 self.check_primitive_impl(\n                     def_id,\n                     lang_items.u8_impl(),\n@@ -255,7 +254,7 @@ impl ItemLikeVisitor<'v> for InherentCollect<'tcx> {\n                     assoc_items,\n                 );\n             }\n-            ty::Uint(ast::UintTy::U16) => {\n+            ty::Uint(ty::UintTy::U16) => {\n                 self.check_primitive_impl(\n                     def_id,\n                     lang_items.u16_impl(),\n@@ -266,7 +265,7 @@ impl ItemLikeVisitor<'v> for InherentCollect<'tcx> {\n                     assoc_items,\n                 );\n             }\n-            ty::Uint(ast::UintTy::U32) => {\n+            ty::Uint(ty::UintTy::U32) => {\n                 self.check_primitive_impl(\n                     def_id,\n                     lang_items.u32_impl(),\n@@ -277,7 +276,7 @@ impl ItemLikeVisitor<'v> for InherentCollect<'tcx> {\n                     assoc_items,\n                 );\n             }\n-            ty::Uint(ast::UintTy::U64) => {\n+            ty::Uint(ty::UintTy::U64) => {\n                 self.check_primitive_impl(\n                     def_id,\n                     lang_items.u64_impl(),\n@@ -288,7 +287,7 @@ impl ItemLikeVisitor<'v> for InherentCollect<'tcx> {\n                     assoc_items,\n                 );\n             }\n-            ty::Uint(ast::UintTy::U128) => {\n+            ty::Uint(ty::UintTy::U128) => {\n                 self.check_primitive_impl(\n                     def_id,\n                     lang_items.u128_impl(),\n@@ -299,7 +298,7 @@ impl ItemLikeVisitor<'v> for InherentCollect<'tcx> {\n                     assoc_items,\n                 );\n             }\n-            ty::Uint(ast::UintTy::Usize) => {\n+            ty::Uint(ty::UintTy::Usize) => {\n                 self.check_primitive_impl(\n                     def_id,\n                     lang_items.usize_impl(),\n@@ -310,7 +309,7 @@ impl ItemLikeVisitor<'v> for InherentCollect<'tcx> {\n                     assoc_items,\n                 );\n             }\n-            ty::Float(ast::FloatTy::F32) => {\n+            ty::Float(ty::FloatTy::F32) => {\n                 self.check_primitive_impl(\n                     def_id,\n                     lang_items.f32_impl(),\n@@ -321,7 +320,7 @@ impl ItemLikeVisitor<'v> for InherentCollect<'tcx> {\n                     assoc_items,\n                 );\n             }\n-            ty::Float(ast::FloatTy::F64) => {\n+            ty::Float(ty::FloatTy::F64) => {\n                 self.check_primitive_impl(\n                     def_id,\n                     lang_items.f64_impl(),"}, {"sha": "b1d98d75196d5be4b3cc351839fda86c5ad5c31b", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=0e190206e2ff0c13d64701d9b4145bf89a2d0cab", "patch": "@@ -50,8 +50,6 @@ use rustc_span::{Span, DUMMY_SP};\n use rustc_target::spec::abi;\n use rustc_trait_selection::traits::error_reporting::suggestions::NextTypeParamName;\n \n-use std::ops::ControlFlow;\n-\n mod item_bounds;\n mod type_of;\n \n@@ -2080,38 +2078,6 @@ fn const_evaluatable_predicates_of<'tcx>(\n                 ));\n             }\n         }\n-\n-        // Look into `TyAlias`.\n-        fn visit_ty(&mut self, ty: &'tcx hir::Ty<'tcx>) {\n-            use ty::fold::{TypeFoldable, TypeVisitor};\n-            struct TyAliasVisitor<'a, 'tcx> {\n-                tcx: TyCtxt<'tcx>,\n-                preds: &'a mut FxIndexSet<(ty::Predicate<'tcx>, Span)>,\n-                span: Span,\n-            }\n-\n-            impl<'a, 'tcx> TypeVisitor<'tcx> for TyAliasVisitor<'a, 'tcx> {\n-                fn visit_const(&mut self, ct: &'tcx Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n-                    if let ty::ConstKind::Unevaluated(def, substs, None) = ct.val {\n-                        self.preds.insert((\n-                            ty::PredicateKind::ConstEvaluatable(def, substs).to_predicate(self.tcx),\n-                            self.span,\n-                        ));\n-                    }\n-                    ControlFlow::CONTINUE\n-                }\n-            }\n-\n-            if let hir::TyKind::Path(hir::QPath::Resolved(None, path)) = ty.kind {\n-                if let Res::Def(DefKind::TyAlias, def_id) = path.res {\n-                    let mut visitor =\n-                        TyAliasVisitor { tcx: self.tcx, preds: &mut self.preds, span: path.span };\n-                    self.tcx.type_of(def_id).visit_with(&mut visitor);\n-                }\n-            }\n-\n-            intravisit::walk_ty(self, ty)\n-        }\n     }\n \n     let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);"}, {"sha": "bd2c266d93dca6a8c94e4c22b59f97b7a53b9096", "filename": "compiler/rustc_typeck/src/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs?ref=0e190206e2ff0c13d64701d9b4145bf89a2d0cab", "patch": "@@ -630,7 +630,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n                         PlaceBase::Local(*var_hir_id)\n                     };\n                     let place_with_id = PlaceWithHirId::new(\n-                        capture_info.expr_id.unwrap_or(closure_expr.hir_id),\n+                        capture_info.path_expr_id.unwrap_or(closure_expr.hir_id),\n                         place.base_ty,\n                         place_base,\n                         place.projections.clone(),"}, {"sha": "a6d3b5ef813f174fc728c2d5968c538ff276705c", "filename": "library/core/src/convert/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/library%2Fcore%2Fsrc%2Fconvert%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/library%2Fcore%2Fsrc%2Fconvert%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fconvert%2Fmod.rs?ref=0e190206e2ff0c13d64701d9b4145bf89a2d0cab", "patch": "@@ -267,6 +267,7 @@ pub trait AsMut<T: ?Sized> {\n ///\n /// [`String`]: ../../std/string/struct.String.html\n /// [`Vec`]: ../../std/vec/struct.Vec.html\n+#[rustc_diagnostic_item = \"into_trait\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Into<T>: Sized {\n     /// Performs the conversion.\n@@ -382,6 +383,7 @@ pub trait From<T>: Sized {\n ///\n /// This suffers the same restrictions and reasoning as implementing\n /// [`Into`], see there for details.\n+#[rustc_diagnostic_item = \"try_into_trait\"]\n #[stable(feature = \"try_from\", since = \"1.34.0\")]\n pub trait TryInto<T>: Sized {\n     /// The type returned in the event of a conversion error.\n@@ -462,6 +464,7 @@ pub trait TryInto<T>: Sized {\n ///\n /// [`try_from`]: TryFrom::try_from\n /// [`!`]: ../../std/primitive.never.html\n+#[rustc_diagnostic_item = \"try_from_trait\"]\n #[stable(feature = \"try_from\", since = \"1.34.0\")]\n pub trait TryFrom<T>: Sized {\n     /// The type returned in the event of a conversion error."}, {"sha": "987371f50ec22558fee4a16e0a27914b590f71e5", "filename": "library/std/src/io/buffered/bufreader.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufreader.rs?ref=0e190206e2ff0c13d64701d9b4145bf89a2d0cab", "patch": "@@ -410,7 +410,6 @@ impl<R: Seek> Seek for BufReader<R> {\n     /// # Example\n     ///\n     /// ```no_run\n-    /// #![feature(seek_convenience)]\n     /// use std::{\n     ///     io::{self, BufRead, BufReader, Seek},\n     ///     fs::File,"}, {"sha": "db3b0e2628f2a3c463d06ab5ef2f08f9c8376823", "filename": "library/std/src/io/mod.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fmod.rs?ref=0e190206e2ff0c13d64701d9b4145bf89a2d0cab", "patch": "@@ -1671,7 +1671,7 @@ pub trait Seek {\n     /// # Example\n     ///\n     /// ```no_run\n-    /// #![feature(seek_convenience)]\n+    /// #![feature(seek_stream_len)]\n     /// use std::{\n     ///     io::{self, Seek},\n     ///     fs::File,\n@@ -1685,7 +1685,7 @@ pub trait Seek {\n     ///     Ok(())\n     /// }\n     /// ```\n-    #[unstable(feature = \"seek_convenience\", issue = \"59359\")]\n+    #[unstable(feature = \"seek_stream_len\", issue = \"59359\")]\n     fn stream_len(&mut self) -> Result<u64> {\n         let old_pos = self.stream_position()?;\n         let len = self.seek(SeekFrom::End(0))?;\n@@ -1706,7 +1706,6 @@ pub trait Seek {\n     /// # Example\n     ///\n     /// ```no_run\n-    /// #![feature(seek_convenience)]\n     /// use std::{\n     ///     io::{self, BufRead, BufReader, Seek},\n     ///     fs::File,\n@@ -1723,7 +1722,7 @@ pub trait Seek {\n     ///     Ok(())\n     /// }\n     /// ```\n-    #[unstable(feature = \"seek_convenience\", issue = \"59359\")]\n+    #[stable(feature = \"seek_convenience\", since = \"1.51.0\")]\n     fn stream_position(&mut self) -> Result<u64> {\n         self.seek(SeekFrom::Current(0))\n     }"}, {"sha": "598fb670bb4bf678242921f42d7c966a6866aa3d", "filename": "library/test/src/test_result.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/library%2Ftest%2Fsrc%2Ftest_result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/library%2Ftest%2Fsrc%2Ftest_result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Ftest_result.rs?ref=0e190206e2ff0c13d64701d9b4145bf89a2d0cab", "patch": "@@ -63,7 +63,7 @@ pub fn calc_result<'a>(\n                 ))\n             }\n         }\n-        (&ShouldPanic::Yes, Ok(())) => {\n+        (&ShouldPanic::Yes, Ok(())) | (&ShouldPanic::YesWithMessage(_), Ok(())) => {\n             TestResult::TrFailedMsg(\"test did not panic as expected\".to_string())\n         }\n         _ if desc.allow_fail => TestResult::TrAllowedFail,"}, {"sha": "a629829b885145f4af02fb64e5985a13eb1c6836", "filename": "library/test/src/tests.rs", "status": "modified", "additions": 24, "deletions": 15, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/library%2Ftest%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/library%2Ftest%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Ftests.rs?ref=0e190206e2ff0c13d64701d9b4145bf89a2d0cab", "patch": "@@ -228,21 +228,30 @@ fn test_should_panic_non_string_message_type() {\n #[test]\n #[cfg(not(target_os = \"emscripten\"))]\n fn test_should_panic_but_succeeds() {\n-    fn f() {}\n-    let desc = TestDescAndFn {\n-        desc: TestDesc {\n-            name: StaticTestName(\"whatever\"),\n-            ignore: false,\n-            should_panic: ShouldPanic::Yes,\n-            allow_fail: false,\n-            test_type: TestType::Unknown,\n-        },\n-        testfn: DynTestFn(Box::new(f)),\n-    };\n-    let (tx, rx) = channel();\n-    run_test(&TestOpts::new(), false, desc, RunStrategy::InProcess, tx, Concurrent::No);\n-    let result = rx.recv().unwrap().result;\n-    assert_eq!(result, TrFailedMsg(\"test did not panic as expected\".to_string()));\n+    let should_panic_variants = [ShouldPanic::Yes, ShouldPanic::YesWithMessage(\"error message\")];\n+\n+    for &should_panic in should_panic_variants.iter() {\n+        fn f() {}\n+        let desc = TestDescAndFn {\n+            desc: TestDesc {\n+                name: StaticTestName(\"whatever\"),\n+                ignore: false,\n+                should_panic,\n+                allow_fail: false,\n+                test_type: TestType::Unknown,\n+            },\n+            testfn: DynTestFn(Box::new(f)),\n+        };\n+        let (tx, rx) = channel();\n+        run_test(&TestOpts::new(), false, desc, RunStrategy::InProcess, tx, Concurrent::No);\n+        let result = rx.recv().unwrap().result;\n+        assert_eq!(\n+            result,\n+            TrFailedMsg(\"test did not panic as expected\".to_string()),\n+            \"should_panic == {:?}\",\n+            should_panic\n+        );\n+    }\n }\n \n fn report_time_test_template(report_time: bool) -> Option<TestExecTime> {"}, {"sha": "bebb746c92d2f7559ec6422bf6c8be9c13fa8541", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 37, "deletions": 2, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=0e190206e2ff0c13d64701d9b4145bf89a2d0cab", "patch": "@@ -11,7 +11,6 @@ use std::{slice, vec};\n use rustc_ast::attr;\n use rustc_ast::util::comments::beautify_doc_string;\n use rustc_ast::{self as ast, AttrStyle};\n-use rustc_ast::{FloatTy, IntTy, UintTy};\n use rustc_attr::{ConstStability, Deprecation, Stability, StabilityLevel};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_feature::UnstableFeatures;\n@@ -21,7 +20,7 @@ use rustc_hir::def_id::{CrateNum, DefId};\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::Mutability;\n use rustc_index::vec::IndexVec;\n-use rustc_middle::ty::TyCtxt;\n+use rustc_middle::ty::{self, TyCtxt};\n use rustc_session::Session;\n use rustc_span::hygiene::MacroKind;\n use rustc_span::source_map::DUMMY_SP;\n@@ -1456,6 +1455,7 @@ impl GetDefId for Type {\n \n impl PrimitiveType {\n     crate fn from_hir(prim: hir::PrimTy) -> PrimitiveType {\n+        use ast::{FloatTy, IntTy, UintTy};\n         match prim {\n             hir::PrimTy::Int(IntTy::Isize) => PrimitiveType::Isize,\n             hir::PrimTy::Int(IntTy::I8) => PrimitiveType::I8,\n@@ -1690,6 +1690,41 @@ impl From<ast::FloatTy> for PrimitiveType {\n     }\n }\n \n+impl From<ty::IntTy> for PrimitiveType {\n+    fn from(int_ty: ty::IntTy) -> PrimitiveType {\n+        match int_ty {\n+            ty::IntTy::Isize => PrimitiveType::Isize,\n+            ty::IntTy::I8 => PrimitiveType::I8,\n+            ty::IntTy::I16 => PrimitiveType::I16,\n+            ty::IntTy::I32 => PrimitiveType::I32,\n+            ty::IntTy::I64 => PrimitiveType::I64,\n+            ty::IntTy::I128 => PrimitiveType::I128,\n+        }\n+    }\n+}\n+\n+impl From<ty::UintTy> for PrimitiveType {\n+    fn from(uint_ty: ty::UintTy) -> PrimitiveType {\n+        match uint_ty {\n+            ty::UintTy::Usize => PrimitiveType::Usize,\n+            ty::UintTy::U8 => PrimitiveType::U8,\n+            ty::UintTy::U16 => PrimitiveType::U16,\n+            ty::UintTy::U32 => PrimitiveType::U32,\n+            ty::UintTy::U64 => PrimitiveType::U64,\n+            ty::UintTy::U128 => PrimitiveType::U128,\n+        }\n+    }\n+}\n+\n+impl From<ty::FloatTy> for PrimitiveType {\n+    fn from(float_ty: ty::FloatTy) -> PrimitiveType {\n+        match float_ty {\n+            ty::FloatTy::F32 => PrimitiveType::F32,\n+            ty::FloatTy::F64 => PrimitiveType::F64,\n+        }\n+    }\n+}\n+\n impl From<hir::PrimTy> for PrimitiveType {\n     fn from(prim_ty: hir::PrimTy) -> PrimitiveType {\n         match prim_ty {"}, {"sha": "50ec6e69fbd408ca1dea9ed78827d24eba335658", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=0e190206e2ff0c13d64701d9b4145bf89a2d0cab", "patch": "@@ -487,12 +487,16 @@ crate fn get_auto_trait_and_blanket_impls(\n     ty: Ty<'tcx>,\n     param_env_def_id: DefId,\n ) -> impl Iterator<Item = Item> {\n-    let auto_impls = cx.sess().time(\"get_auto_trait_impls\", || {\n-        AutoTraitFinder::new(cx).get_auto_trait_impls(ty, param_env_def_id)\n-    });\n-    let blanket_impls = cx.sess().time(\"get_blanket_impls\", || {\n-        BlanketImplFinder::new(cx).get_blanket_impls(ty, param_env_def_id)\n-    });\n+    let auto_impls = cx\n+        .sess()\n+        .prof\n+        .generic_activity(\"get_auto_trait_impls\")\n+        .run(|| AutoTraitFinder::new(cx).get_auto_trait_impls(ty, param_env_def_id));\n+    let blanket_impls = cx\n+        .sess()\n+        .prof\n+        .generic_activity(\"get_blanket_impls\")\n+        .run(|| BlanketImplFinder::new(cx).get_blanket_impls(ty, param_env_def_id));\n     auto_impls.into_iter().chain(blanket_impls)\n }\n "}, {"sha": "7e613220f2d696a13223e00c4c3726125a93f236", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=0e190206e2ff0c13d64701d9b4145bf89a2d0cab", "patch": "@@ -91,6 +91,11 @@ function getThemePickerElement() {\n     return document.getElementById(\"theme-picker\");\n }\n \n+// Returns the current URL without any query parameter or hash.\n+function getNakedUrl() {\n+    return window.location.href.split(\"?\")[0].split(\"#\")[0];\n+}\n+\n // Sets the focus on the search bar at the top of the page\n function focusSearchBar() {\n     getSearchInput().focus();\n@@ -252,7 +257,9 @@ function defocusSearchBar() {\n             hideSearchResults(search);\n             var hash = ev.newURL.slice(ev.newURL.indexOf(\"#\") + 1);\n             if (browserSupportsHistoryApi()) {\n-                history.replaceState(hash, \"\", \"?search=#\" + hash);\n+                // `window.location.search`` contains all the query parameters, not just `search`.\n+                history.replaceState(hash, \"\",\n+                    getNakedUrl() + window.location.search + \"#\" + hash);\n             }\n             elem = document.getElementById(hash);\n             if (elem) {\n@@ -1810,10 +1817,12 @@ function defocusSearchBar() {\n             // Because searching is incremental by character, only the most\n             // recent search query is added to the browser history.\n             if (browserSupportsHistoryApi()) {\n+                var newURL = getNakedUrl() + \"?search=\" + encodeURIComponent(query.raw) +\n+                    window.location.hash;\n                 if (!history.state && !params.search) {\n-                    history.pushState(query, \"\", \"?search=\" + encodeURIComponent(query.raw));\n+                    history.pushState(query, \"\", newURL);\n                 } else {\n-                    history.replaceState(query, \"\", \"?search=\" + encodeURIComponent(query.raw));\n+                    history.replaceState(query, \"\", newURL);\n                 }\n             }\n \n@@ -1922,7 +1931,8 @@ function defocusSearchBar() {\n                 clearInputTimeout();\n                 if (search_input.value.length === 0) {\n                     if (browserSupportsHistoryApi()) {\n-                        history.replaceState(\"\", window.currentCrate + \" - Rust\", \"?search=\");\n+                        history.replaceState(\"\", window.currentCrate + \" - Rust\",\n+                            getNakedUrl() + window.location.hash);\n                     }\n                     hideSearchResults();\n                 } else {\n@@ -2779,9 +2789,9 @@ function defocusSearchBar() {\n         if (search_input.value !== \"\" && hasClass(search, \"hidden\")) {\n             showSearchResults(search);\n             if (browserSupportsHistoryApi()) {\n-                history.replaceState(search_input.value,\n-                                     \"\",\n-                                     \"?search=\" + encodeURIComponent(search_input.value));\n+                var extra = \"?search=\" + encodeURIComponent(search_input.value);\n+                history.replaceState(search_input.value, \"\",\n+                    getNakedUrl() + extra + window.location.hash);\n             }\n             document.title = searchTitle;\n         }"}, {"sha": "6ec6620681bf5162becea0e2a8fd1d5eddccc9f7", "filename": "src/librustdoc/passes/collect_trait_impls.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs?ref=0e190206e2ff0c13d64701d9b4145bf89a2d0cab", "patch": "@@ -30,7 +30,7 @@ crate fn collect_trait_impls(krate: Crate, cx: &DocContext<'_>) -> Crate {\n \n     for &cnum in cx.tcx.crates().iter() {\n         for &(did, _) in cx.tcx.all_trait_implementations(cnum).iter() {\n-            cx.tcx.sess.time(\"build_extern_trait_impl\", || {\n+            cx.tcx.sess.prof.generic_activity(\"build_extern_trait_impl\").run(|| {\n                 inline::build_impl(cx, None, did, None, &mut new_items);\n             });\n         }\n@@ -39,7 +39,7 @@ crate fn collect_trait_impls(krate: Crate, cx: &DocContext<'_>) -> Crate {\n     // Also try to inline primitive impls from other crates.\n     for &def_id in PrimitiveType::all_impls(cx.tcx).values().flatten() {\n         if !def_id.is_local() {\n-            cx.sess().time(\"build_primitive_trait_impl\", || {\n+            cx.tcx.sess.prof.generic_activity(\"build_primitive_trait_impls\").run(|| {\n                 inline::build_impl(cx, None, def_id, None, &mut new_items);\n \n                 // FIXME(eddyb) is this `doc(hidden)` check needed?\n@@ -59,7 +59,7 @@ crate fn collect_trait_impls(krate: Crate, cx: &DocContext<'_>) -> Crate {\n     for &trait_did in cx.tcx.all_traits(LOCAL_CRATE).iter() {\n         for &impl_node in cx.tcx.hir().trait_impls(trait_did) {\n             let impl_did = cx.tcx.hir().local_def_id(impl_node);\n-            cx.tcx.sess.time(\"build_local_trait_impl\", || {\n+            cx.tcx.sess.prof.generic_activity(\"build_local_trait_impl\").run(|| {\n                 let mut extra_attrs = Vec::new();\n                 let mut parent = cx.tcx.parent(impl_did.to_def_id());\n                 while let Some(did) = parent {\n@@ -177,13 +177,11 @@ impl<'a, 'tcx> DocFolder for SyntheticImplCollector<'a, 'tcx> {\n         if i.is_struct() || i.is_enum() || i.is_union() {\n             // FIXME(eddyb) is this `doc(hidden)` check needed?\n             if !self.cx.tcx.get_attrs(i.def_id).lists(sym::doc).has_word(sym::hidden) {\n-                self.cx.sess().time(\"get_auto_trait_and_blanket_synthetic_impls\", || {\n-                    self.impls.extend(get_auto_trait_and_blanket_impls(\n-                        self.cx,\n-                        self.cx.tcx.type_of(i.def_id),\n-                        i.def_id,\n-                    ));\n-                });\n+                self.impls.extend(get_auto_trait_and_blanket_impls(\n+                    self.cx,\n+                    self.cx.tcx.type_of(i.def_id),\n+                    i.def_id,\n+                ));\n             }\n         }\n "}, {"sha": "4368c830e1c612b8162e5780bd544b462b1d294a", "filename": "src/test/ui/closures/2229_closure_analysis/capture-analysis-1.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fcapture-analysis-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fcapture-analysis-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fcapture-analysis-1.rs?ref=0e190206e2ff0c13d64701d9b4145bf89a2d0cab", "patch": "@@ -0,0 +1,35 @@\n+#![feature(capture_disjoint_fields)]\n+//~^ WARNING: the feature `capture_disjoint_fields` is incomplete\n+//~| NOTE: `#[warn(incomplete_features)]` on by default\n+//~| NOTE: see issue #53488 <https://github.com/rust-lang/rust/issues/53488>\n+#![feature(rustc_attrs)]\n+\n+#[derive(Debug)]\n+struct Point {\n+    x: i32,\n+    y: i32,\n+}\n+\n+fn main() {\n+    let p = Point { x: 10, y: 10 };\n+    let q = Point { x: 10, y: 10 };\n+\n+    let c = #[rustc_capture_analysis]\n+    //~^ ERROR: attributes on expressions are experimental\n+    //~| NOTE: see issue #15701 <https://github.com/rust-lang/rust/issues/15701>\n+    || {\n+    //~^ First Pass analysis includes:\n+    //~| Min Capture analysis includes:\n+        println!(\"{:?}\", p);\n+        //~^ NOTE: Capturing p[] -> ImmBorrow\n+        //~| NOTE: Min Capture p[] -> ImmBorrow\n+        println!(\"{:?}\", p.x);\n+        //~^ NOTE: Capturing p[(0, 0)] -> ImmBorrow\n+\n+        println!(\"{:?}\", q.x);\n+        //~^ NOTE: Capturing q[(0, 0)] -> ImmBorrow\n+        println!(\"{:?}\", q);\n+        //~^ NOTE: Capturing q[] -> ImmBorrow\n+        //~| NOTE: Min Capture q[] -> ImmBorrow\n+    };\n+}"}, {"sha": "09255343af0e8bc3fa95efb0a1b0f281ce76b657", "filename": "src/test/ui/closures/2229_closure_analysis/capture-analysis-1.stderr", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fcapture-analysis-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fcapture-analysis-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fcapture-analysis-1.stderr?ref=0e190206e2ff0c13d64701d9b4145bf89a2d0cab", "patch": "@@ -0,0 +1,77 @@\n+error[E0658]: attributes on expressions are experimental\n+  --> $DIR/capture-analysis-1.rs:17:13\n+   |\n+LL |     let c = #[rustc_capture_analysis]\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #15701 <https://github.com/rust-lang/rust/issues/15701> for more information\n+   = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n+\n+warning: the feature `capture_disjoint_fields` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/capture-analysis-1.rs:1:12\n+   |\n+LL | #![feature(capture_disjoint_fields)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n+\n+error: First Pass analysis includes:\n+  --> $DIR/capture-analysis-1.rs:20:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |\n+LL | |         println!(\"{:?}\", p);\n+...  |\n+LL | |\n+LL | |     };\n+   | |_____^\n+   |\n+note: Capturing p[] -> ImmBorrow\n+  --> $DIR/capture-analysis-1.rs:23:26\n+   |\n+LL |         println!(\"{:?}\", p);\n+   |                          ^\n+note: Capturing p[(0, 0)] -> ImmBorrow\n+  --> $DIR/capture-analysis-1.rs:26:26\n+   |\n+LL |         println!(\"{:?}\", p.x);\n+   |                          ^^^\n+note: Capturing q[(0, 0)] -> ImmBorrow\n+  --> $DIR/capture-analysis-1.rs:29:26\n+   |\n+LL |         println!(\"{:?}\", q.x);\n+   |                          ^^^\n+note: Capturing q[] -> ImmBorrow\n+  --> $DIR/capture-analysis-1.rs:31:26\n+   |\n+LL |         println!(\"{:?}\", q);\n+   |                          ^\n+\n+error: Min Capture analysis includes:\n+  --> $DIR/capture-analysis-1.rs:20:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |\n+LL | |         println!(\"{:?}\", p);\n+...  |\n+LL | |\n+LL | |     };\n+   | |_____^\n+   |\n+note: Min Capture p[] -> ImmBorrow\n+  --> $DIR/capture-analysis-1.rs:23:26\n+   |\n+LL |         println!(\"{:?}\", p);\n+   |                          ^\n+note: Min Capture q[] -> ImmBorrow\n+  --> $DIR/capture-analysis-1.rs:31:26\n+   |\n+LL |         println!(\"{:?}\", q);\n+   |                          ^\n+\n+error: aborting due to 3 previous errors; 1 warning emitted\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "ab7fce6a43099eb887dc713b969e69b0c12c295c", "filename": "src/test/ui/closures/2229_closure_analysis/capture-analysis-2.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fcapture-analysis-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fcapture-analysis-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fcapture-analysis-2.rs?ref=0e190206e2ff0c13d64701d9b4145bf89a2d0cab", "patch": "@@ -0,0 +1,30 @@\n+#![feature(capture_disjoint_fields)]\n+//~^ WARNING: the feature `capture_disjoint_fields` is incomplete\n+//~| NOTE: `#[warn(incomplete_features)]` on by default\n+//~| NOTE: see issue #53488 <https://github.com/rust-lang/rust/issues/53488>\n+#![feature(rustc_attrs)]\n+\n+#[derive(Debug)]\n+struct Point {\n+    x: String,\n+    y: i32,\n+}\n+\n+fn main() {\n+    let mut p = Point { x: String::new(), y: 10 };\n+\n+    let c = #[rustc_capture_analysis]\n+    //~^ ERROR: attributes on expressions are experimental\n+    //~| NOTE: see issue #15701 <https://github.com/rust-lang/rust/issues/15701>\n+    || {\n+    //~^ First Pass analysis includes:\n+    //~| Min Capture analysis includes:\n+        let _x = p.x;\n+        //~^ NOTE: Capturing p[(0, 0)] -> ByValue\n+        //~| NOTE: p[] captured as ByValue here\n+        println!(\"{:?}\", p);\n+        //~^ NOTE: Capturing p[] -> ImmBorrow\n+        //~| NOTE: Min Capture p[] -> ByValue\n+        //~| NOTE: p[] used here\n+    };\n+}"}, {"sha": "0e48d6b300b7252f403447681780dc26b0101842", "filename": "src/test/ui/closures/2229_closure_analysis/capture-analysis-2.stderr", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fcapture-analysis-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fcapture-analysis-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fcapture-analysis-2.stderr?ref=0e190206e2ff0c13d64701d9b4145bf89a2d0cab", "patch": "@@ -0,0 +1,65 @@\n+error[E0658]: attributes on expressions are experimental\n+  --> $DIR/capture-analysis-2.rs:16:13\n+   |\n+LL |     let c = #[rustc_capture_analysis]\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #15701 <https://github.com/rust-lang/rust/issues/15701> for more information\n+   = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n+\n+warning: the feature `capture_disjoint_fields` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/capture-analysis-2.rs:1:12\n+   |\n+LL | #![feature(capture_disjoint_fields)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n+\n+error: First Pass analysis includes:\n+  --> $DIR/capture-analysis-2.rs:19:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |\n+LL | |         let _x = p.x;\n+...  |\n+LL | |\n+LL | |     };\n+   | |_____^\n+   |\n+note: Capturing p[(0, 0)] -> ByValue\n+  --> $DIR/capture-analysis-2.rs:22:18\n+   |\n+LL |         let _x = p.x;\n+   |                  ^^^\n+note: Capturing p[] -> ImmBorrow\n+  --> $DIR/capture-analysis-2.rs:25:26\n+   |\n+LL |         println!(\"{:?}\", p);\n+   |                          ^\n+\n+error: Min Capture analysis includes:\n+  --> $DIR/capture-analysis-2.rs:19:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |\n+LL | |         let _x = p.x;\n+...  |\n+LL | |\n+LL | |     };\n+   | |_____^\n+   |\n+note: Min Capture p[] -> ByValue\n+  --> $DIR/capture-analysis-2.rs:22:18\n+   |\n+LL |         let _x = p.x;\n+   |                  ^^^ p[] captured as ByValue here\n+...\n+LL |         println!(\"{:?}\", p);\n+   |                          ^ p[] used here\n+\n+error: aborting due to 3 previous errors; 1 warning emitted\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "817ade899e2a0bc290e2f76fa65e368a85cc3479", "filename": "src/test/ui/closures/2229_closure_analysis/capture-analysis-3.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fcapture-analysis-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fcapture-analysis-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fcapture-analysis-3.rs?ref=0e190206e2ff0c13d64701d9b4145bf89a2d0cab", "patch": "@@ -0,0 +1,35 @@\n+#![feature(capture_disjoint_fields)]\n+//~^ WARNING: the feature `capture_disjoint_fields` is incomplete\n+//~| NOTE: `#[warn(incomplete_features)]` on by default\n+//~| NOTE: see issue #53488 <https://github.com/rust-lang/rust/issues/53488>\n+#![feature(rustc_attrs)]\n+\n+#[derive(Debug)]\n+struct Child {\n+    c: String,\n+    d: String,\n+}\n+\n+#[derive(Debug)]\n+struct Parent {\n+    b: Child,\n+}\n+\n+fn main() {\n+    let mut a = Parent { b: Child {c: String::new(), d: String::new()} };\n+\n+    let c = #[rustc_capture_analysis]\n+    //~^ ERROR: attributes on expressions are experimental\n+    //~| NOTE: see issue #15701 <https://github.com/rust-lang/rust/issues/15701>\n+    || {\n+    //~^ First Pass analysis includes:\n+    //~| Min Capture analysis includes:\n+        let _x = a.b.c;\n+        //~^ NOTE: Capturing a[(0, 0),(0, 0)] -> ByValue\n+        //~| NOTE: a[(0, 0)] captured as ByValue here\n+        println!(\"{:?}\", a.b);\n+        //~^ NOTE: Capturing a[(0, 0)] -> ImmBorrow\n+        //~| NOTE: Min Capture a[(0, 0)] -> ByValue\n+        //~| NOTE: a[(0, 0)] used here\n+    };\n+}"}, {"sha": "263e9ca56ebf6e840fe97cf4d83d29d1490c2348", "filename": "src/test/ui/closures/2229_closure_analysis/capture-analysis-3.stderr", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fcapture-analysis-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fcapture-analysis-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fcapture-analysis-3.stderr?ref=0e190206e2ff0c13d64701d9b4145bf89a2d0cab", "patch": "@@ -0,0 +1,65 @@\n+error[E0658]: attributes on expressions are experimental\n+  --> $DIR/capture-analysis-3.rs:21:13\n+   |\n+LL |     let c = #[rustc_capture_analysis]\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #15701 <https://github.com/rust-lang/rust/issues/15701> for more information\n+   = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n+\n+warning: the feature `capture_disjoint_fields` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/capture-analysis-3.rs:1:12\n+   |\n+LL | #![feature(capture_disjoint_fields)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n+\n+error: First Pass analysis includes:\n+  --> $DIR/capture-analysis-3.rs:24:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |\n+LL | |         let _x = a.b.c;\n+...  |\n+LL | |\n+LL | |     };\n+   | |_____^\n+   |\n+note: Capturing a[(0, 0),(0, 0)] -> ByValue\n+  --> $DIR/capture-analysis-3.rs:27:18\n+   |\n+LL |         let _x = a.b.c;\n+   |                  ^^^^^\n+note: Capturing a[(0, 0)] -> ImmBorrow\n+  --> $DIR/capture-analysis-3.rs:30:26\n+   |\n+LL |         println!(\"{:?}\", a.b);\n+   |                          ^^^\n+\n+error: Min Capture analysis includes:\n+  --> $DIR/capture-analysis-3.rs:24:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |\n+LL | |         let _x = a.b.c;\n+...  |\n+LL | |\n+LL | |     };\n+   | |_____^\n+   |\n+note: Min Capture a[(0, 0)] -> ByValue\n+  --> $DIR/capture-analysis-3.rs:27:18\n+   |\n+LL |         let _x = a.b.c;\n+   |                  ^^^^^ a[(0, 0)] captured as ByValue here\n+...\n+LL |         println!(\"{:?}\", a.b);\n+   |                          ^^^ a[(0, 0)] used here\n+\n+error: aborting due to 3 previous errors; 1 warning emitted\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "e8401299b30ada6f0f4b0fbdaca5694780f5430d", "filename": "src/test/ui/closures/2229_closure_analysis/capture-analysis-4.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fcapture-analysis-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fcapture-analysis-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fcapture-analysis-4.rs?ref=0e190206e2ff0c13d64701d9b4145bf89a2d0cab", "patch": "@@ -0,0 +1,33 @@\n+#![feature(capture_disjoint_fields)]\n+//~^ WARNING: the feature `capture_disjoint_fields` is incomplete\n+//~| NOTE: `#[warn(incomplete_features)]` on by default\n+//~| NOTE: see issue #53488 <https://github.com/rust-lang/rust/issues/53488>\n+#![feature(rustc_attrs)]\n+\n+#[derive(Debug)]\n+struct Child {\n+    c: String,\n+    d: String,\n+}\n+\n+#[derive(Debug)]\n+struct Parent {\n+    b: Child,\n+}\n+\n+fn main() {\n+    let mut a = Parent { b: Child {c: String::new(), d: String::new()} };\n+\n+    let c = #[rustc_capture_analysis]\n+    //~^ ERROR: attributes on expressions are experimental\n+    //~| NOTE: see issue #15701 <https://github.com/rust-lang/rust/issues/15701>\n+    || {\n+    //~^ First Pass analysis includes:\n+    //~| Min Capture analysis includes:\n+        let _x = a.b;\n+        //~^ NOTE: Capturing a[(0, 0)] -> ByValue\n+        //~| NOTE: Min Capture a[(0, 0)] -> ByValue\n+        println!(\"{:?}\", a.b.c);\n+        //~^ NOTE: Capturing a[(0, 0),(0, 0)] -> ImmBorrow\n+    };\n+}"}, {"sha": "f4605c1d51b760225a032691c9bdc1e0cc0a1146", "filename": "src/test/ui/closures/2229_closure_analysis/capture-analysis-4.stderr", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fcapture-analysis-4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fcapture-analysis-4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fcapture-analysis-4.stderr?ref=0e190206e2ff0c13d64701d9b4145bf89a2d0cab", "patch": "@@ -0,0 +1,62 @@\n+error[E0658]: attributes on expressions are experimental\n+  --> $DIR/capture-analysis-4.rs:21:13\n+   |\n+LL |     let c = #[rustc_capture_analysis]\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #15701 <https://github.com/rust-lang/rust/issues/15701> for more information\n+   = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n+\n+warning: the feature `capture_disjoint_fields` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/capture-analysis-4.rs:1:12\n+   |\n+LL | #![feature(capture_disjoint_fields)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n+\n+error: First Pass analysis includes:\n+  --> $DIR/capture-analysis-4.rs:24:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |\n+LL | |         let _x = a.b;\n+...  |\n+LL | |\n+LL | |     };\n+   | |_____^\n+   |\n+note: Capturing a[(0, 0)] -> ByValue\n+  --> $DIR/capture-analysis-4.rs:27:18\n+   |\n+LL |         let _x = a.b;\n+   |                  ^^^\n+note: Capturing a[(0, 0),(0, 0)] -> ImmBorrow\n+  --> $DIR/capture-analysis-4.rs:30:26\n+   |\n+LL |         println!(\"{:?}\", a.b.c);\n+   |                          ^^^^^\n+\n+error: Min Capture analysis includes:\n+  --> $DIR/capture-analysis-4.rs:24:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |\n+LL | |         let _x = a.b;\n+...  |\n+LL | |\n+LL | |     };\n+   | |_____^\n+   |\n+note: Min Capture a[(0, 0)] -> ByValue\n+  --> $DIR/capture-analysis-4.rs:27:18\n+   |\n+LL |         let _x = a.b;\n+   |                  ^^^\n+\n+error: aborting due to 3 previous errors; 1 warning emitted\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "f81866bb7e0967ea8e0780517af02e5a7ded4f5f", "filename": "src/test/ui/closures/2229_closure_analysis/deep-multilevel-struct.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdeep-multilevel-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdeep-multilevel-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdeep-multilevel-struct.rs?ref=0e190206e2ff0c13d64701d9b4145bf89a2d0cab", "patch": "@@ -0,0 +1,52 @@\n+#![feature(capture_disjoint_fields)]\n+//~^ WARNING: the feature `capture_disjoint_fields` is incomplete\n+//~| NOTE: `#[warn(incomplete_features)]` on by default\n+//~| NOTE: see issue #53488 <https://github.com/rust-lang/rust/issues/53488>\n+#![feature(rustc_attrs)]\n+#![allow(unused)]\n+\n+#[derive(Debug)]\n+struct Point {\n+    x: i32,\n+    y: i32,\n+}\n+#[derive(Debug)]\n+struct Line {\n+    p: Point,\n+    q: Point\n+}\n+#[derive(Debug)]\n+struct Plane {\n+    a: Line,\n+    b: Line,\n+}\n+\n+fn main() {\n+    let mut p = Plane {\n+        a: Line {\n+            p: Point { x: 1,y: 2 },\n+            q: Point { x: 3,y: 4 },\n+        },\n+        b: Line {\n+            p: Point { x: 1,y: 2 },\n+            q: Point { x: 3,y: 4 },\n+        }\n+    };\n+\n+    let c = #[rustc_capture_analysis]\n+    //~^ ERROR: attributes on expressions are experimental\n+    //~| NOTE: see issue #15701 <https://github.com/rust-lang/rust/issues/15701>\n+    || {\n+    //~^ ERROR: First Pass analysis includes:\n+    //~| ERROR: Min Capture analysis includes:\n+        let x = &p.a.p.x;\n+        //~^ NOTE: Capturing p[(0, 0),(0, 0),(0, 0)] -> ImmBorrow\n+        p.b.q.y = 9;\n+        //~^ NOTE: Capturing p[(1, 0),(1, 0),(1, 0)] -> MutBorrow\n+        //~| NOTE: p[] captured as MutBorrow here\n+        println!(\"{:?}\", p);\n+        //~^ NOTE: Capturing p[] -> ImmBorrow\n+        //~| NOTE: Min Capture p[] -> MutBorrow\n+        //~| NOTE: p[] used here\n+    };\n+}"}, {"sha": "863f1009131a161d0e963469d5dab132d85a54ba", "filename": "src/test/ui/closures/2229_closure_analysis/deep-multilevel-struct.stderr", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdeep-multilevel-struct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdeep-multilevel-struct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdeep-multilevel-struct.stderr?ref=0e190206e2ff0c13d64701d9b4145bf89a2d0cab", "patch": "@@ -0,0 +1,70 @@\n+error[E0658]: attributes on expressions are experimental\n+  --> $DIR/deep-multilevel-struct.rs:36:13\n+   |\n+LL |     let c = #[rustc_capture_analysis]\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #15701 <https://github.com/rust-lang/rust/issues/15701> for more information\n+   = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n+\n+warning: the feature `capture_disjoint_fields` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/deep-multilevel-struct.rs:1:12\n+   |\n+LL | #![feature(capture_disjoint_fields)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n+\n+error: First Pass analysis includes:\n+  --> $DIR/deep-multilevel-struct.rs:39:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |\n+LL | |         let x = &p.a.p.x;\n+...  |\n+LL | |\n+LL | |     };\n+   | |_____^\n+   |\n+note: Capturing p[(0, 0),(0, 0),(0, 0)] -> ImmBorrow\n+  --> $DIR/deep-multilevel-struct.rs:42:18\n+   |\n+LL |         let x = &p.a.p.x;\n+   |                  ^^^^^^^\n+note: Capturing p[(1, 0),(1, 0),(1, 0)] -> MutBorrow\n+  --> $DIR/deep-multilevel-struct.rs:44:9\n+   |\n+LL |         p.b.q.y = 9;\n+   |         ^^^^^^^\n+note: Capturing p[] -> ImmBorrow\n+  --> $DIR/deep-multilevel-struct.rs:47:26\n+   |\n+LL |         println!(\"{:?}\", p);\n+   |                          ^\n+\n+error: Min Capture analysis includes:\n+  --> $DIR/deep-multilevel-struct.rs:39:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |\n+LL | |         let x = &p.a.p.x;\n+...  |\n+LL | |\n+LL | |     };\n+   | |_____^\n+   |\n+note: Min Capture p[] -> MutBorrow\n+  --> $DIR/deep-multilevel-struct.rs:44:9\n+   |\n+LL |         p.b.q.y = 9;\n+   |         ^^^^^^^ p[] captured as MutBorrow here\n+...\n+LL |         println!(\"{:?}\", p);\n+   |                          ^ p[] used here\n+\n+error: aborting due to 3 previous errors; 1 warning emitted\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "fb03a02efa09e3e9d870a0405b99a96238ee91dd", "filename": "src/test/ui/closures/2229_closure_analysis/deep-multilevel-tuple.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdeep-multilevel-tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdeep-multilevel-tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdeep-multilevel-tuple.rs?ref=0e190206e2ff0c13d64701d9b4145bf89a2d0cab", "patch": "@@ -0,0 +1,27 @@\n+#![feature(capture_disjoint_fields)]\n+//~^ WARNING: the feature `capture_disjoint_fields` is incomplete\n+//~| NOTE: `#[warn(incomplete_features)]` on by default\n+//~| NOTE: see issue #53488 <https://github.com/rust-lang/rust/issues/53488>\n+#![feature(rustc_attrs)]\n+#![allow(unused)]\n+\n+fn main() {\n+    let mut t = (((1,2),(3,4)),((5,6),(7,8)));\n+\n+    let c = #[rustc_capture_analysis]\n+    //~^ ERROR: attributes on expressions are experimental\n+    //~| NOTE: see issue #15701 <https://github.com/rust-lang/rust/issues/15701>\n+    || {\n+    //~^ ERROR: First Pass analysis includes:\n+    //~| ERROR: Min Capture analysis includes:\n+        let x = &t.0.0.0;\n+        //~^ NOTE: Capturing t[(0, 0),(0, 0),(0, 0)] -> ImmBorrow\n+        t.1.1.1 = 9;\n+        //~^ NOTE: Capturing t[(1, 0),(1, 0),(1, 0)] -> MutBorrow\n+        //~| NOTE: t[] captured as MutBorrow here\n+        println!(\"{:?}\", t);\n+        //~^ NOTE: Min Capture t[] -> MutBorrow\n+        //~| NOTE: Capturing t[] -> ImmBorrow\n+        //~| NOTE: t[] used here\n+    };\n+}"}, {"sha": "252db4447322288f64432a7c238b414d5dd2df36", "filename": "src/test/ui/closures/2229_closure_analysis/deep-multilevel-tuple.stderr", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdeep-multilevel-tuple.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdeep-multilevel-tuple.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdeep-multilevel-tuple.stderr?ref=0e190206e2ff0c13d64701d9b4145bf89a2d0cab", "patch": "@@ -0,0 +1,70 @@\n+error[E0658]: attributes on expressions are experimental\n+  --> $DIR/deep-multilevel-tuple.rs:11:13\n+   |\n+LL |     let c = #[rustc_capture_analysis]\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #15701 <https://github.com/rust-lang/rust/issues/15701> for more information\n+   = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n+\n+warning: the feature `capture_disjoint_fields` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/deep-multilevel-tuple.rs:1:12\n+   |\n+LL | #![feature(capture_disjoint_fields)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n+\n+error: First Pass analysis includes:\n+  --> $DIR/deep-multilevel-tuple.rs:14:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |\n+LL | |         let x = &t.0.0.0;\n+...  |\n+LL | |\n+LL | |     };\n+   | |_____^\n+   |\n+note: Capturing t[(0, 0),(0, 0),(0, 0)] -> ImmBorrow\n+  --> $DIR/deep-multilevel-tuple.rs:17:18\n+   |\n+LL |         let x = &t.0.0.0;\n+   |                  ^^^^^^^\n+note: Capturing t[(1, 0),(1, 0),(1, 0)] -> MutBorrow\n+  --> $DIR/deep-multilevel-tuple.rs:19:9\n+   |\n+LL |         t.1.1.1 = 9;\n+   |         ^^^^^^^\n+note: Capturing t[] -> ImmBorrow\n+  --> $DIR/deep-multilevel-tuple.rs:22:26\n+   |\n+LL |         println!(\"{:?}\", t);\n+   |                          ^\n+\n+error: Min Capture analysis includes:\n+  --> $DIR/deep-multilevel-tuple.rs:14:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |\n+LL | |         let x = &t.0.0.0;\n+...  |\n+LL | |\n+LL | |     };\n+   | |_____^\n+   |\n+note: Min Capture t[] -> MutBorrow\n+  --> $DIR/deep-multilevel-tuple.rs:19:9\n+   |\n+LL |         t.1.1.1 = 9;\n+   |         ^^^^^^^ t[] captured as MutBorrow here\n+...\n+LL |         println!(\"{:?}\", t);\n+   |                          ^ t[] used here\n+\n+error: aborting due to 3 previous errors; 1 warning emitted\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "a6b5e12d2ed78e4d6f562d00794764af78f67f10", "filename": "src/test/ui/closures/2229_closure_analysis/simple-struct-min-capture.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fsimple-struct-min-capture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fsimple-struct-min-capture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fsimple-struct-min-capture.rs?ref=0e190206e2ff0c13d64701d9b4145bf89a2d0cab", "patch": "@@ -32,9 +32,11 @@ fn main() {\n     //~| ERROR: Min Capture analysis includes:\n         p.x += 10;\n         //~^ NOTE: Capturing p[(0, 0)] -> MutBorrow\n-        //~| NOTE: Min Capture p[] -> MutBorrow\n+        //~| NOTE: p[] captured as MutBorrow here\n         println!(\"{:?}\", p);\n         //~^ NOTE: Capturing p[] -> ImmBorrow\n+        //~| NOTE: Min Capture p[] -> MutBorrow\n+        //~| NOTE: p[] used here\n     };\n \n     c();"}, {"sha": "cbbc8792199153639bdd13bb1074e16e5b299074", "filename": "src/test/ui/closures/2229_closure_analysis/simple-struct-min-capture.stderr", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fsimple-struct-min-capture.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fsimple-struct-min-capture.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fsimple-struct-min-capture.stderr?ref=0e190206e2ff0c13d64701d9b4145bf89a2d0cab", "patch": "@@ -55,7 +55,10 @@ note: Min Capture p[] -> MutBorrow\n   --> $DIR/simple-struct-min-capture.rs:33:9\n    |\n LL |         p.x += 10;\n-   |         ^^^\n+   |         ^^^ p[] captured as MutBorrow here\n+...\n+LL |         println!(\"{:?}\", p);\n+   |                          ^ p[] used here\n \n error: aborting due to 3 previous errors; 1 warning emitted\n "}, {"sha": "4a4fd1e33117fad6f70249b47f648eaf2dbd9c1e", "filename": "src/test/ui/const-generics/const_evaluatable_checked/elaborate-trait-pred.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Felaborate-trait-pred.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Felaborate-trait-pred.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Felaborate-trait-pred.rs?ref=0e190206e2ff0c13d64701d9b4145bf89a2d0cab", "patch": "@@ -0,0 +1,24 @@\n+// run-pass\n+// Test that we use the elaborated predicates from traits\n+// to satisfy const evaluatable predicates.\n+#![feature(const_generics, const_evaluatable_checked)]\n+#![allow(incomplete_features)]\n+use std::mem::size_of;\n+\n+trait Foo: Sized\n+where\n+    [(); size_of::<Self>()]: Sized,\n+{\n+}\n+\n+impl Foo for u64 {}\n+impl Foo for u32 {}\n+\n+fn foo<T: Foo>() -> [u8; size_of::<T>()] {\n+    [0; size_of::<T>()]\n+}\n+\n+fn main() {\n+    assert_eq!(foo::<u32>(), [0; 4]);\n+    assert_eq!(foo::<u64>(), [0; 8]);\n+}"}, {"sha": "0fe84c1cd2a7225cdc2f6d601436fadd8ca58033", "filename": "src/test/ui/const-generics/const_evaluatable_checked/nested-abstract-consts-1.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fnested-abstract-consts-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fnested-abstract-consts-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fnested-abstract-consts-1.rs?ref=0e190206e2ff0c13d64701d9b4145bf89a2d0cab", "patch": "@@ -0,0 +1,24 @@\n+// run-pass\n+#![feature(const_generics, const_evaluatable_checked)]\n+#![allow(incomplete_features)]\n+\n+fn callee<const M2: usize>() -> usize\n+where\n+    [u8; M2 + 1]: Sized,\n+{\n+    M2\n+}\n+\n+fn caller<const N1: usize>() -> usize\n+where\n+    [u8; N1 + 1]: Sized,\n+    [u8; (N1 + 1) + 1]: Sized,\n+{\n+    callee::<{ N1 + 1 }>()\n+}\n+\n+fn main() {\n+    assert_eq!(caller::<4>(), 5);\n+}\n+\n+// Test that the ``(N1 + 1) + 1`` bound on ``caller`` satisfies the ``M2 + 1`` bound on ``callee``"}, {"sha": "4f588238e23ffb458ec33950a20d85c1295c519f", "filename": "src/test/ui/const-generics/const_evaluatable_checked/nested-abstract-consts-2.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fnested-abstract-consts-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fnested-abstract-consts-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fnested-abstract-consts-2.rs?ref=0e190206e2ff0c13d64701d9b4145bf89a2d0cab", "patch": "@@ -0,0 +1,35 @@\n+// run-pass\n+#![feature(const_evaluatable_checked, const_generics)]\n+#![allow(incomplete_features)]\n+\n+struct Generic<const K: u64>;\n+\n+struct ConstU64<const K: u64>;\n+\n+impl<const K: u64> Generic<K>\n+where\n+    ConstU64<{ K - 1 }>: ,\n+{\n+    fn foo(self) -> u64 {\n+        K\n+    }\n+}\n+\n+impl<const K: u64> Generic<K>\n+where\n+    ConstU64<{ K - 1 }>: ,\n+    ConstU64<{ K + 1 }>: ,\n+    ConstU64<{ K + 1 - 1 }>: ,\n+{\n+    fn bar(self) -> u64 {\n+        let x: Generic<{ K + 1 }> = Generic;\n+        x.foo()\n+    }\n+}\n+\n+fn main() {\n+    assert_eq!((Generic::<10>).bar(), 11);\n+}\n+\n+// Test that the ``ConstU64<{ K + 1 - 1}>`` bound on ``bar``'s impl block satisfies the\n+// ``ConstU64<{K - 1}>`` bound on ``foo``'s impl block"}, {"sha": "1428f774b0d70f14919d236462c686d3e2920435", "filename": "src/test/ui/const-generics/const_evaluatable_checked/nested_uneval_unification-1.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fnested_uneval_unification-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fnested_uneval_unification-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fnested_uneval_unification-1.rs?ref=0e190206e2ff0c13d64701d9b4145bf89a2d0cab", "patch": "@@ -0,0 +1,35 @@\n+// run-pass\n+#![feature(const_generics, const_evaluatable_checked)]\n+#![allow(incomplete_features)]\n+\n+fn zero_init<const N: usize>() -> Substs1<N>\n+where\n+    [u8; N + 1]: ,\n+{\n+    Substs1([0; N + 1])\n+}\n+struct Substs1<const N: usize>([u8; N + 1])\n+where\n+    [(); N + 1]: ;\n+\n+fn substs2<const M: usize>() -> Substs1<{ M * 2 }>\n+where\n+    [(); { M * 2 } + 1]: ,\n+{\n+    zero_init::<{ M * 2 }>()\n+}\n+\n+fn substs3<const L: usize>() -> Substs1<{ (L - 1) * 2 }>\n+where\n+    [(); (L - 1)]: ,\n+    [(); (L - 1) * 2 + 1]: ,\n+{\n+    substs2::<{ L - 1 }>()\n+}\n+\n+fn main() {\n+    assert_eq!(substs3::<2>().0, [0; 3]);\n+}\n+\n+// Test that the ``{ (L - 1) * 2 + 1 }`` bound on ``substs3`` satisfies the\n+// ``{ N + 1 }`` bound on ``Substs1``"}, {"sha": "be8219a7446692589f422f0d1284f5a11fcd2bdd", "filename": "src/test/ui/const-generics/const_evaluatable_checked/nested_uneval_unification-2.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fnested_uneval_unification-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fnested_uneval_unification-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fnested_uneval_unification-2.rs?ref=0e190206e2ff0c13d64701d9b4145bf89a2d0cab", "patch": "@@ -0,0 +1,29 @@\n+// run-pass\n+#![feature(const_generics, const_evaluatable_checked)]\n+#![allow(incomplete_features, unused_parens, unused_braces)]\n+\n+fn zero_init<const N: usize>() -> Substs1<{ (N) }>\n+where\n+    [u8; { (N) }]: ,\n+{\n+    Substs1([0; { (N) }])\n+}\n+\n+struct Substs1<const N: usize>([u8; { (N) }])\n+where\n+    [(); { (N) }]: ;\n+\n+fn substs2<const M: usize>() -> Substs1<{ (M) }> {\n+    zero_init::<{ (M) }>()\n+}\n+\n+fn substs3<const L: usize>() -> Substs1<{ (L) }> {\n+    substs2::<{ (L) }>()\n+}\n+\n+fn main() {\n+    assert_eq!(substs3::<2>().0, [0; 2]);\n+}\n+\n+// Test that the implicit ``{ (L) }`` bound on ``substs3`` satisfies the\n+// ``{ (N) }`` bound on ``Substs1``"}, {"sha": "acf0a52ce5be1462359f10500e32ec9378675590", "filename": "src/test/ui/const-generics/const_evaluatable_checked/simple_fail.full.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fsimple_fail.full.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fsimple_fail.full.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fsimple_fail.full.stderr?ref=0e190206e2ff0c13d64701d9b4145bf89a2d0cab", "patch": "@@ -1,9 +1,15 @@\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/simple_fail.rs:9:48\n+   |\n+LL | fn test<const N: usize>() -> Arr<N> where [u8; N - 1]: Sized {\n+   |                                                ^^^^^ attempt to compute `0_usize - 1_usize`, which would overflow\n+\n error[E0080]: evaluation of constant value failed\n   --> $DIR/simple_fail.rs:6:33\n    |\n LL | type Arr<const N: usize> = [u8; N - 1];\n    |                                 ^^^^^ attempt to compute `0_usize - 1_usize`, which would overflow\n \n-error: aborting due to previous error\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0080`."}, {"sha": "fe5463f8acc4a8ad264388ff3d99dbe1852d448a", "filename": "src/test/ui/const-generics/const_evaluatable_checked/simple_fail.min.stderr", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fsimple_fail.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fsimple_fail.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fsimple_fail.min.stderr?ref=0e190206e2ff0c13d64701d9b4145bf89a2d0cab", "patch": "@@ -7,5 +7,14 @@ LL | type Arr<const N: usize> = [u8; N - 1];\n    = help: const parameters may only be used as standalone arguments, i.e. `N`\n    = help: use `#![feature(const_generics)]` and `#![feature(const_evaluatable_checked)]` to allow generic const expressions\n \n-error: aborting due to previous error\n+error: generic parameters may not be used in const operations\n+  --> $DIR/simple_fail.rs:9:48\n+   |\n+LL | fn test<const N: usize>() -> Arr<N> where [u8; N - 1]: Sized {\n+   |                                                ^ cannot perform const operation using `N`\n+   |\n+   = help: const parameters may only be used as standalone arguments, i.e. `N`\n+   = help: use `#![feature(const_generics)]` and `#![feature(const_evaluatable_checked)]` to allow generic const expressions\n+\n+error: aborting due to 2 previous errors\n "}, {"sha": "c9535d04244d86fa61e74027289f7496313cf40b", "filename": "src/test/ui/const-generics/const_evaluatable_checked/simple_fail.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fsimple_fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fsimple_fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fsimple_fail.rs?ref=0e190206e2ff0c13d64701d9b4145bf89a2d0cab", "patch": "@@ -1,12 +1,14 @@\n // revisions: full min\n #![cfg_attr(full, feature(const_generics))]\n-#![feature(const_evaluatable_checked)]\n+#![cfg_attr(full, feature(const_evaluatable_checked))]\n #![allow(incomplete_features)]\n \n type Arr<const N: usize> = [u8; N - 1]; //[full]~ ERROR evaluation of constant\n //[min]~^ ERROR generic parameters may not be used in const operations\n \n-fn test<const N: usize>() -> Arr<N> where Arr<N>: Sized {\n+fn test<const N: usize>() -> Arr<N> where [u8; N - 1]: Sized {\n+//[min]~^ ERROR generic parameters may not be used in const operations\n+//[full]~^^ ERROR evaluation of constant\n     todo!()\n }\n "}, {"sha": "5c768a61be25e1e8d6b56c8976ca955d3f8e65e6", "filename": "src/test/ui/const-generics/const_evaluatable_checked/ty-alias-substitution.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fty-alias-substitution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fty-alias-substitution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fty-alias-substitution.rs?ref=0e190206e2ff0c13d64701d9b4145bf89a2d0cab", "patch": "@@ -0,0 +1,14 @@\n+// check-pass\n+// Test that we correctly substitute generic arguments for type aliases.\n+#![feature(const_generics, const_evaluatable_checked)]\n+#![allow(incomplete_features)]\n+\n+type Alias<T, const N: usize> = [T; N + 1];\n+\n+fn foo<const M: usize>() -> Alias<u32, M>  where [u8; M + 1]: Sized {\n+    [0; M + 1]\n+}\n+\n+fn main() {\n+    foo::<0>();\n+}"}, {"sha": "8a83e145ea2d024a943b692d4eabf29c620eac06", "filename": "src/test/ui/destructuring-assignment/struct_destructure_fail.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fstruct_destructure_fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fstruct_destructure_fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fstruct_destructure_fail.stderr?ref=0e190206e2ff0c13d64701d9b4145bf89a2d0cab", "patch": "@@ -32,12 +32,12 @@ LL |     Struct { a, _ } = Struct { a: 1, b: 2 };\n    |\n help: include the missing field in the pattern\n    |\n-LL |     Struct { a, b _ } = Struct { a: 1, b: 2 };\n-   |               ^^^\n+LL |     Struct { a, b } = Struct { a: 1, b: 2 };\n+   |               ^^^^^\n help: if you don't care about this missing field, you can explicitly ignore it\n    |\n-LL |     Struct { a, .. _ } = Struct { a: 1, b: 2 };\n-   |               ^^^^\n+LL |     Struct { a, .. } = Struct { a: 1, b: 2 };\n+   |               ^^^^^^\n \n error: aborting due to 5 previous errors\n "}, {"sha": "a3dd6910be4a5209c2f3c39d44a4b0f9a93e32e6", "filename": "src/test/ui/error-codes/E0027.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/src%2Ftest%2Fui%2Ferror-codes%2FE0027.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/src%2Ftest%2Fui%2Ferror-codes%2FE0027.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0027.stderr?ref=0e190206e2ff0c13d64701d9b4145bf89a2d0cab", "patch": "@@ -7,11 +7,11 @@ LL |         Dog { age: x } => {}\n help: include the missing field in the pattern\n    |\n LL |         Dog { age: x, name } => {}\n-   |                     ^^^^^^\n+   |                     ^^^^^^^^\n help: if you don't care about this missing field, you can explicitly ignore it\n    |\n LL |         Dog { age: x, .. } => {}\n-   |                     ^^^^\n+   |                     ^^^^^^\n \n error[E0027]: pattern does not mention field `age`\n   --> $DIR/E0027.rs:15:9\n@@ -22,11 +22,11 @@ LL |         Dog { name: x, } => {}\n help: include the missing field in the pattern\n    |\n LL |         Dog { name: x, age } => {}\n-   |                      ^^^^^\n+   |                      ^^^^^^^\n help: if you don't care about this missing field, you can explicitly ignore it\n    |\n LL |         Dog { name: x, .. } => {}\n-   |                      ^^^^\n+   |                      ^^^^^^\n \n error[E0027]: pattern does not mention field `age`\n   --> $DIR/E0027.rs:19:9\n@@ -37,11 +37,11 @@ LL |         Dog { name: x  , } => {}\n help: include the missing field in the pattern\n    |\n LL |         Dog { name: x, age } => {}\n-   |                      ^^^^^\n+   |                      ^^^^^^^\n help: if you don't care about this missing field, you can explicitly ignore it\n    |\n LL |         Dog { name: x, .. } => {}\n-   |                      ^^^^\n+   |                      ^^^^^^\n \n error[E0027]: pattern does not mention fields `name`, `age`\n   --> $DIR/E0027.rs:22:9"}, {"sha": "c1a95636d34cb0040ca34d207cfe697d0380217f", "filename": "src/test/ui/structs/struct-pat-derived-error.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/src%2Ftest%2Fui%2Fstructs%2Fstruct-pat-derived-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/src%2Ftest%2Fui%2Fstructs%2Fstruct-pat-derived-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstructs%2Fstruct-pat-derived-error.stderr?ref=0e190206e2ff0c13d64701d9b4145bf89a2d0cab", "patch": "@@ -19,11 +19,11 @@ LL |         let A { x, y } = self.d;\n help: include the missing fields in the pattern\n    |\n LL |         let A { x, y, b, c } = self.d;\n-   |                     ^^^^^^\n+   |                     ^^^^^^^^\n help: if you don't care about these missing fields, you can explicitly ignore them\n    |\n LL |         let A { x, y, .. } = self.d;\n-   |                     ^^^^\n+   |                     ^^^^^^\n \n error: aborting due to 3 previous errors\n "}, {"sha": "c3abcfe8a75901c7c701557a728941e8fb19399e", "filename": "src/tools/cargo", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcargo?ref=0e190206e2ff0c13d64701d9b4145bf89a2d0cab", "patch": "@@ -1 +1 @@\n-Subproject commit 783bc43c660bf39c1e562c8c429b32078ad3099b\n+Subproject commit c3abcfe8a75901c7c701557a728941e8fb19399e"}, {"sha": "ac9098a7584d6d6985a02d9d2f7c931e27d5185e", "filename": "src/tools/clippy/clippy_lints/src/bytecount.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbytecount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbytecount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbytecount.rs?ref=0e190206e2ff0c13d64701d9b4145bf89a2d0cab", "patch": "@@ -2,11 +2,10 @@ use crate::utils::{\n     contains_name, get_pat_name, match_type, paths, single_segment_path, snippet_with_applicability, span_lint_and_sugg,\n };\n use if_chain::if_chain;\n-use rustc_ast::ast::UintTy;\n use rustc_errors::Applicability;\n use rustc_hir::{BinOpKind, BorrowKind, Expr, ExprKind, UnOp};\n use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty;\n+use rustc_middle::ty::{self, UintTy};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::sym;\n use rustc_span::Symbol;"}, {"sha": "640cffd24a701d52a006f088726459a07358d3c1", "filename": "src/tools/clippy/clippy_lints/src/consts.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fconsts.rs?ref=0e190206e2ff0c13d64701d9b4145bf89a2d0cab", "patch": "@@ -2,14 +2,14 @@\n \n use crate::utils::{clip, sext, unsext};\n use if_chain::if_chain;\n-use rustc_ast::ast::{FloatTy, LitFloatType, LitKind};\n+use rustc_ast::ast::{self, LitFloatType, LitKind};\n use rustc_data_structures::sync::Lrc;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::{BinOp, BinOpKind, Block, Expr, ExprKind, HirId, QPath, UnOp};\n use rustc_lint::LateContext;\n use rustc_middle::mir::interpret::Scalar;\n use rustc_middle::ty::subst::{Subst, SubstsRef};\n-use rustc_middle::ty::{self, ScalarInt, Ty, TyCtxt};\n+use rustc_middle::ty::{self, FloatTy, ScalarInt, Ty, TyCtxt};\n use rustc_middle::{bug, span_bug};\n use rustc_span::symbol::Symbol;\n use std::cmp::Ordering::{self, Equal};\n@@ -167,8 +167,8 @@ pub fn lit_to_constant(lit: &LitKind, ty: Option<Ty<'_>>) -> Constant {\n         LitKind::Char(c) => Constant::Char(c),\n         LitKind::Int(n, _) => Constant::Int(n),\n         LitKind::Float(ref is, LitFloatType::Suffixed(fty)) => match fty {\n-            FloatTy::F32 => Constant::F32(is.as_str().parse().unwrap()),\n-            FloatTy::F64 => Constant::F64(is.as_str().parse().unwrap()),\n+            ast::FloatTy::F32 => Constant::F32(is.as_str().parse().unwrap()),\n+            ast::FloatTy::F64 => Constant::F64(is.as_str().parse().unwrap()),\n         },\n         LitKind::Float(ref is, LitFloatType::Unsuffixed) => match ty.expect(\"type of float is known\").kind() {\n             ty::Float(FloatTy::F32) => Constant::F32(is.as_str().parse().unwrap()),"}, {"sha": "ae56a8ba5ab4b4056a6a2dd9f8764e952a7fa54a", "filename": "src/tools/clippy/clippy_lints/src/enum_clike.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fenum_clike.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fenum_clike.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fenum_clike.rs?ref=0e190206e2ff0c13d64701d9b4145bf89a2d0cab", "patch": "@@ -3,10 +3,9 @@\n \n use crate::consts::{miri_to_const, Constant};\n use crate::utils::span_lint;\n-use rustc_ast::ast::{IntTy, UintTy};\n use rustc_hir::{Item, ItemKind};\n use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty;\n+use rustc_middle::ty::{self, IntTy, UintTy};\n use rustc_middle::ty::util::IntTypeExt;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use std::convert::TryFrom;"}, {"sha": "527905e375d287b014502236a71fc09667961f55", "filename": "src/tools/clippy/clippy_lints/src/fallible_impl_from.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffallible_impl_from.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffallible_impl_from.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffallible_impl_from.rs?ref=0e190206e2ff0c13d64701d9b4145bf89a2d0cab", "patch": "@@ -1,7 +1,4 @@\n-use crate::utils::paths::FROM_TRAIT;\n-use crate::utils::{\n-    is_expn_of, is_type_diagnostic_item, match_def_path, match_panic_def_id, method_chain_args, span_lint_and_then,\n-};\n+use crate::utils::{is_expn_of, is_type_diagnostic_item, match_panic_def_id, method_chain_args, span_lint_and_then};\n use if_chain::if_chain;\n use rustc_hir as hir;\n use rustc_lint::{LateContext, LateLintPass};\n@@ -59,7 +56,7 @@ impl<'tcx> LateLintPass<'tcx> for FallibleImplFrom {\n         if_chain! {\n             if let hir::ItemKind::Impl(impl_) = &item.kind;\n             if let Some(impl_trait_ref) = cx.tcx.impl_trait_ref(impl_def_id);\n-            if match_def_path(cx, impl_trait_ref.def_id, &FROM_TRAIT);\n+            if cx.tcx.is_diagnostic_item(sym::from_trait, impl_trait_ref.def_id);\n             then {\n                 lint_impl_body(cx, item.span, impl_.items);\n             }"}, {"sha": "be646cbe4d043659bed1a879e8e3f07836090feb", "filename": "src/tools/clippy/clippy_lints/src/float_literal.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffloat_literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffloat_literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffloat_literal.rs?ref=0e190206e2ff0c13d64701d9b4145bf89a2d0cab", "patch": "@@ -1,10 +1,10 @@\n use crate::utils::{numeric_literal, span_lint_and_sugg};\n use if_chain::if_chain;\n-use rustc_ast::ast::{FloatTy, LitFloatType, LitKind};\n+use rustc_ast::ast::{self, LitFloatType, LitKind};\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty;\n+use rustc_middle::ty::{self, FloatTy};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use std::fmt;\n \n@@ -75,8 +75,8 @@ impl<'tcx> LateLintPass<'tcx> for FloatLiteral {\n                 let digits = count_digits(&sym_str);\n                 let max = max_digits(fty);\n                 let type_suffix = match lit_float_ty {\n-                    LitFloatType::Suffixed(FloatTy::F32) => Some(\"f32\"),\n-                    LitFloatType::Suffixed(FloatTy::F64) => Some(\"f64\"),\n+                    LitFloatType::Suffixed(ast::FloatTy::F32) => Some(\"f32\"),\n+                    LitFloatType::Suffixed(ast::FloatTy::F64) => Some(\"f64\"),\n                     LitFloatType::Unsuffixed => None\n                 };\n                 let (is_whole, mut float_str) = match fty {"}, {"sha": "40b236493a3135722fe1ded68054f20ca462a7d9", "filename": "src/tools/clippy/clippy_lints/src/mutex_atomic.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmutex_atomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmutex_atomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmutex_atomic.rs?ref=0e190206e2ff0c13d64701d9b4145bf89a2d0cab", "patch": "@@ -3,7 +3,6 @@\n //! This lint is **warn** by default\n \n use crate::utils::{is_type_diagnostic_item, span_lint};\n-use rustc_ast::ast;\n use rustc_hir::Expr;\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty::{self, Ty};\n@@ -77,8 +76,8 @@ impl<'tcx> LateLintPass<'tcx> for Mutex {\n                         atomic_name\n                     );\n                     match *mutex_param.kind() {\n-                        ty::Uint(t) if t != ast::UintTy::Usize => span_lint(cx, MUTEX_INTEGER, expr.span, &msg),\n-                        ty::Int(t) if t != ast::IntTy::Isize => span_lint(cx, MUTEX_INTEGER, expr.span, &msg),\n+                        ty::Uint(t) if t != ty::UintTy::Usize => span_lint(cx, MUTEX_INTEGER, expr.span, &msg),\n+                        ty::Int(t) if t != ty::IntTy::Isize => span_lint(cx, MUTEX_INTEGER, expr.span, &msg),\n                         _ => span_lint(cx, MUTEX_ATOMIC, expr.span, &msg),\n                     };\n                 }"}, {"sha": "d977cea4da50b6427653d07a59af1ade1686b46e", "filename": "src/tools/clippy/clippy_lints/src/transmute.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute.rs?ref=0e190206e2ff0c13d64701d9b4145bf89a2d0cab", "patch": "@@ -443,7 +443,7 @@ impl<'tcx> LateLintPass<'tcx> for Transmute {\n                             );\n                         },\n                     ),\n-                    (ty::Int(ast::IntTy::I32) | ty::Uint(ast::UintTy::U32), &ty::Char) => {\n+                    (ty::Int(ty::IntTy::I32) | ty::Uint(ty::UintTy::U32), &ty::Char) => {\n                         span_lint_and_then(\n                             cx,\n                             TRANSMUTE_INT_TO_CHAR,\n@@ -468,7 +468,7 @@ impl<'tcx> LateLintPass<'tcx> for Transmute {\n                     (ty::Ref(_, ty_from, from_mutbl), ty::Ref(_, ty_to, to_mutbl)) => {\n                         if_chain! {\n                             if let (&ty::Slice(slice_ty), &ty::Str) = (&ty_from.kind(), &ty_to.kind());\n-                            if let ty::Uint(ast::UintTy::U8) = slice_ty.kind();\n+                            if let ty::Uint(ty::UintTy::U8) = slice_ty.kind();\n                             if from_mutbl == to_mutbl;\n                             then {\n                                 let postfix = if *from_mutbl == Mutability::Mut {\n@@ -536,7 +536,7 @@ impl<'tcx> LateLintPass<'tcx> for Transmute {\n                             }\n                         },\n                     ),\n-                    (ty::Int(ast::IntTy::I8) | ty::Uint(ast::UintTy::U8), ty::Bool) => {\n+                    (ty::Int(ty::IntTy::I8) | ty::Uint(ty::UintTy::U8), ty::Bool) => {\n                         span_lint_and_then(\n                             cx,\n                             TRANSMUTE_INT_TO_BOOL,"}, {"sha": "17cef0af3e9c9e257f0b6cde1852d41cf7c7957f", "filename": "src/tools/clippy/clippy_lints/src/types.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes.rs?ref=0e190206e2ff0c13d64701d9b4145bf89a2d0cab", "patch": "@@ -5,7 +5,7 @@ use std::cmp::Ordering;\n use std::collections::BTreeMap;\n \n use if_chain::if_chain;\n-use rustc_ast::{FloatTy, IntTy, LitFloatType, LitIntType, LitKind, UintTy};\n+use rustc_ast::{LitFloatType, LitIntType, LitKind};\n use rustc_errors::{Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n use rustc_hir::intravisit::{walk_body, walk_expr, walk_ty, FnKind, NestedVisitorMap, Visitor};\n@@ -18,7 +18,7 @@ use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::hir::map::Map;\n use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::TypeFoldable;\n-use rustc_middle::ty::{self, InferTy, Ty, TyCtxt, TyS, TypeAndMut, TypeckResults};\n+use rustc_middle::ty::{self, FloatTy, InferTy, IntTy, Ty, TyCtxt, TyS, TypeAndMut, TypeckResults, UintTy};\n use rustc_semver::RustcVersion;\n use rustc_session::{declare_lint_pass, declare_tool_lint, impl_lint_pass};\n use rustc_span::hygiene::{ExpnKind, MacroKind};\n@@ -1106,9 +1106,7 @@ fn is_empty_block(expr: &Expr<'_>) -> bool {\n         expr.kind,\n         ExprKind::Block(\n             Block {\n-                stmts: &[],\n-                expr: None,\n-                ..\n+                stmts: &[], expr: None, ..\n             },\n             _,\n         )"}, {"sha": "46b2b06d1a280d151f639fd9d21cd326ee634de2", "filename": "src/tools/clippy/clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=0e190206e2ff0c13d64701d9b4145bf89a2d0cab", "patch": "@@ -35,7 +35,6 @@ use std::mem;\n \n use if_chain::if_chain;\n use rustc_ast::ast::{self, Attribute, LitKind};\n-use rustc_attr as attr;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n@@ -1224,27 +1223,27 @@ pub fn get_arg_name(pat: &Pat<'_>) -> Option<Symbol> {\n     }\n }\n \n-pub fn int_bits(tcx: TyCtxt<'_>, ity: ast::IntTy) -> u64 {\n-    Integer::from_attr(&tcx, attr::IntType::SignedInt(ity)).size().bits()\n+pub fn int_bits(tcx: TyCtxt<'_>, ity: ty::IntTy) -> u64 {\n+    Integer::from_int_ty(&tcx, ity).size().bits()\n }\n \n #[allow(clippy::cast_possible_wrap)]\n /// Turn a constant int byte representation into an i128\n-pub fn sext(tcx: TyCtxt<'_>, u: u128, ity: ast::IntTy) -> i128 {\n+pub fn sext(tcx: TyCtxt<'_>, u: u128, ity: ty::IntTy) -> i128 {\n     let amt = 128 - int_bits(tcx, ity);\n     ((u as i128) << amt) >> amt\n }\n \n #[allow(clippy::cast_sign_loss)]\n /// clip unused bytes\n-pub fn unsext(tcx: TyCtxt<'_>, u: i128, ity: ast::IntTy) -> u128 {\n+pub fn unsext(tcx: TyCtxt<'_>, u: i128, ity: ty::IntTy) -> u128 {\n     let amt = 128 - int_bits(tcx, ity);\n     ((u as u128) << amt) >> amt\n }\n \n /// clip unused bytes\n-pub fn clip(tcx: TyCtxt<'_>, u: u128, ity: ast::UintTy) -> u128 {\n-    let bits = Integer::from_attr(&tcx, attr::IntType::UnsignedInt(ity)).size().bits();\n+pub fn clip(tcx: TyCtxt<'_>, u: u128, ity: ty::UintTy) -> u128 {\n+    let bits = Integer::from_uint_ty(&tcx, ity).size().bits();\n     let amt = 128 - bits;\n     (u << amt) >> amt\n }"}, {"sha": "432cc5b59f684ddac760861f8ab4906746de5fb3", "filename": "src/tools/clippy/clippy_lints/src/utils/paths.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fpaths.rs?ref=0e190206e2ff0c13d64701d9b4145bf89a2d0cab", "patch": "@@ -48,7 +48,6 @@ pub const FN_MUT: [&str; 3] = [\"core\", \"ops\", \"FnMut\"];\n pub const FN_ONCE: [&str; 3] = [\"core\", \"ops\", \"FnOnce\"];\n pub const FROM_FROM: [&str; 4] = [\"core\", \"convert\", \"From\", \"from\"];\n pub const FROM_ITERATOR: [&str; 5] = [\"core\", \"iter\", \"traits\", \"collect\", \"FromIterator\"];\n-pub const FROM_TRAIT: [&str; 3] = [\"core\", \"convert\", \"From\"];\n pub const FUTURE_FROM_GENERATOR: [&str; 3] = [\"core\", \"future\", \"from_generator\"];\n pub const HASH: [&str; 3] = [\"core\", \"hash\", \"Hash\"];\n pub const HASHMAP: [&str; 5] = [\"std\", \"collections\", \"hash\", \"map\", \"HashMap\"];"}, {"sha": "c8e767432310a8c7168c17e18f594b3db4580b7c", "filename": "src/tools/compiletest/src/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs?ref=0e190206e2ff0c13d64701d9b4145bf89a2d0cab", "patch": "@@ -174,7 +174,7 @@ impl fmt::Display for Debugger {\n /// Configuration for compiletest\n #[derive(Debug, Clone)]\n pub struct Config {\n-    /// `true` to to overwrite stderr/stdout files instead of complaining about changes in output.\n+    /// `true` to overwrite stderr/stdout files instead of complaining about changes in output.\n     pub bless: bool,\n \n     /// The library paths required for running the compiler."}, {"sha": "663027173ff9d442857f96f92c5189ab03eb299c", "filename": "src/tools/compiletest/src/util/tests.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/src%2Ftools%2Fcompiletest%2Fsrc%2Futil%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e190206e2ff0c13d64701d9b4145bf89a2d0cab/src%2Ftools%2Fcompiletest%2Fsrc%2Futil%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Futil%2Ftests.rs?ref=0e190206e2ff0c13d64701d9b4145bf89a2d0cab", "patch": "@@ -30,3 +30,22 @@ fn test_matches_os() {\n     assert!(matches_os(\"nvptx64-nvidia-cuda\", \"cuda\"));\n     assert!(matches_os(\"x86_64-fortanix-unknown-sgx\", \"sgx\"));\n }\n+\n+#[test]\n+fn is_big_endian_test() {\n+    assert!(!is_big_endian(\"no\"));\n+    assert!(is_big_endian(\"sparc-unknown-unknown\"));\n+}\n+\n+#[test]\n+fn path_buf_with_extra_extension_test() {\n+    assert_eq!(\n+        PathBuf::from(\"foo.rs.stderr\"),\n+        PathBuf::from(\"foo.rs\").with_extra_extension(\"stderr\")\n+    );\n+    assert_eq!(\n+        PathBuf::from(\"foo.rs.stderr\"),\n+        PathBuf::from(\"foo.rs\").with_extra_extension(\".stderr\")\n+    );\n+    assert_eq!(PathBuf::from(\"foo.rs\"), PathBuf::from(\"foo.rs\").with_extra_extension(\"\"));\n+}"}]}