{"sha": "20454da2db9903688dfd60b826cc704de79767bc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIwNDU0ZGEyZGI5OTAzNjg4ZGZkNjBiODI2Y2M3MDRkZTc5NzY3YmM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-28T07:19:21Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-28T07:19:21Z"}, "message": "auto merge of #8069 : erickt/rust/maikklein, r=erickt\n\nGood evening,\r\n\r\nThis is a superset of @MaikKlein's #7969 commit, that I've fixed up to compile. I had a couple commits I wanted to do on top of @MaikKlein's work that I didn't want to bitrot.", "tree": {"sha": "a20efcf40ca3c0473aca0b8c42383cd0bcf65ce1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a20efcf40ca3c0473aca0b8c42383cd0bcf65ce1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/20454da2db9903688dfd60b826cc704de79767bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/20454da2db9903688dfd60b826cc704de79767bc", "html_url": "https://github.com/rust-lang/rust/commit/20454da2db9903688dfd60b826cc704de79767bc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/20454da2db9903688dfd60b826cc704de79767bc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9325535b41fa5a7cfac697e86ae86bd1384542e6", "url": "https://api.github.com/repos/rust-lang/rust/commits/9325535b41fa5a7cfac697e86ae86bd1384542e6", "html_url": "https://github.com/rust-lang/rust/commit/9325535b41fa5a7cfac697e86ae86bd1384542e6"}, {"sha": "b147d70b08f93ea0a13a5331f413d547819b2f4c", "url": "https://api.github.com/repos/rust-lang/rust/commits/b147d70b08f93ea0a13a5331f413d547819b2f4c", "html_url": "https://github.com/rust-lang/rust/commit/b147d70b08f93ea0a13a5331f413d547819b2f4c"}], "stats": {"total": 815, "additions": 379, "deletions": 436}, "files": [{"sha": "4cd67d6ebacf3587e50d58f610904c76ecb50e31", "filename": "src/libextra/json.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/20454da2db9903688dfd60b826cc704de79767bc/src%2Flibextra%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20454da2db9903688dfd60b826cc704de79767bc/src%2Flibextra%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fjson.rs?ref=20454da2db9903688dfd60b826cc704de79767bc", "patch": "@@ -1867,35 +1867,34 @@ mod tests {\n                 col: 8u,\n                 msg: @~\"EOF while parsing object\"}));\n \n-        assert_eq!(result::unwrap(from_str(\"{}\")), mk_object([]));\n-        assert_eq!(result::unwrap(from_str(\"{\\\"a\\\": 3}\")),\n+        assert_eq!(from_str(\"{}\").unwrap(), mk_object([]));\n+        assert_eq!(from_str(\"{\\\"a\\\": 3}\").unwrap(),\n                   mk_object([(~\"a\", Number(3.0f))]));\n \n-        assert_eq!(result::unwrap(from_str(\n-                      \"{ \\\"a\\\": null, \\\"b\\\" : true }\")),\n+        assert_eq!(from_str(\n+                      \"{ \\\"a\\\": null, \\\"b\\\" : true }\").unwrap(),\n                   mk_object([\n                       (~\"a\", Null),\n                       (~\"b\", Boolean(true))]));\n-        assert_eq!(result::unwrap(\n-                      from_str(\"\\n{ \\\"a\\\": null, \\\"b\\\" : true }\\n\")),\n+        assert_eq!(from_str(\"\\n{ \\\"a\\\": null, \\\"b\\\" : true }\\n\").unwrap(),\n                   mk_object([\n                       (~\"a\", Null),\n                       (~\"b\", Boolean(true))]));\n-        assert_eq!(result::unwrap(from_str(\n-                      \"{\\\"a\\\" : 1.0 ,\\\"b\\\": [ true ]}\")),\n+        assert_eq!(from_str(\n+                      \"{\\\"a\\\" : 1.0 ,\\\"b\\\": [ true ]}\").unwrap(),\n                   mk_object([\n                       (~\"a\", Number(1.0)),\n                       (~\"b\", List(~[Boolean(true)]))\n                   ]));\n-        assert_eq!(result::unwrap(from_str(\n+        assert_eq!(from_str(\n                       ~\"{\" +\n                           \"\\\"a\\\": 1.0, \" +\n                           \"\\\"b\\\": [\" +\n                               \"true,\" +\n                               \"\\\"foo\\\\nbar\\\", \" +\n                               \"{ \\\"c\\\": {\\\"d\\\": null} } \" +\n                           \"]\" +\n-                      \"}\")),\n+                      \"}\").unwrap(),\n                   mk_object([\n                       (~\"a\", Number(1.0f)),\n                       (~\"b\", List(~["}, {"sha": "f926572dad61726a7ccb7356c1ffeba2f9023aa7", "filename": "src/libextra/time.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/20454da2db9903688dfd60b826cc704de79767bc/src%2Flibextra%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20454da2db9903688dfd60b826cc704de79767bc/src%2Flibextra%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftime.rs?ref=20454da2db9903688dfd60b826cc704de79767bc", "patch": "@@ -1132,13 +1132,13 @@ mod tests {\n         assert!(test(\"6\", \"%w\"));\n         assert!(test(\"2009\", \"%Y\"));\n         assert!(test(\"09\", \"%y\"));\n-        assert!(result::unwrap(strptime(\"UTC\", \"%Z\")).tm_zone ==\n+        assert!(strptime(\"UTC\", \"%Z\").unwrap().tm_zone ==\n             ~\"UTC\");\n-        assert!(result::unwrap(strptime(\"PST\", \"%Z\")).tm_zone ==\n+        assert!(strptime(\"PST\", \"%Z\").unwrap().tm_zone ==\n             ~\"\");\n-        assert!(result::unwrap(strptime(\"-0000\", \"%z\")).tm_gmtoff ==\n+        assert!(strptime(\"-0000\", \"%z\").unwrap().tm_gmtoff ==\n             0);\n-        assert!(result::unwrap(strptime(\"-0800\", \"%z\")).tm_gmtoff ==\n+        assert!(strptime(\"-0800\", \"%z\").unwrap().tm_gmtoff ==\n             0);\n         assert!(test(\"%\", \"%%\"));\n "}, {"sha": "13a8ad36388d4acdf5a343eee12cf08aa7f824b4", "filename": "src/libextra/workcache.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/20454da2db9903688dfd60b826cc704de79767bc/src%2Flibextra%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20454da2db9903688dfd60b826cc704de79767bc/src%2Flibextra%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fworkcache.rs?ref=20454da2db9903688dfd60b826cc704de79767bc", "patch": "@@ -22,7 +22,6 @@ use std::cell::Cell;\n use std::comm::{PortOne, oneshot, send_one, recv_one};\n use std::either::{Either, Left, Right};\n use std::io;\n-use std::result;\n use std::run;\n use std::task;\n \n@@ -208,7 +207,7 @@ fn json_encode<T:Encodable<json::Encoder>>(t: &T) -> ~str {\n // FIXME(#5121)\n fn json_decode<T:Decodable<json::Decoder>>(s: &str) -> T {\n     do io::with_str_reader(s) |rdr| {\n-        let j = result::unwrap(json::from_reader(rdr));\n+        let j = json::from_reader(rdr).unwrap();\n         let mut decoder = json::Decoder(j);\n         Decodable::decode(&mut decoder)\n     }"}, {"sha": "7ac215e3949eee20d630b1fff6533c36f568f582", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/20454da2db9903688dfd60b826cc704de79767bc/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20454da2db9903688dfd60b826cc704de79767bc/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=20454da2db9903688dfd60b826cc704de79767bc", "patch": "@@ -147,7 +147,7 @@ pub fn get_rustpkg_root() -> Result<Path, ~str> {\n }\n \n pub fn get_rustpkg_root_nearest() -> Result<Path, ~str> {\n-    do result::chain(get_rustpkg_root()) |p| {\n+    do get_rustpkg_root().chain |p| {\n         let cwd = os::getcwd();\n         let cwd_rustpkg = cwd.push(\".rustpkg\");\n         let rustpkg_is_non_root_file =\n@@ -173,13 +173,13 @@ pub fn get_rustpkg_root_nearest() -> Result<Path, ~str> {\n }\n \n fn get_rustpkg_lib_path() -> Result<Path, ~str> {\n-    do result::chain(get_rustpkg_root()) |p| {\n+    do get_rustpkg_root().chain |p| {\n         result::Ok(p.push(libdir()))\n     }\n }\n \n fn get_rustpkg_lib_path_nearest() -> Result<Path, ~str> {\n-    do result::chain(get_rustpkg_root_nearest()) |p| {\n+    do get_rustpkg_root_nearest().chain |p| {\n         result::Ok(p.push(libdir()))\n     }\n }"}, {"sha": "aa3557e8a9d848e3ead55ba2a046ae677e2afd98", "filename": "src/librustdoc/config.rs", "status": "modified", "additions": 10, "deletions": 16, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/20454da2db9903688dfd60b826cc704de79767bc/src%2Flibrustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20454da2db9903688dfd60b826cc704de79767bc/src%2Flibrustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fconfig.rs?ref=20454da2db9903688dfd60b826cc704de79767bc", "patch": "@@ -138,36 +138,30 @@ fn config_from_opts(\n \n     let config = default_config(input_crate);\n     let result = result::Ok(config);\n-    let result = do result::chain(result) |config| {\n+    let result = do result.chain |config| {\n         let output_dir = getopts::opt_maybe_str(matches, opt_output_dir());\n         let output_dir = output_dir.map(|s| Path(*s));\n         result::Ok(Config {\n             output_dir: output_dir.get_or_default(config.output_dir.clone()),\n             .. config\n         })\n     };\n-    let result = do result::chain(result) |config| {\n-        let output_format = getopts::opt_maybe_str(\n-            matches, opt_output_format());\n-        do output_format.map_default(result::Ok(config.clone()))\n-            |output_format| {\n-            do result::chain(parse_output_format(*output_format))\n-                |output_format| {\n-\n+    let result = do result.chain |config| {\n+        let output_format = getopts::opt_maybe_str(matches, opt_output_format());\n+        do output_format.map_default(result::Ok(config.clone())) |output_format| {\n+            do parse_output_format(*output_format).chain |output_format| {\n                 result::Ok(Config {\n                     output_format: output_format,\n                     .. config.clone()\n                 })\n             }\n         }\n     };\n-    let result = do result::chain(result) |config| {\n+    let result = do result.chain |config| {\n         let output_style =\n             getopts::opt_maybe_str(matches, opt_output_style());\n-        do output_style.map_default(result::Ok(config.clone()))\n-            |output_style| {\n-            do result::chain(parse_output_style(*output_style))\n-                |output_style| {\n+        do output_style.map_default(result::Ok(config.clone())) |output_style| {\n+            do parse_output_style(*output_style).chain |output_style| {\n                 result::Ok(Config {\n                     output_style: output_style,\n                     .. config.clone()\n@@ -176,11 +170,11 @@ fn config_from_opts(\n         }\n     };\n     let process_output = Cell::new(process_output);\n-    let result = do result::chain(result) |config| {\n+    let result = do result.chain |config| {\n         let pandoc_cmd = getopts::opt_maybe_str(matches, opt_pandoc_cmd());\n         let pandoc_cmd = maybe_find_pandoc(\n             &config, pandoc_cmd, process_output.take());\n-        do result::chain(pandoc_cmd) |pandoc_cmd| {\n+        do pandoc_cmd.chain |pandoc_cmd| {\n             result::Ok(Config {\n                 pandoc_cmd: pandoc_cmd,\n                 .. config.clone()"}, {"sha": "a203fccfb5f3c7520ff3dbff0a78bccc5193e54a", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/20454da2db9903688dfd60b826cc704de79767bc/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20454da2db9903688dfd60b826cc704de79767bc/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=20454da2db9903688dfd60b826cc704de79767bc", "patch": "@@ -62,9 +62,7 @@ fn git_repo_pkg() -> PkgId {\n }\n \n fn writeFile(file_path: &Path, contents: &str) {\n-    let out: @io::Writer =\n-        result::unwrap(io::file_writer(file_path,\n-                                       [io::Create, io::Truncate]));\n+    let out = io::file_writer(file_path, [io::Create, io::Truncate]).unwrap();\n     out.write_line(contents);\n }\n "}, {"sha": "761d07da8052cf428dca5f321530b4d2c242a3d7", "filename": "src/libstd/io.rs", "status": "modified", "additions": 31, "deletions": 35, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/20454da2db9903688dfd60b826cc704de79767bc/src%2Flibstd%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20454da2db9903688dfd60b826cc704de79767bc/src%2Flibstd%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio.rs?ref=20454da2db9903688dfd60b826cc704de79767bc", "patch": "@@ -46,28 +46,26 @@ implement `Reader` and `Writer`, where appropriate.\n \n #[allow(missing_doc)];\n \n-use result::Result;\n-\n+use cast;\n use clone::Clone;\n use container::Container;\n use int;\n-use libc;\n-use libc::{c_int, c_long, c_void, size_t, ssize_t};\n+use iterator::IteratorUtil;\n use libc::consts::os::posix88::*;\n+use libc::{c_int, c_long, c_void, size_t, ssize_t};\n+use libc;\n use num;\n+use ops::Drop;\n use os;\n-use cast;\n use path::Path;\n-use ops::Drop;\n-use iterator::IteratorUtil;\n use ptr;\n-use result;\n-use str;\n+use result::{Result, Ok, Err};\n use str::{StrSlice, OwnedStr};\n+use str;\n use to_str::ToStr;\n use uint;\n-use vec;\n use vec::{MutableVector, ImmutableVector, OwnedVector, OwnedCopyableVector, CopyableVector};\n+use vec;\n \n #[allow(non_camel_case_types)] // not sure what to do about this\n pub type fd_t = c_int;\n@@ -1038,9 +1036,9 @@ pub fn file_reader(path: &Path) -> Result<@Reader, ~str> {\n     };\n \n     if f as uint == 0u {\n-        result::Err(~\"error opening \" + path.to_str())\n+        Err(~\"error opening \" + path.to_str())\n     } else {\n-        result::Ok(FILE_reader(f, true))\n+        Ok(FILE_reader(f, true))\n     }\n }\n \n@@ -1287,10 +1285,9 @@ pub fn mk_file_writer(path: &Path, flags: &[FileFlag])\n         }\n     };\n     if fd < (0 as c_int) {\n-        result::Err(fmt!(\"error opening %s: %s\", path.to_str(),\n-                         os::last_os_error()))\n+        Err(fmt!(\"error opening %s: %s\", path.to_str(), os::last_os_error()))\n     } else {\n-        result::Ok(fd_writer(fd, true))\n+        Ok(fd_writer(fd, true))\n     }\n }\n \n@@ -1559,7 +1556,7 @@ impl<T:Writer> WriterUtil for T {\n }\n \n pub fn file_writer(path: &Path, flags: &[FileFlag]) -> Result<@Writer, ~str> {\n-    mk_file_writer(path, flags).chain(|w| result::Ok(w))\n+    mk_file_writer(path, flags).chain(|w| Ok(w))\n }\n \n \n@@ -1572,9 +1569,9 @@ pub fn buffered_file_writer(path: &Path) -> Result<@Writer, ~str> {\n             }\n         };\n         return if f as uint == 0u {\n-            result::Err(~\"error opening \" + path.to_str())\n+            Err(~\"error opening \" + path.to_str())\n         } else {\n-            result::Ok(FILE_writer(f, true))\n+            Ok(FILE_writer(f, true))\n         }\n     }\n }\n@@ -1726,21 +1723,21 @@ pub fn seek_in_buf(offset: int, pos: uint, len: uint, whence: SeekStyle) ->\n }\n \n pub fn read_whole_file_str(file: &Path) -> Result<~str, ~str> {\n-    result::chain(read_whole_file(file), |bytes| {\n+    do read_whole_file(file).chain |bytes| {\n         if str::is_utf8(bytes) {\n-            result::Ok(str::from_bytes(bytes))\n+            Ok(str::from_bytes(bytes))\n         } else {\n-            result::Err(file.to_str() + \" is not UTF-8\")\n+            Err(file.to_str() + \" is not UTF-8\")\n         }\n-    })\n+    }\n }\n \n // FIXME (#2004): implement this in a low-level way. Going through the\n // abstractions is pointless.\n pub fn read_whole_file(file: &Path) -> Result<~[u8], ~str> {\n-    result::chain(file_reader(file), |rdr| {\n-        result::Ok(rdr.read_whole_stream())\n-    })\n+    do file_reader(file).chain |rdr| {\n+        Ok(rdr.read_whole_stream())\n+    }\n }\n \n // fsync related\n@@ -1839,6 +1836,7 @@ mod tests {\n     use io::{BytesWriter, SeekCur, SeekEnd, SeekSet};\n     use io;\n     use path::Path;\n+    use result::{Ok, Err};\n     use result;\n     use u64;\n     use vec;\n@@ -1851,12 +1849,10 @@ mod tests {\n             ~\"A hoopy frood who really knows where his towel is.\";\n         debug!(frood.clone());\n         {\n-            let out: @io::Writer =\n-                result::unwrap(\n-                    io::file_writer(tmpfile, [io::Create, io::Truncate]));\n+            let out = io::file_writer(tmpfile, [io::Create, io::Truncate]).unwrap();\n             out.write_str(frood);\n         }\n-        let inp: @io::Reader = result::unwrap(io::file_reader(tmpfile));\n+        let inp = io::file_reader(tmpfile).unwrap();\n         let frood2: ~str = inp.read_c_str();\n         debug!(frood2.clone());\n         assert_eq!(frood, frood2);\n@@ -1941,10 +1937,10 @@ mod tests {\n     #[test]\n     fn file_reader_not_exist() {\n         match io::file_reader(&Path(\"not a file\")) {\n-          result::Err(e) => {\n+          Err(e) => {\n             assert_eq!(e, ~\"error opening not a file\");\n           }\n-          result::Ok(_) => fail!()\n+          Ok(_) => fail!()\n         }\n     }\n \n@@ -1982,20 +1978,20 @@ mod tests {\n     #[test]\n     fn file_writer_bad_name() {\n         match io::file_writer(&Path(\"?/?\"), []) {\n-          result::Err(e) => {\n+          Err(e) => {\n             assert!(e.starts_with(\"error opening\"));\n           }\n-          result::Ok(_) => fail!()\n+          Ok(_) => fail!()\n         }\n     }\n \n     #[test]\n     fn buffered_file_writer_bad_name() {\n         match io::buffered_file_writer(&Path(\"?/?\")) {\n-          result::Err(e) => {\n+          Err(e) => {\n             assert!(e.starts_with(\"error opening\"));\n           }\n-          result::Ok(_) => fail!()\n+          Ok(_) => fail!()\n         }\n     }\n "}, {"sha": "6e4880550ebb4150e04868e7295e181e0f3ebc6e", "filename": "src/libstd/option.rs", "status": "modified", "additions": 117, "deletions": 111, "changes": 228, "blob_url": "https://github.com/rust-lang/rust/blob/20454da2db9903688dfd60b826cc704de79767bc/src%2Flibstd%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20454da2db9903688dfd60b826cc704de79767bc/src%2Flibstd%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foption.rs?ref=20454da2db9903688dfd60b826cc704de79767bc", "patch": "@@ -271,7 +271,7 @@ impl<T> Option<T> {\n     pub fn get_ref<'a>(&'a self) -> &'a T {\n         match *self {\n           Some(ref x) => x,\n-          None => fail!(\"option::get_ref None\")\n+          None => fail!(\"option::get_ref `None`\"),\n         }\n     }\n \n@@ -293,7 +293,7 @@ impl<T> Option<T> {\n     pub fn get_mut_ref<'a>(&'a mut self) -> &'a mut T {\n         match *self {\n           Some(ref mut x) => x,\n-          None => fail!(\"option::get_mut_ref None\")\n+          None => fail!(\"option::get_mut_ref `None`\"),\n         }\n     }\n \n@@ -317,7 +317,7 @@ impl<T> Option<T> {\n          */\n         match self {\n           Some(x) => x,\n-          None => fail!(\"option::unwrap None\")\n+          None => fail!(\"option::unwrap `None`\"),\n         }\n     }\n \n@@ -331,7 +331,7 @@ impl<T> Option<T> {\n      */\n     #[inline]\n     pub fn take_unwrap(&mut self) -> T {\n-        if self.is_none() { fail!(\"option::take_unwrap None\") }\n+        if self.is_none() { fail!(\"option::take_unwrap `None`\") }\n         self.take().unwrap()\n     }\n \n@@ -369,7 +369,7 @@ impl<T> Option<T> {\n     pub fn get(self) -> T {\n         match self {\n           Some(x) => return x,\n-          None => fail!(\"option::get None\")\n+          None => fail!(\"option::get `None`\")\n         }\n     }\n \n@@ -379,7 +379,7 @@ impl<T> Option<T> {\n         match self { Some(x) => x, None => def }\n     }\n \n-    /// Applies a function zero or more times until the result is None.\n+    /// Applies a function zero or more times until the result is `None`.\n     #[inline]\n     pub fn while_some(self, blk: &fn(v: T) -> Option<T>) {\n         let mut opt = self;\n@@ -441,134 +441,140 @@ impl<'self, A> Iterator<&'self mut A> for OptionMutIterator<'self, A> {\n     }\n }\n \n-#[test]\n-fn test_unwrap_ptr() {\n-    unsafe {\n-        let x = ~0;\n-        let addr_x: *int = ::cast::transmute(&*x);\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use util;\n+\n+    #[test]\n+    fn test_unwrap_ptr() {\n+        unsafe {\n+            let x = ~0;\n+            let addr_x: *int = ::cast::transmute(&*x);\n+            let opt = Some(x);\n+            let y = opt.unwrap();\n+            let addr_y: *int = ::cast::transmute(&*y);\n+            assert_eq!(addr_x, addr_y);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_unwrap_str() {\n+        let x = ~\"test\";\n+        let addr_x = x.as_imm_buf(|buf, _len| buf);\n         let opt = Some(x);\n         let y = opt.unwrap();\n-        let addr_y: *int = ::cast::transmute(&*y);\n+        let addr_y = y.as_imm_buf(|buf, _len| buf);\n         assert_eq!(addr_x, addr_y);\n     }\n-}\n \n-#[test]\n-fn test_unwrap_str() {\n-    let x = ~\"test\";\n-    let addr_x = x.as_imm_buf(|buf, _len| buf);\n-    let opt = Some(x);\n-    let y = opt.unwrap();\n-    let addr_y = y.as_imm_buf(|buf, _len| buf);\n-    assert_eq!(addr_x, addr_y);\n-}\n+    #[test]\n+    fn test_unwrap_resource() {\n+        struct R {\n+           i: @mut int,\n+        }\n \n-#[test]\n-fn test_unwrap_resource() {\n-    struct R {\n-       i: @mut int,\n-    }\n+        #[unsafe_destructor]\n+        impl ::ops::Drop for R {\n+           fn drop(&self) { *(self.i) += 1; }\n+        }\n \n-    #[unsafe_destructor]\n-    impl ::ops::Drop for R {\n-       fn drop(&self) { *(self.i) += 1; }\n-    }\n+        fn R(i: @mut int) -> R {\n+            R {\n+                i: i\n+            }\n+        }\n \n-    fn R(i: @mut int) -> R {\n-        R {\n-            i: i\n+        let i = @mut 0;\n+        {\n+            let x = R(i);\n+            let opt = Some(x);\n+            let _y = opt.unwrap();\n         }\n+        assert_eq!(*i, 1);\n     }\n \n-    let i = @mut 0;\n-    {\n-        let x = R(i);\n-        let opt = Some(x);\n-        let _y = opt.unwrap();\n+    #[test]\n+    fn test_option_dance() {\n+        let x = Some(());\n+        let mut y = Some(5);\n+        let mut y2 = 0;\n+        for x.iter().advance |_x| {\n+            y2 = y.take_unwrap();\n+        }\n+        assert_eq!(y2, 5);\n+        assert!(y.is_none());\n+    }\n+    #[test] #[should_fail] #[ignore(cfg(windows))]\n+    fn test_option_too_much_dance() {\n+        let mut y = Some(util::NonCopyable);\n+        let _y2 = y.take_unwrap();\n+        let _y3 = y.take_unwrap();\n+    }\n+\n+    #[test]\n+    fn test_option_while_some() {\n+        let mut i = 0;\n+        do Some(10).while_some |j| {\n+            i += 1;\n+            if (j > 0) {\n+                Some(j-1)\n+            } else {\n+                None\n+            }\n+        }\n+        assert_eq!(i, 11);\n     }\n-    assert_eq!(*i, 1);\n-}\n \n-#[test]\n-fn test_option_dance() {\n-    let x = Some(());\n-    let mut y = Some(5);\n-    let mut y2 = 0;\n-    for x.iter().advance |_x| {\n-        y2 = y.take_unwrap();\n+    #[test]\n+    fn test_get_or_zero() {\n+        let some_stuff = Some(42);\n+        assert_eq!(some_stuff.get_or_zero(), 42);\n+        let no_stuff: Option<int> = None;\n+        assert_eq!(no_stuff.get_or_zero(), 0);\n     }\n-    assert_eq!(y2, 5);\n-    assert!(y.is_none());\n-}\n-#[test] #[should_fail] #[ignore(cfg(windows))]\n-fn test_option_too_much_dance() {\n-    let mut y = Some(util::NonCopyable);\n-    let _y2 = y.take_unwrap();\n-    let _y3 = y.take_unwrap();\n-}\n \n-#[test]\n-fn test_option_while_some() {\n-    let mut i = 0;\n-    do Some(10).while_some |j| {\n-        i += 1;\n-        if (j > 0) {\n-            Some(j-1)\n-        } else {\n-            None\n-        }\n+    #[test]\n+    fn test_filtered() {\n+        let some_stuff = Some(42);\n+        let modified_stuff = some_stuff.filtered(|&x| {x < 10});\n+        assert_eq!(some_stuff.get(), 42);\n+        assert!(modified_stuff.is_none());\n     }\n-    assert_eq!(i, 11);\n-}\n \n-#[test]\n-fn test_get_or_zero() {\n-    let some_stuff = Some(42);\n-    assert_eq!(some_stuff.get_or_zero(), 42);\n-    let no_stuff: Option<int> = None;\n-    assert_eq!(no_stuff.get_or_zero(), 0);\n-}\n+    #[test]\n+    fn test_iter() {\n+        let val = 5;\n \n-#[test]\n-fn test_filtered() {\n-    let some_stuff = Some(42);\n-    let modified_stuff = some_stuff.filtered(|&x| {x < 10});\n-    assert_eq!(some_stuff.get(), 42);\n-    assert!(modified_stuff.is_none());\n-}\n+        let x = Some(val);\n+        let mut it = x.iter();\n \n-#[test]\n-fn test_iter() {\n-    let val = 5;\n-\n-    let x = Some(val);\n-    let mut it = x.iter();\n-\n-    assert_eq!(it.size_hint(), (1, Some(1)));\n-    assert_eq!(it.next(), Some(&val));\n-    assert_eq!(it.size_hint(), (0, Some(0)));\n-    assert!(it.next().is_none());\n-}\n+        assert_eq!(it.size_hint(), (1, Some(1)));\n+        assert_eq!(it.next(), Some(&val));\n+        assert_eq!(it.size_hint(), (0, Some(0)));\n+        assert!(it.next().is_none());\n+    }\n \n-#[test]\n-fn test_mut_iter() {\n-    let val = 5;\n-    let new_val = 11;\n+    #[test]\n+    fn test_mut_iter() {\n+        let val = 5;\n+        let new_val = 11;\n \n-    let mut x = Some(val);\n-    let mut it = x.mut_iter();\n+        let mut x = Some(val);\n+        let mut it = x.mut_iter();\n \n-    assert_eq!(it.size_hint(), (1, Some(1)));\n+        assert_eq!(it.size_hint(), (1, Some(1)));\n \n-    match it.next() {\n-        Some(interior) => {\n-            assert_eq!(*interior, val);\n-            *interior = new_val;\n-            assert_eq!(x, Some(new_val));\n+        match it.next() {\n+            Some(interior) => {\n+                assert_eq!(*interior, val);\n+                *interior = new_val;\n+                assert_eq!(x, Some(new_val));\n+            }\n+            None => assert!(false),\n         }\n-        None => assert!(false),\n-    }\n \n-    assert_eq!(it.size_hint(), (0, Some(0)));\n-    assert!(it.next().is_none());\n+        assert_eq!(it.size_hint(), (0, Some(0)));\n+        assert!(it.next().is_none());\n+    }\n }"}, {"sha": "c045c191488f5af56e7ba9053f3ab90877f92e07", "filename": "src/libstd/result.rs", "status": "modified", "additions": 194, "deletions": 242, "changes": 436, "blob_url": "https://github.com/rust-lang/rust/blob/20454da2db9903688dfd60b826cc704de79767bc/src%2Flibstd%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20454da2db9903688dfd60b826cc704de79767bc/src%2Flibstd%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fresult.rs?ref=20454da2db9903688dfd60b826cc704de79767bc", "patch": "@@ -15,7 +15,6 @@\n use clone::Clone;\n use cmp::Eq;\n use either;\n-use either::Either;\n use iterator::IteratorUtil;\n use option::{None, Option, Some};\n use vec;\n@@ -31,253 +30,215 @@ pub enum Result<T, U> {\n     Err(U)\n }\n \n-/**\n- * Get the value out of a successful result\n- *\n- * # Failure\n- *\n- * If the result is an error\n- */\n-#[inline]\n-pub fn get<T:Clone,U>(res: &Result<T, U>) -> T {\n-    match *res {\n-      Ok(ref t) => (*t).clone(),\n-      Err(ref the_err) =>\n-        fail!(\"get called on error result: %?\", *the_err)\n-    }\n-}\n-\n-/**\n- * Get a reference to the value out of a successful result\n- *\n- * # Failure\n- *\n- * If the result is an error\n- */\n-#[inline]\n-pub fn get_ref<'a, T, U>(res: &'a Result<T, U>) -> &'a T {\n-    match *res {\n-        Ok(ref t) => t,\n-        Err(ref the_err) =>\n-            fail!(\"get_ref called on error result: %?\", *the_err)\n-    }\n-}\n-\n-/**\n- * Get the value out of an error result\n- *\n- * # Failure\n- *\n- * If the result is not an error\n- */\n-#[inline]\n-pub fn get_err<T, U: Clone>(res: &Result<T, U>) -> U {\n-    match *res {\n-      Err(ref u) => (*u).clone(),\n-      Ok(_) => fail!(\"get_err called on ok result\")\n-    }\n-}\n-\n-/// Returns true if the result is `ok`\n-#[inline]\n-pub fn is_ok<T, U>(res: &Result<T, U>) -> bool {\n-    match *res {\n-      Ok(_) => true,\n-      Err(_) => false\n-    }\n-}\n-\n-/// Returns true if the result is `err`\n-#[inline]\n-pub fn is_err<T, U>(res: &Result<T, U>) -> bool {\n-    !is_ok(res)\n-}\n-\n-/**\n- * Convert to the `either` type\n- *\n- * `ok` result variants are converted to `either::right` variants, `err`\n- * result variants are converted to `either::left`.\n- */\n-#[inline]\n-pub fn to_either<T:Clone,U:Clone>(res: &Result<U, T>)\n-    -> Either<T, U> {\n-    match *res {\n-      Ok(ref res) => either::Right((*res).clone()),\n-      Err(ref fail_) => either::Left((*fail_).clone())\n-    }\n-}\n-\n-/**\n- * Call a function based on a previous result\n- *\n- * If `res` is `ok` then the value is extracted and passed to `op` whereupon\n- * `op`s result is returned. if `res` is `err` then it is immediately\n- * returned. This function can be used to compose the results of two\n- * functions.\n- *\n- * Example:\n- *\n- *     let res = chain(read_file(file)) { |buf|\n- *         ok(parse_bytes(buf))\n- *     }\n- */\n-#[inline]\n-pub fn chain<T, U, V>(res: Result<T, V>, op: &fn(T)\n-    -> Result<U, V>) -> Result<U, V> {\n-    match res {\n-        Ok(t) => op(t),\n-        Err(e) => Err(e)\n-    }\n-}\n-\n-/**\n- * Call a function based on a previous result\n- *\n- * If `res` is `err` then the value is extracted and passed to `op`\n- * whereupon `op`s result is returned. if `res` is `ok` then it is\n- * immediately returned.  This function can be used to pass through a\n- * successful result while handling an error.\n- */\n-#[inline]\n-pub fn chain_err<T, U, V>(\n-    res: Result<T, V>,\n-    op: &fn(t: V) -> Result<T, U>)\n-    -> Result<T, U> {\n-    match res {\n-      Ok(t) => Ok(t),\n-      Err(v) => op(v)\n-    }\n-}\n-\n-/**\n- * Call a function based on a previous result\n- *\n- * If `res` is `ok` then the value is extracted and passed to `op` whereupon\n- * `op`s result is returned. if `res` is `err` then it is immediately\n- * returned. This function can be used to compose the results of two\n- * functions.\n- *\n- * Example:\n- *\n- *     iter(read_file(file)) { |buf|\n- *         print_buf(buf)\n- *     }\n- */\n-#[inline]\n-pub fn iter<T, E>(res: &Result<T, E>, f: &fn(&T)) {\n-    match *res {\n-      Ok(ref t) => f(t),\n-      Err(_) => ()\n-    }\n-}\n-\n-/**\n- * Call a function based on a previous result\n- *\n- * If `res` is `err` then the value is extracted and passed to `op` whereupon\n- * `op`s result is returned. if `res` is `ok` then it is immediately returned.\n- * This function can be used to pass through a successful result while\n- * handling an error.\n- */\n-#[inline]\n-pub fn iter_err<T, E>(res: &Result<T, E>, f: &fn(&E)) {\n-    match *res {\n-      Ok(_) => (),\n-      Err(ref e) => f(e)\n-    }\n-}\n-\n-/**\n- * Call a function based on a previous result\n- *\n- * If `res` is `ok` then the value is extracted and passed to `op` whereupon\n- * `op`s result is wrapped in `ok` and returned. if `res` is `err` then it is\n- * immediately returned.  This function can be used to compose the results of\n- * two functions.\n- *\n- * Example:\n- *\n- *     let res = map(read_file(file)) { |buf|\n- *         parse_bytes(buf)\n- *     }\n- */\n-#[inline]\n-pub fn map<T, E: Clone, U: Clone>(res: &Result<T, E>, op: &fn(&T) -> U)\n-  -> Result<U, E> {\n-    match *res {\n-      Ok(ref t) => Ok(op(t)),\n-      Err(ref e) => Err((*e).clone())\n-    }\n-}\n-\n-/**\n- * Call a function based on a previous result\n- *\n- * If `res` is `err` then the value is extracted and passed to `op` whereupon\n- * `op`s result is wrapped in an `err` and returned. if `res` is `ok` then it\n- * is immediately returned.  This function can be used to pass through a\n- * successful result while handling an error.\n- */\n-#[inline]\n-pub fn map_err<T:Clone,E,F:Clone>(res: &Result<T, E>, op: &fn(&E) -> F)\n-  -> Result<T, F> {\n-    match *res {\n-      Ok(ref t) => Ok((*t).clone()),\n-      Err(ref e) => Err(op(e))\n+impl<T, E> Result<T, E> {\n+    /**\n+     * Convert to the `either` type\n+     *\n+     * `Ok` result variants are converted to `either::Right` variants, `Err`\n+     * result variants are converted to `either::Left`.\n+     */\n+    #[inline]\n+    pub fn to_either(self)-> either::Either<E, T>{\n+        match self {\n+            Ok(t) => either::Right(t),\n+            Err(e) => either::Left(e),\n+        }\n     }\n-}\n \n-impl<T, E> Result<T, E> {\n+    /**\n+     * Get a reference to the value out of a successful result\n+     *\n+     * # Failure\n+     *\n+     * If the result is an error\n+     */\n     #[inline]\n-    pub fn get_ref<'a>(&'a self) -> &'a T { get_ref(self) }\n+    pub fn get_ref<'a>(&'a self) -> &'a T {\n+        match *self {\n+            Ok(ref t) => t,\n+            Err(ref e) => fail!(\"get_ref called on `Err` result: %?\", *e),\n+        }\n+    }\n \n+    /// Returns true if the result is `Ok`\n     #[inline]\n-    pub fn is_ok(&self) -> bool { is_ok(self) }\n+    pub fn is_ok(&self) -> bool {\n+        match *self {\n+            Ok(_) => true,\n+            Err(_) => false\n+        }\n+    }\n \n+    /// Returns true if the result is `Err`\n     #[inline]\n-    pub fn is_err(&self) -> bool { is_err(self) }\n+    pub fn is_err(&self) -> bool {\n+        !self.is_ok()\n+    }\n \n+    /**\n+     * Call a method based on a previous result\n+     *\n+     * If `self` is `Ok` then the value is extracted and passed to `op`\n+     * whereupon `op`s result is returned. if `self` is `Err` then it is\n+     * immediately returned. This function can be used to compose the results\n+     * of two functions.\n+     *\n+     * Example:\n+     *\n+     *     do read_file(file).iter |buf| {\n+     *         print_buf(buf)\n+     *     }\n+     */\n     #[inline]\n-    pub fn iter(&self, f: &fn(&T)) { iter(self, f) }\n+    pub fn iter(&self, f: &fn(&T)) {\n+        match *self {\n+            Ok(ref t) => f(t),\n+            Err(_) => (),\n+        }\n+    }\n \n+    /**\n+     * Call a method based on a previous result\n+     *\n+     * If `self` is `Err` then the value is extracted and passed to `op`\n+     * whereupon `op`s result is returned. if `self` is `Ok` then it is\n+     * immediately returned.  This function can be used to pass through a\n+     * successful result while handling an error.\n+     */\n     #[inline]\n-    pub fn iter_err(&self, f: &fn(&E)) { iter_err(self, f) }\n+    pub fn iter_err(&self, f: &fn(&E)) {\n+        match *self {\n+            Ok(_) => (),\n+            Err(ref e) => f(e),\n+        }\n+    }\n \n+    /// Unwraps a result, assuming it is an `Ok(T)`\n     #[inline]\n-    pub fn unwrap(self) -> T { unwrap(self) }\n+    pub fn unwrap(self) -> T {\n+        match self {\n+            Ok(t) => t,\n+            Err(_) => fail!(\"unwrap called on an `Err` result\"),\n+        }\n+    }\n \n+    /// Unwraps a result, assuming it is an `Err(U)`\n     #[inline]\n-    pub fn unwrap_err(self) -> E { unwrap_err(self) }\n+    pub fn unwrap_err(self) -> E {\n+        match self {\n+            Err(e) => e,\n+            Ok(_) => fail!(\"unwrap called on an `Ok` result\"),\n+        }\n+    }\n \n+    /**\n+     * Call a method based on a previous result\n+     *\n+     * If `self` is `Ok` then the value is extracted and passed to `op`\n+     * whereupon `op`s result is returned. if `self` is `Err` then it is\n+     * immediately returned. This function can be used to compose the results\n+     * of two functions.\n+     *\n+     * Example:\n+     *\n+     *     let res = do read_file(file) |buf| {\n+     *         Ok(parse_bytes(buf))\n+     *     };\n+     */\n     #[inline]\n-    pub fn chain<U>(self, op: &fn(T) -> Result<U,E>) -> Result<U,E> {\n-        chain(self, op)\n+    pub fn chain<U>(self, op: &fn(T) -> Result<U, E>) -> Result<U, E> {\n+        match self {\n+            Ok(t) => op(t),\n+            Err(e) => Err(e),\n+        }\n     }\n \n+    /**\n+     * Call a function based on a previous result\n+     *\n+     * If `self` is `Err` then the value is extracted and passed to `op`\n+     * whereupon `op`s result is returned. if `self` is `Ok` then it is\n+     * immediately returned.  This function can be used to pass through a\n+     * successful result while handling an error.\n+     */\n     #[inline]\n-    pub fn chain_err<F>(self, op: &fn(E) -> Result<T,F>) -> Result<T,F> {\n-        chain_err(self, op)\n+    pub fn chain_err<F>(self, op: &fn(E) -> Result<T, F>) -> Result<T, F> {\n+        match self {\n+            Ok(t) => Ok(t),\n+            Err(e) => op(e),\n+        }\n     }\n }\n \n-impl<T:Clone,E> Result<T, E> {\n+impl<T: Clone, E> Result<T, E> {\n+    /**\n+     * Get the value out of a successful result\n+     *\n+     * # Failure\n+     *\n+     * If the result is an error\n+     */\n     #[inline]\n-    pub fn get(&self) -> T { get(self) }\n+    pub fn get(&self) -> T {\n+        match *self {\n+            Ok(ref t) => t.clone(),\n+            Err(ref e) => fail!(\"get called on `Err` result: %?\", *e),\n+        }\n+    }\n \n+    /**\n+     * Call a method based on a previous result\n+     *\n+     * If `self` is `Err` then the value is extracted and passed to `op`\n+     * whereupon `op`s result is wrapped in an `Err` and returned. if `self` is\n+     * `Ok` then it is immediately returned.  This function can be used to pass\n+     * through a successful result while handling an error.\n+     */\n     #[inline]\n     pub fn map_err<F:Clone>(&self, op: &fn(&E) -> F) -> Result<T,F> {\n-        map_err(self, op)\n+        match *self {\n+            Ok(ref t) => Ok(t.clone()),\n+            Err(ref e) => Err(op(e))\n+        }\n     }\n }\n \n-impl<T, E:Clone> Result<T, E> {\n+impl<T, E: Clone> Result<T, E> {\n+    /**\n+     * Get the value out of an error result\n+     *\n+     * # Failure\n+     *\n+     * If the result is not an error\n+     */\n     #[inline]\n-    pub fn get_err(&self) -> E { get_err(self) }\n+    pub fn get_err(&self) -> E {\n+        match *self {\n+            Err(ref e) => e.clone(),\n+            Ok(_) => fail!(\"get_err called on `Ok` result\")\n+        }\n+    }\n \n+    /**\n+     * Call a method based on a previous result\n+     *\n+     * If `self` is `Ok` then the value is extracted and passed to `op`\n+     * whereupon `op`s result is wrapped in `Ok` and returned. if `self` is\n+     * `Err` then it is immediately returned.  This function can be used to\n+     * compose the results of two functions.\n+     *\n+     * Example:\n+     *\n+     *     let res = do read_file(file).map |buf| {\n+     *         parse_bytes(buf)\n+     *     };\n+     */\n     #[inline]\n     pub fn map<U:Clone>(&self, op: &fn(&T) -> U) -> Result<U,E> {\n-        map(self, op)\n+        match *self {\n+            Ok(ref t) => Ok(op(t)),\n+            Err(ref e) => Err(e.clone())\n+        }\n     }\n }\n \n@@ -291,8 +252,8 @@ impl<T, E:Clone> Result<T, E> {\n  * checking for overflow:\n  *\n  *     fn inc_conditionally(x: uint) -> result<uint,str> {\n- *         if x == uint::max_value { return err(\"overflow\"); }\n- *         else { return ok(x+1u); }\n+ *         if x == uint::max_value { return Err(\"overflow\"); }\n+ *         else { return Ok(x+1u); }\n  *     }\n  *     map(~[1u, 2u, 3u], inc_conditionally).chain {|incd|\n  *         assert!(incd == ~[2u, 3u, 4u]);\n@@ -377,45 +338,27 @@ pub fn iter_vec2<S,T,U>(ss: &[S], ts: &[T],\n     return Ok(());\n }\n \n-/// Unwraps a result, assuming it is an `ok(T)`\n-#[inline]\n-pub fn unwrap<T, U>(res: Result<T, U>) -> T {\n-    match res {\n-      Ok(t) => t,\n-      Err(_) => fail!(\"unwrap called on an err result\")\n-    }\n-}\n-\n-/// Unwraps a result, assuming it is an `err(U)`\n-#[inline]\n-pub fn unwrap_err<T, U>(res: Result<T, U>) -> U {\n-    match res {\n-      Err(u) => u,\n-      Ok(_) => fail!(\"unwrap called on an ok result\")\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n-    use result::{Err, Ok, Result, chain, get, get_err};\n-    use result;\n+    use super::*;\n+    use either;\n \n-    pub fn op1() -> result::Result<int, ~str> { result::Ok(666) }\n+    pub fn op1() -> Result<int, ~str> { Ok(666) }\n \n-    pub fn op2(i: int) -> result::Result<uint, ~str> {\n-        result::Ok(i as uint + 1u)\n+    pub fn op2(i: int) -> Result<uint, ~str> {\n+        Ok(i as uint + 1u)\n     }\n \n-    pub fn op3() -> result::Result<int, ~str> { result::Err(~\"sadface\") }\n+    pub fn op3() -> Result<int, ~str> { Err(~\"sadface\") }\n \n     #[test]\n     pub fn chain_success() {\n-        assert_eq!(get(&chain(op1(), op2)), 667u);\n+        assert_eq!(op1().chain(op2).get(), 667u);\n     }\n \n     #[test]\n     pub fn chain_failure() {\n-        assert_eq!(get_err(&chain(op3(), op2)), ~\"sadface\");\n+        assert_eq!(op3().chain( op2).get_err(), ~\"sadface\");\n     }\n \n     #[test]\n@@ -456,4 +399,13 @@ mod tests {\n         let foo: Result<int, ()> = Ok(100);\n         assert_eq!(*foo.get_ref(), 100);\n     }\n+\n+    #[test]\n+    pub fn test_to_either() {\n+        let r: Result<int, ()> = Ok(100);\n+        let err: Result<(), int> = Err(404);\n+\n+        assert_eq!(r.to_either(), either::Right(100));\n+        assert_eq!(err.to_either(), either::Left(404));\n+    }\n }"}, {"sha": "754181f9cd848ba7f83cb0acb72db6d629548b6f", "filename": "src/test/bench/core-std.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/20454da2db9903688dfd60b826cc704de79767bc/src%2Ftest%2Fbench%2Fcore-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20454da2db9903688dfd60b826cc704de79767bc/src%2Ftest%2Fbench%2Fcore-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-std.rs?ref=20454da2db9903688dfd60b826cc704de79767bc", "patch": "@@ -75,7 +75,7 @@ fn read_line() {\n         .push_rel(&Path(\"src/test/bench/shootout-k-nucleotide.data\"));\n \n     for int::range(0, 3) |_i| {\n-        let reader = result::unwrap(io::file_reader(&path));\n+        let reader = io::file_reader(&path).unwrap();\n         while !reader.eof() {\n             reader.read_line();\n         }"}, {"sha": "4597212b390eb90cc6bf72a22e2140f401dec1e9", "filename": "src/test/bench/shootout-fasta.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/20454da2db9903688dfd60b826cc704de79767bc/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20454da2db9903688dfd60b826cc704de79767bc/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta.rs?ref=20454da2db9903688dfd60b826cc704de79767bc", "patch": "@@ -124,8 +124,8 @@ fn main() {\n     };\n \n     let writer = if os::getenv(\"RUST_BENCH\").is_some() {\n-        result::unwrap(io::file_writer(&Path(\"./shootout-fasta.data\"),\n-                                       [io::Truncate, io::Create]))\n+        io::file_writer(&Path(\"./shootout-fasta.data\"),\n+                        [io::Truncate, io::Create]).unwrap()\n     } else {\n         io::stdout()\n     };"}, {"sha": "8b4664ac0606e94dbb049100f9501b4b58f49d2f", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/20454da2db9903688dfd60b826cc704de79767bc/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20454da2db9903688dfd60b826cc704de79767bc/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=20454da2db9903688dfd60b826cc704de79767bc", "patch": "@@ -161,7 +161,7 @@ fn main() {\n        // get to this massive data set, but include_bin! chokes on it (#2598)\n        let path = Path(env!(\"CFG_SRC_DIR\"))\n            .push_rel(&Path(\"src/test/bench/shootout-k-nucleotide.data\"));\n-       result::unwrap(io::file_reader(&path))\n+       io::file_reader(&path).unwrap()\n    } else {\n       io::stdin()\n    };"}, {"sha": "782ce61cab253647286fad6fdbe021d2d6593f12", "filename": "src/test/run-fail/result-get-fail.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/20454da2db9903688dfd60b826cc704de79767bc/src%2Ftest%2Frun-fail%2Fresult-get-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20454da2db9903688dfd60b826cc704de79767bc/src%2Ftest%2Frun-fail%2Fresult-get-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fresult-get-fail.rs?ref=20454da2db9903688dfd60b826cc704de79767bc", "patch": "@@ -8,10 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern:get called on error result: ~\"kitty\"\n+// error-pattern:get called on `Err` result: ~\"kitty\"\n \n use std::result;\n \n fn main() {\n-  error!(result::get(&result::Err::<int,~str>(~\"kitty\")));\n+  error!(result::Err::<int,~str>(~\"kitty\").get());\n }"}, {"sha": "45375efe9d630a0d7e5e6a04d9fd867e7c66954c", "filename": "src/test/run-pass/cleanup-copy-mode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/20454da2db9903688dfd60b826cc704de79767bc/src%2Ftest%2Frun-pass%2Fcleanup-copy-mode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20454da2db9903688dfd60b826cc704de79767bc/src%2Ftest%2Frun-pass%2Fcleanup-copy-mode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcleanup-copy-mode.rs?ref=20454da2db9903688dfd60b826cc704de79767bc", "patch": "@@ -16,7 +16,7 @@ use std::task;\n fn adder(x: @int, y: @int) -> int { return *x + *y; }\n fn failer() -> @int { fail!(); }\n pub fn main() {\n-    assert!(result::is_err(&task::try(|| {\n+    assert!(task::try(|| {\n         adder(@2, failer()); ()\n-    })));\n+    }).is_err());\n }"}, {"sha": "c4178961d9e6946577d558a0018cdf8df04ca640", "filename": "src/test/run-pass/issue-4016.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/20454da2db9903688dfd60b826cc704de79767bc/src%2Ftest%2Frun-pass%2Fissue-4016.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20454da2db9903688dfd60b826cc704de79767bc/src%2Ftest%2Frun-pass%2Fissue-4016.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-4016.rs?ref=20454da2db9903688dfd60b826cc704de79767bc", "patch": "@@ -11,14 +11,13 @@\n \n extern mod extra;\n \n-use std::result;\n use extra::json;\n use extra::serialize::Decodable;\n \n trait JD : Decodable<json::Decoder> { }\n \n fn exec<T: JD>() {\n-    let doc = result::unwrap(json::from_str(\"\"));\n+    let doc = json::from_str(\"\").unwrap();\n     let mut decoder = json::Decoder(doc);\n     let _v: T = Decodable::decode(&mut decoder);\n     fail!()"}]}