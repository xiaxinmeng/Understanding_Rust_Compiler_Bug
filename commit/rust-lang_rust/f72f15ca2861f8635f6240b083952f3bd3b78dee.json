{"sha": "f72f15ca2861f8635f6240b083952f3bd3b78dee", "node_id": "C_kwDOAAsO6NoAKGY3MmYxNWNhMjg2MWY4NjM1ZjYyNDBiMDgzOTUyZjNiZDNiNzhkZWU", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-02-01T17:27:49Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-02-09T19:11:00Z"}, "message": "Use a slice in DefIdForest.", "tree": {"sha": "8d19487671d040b0e5a9877177e4533e8ae9bb67", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8d19487671d040b0e5a9877177e4533e8ae9bb67"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f72f15ca2861f8635f6240b083952f3bd3b78dee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f72f15ca2861f8635f6240b083952f3bd3b78dee", "html_url": "https://github.com/rust-lang/rust/commit/f72f15ca2861f8635f6240b083952f3bd3b78dee", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f72f15ca2861f8635f6240b083952f3bd3b78dee/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6c2ee885e635a411946329e974d6be3d94d3b715", "url": "https://api.github.com/repos/rust-lang/rust/commits/6c2ee885e635a411946329e974d6be3d94d3b715", "html_url": "https://github.com/rust-lang/rust/commit/6c2ee885e635a411946329e974d6be3d94d3b715"}], "stats": {"total": 47, "additions": 22, "deletions": 25}, "files": [{"sha": "387db37f7832e2928141e0e1a7952c102501bceb", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f72f15ca2861f8635f6240b083952f3bd3b78dee/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f72f15ca2861f8635f6240b083952f3bd3b78dee/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=f72f15ca2861f8635f6240b083952f3bd3b78dee", "patch": "@@ -1515,8 +1515,7 @@ rustc_queries! {\n     /// check whether the forest is empty.\n     query type_uninhabited_from(\n         key: ty::ParamEnvAnd<'tcx, Ty<'tcx>>\n-    ) -> ty::inhabitedness::DefIdForest {\n-        storage(ArenaCacheSelector<'tcx>)\n+    ) -> ty::inhabitedness::DefIdForest<'tcx> {\n         desc { \"computing the inhabitedness of `{:?}`\", key }\n         remap_env_constness\n     }"}, {"sha": "c4ad698ba763531896eb8d5e1a633c2c4afb0228", "filename": "compiler/rustc_middle/src/ty/inhabitedness/def_id_forest.rs", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/f72f15ca2861f8635f6240b083952f3bd3b78dee/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fdef_id_forest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f72f15ca2861f8635f6240b083952f3bd3b78dee/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fdef_id_forest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fdef_id_forest.rs?ref=f72f15ca2861f8635f6240b083952f3bd3b78dee", "patch": "@@ -3,7 +3,6 @@ use crate::ty::{DefId, DefIdTree};\n use rustc_span::def_id::CRATE_DEF_ID;\n use smallvec::SmallVec;\n use std::mem;\n-use std::sync::Arc;\n \n use DefIdForest::*;\n \n@@ -18,14 +17,13 @@ use DefIdForest::*;\n /// We store the minimal set of `DefId`s required to represent the whole set. If A and B are\n /// `DefId`s in the `DefIdForest`, and A is a parent of B, then only A will be stored. When this is\n /// used with `type_uninhabited_from`, there will very rarely be more than one `DefId` stored.\n-#[derive(Clone, HashStable, Debug)]\n-pub enum DefIdForest {\n+#[derive(Copy, Clone, HashStable, Debug)]\n+pub enum DefIdForest<'a> {\n     Empty,\n     Single(DefId),\n     /// This variant is very rare.\n     /// Invariant: >1 elements\n-    /// We use `Arc` because this is used in the output of a query.\n-    Multiple(Arc<[DefId]>),\n+    Multiple(&'a [DefId]),\n }\n \n /// Tests whether a slice of roots contains a given DefId.\n@@ -34,21 +32,21 @@ fn slice_contains<'tcx>(tcx: TyCtxt<'tcx>, slice: &[DefId], id: DefId) -> bool {\n     slice.iter().any(|root_id| tcx.is_descendant_of(id, *root_id))\n }\n \n-impl<'tcx> DefIdForest {\n+impl<'tcx> DefIdForest<'tcx> {\n     /// Creates an empty forest.\n-    pub fn empty() -> DefIdForest {\n+    pub fn empty() -> DefIdForest<'tcx> {\n         DefIdForest::Empty\n     }\n \n     /// Creates a forest consisting of a single tree representing the entire\n     /// crate.\n     #[inline]\n-    pub fn full() -> DefIdForest {\n+    pub fn full() -> DefIdForest<'tcx> {\n         DefIdForest::from_id(CRATE_DEF_ID.to_def_id())\n     }\n \n     /// Creates a forest containing a `DefId` and all its descendants.\n-    pub fn from_id(id: DefId) -> DefIdForest {\n+    pub fn from_id(id: DefId) -> DefIdForest<'tcx> {\n         DefIdForest::Single(id)\n     }\n \n@@ -61,11 +59,11 @@ impl<'tcx> DefIdForest {\n     }\n \n     // Only allocates in the rare `Multiple` case.\n-    fn from_slice(root_ids: &[DefId]) -> DefIdForest {\n-        match root_ids {\n+    fn from_vec(tcx: TyCtxt<'tcx>, root_ids: SmallVec<[DefId; 1]>) -> DefIdForest<'tcx> {\n+        match &root_ids[..] {\n             [] => Empty,\n             [id] => Single(*id),\n-            _ => DefIdForest::Multiple(root_ids.into()),\n+            _ => DefIdForest::Multiple(tcx.arena.alloc_from_iter(root_ids)),\n         }\n     }\n \n@@ -88,9 +86,9 @@ impl<'tcx> DefIdForest {\n     }\n \n     /// Calculate the intersection of a collection of forests.\n-    pub fn intersection<I>(tcx: TyCtxt<'tcx>, iter: I) -> DefIdForest\n+    pub fn intersection<I>(tcx: TyCtxt<'tcx>, iter: I) -> DefIdForest<'tcx>\n     where\n-        I: IntoIterator<Item = DefIdForest>,\n+        I: IntoIterator<Item = DefIdForest<'tcx>>,\n     {\n         let mut iter = iter.into_iter();\n         let mut ret: SmallVec<[_; 1]> = if let Some(first) = iter.next() {\n@@ -114,13 +112,13 @@ impl<'tcx> DefIdForest {\n             mem::swap(&mut next_ret, &mut ret);\n             next_ret.clear();\n         }\n-        DefIdForest::from_slice(&ret)\n+        DefIdForest::from_vec(tcx, ret)\n     }\n \n     /// Calculate the union of a collection of forests.\n-    pub fn union<I>(tcx: TyCtxt<'tcx>, iter: I) -> DefIdForest\n+    pub fn union<I>(tcx: TyCtxt<'tcx>, iter: I) -> DefIdForest<'tcx>\n     where\n-        I: IntoIterator<Item = DefIdForest>,\n+        I: IntoIterator<Item = DefIdForest<'tcx>>,\n     {\n         let mut ret: SmallVec<[_; 1]> = SmallVec::new();\n         let mut next_ret: SmallVec<[_; 1]> = SmallVec::new();\n@@ -142,6 +140,6 @@ impl<'tcx> DefIdForest {\n             mem::swap(&mut next_ret, &mut ret);\n             next_ret.clear();\n         }\n-        DefIdForest::from_slice(&ret)\n+        DefIdForest::from_vec(tcx, ret)\n     }\n }"}, {"sha": "14ddccbfd83ae993e177b4d98529fa723e108ed9", "filename": "compiler/rustc_middle/src/ty/inhabitedness/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f72f15ca2861f8635f6240b083952f3bd3b78dee/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f72f15ca2861f8635f6240b083952f3bd3b78dee/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs?ref=f72f15ca2861f8635f6240b083952f3bd3b78dee", "patch": "@@ -112,7 +112,7 @@ impl<'tcx> AdtDef {\n         tcx: TyCtxt<'tcx>,\n         substs: SubstsRef<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n-    ) -> DefIdForest {\n+    ) -> DefIdForest<'tcx> {\n         // Non-exhaustive ADTs from other crates are always considered inhabited.\n         if self.is_variant_list_non_exhaustive() && !self.did.is_local() {\n             DefIdForest::empty()\n@@ -135,7 +135,7 @@ impl<'tcx> VariantDef {\n         substs: SubstsRef<'tcx>,\n         adt_kind: AdtKind,\n         param_env: ty::ParamEnv<'tcx>,\n-    ) -> DefIdForest {\n+    ) -> DefIdForest<'tcx> {\n         let is_enum = match adt_kind {\n             // For now, `union`s are never considered uninhabited.\n             // The precise semantics of inhabitedness with respect to unions is currently undecided.\n@@ -163,7 +163,7 @@ impl<'tcx> FieldDef {\n         substs: SubstsRef<'tcx>,\n         is_enum: bool,\n         param_env: ty::ParamEnv<'tcx>,\n-    ) -> DefIdForest {\n+    ) -> DefIdForest<'tcx> {\n         let data_uninhabitedness = move || self.ty(tcx, substs).uninhabited_from(tcx, param_env);\n         // FIXME(canndrew): Currently enum fields are (incorrectly) stored with\n         // `Visibility::Invisible` so we need to override `self.vis` if we're\n@@ -190,7 +190,7 @@ impl<'tcx> TyS<'tcx> {\n         &'tcx self,\n         tcx: TyCtxt<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n-    ) -> DefIdForest {\n+    ) -> DefIdForest<'tcx> {\n         tcx.type_uninhabited_from(param_env.and(self)).clone()\n     }\n }\n@@ -199,7 +199,7 @@ impl<'tcx> TyS<'tcx> {\n pub(crate) fn type_uninhabited_from<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     key: ty::ParamEnvAnd<'tcx, Ty<'tcx>>,\n-) -> DefIdForest {\n+) -> DefIdForest<'tcx> {\n     let ty = key.value;\n     let param_env = key.param_env;\n     match *ty.kind() {"}]}