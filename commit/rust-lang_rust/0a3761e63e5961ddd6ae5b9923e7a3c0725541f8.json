{"sha": "0a3761e63e5961ddd6ae5b9923e7a3c0725541f8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBhMzc2MWU2M2U1OTYxZGRkNmFlNWI5OTIzZTdhM2MwNzI1NTQxZjg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-01-03T21:06:21Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-01-03T21:06:21Z"}, "message": "Auto merge of #46984 - arielb1:pre-statement-effect, r=nikomatsakis\n\nNLL fixes\n\nFirst, introduce pre-statement effects to dataflow to fix #46875. Edge dataflow effects might make that redundant, but I'm not sure of the best way to integrate them with liveness etc., and if this is a hack, this is one of the cleanest hacks I've seen.\n\nAnd I want a small fix to avoid the torrent of bug reports.\n\nSecond, fix linking of projections to fix #46974\n\nr? @pnkfelix", "tree": {"sha": "9c39babccfd992197284c6a83199764669570fc1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9c39babccfd992197284c6a83199764669570fc1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0a3761e63e5961ddd6ae5b9923e7a3c0725541f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0a3761e63e5961ddd6ae5b9923e7a3c0725541f8", "html_url": "https://github.com/rust-lang/rust/commit/0a3761e63e5961ddd6ae5b9923e7a3c0725541f8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0a3761e63e5961ddd6ae5b9923e7a3c0725541f8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d96cc6e2865ff2cc77f061ae97e58aae50f5a1e9", "url": "https://api.github.com/repos/rust-lang/rust/commits/d96cc6e2865ff2cc77f061ae97e58aae50f5a1e9", "html_url": "https://github.com/rust-lang/rust/commit/d96cc6e2865ff2cc77f061ae97e58aae50f5a1e9"}, {"sha": "bd1bd76cd83d0a75917842966c52140a44753ed3", "url": "https://api.github.com/repos/rust-lang/rust/commits/bd1bd76cd83d0a75917842966c52140a44753ed3", "html_url": "https://github.com/rust-lang/rust/commit/bd1bd76cd83d0a75917842966c52140a44753ed3"}], "stats": {"total": 291, "additions": 262, "deletions": 29}, "files": [{"sha": "61d6c14d6273054830834b743a444f9770d0f075", "filename": "src/librustc_mir/borrow_check/flows.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0a3761e63e5961ddd6ae5b9923e7a3c0725541f8/src%2Flibrustc_mir%2Fborrow_check%2Fflows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a3761e63e5961ddd6ae5b9923e7a3c0725541f8/src%2Flibrustc_mir%2Fborrow_check%2Fflows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fflows.rs?ref=0a3761e63e5961ddd6ae5b9923e7a3c0725541f8", "patch": "@@ -88,7 +88,8 @@ impl<'b, 'gcx, 'tcx> fmt::Display for Flows<'b, 'gcx, 'tcx> {\n             };\n             saw_one = true;\n             let borrow_data = &self.borrows.operator().borrows()[borrow.borrow_index()];\n-            s.push_str(&format!(\"{}\", borrow_data));\n+            s.push_str(&format!(\"{}{}\", borrow_data,\n+                                if borrow.is_activation() { \"@active\" } else { \"\" }));\n         });\n         s.push_str(\"] \");\n "}, {"sha": "b5836c65d675b515c85e95d11fcac984106b7507", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a3761e63e5961ddd6ae5b9923e7a3c0725541f8/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a3761e63e5961ddd6ae5b9923e7a3c0725541f8/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=0a3761e63e5961ddd6ae5b9923e7a3c0725541f8", "patch": "@@ -2012,6 +2012,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             let borrowed = &data[i.borrow_index()];\n \n             if self.places_conflict(&borrowed.borrowed_place, place, access) {\n+                debug!(\"each_borrow_involving_path: {:?} @ {:?} vs. {:?}/{:?}\",\n+                       i, borrowed, place, access);\n                 let ctrl = op(self, i, borrowed);\n                 if ctrl == Control::Break {\n                     return;"}, {"sha": "7ca4ebd1cb29660dd60576d21669f5976a06da05", "filename": "src/librustc_mir/borrow_check/nll/constraint_generation.rs", "status": "modified", "additions": 75, "deletions": 22, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/0a3761e63e5961ddd6ae5b9923e7a3c0725541f8/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a3761e63e5961ddd6ae5b9923e7a3c0725541f8/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs?ref=0a3761e63e5961ddd6ae5b9923e7a3c0725541f8", "patch": "@@ -130,38 +130,91 @@ impl<'cx, 'cg, 'gcx, 'tcx> ConstraintGeneration<'cx, 'cg, 'gcx, 'tcx> {\n             });\n     }\n \n+    // Add the reborrow constraint at `location` so that `borrowed_place`\n+    // is valid for `borrow_region`.\n     fn add_reborrow_constraint(\n         &mut self,\n         location: Location,\n         borrow_region: ty::Region<'tcx>,\n         borrowed_place: &Place<'tcx>,\n     ) {\n-        if let Projection(ref proj) = *borrowed_place {\n-            let PlaceProjection { ref base, ref elem } = **proj;\n-\n-            if let ProjectionElem::Deref = *elem {\n-                let tcx = self.infcx.tcx;\n-                let base_ty = base.ty(self.mir, tcx).to_ty(tcx);\n-                let base_sty = &base_ty.sty;\n-\n-                if let ty::TyRef(base_region, ty::TypeAndMut { ty: _, mutbl }) = *base_sty {\n-                    match mutbl {\n-                        hir::Mutability::MutImmutable => {}\n-\n-                        hir::Mutability::MutMutable => {\n-                            self.add_reborrow_constraint(location, borrow_region, base);\n+        let mut borrowed_place = borrowed_place;\n+\n+        debug!(\"add_reborrow_constraint({:?}, {:?}, {:?})\",\n+               location, borrow_region, borrowed_place);\n+        while let Projection(box PlaceProjection { base, elem }) = borrowed_place {\n+            debug!(\"add_reborrow_constraint - iteration {:?}\", borrowed_place);\n+\n+            match *elem {\n+                ProjectionElem::Deref => {\n+                    let tcx = self.infcx.tcx;\n+                    let base_ty = base.ty(self.mir, tcx).to_ty(tcx);\n+\n+                    debug!(\"add_reborrow_constraint - base_ty = {:?}\", base_ty);\n+                    match base_ty.sty {\n+                        ty::TyRef(ref_region, ty::TypeAndMut { ty: _, mutbl }) => {\n+                            let span = self.mir.source_info(location).span;\n+                            self.regioncx.add_outlives(\n+                                span,\n+                                ref_region.to_region_vid(),\n+                                borrow_region.to_region_vid(),\n+                                location.successor_within_block(),\n+                            );\n+\n+                            match mutbl {\n+                                hir::Mutability::MutImmutable => {\n+                                    // Immutable reference. We don't need the base\n+                                    // to be valid for the entire lifetime of\n+                                    // the borrow.\n+                                    break\n+                                }\n+                                hir::Mutability::MutMutable => {\n+                                    // Mutable reference. We *do* need the base\n+                                    // to be valid, because after the base becomes\n+                                    // invalid, someone else can use our mutable deref.\n+\n+                                    // This is in order to make the following function\n+                                    // illegal:\n+                                    // ```\n+                                    // fn unsafe_deref<'a, 'b>(x: &'a &'b mut T) -> &'b mut T {\n+                                    //     &mut *x\n+                                    // }\n+                                    // ```\n+                                    //\n+                                    // As otherwise you could clone `&mut T` using the\n+                                    // following function:\n+                                    // ```\n+                                    // fn bad(x: &mut T) -> (&mut T, &mut T) {\n+                                    //     let my_clone = unsafe_deref(&'a x);\n+                                    //     ENDREGION 'a;\n+                                    //     (my_clone, x)\n+                                    // }\n+                                    // ```\n+                                }\n+                            }\n+                        }\n+                        ty::TyRawPtr(..) => {\n+                            // deref of raw pointer, guaranteed to be valid\n+                            break\n                         }\n+                        ty::TyAdt(def, _) if def.is_box() => {\n+                            // deref of `Box`, need the base to be valid - propagate\n+                        }\n+                        _ => bug!(\"unexpected deref ty {:?} in {:?}\", base_ty, borrowed_place)\n                     }\n-\n-                    let span = self.mir.source_info(location).span;\n-                    self.regioncx.add_outlives(\n-                        span,\n-                        base_region.to_region_vid(),\n-                        borrow_region.to_region_vid(),\n-                        location.successor_within_block(),\n-                    );\n+                }\n+                ProjectionElem::Field(..) |\n+                ProjectionElem::Downcast(..) |\n+                ProjectionElem::Index(..) |\n+                ProjectionElem::ConstantIndex { .. } |\n+                ProjectionElem::Subslice { .. } => {\n+                    // other field access\n                 }\n             }\n+\n+            // The \"propagate\" case. We need to check that our base is valid\n+            // for the borrow's lifetime.\n+            borrowed_place = base;\n         }\n     }\n }"}, {"sha": "b1f73bfbe2284cf088128c83fbf443ad800f748d", "filename": "src/librustc_mir/dataflow/at_location.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0a3761e63e5961ddd6ae5b9923e7a3c0725541f8/src%2Flibrustc_mir%2Fdataflow%2Fat_location.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a3761e63e5961ddd6ae5b9923e7a3c0725541f8/src%2Flibrustc_mir%2Fdataflow%2Fat_location.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fat_location.rs?ref=0a3761e63e5961ddd6ae5b9923e7a3c0725541f8", "patch": "@@ -149,6 +149,18 @@ impl<BD> FlowsAtLocation for FlowAtLocation<BD>\n     fn reconstruct_statement_effect(&mut self, loc: Location) {\n         self.stmt_gen.reset_to_empty();\n         self.stmt_kill.reset_to_empty();\n+        {\n+            let mut sets = BlockSets {\n+                on_entry: &mut self.curr_state,\n+                gen_set: &mut self.stmt_gen,\n+                kill_set: &mut self.stmt_kill,\n+            };\n+            self.base_results\n+                .operator()\n+                .before_statement_effect(&mut sets, loc);\n+        }\n+        self.apply_local_effect(loc);\n+\n         let mut sets = BlockSets {\n             on_entry: &mut self.curr_state,\n             gen_set: &mut self.stmt_gen,\n@@ -162,6 +174,18 @@ impl<BD> FlowsAtLocation for FlowAtLocation<BD>\n     fn reconstruct_terminator_effect(&mut self, loc: Location) {\n         self.stmt_gen.reset_to_empty();\n         self.stmt_kill.reset_to_empty();\n+        {\n+            let mut sets = BlockSets {\n+                on_entry: &mut self.curr_state,\n+                gen_set: &mut self.stmt_gen,\n+                kill_set: &mut self.stmt_kill,\n+            };\n+            self.base_results\n+                .operator()\n+                .before_terminator_effect(&mut sets, loc);\n+        }\n+        self.apply_local_effect(loc);\n+\n         let mut sets = BlockSets {\n             on_entry: &mut self.curr_state,\n             gen_set: &mut self.stmt_gen,"}, {"sha": "f76aea19677d9b90f60f17c2f8fd20249886f2b7", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/0a3761e63e5961ddd6ae5b9923e7a3c0725541f8/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a3761e63e5961ddd6ae5b9923e7a3c0725541f8/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=0a3761e63e5961ddd6ae5b9923e7a3c0725541f8", "patch": "@@ -649,13 +649,27 @@ impl<'a, 'gcx, 'tcx> BitDenotation for Reservations<'a, 'gcx, 'tcx> {\n         // `_sets`.\n     }\n \n+    fn before_statement_effect(&self,\n+                               sets: &mut BlockSets<ReserveOrActivateIndex>,\n+                               location: Location) {\n+        debug!(\"Reservations::before_statement_effect sets: {:?} location: {:?}\", sets, location);\n+        self.0.kill_loans_out_of_scope_at_location(sets, location, false);\n+    }\n+\n     fn statement_effect(&self,\n                         sets: &mut BlockSets<ReserveOrActivateIndex>,\n                         location: Location) {\n         debug!(\"Reservations::statement_effect sets: {:?} location: {:?}\", sets, location);\n         self.0.statement_effect_on_borrows(sets, location, false);\n     }\n \n+    fn before_terminator_effect(&self,\n+                                sets: &mut BlockSets<ReserveOrActivateIndex>,\n+                                location: Location) {\n+        debug!(\"Reservations::before_terminator_effect sets: {:?} location: {:?}\", sets, location);\n+        self.0.kill_loans_out_of_scope_at_location(sets, location, false);\n+    }\n+\n     fn terminator_effect(&self,\n                          sets: &mut BlockSets<ReserveOrActivateIndex>,\n                          location: Location) {\n@@ -696,13 +710,27 @@ impl<'a, 'gcx, 'tcx> BitDenotation for ActiveBorrows<'a, 'gcx, 'tcx> {\n         // `_sets`.\n     }\n \n+    fn before_statement_effect(&self,\n+                               sets: &mut BlockSets<ReserveOrActivateIndex>,\n+                               location: Location) {\n+        debug!(\"ActiveBorrows::before_statement_effect sets: {:?} location: {:?}\", sets, location);\n+        self.0.kill_loans_out_of_scope_at_location(sets, location, true);\n+    }\n+\n     fn statement_effect(&self,\n                         sets: &mut BlockSets<ReserveOrActivateIndex>,\n                         location: Location) {\n         debug!(\"ActiveBorrows::statement_effect sets: {:?} location: {:?}\", sets, location);\n         self.0.statement_effect_on_borrows(sets, location, true);\n     }\n \n+    fn before_terminator_effect(&self,\n+                                sets: &mut BlockSets<ReserveOrActivateIndex>,\n+                                location: Location) {\n+        debug!(\"ActiveBorrows::before_terminator_effect sets: {:?} location: {:?}\", sets, location);\n+        self.0.kill_loans_out_of_scope_at_location(sets, location, true);\n+    }\n+\n     fn terminator_effect(&self,\n                          sets: &mut BlockSets<ReserveOrActivateIndex>,\n                          location: Location) {"}, {"sha": "b18fb7c7b9ccef1e84d9d0816af8cfcaacb675fc", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "modified", "additions": 44, "deletions": 3, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/0a3761e63e5961ddd6ae5b9923e7a3c0725541f8/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a3761e63e5961ddd6ae5b9923e7a3c0725541f8/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=0a3761e63e5961ddd6ae5b9923e7a3c0725541f8", "patch": "@@ -214,6 +214,7 @@ impl<'a, 'tcx: 'a, BD> DataflowAnalysis<'a, 'tcx, BD> where BD: BitDenotation\n             }\n             for j_stmt in 0..statements.len() {\n                 let location = Location { block: bb, statement_index: j_stmt };\n+                self.flow_state.operator.before_statement_effect(sets, location);\n                 self.flow_state.operator.statement_effect(sets, location);\n                 if track_intrablock {\n                     sets.apply_local_effect();\n@@ -222,6 +223,7 @@ impl<'a, 'tcx: 'a, BD> DataflowAnalysis<'a, 'tcx, BD> where BD: BitDenotation\n \n             if terminator.is_some() {\n                 let location = Location { block: bb, statement_index: statements.len() };\n+                self.flow_state.operator.before_terminator_effect(sets, location);\n                 self.flow_state.operator.terminator_effect(sets, location);\n                 if track_intrablock {\n                     sets.apply_local_effect();\n@@ -365,9 +367,10 @@ pub(crate) trait DataflowResultsConsumer<'a, 'tcx: 'a> {\n     fn mir(&self) -> &'a Mir<'tcx>;\n }\n \n-pub fn state_for_location<T: BitDenotation>(loc: Location,\n-                                            analysis: &T,\n-                                            result: &DataflowResults<T>)\n+pub fn state_for_location<'tcx, T: BitDenotation>(loc: Location,\n+                                                  analysis: &T,\n+                                                  result: &DataflowResults<T>,\n+                                                  mir: &Mir<'tcx>)\n     -> IdxSetBuf<T::Idx> {\n     let mut entry = result.sets().on_entry_set_for(loc.block.index()).to_owned();\n \n@@ -381,8 +384,16 @@ pub fn state_for_location<T: BitDenotation>(loc: Location,\n         for stmt in 0..loc.statement_index {\n             let mut stmt_loc = loc;\n             stmt_loc.statement_index = stmt;\n+            analysis.before_statement_effect(&mut sets, stmt_loc);\n             analysis.statement_effect(&mut sets, stmt_loc);\n         }\n+\n+        // Apply the pre-statement effect of the statement we're evaluating.\n+        if loc.statement_index == mir[loc.block].statements.len() {\n+            analysis.before_terminator_effect(&mut sets, loc);\n+        } else {\n+            analysis.before_statement_effect(&mut sets, loc);\n+        }\n     }\n \n     entry\n@@ -637,6 +648,21 @@ pub trait BitDenotation: BitwiseOperator {\n     /// (For example, establishing the call arguments.)\n     fn start_block_effect(&self, entry_set: &mut IdxSet<Self::Idx>);\n \n+    /// Similar to `statement_effect`, except it applies\n+    /// *just before* the statement rather than *just after* it.\n+    ///\n+    /// This matters for \"dataflow at location\" APIs, because the\n+    /// before-statement effect is visible while visiting the\n+    /// statement, while the after-statement effect only becomes\n+    /// visible at the next statement.\n+    ///\n+    /// Both the before-statement and after-statement effects are\n+    /// applied, in that order, before moving for the next\n+    /// statement.\n+    fn before_statement_effect(&self,\n+                               _sets: &mut BlockSets<Self::Idx>,\n+                               _location: Location) {}\n+\n     /// Mutates the block-sets (the flow sets for the given\n     /// basic block) according to the effects of evaluating statement.\n     ///\n@@ -651,6 +677,21 @@ pub trait BitDenotation: BitwiseOperator {\n                         sets: &mut BlockSets<Self::Idx>,\n                         location: Location);\n \n+    /// Similar to `terminator_effect`, except it applies\n+    /// *just before* the terminator rather than *just after* it.\n+    ///\n+    /// This matters for \"dataflow at location\" APIs, because the\n+    /// before-terminator effect is visible while visiting the\n+    /// terminator, while the after-terminator effect only becomes\n+    /// visible at the terminator's successors.\n+    ///\n+    /// Both the before-terminator and after-terminator effects are\n+    /// applied, in that order, before moving for the next\n+    /// terminator.\n+    fn before_terminator_effect(&self,\n+                                _sets: &mut BlockSets<Self::Idx>,\n+                                _location: Location) {}\n+\n     /// Mutates the block-sets (the flow sets for the given\n     /// basic block) according to the effects of evaluating\n     /// the terminator."}, {"sha": "9734edbe193c1a7bae89d0017017d6b6eb68f011", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a3761e63e5961ddd6ae5b9923e7a3c0725541f8/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a3761e63e5961ddd6ae5b9923e7a3c0725541f8/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=0a3761e63e5961ddd6ae5b9923e7a3c0725541f8", "patch": "@@ -363,7 +363,7 @@ fn locals_live_across_suspend_points<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 statement_index: data.statements.len(),\n             };\n \n-            let storage_liveness = state_for_location(loc, &analysis, &storage_live);\n+            let storage_liveness = state_for_location(loc, &analysis, &storage_live, mir);\n \n             storage_liveness_map.insert(block, storage_liveness.clone());\n "}, {"sha": "b6153ea1fdbad175839dae13e6b33fd9256ceaca", "filename": "src/librustc_mir/transform/rustc_peek.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0a3761e63e5961ddd6ae5b9923e7a3c0725541f8/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a3761e63e5961ddd6ae5b9923e7a3c0725541f8/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs?ref=0a3761e63e5961ddd6ae5b9923e7a3c0725541f8", "patch": "@@ -203,11 +203,18 @@ fn each_block<'a, 'tcx, O>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         // reset GEN and KILL sets before emulating their effect.\n         for e in sets.gen_set.words_mut() { *e = 0; }\n         for e in sets.kill_set.words_mut() { *e = 0; }\n-        results.0.operator.statement_effect(&mut sets, Location { block: bb, statement_index: j });\n+        results.0.operator.before_statement_effect(\n+            &mut sets, Location { block: bb, statement_index: j });\n+        results.0.operator.statement_effect(\n+            &mut sets, Location { block: bb, statement_index: j });\n         sets.on_entry.union(sets.gen_set);\n         sets.on_entry.subtract(sets.kill_set);\n     }\n \n+    results.0.operator.before_terminator_effect(\n+        &mut sets,\n+        Location { block: bb, statement_index: statements.len() });\n+\n     tcx.sess.span_err(span, &format!(\"rustc_peek: MIR did not match \\\n                                       anticipated pattern; note that \\\n                                       rustc_peek expects input of \\"}, {"sha": "a9797e4d215a5da45a7df48e9fb6d341c49cf34d", "filename": "src/test/compile-fail/borrowck/two-phase-activation-sharing-interference.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0a3761e63e5961ddd6ae5b9923e7a3c0725541f8/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-activation-sharing-interference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a3761e63e5961ddd6ae5b9923e7a3c0725541f8/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-activation-sharing-interference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-activation-sharing-interference.rs?ref=0a3761e63e5961ddd6ae5b9923e7a3c0725541f8", "patch": "@@ -56,7 +56,6 @@ fn should_also_eventually_be_ok_with_nll() {\n     let _z = &x;\n     *y += 1;\n     //[lxl]~^  ERROR cannot borrow `x` as mutable because it is also borrowed as immutable\n-    //[nll]~^^ ERROR cannot borrow `x` as mutable because it is also borrowed as immutable\n }\n \n fn main() { }"}, {"sha": "47d69fe8e976c60acdd8356acbd9f95010e81eb2", "filename": "src/test/ui/nll/borrow-use-issue-46875.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/0a3761e63e5961ddd6ae5b9923e7a3c0725541f8/src%2Ftest%2Fui%2Fnll%2Fborrow-use-issue-46875.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a3761e63e5961ddd6ae5b9923e7a3c0725541f8/src%2Ftest%2Fui%2Fnll%2Fborrow-use-issue-46875.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fborrow-use-issue-46875.rs?ref=0a3761e63e5961ddd6ae5b9923e7a3c0725541f8", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(nll)]\n+\n+// run-pass\n+\n+fn vec() {\n+    let mut _x = vec!['c'];\n+    let _y = &_x;\n+    _x = Vec::new();\n+}\n+\n+fn int() {\n+    let mut _x = 5;\n+    let _y = &_x;\n+    _x = 7;\n+}\n+\n+fn main() {\n+    vec();\n+    int();\n+}"}, {"sha": "57ecddb80ab3db250266a36a38ca64c29266b1a1", "filename": "src/test/ui/nll/guarantor-issue-46974.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/0a3761e63e5961ddd6ae5b9923e7a3c0725541f8/src%2Ftest%2Fui%2Fnll%2Fguarantor-issue-46974.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a3761e63e5961ddd6ae5b9923e7a3c0725541f8/src%2Ftest%2Fui%2Fnll%2Fguarantor-issue-46974.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fguarantor-issue-46974.rs?ref=0a3761e63e5961ddd6ae5b9923e7a3c0725541f8", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that NLL analysis propagates lifetimes correctly through\n+// field accesses, Box accesses, etc.\n+\n+#![feature(nll)]\n+\n+fn foo(s: &mut (i32,)) -> i32 {\n+    let t = &mut *s; // this borrow should last for the entire function\n+    let x = &t.0;\n+    *s = (2,); //~ ERROR cannot assign to `*s`\n+    *x\n+}\n+\n+fn bar(s: &Box<(i32,)>) -> &'static i32 {\n+    // FIXME(#46983): error message should be better\n+    &s.0 //~ ERROR free region `` does not outlive free region `'static`\n+}\n+\n+fn main() {\n+    foo(&mut (0,));\n+    bar(&Box::new((1,)));\n+}"}, {"sha": "68cc87ef4073418317d90baff9b9216f2e92c903", "filename": "src/test/ui/nll/guarantor-issue-46974.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0a3761e63e5961ddd6ae5b9923e7a3c0725541f8/src%2Ftest%2Fui%2Fnll%2Fguarantor-issue-46974.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0a3761e63e5961ddd6ae5b9923e7a3c0725541f8/src%2Ftest%2Fui%2Fnll%2Fguarantor-issue-46974.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fguarantor-issue-46974.stderr?ref=0a3761e63e5961ddd6ae5b9923e7a3c0725541f8", "patch": "@@ -0,0 +1,17 @@\n+error[E0506]: cannot assign to `*s` because it is borrowed\n+  --> $DIR/guarantor-issue-46974.rs:19:5\n+   |\n+17 |     let t = &mut *s; // this borrow should last for the entire function\n+   |             ------- borrow of `*s` occurs here\n+18 |     let x = &t.0;\n+19 |     *s = (2,); //~ ERROR cannot assign to `*s`\n+   |     ^^^^^^^^^ assignment to borrowed `*s` occurs here\n+\n+error: free region `` does not outlive free region `'static`\n+  --> $DIR/guarantor-issue-46974.rs:25:5\n+   |\n+25 |     &s.0 //~ ERROR free region `` does not outlive free region `'static`\n+   |     ^^^^\n+\n+error: aborting due to 2 previous errors\n+"}]}