{"sha": "6a478bdfd24ccc4df99a23d275a82e71a990115d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZhNDc4YmRmZDI0Y2NjNGRmOTlhMjNkMjc1YTgyZTcxYTk5MDExNWQ=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-01-17T20:44:42Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-01-29T22:27:12Z"}, "message": "rustc_typeck: use FnCtxt in coercion, instead of mimicking a combiner.", "tree": {"sha": "a76fcf4d161d28942af71df88246cf1597a2a329", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a76fcf4d161d28942af71df88246cf1597a2a329"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6a478bdfd24ccc4df99a23d275a82e71a990115d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6a478bdfd24ccc4df99a23d275a82e71a990115d", "html_url": "https://github.com/rust-lang/rust/commit/6a478bdfd24ccc4df99a23d275a82e71a990115d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6a478bdfd24ccc4df99a23d275a82e71a990115d/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f9f3ba5920ddb2b8bae5047eea556081e0da159d", "url": "https://api.github.com/repos/rust-lang/rust/commits/f9f3ba5920ddb2b8bae5047eea556081e0da159d", "html_url": "https://github.com/rust-lang/rust/commit/f9f3ba5920ddb2b8bae5047eea556081e0da159d"}], "stats": {"total": 152, "additions": 65, "deletions": 87}, "files": [{"sha": "79d57d957abccce0867664abae0dd8872b73369d", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 63, "deletions": 67, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/6a478bdfd24ccc4df99a23d275a82e71a990115d/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a478bdfd24ccc4df99a23d275a82e71a990115d/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=6a478bdfd24ccc4df99a23d275a82e71a990115d", "patch": "@@ -60,10 +60,11 @@\n //! sort of a minor point so I've opted to leave it for later---after all\n //! we may want to adjust precisely when coercions occur.\n \n-use middle::infer::{cres, Coercion, InferCtxt, TypeOrigin, TypeTrace};\n-use middle::infer::combine::{CombineFields, Combine};\n-use middle::infer::sub::Sub;\n+use check::FnCtxt;\n \n+use middle::infer::{self, cres, Coercion, TypeTrace};\n+use middle::infer::combine::Combine;\n+use middle::infer::sub::Sub;\n use middle::subst;\n use middle::ty::{AutoPtr, AutoDerefRef, AdjustDerefRef, AutoUnsize, AutoUnsafe};\n use middle::ty::{mt};\n@@ -74,21 +75,31 @@ use util::ppaux::Repr;\n \n use syntax::ast;\n \n-// Note: Coerce is not actually a combiner, in that it does not\n-// conform to the same interface, though it performs a similar\n-// function.\n-pub struct Coerce<'f, 'tcx: 'f>(pub CombineFields<'f, 'tcx>);\n+struct Coerce<'a, 'tcx: 'a> {\n+    fcx: &'a FnCtxt<'a, 'tcx>,\n+    trace: TypeTrace<'tcx>\n+}\n+\n+type CoerceResult<'tcx> = cres<'tcx, Option<ty::AutoAdjustment<'tcx>>>;\n \n impl<'f, 'tcx> Coerce<'f, 'tcx> {\n-    pub fn get_ref<'a>(&'a self) -> &'a CombineFields<'f, 'tcx> {\n-        let Coerce(ref v) = *self; v\n+    fn tcx(&self) -> &ty::ctxt<'tcx> {\n+        self.fcx.tcx()\n     }\n \n-    fn tcx(&self) -> &ty::ctxt<'tcx> {\n-        self.get_ref().infcx.tcx\n+    fn subtype(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> CoerceResult<'tcx> {\n+        let sub = Sub(self.fcx.infcx().combine_fields(false, self.trace.clone()));\n+        try!(sub.tys(a, b));\n+        Ok(None) // No coercion required.\n     }\n \n-    pub fn tys(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> CoerceResult<'tcx> {\n+    fn unpack_actual_value<T, F>(&self, a: Ty<'tcx>, f: F) -> T where\n+        F: FnOnce(Ty<'tcx>) -> T,\n+    {\n+        f(self.fcx.infcx().shallow_resolve(a))\n+    }\n+\n+    fn coerce(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> CoerceResult<'tcx> {\n         debug!(\"Coerce.tys({} => {})\",\n                a.repr(self.tcx()),\n                b.repr(self.tcx()));\n@@ -179,25 +190,12 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         })\n     }\n \n-    pub fn subtype(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> CoerceResult<'tcx> {\n-        match Sub(self.get_ref().clone()).tys(a, b) {\n-            Ok(_) => Ok(None),         // No coercion required.\n-            Err(ref e) => Err(*e)\n-        }\n-    }\n-\n-    pub fn unpack_actual_value<T, F>(&self, a: Ty<'tcx>, f: F) -> T where\n-        F: FnOnce(Ty<'tcx>) -> T,\n-    {\n-        f(self.get_ref().infcx.shallow_resolve(a))\n-    }\n-\n     // ~T -> &T or &mut T -> &T (including where T = [U] or str)\n-    pub fn coerce_borrowed_pointer(&self,\n-                                   a: Ty<'tcx>,\n-                                   b: Ty<'tcx>,\n-                                   mutbl_b: ast::Mutability)\n-                                   -> CoerceResult<'tcx> {\n+    fn coerce_borrowed_pointer(&self,\n+                               a: Ty<'tcx>,\n+                               b: Ty<'tcx>,\n+                               mutbl_b: ast::Mutability)\n+                               -> CoerceResult<'tcx> {\n         debug!(\"coerce_borrowed_pointer(a={}, b={})\",\n                a.repr(self.tcx()),\n                b.repr(self.tcx()));\n@@ -208,9 +206,8 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         // to type check, we will construct the type that `&M*expr` would\n         // yield.\n \n-        let sub = Sub(self.get_ref().clone());\n-        let coercion = Coercion(self.get_ref().trace.clone());\n-        let r_borrow = self.get_ref().infcx.next_region_var(coercion);\n+        let coercion = Coercion(self.trace.clone());\n+        let r_borrow = self.fcx.infcx().next_region_var(coercion);\n \n         let inner_ty = match a.sty {\n             ty::ty_uniq(_) => return Err(ty::terr_mismatch),\n@@ -220,15 +217,14 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                 }\n                 mt_a.ty\n             }\n-            _ => {\n-                return self.subtype(a, b);\n-            }\n+            _ => return self.subtype(a, b)\n         };\n \n         let a_borrowed = ty::mk_rptr(self.tcx(),\n                                      self.tcx().mk_region(r_borrow),\n                                      mt {ty: inner_ty, mutbl: mutbl_b});\n-        try!(sub.tys(a_borrowed, b));\n+        try!(self.subtype(a_borrowed, b));\n+        if let Err(original_err) = self.subtype(a_borrowed, b) {\n \n         Ok(Some(AdjustDerefRef(AutoDerefRef {\n             autoderefs: 1,\n@@ -253,8 +249,6 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         // we can't unify [T] with U. But to properly support DST, we need to allow\n         // that, at which point we will need extra checks on b here.\n \n-        let sub = Sub(self.get_ref().clone());\n-\n         match (&a.sty, &b.sty) {\n             (&ty::ty_rptr(_, ty::mt{ty: t_a, mutbl: mutbl_a}), &ty::ty_rptr(_, mt_b)) => {\n                 self.unpack_actual_value(t_a, |a| {\n@@ -264,12 +258,12 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                                 return Err(ty::terr_mutability);\n                             }\n \n-                            let coercion = Coercion(self.get_ref().trace.clone());\n-                            let r_borrow = self.get_ref().infcx.next_region_var(coercion);\n+                            let coercion = Coercion(self.trace.clone());\n+                            let r_borrow = self.fcx.infcx().next_region_var(coercion);\n                             let ty = ty::mk_rptr(self.tcx(),\n                                                  self.tcx().mk_region(r_borrow),\n                                                  ty::mt{ty: ty, mutbl: mt_b.mutbl});\n-                            try!(self.get_ref().infcx.try(|_| sub.tys(ty, b)));\n+                            try!(self.fcx.infcx().try(|_| self.subtype(ty, b)));\n                             debug!(\"Success, coerced with AutoDerefRef(1, \\\n                                     AutoPtr(AutoUnsize({:?})))\", kind);\n                             Ok(Some(AdjustDerefRef(AutoDerefRef {\n@@ -292,7 +286,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n \n                             let ty = ty::mk_ptr(self.tcx(),\n                                                  ty::mt{ty: ty, mutbl: mt_b.mutbl});\n-                            try!(self.get_ref().infcx.try(|_| sub.tys(ty, b)));\n+                            try!(self.fcx.infcx().try(|_| self.subtype(ty, b)));\n                             debug!(\"Success, coerced with AutoDerefRef(1, \\\n                                     AutoPtr(AutoUnsize({:?})))\", kind);\n                             Ok(Some(AdjustDerefRef(AutoDerefRef {\n@@ -310,7 +304,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                     match self.unsize_ty(t_a, a, t_b) {\n                         Some((ty, kind)) => {\n                             let ty = ty::mk_uniq(self.tcx(), ty);\n-                            try!(self.get_ref().infcx.try(|_| sub.tys(ty, b)));\n+                            try!(self.fcx.infcx().try(|_| self.subtype(ty, b)));\n                             debug!(\"Success, coerced with AutoDerefRef(1, \\\n                                     AutoUnsizeUniq({:?}))\", kind);\n                             Ok(Some(AdjustDerefRef(AutoDerefRef {\n@@ -362,12 +356,10 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                     let ty_substs_b = substs_b.types.get_slice(subst::TypeSpace);\n                     assert!(ty_substs_a.len() == ty_substs_b.len());\n \n-                    let sub = Sub(self.get_ref().clone());\n-\n                     let mut result = None;\n                     let mut tps = ty_substs_a.iter().zip(ty_substs_b.iter()).enumerate();\n                     for (i, (tp_a, tp_b)) in tps {\n-                        if self.get_ref().infcx.try(|_| sub.tys(*tp_a, *tp_b)).is_ok() {\n+                        if self.fcx.infcx().try(|_| self.subtype(*tp_a, *tp_b)).is_ok() {\n                             continue;\n                         }\n                         match\n@@ -380,7 +372,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                                 let mut new_substs = substs_a.clone();\n                                 new_substs.types.get_mut_slice(subst::TypeSpace)[i] = new_tp;\n                                 let ty = ty::mk_struct(tcx, did_a, tcx.mk_substs(new_substs));\n-                                if self.get_ref().infcx.try(|_| sub.tys(ty, ty_b)).is_err() {\n+                                if self.fcx.infcx().try(|_| self.subtype(ty, ty_b)).is_err() {\n                                     debug!(\"Unsized type parameter '{}', but still \\\n                                             could not match types {} and {}\",\n                                            ppaux::ty_to_string(tcx, *tp_a),\n@@ -416,8 +408,8 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                a.repr(tcx),\n                b.repr(tcx), b_mutbl);\n \n-        let coercion = Coercion(self.get_ref().trace.clone());\n-        let r_a = self.get_ref().infcx.next_region_var(coercion);\n+        let coercion = Coercion(self.trace.clone());\n+        let r_a = self.fcx.infcx().next_region_var(coercion);\n \n         self.coerce_object(a, b, b_mutbl,\n                            |tr| ty::mk_rptr(tcx, tcx.mk_region(r_a),\n@@ -501,11 +493,11 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         })\n     }\n \n-    pub fn coerce_unsafe_ptr(&self,\n-                             a: Ty<'tcx>,\n-                             b: Ty<'tcx>,\n-                             mutbl_b: ast::Mutability)\n-                             -> CoerceResult<'tcx> {\n+    fn coerce_unsafe_ptr(&self,\n+                         a: Ty<'tcx>,\n+                         b: Ty<'tcx>,\n+                         mutbl_b: ast::Mutability)\n+                         -> CoerceResult<'tcx> {\n         debug!(\"coerce_unsafe_ptr(a={}, b={})\",\n                a.repr(self.tcx()),\n                b.repr(self.tcx()));\n@@ -534,21 +526,25 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n     }\n }\n \n-pub type CoerceResult<'tcx> = cres<'tcx, Option<ty::AutoAdjustment<'tcx>>>;\n-\n-pub fn mk_coercety<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n-                             a_is_expected: bool,\n-                             origin: TypeOrigin,\n+pub fn mk_assignty<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                             expr: &ast::Expr,\n                              a: Ty<'tcx>,\n                              b: Ty<'tcx>)\n-                             -> CoerceResult<'tcx> {\n-    debug!(\"mk_coercety({} -> {})\", a.repr(cx.tcx), b.repr(cx.tcx));\n-    indent(|| {\n-        cx.commit_if_ok(|| {\n-            let trace = TypeTrace::types(origin, a_is_expected, a, b);\n-            Coerce(cx.combine_fields(a_is_expected, trace)).tys(a, b)\n+                             -> cres<'tcx, ()> {\n+    debug!(\"mk_assignty({} -> {})\", a.repr(fcx.tcx()), b.repr(fcx.tcx()));\n+    let adjustment = try!(indent(|| {\n+        fcx.infcx().commit_if_ok(|| {\n+            let origin = infer::ExprAssignable(expr.span);\n+            Coerce {\n+                fcx: fcx,\n+                trace: infer::TypeTrace::types(origin, false, a, b)\n+            }.coerce(a, b)\n         })\n-    })\n+    }));\n+    if let Some(adjustment) = adjustment {\n+        fcx.write_adjustment(expr.id, expr.span, adjustment);\n+    }\n+    Ok(())\n }\n \n fn can_coerce_mutbls(from_mutbl: ast::Mutability,"}, {"sha": "6f2d0cb3667418023cc69a0d954305d84bab85cb", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a478bdfd24ccc4df99a23d275a82e71a990115d/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a478bdfd24ccc4df99a23d275a82e71a990115d/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=6a478bdfd24ccc4df99a23d275a82e71a990115d", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n \n-use check::FnCtxt;\n+use check::{coercion, FnCtxt};\n use middle::ty::{self, Ty};\n use middle::infer;\n \n@@ -62,7 +62,7 @@ pub fn coerce<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>, sp: Span,\n            expr_ty.repr(fcx.ccx.tcx));\n     let expr_ty = fcx.resolve_type_vars_if_possible(expr_ty);\n     let expected = fcx.resolve_type_vars_if_possible(expected);\n-    match fcx.mk_assignty(expr, expr_ty, expected) {\n+    match coercion::mk_assignty(fcx, expr, expr_ty, expected) {\n       Ok(()) => { /* ok */ }\n       Err(ref err) => {\n         fcx.report_mismatched_types(sp, expected, expr_ty, err);"}, {"sha": "8d1a43cb08194cb589d40ce5946f4ee0ae86258d", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6a478bdfd24ccc4df99a23d275a82e71a990115d/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a478bdfd24ccc4df99a23d275a82e71a990115d/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=6a478bdfd24ccc4df99a23d275a82e71a990115d", "patch": "@@ -1726,24 +1726,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         infer::mk_subty(self.infcx(), a_is_expected, origin, sub, sup)\n     }\n \n-    pub fn mk_assignty(&self,\n-                       expr: &ast::Expr,\n-                       sub: Ty<'tcx>,\n-                       sup: Ty<'tcx>)\n-                       -> Result<(), ty::type_err<'tcx>> {\n-        match try!(coercion::mk_coercety(self.infcx(),\n-                                         false,\n-                                         infer::ExprAssignable(expr.span),\n-                                         sub,\n-                                         sup)) {\n-            None => {}\n-            Some(adjustment) => {\n-                self.write_adjustment(expr.id, expr.span, adjustment);\n-            }\n-        }\n-        Ok(())\n-    }\n-\n     pub fn mk_eqty(&self,\n                    a_is_expected: bool,\n                    origin: infer::TypeOrigin,"}]}