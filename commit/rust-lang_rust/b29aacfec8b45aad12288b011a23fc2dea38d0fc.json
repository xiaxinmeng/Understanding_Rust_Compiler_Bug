{"sha": "b29aacfec8b45aad12288b011a23fc2dea38d0fc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyOWFhY2ZlYzhiNDVhYWQxMjI4OGIwMTFhMjNmYzJkZWEzOGQwZmM=", "commit": {"author": {"name": "ThibsG", "email": "Thibs@debian.com", "date": "2020-01-26T16:03:39Z"}, "committer": {"name": "ThibsG", "email": "Thibs@debian.com", "date": "2020-02-04T21:53:24Z"}, "message": "Add wild and struct handling", "tree": {"sha": "81865cad6da8be174e1468ed527bd0a7bc09dce8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/81865cad6da8be174e1468ed527bd0a7bc09dce8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b29aacfec8b45aad12288b011a23fc2dea38d0fc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b29aacfec8b45aad12288b011a23fc2dea38d0fc", "html_url": "https://github.com/rust-lang/rust/commit/b29aacfec8b45aad12288b011a23fc2dea38d0fc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b29aacfec8b45aad12288b011a23fc2dea38d0fc/comments", "author": {"login": "ThibsG", "id": 12683889, "node_id": "MDQ6VXNlcjEyNjgzODg5", "avatar_url": "https://avatars.githubusercontent.com/u/12683889?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ThibsG", "html_url": "https://github.com/ThibsG", "followers_url": "https://api.github.com/users/ThibsG/followers", "following_url": "https://api.github.com/users/ThibsG/following{/other_user}", "gists_url": "https://api.github.com/users/ThibsG/gists{/gist_id}", "starred_url": "https://api.github.com/users/ThibsG/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ThibsG/subscriptions", "organizations_url": "https://api.github.com/users/ThibsG/orgs", "repos_url": "https://api.github.com/users/ThibsG/repos", "events_url": "https://api.github.com/users/ThibsG/events{/privacy}", "received_events_url": "https://api.github.com/users/ThibsG/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ThibsG", "id": 12683889, "node_id": "MDQ6VXNlcjEyNjgzODg5", "avatar_url": "https://avatars.githubusercontent.com/u/12683889?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ThibsG", "html_url": "https://github.com/ThibsG", "followers_url": "https://api.github.com/users/ThibsG/followers", "following_url": "https://api.github.com/users/ThibsG/following{/other_user}", "gists_url": "https://api.github.com/users/ThibsG/gists{/gist_id}", "starred_url": "https://api.github.com/users/ThibsG/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ThibsG/subscriptions", "organizations_url": "https://api.github.com/users/ThibsG/orgs", "repos_url": "https://api.github.com/users/ThibsG/repos", "events_url": "https://api.github.com/users/ThibsG/events{/privacy}", "received_events_url": "https://api.github.com/users/ThibsG/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6afd7ea147cf34eb2ce505d513664b5f4fadfb58", "url": "https://api.github.com/repos/rust-lang/rust/commits/6afd7ea147cf34eb2ce505d513664b5f4fadfb58", "html_url": "https://github.com/rust-lang/rust/commit/6afd7ea147cf34eb2ce505d513664b5f4fadfb58"}], "stats": {"total": 308, "additions": 272, "deletions": 36}, "files": [{"sha": "2323df1f0fca635c8a0caed4526ceffae5d1b897", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 59, "deletions": 29, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/b29aacfec8b45aad12288b011a23fc2dea38d0fc/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b29aacfec8b45aad12288b011a23fc2dea38d0fc/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=b29aacfec8b45aad12288b011a23fc2dea38d0fc", "patch": "@@ -3,9 +3,9 @@ use crate::utils::paths;\n use crate::utils::sugg::Sugg;\n use crate::utils::usage::is_unused;\n use crate::utils::{\n-    span_lint_and_help, span_lint_and_note, \n-    expr_block, in_macro, is_allowed, is_expn_of, is_wild, match_qpath, match_type, multispan_sugg, remove_blocks,\n-    snippet, snippet_block, snippet_with_applicability,  span_lint_and_sugg, span_lint_and_then,\n+    expr_block, get_arg_name, in_macro, is_allowed, is_expn_of, is_refutable, is_wild, match_qpath, match_type,\n+    match_var, multispan_sugg, remove_blocks, snippet, snippet_block, snippet_with_applicability, span_lint_and_help,\n+    span_lint_and_note, span_lint_and_sugg, span_lint_and_then, walk_ptrs_ty,\n };\n use if_chain::if_chain;\n use rustc::lint::in_external_macro;\n@@ -822,36 +822,66 @@ fn check_wild_in_or_pats(cx: &LateContext<'_, '_>, arms: &[Arm<'_>]) {\n }\n \n fn check_match_single_binding(cx: &LateContext<'_, '_>, ex: &Expr<'_>, arms: &[Arm<'_>], expr: &Expr<'_>) {\n-    if in_macro(expr.span) {\n+    if in_macro(expr.span) || arms.len() != 1 || is_refutable(cx, arms[0].pat) {\n         return;\n     }\n-    if arms.len() == 1 {\n-        if is_refutable(cx, arms[0].pat) {\n-            return;\n-        }\n-        match arms[0].pat.kind {\n-            PatKind::Binding(..) | PatKind::Tuple(_, _) => {\n-                let bind_names = arms[0].pat.span;\n-                let matched_vars = ex.span;\n-                let match_body = remove_blocks(&arms[0].body);\n-                span_lint_and_sugg(\n-                    cx,\n-                    MATCH_SINGLE_BINDING,\n-                    expr.span,\n-                    \"this match could be written as a `let` statement\",\n-                    \"consider using `let` statement\",\n-                    format!(\n-                        \"let {} = {};\\n{}\",\n-                        snippet(cx, bind_names, \"..\"),\n-                        snippet(cx, matched_vars, \"..\"),\n-                        snippet_block(cx, match_body.span, \"..\")\n-                    ),\n-                    Applicability::MachineApplicable,\n-                );\n-            },\n-            _ => (),\n+    let matched_vars = ex.span;\n+    let bind_names = arms[0].pat.span;\n+    let match_body = remove_blocks(&arms[0].body);\n+    let mut snippet_body = if match_body.span.from_expansion() {\n+        Sugg::hir_with_macro_callsite(cx, match_body, \"..\").to_string()\n+    } else {\n+        snippet_block(cx, match_body.span, \"..\").to_owned().to_string()\n+    };\n+\n+    // Do we need to add ';' to suggestion ?\n+    if_chain! {\n+        if let ExprKind::Block(block, _) = &arms[0].body.kind;\n+        if block.stmts.len() == 1;\n+        if let StmtKind::Semi(s) = block.stmts.get(0).unwrap().kind;\n+        then {\n+            match s.kind {\n+                ExprKind::Block(_, _) => (),\n+                _ => {\n+                    // expr_ty(body) == ()\n+                    if cx.tables.expr_ty(&arms[0].body).is_unit() {\n+                        snippet_body.push(';');\n+                    }\n+                }\n+            }\n         }\n     }\n+\n+    match arms[0].pat.kind {\n+        PatKind::Binding(..) | PatKind::Tuple(_, _) | PatKind::Struct(..) => {\n+            span_lint_and_sugg(\n+                cx,\n+                MATCH_SINGLE_BINDING,\n+                expr.span,\n+                \"this match could be written as a `let` statement\",\n+                \"consider using `let` statement\",\n+                format!(\n+                    \"let {} = {};\\n{}\",\n+                    snippet(cx, bind_names, \"..\"),\n+                    snippet(cx, matched_vars, \"..\"),\n+                    snippet_body\n+                ),\n+                Applicability::MachineApplicable,\n+            );\n+        },\n+        PatKind::Wild => {\n+            span_lint_and_sugg(\n+                cx,\n+                MATCH_SINGLE_BINDING,\n+                expr.span,\n+                \"this match could be replaced by its body itself\",\n+                \"consider using the match body instead\",\n+                snippet_body,\n+                Applicability::MachineApplicable,\n+            );\n+        },\n+        _ => (),\n+    }\n }\n \n /// Gets all arms that are unbounded `PatRange`s."}, {"sha": "c0a52d832c00a2793fa49252ab0bbb88c511e4c0", "filename": "tests/ui/escape_analysis.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b29aacfec8b45aad12288b011a23fc2dea38d0fc/tests%2Fui%2Fescape_analysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b29aacfec8b45aad12288b011a23fc2dea38d0fc/tests%2Fui%2Fescape_analysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fescape_analysis.rs?ref=b29aacfec8b45aad12288b011a23fc2dea38d0fc", "patch": "@@ -4,6 +4,7 @@\n     clippy::needless_pass_by_value,\n     clippy::unused_unit,\n     clippy::redundant_clone,\n+    clippy::match_single_binding\n )]\n #![warn(clippy::boxed_local)]\n "}, {"sha": "5de43733ad33601a1108985bdb686b0d10d332e1", "filename": "tests/ui/match_ref_pats.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b29aacfec8b45aad12288b011a23fc2dea38d0fc/tests%2Fui%2Fmatch_ref_pats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b29aacfec8b45aad12288b011a23fc2dea38d0fc/tests%2Fui%2Fmatch_ref_pats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_ref_pats.rs?ref=b29aacfec8b45aad12288b011a23fc2dea38d0fc", "patch": "@@ -26,6 +26,7 @@ fn ref_pats() {\n     }\n     // False positive: only wildcard pattern.\n     let w = Some(0);\n+    #[allow(clippy::match_single_binding)]\n     match w {\n         _ => println!(\"none\"),\n     }"}, {"sha": "52cb4a14b72bcecce5de2cf219fc616ccfa2e7b6", "filename": "tests/ui/match_ref_pats.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b29aacfec8b45aad12288b011a23fc2dea38d0fc/tests%2Fui%2Fmatch_ref_pats.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b29aacfec8b45aad12288b011a23fc2dea38d0fc/tests%2Fui%2Fmatch_ref_pats.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_ref_pats.stderr?ref=b29aacfec8b45aad12288b011a23fc2dea38d0fc", "patch": "@@ -47,7 +47,7 @@ LL |         None => println!(\"none\"),\n    |\n \n error: you don't need to add `&` to all patterns\n-  --> $DIR/match_ref_pats.rs:34:5\n+  --> $DIR/match_ref_pats.rs:35:5\n    |\n LL | /     if let &None = a {\n LL | |         println!(\"none\");\n@@ -60,7 +60,7 @@ LL |     if let None = *a {\n    |            ^^^^   ^^\n \n error: you don't need to add `&` to both the expression and the patterns\n-  --> $DIR/match_ref_pats.rs:39:5\n+  --> $DIR/match_ref_pats.rs:40:5\n    |\n LL | /     if let &None = &b {\n LL | |         println!(\"none\");\n@@ -73,7 +73,7 @@ LL |     if let None = b {\n    |            ^^^^   ^\n \n error: you don't need to add `&` to all patterns\n-  --> $DIR/match_ref_pats.rs:66:9\n+  --> $DIR/match_ref_pats.rs:67:9\n    |\n LL | /         match foo_variant!(0) {\n LL | |             &Foo::A => println!(\"A\"),"}, {"sha": "8fb8dc323e4302b41d35f77b854c7a9208da6904", "filename": "tests/ui/match_single_binding.fixed", "status": "modified", "additions": 38, "deletions": 1, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/b29aacfec8b45aad12288b011a23fc2dea38d0fc/tests%2Fui%2Fmatch_single_binding.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/b29aacfec8b45aad12288b011a23fc2dea38d0fc/tests%2Fui%2Fmatch_single_binding.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_single_binding.fixed?ref=b29aacfec8b45aad12288b011a23fc2dea38d0fc", "patch": "@@ -1,7 +1,12 @@\n // run-rustfix\n \n #![warn(clippy::match_single_binding)]\n-#[allow(clippy::many_single_char_names)]\n+#![allow(clippy::many_single_char_names, clippy::toplevel_ref_arg)]\n+\n+struct Point {\n+    x: i32,\n+    y: i32,\n+}\n \n fn main() {\n     let a = 1;\n@@ -12,6 +17,9 @@ fn main() {\n {\n     println!(\"{} {} {}\", x, y, z);\n }\n+    // Lint\n+    let (x, y, z) = (a, b, c);\n+println!(\"{} {} {}\", x, y, z);\n     // Ok\n     match a {\n         2 => println!(\"2\"),\n@@ -23,4 +31,33 @@ fn main() {\n         Some(d) => println!(\"{}\", d),\n         _ => println!(\"None\"),\n     }\n+    // Lint\n+    println!(\"whatever\");\n+    // Lint\n+    {\n+    let x = 29;\n+    println!(\"x has a value of {}\", x);\n+}\n+    // Lint\n+    {\n+    let e = 5 * a;\n+    if e >= 5 {\n+        println!(\"e is superior to 5\");\n+    }\n+}\n+    // Lint\n+    let p = Point { x: 0, y: 7 };\n+    let Point { x, y } = p;\n+println!(\"Coords: ({}, {})\", x, y);\n+    // Lint\n+    let Point { x: x1, y: y1 } = p;\n+println!(\"Coords: ({}, {})\", x1, y1);\n+    // Lint\n+    let x = 5;\n+    let ref r = x;\n+println!(\"Got a reference to {}\", r);\n+    // Lint\n+    let mut x = 5;\n+    let ref mut mr = x;\n+println!(\"Got a mutable reference to {}\", mr);\n }"}, {"sha": "55b0b09a008842805492ba598f204a222d784844", "filename": "tests/ui/match_single_binding.rs", "status": "modified", "additions": 49, "deletions": 1, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/b29aacfec8b45aad12288b011a23fc2dea38d0fc/tests%2Fui%2Fmatch_single_binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b29aacfec8b45aad12288b011a23fc2dea38d0fc/tests%2Fui%2Fmatch_single_binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_single_binding.rs?ref=b29aacfec8b45aad12288b011a23fc2dea38d0fc", "patch": "@@ -1,7 +1,12 @@\n // run-rustfix\n \n #![warn(clippy::match_single_binding)]\n-#[allow(clippy::many_single_char_names)]\n+#![allow(clippy::many_single_char_names, clippy::toplevel_ref_arg)]\n+\n+struct Point {\n+    x: i32,\n+    y: i32,\n+}\n \n fn main() {\n     let a = 1;\n@@ -13,6 +18,10 @@ fn main() {\n             println!(\"{} {} {}\", x, y, z);\n         },\n     }\n+    // Lint\n+    match (a, b, c) {\n+        (x, y, z) => println!(\"{} {} {}\", x, y, z),\n+    }\n     // Ok\n     match a {\n         2 => println!(\"2\"),\n@@ -24,4 +33,43 @@ fn main() {\n         Some(d) => println!(\"{}\", d),\n         _ => println!(\"None\"),\n     }\n+    // Lint\n+    match a {\n+        _ => println!(\"whatever\"),\n+    }\n+    // Lint\n+    match a {\n+        _ => {\n+            let x = 29;\n+            println!(\"x has a value of {}\", x);\n+        },\n+    }\n+    // Lint\n+    match a {\n+        _ => {\n+            let e = 5 * a;\n+            if e >= 5 {\n+                println!(\"e is superior to 5\");\n+            }\n+        },\n+    }\n+    // Lint\n+    let p = Point { x: 0, y: 7 };\n+    match p {\n+        Point { x, y } => println!(\"Coords: ({}, {})\", x, y),\n+    }\n+    // Lint\n+    match p {\n+        Point { x: x1, y: y1 } => println!(\"Coords: ({}, {})\", x1, y1),\n+    }\n+    // Lint\n+    let x = 5;\n+    match x {\n+        ref r => println!(\"Got a reference to {}\", r),\n+    }\n+    // Lint\n+    let mut x = 5;\n+    match x {\n+        ref mut mr => println!(\"Got a mutable reference to {}\", mr),\n+    }\n }"}, {"sha": "d76e229adff095c5ed51f05caf70fa5f48dd649b", "filename": "tests/ui/match_single_binding.stderr", "status": "modified", "additions": 121, "deletions": 2, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/b29aacfec8b45aad12288b011a23fc2dea38d0fc/tests%2Fui%2Fmatch_single_binding.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b29aacfec8b45aad12288b011a23fc2dea38d0fc/tests%2Fui%2Fmatch_single_binding.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_single_binding.stderr?ref=b29aacfec8b45aad12288b011a23fc2dea38d0fc", "patch": "@@ -1,5 +1,5 @@\n error: this match could be written as a `let` statement\n-  --> $DIR/match_single_binding.rs:11:5\n+  --> $DIR/match_single_binding.rs:16:5\n    |\n LL | /     match (a, b, c) {\n LL | |         (x, y, z) => {\n@@ -17,5 +17,124 @@ LL |     println!(\"{} {} {}\", x, y, z);\n LL | }\n    |\n \n-error: aborting due to previous error\n+error: this match could be written as a `let` statement\n+  --> $DIR/match_single_binding.rs:22:5\n+   |\n+LL | /     match (a, b, c) {\n+LL | |         (x, y, z) => println!(\"{} {} {}\", x, y, z),\n+LL | |     }\n+   | |_____^\n+   |\n+help: consider using `let` statement\n+   |\n+LL |     let (x, y, z) = (a, b, c);\n+LL | println!(\"{} {} {}\", x, y, z);\n+   |\n+\n+error: this match could be replaced by its body itself\n+  --> $DIR/match_single_binding.rs:37:5\n+   |\n+LL | /     match a {\n+LL | |         _ => println!(\"whatever\"),\n+LL | |     }\n+   | |_____^ help: consider using the match body instead: `println!(\"whatever\");`\n+\n+error: this match could be replaced by its body itself\n+  --> $DIR/match_single_binding.rs:41:5\n+   |\n+LL | /     match a {\n+LL | |         _ => {\n+LL | |             let x = 29;\n+LL | |             println!(\"x has a value of {}\", x);\n+LL | |         },\n+LL | |     }\n+   | |_____^\n+   |\n+help: consider using the match body instead\n+   |\n+LL |     {\n+LL |     let x = 29;\n+LL |     println!(\"x has a value of {}\", x);\n+LL | }\n+   |\n+\n+error: this match could be replaced by its body itself\n+  --> $DIR/match_single_binding.rs:48:5\n+   |\n+LL | /     match a {\n+LL | |         _ => {\n+LL | |             let e = 5 * a;\n+LL | |             if e >= 5 {\n+...  |\n+LL | |         },\n+LL | |     }\n+   | |_____^\n+   |\n+help: consider using the match body instead\n+   |\n+LL |     {\n+LL |     let e = 5 * a;\n+LL |     if e >= 5 {\n+LL |         println!(\"e is superior to 5\");\n+LL |     }\n+LL | }\n+   |\n+\n+error: this match could be written as a `let` statement\n+  --> $DIR/match_single_binding.rs:58:5\n+   |\n+LL | /     match p {\n+LL | |         Point { x, y } => println!(\"Coords: ({}, {})\", x, y),\n+LL | |     }\n+   | |_____^\n+   |\n+help: consider using `let` statement\n+   |\n+LL |     let Point { x, y } = p;\n+LL | println!(\"Coords: ({}, {})\", x, y);\n+   |\n+\n+error: this match could be written as a `let` statement\n+  --> $DIR/match_single_binding.rs:62:5\n+   |\n+LL | /     match p {\n+LL | |         Point { x: x1, y: y1 } => println!(\"Coords: ({}, {})\", x1, y1),\n+LL | |     }\n+   | |_____^\n+   |\n+help: consider using `let` statement\n+   |\n+LL |     let Point { x: x1, y: y1 } = p;\n+LL | println!(\"Coords: ({}, {})\", x1, y1);\n+   |\n+\n+error: this match could be written as a `let` statement\n+  --> $DIR/match_single_binding.rs:67:5\n+   |\n+LL | /     match x {\n+LL | |         ref r => println!(\"Got a reference to {}\", r),\n+LL | |     }\n+   | |_____^\n+   |\n+help: consider using `let` statement\n+   |\n+LL |     let ref r = x;\n+LL | println!(\"Got a reference to {}\", r);\n+   |\n+\n+error: this match could be written as a `let` statement\n+  --> $DIR/match_single_binding.rs:72:5\n+   |\n+LL | /     match x {\n+LL | |         ref mut mr => println!(\"Got a mutable reference to {}\", mr),\n+LL | |     }\n+   | |_____^\n+   |\n+help: consider using `let` statement\n+   |\n+LL |     let ref mut mr = x;\n+LL | println!(\"Got a mutable reference to {}\", mr);\n+   |\n+\n+error: aborting due to 9 previous errors\n "}]}