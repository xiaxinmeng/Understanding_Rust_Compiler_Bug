{"sha": "62f0fe0cc0504217ffc23b2fb8b69d3bed648be9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYyZjBmZTBjYzA1MDQyMTdmZmMyM2IyZmI4YjY5ZDNiZWQ2NDhiZTk=", "commit": {"author": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2015-05-23T10:43:24Z"}, "committer": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2015-05-23T10:43:24Z"}, "message": "Merge pull request #66 from Manishearth/refactoring\n\nanother refactoring\u2026", "tree": {"sha": "3e4635abdcca97b09d252b79a72915fd8590c6b8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3e4635abdcca97b09d252b79a72915fd8590c6b8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/62f0fe0cc0504217ffc23b2fb8b69d3bed648be9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/62f0fe0cc0504217ffc23b2fb8b69d3bed648be9", "html_url": "https://github.com/rust-lang/rust/commit/62f0fe0cc0504217ffc23b2fb8b69d3bed648be9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/62f0fe0cc0504217ffc23b2fb8b69d3bed648be9/comments", "author": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "committer": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "450c0fb40c3b2bdd93a3ceff08efad468cb82dd7", "url": "https://api.github.com/repos/rust-lang/rust/commits/450c0fb40c3b2bdd93a3ceff08efad468cb82dd7", "html_url": "https://github.com/rust-lang/rust/commit/450c0fb40c3b2bdd93a3ceff08efad468cb82dd7"}, {"sha": "b51ca1c3db2c4d2195f325c28bdff83c771705ca", "url": "https://api.github.com/repos/rust-lang/rust/commits/b51ca1c3db2c4d2195f325c28bdff83c771705ca", "html_url": "https://github.com/rust-lang/rust/commit/b51ca1c3db2c4d2195f325c28bdff83c771705ca"}], "stats": {"total": 288, "additions": 148, "deletions": 140}, "files": [{"sha": "352826dffaeacba7b56648ac9811f13420c7683d", "filename": "src/bit_mask.rs", "status": "modified", "additions": 33, "deletions": 31, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/62f0fe0cc0504217ffc23b2fb8b69d3bed648be9/src%2Fbit_mask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62f0fe0cc0504217ffc23b2fb8b69d3bed648be9/src%2Fbit_mask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbit_mask.rs?ref=62f0fe0cc0504217ffc23b2fb8b69d3bed648be9", "patch": "@@ -1,22 +1,3 @@\n-//! Checks for incompatible bit masks in comparisons, e.g. `x & 1 == 2`. This cannot work because the bit that makes up\n-//! the value two was zeroed out by the bit-and with 1. So the formula for detecting if an expression of the type \n-//! `_ <bit_op> m <cmp_op> c` (where `<bit_op>` is one of {`&`, '|'} and `<cmp_op>` is one of {`!=`, `>=`, `>` ,`!=`, `>=`, \n-//! `>`}) can be determined from the following table:\n-//! \n-//! |Comparison  |Bit-Op|Example     |is always|Formula               |\n-//! |------------|------|------------|---------|----------------------|\n-//! |`==` or `!=`| `&`  |`x & 2 == 3`|`false`  |`c & m != c`          |\n-//! |`<`  or `>=`| `&`  |`x & 2 < 3` |`true`   |`m < c`               |\n-//! |`>`  or `<=`| `&`  |`x & 1 > 1` |`false`  |`m <= c`              |\n-//! |`==` or `!=`| `|`  |`x | 1 == 0`|`false`  |`c | m != c`          |\n-//! |`<`  or `>=`| `|`  |`x | 1 < 1` |`false`  |`m >= c`\t\t\t  |\n-//! |`<=` or `>` | `|`  |`x | 1 > 0` |`true`   |`m > c`               |\n-//! \n-//! *TODO*: There is the open question if things like `x | 1 > 1` should be caught by this lint, because it is basically\n-//! an obfuscated version of `x > 1`.\n-//! \n-//! This lint is **deny** by default\n-\n use rustc::plugin::Registry;\n use rustc::lint::*;\n use rustc::middle::const_eval::lookup_const_by_id;\n@@ -29,15 +10,37 @@ use syntax::codemap::Span;\n declare_lint! {\n     pub BAD_BIT_MASK,\n     Deny,\n-    \"Deny the use of incompatible bit masks in comparisons, e.g. '(a & 1) == 2'\"\n+    \"Deny the use of incompatible bit masks in comparisons, e.g. \\\n+    '(a & 1) == 2'\"\n }\n \n declare_lint! {\n \tpub INEFFECTIVE_BIT_MASK,\n \tWarn,\n-\t\"Warn on the use of an ineffective bit mask in comparisons, e.g. '(a & 1) > 2'\"\n+\t\"Warn on the use of an ineffective bit mask in comparisons, e.g. \\\n+\t'(a & 1) > 2'\"\n }\n \n+/// Checks for incompatible bit masks in comparisons, e.g. `x & 1 == 2`. \n+/// This cannot work because the bit that makes up the value two was\n+/// zeroed out by the bit-and with 1. So the formula for detecting if an\n+/// expression of the type  `_ <bit_op> m <cmp_op> c` (where `<bit_op>` \n+/// is one of {`&`, '|'} and `<cmp_op>` is one of {`!=`, `>=`, `>` , \n+/// `!=`, `>=`, `>`}) can be determined from the following table:\n+/// \n+/// |Comparison  |Bit-Op|Example     |is always|Formula               |\n+/// |------------|------|------------|---------|----------------------|\n+/// |`==` or `!=`| `&`  |`x & 2 == 3`|`false`  |`c & m != c`          |\n+/// |`<`  or `>=`| `&`  |`x & 2 < 3` |`true`   |`m < c`               |\n+/// |`>`  or `<=`| `&`  |`x & 1 > 1` |`false`  |`m <= c`              |\n+/// |`==` or `!=`| `|`  |`x | 1 == 0`|`false`  |`c | m != c`          |\n+/// |`<`  or `>=`| `|`  |`x | 1 < 1` |`false`  |`m >= c`              |\n+/// |`<=` or `>` | `|`  |`x | 1 > 0` |`true`   |`m > c`               |\n+/// \n+/// This lint is **deny** by default\n+///\n+/// There is also a lint that warns on ineffective masks that is *warn*\n+/// by default\n #[derive(Copy,Clone)]\n pub struct BitMask;\n \n@@ -49,11 +52,12 @@ impl LintPass for BitMask {\n     fn check_expr(&mut self, cx: &Context, e: &Expr) {\n         if let ExprBinary(ref cmp, ref left, ref right) = e.node {\n \t\t\tif is_comparison_binop(cmp.node) {\n-\t\t\t\tfetch_int_literal(cx, right).map(|cmp_opt| \n-\t\t\t\t\tcheck_compare(cx, left, cmp.node, cmp_opt, &e.span))\n-\t\t\t\t\t.unwrap_or_else(|| fetch_int_literal(cx, left).map(|cmp_val| \n-\t\t\t\t\t\tcheck_compare(cx, right, invert_cmp(cmp.node), cmp_val,\n-\t\t\t\t\t\t &e.span)).unwrap_or(()))\n+\t\t\t\tfetch_int_literal(cx, right).map_or_else(|| \n+\t\t\t\t\tfetch_int_literal(cx, left).map_or((), |cmp_val| \n+\t\t\t\t\t\tcheck_compare(cx, right, invert_cmp(cmp.node), \n+\t\t\t\t\t\t\tcmp_val, &e.span)), \n+\t\t\t\t\t|cmp_opt| check_compare(cx, left, cmp.node, cmp_opt,\n+\t\t\t\t\t\t&e.span))\n \t\t\t}\n \t\t}\n     }\n@@ -77,11 +81,9 @@ fn check_compare(cx: &Context, bit_op: &Expr, cmp_op: BinOp_, cmp_value: u64, sp\n \t\t&ExprParen(ref subexp) => check_compare(cx, subexp, cmp_op, cmp_value, span),\n \t\t&ExprBinary(ref op, ref left, ref right) => {\n \t\t\tif op.node != BiBitAnd && op.node != BiBitOr { return; }\n-\t\t\tif let Some(mask_value) = fetch_int_literal(cx, right) {\n-\t\t\t\tcheck_bit_mask(cx, op.node, cmp_op, mask_value, cmp_value, span);\n-\t\t\t} else if let Some(mask_value) = fetch_int_literal(cx, left) {\n-\t\t\t\tcheck_bit_mask(cx, op.node, cmp_op, mask_value, cmp_value, span);\n-\t\t\t}\n+\t\t\tfetch_int_literal(cx, right).or_else(|| fetch_int_literal(\n+\t\t\t\tcx, left)).map_or((), |mask| check_bit_mask(cx, op.node, \n+\t\t\t\t\tcmp_op, mask, cmp_value, span))\n \t\t},\n \t\t_ => ()\n \t}"}, {"sha": "94a49e748e2044e7e778088fbdcb1682959992ab", "filename": "src/eq_op.rs", "status": "modified", "additions": 52, "deletions": 42, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/62f0fe0cc0504217ffc23b2fb8b69d3bed648be9/src%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62f0fe0cc0504217ffc23b2fb8b69d3bed648be9/src%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feq_op.rs?ref=62f0fe0cc0504217ffc23b2fb8b69d3bed648be9", "patch": "@@ -33,18 +33,20 @@ fn is_exp_equal(left : &Expr, right : &Expr) -> bool {\n \tmatch (&left.node, &right.node) {\n \t\t(&ExprBinary(ref lop, ref ll, ref lr), \n \t\t\t\t&ExprBinary(ref rop, ref rl, ref rr)) => \n-\t\t\tlop.node == rop.node && is_exp_equal(ll, rl) && is_exp_equal(lr, rr),\n-\t\t(&ExprBox(ref lpl, ref lboxedpl), &ExprBox(ref rpl, ref rboxedpl)) => \n+\t\t\tlop.node == rop.node && \n+\t\t\tis_exp_equal(ll, rl) && is_exp_equal(lr, rr),\n+\t\t(&ExprBox(ref lpl, ref lbox), &ExprBox(ref rpl, ref rbox)) => \n \t\t\tboth(lpl, rpl, |l, r| is_exp_equal(l, r)) && \n-\t\t\t\tis_exp_equal(lboxedpl, rboxedpl),\n-\t\t(&ExprCall(ref lcallee, ref largs), &ExprCall(ref rcallee, ref rargs)) => \n-\t\t\tis_exp_equal(lcallee, rcallee) && is_exps_equal(largs, rargs),\n-\t\t(&ExprCast(ref lcast, ref lty), &ExprCast(ref rcast, ref rty)) => \n-\t\t\tis_ty_equal(lty, rty) && is_exp_equal(lcast, rcast),\n+\t\t\t\tis_exp_equal(lbox, rbox),\n+\t\t(&ExprCall(ref lcallee, ref largs), \n+\t\t &ExprCall(ref rcallee, ref rargs)) => is_exp_equal(lcallee, \n+\t\t\trcallee) && is_exps_equal(largs, rargs),\n+\t\t(&ExprCast(ref lc, ref lty), &ExprCast(ref rc, ref rty)) => \n+\t\t\tis_ty_equal(lty, rty) && is_exp_equal(lc, rc),\n \t\t(&ExprField(ref lfexp, ref lfident), \n \t\t\t\t&ExprField(ref rfexp, ref rfident)) => \n \t\t\tlfident.node == rfident.node && is_exp_equal(lfexp, rfexp),\n-\t\t(&ExprLit(ref llit), &ExprLit(ref rlit)) => llit.node == rlit.node,\n+\t\t(&ExprLit(ref l), &ExprLit(ref r)) => l.node == r.node,\n \t\t(&ExprMethodCall(ref lident, ref lcty, ref lmargs), \n \t\t\t\t&ExprMethodCall(ref rident, ref rcty, ref rmargs)) => \n \t\t\tlident.node == rident.node && is_tys_equal(lcty, rcty) && \n@@ -55,10 +57,11 @@ fn is_exp_equal(left : &Expr, right : &Expr) -> bool {\n \t\t\t\t&ExprPath(ref rqself, ref rsubpath)) => \n \t\t\tboth(lqself, rqself, |l, r| is_qself_equal(l, r)) && \n \t\t\t\tis_path_equal(lsubpath, rsubpath),\t\t\n-\t\t(&ExprTup(ref ltup), &ExprTup(ref rtup)) => is_exps_equal(ltup, rtup),\n-\t\t(&ExprUnary(lunop, ref lparam), &ExprUnary(runop, ref rparam)) => \n-\t\t\tlunop == runop && is_exp_equal(lparam, rparam), \n-\t\t(&ExprVec(ref lvec), &ExprVec(ref rvec)) => is_exps_equal(lvec, rvec),\n+\t\t(&ExprTup(ref ltup), &ExprTup(ref rtup)) => \n+\t\t\tis_exps_equal(ltup, rtup),\n+\t\t(&ExprUnary(lunop, ref l), &ExprUnary(runop, ref r)) => \n+\t\t\tlunop == runop && is_exp_equal(l, r), \n+\t\t(&ExprVec(ref l), &ExprVec(ref r)) => is_exps_equal(l, r),\n \t\t_ => false\n \t}\n }\n@@ -83,18 +86,17 @@ fn is_ty_equal(left : &Ty, right : &Ty) -> bool {\n \t\tis_ty_equal(lfvty, rfvty) && is_exp_equal(lfvexp, rfvexp),\n \t(&TyPtr(ref lmut), &TyPtr(ref rmut)) => is_mut_ty_equal(lmut, rmut),\n \t(&TyRptr(ref ltime, ref lrmut), &TyRptr(ref rtime, ref rrmut)) => \n-\t\tboth(ltime, rtime, is_lifetime_equal) && is_mut_ty_equal(lrmut, rrmut),\n+\t\tboth(ltime, rtime, is_lifetime_equal) && \n+\t\tis_mut_ty_equal(lrmut, rrmut),\n \t(&TyBareFn(ref lbare), &TyBareFn(ref rbare)) => \n \t\tis_bare_fn_ty_equal(lbare, rbare),\n     (&TyTup(ref ltup), &TyTup(ref rtup)) => is_tys_equal(ltup, rtup),\n-\t(&TyPath(Option::None, ref lpath), &TyPath(Option::None, ref rpath)) => \n-\t\tis_path_equal(lpath, rpath),\n-\t(&TyPath(Option::Some(ref lqself), ref lsubpath),\n-\t\t\t&TyPath(Option::Some(ref rqself), ref rsubpath)) =>\n-\t\tis_qself_equal(lqself, rqself) && is_path_equal(lsubpath, rsubpath),\n+\t(&TyPath(ref lq, ref lpath), &TyPath(ref rq, ref rpath)) => \n+\t\tboth(lq, rq, is_qself_equal) && is_path_equal(lpath, rpath),\n     (&TyObjectSum(ref lsumty, ref lobounds), \n \t\t\t&TyObjectSum(ref rsumty, ref robounds)) => \n-\t\tis_ty_equal(lsumty, rsumty) && is_param_bounds_equal(lobounds, robounds),\n+\t\tis_ty_equal(lsumty, rsumty) && \n+\t\tis_param_bounds_equal(lobounds, robounds),\n \t(&TyPolyTraitRef(ref ltbounds), &TyPolyTraitRef(ref rtbounds)) => \n \t\tis_param_bounds_equal(ltbounds, rtbounds),\n     (&TyParen(ref lty), &TyParen(ref rty)) => is_ty_equal(lty, rty),\n@@ -104,7 +106,8 @@ fn is_ty_equal(left : &Ty, right : &Ty) -> bool {\n \t}\n }\n \n-fn is_param_bound_equal(left : &TyParamBound, right : &TyParamBound) -> bool {\n+fn is_param_bound_equal(left : &TyParamBound, right : &TyParamBound) \n+\t\t-> bool {\n \tmatch(left, right) {\n \t(&TraitTyParamBound(ref lpoly, ref lmod), \n \t\t\t&TraitTyParamBound(ref rpoly, ref rmod)) => \n@@ -115,12 +118,14 @@ fn is_param_bound_equal(left : &TyParamBound, right : &TyParamBound) -> bool {\n \t}\n }\n \n-fn is_poly_traitref_equal(left : &PolyTraitRef, right : &PolyTraitRef) -> bool {\n-\tis_lifetimedefs_equal(&left.bound_lifetimes, &right.bound_lifetimes) && \n-\t\tis_path_equal(&left.trait_ref.path, &right.trait_ref.path)\n+fn is_poly_traitref_equal(left : &PolyTraitRef, right : &PolyTraitRef)\n+\t\t-> bool {\n+\tis_lifetimedefs_equal(&left.bound_lifetimes, &right.bound_lifetimes)\n+\t\t&& is_path_equal(&left.trait_ref.path, &right.trait_ref.path)\n }\n \n-fn is_param_bounds_equal(left : &TyParamBounds, right : &TyParamBounds) -> bool {\n+fn is_param_bounds_equal(left : &TyParamBounds, right : &TyParamBounds)\n+\t\t-> bool {\n \tover(left, right, is_param_bound_equal)\n }\n \n@@ -135,20 +140,23 @@ fn is_bare_fn_ty_equal(left : &BareFnTy, right : &BareFnTy) -> bool {\n } \n \n fn is_fndecl_equal(left : &P<FnDecl>, right : &P<FnDecl>) -> bool {\n-\tleft.variadic == right.variadic && is_args_equal(&left.inputs, &right.inputs) && \n+\tleft.variadic == right.variadic && \n+\t\tis_args_equal(&left.inputs, &right.inputs) && \n \t\tis_fnret_ty_equal(&left.output, &right.output)\n }\n \n-fn is_fnret_ty_equal(left : &FunctionRetTy, right : &FunctionRetTy) -> bool {\n+fn is_fnret_ty_equal(left : &FunctionRetTy, right : &FunctionRetTy) \n+\t\t-> bool {\n \tmatch (left, right) {\n-\t(&NoReturn(_), &NoReturn(_)) | (&DefaultReturn(_), &DefaultReturn(_)) => true,\n+\t(&NoReturn(_), &NoReturn(_)) | \n+\t(&DefaultReturn(_), &DefaultReturn(_)) => true,\n \t(&Return(ref lty), &Return(ref rty)) => is_ty_equal(lty, rty),\n \t_ => false\t\n \t}\n }\n \n-fn is_arg_equal(left : &Arg, right : &Arg) -> bool {\n-\tis_ty_equal(&left.ty, &right.ty) && is_pat_equal(&left.pat, &right.pat)\n+fn is_arg_equal(l: &Arg, r : &Arg) -> bool {\n+\tis_ty_equal(&l.ty, &r.ty) && is_pat_equal(&l.pat, &r.pat)\n }\n \n fn is_args_equal(left : &[Arg], right : &[Arg]) -> bool {\n@@ -165,17 +173,16 @@ fn is_pat_equal(left : &Pat, right : &Pat) -> bool {\n \t\t\t&PatIdent(ref rmode, ref rident, Option::Some(ref rpat))) =>\n \t\tlmode == rmode && is_ident_equal(&lident.node, &rident.node) && \n \t\t\tis_pat_equal(lpat, rpat),\n-    (&PatEnum(ref lpath, Option::None), &PatEnum(ref rpath, Option::None)) => \n-\t\tis_path_equal(lpath, rpath),\n-    (&PatEnum(ref lpath, Option::Some(ref lenum)), \n-\t\t\t&PatEnum(ref rpath, Option::Some(ref renum))) => \n-\t\tis_path_equal(lpath, rpath) && is_pats_equal(lenum, renum),  \n+    (&PatEnum(ref lpath, ref lenum), &PatEnum(ref rpath, ref renum)) => \n+\t\tis_path_equal(lpath, rpath) && both(lenum, renum, |l, r| \n+\t\t\tis_pats_equal(l, r)),\n     (&PatStruct(ref lpath, ref lfieldpat, lbool), \n \t\t\t&PatStruct(ref rpath, ref rfieldpat, rbool)) =>\n \t\tlbool == rbool && is_path_equal(lpath, rpath) && \n \t\t\tis_spanned_fieldpats_equal(lfieldpat, rfieldpat),\n     (&PatTup(ref ltup), &PatTup(ref rtup)) => is_pats_equal(ltup, rtup), \n-    (&PatBox(ref lboxed), &PatBox(ref rboxed)) => is_pat_equal(lboxed, rboxed),\n+    (&PatBox(ref lboxed), &PatBox(ref rboxed)) => \n+\t\tis_pat_equal(lboxed, rboxed),\n     (&PatRegion(ref lpat, ref lmut), &PatRegion(ref rpat, ref rmut)) => \n \t\tis_pat_equal(lpat, rpat) && lmut == rmut,\n \t(&PatLit(ref llit), &PatLit(ref rlit)) => is_exp_equal(llit, rlit),\n@@ -212,12 +219,14 @@ fn is_pats_equal(left : &[P<Pat>], right : &[P<Pat>]) -> bool {\n \tover(left, right, |l, r| is_pat_equal(l, r))\n }\n \n-fn is_lifetimedef_equal(left : &LifetimeDef, right : &LifetimeDef) -> bool {\n+fn is_lifetimedef_equal(left : &LifetimeDef, right : &LifetimeDef)\n+\t\t-> bool {\n \tis_lifetime_equal(&left.lifetime, &right.lifetime) && \n \t\tover(&left.bounds, &right.bounds, is_lifetime_equal)\n }\n \n-fn is_lifetimedefs_equal(left : &[LifetimeDef], right : &[LifetimeDef]) -> bool {\n+fn is_lifetimedefs_equal(left : &[LifetimeDef], right : &[LifetimeDef]) \n+\t\t-> bool {\n \tover(left, right, is_lifetimedef_equal)\n }\n \n@@ -231,19 +240,20 @@ fn is_tys_equal(left : &[P<Ty>], right : &[P<Ty>]) -> bool {\n \n fn over<X, F>(left: &[X], right: &[X], mut eq_fn: F) -> bool \n \t\twhere F: FnMut(&X, &X) -> bool {\n-    left.len() == right.len() && left.iter().zip(right).all(|(x, y)| eq_fn(x, y))\n+    left.len() == right.len() && left.iter().zip(right).all(|(x, y)| \n+\t\teq_fn(x, y))\n }\n \n fn both<X, F>(l: &Option<X>, r: &Option<X>, mut eq_fn : F) -> bool \n \t\twhere F: FnMut(&X, &X) -> bool {\n-\tl.as_ref().map(|x| r.as_ref().map(|y| eq_fn(x, y)).unwrap_or(false))\n-\t\t.unwrap_or_else(|| r.is_none())\n+\tl.as_ref().map_or_else(|| r.is_none(), |x| r.as_ref().map_or(false,\n+\t\t|y| eq_fn(x, y)))\n }\n \n fn is_cmp_or_bit(op : &BinOp) -> bool {\n     match op.node {\n-        BiEq | BiLt | BiLe | BiGt | BiGe | BiNe | BiAnd | BiOr | BiBitXor | \n-\t\tBiBitAnd | BiBitOr => true,\n+        BiEq | BiLt | BiLe | BiGt | BiGe | BiNe | BiAnd | BiOr | \n+        BiBitXor | BiBitAnd | BiBitOr => true,\n         _ => false\n     }\n }"}, {"sha": "25697199dc39b809f0e686daa87c50ea63f0c794", "filename": "src/identity_op.rs", "status": "modified", "additions": 50, "deletions": 52, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/62f0fe0cc0504217ffc23b2fb8b69d3bed648be9/src%2Fidentity_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62f0fe0cc0504217ffc23b2fb8b69d3bed648be9/src%2Fidentity_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fidentity_op.rs?ref=62f0fe0cc0504217ffc23b2fb8b69d3bed648be9", "patch": "@@ -17,66 +17,64 @@ impl LintPass for IdentityOp {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(IDENTITY_OP)\n     }\n-    \n+\n     fn check_expr(&mut self, cx: &Context, e: &Expr) {\n-\t\tif let ExprBinary(ref cmp, ref left, ref right) = e.node {\n-\t\t\tmatch cmp.node {\n-\t\t\t\tBiAdd | BiBitOr | BiBitXor => {\n-\t\t\t\t\tcheck(cx, left, 0, e.span, right.span);\n-\t\t\t\t\tcheck(cx, right, 0, e.span, left.span);\n-\t\t\t\t},\n-\t\t\t\tBiShl | BiShr | BiSub => \n-\t\t\t\t\tcheck(cx, right, 0, e.span, left.span),\n-\t\t\t\tBiMul => {\n-\t\t\t\t\tcheck(cx, left, 1, e.span, right.span);\n-\t\t\t\t\tcheck(cx, right, 1, e.span, left.span);\n-\t\t\t\t},\n-\t\t\t\tBiDiv =>\n-\t\t\t\t\tcheck(cx, right, 1, e.span, left.span),\n-\t\t\t\tBiBitAnd => {\n-\t\t\t\t\tcheck(cx, left, -1, e.span, right.span);\n-\t\t\t\t\tcheck(cx, right, -1, e.span, left.span);\n-\t\t\t\t},\n-\t\t\t\t_ => ()\n-\t\t\t}\n-\t\t}\n+        if let ExprBinary(ref cmp, ref left, ref right) = e.node {\n+            match cmp.node {\n+                BiAdd | BiBitOr | BiBitXor => {\n+                    check(cx, left, 0, e.span, right.span);\n+                    check(cx, right, 0, e.span, left.span);\n+                },\n+                BiShl | BiShr | BiSub => \n+                    check(cx, right, 0, e.span, left.span),\n+                BiMul => {\n+                    check(cx, left, 1, e.span, right.span);\n+                    check(cx, right, 1, e.span, left.span);\n+                },\n+                BiDiv =>\n+                    check(cx, right, 1, e.span, left.span),\n+                BiBitAnd => {\n+                    check(cx, left, -1, e.span, right.span);\n+                    check(cx, right, -1, e.span, left.span);\n+                },\n+                _ => ()\n+            }\n+        }\n     }\n }\n \n \n fn check(cx: &Context, e: &Expr, m: i8, span: Span, arg: Span) {\n-\tif have_lit(cx, e, m) {\n-\t\tlet map = cx.sess().codemap();\n-\t\tcx.span_lint(IDENTITY_OP, span, &format!(\n-\t\t\t\"The operation is ineffective. Consider reducing it to '{}'\", \n-\t\t\t&*map.span_to_snippet(arg).unwrap_or(\"..\".to_string())));\n-\t}\n+    if have_lit(cx, e, m) {\n+        let map = cx.sess().codemap();\n+        cx.span_lint(IDENTITY_OP, span, &format!(\n+            \"The operation is ineffective. Consider reducing it to '{}'\", \n+            &*map.span_to_snippet(arg).unwrap_or(\"..\".to_string())));\n+    }\n }\n \n fn have_lit(cx: &Context, e : &Expr, m: i8) -> bool {\n-\tmatch &e.node {\n-\t\t&ExprUnary(UnNeg, ref litexp) => have_lit(cx, litexp, -m), \n-\t\t&ExprLit(ref lit) => {\n-\t\t\tmatch (&lit.node, m) {\n-\t\t\t\t(&LitInt(0, _), 0) => true,\n-\t\t\t\t(&LitInt(1, SignedIntLit(_, Plus)), 1) => true,\n-\t\t\t\t(&LitInt(1, UnsuffixedIntLit(Plus)), 1) => true,\n-\t\t\t\t(&LitInt(1, SignedIntLit(_, Minus)), -1) => true,\n-\t\t\t\t(&LitInt(1, UnsuffixedIntLit(Minus)), -1) => true,\n-\t\t\t\t_ => false\n-\t\t\t}\n-\t\t},\n-\t\t&ExprParen(ref p) => have_lit(cx, p, m),\n-\t\t&ExprPath(_, _) => {\n-                match cx.tcx.def_map.borrow().get(&e.id) {\n-                    Some(&PathResolution { base_def: DefConst(def_id), ..}) => \n-\t\t\t\t\t\tmatch lookup_const_by_id(cx.tcx, def_id, Option::None) {\n-\t\t\t\t\t\t\tSome(l) => have_lit(cx, l, m),\n-\t\t\t\t\t\t\tNone => false\n-\t\t\t\t\t\t},\n-                    _ => false\n-                }\n+    match &e.node {\n+        &ExprUnary(UnNeg, ref litexp) => have_lit(cx, litexp, -m), \n+        &ExprLit(ref lit) => {\n+            match (&lit.node, m) {\n+                (&LitInt(0, _), 0) => true,\n+                (&LitInt(1, SignedIntLit(_, Plus)), 1) => true,\n+                (&LitInt(1, UnsuffixedIntLit(Plus)), 1) => true,\n+                (&LitInt(1, SignedIntLit(_, Minus)), -1) => true,\n+                (&LitInt(1, UnsuffixedIntLit(Minus)), -1) => true,\n+                _ => false\n+            }\n+        },\n+        &ExprParen(ref p) => have_lit(cx, p, m),\n+        &ExprPath(_, _) => { \n+            match cx.tcx.def_map.borrow().get(&e.id) {\n+                Some(&PathResolution { base_def: DefConst(id), ..}) => \n+                        lookup_const_by_id(cx.tcx, id, Option::None)\n+                        .map_or(false, |l| have_lit(cx, l, m)),\n+                _ => false\n             }\n-\t\t_ => false\n-\t}\n+        },\n+        _ => false\n+    }\n }"}, {"sha": "bf8155b5c3c948a3b9e70b25c6838779a6f4e7ec", "filename": "src/mut_mut.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/62f0fe0cc0504217ffc23b2fb8b69d3bed648be9/src%2Fmut_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62f0fe0cc0504217ffc23b2fb8b69d3bed648be9/src%2Fmut_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmut_mut.rs?ref=62f0fe0cc0504217ffc23b2fb8b69d3bed648be9", "patch": "@@ -23,7 +23,7 @@ impl LintPass for MutMut {\n \t\t\t}\n \t\t}\n \t\t\n-\t\tunwrap_addr(expr).map(|e| {\n+\t\tunwrap_addr(expr).map_or((), |e| {\n \t\t\tunwrap_addr(e).map(|_| {\n \t\t\t\tcx.span_lint(MUT_MUT, expr.span, \n \t\t\t\t\t\"Generally you want to avoid &mut &mut _ if possible.\")\n@@ -35,13 +35,12 @@ impl LintPass for MutMut {\n \t\t\t\t\t\tConsider reborrowing\")\n \t\t\t\t}\n \t\t\t})\n-\t\t}).unwrap_or(())\n+\t\t})\n \t}\n \t\n \tfn check_ty(&mut self, cx: &Context, ty: &Ty) {\n-\t\tunwrap_mut(ty).and_then(unwrap_mut).map(|_| cx.span_lint(MUT_MUT, \n-\t\t\tty.span, \"Generally you want to avoid &mut &mut _ if possible.\")).\n-\t\t\tunwrap_or(())\n+\t\tunwrap_mut(ty).and_then(unwrap_mut).map_or((), |_| cx.span_lint(MUT_MUT, \n+\t\t\tty.span, \"Generally you want to avoid &mut &mut _ if possible.\"))\n \t}\n }\n "}, {"sha": "86b87a942be1a4cf3fd587dc3caf36bb45666e6a", "filename": "src/ptr_arg.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/62f0fe0cc0504217ffc23b2fb8b69d3bed648be9/src%2Fptr_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62f0fe0cc0504217ffc23b2fb8b69d3bed648be9/src%2Fptr_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fptr_arg.rs?ref=62f0fe0cc0504217ffc23b2fb8b69d3bed648be9", "patch": "@@ -47,23 +47,22 @@ impl LintPass for PtrArg {\n \n fn check_fn(cx: &Context, decl: &FnDecl) {\n \tfor arg in &decl.inputs {\n-\t\tlet ty = &arg.ty;\n-\t\tmatch ty.node {\n-\t\t\tTyPtr(ref pty) => check_ptr_subtype(cx, ty.span, &pty.ty),\n-\t\t\tTyRptr(_, ref rpty) => check_ptr_subtype(cx, ty.span, &rpty.ty),\n+\t\tmatch &arg.ty.node {\n+\t\t\t&TyPtr(ref p) | &TyRptr(_, ref p) => \n+\t\t\t\tcheck_ptr_subtype(cx, arg.ty.span, &p.ty),\n \t\t\t_ => ()\n \t\t}\n \t}\n }\n \n fn check_ptr_subtype(cx: &Context, span: Span, ty: &Ty) {\n-\tmatch_ty_unwrap(ty, &[\"Vec\"]).map(|_| { \n-\t\tcx.span_lint(PTR_ARG, span, \"Writing '&Vec<_>' instead of '&[_]' \\\n-\t\t\tinvolves one more reference and cannot be used with non-vec-based \\\n-\t\t\tslices. Consider changing the type to &[...]\")\n-\t}).unwrap_or_else(|| match_ty_unwrap(ty, &[\"String\"]).map(|_| {\n+\tmatch_ty_unwrap(ty, &[\"Vec\"]).map_or_else(|| match_ty_unwrap(ty, \n+\t\t\t&[\"String\"]).map_or((), |_| {\n \t\tcx.span_lint(PTR_ARG, span,\n \t\t\t\"Writing '&String' instead of '&str' involves a new Object \\\n \t\t\twhere a slices will do. Consider changing the type to &str\")\n-\t}).unwrap_or(()));\n+\t}), |_| cx.span_lint(PTR_ARG, span, \"Writing '&Vec<_>' instead of \\\n+\t\t\t'&[_]' involves one more reference and cannot be used with \\\n+\t\t\tnon-vec-based slices. Consider changing the type to &[...]\")\n+\t)\n }"}]}