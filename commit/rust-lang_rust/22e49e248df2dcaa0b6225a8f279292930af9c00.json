{"sha": "22e49e248df2dcaa0b6225a8f279292930af9c00", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIyZTQ5ZTI0OGRmMmRjYWEwYjYyMjVhOGYyNzkyOTI5MzBhZjljMDA=", "commit": {"author": {"name": "David Wood", "email": "david@davidtw.co", "date": "2018-09-11T15:57:58Z"}, "committer": {"name": "David Wood", "email": "david@davidtw.co", "date": "2018-09-23T11:50:22Z"}, "message": "Improve non-closure, reference in-and-out errors.\n\nFor cases where there are references in the parameters and in the the\noutputs that do not match, and where no closures are involved, this\ncommit introduces an improved error that mentions (or synthesizes)\na name for the regions involved to better illustrate why the borrow\ndoes not live long enough.", "tree": {"sha": "ff654b33c9b7c4b97b844853dcdf382456d63346", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ff654b33c9b7c4b97b844853dcdf382456d63346"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/22e49e248df2dcaa0b6225a8f279292930af9c00", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEWwgxPGhT5b/6kagXAXYLT59T8VQFAlunff4ACgkQAXYLT59T\n8VRSphAAizWKCZf9BDU93ruX3xrGwTW+JSzQG4Qe0UEot21KpUXxbYaRmnlG1xb8\n1LTngo6n9Fg57jc9DWQiAwuHZmd1pfZdl/BlNLDCvHxL2JtuQE2sBeWhtx074jn9\ny0/Mi5E7QkXhdHdhgoDVk5LLkNGXZtl5HrsiwLLQoecU/ve6GrK9EMymx7Ivxovh\nD5RbOpgHLlmnVuztHn7tXXrtfoMaH4pgoiuaccda0aAJVzciqChsUl7B30ah8Lhj\n7RMzs6S7XUSQb5Ga0UCrlntYnhWUmD9oo+8aiU86cyxH6J/YnSMn23RqURCQik8j\n3ACkzJQiG5OZVURhMJy55qd/OIJ2X3VyRNEprJsANah3k/mLnh+252096FUJ2QYC\nQetNAKtbvbyJaUWSG2CNx+VXvpofyRfDPPTe7w/yTemy/NP985h6p9kohs8rdQhs\nfkNf3e22U2vnGphJB752M9sHcdsju9hJgKCFOPv54XBCRgVnSUud814S3fYjJCcy\nbHsKqG1oPvRFGPvXceZYssBWFq2vr1zba/prMuBvBbH7iv7At6/dn0ZgAtWKp3FT\nzmh6aSpdCaYUmCyL5nNX2BJ8wNqxxn6dTbxux6oPUmS5xNA/W7mmvEUEEZu+4T3f\neWDVTZue72eKbzgwWhExOn3fAJf+c3KRqb/Peo5TVNdYu7slyxA=\n=RsSN\n-----END PGP SIGNATURE-----", "payload": "tree ff654b33c9b7c4b97b844853dcdf382456d63346\nparent 650a61c484388283301e03c324b9ac58e1bcfe18\nauthor David Wood <david@davidtw.co> 1536681478 +0200\ncommitter David Wood <david@davidtw.co> 1537703422 +0200\n\nImprove non-closure, reference in-and-out errors.\n\nFor cases where there are references in the parameters and in the the\noutputs that do not match, and where no closures are involved, this\ncommit introduces an improved error that mentions (or synthesizes)\na name for the regions involved to better illustrate why the borrow\ndoes not live long enough.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/22e49e248df2dcaa0b6225a8f279292930af9c00", "html_url": "https://github.com/rust-lang/rust/commit/22e49e248df2dcaa0b6225a8f279292930af9c00", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/22e49e248df2dcaa0b6225a8f279292930af9c00/comments", "author": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "650a61c484388283301e03c324b9ac58e1bcfe18", "url": "https://api.github.com/repos/rust-lang/rust/commits/650a61c484388283301e03c324b9ac58e1bcfe18", "html_url": "https://github.com/rust-lang/rust/commit/650a61c484388283301e03c324b9ac58e1bcfe18"}], "stats": {"total": 124, "additions": 114, "deletions": 10}, "files": [{"sha": "9b148eedd71084ad9cf5aee5cd1b1be58e79a661", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 106, "deletions": 10, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/22e49e248df2dcaa0b6225a8f279292930af9c00/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22e49e248df2dcaa0b6225a8f279292930af9c00/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=22e49e248df2dcaa0b6225a8f279292930af9c00", "patch": "@@ -19,6 +19,7 @@ use rustc::mir::{\n     VarBindingForm,\n };\n use rustc::ty;\n+use rustc::hir;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::{Applicability, DiagnosticBuilder};\n@@ -462,9 +463,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         }\n \n         let mut err = match &self.describe_place(&borrow.borrowed_place) {\n-            Some(_) if self.is_place_thread_local(root_place) => {\n-                self.report_thread_local_value_does_not_live_long_enough(drop_span, borrow_span)\n-            }\n+            Some(_) if self.is_place_thread_local(root_place) =>\n+                self.report_thread_local_value_does_not_live_long_enough(drop_span, borrow_span),\n             Some(name) => self.report_local_value_does_not_live_long_enough(\n                 context,\n                 name,\n@@ -511,14 +511,50 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             Origin::Mir,\n         );\n \n-        err.span_label(borrow_span, \"borrowed value does not live long enough\");\n-        err.span_label(\n-            drop_span,\n-            format!(\"`{}` dropped here while still borrowed\", name),\n-        );\n+        let explanation = self.explain_why_borrow_contains_point(context, borrow, kind_place);\n+        if let Some((\n+            arg_name,\n+            arg_span,\n+            return_name,\n+            return_span,\n+        )) = self.find_name_and_ty_of_values() {\n+            err.span_label(\n+                arg_span,\n+                format!(\"has lifetime `{}`\", arg_name)\n+            );\n \n-        self.explain_why_borrow_contains_point(context, borrow, kind_place)\n-            .emit(self.infcx.tcx, &mut err);\n+            err.span_label(\n+                return_span,\n+                format!(\n+                    \"{}has lifetime `{}`\",\n+                    if arg_name == return_name { \"also \" } else { \"\" },\n+                    return_name\n+                )\n+            );\n+\n+            err.span_label(\n+                borrow_span,\n+                format!(\"`{}` would have to be valid for `{}`\", name, return_name),\n+            );\n+\n+            err.span_label(\n+                drop_span,\n+                format!(\"but `{}` dropped here while still borrowed\", name),\n+            );\n+\n+            if let BorrowExplanation::MustBeValidFor(..) = explanation { } else {\n+                explanation.emit(self.infcx.tcx, &mut err);\n+            }\n+        } else {\n+            err.span_label(borrow_span, \"borrowed value does not live long enough\");\n+\n+            err.span_label(\n+                drop_span,\n+                format!(\"`{}` dropped here while still borrowed\", name),\n+            );\n+\n+            explanation.emit(self.infcx.tcx, &mut err);\n+        }\n \n         err\n     }\n@@ -645,6 +681,66 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         err\n     }\n \n+    fn find_name_and_ty_of_values(\n+        &self,\n+    ) -> Option<(String, Span, String, Span)> {\n+        let mir_node_id = self.infcx.tcx.hir.as_local_node_id(self.mir_def_id)?;\n+        let fn_decl = self.infcx.tcx.hir.fn_decl(mir_node_id)?;\n+\n+        // If there is one argument and this error is being reported, that means\n+        // that the lifetime of the borrow could not be made to match the single\n+        // argument's lifetime. We can highlight it.\n+        //\n+        // If there is more than one argument and this error is being reported, that\n+        // means there must be a self parameter - as otherwise there would be an error\n+        // from lifetime elision and not this. So we highlight the self parameter.\n+        let arg = fn_decl.inputs\n+            .first()\n+            .and_then(|ty| {\n+                if let hir::TyKind::Rptr(\n+                    hir::Lifetime { name, span, ..  }, ..\n+                ) = ty.node {\n+                    Some((name, span))\n+                } else {\n+                    None\n+                }\n+            });\n+\n+        let ret = if let hir::FunctionRetTy::Return(ret_ty) = &fn_decl.output {\n+            if let hir::Ty {\n+                node: hir::TyKind::Rptr(hir::Lifetime { name, span, ..  }, ..),\n+                ..\n+            } = ret_ty.clone().into_inner() {\n+                Some((name, span))\n+            } else {\n+                None\n+            }\n+        } else {\n+            None\n+        };\n+\n+        let (arg_name, arg_span) = arg?;\n+        let (return_name, return_span) = ret?;\n+\n+        let lifetimes_match = arg_name == return_name;\n+\n+        let arg_name = if arg_name.is_elided() {\n+            \"'0\".to_string()\n+        } else {\n+            format!(\"{}\", arg_name.ident())\n+        };\n+\n+        let return_name = if return_name.is_elided() && lifetimes_match {\n+            \"'0\".to_string()\n+        } else if return_name.is_elided() {\n+            \"'1\".to_string()\n+        } else {\n+            format!(\"{}\", return_name.ident())\n+        };\n+\n+        Some((arg_name, arg_span, return_name, return_span))\n+    }\n+\n     fn get_moved_indexes(&mut self, context: Context, mpi: MovePathIndex) -> Vec<MoveOutIndex> {\n         let mir = self.mir;\n "}, {"sha": "1250bd78047434c240ecfc34fa9debe68a28c708", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/22e49e248df2dcaa0b6225a8f279292930af9c00/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22e49e248df2dcaa0b6225a8f279292930af9c00/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=22e49e248df2dcaa0b6225a8f279292930af9c00", "patch": "@@ -652,6 +652,14 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         }\n     }\n \n+    pub fn universal_regions_outlived_by<'a>(\n+        &'a self,\n+        r: RegionVid\n+    ) -> impl Iterator<Item = RegionVid> + 'a {\n+        let borrow_scc = self.constraint_sccs.scc(r);\n+        self.scc_values.universal_regions_outlived_by(borrow_scc)\n+    }\n+\n     /// Invoked when we have some type-test (e.g., `T: 'X`) that we cannot\n     /// prove to be satisfied. If this is a closure, we will attempt to\n     /// \"promote\" this type-test into our `ClosureRegionRequirements` and"}]}