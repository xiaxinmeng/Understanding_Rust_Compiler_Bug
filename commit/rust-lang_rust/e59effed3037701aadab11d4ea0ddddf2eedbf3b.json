{"sha": "e59effed3037701aadab11d4ea0ddddf2eedbf3b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU1OWVmZmVkMzAzNzcwMWFhZGFiMTFkNGVhMGRkZGRmMmVlZGJmM2I=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2020-07-24T17:01:32Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-07-24T17:01:32Z"}, "message": "Rollup merge of #74491 - xldenis:constant-binop-opt, r=oli-obk\n\nOptimize away BitAnd and BitOr when possible\n\nThis PR lets `const_prop` optimize away `a | true == true` , `a & false == false` and `a * 0 = 0`. While I was writing this I've realized that constant propagation misses a lot of opportunities. For example:  https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=2a4b45e772f214210a36749b27223bb0\n\nConstant propagation doesn't seem to... propagate constants, additionally the way constant propagation is currently setup makes it tricky to add cases like `a | false == a`.\n\nI tried to organize `eval_rvalue_with_identities` to make the pattern of the optimizations easier to see but it still obscurs what should be a simple peephole optmization.\n\ncc @oli-obk", "tree": {"sha": "806abbeb804a9e25d08bf88e06182518bb532134", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/806abbeb804a9e25d08bf88e06182518bb532134"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e59effed3037701aadab11d4ea0ddddf2eedbf3b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfGxPsCRBK7hj4Ov3rIwAAdHIIAEzwD2/uJkOLuh173azrLI97\nDde4Ge4BKvPjv/ywFoJkzEczV1YXQPCLZ7WxGaaT5hqp1iyPUOTd6p9rRlWtB98j\nvIZFZjZ4nwYSACQWsOHQ47mDHjNv/FgYMjxYNI1I+L3N+fGVAMEfIy++2cA2eBNF\nsOAtH1WgpKeNla4Wnngnnd+tFah9vK3OiByz/kCVVOD8wGFVM1/Rc0CCDZZZPNhX\nbZj+BqqIc/ii/ruNkSlK4lgAlvlbfecmwQkRo5Q7PCNul5oQFHrkOHKXbOL3fpvA\nI/pRdxqldrNs5TWe3XLQ3vkYJboSSUTUkJUMi8glSUsR/nXF3Qi4q1GOqBdIeaw=\n=ARCq\n-----END PGP SIGNATURE-----\n", "payload": "tree 806abbeb804a9e25d08bf88e06182518bb532134\nparent 3226d723381a24118f6aaa73b096c8ef4510f189\nparent 711a6807a7979715d6b2940db56eaf1585d30a71\nauthor Manish Goregaokar <manishsmail@gmail.com> 1595610092 -0700\ncommitter GitHub <noreply@github.com> 1595610092 -0700\n\nRollup merge of #74491 - xldenis:constant-binop-opt, r=oli-obk\n\nOptimize away BitAnd and BitOr when possible\n\nThis PR lets `const_prop` optimize away `a | true == true` , `a & false == false` and `a * 0 = 0`. While I was writing this I've realized that constant propagation misses a lot of opportunities. For example:  https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=2a4b45e772f214210a36749b27223bb0\n\nConstant propagation doesn't seem to... propagate constants, additionally the way constant propagation is currently setup makes it tricky to add cases like `a | false == a`.\n\nI tried to organize `eval_rvalue_with_identities` to make the pattern of the optimizations easier to see but it still obscurs what should be a simple peephole optmization.\n\ncc @oli-obk\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e59effed3037701aadab11d4ea0ddddf2eedbf3b", "html_url": "https://github.com/rust-lang/rust/commit/e59effed3037701aadab11d4ea0ddddf2eedbf3b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e59effed3037701aadab11d4ea0ddddf2eedbf3b/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3226d723381a24118f6aaa73b096c8ef4510f189", "url": "https://api.github.com/repos/rust-lang/rust/commits/3226d723381a24118f6aaa73b096c8ef4510f189", "html_url": "https://github.com/rust-lang/rust/commit/3226d723381a24118f6aaa73b096c8ef4510f189"}, {"sha": "711a6807a7979715d6b2940db56eaf1585d30a71", "url": "https://api.github.com/repos/rust-lang/rust/commits/711a6807a7979715d6b2940db56eaf1585d30a71", "html_url": "https://github.com/rust-lang/rust/commit/711a6807a7979715d6b2940db56eaf1585d30a71"}], "stats": {"total": 211, "additions": 187, "deletions": 24}, "files": [{"sha": "b3dedd5b8223ebe208ea8e559dfc5dddd218c806", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 85, "deletions": 21, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/e59effed3037701aadab11d4ea0ddddf2eedbf3b/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e59effed3037701aadab11d4ea0ddddf2eedbf3b/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=e59effed3037701aadab11d4ea0ddddf2eedbf3b", "patch": "@@ -28,9 +28,9 @@ use rustc_trait_selection::traits;\n \n use crate::const_eval::error_to_const_error;\n use crate::interpret::{\n-    self, compile_time_machine, AllocId, Allocation, Frame, ImmTy, Immediate, InterpCx, LocalState,\n-    LocalValue, MemPlace, Memory, MemoryKind, OpTy, Operand as InterpOperand, PlaceTy, Pointer,\n-    ScalarMaybeUninit, StackPopCleanup,\n+    self, compile_time_machine, truncate, AllocId, Allocation, Frame, ImmTy, Immediate, InterpCx,\n+    LocalState, LocalValue, MemPlace, Memory, MemoryKind, OpTy, Operand as InterpOperand, PlaceTy,\n+    Pointer, ScalarMaybeUninit, StackPopCleanup,\n };\n use crate::transform::{MirPass, MirSource};\n \n@@ -527,11 +527,11 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         right: &Operand<'tcx>,\n         source_info: SourceInfo,\n     ) -> Option<()> {\n-        let r =\n-            self.use_ecx(|this| this.ecx.read_immediate(this.ecx.eval_operand(right, None)?))?;\n+        let r = self.use_ecx(|this| this.ecx.read_immediate(this.ecx.eval_operand(right, None)?));\n         let l = self.use_ecx(|this| this.ecx.read_immediate(this.ecx.eval_operand(left, None)?));\n         // Check for exceeding shifts *even if* we cannot evaluate the LHS.\n         if op == BinOp::Shr || op == BinOp::Shl {\n+            let r = r?;\n             // We need the type of the LHS. We cannot use `place_layout` as that is the type\n             // of the result, which for checked binops is not the same!\n             let left_ty = left.ty(&self.local_decls, self.tcx);\n@@ -564,21 +564,20 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             }\n         }\n \n-        let l = l?;\n-\n-        // The remaining operators are handled through `overflowing_binary_op`.\n-        if self.use_ecx(|this| {\n-            let (_res, overflow, _ty) = this.ecx.overflowing_binary_op(op, l, r)?;\n-            Ok(overflow)\n-        })? {\n-            self.report_assert_as_lint(\n-                lint::builtin::ARITHMETIC_OVERFLOW,\n-                source_info,\n-                \"this arithmetic operation will overflow\",\n-                AssertKind::Overflow(op, l.to_const_int(), r.to_const_int()),\n-            )?;\n+        if let (Some(l), Some(r)) = (l, r) {\n+            // The remaining operators are handled through `overflowing_binary_op`.\n+            if self.use_ecx(|this| {\n+                let (_res, overflow, _ty) = this.ecx.overflowing_binary_op(op, l, r)?;\n+                Ok(overflow)\n+            })? {\n+                self.report_assert_as_lint(\n+                    lint::builtin::ARITHMETIC_OVERFLOW,\n+                    source_info,\n+                    \"this arithmetic operation will overflow\",\n+                    AssertKind::Overflow(op, l.to_const_int(), r.to_const_int()),\n+                )?;\n+            }\n         }\n-\n         Some(())\n     }\n \n@@ -659,9 +658,74 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             return None;\n         }\n \n+        if self.tcx.sess.opts.debugging_opts.mir_opt_level >= 3 {\n+            self.eval_rvalue_with_identities(rvalue, place)\n+        } else {\n+            self.use_ecx(|this| this.ecx.eval_rvalue_into_place(rvalue, place))\n+        }\n+    }\n+\n+    // Attempt to use albegraic identities to eliminate constant expressions\n+    fn eval_rvalue_with_identities(\n+        &mut self,\n+        rvalue: &Rvalue<'tcx>,\n+        place: Place<'tcx>,\n+    ) -> Option<()> {\n         self.use_ecx(|this| {\n-            trace!(\"calling eval_rvalue_into_place(rvalue = {:?}, place = {:?})\", rvalue, place);\n-            this.ecx.eval_rvalue_into_place(rvalue, place)?;\n+            match rvalue {\n+                Rvalue::BinaryOp(op, left, right) | Rvalue::CheckedBinaryOp(op, left, right) => {\n+                    let l = this.ecx.eval_operand(left, None);\n+                    let r = this.ecx.eval_operand(right, None);\n+\n+                    let const_arg = match (l, r) {\n+                        (Ok(x), Err(_)) | (Err(_), Ok(x)) => this.ecx.read_immediate(x)?,\n+                        (Err(e), Err(_)) => return Err(e),\n+                        (Ok(_), Ok(_)) => {\n+                            this.ecx.eval_rvalue_into_place(rvalue, place)?;\n+                            return Ok(());\n+                        }\n+                    };\n+\n+                    let arg_value =\n+                        this.ecx.force_bits(const_arg.to_scalar()?, const_arg.layout.size)?;\n+                    let dest = this.ecx.eval_place(place)?;\n+\n+                    match op {\n+                        BinOp::BitAnd => {\n+                            if arg_value == 0 {\n+                                this.ecx.write_immediate(*const_arg, dest)?;\n+                            }\n+                        }\n+                        BinOp::BitOr => {\n+                            if arg_value == truncate(u128::MAX, const_arg.layout.size)\n+                                || (const_arg.layout.ty.is_bool() && arg_value == 1)\n+                            {\n+                                this.ecx.write_immediate(*const_arg, dest)?;\n+                            }\n+                        }\n+                        BinOp::Mul => {\n+                            if const_arg.layout.ty.is_integral() && arg_value == 0 {\n+                                if let Rvalue::CheckedBinaryOp(_, _, _) = rvalue {\n+                                    let val = Immediate::ScalarPair(\n+                                        const_arg.to_scalar()?.into(),\n+                                        Scalar::from_bool(false).into(),\n+                                    );\n+                                    this.ecx.write_immediate(val, dest)?;\n+                                } else {\n+                                    this.ecx.write_immediate(*const_arg, dest)?;\n+                                }\n+                            }\n+                        }\n+                        _ => {\n+                            this.ecx.eval_rvalue_into_place(rvalue, place)?;\n+                        }\n+                    }\n+                }\n+                _ => {\n+                    this.ecx.eval_rvalue_into_place(rvalue, place)?;\n+                }\n+            }\n+\n             Ok(())\n         })\n     }"}, {"sha": "4e09acbaa53b45b38c9266c153363602a5ed5106", "filename": "src/test/mir-opt/const_prop/boolean_identities.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e59effed3037701aadab11d4ea0ddddf2eedbf3b/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fboolean_identities.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e59effed3037701aadab11d4ea0ddddf2eedbf3b/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fboolean_identities.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fboolean_identities.rs?ref=e59effed3037701aadab11d4ea0ddddf2eedbf3b", "patch": "@@ -0,0 +1,10 @@\n+// compile-flags: -O -Zmir-opt-level=3\n+\n+// EMIT_MIR rustc.test.ConstProp.diff\n+pub fn test(x: bool, y: bool) -> bool {\n+    (y | true) & (x & false)\n+}\n+\n+fn main() {\n+    test(true, false);\n+}"}, {"sha": "b8f0ad4d434cb8e0549c0c4d8d8581f200f627d0", "filename": "src/test/mir-opt/const_prop/boolean_identities/rustc.test.ConstProp.diff", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/e59effed3037701aadab11d4ea0ddddf2eedbf3b/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fboolean_identities%2Frustc.test.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/e59effed3037701aadab11d4ea0ddddf2eedbf3b/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fboolean_identities%2Frustc.test.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fboolean_identities%2Frustc.test.ConstProp.diff?ref=e59effed3037701aadab11d4ea0ddddf2eedbf3b", "patch": "@@ -0,0 +1,53 @@\n+- // MIR for `test` before ConstProp\n++ // MIR for `test` after ConstProp\n+  \n+  fn test(_1: bool, _2: bool) -> bool {\n+      debug x => _1;                       // in scope 0 at $DIR/boolean_identities.rs:4:13: 4:14\n+      debug y => _2;                       // in scope 0 at $DIR/boolean_identities.rs:4:22: 4:23\n+      let mut _0: bool;                    // return place in scope 0 at $DIR/boolean_identities.rs:4:34: 4:38\n+      let mut _3: bool;                    // in scope 0 at $DIR/boolean_identities.rs:5:5: 5:15\n+      let mut _4: bool;                    // in scope 0 at $DIR/boolean_identities.rs:5:6: 5:7\n+      let mut _5: bool;                    // in scope 0 at $DIR/boolean_identities.rs:5:18: 5:29\n+      let mut _6: bool;                    // in scope 0 at $DIR/boolean_identities.rs:5:19: 5:20\n+  \n+      bb0: {\n+          StorageLive(_3);                 // scope 0 at $DIR/boolean_identities.rs:5:5: 5:15\n+          StorageLive(_4);                 // scope 0 at $DIR/boolean_identities.rs:5:6: 5:7\n+          _4 = _2;                         // scope 0 at $DIR/boolean_identities.rs:5:6: 5:7\n+-         _3 = BitOr(move _4, const true); // scope 0 at $DIR/boolean_identities.rs:5:5: 5:15\n++         _3 = const true;                 // scope 0 at $DIR/boolean_identities.rs:5:5: 5:15\n+                                           // ty::Const\n+                                           // + ty: bool\n+                                           // + val: Value(Scalar(0x01))\n+                                           // mir::Constant\n+-                                          // + span: $DIR/boolean_identities.rs:5:10: 5:14\n++                                          // + span: $DIR/boolean_identities.rs:5:5: 5:15\n+                                           // + literal: Const { ty: bool, val: Value(Scalar(0x01)) }\n+          StorageDead(_4);                 // scope 0 at $DIR/boolean_identities.rs:5:14: 5:15\n+          StorageLive(_5);                 // scope 0 at $DIR/boolean_identities.rs:5:18: 5:29\n+          StorageLive(_6);                 // scope 0 at $DIR/boolean_identities.rs:5:19: 5:20\n+          _6 = _1;                         // scope 0 at $DIR/boolean_identities.rs:5:19: 5:20\n+-         _5 = BitAnd(move _6, const false); // scope 0 at $DIR/boolean_identities.rs:5:18: 5:29\n++         _5 = const false;                // scope 0 at $DIR/boolean_identities.rs:5:18: 5:29\n+                                           // ty::Const\n+                                           // + ty: bool\n+                                           // + val: Value(Scalar(0x00))\n+                                           // mir::Constant\n+-                                          // + span: $DIR/boolean_identities.rs:5:23: 5:28\n++                                          // + span: $DIR/boolean_identities.rs:5:18: 5:29\n+                                           // + literal: Const { ty: bool, val: Value(Scalar(0x00)) }\n+          StorageDead(_6);                 // scope 0 at $DIR/boolean_identities.rs:5:28: 5:29\n+-         _0 = BitAnd(move _3, move _5);   // scope 0 at $DIR/boolean_identities.rs:5:5: 5:29\n++         _0 = const false;                // scope 0 at $DIR/boolean_identities.rs:5:5: 5:29\n++                                          // ty::Const\n++                                          // + ty: bool\n++                                          // + val: Value(Scalar(0x00))\n++                                          // mir::Constant\n++                                          // + span: $DIR/boolean_identities.rs:5:5: 5:29\n++                                          // + literal: Const { ty: bool, val: Value(Scalar(0x00)) }\n+          StorageDead(_5);                 // scope 0 at $DIR/boolean_identities.rs:5:28: 5:29\n+          StorageDead(_3);                 // scope 0 at $DIR/boolean_identities.rs:5:28: 5:29\n+          return;                          // scope 0 at $DIR/boolean_identities.rs:6:2: 6:2\n+      }\n+  }\n+  "}, {"sha": "f40faee3110aee197e5248af2256d849a729277f", "filename": "src/test/mir-opt/const_prop/mult_by_zero.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e59effed3037701aadab11d4ea0ddddf2eedbf3b/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmult_by_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e59effed3037701aadab11d4ea0ddddf2eedbf3b/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmult_by_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmult_by_zero.rs?ref=e59effed3037701aadab11d4ea0ddddf2eedbf3b", "patch": "@@ -0,0 +1,10 @@\n+// compile-flags: -O -Zmir-opt-level=3\n+\n+// EMIT_MIR rustc.test.ConstProp.diff\n+fn test(x : i32) -> i32 {\n+  x * 0\n+}\n+\n+fn main() {\n+    test(10);\n+}"}, {"sha": "7b36669bf15b2e63870562aa24ac93c7d333df5a", "filename": "src/test/mir-opt/const_prop/mult_by_zero/rustc.test.ConstProp.diff", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/e59effed3037701aadab11d4ea0ddddf2eedbf3b/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmult_by_zero%2Frustc.test.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/e59effed3037701aadab11d4ea0ddddf2eedbf3b/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmult_by_zero%2Frustc.test.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmult_by_zero%2Frustc.test.ConstProp.diff?ref=e59effed3037701aadab11d4ea0ddddf2eedbf3b", "patch": "@@ -0,0 +1,25 @@\n+- // MIR for `test` before ConstProp\n++ // MIR for `test` after ConstProp\n+  \n+  fn test(_1: i32) -> i32 {\n+      debug x => _1;                       // in scope 0 at $DIR/mult_by_zero.rs:4:9: 4:10\n+      let mut _0: i32;                     // return place in scope 0 at $DIR/mult_by_zero.rs:4:21: 4:24\n+      let mut _2: i32;                     // in scope 0 at $DIR/mult_by_zero.rs:5:3: 5:4\n+  \n+      bb0: {\n+          StorageLive(_2);                 // scope 0 at $DIR/mult_by_zero.rs:5:3: 5:4\n+          _2 = _1;                         // scope 0 at $DIR/mult_by_zero.rs:5:3: 5:4\n+-         _0 = Mul(move _2, const 0_i32);  // scope 0 at $DIR/mult_by_zero.rs:5:3: 5:8\n++         _0 = const 0_i32;                // scope 0 at $DIR/mult_by_zero.rs:5:3: 5:8\n+                                           // ty::Const\n+                                           // + ty: i32\n+                                           // + val: Value(Scalar(0x00000000))\n+                                           // mir::Constant\n+-                                          // + span: $DIR/mult_by_zero.rs:5:7: 5:8\n++                                          // + span: $DIR/mult_by_zero.rs:5:3: 5:8\n+                                           // + literal: Const { ty: i32, val: Value(Scalar(0x00000000)) }\n+          StorageDead(_2);                 // scope 0 at $DIR/mult_by_zero.rs:5:7: 5:8\n+          return;                          // scope 0 at $DIR/mult_by_zero.rs:6:2: 6:2\n+      }\n+  }\n+  "}, {"sha": "795c5154f815551d04c1b0dfa6354c002081a9c1", "filename": "src/test/ui/consts/const-eval/index-out-of-bounds-never-type.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e59effed3037701aadab11d4ea0ddddf2eedbf3b/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Findex-out-of-bounds-never-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e59effed3037701aadab11d4ea0ddddf2eedbf3b/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Findex-out-of-bounds-never-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Findex-out-of-bounds-never-type.rs?ref=e59effed3037701aadab11d4ea0ddddf2eedbf3b", "patch": "@@ -1,14 +1,15 @@\n // build-fail\n \n // Regression test for #66975\n-#![warn(const_err)]\n+#![warn(const_err, unconditional_panic)]\n #![feature(never_type)]\n \n struct PrintName<T>(T);\n \n impl<T> PrintName<T> {\n     const VOID: ! = { let x = 0 * std::mem::size_of::<T>(); [][x] };\n     //~^ WARN any use of this value will cause an error\n+\n }\n \n fn f<T>() {"}, {"sha": "33e60dd7c9138c725e43441a8b2dbd677829ed3e", "filename": "src/test/ui/consts/const-eval/index-out-of-bounds-never-type.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e59effed3037701aadab11d4ea0ddddf2eedbf3b/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Findex-out-of-bounds-never-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e59effed3037701aadab11d4ea0ddddf2eedbf3b/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Findex-out-of-bounds-never-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Findex-out-of-bounds-never-type.stderr?ref=e59effed3037701aadab11d4ea0ddddf2eedbf3b", "patch": "@@ -9,11 +9,11 @@ LL |     const VOID: ! = { let x = 0 * std::mem::size_of::<T>(); [][x] };\n note: the lint level is defined here\n   --> $DIR/index-out-of-bounds-never-type.rs:4:9\n    |\n-LL | #![warn(const_err)]\n+LL | #![warn(const_err, unconditional_panic)]\n    |         ^^^^^^^^^\n \n error: erroneous constant encountered\n-  --> $DIR/index-out-of-bounds-never-type.rs:15:13\n+  --> $DIR/index-out-of-bounds-never-type.rs:16:13\n    |\n LL |     let _ = PrintName::<T>::VOID;\n    |             ^^^^^^^^^^^^^^^^^^^^"}]}