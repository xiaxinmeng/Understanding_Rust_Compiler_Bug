{"sha": "92101b7655d915ae636efcc09d9df18783d8412e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkyMTAxYjc2NTVkOTE1YWU2MzZlZmNjMDlkOWRmMTg3ODNkODQxMmU=", "commit": {"author": {"name": "Nadrieril", "email": "nadrieril@gmail.com", "date": "2019-10-27T16:36:50Z"}, "committer": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2019-11-01T17:23:03Z"}, "message": "Define a MissingConstructors struct for cleanliness", "tree": {"sha": "e44fd2a035d8e352d65abd70ab56eb24855f43eb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e44fd2a035d8e352d65abd70ab56eb24855f43eb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/92101b7655d915ae636efcc09d9df18783d8412e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/92101b7655d915ae636efcc09d9df18783d8412e", "html_url": "https://github.com/rust-lang/rust/commit/92101b7655d915ae636efcc09d9df18783d8412e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/92101b7655d915ae636efcc09d9df18783d8412e/comments", "author": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cc4583dcd3c3206eda0a71a71730ff0c5501c64c", "url": "https://api.github.com/repos/rust-lang/rust/commits/cc4583dcd3c3206eda0a71a71730ff0c5501c64c", "html_url": "https://github.com/rust-lang/rust/commit/cc4583dcd3c3206eda0a71a71730ff0c5501c64c"}], "stats": {"total": 116, "additions": 75, "deletions": 41}, "files": [{"sha": "986d2584e4e2882de927234b43d29b4a0e432fa0", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 75, "deletions": 41, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/92101b7655d915ae636efcc09d9df18783d8412e/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92101b7655d915ae636efcc09d9df18783d8412e/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=92101b7655d915ae636efcc09d9df18783d8412e", "patch": "@@ -1279,43 +1279,76 @@ impl<'tcx> IntRange<'tcx> {\n     }\n }\n \n-type MissingConstructors<'a, 'tcx, F> =\n-    std::iter::FlatMap<std::slice::Iter<'a, Constructor<'tcx>>, Vec<Constructor<'tcx>>, F>;\n-// Compute a set of constructors equivalent to `all_ctors \\ used_ctors`. This\n-// returns an iterator, so that we only construct the whole set if needed.\n-fn compute_missing_ctors<'a, 'tcx>(\n+// A struct to compute a set of constructors equivalent to `all_ctors \\ used_ctors`.\n+struct MissingConstructors<'tcx> {\n     tcx: TyCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n-    all_ctors: &'a Vec<Constructor<'tcx>>,\n-    used_ctors: &'a Vec<Constructor<'tcx>>,\n-) -> MissingConstructors<'a, 'tcx, impl FnMut(&'a Constructor<'tcx>) -> Vec<Constructor<'tcx>>> {\n-    all_ctors.iter().flat_map(move |req_ctor| {\n-        let mut refined_ctors = vec![req_ctor.clone()];\n-        for used_ctor in used_ctors {\n-            if used_ctor == req_ctor {\n-                // If a constructor appears in a `match` arm, we can\n-                // eliminate it straight away.\n-                refined_ctors = vec![]\n-            } else if let Some(interval) = IntRange::from_ctor(tcx, param_env, used_ctor) {\n-                // Refine the required constructors for the type by subtracting\n-                // the range defined by the current constructor pattern.\n-                refined_ctors = interval.subtract_from(tcx, param_env, refined_ctors);\n-            }\n+    all_ctors: Vec<Constructor<'tcx>>,\n+    used_ctors: Vec<Constructor<'tcx>>,\n+}\n+\n+impl<'tcx> MissingConstructors<'tcx> {\n+    fn new(\n+        tcx: TyCtxt<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        all_ctors: Vec<Constructor<'tcx>>,\n+        used_ctors: Vec<Constructor<'tcx>>,\n+    ) -> Self {\n+        MissingConstructors { tcx, param_env, all_ctors, used_ctors }\n+    }\n \n-            // If the constructor patterns that have been considered so far\n-            // already cover the entire range of values, then we know the\n-            // constructor is not missing, and we can move on to the next one.\n-            if refined_ctors.is_empty() {\n-                break;\n+    fn into_inner(self) -> (Vec<Constructor<'tcx>>, Vec<Constructor<'tcx>>) {\n+        (self.all_ctors, self.used_ctors)\n+    }\n+\n+    fn is_empty(&self) -> bool {\n+        self.iter().next().is_none()\n+    }\n+    /// Whether this contains all the constructors for the given type or only a\n+    /// subset.\n+    fn all_ctors_are_missing(&self) -> bool {\n+        self.used_ctors.is_empty()\n+    }\n+\n+    /// Iterate over all_ctors \\ used_ctors\n+    fn iter<'a>(&'a self) -> impl Iterator<Item = Constructor<'tcx>> + Captures<'a> {\n+        self.all_ctors.iter().flat_map(move |req_ctor| {\n+            let mut refined_ctors = vec![req_ctor.clone()];\n+            for used_ctor in &self.used_ctors {\n+                if used_ctor == req_ctor {\n+                    // If a constructor appears in a `match` arm, we can\n+                    // eliminate it straight away.\n+                    refined_ctors = vec![]\n+                } else if let Some(interval) =\n+                    IntRange::from_ctor(self.tcx, self.param_env, used_ctor)\n+                {\n+                    // Refine the required constructors for the type by subtracting\n+                    // the range defined by the current constructor pattern.\n+                    refined_ctors = interval.subtract_from(self.tcx, self.param_env, refined_ctors);\n+                }\n+\n+                // If the constructor patterns that have been considered so far\n+                // already cover the entire range of values, then we know the\n+                // constructor is not missing, and we can move on to the next one.\n+                if refined_ctors.is_empty() {\n+                    break;\n+                }\n             }\n-        }\n \n-        // If a constructor has not been matched, then it is missing.\n-        // We add `refined_ctors` instead of `req_ctor`, because then we can\n-        // provide more detailed error information about precisely which\n-        // ranges have been omitted.\n-        refined_ctors\n-    })\n+            // If a constructor has not been matched, then it is missing.\n+            // We add `refined_ctors` instead of `req_ctor`, because then we can\n+            // provide more detailed error information about precisely which\n+            // ranges have been omitted.\n+            refined_ctors\n+        })\n+    }\n+}\n+\n+impl<'tcx> fmt::Debug for MissingConstructors<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        let ctors: Vec<_> = self.iter().collect();\n+        write!(f, \"{:?}\", ctors)\n+    }\n }\n \n /// Algorithm from http://moscova.inria.fr/~maranget/papers/warn/index.html.\n@@ -1426,6 +1459,9 @@ pub fn is_useful<'p, 'a, 'tcx>(\n         let all_ctors = all_constructors(cx, pcx);\n         debug!(\"all_ctors = {:#?}\", all_ctors);\n \n+        let is_privately_empty = all_ctors.is_empty() && !cx.is_uninhabited(pcx.ty);\n+        let is_declared_nonexhaustive = cx.is_non_exhaustive_enum(pcx.ty) && !cx.is_local(pcx.ty);\n+\n         // `missing_ctors` is the set of constructors from the same type as the\n         // first column of `matrix` that are matched only by wildcard patterns\n         // from the first column.\n@@ -1449,14 +1485,11 @@ pub fn is_useful<'p, 'a, 'tcx>(\n         // non-wildcard patterns in the current column. To determine if\n         // the set is empty, we can check that `.peek().is_none()`, so\n         // we only fully construct them on-demand, because they're rarely used and can be big.\n-        let mut missing_ctors =\n-            compute_missing_ctors(cx.tcx, cx.param_env, &all_ctors, &used_ctors).peekable();\n+        let missing_ctors = MissingConstructors::new(cx.tcx, cx.param_env, all_ctors, used_ctors);\n \n-        let is_privately_empty = all_ctors.is_empty() && !cx.is_uninhabited(pcx.ty);\n-        let is_declared_nonexhaustive = cx.is_non_exhaustive_enum(pcx.ty) && !cx.is_local(pcx.ty);\n         debug!(\n             \"missing_ctors.empty()={:#?} is_privately_empty={:#?} is_declared_nonexhaustive={:#?}\",\n-            missing_ctors.peek().is_none(),\n+            missing_ctors.is_empty(),\n             is_privately_empty,\n             is_declared_nonexhaustive\n         );\n@@ -1467,8 +1500,8 @@ pub fn is_useful<'p, 'a, 'tcx>(\n             || is_declared_nonexhaustive\n             || (pcx.ty.is_ptr_sized_integral() && !cx.tcx.features().precise_pointer_size_matching);\n \n-        if missing_ctors.peek().is_none() && !is_non_exhaustive {\n-            drop(missing_ctors); // It was borrowing `all_ctors`, which we want to move.\n+        if missing_ctors.is_empty() && !is_non_exhaustive {\n+            let (all_ctors, _) = missing_ctors.into_inner();\n             split_grouped_constructors(\n                 cx.tcx,\n                 cx.param_env,\n@@ -1532,7 +1565,8 @@ pub fn is_useful<'p, 'a, 'tcx>(\n                     // `(<direction-1>, <direction-2>, true)` - we are\n                     // satisfied with `(_, _, true)`. In this case,\n                     // `used_ctors` is empty.\n-                    let new_patterns = if is_non_exhaustive || used_ctors.is_empty() {\n+                    let new_patterns = if is_non_exhaustive || missing_ctors.all_ctors_are_missing()\n+                    {\n                         // All constructors are unused. Add a wild pattern\n                         // rather than each individual constructor.\n                         vec![Pat { ty: pcx.ty, span: DUMMY_SP, kind: box PatKind::Wild }]\n@@ -1541,7 +1575,7 @@ pub fn is_useful<'p, 'a, 'tcx>(\n                         // constructor, that matches everything that can be built with\n                         // it. For example, if `ctor` is a `Constructor::Variant` for\n                         // `Option::Some`, we get the pattern `Some(_)`.\n-                        missing_ctors.map(|ctor| ctor.apply_wildcards(cx, pcx.ty)).collect()\n+                        missing_ctors.iter().map(|ctor| ctor.apply_wildcards(cx, pcx.ty)).collect()\n                     };\n                     // Add the new patterns to each witness\n                     let new_witnesses = witnesses"}]}