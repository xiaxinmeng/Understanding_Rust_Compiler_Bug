{"sha": "3452104715281e1e52791dfe7c94622852ab1143", "node_id": "C_kwDOAAsO6NoAKDM0NTIxMDQ3MTUyODFlMWU1Mjc5MWRmZTdjOTQ2MjI4NTJhYjExNDM", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-01-21T02:33:22Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-01-21T02:33:22Z"}, "message": "Rollup merge of #107061 - compiler-errors:new-solver-new-candidates-3, r=lcnr\n\nImplement some more new solver candidates and fix some bugs\n\nFirst, fix some bugs:\n\n1. `IndexVec::drain_enumerated(a..b)` does not give us an iterator of index keys + items enumerated from `a..b`, but from `0..(b-a)`... That caused a bug. See first commit for the fix.\n2. Implement the `_: Trait` ambiguity hack. I put it in assemble, let me know if it should live elsewhere. This is important, since we otherwise consider `_: Sized` to have no solutions, and nothing passes!\n3. Swap `Ambiguity` and `Unimplemented` cases for the new solver. Sorry for accidentally swapping them \ud83d\ude04\n4. Check GATs' own predicates during projection confirmation.\n\nThen implement a few builtin traits:\n\n5. Implement `PointerSized`. Pretty independent.\n6. Implement `Fn` family of traits for fnptr, fndef, and closures. Closures are currently broken because `FulfillCtxt::relationships` is intentionally left unimplemented. See comment in the test.\n\nr? ```@lcnr```", "tree": {"sha": "fea395c277dbc3b0f5bcf9f4db5a47f4826cc821", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fea395c277dbc3b0f5bcf9f4db5a47f4826cc821"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3452104715281e1e52791dfe7c94622852ab1143", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjy07yCRBK7hj4Ov3rIwAATdUIACrS77QptA1MNqwsbrJ0vPit\nu2hKNdpKUujney1j5y0Uwovcs44te6PDWb2yNAekiSCG/8jlZx+T2tKhSQj/qjc+\nJWbl/15xV0DuvRmLTpRBlj+ho/nAaIkHt8gtonetNuocjKEVL1j25cJB9a3kPsmD\n1c5jHfl0ra/NeSp/e+khGjdPcLmGRG1KXUIdpS+NNLoKsNqnn5Vij914TOyHyk0D\nHMi82pp6pcY/TQI2Tnigz/rA8Jk7H/xIlbKFIAPSwcaxx6pSjudOQxs3jjITndz3\nv9fPVu9gjYcTT78ChM407QTIK6W0mSKNofNLJja11Yz0hhGB/kFjmmTTFJIW9C0=\n=/hSN\n-----END PGP SIGNATURE-----\n", "payload": "tree fea395c277dbc3b0f5bcf9f4db5a47f4826cc821\nparent d26c88c75231ab90b522fb061383f8e0156f1f20\nparent ed6aebbfecb56ae9ec2702572b70d6e350433de2\nauthor Michael Goulet <michael@errs.io> 1674268402 -0500\ncommitter GitHub <noreply@github.com> 1674268402 -0500\n\nRollup merge of #107061 - compiler-errors:new-solver-new-candidates-3, r=lcnr\n\nImplement some more new solver candidates and fix some bugs\n\nFirst, fix some bugs:\n\n1. `IndexVec::drain_enumerated(a..b)` does not give us an iterator of index keys + items enumerated from `a..b`, but from `0..(b-a)`... That caused a bug. See first commit for the fix.\n2. Implement the `_: Trait` ambiguity hack. I put it in assemble, let me know if it should live elsewhere. This is important, since we otherwise consider `_: Sized` to have no solutions, and nothing passes!\n3. Swap `Ambiguity` and `Unimplemented` cases for the new solver. Sorry for accidentally swapping them \ud83d\ude04\n4. Check GATs' own predicates during projection confirmation.\n\nThen implement a few builtin traits:\n\n5. Implement `PointerSized`. Pretty independent.\n6. Implement `Fn` family of traits for fnptr, fndef, and closures. Closures are currently broken because `FulfillCtxt::relationships` is intentionally left unimplemented. See comment in the test.\n\nr? ```@lcnr```\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3452104715281e1e52791dfe7c94622852ab1143", "html_url": "https://github.com/rust-lang/rust/commit/3452104715281e1e52791dfe7c94622852ab1143", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3452104715281e1e52791dfe7c94622852ab1143/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d26c88c75231ab90b522fb061383f8e0156f1f20", "url": "https://api.github.com/repos/rust-lang/rust/commits/d26c88c75231ab90b522fb061383f8e0156f1f20", "html_url": "https://github.com/rust-lang/rust/commit/d26c88c75231ab90b522fb061383f8e0156f1f20"}, {"sha": "ed6aebbfecb56ae9ec2702572b70d6e350433de2", "url": "https://api.github.com/repos/rust-lang/rust/commits/ed6aebbfecb56ae9ec2702572b70d6e350433de2", "html_url": "https://github.com/rust-lang/rust/commit/ed6aebbfecb56ae9ec2702572b70d6e350433de2"}], "stats": {"total": 293, "additions": 272, "deletions": 21}, "files": [{"sha": "68cdc6d7711d4eb840bb49ea3faef8a6c0f121f5", "filename": "compiler/rustc_index/src/vec.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3452104715281e1e52791dfe7c94622852ab1143/compiler%2Frustc_index%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3452104715281e1e52791dfe7c94622852ab1143/compiler%2Frustc_index%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2Fsrc%2Fvec.rs?ref=3452104715281e1e52791dfe7c94622852ab1143", "patch": "@@ -207,7 +207,12 @@ impl<I: Idx, T> IndexVec<I, T> {\n         &'a mut self,\n         range: R,\n     ) -> impl Iterator<Item = (I, T)> + 'a {\n-        self.raw.drain(range).enumerate().map(|(n, t)| (I::new(n), t))\n+        let begin = match range.start_bound() {\n+            std::ops::Bound::Included(i) => *i,\n+            std::ops::Bound::Excluded(i) => i.checked_add(1).unwrap(),\n+            std::ops::Bound::Unbounded => 0,\n+        };\n+        self.raw.drain(range).enumerate().map(move |(n, t)| (I::new(begin + n), t))\n     }\n \n     #[inline]"}, {"sha": "31c1bc9ecc062c7870242474521939b59e2279ee", "filename": "compiler/rustc_trait_selection/src/solve/assembly.rs", "status": "modified", "additions": 39, "deletions": 2, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/3452104715281e1e52791dfe7c94622852ab1143/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3452104715281e1e52791dfe7c94622852ab1143/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs?ref=3452104715281e1e52791dfe7c94622852ab1143", "patch": "@@ -1,7 +1,7 @@\n //! Code shared by trait and projection goals for candidate assembly.\n \n use super::infcx_ext::InferCtxtExt;\n-use super::{CanonicalResponse, EvalCtxt, Goal, QueryResult};\n+use super::{CanonicalResponse, Certainty, EvalCtxt, Goal, MaybeCause, QueryResult};\n use rustc_hir::def_id::DefId;\n use rustc_infer::traits::query::NoSolution;\n use rustc_infer::traits::util::elaborate_predicates;\n@@ -79,7 +79,7 @@ pub(super) enum CandidateSource {\n     AliasBound(usize),\n }\n \n-pub(super) trait GoalKind<'tcx>: TypeFoldable<'tcx> + Copy {\n+pub(super) trait GoalKind<'tcx>: TypeFoldable<'tcx> + Copy + Eq {\n     fn self_ty(self) -> Ty<'tcx>;\n \n     fn with_self_ty(self, tcx: TyCtxt<'tcx>, self_ty: Ty<'tcx>) -> Self;\n@@ -117,13 +117,43 @@ pub(super) trait GoalKind<'tcx>: TypeFoldable<'tcx> + Copy {\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n     ) -> QueryResult<'tcx>;\n+\n+    fn consider_builtin_pointer_sized_candidate(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+    ) -> QueryResult<'tcx>;\n+\n+    fn consider_builtin_fn_trait_candidates(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+        kind: ty::ClosureKind,\n+    ) -> QueryResult<'tcx>;\n+\n+    fn consider_builtin_tuple_candidate(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+    ) -> QueryResult<'tcx>;\n }\n \n impl<'tcx> EvalCtxt<'_, 'tcx> {\n     pub(super) fn assemble_and_evaluate_candidates<G: GoalKind<'tcx>>(\n         &mut self,\n         goal: Goal<'tcx, G>,\n     ) -> Vec<Candidate<'tcx>> {\n+        debug_assert_eq!(goal, self.infcx.resolve_vars_if_possible(goal));\n+\n+        // HACK: `_: Trait` is ambiguous, because it may be satisfied via a builtin rule,\n+        // object bound, alias bound, etc. We are unable to determine this until we can at\n+        // least structually resolve the type one layer.\n+        if goal.predicate.self_ty().is_ty_var() {\n+            return vec![Candidate {\n+                source: CandidateSource::BuiltinImpl,\n+                result: self\n+                    .make_canonical_response(Certainty::Maybe(MaybeCause::Ambiguity))\n+                    .unwrap(),\n+            }];\n+        }\n+\n         let mut candidates = Vec::new();\n \n         self.assemble_candidates_after_normalizing_self_ty(goal, &mut candidates);\n@@ -169,6 +199,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n                 Ok((_, certainty)) => certainty,\n                 Err(NoSolution) => return,\n             };\n+            let normalized_ty = self.infcx.resolve_vars_if_possible(normalized_ty);\n \n             // NOTE: Alternatively we could call `evaluate_goal` here and only have a `Normalized` candidate.\n             // This doesn't work as long as we use `CandidateSource` in winnowing.\n@@ -224,6 +255,12 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n             || lang_items.clone_trait() == Some(trait_def_id)\n         {\n             G::consider_builtin_copy_clone_candidate(self, goal)\n+        } else if lang_items.pointer_sized() == Some(trait_def_id) {\n+            G::consider_builtin_pointer_sized_candidate(self, goal)\n+        } else if let Some(kind) = self.tcx().fn_trait_kind_from_def_id(trait_def_id) {\n+            G::consider_builtin_fn_trait_candidates(self, goal, kind)\n+        } else if lang_items.tuple_trait() == Some(trait_def_id) {\n+            G::consider_builtin_tuple_candidate(self, goal)\n         } else {\n             Err(NoSolution)\n         };"}, {"sha": "a6240666ed43a86add4c87951342777d75e2ab55", "filename": "compiler/rustc_trait_selection/src/solve/fulfill.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3452104715281e1e52791dfe7c94622852ab1143/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3452104715281e1e52791dfe7c94622852ab1143/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ffulfill.rs?ref=3452104715281e1e52791dfe7c94622852ab1143", "patch": "@@ -52,7 +52,7 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentCtxt<'tcx> {\n             .drain(..)\n             .map(|obligation| FulfillmentError {\n                 obligation: obligation.clone(),\n-                code: FulfillmentErrorCode::CodeSelectionError(SelectionError::Unimplemented),\n+                code: FulfillmentErrorCode::CodeAmbiguity,\n                 root_obligation: obligation,\n             })\n             .collect()\n@@ -75,7 +75,9 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentCtxt<'tcx> {\n                     Err(NoSolution) => {\n                         errors.push(FulfillmentError {\n                             obligation: obligation.clone(),\n-                            code: FulfillmentErrorCode::CodeAmbiguity,\n+                            code: FulfillmentErrorCode::CodeSelectionError(\n+                                SelectionError::Unimplemented,\n+                            ),\n                             root_obligation: obligation,\n                         });\n                         continue;"}, {"sha": "e39fa05339286ab86d9d18e512eec92ae0448c3c", "filename": "compiler/rustc_trait_selection/src/solve/project_goals.rs", "status": "modified", "additions": 42, "deletions": 1, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/3452104715281e1e52791dfe7c94622852ab1143/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3452104715281e1e52791dfe7c94622852ab1143/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs?ref=3452104715281e1e52791dfe7c94622852ab1143", "patch": "@@ -2,6 +2,7 @@ use crate::traits::{specialization_graph, translate_substs};\n \n use super::assembly::{self, Candidate, CandidateSource};\n use super::infcx_ext::InferCtxtExt;\n+use super::trait_goals::structural_traits;\n use super::{Certainty, EvalCtxt, Goal, MaybeCause, QueryResult};\n use rustc_errors::ErrorGuaranteed;\n use rustc_hir::def::DefKind;\n@@ -11,9 +12,9 @@ use rustc_infer::traits::query::NoSolution;\n use rustc_infer::traits::specialization_graph::LeafDef;\n use rustc_infer::traits::Reveal;\n use rustc_middle::ty::fast_reject::{DeepRejectCtxt, TreatParams};\n-use rustc_middle::ty::TypeVisitable;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_middle::ty::{ProjectionPredicate, TypeSuperVisitable, TypeVisitor};\n+use rustc_middle::ty::{ToPredicate, TypeVisitable};\n use rustc_span::DUMMY_SP;\n use std::iter;\n use std::ops::ControlFlow;\n@@ -351,6 +352,46 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n     ) -> QueryResult<'tcx> {\n         bug!(\"`Copy`/`Clone` does not have an associated type: {:?}\", goal);\n     }\n+\n+    fn consider_builtin_pointer_sized_candidate(\n+        _ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+    ) -> QueryResult<'tcx> {\n+        bug!(\"`PointerSized` does not have an associated type: {:?}\", goal);\n+    }\n+\n+    fn consider_builtin_fn_trait_candidates(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+        goal_kind: ty::ClosureKind,\n+    ) -> QueryResult<'tcx> {\n+        if let Some(tupled_inputs_and_output) =\n+            structural_traits::extract_tupled_inputs_and_output_from_callable(\n+                ecx.tcx(),\n+                goal.predicate.self_ty(),\n+                goal_kind,\n+            )?\n+        {\n+            let pred = tupled_inputs_and_output\n+                .map_bound(|(inputs, output)| ty::ProjectionPredicate {\n+                    projection_ty: ecx\n+                        .tcx()\n+                        .mk_alias_ty(goal.predicate.def_id(), [goal.predicate.self_ty(), inputs]),\n+                    term: output.into(),\n+                })\n+                .to_predicate(ecx.tcx());\n+            Self::consider_assumption(ecx, goal, pred)\n+        } else {\n+            ecx.make_canonical_response(Certainty::Maybe(MaybeCause::Ambiguity))\n+        }\n+    }\n+\n+    fn consider_builtin_tuple_candidate(\n+        _ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+    ) -> QueryResult<'tcx> {\n+        bug!(\"`Tuple` does not have an associated type: {:?}\", goal);\n+    }\n }\n \n /// This behavior is also implemented in `rustc_ty_utils` and in the old `project` code."}, {"sha": "9985d7181bb7dd000edebae5c2a0f695309e3b9d", "filename": "compiler/rustc_trait_selection/src/solve/trait_goals.rs", "status": "modified", "additions": 62, "deletions": 4, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/3452104715281e1e52791dfe7c94622852ab1143/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3452104715281e1e52791dfe7c94622852ab1143/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs?ref=3452104715281e1e52791dfe7c94622852ab1143", "patch": "@@ -4,16 +4,16 @@ use std::iter;\n \n use super::assembly::{self, Candidate, CandidateSource};\n use super::infcx_ext::InferCtxtExt;\n-use super::{EvalCtxt, Goal, QueryResult};\n+use super::{Certainty, EvalCtxt, Goal, MaybeCause, QueryResult};\n use rustc_hir::def_id::DefId;\n use rustc_infer::infer::InferCtxt;\n use rustc_infer::traits::query::NoSolution;\n use rustc_middle::ty::fast_reject::{DeepRejectCtxt, TreatParams};\n-use rustc_middle::ty::TraitPredicate;\n-use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_middle::ty::{self, ToPredicate, Ty, TyCtxt};\n+use rustc_middle::ty::{TraitPredicate, TypeVisitable};\n use rustc_span::DUMMY_SP;\n \n-mod structural_traits;\n+pub mod structural_traits;\n \n impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n     fn self_ty(self) -> Ty<'tcx> {\n@@ -127,6 +127,64 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n             structural_traits::instantiate_constituent_tys_for_copy_clone_trait,\n         )\n     }\n+\n+    fn consider_builtin_pointer_sized_candidate(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+    ) -> QueryResult<'tcx> {\n+        if goal.predicate.self_ty().has_non_region_infer() {\n+            return ecx.make_canonical_response(Certainty::Maybe(MaybeCause::Ambiguity));\n+        }\n+\n+        let tcx = ecx.tcx();\n+        let self_ty = tcx.erase_regions(goal.predicate.self_ty());\n+\n+        if let Ok(layout) = tcx.layout_of(goal.param_env.and(self_ty))\n+            &&  let usize_layout = tcx.layout_of(ty::ParamEnv::empty().and(tcx.types.usize)).unwrap().layout\n+            && layout.layout.size() == usize_layout.size()\n+            && layout.layout.align().abi == usize_layout.align().abi\n+        {\n+            // FIXME: We could make this faster by making a no-constraints response\n+            ecx.make_canonical_response(Certainty::Yes)\n+        } else {\n+            Err(NoSolution)\n+        }\n+    }\n+\n+    fn consider_builtin_fn_trait_candidates(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+        goal_kind: ty::ClosureKind,\n+    ) -> QueryResult<'tcx> {\n+        if let Some(tupled_inputs_and_output) =\n+            structural_traits::extract_tupled_inputs_and_output_from_callable(\n+                ecx.tcx(),\n+                goal.predicate.self_ty(),\n+                goal_kind,\n+            )?\n+        {\n+            let pred = tupled_inputs_and_output\n+                .map_bound(|(inputs, _)| {\n+                    ecx.tcx()\n+                        .mk_trait_ref(goal.predicate.def_id(), [goal.predicate.self_ty(), inputs])\n+                })\n+                .to_predicate(ecx.tcx());\n+            Self::consider_assumption(ecx, goal, pred)\n+        } else {\n+            ecx.make_canonical_response(Certainty::Maybe(MaybeCause::Ambiguity))\n+        }\n+    }\n+\n+    fn consider_builtin_tuple_candidate(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+    ) -> QueryResult<'tcx> {\n+        if let ty::Tuple(..) = goal.predicate.self_ty().kind() {\n+            ecx.make_canonical_response(Certainty::Yes)\n+        } else {\n+            Err(NoSolution)\n+        }\n+    }\n }\n \n impl<'tcx> EvalCtxt<'_, 'tcx> {"}, {"sha": "a11cd13cb0856b4df3ace3c1261baf9a69d9d4dc", "filename": "compiler/rustc_trait_selection/src/solve/trait_goals/structural_traits.rs", "status": "modified", "additions": 55, "deletions": 11, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/3452104715281e1e52791dfe7c94622852ab1143/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals%2Fstructural_traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3452104715281e1e52791dfe7c94622852ab1143/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals%2Fstructural_traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals%2Fstructural_traits.rs?ref=3452104715281e1e52791dfe7c94622852ab1143", "patch": "@@ -1,6 +1,6 @@\n use rustc_hir::{Movability, Mutability};\n use rustc_infer::{infer::InferCtxt, traits::query::NoSolution};\n-use rustc_middle::ty::{self, Ty};\n+use rustc_middle::ty::{self, Ty, TyCtxt};\n \n // Calculates the constituent types of a type for `auto trait` purposes.\n //\n@@ -30,10 +30,7 @@ pub(super) fn instantiate_constituent_tys_for_auto_trait<'tcx>(\n         | ty::Foreign(..)\n         | ty::Alias(ty::Projection, ..)\n         | ty::Bound(..)\n-        | ty::Infer(ty::TyVar(_)) => {\n-            // FIXME: Do we need to mark anything as ambiguous here? Yeah?\n-            Err(NoSolution)\n-        }\n+        | ty::Infer(ty::TyVar(_)) => Err(NoSolution),\n \n         ty::Infer(ty::FreshTy(_) | ty::FreshIntTy(_) | ty::FreshFloatTy(_)) => bug!(),\n \n@@ -101,9 +98,8 @@ pub(super) fn instantiate_constituent_tys_for_sized_trait<'tcx>(\n         | ty::Dynamic(..)\n         | ty::Foreign(..)\n         | ty::Alias(..)\n-        | ty::Param(_) => Err(NoSolution),\n-\n-        ty::Infer(ty::TyVar(_)) => bug!(\"FIXME: ambiguous\"),\n+        | ty::Param(_)\n+        | ty::Infer(ty::TyVar(_)) => Err(NoSolution),\n \n         ty::Placeholder(..)\n         | ty::Bound(..)\n@@ -151,9 +147,8 @@ pub(super) fn instantiate_constituent_tys_for_copy_clone_trait<'tcx>(\n         | ty::Ref(_, _, Mutability::Mut)\n         | ty::Adt(_, _)\n         | ty::Alias(_, _)\n-        | ty::Param(_) => Err(NoSolution),\n-\n-        ty::Infer(ty::TyVar(_)) => bug!(\"FIXME: ambiguous\"),\n+        | ty::Param(_)\n+        | ty::Infer(ty::TyVar(_)) => Err(NoSolution),\n \n         ty::Placeholder(..)\n         | ty::Bound(..)\n@@ -177,3 +172,52 @@ pub(super) fn instantiate_constituent_tys_for_copy_clone_trait<'tcx>(\n         }\n     }\n }\n+\n+pub(crate) fn extract_tupled_inputs_and_output_from_callable<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    self_ty: Ty<'tcx>,\n+    goal_kind: ty::ClosureKind,\n+) -> Result<Option<ty::Binder<'tcx, (Ty<'tcx>, Ty<'tcx>)>>, NoSolution> {\n+    match *self_ty.kind() {\n+        ty::FnDef(def_id, substs) => Ok(Some(\n+            tcx.bound_fn_sig(def_id)\n+                .subst(tcx, substs)\n+                .map_bound(|sig| (tcx.mk_tup(sig.inputs().iter()), sig.output())),\n+        )),\n+        ty::FnPtr(sig) => {\n+            Ok(Some(sig.map_bound(|sig| (tcx.mk_tup(sig.inputs().iter()), sig.output()))))\n+        }\n+        ty::Closure(_, substs) => {\n+            let closure_substs = substs.as_closure();\n+            match closure_substs.kind_ty().to_opt_closure_kind() {\n+                Some(closure_kind) if closure_kind.extends(goal_kind) => {}\n+                None => return Ok(None),\n+                _ => return Err(NoSolution),\n+            }\n+            Ok(Some(closure_substs.sig().map_bound(|sig| (sig.inputs()[0], sig.output()))))\n+        }\n+        ty::Bool\n+        | ty::Char\n+        | ty::Int(_)\n+        | ty::Uint(_)\n+        | ty::Float(_)\n+        | ty::Adt(_, _)\n+        | ty::Foreign(_)\n+        | ty::Str\n+        | ty::Array(_, _)\n+        | ty::Slice(_)\n+        | ty::RawPtr(_)\n+        | ty::Ref(_, _, _)\n+        | ty::Dynamic(_, _, _)\n+        | ty::Generator(_, _, _)\n+        | ty::GeneratorWitness(_)\n+        | ty::Never\n+        | ty::Tuple(_)\n+        | ty::Alias(_, _)\n+        | ty::Param(_)\n+        | ty::Placeholder(_)\n+        | ty::Bound(_, _)\n+        | ty::Infer(_)\n+        | ty::Error(_) => Err(NoSolution),\n+    }\n+}"}, {"sha": "c0ecf1c91fb384681b3b27ff4d6145019a989101", "filename": "tests/ui/traits/new-solver/fn-trait-closure.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3452104715281e1e52791dfe7c94622852ab1143/tests%2Fui%2Ftraits%2Fnew-solver%2Ffn-trait-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3452104715281e1e52791dfe7c94622852ab1143/tests%2Fui%2Ftraits%2Fnew-solver%2Ffn-trait-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Ffn-trait-closure.rs?ref=3452104715281e1e52791dfe7c94622852ab1143", "patch": "@@ -0,0 +1,15 @@\n+// compile-flags: -Ztrait-solver=next\n+// known-bug: unknown\n+// failure-status: 101\n+// dont-check-compiler-stderr\n+\n+// This test will fail until we fix `FulfillmentCtxt::relationships`. That's\n+// because we create a type variable for closure upvar types, which is not\n+// constrained until after we try to do fallback on diverging type variables.\n+// Thus, we will call that function, which is unimplemented.\n+\n+fn require_fn(_: impl Fn() -> i32) {}\n+\n+fn main() {\n+    require_fn(|| -> i32 { 1i32 });\n+}"}, {"sha": "d566ead105c8627037706e6d43352aa81796d917", "filename": "tests/ui/traits/new-solver/fn-trait.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3452104715281e1e52791dfe7c94622852ab1143/tests%2Fui%2Ftraits%2Fnew-solver%2Ffn-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3452104715281e1e52791dfe7c94622852ab1143/tests%2Fui%2Ftraits%2Fnew-solver%2Ffn-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Ffn-trait.rs?ref=3452104715281e1e52791dfe7c94622852ab1143", "patch": "@@ -0,0 +1,13 @@\n+// compile-flags: -Ztrait-solver=next\n+// check-pass\n+\n+fn require_fn(_: impl Fn() -> i32) {}\n+\n+fn f() -> i32 {\n+    1i32\n+}\n+\n+fn main() {\n+    require_fn(f);\n+    require_fn(f as fn() -> i32);\n+}"}, {"sha": "15681cd132ec64b583380bbff700f3119bace75f", "filename": "tests/ui/traits/new-solver/pointer-sized.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3452104715281e1e52791dfe7c94622852ab1143/tests%2Fui%2Ftraits%2Fnew-solver%2Fpointer-sized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3452104715281e1e52791dfe7c94622852ab1143/tests%2Fui%2Ftraits%2Fnew-solver%2Fpointer-sized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Fpointer-sized.rs?ref=3452104715281e1e52791dfe7c94622852ab1143", "patch": "@@ -0,0 +1,12 @@\n+#![feature(pointer_sized_trait)]\n+\n+use std::marker::PointerSized;\n+\n+fn require_pointer_sized(_: impl PointerSized) {}\n+\n+fn main() {\n+    require_pointer_sized(1usize);\n+    require_pointer_sized(1u16);\n+    //~^ ERROR `u16` needs to be a pointer-sized type\n+    require_pointer_sized(&1i16);\n+}"}, {"sha": "b250b1331bbf9ef1083cc1349d7b6e74ec91e7f7", "filename": "tests/ui/traits/new-solver/pointer-sized.stderr", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3452104715281e1e52791dfe7c94622852ab1143/tests%2Fui%2Ftraits%2Fnew-solver%2Fpointer-sized.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3452104715281e1e52791dfe7c94622852ab1143/tests%2Fui%2Ftraits%2Fnew-solver%2Fpointer-sized.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Fpointer-sized.stderr?ref=3452104715281e1e52791dfe7c94622852ab1143", "patch": "@@ -0,0 +1,24 @@\n+error[E0277]: `u16` needs to be a pointer-sized type\n+  --> $DIR/pointer-sized.rs:9:27\n+   |\n+LL |     require_pointer_sized(1u16);\n+   |     --------------------- ^^^^ the trait `PointerSized` is not implemented for `u16`\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+   = note: the trait bound `u16: PointerSized` is not satisfied\n+note: required by a bound in `require_pointer_sized`\n+  --> $DIR/pointer-sized.rs:5:34\n+   |\n+LL | fn require_pointer_sized(_: impl PointerSized) {}\n+   |                                  ^^^^^^^^^^^^ required by this bound in `require_pointer_sized`\n+help: consider borrowing here\n+   |\n+LL |     require_pointer_sized(&1u16);\n+   |                           +\n+LL |     require_pointer_sized(&mut 1u16);\n+   |                           ++++\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}]}