{"sha": "360b26389c90716650d20fedf329c1a5332bbdbb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM2MGIyNjM4OWM5MDcxNjY1MGQyMGZlZGYzMjljMWE1MzMyYmJkYmI=", "commit": {"author": {"name": "Gilad Naaman", "email": "gilad.naaman@gmail.com", "date": "2017-12-19T21:12:24Z"}, "committer": {"name": "Gilad Naaman", "email": "gilad.naaman@gmail.com", "date": "2018-01-26T17:46:04Z"}, "message": "libtest: Split-up formatters.rs into smaller modules\n\nlibtest: Split HumanFormatter into {Pretty,Terse}\n\nlibtest: Fixed padding of benchmarks when not benchmarking\n\nlibtest: Fixed benchmarks' names not showing in terse-mode\n\nlibtest: Formatting", "tree": {"sha": "e0bb3b3921c39e901e141a8d2e58627148f6b4f2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e0bb3b3921c39e901e141a8d2e58627148f6b4f2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/360b26389c90716650d20fedf329c1a5332bbdbb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/360b26389c90716650d20fedf329c1a5332bbdbb", "html_url": "https://github.com/rust-lang/rust/commit/360b26389c90716650d20fedf329c1a5332bbdbb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/360b26389c90716650d20fedf329c1a5332bbdbb/comments", "author": null, "committer": null, "parents": [{"sha": "adddb0f41ae70be84c5e3bc30fbe7349462d22b9", "url": "https://api.github.com/repos/rust-lang/rust/commits/adddb0f41ae70be84c5e3bc30fbe7349462d22b9", "html_url": "https://github.com/rust-lang/rust/commit/adddb0f41ae70be84c5e3bc30fbe7349462d22b9"}], "stats": {"total": 1314, "additions": 789, "deletions": 525}, "files": [{"sha": "59228146e6be40588f6819d08eafe72f5b545d47", "filename": "src/libtest/formatters.rs", "status": "removed", "additions": 0, "deletions": 499, "changes": 499, "blob_url": "https://github.com/rust-lang/rust/blob/adddb0f41ae70be84c5e3bc30fbe7349462d22b9/src%2Flibtest%2Fformatters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adddb0f41ae70be84c5e3bc30fbe7349462d22b9/src%2Flibtest%2Fformatters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fformatters.rs?ref=adddb0f41ae70be84c5e3bc30fbe7349462d22b9", "patch": "@@ -1,499 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use super::*;\n-\n-pub(crate) trait OutputFormatter {\n-    fn write_run_start(&mut self, test_count: usize) -> io::Result<()>;\n-    fn write_test_start(&mut self, desc: &TestDesc) -> io::Result<()>;\n-    fn write_timeout(&mut self, desc: &TestDesc) -> io::Result<()>;\n-    fn write_result(\n-        &mut self,\n-        desc: &TestDesc,\n-        result: &TestResult,\n-        stdout: &[u8],\n-    ) -> io::Result<()>;\n-    fn write_run_finish(&mut self, state: &ConsoleTestState) -> io::Result<bool>;\n-}\n-\n-pub(crate) struct HumanFormatter<T> {\n-    out: OutputLocation<T>,\n-    terse: bool,\n-    use_color: bool,\n-    test_count: usize,\n-\n-    /// Number of columns to fill when aligning names\n-    max_name_len: usize,\n-\n-    is_multithreaded: bool,\n-}\n-\n-impl<T: Write> HumanFormatter<T> {\n-    pub fn new(\n-        out: OutputLocation<T>,\n-        use_color: bool,\n-        terse: bool,\n-        max_name_len: usize,\n-        is_multithreaded: bool,\n-    ) -> Self {\n-        HumanFormatter {\n-            out,\n-            terse,\n-            use_color,\n-            test_count: 0,\n-            max_name_len,\n-            is_multithreaded,\n-        }\n-    }\n-\n-    #[cfg(test)]\n-    pub fn output_location(&self) -> &OutputLocation<T> {\n-        &self.out\n-    }\n-\n-    pub fn write_ok(&mut self) -> io::Result<()> {\n-        self.write_short_result(\"ok\", \".\", term::color::GREEN)\n-    }\n-\n-    pub fn write_failed(&mut self) -> io::Result<()> {\n-        self.write_short_result(\"FAILED\", \"F\", term::color::RED)\n-    }\n-\n-    pub fn write_ignored(&mut self) -> io::Result<()> {\n-        self.write_short_result(\"ignored\", \"i\", term::color::YELLOW)\n-    }\n-\n-    pub fn write_allowed_fail(&mut self) -> io::Result<()> {\n-        self.write_short_result(\"FAILED (allowed)\", \"a\", term::color::YELLOW)\n-    }\n-\n-    pub fn write_bench(&mut self) -> io::Result<()> {\n-        self.write_pretty(\"bench\", term::color::CYAN)\n-    }\n-\n-    pub fn write_short_result(\n-        &mut self,\n-        verbose: &str,\n-        quiet: &str,\n-        color: term::color::Color,\n-    ) -> io::Result<()> {\n-        if self.terse {\n-            self.write_pretty(quiet, color)?;\n-            if self.test_count % QUIET_MODE_MAX_COLUMN == QUIET_MODE_MAX_COLUMN - 1 {\n-                // we insert a new line every 100 dots in order to flush the\n-                // screen when dealing with line-buffered output (e.g. piping to\n-                // `stamp` in the rust CI).\n-                self.write_plain(\"\\n\")?;\n-            }\n-\n-            self.test_count += 1;\n-            Ok(())\n-        } else {\n-            self.write_pretty(verbose, color)?;\n-            self.write_plain(\"\\n\")\n-        }\n-    }\n-\n-    pub fn write_pretty(&mut self, word: &str, color: term::color::Color) -> io::Result<()> {\n-        match self.out {\n-            Pretty(ref mut term) => {\n-                if self.use_color {\n-                    term.fg(color)?;\n-                }\n-                term.write_all(word.as_bytes())?;\n-                if self.use_color {\n-                    term.reset()?;\n-                }\n-                term.flush()\n-            }\n-            Raw(ref mut stdout) => {\n-                stdout.write_all(word.as_bytes())?;\n-                stdout.flush()\n-            }\n-        }\n-    }\n-\n-    pub fn write_plain<S: AsRef<str>>(&mut self, s: S) -> io::Result<()> {\n-        let s = s.as_ref();\n-        self.out.write_all(s.as_bytes())?;\n-        self.out.flush()\n-    }\n-\n-    pub fn write_outputs(&mut self, state: &ConsoleTestState) -> io::Result<()> {\n-        self.write_plain(\"\\nsuccesses:\\n\")?;\n-        let mut successes = Vec::new();\n-        let mut stdouts = String::new();\n-        for &(ref f, ref stdout) in &state.not_failures {\n-            successes.push(f.name.to_string());\n-            if !stdout.is_empty() {\n-                stdouts.push_str(&format!(\"---- {} stdout ----\\n\\t\", f.name));\n-                let output = String::from_utf8_lossy(stdout);\n-                stdouts.push_str(&output);\n-                stdouts.push_str(\"\\n\");\n-            }\n-        }\n-        if !stdouts.is_empty() {\n-            self.write_plain(\"\\n\")?;\n-            self.write_plain(&stdouts)?;\n-        }\n-\n-        self.write_plain(\"\\nsuccesses:\\n\")?;\n-        successes.sort();\n-        for name in &successes {\n-            self.write_plain(&format!(\"    {}\\n\", name))?;\n-        }\n-        Ok(())\n-    }\n-\n-    pub fn write_failures(&mut self, state: &ConsoleTestState) -> io::Result<()> {\n-        self.write_plain(\"\\nfailures:\\n\")?;\n-        let mut failures = Vec::new();\n-        let mut fail_out = String::new();\n-        for &(ref f, ref stdout) in &state.failures {\n-            failures.push(f.name.to_string());\n-            if !stdout.is_empty() {\n-                fail_out.push_str(&format!(\"---- {} stdout ----\\n\\t\", f.name));\n-                let output = String::from_utf8_lossy(stdout);\n-                fail_out.push_str(&output);\n-                fail_out.push_str(\"\\n\");\n-            }\n-        }\n-        if !fail_out.is_empty() {\n-            self.write_plain(\"\\n\")?;\n-            self.write_plain(&fail_out)?;\n-        }\n-\n-        self.write_plain(\"\\nfailures:\\n\")?;\n-        failures.sort();\n-        for name in &failures {\n-            self.write_plain(&format!(\"    {}\\n\", name))?;\n-        }\n-        Ok(())\n-    }\n-\n-    fn write_test_name(&mut self, desc: &TestDesc) -> io::Result<()> {\n-        if !(self.terse && desc.name.padding() != PadOnRight) {\n-            let name = desc.padded_name(self.max_name_len, desc.name.padding());\n-            self.write_plain(&format!(\"test {} ... \", name))?;\n-        }\n-\n-        Ok(())\n-    }\n-}\n-\n-impl<T: Write> OutputFormatter for HumanFormatter<T> {\n-    fn write_run_start(&mut self, test_count: usize) -> io::Result<()> {\n-        let noun = if test_count != 1 { \"tests\" } else { \"test\" };\n-        self.write_plain(&format!(\"\\nrunning {} {}\\n\", test_count, noun))\n-    }\n-\n-    fn write_test_start(&mut self, desc: &TestDesc) -> io::Result<()> {\n-        // When running tests concurrently, we should not print\n-        // the test's name as the result will be mis-aligned.\n-        // When running the tests serially, we print the name here so\n-        // that the user can see which test hangs.\n-        if !self.is_multithreaded {\n-            self.write_test_name(desc)?;\n-        }\n-\n-        Ok(())\n-    }\n-\n-    fn write_result(&mut self, desc: &TestDesc, result: &TestResult, _: &[u8]) -> io::Result<()> {\n-        if self.is_multithreaded {\n-            self.write_test_name(desc)?;\n-        }\n-\n-        match *result {\n-            TrOk => self.write_ok(),\n-            TrFailed | TrFailedMsg(_) => self.write_failed(),\n-            TrIgnored => self.write_ignored(),\n-            TrAllowedFail => self.write_allowed_fail(),\n-            TrBench(ref bs) => {\n-                self.write_bench()?;\n-                self.write_plain(&format!(\": {}\\n\", fmt_bench_samples(bs)))\n-            }\n-        }\n-    }\n-\n-    fn write_timeout(&mut self, desc: &TestDesc) -> io::Result<()> {\n-        if self.is_multithreaded {\n-            self.write_test_name(desc)?;\n-        }\n-\n-        self.write_plain(&format!(\n-            \"test {} has been running for over {} seconds\\n\",\n-            desc.name,\n-            TEST_WARN_TIMEOUT_S\n-        ))\n-    }\n-\n-    fn write_run_finish(&mut self, state: &ConsoleTestState) -> io::Result<bool> {\n-        if state.options.display_output {\n-            self.write_outputs(state)?;\n-        }\n-        let success = state.failed == 0;\n-        if !success {\n-            self.write_failures(state)?;\n-        }\n-\n-        self.write_plain(\"\\ntest result: \")?;\n-\n-        if success {\n-            // There's no parallelism at this point so it's safe to use color\n-            self.write_pretty(\"ok\", term::color::GREEN)?;\n-        } else {\n-            self.write_pretty(\"FAILED\", term::color::RED)?;\n-        }\n-\n-        let s = if state.allowed_fail > 0 {\n-            format!(\n-                \". {} passed; {} failed ({} allowed); {} ignored; {} measured; {} filtered out\\n\\n\",\n-                state.passed,\n-                state.failed + state.allowed_fail,\n-                state.allowed_fail,\n-                state.ignored,\n-                state.measured,\n-                state.filtered_out\n-            )\n-        } else {\n-            format!(\n-                \". {} passed; {} failed; {} ignored; {} measured; {} filtered out\\n\\n\",\n-                state.passed,\n-                state.failed,\n-                state.ignored,\n-                state.measured,\n-                state.filtered_out\n-            )\n-        };\n-\n-        self.write_plain(&s)?;\n-\n-        Ok(success)\n-    }\n-}\n-\n-pub(crate) struct JsonFormatter<T> {\n-    out: OutputLocation<T>,\n-}\n-\n-impl<T: Write> JsonFormatter<T> {\n-    pub fn new(out: OutputLocation<T>) -> Self {\n-        Self { out }\n-    }\n-\n-    fn write_message(&mut self, s: &str) -> io::Result<()> {\n-        assert!(!s.contains('\\n'));\n-\n-        self.out.write_all(s.as_ref())?;\n-        self.out.write_all(b\"\\n\")\n-    }\n-\n-    fn write_event(\n-        &mut self,\n-        ty: &str,\n-        name: &str,\n-        evt: &str,\n-        extra: Option<String>,\n-    ) -> io::Result<()> {\n-        if let Some(extras) = extra {\n-            self.write_message(&*format!(\n-                r#\"{{ \"type\": \"{}\", \"name\": \"{}\", \"event\": \"{}\", {} }}\"#,\n-                ty,\n-                name,\n-                evt,\n-                extras\n-            ))\n-        } else {\n-            self.write_message(&*format!(\n-                r#\"{{ \"type\": \"{}\", \"name\": \"{}\", \"event\": \"{}\" }}\"#,\n-                ty,\n-                name,\n-                evt\n-            ))\n-        }\n-    }\n-}\n-\n-impl<T: Write> OutputFormatter for JsonFormatter<T> {\n-    fn write_run_start(&mut self, test_count: usize) -> io::Result<()> {\n-        self.write_message(&*format!(\n-            r#\"{{ \"type\": \"suite\", \"event\": \"started\", \"test_count\": \"{}\" }}\"#,\n-            test_count\n-        ))\n-    }\n-\n-    fn write_test_start(&mut self, desc: &TestDesc) -> io::Result<()> {\n-        self.write_message(&*format!(\n-            r#\"{{ \"type\": \"test\", \"event\": \"started\", \"name\": \"{}\" }}\"#,\n-            desc.name\n-        ))\n-    }\n-\n-    fn write_result(\n-        &mut self,\n-        desc: &TestDesc,\n-        result: &TestResult,\n-        stdout: &[u8],\n-    ) -> io::Result<()> {\n-        match *result {\n-            TrOk => self.write_event(\"test\", desc.name.as_slice(), \"ok\", None),\n-\n-            TrFailed => {\n-                let extra_data = if stdout.len() > 0 {\n-                    Some(format!(\n-                        r#\"\"stdout\": \"{}\"\"#,\n-                        EscapedString(String::from_utf8_lossy(stdout))\n-                    ))\n-                } else {\n-                    None\n-                };\n-\n-                self.write_event(\"test\", desc.name.as_slice(), \"failed\", extra_data)\n-            }\n-\n-            TrFailedMsg(ref m) => {\n-                self.write_event(\n-                    \"test\",\n-                    desc.name.as_slice(),\n-                    \"failed\",\n-                    Some(format!(r#\"\"message\": \"{}\"\"#, EscapedString(m))),\n-                )\n-            }\n-\n-            TrIgnored => self.write_event(\"test\", desc.name.as_slice(), \"ignored\", None),\n-\n-            TrAllowedFail => {\n-                self.write_event(\"test\", desc.name.as_slice(), \"allowed_failure\", None)\n-            }\n-\n-            TrBench(ref bs) => {\n-                let median = bs.ns_iter_summ.median as usize;\n-                let deviation = (bs.ns_iter_summ.max - bs.ns_iter_summ.min) as usize;\n-\n-                let mbps = if bs.mb_s == 0 {\n-                    \"\".into()\n-                } else {\n-                    format!(r#\", \"mib_per_second\": {}\"#, bs.mb_s)\n-                };\n-\n-                let line = format!(\n-                    \"{{ \\\"type\\\": \\\"bench\\\", \\\n-                                \\\"name\\\": \\\"{}\\\", \\\n-                                \\\"median\\\": {}, \\\n-                                \\\"deviation\\\": {}{} }}\",\n-                    desc.name,\n-                    median,\n-                    deviation,\n-                    mbps\n-                );\n-\n-                self.write_message(&*line)\n-            }\n-        }\n-    }\n-\n-    fn write_timeout(&mut self, desc: &TestDesc) -> io::Result<()> {\n-        self.write_message(&*format!(\n-            r#\"{{ \"type\": \"test\", \"event\": \"timeout\", \"name\": \"{}\" }}\"#,\n-            desc.name\n-        ))\n-    }\n-\n-    fn write_run_finish(&mut self, state: &ConsoleTestState) -> io::Result<bool> {\n-\n-        self.write_message(&*format!(\n-            \"{{ \\\"type\\\": \\\"suite\\\", \\\n-            \\\"event\\\": \\\"{}\\\", \\\n-            \\\"passed\\\": {}, \\\n-            \\\"failed\\\": {}, \\\n-            \\\"allowed_fail\\\": {}, \\\n-            \\\"ignored\\\": {}, \\\n-            \\\"measured\\\": {}, \\\n-            \\\"filtered_out\\\": \\\"{}\\\" }}\",\n-            if state.failed == 0 { \"ok\" } else { \"failed\" },\n-            state.passed,\n-            state.failed + state.allowed_fail,\n-            state.allowed_fail,\n-            state.ignored,\n-            state.measured,\n-            state.filtered_out\n-        ))?;\n-\n-        Ok(state.failed == 0)\n-    }\n-}\n-\n-/// A formatting utility used to print strings with characters in need of escaping.\n-/// Base code taken form `libserialize::json::escape_str`\n-struct EscapedString<S: AsRef<str>>(S);\n-\n-impl<S: AsRef<str>> ::std::fmt::Display for EscapedString<S> {\n-    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {\n-        let mut start = 0;\n-\n-        for (i, byte) in self.0.as_ref().bytes().enumerate() {\n-            let escaped = match byte {\n-                b'\"' => \"\\\\\\\"\",\n-                b'\\\\' => \"\\\\\\\\\",\n-                b'\\x00' => \"\\\\u0000\",\n-                b'\\x01' => \"\\\\u0001\",\n-                b'\\x02' => \"\\\\u0002\",\n-                b'\\x03' => \"\\\\u0003\",\n-                b'\\x04' => \"\\\\u0004\",\n-                b'\\x05' => \"\\\\u0005\",\n-                b'\\x06' => \"\\\\u0006\",\n-                b'\\x07' => \"\\\\u0007\",\n-                b'\\x08' => \"\\\\b\",\n-                b'\\t' => \"\\\\t\",\n-                b'\\n' => \"\\\\n\",\n-                b'\\x0b' => \"\\\\u000b\",\n-                b'\\x0c' => \"\\\\f\",\n-                b'\\r' => \"\\\\r\",\n-                b'\\x0e' => \"\\\\u000e\",\n-                b'\\x0f' => \"\\\\u000f\",\n-                b'\\x10' => \"\\\\u0010\",\n-                b'\\x11' => \"\\\\u0011\",\n-                b'\\x12' => \"\\\\u0012\",\n-                b'\\x13' => \"\\\\u0013\",\n-                b'\\x14' => \"\\\\u0014\",\n-                b'\\x15' => \"\\\\u0015\",\n-                b'\\x16' => \"\\\\u0016\",\n-                b'\\x17' => \"\\\\u0017\",\n-                b'\\x18' => \"\\\\u0018\",\n-                b'\\x19' => \"\\\\u0019\",\n-                b'\\x1a' => \"\\\\u001a\",\n-                b'\\x1b' => \"\\\\u001b\",\n-                b'\\x1c' => \"\\\\u001c\",\n-                b'\\x1d' => \"\\\\u001d\",\n-                b'\\x1e' => \"\\\\u001e\",\n-                b'\\x1f' => \"\\\\u001f\",\n-                b'\\x7f' => \"\\\\u007f\",\n-                _ => {\n-                    continue;\n-                }\n-            };\n-\n-            if start < i {\n-                f.write_str(&self.0.as_ref()[start..i])?;\n-            }\n-\n-            f.write_str(escaped)?;\n-\n-            start = i + 1;\n-        }\n-\n-        if start != self.0.as_ref().len() {\n-            f.write_str(&self.0.as_ref()[start..])?;\n-        }\n-\n-        Ok(())\n-    }\n-}"}, {"sha": "d323d50f702ba9d3d16c5a2869f76d14c8ff5ba8", "filename": "src/libtest/formatters/json.rs", "status": "added", "additions": 229, "deletions": 0, "changes": 229, "blob_url": "https://github.com/rust-lang/rust/blob/360b26389c90716650d20fedf329c1a5332bbdbb/src%2Flibtest%2Fformatters%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/360b26389c90716650d20fedf329c1a5332bbdbb/src%2Flibtest%2Fformatters%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fformatters%2Fjson.rs?ref=360b26389c90716650d20fedf329c1a5332bbdbb", "patch": "@@ -0,0 +1,229 @@\n+// Copyright 2012-2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use super::*;\n+\n+pub(crate) struct JsonFormatter<T> {\n+    out: OutputLocation<T>,\n+}\n+\n+impl<T: Write> JsonFormatter<T> {\n+    pub fn new(out: OutputLocation<T>) -> Self {\n+        Self { out }\n+    }\n+\n+    fn write_message(&mut self, s: &str) -> io::Result<()> {\n+        assert!(!s.contains('\\n'));\n+\n+        self.out.write_all(s.as_ref())?;\n+        self.out.write_all(b\"\\n\")\n+    }\n+\n+    fn write_event(\n+        &mut self,\n+        ty: &str,\n+        name: &str,\n+        evt: &str,\n+        extra: Option<String>,\n+    ) -> io::Result<()> {\n+        if let Some(extras) = extra {\n+            self.write_message(&*format!(\n+                r#\"{{ \"type\": \"{}\", \"name\": \"{}\", \"event\": \"{}\", {} }}\"#,\n+                ty,\n+                name,\n+                evt,\n+                extras\n+            ))\n+        } else {\n+            self.write_message(&*format!(\n+                r#\"{{ \"type\": \"{}\", \"name\": \"{}\", \"event\": \"{}\" }}\"#,\n+                ty,\n+                name,\n+                evt\n+            ))\n+        }\n+    }\n+}\n+\n+impl<T: Write> OutputFormatter for JsonFormatter<T> {\n+    fn write_run_start(&mut self, test_count: usize) -> io::Result<()> {\n+        self.write_message(&*format!(\n+            r#\"{{ \"type\": \"suite\", \"event\": \"started\", \"test_count\": \"{}\" }}\"#,\n+            test_count\n+        ))\n+    }\n+\n+    fn write_test_start(&mut self, desc: &TestDesc) -> io::Result<()> {\n+        self.write_message(&*format!(\n+            r#\"{{ \"type\": \"test\", \"event\": \"started\", \"name\": \"{}\" }}\"#,\n+            desc.name\n+        ))\n+    }\n+\n+    fn write_result(\n+        &mut self,\n+        desc: &TestDesc,\n+        result: &TestResult,\n+        stdout: &[u8],\n+    ) -> io::Result<()> {\n+        match *result {\n+            TrOk => self.write_event(\"test\", desc.name.as_slice(), \"ok\", None),\n+\n+            TrFailed => {\n+                let extra_data = if stdout.len() > 0 {\n+                    Some(format!(\n+                        r#\"\"stdout\": \"{}\"\"#,\n+                        EscapedString(String::from_utf8_lossy(stdout))\n+                    ))\n+                } else {\n+                    None\n+                };\n+\n+                self.write_event(\"test\", desc.name.as_slice(), \"failed\", extra_data)\n+            }\n+\n+            TrFailedMsg(ref m) => {\n+                self.write_event(\n+                    \"test\",\n+                    desc.name.as_slice(),\n+                    \"failed\",\n+                    Some(format!(r#\"\"message\": \"{}\"\"#, EscapedString(m))),\n+                )\n+            }\n+\n+            TrIgnored => self.write_event(\"test\", desc.name.as_slice(), \"ignored\", None),\n+\n+            TrAllowedFail => {\n+                self.write_event(\"test\", desc.name.as_slice(), \"allowed_failure\", None)\n+            }\n+\n+            TrBench(ref bs) => {\n+                let median = bs.ns_iter_summ.median as usize;\n+                let deviation = (bs.ns_iter_summ.max - bs.ns_iter_summ.min) as usize;\n+\n+                let mbps = if bs.mb_s == 0 {\n+                    \"\".into()\n+                } else {\n+                    format!(r#\", \"mib_per_second\": {}\"#, bs.mb_s)\n+                };\n+\n+                let line = format!(\n+                    \"{{ \\\"type\\\": \\\"bench\\\", \\\n+                                \\\"name\\\": \\\"{}\\\", \\\n+                                \\\"median\\\": {}, \\\n+                                \\\"deviation\\\": {}{} }}\",\n+                    desc.name,\n+                    median,\n+                    deviation,\n+                    mbps\n+                );\n+\n+                self.write_message(&*line)\n+            }\n+        }\n+    }\n+\n+    fn write_timeout(&mut self, desc: &TestDesc) -> io::Result<()> {\n+        self.write_message(&*format!(\n+            r#\"{{ \"type\": \"test\", \"event\": \"timeout\", \"name\": \"{}\" }}\"#,\n+            desc.name\n+        ))\n+    }\n+\n+    fn write_run_finish(&mut self, state: &ConsoleTestState) -> io::Result<bool> {\n+\n+        self.write_message(&*format!(\n+            \"{{ \\\"type\\\": \\\"suite\\\", \\\n+            \\\"event\\\": \\\"{}\\\", \\\n+            \\\"passed\\\": {}, \\\n+            \\\"failed\\\": {}, \\\n+            \\\"allowed_fail\\\": {}, \\\n+            \\\"ignored\\\": {}, \\\n+            \\\"measured\\\": {}, \\\n+            \\\"filtered_out\\\": \\\"{}\\\" }}\",\n+            if state.failed == 0 { \"ok\" } else { \"failed\" },\n+            state.passed,\n+            state.failed + state.allowed_fail,\n+            state.allowed_fail,\n+            state.ignored,\n+            state.measured,\n+            state.filtered_out\n+        ))?;\n+\n+        Ok(state.failed == 0)\n+    }\n+}\n+\n+/// A formatting utility used to print strings with characters in need of escaping.\n+/// Base code taken form `libserialize::json::escape_str`\n+struct EscapedString<S: AsRef<str>>(S);\n+\n+impl<S: AsRef<str>> ::std::fmt::Display for EscapedString<S> {\n+    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {\n+        let mut start = 0;\n+\n+        for (i, byte) in self.0.as_ref().bytes().enumerate() {\n+            let escaped = match byte {\n+                b'\"' => \"\\\\\\\"\",\n+                b'\\\\' => \"\\\\\\\\\",\n+                b'\\x00' => \"\\\\u0000\",\n+                b'\\x01' => \"\\\\u0001\",\n+                b'\\x02' => \"\\\\u0002\",\n+                b'\\x03' => \"\\\\u0003\",\n+                b'\\x04' => \"\\\\u0004\",\n+                b'\\x05' => \"\\\\u0005\",\n+                b'\\x06' => \"\\\\u0006\",\n+                b'\\x07' => \"\\\\u0007\",\n+                b'\\x08' => \"\\\\b\",\n+                b'\\t' => \"\\\\t\",\n+                b'\\n' => \"\\\\n\",\n+                b'\\x0b' => \"\\\\u000b\",\n+                b'\\x0c' => \"\\\\f\",\n+                b'\\r' => \"\\\\r\",\n+                b'\\x0e' => \"\\\\u000e\",\n+                b'\\x0f' => \"\\\\u000f\",\n+                b'\\x10' => \"\\\\u0010\",\n+                b'\\x11' => \"\\\\u0011\",\n+                b'\\x12' => \"\\\\u0012\",\n+                b'\\x13' => \"\\\\u0013\",\n+                b'\\x14' => \"\\\\u0014\",\n+                b'\\x15' => \"\\\\u0015\",\n+                b'\\x16' => \"\\\\u0016\",\n+                b'\\x17' => \"\\\\u0017\",\n+                b'\\x18' => \"\\\\u0018\",\n+                b'\\x19' => \"\\\\u0019\",\n+                b'\\x1a' => \"\\\\u001a\",\n+                b'\\x1b' => \"\\\\u001b\",\n+                b'\\x1c' => \"\\\\u001c\",\n+                b'\\x1d' => \"\\\\u001d\",\n+                b'\\x1e' => \"\\\\u001e\",\n+                b'\\x1f' => \"\\\\u001f\",\n+                b'\\x7f' => \"\\\\u007f\",\n+                _ => {\n+                    continue;\n+                }\n+            };\n+\n+            if start < i {\n+                f.write_str(&self.0.as_ref()[start..i])?;\n+            }\n+\n+            f.write_str(escaped)?;\n+\n+            start = i + 1;\n+        }\n+\n+        if start != self.0.as_ref().len() {\n+            f.write_str(&self.0.as_ref()[start..])?;\n+        }\n+\n+        Ok(())\n+    }\n+}"}, {"sha": "24c7929076c1db4a6579b1b7cceda93b9dcf4b46", "filename": "src/libtest/formatters/mod.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/360b26389c90716650d20fedf329c1a5332bbdbb/src%2Flibtest%2Fformatters%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/360b26389c90716650d20fedf329c1a5332bbdbb/src%2Flibtest%2Fformatters%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fformatters%2Fmod.rs?ref=360b26389c90716650d20fedf329c1a5332bbdbb", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2012-2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use super::*;\n+\n+mod pretty;\n+mod json;\n+mod terse;\n+\n+pub(crate) use self::pretty::PrettyFormatter;\n+pub(crate) use self::json::JsonFormatter;\n+pub(crate) use self::terse::TerseFormatter;\n+\n+pub(crate) trait OutputFormatter {\n+    fn write_run_start(&mut self, test_count: usize) -> io::Result<()>;\n+    fn write_test_start(&mut self, desc: &TestDesc) -> io::Result<()>;\n+    fn write_timeout(&mut self, desc: &TestDesc) -> io::Result<()>;\n+    fn write_result(\n+        &mut self,\n+        desc: &TestDesc,\n+        result: &TestResult,\n+        stdout: &[u8],\n+    ) -> io::Result<()>;\n+    fn write_run_finish(&mut self, state: &ConsoleTestState) -> io::Result<bool>;\n+}"}, {"sha": "f2064deefce621f2ffa7945244e89b3905b1e443", "filename": "src/libtest/formatters/pretty.rs", "status": "added", "additions": 247, "deletions": 0, "changes": 247, "blob_url": "https://github.com/rust-lang/rust/blob/360b26389c90716650d20fedf329c1a5332bbdbb/src%2Flibtest%2Fformatters%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/360b26389c90716650d20fedf329c1a5332bbdbb/src%2Flibtest%2Fformatters%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fformatters%2Fpretty.rs?ref=360b26389c90716650d20fedf329c1a5332bbdbb", "patch": "@@ -0,0 +1,247 @@\n+// Copyright 2012-2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use super::*;\n+\n+pub(crate) struct PrettyFormatter<T> {\n+    out: OutputLocation<T>,\n+    use_color: bool,\n+\n+    /// Number of columns to fill when aligning names\n+    max_name_len: usize,\n+\n+    is_multithreaded: bool,\n+}\n+\n+impl<T: Write> PrettyFormatter<T> {\n+    pub fn new(\n+        out: OutputLocation<T>,\n+        use_color: bool,\n+        max_name_len: usize,\n+        is_multithreaded: bool,\n+    ) -> Self {\n+        PrettyFormatter {\n+            out,\n+            use_color,\n+            max_name_len,\n+            is_multithreaded,\n+        }\n+    }\n+\n+    #[cfg(test)]\n+    pub fn output_location(&self) -> &OutputLocation<T> {\n+        &self.out\n+    }\n+\n+    pub fn write_ok(&mut self) -> io::Result<()> {\n+        self.write_short_result(\"ok\", term::color::GREEN)\n+    }\n+\n+    pub fn write_failed(&mut self) -> io::Result<()> {\n+        self.write_short_result(\"FAILED\", term::color::RED)\n+    }\n+\n+    pub fn write_ignored(&mut self) -> io::Result<()> {\n+        self.write_short_result(\"ignored\", term::color::YELLOW)\n+    }\n+\n+    pub fn write_allowed_fail(&mut self) -> io::Result<()> {\n+        self.write_short_result(\"FAILED (allowed)\", term::color::YELLOW)\n+    }\n+\n+    pub fn write_bench(&mut self) -> io::Result<()> {\n+        self.write_pretty(\"bench\", term::color::CYAN)\n+    }\n+\n+    pub fn write_short_result(\n+        &mut self,\n+        result: &str,\n+        color: term::color::Color,\n+    ) -> io::Result<()> {\n+        self.write_pretty(result, color)?;\n+        self.write_plain(\"\\n\")\n+    }\n+\n+    pub fn write_pretty(&mut self, word: &str, color: term::color::Color) -> io::Result<()> {\n+        match self.out {\n+            Pretty(ref mut term) => {\n+                if self.use_color {\n+                    term.fg(color)?;\n+                }\n+                term.write_all(word.as_bytes())?;\n+                if self.use_color {\n+                    term.reset()?;\n+                }\n+                term.flush()\n+            }\n+            Raw(ref mut stdout) => {\n+                stdout.write_all(word.as_bytes())?;\n+                stdout.flush()\n+            }\n+        }\n+    }\n+\n+    pub fn write_plain<S: AsRef<str>>(&mut self, s: S) -> io::Result<()> {\n+        let s = s.as_ref();\n+        self.out.write_all(s.as_bytes())?;\n+        self.out.flush()\n+    }\n+\n+    pub fn write_successes(&mut self, state: &ConsoleTestState) -> io::Result<()> {\n+        self.write_plain(\"\\nsuccesses:\\n\")?;\n+        let mut successes = Vec::new();\n+        let mut stdouts = String::new();\n+        for &(ref f, ref stdout) in &state.not_failures {\n+            successes.push(f.name.to_string());\n+            if !stdout.is_empty() {\n+                stdouts.push_str(&format!(\"---- {} stdout ----\\n\\t\", f.name));\n+                let output = String::from_utf8_lossy(stdout);\n+                stdouts.push_str(&output);\n+                stdouts.push_str(\"\\n\");\n+            }\n+        }\n+        if !stdouts.is_empty() {\n+            self.write_plain(\"\\n\")?;\n+            self.write_plain(&stdouts)?;\n+        }\n+\n+        self.write_plain(\"\\nsuccesses:\\n\")?;\n+        successes.sort();\n+        for name in &successes {\n+            self.write_plain(&format!(\"    {}\\n\", name))?;\n+        }\n+        Ok(())\n+    }\n+\n+    pub fn write_failures(&mut self, state: &ConsoleTestState) -> io::Result<()> {\n+        self.write_plain(\"\\nfailures:\\n\")?;\n+        let mut failures = Vec::new();\n+        let mut fail_out = String::new();\n+        for &(ref f, ref stdout) in &state.failures {\n+            failures.push(f.name.to_string());\n+            if !stdout.is_empty() {\n+                fail_out.push_str(&format!(\"---- {} stdout ----\\n\\t\", f.name));\n+                let output = String::from_utf8_lossy(stdout);\n+                fail_out.push_str(&output);\n+                fail_out.push_str(\"\\n\");\n+            }\n+        }\n+        if !fail_out.is_empty() {\n+            self.write_plain(\"\\n\")?;\n+            self.write_plain(&fail_out)?;\n+        }\n+\n+        self.write_plain(\"\\nfailures:\\n\")?;\n+        failures.sort();\n+        for name in &failures {\n+            self.write_plain(&format!(\"    {}\\n\", name))?;\n+        }\n+        Ok(())\n+    }\n+\n+    fn write_test_name(&mut self, desc: &TestDesc) -> io::Result<()> {\n+        let name = desc.padded_name(self.max_name_len, desc.name.padding());\n+        self.write_plain(&format!(\"test {} ... \", name))?;\n+\n+        Ok(())\n+    }\n+}\n+\n+impl<T: Write> OutputFormatter for PrettyFormatter<T> {\n+    fn write_run_start(&mut self, test_count: usize) -> io::Result<()> {\n+        let noun = if test_count != 1 { \"tests\" } else { \"test\" };\n+        self.write_plain(&format!(\"\\nrunning {} {}\\n\", test_count, noun))\n+    }\n+\n+    fn write_test_start(&mut self, desc: &TestDesc) -> io::Result<()> {\n+        // When running tests concurrently, we should not print\n+        // the test's name as the result will be mis-aligned.\n+        // When running the tests serially, we print the name here so\n+        // that the user can see which test hangs.\n+        if !self.is_multithreaded {\n+            self.write_test_name(desc)?;\n+        }\n+\n+        Ok(())\n+    }\n+\n+    fn write_result(&mut self, desc: &TestDesc, result: &TestResult, _: &[u8]) -> io::Result<()> {\n+        if self.is_multithreaded {\n+            self.write_test_name(desc)?;\n+        }\n+\n+        match *result {\n+            TrOk => self.write_ok(),\n+            TrFailed | TrFailedMsg(_) => self.write_failed(),\n+            TrIgnored => self.write_ignored(),\n+            TrAllowedFail => self.write_allowed_fail(),\n+            TrBench(ref bs) => {\n+                self.write_bench()?;\n+                self.write_plain(&format!(\": {}\\n\", fmt_bench_samples(bs)))\n+            }\n+        }\n+    }\n+\n+    fn write_timeout(&mut self, desc: &TestDesc) -> io::Result<()> {\n+        if self.is_multithreaded {\n+            self.write_test_name(desc)?;\n+        }\n+\n+        self.write_plain(&format!(\n+            \"test {} has been running for over {} seconds\\n\",\n+            desc.name,\n+            TEST_WARN_TIMEOUT_S\n+        ))\n+    }\n+\n+    fn write_run_finish(&mut self, state: &ConsoleTestState) -> io::Result<bool> {\n+        if state.options.display_output {\n+            self.write_successes(state)?;\n+        }\n+        let success = state.failed == 0;\n+        if !success {\n+            self.write_failures(state)?;\n+        }\n+\n+        self.write_plain(\"\\ntest result: \")?;\n+\n+        if success {\n+            // There's no parallelism at this point so it's safe to use color\n+            self.write_pretty(\"ok\", term::color::GREEN)?;\n+        } else {\n+            self.write_pretty(\"FAILED\", term::color::RED)?;\n+        }\n+\n+        let s = if state.allowed_fail > 0 {\n+            format!(\n+                \". {} passed; {} failed ({} allowed); {} ignored; {} measured; {} filtered out\\n\\n\",\n+                state.passed,\n+                state.failed + state.allowed_fail,\n+                state.allowed_fail,\n+                state.ignored,\n+                state.measured,\n+                state.filtered_out\n+            )\n+        } else {\n+            format!(\n+                \". {} passed; {} failed; {} ignored; {} measured; {} filtered out\\n\\n\",\n+                state.passed,\n+                state.failed,\n+                state.ignored,\n+                state.measured,\n+                state.filtered_out\n+            )\n+        };\n+\n+        self.write_plain(&s)?;\n+\n+        Ok(success)\n+    }\n+}"}, {"sha": "88689485144c0d9a9968486ee23076313d1c07e0", "filename": "src/libtest/formatters/terse.rs", "status": "added", "additions": 246, "deletions": 0, "changes": 246, "blob_url": "https://github.com/rust-lang/rust/blob/360b26389c90716650d20fedf329c1a5332bbdbb/src%2Flibtest%2Fformatters%2Fterse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/360b26389c90716650d20fedf329c1a5332bbdbb/src%2Flibtest%2Fformatters%2Fterse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fformatters%2Fterse.rs?ref=360b26389c90716650d20fedf329c1a5332bbdbb", "patch": "@@ -0,0 +1,246 @@\n+// Copyright 2012-2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use super::*;\n+\n+pub(crate) struct TerseFormatter<T> {\n+    out: OutputLocation<T>,\n+    use_color: bool,\n+    is_multithreaded: bool,\n+    /// Number of columns to fill when aligning names\n+    max_name_len: usize,\n+\n+    test_count: usize,\n+}\n+\n+impl<T: Write> TerseFormatter<T> {\n+    pub fn new(\n+        out: OutputLocation<T>,\n+        use_color: bool,\n+        max_name_len: usize,\n+        is_multithreaded: bool,\n+    ) -> Self {\n+        TerseFormatter {\n+            out,\n+            use_color,\n+            max_name_len,\n+            is_multithreaded,\n+            test_count: 0,\n+        }\n+    }\n+\n+    pub fn write_ok(&mut self) -> io::Result<()> {\n+        self.write_short_result(\".\", term::color::GREEN)\n+    }\n+\n+    pub fn write_failed(&mut self) -> io::Result<()> {\n+        self.write_short_result(\"F\", term::color::RED)\n+    }\n+\n+    pub fn write_ignored(&mut self) -> io::Result<()> {\n+        self.write_short_result(\"i\", term::color::YELLOW)\n+    }\n+\n+    pub fn write_allowed_fail(&mut self) -> io::Result<()> {\n+        self.write_short_result(\"a\", term::color::YELLOW)\n+    }\n+\n+    pub fn write_bench(&mut self) -> io::Result<()> {\n+        self.write_pretty(\"bench\", term::color::CYAN)\n+    }\n+\n+    pub fn write_short_result(\n+        &mut self,\n+        result: &str,\n+        color: term::color::Color,\n+    ) -> io::Result<()> {\n+        self.write_pretty(result, color)?;\n+        if self.test_count % QUIET_MODE_MAX_COLUMN == QUIET_MODE_MAX_COLUMN - 1 {\n+            // we insert a new line every 100 dots in order to flush the\n+            // screen when dealing with line-buffered output (e.g. piping to\n+            // `stamp` in the rust CI).\n+            self.write_plain(\"\\n\")?;\n+        }\n+\n+        self.test_count += 1;\n+        Ok(())\n+    }\n+\n+    pub fn write_pretty(&mut self, word: &str, color: term::color::Color) -> io::Result<()> {\n+        match self.out {\n+            Pretty(ref mut term) => {\n+                if self.use_color {\n+                    term.fg(color)?;\n+                }\n+                term.write_all(word.as_bytes())?;\n+                if self.use_color {\n+                    term.reset()?;\n+                }\n+                term.flush()\n+            }\n+            Raw(ref mut stdout) => {\n+                stdout.write_all(word.as_bytes())?;\n+                stdout.flush()\n+            }\n+        }\n+    }\n+\n+    pub fn write_plain<S: AsRef<str>>(&mut self, s: S) -> io::Result<()> {\n+        let s = s.as_ref();\n+        self.out.write_all(s.as_bytes())?;\n+        self.out.flush()\n+    }\n+\n+    pub fn write_outputs(&mut self, state: &ConsoleTestState) -> io::Result<()> {\n+        self.write_plain(\"\\nsuccesses:\\n\")?;\n+        let mut successes = Vec::new();\n+        let mut stdouts = String::new();\n+        for &(ref f, ref stdout) in &state.not_failures {\n+            successes.push(f.name.to_string());\n+            if !stdout.is_empty() {\n+                stdouts.push_str(&format!(\"---- {} stdout ----\\n\\t\", f.name));\n+                let output = String::from_utf8_lossy(stdout);\n+                stdouts.push_str(&output);\n+                stdouts.push_str(\"\\n\");\n+            }\n+        }\n+        if !stdouts.is_empty() {\n+            self.write_plain(\"\\n\")?;\n+            self.write_plain(&stdouts)?;\n+        }\n+\n+        self.write_plain(\"\\nsuccesses:\\n\")?;\n+        successes.sort();\n+        for name in &successes {\n+            self.write_plain(&format!(\"    {}\\n\", name))?;\n+        }\n+        Ok(())\n+    }\n+\n+    pub fn write_failures(&mut self, state: &ConsoleTestState) -> io::Result<()> {\n+        self.write_plain(\"\\nfailures:\\n\")?;\n+        let mut failures = Vec::new();\n+        let mut fail_out = String::new();\n+        for &(ref f, ref stdout) in &state.failures {\n+            failures.push(f.name.to_string());\n+            if !stdout.is_empty() {\n+                fail_out.push_str(&format!(\"---- {} stdout ----\\n\\t\", f.name));\n+                let output = String::from_utf8_lossy(stdout);\n+                fail_out.push_str(&output);\n+                fail_out.push_str(\"\\n\");\n+            }\n+        }\n+        if !fail_out.is_empty() {\n+            self.write_plain(\"\\n\")?;\n+            self.write_plain(&fail_out)?;\n+        }\n+\n+        self.write_plain(\"\\nfailures:\\n\")?;\n+        failures.sort();\n+        for name in &failures {\n+            self.write_plain(&format!(\"    {}\\n\", name))?;\n+        }\n+        Ok(())\n+    }\n+\n+    fn write_test_name(&mut self, desc: &TestDesc) -> io::Result<()> {\n+        let name = desc.padded_name(self.max_name_len, desc.name.padding());\n+        self.write_plain(&format!(\"test {} ... \", name))?;\n+\n+        Ok(())\n+    }\n+}\n+\n+impl<T: Write> OutputFormatter for TerseFormatter<T> {\n+    fn write_run_start(&mut self, test_count: usize) -> io::Result<()> {\n+        let noun = if test_count != 1 { \"tests\" } else { \"test\" };\n+        self.write_plain(&format!(\"\\nrunning {} {}\\n\", test_count, noun))\n+    }\n+\n+    fn write_test_start(&mut self, desc: &TestDesc) -> io::Result<()> {\n+        // Remnants from old libtest code that used the padding value\n+        // in order to indicate benchmarks.\n+        // When running benchmarks, terse-mode should still print their name as if\n+        // it is the Pretty formatter.\n+        if !self.is_multithreaded && desc.name.padding() == PadOnRight {\n+            self.write_test_name(desc)?;\n+        }\n+\n+        Ok(())\n+    }\n+\n+    fn write_result(&mut self, desc: &TestDesc, result: &TestResult, _: &[u8]) -> io::Result<()> {\n+        match *result {\n+            TrOk => self.write_ok(),\n+            TrFailed | TrFailedMsg(_) => self.write_failed(),\n+            TrIgnored => self.write_ignored(),\n+            TrAllowedFail => self.write_allowed_fail(),\n+            TrBench(ref bs) => {\n+                if self.is_multithreaded {\n+                    self.write_test_name(desc)?;\n+                }\n+                self.write_bench()?;\n+                self.write_plain(&format!(\": {}\\n\", fmt_bench_samples(bs)))\n+            }\n+        }\n+    }\n+\n+    fn write_timeout(&mut self, desc: &TestDesc) -> io::Result<()> {\n+        self.write_plain(&format!(\n+            \"test {} has been running for over {} seconds\\n\",\n+            desc.name,\n+            TEST_WARN_TIMEOUT_S\n+        ))\n+    }\n+\n+    fn write_run_finish(&mut self, state: &ConsoleTestState) -> io::Result<bool> {\n+        if state.options.display_output {\n+            self.write_outputs(state)?;\n+        }\n+        let success = state.failed == 0;\n+        if !success {\n+            self.write_failures(state)?;\n+        }\n+\n+        self.write_plain(\"\\ntest result: \")?;\n+\n+        if success {\n+            // There's no parallelism at this point so it's safe to use color\n+            self.write_pretty(\"ok\", term::color::GREEN)?;\n+        } else {\n+            self.write_pretty(\"FAILED\", term::color::RED)?;\n+        }\n+\n+        let s = if state.allowed_fail > 0 {\n+            format!(\n+                \". {} passed; {} failed ({} allowed); {} ignored; {} measured; {} filtered out\\n\\n\",\n+                state.passed,\n+                state.failed + state.allowed_fail,\n+                state.allowed_fail,\n+                state.ignored,\n+                state.measured,\n+                state.filtered_out\n+            )\n+        } else {\n+            format!(\n+                \". {} passed; {} failed; {} ignored; {} measured; {} filtered out\\n\\n\",\n+                state.passed,\n+                state.failed,\n+                state.ignored,\n+                state.measured,\n+                state.filtered_out\n+            )\n+        };\n+\n+        self.write_plain(&s)?;\n+\n+        Ok(success)\n+    }\n+}"}, {"sha": "d69a9f493f0553882b85d553478293faae0fdc87", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 22, "deletions": 24, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/360b26389c90716650d20fedf329c1a5332bbdbb/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/360b26389c90716650d20fedf329c1a5332bbdbb/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=360b26389c90716650d20fedf329c1a5332bbdbb", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2017 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -87,7 +87,7 @@ pub mod test {\n pub mod stats;\n mod formatters;\n \n-use formatters::*;\n+use formatters::{OutputFormatter, PrettyFormatter, TerseFormatter, JsonFormatter};\n \n // The name of a test. By convention this follows the rules for rust\n // paths; i.e. it should be a series of identifiers separated by double\n@@ -475,7 +475,7 @@ Test Attributes:\n     );\n }\n \n-// FIXME: Copied from libsyntax until linkage errors are resolved.\n+// FIXME: Copied from libsyntax until linkage errors are resolved. Issue #47566\n fn is_nightly() -> bool {\n     // Whether this is a feature-staged build, i.e. on the beta or stable channel\n     let disable_unstable_features = option_env!(\"CFG_DISABLE_UNSTABLE_FEATURES\").is_some();\n@@ -769,13 +769,12 @@ pub fn fmt_bench_samples(bs: &BenchSamples) -> String {\n \n // List the tests to console, and optionally to logfile. Filters are honored.\n pub fn list_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> io::Result<()> {\n-    let output = match term::stdout() {\n+    let mut output = match term::stdout() {\n         None => Raw(io::stdout()),\n         Some(t) => Pretty(t),\n     };\n \n     let quiet = opts.format == OutputFormat::Terse;\n-    let mut out = HumanFormatter::new(output, use_color(opts), quiet, 0, false);\n     let mut st = ConsoleTestState::new(opts)?;\n \n     let mut ntest = 0;\n@@ -801,7 +800,7 @@ pub fn list_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> io::Res\n             }\n         };\n \n-        out.write_plain(format!(\"{}: {}\\n\", name, fntype))?;\n+        writeln!(output, \"{}: {}\", name, fntype)?;\n         st.write_log(format!(\"{} {}\\n\", fntype, name))?;\n     }\n \n@@ -814,29 +813,21 @@ pub fn list_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> io::Res\n \n     if !quiet {\n         if ntest != 0 || nbench != 0 {\n-            out.write_plain(\"\\n\")?;\n+            writeln!(output, \"\")?;\n         }\n-        out.write_plain(format!(\n-            \"{}, {}\\n\",\n+\n+        writeln!(output,\n+            \"{}, {}\",\n             plural(ntest, \"test\"),\n             plural(nbench, \"benchmark\")\n-        ))?;\n+        )?;\n     }\n \n     Ok(())\n }\n \n // A simple console test runner\n pub fn run_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> io::Result<bool> {\n-    let tests = {\n-        let mut tests = tests;\n-        for test in tests.iter_mut() {\n-            test.desc.name = test.desc.name.with_padding(test.testfn.padding());\n-        }\n-\n-        tests\n-    };\n-\n     fn callback(\n         event: &TestEvent,\n         st: &mut ConsoleTestState,\n@@ -902,17 +893,15 @@ pub fn run_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> io::Resu\n     };\n \n     let mut out: Box<OutputFormatter> = match opts.format {\n-        OutputFormat::Pretty => Box::new(HumanFormatter::new(\n+        OutputFormat::Pretty => Box::new(PrettyFormatter::new(\n             output,\n             use_color(opts),\n-            false,\n             max_name_len,\n             is_multithreaded,\n         )),\n-        OutputFormat::Terse => Box::new(HumanFormatter::new(\n+        OutputFormat::Terse => Box::new(TerseFormatter::new(\n             output,\n             use_color(opts),\n-            true,\n             max_name_len,\n             is_multithreaded,\n         )),\n@@ -949,7 +938,7 @@ fn should_sort_failures_before_printing_them() {\n         allow_fail: false,\n     };\n \n-    let mut out = HumanFormatter::new(Raw(Vec::new()), false, false, 10, false);\n+    let mut out = PrettyFormatter::new(Raw(Vec::new()), false, 10, false);\n \n     let st = ConsoleTestState {\n         log_out: None,\n@@ -1040,6 +1029,15 @@ where\n         filtered_tests = convert_benchmarks_to_tests(filtered_tests);\n     }\n \n+    let filtered_tests = {\n+        let mut filtered_tests = filtered_tests;\n+        for test in filtered_tests.iter_mut() {\n+            test.desc.name = test.desc.name.with_padding(test.testfn.padding());\n+        }\n+\n+        filtered_tests\n+    };\n+\n     let filtered_out = tests_len - filtered_tests.len();\n     callback(TeFilteredOut(filtered_out))?;\n "}, {"sha": "5cff1f1a5b1af37f1f312ac1fe6bc574a80ebbd3", "filename": "src/test/run-make/libtest-json/f.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/360b26389c90716650d20fedf329c1a5332bbdbb/src%2Ftest%2Frun-make%2Flibtest-json%2Ff.rs", "raw_url": "https://github.com/rust-lang/rust/raw/360b26389c90716650d20fedf329c1a5332bbdbb/src%2Ftest%2Frun-make%2Flibtest-json%2Ff.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Flibtest-json%2Ff.rs?ref=360b26389c90716650d20fedf329c1a5332bbdbb", "patch": "@@ -28,4 +28,5 @@ fn c() {\n #[ignore]\n fn d() {\n     assert!(false);\n-}\n\\ No newline at end of file\n+}\n+"}, {"sha": "235f8cd7c725744d6f95f89b751ee7847e9e60e5", "filename": "src/test/run-make/libtest-json/output.json", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/360b26389c90716650d20fedf329c1a5332bbdbb/src%2Ftest%2Frun-make%2Flibtest-json%2Foutput.json", "raw_url": "https://github.com/rust-lang/rust/raw/360b26389c90716650d20fedf329c1a5332bbdbb/src%2Ftest%2Frun-make%2Flibtest-json%2Foutput.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Flibtest-json%2Foutput.json?ref=360b26389c90716650d20fedf329c1a5332bbdbb", "patch": "@@ -2,7 +2,7 @@\n { \"type\": \"test\", \"event\": \"started\", \"name\": \"a\" }\n { \"type\": \"test\", \"name\": \"a\", \"event\": \"ok\" }\n { \"type\": \"test\", \"event\": \"started\", \"name\": \"b\" }\n-{ \"type\": \"test\", \"name\": \"b\", \"event\": \"failed\", \"stdout\": \"thread 'b' panicked at 'assertion failed: false', f.rs:18:4\\nnote: Run with `RUST_BACKTRACE=1` for a backtrace.\\n\" }\n+{ \"type\": \"test\", \"name\": \"b\", \"event\": \"failed\", \"stdout\": \"thread 'b' panicked at 'assertion failed: false', f.rs:18:5\\nnote: Run with `RUST_BACKTRACE=1` for a backtrace.\\n\" }\n { \"type\": \"test\", \"event\": \"started\", \"name\": \"c\" }\n { \"type\": \"test\", \"name\": \"c\", \"event\": \"ok\" }\n { \"type\": \"test\", \"event\": \"started\", \"name\": \"d\" }"}, {"sha": "1e97639b524e8bd9f95658e34362f805b3c94c8a", "filename": "src/test/run-make/libtest-json/validate_json.py", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/360b26389c90716650d20fedf329c1a5332bbdbb/src%2Ftest%2Frun-make%2Flibtest-json%2Fvalidate_json.py", "raw_url": "https://github.com/rust-lang/rust/raw/360b26389c90716650d20fedf329c1a5332bbdbb/src%2Ftest%2Frun-make%2Flibtest-json%2Fvalidate_json.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Flibtest-json%2Fvalidate_json.py?ref=360b26389c90716650d20fedf329c1a5332bbdbb", "patch": "@@ -1,5 +1,15 @@\n #!/usr/bin/env python\n \n+# Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+# file at the top-level directory of this distribution and at\n+# http://rust-lang.org/COPYRIGHT.\n+#\n+# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+# option. This file may not be copied, modified, or distributed\n+# except according to those terms.\n+\n import sys\n import json\n "}]}