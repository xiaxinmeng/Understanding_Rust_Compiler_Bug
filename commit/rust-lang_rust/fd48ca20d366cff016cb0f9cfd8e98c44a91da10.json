{"sha": "fd48ca20d366cff016cb0f9cfd8e98c44a91da10", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZkNDhjYTIwZDM2NmNmZjAxNmNiMGY5Y2ZkOGU5OGM0NGE5MWRhMTA=", "commit": {"author": {"name": "Alexander Regueiro", "email": "alex@noldorin.com", "date": "2019-09-06T20:05:37Z"}, "committer": {"name": "Alexander Regueiro", "email": "alexreg@me.com", "date": "2019-09-07T15:27:20Z"}, "message": "Apply suggestions from code review\n\nCo-Authored-By: Mazdak Farrokhzad <twingoow@gmail.com>", "tree": {"sha": "677c13f5211bb59450dba27b41fa2739fe254143", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/677c13f5211bb59450dba27b41fa2739fe254143"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fd48ca20d366cff016cb0f9cfd8e98c44a91da10", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fd48ca20d366cff016cb0f9cfd8e98c44a91da10", "html_url": "https://github.com/rust-lang/rust/commit/fd48ca20d366cff016cb0f9cfd8e98c44a91da10", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fd48ca20d366cff016cb0f9cfd8e98c44a91da10/comments", "author": {"login": "alexreg", "id": 67036, "node_id": "MDQ6VXNlcjY3MDM2", "avatar_url": "https://avatars.githubusercontent.com/u/67036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexreg", "html_url": "https://github.com/alexreg", "followers_url": "https://api.github.com/users/alexreg/followers", "following_url": "https://api.github.com/users/alexreg/following{/other_user}", "gists_url": "https://api.github.com/users/alexreg/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexreg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexreg/subscriptions", "organizations_url": "https://api.github.com/users/alexreg/orgs", "repos_url": "https://api.github.com/users/alexreg/repos", "events_url": "https://api.github.com/users/alexreg/events{/privacy}", "received_events_url": "https://api.github.com/users/alexreg/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexreg", "id": 67036, "node_id": "MDQ6VXNlcjY3MDM2", "avatar_url": "https://avatars.githubusercontent.com/u/67036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexreg", "html_url": "https://github.com/alexreg", "followers_url": "https://api.github.com/users/alexreg/followers", "following_url": "https://api.github.com/users/alexreg/following{/other_user}", "gists_url": "https://api.github.com/users/alexreg/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexreg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexreg/subscriptions", "organizations_url": "https://api.github.com/users/alexreg/orgs", "repos_url": "https://api.github.com/users/alexreg/repos", "events_url": "https://api.github.com/users/alexreg/events{/privacy}", "received_events_url": "https://api.github.com/users/alexreg/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c1d29ee3c754c63fc6c8c3a522b7a71a5a19616a", "url": "https://api.github.com/repos/rust-lang/rust/commits/c1d29ee3c754c63fc6c8c3a522b7a71a5a19616a", "html_url": "https://github.com/rust-lang/rust/commit/c1d29ee3c754c63fc6c8c3a522b7a71a5a19616a"}], "stats": {"total": 114, "additions": 54, "deletions": 60}, "files": [{"sha": "b50cfa00f09ef63e433b29102fe273dfb0f1caa2", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd48ca20d366cff016cb0f9cfd8e98c44a91da10/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd48ca20d366cff016cb0f9cfd8e98c44a91da10/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=fd48ca20d366cff016cb0f9cfd8e98c44a91da10", "patch": "@@ -126,7 +126,7 @@ pub struct LoweringContext<'a> {\n     /// lifetime definitions in the corresponding impl or function generics.\n     lifetimes_to_define: Vec<(Span, ParamName)>,\n \n-    /// `true` ifs in-band lifetimes are being collected. This is used to\n+    /// `true` if in-band lifetimes are being collected. This is used to\n     /// indicate whether or not we're in a place where new lifetimes will result\n     /// in in-band lifetime definitions, such a function or an impl header,\n     /// including implicit lifetimes from `impl_header_lifetime_elision`."}, {"sha": "755cda792ba797091591f3bb2c1d75614ea69134", "filename": "src/librustc/mir/interpret/allocation.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fd48ca20d366cff016cb0f9cfd8e98c44a91da10/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd48ca20d366cff016cb0f9cfd8e98c44a91da10/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs?ref=fd48ca20d366cff016cb0f9cfd8e98c44a91da10", "patch": "@@ -4,13 +4,14 @@ use super::{\n     Pointer, InterpResult, AllocId, ScalarMaybeUndef, write_target_uint, read_target_uint, Scalar,\n };\n \n+use crate::mir;\n use crate::ty::layout::{Size, Align};\n+\n+use rustc_data_structures::sorted_map::SortedMap;\n+use rustc_target::abi::HasDataLayout;\n use syntax::ast::Mutability;\n use std::iter;\n-use crate::mir;\n use std::ops::{Range, Deref, DerefMut};\n-use rustc_data_structures::sorted_map::SortedMap;\n-use rustc_target::abi::HasDataLayout;\n use std::borrow::Cow;\n \n // NOTE: When adding new fields, make sure to adjust the `Snapshot` impl in\n@@ -765,7 +766,7 @@ impl<Tag: Copy, Extra> Allocation<Tag, Extra> {\n         }\n     }\n \n-    /// Apply a relocation copy.\n+    /// Applies a relocation copy.\n     /// The affected range, as defined in the parameters to `prepare_relocation_copy` is expected\n     /// to be clear of relocations.\n     pub fn mark_relocation_range("}, {"sha": "23433c2e8834d28dc65e8b162712e62451a96db6", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fd48ca20d366cff016cb0f9cfd8e98c44a91da10/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd48ca20d366cff016cb0f9cfd8e98c44a91da10/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=fd48ca20d366cff016cb0f9cfd8e98c44a91da10", "patch": "@@ -349,7 +349,6 @@ pub enum GlobalAlloc<'tcx> {\n     Memory(&'tcx Allocation),\n }\n \n-#[derive(Clone)]\n pub struct AllocMap<'tcx> {\n     /// Maps `AllocId`s to their corresponding allocations.\n     alloc_map: FxHashMap<AllocId, GlobalAlloc<'tcx>>,"}, {"sha": "18a5142208d2d6dcb0cce0260769c79ea1f5ae04", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/fd48ca20d366cff016cb0f9cfd8e98c44a91da10/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd48ca20d366cff016cb0f9cfd8e98c44a91da10/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=fd48ca20d366cff016cb0f9cfd8e98c44a91da10", "patch": "@@ -605,8 +605,6 @@ pub enum LocalKind {\n \n #[derive(Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub struct VarBindingForm<'tcx> {\n-    /// The `HirId` of the variable.\n-    pub var_id: hir::HirId,\n     /// Is variable bound via `x`, `mut x`, `ref x`, or `ref mut x`?\n     pub binding_mode: ty::BindingMode,\n     /// If an explicit type was provided for this variable binding,\n@@ -656,7 +654,6 @@ pub enum ImplicitSelfKind {\n CloneTypeFoldableAndLiftImpls! { BindingForm<'tcx>, }\n \n impl_stable_hash_for!(struct self::VarBindingForm<'tcx> {\n-    var_id,\n     binding_mode,\n     opt_ty_info,\n     opt_match_place,\n@@ -877,7 +874,9 @@ impl<'tcx> LocalDecl<'tcx> {\n         match self.is_user_variable {\n             Some(ClearCrossCrate::Set(BindingForm::Var(VarBindingForm {\n                 binding_mode: ty::BindingMode::BindByValue(_),\n-                ..\n+                opt_ty_info: _,\n+                opt_match_place: _,\n+                pat_span: _,\n             }))) => true,\n \n             Some(ClearCrossCrate::Set(BindingForm::ImplicitSelf(ImplicitSelfKind::Imm))) => true,\n@@ -893,7 +892,9 @@ impl<'tcx> LocalDecl<'tcx> {\n         match self.is_user_variable {\n             Some(ClearCrossCrate::Set(BindingForm::Var(VarBindingForm {\n                 binding_mode: ty::BindingMode::BindByValue(_),\n-                ..\n+                opt_ty_info: _,\n+                opt_match_place: _,\n+                pat_span: _,\n             }))) => true,\n \n             Some(ClearCrossCrate::Set(BindingForm::ImplicitSelf(_))) => true,\n@@ -2830,7 +2831,7 @@ impl Location {\n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n pub enum UnsafetyViolationKind {\n     General,\n-    /// Permitted in const fns and regular fns.\n+    /// Permitted both in `const fn`s and regular `fn`s.\n     GeneralAndConstFn,\n     ExternStatic(hir::HirId),\n     BorrowPacked(hir::HirId),\n@@ -2848,7 +2849,7 @@ pub struct UnsafetyViolation {\n pub struct UnsafetyCheckResult {\n     /// Violations that are propagated *upwards* from this function.\n     pub violations: Lrc<[UnsafetyViolation]>,\n-    /// Unsafe blocks in this function, along with whether they are used. This is\n+    /// `unsafe` blocks in this function, along with whether they are used. This is\n     /// used for the \"unused_unsafe\" lint.\n     pub unsafe_blocks: Lrc<[(hir::HirId, bool)]>,\n }\n@@ -2875,12 +2876,14 @@ pub struct GeneratorLayout<'tcx> {\n     /// layout.\n     pub storage_conflicts: BitMatrix<GeneratorSavedLocal, GeneratorSavedLocal>,\n \n-    /// Names and scopes of all the stored generator locals.\n+    /// The names and scopes of all the stored generator locals.\n+    ///\n+    /// N.B., this is *strictly* a temporary hack for codegen\n+    /// debuginfo generation, and will be removed at some point.\n+    /// Do **NOT** use it for anything else, local information should not be\n+    /// in the MIR, please rely on local crate HIR or other side-channels.\n     //\n-    // NOTE(tmandry) This is *strictly* a temporary hack for codegen\n-    // debuginfo generation, and will be removed at some point.\n-    // Do **NOT** use it for anything else, local information should not be\n-    // in the MIR, please rely on local crate HIR or other side-channels.\n+    // FIXME(tmandry): see above.\n     pub __local_debuginfo_codegen_only_do_not_use: IndexVec<GeneratorSavedLocal, LocalDecl<'tcx>>,\n }\n "}, {"sha": "c74b2fee41d6c298428cd02935151e8485148706", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fd48ca20d366cff016cb0f9cfd8e98c44a91da10/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd48ca20d366cff016cb0f9cfd8e98c44a91da10/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=fd48ca20d366cff016cb0f9cfd8e98c44a91da10", "patch": "@@ -711,11 +711,11 @@ impl Passes {\n }\n \n /// Defines all `CodegenOptions`/`DebuggingOptions` fields and parsers all at once. The goal of this\n-/// macro is to define an interface that can be programmatically used by the option parser in order\n+/// macro is to define an interface that can be programmatically used by the option parser\n /// to initialize the struct without hardcoding field names all over the place.\n ///\n /// The goal is to invoke this macro once with the correct fields, and then this macro generates all\n-/// necessary code. The main gotcha of this macro is the cgsetters module which is a bunch of\n+/// necessary code. The main gotcha of this macro is the `cgsetters` module which is a bunch of\n /// generated code to parse an option into its respective field in the struct. There are a few\n /// hand-written parsers for parsing specific types of values in this module.\n macro_rules! options {"}, {"sha": "3d36790c94b8c4bbf9ac37929f2ec0f6841c1647", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd48ca20d366cff016cb0f9cfd8e98c44a91da10/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd48ca20d366cff016cb0f9cfd8e98c44a91da10/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=fd48ca20d366cff016cb0f9cfd8e98c44a91da10", "patch": "@@ -571,7 +571,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                           -> Vec<ty::PolyTraitRef<'tcx>>\n     {\n         if source_trait_ref.def_id() == target_trait_def_id {\n-            return vec![source_trait_ref]; // Shorcut the most common case.\n+            return vec![source_trait_ref]; // Shortcut the most common case.\n         }\n \n         supertraits(self, source_trait_ref)"}, {"sha": "8e8472a5aacc9b54966345befd0fc459e3455479", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fd48ca20d366cff016cb0f9cfd8e98c44a91da10/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd48ca20d366cff016cb0f9cfd8e98c44a91da10/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=fd48ca20d366cff016cb0f9cfd8e98c44a91da10", "patch": "@@ -1,5 +1,3 @@\n-// ignore-tidy-filelength\n-\n //! Type context book-keeping.\n \n use crate::arena::Arena;\n@@ -1753,7 +1751,7 @@ pub mod tls {\n         pub task_deps: Option<&'a Lock<TaskDeps>>,\n     }\n \n-    /// Sets Rayon's thread local variablem, which is preserved for Rayon jobs\n+    /// Sets Rayon's thread-local variable, which is preserved for Rayon jobs\n     /// to `value` during the call to `f`. It is restored to its previous value after.\n     /// This is used to set the pointer to the new `ImplicitCtxt`.\n     #[cfg(parallel_compiler)]\n@@ -1762,7 +1760,7 @@ pub mod tls {\n         rayon_core::tlv::with(value, f)\n     }\n \n-    /// Gets Rayon's thread local variable, which is preserved for Rayon jobs.\n+    /// Gets Rayon's thread-local variable, which is preserved for Rayon jobs.\n     /// This is used to get the pointer to the current `ImplicitCtxt`.\n     #[cfg(parallel_compiler)]\n     #[inline]"}, {"sha": "d99580116e4ae30fe0394c12a012a0566c581d39", "filename": "src/librustc/ty/print/pretty.rs", "status": "modified", "additions": 24, "deletions": 27, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/fd48ca20d366cff016cb0f9cfd8e98c44a91da10/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd48ca20d366cff016cb0f9cfd8e98c44a91da10/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs?ref=fd48ca20d366cff016cb0f9cfd8e98c44a91da10", "patch": "@@ -1093,38 +1093,35 @@ impl<F: fmt::Write> Printer<'tcx> for FmtPrinter<'_, 'tcx, F> {\n         }\n \n         let key = self.tcx.def_key(def_id);\n-        match key.disambiguated_data.data {\n-            DefPathData::Impl => {\n-                // Always use types for non-local impls, where types are always\n-                // available, and filename/line-number is mostly uninteresting.\n-                let use_types =\n-                    !def_id.is_local() || {\n-                        // Otherwise, use filename/line-number if forced.\n-                        let force_no_types = FORCE_IMPL_FILENAME_LINE.with(|f| f.get());\n-                        !force_no_types\n-                    };\n-\n-                if !use_types {\n-                    // If no type info is available, fall back to\n-                    // pretty-printing some span information. This should\n-                    // only occur very early in the compiler pipeline.\n-                    let parent_def_id = DefId { index: key.parent.unwrap(), ..def_id };\n-                    let span = self.tcx.def_span(def_id);\n+        if let DefPathData::Impl = key.disambiguated_data.data {\n+            // Always use types for non-local impls, where types are always\n+            // available, and filename/line-number is mostly uninteresting.\n+            let use_types =\n+                !def_id.is_local() || {\n+                    // Otherwise, use filename/line-number if forced.\n+                    let force_no_types = FORCE_IMPL_FILENAME_LINE.with(|f| f.get());\n+                    !force_no_types\n+                };\n \n-                    self = self.print_def_path(parent_def_id, &[])?;\n+            if !use_types {\n+                // If no type info is available, fall back to\n+                // pretty printing some span information. This should\n+                // only occur very early in the compiler pipeline.\n+                let parent_def_id = DefId { index: key.parent.unwrap(), ..def_id };\n+                let span = self.tcx.def_span(def_id);\n \n-                    // HACK(eddyb) copy of `path_append` to avoid\n-                    // constructing a `DisambiguatedDefPathData`.\n-                    if !self.empty_path {\n-                        write!(self, \"::\")?;\n-                    }\n-                    write!(self, \"<impl at {:?}>\", span)?;\n-                    self.empty_path = false;\n+                self = self.print_def_path(parent_def_id, &[])?;\n \n-                    return Ok(self);\n+                // HACK(eddyb) copy of `path_append` to avoid\n+                // constructing a `DisambiguatedDefPathData`.\n+                if !self.empty_path {\n+                    write!(self, \"::\")?;\n                 }\n+                write!(self, \"<impl at {:?}>\", span)?;\n+                self.empty_path = false;\n+\n+                return Ok(self);\n             }\n-            _ => {}\n         }\n \n         self.default_print_def_path(def_id, substs)"}, {"sha": "4cef6a09925addb6b3365440cd48e59245c6595f", "filename": "src/librustc/ty/query/on_disk_cache.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fd48ca20d366cff016cb0f9cfd8e98c44a91da10/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd48ca20d366cff016cb0f9cfd8e98c44a91da10/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs?ref=fd48ca20d366cff016cb0f9cfd8e98c44a91da10", "patch": "@@ -429,7 +429,7 @@ impl<'sess> OnDiskCache<'sess> {\n \n //- DECODING -------------------------------------------------------------------\n \n-/// A decoder that can read fro the incr. comp. cache. It is similar to the onem\n+/// A decoder that can read fro the incr. comp. cache. It is similar to the one\n /// we use for crate metadata decoding in that it can rebase spans and eventually\n /// will also handle things that contain `Ty` instances.\n struct CacheDecoder<'a, 'tcx> {\n@@ -460,27 +460,25 @@ impl<'a, 'tcx> CacheDecoder<'a, 'tcx> {\n     }\n }\n \n-pub trait DecoderWithPosition: Decoder {\n+trait DecoderWithPosition: Decoder {\n     fn position(&self) -> usize;\n }\n \n impl<'a> DecoderWithPosition for opaque::Decoder<'a> {\n-    #[inline]\n     fn position(&self) -> usize {\n         self.position()\n     }\n }\n \n impl<'a, 'tcx> DecoderWithPosition for CacheDecoder<'a, 'tcx> {\n-    #[inline]\n     fn position(&self) -> usize {\n         self.opaque.position()\n     }\n }\n \n // Decodes something that was encoded with `encode_tagged()` and verify that the\n // tag matches and the correct amount of bytes was read.\n-pub fn decode_tagged<D, T, V>(decoder: &mut D, expected_tag: T) -> Result<V, D::Error>\n+fn decode_tagged<D, T, V>(decoder: &mut D, expected_tag: T) -> Result<V, D::Error>\n where\n     T: Decodable + Eq + ::std::fmt::Debug,\n     V: Decodable,\n@@ -700,7 +698,6 @@ impl<'a, 'tcx> SpecializedDecoder<NodeId> for CacheDecoder<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> SpecializedDecoder<Fingerprint> for CacheDecoder<'a, 'tcx> {\n-    #[inline]\n     fn specialized_decode(&mut self) -> Result<Fingerprint, Self::Error> {\n         Fingerprint::decode_opaque(&mut self.opaque)\n     }\n@@ -754,7 +751,7 @@ where\n     /// encode the specified tag, then the given value, then the number of\n     /// bytes taken up by tag and value. On decoding, we can then verify that\n     /// we get the expected tag and read the expected number of bytes.\n-    pub fn encode_tagged<T: Encodable, V: Encodable>(\n+    fn encode_tagged<T: Encodable, V: Encodable>(\n         &mut self,\n         tag: T,\n         value: &V\n@@ -960,7 +957,6 @@ where\n }\n \n impl<'a, 'tcx> SpecializedEncoder<Fingerprint> for CacheEncoder<'a, 'tcx, opaque::Encoder> {\n-    #[inline]\n     fn specialized_encode(&mut self, f: &Fingerprint) -> Result<(), Self::Error> {\n         f.encode_opaque(&mut self.encoder)\n     }"}]}