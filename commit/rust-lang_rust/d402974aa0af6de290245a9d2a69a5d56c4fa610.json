{"sha": "d402974aa0af6de290245a9d2a69a5d56c4fa610", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ0MDI5NzRhYTBhZjZkZTI5MDI0NWE5ZDJhNjlhNWQ1NmM0ZmE2MTA=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-07-18T16:23:05Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-07-19T10:16:24Z"}, "message": "migrate ra_syntax to the new rowan API", "tree": {"sha": "df4a0e38e548f9f74592e00a2c5a7d37bab3c4c2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/df4a0e38e548f9f74592e00a2c5a7d37bab3c4c2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d402974aa0af6de290245a9d2a69a5d56c4fa610", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d402974aa0af6de290245a9d2a69a5d56c4fa610", "html_url": "https://github.com/rust-lang/rust/commit/d402974aa0af6de290245a9d2a69a5d56c4fa610", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d402974aa0af6de290245a9d2a69a5d56c4fa610/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "58d4983ba5745975446d60f2886d96f8d2adf0f2", "url": "https://api.github.com/repos/rust-lang/rust/commits/58d4983ba5745975446d60f2886d96f8d2adf0f2", "html_url": "https://github.com/rust-lang/rust/commit/58d4983ba5745975446d60f2886d96f8d2adf0f2"}], "stats": {"total": 3537, "additions": 1187, "deletions": 2350}, "files": [{"sha": "16fef3dfd0b21d9945f87641df6c5fef71de3e08", "filename": "Cargo.lock", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d402974aa0af6de290245a9d2a69a5d56c4fa610/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/d402974aa0af6de290245a9d2a69a5d56c4fa610/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=d402974aa0af6de290245a9d2a69a5d56c4fa610", "patch": "@@ -1313,7 +1313,7 @@ dependencies = [\n  \"itertools 0.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ra_parser 0.1.0\",\n  \"ra_text_edit 0.1.0\",\n- \"rowan 0.5.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rowan 0.5.5 (git+https://github.com/rust-analyzer/rowan?branch=cursor)\",\n  \"smol_str 0.1.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"test_utils 0.1.0\",\n  \"unicode-xid 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1585,7 +1585,7 @@ dependencies = [\n [[package]]\n name = \"rowan\"\n version = \"0.5.5\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+source = \"git+https://github.com/rust-analyzer/rowan?branch=cursor#d41b21587487f8b372ee779e37c557b873ba0715\"\n dependencies = [\n  \"colosseum 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"parking_lot 0.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -2275,7 +2275,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum relative-path 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0e7790c7f1cc73d831d28dc5a7deb316a006e7848e6a7f467cdb10a0a9e0fb1c\"\n \"checksum remove_dir_all 0.5.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4a83fa3702a688b9359eccba92d153ac33fd2e8462f9e0e3fdf155239ea7792e\"\n \"checksum ron 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"17f52a24414403f81528b67488cf8edc4eda977d3af1646bb6b106a600ead78f\"\n-\"checksum rowan 0.5.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"500ba7550373d42593a5228085bad391517378fa31ad2a84defe100dd8259fef\"\n+\"checksum rowan 0.5.5 (git+https://github.com/rust-analyzer/rowan?branch=cursor)\" = \"<none>\"\n \"checksum rustc-demangle 0.1.15 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a7f4dccf6f4891ebcc0c39f9b6eb1a83b9bf5d747cb439ec6fba4f3b977038af\"\n \"checksum rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7540fc8b0c49f096ee9c961cda096467dce8084bec6bdca2fc83895fd9b28cb8\"\n \"checksum rustc_version 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"138e3e0acb6c9fb258b19b67cb8abd63c00679d2851805ea151465464fe9030a\""}, {"sha": "df1f6438da96d94e587de9725cc5a653e8d13cc6", "filename": "Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d402974aa0af6de290245a9d2a69a5d56c4fa610/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d402974aa0af6de290245a9d2a69a5d56c4fa610/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=d402974aa0af6de290245a9d2a69a5d56c4fa610", "patch": "@@ -6,3 +6,4 @@ incremental = true\n debug = true\n \n [patch.'crates-io']\n+rowan = { git = \"https://github.com/rust-analyzer/rowan\", branch = \"cursor\" }"}, {"sha": "e2de5e0e39bab1dd08e2bdfb0d991017133f76ad", "filename": "crates/ra_syntax/src/algo.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d402974aa0af6de290245a9d2a69a5d56c4fa610/crates%2Fra_syntax%2Fsrc%2Falgo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d402974aa0af6de290245a9d2a69a5d56c4fa610/crates%2Fra_syntax%2Fsrc%2Falgo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Falgo.rs?ref=d402974aa0af6de290245a9d2a69a5d56c4fa610", "patch": "@@ -9,8 +9,8 @@ pub use rowan::TokenAtOffset;\n pub fn find_token_at_offset(node: &SyntaxNode, offset: TextUnit) -> TokenAtOffset<SyntaxToken> {\n     match node.0.token_at_offset(offset) {\n         TokenAtOffset::None => TokenAtOffset::None,\n-        TokenAtOffset::Single(n) => TokenAtOffset::Single(n.into()),\n-        TokenAtOffset::Between(l, r) => TokenAtOffset::Between(l.into(), r.into()),\n+        TokenAtOffset::Single(n) => TokenAtOffset::Single(SyntaxToken(n)),\n+        TokenAtOffset::Between(l, r) => TokenAtOffset::Between(SyntaxToken(l), SyntaxToken(r)),\n     }\n }\n \n@@ -22,7 +22,7 @@ pub fn find_token_at_offset(node: &SyntaxNode, offset: TextUnit) -> TokenAtOffse\n pub fn ancestors_at_offset(\n     node: &SyntaxNode,\n     offset: TextUnit,\n-) -> impl Iterator<Item = &SyntaxNode> {\n+) -> impl Iterator<Item = SyntaxNode> {\n     find_token_at_offset(node, offset)\n         .map(|token| token.parent().ancestors())\n         .kmerge_by(|node1, node2| node1.range().len() < node2.range().len())\n@@ -37,7 +37,7 @@ pub fn ancestors_at_offset(\n /// ```\n ///\n /// then the shorter node will be silently preferred.\n-pub fn find_node_at_offset<N: AstNode>(syntax: &SyntaxNode, offset: TextUnit) -> Option<&N> {\n+pub fn find_node_at_offset<N: AstNode>(syntax: &SyntaxNode, offset: TextUnit) -> Option<N> {\n     ancestors_at_offset(syntax, offset).find_map(N::cast)\n }\n \n@@ -59,5 +59,5 @@ pub fn non_trivia_sibling(element: SyntaxElement, direction: Direction) -> Optio\n }\n \n pub fn find_covering_element(root: &SyntaxNode, range: TextRange) -> SyntaxElement {\n-    root.0.covering_node(range).into()\n+    SyntaxElement::new(root.0.covering_node(range))\n }"}, {"sha": "87bd15cc0c5bde966f7958629ee14f9044bcbab1", "filename": "crates/ra_syntax/src/algo/visit.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d402974aa0af6de290245a9d2a69a5d56c4fa610/crates%2Fra_syntax%2Fsrc%2Falgo%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d402974aa0af6de290245a9d2a69a5d56c4fa610/crates%2Fra_syntax%2Fsrc%2Falgo%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Falgo%2Fvisit.rs?ref=d402974aa0af6de290245a9d2a69a5d56c4fa610", "patch": "@@ -16,7 +16,7 @@ pub trait Visitor<'a>: Sized {\n     fn visit<N, F>(self, f: F) -> Vis<Self, N, F>\n     where\n         N: AstNode + 'a,\n-        F: FnOnce(&'a N) -> Self::Output,\n+        F: FnOnce(N) -> Self::Output,\n     {\n         Vis { inner: self, f, ph: PhantomData }\n     }\n@@ -29,7 +29,7 @@ pub trait VisitorCtx<'a>: Sized {\n     fn visit<N, F>(self, f: F) -> VisCtx<Self, N, F>\n     where\n         N: AstNode + 'a,\n-        F: FnOnce(&'a N, Self::Ctx) -> Self::Output,\n+        F: FnOnce(N, Self::Ctx) -> Self::Output,\n     {\n         VisCtx { inner: self, f, ph: PhantomData }\n     }\n@@ -74,13 +74,13 @@ impl<'a, V, N, F> Visitor<'a> for Vis<V, N, F>\n where\n     V: Visitor<'a>,\n     N: AstNode + 'a,\n-    F: FnOnce(&'a N) -> <V as Visitor<'a>>::Output,\n+    F: FnOnce(N) -> <V as Visitor<'a>>::Output,\n {\n     type Output = <V as Visitor<'a>>::Output;\n \n     fn accept(self, node: &'a SyntaxNode) -> Option<Self::Output> {\n         let Vis { inner, f, .. } = self;\n-        inner.accept(node).or_else(|| N::cast(node).map(f))\n+        inner.accept(node).or_else(|| N::cast(node.clone()).map(f))\n     }\n }\n \n@@ -95,14 +95,14 @@ impl<'a, V, N, F> VisitorCtx<'a> for VisCtx<V, N, F>\n where\n     V: VisitorCtx<'a>,\n     N: AstNode + 'a,\n-    F: FnOnce(&'a N, <V as VisitorCtx<'a>>::Ctx) -> <V as VisitorCtx<'a>>::Output,\n+    F: FnOnce(N, <V as VisitorCtx<'a>>::Ctx) -> <V as VisitorCtx<'a>>::Output,\n {\n     type Output = <V as VisitorCtx<'a>>::Output;\n     type Ctx = <V as VisitorCtx<'a>>::Ctx;\n \n     fn accept(self, node: &'a SyntaxNode) -> Result<Self::Output, Self::Ctx> {\n         let VisCtx { inner, f, .. } = self;\n-        inner.accept(node).or_else(|ctx| match N::cast(node) {\n+        inner.accept(node).or_else(|ctx| match N::cast(node.clone()) {\n             None => Err(ctx),\n             Some(node) => Ok(f(node, ctx)),\n         })"}, {"sha": "fe00e78d1d706e4c226edfcf8acd751a03a8514c", "filename": "crates/ra_syntax/src/ast.rs", "status": "modified", "additions": 17, "deletions": 19, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/d402974aa0af6de290245a9d2a69a5d56c4fa610/crates%2Fra_syntax%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d402974aa0af6de290245a9d2a69a5d56c4fa610/crates%2Fra_syntax%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast.rs?ref=d402974aa0af6de290245a9d2a69a5d56c4fa610", "patch": "@@ -9,7 +9,7 @@ mod expr_extensions;\n use std::marker::PhantomData;\n \n use crate::{\n-    syntax_node::{SyntaxNode, SyntaxNodeChildren, SyntaxToken, TreeArc},\n+    syntax_node::{SyntaxNode, SyntaxNodeChildren, SyntaxToken},\n     SmolStr,\n };\n \n@@ -25,51 +25,49 @@ pub use self::{\n /// conversion itself has zero runtime cost: ast and syntax nodes have exactly\n /// the same representation: a pointer to the tree root and a pointer to the\n /// node itself.\n-pub trait AstNode:\n-    rowan::TransparentNewType<Repr = rowan::SyntaxNode> + ToOwned<Owned = TreeArc<Self>>\n-{\n-    fn cast(syntax: &SyntaxNode) -> Option<&Self>\n+pub trait AstNode {\n+    fn cast(syntax: SyntaxNode) -> Option<Self>\n     where\n         Self: Sized;\n     fn syntax(&self) -> &SyntaxNode;\n }\n \n /// Like `AstNode`, but wraps tokens rather than interior nodes.\n-pub trait AstToken<'a> {\n-    fn cast(token: SyntaxToken<'a>) -> Option<Self>\n+pub trait AstToken {\n+    fn cast(token: SyntaxToken) -> Option<Self>\n     where\n         Self: Sized;\n-    fn syntax(&self) -> SyntaxToken<'a>;\n-    fn text(&self) -> &'a SmolStr {\n+    fn syntax(&self) -> &SyntaxToken;\n+    fn text(&self) -> &SmolStr {\n         self.syntax().text()\n     }\n }\n \n /// An iterator over `SyntaxNode` children of a particular AST type.\n #[derive(Debug)]\n-pub struct AstChildren<'a, N> {\n-    inner: SyntaxNodeChildren<'a>,\n+pub struct AstChildren<N> {\n+    inner: SyntaxNodeChildren,\n     ph: PhantomData<N>,\n }\n \n-impl<'a, N> AstChildren<'a, N> {\n-    fn new(parent: &'a SyntaxNode) -> Self {\n+impl<N> AstChildren<N> {\n+    fn new(parent: &SyntaxNode) -> Self {\n         AstChildren { inner: parent.children(), ph: PhantomData }\n     }\n }\n \n-impl<'a, N: AstNode + 'a> Iterator for AstChildren<'a, N> {\n-    type Item = &'a N;\n-    fn next(&mut self) -> Option<&'a N> {\n+impl<N: AstNode> Iterator for AstChildren<N> {\n+    type Item = N;\n+    fn next(&mut self) -> Option<N> {\n         self.inner.by_ref().find_map(N::cast)\n     }\n }\n \n-fn child_opt<P: AstNode, C: AstNode>(parent: &P) -> Option<&C> {\n+fn child_opt<P: AstNode + ?Sized, C: AstNode>(parent: &P) -> Option<C> {\n     children(parent).next()\n }\n \n-fn children<P: AstNode, C: AstNode>(parent: &P) -> AstChildren<C> {\n+fn children<P: AstNode + ?Sized, C: AstNode>(parent: &P) -> AstChildren<C> {\n     AstChildren::new(parent.syntax())\n }\n \n@@ -123,7 +121,7 @@ fn test_doc_comment_preserves_indents() {\n \n #[test]\n fn test_where_predicates() {\n-    fn assert_bound(text: &str, bound: Option<&TypeBound>) {\n+    fn assert_bound(text: &str, bound: Option<TypeBound>) {\n         assert_eq!(text, bound.unwrap().syntax().text().to_string());\n     }\n "}, {"sha": "ca1773908a19aeb9fec0db3624b0b9860647ef52", "filename": "crates/ra_syntax/src/ast/expr_extensions.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/d402974aa0af6de290245a9d2a69a5d56c4fa610/crates%2Fra_syntax%2Fsrc%2Fast%2Fexpr_extensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d402974aa0af6de290245a9d2a69a5d56c4fa610/crates%2Fra_syntax%2Fsrc%2Fast%2Fexpr_extensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fexpr_extensions.rs?ref=d402974aa0af6de290245a9d2a69a5d56c4fa610", "patch": "@@ -8,20 +8,20 @@ use crate::{\n };\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n-pub enum ElseBranch<'a> {\n-    Block(&'a ast::Block),\n-    IfExpr(&'a ast::IfExpr),\n+pub enum ElseBranch {\n+    Block(ast::Block),\n+    IfExpr(ast::IfExpr),\n }\n \n impl ast::IfExpr {\n-    pub fn then_branch(&self) -> Option<&ast::Block> {\n+    pub fn then_branch(&self) -> Option<ast::Block> {\n         self.blocks().nth(0)\n     }\n     pub fn else_branch(&self) -> Option<ElseBranch> {\n         let res = match self.blocks().nth(1) {\n             Some(block) => ElseBranch::Block(block),\n             None => {\n-                let elif: &ast::IfExpr = child_opt(self)?;\n+                let elif: ast::IfExpr = child_opt(self)?;\n                 ElseBranch::IfExpr(elif)\n             }\n         };\n@@ -60,7 +60,7 @@ impl ast::PrefixExpr {\n     }\n \n     pub fn op_token(&self) -> Option<SyntaxToken> {\n-        self.syntax().first_child_or_token()?.as_token()\n+        self.syntax().first_child_or_token()?.as_token().cloned()\n     }\n }\n \n@@ -132,7 +132,7 @@ pub enum BinOp {\n \n impl ast::BinExpr {\n     fn op_details(&self) -> Option<(SyntaxToken, BinOp)> {\n-        self.syntax().children_with_tokens().filter_map(|it| it.as_token()).find_map(|c| {\n+        self.syntax().children_with_tokens().filter_map(|it| it.as_token().cloned()).find_map(|c| {\n             match c.kind() {\n                 T![||] => Some((c, BinOp::BooleanOr)),\n                 T![&&] => Some((c, BinOp::BooleanAnd)),\n@@ -178,25 +178,25 @@ impl ast::BinExpr {\n         self.op_details().map(|t| t.0)\n     }\n \n-    pub fn lhs(&self) -> Option<&ast::Expr> {\n+    pub fn lhs(&self) -> Option<ast::Expr> {\n         children(self).nth(0)\n     }\n \n-    pub fn rhs(&self) -> Option<&ast::Expr> {\n+    pub fn rhs(&self) -> Option<ast::Expr> {\n         children(self).nth(1)\n     }\n \n-    pub fn sub_exprs(&self) -> (Option<&ast::Expr>, Option<&ast::Expr>) {\n+    pub fn sub_exprs(&self) -> (Option<ast::Expr>, Option<ast::Expr>) {\n         let mut children = children(self);\n         let first = children.next();\n         let second = children.next();\n         (first, second)\n     }\n }\n \n-pub enum ArrayExprKind<'a> {\n-    Repeat { initializer: Option<&'a ast::Expr>, repeat: Option<&'a ast::Expr> },\n-    ElementList(AstChildren<'a, ast::Expr>),\n+pub enum ArrayExprKind {\n+    Repeat { initializer: Option<ast::Expr>, repeat: Option<ast::Expr> },\n+    ElementList(AstChildren<ast::Expr>),\n }\n \n impl ast::ArrayExpr {\n@@ -275,12 +275,12 @@ impl ast::Literal {\n #[test]\n fn test_literal_with_attr() {\n     let parse = ast::SourceFile::parse(r#\"const _: &str = { #[attr] \"Hello\" };\"#);\n-    let lit = parse.tree.syntax().descendants().find_map(ast::Literal::cast).unwrap();\n+    let lit = parse.tree().syntax().descendants().find_map(ast::Literal::cast).unwrap();\n     assert_eq!(lit.token().text(), r#\"\"Hello\"\"#);\n }\n \n impl ast::NamedField {\n-    pub fn parent_struct_lit(&self) -> &ast::StructLit {\n+    pub fn parent_struct_lit(&self) -> ast::StructLit {\n         self.syntax().ancestors().find_map(ast::StructLit::cast).unwrap()\n     }\n }"}, {"sha": "5420f67ff07dacbe527b522df06d9b6038c5e63f", "filename": "crates/ra_syntax/src/ast/extensions.rs", "status": "modified", "additions": 35, "deletions": 29, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/d402974aa0af6de290245a9d2a69a5d56c4fa610/crates%2Fra_syntax%2Fsrc%2Fast%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d402974aa0af6de290245a9d2a69a5d56c4fa610/crates%2Fra_syntax%2Fsrc%2Fast%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fextensions.rs?ref=d402974aa0af6de290245a9d2a69a5d56c4fa610", "patch": "@@ -4,7 +4,7 @@\n use itertools::Itertools;\n \n use crate::{\n-    ast::{self, child_opt, children, AstNode},\n+    ast::{self, child_opt, children, AstNode, SyntaxNode},\n     SmolStr, SyntaxElement,\n     SyntaxKind::*,\n     SyntaxToken, T,\n@@ -13,15 +13,20 @@ use ra_parser::SyntaxKind;\n \n impl ast::Name {\n     pub fn text(&self) -> &SmolStr {\n-        let ident = self.syntax().first_child_or_token().unwrap().as_token().unwrap();\n-        ident.text()\n+        text_of_first_token(self.syntax())\n     }\n }\n \n impl ast::NameRef {\n     pub fn text(&self) -> &SmolStr {\n-        let ident = self.syntax().first_child_or_token().unwrap().as_token().unwrap();\n-        ident.text()\n+        text_of_first_token(self.syntax())\n+    }\n+}\n+\n+fn text_of_first_token(node: &SyntaxNode) -> &SmolStr {\n+    match node.0.green().children().first() {\n+        Some(rowan::GreenElement::Token(it)) => it.text(),\n+        _ => panic!(),\n     }\n }\n \n@@ -50,10 +55,10 @@ impl ast::Attr {\n         }\n     }\n \n-    pub fn as_call(&self) -> Option<(SmolStr, &ast::TokenTree)> {\n+    pub fn as_call(&self) -> Option<(SmolStr, ast::TokenTree)> {\n         let tt = self.value()?;\n         let (_bra, attr, args, _ket) = tt.syntax().children_with_tokens().collect_tuple()?;\n-        let args = ast::TokenTree::cast(args.as_node()?)?;\n+        let args = ast::TokenTree::cast(args.as_node()?.clone())?;\n         if attr.kind() == IDENT {\n             Some((attr.as_token()?.text().clone(), args))\n         } else {\n@@ -86,16 +91,16 @@ impl ast::Attr {\n     }\n }\n \n-#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n-pub enum PathSegmentKind<'a> {\n-    Name(&'a ast::NameRef),\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub enum PathSegmentKind {\n+    Name(ast::NameRef),\n     SelfKw,\n     SuperKw,\n     CrateKw,\n }\n \n impl ast::PathSegment {\n-    pub fn parent_path(&self) -> &ast::Path {\n+    pub fn parent_path(&self) -> ast::Path {\n         self.syntax()\n             .parent()\n             .and_then(ast::Path::cast)\n@@ -125,7 +130,7 @@ impl ast::PathSegment {\n }\n \n impl ast::Path {\n-    pub fn parent_path(&self) -> Option<&ast::Path> {\n+    pub fn parent_path(&self) -> Option<ast::Path> {\n         self.syntax().parent().and_then(ast::Path::cast)\n     }\n }\n@@ -146,7 +151,7 @@ impl ast::UseTree {\n }\n \n impl ast::UseTreeList {\n-    pub fn parent_use_tree(&self) -> &ast::UseTree {\n+    pub fn parent_use_tree(&self) -> ast::UseTree {\n         self.syntax()\n             .parent()\n             .and_then(ast::UseTree::cast)\n@@ -155,21 +160,21 @@ impl ast::UseTreeList {\n }\n \n impl ast::ImplBlock {\n-    pub fn target_type(&self) -> Option<&ast::TypeRef> {\n+    pub fn target_type(&self) -> Option<ast::TypeRef> {\n         match self.target() {\n             (Some(t), None) | (_, Some(t)) => Some(t),\n             _ => None,\n         }\n     }\n \n-    pub fn target_trait(&self) -> Option<&ast::TypeRef> {\n+    pub fn target_trait(&self) -> Option<ast::TypeRef> {\n         match self.target() {\n             (Some(t), Some(_)) => Some(t),\n             _ => None,\n         }\n     }\n \n-    fn target(&self) -> (Option<&ast::TypeRef>, Option<&ast::TypeRef>) {\n+    fn target(&self) -> (Option<ast::TypeRef>, Option<ast::TypeRef>) {\n         let mut types = children(self);\n         let first = types.next();\n         let second = types.next();\n@@ -182,13 +187,13 @@ impl ast::ImplBlock {\n }\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n-pub enum StructKind<'a> {\n-    Tuple(&'a ast::PosFieldDefList),\n-    Named(&'a ast::NamedFieldDefList),\n+pub enum StructKind {\n+    Tuple(ast::PosFieldDefList),\n+    Named(ast::NamedFieldDefList),\n     Unit,\n }\n \n-impl StructKind<'_> {\n+impl StructKind {\n     fn from_node<N: AstNode>(node: &N) -> StructKind {\n         if let Some(nfdl) = child_opt::<_, ast::NamedFieldDefList>(node) {\n             StructKind::Named(nfdl)\n@@ -218,7 +223,7 @@ impl ast::StructDef {\n }\n \n impl ast::EnumVariant {\n-    pub fn parent_enum(&self) -> &ast::EnumDef {\n+    pub fn parent_enum(&self) -> ast::EnumDef {\n         self.syntax()\n             .parent()\n             .and_then(|it| it.parent())\n@@ -231,10 +236,10 @@ impl ast::EnumVariant {\n }\n \n impl ast::FnDef {\n-    pub fn semicolon_token(&self) -> Option<SyntaxToken<'_>> {\n+    pub fn semicolon_token(&self) -> Option<SyntaxToken> {\n         self.syntax()\n             .last_child_or_token()\n-            .and_then(|it| it.as_token())\n+            .and_then(|it| it.as_token().cloned())\n             .filter(|it| it.kind() == T![;])\n     }\n }\n@@ -258,9 +263,9 @@ impl ast::ExprStmt {\n }\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n-pub enum FieldKind<'a> {\n-    Name(&'a ast::NameRef),\n-    Index(SyntaxToken<'a>),\n+pub enum FieldKind {\n+    Name(ast::NameRef),\n+    Index(SyntaxToken),\n }\n \n impl ast::FieldExpr {\n@@ -271,6 +276,7 @@ impl ast::FieldExpr {\n             .find(|c| c.kind() == SyntaxKind::INT_NUMBER || c.kind() == SyntaxKind::FLOAT_NUMBER)\n             .as_ref()\n             .and_then(SyntaxElement::as_token)\n+            .cloned()\n     }\n \n     pub fn field_access(&self) -> Option<FieldKind> {\n@@ -326,7 +332,7 @@ impl ast::SelfParam {\n     pub fn self_kw_token(&self) -> SyntaxToken {\n         self.syntax()\n             .children_with_tokens()\n-            .filter_map(|it| it.as_token())\n+            .filter_map(|it| it.as_token().cloned())\n             .find(|it| it.kind() == T![self])\n             .expect(\"invalid tree: self param must have self\")\n     }\n@@ -355,7 +361,7 @@ impl ast::LifetimeParam {\n     pub fn lifetime_token(&self) -> Option<SyntaxToken> {\n         self.syntax()\n             .children_with_tokens()\n-            .filter_map(|it| it.as_token())\n+            .filter_map(|it| it.as_token().cloned())\n             .find(|it| it.kind() == LIFETIME)\n     }\n }\n@@ -364,7 +370,7 @@ impl ast::WherePred {\n     pub fn lifetime_token(&self) -> Option<SyntaxToken> {\n         self.syntax()\n             .children_with_tokens()\n-            .filter_map(|it| it.as_token())\n+            .filter_map(|it| it.as_token().cloned())\n             .find(|it| it.kind() == LIFETIME)\n     }\n }"}, {"sha": "a1f320257892ccebe49acc329977c0077c5f7a59", "filename": "crates/ra_syntax/src/ast/generated.rs", "status": "modified", "additions": 832, "deletions": 1888, "changes": 2720, "blob_url": "https://github.com/rust-lang/rust/blob/d402974aa0af6de290245a9d2a69a5d56c4fa610/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d402974aa0af6de290245a9d2a69a5d56c4fa610/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs?ref=d402974aa0af6de290245a9d2a69a5d56c4fa610"}, {"sha": "f3365c5602ef3d8b28f5829bdb33cbeac8012a11", "filename": "crates/ra_syntax/src/ast/generated.rs.tera", "status": "modified", "additions": 15, "deletions": 36, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/d402974aa0af6de290245a9d2a69a5d56c4fa610/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs.tera", "raw_url": "https://github.com/rust-lang/rust/raw/d402974aa0af6de290245a9d2a69a5d56c4fa610/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs.tera", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs.tera?ref=d402974aa0af6de290245a9d2a69a5d56c4fa610", "patch": "@@ -11,94 +11,73 @@ the below applies to the result of this template\n \n #![cfg_attr(rustfmt, rustfmt_skip)]\n \n-use rowan::TransparentNewType;\n-\n use crate::{\n     SyntaxNode, SyntaxKind::*,\n-    syntax_node::{TreeArc},\n     ast::{self, AstNode},\n };\n {% for node, methods in ast %}\n // {{ node }}\n \n {%- if methods.enum %}\n-#[derive(Debug, PartialEq, Eq, Hash)]\n-#[repr(transparent)]\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct {{ node }} {\n     pub(crate) syntax: SyntaxNode,\n }\n-unsafe impl TransparentNewType for {{ node }} {\n-    type Repr = rowan::SyntaxNode;\n-}\n \n-#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n-pub enum {{ node }}Kind<'a> {\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub enum {{ node }}Kind {\n {%- for kind in methods.enum %}\n-    {{ kind }}(&'a {{ kind }}),\n+    {{ kind }}({{ kind }}),\n {%- endfor %}\n }\n \n {%- for kind in methods.enum %}\n-impl<'a> From<&'a {{ kind }}> for &'a {{ node }} {\n-    fn from(n: &'a {{ kind }}) -> &'a {{ node }} {\n-        {{ node }}::cast(&n.syntax).unwrap()\n+impl From<{{ kind }}> for {{ node }} {\n+    fn from(n: {{ kind }}) -> {{ node }} {\n+        {{ node }}::cast(n.syntax).unwrap()\n     }\n }\n {%- endfor %}\n \n \n impl AstNode for {{ node }} {\n-    fn cast(syntax: &SyntaxNode) -> Option<&Self> {\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n         match syntax.kind() {\n             {%- for kind in methods.enum %}\n             | {{ kind | SCREAM }}\n-            {%- endfor %} => Some({{ node }}::from_repr(syntax.into_repr())),\n+            {%- endfor %} => Some({{ node }} { syntax }),\n             _ => None,\n         }\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n-impl ToOwned for {{ node }} {\n-    type Owned = TreeArc<{{ node }}>;\n-    fn to_owned(&self) -> TreeArc<{{ node }}> { TreeArc::cast(self.syntax.to_owned()) }\n-}\n-\n impl {{ node }} {\n     pub fn kind(&self) -> {{ node }}Kind {\n         match self.syntax.kind() {\n             {%- for kind in methods.enum %}\n-            {{ kind | SCREAM }} => {{ node }}Kind::{{ kind }}({{ kind }}::cast(&self.syntax).unwrap()),\n+            {{ kind | SCREAM }} => {{ node }}Kind::{{ kind }}({{ kind }}::cast(self.syntax.clone()).unwrap()),\n             {%- endfor %}\n             _ => unreachable!(),\n         }\n     }\n }\n {% else %}\n-#[derive(Debug, PartialEq, Eq, Hash)]\n-#[repr(transparent)]\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct {{ node }} {\n     pub(crate) syntax: SyntaxNode,\n }\n-unsafe impl TransparentNewType for {{ node }} {\n-    type Repr = rowan::SyntaxNode;\n-}\n \n impl AstNode for {{ node }} {\n-    fn cast(syntax: &SyntaxNode) -> Option<&Self> {\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n         match syntax.kind() {\n-            {{ node | SCREAM }} => Some({{ node }}::from_repr(syntax.into_repr())),\n+            {{ node | SCREAM }} => Some({{ node }} { syntax }),\n             _ => None,\n         }\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n \n-impl ToOwned for {{ node }} {\n-    type Owned = TreeArc<{{ node }}>;\n-    fn to_owned(&self) -> TreeArc<{{ node }}> { TreeArc::cast(self.syntax.to_owned()) }\n-}\n-\n {% endif %}\n {% if methods.traits -%}\n \n@@ -113,7 +92,7 @@ impl {{ node }} {\n {%- for m in methods.collections -%}\n {%- set method_name = m.0 -%}\n {%- set ChildName = m.1 %}\n-    pub fn {{ method_name }}(&self) -> impl Iterator<Item = &{{ ChildName }}> {\n+    pub fn {{ method_name }}(&self) -> impl Iterator<Item = {{ ChildName }}> {\n         super::children(self)\n     }\n {% endfor -%}\n@@ -129,7 +108,7 @@ impl {{ node }} {\n {%- set method_name = m.0 -%}\n {%- set ChildName = m.1 %}\n {%- endif %}\n-    pub fn {{ method_name }}(&self) -> Option<&{{ ChildName }}> {\n+    pub fn {{ method_name }}(&self) -> Option<{{ ChildName }}> {\n         super::child_opt(self)\n     }\n {% endfor -%}"}, {"sha": "87cca325d3fc9dec956abce06e6908167c8d8203", "filename": "crates/ra_syntax/src/ast/tokens.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d402974aa0af6de290245a9d2a69a5d56c4fa610/crates%2Fra_syntax%2Fsrc%2Fast%2Ftokens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d402974aa0af6de290245a9d2a69a5d56c4fa610/crates%2Fra_syntax%2Fsrc%2Fast%2Ftokens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Ftokens.rs?ref=d402974aa0af6de290245a9d2a69a5d56c4fa610", "patch": "@@ -6,23 +6,23 @@ use crate::{\n     SyntaxToken,\n };\n \n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct Comment<'a>(SyntaxToken<'a>);\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Comment(SyntaxToken);\n \n-impl<'a> AstToken<'a> for Comment<'a> {\n-    fn cast(token: SyntaxToken<'a>) -> Option<Self> {\n+impl AstToken for Comment {\n+    fn cast(token: SyntaxToken) -> Option<Self> {\n         if token.kind() == COMMENT {\n             Some(Comment(token))\n         } else {\n             None\n         }\n     }\n-    fn syntax(&self) -> SyntaxToken<'a> {\n-        self.0\n+    fn syntax(&self) -> &SyntaxToken {\n+        &self.0\n     }\n }\n \n-impl<'a> Comment<'a> {\n+impl Comment {\n     pub fn kind(&self) -> CommentKind {\n         kind_by_prefix(self.text())\n     }\n@@ -90,22 +90,22 @@ fn prefix_by_kind(kind: CommentKind) -> &'static str {\n     unreachable!()\n }\n \n-pub struct Whitespace<'a>(SyntaxToken<'a>);\n+pub struct Whitespace(SyntaxToken);\n \n-impl<'a> AstToken<'a> for Whitespace<'a> {\n-    fn cast(token: SyntaxToken<'a>) -> Option<Self> {\n+impl AstToken for Whitespace {\n+    fn cast(token: SyntaxToken) -> Option<Self> {\n         if token.kind() == WHITESPACE {\n             Some(Whitespace(token))\n         } else {\n             None\n         }\n     }\n-    fn syntax(&self) -> SyntaxToken<'a> {\n-        self.0\n+    fn syntax(&self) -> &SyntaxToken {\n+        &self.0\n     }\n }\n \n-impl<'a> Whitespace<'a> {\n+impl Whitespace {\n     pub fn spans_multiple_lines(&self) -> bool {\n         let text = self.text();\n         text.find('\\n').map_or(false, |idx| text[idx + 1..].contains('\\n'))"}, {"sha": "ecbd2d4271db9e26c5648e74ab2d49a54ee77eb6", "filename": "crates/ra_syntax/src/ast/traits.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/d402974aa0af6de290245a9d2a69a5d56c4fa610/crates%2Fra_syntax%2Fsrc%2Fast%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d402974aa0af6de290245a9d2a69a5d56c4fa610/crates%2Fra_syntax%2Fsrc%2Fast%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Ftraits.rs?ref=d402974aa0af6de290245a9d2a69a5d56c4fa610", "patch": "@@ -10,37 +10,37 @@ use crate::{\n };\n \n pub trait TypeAscriptionOwner: AstNode {\n-    fn ascribed_type(&self) -> Option<&ast::TypeRef> {\n+    fn ascribed_type(&self) -> Option<ast::TypeRef> {\n         child_opt(self)\n     }\n }\n \n pub trait NameOwner: AstNode {\n-    fn name(&self) -> Option<&ast::Name> {\n+    fn name(&self) -> Option<ast::Name> {\n         child_opt(self)\n     }\n }\n \n pub trait VisibilityOwner: AstNode {\n-    fn visibility(&self) -> Option<&ast::Visibility> {\n+    fn visibility(&self) -> Option<ast::Visibility> {\n         child_opt(self)\n     }\n }\n \n pub trait LoopBodyOwner: AstNode {\n-    fn loop_body(&self) -> Option<&ast::Block> {\n+    fn loop_body(&self) -> Option<ast::Block> {\n         child_opt(self)\n     }\n }\n \n pub trait TryBlockBodyOwner: AstNode {\n-    fn try_body(&self) -> Option<&ast::Block> {\n+    fn try_body(&self) -> Option<ast::Block> {\n         child_opt(self)\n     }\n }\n \n pub trait ArgListOwner: AstNode {\n-    fn arg_list(&self) -> Option<&ast::ArgList> {\n+    fn arg_list(&self) -> Option<ast::ArgList> {\n         child_opt(self)\n     }\n }\n@@ -51,10 +51,10 @@ pub trait FnDefOwner: AstNode {\n     }\n }\n \n-#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n-pub enum ItemOrMacro<'a> {\n-    Item(&'a ast::ModuleItem),\n-    Macro(&'a ast::MacroCall),\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub enum ItemOrMacro {\n+    Item(ast::ModuleItem),\n+    Macro(ast::MacroCall),\n }\n \n pub trait ModuleItemOwner: AstNode {\n@@ -67,14 +67,14 @@ pub trait ModuleItemOwner: AstNode {\n }\n \n #[derive(Debug)]\n-pub struct ItemOrMacroIter<'a>(SyntaxNodeChildren<'a>);\n+pub struct ItemOrMacroIter(SyntaxNodeChildren);\n \n-impl<'a> Iterator for ItemOrMacroIter<'a> {\n-    type Item = ItemOrMacro<'a>;\n-    fn next(&mut self) -> Option<ItemOrMacro<'a>> {\n+impl Iterator for ItemOrMacroIter {\n+    type Item = ItemOrMacro;\n+    fn next(&mut self) -> Option<ItemOrMacro> {\n         loop {\n             let n = self.0.next()?;\n-            if let Some(item) = ast::ModuleItem::cast(n) {\n+            if let Some(item) = ast::ModuleItem::cast(n.clone()) {\n                 return Some(ItemOrMacro::Item(item));\n             }\n             if let Some(call) = ast::MacroCall::cast(n) {\n@@ -85,17 +85,17 @@ impl<'a> Iterator for ItemOrMacroIter<'a> {\n }\n \n pub trait TypeParamsOwner: AstNode {\n-    fn type_param_list(&self) -> Option<&ast::TypeParamList> {\n+    fn type_param_list(&self) -> Option<ast::TypeParamList> {\n         child_opt(self)\n     }\n \n-    fn where_clause(&self) -> Option<&ast::WhereClause> {\n+    fn where_clause(&self) -> Option<ast::WhereClause> {\n         child_opt(self)\n     }\n }\n \n pub trait TypeBoundsOwner: AstNode {\n-    fn type_bound_list(&self) -> Option<&ast::TypeBoundList> {\n+    fn type_bound_list(&self) -> Option<ast::TypeBoundList> {\n         child_opt(self)\n     }\n }\n@@ -148,19 +148,19 @@ pub trait DocCommentsOwner: AstNode {\n     }\n }\n \n-pub struct CommentIter<'a> {\n-    iter: SyntaxElementChildren<'a>,\n+pub struct CommentIter {\n+    iter: SyntaxElementChildren,\n }\n \n-impl<'a> Iterator for CommentIter<'a> {\n-    type Item = ast::Comment<'a>;\n-    fn next(&mut self) -> Option<ast::Comment<'a>> {\n-        self.iter.by_ref().find_map(|el| el.as_token().and_then(ast::Comment::cast))\n+impl Iterator for CommentIter {\n+    type Item = ast::Comment;\n+    fn next(&mut self) -> Option<ast::Comment> {\n+        self.iter.by_ref().find_map(|el| el.as_token().cloned().and_then(ast::Comment::cast))\n     }\n }\n \n pub trait DefaultTypeParamOwner: AstNode {\n-    fn default_type(&self) -> Option<&ast::PathType> {\n+    fn default_type(&self) -> Option<ast::PathType> {\n         child_opt(self)\n     }\n }"}, {"sha": "716925b2f052ea76a46ab10b5993145fef86160e", "filename": "crates/ra_syntax/src/fuzz.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d402974aa0af6de290245a9d2a69a5d56c4fa610/crates%2Fra_syntax%2Fsrc%2Ffuzz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d402974aa0af6de290245a9d2a69a5d56c4fa610/crates%2Fra_syntax%2Fsrc%2Ffuzz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Ffuzz.rs?ref=d402974aa0af6de290245a9d2a69a5d56c4fa610", "patch": "@@ -9,7 +9,7 @@ fn check_file_invariants(file: &SourceFile) {\n \n pub fn check_parser(text: &str) {\n     let file = SourceFile::parse(text);\n-    check_file_invariants(&file.tree);\n+    check_file_invariants(&file.tree());\n }\n \n #[derive(Debug, Clone)]\n@@ -45,16 +45,16 @@ impl CheckReparse {\n     pub fn run(&self) {\n         let parse = SourceFile::parse(&self.text);\n         let new_parse = parse.reparse(&self.edit);\n-        check_file_invariants(&new_parse.tree);\n-        assert_eq!(&new_parse.tree.syntax().text().to_string(), &self.edited_text);\n+        check_file_invariants(&new_parse.tree());\n+        assert_eq!(&new_parse.tree().syntax().text().to_string(), &self.edited_text);\n         let full_reparse = SourceFile::parse(&self.edited_text);\n         for (a, b) in\n-            new_parse.tree.syntax().descendants().zip(full_reparse.tree.syntax().descendants())\n+            new_parse.tree().syntax().descendants().zip(full_reparse.tree().syntax().descendants())\n         {\n             if (a.kind(), a.range()) != (b.kind(), b.range()) {\n-                eprint!(\"original:\\n{}\", parse.tree.syntax().debug_dump());\n-                eprint!(\"reparsed:\\n{}\", new_parse.tree.syntax().debug_dump());\n-                eprint!(\"full reparse:\\n{}\", full_reparse.tree.syntax().debug_dump());\n+                eprint!(\"original:\\n{}\", parse.tree().syntax().debug_dump());\n+                eprint!(\"reparsed:\\n{}\", new_parse.tree().syntax().debug_dump());\n+                eprint!(\"full reparse:\\n{}\", full_reparse.tree().syntax().debug_dump());\n                 assert_eq!(\n                     format!(\"{:?}\", a),\n                     format!(\"{:?}\", b),"}, {"sha": "ee60c6b8c653dfbd0abd2822c65dad4c501261f8", "filename": "crates/ra_syntax/src/lib.rs", "status": "modified", "additions": 58, "deletions": 64, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/d402974aa0af6de290245a9d2a69a5d56c4fa610/crates%2Fra_syntax%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d402974aa0af6de290245a9d2a69a5d56c4fa610/crates%2Fra_syntax%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Flib.rs?ref=d402974aa0af6de290245a9d2a69a5d56c4fa610", "patch": "@@ -31,7 +31,7 @@ pub mod ast;\n #[doc(hidden)]\n pub mod fuzz;\n \n-use std::{fmt::Write, sync::Arc};\n+use std::{fmt::Write, marker::PhantomData, sync::Arc};\n \n use ra_text_edit::AtomTextEdit;\n \n@@ -43,8 +43,8 @@ pub use crate::{\n     ptr::{AstPtr, SyntaxNodePtr},\n     syntax_error::{Location, SyntaxError, SyntaxErrorKind},\n     syntax_node::{\n-        Direction, InsertPosition, SyntaxElement, SyntaxNode, SyntaxNodeWrapper, SyntaxToken,\n-        SyntaxTreeBuilder, TreeArc, WalkEvent,\n+        Direction, InsertPosition, SyntaxElement, SyntaxNode, SyntaxToken, SyntaxTreeBuilder,\n+        WalkEvent,\n     },\n     syntax_text::SyntaxText,\n };\n@@ -58,48 +58,63 @@ pub use rowan::{SmolStr, TextRange, TextUnit};\n /// Note that we always produce a syntax tree, even for completely invalid\n /// files.\n #[derive(Debug, PartialEq, Eq)]\n-pub struct Parse<T: SyntaxNodeWrapper> {\n-    tree: TreeArc<T>,\n+pub struct Parse<T> {\n+    green: GreenNode,\n     errors: Arc<Vec<SyntaxError>>,\n+    _ty: PhantomData<fn() -> T>,\n }\n \n-impl<T: SyntaxNodeWrapper> Clone for Parse<T> {\n+impl<T> Clone for Parse<T> {\n     fn clone(&self) -> Parse<T> {\n-        Parse { tree: self.tree.clone(), errors: self.errors.clone() }\n+        Parse { green: self.green.clone(), errors: self.errors.clone(), _ty: PhantomData }\n     }\n }\n \n-impl<T: SyntaxNodeWrapper> Parse<T> {\n-    fn new(tree: TreeArc<T>, errors: Vec<SyntaxError>) -> Parse<T> {\n-        Parse { tree, errors: Arc::new(errors) }\n+impl<T> Parse<T> {\n+    fn new(green: GreenNode, errors: Vec<SyntaxError>) -> Parse<T> {\n+        Parse { green, errors: Arc::new(errors), _ty: PhantomData }\n     }\n \n-    pub fn tree(&self) -> &T {\n-        &*self.tree\n+    fn syntax_node(&self) -> SyntaxNode {\n+        SyntaxNode::new(self.green.clone())\n+    }\n+}\n+\n+impl<T: AstNode> Parse<T> {\n+    pub fn to_syntax(self) -> Parse<SyntaxNode> {\n+        Parse { green: self.green, errors: self.errors, _ty: PhantomData }\n+    }\n+\n+    pub fn tree(&self) -> T {\n+        T::cast(self.syntax_node()).unwrap()\n     }\n \n     pub fn errors(&self) -> &[SyntaxError] {\n         &*self.errors\n     }\n \n-    pub fn ok(self) -> Result<TreeArc<T>, Arc<Vec<SyntaxError>>> {\n+    pub fn ok(self) -> Result<T, Arc<Vec<SyntaxError>>> {\n         if self.errors.is_empty() {\n-            Ok(self.tree)\n+            Ok(self.tree())\n         } else {\n             Err(self.errors)\n         }\n     }\n }\n \n-impl<T: AstNode> Parse<T> {\n-    pub fn to_syntax(this: Self) -> Parse<SyntaxNode> {\n-        Parse { tree: this.tree().syntax().to_owned(), errors: this.errors }\n+impl Parse<SyntaxNode> {\n+    pub fn cast<N: AstNode>(self) -> Option<Parse<N>> {\n+        if N::cast(self.syntax_node()).is_some() {\n+            Some(Parse { green: self.green, errors: self.errors, _ty: PhantomData })\n+        } else {\n+            None\n+        }\n     }\n }\n \n impl Parse<SourceFile> {\n     pub fn debug_dump(&self) -> String {\n-        let mut buf = self.tree.syntax().debug_dump();\n+        let mut buf = self.tree().syntax().debug_dump();\n         for err in self.errors.iter() {\n             writeln!(buf, \"error {:?}: {}\", err.location(), err.kind()).unwrap();\n         }\n@@ -112,45 +127,38 @@ impl Parse<SourceFile> {\n \n     fn incremental_reparse(&self, edit: &AtomTextEdit) -> Option<Parse<SourceFile>> {\n         // FIXME: validation errors are not handled here\n-        parsing::incremental_reparse(self.tree.syntax(), edit, self.errors.to_vec()).map(\n+        parsing::incremental_reparse(self.tree().syntax(), edit, self.errors.to_vec()).map(\n             |(green_node, errors, _reparsed_range)| Parse {\n-                tree: SourceFile::new(green_node),\n+                green: green_node,\n                 errors: Arc::new(errors),\n+                _ty: PhantomData,\n             },\n         )\n     }\n \n     fn full_reparse(&self, edit: &AtomTextEdit) -> Parse<SourceFile> {\n-        let text = edit.apply(self.tree.syntax().text().to_string());\n+        let text = edit.apply(self.tree().syntax().text().to_string());\n         SourceFile::parse(&text)\n     }\n }\n \n-impl Parse<SyntaxNode> {\n-    pub fn cast<T: AstNode>(self) -> Option<Parse<T>> {\n-        let node = T::cast(&self.tree)?;\n-        Some(Parse { tree: node.to_owned(), errors: self.errors })\n-    }\n-}\n-\n /// `SourceFile` represents a parse tree for a single Rust file.\n pub use crate::ast::SourceFile;\n \n impl SourceFile {\n-    fn new(green: GreenNode) -> TreeArc<SourceFile> {\n+    fn new(green: GreenNode) -> SourceFile {\n         let root = SyntaxNode::new(green);\n         if cfg!(debug_assertions) {\n             validation::validate_block_structure(&root);\n         }\n         assert_eq!(root.kind(), SyntaxKind::SOURCE_FILE);\n-        TreeArc::cast(root)\n+        SourceFile::cast(root).unwrap()\n     }\n \n     pub fn parse(text: &str) -> Parse<SourceFile> {\n         let (green, mut errors) = parsing::parse_text(text);\n-        let tree = SourceFile::new(green);\n-        errors.extend(validation::validate(&tree));\n-        Parse { tree, errors: Arc::new(errors) }\n+        errors.extend(validation::validate(&SourceFile::new(green.clone())));\n+        Parse { green, errors: Arc::new(errors), _ty: PhantomData }\n     }\n }\n \n@@ -170,46 +178,41 @@ fn api_walkthrough() {\n     // The `parse` method returns a `Parse` -- a pair of syntax tree and a list\n     // of errors. That is, syntax tree is constructed even in presence of errors.\n     let parse = SourceFile::parse(source_code);\n-    assert!(parse.errors.is_empty());\n+    assert!(parse.errors().is_empty());\n \n-    // Due to the way ownership is set up, owned syntax Nodes always live behind\n-    // a `TreeArc` smart pointer. `TreeArc` is roughly an `std::sync::Arc` which\n-    // points to the whole file instead of an individual node.\n-    let file: TreeArc<SourceFile> = parse.tree;\n+    // The `tree` method returns an owned syntax node of type `SourceFile`.\n+    // Owned nodes are cheap: inside, they are `Rc` handles to the underling data.\n+    let file: SourceFile = parse.tree();\n \n-    // `SourceFile` is the root of the syntax tree. We can iterate file's items:\n+    // `SourceFile` is the root of the syntax tree. We can iterate file's items.\n+    // Let's fetch the `foo` function.\n     let mut func = None;\n     for item in file.items() {\n         match item.kind() {\n             ast::ModuleItemKind::FnDef(f) => func = Some(f),\n             _ => unreachable!(),\n         }\n     }\n-    // The returned items are always references.\n-    let func: &ast::FnDef = func.unwrap();\n-\n-    // All nodes implement `ToOwned` trait, with `Owned = TreeArc<Self>`.\n-    // `to_owned` is a cheap operation: atomic increment.\n-    let _owned_func: TreeArc<ast::FnDef> = func.to_owned();\n+    let func: ast::FnDef = func.unwrap();\n \n     // Each AST node has a bunch of getters for children. All getters return\n     // `Option`s though, to account for incomplete code. Some getters are common\n     // for several kinds of node. In this case, a trait like `ast::NameOwner`\n     // usually exists. By convention, all ast types should be used with `ast::`\n     // qualifier.\n-    let name: Option<&ast::Name> = func.name();\n+    let name: Option<ast::Name> = func.name();\n     let name = name.unwrap();\n     assert_eq!(name.text(), \"foo\");\n \n     // Let's get the `1 + 1` expression!\n-    let block: &ast::Block = func.body().unwrap();\n-    let expr: &ast::Expr = block.expr().unwrap();\n+    let block: ast::Block = func.body().unwrap();\n+    let expr: ast::Expr = block.expr().unwrap();\n \n     // \"Enum\"-like nodes are represented using the \"kind\" pattern. It allows us\n     // to match exhaustively against all flavors of nodes, while maintaining\n     // internal representation flexibility. The drawback is that one can't write\n     // nested matches as one pattern.\n-    let bin_expr: &ast::BinExpr = match expr.kind() {\n+    let bin_expr: ast::BinExpr = match expr.kind() {\n         ast::ExprKind::BinExpr(e) => e,\n         _ => unreachable!(),\n     };\n@@ -219,23 +222,14 @@ fn api_walkthrough() {\n     let expr_syntax: &SyntaxNode = expr.syntax();\n \n     // Note how `expr` and `bin_expr` are in fact the same node underneath:\n-    assert!(std::ptr::eq(expr_syntax, bin_expr.syntax()));\n+    assert!(expr_syntax == bin_expr.syntax());\n \n     // To go from CST to AST, `AstNode::cast` function is used:\n-    let expr = match ast::Expr::cast(expr_syntax) {\n+    let _expr: ast::Expr = match ast::Expr::cast(expr_syntax.clone()) {\n         Some(e) => e,\n         None => unreachable!(),\n     };\n \n-    // Note how expr is also a reference!\n-    let expr: &ast::Expr = expr;\n-\n-    // This is possible because the underlying representation is the same:\n-    assert_eq!(\n-        expr as *const ast::Expr as *const u8,\n-        expr_syntax as *const SyntaxNode as *const u8\n-    );\n-\n     // The two properties each syntax node has is a `SyntaxKind`:\n     assert_eq!(expr_syntax.kind(), SyntaxKind::BIN_EXPR);\n \n@@ -248,7 +242,7 @@ fn api_walkthrough() {\n     assert_eq!(text.to_string(), \"1 + 1\");\n \n     // There's a bunch of traversal methods on `SyntaxNode`:\n-    assert_eq!(expr_syntax.parent(), Some(block.syntax()));\n+    assert_eq!(expr_syntax.parent().as_ref(), Some(block.syntax()));\n     assert_eq!(block.syntax().first_child_or_token().map(|it| it.kind()), Some(T!['{']));\n     assert_eq!(\n         expr_syntax.next_sibling_or_token().map(|it| it.kind()),\n@@ -257,7 +251,7 @@ fn api_walkthrough() {\n \n     // As well as some iterator helpers:\n     let f = expr_syntax.ancestors().find_map(ast::FnDef::cast);\n-    assert_eq!(f, Some(&*func));\n+    assert_eq!(f, Some(func));\n     assert!(expr_syntax.siblings_with_tokens(Direction::Next).any(|it| it.kind() == T!['}']));\n     assert_eq!(\n         expr_syntax.descendants_with_tokens().count(),\n@@ -272,7 +266,7 @@ fn api_walkthrough() {\n     for event in expr_syntax.preorder_with_tokens() {\n         match event {\n             WalkEvent::Enter(node) => {\n-                let text = match node {\n+                let text = match &node {\n                     SyntaxElement::Node(it) => it.text().to_string(),\n                     SyntaxElement::Token(it) => it.text().to_string(),\n                 };\n@@ -319,7 +313,7 @@ fn api_walkthrough() {\n     let mut exprs_visit = Vec::new();\n     for node in file.syntax().descendants() {\n         if let Some(result) =\n-            visitor().visit::<ast::Expr, _>(|expr| expr.syntax().text().to_string()).accept(node)\n+            visitor().visit::<ast::Expr, _>(|expr| expr.syntax().text().to_string()).accept(&node)\n         {\n             exprs_visit.push(result);\n         }"}, {"sha": "b4ad9e0199aea249df1d8aa6fc33a18a1c83564e", "filename": "crates/ra_syntax/src/parsing/reparsing.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d402974aa0af6de290245a9d2a69a5d56c4fa610/crates%2Fra_syntax%2Fsrc%2Fparsing%2Freparsing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d402974aa0af6de290245a9d2a69a5d56c4fa610/crates%2Fra_syntax%2Fsrc%2Fparsing%2Freparsing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fparsing%2Freparsing.rs?ref=d402974aa0af6de290245a9d2a69a5d56c4fa610", "patch": "@@ -41,7 +41,7 @@ fn reparse_token<'node>(\n     root: &'node SyntaxNode,\n     edit: &AtomTextEdit,\n ) -> Option<(GreenNode, TextRange)> {\n-    let token = algo::find_covering_element(root, edit.delete).as_token()?;\n+    let token = algo::find_covering_element(root, edit.delete).as_token()?.clone();\n     match token.kind() {\n         WHITESPACE | COMMENT | IDENT | STRING | RAW_STRING => {\n             if token.kind() == WHITESPACE || token.kind() == COMMENT {\n@@ -51,7 +51,7 @@ fn reparse_token<'node>(\n                 }\n             }\n \n-            let text = get_text_after_edit(token.into(), &edit);\n+            let text = get_text_after_edit(token.clone().into(), &edit);\n             let lex_tokens = tokenize(&text);\n             let lex_token = match lex_tokens[..] {\n                 [lex_token] if lex_token.kind == token.kind() => lex_token,\n@@ -81,7 +81,7 @@ fn reparse_block<'node>(\n     edit: &AtomTextEdit,\n ) -> Option<(GreenNode, Vec<SyntaxError>, TextRange)> {\n     let (node, reparser) = find_reparsable_node(root, edit.delete)?;\n-    let text = get_text_after_edit(node.into(), &edit);\n+    let text = get_text_after_edit(node.clone().into(), &edit);\n     let tokens = tokenize(&text);\n     if !is_balanced(&tokens) {\n         return None;\n@@ -109,7 +109,7 @@ fn is_contextual_kw(text: &str) -> bool {\n     }\n }\n \n-fn find_reparsable_node(node: &SyntaxNode, range: TextRange) -> Option<(&SyntaxNode, Reparser)> {\n+fn find_reparsable_node(node: &SyntaxNode, range: TextRange) -> Option<(SyntaxNode, Reparser)> {\n     let node = algo::find_covering_element(node, range);\n     let mut ancestors = match node {\n         SyntaxElement::Token(it) => it.parent().ancestors(),\n@@ -167,8 +167,6 @@ fn merge_errors(\n \n #[cfg(test)]\n mod tests {\n-    use std::sync::Arc;\n-\n     use test_utils::{assert_eq_text, extract_range};\n \n     use super::*;\n@@ -180,18 +178,18 @@ mod tests {\n         let after = edit.apply(before.clone());\n \n         let fully_reparsed = SourceFile::parse(&after);\n-        let incrementally_reparsed = {\n+        let incrementally_reparsed: Parse<SourceFile> = {\n             let f = SourceFile::parse(&before);\n             let edit = AtomTextEdit { delete: range, insert: replace_with.to_string() };\n             let (green, new_errors, range) =\n-                incremental_reparse(f.tree.syntax(), &edit, f.errors.to_vec()).unwrap();\n+                incremental_reparse(f.tree().syntax(), &edit, f.errors.to_vec()).unwrap();\n             assert_eq!(range.len(), reparsed_len.into(), \"reparsed fragment has wrong length\");\n-            Parse { tree: SourceFile::new(green), errors: Arc::new(new_errors) }\n+            Parse::new(green, new_errors)\n         };\n \n         assert_eq_text!(\n-            &fully_reparsed.tree.syntax().debug_dump(),\n-            &incrementally_reparsed.tree.syntax().debug_dump(),\n+            &fully_reparsed.tree().syntax().debug_dump(),\n+            &incrementally_reparsed.tree().syntax().debug_dump(),\n         );\n     }\n "}, {"sha": "01625607547236ab0ce6a2d19bb83906b1bedd10", "filename": "crates/ra_syntax/src/ptr.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d402974aa0af6de290245a9d2a69a5d56c4fa610/crates%2Fra_syntax%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d402974aa0af6de290245a9d2a69a5d56c4fa610/crates%2Fra_syntax%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fptr.rs?ref=d402974aa0af6de290245a9d2a69a5d56c4fa610", "patch": "@@ -1,6 +1,7 @@\n-use crate::{AstNode, SyntaxKind, SyntaxNode, TextRange};\n use std::{iter::successors, marker::PhantomData};\n \n+use crate::{AstNode, SyntaxKind, SyntaxNode, TextRange};\n+\n /// A pointer to a syntax node inside a file. It can be used to remember a\n /// specific node across reparses of the same file.\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n@@ -14,9 +15,9 @@ impl SyntaxNodePtr {\n         SyntaxNodePtr { range: node.range(), kind: node.kind() }\n     }\n \n-    pub fn to_node(self, root: &SyntaxNode) -> &SyntaxNode {\n+    pub fn to_node(self, root: &SyntaxNode) -> SyntaxNode {\n         assert!(root.parent().is_none());\n-        successors(Some(root), |&node| {\n+        successors(Some(root.clone()), |node| {\n             node.children().find(|it| self.range.is_subrange(&it.range()))\n         })\n         .find(|it| it.range() == self.range && it.kind() == self.kind)\n@@ -51,7 +52,7 @@ impl<N: AstNode> AstPtr<N> {\n         AstPtr { raw: SyntaxNodePtr::new(node.syntax()), _ty: PhantomData }\n     }\n \n-    pub fn to_node(self, root: &SyntaxNode) -> &N {\n+    pub fn to_node(self, root: &SyntaxNode) -> N {\n         let syntax_node = self.raw.to_node(root);\n         N::cast(syntax_node).unwrap()\n     }\n@@ -75,5 +76,5 @@ fn test_local_syntax_ptr() {\n     let field = file.syntax().descendants().find_map(ast::NamedFieldDef::cast).unwrap();\n     let ptr = SyntaxNodePtr::new(field.syntax());\n     let field_syntax = ptr.to_node(file.syntax());\n-    assert_eq!(field.syntax(), &*field_syntax);\n+    assert_eq!(field.syntax(), &field_syntax);\n }"}, {"sha": "cf680e66aabe729d5ceddcce6358c30a4ddb21f4", "filename": "crates/ra_syntax/src/syntax_node.rs", "status": "modified", "additions": 120, "deletions": 211, "changes": 331, "blob_url": "https://github.com/rust-lang/rust/blob/d402974aa0af6de290245a9d2a69a5d56c4fa610/crates%2Fra_syntax%2Fsrc%2Fsyntax_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d402974aa0af6de290245a9d2a69a5d56c4fa610/crates%2Fra_syntax%2Fsrc%2Fsyntax_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fsyntax_node.rs?ref=d402974aa0af6de290245a9d2a69a5d56c4fa610", "patch": "@@ -7,14 +7,13 @@\n //! modules just wraps its API.\n \n use std::{\n-    borrow::Borrow,\n     fmt::{self, Write},\n     iter::successors,\n     ops::RangeInclusive,\n };\n \n use ra_parser::ParseError;\n-use rowan::{GreenNodeBuilder, TransparentNewType};\n+use rowan::GreenNodeBuilder;\n \n use crate::{\n     syntax_error::{SyntaxError, SyntaxErrorKind},\n@@ -33,86 +32,8 @@ pub enum InsertPosition<T> {\n     After(T),\n }\n \n-/// Marker trait for CST and AST nodes\n-pub trait SyntaxNodeWrapper: TransparentNewType<Repr = rowan::SyntaxNode> {}\n-impl<T: TransparentNewType<Repr = rowan::SyntaxNode>> SyntaxNodeWrapper for T {}\n-\n-/// An owning smart pointer for CST or AST node.\n-#[derive(PartialEq, Eq, Hash)]\n-pub struct TreeArc<T: SyntaxNodeWrapper>(pub(crate) rowan::TreeArc<T>);\n-\n-impl<T: SyntaxNodeWrapper> Borrow<T> for TreeArc<T> {\n-    fn borrow(&self) -> &T {\n-        &*self\n-    }\n-}\n-\n-impl<T> TreeArc<T>\n-where\n-    T: SyntaxNodeWrapper,\n-{\n-    pub(crate) fn cast<U>(this: TreeArc<T>) -> TreeArc<U>\n-    where\n-        U: SyntaxNodeWrapper,\n-    {\n-        TreeArc(rowan::TreeArc::cast(this.0))\n-    }\n-}\n-\n-impl<T> std::ops::Deref for TreeArc<T>\n-where\n-    T: SyntaxNodeWrapper,\n-{\n-    type Target = T;\n-    fn deref(&self) -> &T {\n-        self.0.deref()\n-    }\n-}\n-\n-impl<T> PartialEq<T> for TreeArc<T>\n-where\n-    T: SyntaxNodeWrapper,\n-    T: PartialEq<T>,\n-{\n-    fn eq(&self, other: &T) -> bool {\n-        let t: &T = self;\n-        t == other\n-    }\n-}\n-\n-impl<T> Clone for TreeArc<T>\n-where\n-    T: SyntaxNodeWrapper,\n-{\n-    fn clone(&self) -> TreeArc<T> {\n-        TreeArc(self.0.clone())\n-    }\n-}\n-\n-impl<T> fmt::Debug for TreeArc<T>\n-where\n-    T: SyntaxNodeWrapper,\n-    T: fmt::Debug,\n-{\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Debug::fmt(&self.0, fmt)\n-    }\n-}\n-\n-#[derive(PartialEq, Eq, Hash)]\n-#[repr(transparent)]\n-pub struct SyntaxNode(pub(crate) rowan::SyntaxNode);\n-unsafe impl TransparentNewType for SyntaxNode {\n-    type Repr = rowan::SyntaxNode;\n-}\n-\n-impl ToOwned for SyntaxNode {\n-    type Owned = TreeArc<SyntaxNode>;\n-    fn to_owned(&self) -> TreeArc<SyntaxNode> {\n-        let ptr = TreeArc(self.0.to_owned());\n-        TreeArc::cast(ptr)\n-    }\n-}\n+#[derive(PartialEq, Eq, Hash, Clone)]\n+pub struct SyntaxNode(pub(crate) rowan::cursor::SyntaxNode);\n \n impl fmt::Debug for SyntaxNode {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n@@ -133,57 +54,57 @@ pub enum Direction {\n }\n \n impl SyntaxNode {\n-    pub(crate) fn new(green: GreenNode) -> TreeArc<SyntaxNode> {\n-        let ptr = TreeArc(rowan::SyntaxNode::new(green, None));\n-        TreeArc::cast(ptr)\n+    pub(crate) fn new(green: GreenNode) -> SyntaxNode {\n+        let inner = rowan::cursor::SyntaxNode::new_root(green);\n+        SyntaxNode(inner)\n     }\n \n     pub fn kind(&self) -> SyntaxKind {\n         self.0.kind().0.into()\n     }\n \n     pub fn range(&self) -> TextRange {\n-        self.0.range()\n+        self.0.text_range()\n     }\n \n     pub fn text(&self) -> SyntaxText {\n         SyntaxText::new(self)\n     }\n \n-    pub fn parent(&self) -> Option<&SyntaxNode> {\n-        self.0.parent().map(SyntaxNode::from_repr)\n+    pub fn parent(&self) -> Option<SyntaxNode> {\n+        self.0.parent().map(SyntaxNode)\n     }\n \n-    pub fn first_child(&self) -> Option<&SyntaxNode> {\n-        self.0.first_child().map(SyntaxNode::from_repr)\n+    pub fn first_child(&self) -> Option<SyntaxNode> {\n+        self.0.first_child().map(SyntaxNode)\n     }\n \n     pub fn first_child_or_token(&self) -> Option<SyntaxElement> {\n-        self.0.first_child_or_token().map(SyntaxElement::from)\n+        self.0.first_child_or_token().map(SyntaxElement::new)\n     }\n \n-    pub fn last_child(&self) -> Option<&SyntaxNode> {\n-        self.0.last_child().map(SyntaxNode::from_repr)\n+    pub fn last_child(&self) -> Option<SyntaxNode> {\n+        self.0.last_child().map(SyntaxNode)\n     }\n \n     pub fn last_child_or_token(&self) -> Option<SyntaxElement> {\n-        self.0.last_child_or_token().map(SyntaxElement::from)\n+        self.0.last_child_or_token().map(SyntaxElement::new)\n     }\n \n-    pub fn next_sibling(&self) -> Option<&SyntaxNode> {\n-        self.0.next_sibling().map(SyntaxNode::from_repr)\n+    pub fn next_sibling(&self) -> Option<SyntaxNode> {\n+        self.0.next_sibling().map(SyntaxNode)\n     }\n \n     pub fn next_sibling_or_token(&self) -> Option<SyntaxElement> {\n-        self.0.next_sibling_or_token().map(SyntaxElement::from)\n+        self.0.next_sibling_or_token().map(SyntaxElement::new)\n     }\n \n-    pub fn prev_sibling(&self) -> Option<&SyntaxNode> {\n-        self.0.prev_sibling().map(SyntaxNode::from_repr)\n+    pub fn prev_sibling(&self) -> Option<SyntaxNode> {\n+        self.0.prev_sibling().map(SyntaxNode)\n     }\n \n     pub fn prev_sibling_or_token(&self) -> Option<SyntaxElement> {\n-        self.0.prev_sibling_or_token().map(SyntaxElement::from)\n+        self.0.prev_sibling_or_token().map(SyntaxElement::new)\n     }\n \n     pub fn children(&self) -> SyntaxNodeChildren {\n@@ -195,18 +116,18 @@ impl SyntaxNode {\n     }\n \n     pub fn first_token(&self) -> Option<SyntaxToken> {\n-        self.0.first_token().map(SyntaxToken::from)\n+        self.0.first_token().map(SyntaxToken)\n     }\n \n     pub fn last_token(&self) -> Option<SyntaxToken> {\n-        self.0.last_token().map(SyntaxToken::from)\n+        self.0.last_token().map(SyntaxToken)\n     }\n \n-    pub fn ancestors(&self) -> impl Iterator<Item = &SyntaxNode> {\n-        successors(Some(self), |&node| node.parent())\n+    pub fn ancestors(&self) -> impl Iterator<Item = SyntaxNode> {\n+        successors(Some(self.clone()), |node| node.parent())\n     }\n \n-    pub fn descendants(&self) -> impl Iterator<Item = &SyntaxNode> {\n+    pub fn descendants(&self) -> impl Iterator<Item = SyntaxNode> {\n         self.preorder().filter_map(|event| match event {\n             WalkEvent::Enter(node) => Some(node),\n             WalkEvent::Leave(_) => None,\n@@ -220,8 +141,8 @@ impl SyntaxNode {\n         })\n     }\n \n-    pub fn siblings(&self, direction: Direction) -> impl Iterator<Item = &SyntaxNode> {\n-        successors(Some(self), move |&node| match direction {\n+    pub fn siblings(&self, direction: Direction) -> impl Iterator<Item = SyntaxNode> {\n+        successors(Some(self.clone()), move |node| match direction {\n             Direction::Next => node.next_sibling(),\n             Direction::Prev => node.prev_sibling(),\n         })\n@@ -231,29 +152,29 @@ impl SyntaxNode {\n         &self,\n         direction: Direction,\n     ) -> impl Iterator<Item = SyntaxElement> {\n-        let me: SyntaxElement = self.into();\n+        let me: SyntaxElement = self.clone().into();\n         successors(Some(me), move |el| match direction {\n             Direction::Next => el.next_sibling_or_token(),\n             Direction::Prev => el.prev_sibling_or_token(),\n         })\n     }\n \n-    pub fn preorder(&self) -> impl Iterator<Item = WalkEvent<&SyntaxNode>> {\n+    pub fn preorder(&self) -> impl Iterator<Item = WalkEvent<SyntaxNode>> {\n         self.0.preorder().map(|event| match event {\n-            WalkEvent::Enter(n) => WalkEvent::Enter(SyntaxNode::from_repr(n)),\n-            WalkEvent::Leave(n) => WalkEvent::Leave(SyntaxNode::from_repr(n)),\n+            WalkEvent::Enter(n) => WalkEvent::Enter(SyntaxNode(n)),\n+            WalkEvent::Leave(n) => WalkEvent::Leave(SyntaxNode(n)),\n         })\n     }\n \n     pub fn preorder_with_tokens(&self) -> impl Iterator<Item = WalkEvent<SyntaxElement>> {\n         self.0.preorder_with_tokens().map(|event| match event {\n-            WalkEvent::Enter(n) => WalkEvent::Enter(n.into()),\n-            WalkEvent::Leave(n) => WalkEvent::Leave(n.into()),\n+            WalkEvent::Enter(n) => WalkEvent::Enter(SyntaxElement::new(n)),\n+            WalkEvent::Leave(n) => WalkEvent::Leave(SyntaxElement::new(n)),\n         })\n     }\n \n     pub fn memory_size_of_subtree(&self) -> usize {\n-        self.0.memory_size_of_subtree()\n+        0\n     }\n \n     pub fn debug_dump(&self) -> String {\n@@ -290,11 +211,11 @@ impl SyntaxNode {\n     ///\n     /// This is a type-unsafe low-level editing API, if you need to use it,\n     /// prefer to create a type-safe abstraction on top of it instead.\n-    pub fn insert_children<'a>(\n+    pub fn insert_children(\n         &self,\n-        position: InsertPosition<SyntaxElement<'_>>,\n-        to_insert: impl Iterator<Item = SyntaxElement<'a>>,\n-    ) -> TreeArc<SyntaxNode> {\n+        position: InsertPosition<SyntaxElement>,\n+        to_insert: impl Iterator<Item = SyntaxElement>,\n+    ) -> SyntaxNode {\n         let mut delta = TextUnit::default();\n         let to_insert = to_insert.map(|element| {\n             delta += element.text_len();\n@@ -303,7 +224,7 @@ impl SyntaxNode {\n \n         let old_children = self.0.green().children();\n \n-        let new_children = match position {\n+        let new_children = match &position {\n             InsertPosition::First => {\n                 to_insert.chain(old_children.iter().cloned()).collect::<Box<[_]>>()\n             }\n@@ -312,7 +233,7 @@ impl SyntaxNode {\n             }\n             InsertPosition::Before(anchor) | InsertPosition::After(anchor) => {\n                 let take_anchor = if let InsertPosition::After(_) = position { 1 } else { 0 };\n-                let split_at = self.position_of_child(anchor) + take_anchor;\n+                let split_at = self.position_of_child(anchor.clone()) + take_anchor;\n                 let (before, after) = old_children.split_at(split_at);\n                 before\n                     .iter()\n@@ -330,13 +251,13 @@ impl SyntaxNode {\n     ///\n     /// This is a type-unsafe low-level editing API, if you need to use it,\n     /// prefer to create a type-safe abstraction on top of it instead.\n-    pub fn replace_children<'a>(\n+    pub fn replace_children(\n         &self,\n-        to_delete: RangeInclusive<SyntaxElement<'_>>,\n-        to_insert: impl Iterator<Item = SyntaxElement<'a>>,\n-    ) -> TreeArc<SyntaxNode> {\n-        let start = self.position_of_child(*to_delete.start());\n-        let end = self.position_of_child(*to_delete.end());\n+        to_delete: RangeInclusive<SyntaxElement>,\n+        to_insert: impl Iterator<Item = SyntaxElement>,\n+    ) -> SyntaxNode {\n+        let start = self.position_of_child(to_delete.start().clone());\n+        let end = self.position_of_child(to_delete.end().clone());\n         let old_children = self.0.green().children();\n \n         let new_children = old_children[..start]\n@@ -348,7 +269,7 @@ impl SyntaxNode {\n         self.with_children(new_children)\n     }\n \n-    fn with_children(&self, new_children: Box<[rowan::GreenElement]>) -> TreeArc<SyntaxNode> {\n+    fn with_children(&self, new_children: Box<[rowan::GreenElement]>) -> SyntaxNode {\n         let len = new_children.iter().map(|it| it.text_len()).sum::<TextUnit>();\n         let new_node = GreenNode::new(rowan::SyntaxKind(self.kind() as u16), new_children);\n         let new_file_node = self.replace_with(new_node);\n@@ -364,7 +285,7 @@ impl SyntaxNode {\n     fn position_of_child(&self, child: SyntaxElement) -> usize {\n         self.children_with_tokens()\n             .position(|it| it == child)\n-            .expect(\"elemetn is not a child of current element\")\n+            .expect(\"element is not a child of current element\")\n     }\n }\n \n@@ -377,11 +298,11 @@ fn to_green_element(element: SyntaxElement) -> rowan::GreenElement {\n     }\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct SyntaxToken<'a>(pub(crate) rowan::SyntaxToken<'a>);\n+#[derive(Clone, PartialEq, Eq, Hash)]\n+pub struct SyntaxToken(pub(crate) rowan::cursor::SyntaxToken);\n \n //FIXME: always output text\n-impl<'a> fmt::Debug for SyntaxToken<'a> {\n+impl fmt::Debug for SyntaxToken {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         write!(fmt, \"{:?}@{:?}\", self.kind(), self.range())?;\n         if self.text().len() < 25 {\n@@ -398,74 +319,80 @@ impl<'a> fmt::Debug for SyntaxToken<'a> {\n     }\n }\n \n-impl<'a> fmt::Display for SyntaxToken<'a> {\n+impl fmt::Display for SyntaxToken {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         fmt::Display::fmt(self.text(), fmt)\n     }\n }\n \n-impl<'a> From<rowan::SyntaxToken<'a>> for SyntaxToken<'a> {\n-    fn from(t: rowan::SyntaxToken<'a>) -> Self {\n-        SyntaxToken(t)\n-    }\n-}\n-\n-impl<'a> SyntaxToken<'a> {\n+impl SyntaxToken {\n     pub fn kind(&self) -> SyntaxKind {\n         self.0.kind().0.into()\n     }\n \n-    pub fn text(&self) -> &'a SmolStr {\n+    pub fn text(&self) -> &SmolStr {\n         self.0.text()\n     }\n \n     pub fn range(&self) -> TextRange {\n-        self.0.range()\n+        self.0.text_range()\n     }\n \n-    pub fn parent(&self) -> &'a SyntaxNode {\n-        SyntaxNode::from_repr(self.0.parent())\n+    pub fn parent(&self) -> SyntaxNode {\n+        SyntaxNode(self.0.parent())\n     }\n \n-    pub fn next_sibling_or_token(&self) -> Option<SyntaxElement<'a>> {\n-        self.0.next_sibling_or_token().map(SyntaxElement::from)\n+    pub fn next_sibling_or_token(&self) -> Option<SyntaxElement> {\n+        self.0.next_sibling_or_token().map(SyntaxElement::new)\n     }\n \n-    pub fn prev_sibling_or_token(&self) -> Option<SyntaxElement<'a>> {\n-        self.0.prev_sibling_or_token().map(SyntaxElement::from)\n+    pub fn prev_sibling_or_token(&self) -> Option<SyntaxElement> {\n+        self.0.prev_sibling_or_token().map(SyntaxElement::new)\n     }\n \n     pub fn siblings_with_tokens(\n         &self,\n         direction: Direction,\n-    ) -> impl Iterator<Item = SyntaxElement<'a>> {\n-        let me: SyntaxElement = (*self).into();\n+    ) -> impl Iterator<Item = SyntaxElement> {\n+        let me: SyntaxElement = self.clone().into();\n         successors(Some(me), move |el| match direction {\n             Direction::Next => el.next_sibling_or_token(),\n             Direction::Prev => el.prev_sibling_or_token(),\n         })\n     }\n \n-    pub fn next_token(&self) -> Option<SyntaxToken<'a>> {\n-        self.0.next_token().map(SyntaxToken::from)\n+    pub fn next_token(&self) -> Option<SyntaxToken> {\n+        self.0.next_token().map(SyntaxToken)\n     }\n \n-    pub fn prev_token(&self) -> Option<SyntaxToken<'a>> {\n-        self.0.prev_token().map(SyntaxToken::from)\n+    pub fn prev_token(&self) -> Option<SyntaxToken> {\n+        self.0.prev_token().map(SyntaxToken)\n     }\n \n     pub(crate) fn replace_with(&self, new_token: GreenToken) -> GreenNode {\n         self.0.replace_with(new_token)\n     }\n }\n \n-#[derive(Debug, PartialEq, Eq, Hash, Clone, Copy)]\n-pub enum SyntaxElement<'a> {\n-    Node(&'a SyntaxNode),\n-    Token(SyntaxToken<'a>),\n+#[derive(Debug, PartialEq, Eq, Hash, Clone)]\n+pub enum SyntaxElement {\n+    Node(SyntaxNode),\n+    Token(SyntaxToken),\n }\n \n-impl<'a> fmt::Display for SyntaxElement<'a> {\n+impl From<SyntaxNode> for SyntaxElement {\n+    fn from(node: SyntaxNode) -> Self {\n+        SyntaxElement::Node(node)\n+    }\n+}\n+\n+impl From<SyntaxToken> for SyntaxElement {\n+    fn from(token: SyntaxToken) -> Self {\n+        SyntaxElement::Token(token)\n+    }\n+}\n+\n+impl fmt::Display for SyntaxElement {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         match self {\n             SyntaxElement::Node(it) => fmt::Display::fmt(it, fmt),\n@@ -474,107 +401,89 @@ impl<'a> fmt::Display for SyntaxElement<'a> {\n     }\n }\n \n-impl<'a> SyntaxElement<'a> {\n+impl SyntaxElement {\n+    pub(crate) fn new(el: rowan::cursor::SyntaxElement) -> Self {\n+        match el {\n+            rowan::cursor::SyntaxElement::Node(it) => SyntaxElement::Node(SyntaxNode(it)),\n+            rowan::cursor::SyntaxElement::Token(it) => SyntaxElement::Token(SyntaxToken(it)),\n+        }\n+    }\n+\n     pub fn kind(&self) -> SyntaxKind {\n         match self {\n             SyntaxElement::Node(it) => it.kind(),\n             SyntaxElement::Token(it) => it.kind(),\n         }\n     }\n \n-    pub fn as_node(&self) -> Option<&'a SyntaxNode> {\n+    pub fn as_node(&self) -> Option<&SyntaxNode> {\n         match self {\n-            SyntaxElement::Node(node) => Some(*node),\n+            SyntaxElement::Node(node) => Some(node),\n             SyntaxElement::Token(_) => None,\n         }\n     }\n \n-    pub fn as_token(&self) -> Option<SyntaxToken<'a>> {\n+    pub fn as_token(&self) -> Option<&SyntaxToken> {\n         match self {\n             SyntaxElement::Node(_) => None,\n-            SyntaxElement::Token(token) => Some(*token),\n+            SyntaxElement::Token(token) => Some(token),\n         }\n     }\n \n-    pub fn next_sibling_or_token(&self) -> Option<SyntaxElement<'a>> {\n+    pub fn next_sibling_or_token(&self) -> Option<SyntaxElement> {\n         match self {\n             SyntaxElement::Node(it) => it.next_sibling_or_token(),\n             SyntaxElement::Token(it) => it.next_sibling_or_token(),\n         }\n     }\n \n-    pub fn prev_sibling_or_token(&self) -> Option<SyntaxElement<'a>> {\n+    pub fn prev_sibling_or_token(&self) -> Option<SyntaxElement> {\n         match self {\n             SyntaxElement::Node(it) => it.prev_sibling_or_token(),\n             SyntaxElement::Token(it) => it.prev_sibling_or_token(),\n         }\n     }\n \n-    pub fn ancestors(&self) -> impl Iterator<Item = &'a SyntaxNode> {\n+    pub fn ancestors(&self) -> impl Iterator<Item = SyntaxNode> {\n         match self {\n-            SyntaxElement::Node(it) => it,\n+            SyntaxElement::Node(it) => it.clone(),\n             SyntaxElement::Token(it) => it.parent(),\n         }\n         .ancestors()\n     }\n \n-    fn text_len(&self) -> TextUnit {\n+    pub fn range(&self) -> TextRange {\n         match self {\n-            SyntaxElement::Node(node) => node.0.green().text_len(),\n-            SyntaxElement::Token(token) => TextUnit::of_str(token.0.text()),\n-        }\n-    }\n-}\n-\n-impl<'a> From<rowan::SyntaxElement<'a>> for SyntaxElement<'a> {\n-    fn from(el: rowan::SyntaxElement<'a>) -> Self {\n-        match el {\n-            rowan::SyntaxElement::Node(n) => SyntaxElement::Node(SyntaxNode::from_repr(n)),\n-            rowan::SyntaxElement::Token(t) => SyntaxElement::Token(t.into()),\n+            SyntaxElement::Node(it) => it.range(),\n+            SyntaxElement::Token(it) => it.range(),\n         }\n     }\n-}\n-\n-impl<'a> From<&'a SyntaxNode> for SyntaxElement<'a> {\n-    fn from(node: &'a SyntaxNode) -> SyntaxElement<'a> {\n-        SyntaxElement::Node(node)\n-    }\n-}\n-\n-impl<'a> From<SyntaxToken<'a>> for SyntaxElement<'a> {\n-    fn from(token: SyntaxToken<'a>) -> SyntaxElement<'a> {\n-        SyntaxElement::Token(token)\n-    }\n-}\n \n-impl<'a> SyntaxElement<'a> {\n-    pub fn range(&self) -> TextRange {\n+    fn text_len(&self) -> TextUnit {\n         match self {\n-            SyntaxElement::Node(it) => it.range(),\n-            SyntaxElement::Token(it) => it.range(),\n+            SyntaxElement::Node(node) => node.0.green().text_len(),\n+            SyntaxElement::Token(token) => TextUnit::of_str(token.0.text()),\n         }\n     }\n }\n \n-#[derive(Debug)]\n-pub struct SyntaxNodeChildren<'a>(rowan::SyntaxNodeChildren<'a>);\n+#[derive(Clone, Debug)]\n+pub struct SyntaxNodeChildren(rowan::cursor::SyntaxNodeChildren);\n \n-impl<'a> Iterator for SyntaxNodeChildren<'a> {\n-    type Item = &'a SyntaxNode;\n-\n-    fn next(&mut self) -> Option<&'a SyntaxNode> {\n-        self.0.next().map(SyntaxNode::from_repr)\n+impl Iterator for SyntaxNodeChildren {\n+    type Item = SyntaxNode;\n+    fn next(&mut self) -> Option<SyntaxNode> {\n+        self.0.next().map(SyntaxNode)\n     }\n }\n \n-#[derive(Debug)]\n-pub struct SyntaxElementChildren<'a>(rowan::SyntaxElementChildren<'a>);\n-\n-impl<'a> Iterator for SyntaxElementChildren<'a> {\n-    type Item = SyntaxElement<'a>;\n+#[derive(Clone, Debug)]\n+pub struct SyntaxElementChildren(rowan::cursor::SyntaxElementChildren);\n \n-    fn next(&mut self) -> Option<SyntaxElement<'a>> {\n-        self.0.next().map(SyntaxElement::from)\n+impl Iterator for SyntaxElementChildren {\n+    type Item = SyntaxElement;\n+    fn next(&mut self) -> Option<SyntaxElement> {\n+        self.0.next().map(SyntaxElement::new)\n     }\n }\n \n@@ -601,7 +510,7 @@ impl SyntaxTreeBuilder {\n         if cfg!(debug_assertions) {\n             crate::validation::validate_block_structure(&node);\n         }\n-        Parse::new(node, errors)\n+        Parse::new(node.0.green().clone(), errors)\n     }\n \n     pub fn token(&mut self, kind: SyntaxKind, text: SmolStr) {"}, {"sha": "6902a04a24e23289a48189274975448c93748677", "filename": "crates/ra_syntax/src/syntax_text.rs", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/d402974aa0af6de290245a9d2a69a5d56c4fa610/crates%2Fra_syntax%2Fsrc%2Fsyntax_text.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d402974aa0af6de290245a9d2a69a5d56c4fa610/crates%2Fra_syntax%2Fsrc%2Fsyntax_text.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fsyntax_text.rs?ref=d402974aa0af6de290245a9d2a69a5d56c4fa610", "patch": "@@ -16,29 +16,36 @@ impl<'a> SyntaxText<'a> {\n         SyntaxText { node, range: node.range() }\n     }\n \n-    pub fn chunks(&self) -> impl Iterator<Item = &'a str> {\n+    pub fn chunks(&self) -> impl Iterator<Item = SmolStr> {\n         let range = self.range;\n         self.node.descendants_with_tokens().filter_map(move |el| match el {\n             SyntaxElement::Token(t) => {\n                 let text = t.text();\n                 let range = range.intersection(&t.range())?;\n-                let range = range - t.range().start();\n-                Some(&text[range])\n+                let res = if range == t.range() {\n+                    t.text().clone()\n+                } else {\n+                    let range = range - t.range().start();\n+                    text[range].into()\n+                };\n+                Some(res)\n             }\n             SyntaxElement::Node(_) => None,\n         })\n     }\n \n     pub fn push_to(&self, buf: &mut String) {\n-        self.chunks().for_each(|it| buf.push_str(it));\n+        self.chunks().for_each(|it| buf.push_str(it.as_str()));\n     }\n \n     pub fn to_string(&self) -> String {\n-        self.chunks().collect()\n+        let mut buf = String::new();\n+        self.push_to(&mut buf);\n+        buf\n     }\n \n     pub fn to_smol_string(&self) -> SmolStr {\n-        self.chunks().collect()\n+        self.to_string().into()\n     }\n \n     pub fn contains(&self, c: char) -> bool {\n@@ -52,7 +59,7 @@ impl<'a> SyntaxText<'a> {\n                 let pos: TextUnit = (pos as u32).into();\n                 return Some(acc + pos);\n             }\n-            acc += TextUnit::of_str(chunk);\n+            acc += TextUnit::of_str(chunk.as_str());\n         }\n         None\n     }\n@@ -97,7 +104,7 @@ impl<'a> SyntaxText<'a> {\n         let mut start: TextUnit = 0.into();\n         let offset = offset.into();\n         for chunk in self.chunks() {\n-            let end = start + TextUnit::of_str(chunk);\n+            let end = start + TextUnit::of_str(chunk.as_str());\n             if start <= offset && offset < end {\n                 let off: usize = u32::from(offset - start) as usize;\n                 return Some(chunk[off..].chars().next().unwrap());\n@@ -129,7 +136,7 @@ impl From<SyntaxText<'_>> for String {\n impl PartialEq<str> for SyntaxText<'_> {\n     fn eq(&self, mut rhs: &str) -> bool {\n         for chunk in self.chunks() {\n-            if !rhs.starts_with(chunk) {\n+            if !rhs.starts_with(chunk.as_str()) {\n                 return false;\n             }\n             rhs = &rhs[chunk.len()..];"}, {"sha": "7140d10c33305911d38f18953cb08d2da67a2ae5", "filename": "crates/ra_syntax/src/validation.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d402974aa0af6de290245a9d2a69a5d56c4fa610/crates%2Fra_syntax%2Fsrc%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d402974aa0af6de290245a9d2a69a5d56c4fa610/crates%2Fra_syntax%2Fsrc%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fvalidation.rs?ref=d402974aa0af6de290245a9d2a69a5d56c4fa610", "patch": "@@ -19,13 +19,13 @@ pub(crate) fn validate(file: &SourceFile) -> Vec<SyntaxError> {\n             .visit::<ast::Literal, _>(validate_literal)\n             .visit::<ast::Block, _>(block::validate_block_node)\n             .visit::<ast::FieldExpr, _>(field_expr::validate_field_expr_node)\n-            .accept(node);\n+            .accept(&node);\n     }\n     errors\n }\n \n // FIXME: kill duplication\n-fn validate_literal(literal: &ast::Literal, acc: &mut Vec<SyntaxError>) {\n+fn validate_literal(literal: ast::Literal, acc: &mut Vec<SyntaxError>) {\n     let token = literal.token();\n     let text = token.text().as_str();\n     match token.kind() {"}, {"sha": "f5573bd8f00f1dbb80874aaa2e46e953c5a0086e", "filename": "crates/ra_syntax/src/validation/block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d402974aa0af6de290245a9d2a69a5d56c4fa610/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d402974aa0af6de290245a9d2a69a5d56c4fa610/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fblock.rs?ref=d402974aa0af6de290245a9d2a69a5d56c4fa610", "patch": "@@ -5,7 +5,7 @@ use crate::{\n     SyntaxKind::*,\n };\n \n-pub(crate) fn validate_block_node(node: &ast::Block, errors: &mut Vec<SyntaxError>) {\n+pub(crate) fn validate_block_node(node: ast::Block, errors: &mut Vec<SyntaxError>) {\n     if let Some(parent) = node.syntax().parent() {\n         match parent.kind() {\n             FN_DEF => return,"}, {"sha": "0e18bd9ca016bdc62db6c4e8552ca1e153e84d11", "filename": "crates/ra_syntax/src/validation/field_expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d402974aa0af6de290245a9d2a69a5d56c4fa610/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Ffield_expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d402974aa0af6de290245a9d2a69a5d56c4fa610/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Ffield_expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Ffield_expr.rs?ref=d402974aa0af6de290245a9d2a69a5d56c4fa610", "patch": "@@ -4,7 +4,7 @@ use crate::{\n     SyntaxErrorKind::*,\r\n };\r\n \r\n-pub(crate) fn validate_field_expr_node(node: &ast::FieldExpr, errors: &mut Vec<SyntaxError>) {\r\n+pub(crate) fn validate_field_expr_node(node: ast::FieldExpr, errors: &mut Vec<SyntaxError>) {\r\n     if let Some(FieldKind::Index(idx)) = node.field_access() {\r\n         if idx.text().chars().any(|c| c < '0' || c > '9') {\r\n             errors.push(SyntaxError::new(InvalidTupleIndexFormat, idx.range()));\r"}]}