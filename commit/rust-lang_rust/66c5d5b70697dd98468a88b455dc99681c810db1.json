{"sha": "66c5d5b70697dd98468a88b455dc99681c810db1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY2YzVkNWI3MDY5N2RkOTg0NjhhODhiNDU1ZGM5OTY4MWM4MTBkYjE=", "commit": {"author": {"name": "Mark Mansi", "email": "markm@cs.wisc.edu", "date": "2019-12-29T01:35:18Z"}, "committer": {"name": "mark", "email": "markm@cs.wisc.edu", "date": "2020-01-13T01:40:50Z"}, "message": "Privatize the fields of RegionInferenceContext", "tree": {"sha": "3b5dfb3762b11e2d744d1cca454588f356059621", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3b5dfb3762b11e2d744d1cca454588f356059621"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/66c5d5b70697dd98468a88b455dc99681c810db1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/66c5d5b70697dd98468a88b455dc99681c810db1", "html_url": "https://github.com/rust-lang/rust/commit/66c5d5b70697dd98468a88b455dc99681c810db1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/66c5d5b70697dd98468a88b455dc99681c810db1/comments", "author": {"login": "mark-i-m", "id": 8827840, "node_id": "MDQ6VXNlcjg4Mjc4NDA=", "avatar_url": "https://avatars.githubusercontent.com/u/8827840?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mark-i-m", "html_url": "https://github.com/mark-i-m", "followers_url": "https://api.github.com/users/mark-i-m/followers", "following_url": "https://api.github.com/users/mark-i-m/following{/other_user}", "gists_url": "https://api.github.com/users/mark-i-m/gists{/gist_id}", "starred_url": "https://api.github.com/users/mark-i-m/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mark-i-m/subscriptions", "organizations_url": "https://api.github.com/users/mark-i-m/orgs", "repos_url": "https://api.github.com/users/mark-i-m/repos", "events_url": "https://api.github.com/users/mark-i-m/events{/privacy}", "received_events_url": "https://api.github.com/users/mark-i-m/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mark-i-m", "id": 8827840, "node_id": "MDQ6VXNlcjg4Mjc4NDA=", "avatar_url": "https://avatars.githubusercontent.com/u/8827840?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mark-i-m", "html_url": "https://github.com/mark-i-m", "followers_url": "https://api.github.com/users/mark-i-m/followers", "following_url": "https://api.github.com/users/mark-i-m/following{/other_user}", "gists_url": "https://api.github.com/users/mark-i-m/gists{/gist_id}", "starred_url": "https://api.github.com/users/mark-i-m/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mark-i-m/subscriptions", "organizations_url": "https://api.github.com/users/mark-i-m/orgs", "repos_url": "https://api.github.com/users/mark-i-m/repos", "events_url": "https://api.github.com/users/mark-i-m/events{/privacy}", "received_events_url": "https://api.github.com/users/mark-i-m/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "786db7399fa8214aa2412fbeb18033524bfa8b34", "url": "https://api.github.com/repos/rust-lang/rust/commits/786db7399fa8214aa2412fbeb18033524bfa8b34", "html_url": "https://github.com/rust-lang/rust/commit/786db7399fa8214aa2412fbeb18033524bfa8b34"}], "stats": {"total": 109, "additions": 71, "deletions": 38}, "files": [{"sha": "dcba790ad7e4824177c2aa05c8b5e2a9ce141279", "filename": "src/librustc_mir/borrow_check/diagnostics/region_errors.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/66c5d5b70697dd98468a88b455dc99681c810db1/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66c5d5b70697dd98468a88b455dc99681c810db1/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs?ref=66c5d5b70697dd98468a88b455dc99681c810db1", "patch": "@@ -113,18 +113,18 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n     /// one (e.g., this is just some random part of the CFG).\n     pub(super) fn to_error_region(&self, r: RegionVid) -> Option<ty::Region<'tcx>> {\n         self.to_error_region_vid(r)\n-            .and_then(|r| self.nonlexical_regioncx.definitions[r].external_name)\n+            .and_then(|r| self.nonlexical_regioncx.region_definition(r).external_name)\n     }\n \n     /// Returns the `RegionVid` corresponding to the region returned by\n     /// `to_error_region`.\n     pub(super) fn to_error_region_vid(&self, r: RegionVid) -> Option<RegionVid> {\n-        if self.nonlexical_regioncx.universal_regions.is_universal_region(r) {\n+        if self.nonlexical_regioncx.universal_regions().is_universal_region(r) {\n             Some(r)\n         } else {\n-            let r_scc = self.nonlexical_regioncx.constraint_sccs.scc(r);\n             let upper_bound = self.nonlexical_regioncx.universal_upper_bound(r);\n-            if self.nonlexical_regioncx.scc_values.contains(r_scc, upper_bound) {\n+\n+            if self.nonlexical_regioncx.upper_bound_in_region_scc(r, upper_bound) {\n                 self.to_error_region_vid(upper_bound)\n             } else {\n                 None\n@@ -137,7 +137,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         if let Some(ty::ReFree(free_region)) = self.to_error_region(fr) {\n             if let ty::BoundRegion::BrEnv = free_region.bound_region {\n                 if let DefiningTy::Closure(def_id, substs) =\n-                    self.nonlexical_regioncx.universal_regions.defining_ty\n+                    self.nonlexical_regioncx.universal_regions().defining_ty\n                 {\n                     let closure_kind_ty = substs.as_closure().kind_ty(def_id, self.infcx.tcx);\n                     return Some(ty::ClosureKind::FnMut) == closure_kind_ty.to_opt_closure_kind();\n@@ -302,8 +302,8 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         }\n \n         let (fr_is_local, outlived_fr_is_local): (bool, bool) = (\n-            self.nonlexical_regioncx.universal_regions.is_local_free_region(fr),\n-            self.nonlexical_regioncx.universal_regions.is_local_free_region(outlived_fr),\n+            self.nonlexical_regioncx.universal_regions().is_local_free_region(fr),\n+            self.nonlexical_regioncx.universal_regions().is_local_free_region(outlived_fr),\n         );\n \n         debug!(\n@@ -378,7 +378,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         // We should check if the return type of this closure is in fact a closure - in that\n         // case, we can special case the error further.\n         let return_type_is_closure =\n-            self.nonlexical_regioncx.universal_regions.unnormalized_output_ty.is_closure();\n+            self.nonlexical_regioncx.universal_regions().unnormalized_output_ty.is_closure();\n         let message = if return_type_is_closure {\n             \"returns a closure that contains a reference to a captured variable, which then \\\n              escapes the closure body\"\n@@ -445,7 +445,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             errci.outlived_fr,\n         );\n \n-        let escapes_from = match self.nonlexical_regioncx.universal_regions.defining_ty {\n+        let escapes_from = match self.nonlexical_regioncx.universal_regions().defining_ty {\n             DefiningTy::Closure(..) => \"closure\",\n             DefiningTy::Generator(..) => \"generator\",\n             DefiningTy::FnDef(..) => \"function\","}, {"sha": "b6bfa30b4dcdf7e2192b086872f02f7d9ae680ba", "filename": "src/librustc_mir/borrow_check/diagnostics/region_name.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/66c5d5b70697dd98468a88b455dc99681c810db1/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66c5d5b70697dd98468a88b455dc99681c810db1/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs?ref=66c5d5b70697dd98468a88b455dc99681c810db1", "patch": "@@ -191,7 +191,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n     ) -> Option<RegionName> {\n         debug!(\"give_region_a_name(fr={:?}, counter={:?})\", fr, renctx.counter);\n \n-        assert!(self.nonlexical_regioncx.universal_regions.is_universal_region(fr));\n+        assert!(self.nonlexical_regioncx.universal_regions().is_universal_region(fr));\n \n         if let Some(value) = renctx.get(&fr) {\n             return Some(value.clone());\n@@ -277,7 +277,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n                         .hir()\n                         .as_local_hir_id(self.mir_def_id)\n                         .expect(\"non-local mir\");\n-                    let def_ty = self.nonlexical_regioncx.universal_regions.defining_ty;\n+                    let def_ty = self.nonlexical_regioncx.universal_regions().defining_ty;\n \n                     if let DefiningTy::Closure(def_id, substs) = def_ty {\n                         let args_span = if let hir::ExprKind::Closure(_, _, _, span, _) =\n@@ -345,11 +345,11 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n         renctx: &mut RegionErrorNamingCtx,\n     ) -> Option<RegionName> {\n         let implicit_inputs =\n-            self.nonlexical_regioncx.universal_regions.defining_ty.implicit_inputs();\n+            self.nonlexical_regioncx.universal_regions().defining_ty.implicit_inputs();\n         let argument_index =\n             self.nonlexical_regioncx.get_argument_index_for_region(self.infcx.tcx, fr)?;\n \n-        let arg_ty = self.nonlexical_regioncx.universal_regions.unnormalized_input_tys\n+        let arg_ty = self.nonlexical_regioncx.universal_regions().unnormalized_input_tys\n             [implicit_inputs + argument_index];\n         if let Some(region_name) =\n             self.give_name_if_we_can_match_hir_ty_from_argument(fr, arg_ty, argument_index, renctx)\n@@ -684,7 +684,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n     ) -> Option<RegionName> {\n         let tcx = self.infcx.tcx;\n \n-        let return_ty = self.nonlexical_regioncx.universal_regions.unnormalized_output_ty;\n+        let return_ty = self.nonlexical_regioncx.universal_regions().unnormalized_output_ty;\n         debug!(\"give_name_if_anonymous_region_appears_in_output: return_ty = {:?}\", return_ty);\n         if !tcx.any_free_region_meets(&return_ty, |r| r.to_region_vid() == fr) {\n             return None;\n@@ -734,7 +734,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n     ) -> Option<RegionName> {\n         // Note: generators from `async fn` yield `()`, so we don't have to\n         // worry about them here.\n-        let yield_ty = self.nonlexical_regioncx.universal_regions.yield_ty?;\n+        let yield_ty = self.nonlexical_regioncx.universal_regions().yield_ty?;\n         debug!(\"give_name_if_anonymous_region_appears_in_yield_ty: yield_ty = {:?}\", yield_ty,);\n \n         let tcx = self.infcx.tcx;"}, {"sha": "5f3585ce8b119927ce127559f86994da3963d049", "filename": "src/librustc_mir/borrow_check/diagnostics/var_name.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/66c5d5b70697dd98468a88b455dc99681c810db1/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fvar_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66c5d5b70697dd98468a88b455dc99681c810db1/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fvar_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fvar_name.rs?ref=66c5d5b70697dd98468a88b455dc99681c810db1", "patch": "@@ -16,7 +16,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         fr: RegionVid,\n     ) -> Option<(Option<Symbol>, Span)> {\n         debug!(\"get_var_name_and_span_for_region(fr={:?})\", fr);\n-        assert!(self.universal_regions.is_universal_region(fr));\n+        assert!(self.universal_regions().is_universal_region(fr));\n \n         debug!(\"get_var_name_and_span_for_region: attempting upvar\");\n         self.get_upvar_index_for_region(tcx, fr)\n@@ -35,7 +35,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// Search the upvars (if any) to find one that references fr. Return its index.\n     crate fn get_upvar_index_for_region(&self, tcx: TyCtxt<'tcx>, fr: RegionVid) -> Option<usize> {\n         let upvar_index =\n-            self.universal_regions.defining_ty.upvar_tys(tcx).position(|upvar_ty| {\n+            self.universal_regions().defining_ty.upvar_tys(tcx).position(|upvar_ty| {\n                 debug!(\"get_upvar_index_for_region: upvar_ty={:?}\", upvar_ty);\n                 tcx.any_free_region_meets(&upvar_ty, |r| {\n                     let r = r.to_region_vid();\n@@ -44,7 +44,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 })\n             })?;\n \n-        let upvar_ty = self.universal_regions.defining_ty.upvar_tys(tcx).nth(upvar_index);\n+        let upvar_ty = self.universal_regions().defining_ty.upvar_tys(tcx).nth(upvar_index);\n \n         debug!(\n             \"get_upvar_index_for_region: found {:?} in upvar {} which has type {:?}\",\n@@ -85,9 +85,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         tcx: TyCtxt<'tcx>,\n         fr: RegionVid,\n     ) -> Option<usize> {\n-        let implicit_inputs = self.universal_regions.defining_ty.implicit_inputs();\n+        let implicit_inputs = self.universal_regions().defining_ty.implicit_inputs();\n         let argument_index =\n-            self.universal_regions.unnormalized_input_tys.iter().skip(implicit_inputs).position(\n+            self.universal_regions().unnormalized_input_tys.iter().skip(implicit_inputs).position(\n                 |arg_ty| {\n                     debug!(\"get_argument_index_for_region: arg_ty = {:?}\", arg_ty);\n                     tcx.any_free_region_meets(arg_ty, |r| r.to_region_vid() == fr)\n@@ -96,7 +96,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n         debug!(\n             \"get_argument_index_for_region: found {:?} in argument {} which has type {:?}\",\n-            fr, argument_index, self.universal_regions.unnormalized_input_tys[argument_index],\n+            fr,\n+            argument_index,\n+            self.universal_regions().unnormalized_input_tys[argument_index],\n         );\n \n         Some(argument_index)\n@@ -110,7 +112,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         local_names: &IndexVec<Local, Option<Symbol>>,\n         argument_index: usize,\n     ) -> (Option<Symbol>, Span) {\n-        let implicit_inputs = self.universal_regions.defining_ty.implicit_inputs();\n+        let implicit_inputs = self.universal_regions().defining_ty.implicit_inputs();\n         let argument_local = Local::new(implicit_inputs + argument_index + 1);\n         debug!(\"get_argument_name_and_span_for_region: argument_local={:?}\", argument_local);\n "}, {"sha": "359f75cac8376bd3435625fad82f93f03500043e", "filename": "src/librustc_mir/borrow_check/region_infer/mod.rs", "status": "modified", "additions": 47, "deletions": 16, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/66c5d5b70697dd98468a88b455dc99681c810db1/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66c5d5b70697dd98468a88b455dc99681c810db1/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fmod.rs?ref=66c5d5b70697dd98468a88b455dc99681c810db1", "patch": "@@ -44,49 +44,48 @@ pub struct RegionInferenceContext<'tcx> {\n     /// variables are identified by their index (`RegionVid`). The\n     /// definition contains information about where the region came\n     /// from as well as its final inferred value.\n-    pub(in crate::borrow_check) definitions: IndexVec<RegionVid, RegionDefinition<'tcx>>,\n+    definitions: IndexVec<RegionVid, RegionDefinition<'tcx>>,\n \n     /// The liveness constraints added to each region. For most\n     /// regions, these start out empty and steadily grow, though for\n     /// each universally quantified region R they start out containing\n     /// the entire CFG and `end(R)`.\n-    pub(in crate::borrow_check) liveness_constraints: LivenessValues<RegionVid>,\n+    liveness_constraints: LivenessValues<RegionVid>,\n \n     /// The outlives constraints computed by the type-check.\n-    pub(in crate::borrow_check) constraints: Rc<OutlivesConstraintSet>,\n+    constraints: Rc<OutlivesConstraintSet>,\n \n     /// The constraint-set, but in graph form, making it easy to traverse\n     /// the constraints adjacent to a particular region. Used to construct\n     /// the SCC (see `constraint_sccs`) and for error reporting.\n-    pub(in crate::borrow_check) constraint_graph: Rc<NormalConstraintGraph>,\n+    constraint_graph: Rc<NormalConstraintGraph>,\n \n     /// The SCC computed from `constraints` and the constraint\n     /// graph. We have an edge from SCC A to SCC B if `A: B`. Used to\n     /// compute the values of each region.\n-    pub(in crate::borrow_check) constraint_sccs: Rc<Sccs<RegionVid, ConstraintSccIndex>>,\n+    constraint_sccs: Rc<Sccs<RegionVid, ConstraintSccIndex>>,\n \n     /// Reverse of the SCC constraint graph -- i.e., an edge `A -> B`\n     /// exists if `B: A`. Computed lazilly.\n-    pub(in crate::borrow_check) rev_constraint_graph: Option<Rc<VecGraph<ConstraintSccIndex>>>,\n+    rev_constraint_graph: Option<Rc<VecGraph<ConstraintSccIndex>>>,\n \n     /// The \"R0 member of [R1..Rn]\" constraints, indexed by SCC.\n-    pub(in crate::borrow_check) member_constraints:\n-        Rc<MemberConstraintSet<'tcx, ConstraintSccIndex>>,\n+    member_constraints: Rc<MemberConstraintSet<'tcx, ConstraintSccIndex>>,\n \n     /// Records the member constraints that we applied to each scc.\n     /// This is useful for error reporting. Once constraint\n     /// propagation is done, this vector is sorted according to\n     /// `member_region_scc`.\n-    pub(in crate::borrow_check) member_constraints_applied: Vec<AppliedMemberConstraint>,\n+    member_constraints_applied: Vec<AppliedMemberConstraint>,\n \n     /// Map closure bounds to a `Span` that should be used for error reporting.\n-    pub(in crate::borrow_check) closure_bounds_mapping:\n+    closure_bounds_mapping:\n         FxHashMap<Location, FxHashMap<(RegionVid, RegionVid), (ConstraintCategory, Span)>>,\n \n     /// Contains the minimum universe of any variable within the same\n     /// SCC. We will ensure that no SCC contains values that are not\n     /// visible from this index.\n-    pub(in crate::borrow_check) scc_universes: IndexVec<ConstraintSccIndex, ty::UniverseIndex>,\n+    scc_universes: IndexVec<ConstraintSccIndex, ty::UniverseIndex>,\n \n     /// Contains a \"representative\" from each SCC. This will be the\n     /// minimal RegionVid belonging to that universe. It is used as a\n@@ -95,23 +94,23 @@ pub struct RegionInferenceContext<'tcx> {\n     /// of its SCC and be sure that -- if they have the same repr --\n     /// they *must* be equal (though not having the same repr does not\n     /// mean they are unequal).\n-    pub(in crate::borrow_check) scc_representatives: IndexVec<ConstraintSccIndex, ty::RegionVid>,\n+    scc_representatives: IndexVec<ConstraintSccIndex, ty::RegionVid>,\n \n     /// The final inferred values of the region variables; we compute\n     /// one value per SCC. To get the value for any given *region*,\n     /// you first find which scc it is a part of.\n-    pub(in crate::borrow_check) scc_values: RegionValues<ConstraintSccIndex>,\n+    scc_values: RegionValues<ConstraintSccIndex>,\n \n     /// Type constraints that we check after solving.\n-    pub(in crate::borrow_check) type_tests: Vec<TypeTest<'tcx>>,\n+    type_tests: Vec<TypeTest<'tcx>>,\n \n     /// Information about the universally quantified regions in scope\n     /// on this function.\n-    pub(in crate::borrow_check) universal_regions: Rc<UniversalRegions<'tcx>>,\n+    universal_regions: Rc<UniversalRegions<'tcx>>,\n \n     /// Information about how the universally quantified regions in\n     /// scope on this function relate to one another.\n-    pub(in crate::borrow_check) universal_region_relations: Rc<UniversalRegionRelations<'tcx>>,\n+    universal_region_relations: Rc<UniversalRegionRelations<'tcx>>,\n }\n \n /// Each time that `apply_member_constraint` is successful, it appends\n@@ -1840,6 +1839,38 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         .unwrap()\n     }\n \n+    /// Get the region outlived by `longer_fr` and live at `element`.\n+    crate fn region_from_element(&self, longer_fr: RegionVid, element: RegionElement) -> RegionVid {\n+        match element {\n+            RegionElement::Location(l) => self.find_sub_region_live_at(longer_fr, l),\n+            RegionElement::RootUniversalRegion(r) => r,\n+            RegionElement::PlaceholderRegion(error_placeholder) => self\n+                .definitions\n+                .iter_enumerated()\n+                .filter_map(|(r, definition)| match definition.origin {\n+                    NLLRegionVariableOrigin::Placeholder(p) if p == error_placeholder => Some(r),\n+                    _ => None,\n+                })\n+                .next()\n+                .unwrap(),\n+        }\n+    }\n+\n+    /// Get the region definition of `r`.\n+    crate fn region_definition(&self, r: RegionVid) -> &RegionDefinition<'tcx> {\n+        &self.definitions[r]\n+    }\n+\n+    /// Check if the SCC of `r` contains `upper`.\n+    crate fn upper_bound_in_region_scc(&self, r: RegionVid, upper: RegionVid) -> bool {\n+        let r_scc = self.constraint_sccs.scc(r);\n+        self.scc_values.contains(r_scc, upper)\n+    }\n+\n+    crate fn universal_regions(&self) -> Rc<UniversalRegions<'tcx>> {\n+        self.universal_regions.clone()\n+    }\n+\n     /// Tries to find the best constraint to blame for the fact that\n     /// `R: from_region`, where `R` is some region that meets\n     /// `target_test`. This works by following the constraint graph,"}]}