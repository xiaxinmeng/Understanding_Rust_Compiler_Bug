{"sha": "9967dc81fe215e0c24fd451c00620929019f9c35", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk5NjdkYzgxZmUyMTVlMGMyNGZkNDUxYzAwNjIwOTI5MDE5ZjljMzU=", "commit": {"author": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-03-18T23:24:48Z"}, "committer": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-03-19T20:27:08Z"}, "message": "rewrite the tutorial section on boxes", "tree": {"sha": "2518880f91b537c5aa953f501ad98bc65a76a3ea", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2518880f91b537c5aa953f501ad98bc65a76a3ea"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9967dc81fe215e0c24fd451c00620929019f9c35", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9967dc81fe215e0c24fd451c00620929019f9c35", "html_url": "https://github.com/rust-lang/rust/commit/9967dc81fe215e0c24fd451c00620929019f9c35", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9967dc81fe215e0c24fd451c00620929019f9c35/comments", "author": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "committer": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3c84bac9462ae853b32f55fcaca2613a7e392d41", "url": "https://api.github.com/repos/rust-lang/rust/commits/3c84bac9462ae853b32f55fcaca2613a7e392d41", "html_url": "https://github.com/rust-lang/rust/commit/3c84bac9462ae853b32f55fcaca2613a7e392d41"}], "stats": {"total": 290, "additions": 160, "deletions": 130}, "files": [{"sha": "699fc33863a1cfdea8ef909622f39b9f06eb3b73", "filename": "doc/tutorial.md", "status": "modified", "additions": 160, "deletions": 130, "changes": 290, "blob_url": "https://github.com/rust-lang/rust/blob/9967dc81fe215e0c24fd451c00620929019f9c35/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/9967dc81fe215e0c24fd451c00620929019f9c35/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=9967dc81fe215e0c24fd451c00620929019f9c35", "patch": "@@ -853,170 +853,184 @@ as in this example that unpacks the first value from a tuple and returns it.\n fn first((value, _): (int, float)) -> int { value }\n ~~~\n \n-# Boxes and pointers\n-\n-Many modern languages have a so-called \"uniform representation\" for\n-aggregate types like structs and enums, so as to represent these types\n-as pointers to heap memory by default. In contrast, Rust, like C and\n-C++, represents such types directly. Another way to say this is that\n-aggregate data in Rust are *unboxed*. This means that if you `let x =\n-Point { x: 1f, y: 1f };`, you are creating a struct on the stack. If you\n-then copy it into a data structure, you copy the entire struct, not\n-just a pointer.\n-\n-For small structs like `Point`, this is usually more efficient than\n-allocating memory and indirecting through a pointer. But for big structs, or\n-those with mutable fields, it can be useful to have a single copy on\n-the stack or on the heap, and refer to that through a pointer.\n-\n-Whenever memory is allocated on the heap, the program needs a strategy to\n-dispose of the memory when no longer needed. Most languages, such as Java or\n-Python, use *garbage collection* for this, a strategy in which the program\n-periodically searches for allocations that are no longer reachable in order\n-to dispose of them. Other languages, such as C, use *manual memory\n-management*, which relies on the programmer to specify when memory should be\n-reclaimed.\n-\n-Rust is in a different position. It differs from the garbage-collected\n-environments in that allows the programmer to choose the disposal\n-strategy on an object-by-object basis. Not only does this have benefits for\n-performance, but we will later see that this model has benefits for\n-concurrency as well, by making it possible for the Rust compiler to detect\n-data races at compile time. Rust also differs from the manually managed\n-languages in that it is *safe*\u2014it uses a [pointer lifetime\n-analysis][borrow] to ensure that manual memory management cannot cause memory\n-errors at runtime.\n+# Destructors\n \n-[borrow]: tutorial-borrowed-ptr.html\n+C-style resource management requires the programmer to match every allocation\n+with a free, which means manually tracking the responsibility for cleaning up\n+(the owner). Correctness is left to the programmer, and it's easy to get wrong.\n \n-The cornerstone of Rust's memory management is the concept of a *smart\n-pointer*\u2014a pointer type that indicates the lifetime of the object it points\n-to. This solution is familiar to C++ programmers; Rust differs from C++,\n-however, in that a small set of smart pointers are built into the language.\n-The safe pointer types are `@T`, for *managed* boxes allocated on the *local\n-heap*, `~T`, for *uniquely-owned* boxes allocated on the *exchange\n-heap*, and `&T`, for *borrowed* pointers, which may point to any memory, and\n-whose lifetimes are governed by the call stack.\n+The following code demonstrates manual memory management, in order to contrast\n+it with Rust's resource management. Rust enforces safety, so the `unsafe`\n+keyword is used to explicitly wrap the unsafe code. The keyword is a promise to\n+the compiler that unsafety does not leak outside of the unsafe block, and is\n+used to create safe concepts on top of low-level code.\n \n-All pointer types can be dereferenced with the `*` unary operator.\n+~~~~\n+use core::libc::funcs::c95::stdlib::{calloc, free};\n+use core::libc::types::os::arch::c95::size_t;\n \n-> ***Note***: You may also hear managed boxes referred to as 'shared\n-> boxes' or 'shared pointers', and owned boxes as 'unique boxes/pointers'.\n-> Borrowed pointers are sometimes called 'region pointers'. The preferred\n-> terminology is what we present here.\n+fn main() {\n+    unsafe {\n+        let a = calloc(1, int::bytes as size_t);\n \n-## Managed boxes\n+        let d;\n \n-Managed boxes are pointers to heap-allocated, garbage-collected\n-memory. Applying the unary `@` operator to an expression creates a\n-managed box. The resulting box contains the result of the\n-expression. Copying a managed box, as happens during assignment, only\n-copies a pointer, never the contents of the box.\n+        {\n+            let b = calloc(1, int::bytes as size_t);\n+\n+            let c = calloc(1, int::bytes as size_t);\n+            d = c; // move ownership to d\n+\n+            free(b);\n+        }\n \n+        free(d);\n+        free(a);\n+    }\n+}\n ~~~~\n-let x: @int = @10; // New box\n-let y = x; // Copy of a pointer to the same box\n \n-// x and y both refer to the same allocation. When both go out of scope\n-// then the allocation will be freed.\n+Rust uses destructors to handle the release of resources like memory\n+allocations, files and sockets. An object will only be destroyed when there is\n+no longer any way to access it, which prevents dynamic failures from an attempt\n+to use a freed resource. When a task fails, the stack unwinds and the\n+destructors of all objects owned by that task are called.\n+\n+The unsafe code from above can be contained behind a safe API that prevents\n+memory leaks or use-after-free:\n+\n ~~~~\n+use core::libc::funcs::c95::stdlib::{calloc, free};\n+use core::libc::types::common::c95::c_void;\n+use core::libc::types::os::arch::c95::size_t;\n \n-A _managed_ type is either of the form `@T` for some type `T`, or any\n-type that contains managed boxes or other managed types.\n+struct Blob { priv ptr: *c_void }\n \n-~~~\n-// A linked list node\n-struct Node {\n-    next: MaybeNode,\n-    prev: MaybeNode,\n-    payload: int\n+impl Blob {\n+    static fn new() -> Blob {\n+        unsafe { Blob{ptr: calloc(1, int::bytes as size_t)} }\n+    }\n }\n \n-enum MaybeNode {\n-    SomeNode(@mut Node),\n-    NoNode\n+impl Drop for Blob {\n+    fn finalize(&self) {\n+        unsafe { free(self.ptr); }\n+    }\n }\n \n-let node1 = @mut Node { next: NoNode, prev: NoNode, payload: 1 };\n-let node2 = @mut Node { next: NoNode, prev: NoNode, payload: 2 };\n-let node3 = @mut Node { next: NoNode, prev: NoNode, payload: 3 };\n+fn main() {\n+    let a = Blob::new();\n \n-// Link the three list nodes together\n-node1.next = SomeNode(node2);\n-node2.prev = SomeNode(node1);\n-node2.next = SomeNode(node3);\n-node3.prev = SomeNode(node2);\n-~~~\n+    let d;\n \n-Managed boxes never cross task boundaries. This has several benefits for\n-performance:\n+    {\n+        let b = Blob::new();\n \n-* The Rust garbage collector does not need to stop multiple threads in order\n-  to collect garbage.\n+        let c = Blob::new();\n+        d = c; // move ownership to d\n \n-* You can separate your application into \"real-time\" tasks that do not use\n-  the garbage collector and \"non-real-time\" tasks that do, and the real-time\n-  tasks will not be interrupted by the non-real-time tasks.\n+        // b is destroyed here\n+    }\n \n-C++ programmers will recognize `@T` as similar to `std::shared_ptr<T>`.\n+    // d is destroyed here\n+    // a is destroyed here\n+}\n+~~~~\n \n-> ***Note:*** Currently, the Rust compiler generates code to reclaim\n-> managed boxes through reference counting and a cycle collector, but\n-> we will switch to a tracing garbage collector eventually.\n+This pattern is common enough that Rust includes dynamically allocated memory\n+as first-class types (`~` and `@`). Non-memory resources like files are cleaned\n+up with custom destructors.\n \n-## Owned boxes\n+~~~~\n+fn main() {\n+    let a = ~0;\n \n-In contrast with managed boxes, owned boxes have a single owning\n-memory slot and thus two owned boxes may not refer to the same\n-memory. All owned boxes across all tasks are allocated on a single\n-_exchange heap_, where their uniquely-owned nature allows tasks to\n-exchange them efficiently.\n+    let d;\n \n-Because owned boxes are uniquely owned, copying them requires allocating\n-a new owned box and duplicating the contents.\n-Instead, owned boxes are _moved_ by default, transferring ownership,\n-and deinitializing the previously owning variable.\n-Any attempt to access a variable after the value has been moved out\n-will result in a compile error.\n+    {\n+        let b = ~0;\n \n-~~~~\n-let x = ~10;\n-// Move x to y, deinitializing x\n-let y = x;\n-~~~~\n+        let c = ~0;\n+        d = c; // move ownership to d\n \n-If you really want to copy an owned box you must say so explicitly.\n+        // b is destroyed here\n+    }\n \n+    // d is destroyed here\n+    // a is destroyed here\n+}\n ~~~~\n-let x = ~10;\n-let y = copy x;\n \n-let z = *x + *y;\n-fail_unless!(z == 20);\n-~~~~\n+# Ownership\n+\n+Rust formalizes the concept of object ownership to delegate management of an\n+object's lifetime to either a variable or a task-local garbage collector. An\n+object's owner is responsible for managing the lifetime of the object by\n+calling the destructor, and the owner determines whether the object is mutable.\n+\n+Ownership is recursive, so mutability is inherited recursively and a destructor\n+destroys the contained tree of owned objects. Variables are top-level owners\n+and destroy the contained object when they go out of scope. A box managed by\n+the garbage collector starts a new ownership tree, and the destructor is called\n+when it is collected.\n+\n+If an object doesn't contain garbage-collected boxes, it consists of a single\n+ownership tree and is given the `Owned` trait which allows it to be sent\n+between tasks.\n+\n+# Boxes\n+\n+Many modern languages represent values as as pointers to heap memory by\n+default. In contrast, Rust, like C and C++, represents such types directly.\n+Another way to say this is that aggregate data in Rust are *unboxed*. This\n+means that if you `let x = Point { x: 1f, y: 1f };`, you are creating a struct\n+on the stack. If you then copy it into a data structure, you copy the entire\n+struct, not just a pointer.\n+\n+For small structs like `Point`, this is usually more efficient than allocating\n+memory and indirecting through a pointer. But for big structs, or mutable\n+state, it can be useful to have a single copy on the stack or on the heap, and\n+refer to that through a pointer.\n+\n+## Owned boxes\n+\n+An owned box (`~`) is a uniquely owned allocation on the heap. An owned box\n+inherits the mutability and lifetime of the owner as it would if there was no\n+box. The purpose of an owned box is to add a layer of indirection in order to\n+create recursive data structures or cheaply pass around an object larger than a\n+pointer.\n \n-When they do not contain any managed boxes, owned boxes can be sent\n-to other tasks. The sending task will give up ownership of the box\n-and won't be able to access it afterwards. The receiving task will\n-become the sole owner of the box. This prevents *data races*\u2014errors\n-that could otherwise result from multiple tasks working on the same\n-data without synchronization.\n+## Managed boxes\n+\n+A managed box (`@`) is a heap allocation with the lifetime managed by a\n+task-local garbage collector. It will be destroyed at some point after there\n+are no references left to the box, no later than the end of the task. Managed\n+boxes lack an owner, so they start a new ownership tree and don't inherit\n+mutability. They do own the contained object, and mutability is defined by the\n+type of the shared box (`@` or `@mut`). An object containing a managed box is\n+not `Owned`, and can't be sent between tasks.\n+\n+# Move semantics\n \n-When an owned pointer goes out of scope or is overwritten, the object\n-it points to is immediately freed. Effective use of owned boxes can\n-therefore be an efficient alternative to garbage collection.\n+Rust uses a shallow copy for parameter passing, assignment and returning values\n+from functions. A shallow copy is considered a move of ownership if the\n+ownership tree of the copied value includes an owned box or a type with a\n+custom destructor. After a value has been moved, it can no longer be used from\n+the source location and will not be destroyed there.\n \n-C++ programmers will recognize `~T` as similar to `std::unique_ptr<T>`\n-(or `std::auto_ptr<T>` in C++03 and below).\n+~~~~\n+let x = ~5;\n+let y = x.clone(); // y is a newly allocated box\n+let z = x; // no new memory allocated, x can no longer be used\n+~~~~\n \n-## Borrowed pointers\n+# Borrowed pointers\n \n-Rust borrowed pointers are a general purpose reference/pointer type,\n-similar to the C++ reference type, but guaranteed to point to valid\n-memory. In contrast with owned pointers, where the holder of an owned\n-pointer is the owner of the pointed-to memory, borrowed pointers never\n-imply ownership. Pointers may be borrowed from any type, in which case\n-the pointer is guaranteed not to outlive the value it points to.\n+Rust's borrowed pointers are a general purpose reference type. In contrast with\n+owned pointers, where the holder of an owned pointer is the owner of the\n+pointed-to memory, borrowed pointers never imply ownership. A pointer can be\n+borrowed to any object, and the compiler verifies that it cannot outlive the\n+lifetime of the object.\n \n As an example, consider a simple struct type, `Point`:\n \n@@ -1099,7 +1113,23 @@ For a more in-depth explanation of borrowed pointers, read the\n \n [borrowtut]: tutorial-borrowed-ptr.html\n \n-## Dereferencing pointers\n+## Freezing\n+\n+Borrowing an immutable pointer to an object freezes it and prevents mutation.\n+`Owned` objects have freezing enforced statically at compile-time. Mutable\n+managed boxes handle freezing dynamically when any of their contents are\n+borrowed, and the task will fail if an attempt to modify them is made while\n+they are frozen.\n+\n+~~~~\n+let mut x = 5;\n+{\n+    let y = &x; // x is now frozen, it cannot be modified\n+}\n+// x is now unfrozen again\n+~~~~\n+\n+# Dereferencing pointers\n \n Rust uses the unary star operator (`*`) to access the contents of a\n box or pointer, similarly to C."}]}