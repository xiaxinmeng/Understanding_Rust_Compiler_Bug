{"sha": "b50a04827c13af00314eb9869d3cc125b2419971", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI1MGEwNDgyN2MxM2FmMDAzMTRlYjk4NjlkM2NjMTI1YjI0MTk5NzE=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-08-19T11:04:51Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-08-19T11:04:51Z"}, "message": "remove ast::*Kind from hir", "tree": {"sha": "bd4e171b740362e50d3bc64a1edb06abdd59a2fd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bd4e171b740362e50d3bc64a1edb06abdd59a2fd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b50a04827c13af00314eb9869d3cc125b2419971", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b50a04827c13af00314eb9869d3cc125b2419971", "html_url": "https://github.com/rust-lang/rust/commit/b50a04827c13af00314eb9869d3cc125b2419971", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b50a04827c13af00314eb9869d3cc125b2419971/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "39e444d70145cbf61ddfdd202572d9c6a7f2fd3c", "url": "https://api.github.com/repos/rust-lang/rust/commits/39e444d70145cbf61ddfdd202572d9c6a7f2fd3c", "html_url": "https://github.com/rust-lang/rust/commit/39e444d70145cbf61ddfdd202572d9c6a7f2fd3c"}], "stats": {"total": 169, "additions": 86, "deletions": 83}, "files": [{"sha": "328d635d4580f53c7f8964c8b516d622ed86a6e6", "filename": "crates/ra_hir/src/expr.rs", "status": "modified", "additions": 44, "deletions": 46, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/b50a04827c13af00314eb9869d3cc125b2419971/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b50a04827c13af00314eb9869d3cc125b2419971/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr.rs?ref=b50a04827c13af00314eb9869d3cc125b2419971", "patch": "@@ -602,8 +602,8 @@ where\n \n     fn collect_expr(&mut self, expr: ast::Expr) -> ExprId {\n         let syntax_ptr = SyntaxNodePtr::new(expr.syntax());\n-        match expr.kind() {\n-            ast::ExprKind::IfExpr(e) => {\n+        match expr {\n+            ast::Expr::IfExpr(e) => {\n                 let then_branch = self.collect_block_opt(e.then_branch());\n \n                 let else_branch = e.else_branch().map(|b| match b {\n@@ -639,16 +639,16 @@ where\n \n                 self.alloc_expr(Expr::If { condition, then_branch, else_branch }, syntax_ptr)\n             }\n-            ast::ExprKind::TryBlockExpr(e) => {\n+            ast::Expr::TryBlockExpr(e) => {\n                 let body = self.collect_block_opt(e.try_body());\n                 self.alloc_expr(Expr::TryBlock { body }, syntax_ptr)\n             }\n-            ast::ExprKind::BlockExpr(e) => self.collect_block_opt(e.block()),\n-            ast::ExprKind::LoopExpr(e) => {\n+            ast::Expr::BlockExpr(e) => self.collect_block_opt(e.block()),\n+            ast::Expr::LoopExpr(e) => {\n                 let body = self.collect_block_opt(e.loop_body());\n                 self.alloc_expr(Expr::Loop { body }, syntax_ptr)\n             }\n-            ast::ExprKind::WhileExpr(e) => {\n+            ast::Expr::WhileExpr(e) => {\n                 let body = self.collect_block_opt(e.loop_body());\n \n                 let condition = match e.condition() {\n@@ -675,13 +675,13 @@ where\n \n                 self.alloc_expr(Expr::While { condition, body }, syntax_ptr)\n             }\n-            ast::ExprKind::ForExpr(e) => {\n+            ast::Expr::ForExpr(e) => {\n                 let iterable = self.collect_expr_opt(e.iterable());\n                 let pat = self.collect_pat_opt(e.pat());\n                 let body = self.collect_block_opt(e.loop_body());\n                 self.alloc_expr(Expr::For { iterable, pat, body }, syntax_ptr)\n             }\n-            ast::ExprKind::CallExpr(e) => {\n+            ast::Expr::CallExpr(e) => {\n                 let callee = self.collect_expr_opt(e.expr());\n                 let args = if let Some(arg_list) = e.arg_list() {\n                     arg_list.args().map(|e| self.collect_expr(e)).collect()\n@@ -690,7 +690,7 @@ where\n                 };\n                 self.alloc_expr(Expr::Call { callee, args }, syntax_ptr)\n             }\n-            ast::ExprKind::MethodCallExpr(e) => {\n+            ast::Expr::MethodCallExpr(e) => {\n                 let receiver = self.collect_expr_opt(e.expr());\n                 let args = if let Some(arg_list) = e.arg_list() {\n                     arg_list.args().map(|e| self.collect_expr(e)).collect()\n@@ -704,7 +704,7 @@ where\n                     syntax_ptr,\n                 )\n             }\n-            ast::ExprKind::MatchExpr(e) => {\n+            ast::Expr::MatchExpr(e) => {\n                 let expr = self.collect_expr_opt(e.expr());\n                 let arms = if let Some(match_arm_list) = e.match_arm_list() {\n                     match_arm_list\n@@ -723,30 +723,30 @@ where\n                 };\n                 self.alloc_expr(Expr::Match { expr, arms }, syntax_ptr)\n             }\n-            ast::ExprKind::PathExpr(e) => {\n+            ast::Expr::PathExpr(e) => {\n                 let path =\n                     e.path().and_then(Path::from_ast).map(Expr::Path).unwrap_or(Expr::Missing);\n                 self.alloc_expr(path, syntax_ptr)\n             }\n-            ast::ExprKind::ContinueExpr(_e) => {\n+            ast::Expr::ContinueExpr(_e) => {\n                 // FIXME: labels\n                 self.alloc_expr(Expr::Continue, syntax_ptr)\n             }\n-            ast::ExprKind::BreakExpr(e) => {\n+            ast::Expr::BreakExpr(e) => {\n                 let expr = e.expr().map(|e| self.collect_expr(e));\n                 self.alloc_expr(Expr::Break { expr }, syntax_ptr)\n             }\n-            ast::ExprKind::ParenExpr(e) => {\n+            ast::Expr::ParenExpr(e) => {\n                 let inner = self.collect_expr_opt(e.expr());\n                 // make the paren expr point to the inner expression as well\n                 self.source_map.expr_map.insert(syntax_ptr, inner);\n                 inner\n             }\n-            ast::ExprKind::ReturnExpr(e) => {\n+            ast::Expr::ReturnExpr(e) => {\n                 let expr = e.expr().map(|e| self.collect_expr(e));\n                 self.alloc_expr(Expr::Return { expr }, syntax_ptr)\n             }\n-            ast::ExprKind::StructLit(e) => {\n+            ast::Expr::StructLit(e) => {\n                 let path = e.path().and_then(Path::from_ast);\n                 let mut field_ptrs = Vec::new();\n                 let struct_lit = if let Some(nfl) = e.named_field_list() {\n@@ -787,41 +787,41 @@ where\n                 }\n                 res\n             }\n-            ast::ExprKind::FieldExpr(e) => {\n+            ast::Expr::FieldExpr(e) => {\n                 let expr = self.collect_expr_opt(e.expr());\n                 let name = match e.field_access() {\n                     Some(kind) => kind.as_name(),\n                     _ => Name::missing(),\n                 };\n                 self.alloc_expr(Expr::Field { expr, name }, syntax_ptr)\n             }\n-            ast::ExprKind::AwaitExpr(e) => {\n+            ast::Expr::AwaitExpr(e) => {\n                 let expr = self.collect_expr_opt(e.expr());\n                 self.alloc_expr(Expr::Await { expr }, syntax_ptr)\n             }\n-            ast::ExprKind::TryExpr(e) => {\n+            ast::Expr::TryExpr(e) => {\n                 let expr = self.collect_expr_opt(e.expr());\n                 self.alloc_expr(Expr::Try { expr }, syntax_ptr)\n             }\n-            ast::ExprKind::CastExpr(e) => {\n+            ast::Expr::CastExpr(e) => {\n                 let expr = self.collect_expr_opt(e.expr());\n                 let type_ref = TypeRef::from_ast_opt(e.type_ref());\n                 self.alloc_expr(Expr::Cast { expr, type_ref }, syntax_ptr)\n             }\n-            ast::ExprKind::RefExpr(e) => {\n+            ast::Expr::RefExpr(e) => {\n                 let expr = self.collect_expr_opt(e.expr());\n                 let mutability = Mutability::from_mutable(e.is_mut());\n                 self.alloc_expr(Expr::Ref { expr, mutability }, syntax_ptr)\n             }\n-            ast::ExprKind::PrefixExpr(e) => {\n+            ast::Expr::PrefixExpr(e) => {\n                 let expr = self.collect_expr_opt(e.expr());\n                 if let Some(op) = e.op_kind() {\n                     self.alloc_expr(Expr::UnaryOp { expr, op }, syntax_ptr)\n                 } else {\n                     self.alloc_expr(Expr::Missing, syntax_ptr)\n                 }\n             }\n-            ast::ExprKind::LambdaExpr(e) => {\n+            ast::Expr::LambdaExpr(e) => {\n                 let mut args = Vec::new();\n                 let mut arg_types = Vec::new();\n                 if let Some(pl) = e.param_list() {\n@@ -835,18 +835,18 @@ where\n                 let body = self.collect_expr_opt(e.body());\n                 self.alloc_expr(Expr::Lambda { args, arg_types, body }, syntax_ptr)\n             }\n-            ast::ExprKind::BinExpr(e) => {\n+            ast::Expr::BinExpr(e) => {\n                 let lhs = self.collect_expr_opt(e.lhs());\n                 let rhs = self.collect_expr_opt(e.rhs());\n                 let op = e.op_kind().map(BinaryOp::from);\n                 self.alloc_expr(Expr::BinaryOp { lhs, rhs, op }, syntax_ptr)\n             }\n-            ast::ExprKind::TupleExpr(e) => {\n+            ast::Expr::TupleExpr(e) => {\n                 let exprs = e.exprs().map(|expr| self.collect_expr(expr)).collect();\n                 self.alloc_expr(Expr::Tuple { exprs }, syntax_ptr)\n             }\n \n-            ast::ExprKind::ArrayExpr(e) => {\n+            ast::Expr::ArrayExpr(e) => {\n                 let kind = e.kind();\n \n                 match kind {\n@@ -865,7 +865,7 @@ where\n                 }\n             }\n \n-            ast::ExprKind::Literal(e) => {\n+            ast::Expr::Literal(e) => {\n                 let lit = match e.kind() {\n                     LiteralKind::IntNumber { suffix } => {\n                         let known_name = suffix\n@@ -895,16 +895,16 @@ where\n                 };\n                 self.alloc_expr(Expr::Literal(lit), syntax_ptr)\n             }\n-            ast::ExprKind::IndexExpr(e) => {\n+            ast::Expr::IndexExpr(e) => {\n                 let base = self.collect_expr_opt(e.base());\n                 let index = self.collect_expr_opt(e.index());\n                 self.alloc_expr(Expr::Index { base, index }, syntax_ptr)\n             }\n \n             // FIXME implement HIR for these:\n-            ast::ExprKind::Label(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n-            ast::ExprKind::RangeExpr(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n-            ast::ExprKind::MacroCall(e) => {\n+            ast::Expr::Label(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n+            ast::Expr::RangeExpr(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n+            ast::Expr::MacroCall(e) => {\n                 let ast_id = self\n                     .db\n                     .ast_id_map(self.current_file_id)\n@@ -945,16 +945,14 @@ where\n     fn collect_block(&mut self, block: ast::Block) -> ExprId {\n         let statements = block\n             .statements()\n-            .map(|s| match s.kind() {\n-                ast::StmtKind::LetStmt(stmt) => {\n+            .map(|s| match s {\n+                ast::Stmt::LetStmt(stmt) => {\n                     let pat = self.collect_pat_opt(stmt.pat());\n                     let type_ref = stmt.ascribed_type().map(TypeRef::from_ast);\n                     let initializer = stmt.initializer().map(|e| self.collect_expr(e));\n                     Statement::Let { pat, type_ref, initializer }\n                 }\n-                ast::StmtKind::ExprStmt(stmt) => {\n-                    Statement::Expr(self.collect_expr_opt(stmt.expr()))\n-                }\n+                ast::Stmt::ExprStmt(stmt) => Statement::Expr(self.collect_expr_opt(stmt.expr())),\n             })\n             .collect();\n         let tail = block.expr().map(|e| self.collect_expr(e));\n@@ -970,33 +968,33 @@ where\n     }\n \n     fn collect_pat(&mut self, pat: ast::Pat) -> PatId {\n-        let pattern = match pat.kind() {\n-            ast::PatKind::BindPat(bp) => {\n+        let pattern = match &pat {\n+            ast::Pat::BindPat(bp) => {\n                 let name = bp.name().map(|nr| nr.as_name()).unwrap_or_else(Name::missing);\n                 let annotation = BindingAnnotation::new(bp.is_mutable(), bp.is_ref());\n                 let subpat = bp.pat().map(|subpat| self.collect_pat(subpat));\n                 Pat::Bind { name, mode: annotation, subpat }\n             }\n-            ast::PatKind::TupleStructPat(p) => {\n+            ast::Pat::TupleStructPat(p) => {\n                 let path = p.path().and_then(Path::from_ast);\n                 let args = p.args().map(|p| self.collect_pat(p)).collect();\n                 Pat::TupleStruct { path, args }\n             }\n-            ast::PatKind::RefPat(p) => {\n+            ast::Pat::RefPat(p) => {\n                 let pat = self.collect_pat_opt(p.pat());\n                 let mutability = Mutability::from_mutable(p.is_mut());\n                 Pat::Ref { pat, mutability }\n             }\n-            ast::PatKind::PathPat(p) => {\n+            ast::Pat::PathPat(p) => {\n                 let path = p.path().and_then(Path::from_ast);\n                 path.map(Pat::Path).unwrap_or(Pat::Missing)\n             }\n-            ast::PatKind::TuplePat(p) => {\n+            ast::Pat::TuplePat(p) => {\n                 let args = p.args().map(|p| self.collect_pat(p)).collect();\n                 Pat::Tuple(args)\n             }\n-            ast::PatKind::PlaceholderPat(_) => Pat::Wild,\n-            ast::PatKind::StructPat(p) => {\n+            ast::Pat::PlaceholderPat(_) => Pat::Wild,\n+            ast::Pat::StructPat(p) => {\n                 let path = p.path().and_then(Path::from_ast);\n                 let field_pat_list =\n                     p.field_pat_list().expect(\"every struct should have a field list\");\n@@ -1022,8 +1020,8 @@ where\n             }\n \n             // FIXME: implement\n-            ast::PatKind::LiteralPat(_) => Pat::Missing,\n-            ast::PatKind::SlicePat(_) | ast::PatKind::RangePat(_) => Pat::Missing,\n+            ast::Pat::LiteralPat(_) => Pat::Missing,\n+            ast::Pat::SlicePat(_) | ast::Pat::RangePat(_) => Pat::Missing,\n         };\n         let ptr = AstPtr::new(&pat);\n         self.alloc_pat(pattern, Either::A(ptr))"}, {"sha": "e6482180d5cbacd4304829e3971583fd32125511", "filename": "crates/ra_hir/src/generics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b50a04827c13af00314eb9869d3cc125b2419971/crates%2Fra_hir%2Fsrc%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b50a04827c13af00314eb9869d3cc125b2419971/crates%2Fra_hir%2Fsrc%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fgenerics.rs?ref=b50a04827c13af00314eb9869d3cc125b2419971", "patch": "@@ -137,8 +137,8 @@ impl GenericParams {\n     fn add_where_predicate_from_bound(&mut self, bound: ast::TypeBound, type_ref: TypeRef) {\n         let path = bound\n             .type_ref()\n-            .and_then(|tr| match tr.kind() {\n-                ast::TypeRefKind::PathType(path) => path.path(),\n+            .and_then(|tr| match tr {\n+                ast::TypeRef::PathType(path) => path.path(),\n                 _ => None,\n             })\n             .and_then(Path::from_ast);"}, {"sha": "62a41719a424a7d7ee59bfb88663c205ede43d99", "filename": "crates/ra_hir/src/impl_block.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b50a04827c13af00314eb9869d3cc125b2419971/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b50a04827c13af00314eb9869d3cc125b2419971/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs?ref=b50a04827c13af00314eb9869d3cc125b2419971", "patch": "@@ -131,10 +131,10 @@ impl ImplData {\n         let items = if let Some(item_list) = node.item_list() {\n             item_list\n                 .impl_items()\n-                .map(|item_node| match item_node.kind() {\n-                    ast::ImplItemKind::FnDef(it) => Function { id: ctx.to_def(&it) }.into(),\n-                    ast::ImplItemKind::ConstDef(it) => Const { id: ctx.to_def(&it) }.into(),\n-                    ast::ImplItemKind::TypeAliasDef(it) => TypeAlias { id: ctx.to_def(&it) }.into(),\n+                .map(|item_node| match item_node {\n+                    ast::ImplItem::FnDef(it) => Function { id: ctx.to_def(&it) }.into(),\n+                    ast::ImplItem::ConstDef(it) => Const { id: ctx.to_def(&it) }.into(),\n+                    ast::ImplItem::TypeAliasDef(it) => TypeAlias { id: ctx.to_def(&it) }.into(),\n                 })\n                 .collect()\n         } else {"}, {"sha": "2f973359fe02438f190d54d50a0eecfad7cecfae", "filename": "crates/ra_hir/src/nameres/raw.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b50a04827c13af00314eb9869d3cc125b2419971/crates%2Fra_hir%2Fsrc%2Fnameres%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b50a04827c13af00314eb9869d3cc125b2419971/crates%2Fra_hir%2Fsrc%2Fnameres%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Fraw.rs?ref=b50a04827c13af00314eb9869d3cc125b2419971", "patch": "@@ -207,24 +207,24 @@ impl RawItemsCollector {\n     }\n \n     fn add_item(&mut self, current_module: Option<Module>, item: ast::ModuleItem) {\n-        let (kind, name) = match item.kind() {\n-            ast::ModuleItemKind::Module(module) => {\n+        let (kind, name) = match item {\n+            ast::ModuleItem::Module(module) => {\n                 self.add_module(current_module, module);\n                 return;\n             }\n-            ast::ModuleItemKind::UseItem(use_item) => {\n+            ast::ModuleItem::UseItem(use_item) => {\n                 self.add_use_item(current_module, use_item);\n                 return;\n             }\n-            ast::ModuleItemKind::ExternCrateItem(extern_crate) => {\n+            ast::ModuleItem::ExternCrateItem(extern_crate) => {\n                 self.add_extern_crate_item(current_module, extern_crate);\n                 return;\n             }\n-            ast::ModuleItemKind::ImplBlock(_) => {\n+            ast::ModuleItem::ImplBlock(_) => {\n                 // impls don't participate in name resolution\n                 return;\n             }\n-            ast::ModuleItemKind::StructDef(it) => {\n+            ast::ModuleItem::StructDef(it) => {\n                 let id = self.source_ast_id_map.ast_id(&it);\n                 let name = it.name();\n                 if it.is_union() {\n@@ -233,22 +233,22 @@ impl RawItemsCollector {\n                     (DefKind::Struct(id), name)\n                 }\n             }\n-            ast::ModuleItemKind::EnumDef(it) => {\n+            ast::ModuleItem::EnumDef(it) => {\n                 (DefKind::Enum(self.source_ast_id_map.ast_id(&it)), it.name())\n             }\n-            ast::ModuleItemKind::FnDef(it) => {\n+            ast::ModuleItem::FnDef(it) => {\n                 (DefKind::Function(self.source_ast_id_map.ast_id(&it)), it.name())\n             }\n-            ast::ModuleItemKind::TraitDef(it) => {\n+            ast::ModuleItem::TraitDef(it) => {\n                 (DefKind::Trait(self.source_ast_id_map.ast_id(&it)), it.name())\n             }\n-            ast::ModuleItemKind::TypeAliasDef(it) => {\n+            ast::ModuleItem::TypeAliasDef(it) => {\n                 (DefKind::TypeAlias(self.source_ast_id_map.ast_id(&it)), it.name())\n             }\n-            ast::ModuleItemKind::ConstDef(it) => {\n+            ast::ModuleItem::ConstDef(it) => {\n                 (DefKind::Const(self.source_ast_id_map.ast_id(&it)), it.name())\n             }\n-            ast::ModuleItemKind::StaticDef(it) => {\n+            ast::ModuleItem::StaticDef(it) => {\n                 (DefKind::Static(self.source_ast_id_map.ast_id(&it)), it.name())\n             }\n         };"}, {"sha": "6cdd3020afdd441b908bed629179d9f8d6fa61ba", "filename": "crates/ra_hir/src/traits.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b50a04827c13af00314eb9869d3cc125b2419971/crates%2Fra_hir%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b50a04827c13af00314eb9869d3cc125b2419971/crates%2Fra_hir%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ftraits.rs?ref=b50a04827c13af00314eb9869d3cc125b2419971", "patch": "@@ -30,10 +30,10 @@ impl TraitData {\n         let items = if let Some(item_list) = src.ast.item_list() {\n             item_list\n                 .impl_items()\n-                .map(|item_node| match item_node.kind() {\n-                    ast::ImplItemKind::FnDef(it) => Function { id: ctx.to_def(&it) }.into(),\n-                    ast::ImplItemKind::ConstDef(it) => Const { id: ctx.to_def(&it) }.into(),\n-                    ast::ImplItemKind::TypeAliasDef(it) => TypeAlias { id: ctx.to_def(&it) }.into(),\n+                .map(|item_node| match item_node {\n+                    ast::ImplItem::FnDef(it) => Function { id: ctx.to_def(&it) }.into(),\n+                    ast::ImplItem::ConstDef(it) => Const { id: ctx.to_def(&it) }.into(),\n+                    ast::ImplItem::TypeAliasDef(it) => TypeAlias { id: ctx.to_def(&it) }.into(),\n                 })\n                 .collect()\n         } else {"}, {"sha": "b92a0b55acdaaddb6b934ce258b8ea64d015ae5a", "filename": "crates/ra_hir/src/type_ref.rs", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/b50a04827c13af00314eb9869d3cc125b2419971/crates%2Fra_hir%2Fsrc%2Ftype_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b50a04827c13af00314eb9869d3cc125b2419971/crates%2Fra_hir%2Fsrc%2Ftype_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ftype_ref.rs?ref=b50a04827c13af00314eb9869d3cc125b2419971", "patch": "@@ -57,28 +57,33 @@ pub enum TypeRef {\n impl TypeRef {\n     /// Converts an `ast::TypeRef` to a `hir::TypeRef`.\n     pub(crate) fn from_ast(node: ast::TypeRef) -> Self {\n-        use ra_syntax::ast::TypeRefKind::*;\n-        match node.kind() {\n-            ParenType(inner) => TypeRef::from_ast_opt(inner.type_ref()),\n-            TupleType(inner) => TypeRef::Tuple(inner.fields().map(TypeRef::from_ast).collect()),\n-            NeverType(..) => TypeRef::Never,\n-            PathType(inner) => {\n+        match node {\n+            ast::TypeRef::ParenType(inner) => TypeRef::from_ast_opt(inner.type_ref()),\n+            ast::TypeRef::TupleType(inner) => {\n+                TypeRef::Tuple(inner.fields().map(TypeRef::from_ast).collect())\n+            }\n+            ast::TypeRef::NeverType(..) => TypeRef::Never,\n+            ast::TypeRef::PathType(inner) => {\n                 inner.path().and_then(Path::from_ast).map(TypeRef::Path).unwrap_or(TypeRef::Error)\n             }\n-            PointerType(inner) => {\n+            ast::TypeRef::PointerType(inner) => {\n                 let inner_ty = TypeRef::from_ast_opt(inner.type_ref());\n                 let mutability = Mutability::from_mutable(inner.is_mut());\n                 TypeRef::RawPtr(Box::new(inner_ty), mutability)\n             }\n-            ArrayType(inner) => TypeRef::Array(Box::new(TypeRef::from_ast_opt(inner.type_ref()))),\n-            SliceType(inner) => TypeRef::Slice(Box::new(TypeRef::from_ast_opt(inner.type_ref()))),\n-            ReferenceType(inner) => {\n+            ast::TypeRef::ArrayType(inner) => {\n+                TypeRef::Array(Box::new(TypeRef::from_ast_opt(inner.type_ref())))\n+            }\n+            ast::TypeRef::SliceType(inner) => {\n+                TypeRef::Slice(Box::new(TypeRef::from_ast_opt(inner.type_ref())))\n+            }\n+            ast::TypeRef::ReferenceType(inner) => {\n                 let inner_ty = TypeRef::from_ast_opt(inner.type_ref());\n                 let mutability = Mutability::from_mutable(inner.is_mut());\n                 TypeRef::Reference(Box::new(inner_ty), mutability)\n             }\n-            PlaceholderType(_inner) => TypeRef::Placeholder,\n-            FnPointerType(inner) => {\n+            ast::TypeRef::PlaceholderType(_inner) => TypeRef::Placeholder,\n+            ast::TypeRef::FnPointerType(inner) => {\n                 let ret_ty = TypeRef::from_ast_opt(inner.ret_type().and_then(|rt| rt.type_ref()));\n                 let mut params = if let Some(pl) = inner.param_list() {\n                     pl.params().map(|p| p.ascribed_type()).map(TypeRef::from_ast_opt).collect()\n@@ -89,9 +94,9 @@ impl TypeRef {\n                 TypeRef::Fn(params)\n             }\n             // for types are close enough for our purposes to the inner type for now...\n-            ForType(inner) => TypeRef::from_ast_opt(inner.type_ref()),\n-            ImplTraitType(_inner) => TypeRef::Error,\n-            DynTraitType(_inner) => TypeRef::Error,\n+            ast::TypeRef::ForType(inner) => TypeRef::from_ast_opt(inner.type_ref()),\n+            ast::TypeRef::ImplTraitType(_inner) => TypeRef::Error,\n+            ast::TypeRef::DynTraitType(_inner) => TypeRef::Error,\n         }\n     }\n "}]}