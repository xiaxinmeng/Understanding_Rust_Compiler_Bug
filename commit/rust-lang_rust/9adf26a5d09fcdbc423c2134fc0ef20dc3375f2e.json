{"sha": "9adf26a5d09fcdbc423c2134fc0ef20dc3375f2e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlhZGYyNmE1ZDA5ZmNkYmM0MjNjMjEzNGZjMGVmMjBkYzMzNzVmMmU=", "commit": {"author": {"name": "Emerentius", "email": "emerentius@arcor.de", "date": "2018-08-20T11:57:10Z"}, "committer": {"name": "Emerentius", "email": "emerentius@arcor.de", "date": "2018-08-20T16:29:56Z"}, "message": "add option to run all tests\n\nadd --all flag to libtest that runs ignored and not ignored tests", "tree": {"sha": "2dcac946745c116f757c93acbd63f859f0f8fd70", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2dcac946745c116f757c93acbd63f859f0f8fd70"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9adf26a5d09fcdbc423c2134fc0ef20dc3375f2e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9adf26a5d09fcdbc423c2134fc0ef20dc3375f2e", "html_url": "https://github.com/rust-lang/rust/commit/9adf26a5d09fcdbc423c2134fc0ef20dc3375f2e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9adf26a5d09fcdbc423c2134fc0ef20dc3375f2e/comments", "author": {"login": "Emerentius", "id": 9992929, "node_id": "MDQ6VXNlcjk5OTI5Mjk=", "avatar_url": "https://avatars.githubusercontent.com/u/9992929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Emerentius", "html_url": "https://github.com/Emerentius", "followers_url": "https://api.github.com/users/Emerentius/followers", "following_url": "https://api.github.com/users/Emerentius/following{/other_user}", "gists_url": "https://api.github.com/users/Emerentius/gists{/gist_id}", "starred_url": "https://api.github.com/users/Emerentius/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Emerentius/subscriptions", "organizations_url": "https://api.github.com/users/Emerentius/orgs", "repos_url": "https://api.github.com/users/Emerentius/repos", "events_url": "https://api.github.com/users/Emerentius/events{/privacy}", "received_events_url": "https://api.github.com/users/Emerentius/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Emerentius", "id": 9992929, "node_id": "MDQ6VXNlcjk5OTI5Mjk=", "avatar_url": "https://avatars.githubusercontent.com/u/9992929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Emerentius", "html_url": "https://github.com/Emerentius", "followers_url": "https://api.github.com/users/Emerentius/followers", "following_url": "https://api.github.com/users/Emerentius/following{/other_user}", "gists_url": "https://api.github.com/users/Emerentius/gists{/gist_id}", "starred_url": "https://api.github.com/users/Emerentius/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Emerentius/subscriptions", "organizations_url": "https://api.github.com/users/Emerentius/orgs", "repos_url": "https://api.github.com/users/Emerentius/repos", "events_url": "https://api.github.com/users/Emerentius/events{/privacy}", "received_events_url": "https://api.github.com/users/Emerentius/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "435b0abd49f3b0146b7c8710a26411be88d4a844", "url": "https://api.github.com/repos/rust-lang/rust/commits/435b0abd49f3b0146b7c8710a26411be88d4a844", "html_url": "https://github.com/rust-lang/rust/commit/435b0abd49f3b0146b7c8710a26411be88d4a844"}], "stats": {"total": 142, "additions": 96, "deletions": 46}, "files": [{"sha": "71207e8e408d1dfca021b893bcdfe5cc2da900a1", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 96, "deletions": 46, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/9adf26a5d09fcdbc423c2134fc0ef20dc3375f2e/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9adf26a5d09fcdbc423c2134fc0ef20dc3375f2e/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=9adf26a5d09fcdbc423c2134fc0ef20dc3375f2e", "patch": "@@ -80,7 +80,7 @@ const QUIET_MODE_MAX_COLUMN: usize = 100; // insert a '\\n' after 100 tests in qu\n // to be used by rustc to compile tests in libtest\n pub mod test {\n     pub use {assert_test_result, filter_tests, parse_opts, run_test, test_main, test_main_static,\n-             Bencher, DynTestFn, DynTestName, Metric, MetricMap, Options, ShouldPanic,\n+             Bencher, DynTestFn, DynTestName, Metric, MetricMap, Options, RunIgnored, ShouldPanic,\n              StaticBenchFn, StaticTestFn, StaticTestName, TestDesc, TestDescAndFn, TestName,\n              TestOpts, TestResult, TrFailed, TrFailedMsg, TrIgnored, TrOk};\n }\n@@ -348,12 +348,19 @@ pub enum OutputFormat {\n     Json,\n }\n \n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub enum RunIgnored {\n+    Yes,\n+    No,\n+    Only,\n+}\n+\n #[derive(Debug)]\n pub struct TestOpts {\n     pub list: bool,\n     pub filter: Option<String>,\n     pub filter_exact: bool,\n-    pub run_ignored: bool,\n+    pub run_ignored: RunIgnored,\n     pub run_tests: bool,\n     pub bench_benchmarks: bool,\n     pub logfile: Option<PathBuf>,\n@@ -372,7 +379,7 @@ impl TestOpts {\n             list: false,\n             filter: None,\n             filter_exact: false,\n-            run_ignored: false,\n+            run_ignored: RunIgnored::No,\n             run_tests: false,\n             bench_benchmarks: false,\n             logfile: None,\n@@ -391,7 +398,8 @@ pub type OptRes = Result<TestOpts, String>;\n \n fn optgroups() -> getopts::Options {\n     let mut opts = getopts::Options::new();\n-    opts.optflag(\"\", \"ignored\", \"Run ignored tests\")\n+    opts.optflag(\"\", \"all\", \"Run ignored and not ignored tests\")\n+        .optflag(\"\", \"ignored\", \"Run only ignored tests\")\n         .optflag(\"\", \"test\", \"Run tests and not benchmarks\")\n         .optflag(\"\", \"bench\", \"Run benchmarks instead of tests\")\n         .optflag(\"\", \"list\", \"List all tests and benchmarks\")\n@@ -490,8 +498,8 @@ Test Attributes:\n                      contain: #[should_panic(expected = \"foo\")].\n     #[ignore]      - When applied to a function which is already attributed as a\n                      test, then the test runner will ignore these tests during\n-                     normal test runs. Running with --ignored will run these\n-                     tests.\"#,\n+                     normal test runs. Running with --ignored or --all will run\n+                     these tests.\"#,\n         usage = options.usage(&message)\n     );\n }\n@@ -544,7 +552,14 @@ pub fn parse_opts(args: &[String]) -> Option<OptRes> {\n         None\n     };\n \n-    let run_ignored = matches.opt_present(\"ignored\");\n+    let run_ignored = match (matches.opt_present(\"all\"), matches.opt_present(\"ignored\")) {\n+        (true, true) => return Some(Err(\n+            \"the options --all and --ignored are mutually exclusive\".into()\n+        )),\n+        (true, false) => RunIgnored::Yes,\n+        (false, true) => RunIgnored::Only,\n+        (false, false) => RunIgnored::No,\n+    };\n     let quiet = matches.opt_present(\"quiet\");\n     let exact = matches.opt_present(\"exact\");\n     let list = matches.opt_present(\"list\");\n@@ -1315,16 +1330,17 @@ pub fn filter_tests(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> Vec<TestDescA\n         !opts.skip.iter().any(|sf| matches_filter(test, sf))\n     });\n \n-    // Maybe pull out the ignored test and unignore them\n-    if opts.run_ignored {\n-        filtered = filtered.into_iter()\n-            .filter(|test| test.desc.ignore)\n-            .map(|mut test| {\n-                test.desc.ignore = false;\n-                test\n-            })\n-            .collect();\n-    };\n+    // maybe unignore tests\n+    match opts.run_ignored {\n+        RunIgnored::Yes => {\n+            filtered.iter_mut().for_each(|test| test.desc.ignore = false);\n+        },\n+        RunIgnored::Only => {\n+            filtered.retain(|test| test.desc.ignore);\n+            filtered.iter_mut().for_each(|test| test.desc.ignore = false);\n+        }\n+        RunIgnored::No => {}\n+    }\n \n     // Sort the tests alphabetically\n     filtered.sort_by(|t1, t2| t1.desc.name.as_slice().cmp(t2.desc.name.as_slice()));\n@@ -1713,13 +1729,37 @@ pub mod bench {\n \n #[cfg(test)]\n mod tests {\n-    use test::{filter_tests, parse_opts, run_test, DynTestFn, DynTestName, MetricMap, ShouldPanic,\n-               StaticTestName, TestDesc, TestDescAndFn, TestOpts, TrFailed, TrFailedMsg,\n-               TrIgnored, TrOk};\n+    use test::{filter_tests, parse_opts, run_test, DynTestFn, DynTestName, MetricMap, RunIgnored,\n+               ShouldPanic, StaticTestName, TestDesc, TestDescAndFn, TestOpts, TrFailed,\n+               TrFailedMsg, TrIgnored, TrOk};\n     use std::sync::mpsc::channel;\n     use bench;\n     use Bencher;\n \n+\n+    fn one_ignored_one_unignored_test() -> Vec<TestDescAndFn> {\n+        vec![\n+            TestDescAndFn {\n+                desc: TestDesc {\n+                    name: StaticTestName(\"1\"),\n+                    ignore: true,\n+                    should_panic: ShouldPanic::No,\n+                    allow_fail: false,\n+                },\n+                testfn: DynTestFn(Box::new(move || {})),\n+            },\n+            TestDescAndFn {\n+                desc: TestDesc {\n+                    name: StaticTestName(\"2\"),\n+                    ignore: false,\n+                    should_panic: ShouldPanic::No,\n+                    allow_fail: false,\n+                },\n+                testfn: DynTestFn(Box::new(move || {})),\n+            },\n+        ]\n+    }\n+\n     #[test]\n     pub fn do_not_run_ignored_tests() {\n         fn f() {\n@@ -1845,11 +1885,19 @@ mod tests {\n             \"filter\".to_string(),\n             \"--ignored\".to_string(),\n         ];\n-        let opts = match parse_opts(&args) {\n-            Some(Ok(o)) => o,\n-            _ => panic!(\"Malformed arg in parse_ignored_flag\"),\n-        };\n-        assert!((opts.run_ignored));\n+        let opts = parse_opts(&args).unwrap().unwrap();\n+        assert_eq!(opts.run_ignored, RunIgnored::Only);\n+    }\n+\n+    #[test]\n+    fn parse_all_flag() {\n+        let args = vec![\n+            \"progname\".to_string(),\n+            \"filter\".to_string(),\n+            \"--all\".to_string(),\n+        ];\n+        let opts = parse_opts(&args).unwrap().unwrap();\n+        assert_eq!(opts.run_ignored, RunIgnored::Yes);\n     }\n \n     #[test]\n@@ -1859,35 +1907,33 @@ mod tests {\n \n         let mut opts = TestOpts::new();\n         opts.run_tests = true;\n-        opts.run_ignored = true;\n+        opts.run_ignored = RunIgnored::Only;\n \n-        let tests = vec![\n-            TestDescAndFn {\n-                desc: TestDesc {\n-                    name: StaticTestName(\"1\"),\n-                    ignore: true,\n-                    should_panic: ShouldPanic::No,\n-                    allow_fail: false,\n-                },\n-                testfn: DynTestFn(Box::new(move || {})),\n-            },\n-            TestDescAndFn {\n-                desc: TestDesc {\n-                    name: StaticTestName(\"2\"),\n-                    ignore: false,\n-                    should_panic: ShouldPanic::No,\n-                    allow_fail: false,\n-                },\n-                testfn: DynTestFn(Box::new(move || {})),\n-            },\n-        ];\n+        let tests = one_ignored_one_unignored_test();\n         let filtered = filter_tests(&opts, tests);\n \n         assert_eq!(filtered.len(), 1);\n         assert_eq!(filtered[0].desc.name.to_string(), \"1\");\n         assert!(!filtered[0].desc.ignore);\n     }\n \n+    #[test]\n+    pub fn run_all_option() {\n+        // When we run \"--all\" tests, the ignore flag should be set to false on\n+        // all tests and no test filtered out\n+\n+        let mut opts = TestOpts::new();\n+        opts.run_tests = true;\n+        opts.run_ignored = RunIgnored::Yes;\n+\n+        let tests = one_ignored_one_unignored_test();\n+        let filtered = filter_tests(&opts, tests);\n+\n+        assert_eq!(filtered.len(), 2);\n+        assert!(!filtered[0].desc.ignore);\n+        assert!(!filtered[1].desc.ignore);\n+    }\n+\n     #[test]\n     pub fn exact_filter_match() {\n         fn tests() -> Vec<TestDescAndFn> {\n@@ -1995,7 +2041,9 @@ mod tests {\n             \"test::ignored_tests_result_in_ignored\".to_string(),\n             \"test::first_free_arg_should_be_a_filter\".to_string(),\n             \"test::parse_ignored_flag\".to_string(),\n+            \"test::parse_all_flag\".to_string(),\n             \"test::filter_for_ignored_option\".to_string(),\n+            \"test::run_all_option\".to_string(),\n             \"test::sort_tests\".to_string(),\n         ];\n         let tests = {\n@@ -2025,7 +2073,9 @@ mod tests {\n             \"test::filter_for_ignored_option\".to_string(),\n             \"test::first_free_arg_should_be_a_filter\".to_string(),\n             \"test::ignored_tests_result_in_ignored\".to_string(),\n+            \"test::parse_all_flag\".to_string(),\n             \"test::parse_ignored_flag\".to_string(),\n+            \"test::run_all_option\".to_string(),\n             \"test::sort_tests\".to_string(),\n         ];\n "}]}