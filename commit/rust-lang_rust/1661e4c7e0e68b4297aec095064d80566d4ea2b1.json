{"sha": "1661e4c7e0e68b4297aec095064d80566d4ea2b1", "node_id": "C_kwDOAAsO6NoAKDE2NjFlNGM3ZTBlNjhiNDI5N2FlYzA5NTA2NGQ4MDU2NmQ0ZWEyYjE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-06T02:14:49Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-06T02:14:49Z"}, "message": "Auto merge of #93805 - petrochenkov:doclinkself, r=camelid,GuillaumeGomez\n\nrustdoc: Stop textually replacing `Self` in doc links before resolving them\n\nResolve it directly to a type / def-id instead.\n\nAlso never pass `Self` to `Resolver`, it is useless because it's guaranteed that no resolution will be found.\n\nThis is a pre-requisite for https://github.com/rust-lang/rust/issues/83761.", "tree": {"sha": "f6c7a06ce52783302e4e9bcf71a89ee633feb89a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f6c7a06ce52783302e4e9bcf71a89ee633feb89a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1661e4c7e0e68b4297aec095064d80566d4ea2b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1661e4c7e0e68b4297aec095064d80566d4ea2b1", "html_url": "https://github.com/rust-lang/rust/commit/1661e4c7e0e68b4297aec095064d80566d4ea2b1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1661e4c7e0e68b4297aec095064d80566d4ea2b1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0cbef1c6a7f4ee33cd41d91778544c5399f10f39", "url": "https://api.github.com/repos/rust-lang/rust/commits/0cbef1c6a7f4ee33cd41d91778544c5399f10f39", "html_url": "https://github.com/rust-lang/rust/commit/0cbef1c6a7f4ee33cd41d91778544c5399f10f39"}, {"sha": "25c5e39bb14976a969664d450086b6e8dc09e318", "url": "https://api.github.com/repos/rust-lang/rust/commits/25c5e39bb14976a969664d450086b6e8dc09e318", "html_url": "https://github.com/rust-lang/rust/commit/25c5e39bb14976a969664d450086b6e8dc09e318"}], "stats": {"total": 225, "additions": 134, "deletions": 91}, "files": [{"sha": "aa771a06f9c36e5593ed49e7dcc550fe8c2f584c", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 126, "deletions": 91, "changes": 217, "blob_url": "https://github.com/rust-lang/rust/blob/1661e4c7e0e68b4297aec095064d80566d4ea2b1/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1661e4c7e0e68b4297aec095064d80566d4ea2b1/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=1661e4c7e0e68b4297aec095064d80566d4ea2b1", "patch": "@@ -26,7 +26,8 @@ use std::fmt::Write;\n use std::mem;\n use std::ops::Range;\n \n-use crate::clean::{self, utils::find_nearest_parent_module, Crate, Item, ItemLink, PrimitiveType};\n+use crate::clean::{self, utils::find_nearest_parent_module};\n+use crate::clean::{Crate, Item, ItemId, ItemLink, PrimitiveType};\n use crate::core::DocContext;\n use crate::html::markdown::{markdown_links, MarkdownLink};\n use crate::lint::{BROKEN_INTRA_DOC_LINKS, PRIVATE_INTRA_DOC_LINKS};\n@@ -177,6 +178,8 @@ enum ResolutionFailure<'a> {\n     /// The link failed to resolve. [`resolution_failure`] should look to see if there's\n     /// a more helpful error that can be given.\n     NotResolved {\n+        /// Item on which the link is resolved, used for resolving `Self`.\n+        item_id: ItemId,\n         /// The scope the link was resolved in.\n         module_id: DefId,\n         /// If part of the link resolved, this has the `Res`.\n@@ -343,6 +346,7 @@ impl ItemFragment {\n \n #[derive(Clone, Debug, Hash, PartialEq, Eq)]\n struct ResolutionInfo {\n+    item_id: ItemId,\n     module_id: DefId,\n     dis: Option<Disambiguator>,\n     path_str: String,\n@@ -384,10 +388,12 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n     fn variant_field<'path>(\n         &self,\n         path_str: &'path str,\n+        item_id: ItemId,\n         module_id: DefId,\n     ) -> Result<(Res, Option<ItemFragment>), ErrorKind<'path>> {\n         let tcx = self.cx.tcx;\n         let no_res = || ResolutionFailure::NotResolved {\n+            item_id,\n             module_id,\n             partial_res: None,\n             unresolved: path_str.into(),\n@@ -410,13 +416,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n             // If there's no third component, we saw `[a::b]` before and it failed to resolve.\n             // So there's no partial res.\n             .ok_or_else(no_res)?;\n-        let ty_res = self\n-            .cx\n-            .enter_resolver(|resolver| {\n-                resolver.resolve_str_path_error(DUMMY_SP, &path, TypeNS, module_id)\n-            })\n-            .and_then(|(_, res)| res.try_into())\n-            .map_err(|()| no_res())?;\n+        let ty_res = self.resolve_path(&path, TypeNS, item_id, module_id).ok_or_else(no_res)?;\n \n         match ty_res {\n             Res::Def(DefKind::Enum, did) => {\n@@ -437,6 +437,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                             Ok((ty_res, Some(ItemFragment(FragmentKind::VariantField, field.did))))\n                         } else {\n                             Err(ResolutionFailure::NotResolved {\n+                                item_id,\n                                 module_id,\n                                 partial_res: Some(Res::Def(DefKind::Enum, def.did)),\n                                 unresolved: variant_field_name.to_string().into(),\n@@ -448,6 +449,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                 }\n             }\n             _ => Err(ResolutionFailure::NotResolved {\n+                item_id,\n                 module_id,\n                 partial_res: Some(ty_res),\n                 unresolved: variant_name.to_string().into(),\n@@ -481,6 +483,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n     fn resolve_macro(\n         &self,\n         path_str: &'a str,\n+        item_id: ItemId,\n         module_id: DefId,\n     ) -> Result<Res, ResolutionFailure<'a>> {\n         self.cx.enter_resolver(|resolver| {\n@@ -499,19 +502,60 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                 return Ok(res.try_into().unwrap());\n             }\n             Err(ResolutionFailure::NotResolved {\n+                item_id,\n                 module_id,\n                 partial_res: None,\n                 unresolved: path_str.into(),\n             })\n         })\n     }\n \n+    fn resolve_self_ty(&self, path_str: &str, ns: Namespace, item_id: ItemId) -> Option<Res> {\n+        if ns != TypeNS || path_str != \"Self\" {\n+            return None;\n+        }\n+\n+        let tcx = self.cx.tcx;\n+        item_id\n+            .as_def_id()\n+            .map(|def_id| match tcx.def_kind(def_id) {\n+                def_kind @ (DefKind::AssocFn\n+                | DefKind::AssocConst\n+                | DefKind::AssocTy\n+                | DefKind::Variant\n+                | DefKind::Field) => {\n+                    let parent_def_id = tcx.parent(def_id).expect(\"nested item has no parent\");\n+                    if def_kind == DefKind::Field && tcx.def_kind(parent_def_id) == DefKind::Variant\n+                    {\n+                        tcx.parent(parent_def_id).expect(\"variant has no parent\")\n+                    } else {\n+                        parent_def_id\n+                    }\n+                }\n+                _ => def_id,\n+            })\n+            .and_then(|self_id| match tcx.def_kind(self_id) {\n+                DefKind::Impl => self.def_id_to_res(self_id),\n+                def_kind => Some(Res::Def(def_kind, self_id)),\n+            })\n+    }\n+\n     /// Convenience wrapper around `resolve_str_path_error`.\n     ///\n     /// This also handles resolving `true` and `false` as booleans.\n     /// NOTE: `resolve_str_path_error` knows only about paths, not about types.\n     /// Associated items will never be resolved by this function.\n-    fn resolve_path(&self, path_str: &str, ns: Namespace, module_id: DefId) -> Option<Res> {\n+    fn resolve_path(\n+        &self,\n+        path_str: &str,\n+        ns: Namespace,\n+        item_id: ItemId,\n+        module_id: DefId,\n+    ) -> Option<Res> {\n+        if let res @ Some(..) = self.resolve_self_ty(path_str, ns, item_id) {\n+            return res;\n+        }\n+\n         let result = self.cx.enter_resolver(|resolver| {\n             resolver\n                 .resolve_str_path_error(DUMMY_SP, path_str, ns, module_id)\n@@ -532,10 +576,11 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         &mut self,\n         path_str: &'path str,\n         ns: Namespace,\n+        item_id: ItemId,\n         module_id: DefId,\n         user_fragment: &Option<String>,\n     ) -> Result<(Res, Option<UrlFragment>), ErrorKind<'path>> {\n-        let (res, rustdoc_fragment) = self.resolve_inner(path_str, ns, module_id)?;\n+        let (res, rustdoc_fragment) = self.resolve_inner(path_str, ns, item_id, module_id)?;\n         let chosen_fragment = match (user_fragment, rustdoc_fragment) {\n             (Some(_), Some(r_frag)) => {\n                 let diag_res = match r_frag {\n@@ -555,9 +600,10 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         &mut self,\n         path_str: &'path str,\n         ns: Namespace,\n+        item_id: ItemId,\n         module_id: DefId,\n     ) -> Result<(Res, Option<ItemFragment>), ErrorKind<'path>> {\n-        if let Some(res) = self.resolve_path(path_str, ns, module_id) {\n+        if let Some(res) = self.resolve_path(path_str, ns, item_id, module_id) {\n             match res {\n                 // FIXME(#76467): make this fallthrough to lookup the associated\n                 // item a separate function.\n@@ -585,6 +631,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n             .ok_or_else(|| {\n                 debug!(\"found no `::`, assumming {} was correctly not in scope\", item_name);\n                 ResolutionFailure::NotResolved {\n+                    item_id,\n                     module_id,\n                     partial_res: None,\n                     unresolved: item_str.into(),\n@@ -596,7 +643,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         // error instead and special case *only* modules with `#[doc(primitive)]`, not all\n         // primitives.\n         resolve_primitive(&path_root, TypeNS)\n-            .or_else(|| self.resolve_path(&path_root, TypeNS, module_id))\n+            .or_else(|| self.resolve_path(&path_root, TypeNS, item_id, module_id))\n             .and_then(|ty_res| {\n                 let (res, fragment) =\n                     self.resolve_associated_item(ty_res, item_name, ns, module_id)?;\n@@ -605,9 +652,10 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n             })\n             .unwrap_or_else(|| {\n                 if ns == Namespace::ValueNS {\n-                    self.variant_field(path_str, module_id)\n+                    self.variant_field(path_str, item_id, module_id)\n                 } else {\n                     Err(ResolutionFailure::NotResolved {\n+                        item_id,\n                         module_id,\n                         partial_res: None,\n                         unresolved: path_root.into(),\n@@ -723,10 +771,27 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                 self.resolve_associated_item(res, item_name, ns, module_id)\n             }\n             Res::Def(\n-                DefKind::Struct | DefKind::Union | DefKind::Enum | DefKind::ForeignTy,\n+                def_kind @ (DefKind::Struct | DefKind::Union | DefKind::Enum | DefKind::ForeignTy),\n                 did,\n             ) => {\n                 debug!(\"looking for associated item named {} for item {:?}\", item_name, did);\n+                // Checks if item_name is a variant of the `SomeItem` enum\n+                if ns == TypeNS && def_kind == DefKind::Enum {\n+                    match tcx.type_of(did).kind() {\n+                        ty::Adt(adt_def, _) => {\n+                            for variant in &adt_def.variants {\n+                                if variant.name == item_name {\n+                                    return Some((\n+                                        root_res,\n+                                        ItemFragment(FragmentKind::Variant, variant.def_id),\n+                                    ));\n+                                }\n+                            }\n+                        }\n+                        _ => unreachable!(),\n+                    }\n+                }\n+\n                 // Checks if item_name belongs to `impl SomeItem`\n                 let assoc_item = tcx\n                     .inherent_impls(did)\n@@ -813,17 +878,18 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         &mut self,\n         ns: Namespace,\n         path_str: &str,\n+        item_id: ItemId,\n         module_id: DefId,\n         extra_fragment: &Option<String>,\n     ) -> Option<Res> {\n         // resolve() can't be used for macro namespace\n         let result = match ns {\n             Namespace::MacroNS => self\n-                .resolve_macro(path_str, module_id)\n+                .resolve_macro(path_str, item_id, module_id)\n                 .map(|res| (res, None))\n                 .map_err(ErrorKind::from),\n             Namespace::TypeNS | Namespace::ValueNS => {\n-                self.resolve(path_str, ns, module_id, extra_fragment)\n+                self.resolve(path_str, ns, item_id, module_id, extra_fragment)\n             }\n         };\n \n@@ -970,53 +1036,6 @@ impl<'a, 'tcx> DocVisitor for LinkCollector<'a, 'tcx> {\n             trace!(\"got parent node for {:?} {:?}, id {:?}\", item.type_(), item.name, item.def_id);\n         }\n \n-        // find item's parent to resolve `Self` in item's docs below\n-        debug!(\"looking for the `Self` type\");\n-        let self_id = match item.def_id.as_def_id() {\n-            None => None,\n-            Some(did)\n-                if (matches!(self.cx.tcx.def_kind(did), DefKind::Field)\n-                    && matches!(\n-                        self.cx.tcx.def_kind(self.cx.tcx.parent(did).unwrap()),\n-                        DefKind::Variant\n-                    )) =>\n-            {\n-                self.cx.tcx.parent(did).and_then(|item_id| self.cx.tcx.parent(item_id))\n-            }\n-            Some(did)\n-                if matches!(\n-                    self.cx.tcx.def_kind(did),\n-                    DefKind::AssocConst\n-                        | DefKind::AssocFn\n-                        | DefKind::AssocTy\n-                        | DefKind::Variant\n-                        | DefKind::Field\n-                ) =>\n-            {\n-                self.cx.tcx.parent(did)\n-            }\n-            Some(did) => Some(did),\n-        };\n-\n-        // FIXME(jynelson): this shouldn't go through stringification, rustdoc should just use the DefId directly\n-        let self_name = self_id.and_then(|self_id| {\n-            if matches!(self.cx.tcx.def_kind(self_id), DefKind::Impl) {\n-                // using `ty.to_string()` (or any variant) has issues with raw idents\n-                let ty = self.cx.tcx.type_of(self_id);\n-                let name = match ty.kind() {\n-                    ty::Adt(def, _) => Some(self.cx.tcx.item_name(def.did).to_string()),\n-                    other if other.is_primitive() => Some(ty.to_string()),\n-                    _ => None,\n-                };\n-                debug!(\"using type_of(): {:?}\", name);\n-                name\n-            } else {\n-                let name = self.cx.tcx.opt_item_name(self_id).map(|sym| sym.to_string());\n-                debug!(\"using item_name(): {:?}\", name);\n-                name\n-            }\n-        });\n-\n         let inner_docs = item.inner_docs(self.cx.tcx);\n \n         if item.is_mod() && inner_docs {\n@@ -1038,7 +1057,7 @@ impl<'a, 'tcx> DocVisitor for LinkCollector<'a, 'tcx> {\n             // NOTE: if there are links that start in one crate and end in another, this will not resolve them.\n             // This is a degenerate case and it's not supported by rustdoc.\n             for md_link in markdown_links(&doc) {\n-                let link = self.resolve_link(&item, &doc, &self_name, parent_node, krate, md_link);\n+                let link = self.resolve_link(&item, &doc, parent_node, krate, md_link);\n                 if let Some(link) = link {\n                     self.cx.cache.intra_doc_links.entry(item.def_id).or_default().push(link);\n                 }\n@@ -1172,7 +1191,6 @@ impl LinkCollector<'_, '_> {\n         &mut self,\n         item: &Item,\n         dox: &str,\n-        self_name: &Option<String>,\n         parent_node: Option<DefId>,\n         krate: CrateNum,\n         ori_link: MarkdownLink,\n@@ -1240,19 +1258,8 @@ impl LinkCollector<'_, '_> {\n         };\n \n         let resolved_self;\n-        // replace `Self` with suitable item's parent name\n-        let is_lone_self = path_str == \"Self\";\n         let is_lone_crate = path_str == \"crate\";\n-        if path_str.starts_with(\"Self::\") || is_lone_self {\n-            if let Some(ref name) = self_name {\n-                if is_lone_self {\n-                    path_str = name;\n-                } else {\n-                    resolved_self = format!(\"{}::{}\", name, &path_str[6..]);\n-                    path_str = &resolved_self;\n-                }\n-            }\n-        } else if path_str.starts_with(\"crate::\") || is_lone_crate {\n+        if path_str.starts_with(\"crate::\") || is_lone_crate {\n             use rustc_span::def_id::CRATE_DEF_INDEX;\n \n             // HACK(jynelson): rustc_resolve thinks that `crate` is the crate currently being documented.\n@@ -1272,6 +1279,7 @@ impl LinkCollector<'_, '_> {\n \n         let (mut res, fragment) = self.resolve_with_disambiguator_cached(\n             ResolutionInfo {\n+                item_id: item.def_id,\n                 module_id,\n                 dis: disambiguator,\n                 path_str: path_str.to_owned(),\n@@ -1514,12 +1522,13 @@ impl LinkCollector<'_, '_> {\n     ) -> Option<(Res, Option<UrlFragment>)> {\n         let disambiguator = key.dis;\n         let path_str = &key.path_str;\n+        let item_id = key.item_id;\n         let base_node = key.module_id;\n         let extra_fragment = &key.extra_fragment;\n \n         match disambiguator.map(Disambiguator::ns) {\n             Some(expected_ns @ (ValueNS | TypeNS)) => {\n-                match self.resolve(path_str, expected_ns, base_node, extra_fragment) {\n+                match self.resolve(path_str, expected_ns, item_id, base_node, extra_fragment) {\n                     Ok(res) => Some(res),\n                     Err(ErrorKind::Resolve(box mut kind)) => {\n                         // We only looked in one namespace. Try to give a better error if possible.\n@@ -1528,9 +1537,13 @@ impl LinkCollector<'_, '_> {\n                             // FIXME: really it should be `resolution_failure` that does this, not `resolve_with_disambiguator`\n                             // See https://github.com/rust-lang/rust/pull/76955#discussion_r493953382 for a good approach\n                             for new_ns in [other_ns, MacroNS] {\n-                                if let Some(res) =\n-                                    self.check_full_res(new_ns, path_str, base_node, extra_fragment)\n-                                {\n+                                if let Some(res) = self.check_full_res(\n+                                    new_ns,\n+                                    path_str,\n+                                    item_id,\n+                                    base_node,\n+                                    extra_fragment,\n+                                ) {\n                                     kind = ResolutionFailure::WrongNamespace { res, expected_ns };\n                                     break;\n                                 }\n@@ -1552,9 +1565,15 @@ impl LinkCollector<'_, '_> {\n                 // Try everything!\n                 let mut candidates = PerNS {\n                     macro_ns: self\n-                        .resolve_macro(path_str, base_node)\n+                        .resolve_macro(path_str, item_id, base_node)\n                         .map(|res| (res, extra_fragment.clone().map(UrlFragment::UserWritten))),\n-                    type_ns: match self.resolve(path_str, TypeNS, base_node, extra_fragment) {\n+                    type_ns: match self.resolve(\n+                        path_str,\n+                        TypeNS,\n+                        item_id,\n+                        base_node,\n+                        extra_fragment,\n+                    ) {\n                         Ok(res) => {\n                             debug!(\"got res in TypeNS: {:?}\", res);\n                             Ok(res)\n@@ -1565,7 +1584,13 @@ impl LinkCollector<'_, '_> {\n                         }\n                         Err(ErrorKind::Resolve(box kind)) => Err(kind),\n                     },\n-                    value_ns: match self.resolve(path_str, ValueNS, base_node, extra_fragment) {\n+                    value_ns: match self.resolve(\n+                        path_str,\n+                        ValueNS,\n+                        item_id,\n+                        base_node,\n+                        extra_fragment,\n+                    ) {\n                         Ok(res) => Ok(res),\n                         Err(ErrorKind::AnchorFailure(msg)) => {\n                             anchor_failure(self.cx, diag, msg);\n@@ -1624,14 +1649,18 @@ impl LinkCollector<'_, '_> {\n                 }\n             }\n             Some(MacroNS) => {\n-                match self.resolve_macro(path_str, base_node) {\n+                match self.resolve_macro(path_str, item_id, base_node) {\n                     Ok(res) => Some((res, extra_fragment.clone().map(UrlFragment::UserWritten))),\n                     Err(mut kind) => {\n                         // `resolve_macro` only looks in the macro namespace. Try to give a better error if possible.\n                         for ns in [TypeNS, ValueNS] {\n-                            if let Some(res) =\n-                                self.check_full_res(ns, path_str, base_node, extra_fragment)\n-                            {\n+                            if let Some(res) = self.check_full_res(\n+                                ns,\n+                                path_str,\n+                                item_id,\n+                                base_node,\n+                                extra_fragment,\n+                            ) {\n                                 kind =\n                                     ResolutionFailure::WrongNamespace { res, expected_ns: MacroNS };\n                                 break;\n@@ -1958,11 +1987,16 @@ fn resolution_failure(\n                 }\n                 variants_seen.push(variant);\n \n-                if let ResolutionFailure::NotResolved { module_id, partial_res, unresolved } =\n-                    &mut failure\n+                if let ResolutionFailure::NotResolved {\n+                    item_id,\n+                    module_id,\n+                    partial_res,\n+                    unresolved,\n+                } = &mut failure\n                 {\n                     use DefKind::*;\n \n+                    let item_id = *item_id;\n                     let module_id = *module_id;\n                     // FIXME(jynelson): this might conflict with my `Self` fix in #76467\n                     // FIXME: maybe use itertools `collect_tuple` instead?\n@@ -1984,7 +2018,8 @@ fn resolution_failure(\n                         };\n                         name = start;\n                         for ns in [TypeNS, ValueNS, MacroNS] {\n-                            if let Some(res) = collector.check_full_res(ns, start, module_id, &None)\n+                            if let Some(res) =\n+                                collector.check_full_res(ns, start, item_id, module_id, &None)\n                             {\n                                 debug!(\"found partial_res={:?}\", res);\n                                 *partial_res = Some(res);"}, {"sha": "0b958eb8eac12b450f6b0d32ef13367f112d8fcf", "filename": "src/test/rustdoc/intra-doc/associated-items.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1661e4c7e0e68b4297aec095064d80566d4ea2b1/src%2Ftest%2Frustdoc%2Fintra-doc%2Fassociated-items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1661e4c7e0e68b4297aec095064d80566d4ea2b1/src%2Ftest%2Frustdoc%2Fintra-doc%2Fassociated-items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-doc%2Fassociated-items.rs?ref=1661e4c7e0e68b4297aec095064d80566d4ea2b1", "patch": "@@ -57,4 +57,12 @@ impl T2 for S {\n     fn ambiguous_method() {}\n }\n \n+// @has associated_items/enum.MyEnum.html '//a/@href' 'enum.MyEnum.html#variant.MyVariant'\n+/// Link to [MyEnumAlias::MyVariant]\n+pub enum MyEnum {\n+    MyVariant,\n+}\n+\n+pub type MyEnumAlias = MyEnum;\n+\n fn main() {}"}]}