{"sha": "74500b99783d126e330184f0392a78f8b93b73ef", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc0NTAwYjk5NzgzZDEyNmUzMzAxODRmMDM5MmE3OGY4YjkzYjczZWY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-01-29T00:58:43Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-01-29T00:58:43Z"}, "message": "Auto merge of #81493 - JohnTitor:rollup-sa4m4zh, r=JohnTitor\n\nRollup of 10 pull requests\n\nSuccessful merges:\n\n - #79570 (rustc: Stabilize `-Zrun-dsymutil` as `-Csplit-debuginfo`)\n - #79819 (Add `SEMICOLON_IN_EXPRESSIONS_FROM_MACROS` lint)\n - #79991 (rustdoc: Render HRTB correctly for bare functions)\n - #80215 (Use -target when linking binaries for Mac Catalyst)\n - #81158 (Point to span of upvar making closure FnMut)\n - #81176 (Improve safety of `LateContext::qpath_res`)\n - #81287 (Split rustdoc JSON types into separately versioned crate)\n - #81306 (Fuse inner iterator in FlattenCompat and improve related tests)\n - #81333 (clean up some const error reporting around promoteds)\n - #81459 (Fix rustdoc text selection for page titles)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "4674c1335afecd916d742d31ab0e29169d10f1a0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4674c1335afecd916d742d31ab0e29169d10f1a0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/74500b99783d126e330184f0392a78f8b93b73ef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/74500b99783d126e330184f0392a78f8b93b73ef", "html_url": "https://github.com/rust-lang/rust/commit/74500b99783d126e330184f0392a78f8b93b73ef", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/74500b99783d126e330184f0392a78f8b93b73ef/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b05fd2a15de7c9e50110e9ed4c01f114be215739", "url": "https://api.github.com/repos/rust-lang/rust/commits/b05fd2a15de7c9e50110e9ed4c01f114be215739", "html_url": "https://github.com/rust-lang/rust/commit/b05fd2a15de7c9e50110e9ed4c01f114be215739"}, {"sha": "2b4fa3d2118110c21e55b899ebfc9a0fadee50fd", "url": "https://api.github.com/repos/rust-lang/rust/commits/2b4fa3d2118110c21e55b899ebfc9a0fadee50fd", "html_url": "https://github.com/rust-lang/rust/commit/2b4fa3d2118110c21e55b899ebfc9a0fadee50fd"}], "stats": {"total": 1421, "additions": 979, "deletions": 442}, "files": [{"sha": "a4ba7704426e86cd0bf94e127dc4d593f6f76af1", "filename": "Cargo.lock", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/74500b99783d126e330184f0392a78f8b93b73ef/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/74500b99783d126e330184f0392a78f8b93b73ef/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=74500b99783d126e330184f0392a78f8b93b73ef", "patch": "@@ -3746,6 +3746,7 @@ dependencies = [\n  \"rustc_errors\",\n  \"rustc_feature\",\n  \"rustc_lexer\",\n+ \"rustc_lint_defs\",\n  \"rustc_macros\",\n  \"rustc_parse\",\n  \"rustc_serialize\",\n@@ -4391,12 +4392,20 @@ dependencies = [\n  \"pulldown-cmark 0.8.0\",\n  \"regex\",\n  \"rustc-rayon\",\n+ \"rustdoc-json-types\",\n  \"serde\",\n  \"serde_json\",\n  \"smallvec 1.4.2\",\n  \"tempfile\",\n ]\n \n+[[package]]\n+name = \"rustdoc-json-types\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"serde\",\n+]\n+\n [[package]]\n name = \"rustdoc-themes\"\n version = \"0.1.0\""}, {"sha": "f3b2e0f740d61e5ad94dcea4018ed375d00cd562", "filename": "Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/74500b99783d126e330184f0392a78f8b93b73ef/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/74500b99783d126e330184f0392a78f8b93b73ef/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=74500b99783d126e330184f0392a78f8b93b73ef", "patch": "@@ -4,6 +4,7 @@ members = [\n   \"compiler/rustc\",\n   \"library/std\",\n   \"library/test\",\n+  \"src/rustdoc-json-types\",\n   \"src/tools/cargotest\",\n   \"src/tools/clippy\",\n   \"src/tools/compiletest\","}, {"sha": "5702832bcb67d99ac60baa6cb5bbd75bcedc5908", "filename": "compiler/rustc_codegen_cranelift/src/constant.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/74500b99783d126e330184f0392a78f8b93b73ef/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74500b99783d126e330184f0392a78f8b93b73ef/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs?ref=74500b99783d126e330184f0392a78f8b93b73ef", "patch": "@@ -134,11 +134,9 @@ pub(crate) fn codegen_constant<'tcx>(\n             {\n                 Ok(const_val) => const_val,\n                 Err(_) => {\n-                    if promoted.is_none() {\n-                        fx.tcx\n-                            .sess\n-                            .span_err(constant.span, \"erroneous constant encountered\");\n-                    }\n+                    fx.tcx\n+                        .sess\n+                        .span_err(constant.span, \"erroneous constant encountered\");\n                     return crate::trap::trap_unreachable_ret_value(\n                         fx,\n                         fx.layout_of(const_.ty),"}, {"sha": "5effe687528082ce2e9634c9b4390e811e1f96d4", "filename": "compiler/rustc_codegen_llvm/src/back/lto.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/74500b99783d126e330184f0392a78f8b93b73ef/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74500b99783d126e330184f0392a78f8b93b73ef/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs?ref=74500b99783d126e330184f0392a78f8b93b73ef", "patch": "@@ -732,10 +732,7 @@ pub unsafe fn optimize_thin_module(\n     let diag_handler = cgcx.create_diag_handler();\n \n     let module_name = &thin_module.shared.module_names[thin_module.idx];\n-    let split_dwarf_file = cgcx\n-        .output_filenames\n-        .split_dwarf_filename(cgcx.split_dwarf_kind, Some(module_name.to_str().unwrap()));\n-    let tm_factory_config = TargetMachineFactoryConfig { split_dwarf_file };\n+    let tm_factory_config = TargetMachineFactoryConfig::new(cgcx, module_name.to_str().unwrap());\n     let tm =\n         (cgcx.tm_factory)(tm_factory_config).map_err(|e| write::llvm_err(&diag_handler, &e))?;\n "}, {"sha": "326ae354ccf485db1cd8b782eb8271d17e72d338", "filename": "compiler/rustc_codegen_llvm/src/back/write.rs", "status": "modified", "additions": 18, "deletions": 11, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/74500b99783d126e330184f0392a78f8b93b73ef/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74500b99783d126e330184f0392a78f8b93b73ef/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs?ref=74500b99783d126e330184f0392a78f8b93b73ef", "patch": "@@ -23,13 +23,11 @@ use rustc_fs_util::{link_or_copy, path_to_c_string};\n use rustc_hir::def_id::LOCAL_CRATE;\n use rustc_middle::bug;\n use rustc_middle::ty::TyCtxt;\n-use rustc_session::config::{\n-    self, Lto, OutputType, Passes, SanitizerSet, SplitDwarfKind, SwitchWithOptPath,\n-};\n+use rustc_session::config::{self, Lto, OutputType, Passes, SanitizerSet, SwitchWithOptPath};\n use rustc_session::Session;\n use rustc_span::symbol::sym;\n use rustc_span::InnerSpan;\n-use rustc_target::spec::{CodeModel, RelocModel};\n+use rustc_target::spec::{CodeModel, RelocModel, SplitDebuginfo};\n use tracing::debug;\n \n use libc::{c_char, c_int, c_uint, c_void, size_t};\n@@ -93,9 +91,12 @@ pub fn create_informational_target_machine(sess: &Session) -> &'static mut llvm:\n }\n \n pub fn create_target_machine(tcx: TyCtxt<'_>, mod_name: &str) -> &'static mut llvm::TargetMachine {\n-    let split_dwarf_file = tcx\n-        .output_filenames(LOCAL_CRATE)\n-        .split_dwarf_filename(tcx.sess.opts.debugging_opts.split_dwarf, Some(mod_name));\n+    let split_dwarf_file = if tcx.sess.target_can_use_split_dwarf() {\n+        tcx.output_filenames(LOCAL_CRATE)\n+            .split_dwarf_filename(tcx.sess.split_debuginfo(), Some(mod_name))\n+    } else {\n+        None\n+    };\n     let config = TargetMachineFactoryConfig { split_dwarf_file };\n     target_machine_factory(&tcx.sess, tcx.backend_optimization_level(LOCAL_CRATE))(config)\n         .unwrap_or_else(|err| llvm_err(tcx.sess.diagnostic(), &err).raise())\n@@ -838,11 +839,17 @@ pub(crate) unsafe fn codegen(\n                     .generic_activity_with_arg(\"LLVM_module_codegen_emit_obj\", &module.name[..]);\n \n                 let dwo_out = cgcx.output_filenames.temp_path_dwo(module_name);\n-                let dwo_out = match cgcx.split_dwarf_kind {\n+                let dwo_out = match cgcx.split_debuginfo {\n                     // Don't change how DWARF is emitted in single mode (or when disabled).\n-                    SplitDwarfKind::None | SplitDwarfKind::Single => None,\n+                    SplitDebuginfo::Off | SplitDebuginfo::Packed => None,\n                     // Emit (a subset of the) DWARF into a separate file in split mode.\n-                    SplitDwarfKind::Split => Some(dwo_out.as_path()),\n+                    SplitDebuginfo::Unpacked => {\n+                        if cgcx.target_can_use_split_dwarf {\n+                            Some(dwo_out.as_path())\n+                        } else {\n+                            None\n+                        }\n+                    }\n                 };\n \n                 with_codegen(tm, llmod, config.no_builtins, |cpm| {\n@@ -880,7 +887,7 @@ pub(crate) unsafe fn codegen(\n \n     Ok(module.into_compiled_module(\n         config.emit_obj != EmitObj::None,\n-        cgcx.split_dwarf_kind == SplitDwarfKind::Split,\n+        cgcx.target_can_use_split_dwarf && cgcx.split_debuginfo == SplitDebuginfo::Unpacked,\n         config.emit_bc,\n         &cgcx.output_filenames,\n     ))"}, {"sha": "6e7c0b3e3478abb14d94413c215b4f7ffa960519", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/74500b99783d126e330184f0392a78f8b93b73ef/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74500b99783d126e330184f0392a78f8b93b73ef/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs?ref=74500b99783d126e330184f0392a78f8b93b73ef", "patch": "@@ -995,10 +995,13 @@ pub fn compile_unit_metadata(\n     let flags = \"\\0\";\n \n     let out_dir = &tcx.output_filenames(LOCAL_CRATE).out_directory;\n-    let split_name = tcx\n-        .output_filenames(LOCAL_CRATE)\n-        .split_dwarf_filename(tcx.sess.opts.debugging_opts.split_dwarf, Some(codegen_unit_name))\n-        .unwrap_or_default();\n+    let split_name = if tcx.sess.target_can_use_split_dwarf() {\n+        tcx.output_filenames(LOCAL_CRATE)\n+            .split_dwarf_filename(tcx.sess.split_debuginfo(), Some(codegen_unit_name))\n+    } else {\n+        None\n+    }\n+    .unwrap_or_default();\n     let out_dir = out_dir.to_str().unwrap();\n     let split_name = split_name.to_str().unwrap();\n "}, {"sha": "d11c1592f99d125604ff5e44da95268b24cfcac0", "filename": "compiler/rustc_codegen_llvm/src/lib.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/74500b99783d126e330184f0392a78f8b93b73ef/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74500b99783d126e330184f0392a78f8b93b73ef/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs?ref=74500b99783d126e330184f0392a78f8b93b73ef", "patch": "@@ -351,12 +351,7 @@ impl ModuleLlvm {\n         unsafe {\n             let llcx = llvm::LLVMRustContextCreate(cgcx.fewer_names);\n             let llmod_raw = back::lto::parse_module(llcx, name, buffer, handler)?;\n-\n-            let split_dwarf_file = cgcx\n-                .output_filenames\n-                .split_dwarf_filename(cgcx.split_dwarf_kind, Some(name.to_str().unwrap()));\n-            let tm_factory_config = TargetMachineFactoryConfig { split_dwarf_file };\n-\n+            let tm_factory_config = TargetMachineFactoryConfig::new(&cgcx, name.to_str().unwrap());\n             let tm = match (cgcx.tm_factory)(tm_factory_config) {\n                 Ok(m) => m,\n                 Err(e) => {"}, {"sha": "8bc4e64422370425bfd31dad23ab4680d572e541", "filename": "compiler/rustc_codegen_ssa/src/back/link.rs", "status": "modified", "additions": 45, "deletions": 48, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/74500b99783d126e330184f0392a78f8b93b73ef/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74500b99783d126e330184f0392a78f8b93b73ef/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs?ref=74500b99783d126e330184f0392a78f8b93b73ef", "patch": "@@ -14,7 +14,7 @@ use rustc_session::utils::NativeLibKind;\n use rustc_session::{filesearch, Session};\n use rustc_span::symbol::Symbol;\n use rustc_target::spec::crt_objects::{CrtObjects, CrtObjectsFallback};\n-use rustc_target::spec::{LinkOutputKind, LinkerFlavor, LldFlavor};\n+use rustc_target::spec::{LinkOutputKind, LinkerFlavor, LldFlavor, SplitDebuginfo};\n use rustc_target::spec::{PanicStrategy, RelocModel, RelroLevel, Target};\n \n use super::archive::ArchiveBuilder;\n@@ -99,9 +99,6 @@ pub fn link_binary<'a, B: ArchiveBuilder<'a>>(\n                         path.as_ref(),\n                         target_cpu,\n                     );\n-                    if sess.opts.debugging_opts.split_dwarf == config::SplitDwarfKind::Split {\n-                        link_dwarf_object(sess, &out_filename);\n-                    }\n                 }\n             }\n             if sess.opts.json_artifact_notifications {\n@@ -828,29 +825,43 @@ fn link_natively<'a, B: ArchiveBuilder<'a>>(\n         }\n     }\n \n-    // On macOS, debuggers need this utility to get run to do some munging of\n-    // the symbols. Note, though, that if the object files are being preserved\n-    // for their debug information there's no need for us to run dsymutil.\n-    if sess.target.is_like_osx\n-        && sess.opts.debuginfo != DebugInfo::None\n-        && !preserve_objects_for_their_debuginfo(sess)\n-    {\n-        let prog = Command::new(\"dsymutil\").arg(out_filename).output();\n-        match prog {\n-            Ok(prog) => {\n-                if !prog.status.success() {\n-                    let mut output = prog.stderr.clone();\n-                    output.extend_from_slice(&prog.stdout);\n-                    sess.struct_warn(&format!(\n-                        \"processing debug info with `dsymutil` failed: {}\",\n-                        prog.status\n-                    ))\n-                    .note(&escape_string(&output))\n-                    .emit();\n+    match sess.split_debuginfo() {\n+        // If split debug information is disabled or located in individual files\n+        // there's nothing to do here.\n+        SplitDebuginfo::Off | SplitDebuginfo::Unpacked => {}\n+\n+        // If packed split-debuginfo is requested, but the final compilation\n+        // doesn't actually have any debug information, then we skip this step.\n+        SplitDebuginfo::Packed if sess.opts.debuginfo == DebugInfo::None => {}\n+\n+        // On macOS the external `dsymutil` tool is used to create the packed\n+        // debug information. Note that this will read debug information from\n+        // the objects on the filesystem which we'll clean up later.\n+        SplitDebuginfo::Packed if sess.target.is_like_osx => {\n+            let prog = Command::new(\"dsymutil\").arg(out_filename).output();\n+            match prog {\n+                Ok(prog) => {\n+                    if !prog.status.success() {\n+                        let mut output = prog.stderr.clone();\n+                        output.extend_from_slice(&prog.stdout);\n+                        sess.struct_warn(&format!(\n+                            \"processing debug info with `dsymutil` failed: {}\",\n+                            prog.status\n+                        ))\n+                        .note(&escape_string(&output))\n+                        .emit();\n+                    }\n                 }\n+                Err(e) => sess.fatal(&format!(\"unable to run `dsymutil`: {}\", e)),\n             }\n-            Err(e) => sess.fatal(&format!(\"unable to run `dsymutil`: {}\", e)),\n         }\n+\n+        // On MSVC packed debug information is produced by the linker itself so\n+        // there's no need to do anything else here.\n+        SplitDebuginfo::Packed if sess.target.is_like_msvc => {}\n+\n+        // ... and otherwise we're processing a `*.dwp` packed dwarf file.\n+        SplitDebuginfo::Packed => link_dwarf_object(sess, &out_filename),\n     }\n }\n \n@@ -1050,28 +1061,9 @@ fn preserve_objects_for_their_debuginfo(sess: &Session) -> bool {\n         return false;\n     }\n \n-    // Single mode keeps debuginfo in the same object file, but in such a way that it it skipped\n-    // by the linker - so it's expected that when codegen units are linked together that this\n-    // debuginfo would be lost without keeping around the temps.\n-    if sess.opts.debugging_opts.split_dwarf == config::SplitDwarfKind::Single {\n-        return true;\n-    }\n-\n-    // If we're on OSX then the equivalent of split dwarf is turned on by\n-    // default. The final executable won't actually have any debug information\n-    // except it'll have pointers to elsewhere. Historically we've always run\n-    // `dsymutil` to \"link all the dwarf together\" but this is actually sort of\n-    // a bummer for incremental compilation! (the whole point of split dwarf is\n-    // that you don't do this sort of dwarf link).\n-    //\n-    // Basically as a result this just means that if we're on OSX and we're\n-    // *not* running dsymutil then the object files are the only source of truth\n-    // for debug information, so we must preserve them.\n-    if sess.target.is_like_osx {\n-        return !sess.opts.debugging_opts.run_dsymutil;\n-    }\n-\n-    false\n+    // \"unpacked\" split debuginfo means that we leave object files as the\n+    // debuginfo is found in the original object files themselves\n+    sess.split_debuginfo() == SplitDebuginfo::Unpacked\n }\n \n pub fn archive_search_paths(sess: &Session) -> Vec<PathBuf> {\n@@ -2211,8 +2203,13 @@ fn add_apple_sdk(cmd: &mut dyn Linker, sess: &Session, flavor: LinkerFlavor) {\n             return;\n         }\n     };\n-    let arch_name = llvm_target.split('-').next().expect(\"LLVM target must have a hyphen\");\n-    cmd.args(&[\"-arch\", arch_name, \"-isysroot\", &sdk_root, \"-Wl,-syslibroot\", &sdk_root]);\n+    if llvm_target.contains(\"macabi\") {\n+        cmd.args(&[\"-target\", llvm_target])\n+    } else {\n+        let arch_name = llvm_target.split('-').next().expect(\"LLVM target must have a hyphen\");\n+        cmd.args(&[\"-arch\", arch_name])\n+    }\n+    cmd.args(&[\"-isysroot\", &sdk_root, \"-Wl,-syslibroot\", &sdk_root]);\n }\n \n fn get_apple_sdk_root(sdk_name: &str) -> Result<String, String> {"}, {"sha": "6aef5cb535a1f47d11e81129cef37bec77f17863", "filename": "compiler/rustc_codegen_ssa/src/back/write.rs", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/74500b99783d126e330184f0392a78f8b93b73ef/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74500b99783d126e330184f0392a78f8b93b73ef/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs?ref=74500b99783d126e330184f0392a78f8b93b73ef", "patch": "@@ -282,6 +282,20 @@ pub struct TargetMachineFactoryConfig {\n     pub split_dwarf_file: Option<PathBuf>,\n }\n \n+impl TargetMachineFactoryConfig {\n+    pub fn new(\n+        cgcx: &CodegenContext<impl WriteBackendMethods>,\n+        module_name: &str,\n+    ) -> TargetMachineFactoryConfig {\n+        let split_dwarf_file = if cgcx.target_can_use_split_dwarf {\n+            cgcx.output_filenames.split_dwarf_filename(cgcx.split_debuginfo, Some(module_name))\n+        } else {\n+            None\n+        };\n+        TargetMachineFactoryConfig { split_dwarf_file }\n+    }\n+}\n+\n pub type TargetMachineFactoryFn<B> = Arc<\n     dyn Fn(TargetMachineFactoryConfig) -> Result<<B as WriteBackendMethods>::TargetMachine, String>\n         + Send\n@@ -311,10 +325,11 @@ pub struct CodegenContext<B: WriteBackendMethods> {\n     pub tm_factory: TargetMachineFactoryFn<B>,\n     pub msvc_imps_needed: bool,\n     pub is_pe_coff: bool,\n+    pub target_can_use_split_dwarf: bool,\n     pub target_pointer_width: u32,\n     pub target_arch: String,\n     pub debuginfo: config::DebugInfo,\n-    pub split_dwarf_kind: config::SplitDwarfKind,\n+    pub split_debuginfo: rustc_target::spec::SplitDebuginfo,\n \n     // Number of cgus excluding the allocator/metadata modules\n     pub total_cgus: usize,\n@@ -1035,10 +1050,11 @@ fn start_executing_work<B: ExtraBackendMethods>(\n         total_cgus,\n         msvc_imps_needed: msvc_imps_needed(tcx),\n         is_pe_coff: tcx.sess.target.is_like_windows,\n+        target_can_use_split_dwarf: tcx.sess.target_can_use_split_dwarf(),\n         target_pointer_width: tcx.sess.target.pointer_width,\n         target_arch: tcx.sess.target.arch.clone(),\n         debuginfo: tcx.sess.opts.debuginfo,\n-        split_dwarf_kind: tcx.sess.opts.debugging_opts.split_dwarf,\n+        split_debuginfo: tcx.sess.split_debuginfo(),\n     };\n \n     // This is the \"main loop\" of parallel work happening for parallel codegen."}, {"sha": "b79a221a0e74acb16f08b6320bbfe2dcb0bba6fe", "filename": "compiler/rustc_codegen_ssa/src/mir/constant.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/74500b99783d126e330184f0392a78f8b93b73ef/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74500b99783d126e330184f0392a78f8b93b73ef/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fconstant.rs?ref=74500b99783d126e330184f0392a78f8b93b73ef", "patch": "@@ -30,12 +30,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 .tcx()\n                 .const_eval_resolve(ty::ParamEnv::reveal_all(), def, substs, promoted, None)\n                 .map_err(|err| {\n-                    if promoted.is_none() {\n-                        self.cx\n-                            .tcx()\n-                            .sess\n-                            .span_err(constant.span, \"erroneous constant encountered\");\n-                    }\n+                    self.cx.tcx().sess.span_err(constant.span, \"erroneous constant encountered\");\n                     err\n                 }),\n             ty::ConstKind::Value(value) => Ok(value),"}, {"sha": "7413b0d9431f954cbb3c5d7382ad00fe9b1bed89", "filename": "compiler/rustc_expand/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/74500b99783d126e330184f0392a78f8b93b73ef/compiler%2Frustc_expand%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/74500b99783d126e330184f0392a78f8b93b73ef/compiler%2Frustc_expand%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2FCargo.toml?ref=74500b99783d126e330184f0392a78f8b93b73ef", "patch": "@@ -18,6 +18,7 @@ rustc_attr = { path = \"../rustc_attr\" }\n rustc_data_structures = { path = \"../rustc_data_structures\" }\n rustc_errors = { path = \"../rustc_errors\" }\n rustc_feature = { path = \"../rustc_feature\" }\n+rustc_lint_defs = { path = \"../rustc_lint_defs\" }\n rustc_macros = { path = \"../rustc_macros\" }\n rustc_lexer = { path = \"../rustc_lexer\" }\n rustc_parse = { path = \"../rustc_parse\" }"}, {"sha": "73fbde70bda9fcccfad032403ed8b1bf981e22fc", "filename": "compiler/rustc_expand/src/mbe/macro_rules.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/74500b99783d126e330184f0392a78f8b93b73ef/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74500b99783d126e330184f0392a78f8b93b73ef/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs?ref=74500b99783d126e330184f0392a78f8b93b73ef", "patch": "@@ -11,12 +11,14 @@ use crate::mbe::transcribe::transcribe;\n use rustc_ast as ast;\n use rustc_ast::token::{self, NonterminalKind, NtTT, Token, TokenKind::*};\n use rustc_ast::tokenstream::{DelimSpan, TokenStream};\n+use rustc_ast::NodeId;\n use rustc_ast_pretty::pprust;\n use rustc_attr::{self as attr, TransparencyError};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::{Applicability, DiagnosticBuilder};\n use rustc_feature::Features;\n+use rustc_lint_defs::builtin::SEMICOLON_IN_EXPRESSIONS_FROM_MACROS;\n use rustc_parse::parser::Parser;\n use rustc_session::parse::ParseSess;\n use rustc_session::Session;\n@@ -37,6 +39,7 @@ crate struct ParserAnyMacro<'a> {\n     site_span: Span,\n     /// The ident of the macro we're parsing\n     macro_ident: Ident,\n+    lint_node_id: NodeId,\n     arm_span: Span,\n }\n \n@@ -110,7 +113,8 @@ fn emit_frag_parse_err(\n \n impl<'a> ParserAnyMacro<'a> {\n     crate fn make(mut self: Box<ParserAnyMacro<'a>>, kind: AstFragmentKind) -> AstFragment {\n-        let ParserAnyMacro { site_span, macro_ident, ref mut parser, arm_span } = *self;\n+        let ParserAnyMacro { site_span, macro_ident, ref mut parser, lint_node_id, arm_span } =\n+            *self;\n         let snapshot = &mut parser.clone();\n         let fragment = match parse_ast_fragment(parser, kind) {\n             Ok(f) => f,\n@@ -124,6 +128,12 @@ impl<'a> ParserAnyMacro<'a> {\n         // `macro_rules! m { () => { panic!(); } }` isn't parsed by `.parse_expr()`,\n         // but `m!()` is allowed in expression positions (cf. issue #34706).\n         if kind == AstFragmentKind::Expr && parser.token == token::Semi {\n+            parser.sess.buffer_lint(\n+                SEMICOLON_IN_EXPRESSIONS_FROM_MACROS,\n+                parser.token.span,\n+                lint_node_id,\n+                \"trailing semicolon in macro used in expression position\",\n+            );\n             parser.bump();\n         }\n \n@@ -276,6 +286,7 @@ fn generic_extension<'cx>(\n \n                 let mut p = Parser::new(sess, tts, false, None);\n                 p.last_type_ascription = cx.current_expansion.prior_type_ascription;\n+                let lint_node_id = cx.resolver.lint_node_id(cx.current_expansion.id);\n \n                 // Let the context choose how to interpret the result.\n                 // Weird, but useful for X-macros.\n@@ -287,6 +298,7 @@ fn generic_extension<'cx>(\n                     // macro leaves unparsed tokens.\n                     site_span: sp,\n                     macro_ident: name,\n+                    lint_node_id,\n                     arm_span,\n                 });\n             }"}, {"sha": "305ae23669bbf2d79b3dc2635d00fac38fc3a81c", "filename": "compiler/rustc_interface/src/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74500b99783d126e330184f0392a78f8b93b73ef/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74500b99783d126e330184f0392a78f8b93b73ef/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Ftests.rs?ref=74500b99783d126e330184f0392a78f8b93b73ef", "patch": "@@ -17,7 +17,7 @@ use rustc_span::edition::{Edition, DEFAULT_EDITION};\n use rustc_span::symbol::sym;\n use rustc_span::SourceFileHashAlgorithm;\n use rustc_target::spec::{CodeModel, LinkerFlavor, MergeFunctions, PanicStrategy};\n-use rustc_target::spec::{RelocModel, RelroLevel, TlsModel};\n+use rustc_target::spec::{RelocModel, RelroLevel, SplitDebuginfo, TlsModel};\n use std::collections::{BTreeMap, BTreeSet};\n use std::iter::FromIterator;\n use std::path::PathBuf;\n@@ -446,6 +446,7 @@ fn test_codegen_options_tracking_hash() {\n     tracked!(profile_use, Some(PathBuf::from(\"abc\")));\n     tracked!(relocation_model, Some(RelocModel::Pic));\n     tracked!(soft_float, true);\n+    tracked!(split_debuginfo, Some(SplitDebuginfo::Packed));\n     tracked!(target_cpu, Some(String::from(\"abc\")));\n     tracked!(target_feature, String::from(\"all the features, all of them\"));\n }\n@@ -579,7 +580,6 @@ fn test_debugging_options_tracking_hash() {\n     tracked!(relax_elf_relocations, Some(true));\n     tracked!(relro_level, Some(RelroLevel::Full));\n     tracked!(report_delayed_bugs, true);\n-    tracked!(run_dsymutil, false);\n     tracked!(sanitizer, SanitizerSet::ADDRESS);\n     tracked!(sanitizer_memory_track_origins, 2);\n     tracked!(sanitizer_recover, SanitizerSet::ADDRESS);"}, {"sha": "8bd9dad785c4b537b1c5f356110515f78359745b", "filename": "compiler/rustc_lint/src/context.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/74500b99783d126e330184f0392a78f8b93b73ef/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74500b99783d126e330184f0392a78f8b93b73ef/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs?ref=74500b99783d126e330184f0392a78f8b93b73ef", "patch": "@@ -746,6 +746,14 @@ impl<'tcx> LateContext<'tcx> {\n             hir::QPath::Resolved(_, ref path) => path.res,\n             hir::QPath::TypeRelative(..) | hir::QPath::LangItem(..) => self\n                 .maybe_typeck_results()\n+                .filter(|typeck_results| typeck_results.hir_owner == id.owner)\n+                .or_else(|| {\n+                    if self.tcx.has_typeck_results(id.owner.to_def_id()) {\n+                        Some(self.tcx.typeck(id.owner))\n+                    } else {\n+                        None\n+                    }\n+                })\n                 .and_then(|typeck_results| typeck_results.type_dependent_def(id))\n                 .map_or(Res::Err, |(kind, def_id)| Res::Def(kind, def_id)),\n         }"}, {"sha": "3821a393efb8b851c959a35f94135b4cf04421fa", "filename": "compiler/rustc_lint/src/late.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74500b99783d126e330184f0392a78f8b93b73ef/compiler%2Frustc_lint%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74500b99783d126e330184f0392a78f8b93b73ef/compiler%2Frustc_lint%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flate.rs?ref=74500b99783d126e330184f0392a78f8b93b73ef", "patch": "@@ -140,13 +140,17 @@ impl<'tcx, T: LateLintPass<'tcx>> hir_visit::Visitor<'tcx> for LateContextAndPas\n     fn visit_item(&mut self, it: &'tcx hir::Item<'tcx>) {\n         let generics = self.context.generics.take();\n         self.context.generics = it.kind.generics();\n+        let old_cached_typeck_results = self.context.cached_typeck_results.take();\n+        let old_enclosing_body = self.context.enclosing_body.take();\n         self.with_lint_attrs(it.hir_id, &it.attrs, |cx| {\n             cx.with_param_env(it.hir_id, |cx| {\n                 lint_callback!(cx, check_item, it);\n                 hir_visit::walk_item(cx, it);\n                 lint_callback!(cx, check_item_post, it);\n             });\n         });\n+        self.context.enclosing_body = old_enclosing_body;\n+        self.context.cached_typeck_results.set(old_cached_typeck_results);\n         self.context.generics = generics;\n     }\n "}, {"sha": "a8bf1ce51bb74e589bfa295230ed7d458bcdeb80", "filename": "compiler/rustc_lint_defs/src/builtin.rs", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/74500b99783d126e330184f0392a78f8b93b73ef/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74500b99783d126e330184f0392a78f8b93b73ef/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs?ref=74500b99783d126e330184f0392a78f8b93b73ef", "patch": "@@ -1,3 +1,4 @@\n+// ignore-tidy-filelength\n //! Some lints that are built in to the compiler.\n //!\n //! These are the built-in lints that are emitted direct in the main\n@@ -2833,6 +2834,52 @@ declare_lint! {\n     \"detects `#[unstable]` on stable trait implementations for stable types\"\n }\n \n+declare_lint! {\n+    /// The `semicolon_in_expressions_from_macros` lint detects trailing semicolons\n+    /// in macro bodies when the macro is invoked in expression position.\n+    /// This was previous accepted, but is being phased out.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,compile_fail\n+    /// #![deny(semicolon_in_expressions_from_macros)]\n+    /// macro_rules! foo {\n+    ///     () => { true; }\n+    /// }\n+    ///\n+    /// fn main() {\n+    ///     let val = match true {\n+    ///         true => false,\n+    ///         _ => foo!()\n+    ///     };\n+    /// }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// Previous, Rust ignored trailing semicolon in a macro\n+    /// body when a macro was invoked in expression position.\n+    /// However, this makes the treatment of semicolons in the language\n+    /// inconsistent, and could lead to unexpected runtime behavior\n+    /// in some circumstances (e.g. if the macro author expects\n+    /// a value to be dropped).\n+    ///\n+    /// This is a [future-incompatible] lint to transition this\n+    /// to a hard error in the future. See [issue #79813] for more details.\n+    ///\n+    /// [issue #79813]: https://github.com/rust-lang/rust/issues/79813\n+    /// [future-incompatible]: ../index.md#future-incompatible-lints\n+    pub SEMICOLON_IN_EXPRESSIONS_FROM_MACROS,\n+    Allow,\n+    \"trailing semicolon in macro body used as expression\",\n+    @future_incompatible = FutureIncompatibleInfo {\n+        reference: \"issue #79813 <https://github.com/rust-lang/rust/issues/79813>\",\n+        edition: None,\n+    };\n+}\n+\n declare_lint_pass! {\n     /// Does nothing as a lint pass, but registers some `Lint`s\n     /// that are used by other parts of the compiler.\n@@ -2920,6 +2967,7 @@ declare_lint_pass! {\n         USELESS_DEPRECATED,\n         UNSUPPORTED_NAKED_FUNCTIONS,\n         MISSING_ABI,\n+        SEMICOLON_IN_EXPRESSIONS_FROM_MACROS,\n     ]\n }\n "}, {"sha": "73196c732f5bbc8586147a279885af5da6caf269", "filename": "compiler/rustc_mir/src/borrow_check/diagnostics/mutability_errors.rs", "status": "modified", "additions": 55, "deletions": 1, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/74500b99783d126e330184f0392a78f8b93b73ef/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74500b99783d126e330184f0392a78f8b93b73ef/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs?ref=74500b99783d126e330184f0392a78f8b93b73ef", "patch": "@@ -1,9 +1,12 @@\n use rustc_hir as hir;\n use rustc_hir::Node;\n use rustc_index::vec::Idx;\n-use rustc_middle::mir::{self, ClearCrossCrate, Local, LocalDecl, LocalInfo, Location};\n use rustc_middle::mir::{Mutability, Place, PlaceRef, ProjectionElem};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_middle::{\n+    hir::place::PlaceBase,\n+    mir::{self, ClearCrossCrate, Local, LocalDecl, LocalInfo, Location},\n+};\n use rustc_span::source_map::DesugaringKind;\n use rustc_span::symbol::{kw, Symbol};\n use rustc_span::Span;\n@@ -241,6 +244,10 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     format!(\"mut {}\", self.local_names[local].unwrap()),\n                     Applicability::MachineApplicable,\n                 );\n+                let tcx = self.infcx.tcx;\n+                if let ty::Closure(id, _) = the_place_err.ty(self.body, tcx).ty.kind() {\n+                    self.show_mutating_upvar(tcx, id, the_place_err, &mut err);\n+                }\n             }\n \n             // Also suggest adding mut for upvars\n@@ -271,6 +278,14 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                         );\n                     }\n                 }\n+\n+                let tcx = self.infcx.tcx;\n+                if let ty::Ref(_, ty, Mutability::Mut) = the_place_err.ty(self.body, tcx).ty.kind()\n+                {\n+                    if let ty::Closure(id, _) = ty.kind() {\n+                        self.show_mutating_upvar(tcx, id, the_place_err, &mut err);\n+                    }\n+                }\n             }\n \n             // complete hack to approximate old AST-borrowck\n@@ -463,6 +478,45 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         err.buffer(&mut self.errors_buffer);\n     }\n \n+    // point to span of upvar making closure call require mutable borrow\n+    fn show_mutating_upvar(\n+        &self,\n+        tcx: TyCtxt<'_>,\n+        id: &hir::def_id::DefId,\n+        the_place_err: PlaceRef<'tcx>,\n+        err: &mut DiagnosticBuilder<'_>,\n+    ) {\n+        let id = id.expect_local();\n+        let tables = tcx.typeck(id);\n+        let hir_id = tcx.hir().local_def_id_to_hir_id(id);\n+        let (span, place) = &tables.closure_kind_origins()[hir_id];\n+        let reason = if let PlaceBase::Upvar(upvar_id) = place.base {\n+            let upvar = ty::place_to_string_for_capture(tcx, place);\n+            match tables.upvar_capture(upvar_id) {\n+                ty::UpvarCapture::ByRef(ty::UpvarBorrow {\n+                    kind: ty::BorrowKind::MutBorrow,\n+                    ..\n+                }) => {\n+                    format!(\"mutable borrow of `{}`\", upvar)\n+                }\n+                ty::UpvarCapture::ByValue(_) => {\n+                    format!(\"possible mutation of `{}`\", upvar)\n+                }\n+                _ => bug!(\"upvar `{}` borrowed, but not mutably\", upvar),\n+            }\n+        } else {\n+            bug!(\"not an upvar\")\n+        };\n+        err.span_label(\n+            *span,\n+            format!(\n+                \"calling `{}` requires mutable binding due to {}\",\n+                self.describe_place(the_place_err).unwrap(),\n+                reason\n+            ),\n+        );\n+    }\n+\n     /// Targeted error when encountering an `FnMut` closure where an `Fn` closure was expected.\n     fn expected_fn_found_fn_mut_call(&self, err: &mut DiagnosticBuilder<'_>, sp: Span, act: &str) {\n         err.span_label(sp, format!(\"cannot {}\", act));"}, {"sha": "252f5e7ef2ff2081f7719d98188e6dc501dc3f81", "filename": "compiler/rustc_mir/src/const_eval/eval_queries.rs", "status": "modified", "additions": 28, "deletions": 74, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/74500b99783d126e330184f0392a78f8b93b73ef/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74500b99783d126e330184f0392a78f8b93b73ef/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Feval_queries.rs?ref=74500b99783d126e330184f0392a78f8b93b73ef", "patch": "@@ -298,90 +298,44 @@ pub fn eval_to_allocation_raw_provider<'tcx>(\n         tcx.def_span(def.did),\n         key.param_env,\n         CompileTimeInterpreter::new(tcx.sess.const_eval_limit()),\n+        // Statics (and promoteds inside statics) may access other statics, because unlike consts\n+        // they do not have to behave \"as if\" they were evaluated at runtime.\n         MemoryExtra { can_access_statics: is_static },\n     );\n \n     let res = ecx.load_mir(cid.instance.def, cid.promoted);\n     match res.and_then(|body| eval_body_using_ecx(&mut ecx, cid, &body)) {\n         Err(error) => {\n             let err = ConstEvalErr::new(&ecx, error, None);\n-            // errors in statics are always emitted as fatal errors\n-            if is_static {\n-                // Ensure that if the above error was either `TooGeneric` or `Reported`\n-                // an error must be reported.\n-                let v = err.report_as_error(\n-                    ecx.tcx.at(ecx.cur_span()),\n-                    \"could not evaluate static initializer\",\n-                );\n-\n-                // If this is `Reveal:All`, then we need to make sure an error is reported but if\n-                // this is `Reveal::UserFacing`, then it's expected that we could get a\n-                // `TooGeneric` error. When we fall back to `Reveal::All`, then it will either\n-                // succeed or we'll report this error then.\n-                if key.param_env.reveal() == Reveal::All {\n-                    tcx.sess.delay_span_bug(\n-                        err.span,\n-                        &format!(\"static eval failure did not emit an error: {:#?}\", v),\n-                    );\n-                }\n-\n-                Err(v)\n-            } else if let Some(def) = def.as_local() {\n-                // constant defined in this crate, we can figure out a lint level!\n-                match tcx.def_kind(def.did.to_def_id()) {\n-                    // constants never produce a hard error at the definition site. Anything else is\n-                    // a backwards compatibility hazard (and will break old versions of winapi for\n-                    // sure)\n-                    //\n-                    // note that validation may still cause a hard error on this very same constant,\n-                    // because any code that existed before validation could not have failed\n-                    // validation thus preventing such a hard error from being a backwards\n-                    // compatibility hazard\n-                    DefKind::Const | DefKind::AssocConst => {\n-                        let hir_id = tcx.hir().local_def_id_to_hir_id(def.did);\n-                        Err(err.report_as_lint(\n-                            tcx.at(tcx.def_span(def.did)),\n-                            \"any use of this value will cause an error\",\n-                            hir_id,\n-                            Some(err.span),\n-                        ))\n-                    }\n-                    // promoting runtime code is only allowed to error if it references broken\n-                    // constants any other kind of error will be reported to the user as a\n-                    // deny-by-default lint\n-                    _ => {\n-                        if let Some(p) = cid.promoted {\n-                            let span = tcx.promoted_mir_opt_const_arg(def.to_global())[p].span;\n-                            if let err_inval!(ReferencedConstant) = err.error {\n-                                Err(err.report_as_error(\n-                                    tcx.at(span),\n-                                    \"evaluation of constant expression failed\",\n-                                ))\n-                            } else {\n-                                Err(err.report_as_lint(\n-                                    tcx.at(span),\n-                                    \"reaching this expression at runtime will panic or abort\",\n-                                    tcx.hir().local_def_id_to_hir_id(def.did),\n-                                    Some(err.span),\n-                                ))\n-                            }\n-                        // anything else (array lengths, enum initializers, constant patterns) are\n-                        // reported as hard errors\n-                        } else {\n-                            Err(err.report_as_error(\n-                                ecx.tcx.at(ecx.cur_span()),\n-                                \"evaluation of constant value failed\",\n-                            ))\n-                        }\n-                    }\n-                }\n+            // Some CTFE errors raise just a lint, not a hard error; see\n+            // <https://github.com/rust-lang/rust/issues/71800>.\n+            let emit_as_lint = if let Some(def) = def.as_local() {\n+                // (Associated) consts only emit a lint, since they might be unused.\n+                matches!(tcx.def_kind(def.did.to_def_id()), DefKind::Const | DefKind::AssocConst)\n             } else {\n-                // use of broken constant from other crate\n-                Err(err.report_as_error(ecx.tcx.at(ecx.cur_span()), \"could not evaluate constant\"))\n+                // use of broken constant from other crate: always an error\n+                false\n+            };\n+            if emit_as_lint {\n+                let hir_id = tcx.hir().local_def_id_to_hir_id(def.as_local().unwrap().did);\n+                Err(err.report_as_lint(\n+                    tcx.at(tcx.def_span(def.did)),\n+                    \"any use of this value will cause an error\",\n+                    hir_id,\n+                    Some(err.span),\n+                ))\n+            } else {\n+                let msg = if is_static {\n+                    \"could not evaluate static initializer\"\n+                } else {\n+                    \"evaluation of constant value failed\"\n+                };\n+                Err(err.report_as_error(ecx.tcx.at(ecx.cur_span()), msg))\n             }\n         }\n         Ok(mplace) => {\n-            // Since evaluation had no errors, valiate the resulting constant:\n+            // Since evaluation had no errors, validate the resulting constant.\n+            // This is a separate `try` block to provide more targeted error reporting.\n             let validation = try {\n                 let mut ref_tracking = RefTracking::new(mplace);\n                 let mut inner = false;\n@@ -399,7 +353,7 @@ pub fn eval_to_allocation_raw_provider<'tcx>(\n                 }\n             };\n             if let Err(error) = validation {\n-                // Validation failed, report an error\n+                // Validation failed, report an error. This is always a hard error.\n                 let err = ConstEvalErr::new(&ecx, error, None);\n                 Err(err.struct_error(\n                     ecx.tcx,"}, {"sha": "d0adee2429d9aecb48de0e1c576e0132544eef90", "filename": "compiler/rustc_resolve/src/macros.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74500b99783d126e330184f0392a78f8b93b73ef/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74500b99783d126e330184f0392a78f8b93b73ef/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs?ref=74500b99783d126e330184f0392a78f8b93b73ef", "patch": "@@ -344,6 +344,8 @@ impl<'a> ResolverExpand for Resolver<'a> {\n     }\n \n     fn lint_node_id(&mut self, expn_id: ExpnId) -> NodeId {\n+        // FIXME - make this more precise. This currently returns the NodeId of the\n+        // nearest closing item - we should try to return the closest parent of the ExpnId\n         self.invocation_parents\n             .get(&expn_id)\n             .map_or(ast::CRATE_NODE_ID, |id| self.def_id_to_node_id[*id])"}, {"sha": "f9e40919149d97d89e394a55d5aef4193f58c557", "filename": "compiler/rustc_session/src/config.rs", "status": "modified", "additions": 19, "deletions": 26, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/74500b99783d126e330184f0392a78f8b93b73ef/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74500b99783d126e330184f0392a78f8b93b73ef/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fconfig.rs?ref=74500b99783d126e330184f0392a78f8b93b73ef", "patch": "@@ -13,7 +13,7 @@ use rustc_data_structures::impl_stable_hash_via_hash;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n \n use rustc_target::abi::{Align, TargetDataLayout};\n-use rustc_target::spec::{Target, TargetTriple};\n+use rustc_target::spec::{SplitDebuginfo, Target, TargetTriple};\n \n use crate::parse::CrateConfig;\n use rustc_feature::UnstableFeatures;\n@@ -221,23 +221,6 @@ pub enum DebugInfo {\n     Full,\n }\n \n-/// Some debuginfo requires link-time relocation and some does not. LLVM can partition the debuginfo\n-/// into sections depending on whether or not it requires link-time relocation. Split DWARF\n-/// provides a mechanism which allows the linker to skip the sections which don't require link-time\n-/// relocation - either by putting those sections into DWARF object files, or keeping them in the\n-/// object file in such a way that the linker will skip them.\n-#[derive(Clone, Copy, Debug, PartialEq, Hash)]\n-pub enum SplitDwarfKind {\n-    /// Disabled.\n-    None,\n-    /// Sections which do not require relocation are written into the object file but ignored\n-    /// by the linker.\n-    Single,\n-    /// Sections which do not require relocation are written into a DWARF object (`.dwo`) file,\n-    /// which is skipped by the linker by virtue of being a different file.\n-    Split,\n-}\n-\n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, PartialOrd, Ord)]\n #[derive(Encodable, Decodable)]\n pub enum OutputType {\n@@ -635,30 +618,30 @@ impl OutputFilenames {\n     /// mode is being used, which is the logic that this function is intended to encapsulate.\n     pub fn split_dwarf_filename(\n         &self,\n-        split_dwarf_kind: SplitDwarfKind,\n+        split_debuginfo_kind: SplitDebuginfo,\n         cgu_name: Option<&str>,\n     ) -> Option<PathBuf> {\n-        self.split_dwarf_path(split_dwarf_kind, cgu_name)\n+        self.split_dwarf_path(split_debuginfo_kind, cgu_name)\n             .map(|path| path.strip_prefix(&self.out_directory).unwrap_or(&path).to_path_buf())\n     }\n \n     /// Returns the path for the Split DWARF file - this can differ depending on which Split DWARF\n     /// mode is being used, which is the logic that this function is intended to encapsulate.\n     pub fn split_dwarf_path(\n         &self,\n-        split_dwarf_kind: SplitDwarfKind,\n+        split_debuginfo_kind: SplitDebuginfo,\n         cgu_name: Option<&str>,\n     ) -> Option<PathBuf> {\n         let obj_out = self.temp_path(OutputType::Object, cgu_name);\n         let dwo_out = self.temp_path_dwo(cgu_name);\n-        match split_dwarf_kind {\n-            SplitDwarfKind::None => None,\n+        match split_debuginfo_kind {\n+            SplitDebuginfo::Off => None,\n             // Single mode doesn't change how DWARF is emitted, but does add Split DWARF attributes\n             // (pointing at the path which is being determined here). Use the path to the current\n             // object file.\n-            SplitDwarfKind::Single => Some(obj_out),\n+            SplitDebuginfo::Packed => Some(obj_out),\n             // Split mode emits the DWARF into a different file, use that path.\n-            SplitDwarfKind::Split => Some(dwo_out),\n+            SplitDebuginfo::Unpacked => Some(dwo_out),\n         }\n     }\n }\n@@ -1910,6 +1893,15 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n \n     let pretty = parse_pretty(matches, &debugging_opts, error_format);\n \n+    if !debugging_opts.unstable_options\n+        && !target_triple.triple().contains(\"apple\")\n+        && cg.split_debuginfo.is_some()\n+    {\n+        {\n+            early_error(error_format, \"`-Csplit-debuginfo` is unstable on this platform\");\n+        }\n+    }\n+\n     Options {\n         crate_types,\n         optimize: opt_level,\n@@ -2191,7 +2183,7 @@ crate mod dep_tracking {\n     use rustc_feature::UnstableFeatures;\n     use rustc_span::edition::Edition;\n     use rustc_target::spec::{CodeModel, MergeFunctions, PanicStrategy, RelocModel};\n-    use rustc_target::spec::{RelroLevel, TargetTriple, TlsModel};\n+    use rustc_target::spec::{RelroLevel, SplitDebuginfo, TargetTriple, TlsModel};\n     use std::collections::hash_map::DefaultHasher;\n     use std::collections::BTreeMap;\n     use std::hash::Hash;\n@@ -2263,6 +2255,7 @@ crate mod dep_tracking {\n     impl_dep_tracking_hash_via_hash!(TargetTriple);\n     impl_dep_tracking_hash_via_hash!(Edition);\n     impl_dep_tracking_hash_via_hash!(LinkerPluginLto);\n+    impl_dep_tracking_hash_via_hash!(Option<SplitDebuginfo>);\n     impl_dep_tracking_hash_via_hash!(SwitchWithOptPath);\n     impl_dep_tracking_hash_via_hash!(Option<SymbolManglingVersion>);\n     impl_dep_tracking_hash_via_hash!(Option<SourceFileHashAlgorithm>);"}, {"sha": "2aaab84585d073614d76f6fccafed8ad17ae54cb", "filename": "compiler/rustc_session/src/options.rs", "status": "modified", "additions": 13, "deletions": 22, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/74500b99783d126e330184f0392a78f8b93b73ef/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74500b99783d126e330184f0392a78f8b93b73ef/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foptions.rs?ref=74500b99783d126e330184f0392a78f8b93b73ef", "patch": "@@ -6,7 +6,7 @@ use crate::search_paths::SearchPath;\n use crate::utils::NativeLibKind;\n \n use rustc_target::spec::{CodeModel, LinkerFlavor, MergeFunctions, PanicStrategy};\n-use rustc_target::spec::{RelocModel, RelroLevel, TargetTriple, TlsModel};\n+use rustc_target::spec::{RelocModel, RelroLevel, SplitDebuginfo, TargetTriple, TlsModel};\n \n use rustc_feature::UnstableFeatures;\n use rustc_span::edition::Edition;\n@@ -269,7 +269,6 @@ macro_rules! options {\n         pub const parse_switch_with_opt_path: &str =\n             \"an optional path to the profiling data output directory\";\n         pub const parse_merge_functions: &str = \"one of: `disabled`, `trampolines`, or `aliases`\";\n-        pub const parse_split_dwarf_kind: &str = \"one of: `none`, `single` or `split`\";\n         pub const parse_symbol_mangling_version: &str = \"either `legacy` or `v0` (RFC 2603)\";\n         pub const parse_src_file_hash: &str = \"either `md5` or `sha1`\";\n         pub const parse_relocation_model: &str =\n@@ -280,6 +279,8 @@ macro_rules! options {\n             \"one of supported TLS models (`rustc --print tls-models`)\";\n         pub const parse_target_feature: &str = parse_string;\n         pub const parse_wasi_exec_model: &str = \"either `command` or `reactor`\";\n+        pub const parse_split_debuginfo: &str =\n+            \"one of supported split-debuginfo modes (`off` or `dsymutil`)\";\n     }\n \n     #[allow(dead_code)]\n@@ -678,19 +679,6 @@ macro_rules! options {\n             true\n         }\n \n-        fn parse_split_dwarf_kind(\n-            slot: &mut SplitDwarfKind,\n-            v: Option<&str>,\n-        ) -> bool {\n-            *slot = match v {\n-                Some(\"none\") => SplitDwarfKind::None,\n-                Some(\"split\") => SplitDwarfKind::Split,\n-                Some(\"single\") => SplitDwarfKind::Single,\n-                _ => return false,\n-            };\n-            true\n-        }\n-\n         fn parse_symbol_mangling_version(\n             slot: &mut Option<SymbolManglingVersion>,\n             v: Option<&str>,\n@@ -732,6 +720,14 @@ macro_rules! options {\n             }\n             true\n         }\n+\n+        fn parse_split_debuginfo(slot: &mut Option<SplitDebuginfo>, v: Option<&str>) -> bool {\n+            match v.and_then(|s| SplitDebuginfo::from_str(s).ok()) {\n+                Some(e) => *slot = Some(e),\n+                _ => return false,\n+            }\n+            true\n+        }\n     }\n ) }\n \n@@ -830,6 +826,8 @@ options! {CodegenOptions, CodegenSetter, basic_codegen_options,\n         \"save all temporary output files during compilation (default: no)\"),\n     soft_float: bool = (false, parse_bool, [TRACKED],\n         \"use soft float ABI (*eabihf targets only) (default: no)\"),\n+    split_debuginfo: Option<SplitDebuginfo> = (None, parse_split_debuginfo, [TRACKED],\n+        \"how to handle split-debuginfo, a platform-specific option\"),\n     target_cpu: Option<String> = (None, parse_opt_string, [TRACKED],\n         \"select target processor (`rustc --print target-cpus` for details)\"),\n     target_feature: String = (String::new(), parse_target_feature, [TRACKED],\n@@ -1073,11 +1071,6 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"choose which RELRO level to use\"),\n     report_delayed_bugs: bool = (false, parse_bool, [TRACKED],\n         \"immediately print bugs registered with `delay_span_bug` (default: no)\"),\n-    // The default historical behavior was to always run dsymutil, so we're\n-    // preserving that temporarily, but we're likely to switch the default\n-    // soon.\n-    run_dsymutil: bool = (true, parse_bool, [TRACKED],\n-        \"if on Mac, run `dsymutil` and delete intermediate object files (default: yes)\"),\n     sanitizer: SanitizerSet = (SanitizerSet::empty(), parse_sanitizers, [TRACKED],\n         \"use a sanitizer\"),\n     sanitizer_memory_track_origins: usize = (0, parse_sanitizer_memory_track_origins, [TRACKED],\n@@ -1112,8 +1105,6 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"hash algorithm of source files in debug info (`md5`, `sha1`, or `sha256`)\"),\n     strip: Strip = (Strip::None, parse_strip, [UNTRACKED],\n         \"tell the linker which information to strip (`none` (default), `debuginfo` or `symbols`)\"),\n-    split_dwarf: SplitDwarfKind = (SplitDwarfKind::None, parse_split_dwarf_kind, [UNTRACKED],\n-        \"enable generation of split dwarf\"),\n     split_dwarf_inlining: bool = (true, parse_bool, [UNTRACKED],\n         \"provide minimal debug info in the object/executable to facilitate online \\\n          symbolication/stack traces in the absence of .dwo/.dwp files when using Split DWARF\"),"}, {"sha": "dad21e59502de2ca7f239b96d323af377992457e", "filename": "compiler/rustc_session/src/session.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/74500b99783d126e330184f0392a78f8b93b73ef/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74500b99783d126e330184f0392a78f8b93b73ef/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fsession.rs?ref=74500b99783d126e330184f0392a78f8b93b73ef", "patch": "@@ -28,7 +28,7 @@ use rustc_span::source_map::{FileLoader, MultiSpan, RealFileLoader, SourceMap, S\n use rustc_span::{sym, SourceFileHashAlgorithm, Symbol};\n use rustc_target::asm::InlineAsmArch;\n use rustc_target::spec::{CodeModel, PanicStrategy, RelocModel, RelroLevel};\n-use rustc_target::spec::{Target, TargetTriple, TlsModel};\n+use rustc_target::spec::{SplitDebuginfo, Target, TargetTriple, TlsModel};\n \n use std::cell::{self, RefCell};\n use std::env;\n@@ -804,6 +804,14 @@ impl Session {\n             )\n     }\n \n+    pub fn split_debuginfo(&self) -> SplitDebuginfo {\n+        self.opts.cg.split_debuginfo.unwrap_or(self.target.split_debuginfo)\n+    }\n+\n+    pub fn target_can_use_split_dwarf(&self) -> bool {\n+        !self.target.is_like_windows && !self.target.is_like_osx\n+    }\n+\n     pub fn must_not_eliminate_frame_pointers(&self) -> bool {\n         // \"mcount\" function relies on stack pointer.\n         // See <https://sourceware.org/binutils/docs/gprof/Implementation.html>."}, {"sha": "3b458962b3d07f47d69dc10eaec9224585c2ae87", "filename": "compiler/rustc_target/src/spec/apple_base.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/74500b99783d126e330184f0392a78f8b93b73ef/compiler%2Frustc_target%2Fsrc%2Fspec%2Fapple_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74500b99783d126e330184f0392a78f8b93b73ef/compiler%2Frustc_target%2Fsrc%2Fspec%2Fapple_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fapple_base.rs?ref=74500b99783d126e330184f0392a78f8b93b73ef", "patch": "@@ -1,6 +1,6 @@\n use std::env;\n \n-use crate::spec::{LinkArgs, TargetOptions};\n+use crate::spec::{LinkArgs, SplitDebuginfo, TargetOptions};\n \n pub fn opts(os: &str) -> TargetOptions {\n     // ELF TLS is only available in macOS 10.7+. If you try to compile for 10.6\n@@ -36,6 +36,10 @@ pub fn opts(os: &str) -> TargetOptions {\n         emit_debug_gdb_scripts: false,\n         eh_frame_header: false,\n \n+        // The historical default for macOS targets is to run `dsymutil` which\n+        // generates a packed version of debuginfo split from the main file.\n+        split_debuginfo: SplitDebuginfo::Packed,\n+\n         // This environment variable is pretty magical but is intended for\n         // producing deterministic builds. This was first discovered to be used\n         // by the `ar` tool as a way to control whether or not mtime entries in"}, {"sha": "0227febd294a0c3cdbd04f50a582c9794acc7f23", "filename": "compiler/rustc_target/src/spec/mod.rs", "status": "modified", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/74500b99783d126e330184f0392a78f8b93b73ef/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74500b99783d126e330184f0392a78f8b93b73ef/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs?ref=74500b99783d126e330184f0392a78f8b93b73ef", "patch": "@@ -448,6 +448,69 @@ impl fmt::Display for LinkOutputKind {\n \n pub type LinkArgs = BTreeMap<LinkerFlavor, Vec<String>>;\n \n+#[derive(Clone, Copy, Hash, Debug, PartialEq, Eq)]\n+pub enum SplitDebuginfo {\n+    /// Split debug-information is disabled, meaning that on supported platforms\n+    /// you can find all debug information in the executable itself. This is\n+    /// only supported for ELF effectively.\n+    ///\n+    /// * Windows - not supported\n+    /// * macOS - don't run `dsymutil`\n+    /// * ELF - `.dwarf_*` sections\n+    Off,\n+\n+    /// Split debug-information can be found in a \"packed\" location separate\n+    /// from the final artifact. This is supported on all platforms.\n+    ///\n+    /// * Windows - `*.pdb`\n+    /// * macOS - `*.dSYM` (run `dsymutil`)\n+    /// * ELF - `*.dwp` (run `rust-llvm-dwp`)\n+    Packed,\n+\n+    /// Split debug-information can be found in individual object files on the\n+    /// filesystem. The main executable may point to the object files.\n+    ///\n+    /// * Windows - not supported\n+    /// * macOS - supported, scattered object files\n+    /// * ELF - supported, scattered `*.dwo` files\n+    Unpacked,\n+}\n+\n+impl SplitDebuginfo {\n+    fn as_str(&self) -> &'static str {\n+        match self {\n+            SplitDebuginfo::Off => \"off\",\n+            SplitDebuginfo::Packed => \"packed\",\n+            SplitDebuginfo::Unpacked => \"unpacked\",\n+        }\n+    }\n+}\n+\n+impl FromStr for SplitDebuginfo {\n+    type Err = ();\n+\n+    fn from_str(s: &str) -> Result<SplitDebuginfo, ()> {\n+        Ok(match s {\n+            \"off\" => SplitDebuginfo::Off,\n+            \"unpacked\" => SplitDebuginfo::Unpacked,\n+            \"packed\" => SplitDebuginfo::Packed,\n+            _ => return Err(()),\n+        })\n+    }\n+}\n+\n+impl ToJson for SplitDebuginfo {\n+    fn to_json(&self) -> Json {\n+        self.as_str().to_json()\n+    }\n+}\n+\n+impl fmt::Display for SplitDebuginfo {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.write_str(self.as_str())\n+    }\n+}\n+\n macro_rules! supported_targets {\n     ( $(($( $triple:literal, )+ $module:ident ),)+ ) => {\n         $(mod $module;)+\n@@ -1085,6 +1148,10 @@ pub struct TargetOptions {\n     /// Is true if the target is an ARM architecture using thumb v1 which allows for\n     /// thumb and arm interworking.\n     pub has_thumb_interworking: bool,\n+\n+    /// How to handle split debug information, if at all. Specifying `None` has\n+    /// target-specific meaning.\n+    pub split_debuginfo: SplitDebuginfo,\n }\n \n impl Default for TargetOptions {\n@@ -1184,6 +1251,7 @@ impl Default for TargetOptions {\n             use_ctors_section: false,\n             eh_frame_header: true,\n             has_thumb_interworking: false,\n+            split_debuginfo: SplitDebuginfo::Off,\n         }\n     }\n }\n@@ -1382,6 +1450,18 @@ impl Target {\n                     Some(Ok(()))\n                 })).unwrap_or(Ok(()))\n             } );\n+            ($key_name:ident, SplitDebuginfo) => ( {\n+                let name = (stringify!($key_name)).replace(\"_\", \"-\");\n+                obj.find(&name[..]).and_then(|o| o.as_string().and_then(|s| {\n+                    match s.parse::<SplitDebuginfo>() {\n+                        Ok(level) => base.$key_name = level,\n+                        _ => return Some(Err(format!(\"'{}' is not a valid value for \\\n+                                                      split-debuginfo. Use 'off' or 'dsymutil'.\",\n+                                                      s))),\n+                    }\n+                    Some(Ok(()))\n+                })).unwrap_or(Ok(()))\n+            } );\n             ($key_name:ident, list) => ( {\n                 let name = (stringify!($key_name)).replace(\"_\", \"-\");\n                 if let Some(v) = obj.find(&name).and_then(Json::as_array) {\n@@ -1627,6 +1707,7 @@ impl Target {\n         key!(use_ctors_section, bool);\n         key!(eh_frame_header, bool);\n         key!(has_thumb_interworking, bool);\n+        key!(split_debuginfo, SplitDebuginfo)?;\n \n         // NB: The old name is deprecated, but support for it is retained for\n         // compatibility.\n@@ -1862,6 +1943,7 @@ impl ToJson for Target {\n         target_option_val!(use_ctors_section);\n         target_option_val!(eh_frame_header);\n         target_option_val!(has_thumb_interworking);\n+        target_option_val!(split_debuginfo);\n \n         if default.unsupported_abis != self.unsupported_abis {\n             d.insert("}, {"sha": "39c0d5f0bb4ff324af35da9b6329f499f7fa57cf", "filename": "compiler/rustc_target/src/spec/msvc_base.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/74500b99783d126e330184f0392a78f8b93b73ef/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmsvc_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74500b99783d126e330184f0392a78f8b93b73ef/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmsvc_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmsvc_base.rs?ref=74500b99783d126e330184f0392a78f8b93b73ef", "patch": "@@ -1,4 +1,4 @@\n-use crate::spec::{LinkArgs, LinkerFlavor, LldFlavor, TargetOptions};\n+use crate::spec::{LinkArgs, LinkerFlavor, LldFlavor, SplitDebuginfo, TargetOptions};\n \n pub fn opts() -> TargetOptions {\n     let pre_link_args_msvc = vec![\n@@ -27,6 +27,10 @@ pub fn opts() -> TargetOptions {\n         abi_return_struct_as_int: true,\n         emit_debug_gdb_scripts: false,\n \n+        // Currently this is the only supported method of debuginfo on MSVC\n+        // where `*.pdb` files show up next to the final artifact.\n+        split_debuginfo: SplitDebuginfo::Packed,\n+\n         ..Default::default()\n     }\n }"}, {"sha": "081f282edcf895a3f9b64f930e4aef67633ed654", "filename": "library/core/src/iter/adapters/flatten.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/74500b99783d126e330184f0392a78f8b93b73ef/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fflatten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74500b99783d126e330184f0392a78f8b93b73ef/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fflatten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fflatten.rs?ref=74500b99783d126e330184f0392a78f8b93b73ef", "patch": "@@ -265,7 +265,13 @@ where\n                 }\n             }\n             match self.iter.next() {\n-                None => return self.backiter.as_mut()?.next(),\n+                None => match self.backiter.as_mut()?.next() {\n+                    None => {\n+                        self.backiter = None;\n+                        return None;\n+                    }\n+                    elt @ Some(_) => return elt,\n+                },\n                 Some(inner) => self.frontiter = Some(inner.into_iter()),\n             }\n         }\n@@ -353,7 +359,13 @@ where\n                 }\n             }\n             match self.iter.next_back() {\n-                None => return self.frontiter.as_mut()?.next_back(),\n+                None => match self.frontiter.as_mut()?.next_back() {\n+                    None => {\n+                        self.frontiter = None;\n+                        return None;\n+                    }\n+                    elt @ Some(_) => return elt,\n+                },\n                 next => self.backiter = next.map(IntoIterator::into_iter),\n             }\n         }"}, {"sha": "4bbae6947bf66ed9b90a0f42b0cf541fff1158b4", "filename": "library/core/tests/iter/adapters/flatten.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/74500b99783d126e330184f0392a78f8b93b73ef/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Fflatten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74500b99783d126e330184f0392a78f8b93b73ef/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Fflatten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Fflatten.rs?ref=74500b99783d126e330184f0392a78f8b93b73ef", "patch": "@@ -64,6 +64,14 @@ fn test_flatten_non_fused_outer() {\n     assert_eq!(iter.next_back(), Some(1));\n     assert_eq!(iter.next(), Some(0));\n     assert_eq!(iter.next(), None);\n+    assert_eq!(iter.next(), None);\n+\n+    let mut iter = NonFused::new(once(0..2)).flatten();\n+\n+    assert_eq!(iter.next(), Some(0));\n+    assert_eq!(iter.next_back(), Some(1));\n+    assert_eq!(iter.next_back(), None);\n+    assert_eq!(iter.next_back(), None);\n }\n \n #[test]\n@@ -74,6 +82,15 @@ fn test_flatten_non_fused_inner() {\n     assert_eq!(iter.next(), Some(0));\n     assert_eq!(iter.next(), Some(1));\n     assert_eq!(iter.next(), None);\n+    assert_eq!(iter.next(), None);\n+\n+    let mut iter = once(0..1).chain(once(1..3)).flat_map(NonFused::new);\n+\n+    assert_eq!(iter.next(), Some(0));\n+    assert_eq!(iter.next_back(), Some(2));\n+    assert_eq!(iter.next_back(), Some(1));\n+    assert_eq!(iter.next_back(), None);\n+    assert_eq!(iter.next_back(), None);\n }\n \n #[test]"}, {"sha": "8576f57959a6f078c02572dba2576aa97f8e4f4e", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/74500b99783d126e330184f0392a78f8b93b73ef/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/74500b99783d126e330184f0392a78f8b93b73ef/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=74500b99783d126e330184f0392a78f8b93b73ef", "patch": "@@ -833,6 +833,7 @@ def build_bootstrap(self):\n         target_linker = self.get_toml(\"linker\", build_section)\n         if target_linker is not None:\n             env[\"RUSTFLAGS\"] += \" -C linker=\" + target_linker\n+        # cfg(bootstrap): Add `-Wsemicolon_in_expressions_from_macros` after the next beta bump\n         env[\"RUSTFLAGS\"] += \" -Wrust_2018_idioms -Wunused_lifetimes\"\n         if self.get_toml(\"deny-warnings\", \"rust\") != \"false\":\n             env[\"RUSTFLAGS\"] += \" -Dwarnings\""}, {"sha": "f1a160250dbe1cbbcde70c617de27306b4c13c9c", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/74500b99783d126e330184f0392a78f8b93b73ef/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74500b99783d126e330184f0392a78f8b93b73ef/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=74500b99783d126e330184f0392a78f8b93b73ef", "patch": "@@ -1139,10 +1139,18 @@ impl<'a> Builder<'a> {\n         // itself, we skip it by default since we know it's safe to do so in that case.\n         // See https://github.com/rust-lang/rust/issues/79361 for more info on this flag.\n         if target.contains(\"apple\") {\n-            if self.config.rust_run_dsymutil {\n-                rustflags.arg(\"-Zrun-dsymutil=yes\");\n+            if stage == 0 {\n+                if self.config.rust_run_dsymutil {\n+                    rustflags.arg(\"-Zrun-dsymutil=yes\");\n+                } else {\n+                    rustflags.arg(\"-Zrun-dsymutil=no\");\n+                }\n             } else {\n-                rustflags.arg(\"-Zrun-dsymutil=no\");\n+                if self.config.rust_run_dsymutil {\n+                    rustflags.arg(\"-Csplit-debuginfo=packed\");\n+                } else {\n+                    rustflags.arg(\"-Csplit-debuginfo=unpacked\");\n+                }\n             }\n         }\n \n@@ -1250,6 +1258,12 @@ impl<'a> Builder<'a> {\n             // some code doesn't go through this `rustc` wrapper.\n             lint_flags.push(\"-Wrust_2018_idioms\");\n             lint_flags.push(\"-Wunused_lifetimes\");\n+            // cfg(bootstrap): unconditionally enable this warning after the next beta bump\n+            // This is currently disabled for the stage1 libstd, since build scripts\n+            // will end up using the bootstrap compiler (which doesn't yet support this lint)\n+            if compiler.stage != 0 && mode != Mode::Std {\n+                lint_flags.push(\"-Wsemicolon_in_expressions_from_macros\");\n+            }\n \n             if self.config.deny_warnings {\n                 lint_flags.push(\"-Dwarnings\");"}, {"sha": "51e7d987d9d82c36c1cfc45faa6d14a60cd4fd82", "filename": "src/doc/rustc/src/codegen-options/index.md", "status": "modified", "additions": 29, "deletions": 1, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/74500b99783d126e330184f0392a78f8b93b73ef/src%2Fdoc%2Frustc%2Fsrc%2Fcodegen-options%2Findex.md", "raw_url": "https://github.com/rust-lang/rust/raw/74500b99783d126e330184f0392a78f8b93b73ef/src%2Fdoc%2Frustc%2Fsrc%2Fcodegen-options%2Findex.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fcodegen-options%2Findex.md?ref=74500b99783d126e330184f0392a78f8b93b73ef", "patch": "@@ -492,14 +492,42 @@ point instructions in software. It takes one of the following values:\n * `y`, `yes`, `on`, or no value: use soft floats.\n * `n`, `no`, or `off`: use hardware floats (the default).\n \n+## split-debuginfo\n+\n+This option controls the emission of \"split debuginfo\" for debug information\n+that `rustc` generates. The default behavior of this option is\n+platform-specific, and not all possible values for this option work on all\n+platform. Possible values are:\n+\n+* `off` - This is the default for platforms with ELF binaries and windows-gnu\n+  (not Windows MSVC and not macOS). This typically means that dwarf debug\n+  information can be found in the final artifact in sections of the executable.\n+  This option is not supported on Windows MSVC. On macOS this options prevents\n+  the final execution of `dsymutil` to generate debuginfo.\n+\n+* `packed` - This is the default for Windows MSVC and macOS platforms. The term\n+  \"packed\" here means that all the debug information is packed into a separate\n+  file from the main executable. On Windows MSVC this is a `*.pdb` file, on\n+  macOS this is a `*.dSYM` folder, and on other platforms this is a `*.dwp`\n+  files.\n+\n+* `unpacked` - This means that debug information will be found in separate\n+  files for each compilation unit (object file). This is not supported on\n+  Windows MSVC. On macOS this means the original object files will contain\n+  debug information. On other Unix platforms this means that `*.dwo` files will\n+  contain debug information.\n+\n+Note that `packed` and `unpacked` gated behind `-Zunstable-options` on\n+non-macOS platforms at this time.\n+\n ## target-cpu\n \n This instructs `rustc` to generate code specifically for a particular processor.\n \n You can run `rustc --print target-cpus` to see the valid options to pass\n here. Each target has a default base CPU. Special values include:\n \n-* `native` can be passed to use the processor of the host machine. \n+* `native` can be passed to use the processor of the host machine.\n * `generic` refers to an LLVM target with minimal features but modern tuning.\n \n ## target-feature"}, {"sha": "db64b31f31cfcf81dc51224d130870e5f8b8ba84", "filename": "src/librustdoc/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/74500b99783d126e330184f0392a78f8b93b73ef/src%2Flibrustdoc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/74500b99783d126e330184f0392a78f8b93b73ef/src%2Flibrustdoc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2FCargo.toml?ref=74500b99783d126e330184f0392a78f8b93b73ef", "patch": "@@ -17,6 +17,7 @@ smallvec = \"1.0\"\n tempfile = \"3\"\n itertools = \"0.9\"\n regex = \"1\"\n+rustdoc-json-types = { path = \"../rustdoc-json-types\" }\n \n [dev-dependencies]\n expect-test = \"1.0\""}, {"sha": "74b61f1555c6f91a8378c9a715a2b8ecc43e316c", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/74500b99783d126e330184f0392a78f8b93b73ef/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74500b99783d126e330184f0392a78f8b93b73ef/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=74500b99783d126e330184f0392a78f8b93b73ef", "patch": "@@ -659,6 +659,8 @@ fn fmt_type(\n     use_absolute: bool,\n     cache: &Cache,\n ) -> fmt::Result {\n+    debug!(\"fmt_type(t = {:?})\", t);\n+\n     match *t {\n         clean::Generic(name) => write!(f, \"{}\", name),\n         clean::ResolvedPath { did, ref param_names, ref path, is_generic } => {\n@@ -675,21 +677,22 @@ fn fmt_type(\n             if f.alternate() {\n                 write!(\n                     f,\n-                    \"{}{:#}fn{:#}{:#}\",\n+                    \"{:#}{}{:#}fn{:#}\",\n+                    decl.print_hrtb_with_space(cache),\n                     decl.unsafety.print_with_space(),\n                     print_abi_with_space(decl.abi),\n-                    decl.print_generic_params(cache),\n                     decl.decl.print(cache)\n                 )\n             } else {\n                 write!(\n                     f,\n-                    \"{}{}\",\n+                    \"{}{}{}\",\n+                    decl.print_hrtb_with_space(cache),\n                     decl.unsafety.print_with_space(),\n                     print_abi_with_space(decl.abi)\n                 )?;\n                 primitive_link(f, PrimitiveType::Fn, \"fn\", cache)?;\n-                write!(f, \"{}{}\", decl.print_generic_params(cache), decl.decl.print(cache))\n+                write!(f, \"{}\", decl.decl.print(cache))\n             }\n         }\n         clean::Tuple(ref typs) => {\n@@ -992,8 +995,14 @@ impl clean::FnRetTy {\n }\n \n impl clean::BareFunctionDecl {\n-    fn print_generic_params<'a>(&'a self, cache: &'a Cache) -> impl fmt::Display + 'a {\n-        comma_sep(self.generic_params.iter().map(move |g| g.print(cache)))\n+    fn print_hrtb_with_space<'a>(&'a self, cache: &'a Cache) -> impl fmt::Display + 'a {\n+        display_fn(move |f| {\n+            if !self.generic_params.is_empty() {\n+                write!(f, \"for<{}> \", comma_sep(self.generic_params.iter().map(|g| g.print(cache))))\n+            } else {\n+                Ok(())\n+            }\n+        })\n     }\n }\n "}, {"sha": "df3701487d7978aa39c1fe494aac49e529b80ad9", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/74500b99783d126e330184f0392a78f8b93b73ef/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74500b99783d126e330184f0392a78f8b93b73ef/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=74500b99783d126e330184f0392a78f8b93b73ef", "patch": "@@ -1345,6 +1345,7 @@ impl AllTypes {\n         write!(\n             f,\n             \"<h1 class=\\\"fqn\\\">\\\n+                 <span class=\\\"in-band\\\">List of all items</span>\\\n                  <span class=\\\"out-of-band\\\">\\\n                      <span id=\\\"render-detail\\\">\\\n                          <a id=\\\"toggle-all-docs\\\" href=\\\"javascript:void(0)\\\" \\\n@@ -1353,7 +1354,6 @@ impl AllTypes {\n                          </a>\\\n                      </span>\n                  </span>\n-                 <span class=\\\"in-band\\\">List of all items</span>\\\n              </h1>\"\n         );\n         print_entries(f, &self.structs, \"Structs\", \"structs\");\n@@ -1711,36 +1711,7 @@ where\n fn print_item(cx: &Context<'_>, item: &clean::Item, buf: &mut Buffer) {\n     debug_assert!(!item.is_stripped());\n     // Write the breadcrumb trail header for the top\n-    write!(buf, \"<h1 class=\\\"fqn\\\"><span class=\\\"out-of-band\\\">\");\n-    render_stability_since_raw(\n-        buf,\n-        item.stable_since(cx.tcx()).as_deref(),\n-        item.const_stable_since(cx.tcx()).as_deref(),\n-        None,\n-        None,\n-    );\n-    write!(\n-        buf,\n-        \"<span id=\\\"render-detail\\\">\\\n-                <a id=\\\"toggle-all-docs\\\" href=\\\"javascript:void(0)\\\" \\\n-                    title=\\\"collapse all docs\\\">\\\n-                    [<span class=\\\"inner\\\">&#x2212;</span>]\\\n-                </a>\\\n-            </span>\"\n-    );\n-\n-    // Write `src` tag\n-    //\n-    // When this item is part of a `crate use` in a downstream crate, the\n-    // [src] link in the downstream documentation will actually come back to\n-    // this page, and this link will be auto-clicked. The `id` attribute is\n-    // used to find the link to auto-click.\n-    if cx.shared.include_sources && !item.is_primitive() {\n-        write_srclink(cx, item, buf);\n-    }\n-\n-    write!(buf, \"</span>\"); // out-of-band\n-    write!(buf, \"<span class=\\\"in-band\\\">\");\n+    write!(buf, \"<h1 class=\\\"fqn\\\"><span class=\\\"in-band\\\">\");\n     let name = match *item.kind {\n         clean::ModuleItem(ref m) => {\n             if m.is_crate {\n@@ -1788,7 +1759,36 @@ fn print_item(cx: &Context<'_>, item: &clean::Item, buf: &mut Buffer) {\n     }\n     write!(buf, \"<a class=\\\"{}\\\" href=\\\"\\\">{}</a>\", item.type_(), item.name.as_ref().unwrap());\n \n-    write!(buf, \"</span></h1>\"); // in-band\n+    write!(buf, \"</span>\"); // in-band\n+    write!(buf, \"<span class=\\\"out-of-band\\\">\");\n+    render_stability_since_raw(\n+        buf,\n+        item.stable_since(cx.tcx()).as_deref(),\n+        item.const_stable_since(cx.tcx()).as_deref(),\n+        None,\n+        None,\n+    );\n+    write!(\n+        buf,\n+        \"<span id=\\\"render-detail\\\">\\\n+                <a id=\\\"toggle-all-docs\\\" href=\\\"javascript:void(0)\\\" \\\n+                    title=\\\"collapse all docs\\\">\\\n+                    [<span class=\\\"inner\\\">&#x2212;</span>]\\\n+                </a>\\\n+            </span>\"\n+    );\n+\n+    // Write `src` tag\n+    //\n+    // When this item is part of a `crate use` in a downstream crate, the\n+    // [src] link in the downstream documentation will actually come back to\n+    // this page, and this link will be auto-clicked. The `id` attribute is\n+    // used to find the link to auto-click.\n+    if cx.shared.include_sources && !item.is_primitive() {\n+        write_srclink(cx, item, buf);\n+    }\n+\n+    write!(buf, \"</span></h1>\"); // out-of-band\n \n     match *item.kind {\n         clean::ModuleItem(ref m) => item_module(buf, cx, item, &m.items),"}, {"sha": "b2e5c8834b8ffa65236119bd00d47cd2afd801b3", "filename": "src/librustdoc/json/conversions.rs", "status": "modified", "additions": 37, "deletions": 46, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/74500b99783d126e330184f0392a78f8b93b73ef/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74500b99783d126e330184f0392a78f8b93b73ef/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fconversions.rs?ref=74500b99783d126e330184f0392a78f8b93b73ef", "patch": "@@ -9,9 +9,10 @@ use rustc_hir::def::CtorKind;\n use rustc_span::def_id::{DefId, CRATE_DEF_INDEX};\n use rustc_span::Pos;\n \n+use rustdoc_json_types::*;\n+\n use crate::clean;\n use crate::formats::item_type::ItemType;\n-use crate::json::types::*;\n use crate::json::JsonRenderer;\n \n impl JsonRenderer<'_> {\n@@ -22,7 +23,7 @@ impl JsonRenderer<'_> {\n         match *kind {\n             clean::StrippedItem(_) => None,\n             kind => Some(Item {\n-                id: def_id.into(),\n+                id: from_def_id(def_id),\n                 crate_id: def_id.krate.as_u32(),\n                 name: name.map(|sym| sym.to_string()),\n                 source: self.convert_span(source),\n@@ -32,15 +33,15 @@ impl JsonRenderer<'_> {\n                     .links\n                     .into_iter()\n                     .filter_map(|clean::ItemLink { link, did, .. }| {\n-                        did.map(|did| (link, did.into()))\n+                        did.map(|did| (link, from_def_id(did)))\n                     })\n                     .collect(),\n                 attrs: attrs\n                     .other_attrs\n                     .iter()\n                     .map(rustc_ast_pretty::pprust::attribute_to_string)\n                     .collect(),\n-                deprecation: deprecation.map(Into::into),\n+                deprecation: deprecation.map(from_deprecation),\n                 kind: item_type.into(),\n                 inner: kind.into(),\n             }),\n@@ -74,19 +75,17 @@ impl JsonRenderer<'_> {\n             Inherited => Visibility::Default,\n             Restricted(did) if did.index == CRATE_DEF_INDEX => Visibility::Crate,\n             Restricted(did) => Visibility::Restricted {\n-                parent: did.into(),\n+                parent: from_def_id(did),\n                 path: self.tcx.def_path(did).to_string_no_crate_verbose(),\n             },\n         }\n     }\n }\n \n-impl From<rustc_attr::Deprecation> for Deprecation {\n-    fn from(deprecation: rustc_attr::Deprecation) -> Self {\n-        #[rustfmt::skip]\n-        let rustc_attr::Deprecation { since, note, is_since_rustc_version: _, suggestion: _ } = deprecation;\n-        Deprecation { since: since.map(|s| s.to_string()), note: note.map(|s| s.to_string()) }\n-    }\n+crate fn from_deprecation(deprecation: rustc_attr::Deprecation) -> Deprecation {\n+    #[rustfmt::skip]\n+    let rustc_attr::Deprecation { since, note, is_since_rustc_version: _, suggestion: _ } = deprecation;\n+    Deprecation { since: since.map(|s| s.to_string()), note: note.map(|s| s.to_string()) }\n }\n \n impl From<clean::GenericArgs> for GenericArgs {\n@@ -141,10 +140,8 @@ impl From<clean::TypeBindingKind> for TypeBindingKind {\n     }\n }\n \n-impl From<DefId> for Id {\n-    fn from(did: DefId) -> Self {\n-        Id(format!(\"{}:{}\", did.krate.as_u32(), u32::from(did.index)))\n-    }\n+crate fn from_def_id(did: DefId) -> Id {\n+    Id(format!(\"{}:{}\", did.krate.as_u32(), u32::from(did.index)))\n }\n \n impl From<clean::ItemKind> for ItemEnum {\n@@ -199,7 +196,7 @@ impl From<clean::Struct> for Struct {\n     fn from(struct_: clean::Struct) -> Self {\n         let clean::Struct { struct_type, generics, fields, fields_stripped } = struct_;\n         Struct {\n-            struct_type: struct_type.into(),\n+            struct_type: from_ctor_kind(struct_type),\n             generics: generics.into(),\n             fields_stripped,\n             fields: ids(fields),\n@@ -221,13 +218,11 @@ impl From<clean::Union> for Struct {\n     }\n }\n \n-impl From<CtorKind> for StructType {\n-    fn from(struct_type: CtorKind) -> Self {\n-        match struct_type {\n-            CtorKind::Fictive => StructType::Plain,\n-            CtorKind::Fn => StructType::Tuple,\n-            CtorKind::Const => StructType::Unit,\n-        }\n+crate fn from_ctor_kind(struct_type: CtorKind) -> StructType {\n+    match struct_type {\n+        CtorKind::Fictive => StructType::Plain,\n+        CtorKind::Fn => StructType::Tuple,\n+        CtorKind::Const => StructType::Unit,\n     }\n }\n \n@@ -310,22 +305,20 @@ impl From<clean::GenericBound> for GenericBound {\n                 GenericBound::TraitBound {\n                     trait_: trait_.into(),\n                     generic_params: generic_params.into_iter().map(Into::into).collect(),\n-                    modifier: modifier.into(),\n+                    modifier: from_trait_bound_modifier(modifier),\n                 }\n             }\n             Outlives(lifetime) => GenericBound::Outlives(lifetime.0.to_string()),\n         }\n     }\n }\n \n-impl From<rustc_hir::TraitBoundModifier> for TraitBoundModifier {\n-    fn from(modifier: rustc_hir::TraitBoundModifier) -> Self {\n-        use rustc_hir::TraitBoundModifier::*;\n-        match modifier {\n-            None => TraitBoundModifier::None,\n-            Maybe => TraitBoundModifier::Maybe,\n-            MaybeConst => TraitBoundModifier::MaybeConst,\n-        }\n+crate fn from_trait_bound_modifier(modifier: rustc_hir::TraitBoundModifier) -> TraitBoundModifier {\n+    use rustc_hir::TraitBoundModifier::*;\n+    match modifier {\n+        None => TraitBoundModifier::None,\n+        Maybe => TraitBoundModifier::Maybe,\n+        MaybeConst => TraitBoundModifier::MaybeConst,\n     }\n }\n \n@@ -335,7 +328,7 @@ impl From<clean::Type> for Type {\n         match ty {\n             ResolvedPath { path, param_names, did, is_generic: _ } => Type::ResolvedPath {\n                 name: path.whole_name(),\n-                id: did.into(),\n+                id: from_def_id(did),\n                 args: path.segments.last().map(|args| Box::new(args.clone().args.into())),\n                 param_names: param_names\n                     .map(|v| v.into_iter().map(Into::into).collect())\n@@ -470,7 +463,7 @@ impl From<clean::VariantStruct> for Struct {\n     fn from(struct_: clean::VariantStruct) -> Self {\n         let clean::VariantStruct { struct_type, fields, fields_stripped } = struct_;\n         Struct {\n-            struct_type: struct_type.into(),\n+            struct_type: from_ctor_kind(struct_type),\n             generics: Default::default(),\n             fields_stripped,\n             fields: ids(fields),\n@@ -497,13 +490,13 @@ impl From<clean::Import> for Import {\n             Simple(s) => Import {\n                 span: import.source.path.whole_name(),\n                 name: s.to_string(),\n-                id: import.source.did.map(Into::into),\n+                id: import.source.did.map(from_def_id),\n                 glob: false,\n             },\n             Glob => Import {\n                 span: import.source.path.whole_name(),\n                 name: import.source.path.last_name().to_string(),\n-                id: import.source.did.map(Into::into),\n+                id: import.source.did.map(from_def_id),\n                 glob: true,\n             },\n         }\n@@ -513,20 +506,18 @@ impl From<clean::Import> for Import {\n impl From<clean::ProcMacro> for ProcMacro {\n     fn from(mac: clean::ProcMacro) -> Self {\n         ProcMacro {\n-            kind: mac.kind.into(),\n+            kind: from_macro_kind(mac.kind),\n             helpers: mac.helpers.iter().map(|x| x.to_string()).collect(),\n         }\n     }\n }\n \n-impl From<rustc_span::hygiene::MacroKind> for MacroKind {\n-    fn from(kind: rustc_span::hygiene::MacroKind) -> Self {\n-        use rustc_span::hygiene::MacroKind::*;\n-        match kind {\n-            Bang => MacroKind::Bang,\n-            Attr => MacroKind::Attr,\n-            Derive => MacroKind::Derive,\n-        }\n+crate fn from_macro_kind(kind: rustc_span::hygiene::MacroKind) -> MacroKind {\n+    use rustc_span::hygiene::MacroKind::*;\n+    match kind {\n+        Bang => MacroKind::Bang,\n+        Attr => MacroKind::Attr,\n+        Derive => MacroKind::Derive,\n     }\n }\n \n@@ -599,5 +590,5 @@ impl From<ItemType> for ItemKind {\n }\n \n fn ids(items: impl IntoIterator<Item = clean::Item>) -> Vec<Id> {\n-    items.into_iter().filter(|x| !x.is_stripped()).map(|i| i.def_id.into()).collect()\n+    items.into_iter().filter(|x| !x.is_stripped()).map(|i| from_def_id(i.def_id)).collect()\n }"}, {"sha": "a7c875fb7480bacb4bf7a38108e967d72cbbf73c", "filename": "src/librustdoc/json/mod.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/74500b99783d126e330184f0392a78f8b93b73ef/src%2Flibrustdoc%2Fjson%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74500b99783d126e330184f0392a78f8b93b73ef/src%2Flibrustdoc%2Fjson%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fmod.rs?ref=74500b99783d126e330184f0392a78f8b93b73ef", "patch": "@@ -5,7 +5,6 @@\n //! docs for usage and details.\n \n mod conversions;\n-pub mod types;\n \n use std::cell::RefCell;\n use std::fs::File;\n@@ -17,12 +16,15 @@ use rustc_middle::ty::TyCtxt;\n use rustc_session::Session;\n use rustc_span::edition::Edition;\n \n+use rustdoc_json_types as types;\n+\n use crate::clean;\n use crate::config::{RenderInfo, RenderOptions};\n use crate::error::Error;\n use crate::formats::cache::Cache;\n use crate::formats::FormatRenderer;\n use crate::html::render::cache::ExternalLocation;\n+use crate::json::conversions::from_def_id;\n \n #[derive(Clone)]\n crate struct JsonRenderer<'tcx> {\n@@ -50,7 +52,7 @@ impl JsonRenderer<'_> {\n                     .map(|i| {\n                         let item = &i.impl_item;\n                         self.item(item.clone()).unwrap();\n-                        item.def_id.into()\n+                        from_def_id(item.def_id)\n                     })\n                     .collect()\n             })\n@@ -68,7 +70,7 @@ impl JsonRenderer<'_> {\n                         let item = &i.impl_item;\n                         if item.def_id.is_local() {\n                             self.item(item.clone()).unwrap();\n-                            Some(item.def_id.into())\n+                            Some(from_def_id(item.def_id))\n                         } else {\n                             None\n                         }\n@@ -87,9 +89,9 @@ impl JsonRenderer<'_> {\n                 if !id.is_local() {\n                     trait_item.items.clone().into_iter().for_each(|i| self.item(i).unwrap());\n                     Some((\n-                        id.into(),\n+                        from_def_id(id),\n                         types::Item {\n-                            id: id.into(),\n+                            id: from_def_id(id),\n                             crate_id: id.krate.as_u32(),\n                             name: self\n                                 .cache\n@@ -163,7 +165,7 @@ impl<'tcx> FormatRenderer<'tcx> for JsonRenderer<'tcx> {\n             } else if let types::ItemEnum::EnumItem(ref mut e) = new_item.inner {\n                 e.impls = self.get_impls(id)\n             }\n-            let removed = self.index.borrow_mut().insert(id.into(), new_item.clone());\n+            let removed = self.index.borrow_mut().insert(from_def_id(id), new_item.clone());\n             // FIXME(adotinthevoid): Currently, the index is duplicated. This is a sanity check\n             // to make sure the items are unique.\n             if let Some(old_item) = removed {\n@@ -203,11 +205,14 @@ impl<'tcx> FormatRenderer<'tcx> for JsonRenderer<'tcx> {\n         debug!(\"Done with crate\");\n         let mut index = (*self.index).clone().into_inner();\n         index.extend(self.get_trait_items());\n+        // This needs to be the default HashMap for compatibility with the public interface for\n+        // rustdoc-json\n+        #[allow(rustc::default_hash_types)]\n         let output = types::Crate {\n             root: types::Id(String::from(\"0:0\")),\n             crate_version: krate.version.clone(),\n             includes_private: self.cache.document_private,\n-            index,\n+            index: index.into_iter().collect(),\n             paths: self\n                 .cache\n                 .paths\n@@ -216,7 +221,7 @@ impl<'tcx> FormatRenderer<'tcx> for JsonRenderer<'tcx> {\n                 .chain(self.cache.external_paths.clone().into_iter())\n                 .map(|(k, (path, kind))| {\n                     (\n-                        k.into(),\n+                        from_def_id(k),\n                         types::ItemSummary { crate_id: k.krate.as_u32(), path, kind: kind.into() },\n                     )\n                 })"}, {"sha": "7bba16a68b96c175fa8b30df87bf1ed1285f5a8d", "filename": "src/rustdoc-json-types/Cargo.toml", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/74500b99783d126e330184f0392a78f8b93b73ef/src%2Frustdoc-json-types%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/74500b99783d126e330184f0392a78f8b93b73ef/src%2Frustdoc-json-types%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc-json-types%2FCargo.toml?ref=74500b99783d126e330184f0392a78f8b93b73ef", "patch": "@@ -0,0 +1,11 @@\n+[package]\n+name = \"rustdoc-json-types\"\n+version = \"0.1.0\"\n+authors = [\"The Rust Project Developers\"]\n+edition = \"2018\"\n+\n+[lib]\n+path = \"lib.rs\"\n+\n+[dependencies]\n+serde = { version = \"1.0\", features = [\"derive\"] }"}, {"sha": "1e67d37655c6eaae31a0bd95ec190a8abcf4d53e", "filename": "src/rustdoc-json-types/README.md", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/74500b99783d126e330184f0392a78f8b93b73ef/src%2Frustdoc-json-types%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/74500b99783d126e330184f0392a78f8b93b73ef/src%2Frustdoc-json-types%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc-json-types%2FREADME.md?ref=74500b99783d126e330184f0392a78f8b93b73ef", "patch": "@@ -0,0 +1,12 @@\n+# Rustdoc JSON Types\n+\n+This crate exposes the Rustdoc JSON API as a set of types with serde implementations.\n+These types are part of the public interface of the rustdoc JSON output, and making them\n+their own crate allows them to be versioned and distributed without having to depend on\n+any rustc/rustdoc internals. This way, consumers can rely on this crate for both documentation\n+of the output, and as a way to read the output easily, and its versioning is intended to\n+follow semver guarantees about the version of the format. JSON format X will always be\n+compatible with rustdoc-json-types version N.\n+\n+Currently, this crate is only used by rustdoc itself. Upon the stabilization of\n+rustdoc-json, it may be distributed separately for consumers of the API."}, {"sha": "3fb2a32d5a0a33fc82d7badd7656d9a7b08eaca6", "filename": "src/rustdoc-json-types/lib.rs", "status": "renamed", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/74500b99783d126e330184f0392a78f8b93b73ef/src%2Frustdoc-json-types%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74500b99783d126e330184f0392a78f8b93b73ef/src%2Frustdoc-json-types%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc-json-types%2Flib.rs?ref=74500b99783d126e330184f0392a78f8b93b73ef", "patch": "@@ -3,9 +3,9 @@\n //! These types are the public API exposed through the `--output-format json` flag. The [`Crate`]\n //! struct is the root of the JSON blob and all other items are contained within.\n \n+use std::collections::HashMap;\n use std::path::PathBuf;\n \n-use rustc_data_structures::fx::FxHashMap;\n use serde::{Deserialize, Serialize};\n \n /// A `Crate` is the root of the emitted JSON blob. It contains all type/documentation information\n@@ -21,11 +21,11 @@ pub struct Crate {\n     pub includes_private: bool,\n     /// A collection of all items in the local crate as well as some external traits and their\n     /// items that are referenced locally.\n-    pub index: FxHashMap<Id, Item>,\n+    pub index: HashMap<Id, Item>,\n     /// Maps IDs to fully qualified paths and other info helpful for generating links.\n-    pub paths: FxHashMap<Id, ItemSummary>,\n+    pub paths: HashMap<Id, ItemSummary>,\n     /// Maps `crate_id` of items to a crate name and html_root_url if it exists.\n-    pub external_crates: FxHashMap<u32, ExternalCrate>,\n+    pub external_crates: HashMap<u32, ExternalCrate>,\n     /// A single version number to be used in the future when making backwards incompatible changes\n     /// to the JSON output.\n     pub format_version: u32,\n@@ -72,7 +72,7 @@ pub struct Item {\n     /// Some(\"\") if there is some documentation but it is empty (EG `#[doc = \"\"]`).\n     pub docs: Option<String>,\n     /// This mapping resolves [intra-doc links](https://github.com/rust-lang/rfcs/blob/master/text/1946-intra-rustdoc-links.md) from the docstring to their IDs\n-    pub links: FxHashMap<String, Id>,\n+    pub links: HashMap<String, Id>,\n     /// Stringified versions of the attributes on this item (e.g. `\"#[inline]\"`)\n     pub attrs: Vec<String>,\n     pub deprecation: Option<Deprecation>,", "previous_filename": "src/librustdoc/json/types.rs"}, {"sha": "e8e62efe01c140de3ddc5c462469aa06859ac20d", "filename": "src/test/run-make-fulldeps/split-debuginfo/Makefile", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftest%2Frun-make-fulldeps%2Fsplit-debuginfo%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftest%2Frun-make-fulldeps%2Fsplit-debuginfo%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fsplit-debuginfo%2FMakefile?ref=74500b99783d126e330184f0392a78f8b93b73ef", "patch": "@@ -0,0 +1,59 @@\n+-include ../tools.mk\n+\n+all: off packed unpacked\n+\n+ifeq ($(UNAME),Darwin)\n+# If disabled, don't run dsymutil\n+off:\n+\trm -rf $(TMPDIR)/*.dSYM\n+\t$(RUSTC) foo.rs -g -C split-debuginfo=off\n+\t[ ! -d $(TMPDIR)/foo.dSYM ]\n+\n+# Packed by default, but only if debuginfo is requested\n+packed:\n+\trm -rf $(TMPDIR)/*.dSYM\n+\t$(RUSTC) foo.rs\n+\t[ ! -d $(TMPDIR)/foo.dSYM ]\n+\trm -rf $(TMPDIR)/*.dSYM\n+\t$(RUSTC) foo.rs -g\n+\t[ -d $(TMPDIR)/foo.dSYM ]\n+\trm -rf $(TMPDIR)/*.dSYM\n+\t$(RUSTC) foo.rs -g -C split-debuginfo=packed\n+\t[ -d $(TMPDIR)/foo.dSYM ]\n+\trm -rf $(TMPDIR)/*.dSYM\n+\n+# Object files are preserved with unpacked and `dsymutil` isn't run\n+unpacked:\n+\t$(RUSTC) foo.rs -g -C split-debuginfo=unpacked\n+\tls $(TMPDIR)/*.o\n+\t[ ! -d $(TMPDIR)/foo.dSYM ]\n+else\n+ifdef IS_WINDOWS\n+# Windows only supports =off\n+off:\n+packed:\n+unpacked:\n+else\n+# If disabled, don't run dsymutil\n+off:\n+\t$(RUSTC) foo.rs -g -C split-debuginfo=off -Z unstable-options\n+\t[ ! -f $(TMPDIR)/*.dwp ]\n+\t[ ! -f $(TMPDIR)/*.dwo ]\n+\n+\t$(RUSTC) foo.rs -g\n+\t[ ! -f $(TMPDIR)/*.dwp ]\n+\t[ ! -f $(TMPDIR)/*.dwo ]\n+\n+packed:\n+\t$(RUSTC) foo.rs -g -C split-debuginfo=packed -Z unstable-options\n+\tls $(TMPDIR)/*.dwp\n+\tls $(TMPDIR)/*.dwo && exit 1 || exit 0\n+\trm -rf $(TMPDIR)/*.dwp\n+\n+unpacked:\n+\t$(RUSTC) foo.rs -g -C split-debuginfo=unpacked -Z unstable-options\n+\tls $(TMPDIR)/*.dwp && exit 1 || exit 0\n+\tls $(TMPDIR)/*.dwo\n+\trm -rf $(TMPDIR)/*.dwo\n+endif\n+endif"}, {"sha": "f328e4d9d04c31d0d70d16d21a07d1613be9d577", "filename": "src/test/run-make-fulldeps/split-debuginfo/foo.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftest%2Frun-make-fulldeps%2Fsplit-debuginfo%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftest%2Frun-make-fulldeps%2Fsplit-debuginfo%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fsplit-debuginfo%2Ffoo.rs?ref=74500b99783d126e330184f0392a78f8b93b73ef", "patch": "@@ -0,0 +1 @@\n+fn main() {}"}, {"sha": "93dfc8e76a961b5080a6feaf0b6112d3de4d86c1", "filename": "src/test/run-make-fulldeps/split-dwarf/Makefile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftest%2Frun-make-fulldeps%2Fsplit-dwarf%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftest%2Frun-make-fulldeps%2Fsplit-dwarf%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fsplit-dwarf%2FMakefile?ref=74500b99783d126e330184f0392a78f8b93b73ef", "patch": "@@ -3,6 +3,6 @@\n # only-linux\n \n all:\n-\t$(RUSTC) -Z split-dwarf=split foo.rs\n+\t$(RUSTC) -Z unstable-options -C split-debuginfo=packed foo.rs -g\n \trm $(TMPDIR)/foo.dwp\n \trm $(TMPDIR)/$(call BIN,foo)"}, {"sha": "f5e123aed9c4799df4e98dbf6533f8a1d3d24367", "filename": "src/test/rustdoc/fn-type.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftest%2Frustdoc%2Ffn-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftest%2Frustdoc%2Ffn-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Ffn-type.rs?ref=74500b99783d126e330184f0392a78f8b93b73ef", "patch": "@@ -0,0 +1,15 @@\n+// ignore-tidy-linelength\n+\n+#![crate_name = \"foo\"]\n+#![crate_type = \"lib\"]\n+\n+pub struct Foo<'a, T> {\n+    pub generic: fn(val: &T) -> T,\n+\n+    pub lifetime: fn(val: &'a i32) -> i32,\n+    pub hrtb_lifetime: for<'b, 'c> fn(one: &'b i32, two: &'c &'b i32) -> (&'b i32, &'c i32),\n+}\n+\n+// @has 'foo/struct.Foo.html' '//span[@id=\"structfield.generic\"]' \"generic: fn(val: &T) -> T\"\n+// @has 'foo/struct.Foo.html' '//span[@id=\"structfield.lifetime\"]' \"lifetime: fn(val: &'a i32) -> i32\"\n+// @has 'foo/struct.Foo.html' '//span[@id=\"structfield.hrtb_lifetime\"]' \"hrtb_lifetime: for<'b, 'c> fn(one: &'b i32, two: &'c &'b i32) -> (&'b i32, &'c i32)\""}, {"sha": "299794b63b2ea906e6152264cb4912fe1f1bbae1", "filename": "src/test/rustdoc/for-lifetime.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftest%2Frustdoc%2Ffor-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftest%2Frustdoc%2Ffor-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Ffor-lifetime.rs?ref=74500b99783d126e330184f0392a78f8b93b73ef", "patch": "@@ -0,0 +1,14 @@\n+// ignore-tidy-linelength\n+\n+#![crate_name = \"foo\"]\n+#![crate_type = \"lib\"]\n+\n+pub struct Foo {\n+    pub some_func: for<'a> fn(val: &'a i32) -> i32,\n+    pub some_trait: dyn for<'a> Trait<'a>,\n+}\n+\n+// @has foo/struct.Foo.html '//span[@id=\"structfield.some_func\"]' \"some_func: for<'a> fn(val: &'a i32) -> i32\"\n+// @has foo/struct.Foo.html '//span[@id=\"structfield.some_trait\"]' \"some_trait: dyn Trait<'a>\"\n+\n+pub trait Trait<'a> {}"}, {"sha": "b0a4c7722e3ceafa2883292986ae790a30dc8555", "filename": "src/test/ui/associated-consts/defaults-not-assumed-fail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftest%2Fui%2Fassociated-consts%2Fdefaults-not-assumed-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftest%2Fui%2Fassociated-consts%2Fdefaults-not-assumed-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-consts%2Fdefaults-not-assumed-fail.rs?ref=74500b99783d126e330184f0392a78f8b93b73ef", "patch": "@@ -31,7 +31,7 @@ impl Tr for u32 {\n fn main() {\n     assert_eq!(<() as Tr>::A, 255);\n     assert_eq!(<() as Tr>::B, 0);    // causes the error above\n-    //~^ ERROR evaluation of constant expression failed\n+    //~^ ERROR evaluation of constant value failed\n     //~| ERROR erroneous constant used\n \n     assert_eq!(<u8 as Tr>::A, 254);"}, {"sha": "cbaaed0508b98c0e605b83ff2b7b8f3d686031cd", "filename": "src/test/ui/associated-consts/defaults-not-assumed-fail.stderr", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftest%2Fui%2Fassociated-consts%2Fdefaults-not-assumed-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftest%2Fui%2Fassociated-consts%2Fdefaults-not-assumed-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-consts%2Fdefaults-not-assumed-fail.stderr?ref=74500b99783d126e330184f0392a78f8b93b73ef", "patch": "@@ -8,15 +8,11 @@ LL |     const B: u8 = Self::A + 1;\n    |\n    = note: `#[deny(const_err)]` on by default\n \n-error[E0080]: evaluation of constant expression failed\n-  --> $DIR/defaults-not-assumed-fail.rs:33:5\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/defaults-not-assumed-fail.rs:33:16\n    |\n LL |     assert_eq!(<() as Tr>::B, 0);    // causes the error above\n-   |     ^^^^^^^^^^^-------------^^^^^\n-   |                |\n-   |                referenced constant has errors\n-   |\n-   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+   |                ^^^^^^^^^^^^^ referenced constant has errors\n \n error: erroneous constant used\n   --> $DIR/defaults-not-assumed-fail.rs:33:5"}, {"sha": "492ff6356bcaf1f207934228432846cb20a385b1", "filename": "src/test/ui/backtrace-apple-no-dsymutil.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftest%2Fui%2Fbacktrace-apple-no-dsymutil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftest%2Fui%2Fbacktrace-apple-no-dsymutil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbacktrace-apple-no-dsymutil.rs?ref=74500b99783d126e330184f0392a78f8b93b73ef", "patch": "@@ -0,0 +1,30 @@\n+// run-pass\n+\n+// compile-flags:-g -Csplit-debuginfo=unpacked\n+// only-macos\n+\n+#![feature(backtrace)]\n+\n+use std::process::Command;\n+use std::str;\n+\n+#[inline(never)]\n+fn main() {\n+    let args: Vec<String> = std::env::args().collect();\n+    if args.len() >= 2 {\n+        println!(\"{}\", std::backtrace::Backtrace::force_capture());\n+        return;\n+    }\n+    let out = Command::new(&args[0]).env(\"RUST_BACKTRACE\", \"1\").arg(\"foo\").output().unwrap();\n+    let output = format!(\n+        \"{}\\n{}\",\n+        str::from_utf8(&out.stdout).unwrap(),\n+        str::from_utf8(&out.stderr).unwrap(),\n+    );\n+    if out.status.success() && output.contains(file!()) {\n+        return;\n+    }\n+    println!(\"status: {}\", out.status);\n+    println!(\"child output:\\n\\t{}\", output.replace(\"\\n\", \"\\n\\t\"));\n+    panic!(\"failed to find {:?} in output\", file!());\n+}"}, {"sha": "ea74fb966846ff1f7ff8ed18a62a5633bbfbe828", "filename": "src/test/ui/borrowck/borrow-raw-address-of-mutability.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftest%2Fui%2Fborrowck%2Fborrow-raw-address-of-mutability.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftest%2Fui%2Fborrowck%2Fborrow-raw-address-of-mutability.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrow-raw-address-of-mutability.stderr?ref=74500b99783d126e330184f0392a78f8b93b73ef", "patch": "@@ -20,7 +20,9 @@ error[E0596]: cannot borrow `f` as mutable, as it is not declared as mutable\n    |\n LL |     let f = || {\n    |         - help: consider changing this to be mutable: `mut f`\n-...\n+LL |         let y = &raw mut x;\n+   |                          - calling `f` requires mutable binding due to mutable borrow of `x`\n+LL |     };\n LL |     f();\n    |     ^ cannot borrow as mutable\n "}, {"sha": "ff210ae06a3bd1220d7d12477294bf1599655f1e", "filename": "src/test/ui/closures/issue-80313-mutable-borrow-in-closure.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftest%2Fui%2Fclosures%2Fissue-80313-mutable-borrow-in-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftest%2Fui%2Fclosures%2Fissue-80313-mutable-borrow-in-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fissue-80313-mutable-borrow-in-closure.rs?ref=74500b99783d126e330184f0392a78f8b93b73ef", "patch": "@@ -0,0 +1,7 @@\n+fn main() {\n+    let mut my_var = false;\n+    let callback = || {\n+        &mut my_var;\n+    };\n+    callback(); //~ ERROR E0596\n+}"}, {"sha": "bf9e1febdbba40a55ba062b64b82a824dd8bde40", "filename": "src/test/ui/closures/issue-80313-mutable-borrow-in-closure.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftest%2Fui%2Fclosures%2Fissue-80313-mutable-borrow-in-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftest%2Fui%2Fclosures%2Fissue-80313-mutable-borrow-in-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fissue-80313-mutable-borrow-in-closure.stderr?ref=74500b99783d126e330184f0392a78f8b93b73ef", "patch": "@@ -0,0 +1,14 @@\n+error[E0596]: cannot borrow `callback` as mutable, as it is not declared as mutable\n+  --> $DIR/issue-80313-mutable-borrow-in-closure.rs:6:5\n+   |\n+LL |     let callback = || {\n+   |         -------- help: consider changing this to be mutable: `mut callback`\n+LL |         &mut my_var;\n+   |              ------ calling `callback` requires mutable binding due to mutable borrow of `my_var`\n+LL |     };\n+LL |     callback();\n+   |     ^^^^^^^^ cannot borrow as mutable\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0596`."}, {"sha": "8f2d8a676302cb1b2f1ab4ae97212a1c13ed00d7", "filename": "src/test/ui/closures/issue-80313-mutable-borrow-in-move-closure.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftest%2Fui%2Fclosures%2Fissue-80313-mutable-borrow-in-move-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftest%2Fui%2Fclosures%2Fissue-80313-mutable-borrow-in-move-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fissue-80313-mutable-borrow-in-move-closure.rs?ref=74500b99783d126e330184f0392a78f8b93b73ef", "patch": "@@ -0,0 +1,7 @@\n+fn main() {\n+    let mut my_var = false;\n+    let callback = move || {\n+        &mut my_var;\n+    };\n+    callback(); //~ ERROR E0596\n+}"}, {"sha": "b67cec6a609f0857eaa8e6a63e0839aa7ba29941", "filename": "src/test/ui/closures/issue-80313-mutable-borrow-in-move-closure.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftest%2Fui%2Fclosures%2Fissue-80313-mutable-borrow-in-move-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftest%2Fui%2Fclosures%2Fissue-80313-mutable-borrow-in-move-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fissue-80313-mutable-borrow-in-move-closure.stderr?ref=74500b99783d126e330184f0392a78f8b93b73ef", "patch": "@@ -0,0 +1,14 @@\n+error[E0596]: cannot borrow `callback` as mutable, as it is not declared as mutable\n+  --> $DIR/issue-80313-mutable-borrow-in-move-closure.rs:6:5\n+   |\n+LL |     let callback = move || {\n+   |         -------- help: consider changing this to be mutable: `mut callback`\n+LL |         &mut my_var;\n+   |              ------ calling `callback` requires mutable binding due to possible mutation of `my_var`\n+LL |     };\n+LL |     callback();\n+   |     ^^^^^^^^ cannot borrow as mutable\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0596`."}, {"sha": "e082ea562ef2219f4ff81d87ded6e35b0242b3d8", "filename": "src/test/ui/closures/issue-80313-mutation-in-closure.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftest%2Fui%2Fclosures%2Fissue-80313-mutation-in-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftest%2Fui%2Fclosures%2Fissue-80313-mutation-in-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fissue-80313-mutation-in-closure.rs?ref=74500b99783d126e330184f0392a78f8b93b73ef", "patch": "@@ -0,0 +1,7 @@\n+fn main() {\n+    let mut my_var = false;\n+    let callback = || {\n+        my_var = true;\n+    };\n+    callback(); //~ ERROR E0596\n+}"}, {"sha": "6e98549f6b84f8cbf1c0252e8c14cb6e5b77bdf1", "filename": "src/test/ui/closures/issue-80313-mutation-in-closure.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftest%2Fui%2Fclosures%2Fissue-80313-mutation-in-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftest%2Fui%2Fclosures%2Fissue-80313-mutation-in-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fissue-80313-mutation-in-closure.stderr?ref=74500b99783d126e330184f0392a78f8b93b73ef", "patch": "@@ -0,0 +1,14 @@\n+error[E0596]: cannot borrow `callback` as mutable, as it is not declared as mutable\n+  --> $DIR/issue-80313-mutation-in-closure.rs:6:5\n+   |\n+LL |     let callback = || {\n+   |         -------- help: consider changing this to be mutable: `mut callback`\n+LL |         my_var = true;\n+   |         ------ calling `callback` requires mutable binding due to mutable borrow of `my_var`\n+LL |     };\n+LL |     callback();\n+   |     ^^^^^^^^ cannot borrow as mutable\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0596`."}, {"sha": "f66bf4e0628319071b0de5a06cb06a0a74ef1632", "filename": "src/test/ui/closures/issue-80313-mutation-in-move-closure.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftest%2Fui%2Fclosures%2Fissue-80313-mutation-in-move-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftest%2Fui%2Fclosures%2Fissue-80313-mutation-in-move-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fissue-80313-mutation-in-move-closure.rs?ref=74500b99783d126e330184f0392a78f8b93b73ef", "patch": "@@ -0,0 +1,7 @@\n+fn main() {\n+    let mut my_var = false;\n+    let callback = move || {\n+        my_var = true;\n+    };\n+    callback(); //~ ERROR E0596\n+}"}, {"sha": "edd55422a0bd490350d671b9b1b82bcaa31e6614", "filename": "src/test/ui/closures/issue-80313-mutation-in-move-closure.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftest%2Fui%2Fclosures%2Fissue-80313-mutation-in-move-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftest%2Fui%2Fclosures%2Fissue-80313-mutation-in-move-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fissue-80313-mutation-in-move-closure.stderr?ref=74500b99783d126e330184f0392a78f8b93b73ef", "patch": "@@ -0,0 +1,14 @@\n+error[E0596]: cannot borrow `callback` as mutable, as it is not declared as mutable\n+  --> $DIR/issue-80313-mutation-in-move-closure.rs:6:5\n+   |\n+LL |     let callback = move || {\n+   |         -------- help: consider changing this to be mutable: `mut callback`\n+LL |         my_var = true;\n+   |         ------ calling `callback` requires mutable binding due to possible mutation of `my_var`\n+LL |     };\n+LL |     callback();\n+   |     ^^^^^^^^ cannot borrow as mutable\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0596`."}, {"sha": "c2adff116ef20b02ce94d69af2f4bba6ee338f73", "filename": "src/test/ui/consts/const-eval/conditional_array_execution.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconditional_array_execution.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconditional_array_execution.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconditional_array_execution.stderr?ref=74500b99783d126e330184f0392a78f8b93b73ef", "patch": "@@ -12,7 +12,7 @@ note: the lint level is defined here\n LL | #![warn(const_err)]\n    |         ^^^^^^^^^\n \n-error[E0080]: evaluation of constant expression failed\n+error[E0080]: evaluation of constant value failed\n   --> $DIR/conditional_array_execution.rs:11:20\n    |\n LL |     println!(\"{}\", FOO);"}, {"sha": "cbfeca240266679e8a5c66ffafc6da822011450c", "filename": "src/test/ui/consts/const-eval/const-eval-query-stack.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-query-stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-query-stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-query-stack.rs?ref=74500b99783d126e330184f0392a78f8b93b73ef", "patch": "@@ -21,6 +21,6 @@ const X: i32 = 1 / 0; //~WARN any use of this value will cause an error\n \n fn main() {\n     let x: &'static i32 = &X;\n-    //~^ ERROR evaluation of constant expression failed\n+    //~^ ERROR evaluation of constant value failed\n     println!(\"x={}\", x);\n }"}, {"sha": "3e727b84aed109da65bf67b490758a0b6febe1ea", "filename": "src/test/ui/consts/const-eval/const-eval-query-stack.stderr", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-query-stack.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-query-stack.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-query-stack.stderr?ref=74500b99783d126e330184f0392a78f8b93b73ef", "patch": "@@ -12,13 +12,11 @@ note: the lint level is defined here\n LL | #[warn(const_err)]\n    |        ^^^^^^^^^\n \n-error[E0080]: evaluation of constant expression failed\n-  --> $DIR/const-eval-query-stack.rs:23:27\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/const-eval-query-stack.rs:23:28\n    |\n LL |     let x: &'static i32 = &X;\n-   |                           ^-\n-   |                            |\n-   |                            referenced constant has errors\n+   |                            ^ referenced constant has errors\n query stack during panic:\n #0 [normalize_generic_arg_after_erasing_regions] normalizing `main::promoted[1]`\n #1 [optimized_mir] optimizing MIR for `main`"}, {"sha": "0a2532973f42302f96ad77e912e461efd2826c87", "filename": "src/test/ui/consts/const-eval/const_fn_ptr_fail2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_fn_ptr_fail2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_fn_ptr_fail2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_fn_ptr_fail2.rs?ref=74500b99783d126e330184f0392a78f8b93b73ef", "patch": "@@ -18,7 +18,7 @@ const Z: usize = bar(double, 2); // FIXME: should fail to typeck someday\n \n fn main() {\n     assert_eq!(Y, 4);\n-    //~^ ERROR evaluation of constant expression failed\n+    //~^ ERROR evaluation of constant value failed\n     assert_eq!(Z, 4);\n-    //~^ ERROR evaluation of constant expression failed\n+    //~^ ERROR evaluation of constant value failed\n }"}, {"sha": "2afedf30563a60c6403748bf558dbaed885f22a3", "filename": "src/test/ui/consts/const-eval/const_fn_ptr_fail2.stderr", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_fn_ptr_fail2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_fn_ptr_fail2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_fn_ptr_fail2.stderr?ref=74500b99783d126e330184f0392a78f8b93b73ef", "patch": "@@ -1,22 +1,14 @@\n-error[E0080]: evaluation of constant expression failed\n-  --> $DIR/const_fn_ptr_fail2.rs:20:5\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/const_fn_ptr_fail2.rs:20:16\n    |\n LL |     assert_eq!(Y, 4);\n-   |     ^^^^^^^^^^^-^^^^^\n-   |                |\n-   |                referenced constant has errors\n-   |\n-   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+   |                ^ referenced constant has errors\n \n-error[E0080]: evaluation of constant expression failed\n-  --> $DIR/const_fn_ptr_fail2.rs:22:5\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/const_fn_ptr_fail2.rs:22:16\n    |\n LL |     assert_eq!(Z, 4);\n-   |     ^^^^^^^^^^^-^^^^^\n-   |                |\n-   |                referenced constant has errors\n-   |\n-   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+   |                ^ referenced constant has errors\n \n warning: skipping const checks\n    |"}, {"sha": "7d1d33288a907ff5741928c20c11bf8d14e7be77", "filename": "src/test/ui/consts/const-eval/issue-43197.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-43197.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-43197.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-43197.rs?ref=74500b99783d126e330184f0392a78f8b93b73ef", "patch": "@@ -12,8 +12,8 @@ fn main() {\n     const Y: u32 = foo(0 - 1);\n     //~^ WARN any use of this value will cause\n     println!(\"{} {}\", X, Y);\n-    //~^ ERROR evaluation of constant expression failed\n-    //~| ERROR evaluation of constant expression failed\n+    //~^ ERROR evaluation of constant value failed\n+    //~| ERROR evaluation of constant value failed\n     //~| WARN erroneous constant used [const_err]\n     //~| WARN erroneous constant used [const_err]\n }"}, {"sha": "8c72b591416877eaf3546474d07fa779595ada6f", "filename": "src/test/ui/consts/const-eval/issue-43197.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-43197.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-43197.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-43197.stderr?ref=74500b99783d126e330184f0392a78f8b93b73ef", "patch": "@@ -20,7 +20,7 @@ LL |     const Y: u32 = foo(0 - 1);\n    |                        |\n    |                        attempt to compute `0_u32 - 1_u32`, which would overflow\n \n-error[E0080]: evaluation of constant expression failed\n+error[E0080]: evaluation of constant value failed\n   --> $DIR/issue-43197.rs:14:23\n    |\n LL |     println!(\"{} {}\", X, Y);\n@@ -32,7 +32,7 @@ warning: erroneous constant used\n LL |     println!(\"{} {}\", X, Y);\n    |                       ^ referenced constant has errors\n \n-error[E0080]: evaluation of constant expression failed\n+error[E0080]: evaluation of constant value failed\n   --> $DIR/issue-43197.rs:14:26\n    |\n LL |     println!(\"{} {}\", X, Y);"}, {"sha": "79f1301a2f944194d246a72ea527acc9df7054da", "filename": "src/test/ui/consts/const-eval/issue-44578.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-44578.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-44578.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-44578.rs?ref=74500b99783d126e330184f0392a78f8b93b73ef", "patch": "@@ -25,5 +25,5 @@ impl Foo for u16 {\n \n fn main() {\n     println!(\"{}\", <Bar<u16, u8> as Foo>::AMT);\n-    //~^ ERROR evaluation of constant expression failed [E0080]\n+    //~^ ERROR evaluation of constant value failed [E0080]\n }"}, {"sha": "bff9f40f82b351cfefbb089f4a04115c87173eb6", "filename": "src/test/ui/consts/const-eval/issue-44578.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-44578.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-44578.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-44578.stderr?ref=74500b99783d126e330184f0392a78f8b93b73ef", "patch": "@@ -1,4 +1,4 @@\n-error[E0080]: evaluation of constant expression failed\n+error[E0080]: evaluation of constant value failed\n   --> $DIR/issue-44578.rs:27:20\n    |\n LL |     println!(\"{}\", <Bar<u16, u8> as Foo>::AMT);"}, {"sha": "f929f500cf9fbd8cf0c136817035989a37e88ed7", "filename": "src/test/ui/consts/const-eval/issue-50814-2.stderr", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-50814-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-50814-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-50814-2.stderr?ref=74500b99783d126e330184f0392a78f8b93b73ef", "patch": "@@ -8,13 +8,11 @@ LL |     const BAR: usize = [5, 6, 7][T::BOO];\n    |\n    = note: `#[deny(const_err)]` on by default\n \n-error[E0080]: evaluation of constant expression failed\n-  --> $DIR/issue-50814-2.rs:18:5\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/issue-50814-2.rs:18:6\n    |\n LL |     &<A<T> as Foo<T>>::BAR\n-   |     ^---------------------\n-   |      |\n-   |      referenced constant has errors\n+   |      ^^^^^^^^^^^^^^^^^^^^^ referenced constant has errors\n \n error: aborting due to 2 previous errors\n "}, {"sha": "307fb3c8c9de1fbd116ffe2096038cb00b075268", "filename": "src/test/ui/consts/const-eval/issue-50814.stderr", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-50814.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-50814.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-50814.stderr?ref=74500b99783d126e330184f0392a78f8b93b73ef", "patch": "@@ -8,13 +8,11 @@ LL |     const MAX: u8 = A::MAX + B::MAX;\n    |\n    = note: `#[deny(const_err)]` on by default\n \n-error[E0080]: evaluation of constant expression failed\n-  --> $DIR/issue-50814.rs:20:5\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/issue-50814.rs:20:6\n    |\n LL |     &Sum::<U8,U8>::MAX\n-   |     ^-----------------\n-   |      |\n-   |      referenced constant has errors\n+   |      ^^^^^^^^^^^^^^^^^ referenced constant has errors\n \n error: aborting due to 2 previous errors\n "}, {"sha": "6dddc7ff6e9d2c45bf274ae2be22a051037c6010", "filename": "src/test/ui/consts/const_unsafe_unreachable_ub.stderr", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftest%2Fui%2Fconsts%2Fconst_unsafe_unreachable_ub.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftest%2Fui%2Fconsts%2Fconst_unsafe_unreachable_ub.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_unsafe_unreachable_ub.stderr?ref=74500b99783d126e330184f0392a78f8b93b73ef", "patch": "@@ -20,15 +20,11 @@ note: the lint level is defined here\n LL | #[warn(const_err)]\n    |        ^^^^^^^^^\n \n-error[E0080]: evaluation of constant expression failed\n-  --> $DIR/const_unsafe_unreachable_ub.rs:17:3\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/const_unsafe_unreachable_ub.rs:17:14\n    |\n LL |   assert_eq!(BAR, true);\n-   |   ^^^^^^^^^^^---^^^^^^^^\n-   |              |\n-   |              referenced constant has errors\n-   |\n-   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+   |              ^^^ referenced constant has errors\n \n error: erroneous constant used\n   --> $DIR/const_unsafe_unreachable_ub.rs:17:3"}, {"sha": "ede5487b65d3965da5c78c2b8919100cd4601a84", "filename": "src/test/ui/consts/issue-55878.stderr", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftest%2Fui%2Fconsts%2Fissue-55878.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftest%2Fui%2Fconsts%2Fissue-55878.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-55878.stderr?ref=74500b99783d126e330184f0392a78f8b93b73ef", "patch": "@@ -2,15 +2,12 @@ error[E0080]: values of the type `[u8; SIZE]` are too big for the current archit\n   --> $SRC_DIR/core/src/mem/mod.rs:LL:COL\n    |\n LL |     intrinsics::size_of::<T>()\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |     |\n-   |     inside `std::mem::size_of::<[u8; SIZE]>` at $SRC_DIR/core/src/mem/mod.rs:LL:COL\n-   |     inside `main` at $DIR/issue-55878.rs:7:26\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ inside `std::mem::size_of::<[u8; SIZE]>` at $SRC_DIR/core/src/mem/mod.rs:LL:COL\n    | \n   ::: $DIR/issue-55878.rs:7:26\n    |\n LL |     println!(\"Size: {}\", std::mem::size_of::<[u8; u64::MAX as usize]>());\n-   |                          ----------------------------------------------\n+   |                          ---------------------------------------------- inside `main` at $DIR/issue-55878.rs:7:26\n \n error: erroneous constant used\n   --> $DIR/issue-55878.rs:7:26"}, {"sha": "6f9e6ec0a57ff0c17d87b33c10084e202c2bfe39", "filename": "src/test/ui/lint/semicolon-in-expressions-from-macros/allow-semicolon-in-expressions-from-macros.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftest%2Fui%2Flint%2Fsemicolon-in-expressions-from-macros%2Fallow-semicolon-in-expressions-from-macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftest%2Fui%2Flint%2Fsemicolon-in-expressions-from-macros%2Fallow-semicolon-in-expressions-from-macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fsemicolon-in-expressions-from-macros%2Fallow-semicolon-in-expressions-from-macros.rs?ref=74500b99783d126e330184f0392a78f8b93b73ef", "patch": "@@ -0,0 +1,15 @@\n+// check-pass\n+// Ensure that trailing semicolons are allowed by default\n+\n+macro_rules! foo {\n+    () => {\n+        true;\n+    }\n+}\n+\n+fn main() {\n+    let val = match true {\n+        true => false,\n+        _ => foo!()\n+    };\n+}"}, {"sha": "605d5a0309cfcf1fb33f6a64c2a92ec092ace3ca", "filename": "src/test/ui/lint/semicolon-in-expressions-from-macros/semicolon-in-expressions-from-macros.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftest%2Fui%2Flint%2Fsemicolon-in-expressions-from-macros%2Fsemicolon-in-expressions-from-macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftest%2Fui%2Flint%2Fsemicolon-in-expressions-from-macros%2Fsemicolon-in-expressions-from-macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fsemicolon-in-expressions-from-macros%2Fsemicolon-in-expressions-from-macros.rs?ref=74500b99783d126e330184f0392a78f8b93b73ef", "patch": "@@ -0,0 +1,30 @@\n+// check-pass\n+#![warn(semicolon_in_expressions_from_macros)]\n+\n+#[allow(dead_code)]\n+macro_rules! foo {\n+    ($val:ident) => {\n+        true; //~ WARN trailing\n+              //~| WARN this was previously\n+              //~| WARN trailing\n+              //~| WARN this was previously\n+    }\n+}\n+\n+fn main() {\n+    // This `allow` doesn't work\n+    #[allow(semicolon_in_expressions_from_macros)]\n+    let _ = {\n+        foo!(first)\n+    };\n+\n+    // This 'allow' doesn't work either\n+    #[allow(semicolon_in_expressions_from_macros)]\n+    let _ = foo!(second);\n+\n+    // But this 'allow' does\n+    #[allow(semicolon_in_expressions_from_macros)]\n+    fn inner() {\n+        let _ = foo!(third);\n+    }\n+}"}, {"sha": "6f9f879661a41062654376c6945b8f967d9aa6aa", "filename": "src/test/ui/lint/semicolon-in-expressions-from-macros/semicolon-in-expressions-from-macros.stderr", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftest%2Fui%2Flint%2Fsemicolon-in-expressions-from-macros%2Fsemicolon-in-expressions-from-macros.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftest%2Fui%2Flint%2Fsemicolon-in-expressions-from-macros%2Fsemicolon-in-expressions-from-macros.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fsemicolon-in-expressions-from-macros%2Fsemicolon-in-expressions-from-macros.stderr?ref=74500b99783d126e330184f0392a78f8b93b73ef", "patch": "@@ -0,0 +1,33 @@\n+warning: trailing semicolon in macro used in expression position\n+  --> $DIR/semicolon-in-expressions-from-macros.rs:7:13\n+   |\n+LL |         true;\n+   |             ^\n+...\n+LL |         foo!(first)\n+   |         ----------- in this macro invocation\n+   |\n+note: the lint level is defined here\n+  --> $DIR/semicolon-in-expressions-from-macros.rs:2:9\n+   |\n+LL | #![warn(semicolon_in_expressions_from_macros)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #79813 <https://github.com/rust-lang/rust/issues/79813>\n+   = note: this warning originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+warning: trailing semicolon in macro used in expression position\n+  --> $DIR/semicolon-in-expressions-from-macros.rs:7:13\n+   |\n+LL |         true;\n+   |             ^\n+...\n+LL |     let _ = foo!(second);\n+   |             ------------ in this macro invocation\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #79813 <https://github.com/rust-lang/rust/issues/79813>\n+   = note: this warning originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+warning: 2 warnings emitted\n+"}, {"sha": "a0ed56d4bcf7bf20ff20ce696debf0734bb9d5aa", "filename": "src/test/ui/unboxed-closures/unboxed-closures-infer-fnmut-calling-fnmut-no-mut.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-infer-fnmut-calling-fnmut-no-mut.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-infer-fnmut-calling-fnmut-no-mut.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-infer-fnmut-calling-fnmut-no-mut.stderr?ref=74500b99783d126e330184f0392a78f8b93b73ef", "patch": "@@ -3,6 +3,8 @@ error[E0596]: cannot borrow `tick1` as mutable, as it is not declared as mutable\n    |\n LL |     let tick1 = || {\n    |         ----- help: consider changing this to be mutable: `mut tick1`\n+LL |         counter += 1;\n+   |         ------- calling `tick1` requires mutable binding due to mutable borrow of `counter`\n ...\n LL |         tick1();\n    |         ^^^^^ cannot borrow as mutable\n@@ -12,6 +14,8 @@ error[E0596]: cannot borrow `tick2` as mutable, as it is not declared as mutable\n    |\n LL |     let tick2 = || {\n    |         ----- help: consider changing this to be mutable: `mut tick2`\n+LL |         tick1();\n+   |         ----- calling `tick2` requires mutable binding due to mutable borrow of `tick1`\n ...\n LL |     tick2();\n    |     ^^^^^ cannot borrow as mutable"}, {"sha": "27d23e3fa044bb5f261478c435f44f0971da4639", "filename": "src/test/ui/unboxed-closures/unboxed-closures-infer-fnmut-missing-mut.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-infer-fnmut-missing-mut.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-infer-fnmut-missing-mut.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-infer-fnmut-missing-mut.stderr?ref=74500b99783d126e330184f0392a78f8b93b73ef", "patch": "@@ -2,7 +2,9 @@ error[E0596]: cannot borrow `tick` as mutable, as it is not declared as mutable\n   --> $DIR/unboxed-closures-infer-fnmut-missing-mut.rs:7:5\n    |\n LL |     let tick = || counter += 1;\n-   |         ---- help: consider changing this to be mutable: `mut tick`\n+   |         ----      ------- calling `tick` requires mutable binding due to mutable borrow of `counter`\n+   |         |\n+   |         help: consider changing this to be mutable: `mut tick`\n LL |     tick();\n    |     ^^^^ cannot borrow as mutable\n "}, {"sha": "c00f986c397a7240012490b0823521d9a8c82d3e", "filename": "src/test/ui/unboxed-closures/unboxed-closures-infer-fnmut-move-missing-mut.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-infer-fnmut-move-missing-mut.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-infer-fnmut-move-missing-mut.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-infer-fnmut-move-missing-mut.stderr?ref=74500b99783d126e330184f0392a78f8b93b73ef", "patch": "@@ -2,7 +2,9 @@ error[E0596]: cannot borrow `tick` as mutable, as it is not declared as mutable\n   --> $DIR/unboxed-closures-infer-fnmut-move-missing-mut.rs:7:5\n    |\n LL |     let tick = move || counter += 1;\n-   |         ---- help: consider changing this to be mutable: `mut tick`\n+   |         ----           ------- calling `tick` requires mutable binding due to possible mutation of `counter`\n+   |         |\n+   |         help: consider changing this to be mutable: `mut tick`\n LL |     tick();\n    |     ^^^^ cannot borrow as mutable\n "}, {"sha": "6fa1378b8c73d66971f75e93e899136a1aa93ab4", "filename": "src/tools/clippy/clippy_lints/src/default.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault.rs?ref=74500b99783d126e330184f0392a78f8b93b73ef", "patch": "@@ -1,5 +1,5 @@\n use crate::utils::{\n-    any_parent_is_automatically_derived, contains_name, match_def_path, paths, qpath_res, snippet_with_macro_callsite,\n+    any_parent_is_automatically_derived, contains_name, match_def_path, paths, snippet_with_macro_callsite,\n };\n use crate::utils::{span_lint_and_note, span_lint_and_sugg};\n use if_chain::if_chain;\n@@ -231,7 +231,7 @@ fn is_expr_default<'tcx>(expr: &'tcx Expr<'tcx>, cx: &LateContext<'tcx>) -> bool\n     if_chain! {\n         if let ExprKind::Call(ref fn_expr, _) = &expr.kind;\n         if let ExprKind::Path(qpath) = &fn_expr.kind;\n-        if let Res::Def(_, def_id) = qpath_res(cx, qpath, fn_expr.hir_id);\n+        if let Res::Def(_, def_id) = cx.qpath_res(qpath, fn_expr.hir_id);\n         then {\n             // right hand side of assignment is `Default::default`\n             match_def_path(cx, def_id, &paths::DEFAULT_TRAIT_METHOD)"}, {"sha": "a84f9c46287163ece6ddd5ab947e175dd0d5481f", "filename": "src/tools/clippy/clippy_lints/src/drop_forget_ref.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdrop_forget_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdrop_forget_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdrop_forget_ref.rs?ref=74500b99783d126e330184f0392a78f8b93b73ef", "patch": "@@ -1,4 +1,4 @@\n-use crate::utils::{is_copy, match_def_path, paths, qpath_res, span_lint_and_note};\n+use crate::utils::{is_copy, match_def_path, paths, span_lint_and_note};\n use if_chain::if_chain;\n use rustc_hir::{Expr, ExprKind};\n use rustc_lint::{LateContext, LateLintPass};\n@@ -114,7 +114,7 @@ impl<'tcx> LateLintPass<'tcx> for DropForgetRef {\n             if let ExprKind::Call(ref path, ref args) = expr.kind;\n             if let ExprKind::Path(ref qpath) = path.kind;\n             if args.len() == 1;\n-            if let Some(def_id) = qpath_res(cx, qpath, path.hir_id).opt_def_id();\n+            if let Some(def_id) = cx.qpath_res(qpath, path.hir_id).opt_def_id();\n             then {\n                 let lint;\n                 let msg;"}, {"sha": "915859270009b27775b5656c67a7241783abc373", "filename": "src/tools/clippy/clippy_lints/src/exit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fexit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fexit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fexit.rs?ref=74500b99783d126e330184f0392a78f8b93b73ef", "patch": "@@ -1,4 +1,4 @@\n-use crate::utils::{is_entrypoint_fn, match_def_path, paths, qpath_res, span_lint};\n+use crate::utils::{is_entrypoint_fn, match_def_path, paths, span_lint};\n use if_chain::if_chain;\n use rustc_hir::{Expr, ExprKind, Item, ItemKind, Node};\n use rustc_lint::{LateContext, LateLintPass};\n@@ -29,7 +29,7 @@ impl<'tcx> LateLintPass<'tcx> for Exit {\n         if_chain! {\n             if let ExprKind::Call(ref path_expr, ref _args) = e.kind;\n             if let ExprKind::Path(ref path) = path_expr.kind;\n-            if let Some(def_id) = qpath_res(cx, path, path_expr.hir_id).opt_def_id();\n+            if let Some(def_id) = cx.qpath_res(path, path_expr.hir_id).opt_def_id();\n             if match_def_path(cx, def_id, &paths::EXIT);\n             then {\n                 let parent = cx.tcx.hir().get_parent_item(e.hir_id);"}, {"sha": "8795425461033d2da785dcab99add48a63a6b396", "filename": "src/tools/clippy/clippy_lints/src/functions.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions.rs?ref=74500b99783d126e330184f0392a78f8b93b73ef", "patch": "@@ -1,7 +1,7 @@\n use crate::utils::{\n     attr_by_name, attrs::is_proc_macro, is_must_use_ty, is_trait_impl_item, is_type_diagnostic_item, iter_input_pats,\n-    last_path_segment, match_def_path, must_use_attr, qpath_res, return_ty, snippet, snippet_opt, span_lint,\n-    span_lint_and_help, span_lint_and_then, trait_ref_of_method, type_is_unsafe_function,\n+    last_path_segment, match_def_path, must_use_attr, return_ty, snippet, snippet_opt, span_lint, span_lint_and_help,\n+    span_lint_and_then, trait_ref_of_method, type_is_unsafe_function,\n };\n use if_chain::if_chain;\n use rustc_ast::ast::Attribute;\n@@ -659,7 +659,7 @@ impl<'a, 'tcx> intravisit::Visitor<'tcx> for DerefVisitor<'a, 'tcx> {\n impl<'a, 'tcx> DerefVisitor<'a, 'tcx> {\n     fn check_arg(&self, ptr: &hir::Expr<'_>) {\n         if let hir::ExprKind::Path(ref qpath) = ptr.kind {\n-            if let Res::Local(id) = qpath_res(self.cx, qpath, ptr.hir_id) {\n+            if let Res::Local(id) = self.cx.qpath_res(qpath, ptr.hir_id) {\n                 if self.ptrs.contains(&id) {\n                     span_lint(\n                         self.cx,\n@@ -722,7 +722,7 @@ fn is_mutated_static(cx: &LateContext<'_>, e: &hir::Expr<'_>) -> bool {\n     use hir::ExprKind::{Field, Index, Path};\n \n     match e.kind {\n-        Path(ref qpath) => !matches!(qpath_res(cx, qpath, e.hir_id), Res::Local(_)),\n+        Path(ref qpath) => !matches!(cx.qpath_res(qpath, e.hir_id), Res::Local(_)),\n         Field(ref inner, _) | Index(ref inner, _) => is_mutated_static(cx, inner),\n         _ => false,\n     }"}, {"sha": "5886c2360e36220ef5c6a7f97dada59c5eda8f5c", "filename": "src/tools/clippy/clippy_lints/src/let_if_seq.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flet_if_seq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flet_if_seq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flet_if_seq.rs?ref=74500b99783d126e330184f0392a78f8b93b73ef", "patch": "@@ -1,4 +1,4 @@\n-use crate::utils::{qpath_res, snippet, span_lint_and_then, visitors::LocalUsedVisitor};\n+use crate::utils::{snippet, span_lint_and_then, visitors::LocalUsedVisitor};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n@@ -145,7 +145,7 @@ fn check_assign<'tcx>(\n         if let hir::StmtKind::Semi(ref expr) = expr.kind;\n         if let hir::ExprKind::Assign(ref var, ref value, _) = expr.kind;\n         if let hir::ExprKind::Path(ref qpath) = var.kind;\n-        if let Res::Local(local_id) = qpath_res(cx, qpath, var.hir_id);\n+        if let Res::Local(local_id) = cx.qpath_res(qpath, var.hir_id);\n         if decl == local_id;\n         then {\n             let mut v = LocalUsedVisitor::new(decl);"}, {"sha": "f89075005bc7acb20a291c53d9b67b67e10888a3", "filename": "src/tools/clippy/clippy_lints/src/loops.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops.rs?ref=74500b99783d126e330184f0392a78f8b93b73ef", "patch": "@@ -6,9 +6,9 @@ use crate::utils::visitors::LocalUsedVisitor;\n use crate::utils::{\n     contains_name, get_enclosing_block, get_parent_expr, get_trait_def_id, has_iter_method, higher, implements_trait,\n     indent_of, is_in_panic_handler, is_integer_const, is_no_std_crate, is_refutable, is_type_diagnostic_item,\n-    last_path_segment, match_trait_method, match_type, match_var, multispan_sugg, qpath_res, single_segment_path,\n-    snippet, snippet_with_applicability, snippet_with_macro_callsite, span_lint, span_lint_and_help,\n-    span_lint_and_sugg, span_lint_and_then, sugg, SpanlessEq,\n+    last_path_segment, match_trait_method, match_type, match_var, multispan_sugg, single_segment_path, snippet,\n+    snippet_with_applicability, snippet_with_macro_callsite, span_lint, span_lint_and_help, span_lint_and_sugg,\n+    span_lint_and_then, sugg, SpanlessEq,\n };\n use if_chain::if_chain;\n use rustc_ast::ast;\n@@ -848,7 +848,7 @@ fn same_var<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>, var: HirId) -> bool {\n         if let ExprKind::Path(qpath) = &expr.kind;\n         if let QPath::Resolved(None, path) = qpath;\n         if path.segments.len() == 1;\n-        if let Res::Local(local_id) = qpath_res(cx, qpath, expr.hir_id);\n+        if let Res::Local(local_id) = cx.qpath_res(qpath, expr.hir_id);\n         then {\n             // our variable!\n             local_id == var\n@@ -1420,7 +1420,7 @@ fn detect_same_item_push<'tcx>(\n                 // Make sure that the push does not involve possibly mutating values\n                 match pushed_item.kind {\n                     ExprKind::Path(ref qpath) => {\n-                        match qpath_res(cx, qpath, pushed_item.hir_id) {\n+                        match cx.qpath_res(qpath, pushed_item.hir_id) {\n                             // immutable bindings that are initialized with literal or constant\n                             Res::Local(hir_id) => {\n                                 if_chain! {\n@@ -1437,7 +1437,7 @@ fn detect_same_item_push<'tcx>(\n                                             ExprKind::Lit(..) => emit_lint(cx, vec, pushed_item),\n                                             // immutable bindings that are initialized with constant\n                                             ExprKind::Path(ref path) => {\n-                                                if let Res::Def(DefKind::Const, ..) = qpath_res(cx, path, init.hir_id) {\n+                                                if let Res::Def(DefKind::Const, ..) = cx.qpath_res(path, init.hir_id) {\n                                                     emit_lint(cx, vec, pushed_item);\n                                                 }\n                                             }\n@@ -2028,7 +2028,7 @@ fn check_for_mutability(cx: &LateContext<'_>, bound: &Expr<'_>) -> Option<HirId>\n         if let ExprKind::Path(ref qpath) = bound.kind;\n         if let QPath::Resolved(None, _) = *qpath;\n         then {\n-            let res = qpath_res(cx, qpath, bound.hir_id);\n+            let res = cx.qpath_res(qpath, bound.hir_id);\n             if let Res::Local(hir_id) = res {\n                 let node_str = cx.tcx.hir().get(hir_id);\n                 if_chain! {\n@@ -2120,7 +2120,7 @@ impl<'a, 'tcx> VarVisitor<'a, 'tcx> {\n                     if self.prefer_mutable {\n                         self.indexed_mut.insert(seqvar.segments[0].ident.name);\n                     }\n-                    let res = qpath_res(self.cx, seqpath, seqexpr.hir_id);\n+                    let res = self.cx.qpath_res(seqpath, seqexpr.hir_id);\n                     match res {\n                         Res::Local(hir_id) => {\n                             let parent_id = self.cx.tcx.hir().get_parent_item(expr.hir_id);\n@@ -2184,7 +2184,7 @@ impl<'a, 'tcx> Visitor<'tcx> for VarVisitor<'a, 'tcx> {\n             if let QPath::Resolved(None, ref path) = *qpath;\n             if path.segments.len() == 1;\n             then {\n-                if let Res::Local(local_id) = qpath_res(self.cx, qpath, expr.hir_id) {\n+                if let Res::Local(local_id) = self.cx.qpath_res(qpath, expr.hir_id) {\n                     if local_id == self.var {\n                         self.nonindex = true;\n                     } else {\n@@ -2589,7 +2589,7 @@ impl<'a, 'tcx> Visitor<'tcx> for InitializeVisitor<'a, 'tcx> {\n \n fn var_def_id(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<HirId> {\n     if let ExprKind::Path(ref qpath) = expr.kind {\n-        let path_res = qpath_res(cx, qpath, expr.hir_id);\n+        let path_res = cx.qpath_res(qpath, expr.hir_id);\n         if let Res::Local(hir_id) = path_res {\n             return Some(hir_id);\n         }\n@@ -2819,7 +2819,7 @@ impl<'a, 'tcx> VarCollectorVisitor<'a, 'tcx> {\n         if_chain! {\n             if let ExprKind::Path(ref qpath) = ex.kind;\n             if let QPath::Resolved(None, _) = *qpath;\n-            let res = qpath_res(self.cx, qpath, ex.hir_id);\n+            let res = self.cx.qpath_res(qpath, ex.hir_id);\n             then {\n                 match res {\n                     Res::Local(hir_id) => {"}, {"sha": "42a92104a4919f28d259e18e940f1b90a36aaff8", "filename": "src/tools/clippy/clippy_lints/src/manual_strip.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_strip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_strip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_strip.rs?ref=74500b99783d126e330184f0392a78f8b93b73ef", "patch": "@@ -1,7 +1,7 @@\n use crate::consts::{constant, Constant};\n use crate::utils::usage::mutated_variables;\n use crate::utils::{\n-    eq_expr_value, higher, match_def_path, meets_msrv, multispan_sugg, paths, qpath_res, snippet, span_lint_and_then,\n+    eq_expr_value, higher, match_def_path, meets_msrv, multispan_sugg, paths, snippet, span_lint_and_then,\n };\n \n use if_chain::if_chain;\n@@ -92,7 +92,7 @@ impl<'tcx> LateLintPass<'tcx> for ManualStrip {\n                 } else {\n                     return;\n                 };\n-                let target_res = qpath_res(cx, &target_path, target_arg.hir_id);\n+                let target_res = cx.qpath_res(&target_path, target_arg.hir_id);\n                 if target_res == Res::Err {\n                     return;\n                 };\n@@ -221,7 +221,7 @@ fn find_stripping<'tcx>(\n                 if let ExprKind::Index(indexed, index) = &unref.kind;\n                 if let Some(higher::Range { start, end, .. }) = higher::range(index);\n                 if let ExprKind::Path(path) = &indexed.kind;\n-                if qpath_res(self.cx, path, ex.hir_id) == self.target;\n+                if self.cx.qpath_res(path, ex.hir_id) == self.target;\n                 then {\n                     match (self.strip_kind, start, end) {\n                         (StripKind::Prefix, Some(start), None) => {\n@@ -235,7 +235,7 @@ fn find_stripping<'tcx>(\n                                 if let ExprKind::Binary(Spanned { node: BinOpKind::Sub, .. }, left, right) = end.kind;\n                                 if let Some(left_arg) = len_arg(self.cx, left);\n                                 if let ExprKind::Path(left_path) = &left_arg.kind;\n-                                if qpath_res(self.cx, left_path, left_arg.hir_id) == self.target;\n+                                if self.cx.qpath_res(left_path, left_arg.hir_id) == self.target;\n                                 if eq_pattern_length(self.cx, self.pattern, right);\n                                 then {\n                                     self.results.push(ex.span);"}, {"sha": "d34f9761e26f9a0d26b29c03733217e9e5296858", "filename": "src/tools/clippy/clippy_lints/src/mem_forget.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmem_forget.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmem_forget.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmem_forget.rs?ref=74500b99783d126e330184f0392a78f8b93b73ef", "patch": "@@ -1,4 +1,4 @@\n-use crate::utils::{match_def_path, paths, qpath_res, span_lint};\n+use crate::utils::{match_def_path, paths, span_lint};\n use rustc_hir::{Expr, ExprKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -29,7 +29,7 @@ impl<'tcx> LateLintPass<'tcx> for MemForget {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) {\n         if let ExprKind::Call(ref path_expr, ref args) = e.kind {\n             if let ExprKind::Path(ref qpath) = path_expr.kind {\n-                if let Some(def_id) = qpath_res(cx, qpath, path_expr.hir_id).opt_def_id() {\n+                if let Some(def_id) = cx.qpath_res(qpath, path_expr.hir_id).opt_def_id() {\n                     if match_def_path(cx, def_id, &paths::MEM_FORGET) {\n                         let forgot_ty = cx.typeck_results().expr_ty(&args[0]);\n "}, {"sha": "69302d695ce0a31304aadca1c8c6fa2dcdd19c1b", "filename": "src/tools/clippy/clippy_lints/src/no_effect.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fno_effect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fno_effect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fno_effect.rs?ref=74500b99783d126e330184f0392a78f8b93b73ef", "patch": "@@ -1,4 +1,4 @@\n-use crate::utils::{has_drop, qpath_res, snippet_opt, span_lint, span_lint_and_sugg};\n+use crate::utils::{has_drop, snippet_opt, span_lint, span_lint_and_sugg};\n use rustc_errors::Applicability;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::{BinOpKind, BlockCheckMode, Expr, ExprKind, Stmt, StmtKind, UnsafeSource};\n@@ -67,7 +67,7 @@ fn has_no_effect(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n         },\n         ExprKind::Call(ref callee, ref args) => {\n             if let ExprKind::Path(ref qpath) = callee.kind {\n-                let res = qpath_res(cx, qpath, callee.hir_id);\n+                let res = cx.qpath_res(qpath, callee.hir_id);\n                 match res {\n                     Res::Def(DefKind::Struct | DefKind::Variant | DefKind::Ctor(..), ..) => {\n                         !has_drop(cx, cx.typeck_results().expr_ty(expr))\n@@ -146,7 +146,7 @@ fn reduce_expression<'a>(cx: &LateContext<'_>, expr: &'a Expr<'a>) -> Option<Vec\n         },\n         ExprKind::Call(ref callee, ref args) => {\n             if let ExprKind::Path(ref qpath) = callee.kind {\n-                let res = qpath_res(cx, qpath, callee.hir_id);\n+                let res = cx.qpath_res(qpath, callee.hir_id);\n                 match res {\n                     Res::Def(DefKind::Struct | DefKind::Variant | DefKind::Ctor(..), ..)\n                         if !has_drop(cx, cx.typeck_results().expr_ty(expr)) =>"}, {"sha": "f57d753631755881da6f739021dec84a07f1ddaa", "filename": "src/tools/clippy/clippy_lints/src/non_copy_const.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_copy_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_copy_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_copy_const.rs?ref=74500b99783d126e330184f0392a78f8b93b73ef", "patch": "@@ -18,7 +18,7 @@ use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::{InnerSpan, Span, DUMMY_SP};\n use rustc_typeck::hir_ty_to_ty;\n \n-use crate::utils::{in_constant, qpath_res, span_lint_and_then};\n+use crate::utils::{in_constant, span_lint_and_then};\n use if_chain::if_chain;\n \n // FIXME: this is a correctness problem but there's no suitable\n@@ -339,7 +339,7 @@ impl<'tcx> LateLintPass<'tcx> for NonCopyConst {\n             }\n \n             // Make sure it is a const item.\n-            let item_def_id = match qpath_res(cx, qpath, expr.hir_id) {\n+            let item_def_id = match cx.qpath_res(qpath, expr.hir_id) {\n                 Res::Def(DefKind::Const | DefKind::AssocConst, did) => did,\n                 _ => return,\n             };"}, {"sha": "fa508df865e48af4a01b79866769aee3395f5dc7", "filename": "src/tools/clippy/clippy_lints/src/to_string_in_display.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fto_string_in_display.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fto_string_in_display.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fto_string_in_display.rs?ref=74500b99783d126e330184f0392a78f8b93b73ef", "patch": "@@ -1,4 +1,4 @@\n-use crate::utils::{match_def_path, match_trait_method, paths, qpath_res, span_lint};\n+use crate::utils::{match_def_path, match_trait_method, paths, span_lint};\n use if_chain::if_chain;\n use rustc_hir::def::Res;\n use rustc_hir::{Expr, ExprKind, HirId, Impl, ImplItem, ImplItemKind, Item, ItemKind};\n@@ -94,7 +94,7 @@ impl LateLintPass<'_> for ToStringInDisplay {\n             if match_trait_method(cx, expr, &paths::TO_STRING);\n             if self.in_display_impl;\n             if let ExprKind::Path(ref qpath) = args[0].kind;\n-            if let Res::Local(hir_id) = qpath_res(cx, qpath, args[0].hir_id);\n+            if let Res::Local(hir_id) = cx.qpath_res(qpath, args[0].hir_id);\n             if let Some(self_hir_id) = self.self_hir_id;\n             if hir_id == self_hir_id;\n             then {"}, {"sha": "04c32ce9e8f2c9d9d2cacdae8374c63f010d6eb2", "filename": "src/tools/clippy/clippy_lints/src/types.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes.rs?ref=74500b99783d126e330184f0392a78f8b93b73ef", "patch": "@@ -34,7 +34,7 @@ use crate::utils::sugg::Sugg;\n use crate::utils::{\n     clip, comparisons, differing_macro_contexts, higher, in_constant, indent_of, int_bits, is_hir_ty_cfg_dependant,\n     is_type_diagnostic_item, last_path_segment, match_def_path, match_path, meets_msrv, method_chain_args,\n-    multispan_sugg, numeric_literal::NumericLiteral, qpath_res, reindent_multiline, sext, snippet, snippet_opt,\n+    multispan_sugg, numeric_literal::NumericLiteral, reindent_multiline, sext, snippet, snippet_opt,\n     snippet_with_applicability, snippet_with_macro_callsite, span_lint, span_lint_and_help, span_lint_and_sugg,\n     span_lint_and_then, unsext,\n };\n@@ -298,7 +298,7 @@ fn match_type_parameter(cx: &LateContext<'_>, qpath: &QPath<'_>, path: &[&str])\n             _ => None,\n         });\n         if let TyKind::Path(ref qpath) = ty.kind;\n-        if let Some(did) = qpath_res(cx, qpath, ty.hir_id).opt_def_id();\n+        if let Some(did) = cx.qpath_res(qpath, ty.hir_id).opt_def_id();\n         if match_def_path(cx, did, path);\n         then {\n             return Some(ty.span);\n@@ -365,7 +365,7 @@ impl Types {\n         match hir_ty.kind {\n             TyKind::Path(ref qpath) if !is_local => {\n                 let hir_id = hir_ty.hir_id;\n-                let res = qpath_res(cx, qpath, hir_id);\n+                let res = cx.qpath_res(qpath, hir_id);\n                 if let Some(def_id) = res.opt_def_id() {\n                     if Some(def_id) == cx.tcx.lang_items().owned_box() {\n                         if let Some(span) = match_borrows_parameter(cx, qpath) {\n@@ -535,7 +535,7 @@ impl Types {\n                             });\n                             // ty is now _ at this point\n                             if let TyKind::Path(ref ty_qpath) = ty.kind;\n-                            let res = qpath_res(cx, ty_qpath, ty.hir_id);\n+                            let res = cx.qpath_res(ty_qpath, ty.hir_id);\n                             if let Some(def_id) = res.opt_def_id();\n                             if Some(def_id) == cx.tcx.lang_items().owned_box();\n                             // At this point, we know ty is Box<T>, now get T\n@@ -652,7 +652,7 @@ impl Types {\n         match mut_ty.ty.kind {\n             TyKind::Path(ref qpath) => {\n                 let hir_id = mut_ty.ty.hir_id;\n-                let def = qpath_res(cx, qpath, hir_id);\n+                let def = cx.qpath_res(qpath, hir_id);\n                 if_chain! {\n                     if let Some(def_id) = def.opt_def_id();\n                     if Some(def_id) == cx.tcx.lang_items().owned_box();\n@@ -739,7 +739,7 @@ fn is_any_trait(t: &hir::Ty<'_>) -> bool {\n \n fn get_bounds_if_impl_trait<'tcx>(cx: &LateContext<'tcx>, qpath: &QPath<'_>, id: HirId) -> Option<GenericBounds<'tcx>> {\n     if_chain! {\n-        if let Some(did) = qpath_res(cx, qpath, id).opt_def_id();\n+        if let Some(did) = cx.qpath_res(qpath, id).opt_def_id();\n         if let Some(Node::GenericParam(generic_param)) = cx.tcx.hir().get_if_local(did);\n         if let GenericParamKind::Type { synthetic, .. } = generic_param.kind;\n         if synthetic == Some(SyntheticTyParamKind::ImplTrait);"}, {"sha": "822863ca3e279d5039077bf78ac9bbbb4038a93c", "filename": "src/tools/clippy/clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=74500b99783d126e330184f0392a78f8b93b73ef", "patch": "@@ -1,7 +1,7 @@\n use crate::consts::{constant_simple, Constant};\n use crate::utils::{\n-    is_expn_of, match_def_path, match_qpath, match_type, method_calls, path_to_res, paths, qpath_res, run_lints,\n-    snippet, span_lint, span_lint_and_help, span_lint_and_sugg, SpanlessEq,\n+    is_expn_of, match_def_path, match_qpath, match_type, method_calls, path_to_res, paths, run_lints, snippet,\n+    span_lint, span_lint_and_help, span_lint_and_sugg, SpanlessEq,\n };\n use if_chain::if_chain;\n use rustc_ast::ast::{Crate as AstCrate, ItemKind, LitKind, NodeId};\n@@ -787,7 +787,7 @@ fn path_to_matched_type(cx: &LateContext<'_>, expr: &hir::Expr<'_>) -> Option<Ve\n \n     match &expr.kind {\n         ExprKind::AddrOf(.., expr) => return path_to_matched_type(cx, expr),\n-        ExprKind::Path(qpath) => match qpath_res(cx, qpath, expr.hir_id) {\n+        ExprKind::Path(qpath) => match cx.qpath_res(qpath, expr.hir_id) {\n             Res::Local(hir_id) => {\n                 let parent_id = cx.tcx.hir().get_parent_node(hir_id);\n                 if let Some(Node::Local(local)) = cx.tcx.hir().find(parent_id) {"}, {"sha": "0bbb6a52a20468c447e43a7d6ec6ab19879af214", "filename": "src/tools/clippy/clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=74500b99783d126e330184f0392a78f8b93b73ef", "patch": "@@ -369,19 +369,6 @@ pub fn path_to_res(cx: &LateContext<'_>, path: &[&str]) -> Option<def::Res> {\n     }\n }\n \n-pub fn qpath_res(cx: &LateContext<'_>, qpath: &hir::QPath<'_>, id: hir::HirId) -> Res {\n-    match qpath {\n-        hir::QPath::Resolved(_, path) => path.res,\n-        hir::QPath::TypeRelative(..) | hir::QPath::LangItem(..) => {\n-            if cx.tcx.has_typeck_results(id.owner.to_def_id()) {\n-                cx.tcx.typeck(id.owner).qpath_res(qpath, id)\n-            } else {\n-                Res::Err\n-            }\n-        },\n-    }\n-}\n-\n /// Convenience function to get the `DefId` of a trait by path.\n /// It could be a trait or trait alias.\n pub fn get_trait_def_id(cx: &LateContext<'_>, path: &[&str]) -> Option<DefId> {"}, {"sha": "52aed57fc76afc4431b73afc01ec59a283e97489", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=74500b99783d126e330184f0392a78f8b93b73ef", "patch": "@@ -2015,10 +2015,10 @@ impl<'test> TestCx<'test> {\n                 rustc.args(&[\"-Zchalk\"]);\n             }\n             Some(CompareMode::SplitDwarf) => {\n-                rustc.args(&[\"-Zsplit-dwarf=split\"]);\n+                rustc.args(&[\"-Csplit-debuginfo=unpacked\", \"-Zunstable-options\"]);\n             }\n             Some(CompareMode::SplitDwarfSingle) => {\n-                rustc.args(&[\"-Zsplit-dwarf=single\"]);\n+                rustc.args(&[\"-Csplit-debuginfo=packed\", \"-Zunstable-options\"]);\n             }\n             None => {}\n         }"}, {"sha": "21d05226fb42c5d6a7124f93c51db5b8c666a6c8", "filename": "src/tools/tidy/src/ui_tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftools%2Ftidy%2Fsrc%2Fui_tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74500b99783d126e330184f0392a78f8b93b73ef/src%2Ftools%2Ftidy%2Fsrc%2Fui_tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fui_tests.rs?ref=74500b99783d126e330184f0392a78f8b93b73ef", "patch": "@@ -7,7 +7,7 @@ use std::path::Path;\n \n const ENTRY_LIMIT: usize = 1000;\n // FIXME: The following limits should be reduced eventually.\n-const ROOT_ENTRY_LIMIT: usize = 1458;\n+const ROOT_ENTRY_LIMIT: usize = 1459;\n const ISSUES_ENTRY_LIMIT: usize = 2669;\n \n fn check_entries(path: &Path, bad: &mut bool) {"}]}