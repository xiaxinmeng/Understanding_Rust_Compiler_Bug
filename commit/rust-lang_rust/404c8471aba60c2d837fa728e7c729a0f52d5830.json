{"sha": "404c8471aba60c2d837fa728e7c729a0f52d5830", "node_id": "C_kwDOAAsO6NoAKDQwNGM4NDcxYWJhNjBjMmQ4MzdmYTcyOGU3YzcyOWEwZjUyZDU4MzA", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-12-14T11:30:17Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-12-14T11:30:17Z"}, "message": "Auto merge of #91902 - matthiaskrgr:rollup-hjjyhow, r=matthiaskrgr\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #91529 (add BinaryHeap::try_reserve and BinaryHeap::try_reserve_exact)\n - #91820 (Suggest to specify a target triple when lang item is missing)\n - #91851 (Make `MaybeUninit::zeroed` `const`)\n - #91875 (Use try_normalize_erasing_regions in RevealAllVisitor)\n - #91887 (Remove `in_band_lifetimes` from `rustc_const_eval`)\n - #91892 (Fix HashStable implementation on InferTy)\n - #91893 (Remove `in_band_lifetimes` from `rustc_hir`)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "fea112a2f7f32d0c68df6fe15f0440bb49436ff4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fea112a2f7f32d0c68df6fe15f0440bb49436ff4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/404c8471aba60c2d837fa728e7c729a0f52d5830", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/404c8471aba60c2d837fa728e7c729a0f52d5830", "html_url": "https://github.com/rust-lang/rust/commit/404c8471aba60c2d837fa728e7c729a0f52d5830", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/404c8471aba60c2d837fa728e7c729a0f52d5830/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "83b32f27fc6c34b0b411f47be31ab4ae07eafed4", "url": "https://api.github.com/repos/rust-lang/rust/commits/83b32f27fc6c34b0b411f47be31ab4ae07eafed4", "html_url": "https://github.com/rust-lang/rust/commit/83b32f27fc6c34b0b411f47be31ab4ae07eafed4"}, {"sha": "1dde0dbbf5ab3698240749f418b7270de5c31def", "url": "https://api.github.com/repos/rust-lang/rust/commits/1dde0dbbf5ab3698240749f418b7270de5c31def", "html_url": "https://github.com/rust-lang/rust/commit/1dde0dbbf5ab3698240749f418b7270de5c31def"}], "stats": {"total": 369, "additions": 271, "deletions": 98}, "files": [{"sha": "550715abc10bf41c84640a29f736a501c02c31fb", "filename": "compiler/rustc_const_eval/src/const_eval/machine.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/404c8471aba60c2d837fa728e7c729a0f52d5830/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/404c8471aba60c2d837fa728e7c729a0f52d5830/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs?ref=404c8471aba60c2d837fa728e7c729a0f52d5830", "patch": "@@ -423,14 +423,14 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n     }\n \n     #[inline(always)]\n-    fn stack(\n+    fn stack<'a>(\n         ecx: &'a InterpCx<'mir, 'tcx, Self>,\n     ) -> &'a [Frame<'mir, 'tcx, Self::PointerTag, Self::FrameExtra>] {\n         &ecx.machine.stack\n     }\n \n     #[inline(always)]\n-    fn stack_mut(\n+    fn stack_mut<'a>(\n         ecx: &'a mut InterpCx<'mir, 'tcx, Self>,\n     ) -> &'a mut Vec<Frame<'mir, 'tcx, Self::PointerTag, Self::FrameExtra>> {\n         &mut ecx.machine.stack"}, {"sha": "91b17d1ac1ef88be5adecd336dec1415b7adbb1a", "filename": "compiler/rustc_const_eval/src/const_eval/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/404c8471aba60c2d837fa728e7c729a0f52d5830/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/404c8471aba60c2d837fa728e7c729a0f52d5830/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmod.rs?ref=404c8471aba60c2d837fa728e7c729a0f52d5830", "patch": "@@ -25,9 +25,9 @@ pub use fn_queries::*;\n pub use machine::*;\n \n pub(crate) fn const_caller_location(\n-    tcx: TyCtxt<'tcx>,\n+    tcx: TyCtxt<'_>,\n     (file, line, col): (Symbol, u32, u32),\n-) -> ConstValue<'tcx> {\n+) -> ConstValue<'_> {\n     trace!(\"const_caller_location: {}:{}:{}\", file, line, col);\n     let mut ecx = mk_eval_cx(tcx, DUMMY_SP, ty::ParamEnv::reveal_all(), false);\n "}, {"sha": "d768f06c4f00d1de1fb10fea35dcc2378339b5f8", "filename": "compiler/rustc_const_eval/src/interpret/eval_context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/404c8471aba60c2d837fa728e7c729a0f52d5830/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/404c8471aba60c2d837fa728e7c729a0f52d5830/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs?ref=404c8471aba60c2d837fa728e7c729a0f52d5830", "patch": "@@ -935,7 +935,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     }\n \n     #[must_use]\n-    pub fn dump_place(&'a self, place: Place<M::PointerTag>) -> PlacePrinter<'a, 'mir, 'tcx, M> {\n+    pub fn dump_place(&self, place: Place<M::PointerTag>) -> PlacePrinter<'_, 'mir, 'tcx, M> {\n         PlacePrinter { ecx: self, place }\n     }\n "}, {"sha": "a1dd587c17ab5c6921ee428c64a407c11461b0e8", "filename": "compiler/rustc_const_eval/src/interpret/intern.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/404c8471aba60c2d837fa728e7c729a0f52d5830/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/404c8471aba60c2d837fa728e7c729a0f52d5830/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs?ref=404c8471aba60c2d837fa728e7c729a0f52d5830", "patch": "@@ -292,14 +292,15 @@ pub enum InternKind {\n /// Any errors here would anyway be turned into `const_err` lints, whereas validation failures\n /// are hard errors.\n #[tracing::instrument(level = \"debug\", skip(ecx))]\n-pub fn intern_const_alloc_recursive<M: CompileTimeMachine<'mir, 'tcx, const_eval::MemoryKind>>(\n+pub fn intern_const_alloc_recursive<\n+    'mir,\n+    'tcx: 'mir,\n+    M: CompileTimeMachine<'mir, 'tcx, const_eval::MemoryKind>,\n+>(\n     ecx: &mut InterpCx<'mir, 'tcx, M>,\n     intern_kind: InternKind,\n     ret: &MPlaceTy<'tcx>,\n-) -> Result<(), ErrorReported>\n-where\n-    'tcx: 'mir,\n-{\n+) -> Result<(), ErrorReported> {\n     let tcx = ecx.tcx;\n     let base_intern_mode = match intern_kind {\n         InternKind::Static(mutbl) => InternMode::Static(mutbl),"}, {"sha": "b77c1c71a15d6a7fcf2f8ec2cb3a75ce268e5ddc", "filename": "compiler/rustc_const_eval/src/interpret/intrinsics/type_name.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/404c8471aba60c2d837fa728e7c729a0f52d5830/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics%2Ftype_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/404c8471aba60c2d837fa728e7c729a0f52d5830/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics%2Ftype_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics%2Ftype_name.rs?ref=404c8471aba60c2d837fa728e7c729a0f52d5830", "patch": "@@ -148,7 +148,7 @@ impl<'tcx> Printer<'tcx> for AbsolutePathPrinter<'tcx> {\n     }\n }\n \n-impl PrettyPrinter<'tcx> for AbsolutePathPrinter<'tcx> {\n+impl<'tcx> PrettyPrinter<'tcx> for AbsolutePathPrinter<'tcx> {\n     fn region_should_not_be_omitted(&self, _region: ty::Region<'_>) -> bool {\n         false\n     }"}, {"sha": "727099848a4ff755295e77ce1008559336167fd2", "filename": "compiler/rustc_const_eval/src/interpret/machine.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/404c8471aba60c2d837fa728e7c729a0f52d5830/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/404c8471aba60c2d837fa728e7c729a0f52d5830/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs?ref=404c8471aba60c2d837fa728e7c729a0f52d5830", "patch": "@@ -374,12 +374,12 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     ) -> InterpResult<'tcx, Frame<'mir, 'tcx, Self::PointerTag, Self::FrameExtra>>;\n \n     /// Borrow the current thread's stack.\n-    fn stack(\n+    fn stack<'a>(\n         ecx: &'a InterpCx<'mir, 'tcx, Self>,\n     ) -> &'a [Frame<'mir, 'tcx, Self::PointerTag, Self::FrameExtra>];\n \n     /// Mutably borrow the current thread's stack.\n-    fn stack_mut(\n+    fn stack_mut<'a>(\n         ecx: &'a mut InterpCx<'mir, 'tcx, Self>,\n     ) -> &'a mut Vec<Frame<'mir, 'tcx, Self::PointerTag, Self::FrameExtra>>;\n "}, {"sha": "dfec4509685f6b83614eec3278b2817c75c1b012", "filename": "compiler/rustc_const_eval/src/interpret/operand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/404c8471aba60c2d837fa728e7c729a0f52d5830/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/404c8471aba60c2d837fa728e7c729a0f52d5830/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs?ref=404c8471aba60c2d837fa728e7c729a0f52d5830", "patch": "@@ -106,7 +106,7 @@ pub struct ImmTy<'tcx, Tag: Provenance = AllocId> {\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n rustc_data_structures::static_assert_size!(ImmTy<'_>, 72);\n \n-impl<Tag: Provenance> std::fmt::Display for ImmTy<'tcx, Tag> {\n+impl<Tag: Provenance> std::fmt::Display for ImmTy<'_, Tag> {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         /// Helper function for printing a scalar to a FmtPrinter\n         fn p<'a, 'tcx, F: std::fmt::Write, Tag: Provenance>("}, {"sha": "851c2a6bb2e39ae5ffc0e89b530bda99b4e27a06", "filename": "compiler/rustc_const_eval/src/interpret/place.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/404c8471aba60c2d837fa728e7c729a0f52d5830/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/404c8471aba60c2d837fa728e7c729a0f52d5830/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs?ref=404c8471aba60c2d837fa728e7c729a0f52d5830", "patch": "@@ -150,7 +150,7 @@ impl<Tag: Provenance> MemPlace<Tag> {\n     }\n \n     #[inline]\n-    pub fn offset(\n+    pub fn offset<'tcx>(\n         self,\n         offset: Size,\n         meta: MemPlaceMeta<Tag>,\n@@ -420,7 +420,7 @@ where\n \n     // Iterates over all fields of an array. Much more efficient than doing the\n     // same by repeatedly calling `mplace_array`.\n-    pub(super) fn mplace_array_fields(\n+    pub(super) fn mplace_array_fields<'a>(\n         &self,\n         base: &'a MPlaceTy<'tcx, Tag>,\n     ) -> InterpResult<'tcx, impl Iterator<Item = InterpResult<'tcx, MPlaceTy<'tcx, Tag>>> + 'a>"}, {"sha": "bb0ecdd928100524bf75a80ca8223443faee3981", "filename": "compiler/rustc_const_eval/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/404c8471aba60c2d837fa728e7c729a0f52d5830/compiler%2Frustc_const_eval%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/404c8471aba60c2d837fa728e7c729a0f52d5830/compiler%2Frustc_const_eval%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Flib.rs?ref=404c8471aba60c2d837fa728e7c729a0f52d5830", "patch": "@@ -11,7 +11,6 @@ Rust MIR: a lowered representation of Rust.\n #![feature(crate_visibility_modifier)]\n #![feature(decl_macro)]\n #![feature(exact_size_is_empty)]\n-#![feature(in_band_lifetimes)]\n #![feature(iter_zip)]\n #![feature(let_else)]\n #![feature(map_try_insert)]"}, {"sha": "1d5f4630152941629928db3e4dcd3c5f088ac083", "filename": "compiler/rustc_const_eval/src/transform/check_consts/check.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/404c8471aba60c2d837fa728e7c729a0f52d5830/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/404c8471aba60c2d837fa728e7c729a0f52d5830/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs?ref=404c8471aba60c2d837fa728e7c729a0f52d5830", "patch": "@@ -35,7 +35,7 @@ pub struct Qualifs<'mir, 'tcx> {\n     needs_non_const_drop: Option<QualifResults<'mir, 'tcx, NeedsNonConstDrop>>,\n }\n \n-impl Qualifs<'mir, 'tcx> {\n+impl<'mir, 'tcx> Qualifs<'mir, 'tcx> {\n     /// Returns `true` if `local` is `NeedsDrop` at the given `Location`.\n     ///\n     /// Only updates the cursor if absolutely necessary\n@@ -185,15 +185,15 @@ pub struct Checker<'mir, 'tcx> {\n     secondary_errors: Vec<Diagnostic>,\n }\n \n-impl Deref for Checker<'mir, 'tcx> {\n+impl<'mir, 'tcx> Deref for Checker<'mir, 'tcx> {\n     type Target = ConstCx<'mir, 'tcx>;\n \n     fn deref(&self) -> &Self::Target {\n         &self.ccx\n     }\n }\n \n-impl Checker<'mir, 'tcx> {\n+impl<'mir, 'tcx> Checker<'mir, 'tcx> {\n     pub fn new(ccx: &'mir ConstCx<'mir, 'tcx>) -> Self {\n         Checker {\n             span: ccx.body.span,\n@@ -273,7 +273,7 @@ impl Checker<'mir, 'tcx> {\n                 struct StorageDeads {\n                     locals: BitSet<Local>,\n                 }\n-                impl Visitor<'tcx> for StorageDeads {\n+                impl<'tcx> Visitor<'tcx> for StorageDeads {\n                     fn visit_statement(&mut self, stmt: &Statement<'tcx>, _: Location) {\n                         if let StatementKind::StorageDead(l) = stmt.kind {\n                             self.locals.insert(l);\n@@ -460,7 +460,7 @@ impl Checker<'mir, 'tcx> {\n     }\n }\n \n-impl Visitor<'tcx> for Checker<'mir, 'tcx> {\n+impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n     fn visit_basic_block_data(&mut self, bb: BasicBlock, block: &BasicBlockData<'tcx>) {\n         trace!(\"visit_basic_block_data: bb={:?} is_cleanup={:?}\", bb, block.is_cleanup);\n \n@@ -1042,7 +1042,7 @@ impl Visitor<'tcx> for Checker<'mir, 'tcx> {\n     }\n }\n \n-fn place_as_reborrow(\n+fn place_as_reborrow<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     body: &Body<'tcx>,\n     place: Place<'tcx>,"}, {"sha": "b026bb2bad6574f100a7679797784618e06d68aa", "filename": "compiler/rustc_const_eval/src/transform/check_consts/mod.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/404c8471aba60c2d837fa728e7c729a0f52d5830/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/404c8471aba60c2d837fa728e7c729a0f52d5830/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fmod.rs?ref=404c8471aba60c2d837fa728e7c729a0f52d5830", "patch": "@@ -28,7 +28,7 @@ pub struct ConstCx<'mir, 'tcx> {\n     pub const_kind: Option<hir::ConstContext>,\n }\n \n-impl ConstCx<'mir, 'tcx> {\n+impl<'mir, 'tcx> ConstCx<'mir, 'tcx> {\n     pub fn new(tcx: TyCtxt<'tcx>, body: &'mir mir::Body<'tcx>) -> Self {\n         let def_id = body.source.def_id().expect_local();\n         let param_env = tcx.param_env(def_id);\n@@ -72,11 +72,7 @@ impl ConstCx<'mir, 'tcx> {\n     }\n }\n \n-pub fn rustc_allow_const_fn_unstable(\n-    tcx: TyCtxt<'tcx>,\n-    def_id: DefId,\n-    feature_gate: Symbol,\n-) -> bool {\n+pub fn rustc_allow_const_fn_unstable(tcx: TyCtxt<'_>, def_id: DefId, feature_gate: Symbol) -> bool {\n     let attrs = tcx.get_attrs(def_id);\n     attr::rustc_allow_const_fn_unstable(&tcx.sess, attrs).any(|name| name == feature_gate)\n }\n@@ -89,7 +85,7 @@ pub fn rustc_allow_const_fn_unstable(\n // functions can be called in a const-context by users of the stable compiler. \"const-stable\"\n // functions are subject to more stringent restrictions than \"const-unstable\" functions: They\n // cannot use unstable features and can only call other \"const-stable\" functions.\n-pub fn is_const_stable_const_fn(tcx: TyCtxt<'tcx>, def_id: DefId) -> bool {\n+pub fn is_const_stable_const_fn(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n     use attr::{ConstStability, Stability, StabilityLevel};\n \n     // A default body marked const is not const-stable because const"}, {"sha": "24c4a4915e5e831f7313a41e18f897d0df1ebd96", "filename": "compiler/rustc_const_eval/src/transform/check_consts/ops.rs", "status": "modified", "additions": 51, "deletions": 27, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/404c8471aba60c2d837fa728e7c729a0f52d5830/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/404c8471aba60c2d837fa728e7c729a0f52d5830/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs?ref=404c8471aba60c2d837fa728e7c729a0f52d5830", "patch": "@@ -39,7 +39,7 @@ pub trait NonConstOp: std::fmt::Debug {\n         DiagnosticImportance::Primary\n     }\n \n-    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx>;\n+    fn build_error<'tcx>(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx>;\n }\n \n #[derive(Debug)]\n@@ -53,7 +53,7 @@ impl NonConstOp for FloatingPointOp {\n         }\n     }\n \n-    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+    fn build_error<'tcx>(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n         feature_err(\n             &ccx.tcx.sess.parse_sess,\n             sym::const_fn_floating_point_arithmetic,\n@@ -67,7 +67,7 @@ impl NonConstOp for FloatingPointOp {\n #[derive(Debug)]\n pub struct FnCallIndirect;\n impl NonConstOp for FnCallIndirect {\n-    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+    fn build_error<'tcx>(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n         ccx.tcx.sess.struct_span_err(span, \"function pointers are not allowed in const fn\")\n     }\n }\n@@ -76,7 +76,7 @@ impl NonConstOp for FnCallIndirect {\n #[derive(Debug)]\n pub struct FnCallNonConst<'tcx>(pub Option<(DefId, SubstsRef<'tcx>)>);\n impl<'a> NonConstOp for FnCallNonConst<'a> {\n-    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+    fn build_error<'tcx>(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n         let mut err = struct_span_err!(\n             ccx.tcx.sess,\n             span,\n@@ -149,7 +149,7 @@ impl<'a> NonConstOp for FnCallNonConst<'a> {\n pub struct FnCallUnstable(pub DefId, pub Option<Symbol>);\n \n impl NonConstOp for FnCallUnstable {\n-    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+    fn build_error<'tcx>(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n         let FnCallUnstable(def_id, feature) = *self;\n \n         let mut err = ccx.tcx.sess.struct_span_err(\n@@ -183,7 +183,7 @@ impl NonConstOp for FnPtrCast {\n         }\n     }\n \n-    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+    fn build_error<'tcx>(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n         feature_err(\n             &ccx.tcx.sess.parse_sess,\n             sym::const_fn_fn_ptr_basics,\n@@ -204,7 +204,7 @@ impl NonConstOp for Generator {\n         }\n     }\n \n-    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+    fn build_error<'tcx>(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n         let msg = format!(\"{}s are not allowed in {}s\", self.0, ccx.const_kind());\n         if let hir::GeneratorKind::Async(hir::AsyncGeneratorKind::Block) = self.0 {\n             feature_err(&ccx.tcx.sess.parse_sess, sym::const_async_blocks, span, &msg)\n@@ -217,7 +217,7 @@ impl NonConstOp for Generator {\n #[derive(Debug)]\n pub struct HeapAllocation;\n impl NonConstOp for HeapAllocation {\n-    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+    fn build_error<'tcx>(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n         let mut err = struct_span_err!(\n             ccx.tcx.sess,\n             span,\n@@ -241,7 +241,7 @@ impl NonConstOp for HeapAllocation {\n #[derive(Debug)]\n pub struct InlineAsm;\n impl NonConstOp for InlineAsm {\n-    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+    fn build_error<'tcx>(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n         struct_span_err!(\n             ccx.tcx.sess,\n             span,\n@@ -257,7 +257,7 @@ pub struct LiveDrop {\n     pub dropped_at: Option<Span>,\n }\n impl NonConstOp for LiveDrop {\n-    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+    fn build_error<'tcx>(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n         let mut err = struct_span_err!(\n             ccx.tcx.sess,\n             span,\n@@ -285,7 +285,7 @@ impl NonConstOp for TransientCellBorrow {\n         // not additionally emit a feature gate error if activating the feature gate won't work.\n         DiagnosticImportance::Secondary\n     }\n-    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+    fn build_error<'tcx>(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n         feature_err(\n             &ccx.tcx.sess.parse_sess,\n             sym::const_refs_to_cell,\n@@ -301,7 +301,7 @@ impl NonConstOp for TransientCellBorrow {\n /// it in the future for static items.\n pub struct CellBorrow;\n impl NonConstOp for CellBorrow {\n-    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+    fn build_error<'tcx>(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n         let mut err = struct_span_err!(\n             ccx.tcx.sess,\n             span,\n@@ -348,7 +348,7 @@ impl NonConstOp for MutBorrow {\n         DiagnosticImportance::Secondary\n     }\n \n-    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+    fn build_error<'tcx>(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n         let raw = match self.0 {\n             hir::BorrowKind::Raw => \"raw \",\n             hir::BorrowKind::Ref => \"\",\n@@ -387,7 +387,7 @@ impl NonConstOp for TransientMutBorrow {\n         Status::Unstable(sym::const_mut_refs)\n     }\n \n-    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+    fn build_error<'tcx>(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n         let raw = match self.0 {\n             hir::BorrowKind::Raw => \"raw \",\n             hir::BorrowKind::Ref => \"\",\n@@ -414,7 +414,7 @@ impl NonConstOp for MutDeref {\n         DiagnosticImportance::Secondary\n     }\n \n-    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+    fn build_error<'tcx>(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n         feature_err(\n             &ccx.tcx.sess.parse_sess,\n             sym::const_mut_refs,\n@@ -428,7 +428,7 @@ impl NonConstOp for MutDeref {\n #[derive(Debug)]\n pub struct PanicNonStr;\n impl NonConstOp for PanicNonStr {\n-    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+    fn build_error<'tcx>(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n         ccx.tcx.sess.struct_span_err(\n             span,\n             \"argument to `panic!()` in a const context must have type `&str`\",\n@@ -442,7 +442,7 @@ impl NonConstOp for PanicNonStr {\n #[derive(Debug)]\n pub struct RawPtrComparison;\n impl NonConstOp for RawPtrComparison {\n-    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+    fn build_error<'tcx>(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n         let mut err = ccx\n             .tcx\n             .sess\n@@ -462,7 +462,7 @@ impl NonConstOp for RawMutPtrDeref {\n         Status::Unstable(sym::const_mut_refs)\n     }\n \n-    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+    fn build_error<'tcx>(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n         feature_err(\n             &ccx.tcx.sess.parse_sess,\n             sym::const_mut_refs,\n@@ -478,7 +478,7 @@ impl NonConstOp for RawMutPtrDeref {\n #[derive(Debug)]\n pub struct RawPtrToIntCast;\n impl NonConstOp for RawPtrToIntCast {\n-    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+    fn build_error<'tcx>(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n         let mut err = ccx\n             .tcx\n             .sess\n@@ -503,7 +503,7 @@ impl NonConstOp for StaticAccess {\n         }\n     }\n \n-    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+    fn build_error<'tcx>(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n         let mut err = struct_span_err!(\n             ccx.tcx.sess,\n             span,\n@@ -529,7 +529,7 @@ impl NonConstOp for StaticAccess {\n #[derive(Debug)]\n pub struct ThreadLocalAccess;\n impl NonConstOp for ThreadLocalAccess {\n-    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+    fn build_error<'tcx>(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n         struct_span_err!(\n             ccx.tcx.sess,\n             span,\n@@ -560,7 +560,11 @@ pub mod ty {\n             }\n         }\n \n-        fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+        fn build_error<'tcx>(\n+            &self,\n+            ccx: &ConstCx<'_, 'tcx>,\n+            span: Span,\n+        ) -> DiagnosticBuilder<'tcx> {\n             feature_err(\n                 &ccx.tcx.sess.parse_sess,\n                 sym::const_mut_refs,\n@@ -590,7 +594,11 @@ pub mod ty {\n             }\n         }\n \n-        fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+        fn build_error<'tcx>(\n+            &self,\n+            ccx: &ConstCx<'_, 'tcx>,\n+            span: Span,\n+        ) -> DiagnosticBuilder<'tcx> {\n             feature_err(\n                 &ccx.tcx.sess.parse_sess,\n                 sym::const_fn_fn_ptr_basics,\n@@ -607,7 +615,11 @@ pub mod ty {\n             Status::Unstable(sym::const_impl_trait)\n         }\n \n-        fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+        fn build_error<'tcx>(\n+            &self,\n+            ccx: &ConstCx<'_, 'tcx>,\n+            span: Span,\n+        ) -> DiagnosticBuilder<'tcx> {\n             feature_err(\n                 &ccx.tcx.sess.parse_sess,\n                 sym::const_impl_trait,\n@@ -637,7 +649,11 @@ pub mod ty {\n             }\n         }\n \n-        fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+        fn build_error<'tcx>(\n+            &self,\n+            ccx: &ConstCx<'_, 'tcx>,\n+            span: Span,\n+        ) -> DiagnosticBuilder<'tcx> {\n             let mut err = feature_err(\n                 &ccx.tcx.sess.parse_sess,\n                 sym::const_fn_trait_bound,\n@@ -676,7 +692,11 @@ pub mod ty {\n             }\n         }\n \n-        fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+        fn build_error<'tcx>(\n+            &self,\n+            ccx: &ConstCx<'_, 'tcx>,\n+            span: Span,\n+        ) -> DiagnosticBuilder<'tcx> {\n             let mut err = feature_err(\n                 &ccx.tcx.sess.parse_sess,\n                 sym::const_fn_trait_bound,\n@@ -703,7 +723,11 @@ pub mod ty {\n             Status::Unstable(sym::const_trait_bound_opt_out)\n         }\n \n-        fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+        fn build_error<'tcx>(\n+            &self,\n+            ccx: &ConstCx<'_, 'tcx>,\n+            span: Span,\n+        ) -> DiagnosticBuilder<'tcx> {\n             feature_err(\n                 &ccx.tcx.sess.parse_sess,\n                 sym::const_trait_bound_opt_out,"}, {"sha": "4e210f66353f310c729634a4c69937e7f52fb402", "filename": "compiler/rustc_const_eval/src/transform/check_consts/post_drop_elaboration.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/404c8471aba60c2d837fa728e7c729a0f52d5830/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fpost_drop_elaboration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/404c8471aba60c2d837fa728e7c729a0f52d5830/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fpost_drop_elaboration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fpost_drop_elaboration.rs?ref=404c8471aba60c2d837fa728e7c729a0f52d5830", "patch": "@@ -23,7 +23,7 @@ pub fn checking_enabled(ccx: &ConstCx<'_, '_>) -> bool {\n ///\n /// This is separate from the rest of the const checking logic because it must run after drop\n /// elaboration.\n-pub fn check_live_drops(tcx: TyCtxt<'tcx>, body: &mir::Body<'tcx>) {\n+pub fn check_live_drops<'tcx>(tcx: TyCtxt<'tcx>, body: &mir::Body<'tcx>) {\n     let def_id = body.source.def_id().expect_local();\n     let const_kind = tcx.hir().body_const_context(def_id);\n     if const_kind.is_none() {\n@@ -50,21 +50,21 @@ struct CheckLiveDrops<'mir, 'tcx> {\n }\n \n // So we can access `body` and `tcx`.\n-impl std::ops::Deref for CheckLiveDrops<'mir, 'tcx> {\n+impl<'mir, 'tcx> std::ops::Deref for CheckLiveDrops<'mir, 'tcx> {\n     type Target = ConstCx<'mir, 'tcx>;\n \n     fn deref(&self) -> &Self::Target {\n         &self.ccx\n     }\n }\n \n-impl CheckLiveDrops<'mir, 'tcx> {\n+impl CheckLiveDrops<'_, '_> {\n     fn check_live_drop(&self, span: Span) {\n         ops::LiveDrop { dropped_at: None }.build_error(self.ccx, span).emit();\n     }\n }\n \n-impl Visitor<'tcx> for CheckLiveDrops<'mir, 'tcx> {\n+impl<'tcx> Visitor<'tcx> for CheckLiveDrops<'_, 'tcx> {\n     fn visit_basic_block_data(&mut self, bb: BasicBlock, block: &mir::BasicBlockData<'tcx>) {\n         trace!(\"visit_basic_block_data: bb={:?} is_cleanup={:?}\", bb, block.is_cleanup);\n "}, {"sha": "a8077b258bb7572f4a844694918853946ae968e2", "filename": "compiler/rustc_const_eval/src/transform/check_consts/qualifs.rs", "status": "modified", "additions": 34, "deletions": 14, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/404c8471aba60c2d837fa728e7c729a0f52d5830/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/404c8471aba60c2d837fa728e7c729a0f52d5830/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs?ref=404c8471aba60c2d837fa728e7c729a0f52d5830", "patch": "@@ -13,7 +13,7 @@ use rustc_trait_selection::traits::{\n \n use super::ConstCx;\n \n-pub fn in_any_value_of_ty(\n+pub fn in_any_value_of_ty<'tcx>(\n     cx: &ConstCx<'_, 'tcx>,\n     ty: Ty<'tcx>,\n     error_occured: Option<ErrorReported>,\n@@ -58,7 +58,7 @@ pub trait Qualif {\n     /// from a call to another function.\n     ///\n     /// It also determines the `Qualif`s for primitive types.\n-    fn in_any_value_of_ty(cx: &ConstCx<'_, 'tcx>, ty: Ty<'tcx>) -> bool;\n+    fn in_any_value_of_ty<'tcx>(cx: &ConstCx<'_, 'tcx>, ty: Ty<'tcx>) -> bool;\n \n     /// Returns `true` if this `Qualif` is inherent to the given struct or enum.\n     ///\n@@ -68,7 +68,7 @@ pub trait Qualif {\n     /// with a custom `Drop` impl is inherently `NeedsDrop`.\n     ///\n     /// Returning `true` for `in_adt_inherently` but `false` for `in_any_value_of_ty` is unsound.\n-    fn in_adt_inherently(\n+    fn in_adt_inherently<'tcx>(\n         cx: &ConstCx<'_, 'tcx>,\n         adt: &'tcx AdtDef,\n         substs: SubstsRef<'tcx>,\n@@ -89,11 +89,15 @@ impl Qualif for HasMutInterior {\n         qualifs.has_mut_interior\n     }\n \n-    fn in_any_value_of_ty(cx: &ConstCx<'_, 'tcx>, ty: Ty<'tcx>) -> bool {\n+    fn in_any_value_of_ty<'tcx>(cx: &ConstCx<'_, 'tcx>, ty: Ty<'tcx>) -> bool {\n         !ty.is_freeze(cx.tcx.at(DUMMY_SP), cx.param_env)\n     }\n \n-    fn in_adt_inherently(cx: &ConstCx<'_, 'tcx>, adt: &'tcx AdtDef, _: SubstsRef<'tcx>) -> bool {\n+    fn in_adt_inherently<'tcx>(\n+        cx: &ConstCx<'_, 'tcx>,\n+        adt: &'tcx AdtDef,\n+        _: SubstsRef<'tcx>,\n+    ) -> bool {\n         // Exactly one type, `UnsafeCell`, has the `HasMutInterior` qualif inherently.\n         // It arises structurally for all other types.\n         Some(adt.did) == cx.tcx.lang_items().unsafe_cell_type()\n@@ -115,11 +119,15 @@ impl Qualif for NeedsDrop {\n         qualifs.needs_drop\n     }\n \n-    fn in_any_value_of_ty(cx: &ConstCx<'_, 'tcx>, ty: Ty<'tcx>) -> bool {\n+    fn in_any_value_of_ty<'tcx>(cx: &ConstCx<'_, 'tcx>, ty: Ty<'tcx>) -> bool {\n         ty.needs_drop(cx.tcx, cx.param_env)\n     }\n \n-    fn in_adt_inherently(cx: &ConstCx<'_, 'tcx>, adt: &'tcx AdtDef, _: SubstsRef<'tcx>) -> bool {\n+    fn in_adt_inherently<'tcx>(\n+        cx: &ConstCx<'_, 'tcx>,\n+        adt: &'tcx AdtDef,\n+        _: SubstsRef<'tcx>,\n+    ) -> bool {\n         adt.has_dtor(cx.tcx)\n     }\n }\n@@ -137,7 +145,7 @@ impl Qualif for NeedsNonConstDrop {\n         qualifs.needs_non_const_drop\n     }\n \n-    fn in_any_value_of_ty(cx: &ConstCx<'_, 'tcx>, mut ty: Ty<'tcx>) -> bool {\n+    fn in_any_value_of_ty<'tcx>(cx: &ConstCx<'_, 'tcx>, mut ty: Ty<'tcx>) -> bool {\n         // Avoid selecting for simple cases.\n         match ty::util::needs_drop_components(ty, &cx.tcx.data_layout).as_deref() {\n             Ok([]) => return false,\n@@ -177,7 +185,11 @@ impl Qualif for NeedsNonConstDrop {\n         )\n     }\n \n-    fn in_adt_inherently(cx: &ConstCx<'_, 'tcx>, adt: &'tcx AdtDef, _: SubstsRef<'tcx>) -> bool {\n+    fn in_adt_inherently<'tcx>(\n+        cx: &ConstCx<'_, 'tcx>,\n+        adt: &'tcx AdtDef,\n+        _: SubstsRef<'tcx>,\n+    ) -> bool {\n         adt.has_non_const_dtor(cx.tcx)\n     }\n }\n@@ -192,7 +204,7 @@ impl Qualif for CustomEq {\n         qualifs.custom_eq\n     }\n \n-    fn in_any_value_of_ty(cx: &ConstCx<'_, 'tcx>, ty: Ty<'tcx>) -> bool {\n+    fn in_any_value_of_ty<'tcx>(cx: &ConstCx<'_, 'tcx>, ty: Ty<'tcx>) -> bool {\n         // If *any* component of a composite data type does not implement `Structural{Partial,}Eq`,\n         // we know that at least some values of that type are not structural-match. I say \"some\"\n         // because that component may be part of an enum variant (e.g.,\n@@ -202,7 +214,7 @@ impl Qualif for CustomEq {\n         traits::search_for_structural_match_violation(id, cx.body.span, cx.tcx, ty).is_some()\n     }\n \n-    fn in_adt_inherently(\n+    fn in_adt_inherently<'tcx>(\n         cx: &ConstCx<'_, 'tcx>,\n         adt: &'tcx AdtDef,\n         substs: SubstsRef<'tcx>,\n@@ -215,7 +227,11 @@ impl Qualif for CustomEq {\n // FIXME: Use `mir::visit::Visitor` for the `in_*` functions if/when it supports early return.\n \n /// Returns `true` if this `Rvalue` contains qualif `Q`.\n-pub fn in_rvalue<Q, F>(cx: &ConstCx<'_, 'tcx>, in_local: &mut F, rvalue: &Rvalue<'tcx>) -> bool\n+pub fn in_rvalue<'tcx, Q, F>(\n+    cx: &ConstCx<'_, 'tcx>,\n+    in_local: &mut F,\n+    rvalue: &Rvalue<'tcx>,\n+) -> bool\n where\n     Q: Qualif,\n     F: FnMut(Local) -> bool,\n@@ -270,7 +286,7 @@ where\n }\n \n /// Returns `true` if this `Place` contains qualif `Q`.\n-pub fn in_place<Q, F>(cx: &ConstCx<'_, 'tcx>, in_local: &mut F, place: PlaceRef<'tcx>) -> bool\n+pub fn in_place<'tcx, Q, F>(cx: &ConstCx<'_, 'tcx>, in_local: &mut F, place: PlaceRef<'tcx>) -> bool\n where\n     Q: Qualif,\n     F: FnMut(Local) -> bool,\n@@ -302,7 +318,11 @@ where\n }\n \n /// Returns `true` if this `Operand` contains qualif `Q`.\n-pub fn in_operand<Q, F>(cx: &ConstCx<'_, 'tcx>, in_local: &mut F, operand: &Operand<'tcx>) -> bool\n+pub fn in_operand<'tcx, Q, F>(\n+    cx: &ConstCx<'_, 'tcx>,\n+    in_local: &mut F,\n+    operand: &Operand<'tcx>,\n+) -> bool\n where\n     Q: Qualif,\n     F: FnMut(Local) -> bool,"}, {"sha": "fd7febc17a3a766633ac456e871252f291c17d57", "filename": "compiler/rustc_const_eval/src/transform/check_consts/resolver.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/404c8471aba60c2d837fa728e7c729a0f52d5830/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/404c8471aba60c2d837fa728e7c729a0f52d5830/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fresolver.rs?ref=404c8471aba60c2d837fa728e7c729a0f52d5830", "patch": "@@ -28,7 +28,7 @@ struct TransferFunction<'a, 'mir, 'tcx, Q> {\n     _qualif: PhantomData<Q>,\n }\n \n-impl<Q> TransferFunction<'a, 'mir, 'tcx, Q>\n+impl<'a, 'mir, 'tcx, Q> TransferFunction<'a, 'mir, 'tcx, Q>\n where\n     Q: Qualif,\n {\n@@ -127,7 +127,7 @@ where\n     }\n }\n \n-impl<Q> Visitor<'tcx> for TransferFunction<'_, '_, 'tcx, Q>\n+impl<'tcx, Q> Visitor<'tcx> for TransferFunction<'_, '_, 'tcx, Q>\n where\n     Q: Qualif,\n {\n@@ -330,7 +330,7 @@ impl JoinSemiLattice for State {\n     }\n }\n \n-impl<Q> AnalysisDomain<'tcx> for FlowSensitiveAnalysis<'_, '_, 'tcx, Q>\n+impl<'tcx, Q> AnalysisDomain<'tcx> for FlowSensitiveAnalysis<'_, '_, 'tcx, Q>\n where\n     Q: Qualif,\n {\n@@ -350,7 +350,7 @@ where\n     }\n }\n \n-impl<Q> Analysis<'tcx> for FlowSensitiveAnalysis<'_, '_, 'tcx, Q>\n+impl<'tcx, Q> Analysis<'tcx> for FlowSensitiveAnalysis<'_, '_, 'tcx, Q>\n where\n     Q: Qualif,\n {"}, {"sha": "1537de993d197f143327f854336bb40979f19fc8", "filename": "compiler/rustc_const_eval/src/transform/promote_consts.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/404c8471aba60c2d837fa728e7c729a0f52d5830/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/404c8471aba60c2d837fa728e7c729a0f52d5830/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs?ref=404c8471aba60c2d837fa728e7c729a0f52d5830", "patch": "@@ -168,8 +168,8 @@ impl<'tcx> Visitor<'tcx> for Collector<'_, 'tcx> {\n     }\n }\n \n-pub fn collect_temps_and_candidates(\n-    ccx: &ConstCx<'mir, 'tcx>,\n+pub fn collect_temps_and_candidates<'tcx>(\n+    ccx: &ConstCx<'_, 'tcx>,\n     rpo: &mut ReversePostorder<'_, 'tcx>,\n ) -> (IndexVec<Local, TempState>, Vec<Candidate>) {\n     let mut collector = Collector {\n@@ -191,7 +191,7 @@ struct Validator<'a, 'tcx> {\n     temps: &'a IndexVec<Local, TempState>,\n }\n \n-impl std::ops::Deref for Validator<'a, 'tcx> {\n+impl<'a, 'tcx> std::ops::Deref for Validator<'a, 'tcx> {\n     type Target = ConstCx<'a, 'tcx>;\n \n     fn deref(&self) -> &Self::Target {"}, {"sha": "c3f81a3ab838f5ffb2136e1d5f981e4d7a83fd84", "filename": "compiler/rustc_const_eval/src/transform/validate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/404c8471aba60c2d837fa728e7c729a0f52d5830/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/404c8471aba60c2d837fa728e7c729a0f52d5830/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs?ref=404c8471aba60c2d837fa728e7c729a0f52d5830", "patch": "@@ -66,7 +66,7 @@ impl<'tcx> MirPass<'tcx> for Validator {\n ///\n /// The point of this function is to approximate \"equal up to subtyping\".  However,\n /// the approximation is incorrect as variance is ignored.\n-pub fn equal_up_to_regions(\n+pub fn equal_up_to_regions<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     param_env: ParamEnv<'tcx>,\n     src: Ty<'tcx>,"}, {"sha": "1807bd3654fccf196beb7b439dea15c3e5bb03b4", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/404c8471aba60c2d837fa728e7c729a0f52d5830/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/404c8471aba60c2d837fa728e7c729a0f52d5830/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=404c8471aba60c2d837fa728e7c729a0f52d5830", "patch": "@@ -522,7 +522,7 @@ pub struct GenericParam<'hir> {\n     pub kind: GenericParamKind<'hir>,\n }\n \n-impl GenericParam<'hir> {\n+impl<'hir> GenericParam<'hir> {\n     pub fn bounds_span_for_suggestions(&self) -> Option<Span> {\n         self.bounds\n             .iter()\n@@ -557,7 +557,7 @@ pub struct Generics<'hir> {\n     pub span: Span,\n }\n \n-impl Generics<'hir> {\n+impl<'hir> Generics<'hir> {\n     pub const fn empty() -> Generics<'hir> {\n         Generics {\n             params: &[],\n@@ -622,7 +622,7 @@ pub enum WherePredicate<'hir> {\n     EqPredicate(WhereEqPredicate<'hir>),\n }\n \n-impl WherePredicate<'_> {\n+impl<'hir> WherePredicate<'hir> {\n     pub fn span(&self) -> Span {\n         match self {\n             WherePredicate::BoundPredicate(p) => p.span,\n@@ -644,7 +644,7 @@ pub struct WhereBoundPredicate<'hir> {\n     pub bounds: GenericBounds<'hir>,\n }\n \n-impl WhereBoundPredicate<'hir> {\n+impl<'hir> WhereBoundPredicate<'hir> {\n     /// Returns `true` if `param_def_id` matches the `bounded_ty` of this predicate.\n     pub fn is_param_bound(&self, param_def_id: DefId) -> bool {\n         let path = match self.bounded_ty.kind {\n@@ -1236,7 +1236,7 @@ pub struct Body<'hir> {\n     pub generator_kind: Option<GeneratorKind>,\n }\n \n-impl Body<'hir> {\n+impl<'hir> Body<'hir> {\n     pub fn id(&self) -> BodyId {\n         BodyId { hir_id: self.value.hir_id }\n     }\n@@ -2623,7 +2623,7 @@ pub enum VariantData<'hir> {\n     Unit(HirId),\n }\n \n-impl VariantData<'hir> {\n+impl<'hir> VariantData<'hir> {\n     /// Return the fields of this variant.\n     pub fn fields(&self) -> &'hir [FieldDef<'hir>] {\n         match *self {"}, {"sha": "a2f1db3579a8e05261c627c2dc62c12668e43fa0", "filename": "compiler/rustc_hir/src/intravisit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/404c8471aba60c2d837fa728e7c729a0f52d5830/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/404c8471aba60c2d837fa728e7c729a0f52d5830/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs?ref=404c8471aba60c2d837fa728e7c729a0f52d5830", "patch": "@@ -139,7 +139,7 @@ pub trait Map<'hir> {\n }\n \n // Used when no map is actually available, forcing manual implementation of nested visitors.\n-impl Map<'hir> for ! {\n+impl<'hir> Map<'hir> for ! {\n     fn find(&self, _: HirId) -> Option<Node<'hir>> {\n         unreachable!()\n     }"}, {"sha": "1df9b5f9c78a95b66d070d4f76a2c987f8fad802", "filename": "compiler/rustc_hir/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/404c8471aba60c2d837fa728e7c729a0f52d5830/compiler%2Frustc_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/404c8471aba60c2d837fa728e7c729a0f52d5830/compiler%2Frustc_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Flib.rs?ref=404c8471aba60c2d837fa728e7c729a0f52d5830", "patch": "@@ -4,7 +4,6 @@\n \n #![feature(const_btree_new)]\n #![feature(crate_visibility_modifier)]\n-#![feature(in_band_lifetimes)]\n #![feature(once_cell)]\n #![feature(min_specialization)]\n #![feature(never_type)]"}, {"sha": "c8d729a999e831e15cb21a625c9a8d32d3c1bb70", "filename": "compiler/rustc_hir/src/stable_hash_impls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/404c8471aba60c2d837fa728e7c729a0f52d5830/compiler%2Frustc_hir%2Fsrc%2Fstable_hash_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/404c8471aba60c2d837fa728e7c729a0f52d5830/compiler%2Frustc_hir%2Fsrc%2Fstable_hash_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fstable_hash_impls.rs?ref=404c8471aba60c2d837fa728e7c729a0f52d5830", "patch": "@@ -211,7 +211,7 @@ impl<HirCtx: crate::HashStableContext> HashStable<HirCtx> for Item<'_> {\n     }\n }\n \n-impl<HirCtx: crate::HashStableContext> HashStable<HirCtx> for OwnerNodes<'tcx> {\n+impl<'tcx, HirCtx: crate::HashStableContext> HashStable<HirCtx> for OwnerNodes<'tcx> {\n     fn hash_stable(&self, hcx: &mut HirCtx, hasher: &mut StableHasher) {\n         // We ignore the `nodes` and `bodies` fields since these refer to information included in\n         // `hash` which is hashed in the collector and used for the crate hash.\n@@ -221,7 +221,7 @@ impl<HirCtx: crate::HashStableContext> HashStable<HirCtx> for OwnerNodes<'tcx> {\n     }\n }\n \n-impl<HirCtx: crate::HashStableContext> HashStable<HirCtx> for AttributeMap<'tcx> {\n+impl<'tcx, HirCtx: crate::HashStableContext> HashStable<HirCtx> for AttributeMap<'tcx> {\n     fn hash_stable(&self, hcx: &mut HirCtx, hasher: &mut StableHasher) {\n         // We ignore the `map` since it refers to information included in `hash` which is hashed in\n         // the collector and used for the crate hash."}, {"sha": "ee661793a44aae74cc7f042cd140f94ad32d1db2", "filename": "compiler/rustc_mir_transform/src/reveal_all.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/404c8471aba60c2d837fa728e7c729a0f52d5830/compiler%2Frustc_mir_transform%2Fsrc%2Freveal_all.rs", "raw_url": "https://github.com/rust-lang/rust/raw/404c8471aba60c2d837fa728e7c729a0f52d5830/compiler%2Frustc_mir_transform%2Fsrc%2Freveal_all.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Freveal_all.rs?ref=404c8471aba60c2d837fa728e7c729a0f52d5830", "patch": "@@ -36,6 +36,9 @@ impl<'tcx> MutVisitor<'tcx> for RevealAllVisitor<'tcx> {\n \n     #[inline]\n     fn visit_ty(&mut self, ty: &mut Ty<'tcx>, _: TyContext) {\n-        *ty = self.tcx.normalize_erasing_regions(self.param_env, ty);\n+        // We have to use `try_normalize_erasing_regions` here, since it's\n+        // possible that we visit impossible-to-satisfy where clauses here,\n+        // see #91745\n+        *ty = self.tcx.try_normalize_erasing_regions(self.param_env, *ty).unwrap_or(ty);\n     }\n }"}, {"sha": "61c82f031dd5b055ae639ca5570afdaa0da79e71", "filename": "compiler/rustc_passes/src/weak_lang_items.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/404c8471aba60c2d837fa728e7c729a0f52d5830/compiler%2Frustc_passes%2Fsrc%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/404c8471aba60c2d837fa728e7c729a0f52d5830/compiler%2Frustc_passes%2Fsrc%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fweak_lang_items.rs?ref=404c8471aba60c2d837fa728e7c729a0f52d5830", "patch": "@@ -67,10 +67,16 @@ fn verify<'tcx>(tcx: TyCtxt<'tcx>, items: &lang_items::LanguageItems) {\n             } else if item == LangItem::Oom {\n                 if !tcx.features().default_alloc_error_handler {\n                     tcx.sess.err(\"`#[alloc_error_handler]` function required, but not found\");\n-                    tcx.sess.note_without_error(\"Use `#![feature(default_alloc_error_handler)]` for a default error handler\");\n+                    tcx.sess.note_without_error(\"use `#![feature(default_alloc_error_handler)]` for a default error handler\");\n                 }\n             } else {\n-                tcx.sess.err(&format!(\"language item required, but not found: `{}`\", name));\n+                tcx\n+                    .sess\n+                    .diagnostic()\n+                    .struct_err(&format!(\"language item required, but not found: `{}`\", name))\n+                    .note(&format!(\"this can occur when a binary crate with `#![no_std]` is compiled for a target where `{}` is defined in the standard library\", name))\n+                    .help(&format!(\"you may be able to compile for a target that doesn't need `{}`, specify a target with `--target` or in `.cargo/config`\", name))\n+                    .emit();\n             }\n         }\n     }"}, {"sha": "f11c93e933996e328109c295ded2e9cdfb13e4f4", "filename": "compiler/rustc_type_ir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/404c8471aba60c2d837fa728e7c729a0f52d5830/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/404c8471aba60c2d837fa728e7c729a0f52d5830/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs?ref=404c8471aba60c2d837fa728e7c729a0f52d5830", "patch": "@@ -559,6 +559,7 @@ impl<CTX> HashStable<CTX> for FloatTy {\n impl<CTX> HashStable<CTX> for InferTy {\n     fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {\n         use InferTy::*;\n+        discriminant(self).hash_stable(ctx, hasher);\n         match self {\n             TyVar(v) => v.as_u32().hash_stable(ctx, hasher),\n             IntVar(v) => v.index.hash_stable(ctx, hasher),"}, {"sha": "6fc6002d551be633b48d8f2401531c09ef1efe3c", "filename": "library/alloc/src/collections/binary_heap.rs", "status": "modified", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/404c8471aba60c2d837fa728e7c729a0f52d5830/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/404c8471aba60c2d837fa728e7c729a0f52d5830/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap.rs?ref=404c8471aba60c2d837fa728e7c729a0f52d5830", "patch": "@@ -149,6 +149,7 @@ use core::mem::{self, swap, ManuallyDrop};\n use core::ops::{Deref, DerefMut};\n use core::ptr;\n \n+use crate::collections::TryReserveError;\n use crate::slice;\n use crate::vec::{self, AsIntoIter, Vec};\n \n@@ -953,6 +954,84 @@ impl<T> BinaryHeap<T> {\n         self.data.reserve(additional);\n     }\n \n+    /// Tries to reserve the minimum capacity for exactly `additional`\n+    /// elements to be inserted in the given `BinaryHeap<T>`. After calling\n+    /// `try_reserve_exact`, capacity will be greater than or equal to\n+    /// `self.len() + additional` if it returns `Ok(())`.\n+    /// Does nothing if the capacity is already sufficient.\n+    ///\n+    /// Note that the allocator may give the collection more space than it\n+    /// requests. Therefore, capacity can not be relied upon to be precisely\n+    /// minimal. Prefer [`try_reserve`] if future insertions are expected.\n+    ///\n+    /// [`try_reserve`]: BinaryHeap::try_reserve\n+    ///\n+    /// # Errors\n+    ///\n+    /// If the capacity overflows, or the allocator reports a failure, then an error\n+    /// is returned.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(try_reserve_2)]\n+    /// use std::collections::BinaryHeap;\n+    /// use std::collections::TryReserveError;\n+    ///\n+    /// fn find_max_slow(data: &[u32]) -> Result<Option<u32>, TryReserveError> {\n+    ///     let mut heap = BinaryHeap::new();\n+    ///\n+    ///     // Pre-reserve the memory, exiting if we can't\n+    ///     heap.try_reserve_exact(data.len())?;\n+    ///\n+    ///     // Now we know this can't OOM in the middle of our complex work\n+    ///     heap.extend(data.iter());\n+    ///\n+    ///     Ok(heap.pop())\n+    /// }\n+    /// # find_max_slow(&[1, 2, 3]).expect(\"why is the test harness OOMing on 12 bytes?\");\n+    /// ```\n+    #[unstable(feature = \"try_reserve_2\", issue = \"91789\")]\n+    pub fn try_reserve_exact(&mut self, additional: usize) -> Result<(), TryReserveError> {\n+        self.data.try_reserve_exact(additional)\n+    }\n+\n+    /// Tries to reserve capacity for at least `additional` more elements to be inserted\n+    /// in the given `BinaryHeap<T>`. The collection may reserve more space to avoid\n+    /// frequent reallocations. After calling `try_reserve`, capacity will be\n+    /// greater than or equal to `self.len() + additional`. Does nothing if\n+    /// capacity is already sufficient.\n+    ///\n+    /// # Errors\n+    ///\n+    /// If the capacity overflows, or the allocator reports a failure, then an error\n+    /// is returned.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(try_reserve_2)]\n+    /// use std::collections::BinaryHeap;\n+    /// use std::collections::TryReserveError;\n+    ///\n+    /// fn find_max_slow(data: &[u32]) -> Result<Option<u32>, TryReserveError> {\n+    ///     let mut heap = BinaryHeap::new();\n+    ///\n+    ///     // Pre-reserve the memory, exiting if we can't\n+    ///     heap.try_reserve(data.len())?;\n+    ///\n+    ///     // Now we know this can't OOM in the middle of our complex work\n+    ///     heap.extend(data.iter());\n+    ///\n+    ///     Ok(heap.pop())\n+    /// }\n+    /// # find_max_slow(&[1, 2, 3]).expect(\"why is the test harness OOMing on 12 bytes?\");\n+    /// ```\n+    #[unstable(feature = \"try_reserve_2\", issue = \"91789\")]\n+    pub fn try_reserve(&mut self, additional: usize) -> Result<(), TryReserveError> {\n+        self.data.try_reserve(additional)\n+    }\n+\n     /// Discards as much additional capacity as possible.\n     ///\n     /// # Examples"}, {"sha": "783a4b08ec19fd29089c59f866145c3d639d7d59", "filename": "library/core/src/mem/maybe_uninit.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/404c8471aba60c2d837fa728e7c729a0f52d5830/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/404c8471aba60c2d837fa728e7c729a0f52d5830/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs?ref=404c8471aba60c2d837fa728e7c729a0f52d5830", "patch": "@@ -394,10 +394,11 @@ impl<T> MaybeUninit<T> {\n     /// // This is undefined behavior. \u26a0\ufe0f\n     /// ```\n     #[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n+    #[rustc_const_unstable(feature = \"const_maybe_uninit_zeroed\", issue = \"91850\")]\n     #[must_use]\n     #[inline]\n     #[rustc_diagnostic_item = \"maybe_uninit_zeroed\"]\n-    pub fn zeroed() -> MaybeUninit<T> {\n+    pub const fn zeroed() -> MaybeUninit<T> {\n         let mut u = MaybeUninit::<T>::uninit();\n         // SAFETY: `u.as_mut_ptr()` points to allocated memory.\n         unsafe {"}, {"sha": "39a66c08de0981ba517eef27a72e0f4cc1514d3b", "filename": "src/test/ui/extern-flag/empty-extern-arg.stderr", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/404c8471aba60c2d837fa728e7c729a0f52d5830/src%2Ftest%2Fui%2Fextern-flag%2Fempty-extern-arg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/404c8471aba60c2d837fa728e7c729a0f52d5830/src%2Ftest%2Fui%2Fextern-flag%2Fempty-extern-arg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fextern-flag%2Fempty-extern-arg.stderr?ref=404c8471aba60c2d837fa728e7c729a0f52d5830", "patch": "@@ -1,6 +1,9 @@\n error: extern location for std does not exist: \n \n error: language item required, but not found: `eh_personality`\n+   |\n+   = note: this can occur when a binary crate with `#![no_std]` is compiled for a target where `eh_personality` is defined in the standard library\n+   = help: you may be able to compile for a target that doesn't need `eh_personality`, specify a target with `--target` or in `.cargo/config`\n \n error: `#[panic_handler]` function required, but not found\n "}, {"sha": "ca3d66b1c8eb7d9cb96551589f5a97b26da50e31", "filename": "src/test/ui/mir/issue-91745.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/404c8471aba60c2d837fa728e7c729a0f52d5830/src%2Ftest%2Fui%2Fmir%2Fissue-91745.rs", "raw_url": "https://github.com/rust-lang/rust/raw/404c8471aba60c2d837fa728e7c729a0f52d5830/src%2Ftest%2Fui%2Fmir%2Fissue-91745.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmir%2Fissue-91745.rs?ref=404c8471aba60c2d837fa728e7c729a0f52d5830", "patch": "@@ -0,0 +1,21 @@\n+// check-pass\n+\n+pub trait Foo {\n+    type Bar;\n+}\n+\n+pub trait Broken {\n+    type Assoc;\n+    fn broken(&self) where Self::Assoc: Foo;\n+}\n+\n+impl<T> Broken for T {\n+    type Assoc = ();\n+    fn broken(&self) where Self::Assoc: Foo {\n+        let _x: <Self::Assoc as Foo>::Bar;\n+    }\n+}\n+\n+fn main() {\n+    let _m: &dyn Broken<Assoc=()> = &();\n+}"}, {"sha": "995fa7cf85e965761f4748d51f19f235c6ad92dd", "filename": "src/test/ui/missing/missing-alloc_error_handler.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/404c8471aba60c2d837fa728e7c729a0f52d5830/src%2Ftest%2Fui%2Fmissing%2Fmissing-alloc_error_handler.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/404c8471aba60c2d837fa728e7c729a0f52d5830/src%2Ftest%2Fui%2Fmissing%2Fmissing-alloc_error_handler.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmissing%2Fmissing-alloc_error_handler.stderr?ref=404c8471aba60c2d837fa728e7c729a0f52d5830", "patch": "@@ -1,6 +1,6 @@\n error: `#[alloc_error_handler]` function required, but not found\n \n-note: Use `#![feature(default_alloc_error_handler)]` for a default error handler\n+note: use `#![feature(default_alloc_error_handler)]` for a default error handler\n \n error: aborting due to previous error\n "}, {"sha": "cc25f08e33a80daee3add086ccdf6562078abb58", "filename": "src/test/ui/panic-handler/weak-lang-item.stderr", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/404c8471aba60c2d837fa728e7c729a0f52d5830/src%2Ftest%2Fui%2Fpanic-handler%2Fweak-lang-item.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/404c8471aba60c2d837fa728e7c729a0f52d5830/src%2Ftest%2Fui%2Fpanic-handler%2Fweak-lang-item.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpanic-handler%2Fweak-lang-item.stderr?ref=404c8471aba60c2d837fa728e7c729a0f52d5830", "patch": "@@ -11,6 +11,9 @@ LL | extern crate core as other_core;\n    |\n \n error: language item required, but not found: `eh_personality`\n+   |\n+   = note: this can occur when a binary crate with `#![no_std]` is compiled for a target where `eh_personality` is defined in the standard library\n+   = help: you may be able to compile for a target that doesn't need `eh_personality`, specify a target with `--target` or in `.cargo/config`\n \n error: `#[panic_handler]` function required, but not found\n "}, {"sha": "f435ff09dc3af1123bc9b153b5c6d846904a2a7e", "filename": "src/test/ui/traits/vtable/issue-91807.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/404c8471aba60c2d837fa728e7c729a0f52d5830/src%2Ftest%2Fui%2Ftraits%2Fvtable%2Fissue-91807.rs", "raw_url": "https://github.com/rust-lang/rust/raw/404c8471aba60c2d837fa728e7c729a0f52d5830/src%2Ftest%2Fui%2Ftraits%2Fvtable%2Fissue-91807.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fvtable%2Fissue-91807.rs?ref=404c8471aba60c2d837fa728e7c729a0f52d5830", "patch": "@@ -0,0 +1,17 @@\n+// check-pass\n+// incremental\n+\n+struct Struct<T>(T);\n+\n+impl<T> std::ops::Deref for Struct<T> {\n+    type Target = dyn Fn(T);\n+    fn deref(&self) -> &Self::Target {\n+        unimplemented!()\n+    }\n+}\n+\n+fn main() {\n+    let f = Struct(Default::default());\n+    f(0);\n+    f(0);\n+}"}]}