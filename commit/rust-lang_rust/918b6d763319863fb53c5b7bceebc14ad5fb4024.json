{"sha": "918b6d763319863fb53c5b7bceebc14ad5fb4024", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkxOGI2ZDc2MzMxOTg2M2ZiNTNjNWI3YmNlZWJjMTRhZDVmYjQwMjQ=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2018-01-16T08:24:38Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2018-03-08T07:08:14Z"}, "message": "Produce  instead of pointers", "tree": {"sha": "02ca8d896e88377b900153d517665fa7c747b2ab", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/02ca8d896e88377b900153d517665fa7c747b2ab"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/918b6d763319863fb53c5b7bceebc14ad5fb4024", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEYFTdM4NKd7XQft77pp+NIls619kFAlqg4V4ACgkQpp+NIls6\n19nV0w/8Dl0kYe90SzrSWa1dFK2meHdbLHeda/GPGrZYwN9idLDVx90bJACD3bKx\nApJWn4jt7R2anxdJAHmFzsZfgtYXpSWD6Vi0NRr2GrRnPJB18FHFRQ/PzDjM8ACw\nUHoIc5rr9ub2MjIXXJBayuAoSVQbilqqQvsfxv6tqbEZkiy21kBfVJJT+riu6BbR\nAKIuyFmXV1p4sJn5A1MNyk6Xe38PABT7+hguMl2HNWx2RPDX/23Hw2EVtCrpOWne\neSteSJJFCCQCUs36B9jzqqrLg0lh6uLC6vABUc5sm51ydbDWD67vhMldjbIOe/uM\nrly0kWaG6rwqtXIFCswoC6sgmL/S3Wp1rxo1LTnqsj1XSqIIfsSoGtly9Ho2Fowf\n6UlLEY9PFtwl5/0uqG8/LOSbd9i8NPKDMrpg8Za3TRwz9ggEWlCADW4cvd+wGmRz\nsr7DUQseGcJ2SLWC94sA7+3Naddk4x9s9QWCfjs+D5dUZpIOmDx7nJ+sOp13Dpp/\nUvKdifK2mp6zdEylzRlvTZ8/S7RqxS3Yf6iMU7Ba4ZsCrf40L0U/shcYGM9+oWGa\naFwK9B7AZyJxqz8SEaBqjNu3UNeMsLo0jpLDX7o55Q4VrUwisoSEAMKP5yUovwDg\naSW7sG2Z7hLNUtL4Hutu7BT3oo5S/RRtML7wCFzPifGtpI7mITs=\n=g+L3\n-----END PGP SIGNATURE-----", "payload": "tree 02ca8d896e88377b900153d517665fa7c747b2ab\nparent c0574c054c1979a4d77822d4fe36ba7571760b00\nauthor Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1516091078 +0100\ncommitter Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1520492894 +0100\n\nProduce  instead of pointers\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/918b6d763319863fb53c5b7bceebc14ad5fb4024", "html_url": "https://github.com/rust-lang/rust/commit/918b6d763319863fb53c5b7bceebc14ad5fb4024", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/918b6d763319863fb53c5b7bceebc14ad5fb4024/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c0574c054c1979a4d77822d4fe36ba7571760b00", "url": "https://api.github.com/repos/rust-lang/rust/commits/c0574c054c1979a4d77822d4fe36ba7571760b00", "html_url": "https://github.com/rust-lang/rust/commit/c0574c054c1979a4d77822d4fe36ba7571760b00"}], "stats": {"total": 2028, "additions": 1496, "deletions": 532}, "files": [{"sha": "6602643dc5106f6101b575b214851777dade3760", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=918b6d763319863fb53c5b7bceebc14ad5fb4024", "patch": "@@ -427,6 +427,7 @@ impl<T: Ord> Ord for Reverse<T> {\n ///     }\n /// }\n /// ```\n+#[cfg_attr(not(stage0), lang = \"ord\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Ord: Eq + PartialOrd<Self> {\n     /// This method returns an `Ordering` between `self` and `other`.\n@@ -596,7 +597,8 @@ impl PartialOrd for Ordering {\n /// assert_eq!(x < y, true);\n /// assert_eq!(x.lt(&y), true);\n /// ```\n-#[lang = \"ord\"]\n+#[cfg_attr(stage0, lang = \"ord\")]\n+#[cfg_attr(not(stage0), lang = \"partial_ord\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_on_unimplemented = \"can't compare `{Self}` with `{Rhs}`\"]\n pub trait PartialOrd<Rhs: ?Sized = Self>: PartialEq<Rhs> {"}, {"sha": "15e1d38be695025b4253ab216f319f4be99de903", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=918b6d763319863fb53c5b7bceebc14ad5fb4024", "patch": "@@ -63,6 +63,7 @@\n use hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX};\n use hir::map::DefPathHash;\n use hir::{HirId, ItemLocalId};\n+use mir;\n \n use ich::Fingerprint;\n use ty::{TyCtxt, Instance, InstanceDef, ParamEnv, ParamEnvAnd, PolyTraitRef, Ty};"}, {"sha": "cf322010e05c3a57904c6a635cc0899cbd977d0c", "filename": "src/librustc/middle/const_val.rs", "status": "modified", "additions": 32, "deletions": 7, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc%2Fmiddle%2Fconst_val.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc%2Fmiddle%2Fconst_val.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_val.rs?ref=918b6d763319863fb53c5b7bceebc14ad5fb4024", "patch": "@@ -14,7 +14,7 @@ use hir::def_id::DefId;\n use ty::{self, TyCtxt, layout};\n use ty::subst::Substs;\n use rustc_const_math::*;\n-use mir::interpret::Value;\n+use mir::interpret::{Value, PrimVal};\n \n use graphviz::IntoCow;\n use errors::DiagnosticBuilder;\n@@ -39,7 +39,7 @@ pub enum ConstVal<'tcx> {\n     Function(DefId, &'tcx Substs<'tcx>),\n     Aggregate(ConstAggregate<'tcx>),\n     Unevaluated(DefId, &'tcx Substs<'tcx>),\n-    /// A miri value, currently only produced if old ctfe fails, but miri succeeds\n+    /// A miri value, currently only produced if --miri is enabled\n     Value(Value),\n }\n \n@@ -71,12 +71,37 @@ impl<'tcx> Decodable for ConstAggregate<'tcx> {\n }\n \n impl<'tcx> ConstVal<'tcx> {\n-    pub fn to_const_int(&self) -> Option<ConstInt> {\n+    pub fn to_u128(&self) -> Option<u128> {\n         match *self {\n-            ConstVal::Integral(i) => Some(i),\n-            ConstVal::Bool(b) => Some(ConstInt::U8(b as u8)),\n-            ConstVal::Char(ch) => Some(ConstInt::U32(ch as u32)),\n-            _ => None\n+            ConstVal::Integral(i) => i.to_u128(),\n+            ConstVal::Bool(b) => Some(b as u128),\n+            ConstVal::Char(ch) => Some(ch as u32 as u128),\n+            ConstVal::Value(Value::ByVal(PrimVal::Bytes(b))) => {\n+                Some(b)\n+            },\n+            _ => None,\n+        }\n+    }\n+    pub fn unwrap_u64(&self) -> u64 {\n+        match self.to_u128() {\n+            Some(val) => {\n+                assert_eq!(val as u64 as u128, val);\n+                val as u64\n+            },\n+            None => bug!(\"expected constant u64, got {:#?}\", self),\n+        }\n+    }\n+    pub fn unwrap_usize<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> ConstUsize {\n+        match *self {\n+            ConstVal::Integral(ConstInt::Usize(i)) => i,\n+            ConstVal::Value(Value::ByVal(PrimVal::Bytes(b))) => {\n+                assert_eq!(b as u64 as u128, b);\n+                match ConstUsize::new(b as u64, tcx.sess.target.usize_ty) {\n+                    Ok(val) => val,\n+                    Err(e) => bug!(\"{:#?} is not a usize {:?}\", self, e),\n+                }\n+            },\n+            _ => bug!(\"expected constant u64, got {:#?}\", self),\n         }\n     }\n }"}, {"sha": "3b37031cf461452978a78fa6a4760262543b4514", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=918b6d763319863fb53c5b7bceebc14ad5fb4024", "patch": "@@ -280,6 +280,7 @@ language_item_table! {\n     GeneratorTraitLangItem,          \"generator\",               gen_trait;\n \n     EqTraitLangItem,                 \"eq\",                      eq_trait;\n+    PartialOrdTraitLangItem,         \"partial_ord\",             partial_ord_trait;\n     OrdTraitLangItem,                \"ord\",                     ord_trait;\n \n     // A number of panic-related lang items. The `panic` item corresponds to"}, {"sha": "1c60ae36cd334354245f1d043737f0c1f117c090", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=918b6d763319863fb53c5b7bceebc14ad5fb4024", "patch": "@@ -913,8 +913,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n \n         // Always promote `[T; 0]` (even when e.g. borrowed mutably).\n         let promotable = match expr_ty.sty {\n-            ty::TyArray(_, len) if\n-                len.val.to_const_int().and_then(|i| i.to_u64()) == Some(0) => true,\n+            ty::TyArray(_, len) if len.val.to_u128() == Some(0) => true,\n             _ => promotable,\n         };\n "}, {"sha": "c00956c0a8570445281d519f9be07352a64d6725", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=918b6d763319863fb53c5b7bceebc14ad5fb4024", "patch": "@@ -1,6 +1,7 @@\n #![allow(unknown_lints)]\n \n use ty::layout::{Align, HasDataLayout};\n+use ty;\n \n use super::{EvalResult, MemoryPointer, PointerArithmetic};\n use syntax::ast::FloatTy;\n@@ -36,6 +37,15 @@ pub enum Value {\n     ByValPair(PrimVal, PrimVal),\n }\n \n+impl<'tcx> ty::TypeFoldable<'tcx> for Value {\n+    fn super_fold_with<'gcx: 'tcx, F: ty::fold::TypeFolder<'gcx, 'tcx>>(&self, _: &mut F) -> Self {\n+        *self\n+    }\n+    fn super_visit_with<V: ty::fold::TypeVisitor<'tcx>>(&self, _: &mut V) -> bool {\n+        false\n+    }\n+}\n+\n /// A wrapper type around `PrimVal` that cannot be turned back into a `PrimVal` accidentally.\n /// This type clears up a few APIs where having a `PrimVal` argument for something that is\n /// potentially an integer pointer or a pointer to an allocation was unclear."}, {"sha": "d35cbd0027fb68e41d52da076a82ce1a59bfc93f", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 67, "deletions": 13, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=918b6d763319863fb53c5b7bceebc14ad5fb4024", "patch": "@@ -15,7 +15,7 @@\n use graphviz::IntoCow;\n use middle::const_val::ConstVal;\n use middle::region;\n-use rustc_const_math::{ConstUsize, ConstInt, ConstMathErr};\n+use rustc_const_math::{ConstUsize, ConstMathErr};\n use rustc_data_structures::sync::{Lrc};\n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n use rustc_data_structures::control_flow_graph::dominators::{Dominators, dominators};\n@@ -25,9 +25,11 @@ use rustc_serialize as serialize;\n use hir::def::CtorKind;\n use hir::def_id::DefId;\n use mir::visit::MirVisitable;\n+use mir::interpret::{Value, PrimVal};\n use ty::subst::{Subst, Substs};\n use ty::{self, AdtDef, ClosureSubsts, Region, Ty, TyCtxt, GeneratorInterior};\n use ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n+use ty::TypeAndMut;\n use util::ppaux;\n use std::slice;\n use hir::{self, InlineAsm};\n@@ -707,7 +709,7 @@ pub enum TerminatorKind<'tcx> {\n \n         /// Possible values. The locations to branch to in each case\n         /// are found in the corresponding indices from the `targets` vector.\n-        values: Cow<'tcx, [ConstInt]>,\n+        values: Cow<'tcx, [u128]>,\n \n         /// Possible branch sites. The last element of this vector is used\n         /// for the otherwise branch, so targets.len() == values.len() + 1\n@@ -858,7 +860,7 @@ impl<'tcx> Terminator<'tcx> {\n impl<'tcx> TerminatorKind<'tcx> {\n     pub fn if_<'a, 'gcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>, cond: Operand<'tcx>,\n                          t: BasicBlock, f: BasicBlock) -> TerminatorKind<'tcx> {\n-        static BOOL_SWITCH_FALSE: &'static [ConstInt] = &[ConstInt::U8(0)];\n+        static BOOL_SWITCH_FALSE: &'static [u128] = &[0];\n         TerminatorKind::SwitchInt {\n             discr: cond,\n             switch_ty: tcx.types.bool,\n@@ -1144,12 +1146,16 @@ impl<'tcx> TerminatorKind<'tcx> {\n         match *self {\n             Return | Resume | Abort | Unreachable | GeneratorDrop => vec![],\n             Goto { .. } => vec![\"\".into()],\n-            SwitchInt { ref values, .. } => {\n+            SwitchInt { ref values, switch_ty, .. } => {\n                 values.iter()\n-                      .map(|const_val| {\n-                          let mut buf = String::new();\n-                          fmt_const_val(&mut buf, &ConstVal::Integral(*const_val)).unwrap();\n-                          buf.into()\n+                      .map(|&u| {\n+                          let mut s = String::new();\n+                          print_miri_value(\n+                              Value::ByVal(PrimVal::Bytes(u)),\n+                              switch_ty,\n+                              &mut s,\n+                          ).unwrap();\n+                          s.into()\n                       })\n                       .chain(iter::once(String::from(\"otherwise\").into()))\n                       .collect()\n@@ -1533,7 +1539,12 @@ impl<'tcx> Operand<'tcx> {\n             ty,\n             literal: Literal::Value {\n                 value: tcx.mk_const(ty::Const {\n-                    val: ConstVal::Function(def_id, substs),\n+                    val: if tcx.sess.opts.debugging_opts.miri {\n+                        // ZST function type\n+                        ConstVal::Value(Value::ByVal(PrimVal::Undef))\n+                    } else {\n+                        ConstVal::Function(def_id, substs)\n+                    },\n                     ty\n                 })\n             },\n@@ -1853,7 +1864,7 @@ impl<'tcx> Debug for Literal<'tcx> {\n         match *self {\n             Value { value } => {\n                 write!(fmt, \"const \")?;\n-                fmt_const_val(fmt, &value.val)\n+                fmt_const_val(fmt, value)\n             }\n             Promoted { index } => {\n                 write!(fmt, \"{:?}\", index)\n@@ -1863,9 +1874,9 @@ impl<'tcx> Debug for Literal<'tcx> {\n }\n \n /// Write a `ConstVal` in a way closer to the original source code than the `Debug` output.\n-fn fmt_const_val<W: Write>(fmt: &mut W, const_val: &ConstVal) -> fmt::Result {\n+fn fmt_const_val<W: Write>(fmt: &mut W, const_val: &ty::Const) -> fmt::Result {\n     use middle::const_val::ConstVal::*;\n-    match *const_val {\n+    match const_val.val {\n         Float(f) => write!(fmt, \"{:?}\", f),\n         Integral(n) => write!(fmt, \"{}\", n),\n         Str(s) => write!(fmt, \"{:?}\", s),\n@@ -1882,7 +1893,41 @@ fn fmt_const_val<W: Write>(fmt: &mut W, const_val: &ConstVal) -> fmt::Result {\n         Function(def_id, _) => write!(fmt, \"{}\", item_path_str(def_id)),\n         Aggregate(_) => bug!(\"`ConstVal::{:?}` should not be in MIR\", const_val),\n         Unevaluated(..) => write!(fmt, \"{:?}\", const_val),\n-        Value(val) => write!(fmt, \"{:?}\", val),\n+        Value(val) => print_miri_value(val, const_val.ty, fmt),\n+    }\n+}\n+\n+fn print_miri_value<W: Write>(value: Value, ty: Ty, f: &mut W) -> fmt::Result {\n+    use ty::TypeVariants::*;\n+    use rustc_const_math::ConstFloat;\n+    match (value, &ty.sty) {\n+        (Value::ByVal(PrimVal::Bytes(0)), &TyBool) => write!(f, \"false\"),\n+        (Value::ByVal(PrimVal::Bytes(1)), &TyBool) => write!(f, \"true\"),\n+        (Value::ByVal(PrimVal::Bytes(bits)), &TyFloat(fty)) =>\n+            write!(f, \"{}\", ConstFloat { bits, ty: fty }),\n+        (Value::ByVal(PrimVal::Bytes(n)), &TyUint(ui)) => write!(f, \"{:?}{}\", n, ui),\n+        (Value::ByVal(PrimVal::Bytes(n)), &TyInt(i)) => write!(f, \"{:?}{}\", n as i128, i),\n+        (Value::ByVal(PrimVal::Bytes(n)), &TyChar) =>\n+            write!(f, \"{:?}\", ::std::char::from_u32(n as u32).unwrap()),\n+        (Value::ByVal(PrimVal::Undef), &TyFnDef(did, _)) =>\n+            write!(f, \"{}\", item_path_str(did)),\n+        (Value::ByValPair(PrimVal::Ptr(ptr), PrimVal::Bytes(len)), &TyRef(_, TypeAndMut {\n+            ty: &ty::TyS { sty: TyStr, .. }, ..\n+        })) => {\n+            ty::tls::with(|tcx| {\n+                let alloc = tcx\n+                    .interpret_interner\n+                    .borrow()\n+                    .get_alloc(ptr.alloc_id.0)\n+                    .expect(\"miri alloc not found\");\n+                assert_eq!(len as usize as u128, len);\n+                let slice = &alloc.bytes[(ptr.offset as usize)..][..(len as usize)];\n+                let s = ::std::str::from_utf8(slice)\n+                    .expect(\"non utf8 str from miri\");\n+                write!(f, \"{:?}\", s)\n+            })\n+        },\n+        _ => write!(f, \"{:?}:{}\", value, ty),\n     }\n }\n \n@@ -2468,6 +2513,15 @@ impl<'tcx, B, V, T> TypeFoldable<'tcx> for Projection<'tcx, B, V, T>\n     }\n }\n \n+impl<'tcx> TypeFoldable<'tcx> for Field {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, _: &mut F) -> Self {\n+        *self\n+    }\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, _: &mut V) -> bool {\n+        false\n+    }\n+}\n+\n impl<'tcx> TypeFoldable<'tcx> for Constant<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         Constant {"}, {"sha": "067c1742040bfb3b7447d2e0d51e0c569e994909", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=918b6d763319863fb53c5b7bceebc14ad5fb4024", "patch": "@@ -70,7 +70,7 @@ impl<'a, 'gcx, 'tcx> PlaceTy<'tcx> {\n                 PlaceTy::Ty {\n                     ty: match ty.sty {\n                         ty::TyArray(inner, size) => {\n-                            let size = size.val.to_const_int().unwrap().to_u64().unwrap();\n+                            let size = size.val.unwrap_u64();\n                             let len = size - (from as u64) - (to as u64);\n                             tcx.mk_array(inner, len)\n                         }"}, {"sha": "54d3ed38d65370f163a348b75ab84158d9265d5b", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=918b6d763319863fb53c5b7bceebc14ad5fb4024", "patch": "@@ -243,12 +243,6 @@ macro_rules! make_mir_visitor {\n                 self.super_generator_interior(interior);\n             }\n \n-            fn visit_const_int(&mut self,\n-                               const_int: &ConstInt,\n-                               _: Location) {\n-                self.super_const_int(const_int);\n-            }\n-\n             fn visit_const_usize(&mut self,\n                                  const_usize: & $($mutability)* ConstUsize,\n                                  _: Location) {\n@@ -426,13 +420,10 @@ macro_rules! make_mir_visitor {\n \n                     TerminatorKind::SwitchInt { ref $($mutability)* discr,\n                                                 ref $($mutability)* switch_ty,\n-                                                ref values,\n+                                                values: _,\n                                                 ref targets } => {\n                         self.visit_operand(discr, source_location);\n                         self.visit_ty(switch_ty, TyContext::Location(source_location));\n-                        for value in &values[..] {\n-                            self.visit_const_int(value, source_location);\n-                        }\n                         for &target in targets {\n                             self.visit_branch(block, target);\n                         }\n@@ -798,9 +789,6 @@ macro_rules! make_mir_visitor {\n                                     _substs: & $($mutability)* ClosureSubsts<'tcx>) {\n             }\n \n-            fn super_const_int(&mut self, _const_int: &ConstInt) {\n-            }\n-\n             fn super_const_usize(&mut self, _const_usize: & $($mutability)* ConstUsize) {\n             }\n "}, {"sha": "17926eeec0020033254faa17729649c322de0845", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 37, "deletions": 2, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=918b6d763319863fb53c5b7bceebc14ad5fb4024", "patch": "@@ -30,7 +30,8 @@ use middle::cstore::EncodedMetadata;\n use middle::lang_items;\n use middle::resolve_lifetime::{self, ObjectLifetimeDefault};\n use middle::stability;\n-use mir::{Mir, interpret};\n+use mir::{self, Mir, interpret};\n+use mir::interpret::{Value, PrimVal};\n use ty::subst::{Kind, Substs};\n use ty::ReprOptions;\n use ty::Instance;\n@@ -1267,6 +1268,36 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.get_lang_items(LOCAL_CRATE)\n     }\n \n+    pub fn is_binop_lang_item(&self, def_id: DefId) -> Option<(mir::BinOp, bool)> {\n+        let items = self.lang_items();\n+        let def_id = Some(def_id);\n+        if items.i128_add_fn() == def_id { Some((mir::BinOp::Add, false)) }\n+        else if items.u128_add_fn() == def_id { Some((mir::BinOp::Add, false)) }\n+        else if items.i128_sub_fn() == def_id { Some((mir::BinOp::Sub, false)) }\n+        else if items.u128_sub_fn() == def_id { Some((mir::BinOp::Sub, false)) }\n+        else if items.i128_mul_fn() == def_id { Some((mir::BinOp::Mul, false)) }\n+        else if items.u128_mul_fn() == def_id { Some((mir::BinOp::Mul, false)) }\n+        else if items.i128_div_fn() == def_id { Some((mir::BinOp::Div, false)) }\n+        else if items.u128_div_fn() == def_id { Some((mir::BinOp::Div, false)) }\n+        else if items.i128_rem_fn() == def_id { Some((mir::BinOp::Rem, false)) }\n+        else if items.u128_rem_fn() == def_id { Some((mir::BinOp::Rem, false)) }\n+        else if items.i128_shl_fn() == def_id { Some((mir::BinOp::Shl, false)) }\n+        else if items.u128_shl_fn() == def_id { Some((mir::BinOp::Shl, false)) }\n+        else if items.i128_shr_fn() == def_id { Some((mir::BinOp::Shr, false)) }\n+        else if items.u128_shr_fn() == def_id { Some((mir::BinOp::Shr, false)) }\n+        else if items.i128_addo_fn() == def_id { Some((mir::BinOp::Add, true)) }\n+        else if items.u128_addo_fn() == def_id { Some((mir::BinOp::Add, true)) }\n+        else if items.i128_subo_fn() == def_id { Some((mir::BinOp::Sub, true)) }\n+        else if items.u128_subo_fn() == def_id { Some((mir::BinOp::Sub, true)) }\n+        else if items.i128_mulo_fn() == def_id { Some((mir::BinOp::Mul, true)) }\n+        else if items.u128_mulo_fn() == def_id { Some((mir::BinOp::Mul, true)) }\n+        else if items.i128_shlo_fn() == def_id { Some((mir::BinOp::Shl, true)) }\n+        else if items.u128_shlo_fn() == def_id { Some((mir::BinOp::Shl, true)) }\n+        else if items.i128_shro_fn() == def_id { Some((mir::BinOp::Shr, true)) }\n+        else if items.u128_shro_fn() == def_id { Some((mir::BinOp::Shr, true)) }\n+        else { None }\n+    }\n+\n     pub fn stability(self) -> Lrc<stability::Index<'tcx>> {\n         self.stability_index(LOCAL_CRATE)\n     }\n@@ -2068,7 +2099,11 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn mk_array_const_usize(self, ty: Ty<'tcx>, n: ConstUsize) -> Ty<'tcx> {\n         self.mk_ty(TyArray(ty, self.mk_const(ty::Const {\n-            val: ConstVal::Integral(ConstInt::Usize(n)),\n+            val: if self.sess.opts.debugging_opts.miri {\n+                ConstVal::Value(Value::ByVal(PrimVal::Bytes(n.as_u64().into())))\n+            } else {\n+                ConstVal::Integral(ConstInt::Usize(n))\n+            },\n             ty: self.types.usize\n         })))\n     }"}, {"sha": "07920c58271cd63dc135762dfcb731271a44c5a2", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=918b6d763319863fb53c5b7bceebc14ad5fb4024", "patch": "@@ -11,6 +11,7 @@\n use hir::def_id::DefId;\n use middle::const_val::ConstVal;\n use ty::{self, BoundRegion, Region, Ty, TyCtxt};\n+use mir::interpret::{Value, PrimVal};\n \n use std::fmt;\n use syntax::abi;\n@@ -186,10 +187,12 @@ impl<'a, 'gcx, 'lcx, 'tcx> ty::TyS<'tcx> {\n             ty::TyAdt(def, _) => format!(\"{} `{}`\", def.descr(), tcx.item_path_str(def.did)),\n             ty::TyForeign(def_id) => format!(\"extern type `{}`\", tcx.item_path_str(def_id)),\n             ty::TyArray(_, n) => {\n-                if let ConstVal::Integral(ConstInt::Usize(n)) = n.val {\n-                    format!(\"array of {} elements\", n)\n-                } else {\n-                    \"array\".to_string()\n+                match n.val {\n+                    ConstVal::Integral(ConstInt::Usize(n)) =>\n+                        format!(\"array of {} elements\", n),\n+                    ConstVal::Value(Value::ByVal(PrimVal::Bytes(n))) =>\n+                        format!(\"array of {} elements\", n),\n+                    _ => \"array\".to_string(),\n                 }\n             }\n             ty::TySlice(_) => \"slice\".to_string(),"}, {"sha": "bfaa661b2432d1f349f38f7622c6d62eb1445ab1", "filename": "src/librustc/ty/inhabitedness/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs?ref=918b6d763319863fb53c5b7bceebc14ad5fb4024", "patch": "@@ -262,7 +262,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n                 }))\n             },\n             TyArray(ty, len) => {\n-                match len.val.to_const_int().and_then(|i| i.to_u64()) {\n+                match len.val.to_u128() {\n                     // If the array is definitely non-empty, it's uninhabited if\n                     // the type of its elements is uninhabited.\n                     Some(n) if n != 0 => ty.uninhabited_from(visited, tcx),"}, {"sha": "35d8fb2a67ac975d3fd400cb89418ee8aa5bfeb7", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=918b6d763319863fb53c5b7bceebc14ad5fb4024", "patch": "@@ -952,7 +952,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n         enum StructKind {\n             /// A tuple, closure, or univariant which cannot be coerced to unsized.\n             AlwaysSized,\n-            /// A univariant, the last field of which may be coerced to unsized.\n+            /// A univariant, the last field of which fn compute_uncachedmay be coerced to unsized.\n             MaybeUnsized,\n             /// A univariant, but with a prefix of an arbitrary size & alignment (e.g. enum tag).\n             Prefixed(Size, Align),\n@@ -1237,7 +1237,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                 }\n \n                 let element = self.layout_of(element)?;\n-                let count = count.val.to_const_int().unwrap().to_u64().unwrap();\n+                let count = count.val.unwrap_u64();\n                 let size = element.size.checked_mul(count, dl)\n                     .ok_or(LayoutError::SizeOverflow(ty))?;\n "}, {"sha": "ef1c8a8d4fa44e85ec777153d6be0dffb2322bec", "filename": "src/librustc/ty/maps/config.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs?ref=918b6d763319863fb53c5b7bceebc14ad5fb4024", "patch": "@@ -13,6 +13,7 @@ use hir::def_id::{CrateNum, DefId, DefIndex};\n use ty::{self, Ty, TyCtxt};\n use ty::maps::queries;\n use ty::subst::Substs;\n+use mir;\n \n use std::hash::Hash;\n use syntax_pos::symbol::InternedString;"}, {"sha": "3dd482ad1640108d2e4620f9b5d69e526a0a7eb5", "filename": "src/librustc/ty/maps/keys.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc%2Fty%2Fmaps%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc%2Fty%2Fmaps%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fkeys.rs?ref=918b6d763319863fb53c5b7bceebc14ad5fb4024", "patch": "@@ -14,6 +14,7 @@ use hir::def_id::{CrateNum, DefId, LOCAL_CRATE, DefIndex};\n use ty::{self, Ty, TyCtxt};\n use ty::subst::Substs;\n use ty::fast_reject::SimplifiedType;\n+use mir;\n \n use std::fmt::Debug;\n use std::hash::Hash;"}, {"sha": "77e022fe7300394a9b2d83cd58f14910595fd746", "filename": "src/librustc/ty/maps/on_disk_cache.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs?ref=918b6d763319863fb53c5b7bceebc14ad5fb4024", "patch": "@@ -15,7 +15,7 @@ use hir::def_id::{CrateNum, DefIndex, DefId, LocalDefId,\n                   RESERVED_FOR_INCR_COMP_CACHE, LOCAL_CRATE};\n use hir::map::definitions::DefPathHash;\n use ich::{CachingCodemapView, Fingerprint};\n-use mir;\n+use mir::{self, interpret};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::Lrc;\n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n@@ -542,6 +542,13 @@ impl<'a, 'tcx: 'a, 'x> ty_codec::TyDecoder<'a, 'tcx> for CacheDecoder<'a, 'tcx,\n \n implement_ty_decoder!( CacheDecoder<'a, 'tcx, 'x> );\n \n+\n+impl<'a, 'tcx, 'x> SpecializedDecoder<interpret::AllocId> for CacheDecoder<'a, 'tcx, 'x> {\n+    fn specialized_decode(&mut self) -> Result<interpret::AllocId, Self::Error> {\n+        unimplemented!()\n+    }\n+}\n+\n impl<'a, 'tcx, 'x> SpecializedDecoder<Span> for CacheDecoder<'a, 'tcx, 'x> {\n     fn specialized_decode(&mut self) -> Result<Span, Self::Error> {\n         let tag: u8 = Decodable::decode(self)?;"}, {"sha": "1577e78d81e22e273e4da5c102f9d722cca4077e", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=918b6d763319863fb53c5b7bceebc14ad5fb4024", "patch": "@@ -26,6 +26,7 @@ use middle::lang_items::{FnTraitLangItem, FnMutTraitLangItem, FnOnceTraitLangIte\n use middle::privacy::AccessLevels;\n use middle::resolve_lifetime::ObjectLifetimeDefault;\n use mir::Mir;\n+use mir::interpret::{Value, PrimVal};\n use mir::GeneratorLayout;\n use session::CrateDisambiguator;\n use traits;\n@@ -1838,6 +1839,19 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n                     Ok(&ty::Const { val: ConstVal::Integral(v), .. }) => {\n                         discr = v;\n                     }\n+                    Ok(&ty::Const {\n+                        val: ConstVal::Value(Value::ByVal(PrimVal::Bytes(b))),\n+                        ..\n+                    }) => {\n+                        trace!(\"discriminants: {} ({:?})\", b, repr_type);\n+                        use syntax::attr::IntType;\n+                        discr = match repr_type {\n+                            IntType::SignedInt(int_type) => ConstInt::new_signed(\n+                                b as i128, int_type, tcx.sess.target.isize_ty).unwrap(),\n+                            IntType::UnsignedInt(uint_type) => ConstInt::new_unsigned(\n+                                b, uint_type, tcx.sess.target.usize_ty).unwrap(),\n+                        };\n+                    }\n                     err => {\n                         if !expr_did.is_local() {\n                             span_bug!(tcx.def_span(expr_did),\n@@ -1879,6 +1893,20 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n                             explicit_value = v;\n                             break;\n                         }\n+                        Ok(&ty::Const {\n+                            val: ConstVal::Value(Value::ByVal(PrimVal::Bytes(b))),\n+                            ..\n+                        }) => {\n+                            trace!(\"discriminants: {} ({:?})\", b, repr_type);\n+                            use syntax::attr::IntType;\n+                            explicit_value = match repr_type {\n+                                IntType::SignedInt(int_type) => ConstInt::new_signed(\n+                                    b as i128, int_type, tcx.sess.target.isize_ty).unwrap(),\n+                                IntType::UnsignedInt(uint_type) => ConstInt::new_unsigned(\n+                                    b, uint_type, tcx.sess.target.usize_ty).unwrap(),\n+                            };\n+                            break;\n+                        }\n                         err => {\n                             if !expr_did.is_local() {\n                                 span_bug!(tcx.def_span(expr_did),"}, {"sha": "bac78508993a5c1dca48b8d8c8b99df9d19dbe51", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=918b6d763319863fb53c5b7bceebc14ad5fb4024", "patch": "@@ -20,6 +20,7 @@ use ty::subst::{UnpackedKind, Substs};\n use ty::{self, Ty, TyCtxt, TypeFoldable};\n use ty::fold::{TypeVisitor, TypeFolder};\n use ty::error::{ExpectedFound, TypeError};\n+use mir::interpret::{Value, PrimVal};\n use util::common::ErrorReported;\n use std::rc::Rc;\n use std::iter;\n@@ -483,6 +484,7 @@ pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n             let to_u64 = |x: &'tcx ty::Const<'tcx>| -> Result<u64, ErrorReported> {\n                 match x.val {\n                     ConstVal::Integral(x) => Ok(x.to_u64().unwrap()),\n+                    ConstVal::Value(Value::ByVal(prim)) => Ok(prim.to_u64().unwrap()),\n                     ConstVal::Unevaluated(def_id, substs) => {\n                         // FIXME(eddyb) get the right param_env.\n                         let param_env = ty::ParamEnv::empty(Reveal::UserFacing);\n@@ -492,6 +494,13 @@ pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n                                     Ok(&ty::Const { val: ConstVal::Integral(x), .. }) => {\n                                         return Ok(x.to_u64().unwrap());\n                                     }\n+                                    Ok(&ty::Const {\n+                                        val: ConstVal::Value(Value::ByVal(PrimVal::Bytes(b))),\n+                                        ..\n+                                    }) => {\n+                                        assert_eq!(b as u64 as u128, b);\n+                                        return Ok(b as u64);\n+                                    }\n                                     _ => {}\n                                 }\n                             }"}, {"sha": "80250949b0b4af64985ed8652b4bc8f3f0d94e3e", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=918b6d763319863fb53c5b7bceebc14ad5fb4024", "patch": "@@ -890,6 +890,61 @@ impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::Slice<Ty<'tcx>> {\n     }\n }\n \n+impl<'tcx> TypeFoldable<'tcx> for ty::instance::Instance<'tcx> {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+        use ty::InstanceDef::*;\n+        Self {\n+            substs: self.substs.fold_with(folder),\n+            def: match self.def {\n+                Item(did) => Item(did.fold_with(folder)),\n+                Intrinsic(did) => Intrinsic(did.fold_with(folder)),\n+                FnPtrShim(did, ty) => FnPtrShim(\n+                    did.fold_with(folder),\n+                    ty.fold_with(folder),\n+                ),\n+                Virtual(did, i) => Virtual(\n+                    did.fold_with(folder),\n+                    i,\n+                ),\n+                ClosureOnceShim { call_once } => ClosureOnceShim {\n+                    call_once: call_once.fold_with(folder),\n+                },\n+                DropGlue(did, ty) => DropGlue(\n+                    did.fold_with(folder),\n+                    ty.fold_with(folder),\n+                ),\n+                CloneShim(did, ty) => CloneShim(\n+                    did.fold_with(folder),\n+                    ty.fold_with(folder),\n+                ),\n+            },\n+        }\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        use ty::InstanceDef::*;\n+        self.substs.visit_with(visitor) ||\n+        match self.def {\n+            Item(did) => did.visit_with(visitor),\n+            Intrinsic(did) => did.visit_with(visitor),\n+            FnPtrShim(did, ty) => {\n+                did.visit_with(visitor) ||\n+                ty.visit_with(visitor)\n+            },\n+            Virtual(did, _) => did.visit_with(visitor),\n+            ClosureOnceShim { call_once } => call_once.visit_with(visitor),\n+            DropGlue(did, ty) => {\n+                did.visit_with(visitor) ||\n+                ty.visit_with(visitor)\n+            },\n+            CloneShim(did, ty) => {\n+                did.visit_with(visitor) ||\n+                ty.visit_with(visitor)\n+            },\n+        }\n+    }\n+}\n+\n impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         let sty = match self.sty {"}, {"sha": "6ad2901ce3a100210e13ae67c0b96192dd0d5830", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=918b6d763319863fb53c5b7bceebc14ad5fb4024", "patch": "@@ -24,6 +24,7 @@ use ty::maps::TyCtxtAt;\n use ty::TypeVariants::*;\n use util::common::ErrorReported;\n use middle::lang_items;\n+use mir::interpret::{Value, PrimVal};\n \n use rustc_const_math::{ConstInt, ConstIsize, ConstUsize};\n use rustc_data_structures::stable_hasher::{StableHasher, StableHasherResult,\n@@ -765,6 +766,7 @@ impl<'a, 'gcx, 'tcx, W> TypeVisitor<'tcx> for TypeIdHasher<'a, 'gcx, 'tcx, W>\n                 self.hash_discriminant_u8(&n.val);\n                 match n.val {\n                     ConstVal::Integral(x) => self.hash(x.to_u64().unwrap()),\n+                    ConstVal::Value(Value::ByVal(PrimVal::Bytes(b))) => self.hash(b),\n                     ConstVal::Unevaluated(def_id, _) => self.def_id(def_id),\n                     _ => bug!(\"arrays should not have {:?} as length\", n)\n                 }"}, {"sha": "63d1f1468251b219dd87d2a04190d1f93e8c3a52", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=918b6d763319863fb53c5b7bceebc14ad5fb4024", "patch": "@@ -21,6 +21,7 @@ use ty::{TyClosure, TyGenerator, TyGeneratorWitness, TyForeign, TyProjection, Ty\n use ty::{TyDynamic, TyInt, TyUint, TyInfer};\n use ty::{self, Ty, TyCtxt, TypeFoldable};\n use util::nodemap::FxHashSet;\n+use mir::interpret::{Value, PrimVal};\n \n use std::cell::Cell;\n use std::fmt;\n@@ -1168,6 +1169,9 @@ define_print! {\n                         ConstVal::Integral(ConstInt::Usize(sz)) => {\n                             write!(f, \"{}\", sz)?;\n                         }\n+                        ConstVal::Value(Value::ByVal(PrimVal::Bytes(sz))) => {\n+                            write!(f, \"{}\", sz)?;\n+                        }\n                         ConstVal::Unevaluated(_def_id, substs) => {\n                             write!(f, \"<unevaluated{:?}>\", &substs[..])?;\n                         }"}, {"sha": "9e9eb4a81d035d4a06779589a597e6d682da5427", "filename": "src/librustc_const_eval/_match.rs", "status": "modified", "additions": 148, "deletions": 32, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc_const_eval%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc_const_eval%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2F_match.rs?ref=918b6d763319863fb53c5b7bceebc14ad5fb4024", "patch": "@@ -28,6 +28,7 @@ use rustc::hir::RangeEnd;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n \n use rustc::mir::Field;\n+use rustc::mir::interpret::{Value, PrimVal};\n use rustc::util::common::ErrorReported;\n \n use syntax_pos::{Span, DUMMY_SP};\n@@ -195,6 +196,41 @@ impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n                         }\n                     })).collect()\n                 }\n+                box PatternKind::Constant {\n+                    value: &ty::Const { val: ConstVal::Value(b), ty }\n+                } => {\n+                    match b {\n+                        Value::ByVal(PrimVal::Ptr(ptr)) => {\n+                            let is_array_ptr = ty\n+                                .builtin_deref(true, ty::NoPreference)\n+                                .and_then(|t| t.ty.builtin_index())\n+                                .map_or(false, |t| t == tcx.types.u8);\n+                            assert!(is_array_ptr);\n+                            let alloc = tcx\n+                                .interpret_interner\n+                                .borrow()\n+                                .get_alloc(ptr.alloc_id.0)\n+                                .unwrap();\n+                            assert_eq!(ptr.offset, 0);\n+                            // FIXME: check length\n+                            alloc.bytes.iter().map(|b| {\n+                                &*pattern_arena.alloc(Pattern {\n+                                    ty: tcx.types.u8,\n+                                    span: pat.span,\n+                                    kind: box PatternKind::Constant {\n+                                        value: tcx.mk_const(ty::Const {\n+                                            val: ConstVal::Value(Value::ByVal(\n+                                                PrimVal::Bytes(*b as u128),\n+                                            )),\n+                                            ty: tcx.types.u8\n+                                        })\n+                                    }\n+                                })\n+                            }).collect()\n+                        },\n+                        _ => bug!(\"not a byte str: {:?}\", b),\n+                    }\n+                }\n                 _ => span_bug!(pat.span, \"unexpected byte array pattern {:?}\", pat)\n             }\n         }).clone()\n@@ -422,13 +458,17 @@ fn all_constructors<'a, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n         ty::TyBool => {\n             [true, false].iter().map(|&b| {\n                 ConstantValue(cx.tcx.mk_const(ty::Const {\n-                    val: ConstVal::Bool(b),\n+                    val: if cx.tcx.sess.opts.debugging_opts.miri {\n+                        ConstVal::Value(Value::ByVal(PrimVal::Bytes(b as u128)))\n+                    } else {\n+                        ConstVal::Bool(b)\n+                    },\n                     ty: cx.tcx.types.bool\n                 }))\n             }).collect()\n         }\n-        ty::TyArray(ref sub_ty, len) if len.val.to_const_int().is_some() => {\n-            let len = len.val.to_const_int().unwrap().to_u64().unwrap();\n+        ty::TyArray(ref sub_ty, len) if len.val.to_u128().is_some() => {\n+            let len = len.val.unwrap_u64();\n             if len != 0 && cx.is_uninhabited(sub_ty) {\n                 vec![]\n             } else {\n@@ -461,7 +501,7 @@ fn all_constructors<'a, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n }\n \n fn max_slice_length<'p, 'a: 'p, 'tcx: 'a, I>(\n-    _cx: &mut MatchCheckCtxt<'a, 'tcx>,\n+    cx: &mut MatchCheckCtxt<'a, 'tcx>,\n     patterns: I) -> u64\n     where I: Iterator<Item=&'p Pattern<'tcx>>\n {\n@@ -538,6 +578,25 @@ fn max_slice_length<'p, 'a: 'p, 'tcx: 'a, I>(\n             PatternKind::Constant { value: &ty::Const { val: ConstVal::ByteStr(b), .. } } => {\n                 max_fixed_len = cmp::max(max_fixed_len, b.data.len() as u64);\n             }\n+            PatternKind::Constant {\n+                value: &ty::Const {\n+                    val: ConstVal::Value(Value::ByVal(PrimVal::Ptr(ptr))),\n+                    ty,\n+                }\n+            } => {\n+                let is_array_ptr = ty\n+                    .builtin_deref(true, ty::NoPreference)\n+                    .and_then(|t| t.ty.builtin_index())\n+                    .map_or(false, |t| t == cx.tcx.types.u8);\n+                if is_array_ptr {\n+                    let alloc = cx.tcx\n+                        .interpret_interner\n+                        .borrow()\n+                        .get_alloc(ptr.alloc_id.0)\n+                        .unwrap();\n+                    max_fixed_len = cmp::max(max_fixed_len, alloc.bytes.len() as u64);\n+                }\n+            }\n             PatternKind::Slice { ref prefix, slice: None, ref suffix } => {\n                 let fixed_len = prefix.len() as u64 + suffix.len() as u64;\n                 max_fixed_len = cmp::max(max_fixed_len, fixed_len);\n@@ -581,7 +640,7 @@ pub fn is_useful<'p, 'a: 'p, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n                                        witness: WitnessPreference)\n                                        -> Usefulness<'tcx> {\n     let &Matrix(ref rows) = matrix;\n-    debug!(\"is_useful({:?}, {:?})\", matrix, v);\n+    debug!(\"is_useful({:#?}, {:#?})\", matrix, v);\n \n     // The base case. We are pattern-matching on () and the return value is\n     // based on whether our matrix has a row or not.\n@@ -626,10 +685,10 @@ pub fn is_useful<'p, 'a: 'p, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n         max_slice_length: max_slice_length(cx, rows.iter().map(|r| r[0]).chain(Some(v[0])))\n     };\n \n-    debug!(\"is_useful_expand_first_col: pcx={:?}, expanding {:?}\", pcx, v[0]);\n+    debug!(\"is_useful_expand_first_col: pcx={:#?}, expanding {:#?}\", pcx, v[0]);\n \n     if let Some(constructors) = pat_constructors(cx, v[0], pcx) {\n-        debug!(\"is_useful - expanding constructors: {:?}\", constructors);\n+        debug!(\"is_useful - expanding constructors: {:#?}\", constructors);\n         constructors.into_iter().map(|c|\n             is_useful_specialized(cx, matrix, v, c.clone(), pcx.ty, witness)\n         ).find(|result| result.is_useful()).unwrap_or(NotUseful)\n@@ -639,9 +698,9 @@ pub fn is_useful<'p, 'a: 'p, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n         let used_ctors: Vec<Constructor> = rows.iter().flat_map(|row| {\n             pat_constructors(cx, row[0], pcx).unwrap_or(vec![])\n         }).collect();\n-        debug!(\"used_ctors = {:?}\", used_ctors);\n+        debug!(\"used_ctors = {:#?}\", used_ctors);\n         let all_ctors = all_constructors(cx, pcx);\n-        debug!(\"all_ctors = {:?}\", all_ctors);\n+        debug!(\"all_ctors = {:#?}\", all_ctors);\n         let missing_ctors: Vec<Constructor> = all_ctors.iter().filter(|c| {\n             !used_ctors.contains(*c)\n         }).cloned().collect();\n@@ -669,7 +728,7 @@ pub fn is_useful<'p, 'a: 'p, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n             all_ctors.is_empty() && !cx.is_uninhabited(pcx.ty);\n         let is_declared_nonexhaustive =\n             cx.is_non_exhaustive_enum(pcx.ty) && !cx.is_local(pcx.ty);\n-        debug!(\"missing_ctors={:?} is_privately_empty={:?} is_declared_nonexhaustive={:?}\",\n+        debug!(\"missing_ctors={:#?} is_privately_empty={:#?} is_declared_nonexhaustive={:#?}\",\n                missing_ctors, is_privately_empty, is_declared_nonexhaustive);\n \n         // For privately empty and non-exhaustive enums, we work as if there were an \"extra\"\n@@ -769,7 +828,7 @@ fn is_useful_specialized<'p, 'a:'p, 'tcx: 'a>(\n     lty: Ty<'tcx>,\n     witness: WitnessPreference) -> Usefulness<'tcx>\n {\n-    debug!(\"is_useful_specialized({:?}, {:?}, {:?})\", v, ctor, lty);\n+    debug!(\"is_useful_specialized({:#?}, {:#?}, {:?})\", v, ctor, lty);\n     let sub_pat_tys = constructor_sub_pattern_tys(cx, &ctor, lty);\n     let wild_patterns_owned: Vec<_> = sub_pat_tys.iter().map(|ty| {\n         Pattern {\n@@ -821,7 +880,7 @@ fn pat_constructors<'tcx>(_cx: &mut MatchCheckCtxt,\n             Some(vec![ConstantRange(lo, hi, end)]),\n         PatternKind::Array { .. } => match pcx.ty.sty {\n             ty::TyArray(_, length) => Some(vec![\n-                Slice(length.val.to_const_int().unwrap().to_u64().unwrap())\n+                Slice(length.val.unwrap_u64())\n             ]),\n             _ => span_bug!(pat.span, \"bad ty {:?} for array pattern\", pcx.ty)\n         },\n@@ -842,7 +901,7 @@ fn pat_constructors<'tcx>(_cx: &mut MatchCheckCtxt,\n /// For instance, a tuple pattern (_, 42, Some([])) has the arity of 3.\n /// A struct pattern's arity is the number of fields it contains, etc.\n fn constructor_arity(_cx: &MatchCheckCtxt, ctor: &Constructor, ty: Ty) -> u64 {\n-    debug!(\"constructor_arity({:?}, {:?})\", ctor, ty);\n+    debug!(\"constructor_arity({:#?}, {:?})\", ctor, ty);\n     match ty.sty {\n         ty::TyTuple(ref fs, _) => fs.len() as u64,\n         ty::TySlice(..) | ty::TyArray(..) => match *ctor {\n@@ -866,12 +925,13 @@ fn constructor_sub_pattern_tys<'a, 'tcx: 'a>(cx: &MatchCheckCtxt<'a, 'tcx>,\n                                              ctor: &Constructor,\n                                              ty: Ty<'tcx>) -> Vec<Ty<'tcx>>\n {\n-    debug!(\"constructor_sub_pattern_tys({:?}, {:?})\", ctor, ty);\n+    debug!(\"constructor_sub_pattern_tys({:#?}, {:?})\", ctor, ty);\n     match ty.sty {\n         ty::TyTuple(ref fs, _) => fs.into_iter().map(|t| *t).collect(),\n         ty::TySlice(ty) | ty::TyArray(ty, _) => match *ctor {\n             Slice(length) => (0..length).map(|_| ty).collect(),\n             ConstantValue(_) => vec![],\n+            Single => vec![ty],\n             _ => bug!(\"bad slice pattern {:?} {:?}\", ctor, ty)\n         },\n         ty::TyRef(_, ref ty_and_mut) => vec![ty_and_mut.ty],\n@@ -880,6 +940,9 @@ fn constructor_sub_pattern_tys<'a, 'tcx: 'a>(cx: &MatchCheckCtxt<'a, 'tcx>,\n                 // Use T as the sub pattern type of Box<T>.\n                 vec![substs.type_at(0)]\n             } else {\n+                if let ConstantValue(_) = *ctor {\n+                    return vec![];\n+                }\n                 adt.variants[ctor.variant_index_for_adt(adt)].fields.iter().map(|field| {\n                     let is_visible = adt.is_enum()\n                         || field.vis.is_accessible_from(cx.module, cx.tcx);\n@@ -901,14 +964,30 @@ fn constructor_sub_pattern_tys<'a, 'tcx: 'a>(cx: &MatchCheckCtxt<'a, 'tcx>,\n     }\n }\n \n-fn slice_pat_covered_by_constructor(_tcx: TyCtxt, _span: Span,\n+fn slice_pat_covered_by_constructor(tcx: TyCtxt, _span: Span,\n                                     ctor: &Constructor,\n                                     prefix: &[Pattern],\n                                     slice: &Option<Pattern>,\n                                     suffix: &[Pattern])\n                                     -> Result<bool, ErrorReported> {\n-    let data = match *ctor {\n+    let data: &[u8] = match *ctor {\n         ConstantValue(&ty::Const { val: ConstVal::ByteStr(b), .. }) => b.data,\n+        ConstantValue(&ty::Const { val: ConstVal::Value(\n+            Value::ByVal(PrimVal::Ptr(ptr))\n+        ), ty }) => {\n+            let is_array_ptr = ty\n+                .builtin_deref(true, ty::NoPreference)\n+                .and_then(|t| t.ty.builtin_index())\n+                .map_or(false, |t| t == tcx.types.u8);\n+            assert!(is_array_ptr);\n+            tcx\n+                .interpret_interner\n+                .borrow()\n+                .get_alloc(ptr.alloc_id.0)\n+                .unwrap()\n+                .bytes\n+                .as_ref()\n+        }\n         _ => bug!()\n     };\n \n@@ -928,6 +1007,12 @@ fn slice_pat_covered_by_constructor(_tcx: TyCtxt, _span: Span,\n                         return Ok(false);\n                     }\n                 },\n+                ConstVal::Value(Value::ByVal(PrimVal::Bytes(b))) => {\n+                    assert_eq!(b as u8 as u128, b);\n+                    if b as u8 != *ch {\n+                        return Ok(false);\n+                    }\n+                }\n                 _ => span_bug!(pat.span, \"bad const u8 {:?}\", value)\n             },\n             _ => {}\n@@ -937,32 +1022,43 @@ fn slice_pat_covered_by_constructor(_tcx: TyCtxt, _span: Span,\n     Ok(true)\n }\n \n-fn constructor_covered_by_range(tcx: TyCtxt, span: Span,\n-                                ctor: &Constructor,\n+fn constructor_covered_by_range(ctor: &Constructor,\n                                 from: &ConstVal, to: &ConstVal,\n-                                end: RangeEnd)\n+                                end: RangeEnd,\n+                                ty: Ty)\n                                 -> Result<bool, ErrorReported> {\n-    let cmp_from = |c_from| Ok(compare_const_vals(tcx, span, c_from, from)? != Ordering::Less);\n-    let cmp_to = |c_to| compare_const_vals(tcx, span, c_to, to);\n+    trace!(\"constructor_covered_by_range {:#?}, {:#?}, {:#?}, {}\", ctor, from, to, ty);\n+    let cmp_from = |c_from| compare_const_vals(c_from, from, ty)\n+        .map(|res| res != Ordering::Less);\n+    let cmp_to = |c_to| compare_const_vals(c_to, to, ty);\n+    macro_rules! some_or_ok {\n+        ($e:expr) => {\n+            match $e {\n+                Some(to) => to,\n+                None => return Ok(false), // not char or int\n+            }\n+        };\n+    }\n     match *ctor {\n         ConstantValue(value) => {\n-            let to = cmp_to(&value.val)?;\n+            let to = some_or_ok!(cmp_to(&value.val));\n             let end = (to == Ordering::Less) ||\n                       (end == RangeEnd::Included && to == Ordering::Equal);\n-            Ok(cmp_from(&value.val)? && end)\n+            Ok(some_or_ok!(cmp_from(&value.val)) && end)\n         },\n         ConstantRange(from, to, RangeEnd::Included) => {\n-            let to = cmp_to(&to.val)?;\n+            let to = some_or_ok!(cmp_to(&to.val));\n             let end = (to == Ordering::Less) ||\n                       (end == RangeEnd::Included && to == Ordering::Equal);\n-            Ok(cmp_from(&from.val)? && end)\n+            Ok(some_or_ok!(cmp_from(&from.val)) && end)\n         },\n         ConstantRange(from, to, RangeEnd::Excluded) => {\n-            let to = cmp_to(&to.val)?;\n+            let to = some_or_ok!(cmp_to(&to.val));\n             let end = (to == Ordering::Less) ||\n                       (end == RangeEnd::Excluded && to == Ordering::Equal);\n-            Ok(cmp_from(&from.val)? && end)\n+            Ok(some_or_ok!(cmp_from(&from.val)) && end)\n         }\n+        Variant(_) |\n         Single => Ok(true),\n         _ => bug!(),\n     }\n@@ -979,7 +1075,7 @@ fn patterns_for_variant<'p, 'a: 'p, 'tcx: 'a>(\n         result[subpat.field.index()] = &subpat.pattern;\n     }\n \n-    debug!(\"patterns_for_variant({:?}, {:?}) = {:?}\", subpatterns, wild_patterns, result);\n+    debug!(\"patterns_for_variant({:#?}, {:#?}) = {:#?}\", subpatterns, wild_patterns, result);\n     result\n }\n \n@@ -994,7 +1090,7 @@ fn patterns_for_variant<'p, 'a: 'p, 'tcx: 'a>(\n fn specialize<'p, 'a: 'p, 'tcx: 'a>(\n     cx: &mut MatchCheckCtxt<'a, 'tcx>,\n     r: &[&'p Pattern<'tcx>],\n-    constructor: &Constructor,\n+    constructor: &Constructor<'tcx>,\n     wild_patterns: &[&'p Pattern<'tcx>])\n     -> Option<Vec<&'p Pattern<'tcx>>>\n {\n@@ -1031,12 +1127,32 @@ fn specialize<'p, 'a: 'p, 'tcx: 'a>(\n                             None\n                         }\n                     }\n+                    ConstVal::Value(Value::ByVal(PrimVal::Ptr(ptr))) => {\n+                        let is_array_ptr = value.ty\n+                            .builtin_deref(true, ty::NoPreference)\n+                            .and_then(|t| t.ty.builtin_index())\n+                            .map_or(false, |t| t == cx.tcx.types.u8);\n+                        assert!(is_array_ptr);\n+                        let data_len = cx.tcx\n+                            .interpret_interner\n+                            .borrow()\n+                            .get_alloc(ptr.alloc_id.0)\n+                            .unwrap()\n+                            .bytes\n+                            .len();\n+                        if wild_patterns.len() == data_len {\n+                            Some(cx.lower_byte_str_pattern(pat))\n+                        } else {\n+                            None\n+                        }\n+                    }\n                     _ => span_bug!(pat.span,\n                         \"unexpected const-val {:?} with ctor {:?}\", value, constructor)\n                 },\n                 _ => {\n                     match constructor_covered_by_range(\n-                        cx.tcx, pat.span, constructor, &value.val, &value.val, RangeEnd::Included\n+                        constructor, &value.val, &value.val, RangeEnd::Included,\n+                        value.ty,\n                             ) {\n                         Ok(true) => Some(vec![]),\n                         Ok(false) => None,\n@@ -1048,7 +1164,7 @@ fn specialize<'p, 'a: 'p, 'tcx: 'a>(\n \n         PatternKind::Range { lo, hi, ref end } => {\n             match constructor_covered_by_range(\n-                cx.tcx, pat.span, constructor, &lo.val, &hi.val, end.clone()\n+                constructor, &lo.val, &hi.val, end.clone(), lo.ty,\n             ) {\n                 Ok(true) => Some(vec![]),\n                 Ok(false) => None,\n@@ -1092,7 +1208,7 @@ fn specialize<'p, 'a: 'p, 'tcx: 'a>(\n             }\n         }\n     };\n-    debug!(\"specialize({:?}, {:?}) = {:?}\", r[0], wild_patterns, head);\n+    debug!(\"specialize({:#?}, {:#?}) = {:#?}\", r[0], wild_patterns, head);\n \n     head.map(|mut head| {\n         head.extend_from_slice(&r[1 ..]);"}, {"sha": "58fe40d12be849f467d10d369837f8dfd1fe9eaf", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 95, "deletions": 85, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=918b6d763319863fb53c5b7bceebc14ad5fb4024", "patch": "@@ -26,7 +26,6 @@ use syntax::abi::Abi;\n use syntax::ast;\n use syntax::attr;\n use rustc::hir::{self, Expr};\n-use syntax_pos::Span;\n \n use std::cmp::Ordering;\n \n@@ -104,60 +103,10 @@ fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n       hir::ExprUnary(hir::UnNeg, ref inner) => {\n         // unary neg literals already got their sign during creation\n         if let hir::ExprLit(ref lit) = inner.node {\n-            use syntax::ast::*;\n-            use syntax::ast::LitIntType::*;\n-            const I8_OVERFLOW: u128 = i8::min_value() as u8 as u128;\n-            const I16_OVERFLOW: u128 = i16::min_value() as u16 as u128;\n-            const I32_OVERFLOW: u128 = i32::min_value() as u32 as u128;\n-            const I64_OVERFLOW: u128 = i64::min_value() as u64 as u128;\n-            const I128_OVERFLOW: u128 = i128::min_value() as u128;\n-            let negated = match (&lit.node, &ty.sty) {\n-                (&LitKind::Int(I8_OVERFLOW, _), &ty::TyInt(IntTy::I8)) |\n-                (&LitKind::Int(I8_OVERFLOW, Signed(IntTy::I8)), _) => {\n-                    Some(I8(i8::min_value()))\n-                },\n-                (&LitKind::Int(I16_OVERFLOW, _), &ty::TyInt(IntTy::I16)) |\n-                (&LitKind::Int(I16_OVERFLOW, Signed(IntTy::I16)), _) => {\n-                    Some(I16(i16::min_value()))\n-                },\n-                (&LitKind::Int(I32_OVERFLOW, _), &ty::TyInt(IntTy::I32)) |\n-                (&LitKind::Int(I32_OVERFLOW, Signed(IntTy::I32)), _) => {\n-                    Some(I32(i32::min_value()))\n-                },\n-                (&LitKind::Int(I64_OVERFLOW, _), &ty::TyInt(IntTy::I64)) |\n-                (&LitKind::Int(I64_OVERFLOW, Signed(IntTy::I64)), _) => {\n-                    Some(I64(i64::min_value()))\n-                },\n-                (&LitKind::Int(I128_OVERFLOW, _), &ty::TyInt(IntTy::I128)) |\n-                (&LitKind::Int(I128_OVERFLOW, Signed(IntTy::I128)), _) => {\n-                    Some(I128(i128::min_value()))\n-                },\n-                (&LitKind::Int(n, _), &ty::TyInt(IntTy::Isize)) |\n-                (&LitKind::Int(n, Signed(IntTy::Isize)), _) => {\n-                    match tcx.sess.target.isize_ty {\n-                        IntTy::I16 => if n == I16_OVERFLOW {\n-                            Some(Isize(Is16(i16::min_value())))\n-                        } else {\n-                            None\n-                        },\n-                        IntTy::I32 => if n == I32_OVERFLOW {\n-                            Some(Isize(Is32(i32::min_value())))\n-                        } else {\n-                            None\n-                        },\n-                        IntTy::I64 => if n == I64_OVERFLOW {\n-                            Some(Isize(Is64(i64::min_value())))\n-                        } else {\n-                            None\n-                        },\n-                        _ => span_bug!(e.span, \"typeck error\")\n-                    }\n-                },\n-                _ => None\n+            return match lit_to_const(&lit.node, tcx, ty, true) {\n+                Ok(val) => Ok(mk_const(val)),\n+                Err(err) => signal!(e, err),\n             };\n-            if let Some(i) = negated {\n-                return Ok(mk_const(Integral(i)));\n-            }\n         }\n         mk_const(match cx.eval(inner)?.val {\n           Float(f) => Float(-f),\n@@ -377,7 +326,7 @@ fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n           };\n           callee_cx.eval(&body.value)?\n       },\n-      hir::ExprLit(ref lit) => match lit_to_const(&lit.node, tcx, ty) {\n+      hir::ExprLit(ref lit) => match lit_to_const(&lit.node, tcx, ty, false) {\n           Ok(val) => mk_const(val),\n           Err(err) => signal!(e, err),\n       },\n@@ -438,7 +387,7 @@ fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n       }\n       hir::ExprRepeat(ref elem, _) => {\n           let n = match ty.sty {\n-            ty::TyArray(_, n) => n.val.to_const_int().unwrap().to_u64().unwrap(),\n+            ty::TyArray(_, n) => n.val.unwrap_u64(),\n             _ => span_bug!(e.span, \"typeck error\")\n           };\n           mk_const(Aggregate(Repeat(cx.eval(elem)?, n)))\n@@ -447,7 +396,8 @@ fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n         if let Aggregate(Tuple(fields)) = cx.eval(base)?.val {\n             fields[index.node]\n         } else {\n-            signal!(base, ExpectedConstTuple);\n+            span_bug!(base.span, \"{:#?}\", cx.eval(base)?.val);\n+            //signal!(base, ExpectedConstTuple);\n         }\n       }\n       hir::ExprField(ref base, field_name) => {\n@@ -557,7 +507,7 @@ fn cast_const<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             },\n             ty::TyRef(_, ty::TypeAndMut { ref ty, mutbl: hir::MutImmutable }) => match ty.sty {\n                 ty::TyArray(ty, n) => {\n-                    let n = n.val.to_const_int().unwrap().to_u64().unwrap();\n+                    let n = n.val.unwrap_u64();\n                     if ty == tcx.types.u8 && n == b.data.len() as u64 {\n                         Ok(val)\n                     } else {\n@@ -583,13 +533,66 @@ fn cast_const<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n-fn lit_to_const<'a, 'tcx>(lit: &'tcx ast::LitKind,\n+pub fn lit_to_const<'a, 'tcx>(lit: &'tcx ast::LitKind,\n                           tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                          mut ty: Ty<'tcx>)\n+                          mut ty: Ty<'tcx>,\n+                          neg: bool)\n                           -> Result<ConstVal<'tcx>, ErrKind<'tcx>> {\n     use syntax::ast::*;\n     use syntax::ast::LitIntType::*;\n \n+    if tcx.sess.opts.debugging_opts.miri {\n+        use rustc::mir::interpret::*;\n+        let lit = match *lit {\n+            LitKind::Str(ref s, _) => {\n+                let s = s.as_str();\n+                let id = tcx.allocate_cached(s.as_bytes());\n+                let ptr = MemoryPointer::new(AllocId(id), 0);\n+                Value::ByValPair(\n+                    PrimVal::Ptr(ptr),\n+                    PrimVal::from_u128(s.len() as u128),\n+                )\n+            },\n+            LitKind::ByteStr(ref data) => {\n+                let id = tcx.allocate_cached(data);\n+                let ptr = MemoryPointer::new(AllocId(id), 0);\n+                Value::ByVal(PrimVal::Ptr(ptr))\n+            },\n+            LitKind::Byte(n) => Value::ByVal(PrimVal::Bytes(n as u128)),\n+            LitKind::Int(n, _) if neg => {\n+                let n = n as i128;\n+                let n = n.overflowing_neg().0;\n+                Value::ByVal(PrimVal::Bytes(n as u128))\n+            },\n+            LitKind::Int(n, _) => Value::ByVal(PrimVal::Bytes(n as u128)),\n+            LitKind::Float(n, fty) => {\n+                let n = n.as_str();\n+                let mut f = parse_float(&n, fty)?;\n+                if neg {\n+                    f = -f;\n+                }\n+                let bits = f.bits;\n+                Value::ByVal(PrimVal::Bytes(bits))\n+            }\n+            LitKind::FloatUnsuffixed(n) => {\n+                let fty = match ty.sty {\n+                    ty::TyFloat(fty) => fty,\n+                    _ => bug!()\n+                };\n+                let n = n.as_str();\n+                let mut f = parse_float(&n, fty)?;\n+                if neg {\n+                    f = -f;\n+                }\n+                let bits = f.bits;\n+                Value::ByVal(PrimVal::Bytes(bits))\n+            }\n+            LitKind::Bool(b) => Value::ByVal(PrimVal::Bytes(b as u128)),\n+            LitKind::Char(c) => Value::ByVal(PrimVal::Bytes(c as u128)),\n+        };\n+        return Ok(ConstVal::Value(lit));\n+    }\n+\n     if let ty::TyAdt(adt, _) = ty.sty {\n         if adt.is_enum() {\n             ty = adt.repr.discr_type().to_ty(tcx)\n@@ -604,26 +607,38 @@ fn lit_to_const<'a, 'tcx>(lit: &'tcx ast::LitKind,\n             match (&ty.sty, hint) {\n                 (&ty::TyInt(ity), _) |\n                 (_, Signed(ity)) => {\n-                    Ok(Integral(ConstInt::new_signed_truncating(n as i128,\n+                    let mut n = n as i128;\n+                    if neg {\n+                        n = n.overflowing_neg().0;\n+                    }\n+                    Ok(Integral(ConstInt::new_signed_truncating(n,\n                         ity, tcx.sess.target.isize_ty)))\n                 }\n                 (&ty::TyUint(uty), _) |\n                 (_, Unsigned(uty)) => {\n-                    Ok(Integral(ConstInt::new_unsigned_truncating(n as u128,\n+                    Ok(Integral(ConstInt::new_unsigned_truncating(n,\n                         uty, tcx.sess.target.usize_ty)))\n                 }\n                 _ => bug!()\n             }\n         }\n         LitKind::Float(n, fty) => {\n-            parse_float(&n.as_str(), fty).map(Float)\n+            let mut f = parse_float(&n.as_str(), fty)?;\n+            if neg {\n+                f = -f;\n+            }\n+            Ok(Float(f))\n         }\n         LitKind::FloatUnsuffixed(n) => {\n             let fty = match ty.sty {\n                 ty::TyFloat(fty) => fty,\n                 _ => bug!()\n             };\n-            parse_float(&n.as_str(), fty).map(Float)\n+            let mut f = parse_float(&n.as_str(), fty)?;\n+            if neg {\n+                f = -f;\n+            }\n+            Ok(Float(f))\n         }\n         LitKind::Bool(b) => Ok(Bool(b)),\n         LitKind::Char(c) => Ok(Char(c)),\n@@ -638,36 +653,31 @@ fn parse_float<'tcx>(num: &str, fty: ast::FloatTy)\n     })\n }\n \n-pub fn compare_const_vals(tcx: TyCtxt, span: Span, a: &ConstVal, b: &ConstVal)\n-                          -> Result<Ordering, ErrorReported>\n-{\n-    let result = match (a, b) {\n+pub fn compare_const_vals(a: &ConstVal, b: &ConstVal, ty: Ty) -> Option<Ordering> {\n+    trace!(\"compare_const_vals: {:?}, {:?}\", a, b);\n+    use rustc::mir::interpret::{Value, PrimVal};\n+    match (a, b) {\n         (&Integral(a), &Integral(b)) => a.try_cmp(b).ok(),\n-        (&Float(a), &Float(b)) => a.try_cmp(b).ok(),\n-        (&Str(ref a), &Str(ref b)) => Some(a.cmp(b)),\n-        (&Bool(a), &Bool(b)) => Some(a.cmp(&b)),\n-        (&ByteStr(a), &ByteStr(b)) => Some(a.data.cmp(b.data)),\n         (&Char(a), &Char(b)) => Some(a.cmp(&b)),\n+        (&Value(Value::ByVal(PrimVal::Bytes(a))),\n+         &Value(Value::ByVal(PrimVal::Bytes(b)))) => {\n+            Some(if ty.is_signed() {\n+                (a as i128).cmp(&(b as i128))\n+            } else {\n+                a.cmp(&b)\n+            })\n+        },\n+        _ if a == b => Some(Ordering::Equal),\n         _ => None,\n-    };\n-\n-    match result {\n-        Some(result) => Ok(result),\n-        None => {\n-            // FIXME: can this ever be reached?\n-            tcx.sess.delay_span_bug(span,\n-                &format!(\"type mismatch comparing {:?} and {:?}\", a, b));\n-            Err(ErrorReported)\n-        }\n     }\n }\n \n impl<'a, 'tcx> ConstContext<'a, 'tcx> {\n     pub fn compare_lit_exprs(&self,\n-                             span: Span,\n                              a: &'tcx Expr,\n-                             b: &'tcx Expr) -> Result<Ordering, ErrorReported> {\n+                             b: &'tcx Expr) -> Result<Option<Ordering>, ErrorReported> {\n         let tcx = self.tcx;\n+        let ty = self.tables.expr_ty(a);\n         let a = match self.eval(a) {\n             Ok(a) => a,\n             Err(e) => {\n@@ -682,6 +692,6 @@ impl<'a, 'tcx> ConstContext<'a, 'tcx> {\n                 return Err(ErrorReported);\n             }\n         };\n-        compare_const_vals(tcx, span, &a.val, &b.val)\n+        Ok(compare_const_vals(&a.val, &b.val, ty))\n     }\n }"}, {"sha": "a2daf22c3b45bb0ac2da13ff33dc10a84536d850", "filename": "src/librustc_const_eval/pattern.rs", "status": "modified", "additions": 213, "deletions": 122, "changes": 335, "blob_url": "https://github.com/rust-lang/rust/blob/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc_const_eval%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc_const_eval%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fpattern.rs?ref=918b6d763319863fb53c5b7bceebc14ad5fb4024", "patch": "@@ -10,8 +10,9 @@\n \n use eval;\n \n-use rustc::middle::const_val::{ConstEvalErr, ConstVal};\n+use rustc::middle::const_val::{ConstEvalErr, ConstVal, ConstAggregate};\n use rustc::mir::{Field, BorrowKind, Mutability};\n+use rustc::mir::interpret::{Value, PrimVal};\n use rustc::ty::{self, TyCtxt, AdtDef, Ty, Region};\n use rustc::ty::subst::{Substs, Kind};\n use rustc::hir::{self, PatKind, RangeEnd};\n@@ -110,22 +111,35 @@ pub enum PatternKind<'tcx> {\n     },\n }\n \n-fn print_const_val(value: &ConstVal, f: &mut fmt::Formatter) -> fmt::Result {\n-    match *value {\n+fn print_const_val(value: &ty::Const, f: &mut fmt::Formatter) -> fmt::Result {\n+    match value.val {\n         ConstVal::Float(ref x) => write!(f, \"{}\", x),\n         ConstVal::Integral(ref i) => write!(f, \"{}\", i),\n         ConstVal::Str(ref s) => write!(f, \"{:?}\", &s[..]),\n         ConstVal::ByteStr(b) => write!(f, \"{:?}\", b.data),\n         ConstVal::Bool(b) => write!(f, \"{:?}\", b),\n         ConstVal::Char(c) => write!(f, \"{:?}\", c),\n+        ConstVal::Value(v) => print_miri_value(v, value.ty, f),\n         ConstVal::Variant(_) |\n         ConstVal::Function(..) |\n         ConstVal::Aggregate(_) |\n-        ConstVal::Value(_) |\n         ConstVal::Unevaluated(..) => bug!(\"{:?} not printable in a pattern\", value)\n     }\n }\n \n+fn print_miri_value(value: Value, ty: Ty, f: &mut fmt::Formatter) -> fmt::Result {\n+    use rustc::ty::TypeVariants::*;\n+    match (value, &ty.sty) {\n+        (Value::ByVal(PrimVal::Bytes(0)), &TyBool) => write!(f, \"false\"),\n+        (Value::ByVal(PrimVal::Bytes(1)), &TyBool) => write!(f, \"true\"),\n+        (Value::ByVal(PrimVal::Bytes(n)), &TyUint(..)) => write!(f, \"{:?}\", n),\n+        (Value::ByVal(PrimVal::Bytes(n)), &TyInt(..)) => write!(f, \"{:?}\", n as i128),\n+        (Value::ByVal(PrimVal::Bytes(n)), &TyChar) =>\n+            write!(f, \"{:?}\", ::std::char::from_u32(n as u32).unwrap()),\n+        _ => bug!(\"{:?}: {} not printable in a pattern\", value, ty),\n+    }\n+}\n+\n impl<'tcx> fmt::Display for Pattern<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self.kind {\n@@ -233,15 +247,15 @@ impl<'tcx> fmt::Display for Pattern<'tcx> {\n                 write!(f, \"{}\", subpattern)\n             }\n             PatternKind::Constant { value } => {\n-                print_const_val(&value.val, f)\n+                print_const_val(value, f)\n             }\n             PatternKind::Range { lo, hi, end } => {\n-                print_const_val(&lo.val, f)?;\n+                print_const_val(lo, f)?;\n                 match end {\n                     RangeEnd::Included => write!(f, \"...\")?,\n                     RangeEnd::Excluded => write!(f, \"..\")?,\n                 }\n-                print_const_val(&hi.val, f)\n+                print_const_val(hi, f)\n             }\n             PatternKind::Slice { ref prefix, ref slice, ref suffix } |\n             PatternKind::Array { ref prefix, ref slice, ref suffix } => {\n@@ -362,7 +376,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n             }\n \n             PatKind::Path(ref qpath) => {\n-                return self.lower_path(qpath, pat.hir_id, pat.id, pat.span);\n+                return self.lower_path(qpath, pat.hir_id, pat.span);\n             }\n \n             PatKind::Ref(ref subpattern, _) |\n@@ -581,7 +595,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n \n             ty::TyArray(_, len) => {\n                 // fixed-length array\n-                let len = len.val.to_const_int().unwrap().to_u64().unwrap();\n+                let len = len.val.unwrap_u64();\n                 assert!(len >= prefix.len() as u64 + suffix.len() as u64);\n                 PatternKind::Array { prefix: prefix, slice: slice, suffix: suffix }\n             }\n@@ -632,7 +646,6 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n     fn lower_path(&mut self,\n                   qpath: &hir::QPath,\n                   id: hir::HirId,\n-                  pat_id: ast::NodeId,\n                   span: Span)\n                   -> Pattern<'tcx> {\n         let ty = self.tables.node_id_to_type(id);\n@@ -644,29 +657,23 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n         let kind = match def {\n             Def::Const(def_id) | Def::AssociatedConst(def_id) => {\n                 let substs = self.tables.node_substs(id);\n-                match eval::lookup_const_by_id(self.tcx, self.param_env.and((def_id, substs))) {\n-                    Some((def_id, substs)) => {\n-                        // Enter the inlined constant's tables&substs temporarily.\n-                        let old_tables = self.tables;\n-                        let old_substs = self.substs;\n-                        self.tables = self.tcx.typeck_tables_of(def_id);\n-                        self.substs = substs;\n-                        let body = if let Some(id) = self.tcx.hir.as_local_node_id(def_id) {\n-                            self.tcx.hir.body(self.tcx.hir.body_owned_by(id))\n-                        } else {\n-                            self.tcx.extern_const_body(def_id).body\n-                        };\n-                        let pat = self.lower_const_expr(&body.value, pat_id, span);\n-                        self.tables = old_tables;\n-                        self.substs = old_substs;\n-                        return pat;\n-                    }\n-                    None => {\n-                        self.errors.push(if is_associated_const {\n-                            PatternError::AssociatedConstInPattern(span)\n-                        } else {\n-                            PatternError::StaticInPattern(span)\n-                        });\n+                match self.tcx.at(span).const_eval(self.param_env.and((def_id, substs))) {\n+                    Ok(value) => {\n+                        if self.tcx.sess.opts.debugging_opts.miri {\n+                            if let ConstVal::Value(_) = value.val {} else {\n+                                panic!(\"const eval produced non-miri value: {:#?}\", value);\n+                            }\n+                        }\n+                        let instance = ty::Instance::resolve(\n+                            self.tcx,\n+                            self.param_env,\n+                            def_id,\n+                            substs,\n+                        ).unwrap();\n+                        return self.const_to_pat(instance, value, span)\n+                    },\n+                    Err(e) => {\n+                        self.errors.push(PatternError::ConstEval(e));\n                         PatternKind::Wild\n                     }\n                 }\n@@ -682,6 +689,52 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n     }\n \n     fn lower_lit(&mut self, expr: &'tcx hir::Expr) -> PatternKind<'tcx> {\n+        if self.tcx.sess.opts.debugging_opts.miri {\n+            return match expr.node {\n+                hir::ExprLit(ref lit) => {\n+                    let ty = self.tables.expr_ty(expr);\n+                    match ::eval::lit_to_const(&lit.node, self.tcx, ty, false) {\n+                        Ok(value) => PatternKind::Constant {\n+                            value: self.tcx.mk_const(ty::Const {\n+                                ty,\n+                                val: value,\n+                            }),\n+                        },\n+                        Err(e) => {\n+                            self.errors.push(PatternError::ConstEval(ConstEvalErr {\n+                                span: lit.span,\n+                                kind: e,\n+                            }));\n+                            PatternKind::Wild\n+                        },\n+                    }\n+                },\n+                hir::ExprPath(ref qpath) => *self.lower_path(qpath, expr.hir_id, expr.span).kind,\n+                hir::ExprUnary(hir::UnNeg, ref expr) => {\n+                    let ty = self.tables.expr_ty(expr);\n+                    let lit = match expr.node {\n+                        hir::ExprLit(ref lit) => lit,\n+                        _ => span_bug!(expr.span, \"not a literal: {:?}\", expr),\n+                    };\n+                    match ::eval::lit_to_const(&lit.node, self.tcx, ty, true) {\n+                        Ok(value) => PatternKind::Constant {\n+                            value: self.tcx.mk_const(ty::Const {\n+                                ty,\n+                                val: value,\n+                            }),\n+                        },\n+                        Err(e) => {\n+                            self.errors.push(PatternError::ConstEval(ConstEvalErr {\n+                                span: lit.span,\n+                                kind: e,\n+                            }));\n+                            PatternKind::Wild\n+                        },\n+                    }\n+                }\n+                _ => span_bug!(expr.span, \"not a literal: {:?}\", expr),\n+            }\n+        }\n         let const_cx = eval::ConstContext::new(self.tcx,\n                                                self.param_env.and(self.substs),\n                                                self.tables);\n@@ -701,118 +754,156 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n         }\n     }\n \n-    fn lower_const_expr(&mut self,\n-                        expr: &'tcx hir::Expr,\n-                        pat_id: ast::NodeId,\n-                        span: Span)\n-                        -> Pattern<'tcx> {\n-        let pat_ty = self.tables.expr_ty(expr);\n-        debug!(\"expr={:?} pat_ty={:?} pat_id={}\", expr, pat_ty, pat_id);\n-        match pat_ty.sty {\n+    fn const_to_pat(\n+        &self,\n+        instance: ty::Instance<'tcx>,\n+        cv: &'tcx ty::Const<'tcx>,\n+        span: Span,\n+    ) -> Pattern<'tcx> {\n+        debug!(\"const_to_pat: cv={:#?}\", cv);\n+        let kind = match cv.ty.sty {\n             ty::TyFloat(_) => {\n                 self.tcx.sess.span_err(span, \"floating point constants cannot be used in patterns\");\n+                PatternKind::Wild\n             }\n             ty::TyAdt(adt_def, _) if adt_def.is_union() => {\n                 // Matching on union fields is unsafe, we can't hide it in constants\n                 self.tcx.sess.span_err(span, \"cannot use unions in constant patterns\");\n+                PatternKind::Wild\n             }\n+            ty::TyAdt(adt_def, _) if !self.tcx.has_attr(adt_def.did, \"structural_match\") => {\n+                let msg = format!(\"to use a constant of type `{}` in a pattern, \\\n+                                    `{}` must be annotated with `#[derive(PartialEq, Eq)]`\",\n+                                    self.tcx.item_path_str(adt_def.did),\n+                                    self.tcx.item_path_str(adt_def.did));\n+                self.tcx.sess.span_err(span, &msg);\n+                PatternKind::Wild\n+            },\n+            ty::TyAdt(adt_def, substs) if adt_def.is_enum() => {\n+                match cv.val {\n+                    ConstVal::Value(val) => {\n+                        let discr = self.tcx.const_discr(self.param_env.and((\n+                            instance, val, cv.ty\n+                        ))).unwrap();\n+                        let variant_index = adt_def\n+                            .discriminants(self.tcx)\n+                            .position(|var| var.to_u128_unchecked() == discr)\n+                            .unwrap();\n+                        PatternKind::Variant {\n+                            adt_def,\n+                            substs,\n+                            variant_index,\n+                            subpatterns: adt_def\n+                                .variants[variant_index]\n+                                .fields\n+                                .iter()\n+                                .enumerate()\n+                                .map(|(i, _)| {\n+                                let field = Field::new(i);\n+                                let val = match cv.val {\n+                                    ConstVal::Value(miri) => self.tcx.const_val_field(\n+                                        self.param_env.and((instance, field, miri, cv.ty)),\n+                                    ).unwrap(),\n+                                    _ => bug!(\"{:#?} is not a valid tuple\", cv),\n+                                };\n+                                FieldPattern {\n+                                    field,\n+                                    pattern: self.const_to_pat(instance, val, span),\n+                                }\n+                            }).collect(),\n+                        }\n+                    },\n+                    ConstVal::Variant(var_did) => {\n+                        let variant_index = adt_def\n+                            .variants\n+                            .iter()\n+                            .position(|var| var.did == var_did)\n+                            .unwrap();\n+                        PatternKind::Variant {\n+                            adt_def,\n+                            substs,\n+                            variant_index,\n+                            subpatterns: Vec::new(),\n+                        }\n+                    }\n+                    _ => return Pattern {\n+                        span,\n+                        ty: cv.ty,\n+                        kind: Box::new(PatternKind::Constant {\n+                            value: cv,\n+                        }),\n+                    }\n+                }\n+            },\n             ty::TyAdt(adt_def, _) => {\n-                if !self.tcx.has_attr(adt_def.did, \"structural_match\") {\n-                    let msg = format!(\"to use a constant of type `{}` in a pattern, \\\n-                                       `{}` must be annotated with `#[derive(PartialEq, Eq)]`\",\n-                                      self.tcx.item_path_str(adt_def.did),\n-                                      self.tcx.item_path_str(adt_def.did));\n-                    self.tcx.sess.span_err(span, &msg);\n+                let struct_var = adt_def.struct_variant();\n+                PatternKind::Leaf {\n+                    subpatterns: struct_var.fields.iter().enumerate().map(|(i, f)| {\n+                        let field = Field::new(i);\n+                        let val = match cv.val {\n+                            ConstVal::Aggregate(ConstAggregate::Struct(consts)) => {\n+                                consts.iter().find(|&&(name, _)| name == f.name).unwrap().1\n+                            },\n+                            ConstVal::Value(miri) => self.tcx.const_val_field(\n+                                self.param_env.and((instance, field, miri, cv.ty)),\n+                            ).unwrap(),\n+                            _ => bug!(\"{:#?} is not a valid tuple\", cv),\n+                        };\n+                        FieldPattern {\n+                            field,\n+                            pattern: self.const_to_pat(instance, val, span),\n+                        }\n+                    }).collect()\n                 }\n             }\n-            _ => { }\n-        }\n-        let kind = match expr.node {\n-            hir::ExprTup(ref exprs) => {\n+            ty::TyTuple(fields, _) => {\n                 PatternKind::Leaf {\n-                    subpatterns: exprs.iter().enumerate().map(|(i, expr)| {\n+                    subpatterns: (0..fields.len()).map(|i| {\n+                        let field = Field::new(i);\n+                        let val = match cv.val {\n+                            ConstVal::Aggregate(ConstAggregate::Tuple(consts)) => consts[i],\n+                            ConstVal::Value(miri) => self.tcx.const_val_field(\n+                                self.param_env.and((instance, field, miri, cv.ty)),\n+                            ).unwrap(),\n+                            _ => bug!(\"{:#?} is not a valid tuple\", cv),\n+                        };\n                         FieldPattern {\n-                            field: Field::new(i),\n-                            pattern: self.lower_const_expr(expr, pat_id, span)\n+                            field,\n+                            pattern: self.const_to_pat(instance, val, span),\n                         }\n                     }).collect()\n                 }\n             }\n-\n-            hir::ExprCall(ref callee, ref args) => {\n-                let qpath = match callee.node {\n-                    hir::ExprPath(ref qpath) => qpath,\n-                    _ => bug!()\n-                };\n-                let ty = self.tables.node_id_to_type(callee.hir_id);\n-                let def = self.tables.qpath_def(qpath, callee.hir_id);\n-                match def {\n-                    Def::Fn(..) | Def::Method(..) => self.lower_lit(expr),\n-                    _ => {\n-                        let subpatterns = args.iter().enumerate().map(|(i, expr)| {\n-                            FieldPattern {\n-                                field: Field::new(i),\n-                                pattern: self.lower_const_expr(expr, pat_id, span)\n-                            }\n-                        }).collect();\n-                        self.lower_variant_or_leaf(def, ty, subpatterns)\n-                    }\n+            ty::TyArray(_, n) => {\n+                PatternKind::Leaf {\n+                    subpatterns: (0..n.val.unwrap_u64()).map(|i| {\n+                        let i = i as usize;\n+                        let field = Field::new(i);\n+                        let val = match cv.val {\n+                            ConstVal::Aggregate(ConstAggregate::Array(consts)) => consts[i],\n+                            ConstVal::Aggregate(ConstAggregate::Repeat(cv, _)) => cv,\n+                            ConstVal::Value(miri) => self.tcx.const_val_field(\n+                                self.param_env.and((instance, field, miri, cv.ty)),\n+                            ).unwrap(),\n+                            _ => bug!(\"{:#?} is not a valid tuple\", cv),\n+                        };\n+                        FieldPattern {\n+                            field,\n+                            pattern: self.const_to_pat(instance, val, span),\n+                        }\n+                    }).collect()\n                 }\n             }\n-\n-            hir::ExprStruct(ref qpath, ref fields, None) => {\n-                let def = self.tables.qpath_def(qpath, expr.hir_id);\n-                let adt_def = match pat_ty.sty {\n-                    ty::TyAdt(adt_def, _) => adt_def,\n-                    _ => {\n-                        span_bug!(\n-                            expr.span,\n-                            \"struct expr without ADT type\");\n-                    }\n-                };\n-                let variant_def = adt_def.variant_of_def(def);\n-\n-                let subpatterns =\n-                    fields.iter()\n-                          .map(|field| {\n-                              let index = variant_def.index_of_field_named(field.name.node);\n-                              let index = index.unwrap_or_else(|| {\n-                                  span_bug!(\n-                                      expr.span,\n-                                      \"no field with name {:?}\",\n-                                      field.name);\n-                              });\n-                              FieldPattern {\n-                                  field: Field::new(index),\n-                                  pattern: self.lower_const_expr(&field.expr, pat_id, span),\n-                              }\n-                          })\n-                          .collect();\n-\n-                self.lower_variant_or_leaf(def, pat_ty, subpatterns)\n-            }\n-\n-            hir::ExprArray(ref exprs) => {\n-                let pats = exprs.iter()\n-                                .map(|expr| self.lower_const_expr(expr, pat_id, span))\n-                                .collect();\n-                PatternKind::Array {\n-                    prefix: pats,\n-                    slice: None,\n-                    suffix: vec![]\n+            _ => {\n+                PatternKind::Constant {\n+                    value: cv,\n                 }\n-            }\n-\n-            hir::ExprPath(ref qpath) => {\n-                return self.lower_path(qpath, expr.hir_id, pat_id, span);\n-            }\n-\n-            _ => self.lower_lit(expr)\n+            },\n         };\n \n         Pattern {\n             span,\n-            ty: pat_ty,\n+            ty: cv.ty,\n             kind: Box::new(kind),\n         }\n     }"}, {"sha": "70733bc6aeda042e826b95787e9ea26047baee37", "filename": "src/librustc_data_structures/stable_hasher.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc_data_structures%2Fstable_hasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc_data_structures%2Fstable_hasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fstable_hasher.rs?ref=918b6d763319863fb53c5b7bceebc14ad5fb4024", "patch": "@@ -259,6 +259,14 @@ impl<CTX> HashStable<CTX> for f64 {\n     }\n }\n \n+impl<CTX> HashStable<CTX> for ::std::cmp::Ordering {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          ctx: &mut CTX,\n+                                          hasher: &mut StableHasher<W>) {\n+        (*self as i8).hash_stable(ctx, hasher);\n+    }\n+}\n+\n impl<T1: HashStable<CTX>, CTX> HashStable<CTX> for (T1,) {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           ctx: &mut CTX,"}, {"sha": "f400ce42a90469d6eec27a65fd555e4c06bf7b41", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=918b6d763319863fb53c5b7bceebc14ad5fb4024", "patch": "@@ -16,6 +16,7 @@ use rustc::ty::{self, AdtKind, Ty, TyCtxt};\n use rustc::ty::layout::{self, LayoutOf};\n use middle::const_val::ConstVal;\n use rustc_const_eval::ConstContext;\n+use rustc::mir::interpret::{Value, PrimVal};\n use util::nodemap::FxHashSet;\n use lint::{LateContext, LintContext, LintArray};\n use lint::{LintPass, LateLintPass};\n@@ -122,6 +123,16 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                                         .map(|i| i >= bits)\n                                         .unwrap_or(true)\n                                 }\n+                                Ok(&ty::Const {\n+                                    val: ConstVal::Value(Value::ByVal(PrimVal::Bytes(b))),\n+                                    ty,\n+                                }) => {\n+                                    if ty.is_signed() {\n+                                        (b as i128) < 0\n+                                    } else {\n+                                        b >= bits as u128\n+                                    }\n+                                }\n                                 _ => false,\n                             }\n                         };"}, {"sha": "1663cab0a592e5f473400f4597d2f384b90fa7f8", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 27, "deletions": 11, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=918b6d763319863fb53c5b7bceebc14ad5fb4024", "patch": "@@ -276,38 +276,54 @@ impl<'a, 'tcx> SpecializedDecoder<DefIndex> for DecodeContext<'a, 'tcx> {\n impl<'a, 'tcx> SpecializedDecoder<interpret::AllocId> for DecodeContext<'a, 'tcx> {\n     fn specialized_decode(&mut self) -> Result<interpret::AllocId, Self::Error> {\n         const MAX1: usize = usize::max_value() - 1;\n-        let mut interpret_interner = self.tcx.unwrap().interpret_interner.borrow_mut();\n+        let tcx = self.tcx;\n+        let interpret_interner = || tcx.unwrap().interpret_interner.borrow_mut();\n         let pos = self.position();\n-        match self.read_usize()? {\n+        match usize::decode(self)? {\n             ::std::usize::MAX => {\n+                let id = interpret_interner().reserve();\n+                let alloc_id = interpret::AllocId(id);\n+                trace!(\"creating alloc id {:?} at {}\", alloc_id, pos);\n+                // insert early to allow recursive allocs\n+                self.interpret_alloc_cache.insert(pos, alloc_id);\n+\n                 let allocation = interpret::Allocation::decode(self)?;\n-                let id = interpret_interner.reserve();\n+                trace!(\"decoded alloc {:?} {:#?}\", alloc_id, allocation);\n                 let allocation = self.tcx.unwrap().intern_const_alloc(allocation);\n-                interpret_interner.intern_at_reserved(id, allocation);\n-                let id = interpret::AllocId(id);\n-                self.interpret_alloc_cache.insert(pos, id);\n+                interpret_interner().intern_at_reserved(id, allocation);\n \n                 let num = usize::decode(self)?;\n                 let ptr = interpret::Pointer {\n                     primval: interpret::PrimVal::Ptr(interpret::MemoryPointer {\n-                        alloc_id: id,\n+                        alloc_id,\n                         offset: 0,\n                     }),\n                 };\n                 for _ in 0..num {\n                     let glob = interpret::GlobalId::decode(self)?;\n-                    interpret_interner.cache(glob, ptr);\n+                    interpret_interner().cache(glob, ptr);\n                 }\n \n-                Ok(id)\n+                Ok(alloc_id)\n             },\n             MAX1 => {\n+                trace!(\"creating fn alloc id at {}\", pos);\n                 let instance = ty::Instance::decode(self)?;\n-                let id = interpret::AllocId(interpret_interner.create_fn_alloc(instance));\n+                trace!(\"decoded fn alloc instance: {:?}\", instance);\n+                let id = interpret::AllocId(interpret_interner().create_fn_alloc(instance));\n+                trace!(\"created fn alloc id: {:?}\", id);\n                 self.interpret_alloc_cache.insert(pos, id);\n                 Ok(id)\n             },\n-            shorthand => Ok(self.interpret_alloc_cache[&shorthand]),\n+            shorthand => {\n+                trace!(\"loading shorthand {}\", shorthand);\n+                if let Some(&alloc_id) = self.interpret_alloc_cache.get(&shorthand) {\n+                    return Ok(alloc_id);\n+                }\n+                trace!(\"shorthand {} not cached, loading entire allocation\", shorthand);\n+                // need to load allocation\n+                self.with_position(shorthand, |this| interpret::AllocId::decode(this))\n+            },\n         }\n     }\n }"}, {"sha": "1e1baba2bac5e708175aa69c66501bcf3883bab6", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=918b6d763319863fb53c5b7bceebc14ad5fb4024", "patch": "@@ -189,12 +189,18 @@ impl<'a, 'tcx> SpecializedEncoder<Ty<'tcx>> for EncodeContext<'a, 'tcx> {\n \n impl<'a, 'tcx> SpecializedEncoder<interpret::AllocId> for EncodeContext<'a, 'tcx> {\n     fn specialized_encode(&mut self, alloc_id: &interpret::AllocId) -> Result<(), Self::Error> {\n+        trace!(\"encoding {:?} at {}\", alloc_id, self.position());\n         if let Some(shorthand) = self.interpret_alloc_shorthands.get(alloc_id).cloned() {\n-            return self.emit_usize(shorthand);\n+            trace!(\"encoding {:?} as shorthand to {}\", alloc_id, shorthand);\n+            return shorthand.encode(self);\n         }\n         let start = self.position();\n+        // cache the allocation shorthand now, because the allocation itself might recursively\n+        // point to itself.\n+        self.interpret_alloc_shorthands.insert(*alloc_id, start);\n         let interpret_interner = self.tcx.interpret_interner.borrow();\n         if let Some(alloc) = interpret_interner.get_alloc(alloc_id.0) {\n+            trace!(\"encoding {:?} with {:#?}\", alloc_id, alloc);\n             usize::max_value().encode(self)?;\n             alloc.encode(self)?;\n             let globals = interpret_interner.get_globals(interpret::Pointer {\n@@ -208,16 +214,12 @@ impl<'a, 'tcx> SpecializedEncoder<interpret::AllocId> for EncodeContext<'a, 'tcx\n                 glob.encode(self)?;\n             }\n         } else if let Some(fn_instance) = interpret_interner.get_fn(alloc_id.0) {\n+            trace!(\"encoding {:?} with {:#?}\", alloc_id, fn_instance);\n             (usize::max_value() - 1).encode(self)?;\n             fn_instance.encode(self)?;\n         } else {\n             bug!(\"alloc id without corresponding allocation: {}\", alloc_id.0);\n         }\n-        let len = self.position() - start * 7;\n-        // Check that the shorthand is a not longer than the\n-        // full encoding itself, i.e. it's an obvious win.\n-        assert!(len >= 64 || (start as u64) < (1 << len));\n-        self.interpret_alloc_shorthands.insert(*alloc_id, start);\n         Ok(())\n     }\n }"}, {"sha": "5955d0ca59adfe77f4f6b62bae8b4e66fee37473", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 42, "deletions": 5, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=918b6d763319863fb53c5b7bceebc14ad5fb4024", "patch": "@@ -26,6 +26,7 @@ use rustc::ty::fold::TypeFoldable;\n use rustc::ty::{self, ToPolyTraitRef, Ty, TyCtxt, TypeVariants};\n use rustc::middle::const_val::ConstVal;\n use rustc::mir::*;\n+use rustc::mir::interpret::{Value, PrimVal};\n use rustc::mir::tcx::PlaceTy;\n use rustc::mir::visit::{PlaceContext, Visitor};\n use std::fmt;\n@@ -258,7 +259,24 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n                 // constraints on `'a` and `'b`. These constraints\n                 // would be lost if we just look at the normalized\n                 // value.\n-                if let ConstVal::Function(def_id, ..) = value.val {\n+                let did = match value.val {\n+                    ConstVal::Function(def_id, ..) => Some(def_id),\n+                    ConstVal::Value(Value::ByVal(PrimVal::Ptr(p))) => {\n+                        self.tcx()\n+                            .interpret_interner\n+                            .borrow()\n+                            .get_fn(p.alloc_id.0)\n+                            .map(|instance| instance.def_id())\n+                    },\n+                    ConstVal::Value(Value::ByVal(PrimVal::Undef)) => {\n+                        match value.ty.sty {\n+                            ty::TyFnDef(ty_def_id, _) => Some(ty_def_id),\n+                            _ => None,\n+                        }\n+                    },\n+                    _ => None,\n+                };\n+                if let Some(def_id) = did {\n                     let tcx = self.tcx();\n                     let type_checker = &mut self.cx;\n \n@@ -436,7 +454,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n             ProjectionElem::Subslice { from, to } => PlaceTy::Ty {\n                 ty: match base_ty.sty {\n                     ty::TyArray(inner, size) => {\n-                        let size = size.val.to_const_int().unwrap().to_u64().unwrap();\n+                        let size = size.val.unwrap_u64();\n                         let min_size = (from as u64) + (to as u64);\n                         if let Some(rest_size) = size.checked_sub(min_size) {\n                             tcx.mk_array(inner, rest_size)\n@@ -1019,13 +1037,32 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     Literal::Value {\n                         value:\n                             &ty::Const {\n-                                val: ConstVal::Function(def_id, _),\n-                                ..\n+                                val,\n+                                ty,\n                             },\n                         ..\n                     },\n                 ..\n-            }) => Some(def_id) == self.tcx().lang_items().box_free_fn(),\n+            }) => match val {\n+                ConstVal::Function(def_id, _) => {\n+                    Some(def_id) == self.tcx().lang_items().box_free_fn()\n+                },\n+                ConstVal::Value(Value::ByVal(PrimVal::Ptr(p))) => {\n+                    let inst = self.tcx().interpret_interner.borrow().get_fn(p.alloc_id.0);\n+                    inst.map_or(false, |inst| {\n+                        Some(inst.def_id()) == self.tcx().lang_items().box_free_fn()\n+                    })\n+                },\n+                ConstVal::Value(Value::ByVal(PrimVal::Undef)) => {\n+                    match ty.sty {\n+                        ty::TyFnDef(ty_def_id, _) => {\n+                            Some(ty_def_id) == self.tcx().lang_items().box_free_fn()\n+                        }\n+                        _ => false,\n+                    }\n+                }\n+                _ => false,\n+            }\n             _ => false,\n         }\n     }"}, {"sha": "b5b8f8d7e78b0a553d7ff105eec4e7a5d1d570a2", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=918b6d763319863fb53c5b7bceebc14ad5fb4024", "patch": "@@ -24,6 +24,7 @@ use rustc::middle::const_val::ConstVal;\n use rustc::middle::region;\n use rustc::ty::{self, Ty};\n use rustc::mir::*;\n+use rustc::mir::interpret::{Value, PrimVal};\n use syntax::ast;\n use syntax_pos::Span;\n \n@@ -203,7 +204,11 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                         ty: this.hir.tcx().types.u32,\n                         literal: Literal::Value {\n                             value: this.hir.tcx().mk_const(ty::Const {\n-                                val: ConstVal::Integral(ConstInt::U32(0)),\n+                                val: if this.hir.tcx().sess.opts.debugging_opts.miri {\n+                                    ConstVal::Value(Value::ByVal(PrimVal::Bytes(0)))\n+                                } else {\n+                                    ConstVal::Integral(ConstInt::U32(0))\n+                                },\n                                 ty: this.hir.tcx().types.u32\n                             }),\n                         },\n@@ -401,7 +406,11 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n                 Literal::Value {\n                     value: self.hir.tcx().mk_const(ty::Const {\n-                        val: ConstVal::Integral(val),\n+                        val: if self.hir.tcx().sess.opts.debugging_opts.miri {\n+                            ConstVal::Value(Value::ByVal(PrimVal::Bytes(val.to_u128_unchecked())))\n+                        } else {\n+                            ConstVal::Integral(val)\n+                        },\n                         ty\n                     })\n                 }\n@@ -439,7 +448,13 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n                 Literal::Value {\n                     value: self.hir.tcx().mk_const(ty::Const {\n-                        val: ConstVal::Integral(val),\n+                        val: if self.hir.tcx().sess.opts.debugging_opts.miri {\n+                            ConstVal::Value(Value::ByVal(PrimVal::Bytes(\n+                                val.to_u128_unchecked()\n+                            )))\n+                        } else {\n+                            ConstVal::Integral(val)\n+                        },\n                         ty\n                     })\n                 }"}, {"sha": "229e33dcd786209fc49b67322248a6b3fb6cc696", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=918b6d763319863fb53c5b7bceebc14ad5fb4024", "patch": "@@ -354,7 +354,7 @@ enum TestKind<'tcx> {\n     // test the branches of enum\n     SwitchInt {\n         switch_ty: Ty<'tcx>,\n-        options: Vec<&'tcx ty::Const<'tcx>>,\n+        options: Vec<u128>,\n         indices: FxHashMap<&'tcx ty::Const<'tcx>, usize>,\n     },\n "}, {"sha": "fafdee5b1e1b9cde3273725a92749c507a1d4e13", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 53, "deletions": 16, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=918b6d763319863fb53c5b7bceebc14ad5fb4024", "patch": "@@ -24,6 +24,7 @@ use rustc::middle::const_val::ConstVal;\n use rustc::ty::{self, Ty};\n use rustc::ty::util::IntTypeExt;\n use rustc::mir::*;\n+use rustc::mir::interpret::{Value, PrimVal};\n use rustc::hir::RangeEnd;\n use syntax_pos::Span;\n use std::cmp::Ordering;\n@@ -112,7 +113,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                                      test_place: &Place<'tcx>,\n                                      candidate: &Candidate<'pat, 'tcx>,\n                                      switch_ty: Ty<'tcx>,\n-                                     options: &mut Vec<&'tcx ty::Const<'tcx>>,\n+                                     options: &mut Vec<u128>,\n                                      indices: &mut FxHashMap<&'tcx ty::Const<'tcx>, usize>)\n                                      -> bool\n     {\n@@ -128,7 +129,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n                 indices.entry(value)\n                        .or_insert_with(|| {\n-                           options.push(value);\n+                           options.push(value.val.to_u128().expect(\"switching on int\"));\n                            options.len() - 1\n                        });\n                 true\n@@ -231,7 +232,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 let tcx = self.hir.tcx();\n                 for (idx, discr) in adt_def.discriminants(tcx).enumerate() {\n                     target_blocks.place_back() <- if variants.contains(idx) {\n-                        values.push(discr);\n+                        values.push(discr.to_u128_unchecked());\n                         *(targets.place_back() <- self.cfg.start_new_block())\n                     } else {\n                         if otherwise_block.is_none() {\n@@ -266,9 +267,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     assert!(options.len() > 0 && options.len() <= 2);\n                     let (true_bb, false_bb) = (self.cfg.start_new_block(),\n                                                self.cfg.start_new_block());\n-                    let ret = match options[0].val {\n-                        ConstVal::Bool(true) => vec![true_bb, false_bb],\n-                        ConstVal::Bool(false) => vec![false_bb, true_bb],\n+                    let ret = match options[0] {\n+                        1 => vec![true_bb, false_bb],\n+                        0 => vec![false_bb, true_bb],\n                         v => span_bug!(test.span, \"expected boolean value but got {:?}\", v)\n                     };\n                     (ret, TerminatorKind::if_(self.hir.tcx(), Operand::Copy(place.clone()),\n@@ -282,13 +283,10 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                                .map(|_| self.cfg.start_new_block())\n                                .chain(Some(otherwise))\n                                .collect();\n-                    let values: Vec<_> = options.iter().map(|v|\n-                        v.val.to_const_int().expect(\"switching on integral\")\n-                    ).collect();\n                     (targets.clone(), TerminatorKind::SwitchInt {\n                         discr: Operand::Copy(place.clone()),\n                         switch_ty,\n-                        values: From::from(values),\n+                        values: options.clone().into(),\n                         targets,\n                     })\n                 };\n@@ -300,14 +298,49 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 let tcx = self.hir.tcx();\n                 let mut val = Operand::Copy(place.clone());\n \n+                let bytes = match value.val {\n+                    ConstVal::ByteStr(bytes) => Some(bytes.data),\n+                    ConstVal::Value(Value::ByVal(PrimVal::Ptr(p))) => {\n+                        let is_array_ptr = ty\n+                            .builtin_deref(true, ty::NoPreference)\n+                            .and_then(|t| t.ty.builtin_index())\n+                            .map_or(false, |t| t == self.hir.tcx().types.u8);\n+                        if is_array_ptr {\n+                            self.hir\n+                                .tcx()\n+                                .interpret_interner\n+                                .borrow()\n+                                .get_alloc(p.alloc_id.0)\n+                                .map(|alloc| &alloc.bytes[..])\n+                        } else {\n+                            None\n+                        }\n+                    },\n+                    _ => None,\n+                };\n                 // If we're using b\"...\" as a pattern, we need to insert an\n                 // unsizing coercion, as the byte string has the type &[u8; N].\n                 //\n                 // We want to do this even when the scrutinee is a reference to an\n                 // array, so we can call `<[u8]>::eq` rather than having to find an\n                 // `<[u8; N]>::eq`.\n-                let (expect, val) = if let ConstVal::ByteStr(bytes) = value.val {\n-                    let array_ty = tcx.mk_array(tcx.types.u8, bytes.data.len() as u64);\n+                let expect = if let Some(bytes) = bytes {\n+                    let tcx = self.hir.tcx();\n+\n+                    // Unsize the place to &[u8], too, if necessary.\n+                    if let ty::TyRef(region, mt) = ty.sty {\n+                        if let ty::TyArray(_, _) = mt.ty.sty {\n+                            ty = tcx.mk_imm_ref(region, tcx.mk_slice(tcx.types.u8));\n+                            let val_slice = self.temp(ty, test.span);\n+                            self.cfg.push_assign(block, source_info, &val_slice,\n+                                                 Rvalue::Cast(CastKind::Unsize, val, ty));\n+                            val = Operand::Move(val_slice);\n+                        }\n+                    }\n+\n+                    assert!(ty.is_slice());\n+\n+                    let array_ty = tcx.mk_array(tcx.types.u8, bytes.len() as u64);\n                     let array_ref = tcx.mk_imm_ref(tcx.types.re_static, array_ty);\n                     let array = self.literal_operand(test.span, array_ref, Literal::Value {\n                         value\n@@ -324,11 +357,15 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n                 // Use PartialEq::eq for &str and &[u8] slices, instead of BinOp::Eq.\n                 let fail = self.cfg.start_new_block();\n-                let ty = expect.ty(&self.local_decls, tcx);\n-                if let ty::TyRef(_, mt) = ty.sty {\n-                    assert!(ty.is_slice());\n+                let str_or_bytestr = ty\n+                    .builtin_deref(true, ty::NoPreference)\n+                    .and_then(|tam| match tam.ty.sty {\n+                        ty::TyStr => Some(tam.ty),\n+                        ty::TySlice(inner) if inner == self.hir.tcx().types.u8 => Some(tam.ty),\n+                        _ => None,\n+                    });\n+                if let Some(ty) = str_or_bytestr {\n                     let eq_def_id = self.hir.tcx().lang_items().eq_trait().unwrap();\n-                    let ty = mt.ty;\n                     let (mty, method) = self.hir.trait_method(eq_def_id, \"eq\", ty, &[ty]);\n \n                     let bool_ty = self.hir.bool_ty();"}, {"sha": "efb367201189bd36d59c60f1119d8641aba4f6b3", "filename": "src/librustc_mir/build/misc.rs", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs?ref=918b6d763319863fb53c5b7bceebc14ad5fb4024", "patch": "@@ -16,6 +16,7 @@ use build::Builder;\n use rustc_const_math::{ConstInt, ConstUsize, ConstIsize};\n use rustc::middle::const_val::ConstVal;\n use rustc::ty::{self, Ty};\n+use rustc::mir::interpret::{Value, PrimVal};\n \n use rustc::mir::*;\n use syntax::ast;\n@@ -62,7 +63,11 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             ty::TyChar => {\n                 Literal::Value {\n                     value: self.hir.tcx().mk_const(ty::Const {\n-                        val: ConstVal::Char('\\0'),\n+                        val: if self.hir.tcx().sess.opts.debugging_opts.miri {\n+                            ConstVal::Value(Value::ByVal(PrimVal::Bytes(0)))\n+                        } else {\n+                            ConstVal::Char('\\0')\n+                        },\n                         ty\n                     })\n                 }\n@@ -83,7 +88,11 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n                 Literal::Value {\n                     value: self.hir.tcx().mk_const(ty::Const {\n-                        val: ConstVal::Integral(val),\n+                        val: if self.hir.tcx().sess.opts.debugging_opts.miri {\n+                            ConstVal::Value(Value::ByVal(PrimVal::Bytes(0)))\n+                        } else {\n+                            ConstVal::Integral(val)\n+                        },\n                         ty\n                     })\n                 }\n@@ -104,7 +113,11 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n                 Literal::Value {\n                     value: self.hir.tcx().mk_const(ty::Const {\n-                        val: ConstVal::Integral(val),\n+                        val: if self.hir.tcx().sess.opts.debugging_opts.miri {\n+                            ConstVal::Value(Value::ByVal(PrimVal::Bytes(0)))\n+                        } else {\n+                            ConstVal::Integral(val)\n+                        },\n                         ty\n                     })\n                 }"}, {"sha": "198e55358e7ee5f01fe61d2015ce3ae570b1fd15", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 35, "deletions": 11, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=918b6d763319863fb53c5b7bceebc14ad5fb4024", "patch": "@@ -10,14 +10,14 @@\n \n use hair::*;\n use rustc_data_structures::indexed_vec::Idx;\n-use rustc_const_math::ConstInt;\n use hair::cx::Cx;\n use hair::cx::block;\n use hair::cx::to_ref::ToRef;\n use rustc::hir::def::{Def, CtorKind};\n use rustc::middle::const_val::ConstVal;\n use rustc::ty::{self, AdtKind, VariantDef, Ty};\n use rustc::ty::adjustment::{Adjustment, Adjust, AutoBorrow, AutoBorrowMutability};\n+use rustc::mir::interpret::{Value, PrimVal};\n use rustc::ty::cast::CastKind as TyCastKind;\n use rustc::hir;\n use rustc::hir::def_id::LocalDefId;\n@@ -100,7 +100,7 @@ fn apply_adjustment<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             ExprKind::Deref { arg: expr.to_ref() }\n         }\n         Adjust::Deref(Some(deref)) => {\n-            let call = deref.method_call(cx.tcx, expr.ty);\n+            let call = deref.method_call(cx.tcx(), expr.ty);\n \n             expr = Expr {\n                 temp_lifetime,\n@@ -314,7 +314,9 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             }\n         }\n \n-        hir::ExprLit(..) => ExprKind::Literal { literal: cx.const_eval_literal(expr) },\n+        hir::ExprLit(ref lit) => ExprKind::Literal {\n+            literal: cx.const_eval_literal(&lit.node, expr_ty, lit.span, false),\n+        },\n \n         hir::ExprBinary(op, ref lhs, ref rhs) => {\n             if cx.tables().is_method_call(expr) {\n@@ -400,9 +402,10 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             if cx.tables().is_method_call(expr) {\n                 overloaded_operator(cx, expr, vec![arg.to_ref()])\n             } else {\n-                // FIXME runtime-overflow\n-                if let hir::ExprLit(_) = arg.node {\n-                    ExprKind::Literal { literal: cx.const_eval_literal(expr) }\n+                if let hir::ExprLit(ref lit) = arg.node {\n+                    ExprKind::Literal {\n+                        literal: cx.const_eval_literal(&lit.node, expr_ty, lit.span, true),\n+                    }\n                 } else {\n                     ExprKind::Unary {\n                         op: UnOp::Neg,\n@@ -509,8 +512,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             let def_id = cx.tcx.hir.body_owner_def_id(count);\n             let substs = Substs::identity_for_item(cx.tcx.global_tcx(), def_id);\n             let count = match cx.tcx.at(c.span).const_eval(cx.param_env.and((def_id, substs))) {\n-                Ok(&ty::Const { val: ConstVal::Integral(ConstInt::Usize(u)), .. }) => u,\n-                Ok(other) => bug!(\"constant evaluation of repeat count yielded {:?}\", other),\n+                Ok(cv) => cv.val.unwrap_usize(cx.tcx),\n                 Err(s) => cx.fatal_const_eval_err(&s, c.span, \"expression\")\n             };\n \n@@ -634,8 +636,8 @@ fn method_callee<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         span: expr.span,\n         kind: ExprKind::Literal {\n             literal: Literal::Value {\n-                value: cx.tcx.mk_const(ty::Const {\n-                    val: ConstVal::Function(def_id, substs),\n+                value: cx.tcx().mk_const(ty::Const {\n+                    val: const_fn(cx.tcx, def_id, substs),\n                     ty\n                 }),\n             },\n@@ -675,6 +677,28 @@ fn convert_arm<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>, arm: &'tcx hir::Arm)\n     }\n }\n \n+fn const_fn<'a, 'gcx, 'tcx>(\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    def_id: DefId,\n+    substs: &'tcx Substs<'tcx>,\n+) -> ConstVal<'tcx> {\n+    if tcx.sess.opts.debugging_opts.miri {\n+        /*\n+        let inst = ty::Instance::new(def_id, substs);\n+        let ptr = tcx\n+            .interpret_interner\n+            .borrow_mut()\n+            .create_fn_alloc(inst);\n+        let ptr = MemoryPointer::new(AllocId(ptr), 0);\n+        ConstVal::Value(Value::ByVal(PrimVal::Ptr(ptr)))\n+        */\n+        // ZST function type\n+        ConstVal::Value(Value::ByVal(PrimVal::Undef))\n+    } else {\n+        ConstVal::Function(def_id, substs)\n+    }\n+}\n+\n fn convert_path_expr<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                      expr: &'tcx hir::Expr,\n                                      def: Def)\n@@ -688,7 +712,7 @@ fn convert_path_expr<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         Def::VariantCtor(def_id, CtorKind::Fn) => ExprKind::Literal {\n             literal: Literal::Value {\n                 value: cx.tcx.mk_const(ty::Const {\n-                    val: ConstVal::Function(def_id, substs),\n+                    val: const_fn(cx.tcx.global_tcx(), def_id, substs),\n                     ty: cx.tables().node_id_to_type(expr.hir_id)\n                 }),\n             },"}, {"sha": "7ebed0bbddbf581996ec01c4f7b2c18b0b6bcaae", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 166, "deletions": 12, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=918b6d763319863fb53c5b7bceebc14ad5fb4024", "patch": "@@ -17,7 +17,6 @@\n use hair::*;\n \n use rustc::middle::const_val::{ConstEvalErr, ConstVal};\n-use rustc_const_eval::ConstContext;\n use rustc_data_structures::indexed_vec::Idx;\n use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::hir::map::blocks::FnLikeNode;\n@@ -32,6 +31,7 @@ use syntax::symbol::Symbol;\n use rustc::hir;\n use rustc_const_math::{ConstInt, ConstUsize};\n use rustc_data_structures::sync::Lrc;\n+use rustc::mir::interpret::{Value, PrimVal};\n \n #[derive(Clone)]\n pub struct Cx<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n@@ -119,7 +119,11 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n             Ok(val) => {\n                 Literal::Value {\n                     value: self.tcx.mk_const(ty::Const {\n-                        val: ConstVal::Integral(ConstInt::Usize(val)),\n+                        val: if self.tcx.sess.opts.debugging_opts.miri {\n+                            ConstVal::Value(Value::ByVal(PrimVal::Bytes(value as u128)))\n+                        } else {\n+                            ConstVal::Integral(ConstInt::Usize(val))\n+                        },\n                         ty: self.tcx.types.usize\n                     })\n                 }\n@@ -139,7 +143,11 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n     pub fn true_literal(&mut self) -> Literal<'tcx> {\n         Literal::Value {\n             value: self.tcx.mk_const(ty::Const {\n-                val: ConstVal::Bool(true),\n+                val: if self.tcx.sess.opts.debugging_opts.miri {\n+                    ConstVal::Value(Value::ByVal(PrimVal::Bytes(1)))\n+                } else {\n+                    ConstVal::Bool(true)\n+                },\n                 ty: self.tcx.types.bool\n             })\n         }\n@@ -148,20 +156,161 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n     pub fn false_literal(&mut self) -> Literal<'tcx> {\n         Literal::Value {\n             value: self.tcx.mk_const(ty::Const {\n-                val: ConstVal::Bool(false),\n+                val: if self.tcx.sess.opts.debugging_opts.miri {\n+                    ConstVal::Value(Value::ByVal(PrimVal::Bytes(0)))\n+                } else {\n+                    ConstVal::Bool(false)\n+                },\n                 ty: self.tcx.types.bool\n             })\n         }\n     }\n \n-    pub fn const_eval_literal(&mut self, e: &hir::Expr) -> Literal<'tcx> {\n+    pub fn const_eval_literal(\n+        &mut self,\n+        lit: &'tcx ast::LitKind,\n+        ty: Ty<'tcx>,\n+        sp: Span,\n+        neg: bool,\n+    ) -> Literal<'tcx> {\n         let tcx = self.tcx.global_tcx();\n-        let const_cx = ConstContext::new(tcx,\n-                                         self.param_env.and(self.identity_substs),\n-                                         self.tables());\n-        match const_cx.eval(tcx.hir.expect_expr(e.id)) {\n-            Ok(value) => Literal::Value { value },\n-            Err(s) => self.fatal_const_eval_err(&s, e.span, \"expression\")\n+\n+        let mut repr_ty = ty;\n+        if let ty::TyAdt(adt, _) = ty.sty {\n+            if adt.is_enum() {\n+                repr_ty = adt.repr.discr_type().to_ty(tcx)\n+            }\n+        }\n+\n+        let parse_float = |num: &str, fty| -> ConstFloat {\n+            ConstFloat::from_str(num, fty).unwrap_or_else(|_| {\n+                // FIXME(#31407) this is only necessary because float parsing is buggy\n+                tcx.sess.span_fatal(sp, \"could not evaluate float literal (see issue #31407)\");\n+            })\n+        };\n+\n+        if tcx.sess.opts.debugging_opts.miri {\n+            use rustc::mir::interpret::*;\n+            let lit = match *lit {\n+                LitKind::Str(ref s, _) => {\n+                    let s = s.as_str();\n+                    let id = self.tcx.allocate_cached(s.as_bytes());\n+                    let ptr = MemoryPointer::new(AllocId(id), 0);\n+                    Value::ByValPair(\n+                        PrimVal::Ptr(ptr),\n+                        PrimVal::from_u128(s.len() as u128),\n+                    )\n+                },\n+                LitKind::ByteStr(ref data) => {\n+                    let id = self.tcx.allocate_cached(data);\n+                    let ptr = MemoryPointer::new(AllocId(id), 0);\n+                    Value::ByVal(PrimVal::Ptr(ptr))\n+                },\n+                LitKind::Byte(n) => Value::ByVal(PrimVal::Bytes(n as u128)),\n+                LitKind::Int(n, _) if neg => {\n+                    let n = n as i128;\n+                    let n = n.overflowing_neg().0;\n+                    Value::ByVal(PrimVal::Bytes(n as u128))\n+                },\n+                LitKind::Int(n, _) => Value::ByVal(PrimVal::Bytes(n)),\n+                LitKind::Float(n, fty) => {\n+                    let n = n.as_str();\n+                    let mut f = parse_float(&n, fty);\n+                    if neg {\n+                        f = -f;\n+                    }\n+                    let bits = f.bits;\n+                    Value::ByVal(PrimVal::Bytes(bits))\n+                }\n+                LitKind::FloatUnsuffixed(n) => {\n+                    let fty = match ty.sty {\n+                        ty::TyFloat(fty) => fty,\n+                        _ => bug!()\n+                    };\n+                    let n = n.as_str();\n+                    let mut f = parse_float(&n, fty);\n+                    if neg {\n+                        f = -f;\n+                    }\n+                    let bits = f.bits;\n+                    Value::ByVal(PrimVal::Bytes(bits))\n+                }\n+                LitKind::Bool(b) => Value::ByVal(PrimVal::Bytes(b as u128)),\n+                LitKind::Char(c) => Value::ByVal(PrimVal::Bytes(c as u128)),\n+            };\n+            return Literal::Value {\n+                value: self.tcx.mk_const(ty::Const {\n+                    val: Value(lit),\n+                    ty,\n+                }),\n+            };\n+        }\n+\n+        use syntax::ast::*;\n+        use syntax::ast::LitIntType::*;\n+        use rustc::middle::const_val::ConstVal::*;\n+        use rustc_const_math::ConstInt::*;\n+        use rustc::ty::util::IntTypeExt;\n+        use rustc::middle::const_val::ByteArray;\n+        use rustc_const_math::ConstFloat;\n+\n+        let lit = match *lit {\n+            LitKind::Str(ref s, _) => Ok(Str(s.as_str())),\n+            LitKind::ByteStr(ref data) => {\n+                let data: &'tcx [u8] = data;\n+                Ok(ByteStr(ByteArray { data }))\n+            },\n+            LitKind::Byte(n) => Ok(Integral(U8(n))),\n+            LitKind::Int(n, hint) => {\n+                match (&repr_ty.sty, hint) {\n+                    (&ty::TyInt(ity), _) |\n+                    (_, Signed(ity)) => {\n+                        let mut n = n as i128;\n+                        if neg {\n+                            n = n.overflowing_neg().0;\n+                        }\n+                        Ok(Integral(ConstInt::new_signed_truncating(n,\n+                            ity, tcx.sess.target.isize_ty)))\n+                    }\n+                    (&ty::TyUint(uty), _) |\n+                    (_, Unsigned(uty)) => {\n+                        Ok(Integral(ConstInt::new_unsigned_truncating(n,\n+                            uty, tcx.sess.target.usize_ty)))\n+                    }\n+                    _ => bug!()\n+                }\n+            }\n+            LitKind::Float(n, fty) => {\n+                let mut f = parse_float(&n.as_str(), fty);\n+                if neg {\n+                    f = -f;\n+                }\n+                Ok(ConstVal::Float(f))\n+            }\n+            LitKind::FloatUnsuffixed(n) => {\n+                let fty = match ty.sty {\n+                    ty::TyFloat(fty) => fty,\n+                    _ => bug!()\n+                };\n+                let mut f = parse_float(&n.as_str(), fty);\n+                if neg {\n+                    f = -f;\n+                }\n+                Ok(ConstVal::Float(f))\n+            }\n+            LitKind::Bool(b) => Ok(Bool(b)),\n+            LitKind::Char(c) => Ok(Char(c)),\n+        };\n+\n+        match lit {\n+            Ok(value) => Literal::Value { value: self.tcx.mk_const(ty::Const {\n+                val: value,\n+                ty,\n+            }) },\n+            Err(kind) => self.fatal_const_eval_err(&ConstEvalErr {\n+                span: sp,\n+                kind,\n+            }, sp, \"expression\")\n         }\n     }\n \n@@ -203,7 +352,12 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n                 return (method_ty,\n                         Literal::Value {\n                             value: self.tcx.mk_const(ty::Const {\n-                                val: ConstVal::Function(item.def_id, substs),\n+                                val: if self.tcx.sess.opts.debugging_opts.miri {\n+                                    // ZST function type\n+                                    ConstVal::Value(Value::ByVal(PrimVal::Undef))\n+                                } else {\n+                                    ConstVal::Function(item.def_id, substs)\n+                                },\n                                 ty: method_ty\n                             }),\n                         });"}, {"sha": "ec8215fb64c38f25020a95a2d7ea3cd20e03bb7f", "filename": "src/librustc_mir/interpret/const_eval.rs", "status": "modified", "additions": 116, "deletions": 37, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs?ref=918b6d763319863fb53c5b7bceebc14ad5fb4024", "patch": "@@ -13,14 +13,13 @@ use syntax::ast::Mutability;\n use syntax::codemap::Span;\n \n use rustc::mir::interpret::{EvalResult, EvalError, EvalErrorKind, GlobalId, Value, MemoryPointer, Pointer, PrimVal};\n-use super::{Place, EvalContext, StackPopCleanup, ValTy};\n+use super::{Place, EvalContext, StackPopCleanup, ValTy, HasMemory};\n \n use rustc_const_math::ConstInt;\n \n use std::fmt;\n use std::error::Error;\n \n-\n pub fn mk_eval_cx<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     instance: Instance<'tcx>,\n@@ -45,7 +44,7 @@ pub fn eval_body<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     instance: Instance<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n-) -> EvalResult<'tcx, (Pointer, Ty<'tcx>)> {\n+) -> EvalResult<'tcx, (Value, Pointer, Ty<'tcx>)> {\n     debug!(\"eval_body: {:?}, {:?}\", instance, param_env);\n     let limits = super::ResourceLimits::default();\n     let mut ecx = EvalContext::new(tcx, param_env, limits, CompileTimeEvaluator, ());\n@@ -82,19 +81,23 @@ pub fn eval_body<'a, 'tcx>(\n         while ecx.step()? {}\n     }\n     let alloc = tcx.interpret_interner.borrow().get_cached(cid).expect(\"global not cached\");\n-    Ok((MemoryPointer::new(alloc, 0).into(), instance_ty))\n+    let align = ecx.layout_of(instance_ty)?.align;\n+    let ptr = MemoryPointer::new(alloc, 0).into();\n+    let value = match ecx.try_read_value(ptr, align, instance_ty)? {\n+        Some(val) => val,\n+        _ => Value::ByRef(ptr, align),\n+    };\n+    Ok((value, ptr, instance_ty))\n }\n \n pub fn eval_body_as_integer<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     instance: Instance<'tcx>,\n ) -> EvalResult<'tcx, ConstInt> {\n-    let ptr_ty = eval_body(tcx, instance, param_env);\n-    let (ptr, ty) = ptr_ty?;\n-    let ecx = mk_eval_cx(tcx, instance, param_env)?;\n-    let prim = match ecx.try_read_value(ptr, ecx.layout_of(ty)?.align, ty)? {\n-        Some(Value::ByVal(prim)) => prim.to_bytes()?,\n+    let (value, _, ty) = eval_body(tcx, instance, param_env)?;\n+    let prim = match value {\n+        Value::ByVal(prim) => prim.to_bytes()?,\n         _ => return err!(TypeNotPrimitive(ty)),\n     };\n     use syntax::ast::{IntTy, UintTy};\n@@ -133,7 +136,7 @@ pub struct CompileTimeEvaluator;\n \n impl<'tcx> Into<EvalError<'tcx>> for ConstEvalError {\n     fn into(self) -> EvalError<'tcx> {\n-        EvalErrorKind::MachineError(Box::new(self)).into()\n+        EvalErrorKind::MachineError(self.to_string()).into()\n     }\n }\n \n@@ -193,7 +196,6 @@ impl<'tcx> super::Machine<'tcx> for CompileTimeEvaluator {\n         let mir = match ecx.load_mir(instance.def) {\n             Ok(mir) => mir,\n             Err(EvalError { kind: EvalErrorKind::NoMirFor(path), .. }) => {\n-                // some simple things like `malloc` might get accepted in the future\n                 return Err(\n                     ConstEvalError::NeedsRfc(format!(\"calling extern function `{}`\", path))\n                         .into(),\n@@ -302,6 +304,70 @@ impl<'tcx> super::Machine<'tcx> for CompileTimeEvaluator {\n     }\n }\n \n+pub fn const_val_field<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    key: ty::ParamEnvAnd<'tcx, (ty::Instance<'tcx>, mir::Field, Value, Ty<'tcx>)>,\n+) -> ::rustc::middle::const_val::EvalResult<'tcx> {\n+    trace!(\"const_val_field: {:#?}\", key);\n+    match const_val_field_inner(tcx, key) {\n+        Ok((field, ty)) => Ok(tcx.mk_const(ty::Const {\n+            val: ConstVal::Value(field),\n+            ty,\n+        })),\n+        Err(err) => Err(ConstEvalErr {\n+            span: tcx.def_span(key.value.0.def_id()),\n+            kind: err.into(),\n+        }),\n+    }\n+}\n+\n+fn const_val_field_inner<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    key: ty::ParamEnvAnd<'tcx, (ty::Instance<'tcx>, mir::Field, Value, Ty<'tcx>)>,\n+) -> ::rustc::mir::interpret::EvalResult<'tcx, (Value, Ty<'tcx>)> {\n+    trace!(\"const_val_field: {:#?}\", key);\n+    let (instance, field, value, ty) = key.value;\n+    let mut ecx = mk_eval_cx(tcx, instance, key.param_env).unwrap();\n+    let (mut field, ty) = match value {\n+        Value::ByValPair(..) | Value::ByVal(_) => ecx.read_field(value, field, ty)?.expect(\"const_val_field on non-field\"),\n+        Value::ByRef(ptr, align) => {\n+            let place = Place::from_primval_ptr(ptr, align);\n+            let layout = ecx.layout_of(ty)?;\n+            let (place, layout) = ecx.place_field(place, field, layout)?;\n+            let (ptr, align) = place.to_ptr_align();\n+            (Value::ByRef(ptr, align), layout.ty)\n+        }\n+    };\n+    if let Value::ByRef(ptr, align) = field {\n+        if let Some(val) = ecx.try_read_value(ptr, align, ty)? {\n+            field = val;\n+        }\n+    }\n+    Ok((field, ty))\n+}\n+\n+pub fn const_discr<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    key: ty::ParamEnvAnd<'tcx, (ty::Instance<'tcx>, Value, Ty<'tcx>)>,\n+) -> EvalResult<'tcx, u128> {\n+    trace!(\"const_discr: {:#?}\", key);\n+    let (instance, value, ty) = key.value;\n+    let mut ecx = mk_eval_cx(tcx, instance, key.param_env).unwrap();\n+    let (ptr, align) = match value {\n+        Value::ByValPair(..) | Value::ByVal(_) => {\n+            let layout = ecx.layout_of(ty)?;\n+            use super::MemoryKind;\n+            let ptr = ecx.memory.allocate(layout.size.bytes(), layout.align, Some(MemoryKind::Stack))?;\n+            let ptr: Pointer = ptr.into();\n+            ecx.write_value_to_ptr(value, ptr, layout.align, ty)?;\n+            (ptr, layout.align)\n+        },\n+        Value::ByRef(ptr, align) => (ptr, align),\n+    };\n+    let place = Place::from_primval_ptr(ptr, align);\n+    ecx.read_discriminant_value(place, ty)\n+}\n+\n pub fn const_eval_provider<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     key: ty::ParamEnvAnd<'tcx, (DefId, &'tcx Substs<'tcx>)>,\n@@ -340,35 +406,48 @@ pub fn const_eval_provider<'a, 'tcx>(\n         return Err(ConstEvalErr { span: body.value.span, kind: TypeckError })\n     }\n \n+\n+    let instance = ty::Instance::new(def_id, substs);\n+    if tcx.sess.opts.debugging_opts.miri {\n+        return match ::interpret::eval_body(tcx, instance, key.param_env) {\n+            Ok((miri_value, _, miri_ty)) => Ok(tcx.mk_const(ty::Const {\n+                val: ConstVal::Value(miri_value),\n+                ty: miri_ty,\n+            })),\n+            Err(err) => {\n+                Err(ConstEvalErr { span: body.value.span, kind: err.into() })\n+            }\n+        };\n+    }\n+\n     trace!(\"running old const eval\");\n     let old_result = ConstContext::new(tcx, key.param_env.and(substs), tables).eval(&body.value);\n     trace!(\"old const eval produced {:?}\", old_result);\n-    if tcx.sess.opts.debugging_opts.miri {\n-        let instance = ty::Instance::new(def_id, substs);\n-        trace!(\"const eval instance: {:?}, {:?}\", instance, key.param_env);\n-        let miri_result = ::interpret::eval_body(tcx, instance, key.param_env);\n-        match (miri_result, old_result) {\n-            (Err(err), Ok(ok)) => {\n-                trace!(\"miri failed, ctfe returned {:?}\", ok);\n-                tcx.sess.span_warn(\n-                    tcx.def_span(key.value.0),\n-                    \"miri failed to eval, while ctfe succeeded\",\n-                );\n-                let ecx = mk_eval_cx(tcx, instance, key.param_env).unwrap();\n-                let () = unwrap_miri(&ecx, Err(err));\n-                Ok(ok)\n-            },\n-            (_, Err(err)) => Err(err),\n-            (Ok((miri_val, miri_ty)), Ok(ctfe)) => {\n-                let mut ecx = mk_eval_cx(tcx, instance, key.param_env).unwrap();\n-                let layout = ecx.layout_of(miri_ty).unwrap();\n-                let miri_place = Place::from_primval_ptr(miri_val, layout.align);\n-                check_ctfe_against_miri(&mut ecx, miri_place, miri_ty, ctfe.val);\n-                Ok(ctfe)\n-            }\n+    trace!(\"const eval instance: {:?}, {:?}\", instance, key.param_env);\n+    let miri_result = ::interpret::eval_body(tcx, instance, key.param_env);\n+    match (miri_result, old_result) {\n+        (Err(err), Ok(ok)) => {\n+            trace!(\"miri failed, ctfe returned {:?}\", ok);\n+            tcx.sess.span_warn(\n+                tcx.def_span(key.value.0),\n+                \"miri failed to eval, while ctfe succeeded\",\n+            );\n+            let ecx = mk_eval_cx(tcx, instance, key.param_env).unwrap();\n+            let () = unwrap_miri(&ecx, Err(err));\n+            Ok(ok)\n+        },\n+        (Ok((value, _, ty)), Err(_)) => Ok(tcx.mk_const(ty::Const {\n+            val: ConstVal::Value(value),\n+            ty,\n+        })),\n+        (Err(_), Err(err)) => Err(err),\n+        (Ok((_, miri_ptr, miri_ty)), Ok(ctfe)) => {\n+            let mut ecx = mk_eval_cx(tcx, instance, key.param_env).unwrap();\n+            let layout = ecx.layout_of(miri_ty).unwrap();\n+            let miri_place = Place::from_primval_ptr(miri_ptr, layout.align);\n+            check_ctfe_against_miri(&mut ecx, miri_place, miri_ty, ctfe.val);\n+            Ok(ctfe)\n         }\n-    } else {\n-        old_result\n     }\n }\n \n@@ -451,7 +530,7 @@ fn check_ctfe_against_miri<'a, 'tcx>(\n             }\n         },\n         TyArray(elem_ty, n) => {\n-            let n = n.val.to_const_int().unwrap().to_u64().unwrap();\n+            let n = n.val.unwrap_u64();\n             let vec: Vec<(ConstVal, Ty<'tcx>)> = match ctfe {\n                 ConstVal::ByteStr(arr) => arr.data.iter().map(|&b| {\n                     (ConstVal::Integral(ConstInt::U8(b)), ecx.tcx.types.u8)"}, {"sha": "f37fb3072b5841c64abe3541dd5fcdbf6edd140f", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=918b6d763319863fb53c5b7bceebc14ad5fb4024", "patch": "@@ -601,7 +601,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n \n             Repeat(ref operand, _) => {\n                 let (elem_ty, length) = match dest_ty.sty {\n-                    ty::TyArray(elem_ty, n) => (elem_ty, n.val.to_const_int().unwrap().to_u64().unwrap()),\n+                    ty::TyArray(elem_ty, n) => (elem_ty, n.val.unwrap_u64()),\n                     _ => {\n                         bug!(\n                             \"tried to assign array-repeat to non-array type {:?}\",\n@@ -1386,7 +1386,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                 let ptr = self.into_ptr(src)?;\n                 // u64 cast is from usize to u64, which is always good\n                 let valty = ValTy {\n-                    value: ptr.to_value_with_len(length.val.to_const_int().unwrap().to_u64().unwrap() ),\n+                    value: ptr.to_value_with_len(length.val.unwrap_u64() ),\n                     ty: dest_ty,\n                 };\n                 self.write_value(valty, dest)"}, {"sha": "a6ebdd45968fcd0913116ba57f26870be0c760fb", "filename": "src/librustc_mir/interpret/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmod.rs?ref=918b6d763319863fb53c5b7bceebc14ad5fb4024", "patch": "@@ -18,6 +18,6 @@ pub use self::place::{Place, PlaceExtra};\n \n pub use self::memory::{Memory, MemoryKind, HasMemory};\n \n-pub use self::const_eval::{eval_body_as_integer, eval_body, CompileTimeEvaluator, const_eval_provider};\n+pub use self::const_eval::{eval_body_as_integer, eval_body, CompileTimeEvaluator, const_eval_provider, const_val_field, const_discr};\n \n pub use self::machine::Machine;"}, {"sha": "b20540b00ceaefde5130e5393726b478c6b79e98", "filename": "src/librustc_mir/interpret/operator.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperator.rs?ref=918b6d763319863fb53c5b7bceebc14ad5fb4024", "patch": "@@ -248,10 +248,15 @@ pub fn unary_op<'tcx>(\n         (Not, I64) => !(bytes as i64) as u128,\n         (Not, I128) => !(bytes as i128) as u128,\n \n+        (Neg, I8) if bytes == i8::min_value() as u128 => return err!(OverflowingMath),\n         (Neg, I8) => -(bytes as i8) as u128,\n+        (Neg, I16) if bytes == i16::min_value() as u128 => return err!(OverflowingMath),\n         (Neg, I16) => -(bytes as i16) as u128,\n+        (Neg, I32) if bytes == i32::min_value() as u128 => return err!(OverflowingMath),\n         (Neg, I32) => -(bytes as i32) as u128,\n+        (Neg, I64) if bytes == i64::min_value() as u128 => return err!(OverflowingMath),\n         (Neg, I64) => -(bytes as i64) as u128,\n+        (Neg, I128) if bytes == i128::min_value() as u128 => return err!(OverflowingMath),\n         (Neg, I128) => -(bytes as i128) as u128,\n \n         (Neg, F32) => (-bytes_to_f32(bytes)).bits,"}, {"sha": "c5e4eeab86709f69bd680bc13a14cf1f6c4355b4", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 25, "deletions": 18, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=918b6d763319863fb53c5b7bceebc14ad5fb4024", "patch": "@@ -71,7 +71,7 @@ impl<'tcx> Place {\n \n     pub(super) fn elem_ty_and_len(self, ty: Ty<'tcx>) -> (Ty<'tcx>, u64) {\n         match ty.sty {\n-            ty::TyArray(elem, n) => (elem, n.val.to_const_int().unwrap().to_u64().unwrap() as u64),\n+            ty::TyArray(elem, n) => (elem, n.val.unwrap_u64() as u64),\n \n             ty::TySlice(elem) => {\n                 match self {\n@@ -115,6 +115,29 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         }\n     }\n \n+    pub fn read_field(\n+        &self,\n+        base: Value,\n+        field: mir::Field,\n+        base_ty: Ty<'tcx>,\n+    ) -> EvalResult<'tcx, Option<(Value, Ty<'tcx>)>> {\n+        let base_layout = self.layout_of(base_ty)?;\n+        let field_index = field.index();\n+        let field = base_layout.field(self, field_index)?;\n+        let offset = base_layout.fields.offset(field_index);\n+        match base {\n+            // the field covers the entire type\n+            Value::ByValPair(..) |\n+            Value::ByVal(_) if offset.bytes() == 0 && field.size == base_layout.size => Ok(Some((base, field.ty))),\n+            // split fat pointers, 2 element tuples, ...\n+            Value::ByValPair(a, b) if base_layout.fields.count() == 2 => {\n+                let val = [a, b][field_index];\n+                Ok(Some((Value::ByVal(val), field.ty)))\n+            },\n+            _ => Ok(None),\n+        }\n+    }\n+\n     fn try_read_place_projection(\n         &mut self,\n         proj: &mir::PlaceProjection<'tcx>,\n@@ -126,23 +149,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         };\n         let base_ty = self.place_ty(&proj.base);\n         match proj.elem {\n-            Field(field, _) => {\n-                let base_layout = self.layout_of(base_ty)?;\n-                let field_index = field.index();\n-                let field = base_layout.field(&self, field_index)?;\n-                let offset = base_layout.fields.offset(field_index);\n-                match base {\n-                    // the field covers the entire type\n-                    Value::ByValPair(..) |\n-                    Value::ByVal(_) if offset.bytes() == 0 && field.size == base_layout.size => Ok(Some(base)),\n-                    // split fat pointers, 2 element tuples, ...\n-                    Value::ByValPair(a, b) if base_layout.fields.count() == 2 => {\n-                        let val = [a, b][field_index];\n-                        Ok(Some(Value::ByVal(val)))\n-                    },\n-                    _ => Ok(None),\n-                }\n-            },\n+            Field(field, _) => Ok(self.read_field(base, field, base_ty)?.map(|(f, _)| f)),\n             // The NullablePointer cases should work fine, need to take care for normal enums\n             Downcast(..) |\n             Subslice { .. } |"}, {"sha": "c18cf6d9f96b9bbd63833c8eba7ecb1dcd4bb72b", "filename": "src/librustc_mir/interpret/terminator/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs?ref=918b6d763319863fb53c5b7bceebc14ad5fb4024", "patch": "@@ -45,8 +45,8 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                 // Branch to the `otherwise` case by default, if no match is found.\n                 let mut target_block = targets[targets.len() - 1];\n \n-                for (index, const_int) in values.iter().enumerate() {\n-                    let prim = PrimVal::Bytes(const_int.to_u128_unchecked());\n+                for (index, &const_int) in values.iter().enumerate() {\n+                    let prim = PrimVal::Bytes(const_int);\n                     if discr_prim.to_bytes()? == prim.to_bytes()? {\n                         target_block = targets[index];\n                         break;"}, {"sha": "1f7f1237ba7894901e671f36ed1a42584dad5605", "filename": "src/librustc_mir/monomorphize/item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs?ref=918b6d763319863fb53c5b7bceebc14ad5fb4024", "patch": "@@ -314,7 +314,7 @@ impl<'a, 'tcx> DefPathBasedNames<'a, 'tcx> {\n                 output.push('[');\n                 self.push_type_name(inner_type, output);\n                 write!(output, \"; {}\",\n-                    len.val.to_const_int().unwrap().to_u64().unwrap()).unwrap();\n+                    len.val.unwrap_u64()).unwrap();\n                 output.push(']');\n             },\n             ty::TySlice(inner_type) => {"}, {"sha": "11dded1d3f075b57059359ca7cd31deae8901bff", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 23, "deletions": 6, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=918b6d763319863fb53c5b7bceebc14ad5fb4024", "patch": "@@ -17,6 +17,7 @@ use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::subst::{Kind, Subst, Substs};\n use rustc::ty::maps::Providers;\n use rustc_const_math::{ConstInt, ConstUsize};\n+use rustc::mir::interpret::{Value, PrimVal};\n \n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n \n@@ -303,7 +304,7 @@ fn build_clone_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     match self_ty.sty {\n         _ if is_copy => builder.copy_shim(),\n         ty::TyArray(ty, len) => {\n-            let len = len.val.to_const_int().unwrap().to_u64().unwrap();\n+            let len = len.val.unwrap_u64();\n             builder.array_shim(dest, src, ty, len)\n         }\n         ty::TyClosure(def_id, substs) => {\n@@ -443,7 +444,12 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n             ty: func_ty,\n             literal: Literal::Value {\n                 value: tcx.mk_const(ty::Const {\n-                    val: ConstVal::Function(self.def_id, substs),\n+                    val: if tcx.sess.opts.debugging_opts.miri {\n+                        // ZST function type\n+                        ConstVal::Value(Value::ByVal(PrimVal::Undef))\n+                    } else {\n+                        ConstVal::Function(self.def_id, substs)\n+                    },\n                     ty: func_ty\n                 }),\n             },\n@@ -501,13 +507,20 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n     }\n \n     fn make_usize(&self, value: u64) -> Box<Constant<'tcx>> {\n-        let value = ConstUsize::new(value, self.tcx.sess.target.usize_ty).unwrap();\n         box Constant {\n             span: self.span,\n             ty: self.tcx.types.usize,\n             literal: Literal::Value {\n                 value: self.tcx.mk_const(ty::Const {\n-                    val: ConstVal::Integral(ConstInt::Usize(value)),\n+                    val: if self.tcx.sess.opts.debugging_opts.miri {\n+                        ConstVal::Value(Value::ByVal(PrimVal::Bytes(value.into())))\n+                    } else {\n+                        let value = ConstUsize::new(\n+                            value,\n+                            self.tcx.sess.target.usize_ty,\n+                        ).unwrap();\n+                        ConstVal::Integral(ConstInt::Usize(value))\n+                    },\n                     ty: self.tcx.types.usize,\n                 })\n             }\n@@ -739,8 +752,12 @@ fn build_call_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 ty,\n                 literal: Literal::Value {\n                     value: tcx.mk_const(ty::Const {\n-                        val: ConstVal::Function(def_id,\n-                            Substs::identity_for_item(tcx, def_id)),\n+                        val: if tcx.sess.opts.debugging_opts.miri {\n+                            // ZST function type\n+                            ConstVal::Value(Value::ByVal(PrimVal::Undef))\n+                        } else {\n+                            ConstVal::Function(def_id, Substs::identity_for_item(tcx, def_id))\n+                        },\n                         ty\n                     }),\n                 },"}, {"sha": "ec3edb1e0680e58414abe86d4ccd1773c4eda013", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=918b6d763319863fb53c5b7bceebc14ad5fb4024", "patch": "@@ -80,6 +80,7 @@ use transform::simplify;\n use transform::no_landing_pads::no_landing_pads;\n use dataflow::{do_dataflow, DebugFormatted, state_for_location};\n use dataflow::{MaybeStorageLive, HaveBeenBorrowedLocals};\n+use rustc::mir::interpret::{Value, PrimVal};\n \n pub struct StateTransform;\n \n@@ -181,7 +182,11 @@ impl<'a, 'tcx> TransformVisitor<'a, 'tcx> {\n             ty: self.tcx.types.u32,\n             literal: Literal::Value {\n                 value: self.tcx.mk_const(ty::Const {\n-                    val: ConstVal::Integral(ConstInt::U32(state_disc)),\n+                    val: if self.tcx.sess.opts.debugging_opts.miri {\n+                        ConstVal::Value(Value::ByVal(PrimVal::Bytes(state_disc.into())))\n+                    } else {\n+                        ConstVal::Integral(ConstInt::U32(state_disc))\n+                    },\n                     ty: self.tcx.types.u32\n                 }),\n             },\n@@ -534,7 +539,7 @@ fn insert_switch<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let switch = TerminatorKind::SwitchInt {\n         discr: Operand::Copy(transform.make_field(transform.state_field, tcx.types.u32)),\n         switch_ty: tcx.types.u32,\n-        values: Cow::from(cases.iter().map(|&(i, _)| ConstInt::U32(i)).collect::<Vec<_>>()),\n+        values: Cow::from(cases.iter().map(|&(i, _)| i.into()).collect::<Vec<_>>()),\n         targets: cases.iter().map(|&(_, d)| d).chain(once(default_block)).collect(),\n     };\n "}, {"sha": "b8a0e0f89073dc09c263f3d08e3bf8c96b778735", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=918b6d763319863fb53c5b7bceebc14ad5fb4024", "patch": "@@ -207,6 +207,13 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n             return false;\n         }\n \n+        // Do not inline {u,i}128 lang items, trans const eval depends\n+        // on detecting calls to these lang items and intercepting them\n+        if tcx.is_binop_lang_item(callsite.callee).is_some() {\n+            debug!(\"    not inlining 128bit integer lang item\");\n+            return false;\n+        }\n+\n         let trans_fn_attrs = tcx.trans_fn_attrs(callsite.callee);\n \n         let hinted = match trans_fn_attrs.inline {"}, {"sha": "88618122e4f1137d5e0fe7b8b90849fc2d0cf640", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=918b6d763319863fb53c5b7bceebc14ad5fb4024", "patch": "@@ -690,7 +690,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                             _ => false\n                         }\n                     } else if let ty::TyArray(_, len) = ty.sty {\n-                        len.val.to_const_int().unwrap().to_u64().unwrap() == 0 &&\n+                        len.val.unwrap_u64() == 0 &&\n                             self.mode == Mode::Fn\n                     } else {\n                         false"}, {"sha": "ca7f573b58a4775840c065c55006ed5d7eeb0521", "filename": "src/librustc_mir/transform/simplify_branches.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs?ref=918b6d763319863fb53c5b7bceebc14ad5fb4024", "patch": "@@ -40,10 +40,10 @@ impl MirPass for SimplifyBranches {\n                 TerminatorKind::SwitchInt { discr: Operand::Constant(box Constant {\n                     literal: Literal::Value { ref value }, ..\n                 }), ref values, ref targets, .. } => {\n-                    if let Some(ref constint) = value.val.to_const_int() {\n+                    if let Some(constint) = value.val.to_u128() {\n                         let (otherwise, targets) = targets.split_last().unwrap();\n                         let mut ret = TerminatorKind::Goto { target: *otherwise };\n-                        for (v, t) in values.iter().zip(targets.iter()) {\n+                        for (&v, t) in values.iter().zip(targets.iter()) {\n                             if v == constint {\n                                 ret = TerminatorKind::Goto { target: *t };\n                                 break;"}, {"sha": "77ef2c20117f1ecb215f2fba658a292e4af42df5", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=918b6d763319863fb53c5b7bceebc14ad5fb4024", "patch": "@@ -11,13 +11,14 @@\n use std::fmt;\n use rustc::hir;\n use rustc::mir::*;\n-use rustc::middle::const_val::{ConstInt, ConstVal};\n+use rustc::middle::const_val::ConstVal;\n use rustc::middle::lang_items;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::subst::{Kind, Substs};\n use rustc::ty::util::IntTypeExt;\n use rustc_data_structures::indexed_vec::Idx;\n use util::patch::MirPatch;\n+use rustc::mir::interpret::{Value, PrimVal};\n \n use std::{iter, u32};\n \n@@ -425,7 +426,7 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n                     variant_path,\n                     &adt.variants[variant_index],\n                     substs);\n-                values.push(discr);\n+                values.push(discr.to_u128().unwrap());\n                 if let Unwind::To(unwind) = unwind {\n                     // We can't use the half-ladder from the original\n                     // drop ladder, because this breaks the\n@@ -480,7 +481,7 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n     fn adt_switch_block(&mut self,\n                         adt: &'tcx ty::AdtDef,\n                         blocks: Vec<BasicBlock>,\n-                        values: &[ConstInt],\n+                        values: &[u128],\n                         succ: BasicBlock,\n                         unwind: Unwind)\n                         -> BasicBlock {\n@@ -803,7 +804,7 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n                 self.complete_drop(Some(DropFlagMode::Deep), succ, unwind)\n             }\n             ty::TyArray(ety, size) => self.open_drop_for_array(\n-                ety, size.val.to_const_int().and_then(|v| v.to_u64())),\n+                ety, size.val.to_u128().map(|i| i as u64)),\n             ty::TySlice(ety) => self.open_drop_for_array(ety, None),\n \n             _ => bug!(\"open drop from non-ADT `{:?}`\", ty)\n@@ -949,7 +950,11 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n             ty: self.tcx().types.usize,\n             literal: Literal::Value {\n                 value: self.tcx().mk_const(ty::Const {\n-                    val: ConstVal::Integral(self.tcx().const_usize(val)),\n+                    val: if self.tcx().sess.opts.debugging_opts.miri {\n+                        ConstVal::Value(Value::ByVal(PrimVal::Bytes(val.into())))\n+                    } else {\n+                        ConstVal::Integral(self.tcx().const_usize(val))\n+                    },\n                     ty: self.tcx().types.usize\n                 })\n             }"}, {"sha": "8153c3c8493ff0ec4651f1ad5c4e876e1221aa59", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=918b6d763319863fb53c5b7bceebc14ad5fb4024", "patch": "@@ -129,6 +129,9 @@ impl<'a, 'gcx> CheckCrateVisitor<'a, 'gcx> {\n     }\n \n     fn check_const_eval(&self, expr: &'gcx hir::Expr) {\n+        if self.tcx.sess.opts.debugging_opts.miri {\n+            return;\n+        }\n         if let Err(err) = self.const_cx().eval(expr) {\n             match err.kind {\n                 UnimplementedConstVal(_) => {}\n@@ -220,23 +223,24 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n                 self.check_const_eval(lit);\n             }\n             PatKind::Range(ref start, ref end, RangeEnd::Excluded) => {\n-                match self.const_cx().compare_lit_exprs(p.span, start, end) {\n-                    Ok(Ordering::Less) => {}\n-                    Ok(Ordering::Equal) |\n-                    Ok(Ordering::Greater) => {\n+                match self.const_cx().compare_lit_exprs(start, end) {\n+                    Ok(Some(Ordering::Less)) => {}\n+                    Ok(Some(Ordering::Equal)) |\n+                    Ok(Some(Ordering::Greater)) => {\n                         span_err!(self.tcx.sess,\n                                   start.span,\n                                   E0579,\n                                   \"lower range bound must be less than upper\");\n                     }\n+                    Ok(None) => bug!(\"ranges must be char or int\"),\n                     Err(ErrorReported) => {}\n                 }\n             }\n             PatKind::Range(ref start, ref end, RangeEnd::Included) => {\n-                match self.const_cx().compare_lit_exprs(p.span, start, end) {\n-                    Ok(Ordering::Less) |\n-                    Ok(Ordering::Equal) => {}\n-                    Ok(Ordering::Greater) => {\n+                match self.const_cx().compare_lit_exprs(start, end) {\n+                    Ok(Some(Ordering::Less)) |\n+                    Ok(Some(Ordering::Equal)) => {}\n+                    Ok(Some(Ordering::Greater)) => {\n                         let mut err = struct_span_err!(\n                             self.tcx.sess,\n                             start.span,\n@@ -252,6 +256,7 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n                         }\n                         err.emit();\n                     }\n+                    Ok(None) => bug!(\"ranges must be char or int\"),\n                     Err(ErrorReported) => {}\n                 }\n             }\n@@ -308,7 +313,7 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n             self.promotable = false;\n         }\n \n-        if self.in_fn && self.promotable {\n+        if self.in_fn && self.promotable && !self.tcx.sess.opts.debugging_opts.miri {\n             match self.const_cx().eval(ex) {\n                 Ok(_) => {}\n                 Err(ConstEvalErr { kind: UnimplementedConstVal(_), .. }) |"}, {"sha": "314b8c59df5ab95566f70de93ac398a8b83bec74", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=918b6d763319863fb53c5b7bceebc14ad5fb4024", "patch": "@@ -195,7 +195,7 @@ pub fn unsized_info<'cx, 'tcx>(cx: &CodegenCx<'cx, 'tcx>,\n     let (source, target) = cx.tcx.struct_lockstep_tails(source, target);\n     match (&source.sty, &target.sty) {\n         (&ty::TyArray(_, len), &ty::TySlice(_)) => {\n-            C_usize(cx, len.val.to_const_int().unwrap().to_u64().unwrap())\n+            C_usize(cx, len.val.unwrap_u64())\n         }\n         (&ty::TyDynamic(..), &ty::TyDynamic(..)) => {\n             // For now, upcasts are limited to changes in marker"}, {"sha": "0fe425fb7ea1ecd4f36bb91941e61e916154ed84", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=918b6d763319863fb53c5b7bceebc14ad5fb4024", "patch": "@@ -276,7 +276,7 @@ fn fixed_vec_metadata<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n \n     let upper_bound = match array_or_slice_type.sty {\n         ty::TyArray(_, len) => {\n-            len.val.to_const_int().unwrap().to_u64().unwrap() as c_longlong\n+            len.val.unwrap_u64() as c_longlong\n         }\n         _ => -1\n     };"}, {"sha": "a88eb9ae354718eaa696d8c01bb8fbd3867e9c80", "filename": "src/librustc_trans/debuginfo/type_names.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs?ref=918b6d763319863fb53c5b7bceebc14ad5fb4024", "patch": "@@ -97,7 +97,7 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n         ty::TyArray(inner_type, len) => {\n             output.push('[');\n             push_debuginfo_type_name(cx, inner_type, true, output);\n-            output.push_str(&format!(\"; {}\", len.val.to_const_int().unwrap().to_u64().unwrap()));\n+            output.push_str(&format!(\"; {}\", len.val.unwrap_u64()));\n             output.push(']');\n         },\n         ty::TySlice(inner_type) => {"}, {"sha": "c88e39d7824c7213c1c2feee011e8fbf5adef56a", "filename": "src/librustc_trans/mir/analyze.rs", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs?ref=918b6d763319863fb53c5b7bceebc14ad5fb4024", "patch": "@@ -17,6 +17,7 @@ use rustc::middle::const_val::ConstVal;\n use rustc::mir::{self, Location, TerminatorKind, Literal};\n use rustc::mir::visit::{Visitor, PlaceContext};\n use rustc::mir::traversal;\n+use rustc::mir::interpret::{Value, PrimVal};\n use rustc::ty;\n use rustc::ty::layout::LayoutOf;\n use type_of::LayoutLlvmExt;\n@@ -109,23 +110,33 @@ impl<'mir, 'a, 'tcx> Visitor<'tcx> for LocalAnalyzer<'mir, 'a, 'tcx> {\n                              block: mir::BasicBlock,\n                              kind: &mir::TerminatorKind<'tcx>,\n                              location: Location) {\n-        match *kind {\n+        let check = match *kind {\n             mir::TerminatorKind::Call {\n                 func: mir::Operand::Constant(box mir::Constant {\n                     literal: Literal::Value {\n-                        value: &ty::Const { val: ConstVal::Function(def_id, _), .. }, ..\n+                        value: &ty::Const { val, ty }, ..\n                     }, ..\n                 }),\n                 ref args, ..\n-            } if Some(def_id) == self.fx.cx.tcx.lang_items().box_free_fn() => {\n+            } => match val {\n+                ConstVal::Function(def_id, _) => Some((def_id, args)),\n+                ConstVal::Value(Value::ByVal(PrimVal::Undef)) => match ty.sty {\n+                    ty::TyFnDef(did, _) => Some((did, args)),\n+                    _ => None,\n+                },\n+                _ => None,\n+            }\n+            _ => None,\n+        };\n+        if let Some((def_id, args)) = check {\n+            if Some(def_id) == self.cx.ccx.tcx().lang_items().box_free_fn() {\n                 // box_free(x) shares with `drop x` the property that it\n                 // is not guaranteed to be statically dominated by the\n                 // definition of x, so x must always be in an alloca.\n                 if let mir::Operand::Move(ref place) = args[0] {\n                     self.visit_place(place, PlaceContext::Drop, location);\n                 }\n             }\n-            _ => {}\n         }\n \n         self.super_terminator_kind(block, kind, location);"}, {"sha": "239300c1ecf4e6df1e630918a65a92059886ef50", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=918b6d763319863fb53c5b7bceebc14ad5fb4024", "patch": "@@ -10,7 +10,7 @@\n \n use llvm::{self, ValueRef, BasicBlockRef};\n use rustc::middle::lang_items;\n-use rustc::middle::const_val::{ConstEvalErr, ConstInt, ErrKind};\n+use rustc::middle::const_val::{ConstEvalErr, ErrKind};\n use rustc::ty::{self, TypeFoldable};\n use rustc::ty::layout::{self, LayoutOf};\n use rustc::traits;\n@@ -196,17 +196,18 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n                 if switch_ty == bx.tcx().types.bool {\n                     let lltrue = llblock(self, targets[0]);\n                     let llfalse = llblock(self, targets[1]);\n-                    if let [ConstInt::U8(0)] = values[..] {\n+                    if let [0] = values[..] {\n                         bx.cond_br(discr.immediate(), llfalse, lltrue);\n                     } else {\n+                        assert_eq!(&values[..], &[1]);\n                         bx.cond_br(discr.immediate(), lltrue, llfalse);\n                     }\n                 } else {\n                     let (otherwise, targets) = targets.split_last().unwrap();\n                     let switch = bx.switch(discr.immediate(),\n                                             llblock(self, *otherwise), values.len());\n-                    for (value, target) in values.iter().zip(targets) {\n-                        let val = Const::from_constint(bx.cx, value);\n+                    for (&value, target) in values.iter().zip(targets) {\n+                        let val = Const::from_bytes(bx.cx, value, switch_ty);\n                         let llbb = llblock(self, *target);\n                         bx.add_case(switch, val.llval, llbb)\n                     }"}, {"sha": "5bd5f19a57c63fbe671f1d7e0525fadffe1024e0", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 75, "deletions": 35, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=918b6d763319863fb53c5b7bceebc14ad5fb4024", "patch": "@@ -16,6 +16,7 @@ use rustc::hir::def_id::DefId;\n use rustc::infer::TransNormalize;\n use rustc::traits;\n use rustc::mir;\n+use rustc::mir::interpret::{Value as MiriValue, PrimVal};\n use rustc::mir::tcx::PlaceTy;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc::ty::layout::{self, LayoutOf, Size};\n@@ -38,6 +39,7 @@ use value::Value;\n \n use syntax_pos::Span;\n use syntax::ast;\n+use syntax::symbol::Symbol;\n \n use std::fmt;\n use std::ptr;\n@@ -81,12 +83,46 @@ impl<'a, 'tcx> Const<'tcx> {\n         Const { llval: llval, ty: ty }\n     }\n \n+    pub fn from_bytes(ccx: &CrateContext<'a, 'tcx>, b: u128, ty: Ty<'tcx>) -> Const<'tcx> {\n+        let llval = match ty.sty {\n+            ty::TyInt(ast::IntTy::I128) |\n+            ty::TyUint(ast::UintTy::U128) => C_uint_big(Type::i128(ccx), b),\n+            ty::TyInt(i) => C_int(Type::int_from_ty(ccx, i), b as i128 as i64),\n+            ty::TyUint(u) => C_uint(Type::uint_from_ty(ccx, u), b as u64),\n+            ty::TyBool => {\n+                assert!(b <= 1);\n+                C_bool(ccx, b == 1)\n+            },\n+            ty::TyChar => {\n+                assert_eq!(b as u32 as u128, b);\n+                let c = b as u32;\n+                assert!(::std::char::from_u32(c).is_some());\n+                C_uint(Type::char(ccx), c as u64)\n+            },\n+            ty::TyFloat(fty) => {\n+                let llty = ccx.layout_of(ty).llvm_type(ccx);\n+                let bits = match fty {\n+                    ast::FloatTy::F32 => C_u32(ccx, b as u32),\n+                    ast::FloatTy::F64 => C_u64(ccx, b as u64),\n+                };\n+                consts::bitcast(bits, llty)\n+            },\n+            ty::TyAdt(adt, _) if adt.is_enum() => {\n+                use rustc::ty::util::IntTypeExt;\n+                Const::from_bytes(ccx, b, adt.repr.discr_type().to_ty(ccx.tcx())).llval\n+            },\n+            _ => bug!(\"from_bytes({}, {})\", b, ty),\n+        };\n+        Const { llval, ty }\n+    }\n+\n     /// Translate ConstVal into a LLVM constant value.\n     pub fn from_constval(cx: &CodegenCx<'a, 'tcx>,\n                          cv: &ConstVal,\n                          ty: Ty<'tcx>)\n                          -> Const<'tcx> {\n         let llty = cx.layout_of(ty).llvm_type(cx);\n+        trace!(\"from_constval: {:#?}: {}\", cv, ty);\n         let val = match *cv {\n             ConstVal::Float(v) => {\n                 let bits = match v.ty {\n@@ -108,7 +144,41 @@ impl<'a, 'tcx> Const<'tcx> {\n             ConstVal::Unevaluated(..) => {\n                 bug!(\"MIR must not use `{:?}` (aggregates are expanded to MIR rvalues)\", cv)\n             }\n-            ConstVal::Value(_) => unimplemented!(),\n+            ConstVal::Value(MiriValue::ByRef(..)) => unimplemented!(\"{:#?}:{}\", cv, ty),\n+            ConstVal::Value(MiriValue::ByValPair(PrimVal::Ptr(ptr), PrimVal::Bytes(len))) => {\n+                match ty.sty {\n+                    ty::TyRef(_, ref tam) => match tam.ty.sty {\n+                        ty::TyStr => {},\n+                        _ => unimplemented!(\"non-str fat pointer: {:?}: {:?}\", ptr, ty),\n+                    },\n+                    _ => unimplemented!(\"non-str fat pointer: {:?}: {:?}\", ptr, ty),\n+                }\n+                let alloc = ccx\n+                    .tcx()\n+                    .interpret_interner\n+                    .borrow()\n+                    .get_alloc(ptr.alloc_id.0)\n+                    .expect(\"miri alloc not found\");\n+                assert_eq!(len as usize as u128, len);\n+                let slice = &alloc.bytes[(ptr.offset as usize)..][..(len as usize)];\n+                let s = ::std::str::from_utf8(slice)\n+                    .expect(\"non utf8 str from miri\");\n+                C_str_slice(ccx, Symbol::intern(s).as_str())\n+            },\n+            ConstVal::Value(MiriValue::ByValPair(..)) => unimplemented!(),\n+            ConstVal::Value(MiriValue::ByVal(PrimVal::Bytes(b))) =>\n+                return Const::from_bytes(ccx, b, ty),\n+            ConstVal::Value(MiriValue::ByVal(PrimVal::Undef)) => C_undef(llty),\n+            ConstVal::Value(MiriValue::ByVal(PrimVal::Ptr(ptr))) => {\n+                let alloc = ccx\n+                    .tcx()\n+                    .interpret_interner\n+                    .borrow()\n+                    .get_alloc(ptr.alloc_id.0)\n+                    .expect(\"miri alloc not found\");\n+                let data = &alloc.bytes[(ptr.offset as usize)..];\n+                consts::addr_of(ccx, C_bytes(ccx, data), ccx.align_of(ty), \"byte_str\")\n+            }\n         };\n \n         assert!(!ty.has_erasable_regions());\n@@ -239,7 +309,7 @@ impl<'tcx> ConstPlace<'tcx> {\n     pub fn len<'a>(&self, cx: &CodegenCx<'a, 'tcx>) -> ValueRef {\n         match self.ty.sty {\n             ty::TyArray(_, n) => {\n-                C_usize(cx, n.val.to_const_int().unwrap().to_u64().unwrap())\n+                C_usize(cx, n.val.unwrap_u64())\n             }\n             ty::TySlice(_) | ty::TyStr => {\n                 assert!(self.llextra != ptr::null_mut());\n@@ -316,7 +386,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n         let tcx = self.cx.tcx;\n         let mut bb = mir::START_BLOCK;\n \n-        // Make sure to evaluate all statemenets to\n+        // Make sure to evaluate all statements to\n         // report as many errors as we possibly can.\n         let mut failure = Ok(());\n \n@@ -392,6 +462,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                         _ => span_bug!(span, \"calling {:?} (of type {}) in constant\",\n                                        func, fn_ty)\n                     };\n+                    trace!(\"trans const fn call {:?}, {:?}, {:#?}\", func, fn_ty, args);\n \n                     let mut arg_vals = IndexVec::with_capacity(args.len());\n                     for arg in args {\n@@ -419,7 +490,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                                 }\n                                 _ => span_bug!(span, \"{:?} in constant\", terminator.kind)\n                             }\n-                        } else if let Some((op, is_checked)) = self.is_binop_lang_item(def_id) {\n+                        } else if let Some((op, is_checked)) = tcx.is_binop_lang_item(def_id) {\n                             (||{\n                                 assert_eq!(arg_vals.len(), 2);\n                                 let rhs = arg_vals.pop().unwrap()?;\n@@ -470,37 +541,6 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n         }\n     }\n \n-    fn is_binop_lang_item(&mut self, def_id: DefId) -> Option<(mir::BinOp, bool)> {\n-        let tcx = self.cx.tcx;\n-        let items = tcx.lang_items();\n-        let def_id = Some(def_id);\n-        if items.i128_add_fn() == def_id { Some((mir::BinOp::Add, false)) }\n-        else if items.u128_add_fn() == def_id { Some((mir::BinOp::Add, false)) }\n-        else if items.i128_sub_fn() == def_id { Some((mir::BinOp::Sub, false)) }\n-        else if items.u128_sub_fn() == def_id { Some((mir::BinOp::Sub, false)) }\n-        else if items.i128_mul_fn() == def_id { Some((mir::BinOp::Mul, false)) }\n-        else if items.u128_mul_fn() == def_id { Some((mir::BinOp::Mul, false)) }\n-        else if items.i128_div_fn() == def_id { Some((mir::BinOp::Div, false)) }\n-        else if items.u128_div_fn() == def_id { Some((mir::BinOp::Div, false)) }\n-        else if items.i128_rem_fn() == def_id { Some((mir::BinOp::Rem, false)) }\n-        else if items.u128_rem_fn() == def_id { Some((mir::BinOp::Rem, false)) }\n-        else if items.i128_shl_fn() == def_id { Some((mir::BinOp::Shl, false)) }\n-        else if items.u128_shl_fn() == def_id { Some((mir::BinOp::Shl, false)) }\n-        else if items.i128_shr_fn() == def_id { Some((mir::BinOp::Shr, false)) }\n-        else if items.u128_shr_fn() == def_id { Some((mir::BinOp::Shr, false)) }\n-        else if items.i128_addo_fn() == def_id { Some((mir::BinOp::Add, true)) }\n-        else if items.u128_addo_fn() == def_id { Some((mir::BinOp::Add, true)) }\n-        else if items.i128_subo_fn() == def_id { Some((mir::BinOp::Sub, true)) }\n-        else if items.u128_subo_fn() == def_id { Some((mir::BinOp::Sub, true)) }\n-        else if items.i128_mulo_fn() == def_id { Some((mir::BinOp::Mul, true)) }\n-        else if items.u128_mulo_fn() == def_id { Some((mir::BinOp::Mul, true)) }\n-        else if items.i128_shlo_fn() == def_id { Some((mir::BinOp::Shl, true)) }\n-        else if items.u128_shlo_fn() == def_id { Some((mir::BinOp::Shl, true)) }\n-        else if items.i128_shro_fn() == def_id { Some((mir::BinOp::Shr, true)) }\n-        else if items.u128_shro_fn() == def_id { Some((mir::BinOp::Shr, true)) }\n-        else { None }\n-    }\n-\n     fn store(&mut self,\n              dest: &mir::Place<'tcx>,\n              value: Result<Const<'tcx>, ConstEvalErr<'tcx>>,"}, {"sha": "b0cb7de824eb5e0ab6600f4ad8c35ba81d4bf3ab", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=918b6d763319863fb53c5b7bceebc14ad5fb4024", "patch": "@@ -497,7 +497,7 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n         if let mir::Place::Local(index) = *place {\n             if let LocalRef::Operand(Some(op)) = self.locals[index] {\n                 if let ty::TyArray(_, n) = op.layout.ty.sty {\n-                    let n = n.val.to_const_int().unwrap().to_u64().unwrap();\n+                    let n = n.val.unwrap_u64();\n                     return common::C_usize(bx.cx, n);\n                 }\n             }"}, {"sha": "eb02c05fd3957112882bd15f0e94a25c2a54f96d", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=918b6d763319863fb53c5b7bceebc14ad5fb4024", "patch": "@@ -413,7 +413,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 let expected_ty = self.structurally_resolved_type(pat.span, expected);\n                 let (inner_ty, slice_ty) = match expected_ty.sty {\n                     ty::TyArray(inner_ty, size) => {\n-                        let size = size.val.to_const_int().unwrap().to_u64().unwrap();\n+                        let size = size.val.unwrap_u64();\n                         let min_len = before.len() as u64 + after.len() as u64;\n                         if slice.is_none() {\n                             if min_len != size {"}, {"sha": "26b9649331025ddf10c795d662644795d4b6c875", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=918b6d763319863fb53c5b7bceebc14ad5fb4024", "patch": "@@ -4029,9 +4029,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             };\n \n             if let Ok(count) = count {\n-                let zero_or_one = count.val.to_const_int().and_then(|count| {\n-                    count.to_u64().map(|count| count <= 1)\n-                }).unwrap_or(false);\n+                let zero_or_one = count.val.to_u128().map_or(false, |count| count <= 1);\n                 if !zero_or_one {\n                     // For [foo, ..n] where n > 1, `foo` must have\n                     // Copy type:"}, {"sha": "47a229cbd3b5b9f98b8bebc28cb2540f8874ef79", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=918b6d763319863fb53c5b7bceebc14ad5fb4024", "patch": "@@ -447,10 +447,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 hir::BiBitOr => (\"bitor\", lang.bitor_trait()),\n                 hir::BiShl => (\"shl\", lang.shl_trait()),\n                 hir::BiShr => (\"shr\", lang.shr_trait()),\n-                hir::BiLt => (\"lt\", lang.ord_trait()),\n-                hir::BiLe => (\"le\", lang.ord_trait()),\n-                hir::BiGe => (\"ge\", lang.ord_trait()),\n-                hir::BiGt => (\"gt\", lang.ord_trait()),\n+                hir::BiLt => (\"lt\", lang.partial_ord_trait()),\n+                hir::BiLe => (\"le\", lang.partial_ord_trait()),\n+                hir::BiGe => (\"ge\", lang.partial_ord_trait()),\n+                hir::BiGt => (\"gt\", lang.partial_ord_trait()),\n                 hir::BiEq => (\"eq\", lang.eq_trait()),\n                 hir::BiNe => (\"ne\", lang.eq_trait()),\n                 hir::BiAnd | hir::BiOr => {"}, {"sha": "5ed35e8203cecacc03891325634a7cbd028b4aaa", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=918b6d763319863fb53c5b7bceebc14ad5fb4024", "patch": "@@ -37,8 +37,8 @@ use rustc::ty::{ToPredicate, ReprOptions};\n use rustc::ty::{self, AdtKind, ToPolyTraitRef, Ty, TyCtxt};\n use rustc::ty::maps::Providers;\n use rustc::ty::util::IntTypeExt;\n-use rustc::util::nodemap::FxHashSet;\n-use util::nodemap::FxHashMap;\n+use rustc::util::nodemap::{FxHashSet, FxHashMap};\n+use rustc::mir::interpret::{Value, PrimVal};\n \n use rustc_const_math::ConstInt;\n \n@@ -534,6 +534,18 @@ fn convert_enum_variant_types<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n             match result {\n                 Ok(&ty::Const { val: ConstVal::Integral(x), .. }) => Some(x),\n+                Ok(&ty::Const {\n+                    val: ConstVal::Value(Value::ByVal(PrimVal::Bytes(b))),\n+                    ..\n+                }) => {\n+                    use syntax::attr::IntType;\n+                    Some(match repr_type {\n+                        IntType::SignedInt(int_type) => ConstInt::new_signed(\n+                            b as i128, int_type, tcx.sess.target.isize_ty).unwrap(),\n+                        IntType::UnsignedInt(uint_type) => ConstInt::new_unsigned(\n+                            b, uint_type, tcx.sess.target.usize_ty).unwrap(),\n+                    })\n+                }\n                 _ => None\n             }\n         } else if let Some(discr) = repr_type.disr_incr(tcx, prev_discr) {"}, {"sha": "40385cabf5661ba32e3f7055babd4487819f5d38", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=918b6d763319863fb53c5b7bceebc14ad5fb4024", "patch": "@@ -86,6 +86,7 @@ This API is completely unstable and subject to change.\n #![feature(refcell_replace_swap)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(slice_patterns)]\n+#![feature(i128_type)]\n \n #[macro_use] extern crate log;\n #[macro_use] extern crate syntax;"}, {"sha": "3fb5621c8ae3ba4429d9584b0046feb9507d8f3d", "filename": "src/test/mir-opt/end_region_2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Ftest%2Fmir-opt%2Fend_region_2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Ftest%2Fmir-opt%2Fend_region_2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_2.rs?ref=918b6d763319863fb53c5b7bceebc14ad5fb4024", "patch": "@@ -49,7 +49,7 @@ fn main() {\n //         _3 = &'23_1rs _2;\n //         StorageLive(_5);\n //         _5 = _2;\n-//         switchInt(move _5) -> [0u8: bb5, otherwise: bb4];\n+//         switchInt(move _5) -> [false: bb5, otherwise: bb4];\n //     }\n //     bb3: {\n //         ..."}, {"sha": "070bde8e3c3e6f7faa15551307266e0f5afeb6c5", "filename": "src/test/mir-opt/end_region_3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Ftest%2Fmir-opt%2Fend_region_3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Ftest%2Fmir-opt%2Fend_region_3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_3.rs?ref=918b6d763319863fb53c5b7bceebc14ad5fb4024", "patch": "@@ -51,7 +51,7 @@ fn main() {\n //         _3 = &'26_1rs _1;\n //         StorageLive(_5);\n //         _5 = _1;\n-//         switchInt(move _5) -> [0u8: bb5, otherwise: bb4];\n+//         switchInt(move _5) -> [false: bb5, otherwise: bb4];\n //     }\n //     bb3: {\n //         ..."}, {"sha": "6d9a27eeeb4560dc276027cd92a4e7cd36bc4f50", "filename": "src/test/mir-opt/end_region_9.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Ftest%2Fmir-opt%2Fend_region_9.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Ftest%2Fmir-opt%2Fend_region_9.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_9.rs?ref=918b6d763319863fb53c5b7bceebc14ad5fb4024", "patch": "@@ -72,7 +72,7 @@ fn main() {\n //    bb4: {\n //        StorageLive(_7);\n //        _7 = _1;\n-//        switchInt(move _7) -> [0u8: bb6, otherwise: bb5];\n+//        switchInt(move _7) -> [false: bb6, otherwise: bb5];\n //    }\n //    bb5: {\n //        _0 = ();"}, {"sha": "83425a72f4598e38131070b9cbaa9d9d6766df4c", "filename": "src/test/mir-opt/end_region_cyclic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Ftest%2Fmir-opt%2Fend_region_cyclic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Ftest%2Fmir-opt%2Fend_region_cyclic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_cyclic.rs?ref=918b6d763319863fb53c5b7bceebc14ad5fb4024", "patch": "@@ -103,7 +103,7 @@ fn query() -> bool { true }\n //         _11 = const query() -> [return: bb6, unwind: bb3];\n //     }\n //     bb6: {\n-//         switchInt(move _11) -> [0u8: bb8, otherwise: bb7];\n+//         switchInt(move _11) -> [false: bb8, otherwise: bb7];\n //     }\n //     bb7: {\n //         _0 = ();"}, {"sha": "a9eea26f46643843d2270ea4402b78467a49d0e2", "filename": "src/test/mir-opt/issue-38669.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Ftest%2Fmir-opt%2Fissue-38669.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Ftest%2Fmir-opt%2Fissue-38669.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fissue-38669.rs?ref=918b6d763319863fb53c5b7bceebc14ad5fb4024", "patch": "@@ -36,7 +36,7 @@ fn main() {\n //     bb3: {\n //         StorageLive(_4);\n //         _4 = _1;\n-//         switchInt(move _4) -> [0u8: bb5, otherwise: bb4];\n+//         switchInt(move _4) -> [false: bb5, otherwise: bb4];\n //     }\n //     bb4: {\n //         _0 = ();"}, {"sha": "596bb4e115dfcd65682db12d3a3cf5cef6ea34a7", "filename": "src/test/mir-opt/match_false_edges.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Ftest%2Fmir-opt%2Fmatch_false_edges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Ftest%2Fmir-opt%2Fmatch_false_edges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fmatch_false_edges.rs?ref=918b6d763319863fb53c5b7bceebc14ad5fb4024", "patch": "@@ -93,7 +93,7 @@ fn main() {\n //      _7 = const guard() -> [return: bb10, unwind: bb1];\n //  }\n //  bb10: { // end of guard\n-//      switchInt(move _7) -> [0u8: bb11, otherwise: bb2];\n+//      switchInt(move _7) -> [false: bb11, otherwise: bb2];\n //  }\n //  bb11: { // to pre_binding2\n //      falseEdges -> [real: bb5, imaginary: bb5];\n@@ -157,7 +157,7 @@ fn main() {\n //      _7 = const guard() -> [return: bb10, unwind: bb1];\n //  }\n //  bb10: { // end of guard\n-//      switchInt(move _7) -> [0u8: bb11, otherwise: bb2];\n+//      switchInt(move _7) -> [false: bb11, otherwise: bb2];\n //  }\n //  bb11: { // to pre_binding2\n //      falseEdges -> [real: bb6, imaginary: bb5];\n@@ -219,7 +219,7 @@ fn main() {\n //     _9 = const guard() -> [return: bb10, unwind: bb1];\n // }\n // bb10: { //end of guard\n-//    switchInt(move _9) -> [0u8: bb11, otherwise: bb2];\n+//    switchInt(move _9) -> [false: bb11, otherwise: bb2];\n // }\n // bb11: { // to pre_binding2\n //     falseEdges -> [real: bb5, imaginary: bb5];\n@@ -239,8 +239,8 @@ fn main() {\n //     _11 = const guard2(move _12) -> [return: bb14, unwind: bb1];\n // }\n // bb14: { // end of guard2\n-//     StorageDead(_12);\n-//     switchInt(move _11) -> [0u8: bb15, otherwise: bb3];\n+//     StorageDead(_11);\n+//     switchInt(move _11) -> [false: bb15, otherwise: bb3];\n // }\n // bb15: { // to pre_binding4\n //     falseEdges -> [real: bb7, imaginary: bb7];"}, {"sha": "19d733d4f6b6a8931bdc0a4d2b5617b970b7b85c", "filename": "src/test/mir-opt/nll/region-liveness-basic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-basic.rs?ref=918b6d763319863fb53c5b7bceebc14ad5fb4024", "patch": "@@ -41,7 +41,7 @@ fn main() {\n //            | Live variables on entry to bb2[0]: [_1, _3]\n //        _2 = &'_#2r _1[_3];\n //            | Live variables on entry to bb2[1]: [_2]\n-//        switchInt(const true) -> [0u8: bb4, otherwise: bb3];\n+//        switchInt(const true) -> [false: bb4, otherwise: bb3];\n //    }\n // END rustc.main.nll.0.mir\n // START rustc.main.nll.0.mir"}, {"sha": "52d5892e6560b96ca2165147535566a8c3711375", "filename": "src/test/mir-opt/simplify_if.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Ftest%2Fmir-opt%2Fsimplify_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Ftest%2Fmir-opt%2Fsimplify_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fsimplify_if.rs?ref=918b6d763319863fb53c5b7bceebc14ad5fb4024", "patch": "@@ -17,7 +17,7 @@ fn main() {\n // END RUST SOURCE\n // START rustc.main.SimplifyBranches-initial.before.mir\n // bb0: {\n-//     switchInt(const false) -> [0u8: bb3, otherwise: bb2];\n+//     switchInt(const false) -> [false: bb3, otherwise: bb2];\n // }\n // END rustc.main.SimplifyBranches-initial.before.mir\n // START rustc.main.SimplifyBranches-initial.after.mir"}, {"sha": "885edb55ed86c9a95ba09cdd68c1eaea1a62463d", "filename": "src/test/ui/const-eval-overflow-2.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Ftest%2Fui%2Fconst-eval-overflow-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Ftest%2Fui%2Fconst-eval-overflow-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-eval-overflow-2.rs?ref=918b6d763319863fb53c5b7bceebc14ad5fb4024", "patch": "@@ -19,8 +19,7 @@ use std::{u8, u16, u32, u64, usize};\n \n const NEG_128: i8 = -128;\n const NEG_NEG_128: i8 = -NEG_128;\n-//~^ ERROR constant evaluation error\n-//~| attempt to negate with overflow\n+//~^ ERROR E0080\n \n fn main() {\n     match -128i8 {"}, {"sha": "a1b90f623cdae1d5b9c35bee0c156ec52704f82d", "filename": "src/test/ui/const-eval-overflow-4.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Ftest%2Fui%2Fconst-eval-overflow-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Ftest%2Fui%2Fconst-eval-overflow-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-eval-overflow-4.rs?ref=918b6d763319863fb53c5b7bceebc14ad5fb4024", "patch": "@@ -21,8 +21,7 @@ use std::{u8, u16, u32, u64, usize};\n \n const A_I8_T\n     : [u32; (i8::MAX as i8 + 1i8) as usize]\n-    //~^ ERROR constant evaluation error\n-    //~| WARNING constant evaluation error\n+    //~^ ERROR E0080\n     = [0; (i8::MAX as usize) + 1];\n \n fn main() {"}, {"sha": "86c5e873df866d72b69be554b4cf5fa08233e4cb", "filename": "src/test/ui/const-eval/issue-43197.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Ftest%2Fui%2Fconst-eval%2Fissue-43197.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Ftest%2Fui%2Fconst-eval%2Fissue-43197.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-eval%2Fissue-43197.rs?ref=918b6d763319863fb53c5b7bceebc14ad5fb4024", "patch": "@@ -16,8 +16,6 @@ const fn foo(x: u32) -> u32 {\n \n fn main() {\n     const X: u32 = 0-1; //~ ERROR constant evaluation error\n-    //~^ WARN constant evaluation error\n     const Y: u32 = foo(0-1); //~ ERROR constant evaluation error\n-    //~^ WARN constant evaluation error\n     println!(\"{} {}\", X, Y);\n }"}, {"sha": "bfd6a4090649b7cfd8bfcef032efe092bdd0939b", "filename": "src/test/ui/const-expr-addr-operator.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Ftest%2Fui%2Fconst-expr-addr-operator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Ftest%2Fui%2Fconst-expr-addr-operator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-expr-addr-operator.rs?ref=918b6d763319863fb53c5b7bceebc14ad5fb4024", "patch": "@@ -9,10 +9,11 @@\n // except according to those terms.\n \n // Encountered while testing #44614.\n+// must-compile-successfully\n \n pub fn main() {\n     // Constant of generic type (int)\n-    const X: &'static u32 = &22; //~ ERROR constant evaluation error\n+    const X: &'static u32 = &22;\n     assert_eq!(0, match &22 {\n         X => 0,\n         _ => 1,"}, {"sha": "dc1526a7079d44e75175e74d19b7ae47247a70cf", "filename": "src/test/ui/const-fn-error.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Ftest%2Fui%2Fconst-fn-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Ftest%2Fui%2Fconst-fn-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-fn-error.rs?ref=918b6d763319863fb53c5b7bceebc14ad5fb4024", "patch": "@@ -13,17 +13,18 @@\n const X : usize = 2;\n \n const fn f(x: usize) -> usize {\n-    let mut sum = 0; //~ ERROR blocks in constant functions are limited\n-    for i in 0..x { //~ ERROR calls in constant functions\n-    //~| ERROR constant function contains unimplemented\n+    let mut sum = 0;\n+    //~^ ERROR E0016\n+    for i in 0..x {\n+        //~^ ERROR E0015\n+        //~| ERROR E0019\n         sum += i;\n     }\n-    sum //~ ERROR E0080\n-        //~| non-constant path in constant\n+    sum\n }\n \n #[allow(unused_variables)]\n fn main() {\n     let a : [i32; f(X)];\n-    //~^ WARNING constant evaluation error: non-constant path\n+    //~^ ERROR E0080\n }"}, {"sha": "26c238992ab60d1b93d5dd47f3ece68b88f91807", "filename": "src/test/ui/const-fn-error.stderr", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Ftest%2Fui%2Fconst-fn-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Ftest%2Fui%2Fconst-fn-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-fn-error.stderr?ref=918b6d763319863fb53c5b7bceebc14ad5fb4024", "patch": "@@ -1,3 +1,4 @@\n+<<<<<<< HEAD\n warning: constant evaluation error: non-constant path in constant expression\n   --> $DIR/const-fn-error.rs:27:19\n    |\n@@ -10,6 +11,12 @@ error[E0016]: blocks in constant functions are limited to items and tail express\n   --> $DIR/const-fn-error.rs:16:19\n    |\n LL |     let mut sum = 0; //~ ERROR blocks in constant functions are limited\n+=======\n+error[E0016]: blocks in constant functions are limited to items and tail expressions\n+  --> $DIR/const-fn-error.rs:16:19\n+   |\n+16 |     let mut sum = 0;\n+>>>>>>> Produce  instead of pointers\n    |                   ^\n \n error[E0015]: calls in constant functions are limited to constant functions, struct and enum constructors\n@@ -25,6 +32,7 @@ LL |     for i in 0..x { //~ ERROR calls in constant functions\n    |              ^^^^\n \n error[E0080]: constant evaluation error\n+<<<<<<< HEAD\n   --> $DIR/const-fn-error.rs:21:5\n    |\n LL |     sum //~ ERROR E0080\n@@ -35,6 +43,12 @@ note: for constant expression here\n    |\n LL |     let a : [i32; f(X)];\n    |             ^^^^^^^^^^^\n+=======\n+  --> $DIR/const-fn-error.rs:28:19\n+   |\n+28 |     let a : [i32; f(X)];\n+   |                   ^^^^ miri failed: machine error: Cannot evaluate within constants: \"calling non-const fn `<I as std::iter::IntoIterator><std::ops::Range<usize>>::into_iter`\"\n+>>>>>>> Produce  instead of pointers\n \n error: aborting due to 4 previous errors\n "}, {"sha": "7582d0efa812e1d0082a0247b2d7789f3edc67eb", "filename": "src/test/ui/const-len-underflow-separate-spans.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Ftest%2Fui%2Fconst-len-underflow-separate-spans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Ftest%2Fui%2Fconst-len-underflow-separate-spans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-len-underflow-separate-spans.rs?ref=918b6d763319863fb53c5b7bceebc14ad5fb4024", "patch": "@@ -15,9 +15,8 @@\n const ONE: usize = 1;\n const TWO: usize = 2;\n const LEN: usize = ONE - TWO;\n-//~^ ERROR constant evaluation error [E0080]\n-//~| WARN attempt to subtract with overflow\n \n fn main() {\n     let a: [i8; LEN] = unimplemented!();\n+//~^ ERROR E0080\n }"}, {"sha": "09b24d1ffa208ba8d16fa47fea13523f6ccbaccd", "filename": "src/test/ui/const-pattern-not-const-evaluable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Ftest%2Fui%2Fconst-pattern-not-const-evaluable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Ftest%2Fui%2Fconst-pattern-not-const-evaluable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-pattern-not-const-evaluable.rs?ref=918b6d763319863fb53c5b7bceebc14ad5fb4024", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// must-compile-successfully\n+\n #![feature(const_fn)]\n \n #[derive(PartialEq, Eq)]\n@@ -20,8 +22,6 @@ use Cake::*;\n struct Pair<A, B>(A, B);\n \n const BOO: Pair<Cake, Cake> = Pair(Marmor, BlackForest);\n-//~^ ERROR: constant evaluation error [E0080]\n-//~| unimplemented constant expression: tuple struct constructors\n const FOO: Cake = BOO.1;\n \n const fn foo() -> Cake {"}, {"sha": "eb5f746774cf13886c8eb9ffa377b8010ad9548e", "filename": "src/test/ui/feature-gate-const-indexing.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Ftest%2Fui%2Ffeature-gate-const-indexing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Ftest%2Fui%2Ffeature-gate-const-indexing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-const-indexing.rs?ref=918b6d763319863fb53c5b7bceebc14ad5fb4024", "patch": "@@ -8,10 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// must-compile-successfully\n \n fn main() {\n     const ARR: [i32; 6] = [42, 43, 44, 45, 46, 47];\n     const IDX: usize = 3;\n     const VAL: i32 = ARR[IDX];\n-    const BLUB: [i32; (ARR[0] - 41) as usize] = [5]; //~ ERROR constant evaluation error\n+    const BLUB: [i32; (ARR[0] - 41) as usize] = [5];\n }"}, {"sha": "24cd20a84a9feebd3997a671788a8e90f568a9a0", "filename": "src/test/ui/issue-38875/issue_38875.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Ftest%2Fui%2Fissue-38875%2Fissue_38875.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Ftest%2Fui%2Fissue-38875%2Fissue_38875.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-38875%2Fissue_38875.rs?ref=918b6d763319863fb53c5b7bceebc14ad5fb4024", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n // aux-build:issue_38875_b.rs\n+// must-compile-successfully\n \n extern crate issue_38875_b;\n "}, {"sha": "aeafb45e6a552658f7e0b3968d0eaafe109cb927", "filename": "src/test/ui/union/union-const-eval.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Ftest%2Fui%2Funion%2Funion-const-eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Ftest%2Fui%2Funion%2Funion-const-eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-const-eval.rs?ref=918b6d763319863fb53c5b7bceebc14ad5fb4024", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// must-compile-successfully\n+\n union U {\n     a: usize,\n     b: usize,\n@@ -16,9 +18,6 @@ union U {\n const C: U = U { a: 10 };\n \n fn main() {\n-    unsafe {\n-        let a: [u8; C.a]; // OK\n-        let b: [u8; C.b]; //~ ERROR constant evaluation error\n-                          //~| WARNING constant evaluation error\n-    }\n+    let a: [u8; unsafe { C.a }];\n+    let b: [u8; unsafe { C.b }];\n }"}]}