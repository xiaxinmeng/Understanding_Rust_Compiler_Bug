{"sha": "854b52dbedbfe4944309514e98a7aba4185c2c5c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg1NGI1MmRiZWRiZmU0OTQ0MzA5NTE0ZTk4YTdhYmE0MTg1YzJjNWM=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-04-21T10:50:43Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-04-21T10:50:43Z"}, "message": "Keep comments on fn arguments", "tree": {"sha": "ce5293c27542fbd9ed8c2026a17ed44e55b4f758", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ce5293c27542fbd9ed8c2026a17ed44e55b4f758"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/854b52dbedbfe4944309514e98a7aba4185c2c5c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/854b52dbedbfe4944309514e98a7aba4185c2c5c", "html_url": "https://github.com/rust-lang/rust/commit/854b52dbedbfe4944309514e98a7aba4185c2c5c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/854b52dbedbfe4944309514e98a7aba4185c2c5c/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4c869a1b9d3b7b93dd5f5328466a105c18277d91", "url": "https://api.github.com/repos/rust-lang/rust/commits/4c869a1b9d3b7b93dd5f5328466a105c18277d91", "html_url": "https://github.com/rust-lang/rust/commit/4c869a1b9d3b7b93dd5f5328466a105c18277d91"}], "stats": {"total": 364, "additions": 242, "deletions": 122}, "files": [{"sha": "5b08fa797bcf38bcd2be28d94565f6836baa7a38", "filename": "src/functions.rs", "status": "modified", "additions": 187, "deletions": 101, "changes": 288, "blob_url": "https://github.com/rust-lang/rust/blob/854b52dbedbfe4944309514e98a7aba4185c2c5c/src%2Ffunctions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/854b52dbedbfe4944309514e98a7aba4185c2c5c/src%2Ffunctions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffunctions.rs?ref=854b52dbedbfe4944309514e98a7aba4185c2c5c", "patch": "@@ -14,6 +14,7 @@ use utils::make_indent;\n use lists::{write_list, ListFormatting, SeparatorTactic, ListTactic};\n use visitor::FmtVisitor;\n use syntax::{ast, abi};\n+use syntax::codemap::{self, Span};\n use syntax::print::pprust;\n use syntax::parse::token;\n \n@@ -55,42 +56,164 @@ impl<'a> FmtVisitor<'a> {\n         result.push_str(&token::get_ident(ident));\n \n         // Generics.\n-        // FIXME convert bounds to where clauses where they get too big or if\n-        // there is a where clause at all.\n-        let lifetimes: &[_] = &generics.lifetimes;\n-        let tys: &[_] = &generics.ty_params;\n-        if lifetimes.len() + tys.len() > 0 {\n-            let budget = MAX_WIDTH - indent - result.len() - 2;\n-            // TODO might need to insert a newline if the generics are really long\n-            result.push('<');\n+        result.push_str(&self.rewrite_generics(generics, indent));\n \n-            let lt_strs = lifetimes.iter().map(|l| self.rewrite_lifetime_def(l));\n-            let ty_strs = tys.iter().map(|ty| self.rewrite_ty_param(ty));\n-            let generics_strs: Vec<_> = lt_strs.chain(ty_strs).map(|s| (s, String::new())).collect();\n-            let fmt = ListFormatting {\n-                tactic: ListTactic::HorizontalVertical,\n-                separator: \",\",\n-                trailing_separator: SeparatorTactic::Never,\n-                indent: indent + result.len() + 1,\n-                h_width: budget,\n-                v_width: budget,\n-            };\n-            result.push_str(&write_list(&generics_strs, &fmt));\n+        let ret_str = self.rewrite_return(&fd.output);\n \n-            result.push('>');\n+        // Args.\n+        let (one_line_budget, multi_line_budget, arg_indent) =\n+            self.compute_budgets_for_args(&mut result, indent, ret_str.len(), newline_brace);\n+\n+        result.push('(');\n+        result.push_str(&self.rewrite_args(&fd.inputs,\n+                                           explicit_self,\n+                                           one_line_budget,\n+                                           multi_line_budget,\n+                                           arg_indent,\n+                                           span_for_return(&fd.output)));\n+        result.push(')');\n+\n+        // Where clause.\n+        result.push_str(&self.rewrite_where_clause(where_clause, indent));\n+\n+        // Return type.\n+        if ret_str.len() > 0 {\n+            // If we've already gone multi-line, or the return type would push\n+            // over the max width, then put the return type on a new line.\n+            if result.contains(\"\\n\") ||\n+               result.len() + indent + ret_str.len() > MAX_WIDTH {\n+                let indent = match FN_RETURN_INDENT {\n+                    ReturnIndent::WithWhereClause => indent + 4,\n+                    // TODO we might want to check that using the arg indent doesn't\n+                    // blow our budget, and if it does, then fallback to the where\n+                    // clause indent.\n+                    ReturnIndent::WithArgs => arg_indent,\n+                };\n+\n+                result.push('\\n');\n+                result.push_str(&make_indent(indent));\n+            } else {\n+                result.push(' ');\n+            }\n+            result.push_str(&ret_str);\n         }\n \n-        let ret_str = self.rewrite_return(&fd.output);\n+        // Prepare for the function body by possibly adding a newline and indent.\n+        // FIXME we'll miss anything between the end of the signature and the start\n+        // of the body, but we need more spans from the compiler to solve this.\n+        if newline_brace {\n+            result.push('\\n');\n+            result.push_str(&make_indent(self.block_indent));\n+        } else {\n+            result.push(' ');\n+        }\n \n-        // Args.\n-        let args = &fd.inputs;\n+        result\n+    }\n+\n+    fn rewrite_args(&self,\n+                    args: &[ast::Arg],\n+                    explicit_self: Option<&ast::ExplicitSelf>,\n+                    one_line_budget: usize,\n+                    multi_line_budget: usize,\n+                    arg_indent: usize,\n+                    ret_span: Span)\n+        -> String\n+    {\n+        let mut arg_item_strs: Vec<_> = args.iter().map(|a| self.rewrite_fn_input(a)).collect();\n+        // Account for sugary self.\n+        let mut min_args = 1;\n+        if let Some(explicit_self) = explicit_self {\n+            match explicit_self.node {\n+                ast::ExplicitSelf_::SelfRegion(ref lt, ref m, _) => {\n+                    let lt_str = match lt {\n+                        &Some(ref l) => format!(\"{} \", pprust::lifetime_to_string(l)),\n+                        &None => String::new(),\n+                    };\n+                    let mut_str = match m {\n+                        &ast::Mutability::MutMutable => \"mut \".to_string(),\n+                        &ast::Mutability::MutImmutable => String::new(),\n+                    };\n+                    arg_item_strs[0] = format!(\"&{}{}self\", lt_str, mut_str);\n+                    min_args = 2;\n+                }\n+                ast::ExplicitSelf_::SelfExplicit(ref ty, _) => {\n+                    arg_item_strs[0] = format!(\"self: {}\", pprust::ty_to_string(ty));\n+                }\n+                ast::ExplicitSelf_::SelfValue(_) => {\n+                    arg_item_strs[0] = \"self\".to_string();\n+                    min_args = 2;\n+                }\n+                _ => {}\n+            }\n+        }\n+\n+        // Comments between args\n+        let mut arg_comments = Vec::new();\n+        if min_args == 2 {\n+            arg_comments.push(\"\".to_string());\n+        }\n+        // TODO if there are no args, there might still be a comment, but without\n+        // spans for the comment or parens, there is no chance of getting it right.\n+        // You also don't get to put a comment on self, unless it is explicit.\n+        if args.len() >= min_args {\n+            let mut prev_end = args[min_args-1].ty.span.hi;\n+            for arg in &args[min_args..] {\n+                let cur_start = arg.pat.span.lo;\n+                let snippet = self.snippet(codemap::mk_sp(prev_end, cur_start));\n+                let mut snippet = snippet.trim();\n+                if snippet.starts_with(\",\") {\n+                    snippet = snippet[1..].trim();\n+                } else if snippet.ends_with(\",\") {\n+                    snippet = snippet[..snippet.len()-1].trim();\n+                }\n+                arg_comments.push(snippet.to_string());\n+                prev_end = arg.ty.span.hi;\n+            }\n+            // Get the last commment.\n+            // FIXME If you thought the crap with the commas was ugly, just wait.\n+            // This is awful. We're going to look from the last arg span to the\n+            // start of the return type span, then we drop everything after the\n+            // first closing paren. Obviously, this will break if there is a \n+            // closing paren in the comment.\n+            // The fix is comments in the AST or a span for the closing paren.\n+            let snippet = self.snippet(codemap::mk_sp(prev_end, ret_span.lo));\n+            let snippet = snippet.trim();\n+            let snippet = &snippet[..snippet.find(\")\").unwrap()];\n+            let snippet = snippet.trim();\n+            arg_comments.push(snippet.to_string());\n+        }\n+\n+        debug!(\"comments: {:?}\", arg_comments);\n+\n+        assert_eq!(arg_item_strs.len(), arg_comments.len());\n+        let arg_strs: Vec<_> = arg_item_strs.into_iter().zip(arg_comments.into_iter()).collect();\n+\n+        let fmt = ListFormatting {\n+            tactic: ListTactic::HorizontalVertical,\n+            separator: \",\",\n+            trailing_separator: SeparatorTactic::Never,\n+            indent: arg_indent,\n+            h_width: one_line_budget,\n+            v_width: multi_line_budget,\n+        };\n+\n+        write_list(&arg_strs, &fmt)\n+    }\n \n+    fn compute_budgets_for_args(&self,\n+                                result: &mut String,\n+                                indent: usize,\n+                                ret_str_len: usize,\n+                                newline_brace: bool)\n+        -> (usize, usize, usize)\n+    {\n         let mut budgets = None;\n \n         // Try keeping everything on the same line\n         if !result.contains(\"\\n\") {\n             // 3 = `() `, space is before ret_string\n-            let mut used_space = indent + result.len() + 3 + ret_str.len();\n+            let mut used_space = indent + result.len() + 3 + ret_str_len;\n             if newline_brace {\n                 used_space += 2;\n             }\n@@ -126,82 +249,7 @@ impl<'a> FmtVisitor<'a> {\n             }\n         }\n \n-        let (one_line_budget, multi_line_budget, arg_indent) = budgets.unwrap();\n-        result.push('(');\n-\n-        let fmt = ListFormatting {\n-            tactic: ListTactic::HorizontalVertical,\n-            separator: \",\",\n-            trailing_separator: SeparatorTactic::Never,\n-            indent: arg_indent,\n-            h_width: one_line_budget,\n-            v_width: multi_line_budget,\n-        };\n-        // TODO dead spans\n-        let mut arg_strs: Vec<_> = args.iter().map(|a| (self.rewrite_fn_input(a), String::new())).collect();\n-        // Account for sugary self.\n-        if let Some(explicit_self) = explicit_self {\n-            match explicit_self.node {\n-                ast::ExplicitSelf_::SelfRegion(ref lt, ref m, _) => {\n-                    let lt_str = match lt {\n-                        &Some(ref l) => format!(\"{} \", pprust::lifetime_to_string(l)),\n-                        &None => String::new(),\n-                    };\n-                    let mut_str = match m {\n-                        &ast::Mutability::MutMutable => \"mut \".to_string(),\n-                        &ast::Mutability::MutImmutable => String::new(),\n-                    };\n-                    arg_strs[0].0 = format!(\"&{}{}self\", lt_str, mut_str);\n-                }\n-                ast::ExplicitSelf_::SelfExplicit(ref ty, _) => {\n-                    arg_strs[0].0 = format!(\"self: {}\", pprust::ty_to_string(ty));\n-                }\n-                ast::ExplicitSelf_::SelfValue(_) => {\n-                    arg_strs[0].0 = \"self\".to_string();\n-                }\n-                _ => {}\n-            }\n-        }\n-        result.push_str(&write_list(&arg_strs, &fmt));\n-\n-        result.push(')');\n-\n-        // Where clause.\n-        result.push_str(&self.rewrite_where_clause(where_clause, indent));\n-\n-        // Return type.\n-        if ret_str.len() > 0 {\n-            // If we've already gone multi-line, or the return type would push\n-            // over the max width, then put the return type on a new line.\n-            if result.contains(\"\\n\") ||\n-               result.len() + indent + ret_str.len() > MAX_WIDTH {\n-                let indent = match FN_RETURN_INDENT {\n-                    ReturnIndent::WithWhereClause => indent + 4,\n-                    // TODO we might want to check that using the arg indent doesn't\n-                    // blow our budget, and if it does, then fallback to the where\n-                    // clause indent.\n-                    ReturnIndent::WithArgs => arg_indent,\n-                };\n-\n-                result.push('\\n');\n-                result.push_str(&make_indent(indent));\n-            } else {\n-                result.push(' ');\n-            }\n-            result.push_str(&ret_str);\n-        }\n-\n-        // Prepare for the function body by possibly adding a newline and indent.\n-        // FIXME we'll miss anything between the end of the signature and the start\n-        // of the body, but we need more spans from the compiler to solve this.\n-        if newline_brace {\n-            result.push('\\n');\n-            result.push_str(&make_indent(self.block_indent));\n-        } else {\n-            result.push(' ');\n-        }\n-\n-        result\n+        budgets.unwrap()\n     }\n \n     fn newline_for_brace(&self, where_clause: &ast::WhereClause) -> bool {\n@@ -212,6 +260,36 @@ impl<'a> FmtVisitor<'a> {\n         }\n     }\n \n+    fn rewrite_generics(&self, generics: &ast::Generics, indent: usize) -> String {\n+        // FIXME convert bounds to where clauses where they get too big or if\n+        // there is a where clause at all.\n+        let mut result = String::new();\n+        let lifetimes: &[_] = &generics.lifetimes;\n+        let tys: &[_] = &generics.ty_params;\n+        if lifetimes.len() + tys.len() > 0 {\n+            let budget = MAX_WIDTH - indent - result.len() - 2;\n+            // TODO might need to insert a newline if the generics are really long\n+            result.push('<');\n+\n+            let lt_strs = lifetimes.iter().map(|l| self.rewrite_lifetime_def(l));\n+            let ty_strs = tys.iter().map(|ty| self.rewrite_ty_param(ty));\n+            let generics_strs: Vec<_> = lt_strs.chain(ty_strs).map(|s| (s, String::new())).collect();\n+            let fmt = ListFormatting {\n+                tactic: ListTactic::HorizontalVertical,\n+                separator: \",\",\n+                trailing_separator: SeparatorTactic::Never,\n+                indent: indent + result.len() + 1,\n+                h_width: budget,\n+                v_width: budget,\n+            };\n+            result.push_str(&write_list(&generics_strs, &fmt));\n+\n+            result.push('>');\n+        }\n+\n+        result\n+    }\n+\n     fn rewrite_where_clause(&self, where_clause: &ast::WhereClause, indent: usize) -> String {\n         let mut result = String::new();\n         if where_clause.predicates.len() == 0 {\n@@ -252,3 +330,11 @@ impl<'a> FmtVisitor<'a> {\n                 pprust::ty_to_string(&arg.ty))\n     }\n }\n+\n+fn span_for_return(ret: &ast::FunctionRetTy) -> Span {\n+    match *ret {\n+        ast::FunctionRetTy::NoReturn(ref span) |\n+        ast::FunctionRetTy::DefaultReturn(ref span) => span.clone(),\n+        ast::FunctionRetTy::Return(ref ty) => ty.span,\n+    }\n+}"}, {"sha": "7e64308eafc671602c5144ae5bd2ee0d67c60125", "filename": "src/imports.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/854b52dbedbfe4944309514e98a7aba4185c2c5c/src%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/854b52dbedbfe4944309514e98a7aba4185c2c5c/src%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fimports.rs?ref=854b52dbedbfe4944309514e98a7aba4185c2c5c", "patch": "@@ -18,6 +18,10 @@ use syntax::print::pprust;\n \n use IDEAL_WIDTH;\n \n+// TODO change import lists with one item to a single import\n+//      remove empty lists (if they're even possible)\n+// TODO (some day) remove unused imports, expand globs, compress many single imports into a list import\n+\n impl<'a> FmtVisitor<'a> {\n     // Basically just pretty prints a multi-item import.\n     pub fn rewrite_use_list(&mut self,"}, {"sha": "01bad45b6aff89532ebeefa88daad657fd765746", "filename": "src/lists.rs", "status": "modified", "additions": 42, "deletions": 17, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/854b52dbedbfe4944309514e98a7aba4185c2c5c/src%2Flists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/854b52dbedbfe4944309514e98a7aba4185c2c5c/src%2Flists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flists.rs?ref=854b52dbedbfe4944309514e98a7aba4185c2c5c", "patch": "@@ -41,30 +41,28 @@ pub struct ListFormatting<'a> {\n }\n \n // Format a list of strings into a string.\n-pub fn write_list<'b>(items:&[(String, String)], formatting: &ListFormatting<'b>) -> String {\n+// Precondition: all strings in items are trimmed.\n+pub fn write_list<'b>(items: &[(String, String)], formatting: &ListFormatting<'b>) -> String {\n     if items.len() == 0 {\n         return String::new();\n     }\n \n     let mut tactic = formatting.tactic;\n \n-    let h_width = formatting.h_width;\n-    let v_width = formatting.v_width;\n-    let sep_len = formatting.separator.len();\n-\n     // Conservatively overestimates because of the changing separator tactic.\n     let sep_count = if formatting.trailing_separator != SeparatorTactic::Never {\n         items.len()\n     } else {\n         items.len() - 1\n     };\n+    let sep_len = formatting.separator.len();\n+    let total_sep_len = (sep_len + 1) * sep_count;\n \n-    // TODO count dead space too.\n-    let total_width = items.iter().map(|&(ref s, _)| s.len()).fold(0, |a, l| a + l);\n+    let total_width = calculate_width(items);\n \n     // Check if we need to fallback from horizontal listing, if possible.\n     if tactic == ListTactic::HorizontalVertical { \n-        if (total_width + (sep_len + 1) * sep_count) > h_width {\n+        if total_width + total_sep_len > formatting.h_width {\n             tactic = ListTactic::Vertical;\n         } else {\n             tactic = ListTactic::Horizontal;\n@@ -73,24 +71,20 @@ pub fn write_list<'b>(items:&[(String, String)], formatting: &ListFormatting<'b>\n \n     // Now that we know how we will layout, we can decide for sure if there\n     // will be a trailing separator.\n-    let trailing_separator = match formatting.trailing_separator {\n-        SeparatorTactic::Always => true,\n-        SeparatorTactic::Vertical => tactic == ListTactic::Vertical,\n-        SeparatorTactic::Never => false,\n-    };\n+    let trailing_separator = needs_trailing_separator(formatting.trailing_separator, tactic);\n \n     // Create a buffer for the result.\n     // TODO could use a StringBuffer or rope for this\n     let alloc_width = if tactic == ListTactic::Horizontal {\n-        total_width + (sep_len + 1) * sep_count\n+        total_width + total_sep_len\n     } else {\n         total_width + items.len() * (formatting.indent + 1)\n     };\n     let mut result = String::with_capacity(alloc_width);\n \n     let mut line_len = 0;\n     let indent_str = &make_indent(formatting.indent);\n-    for (i, &(ref item, _)) in items.iter().enumerate() {\n+    for (i, &(ref item, ref comment)) in items.iter().enumerate() {\n         let first = i == 0;\n         let separate = i != items.len() - 1 || trailing_separator;\n \n@@ -108,7 +102,7 @@ pub fn write_list<'b>(items:&[(String, String)], formatting: &ListFormatting<'b>\n                     item_width += sep_len;\n                 }\n \n-                if line_len > 0 && line_len + item_width > v_width {\n+                if line_len > 0 && line_len + item_width > formatting.v_width {\n                     result.push('\\n');\n                     result.push_str(indent_str);\n                     line_len = 0;\n@@ -126,11 +120,42 @@ pub fn write_list<'b>(items:&[(String, String)], formatting: &ListFormatting<'b>\n \n         result.push_str(item);\n         \n+        if tactic != ListTactic::Vertical && comment.len() > 0 {\n+            result.push(' ');\n+            result.push_str(comment);\n+        }\n+\n         if separate {\n             result.push_str(formatting.separator);\n         }\n-        // TODO dead spans\n+\n+        if tactic == ListTactic::Vertical && comment.len() > 0 {\n+            result.push(' ');\n+            result.push_str(comment);\n+        }\n     }\n \n     result\n }\n+\n+fn needs_trailing_separator(separator_tactic: SeparatorTactic, list_tactic: ListTactic) -> bool {\n+    match separator_tactic {\n+        SeparatorTactic::Always => true,\n+        SeparatorTactic::Vertical => list_tactic == ListTactic::Vertical,\n+        SeparatorTactic::Never => false,\n+    }\n+}\n+\n+fn calculate_width(items:&[(String, String)]) -> usize {\n+    let missed_width = items.iter().map(|&(_, ref s)| {\n+        let text_len = s.trim().len();\n+        if text_len > 0 {\n+            // We'll put a space before any comment.\n+            text_len + 1\n+        } else {\n+            text_len\n+        }\n+    }).fold(0, |a, l| a + l);\n+    let item_width = items.iter().map(|&(ref s, _)| s.len()).fold(0, |a, l| a + l);\n+    missed_width + item_width\n+}"}, {"sha": "23fe92438c3014b87b19c81b331bcd3d37506c2d", "filename": "src/mod.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/854b52dbedbfe4944309514e98a7aba4185c2c5c/src%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/854b52dbedbfe4944309514e98a7aba4185c2c5c/src%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmod.rs?ref=854b52dbedbfe4944309514e98a7aba4185c2c5c", "patch": "@@ -21,10 +21,12 @@\n \n // TODO priorities\n // Fix fns and methods properly\n-//   dead spans\n+//   dead spans (comments) - in generics\n //\n // Smoke testing till we can use it\n //   no newline at the end of doc.rs\n+// fmt_skip annotations\n+// take config options from a file\n \n #[macro_use]\n extern crate log;\n@@ -107,7 +109,10 @@ fn fmt_ast<'a>(krate: &ast::Crate, codemap: &'a CodeMap) -> ChangeSet<'a> {\n     visitor.changes\n }\n \n-// Formatting done on a char by char basis.\n+// Formatting done on a char by char or line by line basis.\n+// TODO warn on TODOs and FIXMEs without an issue number\n+// TODO warn on bad license\n+// TODO other stuff for parity with make tidy\n fn fmt_lines(changes: &mut ChangeSet) {\n     // Iterate over the chars in the change set.\n     for (f, text) in changes.text() {\n@@ -124,7 +129,7 @@ fn fmt_lines(changes: &mut ChangeSet) {\n                 }\n                 // Check for any line width errors we couldn't correct.\n                 if line_len > MAX_WIDTH {\n-                    // FIXME store the error rather than reporting immediately.\n+                    // TODO store the error rather than reporting immediately.\n                     println!(\"Rustfmt couldn't fix (sorry). {}:{}: line longer than {} characters\",\n                              f, cur_line, MAX_WIDTH);\n                 }\n@@ -144,7 +149,7 @@ fn fmt_lines(changes: &mut ChangeSet) {\n         }\n \n         for &(l, _, _) in trims.iter() {\n-            // FIXME store the error rather than reporting immediately.\n+            // TODO store the error rather than reporting immediately.\n             println!(\"Rustfmt left trailing whitespace at {}:{} (sorry)\", f, l);\n         }\n     }"}]}