{"sha": "9783947c2adfcadba3c0e036548cf6fd3e12553a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk3ODM5NDdjMmFkZmNhZGJhM2MwZTAzNjU0OGNmNmZkM2UxMjU1M2E=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-01-13T13:10:37Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-01-28T00:56:46Z"}, "message": "rustc_typeck: move impl Trait checks out of RegionScope.", "tree": {"sha": "1f63beb28b7bc1b10a11ea0f8ad671e1343dbb1e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1f63beb28b7bc1b10a11ea0f8ad671e1343dbb1e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9783947c2adfcadba3c0e036548cf6fd3e12553a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9783947c2adfcadba3c0e036548cf6fd3e12553a", "html_url": "https://github.com/rust-lang/rust/commit/9783947c2adfcadba3c0e036548cf6fd3e12553a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9783947c2adfcadba3c0e036548cf6fd3e12553a/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ba1849daecf0ae8fee54cc32f378809a9531e5ed", "url": "https://api.github.com/repos/rust-lang/rust/commits/ba1849daecf0ae8fee54cc32f378809a9531e5ed", "html_url": "https://github.com/rust-lang/rust/commit/ba1849daecf0ae8fee54cc32f378809a9531e5ed"}], "stats": {"total": 208, "additions": 65, "deletions": 143}, "files": [{"sha": "90efe7cad3999cc0c5443a0fa0cc156c98142cfd", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 53, "deletions": 41, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/9783947c2adfcadba3c0e036548cf6fd3e12553a/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9783947c2adfcadba3c0e036548cf6fd3e12553a/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=9783947c2adfcadba3c0e036548cf6fd3e12553a", "patch": "@@ -62,7 +62,7 @@ use rustc::ty::wf::object_region_bounds;\n use rustc_back::slice;\n use require_c_abi_if_variadic;\n use rscope::{RegionScope, ObjectLifetimeDefaultRscope, ShiftedRscope};\n-use rscope::{AnonTypeScope, MaybeWithAnonTypes, ExplicitRscope};\n+use rscope::ExplicitRscope;\n use util::common::{ErrorReported, FN_OUTPUT_NAME};\n use util::nodemap::{NodeMap, FxHashSet};\n \n@@ -361,8 +361,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                     }\n                     hir::ParenthesizedParameters(ref data) => {\n                         assert_eq!(i, 0);\n-                        let (ty, assoc) =\n-                            self.convert_parenthesized_parameters(rscope, substs, data);\n+                        let (ty, assoc) = self.convert_parenthesized_parameters(substs, data);\n                         output_assoc_binding = Some(assoc);\n                         ty\n                     }\n@@ -416,7 +415,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 vec![output_assoc_binding.unwrap_or_else(|| {\n                     // This is an error condition, but we should\n                     // get the associated type binding anyway.\n-                    self.convert_parenthesized_parameters(rscope, substs, data).1\n+                    self.convert_parenthesized_parameters(substs, data).1\n                 })]\n             }\n         };\n@@ -428,20 +427,17 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n     }\n \n     fn convert_parenthesized_parameters(&self,\n-                                        rscope: &RegionScope,\n                                         region_substs: &[Kind<'tcx>],\n                                         data: &hir::ParenthesizedParameterData)\n                                         -> (Ty<'tcx>, ConvertedBinding<'tcx>)\n     {\n-        let anon_scope = rscope.anon_type_scope();\n-        let rscope = MaybeWithAnonTypes::new(ExplicitRscope, anon_scope);\n         let inputs = self.tcx().mk_type_list(data.inputs.iter().map(|a_t| {\n-            self.ast_ty_arg_to_ty(&rscope, None, region_substs, a_t)\n+            self.ast_ty_arg_to_ty(&ExplicitRscope, None, region_substs, a_t)\n         }));\n \n         let (output, output_span) = match data.output {\n             Some(ref output_ty) => {\n-                (self.ast_ty_to_ty(&rscope, output_ty), output_ty.span)\n+                (self.ast_ty_to_ty(&ExplicitRscope, output_ty), output_ty.span)\n             }\n             None => {\n                 (self.tcx().mk_nil(), data.span)\n@@ -1309,12 +1305,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             }\n             hir::TyBareFn(ref bf) => {\n                 require_c_abi_if_variadic(tcx, &bf.decl, bf.abi, ast_ty.span);\n-                let anon_scope = rscope.anon_type_scope();\n-                let bare_fn_ty = self.ty_of_method_or_bare_fn(bf.unsafety,\n-                                                              bf.abi,\n-                                                              &bf.decl,\n-                                                              anon_scope,\n-                                                              anon_scope);\n+                let bare_fn_ty = self.ty_of_fn(bf.unsafety, bf.abi, &bf.decl);\n \n                 // Find any late-bound regions declared in return type that do\n                 // not appear in the arguments. These are not wellformed.\n@@ -1361,16 +1352,54 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             hir::TyImplTrait(ref bounds) => {\n                 use collect::{compute_bounds, SizedByDefault};\n \n+                // Figure out if we can allow an `impl Trait` here, by walking up\n+                // to a `fn` or inherent `impl` method, going only through `Ty`\n+                // or `TraitRef` nodes (as nothing else should be in types) and\n+                // ensuring that we reach the `fn`/method signature's return type.\n+                let mut node_id = ast_ty.id;\n+                let fn_decl = loop {\n+                    let parent = tcx.hir.get_parent_node(node_id);\n+                    match tcx.hir.get(parent) {\n+                        hir::map::NodeItem(&hir::Item {\n+                            node: hir::ItemFn(ref fn_decl, ..), ..\n+                        }) => break Some(fn_decl),\n+\n+                        hir::map::NodeImplItem(&hir::ImplItem {\n+                            node: hir::ImplItemKind::Method(ref sig, _), ..\n+                        }) => {\n+                            match tcx.hir.expect_item(tcx.hir.get_parent(parent)).node {\n+                                hir::ItemImpl(.., None, _, _) => {\n+                                    break Some(&sig.decl)\n+                                }\n+                                _ => break None\n+                            }\n+                        }\n+\n+                        hir::map::NodeTy(_) | hir::map::NodeTraitRef(_) => {}\n+\n+                        _ => break None\n+                    }\n+                    node_id = parent;\n+                };\n+                let allow = fn_decl.map_or(false, |fd| {\n+                    match fd.output {\n+                        hir::DefaultReturn(_) => false,\n+                        hir::Return(ref ty) => ty.id == node_id\n+                    }\n+                });\n+\n                 // Create the anonymized type.\n-                let def_id = tcx.hir.local_def_id(ast_ty.id);\n-                if let Some(anon_scope) = rscope.anon_type_scope() {\n-                    let substs = anon_scope.fresh_substs(self, ast_ty.span);\n+                if allow {\n+                    let def_id = tcx.hir.local_def_id(ast_ty.id);\n+                    if let Err(ErrorReported) = self.get_generics(ast_ty.span, def_id) {\n+                        return tcx.types.err;\n+                    }\n+                    let substs = Substs::identity_for_item(tcx, def_id);\n                     let ty = tcx.mk_anon(tcx.hir.local_def_id(ast_ty.id), substs);\n \n                     // Collect the bounds, i.e. the `A+B+'c` in `impl A+B+'c`.\n                     let bounds = compute_bounds(self, ty, bounds,\n                                                 SizedByDefault::Yes,\n-                                                Some(anon_scope),\n                                                 ast_ty.span);\n                     let predicates = bounds.predicates(tcx, ty);\n                     let predicates = tcx.lift_to_global(&predicates).unwrap();\n@@ -1450,36 +1479,19 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n     pub fn ty_of_fn(&self,\n                     unsafety: hir::Unsafety,\n                     abi: abi::Abi,\n-                    decl: &hir::FnDecl,\n-                    anon_scope: Option<AnonTypeScope>)\n+                    decl: &hir::FnDecl)\n                     -> &'tcx ty::BareFnTy<'tcx> {\n-        self.ty_of_method_or_bare_fn(unsafety, abi, decl, None, anon_scope)\n-    }\n-\n-    fn ty_of_method_or_bare_fn(&self,\n-                               unsafety: hir::Unsafety,\n-                               abi: abi::Abi,\n-                               decl: &hir::FnDecl,\n-                               arg_anon_scope: Option<AnonTypeScope>,\n-                               ret_anon_scope: Option<AnonTypeScope>)\n-                               -> &'tcx ty::BareFnTy<'tcx>\n-    {\n-        debug!(\"ty_of_method_or_bare_fn\");\n-\n-        // New region names that appear inside of the arguments of the function\n-        // declaration are bound to that function type.\n-        let rb = MaybeWithAnonTypes::new(ExplicitRscope, arg_anon_scope);\n+        debug!(\"ty_of_fn\");\n \n         let input_tys: Vec<Ty> =\n-            decl.inputs.iter().map(|a| self.ty_of_arg(&rb, a, None)).collect();\n+            decl.inputs.iter().map(|a| self.ty_of_arg(&ExplicitRscope, a, None)).collect();\n \n         let output_ty = match decl.output {\n-            hir::Return(ref output) =>\n-                self.ast_ty_to_ty(&MaybeWithAnonTypes::new(ExplicitRscope, ret_anon_scope), output),\n+            hir::Return(ref output) => self.ast_ty_to_ty(&ExplicitRscope, output),\n             hir::DefaultReturn(..) => self.tcx().mk_nil(),\n         };\n \n-        debug!(\"ty_of_method_or_bare_fn: output_ty={:?}\", output_ty);\n+        debug!(\"ty_of_fn: output_ty={:?}\", output_ty);\n \n         self.tcx().mk_bare_fn(ty::BareFnTy {\n             unsafety: unsafety,"}, {"sha": "1bfa4fc7b682c111e75adea6eecfb906e7921ad3", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 10, "deletions": 22, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/9783947c2adfcadba3c0e036548cf6fd3e12553a/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9783947c2adfcadba3c0e036548cf6fd3e12553a/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=9783947c2adfcadba3c0e036548cf6fd3e12553a", "patch": "@@ -641,7 +641,6 @@ fn convert_field<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n }\n \n fn convert_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                            container: AssociatedItemContainer,\n                             id: ast::NodeId,\n                             sig: &hir::MethodSig,\n                             rcvr_ty_predicates: &ty::GenericPredicates<'tcx>,) {\n@@ -651,12 +650,8 @@ fn convert_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     let ty_generic_predicates =\n         ty_generic_predicates(ccx, &sig.generics, ty_generics.parent, vec![], false);\n \n-    let anon_scope = match container {\n-        ImplContainer(_) => Some(AnonTypeScope::new(def_id)),\n-        TraitContainer(_) => None\n-    };\n     let fty = AstConv::ty_of_fn(&ccx.icx(&(rcvr_ty_predicates, &sig.generics)),\n-                                sig.unsafety, sig.abi, &sig.decl, anon_scope);\n+                                sig.unsafety, sig.abi, &sig.decl);\n \n     let substs = mk_item_substs(&ccx.icx(&(rcvr_ty_predicates, &sig.generics)),\n                                 ccx.tcx.hir.span(id), def_id);\n@@ -874,8 +869,7 @@ fn convert_trait_item(ccx: &CrateCtxt, trait_item: &hir::TraitItem) {\n         }\n \n         hir::TraitItemKind::Method(ref sig, _) => {\n-            convert_method(ccx, TraitContainer(trait_def_id),\n-                           trait_item.id, sig, &trait_predicates);\n+            convert_method(ccx, trait_item.id, sig, &trait_predicates);\n         }\n     }\n }\n@@ -915,7 +909,7 @@ fn convert_impl_item(ccx: &CrateCtxt, impl_item: &hir::ImplItem) {\n         }\n \n         hir::ImplItemKind::Method(ref sig, _) => {\n-            convert_method(ccx, ImplContainer(impl_def_id), impl_item.id, sig, &impl_predicates);\n+            convert_method(ccx, impl_item.id, sig, &impl_predicates);\n         }\n     }\n }\n@@ -1186,7 +1180,6 @@ fn ensure_super_predicates_step(ccx: &CrateCtxt,\n                                           self_param_ty,\n                                           bounds,\n                                           SizedByDefault::No,\n-                                          None,\n                                           item.span);\n \n         let superbounds1 = superbounds1.predicates(tcx, self_param_ty);\n@@ -1323,7 +1316,6 @@ fn convert_trait_predicates<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &hir::Item)\n                                         assoc_ty,\n                                         bounds,\n                                         SizedByDefault::Yes,\n-                                        None,\n                                         trait_item.span);\n \n             bounds.predicates(ccx.tcx, assoc_ty).into_iter()\n@@ -1537,8 +1529,7 @@ fn type_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                         ccx.icx(&()).to_ty(&ExplicitRscope, &t)\n                     }\n                     ItemFn(ref decl, unsafety, _, abi, ref generics, _) => {\n-                        let tofd = AstConv::ty_of_fn(&ccx.icx(generics), unsafety, abi, &decl,\n-                                                     Some(AnonTypeScope::new(def_id)));\n+                        let tofd = AstConv::ty_of_fn(&ccx.icx(generics), unsafety, abi, &decl);\n                         let substs = mk_item_substs(&ccx.icx(generics), item.span, def_id);\n                         ccx.tcx.mk_fn_def(def_id, substs, tofd)\n                     }\n@@ -1770,7 +1761,6 @@ fn ty_generic_predicates<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                                     param_ty,\n                                     &param.bounds,\n                                     SizedByDefault::Yes,\n-                                    None,\n                                     param.span);\n         predicates.extend(bounds.predicates(ccx.tcx, param_ty));\n     }\n@@ -1968,7 +1958,6 @@ pub fn compute_bounds<'gcx: 'tcx, 'tcx>(astconv: &AstConv<'gcx, 'tcx>,\n                                         param_ty: ty::Ty<'tcx>,\n                                         ast_bounds: &[hir::TyParamBound],\n                                         sized_by_default: SizedByDefault,\n-                                        anon_scope: Option<AnonTypeScope>,\n                                         span: Span)\n                                         -> Bounds<'tcx>\n {\n@@ -1979,9 +1968,8 @@ pub fn compute_bounds<'gcx: 'tcx, 'tcx>(astconv: &AstConv<'gcx, 'tcx>,\n \n     let mut projection_bounds = vec![];\n \n-    let rscope = MaybeWithAnonTypes::new(ExplicitRscope, anon_scope);\n     let mut trait_bounds: Vec<_> = trait_bounds.iter().map(|&bound| {\n-        astconv.instantiate_poly_trait_ref(&rscope,\n+        astconv.instantiate_poly_trait_ref(&ExplicitRscope,\n                                            bound,\n                                            param_ty,\n                                            &mut projection_bounds)\n@@ -2048,7 +2036,7 @@ fn compute_type_of_foreign_fn_decl<'a, 'tcx>(\n     abi: abi::Abi)\n     -> Ty<'tcx>\n {\n-    let fty = AstConv::ty_of_fn(&ccx.icx(ast_generics), hir::Unsafety::Unsafe, abi, decl, None);\n+    let fty = AstConv::ty_of_fn(&ccx.icx(ast_generics), hir::Unsafety::Unsafe, abi, decl);\n \n     // feature gate SIMD types in FFI, since I (huonw) am not sure the\n     // ABIs are handled at all correctly.\n@@ -2077,10 +2065,10 @@ fn compute_type_of_foreign_fn_decl<'a, 'tcx>(\n     ccx.tcx.mk_fn_def(def_id, substs, fty)\n }\n \n-pub fn mk_item_substs<'gcx: 'tcx, 'tcx>(astconv: &AstConv<'gcx, 'tcx>,\n-                                        span: Span,\n-                                        def_id: DefId)\n-                                        -> &'tcx Substs<'tcx> {\n+fn mk_item_substs<'tcx>(astconv: &AstConv<'tcx, 'tcx>,\n+                        span: Span,\n+                        def_id: DefId)\n+                        -> &'tcx Substs<'tcx> {\n     let tcx = astconv.tcx();\n     // FIXME(eddyb) Do this request from Substs::for_item in librustc.\n     if let Err(ErrorReported) = astconv.get_generics(span, def_id) {"}, {"sha": "90ce77cc5f4bc5a542896d7c6e48180f6b91e781", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9783947c2adfcadba3c0e036548cf6fd3e12553a/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9783947c2adfcadba3c0e036548cf6fd3e12553a/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=9783947c2adfcadba3c0e036548cf6fd3e12553a", "patch": "@@ -77,6 +77,7 @@ This API is completely unstable and subject to change.\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n #![feature(conservative_impl_trait)]\n+#![feature(loop_break_value)]\n #![feature(quote)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]"}, {"sha": "d982c91e388d18ade4cbd92288f49cb80457d942", "filename": "src/librustc_typeck/rscope.rs", "status": "modified", "additions": 0, "deletions": 79, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/9783947c2adfcadba3c0e036548cf6fd3e12553a/src%2Flibrustc_typeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9783947c2adfcadba3c0e036548cf6fd3e12553a/src%2Flibrustc_typeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Frscope.rs?ref=9783947c2adfcadba3c0e036548cf6fd3e12553a", "patch": "@@ -8,11 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use rustc::hir::def_id::DefId;\n use rustc::ty;\n-use rustc::ty::subst::Substs;\n-\n-use astconv::AstConv;\n \n use syntax_pos::Span;\n \n@@ -38,73 +34,6 @@ pub trait RegionScope {\n     /// computing `object_lifetime_default` (in particular, in legacy\n     /// modes, it may not be relevant).\n     fn base_object_lifetime_default(&self, span: Span) -> ty::Region;\n-\n-    /// If this scope allows anonymized types, return the generics in\n-    /// scope, that anonymized types will close over. For example,\n-    /// if you have a function like:\n-    ///\n-    ///     fn foo<'a, T>() -> impl Trait { ... }\n-    ///\n-    /// then, for the rscope that is used when handling the return type,\n-    /// `anon_type_scope()` would return a `Some(AnonTypeScope {...})`,\n-    /// on which `.fresh_substs(...)` can be used to obtain identity\n-    /// Substs for `'a` and `T`, to track them in `TyAnon`. This property\n-    /// is controlled by the region scope because it's fine-grained enough\n-    /// to allow restriction of anonymized types to the syntactical extent\n-    /// of a function's return type.\n-    fn anon_type_scope(&self) -> Option<AnonTypeScope> {\n-        None\n-    }\n-}\n-\n-#[derive(Copy, Clone)]\n-pub struct AnonTypeScope {\n-    enclosing_item: DefId\n-}\n-\n-impl<'gcx: 'tcx, 'tcx> AnonTypeScope {\n-    pub fn new(enclosing_item: DefId) -> AnonTypeScope {\n-        AnonTypeScope {\n-            enclosing_item: enclosing_item\n-        }\n-    }\n-\n-    pub fn fresh_substs(&self, astconv: &AstConv<'gcx, 'tcx>, span: Span)\n-                        -> &'tcx Substs<'tcx> {\n-        use collect::mk_item_substs;\n-\n-        mk_item_substs(astconv, span, self.enclosing_item)\n-    }\n-}\n-\n-/// A scope wrapper which optionally allows anonymized types.\n-#[derive(Copy, Clone)]\n-pub struct MaybeWithAnonTypes<R> {\n-    base_scope: R,\n-    anon_scope: Option<AnonTypeScope>\n-}\n-\n-impl<R: RegionScope> MaybeWithAnonTypes<R>  {\n-    pub fn new(base_scope: R, anon_scope: Option<AnonTypeScope>) -> Self {\n-        MaybeWithAnonTypes {\n-            base_scope: base_scope,\n-            anon_scope: anon_scope\n-        }\n-    }\n-}\n-\n-impl<R: RegionScope> RegionScope for MaybeWithAnonTypes<R> {\n-    fn object_lifetime_default(&self, span: Span) -> Option<ty::Region> {\n-        self.base_scope.object_lifetime_default(span)\n-    }\n-\n-    fn base_object_lifetime_default(&self, span: Span) -> ty::Region {\n-        self.base_scope.base_object_lifetime_default(span)\n-    }\n-\n-    fn anon_type_scope(&self) -> Option<AnonTypeScope> {\n-        self.anon_scope\n-    }\n }\n \n // A scope in which all regions must be explicitly named. This is used\n@@ -158,10 +87,6 @@ impl<'r> RegionScope for ObjectLifetimeDefaultRscope<'r> {\n     fn base_object_lifetime_default(&self, span: Span) -> ty::Region {\n         self.base_scope.base_object_lifetime_default(span)\n     }\n-\n-    fn anon_type_scope(&self) -> Option<AnonTypeScope> {\n-        self.base_scope.anon_type_scope()\n-    }\n }\n \n /// A scope which simply shifts the Debruijn index of other scopes\n@@ -185,8 +110,4 @@ impl<'r> RegionScope for ShiftedRscope<'r> {\n     fn base_object_lifetime_default(&self, span: Span) -> ty::Region {\n         ty::fold::shift_region(self.base_scope.base_object_lifetime_default(span), 1)\n     }\n-\n-    fn anon_type_scope(&self) -> Option<AnonTypeScope> {\n-        self.base_scope.anon_type_scope()\n-    }\n }"}, {"sha": "0467c49b0311def45249af4a813e3eb2a18493f1", "filename": "src/test/compile-fail/impl-trait/disallowed.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9783947c2adfcadba3c0e036548cf6fd3e12553a/src%2Ftest%2Fcompile-fail%2Fimpl-trait%2Fdisallowed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9783947c2adfcadba3c0e036548cf6fd3e12553a/src%2Ftest%2Fcompile-fail%2Fimpl-trait%2Fdisallowed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimpl-trait%2Fdisallowed.rs?ref=9783947c2adfcadba3c0e036548cf6fd3e12553a", "patch": "@@ -26,9 +26,9 @@ trait LazyToString {\n     //~^ ERROR `impl Trait` not allowed outside of function and inherent method return types\n }\n \n-// Note that the following impl doesn't error, because the trait is invalid.\n impl LazyToString for String {\n     fn lazy_to_string<'a>(&'a self) -> impl Fn() -> String {\n+    //~^ ERROR `impl Trait` not allowed outside of function and inherent method return types\n         || self.clone()\n     }\n }"}]}