{"sha": "683bcc02955f988ab2726f1b7708baa6c1e64b7b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY4M2JjYzAyOTU1Zjk4OGFiMjcyNmYxYjc3MDhiYWE2YzFlNjRiN2I=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2016-05-03T01:01:54Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2016-08-18T04:51:56Z"}, "message": "Use a Carrier trait with the `?` operator\n\nAllows use with `Option` and custom `Result`-like types.", "tree": {"sha": "3f1fed8e080478012a770431b01f240f494244c0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3f1fed8e080478012a770431b01f240f494244c0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/683bcc02955f988ab2726f1b7708baa6c1e64b7b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/683bcc02955f988ab2726f1b7708baa6c1e64b7b", "html_url": "https://github.com/rust-lang/rust/commit/683bcc02955f988ab2726f1b7708baa6c1e64b7b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/683bcc02955f988ab2726f1b7708baa6c1e64b7b/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aef6971ca96be5f04291420cc773b8bfacb8b36d", "url": "https://api.github.com/repos/rust-lang/rust/commits/aef6971ca96be5f04291420cc773b8bfacb8b36d", "html_url": "https://github.com/rust-lang/rust/commit/aef6971ca96be5f04291420cc773b8bfacb8b36d"}], "stats": {"total": 345, "additions": 296, "deletions": 49}, "files": [{"sha": "a869b3c4f98c5c39301a098406a75263560011e8", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 125, "deletions": 0, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/683bcc02955f988ab2726f1b7708baa6c1e64b7b/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/683bcc02955f988ab2726f1b7708baa6c1e64b7b/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=683bcc02955f988ab2726f1b7708baa6c1e64b7b", "patch": "@@ -75,6 +75,8 @@\n use cmp::PartialOrd;\n use fmt;\n use marker::{Sized, Unsize};\n+use result::Result::{self, Ok, Err};\n+use option::Option::{self, Some, None};\n \n /// The `Drop` trait is used to run some code when a value goes out of scope.\n /// This is sometimes called a 'destructor'.\n@@ -2150,3 +2152,126 @@ pub trait BoxPlace<Data: ?Sized> : Place<Data> {\n     /// Creates a globally fresh place.\n     fn make_place() -> Self;\n }\n+\n+/// A trait for types which have success and error states and are meant to work\n+/// with the question mark operator.\n+/// When the `?` operator is used with a value, whether the value is in the\n+/// success or error state is determined by calling `translate`.\n+///\n+/// This trait is **very** experimental, it will probably be iterated on heavily\n+/// before it is stabilised. Implementors should expect change. Users of `?`\n+/// should not rely on any implementations of `Carrier` other than `Result`,\n+/// i.e., you should not expect `?` to continue to work with `Option`, etc.\n+#[unstable(feature = \"question_mark_carrier\", issue = \"31436\")]\n+pub trait Carrier {\n+    /// The type of the value when computation succeeds.\n+    type Success;\n+    /// The type of the value when computation errors out.\n+    type Error;\n+\n+    /// Create a `Carrier` from a success value.\n+    fn from_success(Self::Success) -> Self;\n+\n+    /// Create a `Carrier` from an error value.\n+    fn from_error(Self::Error) -> Self;\n+\n+    /// Translate this `Carrier` to another implementation of `Carrier` with the\n+    /// same associated types.\n+    fn translate<T>(self) -> T where T: Carrier<Success=Self::Success, Error=Self::Error>;\n+}\n+\n+#[unstable(feature = \"question_mark_carrier\", issue = \"31436\")]\n+impl<U, V> Carrier for Result<U, V> {\n+    type Success = U;\n+    type Error = V;\n+\n+    fn from_success(u: U) -> Result<U, V> {\n+        Ok(u)\n+    }\n+\n+    fn from_error(e: V) -> Result<U, V> {\n+        Err(e)\n+    }\n+\n+    fn translate<T>(self) -> T\n+        where T: Carrier<Success=U, Error=V>\n+    {\n+        match self {\n+            Ok(u) => T::from_success(u),\n+            Err(e) => T::from_error(e),\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"question_mark_carrier\", issue = \"31436\")]\n+impl<U> Carrier for Option<U> {\n+    type Success = U;\n+    type Error = ();\n+\n+    fn from_success(u: U) -> Option<U> {\n+        Some(u)\n+    }\n+\n+    fn from_error(_: ()) -> Option<U> {\n+        None\n+    }\n+\n+    fn translate<T>(self) -> T\n+        where T: Carrier<Success=U, Error=()>\n+    {\n+        match self {\n+            Some(u) => T::from_success(u),\n+            None => T::from_error(()),\n+        }\n+    }\n+}\n+\n+// Implementing Carrier for bools means it's easy to write short-circuiting\n+// functions. E.g.,\n+// ```\n+// fn foo() -> bool {\n+//     if !(f() || g()) {\n+//         return false;\n+//     }\n+//\n+//     some_computation();\n+//     if h() {\n+//         return false;\n+//     }\n+//\n+//     more_computation();\n+//     i()\n+// }\n+// ```\n+// becomes\n+// ```\n+// fn foo() -> bool {\n+//     (f() || g())?;\n+//     some_computation();\n+//     (!h())?;\n+//     more_computation();\n+//     i()\n+// }\n+// ```\n+#[unstable(feature = \"question_mark_carrier\", issue = \"31436\")]\n+impl Carrier for bool {\n+    type Success = ();\n+    type Error = ();\n+\n+    fn from_success(_: ()) -> bool {\n+        true\n+    }\n+\n+    fn from_error(_: ()) -> bool {\n+        false\n+    }\n+\n+    fn translate<T>(self) -> T\n+        where T: Carrier<Success=(), Error=()>\n+    {\n+        match self {\n+            true => T::from_success(()),\n+            false => T::from_error(()),\n+        }\n+    }\n+}"}, {"sha": "b45610c3fe820150bccc4f68a437991fc7887d7f", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 81, "deletions": 49, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/683bcc02955f988ab2726f1b7708baa6c1e64b7b/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/683bcc02955f988ab2726f1b7708baa6c1e64b7b/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=683bcc02955f988ab2726f1b7708baa6c1e64b7b", "patch": "@@ -966,7 +966,7 @@ impl<'a> LoweringContext<'a> {\n                     let inplace_finalize = [\"ops\", \"InPlace\", \"finalize\"];\n \n                     let make_call = |this: &mut LoweringContext, p, args| {\n-                        let path = this.core_path(e.span, p);\n+                        let path = this.std_path(e.span, p);\n                         let path = this.expr_path(path, ThinVec::new());\n                         this.expr_call(e.span, path, args)\n                     };\n@@ -1159,15 +1159,13 @@ impl<'a> LoweringContext<'a> {\n                                    ast_expr: &Expr,\n                                    path: &[&str],\n                                    fields: &[(&str, &P<Expr>)]) -> P<hir::Expr> {\n-                        let strs = this.std_path(&iter::once(&\"ops\")\n-                                                        .chain(path)\n-                                                        .map(|s| *s)\n-                                                        .collect::<Vec<_>>());\n-\n-                        let structpath = this.path_global(ast_expr.span, strs);\n+                        let struct_path = this.std_path(ast_expr.span,\n+                                                        &iter::once(&\"ops\").chain(path)\n+                                                                           .map(|s| *s)\n+                                                                           .collect::<Vec<_>>());\n \n                         let hir_expr = if fields.len() == 0 {\n-                            this.expr_path(structpath, ast_expr.attrs.clone())\n+                            this.expr_path(struct_path, ast_expr.attrs.clone())\n                         } else {\n                             let fields = fields.into_iter().map(|&(s, e)| {\n                                 let expr = this.lower_expr(&e);\n@@ -1180,7 +1178,7 @@ impl<'a> LoweringContext<'a> {\n                             }).collect();\n                             let attrs = ast_expr.attrs.clone();\n \n-                            this.expr_struct(ast_expr.span, structpath, fields, None, attrs)\n+                            this.expr_struct(ast_expr.span, struct_path, fields, None, attrs)\n                         };\n \n                         this.signal_block_expr(hir_vec![],\n@@ -1463,11 +1461,7 @@ impl<'a> LoweringContext<'a> {\n \n                     // `match ::std::iter::Iterator::next(&mut iter) { ... }`\n                     let match_expr = {\n-                        let next_path = {\n-                            let strs = self.std_path(&[\"iter\", \"Iterator\", \"next\"]);\n-\n-                            self.path_global(e.span, strs)\n-                        };\n+                        let next_path = self.std_path(e.span, &[\"iter\", \"Iterator\", \"next\"]);\n                         let iter = self.expr_ident(e.span, iter, iter_pat.id);\n                         let ref_mut_iter = self.expr_mut_addr_of(e.span, iter);\n                         let next_path = self.expr_path(next_path, ThinVec::new());\n@@ -1494,11 +1488,8 @@ impl<'a> LoweringContext<'a> {\n \n                     // `match ::std::iter::IntoIterator::into_iter(<head>) { ... }`\n                     let into_iter_expr = {\n-                        let into_iter_path = {\n-                            let strs = self.std_path(&[\"iter\", \"IntoIterator\", \"into_iter\"]);\n-\n-                            self.path_global(e.span, strs)\n-                        };\n+                        let into_iter_path = self.std_path(e.span,\n+                                                           &[\"iter\", \"IntoIterator\", \"into_iter\"]);\n \n                         let into_iter = self.expr_path(into_iter_path, ThinVec::new());\n                         self.expr_call(e.span, into_iter, hir_vec![head])\n@@ -1527,16 +1518,32 @@ impl<'a> LoweringContext<'a> {\n                     // to:\n                     //\n                     // {\n-                    //     match <expr> {\n+                    //     match { Carrier::translate( { <expr> } ) } {\n                     //         Ok(val) => val,\n-                    //         Err(err) => {\n-                    //             return Err(From::from(err))\n-                    //         }\n+                    //         Err(err) => { return Carrier::from_error(From::from(err)); }\n                     //     }\n                     // }\n \n-                    // expand <expr>\n-                    let sub_expr = self.lower_expr(sub_expr);\n+                    // { Carrier::translate( { <expr> } ) }\n+                    let discr = {\n+                        // expand <expr>\n+                        let sub_expr = self.lower_expr(sub_expr);\n+                        let sub_expr = self.signal_block_expr(hir_vec![],\n+                                                              sub_expr,\n+                                                              e.span,\n+                                                              hir::PopUnstableBlock,\n+                                                              ThinVec::new());\n+\n+                        let path = self.std_path(e.span, &[\"ops\", \"Carrier\", \"translate\"]);\n+                        let path = self.expr_path(path, ThinVec::new());\n+                        let call = self.expr_call(e.span, path, hir_vec![sub_expr]);\n+\n+                        self.signal_block_expr(hir_vec![],\n+                                               call,\n+                                               e.span,\n+                                               hir::PushUnstableBlock,\n+                                               ThinVec::new())\n+                    };\n \n                     // Ok(val) => val\n                     let ok_arm = {\n@@ -1548,32 +1555,35 @@ impl<'a> LoweringContext<'a> {\n                         self.arm(hir_vec![ok_pat], val_expr)\n                     };\n \n-                    // Err(err) => return Err(From::from(err))\n+                    // Err(err) => { return Carrier::from_error(From::from(err)); }\n                     let err_arm = {\n                         let err_ident = self.str_to_ident(\"err\");\n                         let err_local = self.pat_ident(e.span, err_ident);\n                         let from_expr = {\n-                            let path = self.std_path(&[\"convert\", \"From\", \"from\"]);\n-                            let path = self.path_global(e.span, path);\n+                            let path = self.std_path(e.span, &[\"convert\", \"From\", \"from\"]);\n                             let from = self.expr_path(path, ThinVec::new());\n                             let err_expr = self.expr_ident(e.span, err_ident, err_local.id);\n \n                             self.expr_call(e.span, from, hir_vec![err_expr])\n                         };\n-                        let err_expr = {\n-                            let path = self.std_path(&[\"result\", \"Result\", \"Err\"]);\n-                            let path = self.path_global(e.span, path);\n-                            let err_ctor = self.expr_path(path, ThinVec::new());\n-                            self.expr_call(e.span, err_ctor, hir_vec![from_expr])\n+                        let from_err_expr = {\n+                            let path = self.std_path(e.span, &[\"ops\", \"Carrier\", \"from_error\"]);\n+                            let from_err = self.expr_path(path, ThinVec::new());\n+                            self.expr_call(e.span, from_err, hir_vec![from_expr])\n                         };\n-                        let err_pat = self.pat_err(e.span, err_local);\n+\n                         let ret_expr = self.expr(e.span,\n-                                                 hir::Expr_::ExprRet(Some(err_expr)),\n-                                                 ThinVec::new());\n-                        self.arm(hir_vec![err_pat], ret_expr)\n+                                                 hir::Expr_::ExprRet(Some(from_err_expr)),\n+                                                                     ThinVec::new());\n+                        let ret_stmt = self.stmt_expr(ret_expr);\n+                        let block = self.signal_block_stmt(ret_stmt, e.span,\n+                                                           hir::PushUnstableBlock, ThinVec::new());\n+\n+                        let err_pat = self.pat_err(e.span, err_local);\n+                        self.arm(hir_vec![err_pat], block)\n                     };\n \n-                    return self.expr_match(e.span, sub_expr, hir_vec![err_arm, ok_arm],\n+                    return self.expr_match(e.span, discr, hir_vec![err_arm, ok_arm],\n                                            hir::MatchSource::TryDesugar);\n                 }\n \n@@ -1787,6 +1797,15 @@ impl<'a> LoweringContext<'a> {\n         (respan(sp, hir::StmtDecl(P(decl), self.next_id())), pat_id)\n     }\n \n+    // Turns `<expr>` into `<expr>;`, note that this produces a StmtSemi, not a\n+    // StmtExpr.\n+    fn stmt_expr(&self, expr: P<hir::Expr>) -> hir::Stmt {\n+        hir::Stmt {\n+            span: expr.span,\n+            node: hir::StmtSemi(expr, self.next_id()),\n+        }\n+    }\n+\n     fn block_expr(&mut self, expr: P<hir::Expr>) -> P<hir::Block> {\n         self.block_all(expr.span, hir::HirVec::new(), Some(expr))\n     }\n@@ -1803,26 +1822,22 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn pat_ok(&mut self, span: Span, pat: P<hir::Pat>) -> P<hir::Pat> {\n-        let ok = self.std_path(&[\"result\", \"Result\", \"Ok\"]);\n-        let path = self.path_global(span, ok);\n+        let path = self.std_path(span, &[\"result\", \"Result\", \"Ok\"]);\n         self.pat_enum(span, path, hir_vec![pat])\n     }\n \n     fn pat_err(&mut self, span: Span, pat: P<hir::Pat>) -> P<hir::Pat> {\n-        let err = self.std_path(&[\"result\", \"Result\", \"Err\"]);\n-        let path = self.path_global(span, err);\n+        let path = self.std_path(span, &[\"result\", \"Result\", \"Err\"]);\n         self.pat_enum(span, path, hir_vec![pat])\n     }\n \n     fn pat_some(&mut self, span: Span, pat: P<hir::Pat>) -> P<hir::Pat> {\n-        let some = self.std_path(&[\"option\", \"Option\", \"Some\"]);\n-        let path = self.path_global(span, some);\n+        let path = self.std_path(span, &[\"option\", \"Option\", \"Some\"]);\n         self.pat_enum(span, path, hir_vec![pat])\n     }\n \n     fn pat_none(&mut self, span: Span) -> P<hir::Pat> {\n-        let none = self.std_path(&[\"option\", \"Option\", \"None\"]);\n-        let path = self.path_global(span, none);\n+        let path = self.std_path(span, &[\"option\", \"Option\", \"None\"]);\n         self.pat_enum(span, path, hir_vec![])\n     }\n \n@@ -1920,7 +1935,7 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n-    fn std_path(&mut self, components: &[&str]) -> Vec<Name> {\n+    fn std_path_components(&mut self, components: &[&str]) -> Vec<Name> {\n         let mut v = Vec::new();\n         if let Some(s) = self.crate_root {\n             v.push(token::intern(s));\n@@ -1931,8 +1946,8 @@ impl<'a> LoweringContext<'a> {\n \n     // Given suffix [\"b\",\"c\",\"d\"], returns path `::std::b::c::d` when\n     // `fld.cx.use_std`, and `::core::b::c::d` otherwise.\n-    fn core_path(&mut self, span: Span, components: &[&str]) -> hir::Path {\n-        let idents = self.std_path(components);\n+    fn std_path(&mut self, span: Span, components: &[&str]) -> hir::Path {\n+        let idents = self.std_path_components(components);\n         self.path_global(span, idents)\n     }\n \n@@ -1953,4 +1968,21 @@ impl<'a> LoweringContext<'a> {\n         });\n         self.expr_block(block, attrs)\n     }\n+\n+    fn signal_block_stmt(&mut self,\n+                         stmt: hir::Stmt,\n+                         span: Span,\n+                         rule: hir::BlockCheckMode,\n+                         attrs: ThinVec<Attribute>)\n+                         -> P<hir::Expr> {\n+        let id = self.next_id();\n+        let block = P(hir::Block {\n+            rules: rule,\n+            span: span,\n+            id: id,\n+            stmts: hir_vec![stmt],\n+            expr: None,\n+        });\n+        self.expr_block(block, attrs)\n+    }\n }"}, {"sha": "577d19a58960da6382bb21ea20cd7aaf70aa7a91", "filename": "src/test/run-pass/try-operator-custom.rs", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/683bcc02955f988ab2726f1b7708baa6c1e64b7b/src%2Ftest%2Frun-pass%2Ftry-operator-custom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/683bcc02955f988ab2726f1b7708baa6c1e64b7b/src%2Ftest%2Frun-pass%2Ftry-operator-custom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftry-operator-custom.rs?ref=683bcc02955f988ab2726f1b7708baa6c1e64b7b", "patch": "@@ -0,0 +1,73 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(question_mark, question_mark_carrier)]\n+\n+use std::ops::Carrier;\n+\n+enum MyResult<T, U> {\n+    Awesome(T),\n+    Terrible(U)\n+}\n+\n+impl<U, V> Carrier for MyResult<U, V> {\n+    type Success = U;\n+    type Error = V;\n+\n+    fn from_success(u: U) -> MyResult<U, V> {\n+        MyResult::Awesome(u)\n+    }\n+\n+    fn from_error(e: V) -> MyResult<U, V> {\n+        MyResult::Terrible(e)\n+    }\n+\n+    fn translate<T>(self) -> T\n+        where T: Carrier<Success=U, Error=V>\n+    {\n+        match self {\n+            MyResult::Awesome(u) => T::from_success(u),\n+            MyResult::Terrible(e) => T::from_error(e),\n+        }\n+    }\n+}\n+\n+fn f(x: i32) -> Result<i32, String> {\n+    if x == 0 {\n+        Ok(42)\n+    } else {\n+        let y = g(x)?;\n+        Ok(y)\n+    }\n+}\n+\n+fn g(x: i32) -> MyResult<i32, String> {\n+    let _y = f(x - 1)?;\n+    MyResult::Terrible(\"Hello\".to_owned())\n+}\n+\n+fn h() -> MyResult<i32, String> {\n+    let a: Result<i32, &'static str> = Err(\"Hello\");\n+    let b = a?;\n+    MyResult::Awesome(b)\n+}\n+\n+fn i() -> MyResult<i32, String> {\n+    let a: MyResult<i32, &'static str> = MyResult::Terrible(\"Hello\");\n+    let b = a?;\n+    MyResult::Awesome(b)\n+}\n+\n+fn main() {\n+    assert!(f(0) == Ok(42));\n+    assert!(f(10) == Err(\"Hello\".to_owned()));\n+    let _ = h();\n+    let _ = i();\n+}"}, {"sha": "8076e00fd08ac6f8432f110e9883f25426971b82", "filename": "src/test/run-pass/try-operator.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/683bcc02955f988ab2726f1b7708baa6c1e64b7b/src%2Ftest%2Frun-pass%2Ftry-operator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/683bcc02955f988ab2726f1b7708baa6c1e64b7b/src%2Ftest%2Frun-pass%2Ftry-operator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftry-operator.rs?ref=683bcc02955f988ab2726f1b7708baa6c1e64b7b", "patch": "@@ -144,6 +144,23 @@ fn merge_error() -> Result<i32, Error> {\n     Ok(s.parse::<i32>()? + 1)\n }\n \n+fn option() -> Option<i32> {\n+    let x = Some(42);\n+    let y = x?;\n+    Some(y + 2)\n+}\n+\n+fn bool() -> bool {\n+    let x = true;\n+    let y = false;\n+    let z = true;\n+\n+    (x || y)?;\n+    let a: () = z?;\n+    x?;\n+    true\n+}\n+\n fn main() {\n     assert_eq!(Ok(3), on_method());\n "}]}