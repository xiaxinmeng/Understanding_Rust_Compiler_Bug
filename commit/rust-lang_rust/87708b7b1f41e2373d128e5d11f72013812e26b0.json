{"sha": "87708b7b1f41e2373d128e5d11f72013812e26b0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg3NzA4YjdiMWY0MWUyMzczZDEyOGU1ZDExZjcyMDEzODEyZTI2YjA=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-03-08T23:28:10Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-03-08T23:28:34Z"}, "message": "Refactor away check_ribs", "tree": {"sha": "0564cb7c30d5a908b0ef7e76bf7529ecdd1074ef", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0564cb7c30d5a908b0ef7e76bf7529ecdd1074ef"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/87708b7b1f41e2373d128e5d11f72013812e26b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/87708b7b1f41e2373d128e5d11f72013812e26b0", "html_url": "https://github.com/rust-lang/rust/commit/87708b7b1f41e2373d128e5d11f72013812e26b0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/87708b7b1f41e2373d128e5d11f72013812e26b0/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "210109cf7bc66fe9e4e9883cfe96e81381ba7d73", "url": "https://api.github.com/repos/rust-lang/rust/commits/210109cf7bc66fe9e4e9883cfe96e81381ba7d73", "html_url": "https://github.com/rust-lang/rust/commit/210109cf7bc66fe9e4e9883cfe96e81381ba7d73"}], "stats": {"total": 58, "additions": 18, "deletions": 40}, "files": [{"sha": "eefef015636aef7aa455e1a375828829ec69e0ab", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 18, "deletions": 40, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/87708b7b1f41e2373d128e5d11f72013812e26b0/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87708b7b1f41e2373d128e5d11f72013812e26b0/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=87708b7b1f41e2373d128e5d11f72013812e26b0", "patch": "@@ -1874,7 +1874,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                trait_path: &Path,\n                                path_depth: usize)\n                                -> Result<PathResolution, ()> {\n-        if let Some(path_res) = self.resolve_path(id, trait_path, path_depth, TypeNS, true) {\n+        if let Some(path_res) = self.resolve_path(id, trait_path, path_depth, TypeNS) {\n             if let Def::Trait(_) = path_res.base_def {\n                 debug!(\"(resolving trait) found trait def: {:?}\", path_res);\n                 Ok(path_res)\n@@ -1932,7 +1932,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 &hir::WherePredicate::BoundPredicate(_) |\n                 &hir::WherePredicate::RegionPredicate(_) => {}\n                 &hir::WherePredicate::EqPredicate(ref eq_pred) => {\n-                    let path_res = self.resolve_path(eq_pred.id, &eq_pred.path, 0, TypeNS, true);\n+                    let path_res = self.resolve_path(eq_pred.id, &eq_pred.path, 0, TypeNS);\n                     if let Some(PathResolution { base_def: Def::TyParam(..), .. }) = path_res {\n                         self.record_def(eq_pred.id, path_res.unwrap());\n                     } else {\n@@ -2198,8 +2198,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 let resolution = match self.resolve_possibly_assoc_item(ty.id,\n                                                                         maybe_qself.as_ref(),\n                                                                         path,\n-                                                                        TypeNS,\n-                                                                        true) {\n+                                                                        TypeNS) {\n                     // `<T>::a::b::c` is resolved by typeck alone.\n                     TypecheckRequired => {\n                         // Resolve embedded types.\n@@ -2224,7 +2223,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         self.record_def(ty.id, err_path_resolution());\n \n                         // Keep reporting some errors even if they're ignored above.\n-                        self.resolve_path(ty.id, path, 0, TypeNS, true);\n+                        self.resolve_path(ty.id, path, 0, TypeNS);\n \n                         let kind = if maybe_qself.is_some() {\n                             \"associated type\"\n@@ -2402,8 +2401,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     let resolution = match self.resolve_possibly_assoc_item(pat_id,\n                                                                             None,\n                                                                             path,\n-                                                                            ValueNS,\n-                                                                            false) {\n+                                                                            ValueNS) {\n                         // The below shouldn't happen because all\n                         // qualified paths should be in PatKind::QPath.\n                         TypecheckRequired =>\n@@ -2475,8 +2473,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     let resolution = match self.resolve_possibly_assoc_item(pat_id,\n                                                                             Some(qself),\n                                                                             path,\n-                                                                            ValueNS,\n-                                                                            false) {\n+                                                                            ValueNS) {\n                         TypecheckRequired => {\n                             // All `<T>::CONST` should end up here, and will\n                             // require use of the trait map to resolve\n@@ -2526,7 +2523,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 }\n \n                 PatKind::Struct(ref path, _, _) => {\n-                    match self.resolve_path(pat_id, path, 0, TypeNS, false) {\n+                    match self.resolve_path(pat_id, path, 0, TypeNS) {\n                         Some(definition) => {\n                             self.record_def(pattern.id, definition);\n                         }\n@@ -2607,8 +2604,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                    id: NodeId,\n                                    maybe_qself: Option<&hir::QSelf>,\n                                    path: &Path,\n-                                   namespace: Namespace,\n-                                   check_ribs: bool)\n+                                   namespace: Namespace)\n                                    -> AssocItemResolveResult {\n         let max_assoc_types;\n \n@@ -2627,14 +2623,14 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         }\n \n         let mut resolution = self.with_no_errors(|this| {\n-            this.resolve_path(id, path, 0, namespace, check_ribs)\n+            this.resolve_path(id, path, 0, namespace)\n         });\n         for depth in 1..max_assoc_types {\n             if resolution.is_some() {\n                 break;\n             }\n             self.with_no_errors(|this| {\n-                resolution = this.resolve_path(id, path, depth, TypeNS, true);\n+                resolution = this.resolve_path(id, path, depth, TypeNS);\n             });\n         }\n         if let Some(Def::Mod(_)) = resolution.map(|r| r.base_def) {\n@@ -2644,16 +2640,13 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         ResolveAttempt(resolution)\n     }\n \n-    /// If `check_ribs` is true, checks the local definitions first; i.e.\n-    /// doesn't skip straight to the containing module.\n     /// Skips `path_depth` trailing segments, which is also reflected in the\n     /// returned value. See `middle::def::PathResolution` for more info.\n     pub fn resolve_path(&mut self,\n                         id: NodeId,\n                         path: &Path,\n                         path_depth: usize,\n-                        namespace: Namespace,\n-                        check_ribs: bool)\n+                        namespace: Namespace)\n                         -> Option<PathResolution> {\n         let span = path.span;\n         let segments = &path.segments[..path.segments.len() - path_depth];\n@@ -2668,14 +2661,14 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         // Try to find a path to an item in a module.\n         let last_ident = segments.last().unwrap().identifier;\n         if segments.len() <= 1 {\n-            let unqualified_def = self.resolve_identifier(last_ident, namespace, check_ribs, true);\n+            let unqualified_def = self.resolve_identifier(last_ident, namespace, true);\n             return unqualified_def.and_then(|def| self.adjust_local_def(def, span))\n                                   .map(|def| {\n                                       PathResolution::new(def, path_depth)\n                                   });\n         }\n \n-        let unqualified_def = self.resolve_identifier(last_ident, namespace, check_ribs, false);\n+        let unqualified_def = self.resolve_identifier(last_ident, namespace, false);\n         let def = self.resolve_module_relative_path(span, segments, namespace);\n         match (def, unqualified_def) {\n             (Some(d), Some(ref ud)) if d == ud.def => {\n@@ -2695,7 +2688,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     fn resolve_identifier(&mut self,\n                           identifier: hir::Ident,\n                           namespace: Namespace,\n-                          check_ribs: bool,\n                           record_used: bool)\n                           -> Option<LocalDef> {\n         if identifier.name == special_idents::invalid.name {\n@@ -2711,20 +2703,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             }\n         }\n \n-        if check_ribs {\n-            return self.resolve_identifier_in_local_ribs(identifier, namespace, record_used);\n-        }\n-\n-        // Check the items.\n-        let name = identifier.unhygienic_name;\n-        match self.resolve_item_in_lexical_scope(name, namespace, record_used) {\n-            Success(binding) => binding.def().map(LocalDef::from_def),\n-            Failed(Some((span, msg))) => {\n-                resolve_error(self, span, ResolutionError::FailedToResolve(&msg));\n-                None\n-            }\n-            _ => None,\n-        }\n+        self.resolve_identifier_in_local_ribs(identifier, namespace, record_used)\n     }\n \n     // Resolve a local definition, potentially adjusting for closures.\n@@ -3104,8 +3083,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 let resolution = match self.resolve_possibly_assoc_item(expr.id,\n                                                                         maybe_qself.as_ref(),\n                                                                         path,\n-                                                                        ValueNS,\n-                                                                        true) {\n+                                                                        ValueNS) {\n                     // `<T>::a::b::c` is resolved by typeck alone.\n                     TypecheckRequired => {\n                         let method_name = path.segments.last().unwrap().identifier.name;\n@@ -3165,7 +3143,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     // structs, which wouldn't result in this error.)\n                     let path_name = path_names_to_string(path, 0);\n                     let type_res = self.with_no_errors(|this| {\n-                        this.resolve_path(expr.id, path, 0, TypeNS, false)\n+                        this.resolve_path(expr.id, path, 0, TypeNS)\n                     });\n \n                     self.record_def(expr.id, err_path_resolution());\n@@ -3186,7 +3164,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         }\n                         _ => {\n                             // Keep reporting some errors even if they're ignored above.\n-                            self.resolve_path(expr.id, path, 0, ValueNS, true);\n+                            self.resolve_path(expr.id, path, 0, ValueNS);\n \n                             let mut method_scope = false;\n                             self.value_ribs.iter().rev().all(|rib| {\n@@ -3260,7 +3238,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 // Resolve the path to the structure it goes to. We don't\n                 // check to ensure that the path is actually a structure; that\n                 // is checked later during typeck.\n-                match self.resolve_path(expr.id, path, 0, TypeNS, false) {\n+                match self.resolve_path(expr.id, path, 0, TypeNS) {\n                     Some(definition) => self.record_def(expr.id, definition),\n                     None => {\n                         debug!(\"(resolving expression) didn't find struct def\",);"}]}