{"sha": "3dec727297e6ebd6614219a93f376d8181ab11b1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNkZWM3MjcyOTdlNmViZDY2MTQyMTlhOTNmMzc2ZDgxODFhYjExYjE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-10-17T02:07:24Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-10-17T02:07:24Z"}, "message": "auto merge of #17869 : bkoropoff/rust/bound-all-the-upvars, r=nikomatsakis\n\nThis PR is based on #17784, which fixes closure soundness problems in borrowck.  Only the last two commits are unique to this PR.\r\n\r\nMy understanding of regionck is still evolving, so I'm not sure if this is the right approach.  Feedback is appreciated.\r\n\r\n- In `link_reborrowed_region`, we account for the ability of upvars to\r\n  change their mutability due to later processing.  A map of recursive\r\n  region links we may want to establish in the future is maintained,\r\n  with the links being established when the mutability of the borrow\r\n  is adjusted.\r\n- When asked to establish a region link for an upvar, we link it to\r\n  the region of the closure body.  This creates the necessary\r\n  constraint to stop unsound reborrows from the closure environment.\r\n\r\nThis partially (maybe completely) solves issue #17403.  Remaining work:\r\n\r\n- This is only known to help with by-ref upvars.  I have not looked at\r\n  by-value upvars yet to see if they can cause problems.\r\n- The error diagnostics that result from failed region inference are\r\n  pretty inscrutible.", "tree": {"sha": "3b32606a720eb3baa059837b0f0c4068cc8f54ee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3b32606a720eb3baa059837b0f0c4068cc8f54ee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3dec727297e6ebd6614219a93f376d8181ab11b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3dec727297e6ebd6614219a93f376d8181ab11b1", "html_url": "https://github.com/rust-lang/rust/commit/3dec727297e6ebd6614219a93f376d8181ab11b1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3dec727297e6ebd6614219a93f376d8181ab11b1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1600e0b93c4edf10bce71fbb68d383827c40a153", "url": "https://api.github.com/repos/rust-lang/rust/commits/1600e0b93c4edf10bce71fbb68d383827c40a153", "html_url": "https://github.com/rust-lang/rust/commit/1600e0b93c4edf10bce71fbb68d383827c40a153"}, {"sha": "fdd69accd0c9366b882a0e0d93ddb94eee307431", "url": "https://api.github.com/repos/rust-lang/rust/commits/fdd69accd0c9366b882a0e0d93ddb94eee307431", "html_url": "https://github.com/rust-lang/rust/commit/fdd69accd0c9366b882a0e0d93ddb94eee307431"}], "stats": {"total": 810, "additions": 526, "deletions": 284}, "files": [{"sha": "fb2c8aace95147828fb63d4227d5d4314ac60bbd", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3dec727297e6ebd6614219a93f376d8181ab11b1/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dec727297e6ebd6614219a93f376d8181ab11b1/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=3dec727297e6ebd6614219a93f376d8181ab11b1", "patch": "@@ -277,6 +277,7 @@ fn parse_bound_region(st: &mut PState, conv: conv_did) -> ty::BoundRegion {\n             assert_eq!(next(st), '|');\n             ty::BrFresh(id)\n         }\n+        'e' => ty::BrEnv,\n         _ => fail!(\"parse_bound_region: bad input\")\n     }\n }"}, {"sha": "ee31149165211b97eceaf661440095013b51bb40", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3dec727297e6ebd6614219a93f376d8181ab11b1/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dec727297e6ebd6614219a93f376d8181ab11b1/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=3dec727297e6ebd6614219a93f376d8181ab11b1", "patch": "@@ -175,6 +175,9 @@ fn enc_bound_region(w: &mut SeekableMemWriter, cx: &ctxt, br: ty::BoundRegion) {\n         ty::BrFresh(id) => {\n             mywrite!(w, \"f{}|\", id);\n         }\n+        ty::BrEnv => {\n+            mywrite!(w, \"e|\");\n+        }\n     }\n }\n "}, {"sha": "32fc045012d8c35b32dde9015befdeeabc18dcd0", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3dec727297e6ebd6614219a93f376d8181ab11b1/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dec727297e6ebd6614219a93f376d8181ab11b1/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=3dec727297e6ebd6614219a93f376d8181ab11b1", "patch": "@@ -516,7 +516,8 @@ impl tr for ty::BoundRegion {\n     fn tr(&self, dcx: &DecodeContext) -> ty::BoundRegion {\n         match *self {\n             ty::BrAnon(_) |\n-            ty::BrFresh(_) => *self,\n+            ty::BrFresh(_) |\n+            ty::BrEnv => *self,\n             ty::BrNamed(id, ident) => ty::BrNamed(dcx.tr_def_id(id),\n                                                     ident),\n         }"}, {"sha": "5f09cafb5e26eb4201de364a00253073f5bab8b8", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 24, "deletions": 23, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/3dec727297e6ebd6614219a93f376d8181ab11b1/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dec727297e6ebd6614219a93f376d8181ab11b1/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=3dec727297e6ebd6614219a93f376d8181ab11b1", "patch": "@@ -775,21 +775,32 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n         }\n \n         // Otherwise, just a plain error.\n-        match opt_loan_path(&assignee_cmt) {\n-            Some(lp) => {\n-                self.bccx.span_err(\n-                    assignment_span,\n-                    format!(\"cannot assign to {} {} `{}`\",\n-                            assignee_cmt.mutbl.to_user_str(),\n-                            self.bccx.cmt_to_string(&*assignee_cmt),\n-                            self.bccx.loan_path_to_string(&*lp)).as_slice());\n-            }\n-            None => {\n+        match assignee_cmt.note {\n+            mc::NoteClosureEnv(upvar_id) => {\n                 self.bccx.span_err(\n                     assignment_span,\n-                    format!(\"cannot assign to {} {}\",\n-                            assignee_cmt.mutbl.to_user_str(),\n+                    format!(\"cannot assign to {}\",\n                             self.bccx.cmt_to_string(&*assignee_cmt)).as_slice());\n+                self.bccx.span_note(\n+                    self.tcx().map.span(upvar_id.closure_expr_id),\n+                    \"consider changing this closure to take self by mutable reference\");\n+            }\n+            _ => match opt_loan_path(&assignee_cmt) {\n+                Some(lp) => {\n+                    self.bccx.span_err(\n+                        assignment_span,\n+                        format!(\"cannot assign to {} {} `{}`\",\n+                                assignee_cmt.mutbl.to_user_str(),\n+                                self.bccx.cmt_to_string(&*assignee_cmt),\n+                                self.bccx.loan_path_to_string(&*lp)).as_slice());\n+                }\n+                None => {\n+                    self.bccx.span_err(\n+                        assignment_span,\n+                        format!(\"cannot assign to {} {}\",\n+                                assignee_cmt.mutbl.to_user_str(),\n+                                self.bccx.cmt_to_string(&*assignee_cmt)).as_slice());\n+                }\n             }\n         }\n         return;\n@@ -805,16 +816,12 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n             loop {\n                 debug!(\"mark_variable_as_used_mut(cmt={})\", cmt.repr(this.tcx()));\n                 match cmt.cat.clone() {\n-                    mc::cat_copied_upvar(mc::CopiedUpvar { upvar_id: id, .. }) |\n+                    mc::cat_upvar(mc::Upvar { id: ty::UpvarId { var_id: id, .. }, .. }) |\n                     mc::cat_local(id) => {\n                         this.tcx().used_mut_nodes.borrow_mut().insert(id);\n                         return;\n                     }\n \n-                    mc::cat_upvar(..) => {\n-                        return;\n-                    }\n-\n                     mc::cat_rvalue(..) |\n                     mc::cat_static_item |\n                     mc::cat_deref(_, _, mc::UnsafePtr(..)) |\n@@ -854,12 +861,6 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                     check_for_aliasability_violation(this, span, b.clone());\n                 }\n \n-                mc::cat_copied_upvar(mc::CopiedUpvar {\n-                    kind: mc::Unboxed(ty::FnUnboxedClosureKind), ..}) => {\n-                    // Prohibit writes to capture-by-move upvars in non-once closures\n-                    check_for_aliasability_violation(this, span, guarantor.clone());\n-                }\n-\n                 _ => {}\n             }\n "}, {"sha": "7c037cf50ff29e5104b2ac2e08aa397a1dbb20d8", "filename": "src/librustc/middle/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3dec727297e6ebd6614219a93f376d8181ab11b1/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dec727297e6ebd6614219a93f376d8181ab11b1/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=3dec727297e6ebd6614219a93f376d8181ab11b1", "patch": "@@ -133,19 +133,13 @@ fn check_and_get_illegal_move_origin(bccx: &BorrowckCtxt,\n         mc::cat_deref(_, _, mc::BorrowedPtr(..)) |\n         mc::cat_deref(_, _, mc::Implicit(..)) |\n         mc::cat_deref(_, _, mc::UnsafePtr(..)) |\n-        mc::cat_upvar(..) | mc::cat_static_item => {\n+        mc::cat_static_item => {\n             Some(cmt.clone())\n         }\n \n-        mc::cat_copied_upvar(mc::CopiedUpvar { kind: kind, .. }) => {\n-            match kind.onceness() {\n-                ast::Once => None,\n-                ast::Many => Some(cmt.clone())\n-            }\n-        }\n-\n         mc::cat_rvalue(..) |\n-        mc::cat_local(..) => {\n+        mc::cat_local(..) |\n+        mc::cat_upvar(..) => {\n             None\n         }\n "}, {"sha": "5018fe0f96e076982fae2e85ab6119015d0291b6", "filename": "src/librustc/middle/borrowck/gather_loans/lifetime.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3dec727297e6ebd6614219a93f376d8181ab11b1/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dec727297e6ebd6614219a93f376d8181ab11b1/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs?ref=3dec727297e6ebd6614219a93f376d8181ab11b1", "patch": "@@ -67,7 +67,6 @@ impl<'a, 'tcx> GuaranteeLifetimeContext<'a, 'tcx> {\n \n         match cmt.cat {\n             mc::cat_rvalue(..) |\n-            mc::cat_copied_upvar(..) |                  // L-Local\n             mc::cat_local(..) |                         // L-Local\n             mc::cat_upvar(..) |\n             mc::cat_deref(_, _, mc::BorrowedPtr(..)) |  // L-Deref-Borrowed\n@@ -165,8 +164,7 @@ impl<'a, 'tcx> GuaranteeLifetimeContext<'a, 'tcx> {\n             mc::cat_rvalue(temp_scope) => {\n                 temp_scope\n             }\n-            mc::cat_upvar(..) |\n-            mc::cat_copied_upvar(_) => {\n+            mc::cat_upvar(..) => {\n                 ty::ReScope(self.item_scope_id)\n             }\n             mc::cat_static_item => {"}, {"sha": "b1757a4eb2cbc3ff557928370571dee54cc8775f", "filename": "src/librustc/middle/borrowck/gather_loans/move_error.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3dec727297e6ebd6614219a93f376d8181ab11b1/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dec727297e6ebd6614219a93f376d8181ab11b1/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmove_error.rs?ref=3dec727297e6ebd6614219a93f376d8181ab11b1", "patch": "@@ -115,15 +115,7 @@ fn report_cannot_move_out_of(bccx: &BorrowckCtxt, move_from: mc::cmt) {\n         mc::cat_deref(_, _, mc::BorrowedPtr(..)) |\n         mc::cat_deref(_, _, mc::Implicit(..)) |\n         mc::cat_deref(_, _, mc::UnsafePtr(..)) |\n-        mc::cat_upvar(..) | mc::cat_static_item => {\n-            bccx.span_err(\n-                move_from.span,\n-                format!(\"cannot move out of {}\",\n-                        bccx.cmt_to_string(&*move_from)).as_slice());\n-        }\n-\n-        mc::cat_copied_upvar(mc::CopiedUpvar { kind: kind, .. })\n-            if kind.onceness() == ast::Many => {\n+        mc::cat_static_item => {\n             bccx.span_err(\n                 move_from.span,\n                 format!(\"cannot move out of {}\","}, {"sha": "15a7437b6a87a4b1701b65b7385afb2e3e2d3e36", "filename": "src/librustc/middle/borrowck/gather_loans/restrictions.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3dec727297e6ebd6614219a93f376d8181ab11b1/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dec727297e6ebd6614219a93f376d8181ab11b1/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs?ref=3dec727297e6ebd6614219a93f376d8181ab11b1", "patch": "@@ -73,15 +73,9 @@ impl<'a, 'tcx> RestrictionsContext<'a, 'tcx> {\n                 SafeIf(lp.clone(), vec![lp])\n             }\n \n-            mc::cat_upvar(upvar_id, _, _) => {\n+            mc::cat_upvar(mc::Upvar { id, .. }) => {\n                 // R-Variable, captured into closure\n-                let lp = Rc::new(LpUpvar(upvar_id));\n-                SafeIf(lp.clone(), vec![lp])\n-            }\n-\n-            mc::cat_copied_upvar(mc::CopiedUpvar { upvar_id, .. }) => {\n-                // R-Variable, copied/moved into closure\n-                let lp = Rc::new(LpVar(upvar_id));\n+                let lp = Rc::new(LpUpvar(id));\n                 SafeIf(lp.clone(), vec![lp])\n             }\n "}, {"sha": "b4828e42cef860339650c41a129738a443014eb1", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 30, "deletions": 24, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/3dec727297e6ebd6614219a93f376d8181ab11b1/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dec727297e6ebd6614219a93f376d8181ab11b1/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=3dec727297e6ebd6614219a93f376d8181ab11b1", "patch": "@@ -359,21 +359,12 @@ pub fn opt_loan_path(cmt: &mc::cmt) -> Option<Rc<LoanPath>> {\n             None\n         }\n \n-        mc::cat_copied_upvar(mc::CopiedUpvar { kind: kind, .. })\n-            if kind.onceness() == ast::Many => {\n-            None\n-        }\n-\n         mc::cat_local(id) => {\n             Some(Rc::new(LpVar(id)))\n         }\n \n-        mc::cat_upvar(ty::UpvarId {var_id: id, closure_expr_id: proc_id}, _, _) |\n-        mc::cat_copied_upvar(mc::CopiedUpvar { upvar_id: id,\n-                                               kind: _,\n-                                               capturing_proc: proc_id }) => {\n-            let upvar_id = ty::UpvarId{ var_id: id, closure_expr_id: proc_id };\n-            Some(Rc::new(LpUpvar(upvar_id)))\n+        mc::cat_upvar(mc::Upvar { id, .. }) => {\n+            Some(Rc::new(LpUpvar(id)))\n         }\n \n         mc::cat_deref(ref cmt_base, _, pk) => {\n@@ -630,17 +621,22 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n     pub fn bckerr_to_string(&self, err: &BckError) -> String {\n         match err.code {\n             err_mutbl => {\n-                let descr = match opt_loan_path(&err.cmt) {\n-                    None => {\n-                        format!(\"{} {}\",\n-                                err.cmt.mutbl.to_user_str(),\n-                                self.cmt_to_string(&*err.cmt))\n+                let descr = match err.cmt.note {\n+                    mc::NoteClosureEnv(_) => {\n+                        self.cmt_to_string(&*err.cmt)\n                     }\n-                    Some(lp) => {\n-                        format!(\"{} {} `{}`\",\n-                                err.cmt.mutbl.to_user_str(),\n-                                self.cmt_to_string(&*err.cmt),\n-                                self.loan_path_to_string(&*lp))\n+                    _ => match opt_loan_path(&err.cmt) {\n+                        None => {\n+                            format!(\"{} {}\",\n+                                    err.cmt.mutbl.to_user_str(),\n+                                    self.cmt_to_string(&*err.cmt))\n+                        }\n+                        Some(lp) => {\n+                            format!(\"{} {} `{}`\",\n+                                    err.cmt.mutbl.to_user_str(),\n+                                    self.cmt_to_string(&*err.cmt),\n+                                    self.loan_path_to_string(&*lp))\n+                        }\n                     }\n                 };\n \n@@ -732,8 +728,8 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n             }\n             mc::AliasableClosure(id) => {\n                 self.tcx.sess.span_err(span,\n-                                       format!(\"{} in a free variable from an \\\n-                                               immutable unboxed closure\", prefix).as_slice());\n+                                       format!(\"{} in a captured outer \\\n+                                               variable in an `Fn` closure\", prefix).as_slice());\n                 span_note!(self.tcx.sess, self.tcx.map.span(id),\n                            \"consider changing this closure to take self by mutable reference\");\n             }\n@@ -760,7 +756,17 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n     pub fn note_and_explain_bckerr(&self, err: BckError) {\n         let code = err.code;\n         match code {\n-            err_mutbl(..) => { }\n+            err_mutbl(..) => {\n+                match err.cmt.note {\n+                    mc::NoteClosureEnv(upvar_id) => {\n+                        self.tcx.sess.span_note(\n+                            self.tcx.map.span(upvar_id.closure_expr_id),\n+                            \"consider changing this closure to take \\\n+                             self by mutable reference\");\n+                    }\n+                    _ => {}\n+                }\n+            }\n \n             err_out_of_scope(super_scope, sub_scope) => {\n                 note_and_explain_region("}, {"sha": "97acc74b8c69ee20e5183d798860c21da0709157", "filename": "src/librustc/middle/check_static.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dec727297e6ebd6614219a93f376d8181ab11b1/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dec727297e6ebd6614219a93f376d8181ab11b1/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs?ref=3dec727297e6ebd6614219a93f376d8181ab11b1", "patch": "@@ -264,7 +264,6 @@ impl euv::Delegate for GlobalChecker {\n                 mc::cat_interior(ref cmt, _) => cur = cmt,\n \n                 mc::cat_rvalue(..) |\n-                mc::cat_copied_upvar(..) |\n                 mc::cat_upvar(..) |\n                 mc::cat_local(..) => break,\n             }\n@@ -299,7 +298,6 @@ impl euv::Delegate for GlobalChecker {\n \n                 mc::cat_downcast(..) |\n                 mc::cat_discr(..) |\n-                mc::cat_copied_upvar(..) |\n                 mc::cat_upvar(..) |\n                 mc::cat_local(..) => unreachable!(),\n             }"}, {"sha": "e43996559417bd95d9bc9b7f174e4a832c6654ea", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 258, "deletions": 147, "changes": 405, "blob_url": "https://github.com/rust-lang/rust/blob/3dec727297e6ebd6614219a93f376d8181ab11b1/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dec727297e6ebd6614219a93f376d8181ab11b1/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=3dec727297e6ebd6614219a93f376d8181ab11b1", "patch": "@@ -82,9 +82,7 @@ use std::rc::Rc;\n pub enum categorization {\n     cat_rvalue(ty::Region),            // temporary val, argument is its scope\n     cat_static_item,\n-    cat_copied_upvar(CopiedUpvar),     // upvar copied into proc env\n-    cat_upvar(ty::UpvarId, ty::UpvarBorrow,\n-              Option<ty::UnboxedClosureKind>), // by ref upvar from stack or unboxed closure\n+    cat_upvar(Upvar),                  // upvar referenced by closure env\n     cat_local(ast::NodeId),            // local variable\n     cat_deref(cmt, uint, PointerKind), // deref of a ptr\n     cat_interior(cmt, InteriorKind),   // something interior: field, tuple, etc\n@@ -94,28 +92,14 @@ pub enum categorization {\n     // (*1) downcast is only required if the enum has more than one variant\n }\n \n+// Represents any kind of upvar\n #[deriving(Clone, PartialEq, Show)]\n-pub enum CopiedUpvarKind {\n-    Boxed(ast::Onceness),\n-    Unboxed(ty::UnboxedClosureKind)\n-}\n-\n-impl CopiedUpvarKind {\n-    pub fn onceness(&self) -> ast::Onceness {\n-        match *self {\n-            Boxed(onceness) => onceness,\n-            Unboxed(ty::FnUnboxedClosureKind) |\n-            Unboxed(ty::FnMutUnboxedClosureKind) => ast::Many,\n-            Unboxed(ty::FnOnceUnboxedClosureKind) => ast::Once\n-        }\n-    }\n-}\n-\n-#[deriving(Clone, PartialEq, Show)]\n-pub struct CopiedUpvar {\n-    pub upvar_id: ast::NodeId,\n-    pub kind: CopiedUpvarKind,\n-    pub capturing_proc: ast::NodeId,\n+pub struct Upvar {\n+    pub id: ty::UpvarId,\n+    // Unboxed closure kinds are used even for old-style closures for simplicity\n+    pub kind: ty::UnboxedClosureKind,\n+    // Is this from an unboxed closure?  Used only for diagnostics.\n+    pub is_unboxed: bool\n }\n \n // different kinds of pointers:\n@@ -154,6 +138,18 @@ pub enum MutabilityCategory {\n     McInherited, // Inherited from the fact that owner is mutable.\n }\n \n+// A note about the provenance of a `cmt`.  This is used for\n+// special-case handling of upvars such as mutability inference.\n+// Upvar categorization can generate a variable number of nested\n+// derefs.  The note allows detecting them without deep pattern\n+// matching on the categorization.\n+#[deriving(Clone, PartialEq, Show)]\n+pub enum Note {\n+    NoteClosureEnv(ty::UpvarId), // Deref through closure env\n+    NoteUpvarRef(ty::UpvarId),   // Deref through by-ref upvar\n+    NoteNone                     // Nothing special\n+}\n+\n // `cmt`: \"Category, Mutability, and Type\".\n //\n // a complete categorization of a value indicating where it originated\n@@ -174,7 +170,8 @@ pub struct cmt_ {\n     pub span: Span,                // span of same expr/pat\n     pub cat: categorization,       // categorization of expr\n     pub mutbl: MutabilityCategory, // mutability of expr as lvalue\n-    pub ty: ty::t                  // type of the expr (*see WARNING above*)\n+    pub ty: ty::t,                 // type of the expr (*see WARNING above*)\n+    pub note: Note,                // Note about the provenance of this cmt\n }\n \n pub type cmt = Rc<cmt_>;\n@@ -560,7 +557,8 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                   span:span,\n                   cat:cat_static_item,\n                   mutbl: McImmutable,\n-                  ty:expr_ty\n+                  ty:expr_ty,\n+                  note: NoteNone\n               }))\n           }\n \n@@ -570,63 +568,38 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                   span:span,\n                   cat:cat_static_item,\n                   mutbl: if mutbl { McDeclared } else { McImmutable},\n-                  ty:expr_ty\n+                  ty:expr_ty,\n+                  note: NoteNone\n               }))\n           }\n \n           def::DefUpvar(var_id, fn_node_id, _) => {\n               let ty = if_ok!(self.node_ty(fn_node_id));\n               match ty::get(ty).sty {\n                   ty::ty_closure(ref closure_ty) => {\n-                      // Decide whether to use implicit reference or by copy/move\n-                      // capture for the upvar. This, combined with the onceness,\n-                      // determines whether the closure can move out of it.\n-                      let var_is_refd = match (closure_ty.store, closure_ty.onceness) {\n-                          // Many-shot stack closures can never move out.\n-                          (ty::RegionTraitStore(..), ast::Many) => true,\n-                          // 1-shot stack closures can move out.\n-                          (ty::RegionTraitStore(..), ast::Once) => false,\n-                          // Heap closures always capture by copy/move, and can\n-                          // move out if they are once.\n-                          (ty::UniqTraitStore, _) => false,\n-\n+                      // Translate old closure type info into unboxed\n+                      // closure kind/capture mode\n+                      let (mode, kind) = match (closure_ty.store, closure_ty.onceness) {\n+                          // stack closure\n+                          (ty::RegionTraitStore(..), ast::Many) => {\n+                              (ast::CaptureByRef, ty::FnMutUnboxedClosureKind)\n+                          }\n+                          // proc or once closure\n+                          (_, ast::Once) => {\n+                              (ast::CaptureByValue, ty::FnOnceUnboxedClosureKind)\n+                          }\n+                          // There should be no such old closure type\n+                          (ty::UniqTraitStore, ast::Many) => {\n+                              self.tcx().sess.span_bug(span, \"Impossible closure type\");\n+                          }\n                       };\n-                      if var_is_refd {\n-                          self.cat_upvar(id, span, var_id, fn_node_id, None)\n-                      } else {\n-                          Ok(Rc::new(cmt_ {\n-                              id:id,\n-                              span:span,\n-                              cat:cat_copied_upvar(CopiedUpvar {\n-                                  upvar_id: var_id,\n-                                  kind: Boxed(closure_ty.onceness),\n-                                  capturing_proc: fn_node_id,\n-                              }),\n-                              mutbl: MutabilityCategory::from_local(self.tcx(), var_id),\n-                              ty:expr_ty\n-                          }))\n-                      }\n+                      self.cat_upvar(id, span, var_id, fn_node_id, kind, mode, false)\n                   }\n                   ty::ty_unboxed_closure(closure_id, _) => {\n-                      let unboxed_closures = self.typer\n-                                                 .unboxed_closures()\n-                                                 .borrow();\n+                      let unboxed_closures = self.typer.unboxed_closures().borrow();\n                       let kind = unboxed_closures.get(&closure_id).kind;\n-                      if self.typer.capture_mode(fn_node_id) == ast::CaptureByRef {\n-                          self.cat_upvar(id, span, var_id, fn_node_id, Some(kind))\n-                      } else {\n-                          Ok(Rc::new(cmt_ {\n-                              id: id,\n-                              span: span,\n-                              cat: cat_copied_upvar(CopiedUpvar {\n-                                  upvar_id: var_id,\n-                                  kind: Unboxed(kind),\n-                                  capturing_proc: fn_node_id,\n-                              }),\n-                              mutbl: MutabilityCategory::from_local(self.tcx(), var_id),\n-                              ty: expr_ty\n-                          }))\n-                      }\n+                      let mode = self.typer.capture_mode(fn_node_id);\n+                      self.cat_upvar(id, span, var_id, fn_node_id, kind, mode, true)\n                   }\n                   _ => {\n                       self.tcx().sess.span_bug(\n@@ -644,61 +617,171 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                 span: span,\n                 cat: cat_local(vid),\n                 mutbl: MutabilityCategory::from_local(self.tcx(), vid),\n-                ty: expr_ty\n+                ty: expr_ty,\n+                note: NoteNone\n             }))\n           }\n         }\n     }\n \n+    // Categorize an upvar, complete with invisible derefs of closure\n+    // environment and upvar reference as appropriate.\n     fn cat_upvar(&self,\n                  id: ast::NodeId,\n                  span: Span,\n                  var_id: ast::NodeId,\n                  fn_node_id: ast::NodeId,\n-                 kind: Option<ty::UnboxedClosureKind>)\n+                 kind: ty::UnboxedClosureKind,\n+                 mode: ast::CaptureClause,\n+                 is_unboxed: bool)\n                  -> McResult<cmt> {\n-        /*!\n-         * Upvars through a closure are in fact indirect\n-         * references. That is, when a closure refers to a\n-         * variable from a parent stack frame like `x = 10`,\n-         * that is equivalent to `*x_ = 10` where `x_` is a\n-         * borrowed pointer (`&mut x`) created when the closure\n-         * was created and store in the environment. This\n-         * equivalence is expose in the mem-categorization.\n-         */\n-\n+        // An upvar can have up to 3 components.  The base is a\n+        // `cat_upvar`.  Next, we add a deref through the implicit\n+        // environment pointer with an anonymous free region 'env and\n+        // appropriate borrow kind for closure kinds that take self by\n+        // reference.  Finally, if the upvar was captured\n+        // by-reference, we add a deref through that reference.  The\n+        // region of this reference is an inference variable 'up that\n+        // was previously generated and recorded in the upvar borrow\n+        // map.  The borrow kind bk is inferred by based on how the\n+        // upvar is used.\n+        //\n+        // This results in the following table for concrete closure\n+        // types:\n+        //\n+        //                | move                 | ref\n+        // ---------------+----------------------+-------------------------------\n+        // Fn             | copied -> &'env      | upvar -> &'env -> &'up bk\n+        // FnMut          | copied -> &'env mut  | upvar -> &'env mut -> &'up bk\n+        // FnOnce         | copied               | upvar -> &'up bk\n+        // old stack      | N/A                  | upvar -> &'env mut -> &'up bk\n+        // old proc/once  | copied               | N/A\n         let upvar_id = ty::UpvarId { var_id: var_id,\n                                      closure_expr_id: fn_node_id };\n \n-        let upvar_borrow = self.typer.upvar_borrow(upvar_id);\n+        // Do we need to deref through an env reference?\n+        let has_env_deref = kind != ty::FnOnceUnboxedClosureKind;\n \n-        let var_ty = if_ok!(self.node_ty(var_id));\n+        // Mutability of original variable itself\n+        let var_mutbl = MutabilityCategory::from_local(self.tcx(), var_id);\n \n-        // We can't actually represent the types of all upvars\n-        // as user-describable types, since upvars support const\n-        // and unique-imm borrows! Therefore, we cheat, and just\n-        // give err type. Nobody should be inspecting this type anyhow.\n-        let upvar_ty = ty::mk_err();\n+        // Mutability of environment dereference\n+        let env_mutbl = match kind {\n+            ty::FnOnceUnboxedClosureKind => var_mutbl,\n+            ty::FnMutUnboxedClosureKind => McInherited,\n+            ty::FnUnboxedClosureKind => McImmutable\n+        };\n \n-        let base_cmt = Rc::new(cmt_ {\n-            id:id,\n-            span:span,\n-            cat:cat_upvar(upvar_id, upvar_borrow, kind),\n-            mutbl:McImmutable,\n-            ty:upvar_ty,\n+        // Look up the node ID of the closure body so we can construct\n+        // a free region within it\n+        let fn_body_id = {\n+            let fn_expr = match self.tcx().map.find(fn_node_id) {\n+                Some(ast_map::NodeExpr(e)) => e,\n+                _ => unreachable!()\n+            };\n+\n+            match fn_expr.node {\n+                ast::ExprFnBlock(_, _, ref body) |\n+                ast::ExprProc(_, ref body) |\n+                ast::ExprUnboxedFn(_, _, _, ref body) => body.id,\n+                _ => unreachable!()\n+            }\n+        };\n+\n+        // Region of environment pointer\n+        let env_region = ty::ReFree(ty::FreeRegion {\n+            scope_id: fn_body_id,\n+            bound_region: ty::BrEnv\n         });\n \n-        let ptr = BorrowedPtr(upvar_borrow.kind, upvar_borrow.region);\n+        let env_ptr = BorrowedPtr(if env_mutbl.is_mutable() {\n+            ty::MutBorrow\n+        } else {\n+            ty::ImmBorrow\n+        }, env_region);\n \n-        let deref_cmt = Rc::new(cmt_ {\n-            id:id,\n-            span:span,\n-            cat:cat_deref(base_cmt, 0, ptr),\n-            mutbl:MutabilityCategory::from_borrow_kind(upvar_borrow.kind),\n-            ty:var_ty,\n-        });\n+        let var_ty = if_ok!(self.node_ty(var_id));\n+\n+        // First, switch by capture mode\n+        Ok(match mode {\n+            ast::CaptureByValue => {\n+                let mut base = cmt_ {\n+                    id: id,\n+                    span: span,\n+                    cat: cat_upvar(Upvar {\n+                        id: upvar_id,\n+                        kind: kind,\n+                        is_unboxed: is_unboxed\n+                    }),\n+                    mutbl: var_mutbl,\n+                    ty: var_ty,\n+                    note: NoteNone\n+                };\n \n-        Ok(deref_cmt)\n+                if has_env_deref {\n+                    // We need to add the env deref.  This means that\n+                    // the above is actually immutable and has a ref\n+                    // type.  However, nothing should actually look at\n+                    // the type, so we can get away with stuffing a\n+                    // `ty_err` in there instead of bothering to\n+                    // construct a proper one.\n+                    base.mutbl = McImmutable;\n+                    base.ty = ty::mk_err();\n+                    Rc::new(cmt_ {\n+                        id: id,\n+                        span: span,\n+                        cat: cat_deref(Rc::new(base), 0, env_ptr),\n+                        mutbl: env_mutbl,\n+                        ty: var_ty,\n+                        note: NoteClosureEnv(upvar_id)\n+                    })\n+                } else {\n+                    Rc::new(base)\n+                }\n+            },\n+            ast::CaptureByRef => {\n+                // The type here is actually a ref (or ref of a ref),\n+                // but we can again get away with not constructing one\n+                // properly since it will never be used.\n+                let mut base = cmt_ {\n+                    id: id,\n+                    span: span,\n+                    cat: cat_upvar(Upvar {\n+                        id: upvar_id,\n+                        kind: kind,\n+                        is_unboxed: is_unboxed\n+                    }),\n+                    mutbl: McImmutable,\n+                    ty: ty::mk_err(),\n+                    note: NoteNone\n+                };\n+\n+                // As in the by-value case, add env deref if needed\n+                if has_env_deref {\n+                    base = cmt_ {\n+                        id: id,\n+                        span: span,\n+                        cat: cat_deref(Rc::new(base), 0, env_ptr),\n+                        mutbl: env_mutbl,\n+                        ty: ty::mk_err(),\n+                        note: NoteClosureEnv(upvar_id)\n+                    };\n+                }\n+\n+                // Look up upvar borrow so we can get its region\n+                let upvar_borrow = self.typer.upvar_borrow(upvar_id);\n+                let ptr = BorrowedPtr(upvar_borrow.kind, upvar_borrow.region);\n+\n+                Rc::new(cmt_ {\n+                    id: id,\n+                    span: span,\n+                    cat: cat_deref(Rc::new(base), 0, ptr),\n+                    mutbl: MutabilityCategory::from_borrow_kind(upvar_borrow.kind),\n+                    ty: var_ty,\n+                    note: NoteUpvarRef(upvar_id)\n+                })\n+            }\n+        })\n     }\n \n     pub fn cat_rvalue_node(&self,\n@@ -729,7 +812,8 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n             span:span,\n             cat:cat_rvalue(temp_scope),\n             mutbl:McDeclared,\n-            ty:expr_ty\n+            ty:expr_ty,\n+            note: NoteNone\n         })\n     }\n \n@@ -744,7 +828,8 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n             span: node.span(),\n             mutbl: base_cmt.mutbl.inherit(),\n             cat: cat_interior(base_cmt, InteriorField(NamedField(f_name.name))),\n-            ty: f_ty\n+            ty: f_ty,\n+            note: NoteNone\n         })\n     }\n \n@@ -759,7 +844,8 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n             span: node.span(),\n             mutbl: base_cmt.mutbl.inherit(),\n             cat: cat_interior(base_cmt, InteriorField(PositionalField(f_idx))),\n-            ty: f_ty\n+            ty: f_ty,\n+            note: NoteNone\n         })\n     }\n \n@@ -834,7 +920,8 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n             span: node.span(),\n             cat: cat,\n             mutbl: m,\n-            ty: deref_ty\n+            ty: deref_ty,\n+            note: NoteNone\n         })\n     }\n \n@@ -895,7 +982,8 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                 span:elt.span(),\n                 cat:cat_interior(of_cmt, InteriorElement(element_kind(vec_ty))),\n                 mutbl:mutbl,\n-                ty:element_ty\n+                ty:element_ty,\n+                note: NoteNone\n             })\n         }\n     }\n@@ -921,7 +1009,8 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                     ty: match ty::deref(base_cmt.ty, false) {\n                         Some(mt) => mt.ty,\n                         None => self.tcx().sess.bug(\"Found non-derefable type\")\n-                    }\n+                    },\n+                    note: NoteNone\n                 })\n             }\n \n@@ -988,7 +1077,8 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n             span: node.span(),\n             mutbl: base_cmt.mutbl.inherit(),\n             cat: cat_interior(base_cmt, interior),\n-            ty: interior_ty\n+            ty: interior_ty,\n+            note: NoteNone\n         })\n     }\n \n@@ -1002,7 +1092,8 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n             span: node.span(),\n             mutbl: base_cmt.mutbl.inherit(),\n             cat: cat_downcast(base_cmt),\n-            ty: downcast_ty\n+            ty: downcast_ty,\n+            note: NoteNone\n         })\n     }\n \n@@ -1184,13 +1275,26 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n     }\n \n     pub fn cmt_to_string(&self, cmt: &cmt_) -> String {\n+        fn upvar_to_string(upvar: &Upvar, is_copy: bool) -> String {\n+            if upvar.is_unboxed {\n+                let kind = match upvar.kind {\n+                    ty::FnUnboxedClosureKind => \"Fn\",\n+                    ty::FnMutUnboxedClosureKind => \"FnMut\",\n+                    ty::FnOnceUnboxedClosureKind => \"FnOnce\"\n+                };\n+                format!(\"captured outer variable in an `{}` closure\", kind)\n+            } else {\n+                (match (upvar.kind, is_copy) {\n+                    (ty::FnOnceUnboxedClosureKind, true) => \"captured outer variable in a proc\",\n+                    _ => \"captured outer variable\"\n+                }).to_string()\n+            }\n+        }\n+\n         match cmt.cat {\n           cat_static_item => {\n               \"static item\".to_string()\n           }\n-          cat_copied_upvar(_) => {\n-              \"captured outer variable in a proc\".to_string()\n-          }\n           cat_rvalue(..) => {\n               \"non-lvalue\".to_string()\n           }\n@@ -1202,12 +1306,14 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                   _ => \"local variable\".to_string()\n               }\n           }\n-          cat_deref(ref base, _, pk) => {\n-              match base.cat {\n-                  cat_upvar(..) => {\n-                      \"captured outer variable\".to_string()\n+          cat_deref(_, _, pk) => {\n+              let upvar = cmt.upvar();\n+              match upvar.as_ref().map(|i| &i.cat) {\n+                  Some(&cat_upvar(ref var)) => {\n+                      upvar_to_string(var, false)\n                   }\n-                  _ => {\n+                  Some(_) => unreachable!(),\n+                  None => {\n                       match pk {\n                           Implicit(..) => {\n                             \"dereference (dereference is implicit, due to indexing)\".to_string()\n@@ -1230,8 +1336,8 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n           cat_interior(_, InteriorElement(OtherElement)) => {\n               \"indexed content\".to_string()\n           }\n-          cat_upvar(..) => {\n-              \"captured outer variable\".to_string()\n+          cat_upvar(ref var) => {\n+              upvar_to_string(var, true)\n           }\n           cat_discr(ref cmt, _) => {\n             self.cmt_to_string(&**cmt)\n@@ -1250,7 +1356,7 @@ pub enum InteriorSafety {\n \n pub enum AliasableReason {\n     AliasableBorrowed,\n-    AliasableClosure(ast::NodeId), // Aliasable due to capture by unboxed closure expr\n+    AliasableClosure(ast::NodeId), // Aliasable due to capture Fn closure env\n     AliasableOther,\n     AliasableStatic(InteriorSafety),\n     AliasableStaticMut(InteriorSafety),\n@@ -1265,7 +1371,6 @@ impl cmt_ {\n         match self.cat {\n             cat_rvalue(..) |\n             cat_static_item |\n-            cat_copied_upvar(..) |\n             cat_local(..) |\n             cat_deref(_, _, UnsafePtr(..)) |\n             cat_deref(_, _, BorrowedPtr(..)) |\n@@ -1307,27 +1412,11 @@ impl cmt_ {\n \n             cat_rvalue(..) |\n             cat_local(..) |\n+            cat_upvar(..) |\n             cat_deref(_, _, UnsafePtr(..)) => { // yes, it's aliasable, but...\n                 None\n             }\n \n-            cat_copied_upvar(CopiedUpvar {kind: kind, capturing_proc: id, ..}) => {\n-                match kind {\n-                    Boxed(ast::Once) |\n-                    Unboxed(ty::FnOnceUnboxedClosureKind) |\n-                    Unboxed(ty::FnMutUnboxedClosureKind) => None,\n-                    Boxed(_) => Some(AliasableOther),\n-                    Unboxed(_) => Some(AliasableClosure(id))\n-                }\n-            }\n-\n-            cat_upvar(ty::UpvarId { closure_expr_id: id, .. }, _,\n-                      Some(ty::FnUnboxedClosureKind)) => {\n-                Some(AliasableClosure(id))\n-            }\n-\n-            cat_upvar(..) => None,\n-\n             cat_static_item(..) => {\n                 let int_safe = if ty::type_interior_is_unsafe(ctxt, self.ty) {\n                     InteriorUnsafe\n@@ -1342,10 +1431,33 @@ impl cmt_ {\n                 }\n             }\n \n-            cat_deref(_, _, BorrowedPtr(ty::ImmBorrow, _)) |\n-            cat_deref(_, _, Implicit(ty::ImmBorrow, _)) => {\n-                Some(AliasableBorrowed)\n+            cat_deref(ref base, _, BorrowedPtr(ty::ImmBorrow, _)) |\n+            cat_deref(ref base, _, Implicit(ty::ImmBorrow, _)) => {\n+                match base.cat {\n+                    cat_upvar(Upvar{ id, .. }) => Some(AliasableClosure(id.closure_expr_id)),\n+                    _ => Some(AliasableBorrowed)\n+                }\n+            }\n+        }\n+    }\n+\n+    // Digs down through one or two layers of deref and grabs the cmt\n+    // for the upvar if a note indicates there is one.\n+    pub fn upvar(&self) -> Option<cmt> {\n+        match self.note {\n+            NoteClosureEnv(..) | NoteUpvarRef(..) => {\n+                Some(match self.cat {\n+                    cat_deref(ref inner, _, _) => {\n+                        match inner.cat {\n+                            cat_deref(ref inner, _, _) => inner.clone(),\n+                            cat_upvar(..) => inner.clone(),\n+                            _ => unreachable!()\n+                        }\n+                    }\n+                    _ => unreachable!()\n+                })\n             }\n+            NoteNone => None\n         }\n     }\n }\n@@ -1365,7 +1477,6 @@ impl Repr for categorization {\n         match *self {\n             cat_static_item |\n             cat_rvalue(..) |\n-            cat_copied_upvar(..) |\n             cat_local(..) |\n             cat_upvar(..) => {\n                 format!(\"{}\", *self)"}, {"sha": "0ff9f9f26e867d1e218d6d88696237940a30d810", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dec727297e6ebd6614219a93f376d8181ab11b1/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dec727297e6ebd6614219a93f376d8181ab11b1/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=3dec727297e6ebd6614219a93f376d8181ab11b1", "patch": "@@ -1270,7 +1270,7 @@ impl euv::Delegate for ReassignmentChecker {\n \n     fn mutate(&mut self, _: ast::NodeId, _: Span, cmt: mc::cmt, _: euv::MutateMode) {\n         match cmt.cat {\n-            mc::cat_copied_upvar(mc::CopiedUpvar { upvar_id: vid, .. }) |\n+            mc::cat_upvar(mc::Upvar { id: ty::UpvarId { var_id: vid, .. }, .. }) |\n             mc::cat_local(vid) => self.reassigned = self.node == vid,\n             _ => {}\n         }"}, {"sha": "832e9a79acae033fd1df34cdb84899206f3d20f7", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3dec727297e6ebd6614219a93f376d8181ab11b1/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dec727297e6ebd6614219a93f376d8181ab11b1/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=3dec727297e6ebd6614219a93f376d8181ab11b1", "patch": "@@ -863,6 +863,10 @@ pub enum BoundRegion {\n \n     /// Fresh bound identifiers created during GLB computations.\n     BrFresh(uint),\n+\n+    // Anonymous region for the implicit env pointer parameter\n+    // to a closure\n+    BrEnv\n }\n \n mod primitives {"}, {"sha": "b595b9b84aed875a0b3494262d3b6e3b711f0d2e", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 110, "deletions": 36, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/3dec727297e6ebd6614219a93f376d8181ab11b1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dec727297e6ebd6614219a93f376d8181ab11b1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=3dec727297e6ebd6614219a93f376d8181ab11b1", "patch": "@@ -140,7 +140,9 @@ use syntax::codemap::Span;\n use syntax::visit;\n use syntax::visit::Visitor;\n \n-use std::cell::RefCell;\n+use std::cell::{RefCell};\n+use std::collections::HashMap;\n+use std::collections::hashmap::{Vacant, Occupied};\n \n ///////////////////////////////////////////////////////////////////////////\n // PUBLIC ENTRY POINTS\n@@ -211,13 +213,30 @@ macro_rules! ignore_err(\n     )\n )\n \n+// Stores parameters for a potential call to link_region()\n+// to perform if an upvar reference is marked unique/mutable after\n+// it has already been processed before.\n+struct MaybeLink {\n+    span: Span,\n+    borrow_region: ty::Region,\n+    borrow_kind: ty::BorrowKind,\n+    borrow_cmt: mc::cmt\n+}\n+\n+// A map associating an upvar ID to a vector of the above\n+type MaybeLinkMap = RefCell<HashMap<ty::UpvarId, Vec<MaybeLink>>>;\n+\n pub struct Rcx<'a, 'tcx: 'a> {\n     fcx: &'a FnCtxt<'a, 'tcx>,\n \n     region_param_pairs: Vec<(ty::Region, ty::ParamTy)>,\n \n     // id of innermost fn or loop\n     repeating_scope: ast::NodeId,\n+\n+    // Possible region links we will establish if an upvar\n+    // turns out to be unique/mutable\n+    maybe_links: MaybeLinkMap\n }\n \n fn region_of_def(fcx: &FnCtxt, def: def::Def) -> ty::Region {\n@@ -250,7 +269,8 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n                initial_repeating_scope: ast::NodeId) -> Rcx<'a, 'tcx> {\n         Rcx { fcx: fcx,\n               repeating_scope: initial_repeating_scope,\n-              region_param_pairs: Vec::new() }\n+              region_param_pairs: Vec::new(),\n+              maybe_links: RefCell::new(HashMap::new()) }\n     }\n \n     pub fn tcx(&self) -> &'a ty::ctxt<'tcx> {\n@@ -848,14 +868,13 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n             });\n         }\n         ty::ty_unboxed_closure(_, region) => {\n-            let bounds = ty::region_existential_bound(region);\n             if tcx.capture_modes.borrow().get_copy(&expr.id) == ast::CaptureByRef {\n                 ty::with_freevars(tcx, expr.id, |freevars| {\n                     if !freevars.is_empty() {\n                         // Variables being referenced must be constrained and registered\n                         // in the upvar borrow map\n                         constrain_free_variables_in_by_ref_closure(\n-                            rcx, bounds.region_bound, expr, freevars);\n+                            rcx, region, expr, freevars);\n                     }\n                 })\n             }\n@@ -1463,7 +1482,8 @@ fn link_region(rcx: &Rcx,\n                           mc::BorrowedPtr(ref_kind, ref_region)) => {\n                 match link_reborrowed_region(rcx, span,\n                                              borrow_region, borrow_kind,\n-                                             ref_cmt, ref_region, ref_kind) {\n+                                             ref_cmt, ref_region, ref_kind,\n+                                             borrow_cmt.note) {\n                     Some((c, k)) => {\n                         borrow_cmt = c;\n                         borrow_kind = k;\n@@ -1486,9 +1506,8 @@ fn link_region(rcx: &Rcx,\n \n             mc::cat_deref(_, _, mc::UnsafePtr(..)) |\n             mc::cat_static_item |\n-            mc::cat_copied_upvar(..) |\n-            mc::cat_local(..) |\n             mc::cat_upvar(..) |\n+            mc::cat_local(..) |\n             mc::cat_rvalue(..) => {\n                 // These are all \"base cases\" with independent lifetimes\n                 // that are not subject to inference\n@@ -1504,7 +1523,8 @@ fn link_reborrowed_region(rcx: &Rcx,\n                           borrow_kind: ty::BorrowKind,\n                           ref_cmt: mc::cmt,\n                           ref_region: ty::Region,\n-                          ref_kind: ty::BorrowKind)\n+                          mut ref_kind: ty::BorrowKind,\n+                          note: mc::Note)\n                           -> Option<(mc::cmt, ty::BorrowKind)>\n {\n     /*!\n@@ -1550,20 +1570,28 @@ fn link_reborrowed_region(rcx: &Rcx,\n      * recurse and process `ref_cmt` (see case 2 above).\n      */\n \n-    // Detect references to an upvar `x`:\n-    let cause = match ref_cmt.cat {\n-        mc::cat_upvar(ref upvar_id, _, _) => {\n+    // Possible upvar ID we may need later to create an entry in the\n+    // maybe link map.\n+\n+    // Detect by-ref upvar `x`:\n+    let cause = match note {\n+        mc::NoteUpvarRef(ref upvar_id) => {\n             let mut upvar_borrow_map =\n                 rcx.fcx.inh.upvar_borrow_map.borrow_mut();\n             match upvar_borrow_map.find_mut(upvar_id) {\n                 Some(upvar_borrow) => {\n                     // Adjust mutability that we infer for the upvar\n                     // so it can accommodate being borrowed with\n                     // mutability `kind`:\n-                    adjust_upvar_borrow_kind_for_loan(*upvar_id,\n+                    adjust_upvar_borrow_kind_for_loan(rcx,\n+                                                      *upvar_id,\n                                                       upvar_borrow,\n                                                       borrow_kind);\n \n+                    // The mutability of the upvar may have been modified\n+                    // by the above adjustment, so update our local variable.\n+                    ref_kind = upvar_borrow.kind;\n+\n                     infer::ReborrowUpvar(span, *upvar_id)\n                 }\n                 None => {\n@@ -1575,7 +1603,12 @@ fn link_reborrowed_region(rcx: &Rcx,\n                 }\n             }\n         }\n-\n+        mc::NoteClosureEnv(ref upvar_id) => {\n+            // We don't have any mutability changes to propagate, but\n+            // we do want to note that an upvar reborrow caused this\n+            // link\n+            infer::ReborrowUpvar(span, *upvar_id)\n+        }\n         _ => {\n             infer::Reborrow(span)\n         }\n@@ -1586,6 +1619,21 @@ fn link_reborrowed_region(rcx: &Rcx,\n            ref_region.repr(rcx.tcx()));\n     rcx.fcx.mk_subr(cause, borrow_region, ref_region);\n \n+    // If we end up needing to recurse and establish a region link\n+    // with `ref_cmt`, calculate what borrow kind we will end up\n+    // needing. This will be used below.\n+    //\n+    // One interesting twist is that we can weaken the borrow kind\n+    // when we recurse: to reborrow an `&mut` referent as mutable,\n+    // borrowck requires a unique path to the `&mut` reference but not\n+    // necessarily a *mutable* path.\n+    let new_borrow_kind = match borrow_kind {\n+        ty::ImmBorrow =>\n+            ty::ImmBorrow,\n+        ty::MutBorrow | ty::UniqueImmBorrow =>\n+            ty::UniqueImmBorrow\n+    };\n+\n     // Decide whether we need to recurse and link any regions within\n     // the `ref_cmt`. This is concerned for the case where the value\n     // being reborrowed is in fact a borrowed pointer found within\n@@ -1624,23 +1672,36 @@ fn link_reborrowed_region(rcx: &Rcx,\n             // else the user is borrowed imm memory as mut memory,\n             // which means they'll get an error downstream in borrowck\n             // anyhow.)\n+            //\n+            // If mutability was inferred from an upvar, we may be\n+            // forced to revisit this decision later if processing\n+            // another borrow or nested closure ends up coverting the\n+            // upvar borrow kind to mutable/unique.  Record the\n+            // information needed to perform the recursive link in the\n+            // maybe link map.\n+            match note {\n+                mc::NoteUpvarRef(upvar_id) => {\n+                    let link = MaybeLink {\n+                        span: span,\n+                        borrow_region: borrow_region,\n+                        borrow_kind: new_borrow_kind,\n+                        borrow_cmt: ref_cmt\n+                    };\n+\n+                    match rcx.maybe_links.borrow_mut().entry(upvar_id) {\n+                        Vacant(entry) => { entry.set(vec![link]); }\n+                        Occupied(entry) => { entry.into_mut().push(link); }\n+                    }\n+                },\n+                _ => {}\n+            }\n+\n             return None;\n         }\n \n         ty::MutBorrow | ty::UniqueImmBorrow => {\n             // The reference being reborrowed is either an `&mut T` or\n             // `&uniq T`. This is the case where recursion is needed.\n-            //\n-            // One interesting twist is that we can weaken the borrow\n-            // kind when we recurse: to reborrow an `&mut` referent as\n-            // mutable, borrowck requires a unique path to the `&mut`\n-            // reference but not necessarily a *mutable* path.\n-            let new_borrow_kind = match borrow_kind {\n-                ty::ImmBorrow =>\n-                    ty::ImmBorrow,\n-                ty::MutBorrow | ty::UniqueImmBorrow =>\n-                    ty::UniqueImmBorrow\n-            };\n             return Some((ref_cmt, new_borrow_kind));\n         }\n     }\n@@ -1685,16 +1746,16 @@ fn adjust_upvar_borrow_kind_for_mut(rcx: &Rcx,\n \n             mc::cat_deref(base, _, mc::BorrowedPtr(..)) |\n             mc::cat_deref(base, _, mc::Implicit(..)) => {\n-                match base.cat {\n-                    mc::cat_upvar(ref upvar_id, _, _) => {\n+                match cmt.note {\n+                    mc::NoteUpvarRef(ref upvar_id) => {\n                         // if this is an implicit deref of an\n                         // upvar, then we need to modify the\n                         // borrow_kind of the upvar to make sure it\n                         // is inferred to mutable if necessary\n                         let mut upvar_borrow_map =\n                             rcx.fcx.inh.upvar_borrow_map.borrow_mut();\n                         let ub = upvar_borrow_map.get_mut(upvar_id);\n-                        return adjust_upvar_borrow_kind(*upvar_id, ub, ty::MutBorrow);\n+                        return adjust_upvar_borrow_kind(rcx, *upvar_id, ub, ty::MutBorrow);\n                     }\n \n                     _ => {}\n@@ -1710,7 +1771,6 @@ fn adjust_upvar_borrow_kind_for_mut(rcx: &Rcx,\n             mc::cat_deref(_, _, mc::UnsafePtr(..)) |\n             mc::cat_static_item |\n             mc::cat_rvalue(_) |\n-            mc::cat_copied_upvar(_) |\n             mc::cat_local(_) |\n             mc::cat_upvar(..) => {\n                 return;\n@@ -1738,15 +1798,15 @@ fn adjust_upvar_borrow_kind_for_unique(rcx: &Rcx, cmt: mc::cmt) {\n \n             mc::cat_deref(base, _, mc::BorrowedPtr(..)) |\n             mc::cat_deref(base, _, mc::Implicit(..)) => {\n-                match base.cat {\n-                    mc::cat_upvar(ref upvar_id, _, _) => {\n+                match cmt.note {\n+                    mc::NoteUpvarRef(ref upvar_id) => {\n                         // if this is an implicit deref of an\n                         // upvar, then we need to modify the\n                         // borrow_kind of the upvar to make sure it\n                         // is inferred to unique if necessary\n                         let mut ub = rcx.fcx.inh.upvar_borrow_map.borrow_mut();\n                         let ub = ub.get_mut(upvar_id);\n-                        return adjust_upvar_borrow_kind(*upvar_id, ub, ty::UniqueImmBorrow);\n+                        return adjust_upvar_borrow_kind(rcx, *upvar_id, ub, ty::UniqueImmBorrow);\n                     }\n \n                     _ => {}\n@@ -1760,7 +1820,6 @@ fn adjust_upvar_borrow_kind_for_unique(rcx: &Rcx, cmt: mc::cmt) {\n             mc::cat_deref(_, _, mc::UnsafePtr(..)) |\n             mc::cat_static_item |\n             mc::cat_rvalue(_) |\n-            mc::cat_copied_upvar(_) |\n             mc::cat_local(_) |\n             mc::cat_upvar(..) => {\n                 return;\n@@ -1786,22 +1845,24 @@ fn link_upvar_borrow_kind_for_nested_closures(rcx: &mut Rcx,\n     let inner_borrow = upvar_borrow_map.get_copy(&inner_upvar_id);\n     match upvar_borrow_map.find_mut(&outer_upvar_id) {\n         Some(outer_borrow) => {\n-            adjust_upvar_borrow_kind(outer_upvar_id, outer_borrow, inner_borrow.kind);\n+            adjust_upvar_borrow_kind(rcx, outer_upvar_id, outer_borrow, inner_borrow.kind);\n         }\n         None => { /* outer closure is not a stack closure */ }\n     }\n }\n \n-fn adjust_upvar_borrow_kind_for_loan(upvar_id: ty::UpvarId,\n+fn adjust_upvar_borrow_kind_for_loan(rcx: &Rcx,\n+                                     upvar_id: ty::UpvarId,\n                                      upvar_borrow: &mut ty::UpvarBorrow,\n                                      kind: ty::BorrowKind) {\n     debug!(\"adjust_upvar_borrow_kind_for_loan: upvar_id={} kind={} -> {}\",\n            upvar_id, upvar_borrow.kind, kind);\n \n-    adjust_upvar_borrow_kind(upvar_id, upvar_borrow, kind)\n+    adjust_upvar_borrow_kind(rcx, upvar_id, upvar_borrow, kind)\n }\n \n-fn adjust_upvar_borrow_kind(upvar_id: ty::UpvarId,\n+fn adjust_upvar_borrow_kind(rcx: &Rcx,\n+                            upvar_id: ty::UpvarId,\n                             upvar_borrow: &mut ty::UpvarBorrow,\n                             kind: ty::BorrowKind) {\n     /*!\n@@ -1821,6 +1882,19 @@ fn adjust_upvar_borrow_kind(upvar_id: ty::UpvarId,\n         (ty::ImmBorrow, ty::MutBorrow) |\n         (ty::UniqueImmBorrow, ty::MutBorrow) => {\n             upvar_borrow.kind = kind;\n+\n+            // Check if there are any region links we now need to\n+            // establish due to adjusting the borrow kind of the upvar\n+            match rcx.maybe_links.borrow_mut().entry(upvar_id) {\n+                Occupied(entry) => {\n+                    for MaybeLink { span, borrow_region,\n+                                    borrow_kind, borrow_cmt } in entry.take().into_iter()\n+                    {\n+                        link_region(rcx, span, borrow_region, borrow_kind, borrow_cmt);\n+                    }\n+                }\n+                Vacant(_) => {}\n+            }\n         }\n         // Take LHS:\n         (ty::ImmBorrow, ty::ImmBorrow) |"}, {"sha": "085295cad7d2a43d51ed799b7574028175bc9664", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3dec727297e6ebd6614219a93f376d8181ab11b1/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dec727297e6ebd6614219a93f376d8181ab11b1/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=3dec727297e6ebd6614219a93f376d8181ab11b1", "patch": "@@ -15,7 +15,7 @@ use middle::subst;\n use middle::ty::{BoundRegion, BrAnon, BrNamed};\n use middle::ty::{ReEarlyBound, BrFresh, ctxt};\n use middle::ty::{ReFree, ReScope, ReInfer, ReStatic, Region, ReEmpty};\n-use middle::ty::{ReSkolemized, ReVar};\n+use middle::ty::{ReSkolemized, ReVar, BrEnv};\n use middle::ty::{mt, t, ParamTy};\n use middle::ty::{ty_bool, ty_char, ty_bot, ty_struct, ty_enum};\n use middle::ty::{ty_err, ty_str, ty_vec, ty_float, ty_bare_fn, ty_closure};\n@@ -183,8 +183,7 @@ pub fn bound_region_to_string(cx: &ctxt,\n         BrNamed(_, name) => {\n             format!(\"{}{}{}\", prefix, token::get_name(name), space_str)\n         }\n-        BrAnon(_) => prefix.to_string(),\n-        BrFresh(_) => prefix.to_string(),\n+        BrAnon(_) | BrFresh(_) | BrEnv => prefix.to_string()\n     }\n }\n \n@@ -769,6 +768,7 @@ impl Repr for ty::BoundRegion {\n                 format!(\"BrNamed({}, {})\", id.repr(tcx), token::get_name(name))\n             }\n             ty::BrFresh(id) => format!(\"BrFresh({})\", id),\n+            ty::BrEnv => \"BrEnv\".to_string()\n         }\n     }\n }"}, {"sha": "f748c400654479f942be1ae08beeb10d40b0d67a", "filename": "src/test/compile-fail/borrow-immutable-upvar-mutation.rs", "status": "renamed", "additions": 9, "deletions": 18, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/3dec727297e6ebd6614219a93f376d8181ab11b1/src%2Ftest%2Fcompile-fail%2Fborrow-immutable-upvar-mutation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dec727297e6ebd6614219a93f376d8181ab11b1/src%2Ftest%2Fcompile-fail%2Fborrow-immutable-upvar-mutation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrow-immutable-upvar-mutation.rs?ref=3dec727297e6ebd6614219a93f376d8181ab11b1", "patch": "@@ -10,41 +10,32 @@\n \n #![feature(unboxed_closures, overloaded_calls)]\n \n+// Tests that we can't assign to or mutably borrow upvars from `Fn`\n+// closures (issue #17780)\n+\n fn set(x: &mut uint) { *x = 5; }\n \n fn main() {\n     // By-ref captures\n     {\n         let mut x = 0u;\n-        let _f = |&:| x = 42;\n-        //~^ ERROR cannot assign to data in a free\n-        // variable from an immutable unboxed closure\n+        let _f = |&:| x = 42; //~ ERROR cannot assign\n \n         let mut y = 0u;\n-        let _g = |&:| set(&mut y);\n-        //~^ ERROR cannot borrow data mutably in a free\n-        // variable from an immutable unboxed closure\n+        let _g = |&:| set(&mut y); //~ ERROR cannot borrow\n \n         let mut z = 0u;\n-        let _h = |&mut:| { set(&mut z); |&:| z = 42; };\n-        //~^ ERROR cannot assign to data in a\n-        // free variable from an immutable unboxed closure\n+        let _h = |&mut:| { set(&mut z); |&:| z = 42; }; //~ ERROR cannot assign\n     }\n     // By-value captures\n     {\n         let mut x = 0u;\n-        let _f = move |&:| x = 42;\n-        //~^ ERROR cannot assign to data in a free\n-        // variable from an immutable unboxed closure\n+        let _f = move |&:| x = 42; //~ ERROR cannot assign\n \n         let mut y = 0u;\n-        let _g = move |&:| set(&mut y);\n-        //~^ ERROR cannot borrow data mutably in a free\n-        // variable from an immutable unboxed closure\n+        let _g = move |&:| set(&mut y); //~ ERROR cannot borrow\n \n         let mut z = 0u;\n-        let _h = move |&mut:| { set(&mut z); move |&:| z = 42; };\n-        //~^ ERROR cannot assign to data in a free\n-        // variable from an immutable unboxed closure\n+        let _h = move |&mut:| { set(&mut z); move |&:| z = 42; }; //~ ERROR cannot assign\n     }\n }", "previous_filename": "src/test/compile-fail/issue-17780.rs"}, {"sha": "aedaced5794a784a9449be54262e31beab676478", "filename": "src/test/compile-fail/regions-return-ref-to-upvar-issue-17403.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/3dec727297e6ebd6614219a93f376d8181ab11b1/src%2Ftest%2Fcompile-fail%2Fregions-return-ref-to-upvar-issue-17403.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dec727297e6ebd6614219a93f376d8181ab11b1/src%2Ftest%2Fcompile-fail%2Fregions-return-ref-to-upvar-issue-17403.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-return-ref-to-upvar-issue-17403.rs?ref=3dec727297e6ebd6614219a93f376d8181ab11b1", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that closures cannot subvert aliasing restrictions\n+\n+#![feature(overloaded_calls, unboxed_closures)]\n+\n+fn main() {\n+    // Unboxed closure case\n+    {\n+        let mut x = 0u;\n+        let mut f = |&mut:| &mut x; //~ ERROR cannot infer\n+        let x = f();\n+        let y = f();\n+    }\n+    // Boxed closure case\n+    {\n+        let mut x = 0u;\n+        let f = || &mut x; //~ ERROR cannot infer\n+        let x = f();\n+        let y = f();\n+    }\n+}"}, {"sha": "9e981f2c9bb023fb4f18b62629e5b7b99aadfe65", "filename": "src/test/compile-fail/unboxed-closure-illegal-move.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/3dec727297e6ebd6614219a93f376d8181ab11b1/src%2Ftest%2Fcompile-fail%2Funboxed-closure-illegal-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dec727297e6ebd6614219a93f376d8181ab11b1/src%2Ftest%2Fcompile-fail%2Funboxed-closure-illegal-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-illegal-move.rs?ref=3dec727297e6ebd6614219a93f376d8181ab11b1", "patch": "@@ -0,0 +1,44 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(unboxed_closures)]\n+\n+// Tests that we can't move out of an unboxed closure environment\n+// if the upvar is captured by ref or the closure takes self by\n+// reference.\n+\n+fn main() {\n+    // By-ref cases\n+    {\n+        let x = box 0u;\n+        let f = |&:| drop(x); //~ cannot move\n+    }\n+    {\n+        let x = box 0u;\n+        let f = |&mut:| drop(x); //~ cannot move\n+    }\n+    {\n+        let x = box 0u;\n+        let f = |:| drop(x); //~ cannot move\n+    }\n+    // By-value cases\n+    {\n+        let x = box 0u;\n+        let f = move |&:| drop(x); //~ cannot move\n+    }\n+    {\n+        let x = box 0u;\n+        let f = move |&mut:| drop(x); //~ cannot move\n+    }\n+    {\n+        let x = box 0u;\n+        let f = move |:| drop(x); // this one is ok\n+    }\n+}"}]}