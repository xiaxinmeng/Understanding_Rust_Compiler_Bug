{"sha": "10c495643a849d38ced1256382e8b04d2376b19c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEwYzQ5NTY0M2E4NDlkMzhjZWQxMjU2MzgyZThiMDRkMjM3NmIxOWM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-05-22T12:56:51Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-05-22T12:56:51Z"}, "message": "Auto merge of #1811 - RalfJung:less-rc, r=RalfJung\n\nget rid of some `Rc`\n\nNow that the memory access hooks get references to `MemoryExtra`, we can avoid refcounting for the global state of Stacked Borrows and the data race detector.", "tree": {"sha": "8db7df2a90c8c7ceb2d7a05017c98a38015c86e2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8db7df2a90c8c7ceb2d7a05017c98a38015c86e2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/10c495643a849d38ced1256382e8b04d2376b19c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/10c495643a849d38ced1256382e8b04d2376b19c", "html_url": "https://github.com/rust-lang/rust/commit/10c495643a849d38ced1256382e8b04d2376b19c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/10c495643a849d38ced1256382e8b04d2376b19c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3a249581280ea0181cf3ae0d2028ee8b88d3d1e4", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a249581280ea0181cf3ae0d2028ee8b88d3d1e4", "html_url": "https://github.com/rust-lang/rust/commit/3a249581280ea0181cf3ae0d2028ee8b88d3d1e4"}, {"sha": "c73f8b1097e9e5d01baa56df9bb4cd93f3828fd4", "url": "https://api.github.com/repos/rust-lang/rust/commits/c73f8b1097e9e5d01baa56df9bb4cd93f3828fd4", "html_url": "https://github.com/rust-lang/rust/commit/c73f8b1097e9e5d01baa56df9bb4cd93f3828fd4"}], "stats": {"total": 167, "additions": 92, "deletions": 75}, "files": [{"sha": "16ab03ace2228249dd7026e65e5c91266b2e039c", "filename": "src/data_race.rs", "status": "modified", "additions": 31, "deletions": 28, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/10c495643a849d38ced1256382e8b04d2376b19c/src%2Fdata_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10c495643a849d38ced1256382e8b04d2376b19c/src%2Fdata_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdata_race.rs?ref=10c495643a849d38ced1256382e8b04d2376b19c", "patch": "@@ -65,7 +65,6 @@ use std::{\n     cell::{Cell, Ref, RefCell, RefMut},\n     fmt::Debug,\n     mem,\n-    rc::Rc,\n };\n \n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n@@ -80,7 +79,7 @@ use crate::{\n };\n \n pub type AllocExtra = VClockAlloc;\n-pub type MemoryExtra = Rc<GlobalState>;\n+pub type MemoryExtra = GlobalState;\n \n /// Valid atomic read-write operations, alias of atomic::Ordering (not non-exhaustive).\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n@@ -488,7 +487,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n     ) -> InterpResult<'tcx, ScalarMaybeUninit<Tag>> {\n         let this = self.eval_context_ref();\n         let scalar = this.allow_data_races_ref(move |this| this.read_scalar(&place.into()))?;\n-        self.validate_atomic_load(place, atomic)?;\n+        this.validate_atomic_load(place, atomic)?;\n         Ok(scalar)\n     }\n \n@@ -501,7 +500,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         this.allow_data_races_mut(move |this| this.write_scalar(val, &(*dest).into()))?;\n-        self.validate_atomic_store(dest, atomic)\n+        this.validate_atomic_store(dest, atomic)\n     }\n \n     /// Perform a atomic operation on a memory location.\n@@ -733,9 +732,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n pub struct VClockAlloc {\n     /// Assigning each byte a MemoryCellClocks.\n     alloc_ranges: RefCell<RangeMap<MemoryCellClocks>>,\n-\n-    /// Pointer to global state.\n-    global: MemoryExtra,\n }\n \n impl VClockAlloc {\n@@ -767,7 +763,6 @@ impl VClockAlloc {\n             | MemoryKind::Vtable => (0, VectorIdx::MAX_INDEX),\n         };\n         VClockAlloc {\n-            global: Rc::clone(global),\n             alloc_ranges: RefCell::new(RangeMap::new(\n                 len,\n                 MemoryCellClocks::new(alloc_timestamp, alloc_index),\n@@ -888,21 +883,19 @@ impl VClockAlloc {\n     /// being created or if it is temporarily disabled during a racy read or write\n     /// operation for which data-race detection is handled separately, for example\n     /// atomic read operations.\n-    pub fn read<'tcx>(&self, pointer: Pointer<Tag>, len: Size) -> InterpResult<'tcx> {\n-        if self.global.multi_threaded.get() {\n-            let (index, clocks) = self.global.current_thread_state();\n+    pub fn read<'tcx>(\n+        &self,\n+        pointer: Pointer<Tag>,\n+        len: Size,\n+        global: &GlobalState,\n+    ) -> InterpResult<'tcx> {\n+        if global.multi_threaded.get() {\n+            let (index, clocks) = global.current_thread_state();\n             let mut alloc_ranges = self.alloc_ranges.borrow_mut();\n             for (_, range) in alloc_ranges.iter_mut(pointer.offset, len) {\n                 if let Err(DataRace) = range.read_race_detect(&*clocks, index) {\n                     // Report data-race.\n-                    return Self::report_data_race(\n-                        &self.global,\n-                        range,\n-                        \"Read\",\n-                        false,\n-                        pointer,\n-                        len,\n-                    );\n+                    return Self::report_data_race(global, range, \"Read\", false, pointer, len);\n                 }\n             }\n             Ok(())\n@@ -917,14 +910,15 @@ impl VClockAlloc {\n         pointer: Pointer<Tag>,\n         len: Size,\n         write_type: WriteType,\n+        global: &mut GlobalState,\n     ) -> InterpResult<'tcx> {\n-        if self.global.multi_threaded.get() {\n-            let (index, clocks) = self.global.current_thread_state();\n+        if global.multi_threaded.get() {\n+            let (index, clocks) = global.current_thread_state();\n             for (_, range) in self.alloc_ranges.get_mut().iter_mut(pointer.offset, len) {\n                 if let Err(DataRace) = range.write_race_detect(&*clocks, index, write_type) {\n                     // Report data-race\n                     return Self::report_data_race(\n-                        &self.global,\n+                        global,\n                         range,\n                         write_type.get_descriptor(),\n                         false,\n@@ -943,16 +937,26 @@ impl VClockAlloc {\n     /// data-race threads if `multi-threaded` is false, either due to no threads\n     /// being created or if it is temporarily disabled during a racy read or write\n     /// operation\n-    pub fn write<'tcx>(&mut self, pointer: Pointer<Tag>, len: Size) -> InterpResult<'tcx> {\n-        self.unique_access(pointer, len, WriteType::Write)\n+    pub fn write<'tcx>(\n+        &mut self,\n+        pointer: Pointer<Tag>,\n+        len: Size,\n+        global: &mut GlobalState,\n+    ) -> InterpResult<'tcx> {\n+        self.unique_access(pointer, len, WriteType::Write, global)\n     }\n \n     /// Detect data-races for an unsynchronized deallocate operation, will not perform\n     /// data-race threads if `multi-threaded` is false, either due to no threads\n     /// being created or if it is temporarily disabled during a racy read or write\n     /// operation\n-    pub fn deallocate<'tcx>(&mut self, pointer: Pointer<Tag>, len: Size) -> InterpResult<'tcx> {\n-        self.unique_access(pointer, len, WriteType::Deallocate)\n+    pub fn deallocate<'tcx>(\n+        &mut self,\n+        pointer: Pointer<Tag>,\n+        len: Size,\n+        global: &mut GlobalState,\n+    ) -> InterpResult<'tcx> {\n+        self.unique_access(pointer, len, WriteType::Deallocate, global)\n     }\n }\n \n@@ -1035,15 +1039,14 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n                 );\n \n                 // Perform the atomic operation.\n-                let data_race = &alloc_meta.global;\n                 data_race.maybe_perform_sync_operation(|index, mut clocks| {\n                     for (_, range) in\n                         alloc_meta.alloc_ranges.borrow_mut().iter_mut(place_ptr.offset, size)\n                     {\n                         if let Err(DataRace) = op(range, &mut *clocks, index, atomic) {\n                             mem::drop(clocks);\n                             return VClockAlloc::report_data_race(\n-                                &alloc_meta.global,\n+                                data_race,\n                                 range,\n                                 description,\n                                 true,"}, {"sha": "fb2d877c3803992779ceaa3c519014f979742703", "filename": "src/machine.rs", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/10c495643a849d38ced1256382e8b04d2376b19c/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10c495643a849d38ced1256382e8b04d2376b19c/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=10c495643a849d38ced1256382e8b04d2376b19c", "patch": "@@ -5,7 +5,6 @@ use std::borrow::Cow;\n use std::cell::RefCell;\n use std::fmt;\n use std::num::NonZeroU64;\n-use std::rc::Rc;\n use std::time::Instant;\n \n use log::trace;\n@@ -116,7 +115,7 @@ pub struct AllocExtra {\n }\n \n /// Extra global memory data\n-#[derive(Clone, Debug)]\n+#[derive(Debug)]\n pub struct MemoryExtra {\n     pub stacked_borrows: Option<stacked_borrows::MemoryExtra>,\n     pub data_race: Option<data_race::MemoryExtra>,\n@@ -144,19 +143,16 @@ impl MemoryExtra {\n     pub fn new(config: &MiriConfig) -> Self {\n         let rng = StdRng::seed_from_u64(config.seed.unwrap_or(0));\n         let stacked_borrows = if config.stacked_borrows {\n-            Some(Rc::new(RefCell::new(stacked_borrows::GlobalState::new(\n+            Some(RefCell::new(stacked_borrows::GlobalState::new(\n                 config.tracked_pointer_tag,\n                 config.tracked_call_id,\n                 config.track_raw,\n-            ))))\n-        } else {\n-            None\n-        };\n-        let data_race = if config.data_race_detector {\n-            Some(Rc::new(data_race::GlobalState::new()))\n+            )))\n         } else {\n             None\n         };\n+        let data_race =\n+            if config.data_race_detector { Some(data_race::GlobalState::new()) } else { None };\n         MemoryExtra {\n             stacked_borrows,\n             data_race,\n@@ -478,7 +474,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n         let alloc = alloc.into_owned();\n         let (stacks, base_tag) = if let Some(stacked_borrows) = &memory_extra.stacked_borrows {\n             let (stacks, base_tag) =\n-                Stacks::new_allocation(id, alloc.size(), Rc::clone(stacked_borrows), kind);\n+                Stacks::new_allocation(id, alloc.size(), stacked_borrows, kind);\n             (Some(stacks), base_tag)\n         } else {\n             // No stacks, no tag.\n@@ -507,33 +503,37 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n \n     #[inline(always)]\n     fn memory_read(\n-        _memory_extra: &Self::MemoryExtra,\n+        memory_extra: &Self::MemoryExtra,\n         alloc_extra: &AllocExtra,\n         ptr: Pointer<Tag>,\n         size: Size,\n     ) -> InterpResult<'tcx> {\n         if let Some(data_race) = &alloc_extra.data_race {\n-            data_race.read(ptr, size)?;\n+            data_race.read(ptr, size, memory_extra.data_race.as_ref().unwrap())?;\n         }\n         if let Some(stacked_borrows) = &alloc_extra.stacked_borrows {\n-            stacked_borrows.memory_read(ptr, size)\n+            stacked_borrows.memory_read(ptr, size, memory_extra.stacked_borrows.as_ref().unwrap())\n         } else {\n             Ok(())\n         }\n     }\n \n     #[inline(always)]\n     fn memory_written(\n-        _memory_extra: &mut Self::MemoryExtra,\n+        memory_extra: &mut Self::MemoryExtra,\n         alloc_extra: &mut AllocExtra,\n         ptr: Pointer<Tag>,\n         size: Size,\n     ) -> InterpResult<'tcx> {\n         if let Some(data_race) = &mut alloc_extra.data_race {\n-            data_race.write(ptr, size)?;\n+            data_race.write(ptr, size, memory_extra.data_race.as_mut().unwrap())?;\n         }\n         if let Some(stacked_borrows) = &mut alloc_extra.stacked_borrows {\n-            stacked_borrows.memory_written(ptr, size)\n+            stacked_borrows.memory_written(\n+                ptr,\n+                size,\n+                memory_extra.stacked_borrows.as_mut().unwrap(),\n+            )\n         } else {\n             Ok(())\n         }\n@@ -550,10 +550,14 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n             register_diagnostic(NonHaltingDiagnostic::FreedAlloc(ptr.alloc_id));\n         }\n         if let Some(data_race) = &mut alloc_extra.data_race {\n-            data_race.deallocate(ptr, size)?;\n+            data_race.deallocate(ptr, size, memory_extra.data_race.as_mut().unwrap())?;\n         }\n         if let Some(stacked_borrows) = &mut alloc_extra.stacked_borrows {\n-            stacked_borrows.memory_deallocated(ptr, size)\n+            stacked_borrows.memory_deallocated(\n+                ptr,\n+                size,\n+                memory_extra.stacked_borrows.as_mut().unwrap(),\n+            )\n         } else {\n             Ok(())\n         }"}, {"sha": "a9c030c87de4ed94f929d3f11de5837123130ec2", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 36, "deletions": 22, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/10c495643a849d38ced1256382e8b04d2376b19c/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10c495643a849d38ced1256382e8b04d2376b19c/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=10c495643a849d38ced1256382e8b04d2376b19c", "patch": "@@ -1,12 +1,10 @@\n //! Implements \"Stacked Borrows\".  See <https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md>\n //! for further information.\n \n+use log::trace;\n use std::cell::RefCell;\n use std::fmt;\n use std::num::NonZeroU64;\n-use std::rc::Rc;\n-\n-use log::trace;\n \n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir::Mutability;\n@@ -87,8 +85,6 @@ pub struct Stack {\n pub struct Stacks {\n     // Even reading memory can have effects on the stack, so we need a `RefCell` here.\n     stacks: RefCell<RangeMap<Stack>>,\n-    // Pointer to global state\n-    global: MemoryExtra,\n }\n \n /// Extra global state, available to the memory access hooks.\n@@ -112,7 +108,7 @@ pub struct GlobalState {\n     track_raw: bool,\n }\n /// Memory extra state gives us interior mutable access to the global state.\n-pub type MemoryExtra = Rc<RefCell<GlobalState>>;\n+pub type MemoryExtra = RefCell<GlobalState>;\n \n /// Indicates which kind of access is being performed.\n #[derive(Copy, Clone, Hash, PartialEq, Eq)]\n@@ -449,21 +445,21 @@ impl<'tcx> Stack {\n /// Map per-stack operations to higher-level per-location-range operations.\n impl<'tcx> Stacks {\n     /// Creates new stack with initial tag.\n-    fn new(size: Size, perm: Permission, tag: Tag, extra: MemoryExtra) -> Self {\n+    fn new(size: Size, perm: Permission, tag: Tag) -> Self {\n         let item = Item { perm, tag, protector: None };\n         let stack = Stack { borrows: vec![item] };\n \n-        Stacks { stacks: RefCell::new(RangeMap::new(size, stack)), global: extra }\n+        Stacks { stacks: RefCell::new(RangeMap::new(size, stack)) }\n     }\n \n     /// Call `f` on every stack in the range.\n     fn for_each(\n         &self,\n         ptr: Pointer<Tag>,\n         size: Size,\n+        global: &GlobalState,\n         f: impl Fn(Pointer<Tag>, &mut Stack, &GlobalState) -> InterpResult<'tcx>,\n     ) -> InterpResult<'tcx> {\n-        let global = self.global.borrow();\n         let mut stacks = self.stacks.borrow_mut();\n         for (offset, stack) in stacks.iter_mut(ptr.offset, size) {\n             let mut cur_ptr = ptr;\n@@ -479,16 +475,17 @@ impl Stacks {\n     pub fn new_allocation(\n         id: AllocId,\n         size: Size,\n-        extra: MemoryExtra,\n+        extra: &MemoryExtra,\n         kind: MemoryKind<MiriMemoryKind>,\n     ) -> (Self, Tag) {\n+        let mut extra = extra.borrow_mut();\n         let (tag, perm) = match kind {\n             // New unique borrow. This tag is not accessible by the program,\n             // so it will only ever be used when using the local directly (i.e.,\n             // not through a pointer). That is, whenever we directly write to a local, this will pop\n             // everything else off the stack, invalidating all previous pointers,\n             // and in particular, *all* raw pointers.\n-            MemoryKind::Stack => (Tag::Tagged(extra.borrow_mut().new_ptr()), Permission::Unique),\n+            MemoryKind::Stack => (Tag::Tagged(extra.new_ptr()), Permission::Unique),\n             // `Global` memory can be referenced by global pointers from `tcx`.\n             // Thus we call `global_base_ptr` such that the global pointers get the same tag\n             // as what we use here.\n@@ -500,38 +497,52 @@ impl Stacks {\n                 | MiriMemoryKind::ExternStatic\n                 | MiriMemoryKind::Tls\n                 | MiriMemoryKind::Env,\n-            ) => (extra.borrow_mut().global_base_ptr(id), Permission::SharedReadWrite),\n+            ) => (extra.global_base_ptr(id), Permission::SharedReadWrite),\n             // Everything else we handle like raw pointers for now.\n             _ => {\n-                let mut extra = extra.borrow_mut();\n                 let tag =\n                     if extra.track_raw { Tag::Tagged(extra.new_ptr()) } else { Tag::Untagged };\n                 (tag, Permission::SharedReadWrite)\n             }\n         };\n-        (Stacks::new(size, perm, tag, extra), tag)\n+        (Stacks::new(size, perm, tag), tag)\n     }\n \n     #[inline(always)]\n-    pub fn memory_read<'tcx>(&self, ptr: Pointer<Tag>, size: Size) -> InterpResult<'tcx> {\n+    pub fn memory_read<'tcx>(\n+        &self,\n+        ptr: Pointer<Tag>,\n+        size: Size,\n+        extra: &MemoryExtra,\n+    ) -> InterpResult<'tcx> {\n         trace!(\"read access with tag {:?}: {:?}, size {}\", ptr.tag, ptr.erase_tag(), size.bytes());\n-        self.for_each(ptr, size, |ptr, stack, global| stack.access(AccessKind::Read, ptr, global))\n+        self.for_each(ptr, size, &*extra.borrow(), |ptr, stack, global| {\n+            stack.access(AccessKind::Read, ptr, global)\n+        })\n     }\n \n     #[inline(always)]\n-    pub fn memory_written<'tcx>(&mut self, ptr: Pointer<Tag>, size: Size) -> InterpResult<'tcx> {\n+    pub fn memory_written<'tcx>(\n+        &mut self,\n+        ptr: Pointer<Tag>,\n+        size: Size,\n+        extra: &mut MemoryExtra,\n+    ) -> InterpResult<'tcx> {\n         trace!(\"write access with tag {:?}: {:?}, size {}\", ptr.tag, ptr.erase_tag(), size.bytes());\n-        self.for_each(ptr, size, |ptr, stack, global| stack.access(AccessKind::Write, ptr, global))\n+        self.for_each(ptr, size, extra.get_mut(), |ptr, stack, global| {\n+            stack.access(AccessKind::Write, ptr, global)\n+        })\n     }\n \n     #[inline(always)]\n     pub fn memory_deallocated<'tcx>(\n         &mut self,\n         ptr: Pointer<Tag>,\n         size: Size,\n+        extra: &mut MemoryExtra,\n     ) -> InterpResult<'tcx> {\n         trace!(\"deallocation with tag {:?}: {:?}, size {}\", ptr.tag, ptr.erase_tag(), size.bytes());\n-        self.for_each(ptr, size, |ptr, stack, global| stack.dealloc(ptr, global))\n+        self.for_each(ptr, size, extra.get_mut(), |ptr, stack, global| stack.dealloc(ptr, global))\n     }\n }\n \n@@ -560,10 +571,12 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             size.bytes()\n         );\n \n-        // Get the allocation. It might not be mutable, so we cannot use `get_mut`.\n+        // Get the allocation. We need both the allocation and the MemoryExtra, so we cannot use `&mut`.\n+        // FIXME: make `get_alloc_extra_mut` also return `&mut MemoryExtra`.\n         let extra = this.memory.get_alloc_extra(ptr.alloc_id)?;\n         let stacked_borrows =\n             extra.stacked_borrows.as_ref().expect(\"we should have Stacked Borrows data\");\n+        let global = this.memory.extra.stacked_borrows.as_ref().unwrap().borrow();\n         // Update the stacks.\n         // Make sure that raw pointers and mutable shared references are reborrowed \"weak\":\n         // There could be existing unique pointers reborrowed from them that should remain valid!\n@@ -583,14 +596,15 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                         Permission::SharedReadWrite\n                     };\n                     let item = Item { perm, tag: new_tag, protector };\n-                    stacked_borrows.for_each(cur_ptr, size, |cur_ptr, stack, global| {\n+                    stacked_borrows.for_each(cur_ptr, size, &*global, |cur_ptr, stack, global| {\n                         stack.grant(cur_ptr, item, global)\n                     })\n                 });\n             }\n         };\n         let item = Item { perm, tag: new_tag, protector };\n-        stacked_borrows.for_each(ptr, size, |ptr, stack, global| stack.grant(ptr, item, global))\n+        stacked_borrows\n+            .for_each(ptr, size, &*global, |ptr, stack, global| stack.grant(ptr, item, global))\n     }\n \n     /// Retags an indidual pointer, returning the retagged version."}, {"sha": "3418e8c7d2bfdf9ce63522b418c86bbee05e689e", "filename": "src/thread.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/10c495643a849d38ced1256382e8b04d2376b19c/src%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10c495643a849d38ced1256382e8b04d2376b19c/src%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fthread.rs?ref=10c495643a849d38ced1256382e8b04d2376b19c", "patch": "@@ -4,7 +4,6 @@ use std::cell::RefCell;\n use std::collections::hash_map::Entry;\n use std::convert::TryFrom;\n use std::num::TryFromIntError;\n-use std::rc::Rc;\n use std::time::{Duration, Instant, SystemTime};\n \n use log::trace;\n@@ -333,7 +332,7 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n     fn join_thread(\n         &mut self,\n         joined_thread_id: ThreadId,\n-        data_race: &Option<Rc<data_race::GlobalState>>,\n+        data_race: &Option<data_race::GlobalState>,\n     ) -> InterpResult<'tcx> {\n         if self.threads[joined_thread_id].join_status != ThreadJoinStatus::Joinable {\n             throw_ub_format!(\"trying to join a detached or already joined thread\");\n@@ -437,10 +436,7 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n \n     /// Wakes up threads joining on the active one and deallocates thread-local statics.\n     /// The `AllocId` that can now be freed is returned.\n-    fn thread_terminated(\n-        &mut self,\n-        data_race: &Option<Rc<data_race::GlobalState>>,\n-    ) -> Vec<AllocId> {\n+    fn thread_terminated(&mut self, data_race: &Option<data_race::GlobalState>) -> Vec<AllocId> {\n         let mut free_tls_statics = Vec::new();\n         {\n             let mut thread_local_statics = self.thread_local_alloc_ids.borrow_mut();\n@@ -481,7 +477,7 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n     /// blocked, terminated, or has explicitly asked to be preempted).\n     fn schedule(\n         &mut self,\n-        data_race: &Option<Rc<data_race::GlobalState>>,\n+        data_race: &Option<data_race::GlobalState>,\n     ) -> InterpResult<'tcx, SchedulingAction> {\n         // Check whether the thread has **just** terminated (`check_terminated`\n         // checks whether the thread has popped all its stack and if yes, sets"}]}