{"sha": "4a78f9b16620489855da93c19be56f59431416f6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRhNzhmOWIxNjYyMDQ4OTg1NWRhOTNjMTliZTU2ZjU5NDMxNDE2ZjY=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-09-22T02:37:57Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-09-24T00:15:00Z"}, "message": "core: Demode option", "tree": {"sha": "4b164738698203f474003682d5f0a5e23aa13377", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4b164738698203f474003682d5f0a5e23aa13377"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4a78f9b16620489855da93c19be56f59431416f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4a78f9b16620489855da93c19be56f59431416f6", "html_url": "https://github.com/rust-lang/rust/commit/4a78f9b16620489855da93c19be56f59431416f6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4a78f9b16620489855da93c19be56f59431416f6/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "92752a462a055d6478bd96dab37a740514992106", "url": "https://api.github.com/repos/rust-lang/rust/commits/92752a462a055d6478bd96dab37a740514992106", "html_url": "https://github.com/rust-lang/rust/commit/92752a462a055d6478bd96dab37a740514992106"}], "stats": {"total": 638, "additions": 325, "deletions": 313}, "files": [{"sha": "c4bf1878f9db1db7bf4a789ecaf56c1abc09dc72", "filename": "src/cargo/cargo.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4a78f9b16620489855da93c19be56f59431416f6/src%2Fcargo%2Fcargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a78f9b16620489855da93c19be56f59431416f6/src%2Fcargo%2Fcargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcargo%2Fcargo.rs?ref=4a78f9b16620489855da93c19be56f59431416f6", "patch": "@@ -805,7 +805,7 @@ fn install_one_crate(c: &cargo, path: &Path, cf: &Path) {\n         if (exec_suffix != ~\"\" && str::ends_with(ct.to_str(),\n                                                  exec_suffix)) ||\n             (exec_suffix == ~\"\" &&\n-             !str::starts_with(option::get(ct.filename()),\n+             !str::starts_with(ct.filename().get(),\n                                ~\"lib\")) {\n             debug!(\"  bin: %s\", ct.to_str());\n             install_to_dir(*ct, &c.bindir);\n@@ -874,8 +874,8 @@ fn install_source(c: &cargo, path: &Path) {\n \n fn install_git(c: &cargo, wd: &Path, url: ~str, reference: Option<~str>) {\n     run::program_output(~\"git\", ~[~\"clone\", url, wd.to_str()]);\n-    if option::is_some(reference) {\n-        let r = option::get(reference);\n+    if reference.is_some() {\n+        let r = reference.get();\n         os::change_dir(wd);\n         run::run_program(~\"git\", ~[~\"checkout\", r]);\n     }\n@@ -1597,7 +1597,7 @@ fn cmd_search(c: &cargo) {\n }\n \n fn install_to_dir(srcfile: &Path, destdir: &Path) {\n-    let newfile = destdir.push(option::get(srcfile.filename()));\n+    let newfile = destdir.push(srcfile.filename().get());\n \n     let status = run::run_program(~\"cp\", ~[~\"-r\", srcfile.to_str(),\n                                            newfile.to_str()]);"}, {"sha": "1e6c008421d49780574c91670a1cdb32638692e3", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4a78f9b16620489855da93c19be56f59431416f6/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a78f9b16620489855da93c19be56f59431416f6/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=4a78f9b16620489855da93c19be56f59431416f6", "patch": "@@ -56,7 +56,7 @@ fn parse_config(args: ~[~str]) -> config {\n              if vec::len(matches.free) > 0u {\n                  option::Some(matches.free[0])\n              } else { option::None },\n-         logfile: option::map(getopts::opt_maybe_str(matches,\n+         logfile: option::map(&getopts::opt_maybe_str(matches,\n                                                      ~\"logfile\"),\n                               |s| Path(s)),\n          runtool: getopts::opt_maybe_str(matches, ~\"runtool\"),\n@@ -155,7 +155,7 @@ fn is_test(config: config, testfile: &Path) -> bool {\n           _ => ~[~\".rc\", ~\".rs\"]\n         };\n     let invalid_prefixes = ~[~\".\", ~\"#\", ~\"~\"];\n-    let name = option::get(testfile.filename());\n+    let name = testfile.filename().get();\n \n     let mut valid = false;\n "}, {"sha": "4ff1b8e9c7887746eb6e5bd6947bb59d6ae72b5d", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4a78f9b16620489855da93c19be56f59431416f6/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a78f9b16620489855da93c19be56f59431416f6/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=4a78f9b16620489855da93c19be56f59431416f6", "patch": "@@ -32,19 +32,19 @@ fn load_props(testfile: &Path) -> test_props {\n           option::None => ()\n         };\n \n-        if option::is_none(compile_flags) {\n+        if compile_flags.is_none() {\n             compile_flags = parse_compile_flags(ln);\n         }\n \n-        if option::is_none(pp_exact) {\n+        if pp_exact.is_none() {\n             pp_exact = parse_pp_exact(ln, testfile);\n         }\n \n-        do option::iter(parse_aux_build(ln)) |ab| {\n+        do parse_aux_build(ln).iter |ab| {\n             vec::push(aux_builds, ab);\n         }\n \n-        do option::iter(parse_exec_env(ln)) |ee| {\n+        do parse_exec_env(ln).iter |ee| {\n             vec::push(exec_env, ee);\n         }\n     };"}, {"sha": "d62f2fe5837ff43717a0b0c2f3d56f0747f76b75", "filename": "src/compiletest/procsrv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4a78f9b16620489855da93c19be56f59431416f6/src%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a78f9b16620489855da93c19be56f59431416f6/src%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fprocsrv.rs?ref=4a78f9b16620489855da93c19be56f59431416f6", "patch": "@@ -89,9 +89,9 @@ fn run(lib_path: ~str,\n }\n \n fn writeclose(fd: c_int, s: Option<~str>) {\n-    if option::is_some(s) {\n+    if s.is_some() {\n         let writer = io::fd_writer(fd, false);\n-        writer.write_str(option::get(s));\n+        writer.write_str(s.get());\n     }\n \n     os::close(fd);"}, {"sha": "1c69e51113751f1298d30bfa1b7c625d3bdac14a", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4a78f9b16620489855da93c19be56f59431416f6/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a78f9b16620489855da93c19be56f59431416f6/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=4a78f9b16620489855da93c19be56f59431416f6", "patch": "@@ -102,7 +102,7 @@ fn run_rpass_test(config: config, props: test_props, testfile: &Path) {\n }\n \n fn run_pretty_test(config: config, props: test_props, testfile: &Path) {\n-    if option::is_some(props.pp_exact) {\n+    if props.pp_exact.is_some() {\n         logv(config, ~\"testing for exact pretty-printing\");\n     } else { logv(config, ~\"testing for converging pretty-printing\"); }\n \n@@ -135,7 +135,7 @@ fn run_pretty_test(config: config, props: test_props, testfile: &Path) {\n         };\n     let mut actual = srcs[vec::len(srcs) - 1u];\n \n-    if option::is_some(props.pp_exact) {\n+    if props.pp_exact.is_some() {\n         // Now we have to care about line endings\n         let cr = ~\"\\r\";\n         actual = str::replace(actual, cr, ~\"\");\n@@ -575,7 +575,7 @@ fn aux_output_dir_name(config: config, testfile: &Path) -> Path {\n }\n \n fn output_testname(testfile: &Path) -> Path {\n-    Path(option::get(testfile.filestem()))\n+    Path(testfile.filestem().get())\n }\n \n fn output_base_name(config: config, testfile: &Path) -> Path {"}, {"sha": "cb1c04434f41f311c08fd359a73bc655caac45e7", "filename": "src/fuzzer/fuzzer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4a78f9b16620489855da93c19be56f59431416f6/src%2Ffuzzer%2Ffuzzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a78f9b16620489855da93c19be56f59431416f6/src%2Ffuzzer%2Ffuzzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Ffuzzer.rs?ref=4a78f9b16620489855da93c19be56f59431416f6", "patch": "@@ -305,7 +305,7 @@ fn check_variants_T<T: Copy>(\n }\n \n fn last_part(filename: ~str) -> ~str {\n-  let ix = option::get(str::rfind_char(filename, '/'));\n+  let ix = option::get(&str::rfind_char(filename, '/'));\n   str::slice(filename, ix + 1u, str::len(filename) - 3u)\n }\n "}, {"sha": "e997d1f13edbe3732a58db233b0fb95a0909677d", "filename": "src/libcore/dlist.rs", "status": "modified", "additions": 26, "deletions": 18, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/4a78f9b16620489855da93c19be56f59431416f6/src%2Flibcore%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a78f9b16620489855da93c19be56f59431416f6/src%2Flibcore%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdlist.rs?ref=4a78f9b16620489855da93c19be56f59431416f6", "patch": "@@ -211,7 +211,7 @@ impl<T> DList<T> {\n     fn push_head_n(+data: T) -> DListNode<T> {\n         let mut nobe = self.new_link(move data);\n         self.add_head(nobe);\n-        option::get(nobe)\n+        option::get(&nobe)\n     }\n     /// Add data to the tail of the list. O(1).\n     fn push(+data: T) {\n@@ -224,7 +224,7 @@ impl<T> DList<T> {\n     fn push_n(+data: T) -> DListNode<T> {\n         let mut nobe = self.new_link(move data);\n         self.add_tail(nobe);\n-        option::get(nobe)\n+        option::get(&nobe)\n     }\n     /**\n      * Insert data into the middle of the list, left of the given node.\n@@ -248,7 +248,7 @@ impl<T> DList<T> {\n     fn insert_before_n(+data: T, neighbour: DListNode<T>) -> DListNode<T> {\n         let mut nobe = self.new_link(move data);\n         self.insert_left(nobe, neighbour);\n-        option::get(nobe)\n+        option::get(&nobe)\n     }\n     /**\n      * Insert data into the middle of the list, right of the given node.\n@@ -272,7 +272,7 @@ impl<T> DList<T> {\n     fn insert_after_n(+data: T, neighbour: DListNode<T>) -> DListNode<T> {\n         let mut nobe = self.new_link(move data);\n         self.insert_right(neighbour, nobe);\n-        option::get(nobe)\n+        option::get(&nobe)\n     }\n \n     /// Remove a node from the head of the list. O(1).\n@@ -380,21 +380,25 @@ impl<T> DList<T> {\n \n     /// Check data structure integrity. O(n).\n     fn assert_consistent() {\n-        if option::is_none(self.hd) || option::is_none(self.tl) {\n-            assert option::is_none(self.hd) && option::is_none(self.tl);\n+        if option::is_none(&self.hd) || option::is_none(&self.tl) {\n+            assert option::is_none(&self.hd) && option::is_none(&self.tl);\n         }\n         // iterate forwards\n         let mut count = 0;\n         let mut link = self.peek_n();\n         let mut rabbit = link;\n-        while option::is_some(link) {\n-            let nobe = option::get(link);\n+        while option::is_some(&link) {\n+            let nobe = option::get(&link);\n             assert nobe.linked;\n             // check cycle\n-            if option::is_some(rabbit) { rabbit = option::get(rabbit).next; }\n-            if option::is_some(rabbit) { rabbit = option::get(rabbit).next; }\n-            if option::is_some(rabbit) {\n-                assert !box::ptr_eq(*option::get(rabbit), *nobe);\n+            if option::is_some(&rabbit) {\n+                rabbit = option::get(&rabbit).next;\n+            }\n+            if option::is_some(&rabbit) {\n+                rabbit = option::get(&rabbit).next;\n+            }\n+            if option::is_some(&rabbit) {\n+                assert !box::ptr_eq(*option::get(&rabbit), *nobe);\n             }\n             // advance\n             link = nobe.next_link();\n@@ -404,14 +408,18 @@ impl<T> DList<T> {\n         // iterate backwards - some of this is probably redundant.\n         link = self.peek_tail_n();\n         rabbit = link;\n-        while option::is_some(link) {\n-            let nobe = option::get(link);\n+        while option::is_some(&link) {\n+            let nobe = option::get(&link);\n             assert nobe.linked;\n             // check cycle\n-            if option::is_some(rabbit) { rabbit = option::get(rabbit).prev; }\n-            if option::is_some(rabbit) { rabbit = option::get(rabbit).prev; }\n-            if option::is_some(rabbit) {\n-                assert !box::ptr_eq(*option::get(rabbit), *nobe);\n+            if option::is_some(&rabbit) {\n+                rabbit = option::get(&rabbit).prev;\n+            }\n+            if option::is_some(&rabbit) {\n+                rabbit = option::get(&rabbit).prev;\n+            }\n+            if option::is_some(&rabbit) {\n+                assert !box::ptr_eq(*option::get(&rabbit), *nobe);\n             }\n             // advance\n             link = nobe.prev_link();"}, {"sha": "4faffb0c9ad52604468a834ba42eb6145f337cd7", "filename": "src/libcore/gc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4a78f9b16620489855da93c19be56f59431416f6/src%2Flibcore%2Fgc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a78f9b16620489855da93c19be56f59431416f6/src%2Flibcore%2Fgc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fgc.rs?ref=4a78f9b16620489855da93c19be56f59431416f6", "patch": "@@ -328,7 +328,7 @@ fn cleanup_stack_for_failure() {\n         let mut roots = ~RootSet();\n         for walk_gc_roots(need_cleanup, sentinel) |root, tydesc| {\n             // Track roots to avoid double frees.\n-            if option::is_some(roots.find(&*root)) {\n+            if roots.find(&*root).is_some() {\n                 loop;\n             }\n             roots.insert(*root, ());"}, {"sha": "b6bbc1f70c03a6dd19f9cda6b00c3bd0328b7aff", "filename": "src/libcore/iter-trait/dlist.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4a78f9b16620489855da93c19be56f59431416f6/src%2Flibcore%2Fiter-trait%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a78f9b16620489855da93c19be56f59431416f6/src%2Flibcore%2Fiter-trait%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter-trait%2Fdlist.rs?ref=4a78f9b16620489855da93c19be56f59431416f6", "patch": "@@ -10,8 +10,8 @@ type IMPL_T<A> = dlist::DList<A>;\n  */\n pure fn EACH<A>(self: IMPL_T<A>, f: fn(v: &A) -> bool) {\n     let mut link = self.peek_n();\n-    while option::is_some(link) {\n-        let nobe = option::get(link);\n+    while option::is_some(&link) {\n+        let nobe = option::get(&link);\n         assert nobe.linked;\n         if !f(&nobe.data) { break; }\n         // Check (weakly) that the user didn't do a remove."}, {"sha": "94e824d9ad987fd7998904930936190d4db79910", "filename": "src/libcore/option.rs", "status": "modified", "additions": 31, "deletions": 27, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/4a78f9b16620489855da93c19be56f59431416f6/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a78f9b16620489855da93c19be56f59431416f6/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=4a78f9b16620489855da93c19be56f59431416f6", "patch": "@@ -8,6 +8,10 @@\n  * type.\n  */\n \n+// NB: transitionary, de-mode-ing.\n+#[forbid(deprecated_mode)];\n+#[forbid(deprecated_pattern)];\n+\n use cmp::Eq;\n \n /// The option type\n@@ -16,7 +20,7 @@ enum Option<T> {\n     Some(T),\n }\n \n-pure fn get<T: Copy>(opt: Option<T>) -> T {\n+pure fn get<T: Copy>(opt: &Option<T>) -> T {\n     /*!\n      * Gets the value out of an option\n      *\n@@ -25,7 +29,7 @@ pure fn get<T: Copy>(opt: Option<T>) -> T {\n      * Fails if the value equals `none`\n      */\n \n-    match opt {\n+    match *opt {\n       Some(x) => return x,\n       None => fail ~\"option::get none\"\n     }\n@@ -45,7 +49,7 @@ pure fn get_ref<T>(opt: &r/Option<T>) -> &r/T {\n     }\n }\n \n-pure fn expect<T: Copy>(opt: Option<T>, reason: ~str) -> T {\n+pure fn expect<T: Copy>(opt: &Option<T>, +reason: ~str) -> T {\n     /*!\n      * Gets the value out of an option, printing a specified message on\n      * failure\n@@ -54,13 +58,13 @@ pure fn expect<T: Copy>(opt: Option<T>, reason: ~str) -> T {\n      *\n      * Fails if the value equals `none`\n      */\n-    match opt { Some(x) => x, None => fail reason }\n+    match *opt { Some(x) => x, None => fail reason }\n }\n \n-pure fn map<T, U>(opt: Option<T>, f: fn(T) -> U) -> Option<U> {\n+pure fn map<T, U>(opt: &Option<T>, f: fn(T) -> U) -> Option<U> {\n     //! Maps a `some` value from one type to another\n \n-    match opt { Some(x) => Some(f(x)), None => None }\n+    match *opt { Some(x) => Some(f(x)), None => None }\n }\n \n pure fn map_ref<T, U>(opt: &Option<T>, f: fn(x: &T) -> U) -> Option<U> {\n@@ -77,13 +81,13 @@ pure fn map_consume<T, U>(+opt: Option<T>, f: fn(+v: T) -> U) -> Option<U> {\n     if opt.is_some() { Some(f(option::unwrap(move opt))) } else { None }\n }\n \n-pure fn chain<T, U>(opt: Option<T>, f: fn(T) -> Option<U>) -> Option<U> {\n+pure fn chain<T, U>(opt: &Option<T>, f: fn(T) -> Option<U>) -> Option<U> {\n     /*!\n      * Update an optional value by optionally running its content through a\n      * function that returns an option.\n      */\n \n-    match opt { Some(x) => f(x), None => None }\n+    match *opt { Some(x) => f(x), None => None }\n }\n \n pure fn chain_ref<T, U>(opt: &Option<T>,\n@@ -116,28 +120,28 @@ pure fn while_some<T>(+x: Option<T>, blk: fn(+v: T) -> Option<T>) {\n     }\n }\n \n-pure fn is_none<T>(opt: Option<T>) -> bool {\n+pure fn is_none<T>(opt: &Option<T>) -> bool {\n     //! Returns true if the option equals `none`\n \n-    match opt { None => true, Some(_) => false }\n+    match *opt { None => true, Some(_) => false }\n }\n \n-pure fn is_some<T>(opt: Option<T>) -> bool {\n+pure fn is_some<T>(opt: &Option<T>) -> bool {\n     //! Returns true if the option contains some value\n \n     !is_none(opt)\n }\n \n-pure fn get_default<T: Copy>(opt: Option<T>, def: T) -> T {\n+pure fn get_default<T: Copy>(opt: &Option<T>, +def: T) -> T {\n     //! Returns the contained value or a default\n \n-    match opt { Some(x) => x, None => def }\n+    match *opt { Some(x) => x, None => def }\n }\n \n-pure fn map_default<T, U>(opt: Option<T>, +def: U, f: fn(T) -> U) -> U {\n+pure fn map_default<T, U>(opt: &Option<T>, +def: U, f: fn(T) -> U) -> U {\n     //! Applies a function to the contained value or returns a default\n \n-    match opt { None => move def, Some(t) => f(t) }\n+    match *opt { None => move def, Some(t) => f(t) }\n }\n \n // This should replace map_default.\n@@ -149,10 +153,10 @@ pure fn map_default_ref<T, U>(opt: &Option<T>, +def: U,\n }\n \n // This should change to by-copy mode; use iter_ref below for by reference\n-pure fn iter<T>(opt: Option<T>, f: fn(T)) {\n+pure fn iter<T>(opt: &Option<T>, f: fn(T)) {\n     //! Performs an operation on the contained value or does nothing\n \n-    match opt { None => (), Some(t) => f(t) }\n+    match *opt { None => (), Some(t) => f(t) }\n }\n \n pure fn iter_ref<T>(opt: &Option<T>, f: fn(x: &T)) {\n@@ -163,7 +167,7 @@ pure fn iter_ref<T>(opt: &Option<T>, f: fn(x: &T)) {\n // tjc: shouldn't this be - instead of +?\n // then could get rid of some superfluous moves\n #[inline(always)]\n-pure fn unwrap<T>(-opt: Option<T>) -> T {\n+pure fn unwrap<T>(+opt: Option<T>) -> T {\n     /*!\n      * Moves a value out of an option type and returns it.\n      *\n@@ -195,18 +199,18 @@ impl<T> Option<T> {\n      * Update an optional value by optionally running its content through a\n      * function that returns an option.\n      */\n-    pure fn chain<U>(f: fn(T) -> Option<U>) -> Option<U> { chain(self, f) }\n+    pure fn chain<U>(f: fn(T) -> Option<U>) -> Option<U> { chain(&self, f) }\n     /// Applies a function to the contained value or returns a default\n     pure fn map_default<U>(+def: U, f: fn(T) -> U) -> U\n-        { map_default(self, move def, f) }\n+        { map_default(&self, move def, f) }\n     /// Performs an operation on the contained value or does nothing\n-    pure fn iter(f: fn(T)) { iter(self, f) }\n+    pure fn iter(f: fn(T)) { iter(&self, f) }\n     /// Returns true if the option equals `none`\n-    pure fn is_none() -> bool { is_none(self) }\n+    pure fn is_none() -> bool { is_none(&self) }\n     /// Returns true if the option contains some value\n-    pure fn is_some() -> bool { is_some(self) }\n+    pure fn is_some() -> bool { is_some(&self) }\n     /// Maps a `some` value from one type to another\n-    pure fn map<U>(f: fn(T) -> U) -> Option<U> { map(self, f) }\n+    pure fn map<U>(f: fn(T) -> U) -> Option<U> { map(&self, f) }\n }\n \n impl<T> &Option<T> {\n@@ -236,8 +240,8 @@ impl<T: Copy> Option<T> {\n      *\n      * Fails if the value equals `none`\n      */\n-    pure fn get() -> T { get(self) }\n-    pure fn get_default(def: T) -> T { get_default(self, def) }\n+    pure fn get() -> T { get(&self) }\n+    pure fn get_default(+def: T) -> T { get_default(&self, def) }\n     /**\n      * Gets the value out of an option, printing a specified message on\n      * failure\n@@ -246,7 +250,7 @@ impl<T: Copy> Option<T> {\n      *\n      * Fails if the value equals `none`\n      */\n-    pure fn expect(reason: ~str) -> T { expect(self, reason) }\n+    pure fn expect(+reason: ~str) -> T { expect(&self, reason) }\n     /// Applies a function zero or more times until the result is none.\n     pure fn while_some(blk: fn(+v: T) -> Option<T>) { while_some(self, blk) }\n }"}, {"sha": "a9a7e94b08fee74609d3ac21a582a829ad65b670", "filename": "src/libcore/os.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4a78f9b16620489855da93c19be56f59431416f6/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a78f9b16620489855da93c19be56f59431416f6/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=4a78f9b16620489855da93c19be56f59431416f6", "patch": "@@ -438,7 +438,7 @@ fn self_exe_path() -> Option<Path> {\n         }\n     }\n \n-    do option::map(load_self()) |pth| {\n+    do load_self().map |pth| {\n         Path(pth).dir_path()\n     }\n }\n@@ -512,15 +512,15 @@ fn tmpdir() -> Path {\n     #[cfg(unix)]\n     #[allow(non_implicitly_copyable_typarams)]\n     fn lookup() -> Path {\n-        option::get_default(getenv_nonempty(\"TMPDIR\"),\n+        option::get_default(&getenv_nonempty(\"TMPDIR\"),\n                             Path(\"/tmp\"))\n     }\n \n     #[cfg(windows)]\n     #[allow(non_implicitly_copyable_typarams)]\n     fn lookup() -> Path {\n         option::get_default(\n-                    option::or(getenv_nonempty(\"TMP\"),\n+                    &option::or(getenv_nonempty(\"TMP\"),\n                     option::or(getenv_nonempty(\"TEMP\"),\n                     option::or(getenv_nonempty(\"USERPROFILE\"),\n                                getenv_nonempty(\"WINDIR\")))),\n@@ -848,7 +848,7 @@ mod tests {\n     fn make_rand_name() -> ~str {\n         let rng: rand::Rng = rand::Rng();\n         let n = ~\"TEST\" + rng.gen_str(10u);\n-        assert option::is_none(getenv(n));\n+        assert getenv(n).is_none();\n         n\n     }\n \n@@ -889,8 +889,8 @@ mod tests {\n     #[test]\n     fn test_self_exe_path() {\n         let path = os::self_exe_path();\n-        assert option::is_some(path);\n-        let path = option::get(path);\n+        assert path.is_some();\n+        let path = path.get();\n         log(debug, path);\n \n         // Hard to test this function\n@@ -909,7 +909,7 @@ mod tests {\n             // MingW seems to set some funky environment variables like\n             // \"=C:=C:\\MinGW\\msys\\1.0\\bin\" and \"!::=::\\\" that are returned\n             // from env() but not visible from getenv().\n-            assert option::is_none(v2) || v2 == option::Some(v);\n+            assert v2.is_none() || v2 == option::Some(v);\n         }\n     }\n \n@@ -946,7 +946,7 @@ mod tests {\n         setenv(~\"HOME\", ~\"\");\n         assert os::homedir().is_none();\n \n-        option::iter(oldhome, |s| setenv(~\"HOME\", s));\n+        oldhome.iter(|s| setenv(~\"HOME\", s));\n     }\n \n     #[test]"}, {"sha": "7adc0babe2059c447e55903706e1bdfa8e7acf3a", "filename": "src/libcore/str.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4a78f9b16620489855da93c19be56f59431416f6/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a78f9b16620489855da93c19be56f59431416f6/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=4a78f9b16620489855da93c19be56f59431416f6", "patch": "@@ -1466,7 +1466,7 @@ pure fn find_str_between(haystack: &a/str, needle: &b/str, start: uint,\n  * * needle - The string to look for\n  */\n pure fn contains(haystack: &a/str, needle: &b/str) -> bool {\n-    option::is_some(find_str(haystack, needle))\n+    find_str(haystack, needle).is_some()\n }\n \n /**\n@@ -1478,7 +1478,7 @@ pure fn contains(haystack: &a/str, needle: &b/str) -> bool {\n  * * needle - The char to look for\n  */\n pure fn contains_char(haystack: &str, needle: char) -> bool {\n-    option::is_some(find_char(haystack, needle))\n+    find_char(haystack, needle).is_some()\n }\n \n /**"}, {"sha": "7edd47f52d9eaa36b9fcc50d0126ea1117b37cd5", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4a78f9b16620489855da93c19be56f59431416f6/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a78f9b16620489855da93c19be56f59431416f6/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=4a78f9b16620489855da93c19be56f59431416f6", "patch": "@@ -957,7 +957,7 @@ pure fn find<T: Copy>(v: &[T], f: fn(T) -> bool) -> Option<T> {\n  */\n pure fn find_between<T: Copy>(v: &[T], start: uint, end: uint,\n                       f: fn(T) -> bool) -> Option<T> {\n-    option::map(position_between(v, start, end, f), |i| v[i])\n+    position_between(v, start, end, f).map(|i| v[i])\n }\n \n /**\n@@ -980,7 +980,7 @@ pure fn rfind<T: Copy>(v: &[T], f: fn(T) -> bool) -> Option<T> {\n  */\n pure fn rfind_between<T: Copy>(v: &[T], start: uint, end: uint,\n                                f: fn(T) -> bool) -> Option<T> {\n-    option::map(rposition_between(v, start, end, f), |i| v[i])\n+    rposition_between(v, start, end, f).map(|i| v[i])\n }\n \n /// Find the first index containing a matching value"}, {"sha": "c8d1c6026c7c05ac933dce51f46c5f06f86e1ca6", "filename": "src/libstd/getopts.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4a78f9b16620489855da93c19be56f59431416f6/src%2Flibstd%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a78f9b16620489855da93c19be56f59431416f6/src%2Flibstd%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgetopts.rs?ref=4a78f9b16620489855da93c19be56f59431416f6", "patch": "@@ -303,8 +303,8 @@ fn getopts(args: &[~str], opts: &[Opt]) -> Result unsafe {\n                       Some(id) => last_valid_opt_id = option::Some(id),\n                       None => {\n                         let arg_follows =\n-                            option::is_some(last_valid_opt_id) &&\n-                            match opts[option::get(last_valid_opt_id)]\n+                            last_valid_opt_id.is_some() &&\n+                            match opts[last_valid_opt_id.get()]\n                               .hasarg {\n \n                               Yes | Maybe => true,\n@@ -331,23 +331,23 @@ fn getopts(args: &[~str], opts: &[Opt]) -> Result unsafe {\n                 };\n                 match opts[optid].hasarg {\n                   No => {\n-                    if !option::is_none::<~str>(i_arg) {\n+                    if !i_arg.is_none() {\n                         return Err(UnexpectedArgument(name_str(nm)));\n                     }\n                     vec::push(vals[optid], Given);\n                   }\n                   Maybe => {\n-                    if !option::is_none::<~str>(i_arg) {\n-                        vec::push(vals[optid], Val(option::get(i_arg)));\n+                    if !i_arg.is_none() {\n+                        vec::push(vals[optid], Val(i_arg.get()));\n                     } else if name_pos < vec::len::<Name>(names) ||\n                                   i + 1u == l || is_arg(args[i + 1u]) {\n                         vec::push(vals[optid], Given);\n                     } else { i += 1u; vec::push(vals[optid], Val(args[i])); }\n                   }\n                   Yes => {\n-                    if !option::is_none::<~str>(i_arg) {\n+                    if !i_arg.is_none() {\n                         vec::push(vals[optid],\n-                                  Val(option::get::<~str>(i_arg)));\n+                                  Val(i_arg.get()));\n                     } else if i + 1u == l {\n                         return Err(ArgumentMissing(name_str(nm)));\n                     } else { i += 1u; vec::push(vals[optid], Val(args[i])); }"}, {"sha": "9bdf6e15ee5735f9dc384bb4f3aebb4fe1fabeaf", "filename": "src/libstd/map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4a78f9b16620489855da93c19be56f59431416f6/src%2Flibstd%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a78f9b16620489855da93c19be56f59431416f6/src%2Flibstd%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmap.rs?ref=4a78f9b16620489855da93c19be56f59431416f6", "patch": "@@ -730,9 +730,9 @@ mod tests {\n     fn test_find() {\n         let key = ~\"k\";\n         let map = map::HashMap::<~str, ~str>();\n-        assert (option::is_none(map.find(key)));\n+        assert (option::is_none(&map.find(key)));\n         map.insert(key, ~\"val\");\n-        assert (option::get(map.find(key)) == ~\"val\");\n+        assert (option::get(&map.find(key)) == ~\"val\");\n     }\n \n     #[test]"}, {"sha": "2545661356f4c67a846a51e5fb31bce77f91b417", "filename": "src/libstd/net_url.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4a78f9b16620489855da93c19be56f59431416f6/src%2Flibstd%2Fnet_url.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a78f9b16620489855da93c19be56f59431416f6/src%2Flibstd%2Fnet_url.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_url.rs?ref=4a78f9b16620489855da93c19be56f59431416f6", "patch": "@@ -308,7 +308,7 @@ fn userinfo_from_str(uinfo: &str) -> UserInfo {\n }\n \n fn userinfo_to_str(+userinfo: UserInfo) -> ~str {\n-    if option::is_some(userinfo.pass) {\n+    if option::is_some(&userinfo.pass) {\n         return str::concat(~[copy userinfo.user, ~\":\",\n                           option::unwrap(copy userinfo.pass),\n                           ~\"@\"]);\n@@ -708,7 +708,7 @@ impl Url : FromStr {\n  *\n  */\n fn to_str(+url: Url) -> ~str {\n-    let user = if option::is_some(url.user) {\n+    let user = if url.user.is_some() {\n       userinfo_to_str(option::unwrap(copy url.user))\n     } else {\n        ~\"\"\n@@ -723,7 +723,7 @@ fn to_str(+url: Url) -> ~str {\n     } else {\n         str::concat(~[~\"?\", query_to_str(url.query)])\n     };\n-    let fragment = if option::is_some(url.fragment) {\n+    let fragment = if url.fragment.is_some() {\n         str::concat(~[~\"#\", encode_component(\n             option::unwrap(copy url.fragment))])\n     } else {\n@@ -805,21 +805,21 @@ mod tests {\n         assert u == option::Some({user: ~\"user\",\n                                   pass: option::Some(~\"pass\")});\n         assert h == ~\"rust-lang.org\";\n-        assert option::is_none(p);\n+        assert p.is_none();\n         assert r == ~\"/something\";\n \n         let (u, h, p, r) = result::unwrap(get_authority(\n             ~\"//rust-lang.org:8000?something\"));\n-        assert option::is_none(u);\n+        assert u.is_none();\n         assert h == ~\"rust-lang.org\";\n         assert p == option::Some(~\"8000\");\n         assert r == ~\"?something\";\n \n         let (u, h, p, r) = result::unwrap(get_authority(\n             ~\"//rust-lang.org#blah\"));\n-        assert option::is_none(u);\n+        assert u.is_none();\n         assert h == ~\"rust-lang.org\";\n-        assert option::is_none(p);\n+        assert p.is_none();\n         assert r == ~\"#blah\";\n \n         // ipv6 tests"}, {"sha": "8ce1ebde127aa4e99d74186590e50982810f2e63", "filename": "src/libstd/smallintmap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4a78f9b16620489855da93c19be56f59431416f6/src%2Flibstd%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a78f9b16620489855da93c19be56f59431416f6/src%2Flibstd%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsmallintmap.rs?ref=4a78f9b16620489855da93c19be56f59431416f6", "patch": "@@ -62,7 +62,7 @@ pure fn get<T: Copy>(self: SmallIntMap<T>, key: uint) -> T {\n \n /// Returns true if the map contains a value for the specified key\n fn contains_key<T: Copy>(self: SmallIntMap<T>, key: uint) -> bool {\n-    return !option::is_none(find(self, key));\n+    return !find(self, key).is_none();\n }\n \n /// Implements the map::map interface for smallintmap"}, {"sha": "a4af0a1772f47e63ea8ad377582b23199c75a536", "filename": "src/libstd/test.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4a78f9b16620489855da93c19be56f59431416f6/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a78f9b16620489855da93c19be56f59431416f6/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=4a78f9b16620489855da93c19be56f59431416f6", "patch": "@@ -274,8 +274,8 @@ fn should_sort_failures_before_printing_them() {\n         print_failures(st);\n     };\n \n-    let apos = option::get(str::find_str(s, ~\"a\"));\n-    let bpos = option::get(str::find_str(s, ~\"b\"));\n+    let apos = str::find_str(s, ~\"a\").get();\n+    let bpos = str::find_str(s, ~\"b\").get();\n     assert apos < bpos;\n }\n \n@@ -351,7 +351,7 @@ fn filter_tests(opts: &TestOpts,\n     let mut filtered = vec::slice(tests, 0, tests.len());\n \n     // Remove tests that don't match the test filter\n-    filtered = if option::is_none(opts.filter) {\n+    filtered = if opts.filter.is_none() {\n         move filtered\n     } else {\n         let filter_str =\n@@ -503,7 +503,7 @@ mod tests {\n           either::Left(o) => o,\n           _ => fail ~\"Malformed arg in first_free_arg_should_be_a_filter\"\n         };\n-        assert ~\"filter\" == option::get(opts.filter);\n+        assert ~\"filter\" == opts.filter.get();\n     }\n \n     #[test]"}, {"sha": "abeddbdd69a7875e1d5d38cf007dc9c7c0e6f7c1", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4a78f9b16620489855da93c19be56f59431416f6/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a78f9b16620489855da93c19be56f59431416f6/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=4a78f9b16620489855da93c19be56f59431416f6", "patch": "@@ -269,8 +269,8 @@ fn highlight_lines(cm: codemap::codemap, sp: span,\n }\n \n fn print_macro_backtrace(cm: codemap::codemap, sp: span) {\n-    do option::iter (sp.expn_info) |ei| {\n-        let ss = option::map_default(ei.callie.span, @~\"\",\n+    do option::iter(&sp.expn_info) |ei| {\n+        let ss = option::map_default(&ei.callie.span, @~\"\",\n                                      |span| @codemap::span_to_str(span, cm));\n         print_diagnostic(*ss, note,\n                          fmt!(\"in expansion of #%s\", ei.callie.name));"}, {"sha": "ee9602598d1ed60e7dab2b7db9907842788fbc0e", "filename": "src/libsyntax/ext/qquote.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4a78f9b16620489855da93c19be56f59431416f6/src%2Flibsyntax%2Fext%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a78f9b16620489855da93c19be56f59431416f6/src%2Flibsyntax%2Fext%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fqquote.rs?ref=4a78f9b16620489855da93c19be56f59431416f6", "patch": "@@ -155,7 +155,7 @@ fn expand_ast(ecx: ext_ctxt, _sp: span,\n     -> @ast::expr\n {\n     let mut what = ~\"expr\";\n-    do option::iter(arg) |arg| {\n+    do arg.iter |arg| {\n         let args: ~[@ast::expr] =\n             match arg.node {\n               ast::expr_vec(elts, _) => elts,\n@@ -311,7 +311,7 @@ fn fold_crate(f: ast_fold, &&n: @ast::crate) -> @ast::crate {\n fn fold_expr(f: ast_fold, &&n: @ast::expr) -> @ast::expr {f.fold_expr(n)}\n fn fold_ty(f: ast_fold, &&n: @ast::ty) -> @ast::ty {f.fold_ty(n)}\n fn fold_item(f: ast_fold, &&n: @ast::item) -> @ast::item {\n-    option::get(f.fold_item(n)) //HACK: we know we don't drop items\n+    f.fold_item(n).get() //HACK: we know we don't drop items\n }\n fn fold_stmt(f: ast_fold, &&n: @ast::stmt) -> @ast::stmt {f.fold_stmt(n)}\n fn fold_pat(f: ast_fold, &&n: @ast::pat) -> @ast::pat {f.fold_pat(n)}"}, {"sha": "3af9cfe852dc9b92b6c9ded95c3e67c1f742b52e", "filename": "src/libsyntax/ext/simplext.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4a78f9b16620489855da93c19be56f59431416f6/src%2Flibsyntax%2Fext%2Fsimplext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a78f9b16620489855da93c19be56f59431416f6/src%2Flibsyntax%2Fext%2Fsimplext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsimplext.rs?ref=4a78f9b16620489855da93c19be56f59431416f6", "patch": "@@ -707,7 +707,7 @@ fn add_new_extension(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n                None => cx.span_fatal(sp, ~\"macro definition must have \" +\n                                      ~\"at least one clause\")\n              },\n-         ext: normal({expander: ext, span: Some(option::get(arg).span)})};\n+         ext: normal({expander: ext, span: Some(arg.get().span)})};\n \n     fn generic_extension(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n                          _body: ast::mac_body,"}, {"sha": "918b6b284592b291ce3c0f242ca8886522063079", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/4a78f9b16620489855da93c19be56f59431416f6/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a78f9b16620489855da93c19be56f59431416f6/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=4a78f9b16620489855da93c19be56f59431416f6", "patch": "@@ -114,7 +114,7 @@ fn fold_mac_(m: mac, fld: ast_fold) -> mac {\n              match m.node {\n                mac_invoc(pth, arg, body) => {\n                  mac_invoc(fld.fold_path(pth),\n-                           option::map(arg, |x| fld.fold_expr(x)), body)\n+                           option::map(&arg, |x| fld.fold_expr(x)), body)\n                }\n                mac_invoc_tt(*) => m.node,\n                mac_ellipsis => mac_ellipsis,\n@@ -241,7 +241,7 @@ fn noop_fold_item_underscore(i: item_, fld: ast_fold) -> item_ {\n             item_enum(ast::enum_def({\n                 variants: vec::map(enum_definition.variants,\n                                    |x| fld.fold_variant(*x)),\n-                common: option::map(enum_definition.common,\n+                common: option::map(&enum_definition.common,\n                                     |x| fold_struct_def(x, fld))\n             }), fold_ty_params(typms, fld))\n           }\n@@ -286,7 +286,7 @@ fn fold_struct_def(struct_def: @ast::struct_def, fld: ast_fold)\n             });\n         }\n     }\n-    let dtor = do option::map(struct_def.dtor) |dtor| {\n+    let dtor = do option::map(&struct_def.dtor) |dtor| {\n         let dtor_body = fld.fold_block(dtor.node.body);\n         let dtor_id   = fld.new_id(dtor.node.id);\n         {node: {body: dtor_body,\n@@ -331,7 +331,7 @@ fn noop_fold_method(&&m: @method, fld: ast_fold) -> @method {\n fn noop_fold_block(b: blk_, fld: ast_fold) -> blk_ {\n     return {view_items: vec::map(b.view_items, |x| fld.fold_view_item(*x)),\n          stmts: vec::map(b.stmts, |x| fld.fold_stmt(*x)),\n-         expr: option::map(b.expr, |x| fld.fold_expr(x)),\n+         expr: option::map(&b.expr, |x| fld.fold_expr(x)),\n          id: fld.new_id(b.id),\n          rules: b.rules};\n }\n@@ -346,7 +346,7 @@ fn noop_fold_stmt(s: stmt_, fld: ast_fold) -> stmt_ {\n \n fn noop_fold_arm(a: arm, fld: ast_fold) -> arm {\n     return {pats: vec::map(a.pats, |x| fld.fold_pat(*x)),\n-         guard: option::map(a.guard, |x| fld.fold_expr(x)),\n+         guard: option::map(&a.guard, |x| fld.fold_expr(x)),\n          body: fld.fold_block(a.body)};\n }\n \n@@ -356,11 +356,11 @@ fn noop_fold_pat(p: pat_, fld: ast_fold) -> pat_ {\n           pat_ident(binding_mode, pth, sub) => {\n             pat_ident(binding_mode,\n                       fld.fold_path(pth),\n-                      option::map(sub, |x| fld.fold_pat(x)))\n+                      option::map(&sub, |x| fld.fold_pat(x)))\n           }\n           pat_lit(e) => pat_lit(fld.fold_expr(e)),\n           pat_enum(pth, pats) => {\n-              pat_enum(fld.fold_path(pth), option::map(pats,\n+              pat_enum(fld.fold_path(pth), option::map(&pats,\n                        |pats| vec::map(pats, |x| fld.fold_pat(*x))))\n           }\n           pat_rec(fields, etc) => {\n@@ -433,7 +433,7 @@ fn noop_fold_expr(e: expr_, fld: ast_fold) -> expr_ {\n             expr_repeat(fld.fold_expr(expr), fld.fold_expr(count), mutt),\n           expr_rec(fields, maybe_expr) => {\n             expr_rec(vec::map(fields, |x| fold_field(*x)),\n-                     option::map(maybe_expr, |x| fld.fold_expr(x)))\n+                     option::map(&maybe_expr, |x| fld.fold_expr(x)))\n           }\n           expr_tup(elts) => expr_tup(vec::map(elts, |x| fld.fold_expr(*x))),\n           expr_call(f, args, blk) => {\n@@ -452,14 +452,14 @@ fn noop_fold_expr(e: expr_, fld: ast_fold) -> expr_ {\n           expr_addr_of(m, ohs) => expr_addr_of(m, fld.fold_expr(ohs)),\n           expr_if(cond, tr, fl) => {\n             expr_if(fld.fold_expr(cond), fld.fold_block(tr),\n-                    option::map(fl, |x| fld.fold_expr(x)))\n+                    option::map(&fl, |x| fld.fold_expr(x)))\n           }\n           expr_while(cond, body) => {\n             expr_while(fld.fold_expr(cond), fld.fold_block(body))\n           }\n           expr_loop(body, opt_ident) => {\n               expr_loop(fld.fold_block(body),\n-                        option::map(opt_ident, |x| fld.fold_ident(x)))\n+                        option::map(&opt_ident, |x| fld.fold_ident(x)))\n           }\n           expr_match(expr, arms) => {\n             expr_match(fld.fold_expr(expr),\n@@ -501,20 +501,20 @@ fn noop_fold_expr(e: expr_, fld: ast_fold) -> expr_ {\n             expr_index(fld.fold_expr(el), fld.fold_expr(er))\n           }\n           expr_path(pth) => expr_path(fld.fold_path(pth)),\n-          expr_fail(e) => expr_fail(option::map(e, |x| fld.fold_expr(x))),\n+          expr_fail(e) => expr_fail(option::map(&e, |x| fld.fold_expr(x))),\n           expr_break(opt_ident) =>\n-            expr_break(option::map(opt_ident, |x| fld.fold_ident(x))),\n+            expr_break(option::map(&opt_ident, |x| fld.fold_ident(x))),\n           expr_again(opt_ident) =>\n-            expr_again(option::map(opt_ident, |x| fld.fold_ident(x))),\n-          expr_ret(e) => expr_ret(option::map(e, |x| fld.fold_expr(x))),\n+            expr_again(option::map(&opt_ident, |x| fld.fold_ident(x))),\n+          expr_ret(e) => expr_ret(option::map(&e, |x| fld.fold_expr(x))),\n           expr_log(i, lv, e) => expr_log(i, fld.fold_expr(lv),\n                                          fld.fold_expr(e)),\n           expr_assert(e) => expr_assert(fld.fold_expr(e)),\n           expr_mac(mac) => expr_mac(fold_mac(mac)),\n           expr_struct(path, fields, maybe_expr) => {\n             expr_struct(fld.fold_path(path),\n                         vec::map(fields, |x| fold_field(*x)),\n-                        option::map(maybe_expr, |x| fld.fold_expr(x)))\n+                        option::map(&maybe_expr, |x| fld.fold_expr(x)))\n           }\n         }\n }\n@@ -573,7 +573,7 @@ fn noop_fold_variant(v: variant_, fld: ast_fold) -> variant_ {\n             kind = tuple_variant_kind(vec::map(variant_args,\n                                                |x| fold_variant_arg(*x))),\n         struct_variant_kind(struct_def) => {\n-            let dtor = do option::map(struct_def.dtor) |dtor| {\n+            let dtor = do option::map(&struct_def.dtor) |dtor| {\n                 let dtor_body = fld.fold_block(dtor.node.body);\n                 let dtor_id   = fld.new_id(dtor.node.id);\n                 {node: {body: dtor_body,\n@@ -593,7 +593,7 @@ fn noop_fold_variant(v: variant_, fld: ast_fold) -> variant_ {\n         enum_variant_kind(enum_definition) => {\n             let variants = vec::map(enum_definition.variants,\n                                     |x| fld.fold_variant(*x));\n-            let common = option::map(enum_definition.common,\n+            let common = option::map(&enum_definition.common,\n                                      |x| fold_struct_def(x, fld));\n             kind = enum_variant_kind(ast::enum_def({ variants: variants,\n                                                      common: common }));"}, {"sha": "312c78085acfcda13dd0ef5d1374f1ff6a199d8a", "filename": "src/libsyntax/parse.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4a78f9b16620489855da93c19be56f59431416f6/src%2Flibsyntax%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a78f9b16620489855da93c19be56f59431416f6/src%2Flibsyntax%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse.rs?ref=4a78f9b16620489855da93c19be56f59431416f6", "patch": "@@ -73,7 +73,7 @@ fn parse_crate_from_crate_file(input: &Path, cfg: ast::crate_cfg,\n     sess.chpos = rdr.chpos;\n     sess.byte_pos = sess.byte_pos + rdr.pos;\n     let cx = @{sess: sess, cfg: /* FIXME (#2543) */ copy p.cfg};\n-    let companionmod = option::map(input.filestem(), |s| Path(s));\n+    let companionmod = input.filestem().map(|s| Path(s));\n     let (m, attrs) = eval::eval_crate_directives_to_mod(\n         cx, cdirs, &prefix, &companionmod);\n     let mut hi = p.span.hi;"}, {"sha": "c9b10c7b754715c9677c185c90496ea455fd4fcd", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4a78f9b16620489855da93c19be56f59431416f6/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a78f9b16620489855da93c19be56f59431416f6/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=4a78f9b16620489855da93c19be56f59431416f6", "patch": "@@ -364,7 +364,7 @@ fn scan_number(c: char, rdr: string_reader) -> token::token {\n         if str::len(num_str) == 0u {\n             rdr.fatal(~\"no valid digits found for number\");\n         }\n-        let parsed = option::get(u64::from_str_radix(num_str, base as u64));\n+        let parsed = u64::from_str_radix(num_str, base as u64).get();\n         match tp {\n           either::Left(t) => return token::LIT_INT(parsed as i64, t),\n           either::Right(t) => return token::LIT_UINT(parsed, t)\n@@ -412,7 +412,7 @@ fn scan_number(c: char, rdr: string_reader) -> token::token {\n         if str::len(num_str) == 0u {\n             rdr.fatal(~\"no valid digits found for number\");\n         }\n-        let parsed = option::get(u64::from_str_radix(num_str, base as u64));\n+        let parsed = u64::from_str_radix(num_str, base as u64).get();\n \n         debug!(\"lexing %s as an unsuffixed integer literal\",\n                num_str);"}, {"sha": "490808edaadb5344df7374739b7d568441aa3ae2", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4a78f9b16620489855da93c19be56f59431416f6/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a78f9b16620489855da93c19be56f59431416f6/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=4a78f9b16620489855da93c19be56f59431416f6", "patch": "@@ -2743,7 +2743,7 @@ impl parser {\n                             token_to_str(self.reader, self.token)));\n         }\n \n-        let actual_dtor = do option::map(the_dtor) |dtor| {\n+        let actual_dtor = do the_dtor.map |dtor| {\n             let (d_body, d_attrs, d_s) = dtor;\n             {node: {id: self.get_id(),\n                     attrs: d_attrs,\n@@ -3111,7 +3111,7 @@ impl parser {\n             }\n         }\n         self.bump();\n-        let mut actual_dtor = do option::map(the_dtor) |dtor| {\n+        let mut actual_dtor = do the_dtor.map |dtor| {\n             let (d_body, d_attrs, d_s) = dtor;\n             {node: {id: self.get_id(),\n                     attrs: d_attrs,"}, {"sha": "3630ba8c5c6b2e8de1d4b78b7aaf076fc8ce2182", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4a78f9b16620489855da93c19be56f59431416f6/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a78f9b16620489855da93c19be56f59431416f6/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=4a78f9b16620489855da93c19be56f59431416f6", "patch": "@@ -652,7 +652,7 @@ fn print_struct(s: ps, struct_def: @ast::struct_def, tps: ~[ast::ty_param],\n     }\n     bopen(s);\n     hardbreak_if_not_bol(s);\n-    do option::iter(struct_def.ctor) |ctor| {\n+    do struct_def.ctor.iter |ctor| {\n       maybe_print_comment(s, ctor.span.lo);\n       print_outer_attributes(s, ctor.node.attrs);\n       // Doesn't call head because there shouldn't be a space after new.\n@@ -664,7 +664,7 @@ fn print_struct(s: ps, struct_def: @ast::struct_def, tps: ~[ast::ty_param],\n       space(s.s);\n       print_block(s, ctor.node.body);\n     }\n-    do option::iter(struct_def.dtor) |dtor| {\n+    do struct_def.dtor.iter |dtor| {\n       hardbreak_if_not_bol(s);\n       maybe_print_comment(s, dtor.span.lo);\n       print_outer_attributes(s, dtor.node.attrs);\n@@ -979,7 +979,7 @@ fn print_mac(s: ps, m: ast::mac) {\n           Some(@{node: ast::expr_vec(_, _), _}) => (),\n           _ => word(s.s, ~\" \")\n         }\n-        option::iter(arg, |a| print_expr(s, a));\n+        arg.iter(|a| print_expr(s, a));\n         // FIXME: extension 'body' (#2339)\n       }\n       ast::mac_invoc_tt(pth, tts) => {\n@@ -1177,7 +1177,7 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n       ast::expr_loop(blk, opt_ident) => {\n         head(s, ~\"loop\");\n         space(s.s);\n-        option::iter(opt_ident, |ident| {print_ident(s, ident); space(s.s)});\n+        opt_ident.iter(|ident| {print_ident(s, ident); space(s.s)});\n         print_block(s, blk);\n       }\n       ast::expr_match(expr, arms) => {\n@@ -1360,12 +1360,12 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n       ast::expr_break(opt_ident) => {\n         word(s.s, ~\"break\");\n         space(s.s);\n-        option::iter(opt_ident, |ident| {print_ident(s, ident); space(s.s)});\n+        opt_ident.iter(|ident| {print_ident(s, ident); space(s.s)});\n       }\n       ast::expr_again(opt_ident) => {\n         word(s.s, ~\"loop\");\n         space(s.s);\n-        option::iter(opt_ident, |ident| {print_ident(s, ident); space(s.s)});\n+        opt_ident.iter(|ident| {print_ident(s, ident); space(s.s)});\n       }\n       ast::expr_ret(result) => {\n         word(s.s, ~\"return\");\n@@ -1920,7 +1920,7 @@ fn maybe_print_trailing_comment(s: ps, span: codemap::span,\n fn print_remaining_comments(s: ps) {\n     // If there aren't any remaining comments, then we need to manually\n     // make sure there is a line break at the end.\n-    if option::is_none(next_comment(s)) { hardbreak(s.s); }\n+    if next_comment(s).is_none() { hardbreak(s.s); }\n     loop {\n         match next_comment(s) {\n           Some(cmnt) => { print_comment(s, cmnt); s.cur_cmnt += 1u; }"}, {"sha": "efcb5b2bda01b8fef8b93261f550de607a357fe2", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4a78f9b16620489855da93c19be56f59431416f6/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a78f9b16620489855da93c19be56f59431416f6/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=4a78f9b16620489855da93c19be56f59431416f6", "patch": "@@ -222,7 +222,7 @@ fn visit_pat<E>(p: @pat, e: E, v: vt<E>) {\n     match p.node {\n       pat_enum(path, children) => {\n         visit_path(path, e, v);\n-        do option::iter(children) |children| {\n+        do option::iter(&children) |children| {\n             for children.each |child| { v.visit_pat(*child, e, v); }}\n       }\n       pat_rec(fields, _) => for fields.each |f| {\n@@ -241,7 +241,7 @@ fn visit_pat<E>(p: @pat, e: E, v: vt<E>) {\n           v.visit_pat(inner, e, v),\n       pat_ident(_, path, inner) => {\n           visit_path(path, e, v);\n-          do option::iter(inner) |subpat| { v.visit_pat(subpat, e, v)};\n+          do option::iter(&inner) |subpat| { v.visit_pat(subpat, e, v)};\n       }\n       pat_lit(ex) => v.visit_expr(ex, e, v),\n       pat_range(e1, e2) => { v.visit_expr(e1, e, v); v.visit_expr(e2, e, v); }\n@@ -341,10 +341,10 @@ fn visit_struct_def<E>(sd: @struct_def, nm: ast::ident, tps: ~[ty_param],\n     for sd.traits.each |p| {\n         visit_path(p.path, e, v);\n     }\n-    do option::iter(sd.ctor) |ctor| {\n+    do option::iter(&sd.ctor) |ctor| {\n       visit_class_ctor_helper(ctor, nm, tps, ast_util::local_def(id), e, v);\n     };\n-    do option::iter(sd.dtor) |dtor| {\n+    do option::iter(&sd.dtor) |dtor| {\n       visit_class_dtor_helper(dtor, tps, ast_util::local_def(id), e, v)\n     };\n }\n@@ -395,7 +395,7 @@ fn visit_exprs<E>(exprs: ~[@expr], e: E, v: vt<E>) {\n fn visit_mac<E>(m: mac, e: E, v: vt<E>) {\n     match m.node {\n       ast::mac_invoc(_, arg, _) => {\n-        option::map(arg, |arg| v.visit_expr(arg, e, v)); }\n+        option::map(&arg, |arg| v.visit_expr(arg, e, v)); }\n       ast::mac_invoc_tt(*) => { /* no user-serviceable parts inside */ }\n       ast::mac_ellipsis => (),\n       ast::mac_aq(*) => { /* FIXME: maybe visit (Issue #2340) */ }"}, {"sha": "22d7451c6ae77e13307efa538cf2e3ad634b26cc", "filename": "src/rustc/back/link.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4a78f9b16620489855da93c19be56f59431416f6/src%2Frustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a78f9b16620489855da93c19be56f59431416f6/src%2Frustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fback%2Flink.rs?ref=4a78f9b16620489855da93c19be56f59431416f6", "patch": "@@ -688,7 +688,7 @@ fn link_binary(sess: session,\n         }\n         let dir = cratepath.dirname();\n         if dir != ~\"\" { vec::push(cc_args, ~\"-L\" + dir); }\n-        let libarg = unlib(sess.targ_cfg, option::get(cratepath.filestem()));\n+        let libarg = unlib(sess.targ_cfg, cratepath.filestem().get());\n         vec::push(cc_args, ~\"-l\" + libarg);\n     }\n \n@@ -717,7 +717,7 @@ fn link_binary(sess: session,\n         // be rpathed\n         if sess.targ_cfg.os == session::os_macos {\n             vec::push(cc_args, ~\"-Wl,-install_name,@rpath/\"\n-                      + option::get(output.filename()));\n+                      + output.filename().get());\n         }\n     }\n "}, {"sha": "6fe6cab58e05d9a74c012a47b8cc12f684d21020", "filename": "src/rustc/driver/driver.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4a78f9b16620489855da93c19be56f59431416f6/src%2Frustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a78f9b16620489855da93c19be56f59431416f6/src%2Frustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fdriver.rs?ref=4a78f9b16620489855da93c19be56f59431416f6", "patch": "@@ -254,7 +254,7 @@ fn compile_upto(sess: session, cfg: ast::crate_cfg,\n     time(time_passes, ~\"lint checking\", || lint::check_crate(ty_cx, crate));\n \n     if upto == cu_no_trans { return {crate: crate, tcx: Some(ty_cx)}; }\n-    let outputs = option::get(outputs);\n+    let outputs = outputs.get();\n \n     let maps = {mutbl_map: mutbl_map,\n                 root_map: root_map,\n@@ -353,7 +353,7 @@ fn pretty_print_input(sess: session, cfg: ast::crate_cfg, input: input,\n     let ann = match ppm {\n       ppm_typed => {\n         {pre: ann_paren_for_expr,\n-         post: |a| ann_typed_post(option::get(tcx), a) }\n+         post: |a| ann_typed_post(tcx.get(), a) }\n       }\n       ppm_identified | ppm_expanded_identified => {\n         {pre: ann_paren_for_expr, post: ann_identified_post}\n@@ -516,7 +516,7 @@ fn build_session_options(binary: ~str,\n     let extra_debuginfo = opt_present(matches, ~\"xg\");\n     let debuginfo = opt_present(matches, ~\"g\") || extra_debuginfo;\n     let sysroot_opt = getopts::opt_maybe_str(matches, ~\"sysroot\");\n-    let sysroot_opt = option::map(sysroot_opt, |m| Path(m));\n+    let sysroot_opt = sysroot_opt.map(|m| Path(m));\n     let target_opt = getopts::opt_maybe_str(matches, ~\"target\");\n     let save_temps = getopts::opt_present(matches, ~\"save-temps\");\n     match output_type {\n@@ -695,7 +695,7 @@ fn build_output_filenames(input: input,\n         };\n \n         let stem = match input {\n-          file_input(ifile) => option::get(ifile.filestem()),\n+          file_input(ifile) => ifile.filestem().get(),\n           str_input(_) => ~\"rust_out\"\n         };\n "}, {"sha": "3d055237669def08997ce4b21889d0fa189aea90", "filename": "src/rustc/driver/rustc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4a78f9b16620489855da93c19be56f59431416f6/src%2Frustc%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a78f9b16620489855da93c19be56f59431416f6/src%2Frustc%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Frustc.rs?ref=4a78f9b16620489855da93c19be56f59431416f6", "patch": "@@ -171,12 +171,12 @@ fn run_compiler(args: ~[~str], demitter: diagnostic::emitter) {\n     let sopts = build_session_options(binary, matches, demitter);\n     let sess = build_session(sopts, demitter);\n     let odir = getopts::opt_maybe_str(matches, ~\"out-dir\");\n-    let odir = option::map(odir, |o| Path(o));\n+    let odir = odir.map(|o| Path(o));\n     let ofile = getopts::opt_maybe_str(matches, ~\"o\");\n-    let ofile = option::map(ofile, |o| Path(o));\n+    let ofile = ofile.map(|o| Path(o));\n     let cfg = build_configuration(sess, binary, input);\n     let pretty =\n-        option::map(getopts::opt_default(matches, ~\"pretty\",\n+        option::map(&getopts::opt_default(matches, ~\"pretty\",\n                                          ~\"normal\"),\n                     |a| parse_pretty(sess, a) );\n     match pretty {"}, {"sha": "4c262e3dc650625ea8db75ac9412fba2d29b7342", "filename": "src/rustc/front/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4a78f9b16620489855da93c19be56f59431416f6/src%2Frustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a78f9b16620489855da93c19be56f59431416f6/src%2Frustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Ffront%2Fconfig.rs?ref=4a78f9b16620489855da93c19be56f59431416f6", "patch": "@@ -104,7 +104,7 @@ fn fold_block(cx: ctxt, b: ast::blk_, fld: fold::ast_fold) ->\n     let filtered_stmts = vec::filter_map(b.stmts, filter);\n     return {view_items: b.view_items,\n          stmts: vec::map(filtered_stmts, |x| fld.fold_stmt(*x)),\n-         expr: option::map(b.expr, |x| fld.fold_expr(x)),\n+         expr: option::map(&b.expr, |x| fld.fold_expr(x)),\n          id: b.id,\n          rules: b.rules};\n }"}, {"sha": "cb304c419e5634333713b6c7b6bb771015a055d4", "filename": "src/rustc/metadata/cstore.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4a78f9b16620489855da93c19be56f59431416f6/src%2Frustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a78f9b16620489855da93c19be56f59431416f6/src%2Frustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcstore.rs?ref=4a78f9b16620489855da93c19be56f59431416f6", "patch": "@@ -176,7 +176,7 @@ fn get_dep_hashes(cstore: cstore) -> ~[~str] {\n }\n \n fn get_path(cstore: cstore, d: ast::def_id) -> ~[~str] {\n-    option::map_default(p(cstore).mod_path_map.find(d), ~[],\n+    option::map_default(&p(cstore).mod_path_map.find(d), ~[],\n                         |ds| str::split_str(*ds, ~\"::\"))\n }\n // Local Variables:"}, {"sha": "181b8c6f1045dc2170aa5b1b87bfaf0b1d0a3b72", "filename": "src/rustc/metadata/decoder.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4a78f9b16620489855da93c19be56f59431416f6/src%2Frustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a78f9b16620489855da93c19be56f59431416f6/src%2Frustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fdecoder.rs?ref=4a78f9b16620489855da93c19be56f59431416f6", "patch": "@@ -92,7 +92,7 @@ fn maybe_find_item(item_id: int, items: ebml::Doc) -> Option<ebml::Doc> {\n }\n \n fn find_item(item_id: int, items: ebml::Doc) -> ebml::Doc {\n-    return option::get(maybe_find_item(item_id, items));\n+    return maybe_find_item(item_id, items).get();\n }\n \n // Looks up an item in the given metadata and returns an ebml doc pointing\n@@ -202,7 +202,7 @@ fn each_reexport(d: ebml::Doc, f: fn(ebml::Doc) -> bool) {\n fn field_mutability(d: ebml::Doc) -> ast::class_mutability {\n     // Use maybe_get_doc in case it's a method\n     option::map_default(\n-        ebml::maybe_get_doc(d, tag_class_mut),\n+        &ebml::maybe_get_doc(d, tag_class_mut),\n         ast::class_immutable,\n         |d| {\n             match ebml::doc_as_u8(d) as char {\n@@ -213,7 +213,7 @@ fn field_mutability(d: ebml::Doc) -> ast::class_mutability {\n }\n \n fn variant_disr_val(d: ebml::Doc) -> Option<int> {\n-    do option::chain(ebml::maybe_get_doc(d, tag_disr_val)) |val_doc| {\n+    do option::chain(&ebml::maybe_get_doc(d, tag_disr_val)) |val_doc| {\n         int::parse_bytes(ebml::doc_data(val_doc), 10u)\n     }\n }\n@@ -384,7 +384,7 @@ fn get_impl_method(intr: ident_interner, cdata: cmd, id: ast::node_id,\n             found = Some(translate_def_id(cdata, m_did));\n         }\n     }\n-    option::get(found)\n+    found.get()\n }\n \n fn get_class_method(intr: ident_interner, cdata: cmd, id: ast::node_id,"}, {"sha": "3424ea8dd576d514d7ffdc2bff6d192d7a7365aa", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4a78f9b16620489855da93c19be56f59431416f6/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a78f9b16620489855da93c19be56f59431416f6/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=4a78f9b16620489855da93c19be56f59431416f6", "patch": "@@ -602,7 +602,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::Writer, item: @item,\n                                         struct_def.fields, struct_def.methods,\n                                         index);\n         /* Encode the dtor */\n-        do option::iter(struct_def.dtor) |dtor| {\n+        do struct_def.dtor.iter |dtor| {\n             vec::push(*index, {val: dtor.node.id, pos: ebml_w.writer.tell()});\n           encode_info_for_ctor(ecx, ebml_w, dtor.node.id,\n                                ecx.tcx.sess.ident_of(\n@@ -635,7 +635,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::Writer, item: @item,\n         }\n         /* Encode the dtor */\n         /* Encode id for dtor */\n-        do option::iter(struct_def.dtor) |dtor| {\n+        do struct_def.dtor.iter |dtor| {\n             do ebml_w.wr_tag(tag_item_dtor) {\n                 encode_def_id(ebml_w, local_def(dtor.node.id));\n             }"}, {"sha": "77d06bd2d29e823ba017616ef13200d84fa93494", "filename": "src/rustc/metadata/filesearch.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4a78f9b16620489855da93c19be56f59431416f6/src%2Frustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a78f9b16620489855da93c19be56f59431416f6/src%2Frustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ffilesearch.rs?ref=4a78f9b16620489855da93c19be56f59431416f6", "patch": "@@ -74,15 +74,15 @@ fn search<T: Copy>(filesearch: filesearch, pick: pick<T>) -> Option<T> {\n         for os::list_dir_path(lib_search_path).each |path| {\n             debug!(\"testing %s\", path.to_str());\n             let maybe_picked = pick(*path);\n-            if option::is_some(maybe_picked) {\n+            if maybe_picked.is_some() {\n                 debug!(\"picked %s\", path.to_str());\n                 rslt = maybe_picked;\n                 break;\n             } else {\n                 debug!(\"rejected %s\", path.to_str());\n             }\n         }\n-        if option::is_some(rslt) { break; }\n+        if rslt.is_some() { break; }\n     }\n     return rslt;\n }"}, {"sha": "e11793a36d01ec262bed6986952961d05f58e123", "filename": "src/rustc/metadata/loader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4a78f9b16620489855da93c19be56f59431416f6/src%2Frustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a78f9b16620489855da93c19be56f59431416f6/src%2Frustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Floader.rs?ref=4a78f9b16620489855da93c19be56f59431416f6", "patch": "@@ -75,7 +75,7 @@ fn find_library_crate_aux(cx: ctxt,\n     let mut matches = ~[];\n     filesearch::search(filesearch, |path| {\n         debug!(\"inspecting file %s\", path.to_str());\n-        let f: ~str = option::get(path.filename());\n+        let f: ~str = path.filename().get();\n         if !(str::starts_with(f, prefix) && str::ends_with(f, suffix)) {\n             debug!(\"skipping %s, doesn't look like %s*%s\", path.to_str(),\n                    prefix, suffix);"}, {"sha": "acb7bb1bf2c3517ddc22ebca59ec95375cbd7f6f", "filename": "src/rustc/middle/astencode.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/4a78f9b16620489855da93c19be56f59431416f6/src%2Frustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a78f9b16620489855da93c19be56f59431416f6/src%2Frustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fastencode.rs?ref=4a78f9b16620489855da93c19be56f59431416f6", "patch": "@@ -719,15 +719,15 @@ fn encode_side_tables_for_id(ecx: @e::encode_ctxt,\n \n     debug!(\"Encoding side tables for id %d\", id);\n \n-    do option::iter(tcx.def_map.find(id)) |def| {\n+    do option::iter(&tcx.def_map.find(id)) |def| {\n         do ebml_w.tag(c::tag_table_def) {\n             ebml_w.id(id);\n             do ebml_w.tag(c::tag_table_val) {\n                 ast::serialize_def(ebml_w, def)\n             }\n         }\n     }\n-    do option::iter((*tcx.node_types).find(id as uint)) |ty| {\n+    do option::iter(&(*tcx.node_types).find(id as uint)) |ty| {\n         do ebml_w.tag(c::tag_table_node_type) {\n             ebml_w.id(id);\n             do ebml_w.tag(c::tag_table_val) {\n@@ -736,7 +736,7 @@ fn encode_side_tables_for_id(ecx: @e::encode_ctxt,\n         }\n     }\n \n-    do option::iter(tcx.node_type_substs.find(id)) |tys| {\n+    do option::iter(&tcx.node_type_substs.find(id)) |tys| {\n         do ebml_w.tag(c::tag_table_node_type_subst) {\n             ebml_w.id(id);\n             do ebml_w.tag(c::tag_table_val) {\n@@ -745,7 +745,7 @@ fn encode_side_tables_for_id(ecx: @e::encode_ctxt,\n         }\n     }\n \n-    do option::iter(tcx.freevars.find(id)) |fv| {\n+    do option::iter(&tcx.freevars.find(id)) |fv| {\n         do ebml_w.tag(c::tag_table_freevars) {\n             ebml_w.id(id);\n             do ebml_w.tag(c::tag_table_val) {\n@@ -757,7 +757,7 @@ fn encode_side_tables_for_id(ecx: @e::encode_ctxt,\n     }\n \n     let lid = {crate: ast::local_crate, node: id};\n-    do option::iter(tcx.tcache.find(lid)) |tpbt| {\n+    do option::iter(&tcx.tcache.find(lid)) |tpbt| {\n         do ebml_w.tag(c::tag_table_tcache) {\n             ebml_w.id(id);\n             do ebml_w.tag(c::tag_table_val) {\n@@ -766,7 +766,7 @@ fn encode_side_tables_for_id(ecx: @e::encode_ctxt,\n         }\n     }\n \n-    do option::iter(tcx.ty_param_bounds.find(id)) |pbs| {\n+    do option::iter(&tcx.ty_param_bounds.find(id)) |pbs| {\n         do ebml_w.tag(c::tag_table_param_bounds) {\n             ebml_w.id(id);\n             do ebml_w.tag(c::tag_table_val) {\n@@ -789,13 +789,13 @@ fn encode_side_tables_for_id(ecx: @e::encode_ctxt,\n     //    }\n     //}\n \n-    do option::iter(maps.mutbl_map.find(id)) |_m| {\n+    do option::iter(&maps.mutbl_map.find(id)) |_m| {\n         do ebml_w.tag(c::tag_table_mutbl) {\n             ebml_w.id(id);\n         }\n     }\n \n-    do option::iter(maps.last_use_map.find(id)) |m| {\n+    do option::iter(&maps.last_use_map.find(id)) |m| {\n         do ebml_w.tag(c::tag_table_last_use) {\n             ebml_w.id(id);\n             do ebml_w.tag(c::tag_table_val) {\n@@ -806,7 +806,7 @@ fn encode_side_tables_for_id(ecx: @e::encode_ctxt,\n         }\n     }\n \n-    do option::iter(maps.method_map.find(id)) |mme| {\n+    do option::iter(&maps.method_map.find(id)) |mme| {\n         do ebml_w.tag(c::tag_table_method_map) {\n             ebml_w.id(id);\n             do ebml_w.tag(c::tag_table_val) {\n@@ -815,7 +815,7 @@ fn encode_side_tables_for_id(ecx: @e::encode_ctxt,\n         }\n     }\n \n-    do option::iter(maps.vtable_map.find(id)) |dr| {\n+    do option::iter(&maps.vtable_map.find(id)) |dr| {\n         do ebml_w.tag(c::tag_table_vtable_map) {\n             ebml_w.id(id);\n             do ebml_w.tag(c::tag_table_val) {\n@@ -824,7 +824,7 @@ fn encode_side_tables_for_id(ecx: @e::encode_ctxt,\n         }\n     }\n \n-    do option::iter(tcx.adjustments.find(id)) |adj| {\n+    do option::iter(&tcx.adjustments.find(id)) |adj| {\n         do ebml_w.tag(c::tag_table_adjustments) {\n             ebml_w.id(id);\n             do ebml_w.tag(c::tag_table_val) {"}, {"sha": "a0f8ad4a4d47193295ae5ceee809198ef037b646", "filename": "src/rustc/middle/check_alt.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4a78f9b16620489855da93c19be56f59431416f6/src%2Frustc%2Fmiddle%2Fcheck_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a78f9b16620489855da93c19be56f59431416f6/src%2Frustc%2Fmiddle%2Fcheck_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fcheck_alt.rs?ref=4a78f9b16620489855da93c19be56f59431416f6", "patch": "@@ -67,7 +67,7 @@ fn check_arms(tcx: ty::ctxt, arms: ~[arm]) {\n               }\n               _ => ()\n             }\n-            if option::is_none(arm.guard) { vec::push(seen, v); }\n+            if arm.guard.is_none() { vec::push(seen, v); }\n         }\n     }\n }\n@@ -233,7 +233,7 @@ fn is_useful_specialized(tcx: ty::ctxt, m: matrix, v: ~[@pat], ctor: ctor,\n                           arity: uint, lty: ty::t) -> useful {\n     let ms = vec::filter_map(m, |r| specialize(tcx, r, ctor, arity, lty) );\n     let could_be_useful = is_useful(\n-        tcx, ms, option::get(specialize(tcx, v, ctor, arity, lty)));\n+        tcx, ms, specialize(tcx, v, ctor, arity, lty).get());\n     match could_be_useful {\n       useful_ => useful(lty, ctor),\n       u => u\n@@ -287,7 +287,7 @@ fn missing_ctor(tcx: ty::ctxt, m: matrix, left_ty: ty::t) -> Option<ctor> {\n       ty::ty_enum(eid, _) => {\n         let mut found = ~[];\n         for m.each |r| {\n-            do option::iter(pat_ctor_id(tcx, r[0])) |id| {\n+            do option::iter(&pat_ctor_id(tcx, r[0])) |id| {\n                 if !vec::contains(found, id) { vec::push(found, id); }\n             }\n         }"}, {"sha": "e194a907ffda79ab51c43786f096b4aa0056c3c9", "filename": "src/rustc/middle/check_const.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4a78f9b16620489855da93c19be56f59431416f6/src%2Frustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a78f9b16620489855da93c19be56f59431416f6/src%2Frustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fcheck_const.rs?ref=4a78f9b16620489855da93c19be56f59431416f6", "patch": "@@ -27,7 +27,7 @@ fn check_item(sess: session, ast_map: ast_map::map,\n       }\n       item_enum(enum_definition, _) => {\n         for enum_definition.variants.each |var| {\n-            do option::iter(var.node.disr_expr) |ex| {\n+            do option::iter(&var.node.disr_expr) |ex| {\n                 v.visit_expr(ex, true, v);\n             }\n         }"}, {"sha": "b0206d4b95ffe0fa2951c7fd6615712906b78892", "filename": "src/rustc/middle/const_eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4a78f9b16620489855da93c19be56f59431416f6/src%2Frustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a78f9b16620489855da93c19be56f59431416f6/src%2Frustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fconst_eval.rs?ref=4a78f9b16620489855da93c19be56f59431416f6", "patch": "@@ -375,7 +375,7 @@ fn lit_to_const(lit: @lit) -> const_val {\n       lit_int(n, _) => const_int(n),\n       lit_uint(n, _) => const_uint(n),\n       lit_int_unsuffixed(n) => const_int(n),\n-      lit_float(n, _) => const_float(option::get(float::from_str(*n)) as f64),\n+      lit_float(n, _) => const_float(float::from_str(*n).get() as f64),\n       lit_nil => const_int(0i64),\n       lit_bool(b) => const_bool(b)\n     }"}, {"sha": "0f918ba92a9442f61ba81e3631ad993e790b4574", "filename": "src/rustc/middle/kind.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4a78f9b16620489855da93c19be56f59431416f6/src%2Frustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a78f9b16620489855da93c19be56f59431416f6/src%2Frustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fkind.rs?ref=4a78f9b16620489855da93c19be56f59431416f6", "patch": "@@ -248,7 +248,7 @@ fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n     };\n \n     // Handle any kind bounds on type parameters\n-    do option::iter(cx.tcx.node_type_substs.find(id_to_use)) |ts| {\n+    do option::iter(&cx.tcx.node_type_substs.find(id_to_use)) |ts| {\n         let bounds = match e.node {\n           expr_path(_) => {\n             let did = ast_util::def_id_of_def(cx.tcx.def_map.get(e.id));\n@@ -373,7 +373,7 @@ fn check_stmt(stmt: @stmt, cx: ctx, v: visit::vt<ctx>) {\n fn check_ty(aty: @ty, cx: ctx, v: visit::vt<ctx>) {\n     match aty.node {\n       ty_path(_, id) => {\n-        do option::iter(cx.tcx.node_type_substs.find(id)) |ts| {\n+        do option::iter(&cx.tcx.node_type_substs.find(id)) |ts| {\n             let did = ast_util::def_id_of_def(cx.tcx.def_map.get(id));\n             let bounds = ty::lookup_item_type(cx.tcx, did).bounds;\n             do vec::iter2(ts, *bounds) |ty, bound| {"}, {"sha": "1d6a8d8a6309aaace425b9dd27309e8c8ebcd409", "filename": "src/rustc/middle/resolve.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4a78f9b16620489855da93c19be56f59431416f6/src%2Frustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a78f9b16620489855da93c19be56f59431416f6/src%2Frustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve.rs?ref=4a78f9b16620489855da93c19be56f59431416f6", "patch": "@@ -1168,7 +1168,7 @@ impl Resolver {\n \n                 // Record the def ID of this struct.\n                 self.structs.insert(local_def(item.id),\n-                                    is_some(struct_definition.ctor));\n+                                    struct_definition.ctor.is_some());\n \n                 visit_item(item, new_parent, visitor);\n             }\n@@ -1607,7 +1607,7 @@ impl Resolver {\n         let modules = HashMap();\n \n         // Create all the items reachable by paths.\n-        for each_path(self.session.cstore, get(root.def_id).crate)\n+        for each_path(self.session.cstore, root.def_id.get().crate)\n                 |path_entry| {\n \n             debug!(\"(building reduced graph for external crate) found path \\"}, {"sha": "203074a2c1d323fa8187cb4584aea76f8c86871b", "filename": "src/rustc/middle/trans/alt.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4a78f9b16620489855da93c19be56f59431416f6/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a78f9b16620489855da93c19be56f59431416f6/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs?ref=4a78f9b16620489855da93c19be56f59431416f6", "patch": "@@ -354,7 +354,7 @@ fn enter_opt(bcx: block, m: &[@Match/&r], opt: &Opt, col: uint,\n         match p.node {\n             ast::pat_enum(_, subpats) => {\n                 if opt_eq(tcx, &variant_opt(tcx, p.id), opt) {\n-                    Some(option::get_default(subpats,\n+                    Some(option::get_default(&subpats,\n                                              vec::from_elem(variant_size,\n                                                             dummy)))\n                 } else {\n@@ -872,12 +872,12 @@ fn compile_submatch(bcx: block,\n     /*\n       For an empty match, a fall-through case must exist\n      */\n-    assert(m.len() > 0u || is_some(chk));\n+    assert(m.len() > 0u || chk.is_some());\n     let _icx = bcx.insn_ctxt(\"alt::compile_submatch\");\n     let mut bcx = bcx;\n     let tcx = bcx.tcx(), dm = tcx.def_map;\n     if m.len() == 0u {\n-        Br(bcx, option::get(chk)());\n+        Br(bcx, chk.get()());\n         return;\n     }\n     if m[0].pats.len() == 0u {\n@@ -1019,7 +1019,7 @@ fn compile_submatch(bcx: block,\n     };\n \n     let defaults = enter_default(else_cx, dm, m, col, val);\n-    let exhaustive = option::is_none(chk) && defaults.len() == 0u;\n+    let exhaustive = chk.is_none() && defaults.len() == 0u;\n     let len = opts.len();\n     let mut i = 0u;\n "}, {"sha": "964b418b765e402d631bcf360c50f2d114fe6d0d", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4a78f9b16620489855da93c19be56f59431416f6/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a78f9b16620489855da93c19be56f59431416f6/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=4a78f9b16620489855da93c19be56f59431416f6", "patch": "@@ -777,7 +777,7 @@ fn in_lpad_scope_cx(bcx: block, f: fn(scope_info)) {\n     loop {\n         match bcx.kind {\n           block_scope(inf) => {\n-            if inf.cleanups.len() > 0u || is_none(bcx.parent) {\n+            if inf.cleanups.len() > 0u || bcx.parent.is_none() {\n                 f(inf); return;\n             }\n           }\n@@ -1042,7 +1042,7 @@ fn new_block(cx: fn_ctxt, parent: Option<block>, +kind: block_kind,\n         llvm::LLVMAppendBasicBlock(cx.llfn, buf)\n     });\n     let bcx = mk_block(llbb, parent, move kind, is_lpad, opt_node_info, cx);\n-    do option::iter(parent) |cx| {\n+    do option::iter(&parent) |cx| {\n         if cx.unreachable { Unreachable(bcx); }\n     };\n     return bcx;\n@@ -1164,12 +1164,12 @@ fn cleanup_and_leave(bcx: block, upto: Option<BasicBlockRef>,\n         }\n         cur = match cur.parent {\n           Some(next) => next,\n-          None => { assert is_none(upto); break; }\n+          None => { assert upto.is_none(); break; }\n         };\n     }\n     match leave {\n       Some(target) => Br(bcx, target),\n-      None => { Resume(bcx, Load(bcx, option::get(bcx.fcx.personality))); }\n+      None => { Resume(bcx, Load(bcx, bcx.fcx.personality.get())); }\n     }\n }\n \n@@ -1251,7 +1251,7 @@ fn alloc_local(cx: block, local: @ast::local) -> block {\n     };\n     let val = alloc_ty(cx, t);\n     if cx.sess().opts.debuginfo {\n-        do option::iter(simple_name) |name| {\n+        do option::iter(&simple_name) |name| {\n             str::as_c_str(cx.ccx().sess.str_of(name), |buf| {\n                 llvm::LLVMSetValueName(val, buf)\n             });\n@@ -1601,7 +1601,7 @@ fn trans_closure(ccx: @crate_ctxt, path: path, decl: ast::fn_decl,\n        /* avoids the need for special cases to assign a type to\n           the constructor body (since it has no explicit return) */\n       &&\n-      (option::is_none(body.node.expr) ||\n+      (body.node.expr.is_none() ||\n        ty::type_is_bot(block_ty) ||\n        ty::type_is_nil(block_ty))  {\n         bcx = controlflow::trans_block(bcx, body, expr::Ignore);\n@@ -1728,7 +1728,7 @@ fn trans_class_ctor(ccx: @crate_ctxt, path: path, decl: ast::fn_decl,\n     let selfdatum = datum::scratch_datum(bcx_top, rslt_ty, true);\n \n     // Initialize dtor flag (if any) to 1\n-    if option::is_some(ty::ty_dtor(bcx_top.tcx(), parent_id)) {\n+    if ty::ty_dtor(bcx_top.tcx(), parent_id).is_some() {\n         let flag = GEPi(bcx_top, selfdatum.val, [0, 1]);\n         Store(bcx_top, C_u8(1), flag);\n     }\n@@ -1761,7 +1761,7 @@ fn trans_class_dtor(ccx: @crate_ctxt, path: path,\n   /* Look up the parent class's def_id */\n   let mut class_ty = ty::lookup_item_type(tcx, parent_id).ty;\n   /* Substitute in the class type if necessary */\n-    do option::iter(psubsts) |ss| {\n+    do option::iter(&psubsts) |ss| {\n     class_ty = ty::subst_tps(tcx, ss.tys, class_ty);\n   }\n \n@@ -1779,7 +1779,7 @@ fn trans_class_dtor(ccx: @crate_ctxt, path: path,\n \n   /* If we're monomorphizing, register the monomorphized decl\n      for the dtor */\n-    do option::iter(hash_id) |h_id| {\n+    do option::iter(&hash_id) |h_id| {\n     ccx.monomorphized.insert(h_id, lldecl);\n   }\n   /* Translate the dtor body */\n@@ -1889,12 +1889,12 @@ fn trans_struct_def(ccx: @crate_ctxt, struct_def: @ast::struct_def,\n       let psubsts = {tys: ty::ty_params_to_tys(ccx.tcx, tps),\n                      vtables: None,\n                      bounds: @~[]};\n-      do option::iter(struct_def.ctor) |ctor| {\n+      do option::iter(&struct_def.ctor) |ctor| {\n         trans_class_ctor(ccx, *path, ctor.node.dec, ctor.node.body,\n                          get_item_val(ccx, ctor.node.id), psubsts,\n                          ctor.node.id, local_def(id), ctor.span);\n       }\n-      do option::iter(struct_def.dtor) |dtor| {\n+      do option::iter(&struct_def.dtor) |dtor| {\n          trans_class_dtor(ccx, *path, dtor.node.body,\n            dtor.node.id, None, None, local_def(id));\n       };\n@@ -2070,7 +2070,7 @@ fn get_dtor_symbol(ccx: @crate_ctxt, path: path, id: ast::node_id,\n   let t = ty::node_id_to_type(ccx.tcx, id);\n   match ccx.item_symbols.find(id) {\n      Some(s) => s,\n-     None if is_none(substs) => {\n+     None if substs.is_none() => {\n        let s = mangle_exported_name(\n            ccx,\n            vec::append(path, ~[path_name(ccx.names(~\"dtor\"))]),"}, {"sha": "308ff75c82e59c36f2f5a7f31ca01df0bc1e87d2", "filename": "src/rustc/middle/trans/callee.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4a78f9b16620489855da93c19be56f59431416f6/src%2Frustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a78f9b16620489855da93c19be56f59431416f6/src%2Frustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=4a78f9b16620489855da93c19be56f59431416f6", "patch": "@@ -394,8 +394,8 @@ fn trans_call_inner(\n         if ty::type_is_bot(ret_ty) {\n             Unreachable(bcx);\n         } else if ret_in_loop {\n-            bcx = do with_cond(bcx, Load(bcx, option::get(ret_flag))) |bcx| {\n-                do option::iter(copy bcx.fcx.loop_ret) |lret| {\n+            bcx = do with_cond(bcx, Load(bcx, ret_flag.get())) |bcx| {\n+                do option::iter(&copy bcx.fcx.loop_ret) |lret| {\n                     Store(bcx, C_bool(true), lret.flagptr);\n                     Store(bcx, C_bool(false), bcx.fcx.llretptr);\n                 }"}, {"sha": "38526c223a1c62ea82e2ab97d80a0b6aeecaae9f", "filename": "src/rustc/middle/trans/closure.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4a78f9b16620489855da93c19be56f59431416f6/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a78f9b16620489855da93c19be56f59431416f6/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=4a78f9b16620489855da93c19be56f59431416f6", "patch": "@@ -279,7 +279,7 @@ fn build_closure(bcx0: block,\n \n     // If this is a `for` loop body, add two special environment\n     // variables:\n-    do option::iter(include_ret_handle) |flagptr| {\n+    do option::iter(&include_ret_handle) |flagptr| {\n         // Flag indicating we have returned (a by-ref bool):\n         let flag_datum = Datum {val: flagptr, ty: ty::mk_bool(tcx),\n                                 mode: ByRef, source: FromLvalue};\n@@ -375,9 +375,9 @@ fn trans_expr_fn(bcx: block,\n         trans_closure(ccx, sub_path, decl, body, llfn, no_self,\n                       bcx.fcx.param_substs, id, |fcx| {\n             load_environment(fcx, cdata_ty, cap_vars,\n-                             option::is_some(ret_handle), ck);\n+                             ret_handle.is_some(), ck);\n                       }, |bcx| {\n-            if option::is_some(is_loop_body) {\n+            if is_loop_body.is_some() {\n                 Store(bcx, C_bool(true), bcx.fcx.llretptr);\n             }\n         });"}, {"sha": "fce97516194a5266fe7684a420079654ad69cea1", "filename": "src/rustc/middle/trans/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4a78f9b16620489855da93c19be56f59431416f6/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a78f9b16620489855da93c19be56f59431416f6/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=4a78f9b16620489855da93c19be56f59431416f6", "patch": "@@ -1333,7 +1333,7 @@ fn find_vtable(tcx: ty::ctxt, ps: &param_substs,\n         }\n         i += 1u;\n     }\n-    option::get(ps.vtables)[vtable_off]\n+    ps.vtables.get()[vtable_off]\n }\n \n fn dummy_substs(tps: ~[ty::t]) -> ty::substs {"}, {"sha": "9944daefea40465b0b7af607583fff3ac5c039e8", "filename": "src/rustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/4a78f9b16620489855da93c19be56f59431416f6/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a78f9b16620489855da93c19be56f59431416f6/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=4a78f9b16620489855da93c19be56f59431416f6", "patch": "@@ -164,7 +164,7 @@ fn cached_metadata<T: Copy>(cache: metadata_cache, mdtag: int,\n fn create_compile_unit(cx: @crate_ctxt)\n     -> @metadata<compile_unit_md> unsafe {\n     let cache = get_cache(cx);\n-    let crate_name = option::get(cx.dbg_cx).crate_file;\n+    let crate_name = cx.dbg_cx.get().crate_file;\n     let tg = CompileUnitTag;\n     match cached_metadata::<@metadata<compile_unit_md>>(cache, tg,\n                         |md| md.data.name == crate_name) {\n@@ -194,7 +194,7 @@ fn create_compile_unit(cx: @crate_ctxt)\n }\n \n fn get_cache(cx: @crate_ctxt) -> metadata_cache {\n-    option::get(cx.dbg_cx).llmetadata\n+    cx.dbg_cx.get().llmetadata\n }\n \n fn get_file_path_and_dir(work_dir: &str, full_path: &str) -> (~str, ~str) {\n@@ -236,13 +236,13 @@ fn line_from_span(cm: codemap::codemap, sp: span) -> uint {\n fn create_block(cx: block) -> @metadata<block_md> {\n     let cache = get_cache(cx.ccx());\n     let mut cx = cx;\n-    while option::is_none(cx.node_info) {\n+    while cx.node_info.is_none() {\n         match cx.parent {\n           Some(b) => cx = b,\n           None => fail\n         }\n     }\n-    let sp = option::get(cx.node_info).span;\n+    let sp = cx.node_info.get().span;\n \n     let start = codemap::lookup_char_pos(cx.sess().codemap, sp.lo);\n     let fname = start.file.name;\n@@ -395,7 +395,7 @@ fn create_record(cx: @crate_ctxt, t: ty::t, fields: ~[ast::ty_field],\n     let file_node = create_file(cx, fname);\n     let scx = create_structure(file_node,\n                                cx.sess.str_of(\n-                                   option::get(cx.dbg_cx).names(~\"rec\")),\n+                                   cx.dbg_cx.get().names(~\"rec\")),\n                                line_from_span(cx.sess.codemap,\n                                               span) as int);\n     for fields.each |field| {\n@@ -452,15 +452,15 @@ fn create_composite_type(type_tag: int, name: ~str, file: ValueRef, line: int,\n                   lli64(align), // align\n                   lli32/*64*/(offset), // offset\n                   lli32(0), // flags\n-                  if option::is_none(derived) {\n+                  if derived.is_none() {\n                       llnull()\n                   } else { // derived from\n-                      option::get(derived)\n+                      derived.get()\n                   },\n-                  if option::is_none(members) {\n+                  if members.is_none() {\n                       llnull()\n                   } else { //members\n-                      llmdnode(option::get(members))\n+                      llmdnode(members.get())\n                   },\n                   lli32(0),  // runtime language\n                   llnull()\n@@ -711,12 +711,12 @@ fn update_source_pos(cx: block, s: span) {\n \n fn create_function(fcx: fn_ctxt) -> @metadata<subprogram_md> {\n     let cx = fcx.ccx;\n-    let dbg_cx = option::get(cx.dbg_cx);\n+    let dbg_cx = cx.dbg_cx.get();\n \n     debug!(\"~~\");\n     log(debug, fcx.id);\n \n-    let sp = option::get(fcx.span);\n+    let sp = fcx.span.get();\n     log(debug, codemap::span_to_str(sp, cx.sess.codemap));\n \n     let (ident, ret_ty, id) = match cx.tcx.items.get(fcx.id) {"}, {"sha": "6f018fcd1b131b0051998c4fb243e5c0a76ff651", "filename": "src/rustc/middle/trans/foreign.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4a78f9b16620489855da93c19be56f59431416f6/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a78f9b16620489855da93c19be56f59431416f6/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=4a78f9b16620489855da93c19be56f59431416f6", "patch": "@@ -392,7 +392,7 @@ fn x86_64_tys(atys: ~[TypeRef],\n     }\n     let mut (ret_ty, ret_attr) = x86_64_ty(rty, is_ret_bysret,\n                                        StructRetAttribute);\n-    let sret = option::is_some(ret_attr);\n+    let sret = ret_attr.is_some();\n     if sret {\n         arg_tys = vec::append(~[ret_ty], arg_tys);\n         ret_ty = { cast:  false,\n@@ -623,7 +623,7 @@ fn trans_foreign_mod(ccx: @crate_ctxt,\n                             let arg_ptr = BitCast(bcx, arg_ptr,\n                                               T_ptr(atys[i].ty));\n                             Load(bcx, arg_ptr)\n-                        } else if option::is_some(attrs[i]) {\n+                        } else if attrs[i].is_some() {\n                             GEPi(bcx, llargbundle, [0u, i])\n                         } else {\n                             load_inbounds(bcx, llargbundle, [0u, i])\n@@ -938,7 +938,7 @@ fn trans_intrinsic(ccx: @crate_ctxt, decl: ValueRef, item: @ast::foreign_item,\n             let tp_sz = shape::llsize_of_real(ccx, lltp_ty),\n             out_sz = shape::llsize_of_real(ccx, llout_ty);\n           if tp_sz != out_sz {\n-              let sp = match ccx.tcx.items.get(option::get(ref_id)) {\n+              let sp = match ccx.tcx.items.get(ref_id.get()) {\n                   ast_map::node_expr(e) => e.span,\n                   _ => fail ~\"reinterpret_cast or forget has non-expr arg\"\n               };\n@@ -1105,7 +1105,7 @@ fn trans_foreign_fn(ccx: @crate_ctxt, path: ast_map::path, decl: ast::fn_decl,\n                     let n = vec::len(atys);\n                     while i < n {\n                         let mut argval = get_param(llwrapfn, i + j);\n-                        if option::is_some(attrs[i]) {\n+                        if attrs[i].is_some() {\n                             argval = Load(bcx, argval);\n                             store_inbounds(bcx, argval, llargbundle,\n                                            [0u, i]);"}, {"sha": "8ac42bc22846de948fa9008efffb4e12d7a09a2c", "filename": "src/rustc/middle/trans/glue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4a78f9b16620489855da93c19be56f59431416f6/src%2Frustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a78f9b16620489855da93c19be56f59431416f6/src%2Frustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=4a78f9b16620489855da93c19be56f59431416f6", "patch": "@@ -316,7 +316,7 @@ fn call_tydesc_glue_full(++bcx: block, v: ValueRef, tydesc: ValueRef,\n \n     // When static type info is available, avoid casting parameter because the\n     // function already has the right type. Otherwise cast to generic pointer.\n-    let llrawptr = if is_none(static_ti) || is_none(static_glue_fn) {\n+    let llrawptr = if static_ti.is_none() || static_glue_fn.is_none() {\n         PointerCast(bcx, v, T_ptr(T_i8()))\n     } else {\n         v\n@@ -397,7 +397,7 @@ fn make_free_glue(bcx: block, v: ValueRef, t: ty::t) {\n       }\n       ty::ty_class(did, ref substs) => {\n         // Call the dtor if there is one\n-        do option::map_default(ty::ty_dtor(bcx.tcx(), did), bcx) |dt_id| {\n+        do option::map_default(&ty::ty_dtor(bcx.tcx(), did), bcx) |dt_id| {\n             trans_class_drop(bcx, v, dt_id, did, substs)\n         }\n       }"}, {"sha": "33df35cca52b0cfcb920d24c826cad4f616692c2", "filename": "src/rustc/middle/trans/meth.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4a78f9b16620489855da93c19be56f59431416f6/src%2Frustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a78f9b16620489855da93c19be56f59431416f6/src%2Frustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=4a78f9b16620489855da93c19be56f59431416f6", "patch": "@@ -206,7 +206,7 @@ fn trans_static_method_callee(bcx: block,\n \n fn method_from_methods(ms: ~[@ast::method], name: ast::ident)\n     -> ast::def_id {\n-  local_def(option::get(vec::find(ms, |m| m.ident == name)).id)\n+  local_def(option::get(&vec::find(ms, |m| m.ident == name)).id)\n }\n \n fn method_with_name(ccx: @crate_ctxt, impl_id: ast::def_id,"}, {"sha": "8a68ef4823b41a58659e39904e3623a0c5dadce3", "filename": "src/rustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4a78f9b16620489855da93c19be56f59431416f6/src%2Frustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a78f9b16620489855da93c19be56f59431416f6/src%2Frustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=4a78f9b16620489855da93c19be56f59431416f6", "patch": "@@ -99,7 +99,7 @@ fn monomorphic_fn(ccx: @crate_ctxt,\n \n     ccx.stats.n_monos += 1;\n \n-    let depth = option::get_default(ccx.monomorphizing.find(fn_id), 0u);\n+    let depth = option::get_default(&ccx.monomorphizing.find(fn_id), 0u);\n     // Random cut-off -- code that needs to instantiate the same function\n     // recursively more than ten times can probably safely be assumed to be\n     // causing an infinite expansion.\n@@ -132,13 +132,13 @@ fn monomorphic_fn(ccx: @crate_ctxt,\n       }\n       ast_map::node_foreign_item(i, _, _) => {\n           let d = mk_lldecl();\n-          foreign::trans_intrinsic(ccx, d, i, pt, option::get(psubsts),\n+          foreign::trans_intrinsic(ccx, d, i, pt, psubsts.get(),\n                                 ref_id);\n           d\n       }\n       ast_map::node_variant(v, enum_item, _) => {\n         let tvs = ty::enum_variants(ccx.tcx, local_def(enum_item.id));\n-        let this_tv = option::get(vec::find(*tvs, |tv| {\n+        let this_tv = option::get(&vec::find(*tvs, |tv| {\n             tv.id.node == fn_id.node}));\n         let d = mk_lldecl();\n         set_inline_hint(d);\n@@ -166,7 +166,7 @@ fn monomorphic_fn(ccx: @crate_ctxt,\n         let d = mk_lldecl();\n         let tp_tys = ty::ty_params_to_tys(ccx.tcx, tps);\n         trans_class_ctor(ccx, pt, ctor.node.dec, ctor.node.body, d,\n-               option::get_default(psubsts,\n+               option::get_default(&psubsts,\n                         {tys:tp_tys, vtables: None, bounds: @~[]}),\n                          fn_id.node, parent_id, ctor.span);\n         d"}, {"sha": "3c4439c918fbda9b0217074b72b805dff69112a0", "filename": "src/rustc/middle/trans/reachable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4a78f9b16620489855da93c19be56f59431416f6/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a78f9b16620489855da93c19be56f59431416f6/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs?ref=4a78f9b16620489855da93c19be56f59431416f6", "patch": "@@ -104,14 +104,14 @@ fn traverse_public_item(cx: ctx, item: @item) {\n         }\n       }\n       item_class(struct_def, tps) => {\n-        do option::iter(struct_def.ctor) |ctor| {\n+        do option::iter(&struct_def.ctor) |ctor| {\n             cx.rmap.insert(ctor.node.id, ());\n             if tps.len() > 0u || attr::find_inline_attr(ctor.node.attrs)\n                      != attr::ia_none {\n                 traverse_inline_body(cx, ctor.node.body);\n             }\n         }\n-        do option::iter(struct_def.dtor) |dtor| {\n+        do option::iter(&struct_def.dtor) |dtor| {\n             cx.rmap.insert(dtor.node.id, ());\n             if tps.len() > 0u || attr::find_inline_attr(dtor.node.attrs)\n                      != attr::ia_none {"}, {"sha": "cdd11ee85c5716048ca559fedce4465a11b88592", "filename": "src/rustc/middle/trans/reflect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4a78f9b16620489855da93c19be56f59431416f6/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a78f9b16620489855da93c19be56f59431416f6/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=4a78f9b16620489855da93c19be56f59431416f6", "patch": "@@ -58,7 +58,7 @@ impl reflector {\n \n     fn visit(ty_name: ~str, args: ~[ValueRef]) {\n         let tcx = self.bcx.tcx();\n-        let mth_idx = option::get(ty::method_idx(\n+        let mth_idx = option::get(&ty::method_idx(\n             tcx.sess.ident_of(~\"visit_\" + ty_name),\n             *self.visitor_methods));\n         let mth_ty = ty::mk_fn(tcx, self.visitor_methods[mth_idx].fty);"}, {"sha": "34a499c7e131272a167829f86986bd27dacc87f7", "filename": "src/rustc/middle/trans/shape.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4a78f9b16620489855da93c19be56f59431416f6/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a78f9b16620489855da93c19be56f59431416f6/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs?ref=4a78f9b16620489855da93c19be56f59431416f6", "patch": "@@ -351,11 +351,11 @@ fn shape_of(ccx: @crate_ctxt, t: ty::t) -> ~[u8] {\n             // same as records, unless there's a dtor\n             let tps = substs.tps;\n             let m_dtor_did = ty::ty_dtor(ccx.tcx, did);\n-            let mut s = if option::is_some(m_dtor_did) {\n+            let mut s = if m_dtor_did.is_some() {\n                 ~[shape_res]\n             }\n             else { ~[shape_struct] }, sub = ~[];\n-            do option::iter(m_dtor_did) |dtor_did| {\n+            do m_dtor_did.iter |dtor_did| {\n                 let ri = @{did: dtor_did, parent_id: Some(did), tps: tps};\n                 let id = ccx.shape_cx.resources.intern(ri);\n                 add_u16(s, id as u16);\n@@ -601,7 +601,7 @@ fn gen_resource_shapes(ccx: @crate_ctxt) -> ValueRef {\n     for uint::range(0u, len) |i| {\n         let ri = ccx.shape_cx.resources.get(i);\n         for ri.tps.each() |s| { assert !ty::type_has_params(*s); }\n-        do option::iter(ri.parent_id) |id| {\n+        do ri.parent_id.iter |id| {\n             dtors += ~[trans::base::get_res_dtor(ccx, ri.did, id, ri.tps)];\n         }\n     }\n@@ -630,7 +630,7 @@ fn force_declare_tydescs(ccx: @crate_ctxt) {\n     for uint::range(0u, len) |i| {\n         let ri = ccx.shape_cx.resources.get(i);\n         for ri.tps.each() |s| { assert !ty::type_has_params(*s); }\n-        do option::iter(ri.parent_id) |id| {\n+        do ri.parent_id.iter |id| {\n             trans::base::get_res_dtor(ccx, ri.did, id, ri.tps);\n         }\n     }\n@@ -782,7 +782,7 @@ fn simplify_type(tcx: ty::ctxt, typ: ty::t) -> ty::t {\n           // Reduce a class type to a record type in which all the fields are\n           // simplified\n           ty::ty_class(did, ref substs) => {\n-            let simpl_fields = (if is_some(ty::ty_dtor(tcx, did)) {\n+            let simpl_fields = (if ty::ty_dtor(tcx, did).is_some() {\n                 // remember the drop flag\n                   ~[{ident: syntax::parse::token::special_idents::dtor,\n                      mt: {ty: ty::mk_u8(tcx),"}, {"sha": "8a0873f058511c50bfa0fcdb3ebc1898bd501a0d", "filename": "src/rustc/middle/trans/type_use.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4a78f9b16620489855da93c19be56f59431416f6/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a78f9b16620489855da93c19be56f59431416f6/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=4a78f9b16620489855da93c19be56f59431416f6", "patch": "@@ -146,7 +146,7 @@ fn type_needs_inner(cx: ctx, use_: uint, ty: ty::t,\n               ty::ty_fn(_) | ty::ty_ptr(_) | ty::ty_rptr(_, _)\n                | ty::ty_trait(_, _, _) => false,\n               ty::ty_enum(did, substs) => {\n-                if option::is_none(list::find(enums_seen, |id| *id == did)) {\n+                if option::is_none(&list::find(enums_seen, |id| *id == did)) {\n                     let seen = @Cons(did, enums_seen);\n                     for vec::each(*ty::enum_variants(cx.ccx.tcx, did)) |v| {\n                         for vec::each(v.args) |aty| {\n@@ -234,10 +234,10 @@ fn mark_for_expr(cx: ctx, e: @expr) {\n         let base_ty = ty::node_id_to_type(cx.ccx.tcx, base.id);\n         type_needs(cx, use_repr, ty::type_autoderef(cx.ccx.tcx, base_ty));\n \n-        do option::iter(cx.ccx.maps.method_map.find(e.id)) |mth| {\n+        do option::iter(&cx.ccx.maps.method_map.find(e.id)) |mth| {\n             match mth.origin {\n               typeck::method_static(did) => {\n-                do option::iter(cx.ccx.tcx.node_type_substs.find(e.id)) |ts| {\n+                do cx.ccx.tcx.node_type_substs.find(e.id).iter |ts| {\n                     do vec::iter2(type_uses_for(cx.ccx, did, ts.len()), ts)\n                         |uses, subst| { type_needs(cx, uses, subst)}\n                 }\n@@ -289,7 +289,7 @@ fn handle_body(cx: ctx, body: blk) {\n         },\n         visit_block: |b, cx, v| {\n             visit::visit_block(b, cx, v);\n-            do option::iter(b.node.expr) |e| {\n+            do option::iter(&b.node.expr) |e| {\n                 node_type_needs(cx, use_repr, e.id);\n             }\n         },"}, {"sha": "4f753f7163ccba7a0489b07a7325a51f8703543b", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4a78f9b16620489855da93c19be56f59431416f6/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a78f9b16620489855da93c19be56f59431416f6/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=4a78f9b16620489855da93c19be56f59431416f6", "patch": "@@ -1691,7 +1691,7 @@ fn type_needs_drop(cx: ctxt, ty: t) -> bool {\n       }\n       ty_class(did, ref substs) => {\n          // Any class with a dtor needs a drop\n-         option::is_some(ty_dtor(cx, did)) || {\n+         ty_dtor(cx, did).is_some() || {\n              for vec::each(ty::class_items_as_fields(cx, did, substs)) |f| {\n                  if type_needs_drop(cx, f.mt.ty) { accum = true; }\n              }\n@@ -3454,7 +3454,7 @@ fn impl_traits(cx: ctxt, id: ast::def_id) -> ~[t] {\n                         _},\n                     _)) => {\n \n-               do option::map_default(opt_trait, ~[]) |trait_ref| {\n+               do option::map_default(&opt_trait, ~[]) |trait_ref| {\n                        ~[node_id_to_type(cx, trait_ref.ref_id)]\n                    }\n            }\n@@ -3519,7 +3519,7 @@ fn ty_dtor(cx: ctxt, class_id: def_id) -> Option<def_id> {\n }\n \n fn has_dtor(cx: ctxt, class_id: def_id) -> bool {\n-    option::is_some(ty_dtor(cx, class_id))\n+    ty_dtor(cx, class_id).is_some()\n }\n \n fn item_path(cx: ctxt, id: ast::def_id) -> ast_map::path {"}, {"sha": "cfc14999430ceb40185dfa97eefe160889a7743b", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4a78f9b16620489855da93c19be56f59431416f6/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a78f9b16620489855da93c19be56f59431416f6/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=4a78f9b16620489855da93c19be56f59431416f6", "patch": "@@ -176,7 +176,7 @@ trait get_and_find_region {\n \n impl isr_alist: get_and_find_region {\n     fn get(br: ty::bound_region) -> ty::region {\n-        option::get(self.find(br))\n+        self.find(br).get()\n     }\n \n     fn find(br: ty::bound_region) -> Option<ty::region> {\n@@ -227,7 +227,7 @@ fn check_fn(ccx: @crate_ctxt,\n     // the node_id of the body block.\n \n     let {isr, self_info, fn_ty} = {\n-        let old_isr = option::map_default(old_fcx, @Nil,\n+        let old_isr = option::map_default(&old_fcx, @Nil,\n                                          |fcx| fcx.in_scope_regions);\n         replace_bound_regions_in_fn_ty(tcx, old_isr, self_info, fn_ty,\n                                        |br| ty::re_free(body.node.id, br))\n@@ -239,7 +239,7 @@ fn check_fn(ccx: @crate_ctxt,\n     debug!(\"check_fn(arg_tys=%?, ret_ty=%?, self_info.self_ty=%?)\",\n            arg_tys.map(|a| ty_to_str(tcx, *a)),\n            ty_to_str(tcx, ret_ty),\n-           option::map(self_info, |s| ty_to_str(tcx, s.self_ty)));\n+           option::map(&self_info, |s| ty_to_str(tcx, s.self_ty)));\n \n     // ______________________________________________________________________\n     // Create the function context.  This is either derived from scratch or,\n@@ -258,7 +258,7 @@ fn check_fn(ccx: @crate_ctxt,\n         };\n \n         let indirect_ret_ty = if indirect_ret {\n-            let ofcx = option::get(old_fcx);\n+            let ofcx = old_fcx.get();\n             match ofcx.indirect_ret_ty {\n               Some(t) => Some(t),\n               None => Some(ofcx.ret_ty)\n@@ -316,7 +316,7 @@ fn check_fn(ccx: @crate_ctxt,\n     // force any remaining type vars to be resolved.\n     // If we have an enclosing function scope, our type variables will be\n     // resolved when the enclosing scope finishes up.\n-    if option::is_none(old_fcx) {\n+    if old_fcx.is_none() {\n         vtable::resolve_in_block(fcx, body);\n         regionck::regionck_fn(fcx, decl, body);\n         writeback::resolve_type_vars_in_fn(fcx, decl, body, self_info);\n@@ -451,7 +451,7 @@ fn check_struct(ccx: @crate_ctxt, struct_def: @ast::struct_def,\n     let tcx = ccx.tcx;\n     let self_ty = ty::node_id_to_type(tcx, id);\n \n-    do option::iter(struct_def.ctor) |ctor| {\n+    do option::iter(&struct_def.ctor) |ctor| {\n         let class_t = {self_ty: self_ty,\n                        self_id: ctor.node.self_id,\n                        def_id: local_def(id),\n@@ -463,7 +463,7 @@ fn check_struct(ccx: @crate_ctxt, struct_def: @ast::struct_def,\n                       Some(class_t));\n     }\n \n-    do option::iter(struct_def.dtor) |dtor| {\n+    do option::iter(&struct_def.dtor) |dtor| {\n         let class_t = {self_ty: self_ty,\n                        self_id: dtor.node.self_id,\n                        def_id: local_def(id),\n@@ -935,7 +935,7 @@ fn lookup_field_ty(tcx: ty::ctxt,\n                    substs: &ty::substs) -> Option<ty::t> {\n \n     let o_field = vec::find(items, |f| f.ident == fieldname);\n-    do option::map(o_field) |f| {\n+    do o_field.map() |f| {\n         ty::lookup_field_type(tcx, class_id, f.id, substs)\n     }\n }\n@@ -1864,7 +1864,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         fcx.write_ty(id, typ);\n       }\n       ast::expr_rec(fields, base) => {\n-        option::iter(base, |b| { check_expr(fcx, b, expected); });\n+        option::iter(&base, |b| { check_expr(fcx, b, expected); });\n         let expected = if expected.is_none() && base.is_some() {\n             Some(fcx.expr_ty(base.get()))\n         } else { expected };"}, {"sha": "61d85b2dbfa04016f65777b5527cbd329dedab68", "filename": "src/rustc/middle/typeck/check/alt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4a78f9b16620489855da93c19be56f59431416f6/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a78f9b16620489855da93c19be56f59431416f6/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs?ref=4a78f9b16620489855da93c19be56f59431416f6", "patch": "@@ -163,7 +163,7 @@ fn check_pat_variant(pcx: pat_ctxt, pat: @ast::pat, path: @ast::path,\n                 tcx.sess.span_fatal(pat.span, s);\n             }\n \n-            do option::iter(subpats) |pats| {\n+            do subpats.iter() |pats| {\n                 do vec::iter2(pats, arg_types) |subpat, arg_ty| {\n                   check_pat(pcx, subpat, arg_ty);\n                 }"}, {"sha": "630ac8c13a194952a9131ba3fcef0b3a72175e38", "filename": "src/rustc/middle/typeck/collect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4a78f9b16620489855da93c19be56f59431416f6/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a78f9b16620489855da93c19be56f59431416f6/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=4a78f9b16620489855da93c19be56f59431416f6", "patch": "@@ -497,7 +497,7 @@ fn convert_struct(ccx: @crate_ctxt,\n                   tpt: ty::ty_param_bounds_and_ty,\n                   id: ast::node_id) {\n     let tcx = ccx.tcx;\n-    do option::iter(struct_def.ctor) |ctor| {\n+    do option::iter(&struct_def.ctor) |ctor| {\n         // Write the ctor type\n         let t_args = ctor.node.dec.inputs.map(\n             |a| ty_of_arg(ccx, type_rscope(rp), *a, None) );\n@@ -522,7 +522,7 @@ fn convert_struct(ccx: @crate_ctxt,\n                            ty: t_ctor});\n     }\n \n-    do option::iter(struct_def.dtor) |dtor| {\n+    do option::iter(&struct_def.dtor) |dtor| {\n         // Write the dtor type\n         let t_dtor = ty::mk_fn(\n             tcx,"}, {"sha": "b3ba7f1410971c3fd2e4dcc0d38d99682fc68423", "filename": "src/rustdoc/attr_pass.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4a78f9b16620489855da93c19be56f59431416f6/src%2Frustdoc%2Fattr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a78f9b16620489855da93c19be56f59431416f6/src%2Frustdoc%2Fattr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fattr_pass.rs?ref=4a78f9b16620489855da93c19be56f59431416f6", "patch": "@@ -52,7 +52,7 @@ fn fold_crate(\n     {\n         topmod: doc::ModDoc_({\n             item: {\n-                name: option::get_default(attrs.name, doc.topmod.name()),\n+                name: option::get_default(&attrs.name, doc.topmod.name()),\n                 .. doc.topmod.item\n             },\n             .. *doc.topmod\n@@ -150,7 +150,7 @@ fn fold_enum(\n                     node: ast::item_enum(enum_definition, _), _\n                   }, _) => {\n                     let ast_variant = option::get(\n-                        vec::find(enum_definition.variants, |v| {\n+                        &vec::find(enum_definition.variants, |v| {\n                             to_str(v.node.name) == variant.name\n                         }));\n "}, {"sha": "383b002110aa56aabd8beace469a71c3412b2164", "filename": "src/rustdoc/config.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4a78f9b16620489855da93c19be56f59431416f6/src%2Frustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a78f9b16620489855da93c19be56f59431416f6/src%2Frustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fconfig.rs?ref=4a78f9b16620489855da93c19be56f59431416f6", "patch": "@@ -159,16 +159,16 @@ fn config_from_opts(\n     let result = result::Ok(config);\n     let result = do result::chain(result) |config| {\n         let output_dir = getopts::opt_maybe_str(matches, opt_output_dir());\n-        let output_dir = option::map(output_dir, |s| Path(s));\n+        let output_dir = output_dir.map(|s| Path(s));\n         result::Ok({\n-            output_dir: option::get_default(output_dir, config.output_dir),\n+            output_dir: output_dir.get_default(config.output_dir),\n             .. config\n         })\n     };\n     let result = do result::chain(result) |config| {\n         let output_format = getopts::opt_maybe_str(\n             matches, opt_output_format());\n-        do option::map_default(output_format, result::Ok(config))\n+        do output_format.map_default(result::Ok(config))\n             |output_format| {\n             do result::chain(parse_output_format(output_format))\n                 |output_format| {\n@@ -183,7 +183,7 @@ fn config_from_opts(\n     let result = do result::chain(result) |config| {\n         let output_style =\n             getopts::opt_maybe_str(matches, opt_output_style());\n-        do option::map_default(output_style, result::Ok(config))\n+        do output_style.map_default(result::Ok(config))\n             |output_style| {\n             do result::chain(parse_output_style(output_style))\n                 |output_style| {\n@@ -251,7 +251,7 @@ fn maybe_find_pandoc(\n         output.status == 0\n     };\n \n-    if option::is_some(pandoc) {\n+    if pandoc.is_some() {\n         result::Ok(pandoc)\n     } else {\n         result::Err(~\"couldn't find pandoc\")"}, {"sha": "b517c2f24091f6e9e42535439f35d55371c2a37e", "filename": "src/rustdoc/desc_to_brief_pass.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4a78f9b16620489855da93c19be56f59431416f6/src%2Frustdoc%2Fdesc_to_brief_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a78f9b16620489855da93c19be56f59431416f6/src%2Frustdoc%2Fdesc_to_brief_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fdesc_to_brief_pass.rs?ref=4a78f9b16620489855da93c19be56f59431416f6", "patch": "@@ -94,11 +94,11 @@ mod test {\n }\n \n fn extract(desc: Option<~str>) -> Option<~str> {\n-    if option::is_none(desc) {\n+    if desc.is_none() {\n         return None\n     }\n \n-    parse_desc(option::get(desc))\n+    parse_desc(desc.get())\n }\n \n fn parse_desc(desc: ~str) -> Option<~str> {"}, {"sha": "a9426ee9ffd5c0d3c2b4974f02b5dda3048a3978", "filename": "src/rustdoc/doc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4a78f9b16620489855da93c19be56f59431416f6/src%2Frustdoc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a78f9b16620489855da93c19be56f59431416f6/src%2Frustdoc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fdoc.rs?ref=4a78f9b16620489855da93c19be56f59431416f6", "patch": "@@ -635,7 +635,7 @@ impl IndexEntry : cmp::Eq {\n \n impl Doc {\n     fn CrateDoc() -> CrateDoc {\n-        option::get(vec::foldl(None, self.pages, |_m, page| {\n+        option::get(&vec::foldl(None, self.pages, |_m, page| {\n             match page {\n               doc::CratePage(doc) => Some(doc),\n               _ => None"}, {"sha": "e8b8bd1a9fd1c748f39b4d7d474c331b04c31446", "filename": "src/rustdoc/markdown_index_pass.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4a78f9b16620489855da93c19be56f59431416f6/src%2Frustdoc%2Fmarkdown_index_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a78f9b16620489855da93c19be56f59431416f6/src%2Frustdoc%2Fmarkdown_index_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fmarkdown_index_pass.rs?ref=4a78f9b16620489855da93c19be56f59431416f6", "patch": "@@ -152,13 +152,13 @@ fn should_index_mod_contents() {\n         config::DocPerCrate,\n         ~\"mod a { } fn b() { }\"\n     );\n-    assert option::get(doc.cratemod().index).entries[0] == {\n+    assert doc.cratemod().index.get().entries[0] == {\n         kind: ~\"Module\",\n         name: ~\"a\",\n         brief: None,\n         link: ~\"#module-a\"\n     };\n-    assert option::get(doc.cratemod().index).entries[1] == {\n+    assert doc.cratemod().index.get().entries[1] == {\n         kind: ~\"Function\",\n         name: ~\"b\",\n         brief: None,\n@@ -172,13 +172,13 @@ fn should_index_mod_contents_multi_page() {\n         config::DocPerMod,\n         ~\"mod a { } fn b() { }\"\n     );\n-    assert option::get(doc.cratemod().index).entries[0] == {\n+    assert doc.cratemod().index.get().entries[0] == {\n         kind: ~\"Module\",\n         name: ~\"a\",\n         brief: None,\n         link: ~\"a.html\"\n     };\n-    assert option::get(doc.cratemod().index).entries[1] == {\n+    assert doc.cratemod().index.get().entries[1] == {\n         kind: ~\"Function\",\n         name: ~\"b\",\n         brief: None,\n@@ -192,7 +192,7 @@ fn should_index_foreign_mod_pages() {\n         config::DocPerMod,\n         ~\"extern mod a { }\"\n     );\n-    assert option::get(doc.cratemod().index).entries[0] == {\n+    assert doc.cratemod().index.get().entries[0] == {\n         kind: ~\"Foreign module\",\n         name: ~\"a\",\n         brief: None,\n@@ -206,7 +206,7 @@ fn should_add_brief_desc_to_index() {\n         config::DocPerMod,\n         ~\"#[doc = \\\"test\\\"] mod a { }\"\n     );\n-    assert option::get(doc.cratemod().index).entries[0].brief\n+    assert doc.cratemod().index.get().entries[0].brief\n         == Some(~\"test\");\n }\n \n@@ -216,7 +216,7 @@ fn should_index_foreign_mod_contents() {\n         config::DocPerCrate,\n         ~\"extern mod a { fn b(); }\"\n     );\n-    assert option::get(doc.cratemod().nmods()[0].index).entries[0] == {\n+    assert doc.cratemod().nmods()[0].index.get().entries[0] == {\n         kind: ~\"Function\",\n         name: ~\"b\",\n         brief: None,"}, {"sha": "924e4be63054c8d4611f6aef1856d1f02d73fb9d", "filename": "src/rustdoc/markdown_pass.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/4a78f9b16620489855da93c19be56f59431416f6/src%2Frustdoc%2Fmarkdown_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a78f9b16620489855da93c19be56f59431416f6/src%2Frustdoc%2Fmarkdown_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fmarkdown_pass.rs?ref=4a78f9b16620489855da93c19be56f59431416f6", "patch": "@@ -66,10 +66,10 @@ fn should_write_modules_last() {\n          fn d() { }\"\n     );\n \n-    let idx_a = option::get(str::find_str(markdown, ~\"# Module `a`\"));\n-    let idx_b = option::get(str::find_str(markdown, ~\"## Function `b`\"));\n-    let idx_c = option::get(str::find_str(markdown, ~\"# Module `c`\"));\n-    let idx_d = option::get(str::find_str(markdown, ~\"## Function `d`\"));\n+    let idx_a = str::find_str(markdown, ~\"# Module `a`\").get();\n+    let idx_b = str::find_str(markdown, ~\"## Function `b`\").get();\n+    let idx_c = str::find_str(markdown, ~\"# Module `c`\").get();\n+    let idx_d = str::find_str(markdown, ~\"## Function `d`\").get();\n \n     assert idx_b < idx_d;\n     assert idx_d < idx_a;\n@@ -227,8 +227,8 @@ fn header_name(doc: doc::ItemTag) -> ~str {\n         fullpath\n       }\n       doc::ImplTag(doc) => {\n-        assert option::is_some(doc.self_ty);\n-        let self_ty = option::get(doc.self_ty);\n+        assert doc.self_ty.is_some();\n+        let self_ty = doc.self_ty.get();\n         let mut trait_part = ~\"\";\n         for doc.trait_types.eachi |i, trait_type| {\n             if i == 0 {\n@@ -345,8 +345,8 @@ fn write_mod_contents(\n     doc: doc::ModDoc\n ) {\n     write_common(ctxt, doc.desc(), doc.sections());\n-    if option::is_some(doc.index) {\n-        write_index(ctxt, option::get(doc.index));\n+    if doc.index.is_some() {\n+        write_index(ctxt, doc.index.get());\n     }\n \n     for doc.items.each |itemTag| {\n@@ -405,9 +405,9 @@ fn write_index(ctxt: Ctxt, index: doc::Index) {\n     for index.entries.each |entry| {\n         let header = header_text_(entry.kind, entry.name);\n         let id = entry.link;\n-        if option::is_some(entry.brief) {\n+        if entry.brief.is_some() {\n             ctxt.w.write_line(fmt!(\"* [%s](%s) - %s\",\n-                                   header, id, option::get(entry.brief)));\n+                                   header, id, entry.brief.get()));\n         } else {\n             ctxt.w.write_line(fmt!(\"* [%s](%s)\", header, id));\n         }\n@@ -448,8 +448,8 @@ fn should_write_index_for_foreign_mods() {\n \n fn write_nmod(ctxt: Ctxt, doc: doc::NmodDoc) {\n     write_common(ctxt, doc.desc(), doc.sections());\n-    if option::is_some(doc.index) {\n-        write_index(ctxt, option::get(doc.index));\n+    if doc.index.is_some() {\n+        write_index(ctxt, doc.index.get());\n     }\n \n     for doc.fns.each |FnDoc| {\n@@ -623,8 +623,8 @@ fn write_variants(\n }\n \n fn write_variant(ctxt: Ctxt, doc: doc::VariantDoc) {\n-    assert option::is_some(doc.sig);\n-    let sig = option::get(doc.sig);\n+    assert doc.sig.is_some();\n+    let sig = doc.sig.get();\n     match doc.desc {\n       Some(desc) => {\n         ctxt.w.write_line(fmt!(\"* `%s` - %s\", sig, desc));"}, {"sha": "d0fe7a3840b38cc084e08ffead3127a347e75c37", "filename": "src/rustdoc/markdown_writer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4a78f9b16620489855da93c19be56f59431416f6/src%2Frustdoc%2Fmarkdown_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a78f9b16620489855da93c19be56f59431416f6/src%2Frustdoc%2Fmarkdown_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fmarkdown_writer.rs?ref=4a78f9b16620489855da93c19be56f59431416f6", "patch": "@@ -74,8 +74,8 @@ fn pandoc_writer(\n     config: config::Config,\n     page: doc::Page\n ) -> Writer {\n-    assert option::is_some(config.pandoc_cmd);\n-    let pandoc_cmd = option::get(config.pandoc_cmd);\n+    assert config.pandoc_cmd.is_some();\n+    let pandoc_cmd = config.pandoc_cmd.get();\n     let filename = make_local_filename(config, page);\n \n     let pandoc_args = ~["}, {"sha": "8710792f0e4764554721bc86dd22d03d57ff0f35", "filename": "src/rustdoc/page_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4a78f9b16620489855da93c19be56f59431416f6/src%2Frustdoc%2Fpage_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a78f9b16620489855da93c19be56f59431416f6/src%2Frustdoc%2Fpage_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fpage_pass.rs?ref=4a78f9b16620489855da93c19be56f59431416f6", "patch": "@@ -45,7 +45,7 @@ fn make_doc_from_pages(page_port: PagePort) -> doc::Doc {\n     let mut pages = ~[];\n     loop {\n         let val = comm::recv(page_port);\n-        if option::is_some(val) {\n+        if val.is_some() {\n             pages += ~[option::unwrap(val)];\n         } else {\n             break;"}, {"sha": "2203707ed21318f0bf1abbbe28b415d36d883553", "filename": "src/rustdoc/sectionalize_pass.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4a78f9b16620489855da93c19be56f59431416f6/src%2Frustdoc%2Fsectionalize_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a78f9b16620489855da93c19be56f59431416f6/src%2Frustdoc%2Fsectionalize_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fsectionalize_pass.rs?ref=4a78f9b16620489855da93c19be56f59431416f6", "patch": "@@ -84,11 +84,11 @@ fn sectionalize(desc: Option<~str>) -> (Option<~str>, ~[doc::Section]) {\n      * and remove each header and accompanying text into section records.\n      */\n \n-    if option::is_none(desc) {\n+    if desc.is_none() {\n         return (None, ~[]);\n     }\n \n-    let lines = str::lines(option::get(desc));\n+    let lines = str::lines(desc.get());\n \n     let mut new_desc = None::<~str>;\n     let mut current_section = None;\n@@ -97,8 +97,8 @@ fn sectionalize(desc: Option<~str>) -> (Option<~str>, ~[doc::Section]) {\n     for lines.each |line| {\n         match parse_header(*line) {\n           Some(header) => {\n-            if option::is_some(current_section) {\n-                sections += ~[option::get(current_section)];\n+            if current_section.is_some() {\n+                sections += ~[current_section.get()];\n             }\n             current_section = Some({\n                 header: header,\n@@ -128,8 +128,8 @@ fn sectionalize(desc: Option<~str>) -> (Option<~str>, ~[doc::Section]) {\n         }\n     }\n \n-    if option::is_some(current_section) {\n-        sections += ~[option::get(current_section)];\n+    if current_section.is_some() {\n+        sections += ~[current_section.get()];\n     }\n \n     (new_desc, sections)\n@@ -190,10 +190,10 @@ fn should_remove_section_text_from_main_desc() {\n          mod a {\n              #[legacy_exports]; }\");\n     assert !str::contains(\n-        option::get(doc.cratemod().mods()[0].desc()),\n+        doc.cratemod().mods()[0].desc().get(),\n         ~\"Header\");\n     assert !str::contains(\n-        option::get(doc.cratemod().mods()[0].desc()),\n+        doc.cratemod().mods()[0].desc().get(),\n         ~\"Body\");\n }\n "}, {"sha": "76ae3192cef9c58e149f29a8b92d76f01566e05f", "filename": "src/rustdoc/text_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4a78f9b16620489855da93c19be56f59431416f6/src%2Frustdoc%2Ftext_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a78f9b16620489855da93c19be56f59431416f6/src%2Frustdoc%2Ftext_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Ftext_pass.rs?ref=4a78f9b16620489855da93c19be56f59431416f6", "patch": "@@ -32,7 +32,7 @@ fn run(\n }\n \n fn maybe_apply_op(op: Op, s: Option<~str>) -> Option<~str> {\n-    option::map(s, |s| op(s) )\n+    s.map(|s| op(s) )\n }\n \n fn fold_item(fold: fold::Fold<Op>, doc: doc::ItemDoc) -> doc::ItemDoc {"}, {"sha": "62db53b760090aee4961ba2e77ed3dd6d5435356", "filename": "src/rustdoc/tystr_pass.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4a78f9b16620489855da93c19be56f59431416f6/src%2Frustdoc%2Ftystr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a78f9b16620489855da93c19be56f59431416f6/src%2Frustdoc%2Ftystr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Ftystr_pass.rs?ref=4a78f9b16620489855da93c19be56f59431416f6", "patch": "@@ -117,10 +117,10 @@ fn fold_enum(\n                   ast_map::node_item(@{\n                     node: ast::item_enum(enum_definition, _), _\n                   }, _) => {\n-                    let ast_variant = option::get(\n+                    let ast_variant =\n                         do vec::find(enum_definition.variants) |v| {\n                             to_str(v.node.name) == variant.name\n-                        });\n+                        }.get();\n \n                     pprust::variant_to_str(ast_variant, extract::interner())\n                   }"}, {"sha": "2326c06f280bb5f9eef3acc785e4121574ccc132", "filename": "src/test/bench/msgsend-pipes-shared.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4a78f9b16620489855da93c19be56f59431416f6/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a78f9b16620489855da93c19be56f59431416f6/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs?ref=4a78f9b16620489855da93c19be56f59431416f6", "patch": "@@ -52,8 +52,8 @@ fn run(args: &[~str]) {\n \n     let to_child = SharedChan(to_child);\n \n-    let size = option::get(uint::from_str(args[1]));\n-    let workers = option::get(uint::from_str(args[2]));\n+    let size = uint::from_str(args[1]).get();\n+    let workers = uint::from_str(args[2]).get();\n     let num_bytes = 100;\n     let start = std::time::precise_time_s();\n     let mut worker_results = ~[];"}, {"sha": "6d47c2a7378af29e95461e2ded8e7750705d6fd2", "filename": "src/test/bench/msgsend-pipes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4a78f9b16620489855da93c19be56f59431416f6/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a78f9b16620489855da93c19be56f59431416f6/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs?ref=4a78f9b16620489855da93c19be56f59431416f6", "patch": "@@ -48,8 +48,8 @@ fn run(args: &[~str]) {\n     let from_parent = PortSet();\n     from_parent.add(from_parent_);\n \n-    let size = option::get(uint::from_str(args[1]));\n-    let workers = option::get(uint::from_str(args[2]));\n+    let size = uint::from_str(args[1]).get();\n+    let workers = uint::from_str(args[2]).get();\n     let num_bytes = 100;\n     let start = std::time::precise_time_s();\n     let mut worker_results = ~[];"}, {"sha": "3bc88fdcae18bc0d87269fba91b7bd079c72c604", "filename": "src/test/bench/msgsend-ring-mutex-arcs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4a78f9b16620489855da93c19be56f59431416f6/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a78f9b16620489855da93c19be56f59431416f6/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs?ref=4a78f9b16620489855da93c19be56f59431416f6", "patch": "@@ -65,8 +65,8 @@ fn main(args: ~[~str]) {\n         copy args\n     }; \n \n-    let num_tasks = option::get(uint::from_str(args[1]));\n-    let msg_per_task = option::get(uint::from_str(args[2]));\n+    let num_tasks = uint::from_str(args[1]).get();\n+    let msg_per_task = uint::from_str(args[2]).get();\n \n     let (num_chan, num_port) = init();\n     let mut num_chan = Some(num_chan);"}, {"sha": "25532fb46a6d7c61c1fb639c3dced927b99a4b61", "filename": "src/test/bench/msgsend-ring-pipes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4a78f9b16620489855da93c19be56f59431416f6/src%2Ftest%2Fbench%2Fmsgsend-ring-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a78f9b16620489855da93c19be56f59431416f6/src%2Ftest%2Fbench%2Fmsgsend-ring-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-pipes.rs?ref=4a78f9b16620489855da93c19be56f59431416f6", "patch": "@@ -61,8 +61,8 @@ fn main(args: ~[~str]) {\n         copy args\n     }; \n \n-    let num_tasks = option::get(uint::from_str(args[1]));\n-    let msg_per_task = option::get(uint::from_str(args[2]));\n+    let num_tasks = uint::from_str(args[1]).get();\n+    let msg_per_task = uint::from_str(args[2]).get();\n \n     let (num_chan, num_port) = ring::init();\n     let mut num_chan = Some(num_chan);"}, {"sha": "0b44410184507722f2b88c3c2ffc3be20bae9300", "filename": "src/test/bench/msgsend-ring-rw-arcs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4a78f9b16620489855da93c19be56f59431416f6/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a78f9b16620489855da93c19be56f59431416f6/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs?ref=4a78f9b16620489855da93c19be56f59431416f6", "patch": "@@ -65,8 +65,8 @@ fn main(args: ~[~str]) {\n         copy args\n     }; \n \n-    let num_tasks = option::get(uint::from_str(args[1]));\n-    let msg_per_task = option::get(uint::from_str(args[2]));\n+    let num_tasks = uint::from_str(args[1]).get();\n+    let msg_per_task = uint::from_str(args[2]).get();\n \n     let (num_chan, num_port) = init();\n     let mut num_chan = Some(num_chan);"}, {"sha": "719ab1b00ba7693b745e08ff976632565b953841", "filename": "src/test/bench/msgsend-ring.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4a78f9b16620489855da93c19be56f59431416f6/src%2Ftest%2Fbench%2Fmsgsend-ring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a78f9b16620489855da93c19be56f59431416f6/src%2Ftest%2Fbench%2Fmsgsend-ring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring.rs?ref=4a78f9b16620489855da93c19be56f59431416f6", "patch": "@@ -30,8 +30,8 @@ fn main(args: ~[~str]) {\n         args\n     };        \n \n-    let num_tasks = option::get(uint::from_str(args[1]));\n-    let msg_per_task = option::get(uint::from_str(args[2]));\n+    let num_tasks = uint::from_str(args[1]).get();\n+    let msg_per_task = uint::from_str(args[2]).get();\n \n     let num_port = Port();\n     let mut num_chan = Chan(num_port);"}, {"sha": "1b2c926508fda7ef8fb893994c1ebccb01bb22a4", "filename": "src/test/bench/msgsend.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4a78f9b16620489855da93c19be56f59431416f6/src%2Ftest%2Fbench%2Fmsgsend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a78f9b16620489855da93c19be56f59431416f6/src%2Ftest%2Fbench%2Fmsgsend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend.rs?ref=4a78f9b16620489855da93c19be56f59431416f6", "patch": "@@ -31,8 +31,8 @@ fn run(args: ~[~str]) {\n     let (from_child, to_child) = do task::spawn_conversation |po, ch| {\n         server(po, ch);\n     };\n-    let size = option::get(uint::from_str(args[1]));\n-    let workers = option::get(uint::from_str(args[2]));\n+    let size = uint::from_str(args[1]).get();\n+    let workers = uint::from_str(args[2]).get();\n     let start = std::time::precise_time_s();\n     let mut worker_results = ~[];\n     for uint::range(0u, workers) |_i| {"}, {"sha": "4796fdc5b112e5f8619c7b64b29beaeb595551f6", "filename": "src/test/bench/shootout-pfib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4a78f9b16620489855da93c19be56f59431416f6/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a78f9b16620489855da93c19be56f59431416f6/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=4a78f9b16620489855da93c19be56f59431416f6", "patch": "@@ -95,8 +95,8 @@ fn main(args: ~[~str]) {\n     if opts.stress {\n         stress(2);\n     } else {\n-        let max = option::get(uint::parse_bytes(str::to_bytes(args[1]),\n-                                                10u)) as int;\n+        let max = uint::parse_bytes(str::to_bytes(args[1]),\n+                                                10u).get() as int;\n \n         let num_trials = 10;\n "}, {"sha": "eae905079ffc15bf83b9b5d4dfac10e68f82521f", "filename": "src/test/bench/sudoku.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4a78f9b16620489855da93c19be56f59431416f6/src%2Ftest%2Fbench%2Fsudoku.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a78f9b16620489855da93c19be56f59431416f6/src%2Ftest%2Fbench%2Fsudoku.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fsudoku.rs?ref=4a78f9b16620489855da93c19be56f59431416f6", "patch": "@@ -37,9 +37,9 @@ fn read_grid(f: io::Reader) -> grid_t {\n     while !f.eof() {\n         let comps = str::split_char(str::trim(f.read_line()), ',');\n         if vec::len(comps) >= 3u {\n-            let row     = option::get(uint::from_str(comps[0])) as u8;\n-            let col     = option::get(uint::from_str(comps[1])) as u8;\n-            g[row][col] = option::get(uint::from_str(comps[2])) as u8;\n+            let row     = uint::from_str(comps[0]).get() as u8;\n+            let col     = uint::from_str(comps[1]).get() as u8;\n+            g[row][col] = uint::from_str(comps[2]).get() as u8;\n         }\n     }\n     return grid_ctor(g);"}, {"sha": "0482fc278c81afc6e7d57e113397cd5a10fa693c", "filename": "src/test/run-pass/test-ignore-cfg.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4a78f9b16620489855da93c19be56f59431416f6/src%2Ftest%2Frun-pass%2Ftest-ignore-cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a78f9b16620489855da93c19be56f59431416f6/src%2Ftest%2Frun-pass%2Ftest-ignore-cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftest-ignore-cfg.rs?ref=4a78f9b16620489855da93c19be56f59431416f6", "patch": "@@ -20,10 +20,10 @@ fn checktests() {\n     let tests = __test::tests();\n \n     let shouldignore = option::get(\n-        vec::find(tests, |t| t.name == ~\"shouldignore\" ));\n+        &vec::find(tests, |t| t.name == ~\"shouldignore\" ));\n     assert shouldignore.ignore == true;\n \n     let shouldnotignore = option::get(\n-        vec::find(tests, |t| t.name == ~\"shouldnotignore\" ));\n+        &vec::find(tests, |t| t.name == ~\"shouldnotignore\" ));\n     assert shouldnotignore.ignore == false;\n }\n\\ No newline at end of file"}]}