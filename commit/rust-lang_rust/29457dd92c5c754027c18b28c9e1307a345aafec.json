{"sha": "29457dd92c5c754027c18b28c9e1307a345aafec", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI5NDU3ZGQ5MmM1Yzc1NDAyN2MxOGIyOGM5ZTEzMDdhMzQ1YWFmZWM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-06T20:38:56Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-06T20:38:56Z"}, "message": "Auto merge of #71958 - Dylan-DPC:rollup-woxwt5d, r=Dylan-DPC\n\nRollup of 5 pull requests\n\nSuccessful merges:\n\n - #70908 (Provide suggestions for type parameters missing bounds for associated types)\n - #71731 (Turn off rustc-dev-guide toolstate for now)\n - #71888 (refactor suggest_traits_to_import)\n - #71918 (Rename methods section)\n - #71950 (Miri validation error handling cleanup)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "6e7854eeb4cb6ed5b1c07f8589186bbfa167446f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6e7854eeb4cb6ed5b1c07f8589186bbfa167446f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/29457dd92c5c754027c18b28c9e1307a345aafec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/29457dd92c5c754027c18b28c9e1307a345aafec", "html_url": "https://github.com/rust-lang/rust/commit/29457dd92c5c754027c18b28c9e1307a345aafec", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/29457dd92c5c754027c18b28c9e1307a345aafec/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1836e3b42a5b2f37fd79104eedbe8f48a5afdee6", "url": "https://api.github.com/repos/rust-lang/rust/commits/1836e3b42a5b2f37fd79104eedbe8f48a5afdee6", "html_url": "https://github.com/rust-lang/rust/commit/1836e3b42a5b2f37fd79104eedbe8f48a5afdee6"}, {"sha": "066eb08f5d4304394d16af634c02d75c31adf580", "url": "https://api.github.com/repos/rust-lang/rust/commits/066eb08f5d4304394d16af634c02d75c31adf580", "html_url": "https://github.com/rust-lang/rust/commit/066eb08f5d4304394d16af634c02d75c31adf580"}], "stats": {"total": 1435, "additions": 950, "deletions": 485}, "files": [{"sha": "6c219cee01ee589330893f007020b0eb5d5efcb3", "filename": "src/bootstrap/toolstate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29457dd92c5c754027c18b28c9e1307a345aafec/src%2Fbootstrap%2Ftoolstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29457dd92c5c754027c18b28c9e1307a345aafec/src%2Fbootstrap%2Ftoolstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftoolstate.rs?ref=29457dd92c5c754027c18b28c9e1307a345aafec", "patch": "@@ -88,7 +88,7 @@ static STABLE_TOOLS: &[(&str, &str)] = &[\n static NIGHTLY_TOOLS: &[(&str, &str)] = &[\n     (\"miri\", \"src/tools/miri\"),\n     (\"embedded-book\", \"src/doc/embedded-book\"),\n-    (\"rustc-dev-guide\", \"src/doc/rustc-dev-guide\"),\n+    // (\"rustc-dev-guide\", \"src/doc/rustc-dev-guide\"),\n ];\n \n fn print_error(tool: &str, submodule: &str) {"}, {"sha": "c9d1cb21da8b09779c0c9881809cf5269379155d", "filename": "src/ci/docker/x86_64-gnu-tools/checktools.sh", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/29457dd92c5c754027c18b28c9e1307a345aafec/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2Fchecktools.sh", "raw_url": "https://github.com/rust-lang/rust/raw/29457dd92c5c754027c18b28c9e1307a345aafec/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2Fchecktools.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2Fchecktools.sh?ref=29457dd92c5c754027c18b28c9e1307a345aafec", "patch": "@@ -14,7 +14,6 @@ python3 \"$X_PY\" test --no-fail-fast \\\n     src/doc/rust-by-example \\\n     src/doc/embedded-book \\\n     src/doc/edition-guide \\\n-    src/doc/rustc-dev-guide \\\n     src/tools/clippy \\\n     src/tools/rls \\\n     src/tools/rustfmt \\"}, {"sha": "cc88fbb295c68384ed45560bbd4774a699c1aa63", "filename": "src/librustc_ast_passes/ast_validation.rs", "status": "modified", "additions": 85, "deletions": 11, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/29457dd92c5c754027c18b28c9e1307a345aafec/src%2Flibrustc_ast_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29457dd92c5c754027c18b28c9e1307a345aafec/src%2Flibrustc_ast_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_passes%2Fast_validation.rs?ref=29457dd92c5c754027c18b28c9e1307a345aafec", "patch": "@@ -23,6 +23,7 @@ use rustc_session::Session;\n use rustc_span::symbol::{kw, sym};\n use rustc_span::Span;\n use std::mem;\n+use std::ops::DerefMut;\n \n const MORE_EXTERN: &str =\n     \"for more information, visit https://doc.rust-lang.org/std/keyword.extern.html\";\n@@ -1113,17 +1114,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n \n         for predicate in &generics.where_clause.predicates {\n             if let WherePredicate::EqPredicate(ref predicate) = *predicate {\n-                self.err_handler()\n-                    .struct_span_err(\n-                        predicate.span,\n-                        \"equality constraints are not yet supported in `where` clauses\",\n-                    )\n-                    .span_label(predicate.span, \"not supported\")\n-                    .note(\n-                        \"see issue #20041 <https://github.com/rust-lang/rust/issues/20041> \\\n-                         for more information\",\n-                    )\n-                    .emit();\n+                deny_equality_constraints(self, predicate, generics);\n             }\n         }\n \n@@ -1300,6 +1291,89 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n     }\n }\n \n+/// When encountering an equality constraint in a `where` clause, emit an error. If the code seems\n+/// like it's setting an associated type, provide an appropriate suggestion.\n+fn deny_equality_constraints(\n+    this: &mut AstValidator<'_>,\n+    predicate: &WhereEqPredicate,\n+    generics: &Generics,\n+) {\n+    let mut err = this.err_handler().struct_span_err(\n+        predicate.span,\n+        \"equality constraints are not yet supported in `where` clauses\",\n+    );\n+    err.span_label(predicate.span, \"not supported\");\n+\n+    // Given `<A as Foo>::Bar = RhsTy`, suggest `A: Foo<Bar = RhsTy>`.\n+    if let TyKind::Path(Some(qself), full_path) = &predicate.lhs_ty.kind {\n+        if let TyKind::Path(None, path) = &qself.ty.kind {\n+            match &path.segments[..] {\n+                [PathSegment { ident, args: None, .. }] => {\n+                    for param in &generics.params {\n+                        if param.ident == *ident {\n+                            let param = ident;\n+                            match &full_path.segments[qself.position..] {\n+                                [PathSegment { ident, .. }] => {\n+                                    // Make a new `Path` from `foo::Bar` to `Foo<Bar = RhsTy>`.\n+                                    let mut assoc_path = full_path.clone();\n+                                    // Remove `Bar` from `Foo::Bar`.\n+                                    assoc_path.segments.pop();\n+                                    let len = assoc_path.segments.len() - 1;\n+                                    // Build `<Bar = RhsTy>`.\n+                                    let arg = AngleBracketedArg::Constraint(AssocTyConstraint {\n+                                        id: rustc_ast::node_id::DUMMY_NODE_ID,\n+                                        ident: *ident,\n+                                        kind: AssocTyConstraintKind::Equality {\n+                                            ty: predicate.rhs_ty.clone(),\n+                                        },\n+                                        span: ident.span,\n+                                    });\n+                                    // Add `<Bar = RhsTy>` to `Foo`.\n+                                    match &mut assoc_path.segments[len].args {\n+                                        Some(args) => match args.deref_mut() {\n+                                            GenericArgs::Parenthesized(_) => continue,\n+                                            GenericArgs::AngleBracketed(args) => {\n+                                                args.args.push(arg);\n+                                            }\n+                                        },\n+                                        empty_args => {\n+                                            *empty_args = AngleBracketedArgs {\n+                                                span: ident.span,\n+                                                args: vec![arg],\n+                                            }\n+                                            .into();\n+                                        }\n+                                    }\n+                                    err.span_suggestion_verbose(\n+                                        predicate.span,\n+                                        &format!(\n+                                            \"if `{}` is an associated type you're trying to set, \\\n+                                            use the associated type binding syntax\",\n+                                            ident\n+                                        ),\n+                                        format!(\n+                                            \"{}: {}\",\n+                                            param,\n+                                            pprust::path_to_string(&assoc_path)\n+                                        ),\n+                                        Applicability::MaybeIncorrect,\n+                                    );\n+                                }\n+                                _ => {}\n+                            };\n+                        }\n+                    }\n+                }\n+                _ => {}\n+            }\n+        }\n+    }\n+    err.note(\n+        \"see issue #20041 <https://github.com/rust-lang/rust/issues/20041> for more information\",\n+    );\n+    err.emit();\n+}\n+\n pub fn check_crate(session: &Session, krate: &Crate, lints: &mut LintBuffer) -> bool {\n     let mut validator = AstValidator {\n         session,"}, {"sha": "e6d673b30f7bcfe319c340f60255d7e83568acc1", "filename": "src/librustc_hir/hir.rs", "status": "modified", "additions": 35, "deletions": 1, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/29457dd92c5c754027c18b28c9e1307a345aafec/src%2Flibrustc_hir%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29457dd92c5c754027c18b28c9e1307a345aafec/src%2Flibrustc_hir%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fhir.rs?ref=29457dd92c5c754027c18b28c9e1307a345aafec", "patch": "@@ -2626,8 +2626,42 @@ impl Node<'_> {\n         match self {\n             Node::TraitItem(TraitItem { generics, .. })\n             | Node::ImplItem(ImplItem { generics, .. })\n-            | Node::Item(Item { kind: ItemKind::Fn(_, generics, _), .. }) => Some(generics),\n+            | Node::Item(Item {\n+                kind:\n+                    ItemKind::Trait(_, _, generics, ..)\n+                    | ItemKind::Impl { generics, .. }\n+                    | ItemKind::Fn(_, generics, _),\n+                ..\n+            }) => Some(generics),\n             _ => None,\n         }\n     }\n+\n+    pub fn hir_id(&self) -> Option<HirId> {\n+        match self {\n+            Node::Item(Item { hir_id, .. })\n+            | Node::ForeignItem(ForeignItem { hir_id, .. })\n+            | Node::TraitItem(TraitItem { hir_id, .. })\n+            | Node::ImplItem(ImplItem { hir_id, .. })\n+            | Node::Field(StructField { hir_id, .. })\n+            | Node::AnonConst(AnonConst { hir_id, .. })\n+            | Node::Expr(Expr { hir_id, .. })\n+            | Node::Stmt(Stmt { hir_id, .. })\n+            | Node::Ty(Ty { hir_id, .. })\n+            | Node::Binding(Pat { hir_id, .. })\n+            | Node::Pat(Pat { hir_id, .. })\n+            | Node::Arm(Arm { hir_id, .. })\n+            | Node::Block(Block { hir_id, .. })\n+            | Node::Local(Local { hir_id, .. })\n+            | Node::MacroDef(MacroDef { hir_id, .. })\n+            | Node::Lifetime(Lifetime { hir_id, .. })\n+            | Node::Param(Param { hir_id, .. })\n+            | Node::GenericParam(GenericParam { hir_id, .. }) => Some(*hir_id),\n+            Node::TraitRef(TraitRef { hir_ref_id, .. }) => Some(*hir_ref_id),\n+            Node::PathSegment(PathSegment { hir_id, .. }) => *hir_id,\n+            Node::Variant(Variant { id, .. }) => Some(*id),\n+            Node::Ctor(variant) => variant.ctor_hir_id(),\n+            Node::Crate(_) | Node::Visibility(_) => None,\n+        }\n+    }\n }"}, {"sha": "ffe71eb3a0924c8008fd65fd657542d0ed9e77cd", "filename": "src/librustc_middle/mir/interpret/error.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/29457dd92c5c754027c18b28c9e1307a345aafec/src%2Flibrustc_middle%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29457dd92c5c754027c18b28c9e1307a345aafec/src%2Flibrustc_middle%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Finterpret%2Ferror.rs?ref=29457dd92c5c754027c18b28c9e1307a345aafec", "patch": "@@ -3,8 +3,7 @@ use super::{AllocId, Pointer, RawConst, ScalarMaybeUndef};\n use crate::mir::interpret::ConstValue;\n use crate::ty::layout::LayoutError;\n use crate::ty::query::TyCtxtAt;\n-use crate::ty::tls;\n-use crate::ty::{self, layout, Ty};\n+use crate::ty::{self, layout, tls, FnSig, Ty};\n \n use rustc_data_structures::sync::Lock;\n use rustc_errors::{struct_span_err, DiagnosticBuilder, ErrorReported};\n@@ -329,7 +328,7 @@ impl fmt::Display for CheckInAllocMsg {\n }\n \n /// Error information for when the program caused Undefined Behavior.\n-pub enum UndefinedBehaviorInfo {\n+pub enum UndefinedBehaviorInfo<'tcx> {\n     /// Free-form case. Only for errors that are never caught!\n     Ub(String),\n     /// Unreachable code was executed.\n@@ -347,6 +346,8 @@ pub enum UndefinedBehaviorInfo {\n     PointerArithOverflow,\n     /// Invalid metadata in a wide pointer (using `str` to avoid allocations).\n     InvalidMeta(&'static str),\n+    /// Invalid drop function in vtable.\n+    InvalidDropFn(FnSig<'tcx>),\n     /// Reading a C string that does not end within its allocation.\n     UnterminatedCString(Pointer),\n     /// Dereferencing a dangling pointer after it got freed.\n@@ -380,6 +381,8 @@ pub enum UndefinedBehaviorInfo {\n     InvalidDiscriminant(ScalarMaybeUndef),\n     /// Using a pointer-not-to-a-function as function pointer.\n     InvalidFunctionPointer(Pointer),\n+    /// Using a string that is not valid UTF-8,\n+    InvalidStr(std::str::Utf8Error),\n     /// Using uninitialized data where it is not allowed.\n     InvalidUndefBytes(Option<Pointer>),\n     /// Working with a local that is not currently live.\n@@ -391,7 +394,7 @@ pub enum UndefinedBehaviorInfo {\n     },\n }\n \n-impl fmt::Display for UndefinedBehaviorInfo {\n+impl fmt::Display for UndefinedBehaviorInfo<'_> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         use UndefinedBehaviorInfo::*;\n         match self {\n@@ -404,6 +407,11 @@ impl fmt::Display for UndefinedBehaviorInfo {\n             RemainderByZero => write!(f, \"calculating the remainder with a divisor of zero\"),\n             PointerArithOverflow => write!(f, \"overflowing in-bounds pointer arithmetic\"),\n             InvalidMeta(msg) => write!(f, \"invalid metadata in wide pointer: {}\", msg),\n+            InvalidDropFn(sig) => write!(\n+                f,\n+                \"invalid drop function signature: got {}, expected exactly one argument which must be a pointer type\",\n+                sig\n+            ),\n             UnterminatedCString(p) => write!(\n                 f,\n                 \"reading a null-terminated string starting at {} with no null found before end of allocation\",\n@@ -446,6 +454,7 @@ impl fmt::Display for UndefinedBehaviorInfo {\n             InvalidFunctionPointer(p) => {\n                 write!(f, \"using {} as function pointer but it does not point to a function\", p)\n             }\n+            InvalidStr(err) => write!(f, \"this string is not valid UTF-8: {}\", err),\n             InvalidUndefBytes(Some(p)) => write!(\n                 f,\n                 \"reading uninitialized memory at {}, but this operation requires initialized memory\",\n@@ -549,7 +558,7 @@ impl dyn MachineStopType {\n \n pub enum InterpError<'tcx> {\n     /// The program caused undefined behavior.\n-    UndefinedBehavior(UndefinedBehaviorInfo),\n+    UndefinedBehavior(UndefinedBehaviorInfo<'tcx>),\n     /// The program did something the interpreter does not support (some of these *might* be UB\n     /// but the interpreter is not sure).\n     Unsupported(UnsupportedOpInfo),"}, {"sha": "613d66d59c55bc81e8c8dfa6a6e5321be675333b", "filename": "src/librustc_middle/ty/diagnostics.rs", "status": "modified", "additions": 183, "deletions": 1, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/29457dd92c5c754027c18b28c9e1307a345aafec/src%2Flibrustc_middle%2Fty%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29457dd92c5c754027c18b28c9e1307a345aafec/src%2Flibrustc_middle%2Fty%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fdiagnostics.rs?ref=29457dd92c5c754027c18b28c9e1307a345aafec", "patch": "@@ -2,7 +2,12 @@\n \n use crate::ty::sty::InferTy;\n use crate::ty::TyKind::*;\n-use crate::ty::TyS;\n+use crate::ty::{TyCtxt, TyS};\n+use rustc_errors::{Applicability, DiagnosticBuilder};\n+use rustc_hir as hir;\n+use rustc_hir::def_id::DefId;\n+use rustc_hir::{QPath, TyKind, WhereBoundPredicate, WherePredicate};\n+use rustc_span::{BytePos, Span};\n \n impl<'tcx> TyS<'tcx> {\n     /// Similar to `TyS::is_primitive`, but also considers inferred numeric values to be primitive.\n@@ -67,3 +72,180 @@ impl<'tcx> TyS<'tcx> {\n         }\n     }\n }\n+\n+/// Suggest restricting a type param with a new bound.\n+pub fn suggest_constraining_type_param(\n+    tcx: TyCtxt<'_>,\n+    generics: &hir::Generics<'_>,\n+    err: &mut DiagnosticBuilder<'_>,\n+    param_name: &str,\n+    constraint: &str,\n+    def_id: Option<DefId>,\n+) -> bool {\n+    let param = generics.params.iter().find(|p| p.name.ident().as_str() == param_name);\n+\n+    let param = if let Some(param) = param {\n+        param\n+    } else {\n+        return false;\n+    };\n+\n+    const MSG_RESTRICT_BOUND_FURTHER: &str = \"consider further restricting this bound\";\n+    let msg_restrict_type = format!(\"consider restricting type parameter `{}`\", param_name);\n+    let msg_restrict_type_further =\n+        format!(\"consider further restricting type parameter `{}`\", param_name);\n+\n+    if def_id == tcx.lang_items().sized_trait() {\n+        // Type parameters are already `Sized` by default.\n+        err.span_label(param.span, &format!(\"this type parameter needs to be `{}`\", constraint));\n+        return true;\n+    }\n+    let mut suggest_restrict = |span| {\n+        err.span_suggestion_verbose(\n+            span,\n+            MSG_RESTRICT_BOUND_FURTHER,\n+            format!(\" + {}\", constraint),\n+            Applicability::MachineApplicable,\n+        );\n+    };\n+\n+    if param_name.starts_with(\"impl \") {\n+        // If there's an `impl Trait` used in argument position, suggest\n+        // restricting it:\n+        //\n+        //   fn foo(t: impl Foo) { ... }\n+        //             --------\n+        //             |\n+        //             help: consider further restricting this bound with `+ Bar`\n+        //\n+        // Suggestion for tools in this case is:\n+        //\n+        //   fn foo(t: impl Foo) { ... }\n+        //             --------\n+        //             |\n+        //             replace with: `impl Foo + Bar`\n+\n+        suggest_restrict(param.span.shrink_to_hi());\n+        return true;\n+    }\n+\n+    if generics.where_clause.predicates.is_empty()\n+        // Given `trait Base<T = String>: Super<T>` where `T: Copy`, suggest restricting in the\n+        // `where` clause instead of `trait Base<T: Copy = String>: Super<T>`.\n+        && !matches!(param.kind, hir::GenericParamKind::Type { default: Some(_), .. })\n+    {\n+        if let Some(bounds_span) = param.bounds_span() {\n+            // If user has provided some bounds, suggest restricting them:\n+            //\n+            //   fn foo<T: Foo>(t: T) { ... }\n+            //             ---\n+            //             |\n+            //             help: consider further restricting this bound with `+ Bar`\n+            //\n+            // Suggestion for tools in this case is:\n+            //\n+            //   fn foo<T: Foo>(t: T) { ... }\n+            //          --\n+            //          |\n+            //          replace with: `T: Bar +`\n+            suggest_restrict(bounds_span.shrink_to_hi());\n+        } else {\n+            // If user hasn't provided any bounds, suggest adding a new one:\n+            //\n+            //   fn foo<T>(t: T) { ... }\n+            //          - help: consider restricting this type parameter with `T: Foo`\n+            err.span_suggestion_verbose(\n+                param.span.shrink_to_hi(),\n+                &msg_restrict_type,\n+                format!(\": {}\", constraint),\n+                Applicability::MachineApplicable,\n+            );\n+        }\n+\n+        true\n+    } else {\n+        // This part is a bit tricky, because using the `where` clause user can\n+        // provide zero, one or many bounds for the same type parameter, so we\n+        // have following cases to consider:\n+        //\n+        // 1) When the type parameter has been provided zero bounds\n+        //\n+        //    Message:\n+        //      fn foo<X, Y>(x: X, y: Y) where Y: Foo { ... }\n+        //             - help: consider restricting this type parameter with `where X: Bar`\n+        //\n+        //    Suggestion:\n+        //      fn foo<X, Y>(x: X, y: Y) where Y: Foo { ... }\n+        //                                           - insert: `, X: Bar`\n+        //\n+        //\n+        // 2) When the type parameter has been provided one bound\n+        //\n+        //    Message:\n+        //      fn foo<T>(t: T) where T: Foo { ... }\n+        //                            ^^^^^^\n+        //                            |\n+        //                            help: consider further restricting this bound with `+ Bar`\n+        //\n+        //    Suggestion:\n+        //      fn foo<T>(t: T) where T: Foo { ... }\n+        //                            ^^\n+        //                            |\n+        //                            replace with: `T: Bar +`\n+        //\n+        //\n+        // 3) When the type parameter has been provided many bounds\n+        //\n+        //    Message:\n+        //      fn foo<T>(t: T) where T: Foo, T: Bar {... }\n+        //             - help: consider further restricting this type parameter with `where T: Zar`\n+        //\n+        //    Suggestion:\n+        //      fn foo<T>(t: T) where T: Foo, T: Bar {... }\n+        //                                          - insert: `, T: Zar`\n+\n+        let mut param_spans = Vec::new();\n+\n+        for predicate in generics.where_clause.predicates {\n+            if let WherePredicate::BoundPredicate(WhereBoundPredicate {\n+                span, bounded_ty, ..\n+            }) = predicate\n+            {\n+                if let TyKind::Path(QPath::Resolved(_, path)) = &bounded_ty.kind {\n+                    if let Some(segment) = path.segments.first() {\n+                        if segment.ident.to_string() == param_name {\n+                            param_spans.push(span);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        let where_clause_span = generics.where_clause.span_for_predicates_or_empty_place();\n+        // Account for `fn foo<T>(t: T) where T: Foo,` so we don't suggest two trailing commas.\n+        let mut trailing_comma = false;\n+        if let Ok(snippet) = tcx.sess.source_map().span_to_snippet(where_clause_span) {\n+            trailing_comma = snippet.ends_with(',');\n+        }\n+        let where_clause_span = if trailing_comma {\n+            let hi = where_clause_span.hi();\n+            Span::new(hi - BytePos(1), hi, where_clause_span.ctxt())\n+        } else {\n+            where_clause_span.shrink_to_hi()\n+        };\n+\n+        match &param_spans[..] {\n+            &[&param_span] => suggest_restrict(param_span.shrink_to_hi()),\n+            _ => {\n+                err.span_suggestion_verbose(\n+                    where_clause_span,\n+                    &msg_restrict_type_further,\n+                    format!(\", {}: {}\", param_name, constraint),\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+        }\n+\n+        true\n+    }\n+}"}, {"sha": "f3b6a53dfeb824e84251291065fa76d74e33f747", "filename": "src/librustc_middle/ty/error.rs", "status": "modified", "additions": 41, "deletions": 2, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/29457dd92c5c754027c18b28c9e1307a345aafec/src%2Flibrustc_middle%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29457dd92c5c754027c18b28c9e1307a345aafec/src%2Flibrustc_middle%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Ferror.rs?ref=29457dd92c5c754027c18b28c9e1307a345aafec", "patch": "@@ -1,4 +1,5 @@\n use crate::traits::{ObligationCause, ObligationCauseCode};\n+use crate::ty::diagnostics::suggest_constraining_type_param;\n use crate::ty::{self, BoundRegion, Region, Ty, TyCtxt};\n use rustc_ast::ast;\n use rustc_errors::Applicability::{MachineApplicable, MaybeIncorrect};\n@@ -401,8 +402,46 @@ impl<'tcx> TyCtxt<'tcx> {\n                     (ty::Projection(_), ty::Projection(_)) => {\n                         db.note(\"an associated type was expected, but a different one was found\");\n                     }\n-                    (ty::Param(_), ty::Projection(_)) | (ty::Projection(_), ty::Param(_)) => {\n-                        db.note(\"you might be missing a type parameter or trait bound\");\n+                    (ty::Param(p), ty::Projection(proj)) | (ty::Projection(proj), ty::Param(p)) => {\n+                        let generics = self.generics_of(body_owner_def_id);\n+                        let p_span = self.def_span(generics.type_param(p, self).def_id);\n+                        if !sp.contains(p_span) {\n+                            db.span_label(p_span, \"this type parameter\");\n+                        }\n+                        let hir = self.hir();\n+                        let mut note = true;\n+                        if let Some(generics) = generics\n+                            .type_param(p, self)\n+                            .def_id\n+                            .as_local()\n+                            .map(|id| hir.as_local_hir_id(id))\n+                            .and_then(|id| self.hir().find(self.hir().get_parent_node(id)))\n+                            .as_ref()\n+                            .and_then(|node| node.generics())\n+                        {\n+                            // Synthesize the associated type restriction `Add<Output = Expected>`.\n+                            // FIXME: extract this logic for use in other diagnostics.\n+                            let trait_ref = proj.trait_ref(self);\n+                            let path =\n+                                self.def_path_str_with_substs(trait_ref.def_id, trait_ref.substs);\n+                            let item_name = self.item_name(proj.item_def_id);\n+                            let path = if path.ends_with('>') {\n+                                format!(\"{}, {} = {}>\", &path[..path.len() - 1], item_name, p)\n+                            } else {\n+                                format!(\"{}<{} = {}>\", path, item_name, p)\n+                            };\n+                            note = !suggest_constraining_type_param(\n+                                self,\n+                                generics,\n+                                db,\n+                                &format!(\"{}\", proj.self_ty()),\n+                                &path,\n+                                None,\n+                            );\n+                        }\n+                        if note {\n+                            db.note(\"you might be missing a type parameter or trait bound\");\n+                        }\n                     }\n                     (ty::Param(p), ty::Dynamic(..) | ty::Opaque(..))\n                     | (ty::Dynamic(..) | ty::Opaque(..), ty::Param(p)) => {"}, {"sha": "14a094b9d5273f6fefa7796001c68729144d3df1", "filename": "src/librustc_mir/borrow_check/diagnostics/conflict_errors.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/29457dd92c5c754027c18b28c9e1307a345aafec/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29457dd92c5c754027c18b28c9e1307a345aafec/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs?ref=29457dd92c5c754027c18b28c9e1307a345aafec", "patch": "@@ -10,10 +10,9 @@ use rustc_middle::mir::{\n     FakeReadCause, Local, LocalDecl, LocalInfo, LocalKind, Location, Operand, Place, PlaceRef,\n     ProjectionElem, Rvalue, Statement, StatementKind, TerminatorKind, VarBindingForm,\n };\n-use rustc_middle::ty::{self, Ty};\n+use rustc_middle::ty::{self, suggest_constraining_type_param, Ty};\n use rustc_span::source_map::DesugaringKind;\n use rustc_span::Span;\n-use rustc_trait_selection::traits::error_reporting::suggest_constraining_type_param;\n \n use crate::dataflow::drop_flag_effects;\n use crate::dataflow::indexes::{MoveOutIndex, MovePathIndex};"}, {"sha": "db836d88dd05eaa0b45850dcaab7f7f266becb49", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/29457dd92c5c754027c18b28c9e1307a345aafec/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29457dd92c5c754027c18b28c9e1307a345aafec/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=29457dd92c5c754027c18b28c9e1307a345aafec", "patch": "@@ -327,8 +327,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     pub fn read_str(&self, mplace: MPlaceTy<'tcx, M::PointerTag>) -> InterpResult<'tcx, &str> {\n         let len = mplace.len(self)?;\n         let bytes = self.memory.read_bytes(mplace.ptr, Size::from_bytes(len))?;\n-        let str = ::std::str::from_utf8(bytes)\n-            .map_err(|err| err_ub_format!(\"this string is not valid UTF-8: {}\", err))?;\n+        let str = ::std::str::from_utf8(bytes).map_err(|err| err_ub!(InvalidStr(err)))?;\n         Ok(str)\n     }\n "}, {"sha": "b9f9d37df7645d19400ac4c3a5ebb783a859e04c", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/29457dd92c5c754027c18b28c9e1307a345aafec/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29457dd92c5c754027c18b28c9e1307a345aafec/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=29457dd92c5c754027c18b28c9e1307a345aafec", "patch": "@@ -147,14 +147,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // The drop function takes `*mut T` where `T` is the type being dropped, so get that.\n         let args = fn_sig.inputs();\n         if args.len() != 1 {\n-            throw_ub_format!(\"drop fn should have 1 argument, but signature is {:?}\", fn_sig);\n+            throw_ub!(InvalidDropFn(fn_sig));\n         }\n-        let ty = args[0]\n-            .builtin_deref(true)\n-            .ok_or_else(|| {\n-                err_ub_format!(\"drop fn argument type {} is not a pointer type\", args[0])\n-            })?\n-            .ty;\n+        let ty = args[0].builtin_deref(true).ok_or_else(|| err_ub!(InvalidDropFn(fn_sig)))?.ty;\n         Ok((drop_instance, ty))\n     }\n "}, {"sha": "9f2e79bbee31ea71537372f21356aa9b6ff5a997", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 138, "deletions": 150, "changes": 288, "blob_url": "https://github.com/rust-lang/rust/blob/29457dd92c5c754027c18b28c9e1307a345aafec/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29457dd92c5c754027c18b28c9e1307a345aafec/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=29457dd92c5c754027c18b28c9e1307a345aafec", "patch": "@@ -25,43 +25,39 @@ use super::{\n };\n \n macro_rules! throw_validation_failure {\n-    ($what:expr, $where:expr $(, $expected:expr )?) => {{\n-        let mut msg = format!(\"encountered {}\", $what);\n+    ($where:expr, { $( $what_fmt:expr ),+ } $( expected { $( $expected_fmt:expr ),+ } )?) => {{\n+        let mut msg = String::new();\n+        msg.push_str(\"encountered \");\n+        write!(&mut msg, $($what_fmt),+).unwrap();\n         let where_ = &$where;\n         if !where_.is_empty() {\n             msg.push_str(\" at \");\n             write_path(&mut msg, where_);\n         }\n-        $( write!(&mut msg, \", but expected {}\", $expected).unwrap(); )?\n+        $(\n+            msg.push_str(\", but expected \");\n+            write!(&mut msg, $($expected_fmt),+).unwrap();\n+        )?\n         throw_ub!(ValidationFailure(msg))\n     }};\n }\n \n-/// Returns a validation failure for any Err value of $e.\n-// FIXME: Replace all usages of try_validation! with try_validation_pat!.\n-macro_rules! try_validation {\n-    ($e:expr, $what:expr, $where:expr $(, $expected:expr )?) => {{\n-        try_validation_pat!($e, $where, {\n-            _ => { \"{}\", $what } $( expected { \"{}\", $expected } )?,\n-        })\n-    }};\n-}\n-/// Like try_validation, but will throw a validation error if any of the patterns in $p are\n-/// matched. Other errors are passed back to the caller, unchanged. This lets you use the patterns\n-/// as a kind of validation blacklist:\n+/// If $e throws an error matching the pattern, throw a validation failure.\n+/// Other errors are passed back to the caller, unchanged -- and if they reach the root of\n+/// the visitor, we make sure only validation errors and `InvalidProgram` errors are left.\n+/// This lets you use the patterns as a kind of validation whitelist, asserting which errors\n+/// can possibly happen:\n ///\n /// ```\n-/// let v = try_validation_pat!(some_fn(), some_path, {\n+/// let v = try_validation!(some_fn(), some_path, {\n ///     Foo | Bar | Baz => { \"some failure\" },\n /// });\n-/// // Failures that match $p are thrown up as validation errors, but other errors are passed back\n-/// // unchanged.\n /// ```\n ///\n /// An additional expected parameter can also be added to the failure message:\n ///\n /// ```\n-/// let v = try_validation_pat!(some_fn(), some_path, {\n+/// let v = try_validation!(some_fn(), some_path, {\n ///     Foo | Bar | Baz => { \"some failure\" } expected { \"something that wasn't a failure\" },\n /// });\n /// ```\n@@ -70,24 +66,25 @@ macro_rules! try_validation {\n /// the format string in directly:\n ///\n /// ```\n-/// let v = try_validation_pat!(some_fn(), some_path, {\n+/// let v = try_validation!(some_fn(), some_path, {\n ///     Foo | Bar | Baz => { \"{:?}\", some_failure } expected { \"{}\", expected_value },\n /// });\n /// ```\n ///\n-macro_rules! try_validation_pat {\n-    ($e:expr, $where:expr, { $( $p:pat )|+ =>\n-        { $( $what_fmt:expr ),+ } $( expected { $( $expected_fmt:expr ),+ } )? $( , )?}) => {{\n+macro_rules! try_validation {\n+    ($e:expr, $where:expr,\n+     $( $( $p:pat )|+ => { $( $what_fmt:expr ),+ } $( expected { $( $expected_fmt:expr ),+ } )? ),+ $(,)?\n+    ) => {{\n         match $e {\n             Ok(x) => x,\n             // We catch the error and turn it into a validation failure. We are okay with\n             // allocation here as this can only slow down builds that fail anyway.\n-            $( Err(InterpErrorInfo { kind: $p, .. }) )|+ =>\n+            $( $( Err(InterpErrorInfo { kind: $p, .. }) )|+ =>\n                 throw_validation_failure!(\n-                    format_args!($( $what_fmt ),+),\n-                    $where\n-                    $(, format_args!($( $expected_fmt ),+))?\n+                    $where,\n+                    { $( $what_fmt ),+ } $( expected { $( $expected_fmt ),+ } )?\n                 ),\n+            )+\n             #[allow(unreachable_patterns)]\n             Err(e) => Err::<!, _>(e)?,\n         }\n@@ -303,32 +300,45 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n         match tail.kind {\n             ty::Dynamic(..) => {\n                 let vtable = meta.unwrap_meta();\n+                // Direct call to `check_ptr_access_align` checks alignment even on CTFE machines.\n                 try_validation!(\n-                    self.ecx.memory.check_ptr_access(\n+                    self.ecx.memory.check_ptr_access_align(\n                         vtable,\n                         3 * self.ecx.tcx.data_layout.pointer_size, // drop, size, align\n-                        self.ecx.tcx.data_layout.pointer_align.abi,\n+                        Some(self.ecx.tcx.data_layout.pointer_align.abi),\n+                        CheckInAllocMsg::InboundsTest,\n                     ),\n-                    \"dangling or unaligned vtable pointer in wide pointer or too small vtable\",\n-                    self.path\n+                    self.path,\n+                    err_ub!(DanglingIntPointer(..)) |\n+                    err_ub!(PointerUseAfterFree(..)) |\n+                    err_unsup!(ReadBytesAsPointer) =>\n+                        { \"dangling vtable pointer in wide pointer\" },\n+                    err_ub!(AlignmentCheckFailed { .. }) =>\n+                        { \"unaligned vtable pointer in wide pointer\" },\n+                    err_ub!(PointerOutOfBounds { .. }) =>\n+                        { \"too small vtable\" },\n                 );\n                 try_validation!(\n                     self.ecx.read_drop_type_from_vtable(vtable),\n-                    \"invalid drop fn in vtable\",\n-                    self.path\n+                    self.path,\n+                    err_ub!(InvalidDropFn(..)) |\n+                    err_ub!(DanglingIntPointer(..)) |\n+                    err_ub!(InvalidFunctionPointer(..)) |\n+                    err_unsup!(ReadBytesAsPointer) =>\n+                        { \"invalid drop function pointer in vtable\" },\n                 );\n                 try_validation!(\n                     self.ecx.read_size_and_align_from_vtable(vtable),\n-                    \"invalid size or align in vtable\",\n-                    self.path\n+                    self.path,\n+                    err_unsup!(ReadPointerAsBytes) => { \"invalid size or align in vtable\" },\n                 );\n                 // FIXME: More checks for the vtable.\n             }\n             ty::Slice(..) | ty::Str => {\n                 let _len = try_validation!(\n                     meta.unwrap_meta().to_machine_usize(self.ecx),\n-                    \"non-integer slice length in wide pointer\",\n-                    self.path\n+                    self.path,\n+                    err_unsup!(ReadPointerAsBytes) => { \"non-integer slice length in wide pointer\" },\n                 );\n                 // We do not check that `len * elem_size <= isize::MAX`:\n                 // that is only required for references, and there it falls out of the\n@@ -354,78 +364,52 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n         // Check metadata early, for better diagnostics\n         let place = try_validation!(\n             self.ecx.ref_to_mplace(value),\n-            format_args!(\"uninitialized {}\", kind),\n-            self.path\n+            self.path,\n+            err_ub!(InvalidUndefBytes(..)) => { \"uninitialized {}\", kind },\n         );\n         if place.layout.is_unsized() {\n             self.check_wide_ptr_meta(place.meta, place.layout)?;\n         }\n         // Make sure this is dereferenceable and all.\n-        let size_and_align = match self.ecx.size_and_align_of(place.meta, place.layout) {\n-            Ok(res) => res,\n-            Err(err) => match err.kind {\n-                err_ub!(InvalidMeta(msg)) => throw_validation_failure!(\n-                    format_args!(\"invalid {} metadata: {}\", kind, msg),\n-                    self.path\n-                ),\n-                _ => bug!(\"unexpected error during ptr size_and_align_of: {}\", err),\n-            },\n-        };\n+        let size_and_align = try_validation!(\n+            self.ecx.size_and_align_of(place.meta, place.layout),\n+            self.path,\n+            err_ub!(InvalidMeta(msg)) => { \"invalid {} metadata: {}\", kind, msg },\n+        );\n         let (size, align) = size_and_align\n             // for the purpose of validity, consider foreign types to have\n             // alignment and size determined by the layout (size will be 0,\n             // alignment should take attributes into account).\n             .unwrap_or_else(|| (place.layout.size, place.layout.align.abi));\n-        let ptr: Option<_> = match self.ecx.memory.check_ptr_access_align(\n-            place.ptr,\n-            size,\n-            Some(align),\n-            CheckInAllocMsg::InboundsTest,\n-        ) {\n-            Ok(ptr) => ptr,\n-            Err(err) => {\n-                info!(\n-                    \"{:?} did not pass access check for size {:?}, align {:?}\",\n-                    place.ptr, size, align\n-                );\n-                match err.kind {\n-                    err_ub!(DanglingIntPointer(0, _)) => {\n-                        throw_validation_failure!(format_args!(\"a NULL {}\", kind), self.path)\n-                    }\n-                    err_ub!(DanglingIntPointer(i, _)) => throw_validation_failure!(\n-                        format_args!(\"a {} to unallocated address {}\", kind, i),\n-                        self.path\n-                    ),\n-                    err_ub!(AlignmentCheckFailed { required, has }) => throw_validation_failure!(\n-                        format_args!(\n-                            \"an unaligned {} (required {} byte alignment but found {})\",\n-                            kind,\n-                            required.bytes(),\n-                            has.bytes()\n-                        ),\n-                        self.path\n-                    ),\n-                    err_unsup!(ReadBytesAsPointer) => throw_validation_failure!(\n-                        format_args!(\"a dangling {} (created from integer)\", kind),\n-                        self.path\n-                    ),\n-                    err_ub!(PointerOutOfBounds { .. }) => throw_validation_failure!(\n-                        format_args!(\n-                            \"a dangling {} (going beyond the bounds of its allocation)\",\n-                            kind\n-                        ),\n-                        self.path\n-                    ),\n-                    // This cannot happen during const-eval (because interning already detects\n-                    // dangling pointers), but it can happen in Miri.\n-                    err_ub!(PointerUseAfterFree(_)) => throw_validation_failure!(\n-                        format_args!(\"a dangling {} (use-after-free)\", kind),\n-                        self.path\n-                    ),\n-                    _ => bug!(\"Unexpected error during ptr inbounds test: {}\", err),\n-                }\n-            }\n-        };\n+        // Direct call to `check_ptr_access_align` checks alignment even on CTFE machines.\n+        let ptr: Option<_> = try_validation!(\n+            self.ecx.memory.check_ptr_access_align(\n+                place.ptr,\n+                size,\n+                Some(align),\n+                CheckInAllocMsg::InboundsTest,\n+            ),\n+            self.path,\n+            err_ub!(AlignmentCheckFailed { required, has }) =>\n+                {\n+                    \"an unaligned {} (required {} byte alignment but found {})\",\n+                    kind,\n+                    required.bytes(),\n+                    has.bytes()\n+                },\n+            err_ub!(DanglingIntPointer(0, _)) =>\n+                { \"a NULL {}\", kind },\n+            err_ub!(DanglingIntPointer(i, _)) =>\n+                { \"a dangling {} (address {} is unallocated)\", kind, i },\n+            err_ub!(PointerOutOfBounds { .. }) =>\n+                { \"a dangling {} (going beyond the bounds of its allocation)\", kind },\n+            err_unsup!(ReadBytesAsPointer) =>\n+                { \"a dangling {} (created from integer)\", kind },\n+            // This cannot happen during const-eval (because interning already detects\n+            // dangling pointers), but it can happen in Miri.\n+            err_ub!(PointerUseAfterFree(..)) =>\n+                { \"a dangling {} (use-after-free)\", kind },\n+        );\n         // Recursive checking\n         if let Some(ref mut ref_tracking) = self.ref_tracking_for_consts {\n             if let Some(ptr) = ptr {\n@@ -440,9 +424,8 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                     // We also need to do it here instead of going on to avoid running\n                     // into the `before_access_global` check during validation.\n                     if !self.may_ref_to_static && self.ecx.tcx.is_static(did) {\n-                        throw_validation_failure!(\n-                            format_args!(\"a {} pointing to a static variable\", kind),\n-                            self.path\n+                        throw_validation_failure!(self.path,\n+                            { \"a {} pointing to a static variable\", kind }\n                         );\n                     }\n                     // `extern static` cannot be validated as they have no body.\n@@ -489,12 +472,20 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n         match ty.kind {\n             ty::Bool => {\n                 let value = self.ecx.read_scalar(value)?;\n-                try_validation!(value.to_bool(), value, self.path, \"a boolean\");\n+                try_validation!(\n+                    value.to_bool(),\n+                    self.path,\n+                    err_ub!(InvalidBool(..)) => { \"{}\", value } expected { \"a boolean\" },\n+                );\n                 Ok(true)\n             }\n             ty::Char => {\n                 let value = self.ecx.read_scalar(value)?;\n-                try_validation!(value.to_char(), value, self.path, \"a valid unicode codepoint\");\n+                try_validation!(\n+                    value.to_char(),\n+                    self.path,\n+                    err_ub!(InvalidChar(..)) => { \"{}\", value } expected { \"a valid unicode codepoint\" },\n+                );\n                 Ok(true)\n             }\n             ty::Float(_) | ty::Int(_) | ty::Uint(_) => {\n@@ -505,10 +496,8 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                     // Integers/floats in CTFE: Must be scalar bits, pointers are dangerous\n                     let is_bits = value.not_undef().map_or(false, |v| v.is_bits());\n                     if !is_bits {\n-                        throw_validation_failure!(\n-                            value,\n-                            self.path,\n-                            \"initialized plain (non-pointer) bytes\"\n+                        throw_validation_failure!(self.path,\n+                            { \"{}\", value } expected { \"initialized plain (non-pointer) bytes\" }\n                         )\n                     }\n                 } else {\n@@ -521,9 +510,11 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                 // We are conservative with undef for integers, but try to\n                 // actually enforce the strict rules for raw pointers (mostly because\n                 // that lets us re-use `ref_to_mplace`).\n-                let place = try_validation_pat!(self.ecx.ref_to_mplace(self.ecx.read_immediate(value)?), self.path, {\n+                let place = try_validation!(\n+                    self.ecx.ref_to_mplace(self.ecx.read_immediate(value)?),\n+                    self.path,\n                     err_ub!(InvalidUndefBytes(..)) => { \"uninitialized raw pointer\" },\n-                });\n+                );\n                 if place.layout.is_unsized() {\n                     self.check_wide_ptr_meta(place.meta, place.layout)?;\n                 }\n@@ -541,14 +532,16 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                 let value = self.ecx.read_scalar(value)?;\n                 let _fn = try_validation!(\n                     value.not_undef().and_then(|ptr| self.ecx.memory.get_fn(ptr)),\n-                    value,\n                     self.path,\n-                    \"a function pointer\"\n+                    err_ub!(DanglingIntPointer(..)) |\n+                    err_ub!(InvalidFunctionPointer(..)) |\n+                    err_unsup!(ReadBytesAsPointer) =>\n+                        { \"{}\", value } expected { \"a function pointer\" },\n                 );\n                 // FIXME: Check if the signature matches\n                 Ok(true)\n             }\n-            ty::Never => throw_validation_failure!(\"a value of the never type `!`\", self.path),\n+            ty::Never => throw_validation_failure!(self.path, { \"a value of the never type `!`\" }),\n             ty::Foreign(..) | ty::FnDef(..) => {\n                 // Nothing to check.\n                 Ok(true)\n@@ -598,35 +591,33 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n         // At least one value is excluded. Get the bits.\n         let value = try_validation!(\n             value.not_undef(),\n-            value,\n             self.path,\n-            format_args!(\"something {}\", wrapping_range_format(valid_range, max_hi),)\n+            err_ub!(InvalidUndefBytes(..)) => { \"{}\", value }\n+                expected { \"something {}\", wrapping_range_format(valid_range, max_hi) },\n         );\n         let bits = match value.to_bits_or_ptr(op.layout.size, self.ecx) {\n             Err(ptr) => {\n                 if lo == 1 && hi == max_hi {\n                     // Only NULL is the niche.  So make sure the ptr is NOT NULL.\n                     if self.ecx.memory.ptr_may_be_null(ptr) {\n-                        throw_validation_failure!(\n-                            \"a potentially NULL pointer\",\n-                            self.path,\n-                            format_args!(\n+                        throw_validation_failure!(self.path,\n+                            { \"a potentially NULL pointer\" }\n+                            expected {\n                                 \"something that cannot possibly fail to be {}\",\n                                 wrapping_range_format(valid_range, max_hi)\n-                            )\n+                            }\n                         )\n                     }\n                     return Ok(());\n                 } else {\n                     // Conservatively, we reject, because the pointer *could* have a bad\n                     // value.\n-                    throw_validation_failure!(\n-                        \"a pointer\",\n-                        self.path,\n-                        format_args!(\n+                    throw_validation_failure!(self.path,\n+                        { \"a pointer\" }\n+                        expected {\n                             \"something that cannot possibly fail to be {}\",\n                             wrapping_range_format(valid_range, max_hi)\n-                        )\n+                        }\n                     )\n                 }\n             }\n@@ -636,10 +627,9 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n         if wrapping_range_contains(&valid_range, bits) {\n             Ok(())\n         } else {\n-            throw_validation_failure!(\n-                bits,\n-                self.path,\n-                format_args!(\"something {}\", wrapping_range_format(valid_range, max_hi))\n+            throw_validation_failure!(self.path,\n+                { \"{}\", bits }\n+                expected { \"something {}\", wrapping_range_format(valid_range, max_hi) }\n             )\n         }\n     }\n@@ -703,19 +693,14 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n         assert!(op.layout.ty.builtin_deref(true).is_none());\n \n         // Recursively walk the type. Translate some possible errors to something nicer.\n-        match self.walk_value(op) {\n-            Ok(()) => {}\n-            Err(err) => match err.kind {\n-                err_ub!(InvalidDiscriminant(val)) => {\n-                    throw_validation_failure!(val, self.path, \"a valid enum discriminant\")\n-                }\n-                err_unsup!(ReadPointerAsBytes) => {\n-                    throw_validation_failure!(\"a pointer\", self.path, \"plain (non-pointer) bytes\")\n-                }\n-                // Propagate upwards (that will also check for unexpected errors).\n-                _ => return Err(err),\n-            },\n-        }\n+        try_validation!(\n+            self.walk_value(op),\n+            self.path,\n+            err_ub!(InvalidDiscriminant(val)) =>\n+                { \"{}\", val } expected { \"a valid enum discriminant\" },\n+            err_unsup!(ReadPointerAsBytes) =>\n+                { \"a pointer\" } expected { \"plain (non-pointer) bytes\" },\n+        );\n \n         // *After* all of this, check the ABI.  We need to check the ABI to handle\n         // types like `NonNull` where the `Scalar` info is more restrictive than what\n@@ -729,9 +714,8 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n         // MyNewtype and then the scalar in there).\n         match op.layout.abi {\n             Abi::Uninhabited => {\n-                throw_validation_failure!(\n-                    format_args!(\"a value of uninhabited type {:?}\", op.layout.ty),\n-                    self.path\n+                throw_validation_failure!(self.path,\n+                    { \"a value of uninhabited type {:?}\", op.layout.ty }\n                 );\n             }\n             Abi::Scalar(ref scalar_layout) => {\n@@ -761,8 +745,8 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                 let mplace = op.assert_mem_place(self.ecx); // strings are never immediate\n                 try_validation!(\n                     self.ecx.read_str(mplace),\n-                    \"uninitialized or non-UTF-8 data in str\",\n-                    self.path\n+                    self.path,\n+                    err_ub!(InvalidStr(..)) => { \"uninitialized or non-UTF-8 data in str\" },\n                 );\n             }\n             ty::Array(tys, ..) | ty::Slice(tys)\n@@ -815,7 +799,8 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                     Ok(()) => {}\n                     // Some error happened, try to provide a more detailed description.\n                     Err(err) => {\n-                        // For some errors we might be able to provide extra information\n+                        // For some errors we might be able to provide extra information.\n+                        // (This custom logic does not fit the `try_validation!` macro.)\n                         match err.kind {\n                             err_ub!(InvalidUndefBytes(Some(ptr))) => {\n                                 // Some byte was uninitialized, determine which\n@@ -825,7 +810,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                                     .unwrap();\n                                 self.path.push(PathElem::ArrayElem(i));\n \n-                                throw_validation_failure!(\"uninitialized bytes\", self.path)\n+                                throw_validation_failure!(self.path, { \"uninitialized bytes\" })\n                             }\n                             // Propagate upwards (that will also check for unexpected errors).\n                             _ => return Err(err),\n@@ -876,7 +861,10 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             // validate and each caller will know best what to do with them.\n             Err(err) if matches!(err.kind, InterpError::InvalidProgram(_)) => Err(err),\n             // Avoid other errors as those do not show *where* in the value the issue lies.\n-            Err(err) => bug!(\"Unexpected error during validation: {}\", err),\n+            Err(err) => {\n+                err.print_backtrace();\n+                bug!(\"Unexpected error during validation: {}\", err);\n+            }\n         }\n     }\n "}, {"sha": "19ed6b50f92a624ba00d7082927edbce4b6d17ac", "filename": "src/librustc_trait_selection/traits/error_reporting/mod.rs", "status": "modified", "additions": 4, "deletions": 182, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/29457dd92c5c754027c18b28c9e1307a345aafec/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29457dd92c5c754027c18b28c9e1307a345aafec/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=29457dd92c5c754027c18b28c9e1307a345aafec", "patch": "@@ -15,17 +15,16 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::{pluralize, struct_span_err, Applicability, DiagnosticBuilder, ErrorReported};\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n-use rustc_hir::{Node, QPath, TyKind, WhereBoundPredicate, WherePredicate};\n+use rustc_hir::Node;\n use rustc_middle::mir::interpret::ErrorHandled;\n use rustc_middle::ty::error::ExpectedFound;\n-use rustc_middle::ty::fast_reject;\n use rustc_middle::ty::fold::TypeFolder;\n-use rustc_middle::ty::SubtypePredicate;\n use rustc_middle::ty::{\n-    self, AdtKind, ToPolyTraitRef, ToPredicate, Ty, TyCtxt, TypeFoldable, WithConstness,\n+    self, fast_reject, AdtKind, SubtypePredicate, ToPolyTraitRef, ToPredicate, Ty, TyCtxt,\n+    TypeFoldable, WithConstness,\n };\n use rustc_session::DiagnosticMessageId;\n-use rustc_span::{BytePos, ExpnKind, Span, DUMMY_SP};\n+use rustc_span::{ExpnKind, Span, DUMMY_SP};\n use std::fmt;\n \n use crate::traits::query::evaluate_obligation::InferCtxtExt as _;\n@@ -1700,180 +1699,3 @@ impl ArgKind {\n         }\n     }\n }\n-\n-/// Suggest restricting a type param with a new bound.\n-pub fn suggest_constraining_type_param(\n-    tcx: TyCtxt<'_>,\n-    generics: &hir::Generics<'_>,\n-    err: &mut DiagnosticBuilder<'_>,\n-    param_name: &str,\n-    constraint: &str,\n-    def_id: Option<DefId>,\n-) -> bool {\n-    let param = generics.params.iter().find(|p| p.name.ident().as_str() == param_name);\n-\n-    let param = if let Some(param) = param {\n-        param\n-    } else {\n-        return false;\n-    };\n-\n-    const MSG_RESTRICT_BOUND_FURTHER: &str = \"consider further restricting this bound\";\n-    let msg_restrict_type = format!(\"consider restricting type parameter `{}`\", param_name);\n-    let msg_restrict_type_further =\n-        format!(\"consider further restricting type parameter `{}`\", param_name);\n-\n-    if def_id == tcx.lang_items().sized_trait() {\n-        // Type parameters are already `Sized` by default.\n-        err.span_label(param.span, &format!(\"this type parameter needs to be `{}`\", constraint));\n-        return true;\n-    }\n-    let mut suggest_restrict = |span| {\n-        err.span_suggestion_verbose(\n-            span,\n-            MSG_RESTRICT_BOUND_FURTHER,\n-            format!(\" + {}\", constraint),\n-            Applicability::MachineApplicable,\n-        );\n-    };\n-\n-    if param_name.starts_with(\"impl \") {\n-        // If there's an `impl Trait` used in argument position, suggest\n-        // restricting it:\n-        //\n-        //   fn foo(t: impl Foo) { ... }\n-        //             --------\n-        //             |\n-        //             help: consider further restricting this bound with `+ Bar`\n-        //\n-        // Suggestion for tools in this case is:\n-        //\n-        //   fn foo(t: impl Foo) { ... }\n-        //             --------\n-        //             |\n-        //             replace with: `impl Foo + Bar`\n-\n-        suggest_restrict(param.span.shrink_to_hi());\n-        return true;\n-    }\n-\n-    if generics.where_clause.predicates.is_empty()\n-        // Given `trait Base<T = String>: Super<T>` where `T: Copy`, suggest restricting in the\n-        // `where` clause instead of `trait Base<T: Copy = String>: Super<T>`.\n-        && !matches!(param.kind, hir::GenericParamKind::Type { default: Some(_), .. })\n-    {\n-        if let Some(bounds_span) = param.bounds_span() {\n-            // If user has provided some bounds, suggest restricting them:\n-            //\n-            //   fn foo<T: Foo>(t: T) { ... }\n-            //             ---\n-            //             |\n-            //             help: consider further restricting this bound with `+ Bar`\n-            //\n-            // Suggestion for tools in this case is:\n-            //\n-            //   fn foo<T: Foo>(t: T) { ... }\n-            //          --\n-            //          |\n-            //          replace with: `T: Bar +`\n-            suggest_restrict(bounds_span.shrink_to_hi());\n-        } else {\n-            // If user hasn't provided any bounds, suggest adding a new one:\n-            //\n-            //   fn foo<T>(t: T) { ... }\n-            //          - help: consider restricting this type parameter with `T: Foo`\n-            err.span_suggestion_verbose(\n-                param.span.shrink_to_hi(),\n-                &msg_restrict_type,\n-                format!(\": {}\", constraint),\n-                Applicability::MachineApplicable,\n-            );\n-        }\n-\n-        true\n-    } else {\n-        // This part is a bit tricky, because using the `where` clause user can\n-        // provide zero, one or many bounds for the same type parameter, so we\n-        // have following cases to consider:\n-        //\n-        // 1) When the type parameter has been provided zero bounds\n-        //\n-        //    Message:\n-        //      fn foo<X, Y>(x: X, y: Y) where Y: Foo { ... }\n-        //             - help: consider restricting this type parameter with `where X: Bar`\n-        //\n-        //    Suggestion:\n-        //      fn foo<X, Y>(x: X, y: Y) where Y: Foo { ... }\n-        //                                           - insert: `, X: Bar`\n-        //\n-        //\n-        // 2) When the type parameter has been provided one bound\n-        //\n-        //    Message:\n-        //      fn foo<T>(t: T) where T: Foo { ... }\n-        //                            ^^^^^^\n-        //                            |\n-        //                            help: consider further restricting this bound with `+ Bar`\n-        //\n-        //    Suggestion:\n-        //      fn foo<T>(t: T) where T: Foo { ... }\n-        //                            ^^\n-        //                            |\n-        //                            replace with: `T: Bar +`\n-        //\n-        //\n-        // 3) When the type parameter has been provided many bounds\n-        //\n-        //    Message:\n-        //      fn foo<T>(t: T) where T: Foo, T: Bar {... }\n-        //             - help: consider further restricting this type parameter with `where T: Zar`\n-        //\n-        //    Suggestion:\n-        //      fn foo<T>(t: T) where T: Foo, T: Bar {... }\n-        //                                          - insert: `, T: Zar`\n-\n-        let mut param_spans = Vec::new();\n-\n-        for predicate in generics.where_clause.predicates {\n-            if let WherePredicate::BoundPredicate(WhereBoundPredicate {\n-                span, bounded_ty, ..\n-            }) = predicate\n-            {\n-                if let TyKind::Path(QPath::Resolved(_, path)) = &bounded_ty.kind {\n-                    if let Some(segment) = path.segments.first() {\n-                        if segment.ident.to_string() == param_name {\n-                            param_spans.push(span);\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-\n-        let where_clause_span = generics.where_clause.span_for_predicates_or_empty_place();\n-        // Account for `fn foo<T>(t: T) where T: Foo,` so we don't suggest two trailing commas.\n-        let mut trailing_comma = false;\n-        if let Ok(snippet) = tcx.sess.source_map().span_to_snippet(where_clause_span) {\n-            trailing_comma = snippet.ends_with(',');\n-        }\n-        let where_clause_span = if trailing_comma {\n-            let hi = where_clause_span.hi();\n-            Span::new(hi - BytePos(1), hi, where_clause_span.ctxt())\n-        } else {\n-            where_clause_span.shrink_to_hi()\n-        };\n-\n-        match &param_spans[..] {\n-            &[&param_span] => suggest_restrict(param_span.shrink_to_hi()),\n-            _ => {\n-                err.span_suggestion_verbose(\n-                    where_clause_span,\n-                    &msg_restrict_type_further,\n-                    format!(\", {}: {}\", param_name, constraint),\n-                    Applicability::MachineApplicable,\n-                );\n-            }\n-        }\n-\n-        true\n-    }\n-}"}, {"sha": "74dd47a91c2790e9b86bb840fd55aa1ef0defe59", "filename": "src/librustc_trait_selection/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/29457dd92c5c754027c18b28c9e1307a345aafec/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29457dd92c5c754027c18b28c9e1307a345aafec/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=29457dd92c5c754027c18b28c9e1307a345aafec", "patch": "@@ -3,7 +3,6 @@ use super::{\n };\n \n use crate::infer::InferCtxt;\n-use crate::traits::error_reporting::suggest_constraining_type_param;\n \n use rustc_errors::{error_code, struct_span_err, Applicability, DiagnosticBuilder, Style};\n use rustc_hir as hir;\n@@ -13,7 +12,8 @@ use rustc_hir::intravisit::Visitor;\n use rustc_hir::{AsyncGeneratorKind, GeneratorKind, Node};\n use rustc_middle::ty::TypeckTables;\n use rustc_middle::ty::{\n-    self, AdtKind, DefIdTree, Infer, InferTy, ToPredicate, Ty, TyCtxt, TypeFoldable, WithConstness,\n+    self, suggest_constraining_type_param, AdtKind, DefIdTree, Infer, InferTy, ToPredicate, Ty,\n+    TyCtxt, TypeFoldable, WithConstness,\n };\n use rustc_span::symbol::{kw, sym, Symbol};\n use rustc_span::{MultiSpan, Span, DUMMY_SP};"}, {"sha": "857cc972559e499c7aa17fd8836ff9bee5d25dd9", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 49, "deletions": 55, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/29457dd92c5c754027c18b28c9e1307a345aafec/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29457dd92c5c754027c18b28c9e1307a345aafec/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=29457dd92c5c754027c18b28c9e1307a345aafec", "patch": "@@ -947,65 +947,59 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // this isn't perfect (that is, there are cases when\n                 // implementing a trait would be legal but is rejected\n                 // here).\n-                !unsatisfied_predicates.iter().any(|(p, _)| match p {\n-                        // Hide traits if they are present in predicates as they can be fixed without\n-                        // having to implement them.\n-                        ty::Predicate::Trait(t, _) => t.def_id() != info.def_id,\n-                        ty::Predicate::Projection(p) => p.item_def_id() != info.def_id,\n-                        _ => true,\n-                    }) && (type_is_local || info.def_id.is_local())\n-                        && self\n-                            .associated_item(info.def_id, item_name, Namespace::ValueNS)\n-                            .filter(|item| {\n-                                if let ty::AssocKind::Fn = item.kind {\n-                                    let id = item.def_id.as_local().map(|def_id| {\n-                                        self.tcx.hir().as_local_hir_id(def_id)\n-                                    });\n-                                    if let Some(hir::Node::TraitItem(hir::TraitItem {\n-                                        kind: hir::TraitItemKind::Fn(fn_sig, method),\n-                                        ..\n-                                    })) = id.map(|id| self.tcx.hir().get(id))\n+                unsatisfied_predicates.iter().all(|(p, _)| match p {\n+                    // Hide traits if they are present in predicates as they can be fixed without\n+                    // having to implement them.\n+                    ty::Predicate::Trait(t, _) => t.def_id() == info.def_id,\n+                    ty::Predicate::Projection(p) => p.item_def_id() == info.def_id,\n+                    _ => false,\n+                }) && (type_is_local || info.def_id.is_local())\n+                    && self\n+                        .associated_item(info.def_id, item_name, Namespace::ValueNS)\n+                        .filter(|item| {\n+                            if let ty::AssocKind::Fn = item.kind {\n+                                let id = item\n+                                    .def_id\n+                                    .as_local()\n+                                    .map(|def_id| self.tcx.hir().as_local_hir_id(def_id));\n+                                if let Some(hir::Node::TraitItem(hir::TraitItem {\n+                                    kind: hir::TraitItemKind::Fn(fn_sig, method),\n+                                    ..\n+                                })) = id.map(|id| self.tcx.hir().get(id))\n+                                {\n+                                    let self_first_arg = match method {\n+                                        hir::TraitFn::Required([ident, ..]) => {\n+                                            ident.name == kw::SelfLower\n+                                        }\n+                                        hir::TraitFn::Provided(body_id) => {\n+                                            self.tcx.hir().body(*body_id).params.first().map_or(\n+                                                false,\n+                                                |param| {\n+                                                    matches!(\n+                                                        param.pat.kind,\n+                                                        hir::PatKind::Binding(_, _, ident, _)\n+                                                            if ident.name == kw::SelfLower\n+                                                    )\n+                                                },\n+                                            )\n+                                        }\n+                                        _ => false,\n+                                    };\n+\n+                                    if !fn_sig.decl.implicit_self.has_implicit_self()\n+                                        && self_first_arg\n                                     {\n-                                        let self_first_arg = match method {\n-                                            hir::TraitFn::Required([ident, ..]) => {\n-                                                ident.name == kw::SelfLower\n-                                            }\n-                                            hir::TraitFn::Provided(body_id) => {\n-                                                match &self.tcx.hir().body(*body_id).params[..] {\n-                                                    [hir::Param {\n-                                                        pat:\n-                                                            hir::Pat {\n-                                                                kind:\n-                                                                    hir::PatKind::Binding(\n-                                                                        _,\n-                                                                        _,\n-                                                                        ident,\n-                                                                        ..,\n-                                                                    ),\n-                                                                ..\n-                                                            },\n-                                                        ..\n-                                                    }, ..] => ident.name == kw::SelfLower,\n-                                                    _ => false,\n-                                                }\n-                                            }\n-                                            _ => false,\n-                                        };\n-\n-                                        if !fn_sig.decl.implicit_self.has_implicit_self()\n-                                            && self_first_arg\n-                                        {\n-                                            if let Some(ty) = fn_sig.decl.inputs.get(0) {\n-                                                arbitrary_rcvr.push(ty.span);\n-                                            }\n-                                            return false;\n+                                        if let Some(ty) = fn_sig.decl.inputs.get(0) {\n+                                            arbitrary_rcvr.push(ty.span);\n                                         }\n+                                        return false;\n                                     }\n                                 }\n-                                // We only want to suggest public or local traits (#45781).\n-                                item.vis == ty::Visibility::Public || info.def_id.is_local()\n-                            })\n-                            .is_some()\n+                            }\n+                            // We only want to suggest public or local traits (#45781).\n+                            item.vis == ty::Visibility::Public || info.def_id.is_local()\n+                        })\n+                        .is_some()\n             })\n             .collect::<Vec<_>>();\n         for span in &arbitrary_rcvr {"}, {"sha": "e6cbc8ab7230c79795c8180c72730fcba3019329", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 78, "deletions": 14, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/29457dd92c5c754027c18b28c9e1307a345aafec/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29457dd92c5c754027c18b28c9e1307a345aafec/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=29457dd92c5c754027c18b28c9e1307a345aafec", "patch": "@@ -10,7 +10,7 @@ use rustc_middle::ty::adjustment::{\n     Adjust, Adjustment, AllowTwoPhase, AutoBorrow, AutoBorrowMutability,\n };\n use rustc_middle::ty::TyKind::{Adt, Array, Char, FnDef, Never, Ref, Str, Tuple, Uint};\n-use rustc_middle::ty::{self, Ty, TypeFoldable};\n+use rustc_middle::ty::{self, suggest_constraining_type_param, Ty, TyCtxt, TypeFoldable};\n use rustc_span::Span;\n use rustc_trait_selection::infer::InferCtxtExt;\n \n@@ -253,6 +253,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // error types are considered \"builtin\"\n                 if !lhs_ty.references_error() && !rhs_ty.references_error() {\n                     let source_map = self.tcx.sess.source_map();\n+\n                     match is_assign {\n                         IsAssign::Yes => {\n                             let mut err = struct_span_err!(\n@@ -317,59 +318,74 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                     // This has nothing here because it means we did string\n                                     // concatenation (e.g., \"Hello \" += \"World!\"). This means\n                                     // we don't want the note in the else clause to be emitted\n-                                } else if let ty::Param(_) = lhs_ty.kind {\n-                                    // FIXME: point to span of param\n-                                    err.note(&format!(\n-                                        \"`{}` might need a bound for `{}`\",\n-                                        lhs_ty, missing_trait\n-                                    ));\n+                                } else if let ty::Param(p) = lhs_ty.kind {\n+                                    suggest_constraining_param(\n+                                        self.tcx,\n+                                        self.body_id,\n+                                        &mut err,\n+                                        lhs_ty,\n+                                        rhs_ty,\n+                                        missing_trait,\n+                                        p,\n+                                        false,\n+                                    );\n                                 } else if !suggested_deref {\n                                     suggest_impl_missing(&mut err, lhs_ty, &missing_trait);\n                                 }\n                             }\n                             err.emit();\n                         }\n                         IsAssign::No => {\n-                            let (message, missing_trait) = match op.node {\n+                            let (message, missing_trait, use_output) = match op.node {\n                                 hir::BinOpKind::Add => (\n                                     format!(\"cannot add `{}` to `{}`\", rhs_ty, lhs_ty),\n                                     Some(\"std::ops::Add\"),\n+                                    true,\n                                 ),\n                                 hir::BinOpKind::Sub => (\n                                     format!(\"cannot subtract `{}` from `{}`\", rhs_ty, lhs_ty),\n                                     Some(\"std::ops::Sub\"),\n+                                    true,\n                                 ),\n                                 hir::BinOpKind::Mul => (\n                                     format!(\"cannot multiply `{}` to `{}`\", rhs_ty, lhs_ty),\n                                     Some(\"std::ops::Mul\"),\n+                                    true,\n                                 ),\n                                 hir::BinOpKind::Div => (\n                                     format!(\"cannot divide `{}` by `{}`\", lhs_ty, rhs_ty),\n                                     Some(\"std::ops::Div\"),\n+                                    true,\n                                 ),\n                                 hir::BinOpKind::Rem => (\n                                     format!(\"cannot mod `{}` by `{}`\", lhs_ty, rhs_ty),\n                                     Some(\"std::ops::Rem\"),\n+                                    true,\n                                 ),\n                                 hir::BinOpKind::BitAnd => (\n                                     format!(\"no implementation for `{} & {}`\", lhs_ty, rhs_ty),\n                                     Some(\"std::ops::BitAnd\"),\n+                                    true,\n                                 ),\n                                 hir::BinOpKind::BitXor => (\n                                     format!(\"no implementation for `{} ^ {}`\", lhs_ty, rhs_ty),\n                                     Some(\"std::ops::BitXor\"),\n+                                    true,\n                                 ),\n                                 hir::BinOpKind::BitOr => (\n                                     format!(\"no implementation for `{} | {}`\", lhs_ty, rhs_ty),\n                                     Some(\"std::ops::BitOr\"),\n+                                    true,\n                                 ),\n                                 hir::BinOpKind::Shl => (\n                                     format!(\"no implementation for `{} << {}`\", lhs_ty, rhs_ty),\n                                     Some(\"std::ops::Shl\"),\n+                                    true,\n                                 ),\n                                 hir::BinOpKind::Shr => (\n                                     format!(\"no implementation for `{} >> {}`\", lhs_ty, rhs_ty),\n                                     Some(\"std::ops::Shr\"),\n+                                    true,\n                                 ),\n                                 hir::BinOpKind::Eq | hir::BinOpKind::Ne => (\n                                     format!(\n@@ -378,6 +394,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                         lhs_ty\n                                     ),\n                                     Some(\"std::cmp::PartialEq\"),\n+                                    false,\n                                 ),\n                                 hir::BinOpKind::Lt\n                                 | hir::BinOpKind::Le\n@@ -389,6 +406,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                         lhs_ty\n                                     ),\n                                     Some(\"std::cmp::PartialOrd\"),\n+                                    false,\n                                 ),\n                                 _ => (\n                                     format!(\n@@ -397,6 +415,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                         lhs_ty\n                                     ),\n                                     None,\n+                                    false,\n                                 ),\n                             };\n                             let mut err = struct_span_err!(\n@@ -459,12 +478,17 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                     // This has nothing here because it means we did string\n                                     // concatenation (e.g., \"Hello \" + \"World!\"). This means\n                                     // we don't want the note in the else clause to be emitted\n-                                } else if let ty::Param(_) = lhs_ty.kind {\n-                                    // FIXME: point to span of param\n-                                    err.note(&format!(\n-                                        \"`{}` might need a bound for `{}`\",\n-                                        lhs_ty, missing_trait\n-                                    ));\n+                                } else if let ty::Param(p) = lhs_ty.kind {\n+                                    suggest_constraining_param(\n+                                        self.tcx,\n+                                        self.body_id,\n+                                        &mut err,\n+                                        lhs_ty,\n+                                        rhs_ty,\n+                                        missing_trait,\n+                                        p,\n+                                        use_output,\n+                                    );\n                                 } else if !suggested_deref && !involves_fn {\n                                     suggest_impl_missing(&mut err, lhs_ty, &missing_trait);\n                                 }\n@@ -911,3 +935,43 @@ fn suggest_impl_missing(err: &mut DiagnosticBuilder<'_>, ty: Ty<'_>, missing_tra\n         }\n     }\n }\n+\n+fn suggest_constraining_param(\n+    tcx: TyCtxt<'_>,\n+    body_id: hir::HirId,\n+    mut err: &mut DiagnosticBuilder<'_>,\n+    lhs_ty: Ty<'_>,\n+    rhs_ty: Ty<'_>,\n+    missing_trait: &str,\n+    p: ty::ParamTy,\n+    set_output: bool,\n+) {\n+    let hir = tcx.hir();\n+    let msg = &format!(\"`{}` might need a bound for `{}`\", lhs_ty, missing_trait);\n+    // Try to find the def-id and details for the parameter p. We have only the index,\n+    // so we have to find the enclosing function's def-id, then look through its declared\n+    // generic parameters to get the declaration.\n+    let def_id = hir.body_owner_def_id(hir::BodyId { hir_id: body_id });\n+    let generics = tcx.generics_of(def_id);\n+    let param_def_id = generics.type_param(&p, tcx).def_id;\n+    if let Some(generics) = param_def_id\n+        .as_local()\n+        .map(|id| hir.as_local_hir_id(id))\n+        .and_then(|id| hir.find(hir.get_parent_item(id)))\n+        .as_ref()\n+        .and_then(|node| node.generics())\n+    {\n+        let output = if set_output { format!(\"<Output = {}>\", rhs_ty) } else { String::new() };\n+        suggest_constraining_type_param(\n+            tcx,\n+            generics,\n+            &mut err,\n+            &format!(\"{}\", lhs_ty),\n+            &format!(\"{}{}\", missing_trait, output),\n+            None,\n+        );\n+    } else {\n+        let span = tcx.def_span(param_def_id);\n+        err.span_label(span, msg);\n+    }\n+}"}, {"sha": "550f672ed4cf673a086d50b2dc02800603c1bd79", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 29, "deletions": 2, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/29457dd92c5c754027c18b28c9e1307a345aafec/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29457dd92c5c754027c18b28c9e1307a345aafec/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=29457dd92c5c754027c18b28c9e1307a345aafec", "patch": "@@ -1129,9 +1129,36 @@ pub struct IdMap {\n     map: FxHashMap<String, usize>,\n }\n \n+fn init_id_map() -> FxHashMap<String, usize> {\n+    let mut map = FxHashMap::default();\n+    // This is the list of IDs used by rustdoc templates.\n+    map.insert(\"mainThemeStyle\".to_owned(), 1);\n+    map.insert(\"themeStyle\".to_owned(), 1);\n+    map.insert(\"theme-picker\".to_owned(), 1);\n+    map.insert(\"theme-choices\".to_owned(), 1);\n+    map.insert(\"settings-menu\".to_owned(), 1);\n+    map.insert(\"main\".to_owned(), 1);\n+    map.insert(\"search\".to_owned(), 1);\n+    map.insert(\"crate-search\".to_owned(), 1);\n+    map.insert(\"render-detail\".to_owned(), 1);\n+    map.insert(\"toggle-all-docs\".to_owned(), 1);\n+    map.insert(\"all-types\".to_owned(), 1);\n+    // This is the list of IDs used by rustdoc sections.\n+    map.insert(\"fields\".to_owned(), 1);\n+    map.insert(\"variants\".to_owned(), 1);\n+    map.insert(\"implementors-list\".to_owned(), 1);\n+    map.insert(\"synthetic-implementors-list\".to_owned(), 1);\n+    map.insert(\"implementations\".to_owned(), 1);\n+    map.insert(\"trait-implementations\".to_owned(), 1);\n+    map.insert(\"synthetic-implementations\".to_owned(), 1);\n+    map.insert(\"blanket-implementations\".to_owned(), 1);\n+    map.insert(\"deref-methods\".to_owned(), 1);\n+    map\n+}\n+\n impl IdMap {\n     pub fn new() -> Self {\n-        IdMap::default()\n+        IdMap { map: init_id_map() }\n     }\n \n     pub fn populate<I: IntoIterator<Item = String>>(&mut self, ids: I) {\n@@ -1141,7 +1168,7 @@ impl IdMap {\n     }\n \n     pub fn reset(&mut self) {\n-        self.map = FxHashMap::default();\n+        self.map = init_id_map();\n     }\n \n     pub fn derive(&mut self, candidate: String) -> String {"}, {"sha": "bf0451a1d9d659c837f94ee124bba2c1db0c5874", "filename": "src/librustdoc/html/markdown/tests.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/29457dd92c5c754027c18b28c9e1307a345aafec/src%2Flibrustdoc%2Fhtml%2Fmarkdown%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29457dd92c5c754027c18b28c9e1307a345aafec/src%2Flibrustdoc%2Fhtml%2Fmarkdown%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown%2Ftests.rs?ref=29457dd92c5c754027c18b28c9e1307a345aafec", "patch": "@@ -29,8 +29,8 @@ fn test_unique_id() {\n         \"examples-2\",\n         \"method.into_iter-1\",\n         \"foo-1\",\n-        \"main\",\n-        \"search\",\n+        \"main-1\",\n+        \"search-1\",\n         \"methods\",\n         \"examples-3\",\n         \"method.into_iter-2\",\n@@ -191,8 +191,8 @@ fn test_header_ids_multiple_blocks() {\n     t(\n         &mut map,\n         \"# Main\",\n-        \"<h1 id=\\\"main\\\" class=\\\"section-header\\\">\\\n-        <a href=\\\"#main\\\">Main</a></h1>\",\n+        \"<h1 id=\\\"main-1\\\" class=\\\"section-header\\\">\\\n+        <a href=\\\"#main-1\\\">Main</a></h1>\",\n     );\n     t(\n         &mut map,"}, {"sha": "666e59b9a045eda2991f7f23980abd6f026b4c69", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/29457dd92c5c754027c18b28c9e1307a345aafec/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29457dd92c5c754027c18b28c9e1307a345aafec/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=29457dd92c5c754027c18b28c9e1307a345aafec", "patch": "@@ -3413,8 +3413,8 @@ fn render_assoc_items(\n                 write!(\n                     w,\n                     \"\\\n-                    <h2 id='methods' class='small-section-header'>\\\n-                      Methods<a href='#methods' class='anchor'></a>\\\n+                    <h2 id='implementations' class='small-section-header'>\\\n+                      Implementations<a href='#implementations' class='anchor'></a>\\\n                     </h2>\\\n                 \"\n                 );\n@@ -3475,10 +3475,10 @@ fn render_assoc_items(\n             write!(\n                 w,\n                 \"\\\n-                <h2 id='implementations' class='small-section-header'>\\\n-                  Trait Implementations<a href='#implementations' class='anchor'></a>\\\n+                <h2 id='trait-implementations' class='small-section-header'>\\\n+                  Trait Implementations<a href='#trait-implementations' class='anchor'></a>\\\n                 </h2>\\\n-                <div id='implementations-list'>{}</div>\",\n+                <div id='trait-implementations-list'>{}</div>\",\n                 impls\n             );\n         }\n@@ -4097,8 +4097,8 @@ fn sidebar_assoc_items(it: &clean::Item) -> String {\n             ret.sort();\n             if !ret.is_empty() {\n                 out.push_str(&format!(\n-                    \"<a class=\\\"sidebar-title\\\" href=\\\"#methods\\\">Methods\\\n-                                       </a><div class=\\\"sidebar-links\\\">{}</div>\",\n+                    \"<a class=\\\"sidebar-title\\\" href=\\\"#implementations\\\">Methods</a>\\\n+                     <div class=\\\"sidebar-links\\\">{}</div>\",\n                     ret.join(\"\")\n                 ));\n             }\n@@ -4191,24 +4191,24 @@ fn sidebar_assoc_items(it: &clean::Item) -> String {\n \n             if !concrete_format.is_empty() {\n                 out.push_str(\n-                    \"<a class=\\\"sidebar-title\\\" href=\\\"#implementations\\\">\\\n-                              Trait Implementations</a>\",\n+                    \"<a class=\\\"sidebar-title\\\" href=\\\"#trait-implementations\\\">\\\n+                        Trait Implementations</a>\",\n                 );\n                 out.push_str(&format!(\"<div class=\\\"sidebar-links\\\">{}</div>\", concrete_format));\n             }\n \n             if !synthetic_format.is_empty() {\n                 out.push_str(\n                     \"<a class=\\\"sidebar-title\\\" href=\\\"#synthetic-implementations\\\">\\\n-                              Auto Trait Implementations</a>\",\n+                        Auto Trait Implementations</a>\",\n                 );\n                 out.push_str(&format!(\"<div class=\\\"sidebar-links\\\">{}</div>\", synthetic_format));\n             }\n \n             if !blanket_format.is_empty() {\n                 out.push_str(\n                     \"<a class=\\\"sidebar-title\\\" href=\\\"#blanket-implementations\\\">\\\n-                              Blanket Implementations</a>\",\n+                        Blanket Implementations</a>\",\n                 );\n                 out.push_str(&format!(\"<div class=\\\"sidebar-links\\\">{}</div>\", blanket_format));\n             }"}, {"sha": "a023d5a2d95f1aaf65447e1c3e9094a4811c1a8e", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29457dd92c5c754027c18b28c9e1307a345aafec/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/29457dd92c5c754027c18b28c9e1307a345aafec/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=29457dd92c5c754027c18b28c9e1307a345aafec", "patch": "@@ -2180,7 +2180,7 @@ function getSearchElement() {\n         if (collapse) {\n             toggleAllDocs(pageId, true);\n         } else if (getCurrentValue(\"rustdoc-auto-hide-trait-implementations\") !== \"false\") {\n-            var impl_list = document.getElementById(\"implementations-list\");\n+            var impl_list = document.getElementById(\"trait-implementations-list\");\n \n             if (impl_list !== null) {\n                 onEachLazy(impl_list.getElementsByClassName(\"collapse-toggle\"), function(e) {"}, {"sha": "905f958826897833f029bada240c76a9950782a8", "filename": "src/test/rustdoc/const-generics/add-impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29457dd92c5c754027c18b28c9e1307a345aafec/src%2Ftest%2Frustdoc%2Fconst-generics%2Fadd-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29457dd92c5c754027c18b28c9e1307a345aafec/src%2Ftest%2Frustdoc%2Fconst-generics%2Fadd-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fconst-generics%2Fadd-impl.rs?ref=29457dd92c5c754027c18b28c9e1307a345aafec", "patch": "@@ -11,7 +11,7 @@ pub struct Simd<T, const WIDTH: usize> {\n     inner: T,\n }\n \n-// @has foo/struct.Simd.html '//div[@id=\"implementations-list\"]/h3/code' 'impl Add<Simd<u8, 16usize>> for Simd<u8, 16>'\n+// @has foo/struct.Simd.html '//div[@id=\"trait-implementations-list\"]/h3/code' 'impl Add<Simd<u8, 16usize>> for Simd<u8, 16>'\n impl Add for Simd<u8, 16> {\n     type Output = Self;\n "}, {"sha": "112d632971a5f1e57a96f3e33404aae2437d0b23", "filename": "src/test/rustdoc/duplicate_impls/issue-33054.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29457dd92c5c754027c18b28c9e1307a345aafec/src%2Ftest%2Frustdoc%2Fduplicate_impls%2Fissue-33054.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29457dd92c5c754027c18b28c9e1307a345aafec/src%2Ftest%2Frustdoc%2Fduplicate_impls%2Fissue-33054.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fduplicate_impls%2Fissue-33054.rs?ref=29457dd92c5c754027c18b28c9e1307a345aafec", "patch": "@@ -1,7 +1,7 @@\n // @has issue_33054/impls/struct.Foo.html\n // @has - '//code' 'impl Foo'\n // @has - '//code' 'impl Bar for Foo'\n-// @count - '//*[@id=\"implementations-list\"]/*[@class=\"impl\"]' 1\n+// @count - '//*[@id=\"trait-implementations-list\"]/*[@class=\"impl\"]' 1\n // @count - '//*[@id=\"main\"]/*[@class=\"impl\"]' 1\n // @has issue_33054/impls/bar/trait.Bar.html\n // @has - '//code' 'impl Bar for Foo'"}, {"sha": "896fc1a78f13f94ff997826ae39f023e225b61b7", "filename": "src/test/rustdoc/issue-21474.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29457dd92c5c754027c18b28c9e1307a345aafec/src%2Ftest%2Frustdoc%2Fissue-21474.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29457dd92c5c754027c18b28c9e1307a345aafec/src%2Ftest%2Frustdoc%2Fissue-21474.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-21474.rs?ref=29457dd92c5c754027c18b28c9e1307a345aafec", "patch": "@@ -7,5 +7,5 @@ mod inner {\n pub trait Blah { }\n \n // @count issue_21474/struct.What.html \\\n-//        '//*[@id=\"implementations-list\"]/*[@class=\"impl\"]' 1\n+//        '//*[@id=\"trait-implementations-list\"]/*[@class=\"impl\"]' 1\n pub struct What;"}, {"sha": "0225c0c5c2fa74e2f3d841d87fa61e235f5730af", "filename": "src/test/rustdoc/issue-45584.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/29457dd92c5c754027c18b28c9e1307a345aafec/src%2Ftest%2Frustdoc%2Fissue-45584.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29457dd92c5c754027c18b28c9e1307a345aafec/src%2Ftest%2Frustdoc%2Fissue-45584.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-45584.rs?ref=29457dd92c5c754027c18b28c9e1307a345aafec", "patch": "@@ -4,12 +4,12 @@ pub trait Bar<T, U> {}\n \n // @has 'foo/struct.Foo1.html'\n pub struct Foo1;\n-// @count - '//*[@id=\"implementations-list\"]/*[@class=\"impl\"]' 1\n+// @count - '//*[@id=\"trait-implementations-list\"]/*[@class=\"impl\"]' 1\n // @has - '//*[@class=\"impl\"]' \"impl Bar<Foo1, &'static Foo1> for Foo1\"\n impl Bar<Foo1, &'static Foo1> for Foo1 {}\n \n // @has 'foo/struct.Foo2.html'\n pub struct Foo2;\n-// @count - '//*[@id=\"implementations-list\"]/*[@class=\"impl\"]' 1\n+// @count - '//*[@id=\"trait-implementations-list\"]/*[@class=\"impl\"]' 1\n // @has - '//*[@class=\"impl\"]' \"impl Bar<&'static Foo2, Foo2> for u8\"\n impl Bar<&'static Foo2, Foo2> for u8 {}"}, {"sha": "d312a5114595a466290dad98f9ce96f8707eea71", "filename": "src/test/rustdoc/issue-55321.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/29457dd92c5c754027c18b28c9e1307a345aafec/src%2Ftest%2Frustdoc%2Fissue-55321.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29457dd92c5c754027c18b28c9e1307a345aafec/src%2Ftest%2Frustdoc%2Fissue-55321.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-55321.rs?ref=29457dd92c5c754027c18b28c9e1307a345aafec", "patch": "@@ -1,8 +1,8 @@\n #![feature(negative_impls)]\n \n // @has issue_55321/struct.A.html\n-// @has - '//*[@id=\"implementations-list\"]/*[@class=\"impl\"]//code' \"impl !Send for A\"\n-// @has - '//*[@id=\"implementations-list\"]/*[@class=\"impl\"]//code' \"impl !Sync for A\"\n+// @has - '//*[@id=\"trait-implementations-list\"]/*[@class=\"impl\"]//code' \"impl !Send for A\"\n+// @has - '//*[@id=\"trait-implementations-list\"]/*[@class=\"impl\"]//code' \"impl !Sync for A\"\n pub struct A();\n \n impl !Send for A {}"}, {"sha": "3414d9540776aa4ac24f4a058676d71ee6e450d3", "filename": "src/test/rustdoc/negative-impl-sidebar.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29457dd92c5c754027c18b28c9e1307a345aafec/src%2Ftest%2Frustdoc%2Fnegative-impl-sidebar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29457dd92c5c754027c18b28c9e1307a345aafec/src%2Ftest%2Frustdoc%2Fnegative-impl-sidebar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fnegative-impl-sidebar.rs?ref=29457dd92c5c754027c18b28c9e1307a345aafec", "patch": "@@ -4,6 +4,6 @@\n pub struct Foo;\n \n // @has foo/struct.Foo.html\n-// @has - '//*[@class=\"sidebar-title\"][@href=\"#implementations\"]' 'Trait Implementations'\n+// @has - '//*[@class=\"sidebar-title\"][@href=\"#trait-implementations\"]' 'Trait Implementations'\n // @has - '//*[@class=\"sidebar-links\"]/a' '!Sync'\n impl !Sync for Foo {}"}, {"sha": "96eb11311d6b43ba6ad3bfd410a03b1e726d2d0d", "filename": "src/test/rustdoc/struct-implementations-title.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/29457dd92c5c754027c18b28c9e1307a345aafec/src%2Ftest%2Frustdoc%2Fstruct-implementations-title.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29457dd92c5c754027c18b28c9e1307a345aafec/src%2Ftest%2Frustdoc%2Fstruct-implementations-title.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fstruct-implementations-title.rs?ref=29457dd92c5c754027c18b28c9e1307a345aafec", "patch": "@@ -0,0 +1,9 @@\n+#![crate_name = \"foo\"]\n+\n+pub struct Struc;\n+\n+// @has foo/struct.Struc.html\n+// @has - '//*[@id=\"main\"]/h2[@id=\"implementations\"]' \"Implementations\"\n+impl Struc {\n+    pub const S: u64 = 0;\n+}"}, {"sha": "d20b4744af15b413a7a7ea71f2e10d39610d388f", "filename": "src/test/rustdoc/synthetic_auto/manual.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/29457dd92c5c754027c18b28c9e1307a345aafec/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Fmanual.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29457dd92c5c754027c18b28c9e1307a345aafec/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Fmanual.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Fmanual.rs?ref=29457dd92c5c754027c18b28c9e1307a345aafec", "patch": "@@ -2,10 +2,10 @@\n // @has - '//*[@id=\"synthetic-implementations-list\"]/*[@class=\"impl\"]//code' 'impl<T> Sync for \\\n // Foo<T> where T: Sync'\n //\n-// @has - '//*[@id=\"implementations-list\"]/*[@class=\"impl\"]//code' \\\n+// @has - '//*[@id=\"trait-implementations-list\"]/*[@class=\"impl\"]//code' \\\n // 'impl<T> Send for Foo<T>'\n //\n-// @count - '//*[@id=\"implementations-list\"]/*[@class=\"impl\"]' 1\n+// @count - '//*[@id=\"trait-implementations-list\"]/*[@class=\"impl\"]' 1\n // @count - '//*[@id=\"synthetic-implementations-list\"]/*[@class=\"impl\"]' 4\n pub struct Foo<T> {\n     field: T,"}, {"sha": "7f834d3d5a51216ae09102af8d16a9a365ab32bb", "filename": "src/test/rustdoc/typedef.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/29457dd92c5c754027c18b28c9e1307a345aafec/src%2Ftest%2Frustdoc%2Ftypedef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29457dd92c5c754027c18b28c9e1307a345aafec/src%2Ftest%2Frustdoc%2Ftypedef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Ftypedef.rs?ref=29457dd92c5c754027c18b28c9e1307a345aafec", "patch": "@@ -13,8 +13,8 @@ impl MyStruct {\n // @has - '//*[@class=\"impl\"]//code' 'impl MyTrait for MyAlias'\n // @has - 'Alias docstring'\n // @has - '//*[@class=\"sidebar\"]//p[@class=\"location\"]' 'Type Definition MyAlias'\n-// @has - '//*[@class=\"sidebar\"]//a[@href=\"#methods\"]' 'Methods'\n-// @has - '//*[@class=\"sidebar\"]//a[@href=\"#implementations\"]' 'Trait Implementations'\n+// @has - '//*[@class=\"sidebar\"]//a[@href=\"#implementations\"]' 'Methods'\n+// @has - '//*[@class=\"sidebar\"]//a[@href=\"#trait-implementations\"]' 'Trait Implementations'\n /// Alias docstring\n pub type MyAlias = MyStruct;\n "}, {"sha": "29ac32fcf2204765e7fe0f2a5ee9f914887f3b05", "filename": "src/test/ui/consts/const-eval/ub-wide-ptr.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/29457dd92c5c754027c18b28c9e1307a345aafec/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29457dd92c5c754027c18b28c9e1307a345aafec/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.rs?ref=29457dd92c5c754027c18b28c9e1307a345aafec", "patch": "@@ -104,6 +104,14 @@ const TRAIT_OBJ_SHORT_VTABLE_2: &dyn Trait = unsafe { mem::transmute((&92u8, &3u\n // bad trait object\n const TRAIT_OBJ_INT_VTABLE: &dyn Trait = unsafe { mem::transmute((&92u8, 4usize)) };\n //~^ ERROR it is undefined behavior to use this value\n+const TRAIT_OBJ_UNALIGNED_VTABLE: &dyn Trait = unsafe { mem::transmute((&92u8, &[0u8; 128])) };\n+//~^ ERROR it is undefined behavior to use this value\n+const TRAIT_OBJ_BAD_DROP_FN_NULL: &dyn Trait = unsafe { mem::transmute((&92u8, &[0usize; 8])) };\n+//~^ ERROR it is undefined behavior to use this value\n+const TRAIT_OBJ_BAD_DROP_FN_INT: &dyn Trait = unsafe { mem::transmute((&92u8, &[1usize; 8])) };\n+//~^ ERROR it is undefined behavior to use this value\n+const TRAIT_OBJ_BAD_DROP_FN_NOT_FN_PTR: &dyn Trait = unsafe { mem::transmute((&92u8, &[&42u8; 8])) };\n+//~^ ERROR it is undefined behavior to use this value\n \n // bad data *inside* the trait object\n const TRAIT_OBJ_CONTENT_INVALID: &dyn Trait = unsafe { mem::transmute::<_, &bool>(&3u8) };"}, {"sha": "94ca60596d61bd6ccebf689626a5e42745cc39e6", "filename": "src/test/ui/consts/const-eval/ub-wide-ptr.stderr", "status": "modified", "additions": 42, "deletions": 10, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/29457dd92c5c754027c18b28c9e1307a345aafec/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/29457dd92c5c754027c18b28c9e1307a345aafec/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.stderr?ref=29457dd92c5c754027c18b28c9e1307a345aafec", "patch": "@@ -138,62 +138,94 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-wide-ptr.rs:99:1\n    |\n LL | const TRAIT_OBJ_SHORT_VTABLE_1: &dyn Trait = unsafe { mem::transmute((&92u8, &3u8)) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered dangling or unaligned vtable pointer in wide pointer or too small vtable\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered too small vtable\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-wide-ptr.rs:102:1\n    |\n LL | const TRAIT_OBJ_SHORT_VTABLE_2: &dyn Trait = unsafe { mem::transmute((&92u8, &3u64)) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered dangling or unaligned vtable pointer in wide pointer or too small vtable\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered too small vtable\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-wide-ptr.rs:105:1\n    |\n LL | const TRAIT_OBJ_INT_VTABLE: &dyn Trait = unsafe { mem::transmute((&92u8, 4usize)) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered dangling or unaligned vtable pointer in wide pointer or too small vtable\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered dangling vtable pointer in wide pointer\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/ub-wide-ptr.rs:107:1\n+   |\n+LL | const TRAIT_OBJ_UNALIGNED_VTABLE: &dyn Trait = unsafe { mem::transmute((&92u8, &[0u8; 128])) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered unaligned vtable pointer in wide pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-wide-ptr.rs:109:1\n    |\n+LL | const TRAIT_OBJ_BAD_DROP_FN_NULL: &dyn Trait = unsafe { mem::transmute((&92u8, &[0usize; 8])) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered invalid drop function pointer in vtable\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/ub-wide-ptr.rs:111:1\n+   |\n+LL | const TRAIT_OBJ_BAD_DROP_FN_INT: &dyn Trait = unsafe { mem::transmute((&92u8, &[1usize; 8])) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered invalid drop function pointer in vtable\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/ub-wide-ptr.rs:113:1\n+   |\n+LL | const TRAIT_OBJ_BAD_DROP_FN_NOT_FN_PTR: &dyn Trait = unsafe { mem::transmute((&92u8, &[&42u8; 8])) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered invalid drop function pointer in vtable\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/ub-wide-ptr.rs:117:1\n+   |\n LL | const TRAIT_OBJ_CONTENT_INVALID: &dyn Trait = unsafe { mem::transmute::<_, &bool>(&3u8) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 0x03 at .<deref>.<dyn-downcast>, but expected a boolean\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:113:1\n+  --> $DIR/ub-wide-ptr.rs:121:1\n    |\n LL | const RAW_TRAIT_OBJ_VTABLE_NULL: *const dyn Trait = unsafe { mem::transmute((&92u8, 0usize)) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered dangling or unaligned vtable pointer in wide pointer or too small vtable\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered dangling vtable pointer in wide pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:115:1\n+  --> $DIR/ub-wide-ptr.rs:123:1\n    |\n LL | const RAW_TRAIT_OBJ_VTABLE_INVALID: *const dyn Trait = unsafe { mem::transmute((&92u8, &3u64)) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered dangling or unaligned vtable pointer in wide pointer or too small vtable\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered too small vtable\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: could not evaluate static initializer\n-  --> $DIR/ub-wide-ptr.rs:121:5\n+  --> $DIR/ub-wide-ptr.rs:129:5\n    |\n LL |     mem::transmute::<_, &dyn Trait>((&92u8, 0usize))\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ inbounds test failed: 0x0 is not a valid pointer\n \n error[E0080]: could not evaluate static initializer\n-  --> $DIR/ub-wide-ptr.rs:125:5\n+  --> $DIR/ub-wide-ptr.rs:133:5\n    |\n LL |     mem::transmute::<_, &dyn Trait>((&92u8, &3u64))\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ memory access failed: pointer must be in-bounds at offset N, but is outside bounds of allocN which has size N\n \n-error: aborting due to 24 previous errors\n+error: aborting due to 28 previous errors\n \n For more information about this error, try `rustc --explain E0080`."}, {"sha": "b9468b3330b44e5b4a794fe2a7b2824b837dbe34", "filename": "src/test/ui/generic-associated-types/construct_with_other_type.stderr", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/29457dd92c5c754027c18b28c9e1307a345aafec/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fconstruct_with_other_type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/29457dd92c5c754027c18b28c9e1307a345aafec/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fconstruct_with_other_type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fconstruct_with_other_type.stderr?ref=29457dd92c5c754027c18b28c9e1307a345aafec", "patch": "@@ -2,11 +2,16 @@ error[E0271]: type mismatch resolving `for<'a> <<T as Baz>::Baa<'a> as std::ops:\n   --> $DIR/construct_with_other_type.rs:19:9\n    |\n LL | impl<T> Baz for T where T: Foo {\n-   |         ^^^ expected type parameter `T`, found associated type\n+   |      -  ^^^ expected type parameter `T`, found associated type\n+   |      |\n+   |      this type parameter\n    |\n    = note: expected associated type `<T as Foo>::Bar<'_, 'static>`\n               found associated type `<<T as Baz>::Quux<'_> as Foo>::Bar<'_, 'static>`\n-   = note: you might be missing a type parameter or trait bound\n+help: consider further restricting this bound\n+   |\n+LL | impl<T> Baz for T where T: Foo + Baz<Quux = T> {\n+   |                                ^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "364d2388741b0e9664970e9a17bd4ba6a94a3136", "filename": "src/test/ui/generic-associated-types/missing-bounds.fixed", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/29457dd92c5c754027c18b28c9e1307a345aafec/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmissing-bounds.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/29457dd92c5c754027c18b28c9e1307a345aafec/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmissing-bounds.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmissing-bounds.fixed?ref=29457dd92c5c754027c18b28c9e1307a345aafec", "patch": "@@ -0,0 +1,46 @@\n+// run-rustfix\n+\n+use std::ops::Add;\n+\n+struct A<B>(B);\n+\n+impl<B> Add for A<B> where B: Add + std::ops::Add<Output = B> {\n+    type Output = Self;\n+\n+    fn add(self, rhs: Self) -> Self {\n+        A(self.0 + rhs.0) //~ ERROR mismatched types\n+    }\n+}\n+\n+struct C<B>(B);\n+\n+impl<B: Add + std::ops::Add<Output = B>> Add for C<B> {\n+    type Output = Self;\n+\n+    fn add(self, rhs: Self) -> Self {\n+        Self(self.0 + rhs.0) //~ ERROR mismatched types\n+    }\n+}\n+\n+struct D<B>(B);\n+\n+impl<B: std::ops::Add<Output = B>> Add for D<B> {\n+    type Output = Self;\n+\n+    fn add(self, rhs: Self) -> Self {\n+        Self(self.0 + rhs.0) //~ ERROR cannot add `B` to `B`\n+    }\n+}\n+\n+struct E<B>(B);\n+\n+impl<B: Add> Add for E<B> where B: Add<Output = B>, B: std::ops::Add<Output = B> {\n+    //~^ ERROR equality constraints are not yet supported in `where` clauses\n+    type Output = Self;\n+\n+    fn add(self, rhs: Self) -> Self {\n+        Self(self.0 + rhs.0) //~ ERROR mismatched types\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "ffafff5e9f586d2543061aaaa616eec501040f8a", "filename": "src/test/ui/generic-associated-types/missing-bounds.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/29457dd92c5c754027c18b28c9e1307a345aafec/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmissing-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29457dd92c5c754027c18b28c9e1307a345aafec/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmissing-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmissing-bounds.rs?ref=29457dd92c5c754027c18b28c9e1307a345aafec", "patch": "@@ -0,0 +1,46 @@\n+// run-rustfix\n+\n+use std::ops::Add;\n+\n+struct A<B>(B);\n+\n+impl<B> Add for A<B> where B: Add {\n+    type Output = Self;\n+\n+    fn add(self, rhs: Self) -> Self {\n+        A(self.0 + rhs.0) //~ ERROR mismatched types\n+    }\n+}\n+\n+struct C<B>(B);\n+\n+impl<B: Add> Add for C<B> {\n+    type Output = Self;\n+\n+    fn add(self, rhs: Self) -> Self {\n+        Self(self.0 + rhs.0) //~ ERROR mismatched types\n+    }\n+}\n+\n+struct D<B>(B);\n+\n+impl<B> Add for D<B> {\n+    type Output = Self;\n+\n+    fn add(self, rhs: Self) -> Self {\n+        Self(self.0 + rhs.0) //~ ERROR cannot add `B` to `B`\n+    }\n+}\n+\n+struct E<B>(B);\n+\n+impl<B: Add> Add for E<B> where <B as Add>::Output = B {\n+    //~^ ERROR equality constraints are not yet supported in `where` clauses\n+    type Output = Self;\n+\n+    fn add(self, rhs: Self) -> Self {\n+        Self(self.0 + rhs.0) //~ ERROR mismatched types\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "50536fdaca96e25d04359a9ac5bf05d8c5ee4194", "filename": "src/test/ui/generic-associated-types/missing-bounds.stderr", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/29457dd92c5c754027c18b28c9e1307a345aafec/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmissing-bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/29457dd92c5c754027c18b28c9e1307a345aafec/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmissing-bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmissing-bounds.stderr?ref=29457dd92c5c754027c18b28c9e1307a345aafec", "patch": "@@ -0,0 +1,77 @@\n+error: equality constraints are not yet supported in `where` clauses\n+  --> $DIR/missing-bounds.rs:37:33\n+   |\n+LL | impl<B: Add> Add for E<B> where <B as Add>::Output = B {\n+   |                                 ^^^^^^^^^^^^^^^^^^^^^^ not supported\n+   |\n+   = note: see issue #20041 <https://github.com/rust-lang/rust/issues/20041> for more information\n+help: if `Output` is an associated type you're trying to set, use the associated type binding syntax\n+   |\n+LL | impl<B: Add> Add for E<B> where B: Add<Output = B> {\n+   |                                 ^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/missing-bounds.rs:11:11\n+   |\n+LL | impl<B> Add for A<B> where B: Add {\n+   |      - this type parameter\n+...\n+LL |         A(self.0 + rhs.0)\n+   |           ^^^^^^^^^^^^^^ expected type parameter `B`, found associated type\n+   |\n+   = note: expected type parameter `B`\n+             found associated type `<B as std::ops::Add>::Output`\n+help: consider further restricting this bound\n+   |\n+LL | impl<B> Add for A<B> where B: Add + std::ops::Add<Output = B> {\n+   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/missing-bounds.rs:21:14\n+   |\n+LL | impl<B: Add> Add for C<B> {\n+   |      - this type parameter\n+...\n+LL |         Self(self.0 + rhs.0)\n+   |              ^^^^^^^^^^^^^^ expected type parameter `B`, found associated type\n+   |\n+   = note: expected type parameter `B`\n+             found associated type `<B as std::ops::Add>::Output`\n+help: consider further restricting this bound\n+   |\n+LL | impl<B: Add + std::ops::Add<Output = B>> Add for C<B> {\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0369]: cannot add `B` to `B`\n+  --> $DIR/missing-bounds.rs:31:21\n+   |\n+LL |         Self(self.0 + rhs.0)\n+   |              ------ ^ ----- B\n+   |              |\n+   |              B\n+   |\n+help: consider restricting type parameter `B`\n+   |\n+LL | impl<B: std::ops::Add<Output = B>> Add for D<B> {\n+   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/missing-bounds.rs:42:14\n+   |\n+LL | impl<B: Add> Add for E<B> where <B as Add>::Output = B {\n+   |      - this type parameter\n+...\n+LL |         Self(self.0 + rhs.0)\n+   |              ^^^^^^^^^^^^^^ expected type parameter `B`, found associated type\n+   |\n+   = note: expected type parameter `B`\n+             found associated type `<B as std::ops::Add>::Output`\n+help: consider further restricting type parameter `B`\n+   |\n+LL | impl<B: Add> Add for E<B> where <B as Add>::Output = B, B: std::ops::Add<Output = B> {\n+   |                                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 5 previous errors\n+\n+Some errors have detailed explanations: E0308, E0369.\n+For more information about an error, try `rustc --explain E0308`."}, {"sha": "f53489a99f3b4edc32eae4d81086f84d86c0d63d", "filename": "src/test/ui/issues/issue-20005.stderr", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/29457dd92c5c754027c18b28c9e1307a345aafec/src%2Ftest%2Fui%2Fissues%2Fissue-20005.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/29457dd92c5c754027c18b28c9e1307a345aafec/src%2Ftest%2Fui%2Fissues%2Fissue-20005.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-20005.stderr?ref=29457dd92c5c754027c18b28c9e1307a345aafec", "patch": "@@ -5,12 +5,18 @@ LL | trait From<Src> {\n    |            --- required by this bound in `From`\n ...\n LL |     ) -> <Dst as From<Self>>::Result where Dst: From<Self> {\n-   |                                                 ^^^^^^^^^^- help: consider further restricting `Self`: `, Self: std::marker::Sized`\n-   |                                                 |\n-   |                                                 doesn't have a size known at compile-time\n+   |                                                 ^^^^^^^^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `Self`\n    = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n+help: consider further restricting `Self`\n+   |\n+LL |     ) -> <Dst as From<Self>>::Result where Dst: From<Self>, Self: std::marker::Sized  {\n+   |                                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: consider relaxing the implicit `Sized` restriction\n+   |\n+LL | trait From<Src: ?Sized> {\n+   |               ^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "d5cbcf786bf1abfe5426869412c4f3fd01871c89", "filename": "src/test/ui/issues/issue-24204.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/29457dd92c5c754027c18b28c9e1307a345aafec/src%2Ftest%2Fui%2Fissues%2Fissue-24204.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/29457dd92c5c754027c18b28c9e1307a345aafec/src%2Ftest%2Fui%2Fissues%2Fissue-24204.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-24204.stderr?ref=29457dd92c5c754027c18b28c9e1307a345aafec", "patch": "@@ -7,7 +7,9 @@ LL |     type A: MultiDispatch<Self::B, O = Self>;\n    |                                    -------- required by this bound in `Trait`\n ...\n LL | fn test<T: Trait<B=i32>>(b: i32) -> T where T::A: MultiDispatch<i32> { T::new(b) }\n-   |            ^^^^^^^^^^^^ expected type parameter `T`, found associated type\n+   |         -  ^^^^^^^^^^^^ expected type parameter `T`, found associated type\n+   |         |\n+   |         this type parameter\n    |\n    = note: expected type parameter `T`\n              found associated type `<<T as Trait>::A as MultiDispatch<i32>>::O`"}, {"sha": "a428ff7e91faddb04e0a80a4136be4bcf0dfff91", "filename": "src/test/ui/issues/issue-6738.stderr", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/29457dd92c5c754027c18b28c9e1307a345aafec/src%2Ftest%2Fui%2Fissues%2Fissue-6738.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/29457dd92c5c754027c18b28c9e1307a345aafec/src%2Ftest%2Fui%2Fissues%2Fissue-6738.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-6738.stderr?ref=29457dd92c5c754027c18b28c9e1307a345aafec", "patch": "@@ -6,7 +6,10 @@ LL |         self.x += v.x;\n    |         |\n    |         cannot use `+=` on type `T`\n    |\n-   = note: `T` might need a bound for `std::ops::AddAssign`\n+help: consider restricting type parameter `T`\n+   |\n+LL | impl<T: std::ops::AddAssign> Foo<T> {\n+   |       ^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "30df1261cefa1f56e9f23a3245f57fa400b12627", "filename": "src/test/ui/type/type-check/missing_trait_impl.stderr", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/29457dd92c5c754027c18b28c9e1307a345aafec/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fmissing_trait_impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/29457dd92c5c754027c18b28c9e1307a345aafec/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fmissing_trait_impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fmissing_trait_impl.stderr?ref=29457dd92c5c754027c18b28c9e1307a345aafec", "patch": "@@ -6,7 +6,10 @@ LL |     let z = x + y;\n    |             |\n    |             T\n    |\n-   = note: `T` might need a bound for `std::ops::Add`\n+help: consider restricting type parameter `T`\n+   |\n+LL | fn foo<T: std::ops::Add<Output = T>>(x: T, y: T) {\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0368]: binary assignment operation `+=` cannot be applied to type `T`\n   --> $DIR/missing_trait_impl.rs:9:5\n@@ -16,7 +19,10 @@ LL |     x += x;\n    |     |\n    |     cannot use `+=` on type `T`\n    |\n-   = note: `T` might need a bound for `std::ops::AddAssign`\n+help: consider restricting type parameter `T`\n+   |\n+LL | fn bar<T: std::ops::AddAssign>(x: T) {\n+   |         ^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to 2 previous errors\n "}]}