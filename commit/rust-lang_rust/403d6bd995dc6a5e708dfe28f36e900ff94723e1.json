{"sha": "403d6bd995dc6a5e708dfe28f36e900ff94723e1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQwM2Q2YmQ5OTVkYzZhNWU3MDhkZmUyOGYzNmU5MDBmZjk0NzIzZTE=", "commit": {"author": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2019-11-01T15:44:58Z"}, "committer": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2019-11-01T15:44:58Z"}, "message": "Abstract out pattern stacks to make the code more legible", "tree": {"sha": "e8ca53ad501b70f408c65816486c08145668396e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e8ca53ad501b70f408c65816486c08145668396e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/403d6bd995dc6a5e708dfe28f36e900ff94723e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/403d6bd995dc6a5e708dfe28f36e900ff94723e1", "html_url": "https://github.com/rust-lang/rust/commit/403d6bd995dc6a5e708dfe28f36e900ff94723e1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/403d6bd995dc6a5e708dfe28f36e900ff94723e1/comments", "author": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2665b6434e6c851f6bffecf83e35db22ee6bf6bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/2665b6434e6c851f6bffecf83e35db22ee6bf6bd", "html_url": "https://github.com/rust-lang/rust/commit/2665b6434e6c851f6bffecf83e35db22ee6bf6bd"}], "stats": {"total": 133, "additions": 92, "deletions": 41}, "files": [{"sha": "8382ddeabc6fe7eeb35e5384b535bc41116f7dab", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 87, "deletions": 35, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/403d6bd995dc6a5e708dfe28f36e900ff94723e1/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/403d6bd995dc6a5e708dfe28f36e900ff94723e1/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=403d6bd995dc6a5e708dfe28f36e900ff94723e1", "patch": "@@ -342,16 +342,69 @@ impl<'tcx> Pat<'tcx> {\n     }\n }\n \n-/// A 2D matrix. Nx1 matrices are very common, which is why `SmallVec[_; 2]`\n-/// works well for each row.\n-pub struct Matrix<'p, 'tcx>(Vec<SmallVec<[&'p Pat<'tcx>; 2]>>);\n+/// A row of a matrix. Rows of len 1 are very common, which is why `SmallVec[_; 2]`\n+/// works well.\n+#[derive(Debug, Clone)]\n+pub struct PatStack<'p, 'tcx>(SmallVec<[&'p Pat<'tcx>; 2]>);\n+\n+impl<'p, 'tcx> PatStack<'p, 'tcx> {\n+    pub fn from_pattern(pat: &'p Pat<'tcx>) -> Self {\n+        PatStack(smallvec![pat])\n+    }\n+\n+    fn from_vec(vec: SmallVec<[&'p Pat<'tcx>; 2]>) -> Self {\n+        PatStack(vec)\n+    }\n+\n+    fn from_slice(s: &[&'p Pat<'tcx>]) -> Self {\n+        PatStack(SmallVec::from_slice(s))\n+    }\n+\n+    fn is_empty(&self) -> bool {\n+        self.0.is_empty()\n+    }\n+\n+    fn len(&self) -> usize {\n+        self.0.len()\n+    }\n+\n+    fn head(&self) -> &'p Pat<'tcx> {\n+        self.0[0]\n+    }\n+\n+    fn to_tail(&self) -> Self {\n+        PatStack::from_slice(&self.0[1..])\n+    }\n+\n+    fn iter(&self) -> impl Iterator<Item = &Pat<'tcx>> {\n+        self.0.iter().map(|p| *p)\n+    }\n+}\n+\n+impl<'p, 'tcx> Default for PatStack<'p, 'tcx> {\n+    fn default() -> Self {\n+        PatStack(smallvec![])\n+    }\n+}\n+\n+impl<'p, 'tcx> FromIterator<&'p Pat<'tcx>> for PatStack<'p, 'tcx> {\n+    fn from_iter<T>(iter: T) -> Self\n+    where\n+        T: IntoIterator<Item = &'p Pat<'tcx>>,\n+    {\n+        PatStack(iter.into_iter().collect())\n+    }\n+}\n+\n+/// A 2D matrix.\n+pub struct Matrix<'p, 'tcx>(Vec<PatStack<'p, 'tcx>>);\n \n impl<'p, 'tcx> Matrix<'p, 'tcx> {\n     pub fn empty() -> Self {\n         Matrix(vec![])\n     }\n \n-    pub fn push(&mut self, row: SmallVec<[&'p Pat<'tcx>; 2]>) {\n+    pub fn push(&mut self, row: PatStack<'p, 'tcx>) {\n         self.0.push(row)\n     }\n }\n@@ -399,10 +452,10 @@ impl<'p, 'tcx> fmt::Debug for Matrix<'p, 'tcx> {\n     }\n }\n \n-impl<'p, 'tcx> FromIterator<SmallVec<[&'p Pat<'tcx>; 2]>> for Matrix<'p, 'tcx> {\n+impl<'p, 'tcx> FromIterator<PatStack<'p, 'tcx>> for Matrix<'p, 'tcx> {\n     fn from_iter<T>(iter: T) -> Self\n     where\n-        T: IntoIterator<Item = SmallVec<[&'p Pat<'tcx>; 2]>>,\n+        T: IntoIterator<Item = PatStack<'p, 'tcx>>,\n     {\n         Matrix(iter.into_iter().collect())\n     }\n@@ -1226,7 +1279,7 @@ fn compute_missing_ctors<'tcx>(\n pub fn is_useful<'p, 'a, 'tcx>(\n     cx: &mut MatchCheckCtxt<'a, 'tcx>,\n     matrix: &Matrix<'p, 'tcx>,\n-    v: &[&Pat<'tcx>],\n+    v: &PatStack<'_, 'tcx>,\n     witness: WitnessPreference,\n     hir_id: HirId,\n ) -> Usefulness<'tcx> {\n@@ -1253,9 +1306,9 @@ pub fn is_useful<'p, 'a, 'tcx>(\n \n     let (ty, span) = rows\n         .iter()\n-        .map(|r| (r[0].ty, r[0].span))\n+        .map(|r| (r.head().ty, r.head().span))\n         .find(|(ty, _)| !ty.references_error())\n-        .unwrap_or((v[0].ty, v[0].span));\n+        .unwrap_or((v.head().ty, v.head().span));\n     let pcx = PatCtxt {\n         // TyErr is used to represent the type of wildcard patterns matching\n         // against inaccessible (private) fields of structs, so that we won't\n@@ -1277,13 +1330,13 @@ pub fn is_useful<'p, 'a, 'tcx>(\n         // introducing uninhabited patterns for inaccessible fields. We\n         // need to figure out how to model that.\n         ty,\n-        max_slice_length: max_slice_length(cx, rows.iter().map(|r| r[0]).chain(Some(v[0]))),\n+        max_slice_length: max_slice_length(cx, rows.iter().map(|r| r.head()).chain(Some(v.head()))),\n         span,\n     };\n \n-    debug!(\"is_useful_expand_first_col: pcx={:#?}, expanding {:#?}\", pcx, v[0]);\n+    debug!(\"is_useful_expand_first_col: pcx={:#?}, expanding {:#?}\", pcx, v.head());\n \n-    if let Some(constructors) = pat_constructors(cx, v[0], pcx) {\n+    if let Some(constructors) = pat_constructors(cx, v.head(), pcx) {\n         debug!(\"is_useful - expanding constructors: {:#?}\", constructors);\n         split_grouped_constructors(\n             cx.tcx,\n@@ -1303,7 +1356,7 @@ pub fn is_useful<'p, 'a, 'tcx>(\n \n         let used_ctors: Vec<Constructor<'_>> = rows\n             .iter()\n-            .flat_map(|row| pat_constructors(cx, row[0], pcx).unwrap_or(vec![]))\n+            .flat_map(|row| pat_constructors(cx, row.head(), pcx).unwrap_or(vec![]))\n             .collect();\n         debug!(\"used_ctors = {:#?}\", used_ctors);\n         // `all_ctors` are all the constructors for the given type, which\n@@ -1372,11 +1425,9 @@ pub fn is_useful<'p, 'a, 'tcx>(\n         } else {\n             let matrix = rows\n                 .iter()\n-                .filter_map(|r| {\n-                    if r[0].is_wildcard() { Some(SmallVec::from_slice(&r[1..])) } else { None }\n-                })\n+                .filter_map(|r| if r.head().is_wildcard() { Some(r.to_tail()) } else { None })\n                 .collect();\n-            match is_useful(cx, &matrix, &v[1..], witness, hir_id) {\n+            match is_useful(cx, &matrix, &v.to_tail(), witness, hir_id) {\n                 UsefulWithWitness(pats) => {\n                     let cx = &*cx;\n                     // In this case, there's at least one \"free\"\n@@ -1473,7 +1524,7 @@ pub fn is_useful<'p, 'a, 'tcx>(\n fn is_useful_specialized<'p, 'a, 'tcx>(\n     cx: &mut MatchCheckCtxt<'a, 'tcx>,\n     &Matrix(ref m): &Matrix<'p, 'tcx>,\n-    v: &[&Pat<'tcx>],\n+    v: &PatStack<'_, 'tcx>,\n     ctor: Constructor<'tcx>,\n     lty: Ty<'tcx>,\n     witness: WitnessPreference,\n@@ -1787,7 +1838,7 @@ fn split_grouped_constructors<'p, 'tcx>(\n                 let row_borders = m\n                     .iter()\n                     .flat_map(|row| {\n-                        IntRange::from_pat(tcx, param_env, row[0]).map(|r| (r, row.len()))\n+                        IntRange::from_pat(tcx, param_env, row.head()).map(|r| (r, row.len()))\n                     })\n                     .flat_map(|(range, row_len)| {\n                         let intersection = ctor_range.intersection(&range);\n@@ -1933,7 +1984,7 @@ fn patterns_for_variant<'p, 'a: 'p, 'tcx>(\n     subpatterns: &'p [FieldPat<'tcx>],\n     wild_patterns: &[&'p Pat<'tcx>],\n     is_non_exhaustive: bool,\n-) -> SmallVec<[&'p Pat<'tcx>; 2]> {\n+) -> PatStack<'p, 'tcx> {\n     let mut result = SmallVec::from_slice(wild_patterns);\n \n     for subpat in subpatterns {\n@@ -1943,7 +1994,7 @@ fn patterns_for_variant<'p, 'a: 'p, 'tcx>(\n     }\n \n     debug!(\"patterns_for_variant({:#?}, {:#?}) = {:#?}\", subpatterns, wild_patterns, result);\n-    result\n+    PatStack::from_vec(result)\n }\n \n /// This is the main specialization step. It expands the first pattern in the given row\n@@ -1954,20 +2005,20 @@ fn patterns_for_variant<'p, 'a: 'p, 'tcx>(\n /// different patterns.\n /// Structure patterns with a partial wild pattern (Foo { a: 42, .. }) have their missing\n /// fields filled with wild patterns.\n-fn specialize<'p, 'a: 'p, 'tcx>(\n+fn specialize<'p, 'a: 'p, 'q: 'p, 'tcx>(\n     cx: &mut MatchCheckCtxt<'a, 'tcx>,\n-    r: &[&'p Pat<'tcx>],\n+    r: &PatStack<'q, 'tcx>,\n     constructor: &Constructor<'tcx>,\n     wild_patterns: &[&'p Pat<'tcx>],\n-) -> Option<SmallVec<[&'p Pat<'tcx>; 2]>> {\n-    let pat = &r[0];\n+) -> Option<PatStack<'p, 'tcx>> {\n+    let pat = r.head();\n \n     let head = match *pat.kind {\n         PatKind::AscribeUserType { ref subpattern, .. } => {\n-            specialize(cx, ::std::slice::from_ref(&subpattern), constructor, wild_patterns)\n+            specialize(cx, &PatStack::from_pattern(subpattern), constructor, wild_patterns)\n         }\n \n-        PatKind::Binding { .. } | PatKind::Wild => Some(SmallVec::from_slice(wild_patterns)),\n+        PatKind::Binding { .. } | PatKind::Wild => Some(PatStack::from_slice(wild_patterns)),\n \n         PatKind::Variant { adt_def, variant_index, ref subpatterns, .. } => {\n             let ref variant = adt_def.variants[variant_index];\n@@ -1981,7 +2032,7 @@ fn specialize<'p, 'a: 'p, 'tcx>(\n             Some(patterns_for_variant(cx, subpatterns, wild_patterns, false))\n         }\n \n-        PatKind::Deref { ref subpattern } => Some(smallvec![subpattern]),\n+        PatKind::Deref { ref subpattern } => Some(PatStack::from_pattern(subpattern)),\n \n         PatKind::Constant { value } if constructor.is_slice() => {\n             // We extract an `Option` for the pointer because slices of zero\n@@ -2051,7 +2102,7 @@ fn specialize<'p, 'a: 'p, 'tcx>(\n                         let (pat_lo, pat_hi) = pat.range.into_inner();\n                         let (ctor_lo, ctor_hi) = ctor.range.into_inner();\n                         assert!(pat_lo <= ctor_lo && ctor_hi <= pat_hi);\n-                        smallvec![]\n+                        PatStack::default()\n                     }),\n                     _ => None,\n                 }\n@@ -2062,7 +2113,7 @@ fn specialize<'p, 'a: 'p, 'tcx>(\n                 // range so intersection actually devolves into being covered\n                 // by the pattern.\n                 match constructor_covered_by_range(cx.tcx, cx.param_env, constructor, pat) {\n-                    Ok(true) => Some(smallvec![]),\n+                    Ok(true) => Some(PatStack::default()),\n                     Ok(false) | Err(ErrorReported) => None,\n                 }\n             }\n@@ -2104,7 +2155,7 @@ fn specialize<'p, 'a: 'p, 'tcx>(\n                     suffix,\n                     cx.param_env,\n                 ) {\n-                    Ok(true) => Some(smallvec![]),\n+                    Ok(true) => Some(PatStack::default()),\n                     Ok(false) => None,\n                     Err(ErrorReported) => None,\n                 }\n@@ -2116,10 +2167,11 @@ fn specialize<'p, 'a: 'p, 'tcx>(\n             bug!(\"support for or-patterns has not been fully implemented yet.\");\n         }\n     };\n-    debug!(\"specialize({:#?}, {:#?}) = {:#?}\", r[0], wild_patterns, head);\n+    debug!(\"specialize({:#?}, {:#?}) = {:#?}\", r.head(), wild_patterns, head);\n \n-    head.map(|mut head| {\n-        head.extend_from_slice(&r[1..]);\n-        head\n+    head.map(|head| {\n+        let mut head = head.0;\n+        head.extend_from_slice(&r.0[1..]);\n+        PatStack::from_vec(head)\n     })\n }"}, {"sha": "9d370554e86b40c30d82e2c488ae6328ebdfc8b0", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/403d6bd995dc6a5e708dfe28f36e900ff94723e1/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/403d6bd995dc6a5e708dfe28f36e900ff94723e1/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=403d6bd995dc6a5e708dfe28f36e900ff94723e1", "patch": "@@ -1,6 +1,6 @@\n use super::_match::Usefulness::*;\n use super::_match::WitnessPreference::*;\n-use super::_match::{expand_pattern, is_useful, MatchCheckCtxt, Matrix};\n+use super::_match::{expand_pattern, is_useful, MatchCheckCtxt, Matrix, PatStack};\n \n use super::{PatCtxt, PatKind, PatternError};\n \n@@ -16,7 +16,6 @@ use rustc::hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc::hir::HirId;\n use rustc::hir::{self, Pat};\n \n-use smallvec::smallvec;\n use std::slice;\n \n use syntax_pos::{MultiSpan, Span, DUMMY_SP};\n@@ -251,7 +250,7 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n                 .iter()\n                 .filter(|&&(_, guard)| guard.is_none())\n                 .flat_map(|arm| &arm.0)\n-                .map(|pat| smallvec![pat.0])\n+                .map(|pat| PatStack::from_pattern(pat.0))\n                 .collect();\n             let scrut_ty = self.tables.node_type(scrut.hir_id);\n             check_exhaustive(cx, scrut_ty, scrut.span, &matrix, scrut.hir_id);\n@@ -267,7 +266,7 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n             let pattern = patcx.lower_pattern(pat);\n             let pattern_ty = pattern.ty;\n             let pattern = expand_pattern(cx, pattern);\n-            let pats: Matrix<'_, '_> = vec![smallvec![&pattern]].into_iter().collect();\n+            let pats: Matrix<'_, '_> = vec![PatStack::from_pattern(&pattern)].into_iter().collect();\n \n             let witnesses = match check_not_useful(cx, pattern_ty, &pats, pat.hir_id) {\n                 Ok(_) => return,\n@@ -411,7 +410,7 @@ fn check_arms<'tcx>(\n     let mut catchall = None;\n     for (arm_index, &(ref pats, guard)) in arms.iter().enumerate() {\n         for &(pat, hir_pat) in pats {\n-            let v = smallvec![pat];\n+            let v = PatStack::from_pattern(pat);\n \n             match is_useful(cx, &seen, &v, LeaveOutWitness, hir_pat.hir_id) {\n                 NotUseful => {\n@@ -493,7 +492,7 @@ fn check_not_useful(\n     hir_id: HirId,\n ) -> Result<(), Vec<super::Pat<'tcx>>> {\n     let wild_pattern = super::Pat { ty, span: DUMMY_SP, kind: box PatKind::Wild };\n-    match is_useful(cx, matrix, &[&wild_pattern], ConstructWitness, hir_id) {\n+    match is_useful(cx, matrix, &PatStack::from_pattern(&wild_pattern), ConstructWitness, hir_id) {\n         NotUseful => Ok(()), // This is good, wildcard pattern isn't reachable.\n         UsefulWithWitness(pats) => Err(if pats.is_empty() {\n             vec![wild_pattern]"}]}