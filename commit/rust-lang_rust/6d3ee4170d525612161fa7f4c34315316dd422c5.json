{"sha": "6d3ee4170d525612161fa7f4c34315316dd422c5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZkM2VlNDE3MGQ1MjU2MTIxNjFmYTdmNGMzNDMxNTMxNmRkNDIyYzU=", "commit": {"author": {"name": "Alexander Regueiro", "email": "alexreg@me.com", "date": "2018-11-05T02:02:43Z"}, "committer": {"name": "Alexander Regueiro", "email": "alexreg@me.com", "date": "2018-11-07T21:57:45Z"}, "message": "Added error for duplicate bindings of associated type.", "tree": {"sha": "3289b8f1d539ce6eb8ffae6e6c960361fd6a721e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3289b8f1d539ce6eb8ffae6e6c960361fd6a721e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6d3ee4170d525612161fa7f4c34315316dd422c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6d3ee4170d525612161fa7f4c34315316dd422c5", "html_url": "https://github.com/rust-lang/rust/commit/6d3ee4170d525612161fa7f4c34315316dd422c5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6d3ee4170d525612161fa7f4c34315316dd422c5/comments", "author": {"login": "alexreg", "id": 67036, "node_id": "MDQ6VXNlcjY3MDM2", "avatar_url": "https://avatars.githubusercontent.com/u/67036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexreg", "html_url": "https://github.com/alexreg", "followers_url": "https://api.github.com/users/alexreg/followers", "following_url": "https://api.github.com/users/alexreg/following{/other_user}", "gists_url": "https://api.github.com/users/alexreg/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexreg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexreg/subscriptions", "organizations_url": "https://api.github.com/users/alexreg/orgs", "repos_url": "https://api.github.com/users/alexreg/repos", "events_url": "https://api.github.com/users/alexreg/events{/privacy}", "received_events_url": "https://api.github.com/users/alexreg/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexreg", "id": 67036, "node_id": "MDQ6VXNlcjY3MDM2", "avatar_url": "https://avatars.githubusercontent.com/u/67036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexreg", "html_url": "https://github.com/alexreg", "followers_url": "https://api.github.com/users/alexreg/followers", "following_url": "https://api.github.com/users/alexreg/following{/other_user}", "gists_url": "https://api.github.com/users/alexreg/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexreg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexreg/subscriptions", "organizations_url": "https://api.github.com/users/alexreg/orgs", "repos_url": "https://api.github.com/users/alexreg/repos", "events_url": "https://api.github.com/users/alexreg/events{/privacy}", "received_events_url": "https://api.github.com/users/alexreg/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0e89f570d224ee08b6e32aa9ea8ea44a4e9244f3", "url": "https://api.github.com/repos/rust-lang/rust/commits/0e89f570d224ee08b6e32aa9ea8ea44a4e9244f3", "html_url": "https://github.com/rust-lang/rust/commit/0e89f570d224ee08b6e32aa9ea8ea44a4e9244f3"}], "stats": {"total": 301, "additions": 184, "deletions": 117}, "files": [{"sha": "33b689c60a1188dad35d27597bbe23a67b77ce53", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6d3ee4170d525612161fa7f4c34315316dd422c5/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d3ee4170d525612161fa7f4c34315316dd422c5/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=6d3ee4170d525612161fa7f4c34315316dd422c5", "patch": "@@ -50,11 +50,8 @@ pub use self::select::{EvaluationResult, IntercrateAmbiguityCause, OverflowError\n pub use self::specialize::{OverlapError, specialization_graph, translate_substs};\n pub use self::specialize::find_associated_item;\n pub use self::engine::{TraitEngine, TraitEngineExt};\n-pub use self::util::elaborate_predicates;\n-pub use self::util::supertraits;\n-pub use self::util::Supertraits;\n-pub use self::util::supertrait_def_ids;\n-pub use self::util::SupertraitDefIds;\n+pub use self::util::{elaborate_predicates, elaborate_trait_ref, elaborate_trait_refs};\n+pub use self::util::{supertraits, supertrait_def_ids, Supertraits, SupertraitDefIds};\n pub use self::util::transitive_bounds;\n \n #[allow(dead_code)]"}, {"sha": "19fe8606a4d071ec4305a06705f7152fe2c3357d", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/6d3ee4170d525612161fa7f4c34315316dd422c5/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d3ee4170d525612161fa7f4c34315316dd422c5/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=6d3ee4170d525612161fa7f4c34315316dd422c5", "patch": "@@ -544,14 +544,14 @@ impl<'tcx> TyS<'tcx> {\n     pub fn is_primitive_ty(&self) -> bool {\n         match self.sty {\n             TyKind::Bool |\n-                TyKind::Char |\n-                TyKind::Int(_) |\n-                TyKind::Uint(_) |\n-                TyKind::Float(_) |\n-                TyKind::Infer(InferTy::IntVar(_)) |\n-                TyKind::Infer(InferTy::FloatVar(_)) |\n-                TyKind::Infer(InferTy::FreshIntTy(_)) |\n-                TyKind::Infer(InferTy::FreshFloatTy(_)) => true,\n+            TyKind::Char |\n+            TyKind::Int(_) |\n+            TyKind::Uint(_) |\n+            TyKind::Float(_) |\n+            TyKind::Infer(InferTy::IntVar(_)) |\n+            TyKind::Infer(InferTy::FloatVar(_)) |\n+            TyKind::Infer(InferTy::FreshIntTy(_)) |\n+            TyKind::Infer(InferTy::FreshFloatTy(_)) => true,\n             TyKind::Ref(_, x, _) => x.is_primitive_ty(),\n             _ => false,\n         }\n@@ -1042,15 +1042,15 @@ impl<'a, 'gcx, 'tcx> GenericPredicates<'tcx> {\n \n #[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub enum Predicate<'tcx> {\n-    /// Corresponds to `where Foo : Bar<A,B,C>`. `Foo` here would be\n+    /// Corresponds to `where Foo: Bar<A,B,C>`. `Foo` here would be\n     /// the `Self` type of the trait reference and `A`, `B`, and `C`\n     /// would be the type parameters.\n     Trait(PolyTraitPredicate<'tcx>),\n \n-    /// where `'a : 'b`\n+    /// where `'a: 'b`\n     RegionOutlives(PolyRegionOutlivesPredicate<'tcx>),\n \n-    /// where `T : 'a`\n+    /// where `T: 'a`\n     TypeOutlives(PolyTypeOutlivesPredicate<'tcx>),\n \n     /// where `<T as TraitRef>::Name == X`, approximately.\n@@ -1063,7 +1063,7 @@ pub enum Predicate<'tcx> {\n     /// trait must be object-safe\n     ObjectSafe(DefId),\n \n-    /// No direct syntax. May be thought of as `where T : FnFoo<...>`\n+    /// No direct syntax. May be thought of as `where T: FnFoo<...>`\n     /// for some substitutions `...` and `T` being a closure type.\n     /// Satisfied (or refuted) once we know the closure's kind.\n     ClosureKind(DefId, ClosureSubsts<'tcx>, ClosureKind),\n@@ -1112,11 +1112,11 @@ impl<'a, 'gcx, 'tcx> Predicate<'tcx> {\n         //\n         // Let's start with an easy case. Consider two traits:\n         //\n-        //     trait Foo<'a> : Bar<'a,'a> { }\n+        //     trait Foo<'a>: Bar<'a,'a> { }\n         //     trait Bar<'b,'c> { }\n         //\n-        // Now, if we have a trait reference `for<'x> T : Foo<'x>`, then\n-        // we can deduce that `for<'x> T : Bar<'x,'x>`. Basically, if we\n+        // Now, if we have a trait reference `for<'x> T: Foo<'x>`, then\n+        // we can deduce that `for<'x> T: Bar<'x,'x>`. Basically, if we\n         // knew that `Foo<'x>` (for any 'x) then we also know that\n         // `Bar<'x,'x>` (for any 'x). This more-or-less falls out from\n         // normal substitution.\n@@ -1129,21 +1129,21 @@ impl<'a, 'gcx, 'tcx> Predicate<'tcx> {\n         //\n         // Another example to be careful of is this:\n         //\n-        //     trait Foo1<'a> : for<'b> Bar1<'a,'b> { }\n+        //     trait Foo1<'a>: for<'b> Bar1<'a,'b> { }\n         //     trait Bar1<'b,'c> { }\n         //\n-        // Here, if we have `for<'x> T : Foo1<'x>`, then what do we know?\n-        // The answer is that we know `for<'x,'b> T : Bar1<'x,'b>`. The\n+        // Here, if we have `for<'x> T: Foo1<'x>`, then what do we know?\n+        // The answer is that we know `for<'x,'b> T: Bar1<'x,'b>`. The\n         // reason is similar to the previous example: any impl of\n-        // `T:Foo1<'x>` must show that `for<'b> T : Bar1<'x, 'b>`.  So\n+        // `T:Foo1<'x>` must show that `for<'b> T: Bar1<'x, 'b>`.  So\n         // basically we would want to collapse the bound lifetimes from\n         // the input (`trait_ref`) and the supertraits.\n         //\n         // To achieve this in practice is fairly straightforward. Let's\n         // consider the more complicated scenario:\n         //\n-        // - We start out with `for<'x> T : Foo1<'x>`. In this case, `'x`\n-        //   has a De Bruijn index of 1. We want to produce `for<'x,'b> T : Bar1<'x,'b>`,\n+        // - We start out with `for<'x> T: Foo1<'x>`. In this case, `'x`\n+        //   has a De Bruijn index of 1. We want to produce `for<'x,'b> T: Bar1<'x,'b>`,\n         //   where both `'x` and `'b` would have a DB index of 1.\n         //   The substitution from the input trait-ref is therefore going to be\n         //   `'a => 'x` (where `'x` has a DB index of 1).\n@@ -1219,7 +1219,7 @@ impl<'tcx> PolyTraitPredicate<'tcx> {\n }\n \n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, RustcEncodable, RustcDecodable)]\n-pub struct OutlivesPredicate<A,B>(pub A, pub B); // `A : B`\n+pub struct OutlivesPredicate<A,B>(pub A, pub B); // `A: B`\n pub type PolyOutlivesPredicate<A,B> = ty::Binder<OutlivesPredicate<A,B>>;\n pub type RegionOutlivesPredicate<'tcx> = OutlivesPredicate<ty::Region<'tcx>,\n                                                            ty::Region<'tcx>>;\n@@ -2476,7 +2476,7 @@ impl<'tcx> TyS<'tcx> {\n     ///\n     /// Note: prefer `ty.walk()` where possible.\n     pub fn maybe_walk<F>(&'tcx self, mut f: F)\n-        where F : FnMut(Ty<'tcx>) -> bool\n+        where F: FnMut(Ty<'tcx>) -> bool\n     {\n         let mut walker = self.walk();\n         while let Some(ty) = walker.next() {"}, {"sha": "5c8549cba2333e3a37a5a7ee43a69709d16af263", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6d3ee4170d525612161fa7f4c34315316dd422c5/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d3ee4170d525612161fa7f4c34315316dd422c5/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=6d3ee4170d525612161fa7f4c34315316dd422c5", "patch": "@@ -627,7 +627,7 @@ impl<'tcx> Binder<&'tcx List<ExistentialPredicate<'tcx>>> {\n /// A complete reference to a trait. These take numerous guises in syntax,\n /// but perhaps the most recognizable form is in a where clause:\n ///\n-///     T : Foo<U>\n+///     T: Foo<U>\n ///\n /// This would be represented by a trait-reference where the def-id is the\n /// def-id for the trait `Foo` and the substs define `T` as parameter 0,\n@@ -637,8 +637,8 @@ impl<'tcx> Binder<&'tcx List<ExistentialPredicate<'tcx>>> {\n /// that case the `Self` parameter is absent from the substitutions.\n ///\n /// Note that a `TraitRef` introduces a level of region binding, to\n-/// account for higher-ranked trait bounds like `T : for<'a> Foo<&'a\n-/// U>` or higher-ranked object types.\n+/// account for higher-ranked trait bounds like `T: for<'a> Foo<&'a U>`\n+/// or higher-ranked object types.\n #[derive(Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub struct TraitRef<'tcx> {\n     pub def_id: DefId,\n@@ -663,7 +663,7 @@ impl<'tcx> TraitRef<'tcx> {\n         self.substs.type_at(0)\n     }\n \n-    pub fn input_types<'a>(&'a self) -> impl DoubleEndedIterator<Item=Ty<'tcx>> + 'a {\n+    pub fn input_types<'a>(&'a self) -> impl DoubleEndedIterator<Item = Ty<'tcx>> + 'a {\n         // Select only the \"input types\" from a trait-reference. For\n         // now this is all the types that appear in the\n         // trait-reference, but it should eventually exclude\n@@ -886,16 +886,16 @@ pub struct ProjectionTy<'tcx> {\n     /// The parameters of the associated item.\n     pub substs: &'tcx Substs<'tcx>,\n \n-    /// The DefId of the TraitItem for the associated type N.\n+    /// The `DefId` of the `TraitItem` for the associated type `N`.\n     ///\n-    /// Note that this is not the DefId of the TraitRef containing this\n-    /// associated type, which is in tcx.associated_item(item_def_id).container.\n+    /// Note that this is not the `DefId` of the `TraitRef` containing this\n+    /// associated type, which is in `tcx.associated_item(item_def_id).container`.\n     pub item_def_id: DefId,\n }\n \n impl<'a, 'tcx> ProjectionTy<'tcx> {\n-    /// Construct a ProjectionTy by searching the trait from trait_ref for the\n-    /// associated item named item_name.\n+    /// Construct a `ProjectionTy` by searching the trait from `trait_ref` for the\n+    /// associated item named `item_name`.\n     pub fn from_ref_and_name(\n         tcx: TyCtxt<'_, '_, '_>, trait_ref: ty::TraitRef<'tcx>, item_name: Ident\n     ) -> ProjectionTy<'tcx> {"}, {"sha": "b28e7c9fb199be7daaacce299e889784c7375078", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6d3ee4170d525612161fa7f4c34315316dd422c5/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d3ee4170d525612161fa7f4c34315316dd422c5/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=6d3ee4170d525612161fa7f4c34315316dd422c5", "patch": "@@ -27,7 +27,7 @@ use std::marker::PhantomData;\n use std::mem;\n use std::num::NonZeroUsize;\n \n-/// An entity in the Rust typesystem, which can be one of\n+/// An entity in the Rust type system, which can be one of\n /// several kinds (only types and lifetimes for now).\n /// To reduce memory usage, a `Kind` is a interned pointer,\n /// with the lowest 2 bits being reserved for a tag to\n@@ -171,17 +171,17 @@ impl<'tcx> Decodable for Kind<'tcx> {\n pub type Substs<'tcx> = List<Kind<'tcx>>;\n \n impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n-    /// Creates a Substs that maps each generic parameter to itself.\n+    /// Creates a `Substs` that maps each generic parameter to itself.\n     pub fn identity_for_item(tcx: TyCtxt<'a, 'gcx, 'tcx>, def_id: DefId)\n                              -> &'tcx Substs<'tcx> {\n         Substs::for_item(tcx, def_id, |param, _| {\n             tcx.mk_param_from_def(param)\n         })\n     }\n \n-    /// Creates a Substs for generic parameter definitions,\n+    /// Creates a `Substs` for generic parameter definitions,\n     /// by calling closures to obtain each kind.\n-    /// The closures get to observe the Substs as they're\n+    /// The closures get to observe the `Substs` as they're\n     /// being built, which can be used to correctly\n     /// substitute defaults of generic parameters.\n     pub fn for_item<F>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n@@ -242,7 +242,7 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n     }\n \n     #[inline]\n-    pub fn types(&'a self) -> impl DoubleEndedIterator<Item=Ty<'tcx>> + 'a {\n+    pub fn types(&'a self) -> impl DoubleEndedIterator<Item = Ty<'tcx>> + 'a {\n         self.iter().filter_map(|k| {\n             if let UnpackedKind::Type(ty) = k.unpack() {\n                 Some(ty)\n@@ -253,7 +253,7 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n     }\n \n     #[inline]\n-    pub fn regions(&'a self) -> impl DoubleEndedIterator<Item=ty::Region<'tcx>> + 'a {\n+    pub fn regions(&'a self) -> impl DoubleEndedIterator<Item = ty::Region<'tcx>> + 'a {\n         self.iter().filter_map(|k| {\n             if let UnpackedKind::Lifetime(lt) = k.unpack() {\n                 Some(lt)\n@@ -332,7 +332,7 @@ impl<'tcx> serialize::UseSpecializedDecodable for &'tcx Substs<'tcx> {}\n // `foo`. Or use `foo.subst_spanned(tcx, substs, Some(span))` when\n // there is more information available (for better errors).\n \n-pub trait Subst<'tcx> : Sized {\n+pub trait Subst<'tcx>: Sized {\n     fn subst<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                        substs: &[Kind<'tcx>]) -> Self {\n         self.subst_spanned(tcx, substs, None)"}, {"sha": "f3f4251693864c8afae3ac30dafc46184b68dea9", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 67, "deletions": 63, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/6d3ee4170d525612161fa7f4c34315316dd422c5/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d3ee4170d525612161fa7f4c34315316dd422c5/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=6d3ee4170d525612161fa7f4c34315316dd422c5", "patch": "@@ -37,7 +37,7 @@ use std::iter;\n use syntax::ast;\n use syntax::ptr::P;\n use syntax::feature_gate::{GateIssue, emit_feature_err};\n-use syntax_pos::{Span, MultiSpan};\n+use syntax_pos::{DUMMY_SP, Span, MultiSpan};\n \n pub trait AstConv<'gcx, 'tcx> {\n     fn tcx<'a>(&'a self) -> TyCtxt<'a, 'gcx, 'tcx>;\n@@ -719,6 +719,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n         speculative: bool)\n         -> ty::PolyTraitRef<'tcx>\n     {\n+        let tcx = self.tcx();\n+\n         let trait_def_id = self.trait_def_id(trait_ref);\n \n         debug!(\"instantiate_poly_trait_ref({:?}, def_id={:?})\", trait_ref, trait_def_id);\n@@ -732,16 +734,74 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n                                                  trait_ref.path.segments.last().unwrap());\n         let poly_trait_ref = ty::Binder::bind(ty::TraitRef::new(trait_def_id, substs));\n \n-        let mut dup_bindings = FxHashMap::default();\n         poly_projections.extend(assoc_bindings.iter().filter_map(|binding| {\n             // specify type to assert that error was already reported in Err case:\n             let predicate: Result<_, ErrorReported> =\n                 self.ast_type_binding_to_poly_projection_predicate(\n-                    trait_ref.ref_id, poly_trait_ref, binding, speculative, &mut dup_bindings);\n+                    trait_ref.ref_id, poly_trait_ref, binding, speculative);\n             // okay to ignore Err because of ErrorReported (see above)\n             Some((predicate.ok()?, binding.span))\n         }));\n \n+        // make flat_map:\n+        // for tr in traits::supertraits(tcx, poly_trait_ref) {\n+        //     let sup_trait_ref = tr.skip_binder();\n+        //     poly_projections.extend(sup_trait_ref.substs.types().filter_map(|t| {\n+        //         if let TyKind::Projection(proj) = t.sty {\n+        //             Some((proj, span))\n+        //         } else {\n+        //             None\n+        //         }\n+        //     });\n+        // }\n+\n+        // Include all projections from associated type bindings of supertraits.\n+        poly_projections.extend(traits::elaborate_trait_ref(tcx, poly_trait_ref)\n+            .into_iter()\n+            .filter_map(|pred| {\n+                if let ty::Predicate::Projection(proj) = pred {\n+                    Some(proj)\n+                } else {\n+                    None\n+                }\n+            })\n+            .map(|proj| (proj, DUMMY_SP))\n+        );\n+\n+        // // Include associated type bindings from supertraits.\n+        // let mut foo = poly_projections.clone();\n+        // foo.extend(tcx.predicates_of(trait_def_id)\n+        //     .predicates.into_iter()\n+        //     .filter_map(|(pred, span)| {\n+        //         debug!(\"pred: {:?}\", pred);\n+        //         if let ty::Predicate::Projection(proj) = pred {\n+        //             Some((proj, span))\n+        //         } else {\n+        //             None\n+        //         }\n+        //     }));\n+\n+        // Check for multiple bindings of associated types.\n+        let mut seen_projection_bounds = FxHashMap::default();\n+        for (projection_bound, span) in poly_projections.iter().rev() {\n+            let bound_def_id = projection_bound.projection_def_id();\n+            let assoc_item = tcx.associated_item(bound_def_id);\n+            let trait_def_id = assoc_item.container.id();\n+            // let trait_ref = tcx.associated_item(proj.projection_type.item_def_id).container;\n+            seen_projection_bounds.entry((assoc_item.def_id, bound_def_id))\n+                .and_modify(|prev_span| {\n+                    struct_span_err!(tcx.sess, *span, E0719,\n+                                     \"the value of the associated type `{}` (from the trait `{}`) \\\n+                                      is already specified\",\n+                                     assoc_item.ident,\n+                                     tcx.item_path_str(trait_def_id))\n+                        .span_label(*span, \"re-bound here\")\n+                        .span_label(*prev_span, format!(\"`{}` bound here first\", assoc_item.ident))\n+                        .emit();\n+                })\n+                .or_insert(*span);\n+        }\n+\n         debug!(\"instantiate_poly_trait_ref({:?}, projections={:?}) -> {:?}\",\n                trait_ref, poly_projections, poly_trait_ref);\n         poly_trait_ref\n@@ -824,8 +884,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n         ref_id: ast::NodeId,\n         trait_ref: ty::PolyTraitRef<'tcx>,\n         binding: &ConvertedBinding<'tcx>,\n-        speculative: bool,\n-        dup_bindings: &mut FxHashMap<DefId, Span>)\n+        speculative: bool)\n         -> Result<ty::PolyProjectionPredicate<'tcx>, ErrorReported>\n     {\n         let tcx = self.tcx();\n@@ -879,19 +938,16 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n             }\n         }\n \n-        let supertraits = traits::supertraits(tcx, trait_ref);\n         let candidate = if self.trait_defines_associated_type_named(trait_ref.def_id(),\n                                                                     binding.item_name) {\n             // Simple case: X is defined in the current trait.\n             Ok(trait_ref)\n         } else {\n             // Otherwise, we have to walk through the supertraits to find\n             // those that do.\n-            let candidates = supertraits.filter(|r| {\n+            let candidates = traits::supertraits(tcx, trait_ref).filter(|r| {\n                 self.trait_defines_associated_type_named(r.def_id(), binding.item_name)\n             });\n-            let candidates = candidates.collect::<Vec<_>>();\n-            debug!(\"foo: candidates: {:?}\", candidates);\n             self.one_bound_for_assoc_type(candidates.into_iter(), &trait_ref.to_string(),\n                                           binding.item_name, binding.span)\n         }?;\n@@ -908,31 +964,6 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n         }\n         tcx.check_stability(assoc_ty.def_id, Some(ref_id), binding.span);\n \n-        debug!(\"foo: info: {:?} {:?} {:?} {:?} {:?}\", trait_ref, binding.item_name, speculative, assoc_ty.def_id, dup_bindings);\n-        if !speculative {\n-            dup_bindings.entry(assoc_ty.def_id)\n-                .and_modify(|prev_span| {\n-                    let mut err = self.tcx().struct_span_lint_node(\n-                        ::rustc::lint::builtin::DUPLICATE_ASSOCIATED_TYPE_BINDINGS,\n-                        ref_id,\n-                        binding.span,\n-                        &format!(\"associated type binding `{}` specified more than once\",\n-                                 binding.item_name)\n-                    );\n-                    err.span_label(binding.span, \"used more than once\");\n-                    err.span_label(*prev_span, format!(\"first use of `{}`\", binding.item_name));\n-                    err.emit();\n-                })\n-                .or_insert(binding.span);\n-        }\n-        static mut ABC: u32 = 0;\n-        unsafe {\n-            ABC += 1;\n-            if ABC == 3 {\n-                assert!(false);\n-            }\n-        };\n-\n         Ok(candidate.map_bound(|trait_ref| {\n             ty::ProjectionPredicate {\n                 projection_ty: ty::ProjectionTy::from_ref_and_name(\n@@ -1016,37 +1047,10 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n             associated_types.extend(tcx.associated_items(tr.def_id())\n                 .filter(|item| item.kind == ty::AssociatedKind::Type)\n                 .map(|item| item.def_id));\n-\n-            projection_bounds.extend(tcx.predicates_of(tr.def_id())\n-                .predicates.into_iter()\n-                .filter_map(|(pred, span)| {\n-                    if let ty::Predicate::Projection(proj) = pred {\n-                        Some((proj, span))\n-                    } else {\n-                        None\n-                    }\n-                }));\n         }\n \n-        let mut seen_projection_bounds = FxHashMap::default();\n-        for (projection_bound, span) in projection_bounds.iter().rev() {\n-            let bound_def_id = projection_bound.projection_def_id();\n-            seen_projection_bounds.entry(bound_def_id)\n-                .and_modify(|prev_span| {\n-                    let assoc_item = tcx.associated_item(bound_def_id);\n-                    let trait_def_id = assoc_item.container.id();\n-                    struct_span_err!(tcx.sess, *span, E0719,\n-                                     \"the value of the associated type `{}` (from the trait `{}`) \\\n-                                      is already specified\",\n-                                     assoc_item.ident,\n-                                     tcx.item_path_str(trait_def_id))\n-                        .span_label(*span, \"re-bound here\")\n-                        .span_label(*prev_span, format!(\"binding for `{}`\", assoc_item.ident))\n-                        .emit();\n-                })\n-                .or_insert(*span);\n-\n-            associated_types.remove(&bound_def_id);\n+        for (projection_bound, _) in projection_bounds.iter().rev() {\n+            associated_types.remove(&projection_bound.projection_def_id());\n         }\n \n         for item_def_id in associated_types {"}, {"sha": "adac28eeb1292d40797fc1f322aba3b1fdb7e030", "filename": "src/test/run-pass/traits/trait-alias-object.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d3ee4170d525612161fa7f4c34315316dd422c5/src%2Ftest%2Frun-pass%2Ftraits%2Ftrait-alias-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d3ee4170d525612161fa7f4c34315316dd422c5/src%2Ftest%2Frun-pass%2Ftraits%2Ftrait-alias-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftraits%2Ftrait-alias-object.rs?ref=6d3ee4170d525612161fa7f4c34315316dd422c5", "patch": "@@ -21,6 +21,6 @@ pub fn main() {\n     let b = Box::new(456) as Box<dyn Foo>;\n     assert!(*b == 456);\n \n-    let c: &mut dyn I32Iterator<Item = u32> = &mut vec![123].into_iter();\n+    let c: &mut dyn I32Iterator = &mut vec![123].into_iter();\n     assert_eq!(c.next(), Some(123));\n }", "previous_filename": "src/test/run-pass/traits/trait-alias-objects.rs"}, {"sha": "1e842e5b508e970e6fec60688ef283934a1ec897", "filename": "src/test/ui/error-codes/E0719-trait-alias-object.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6d3ee4170d525612161fa7f4c34315316dd422c5/src%2Ftest%2Fui%2Ferror-codes%2FE0719-trait-alias-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d3ee4170d525612161fa7f4c34315316dd422c5/src%2Ftest%2Fui%2Ferror-codes%2FE0719-trait-alias-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0719-trait-alias-object.rs?ref=6d3ee4170d525612161fa7f4c34315316dd422c5", "patch": "@@ -11,7 +11,7 @@\n #![feature(trait_alias)]\n \n trait I32Iterator = Iterator<Item = i32>;\n-trait I32Iterator2 = I32Iterator<Item = i32>;\n-trait U32Iterator = I32Iterator2<Item = i32>;\n \n-pub fn main() {}\n+fn main() {\n+    let _: &I32Iterator<Item = u32>; //~ ERROR E0719\n+}", "previous_filename": "src/test/ui/traits/trait-alias-associated-type-rebound.rs"}, {"sha": "17ebf5901c438c778c22f95c4d8e9ff336af1809", "filename": "src/test/ui/error-codes/E0719-trait-alias-object.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6d3ee4170d525612161fa7f4c34315316dd422c5/src%2Ftest%2Fui%2Ferror-codes%2FE0719-trait-alias-object.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6d3ee4170d525612161fa7f4c34315316dd422c5/src%2Ftest%2Fui%2Ferror-codes%2FE0719-trait-alias-object.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0719-trait-alias-object.stderr?ref=6d3ee4170d525612161fa7f4c34315316dd422c5", "patch": "@@ -0,0 +1,12 @@\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/E0719-trait-alias-object.rs:16:25\n+   |\n+LL | trait I32Iterator = Iterator<Item = i32>;\n+   |                              ---------- `Item` bound here first\n+...\n+LL |     let _: &I32Iterator<Item = u32>; //~ ERROR E0719\n+   |                         ^^^^^^^^^^ re-bound here\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0719`."}, {"sha": "4232cafa58b07198a2976165ec9b7b50992e3822", "filename": "src/test/ui/error-codes/E0719-trait-alias.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6d3ee4170d525612161fa7f4c34315316dd422c5/src%2Ftest%2Fui%2Ferror-codes%2FE0719-trait-alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d3ee4170d525612161fa7f4c34315316dd422c5/src%2Ftest%2Fui%2Ferror-codes%2FE0719-trait-alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0719-trait-alias.rs?ref=6d3ee4170d525612161fa7f4c34315316dd422c5", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(trait_alias)]\n+\n+trait I32Iterator = Iterator<Item = i32>;\n+trait I32Iterator2 = I32Iterator<Item = i32>; //~ ERROR E0719\n+trait U32Iterator = I32Iterator2<Item = i32>; //~ ERROR E0719\n+trait U32Iterator2 = U32Iterator<Item = u32>; //~ ERROR E0719\n+\n+fn main() {}"}, {"sha": "6bb1a541f4d44b4f505c4f6ed3222c4f6da8480a", "filename": "src/test/ui/error-codes/E0719-trait-alias.stderr", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/6d3ee4170d525612161fa7f4c34315316dd422c5/src%2Ftest%2Fui%2Ferror-codes%2FE0719-trait-alias.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6d3ee4170d525612161fa7f4c34315316dd422c5/src%2Ftest%2Fui%2Ferror-codes%2FE0719-trait-alias.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0719-trait-alias.stderr?ref=6d3ee4170d525612161fa7f4c34315316dd422c5", "patch": "@@ -0,0 +1,29 @@\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/E0719-trait-alias.rs:14:34\n+   |\n+LL | trait I32Iterator = Iterator<Item = i32>;\n+   |                              ---------- `Item` bound here first\n+LL | trait I32Iterator2 = I32Iterator<Item = i32>; //~ ERROR E0719\n+   |                                  ^^^^^^^^^^ re-bound here\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/E0719-trait-alias.rs:15:34\n+   |\n+LL | trait I32Iterator = Iterator<Item = i32>;\n+   |                              ---------- `Item` bound here first\n+LL | trait I32Iterator2 = I32Iterator<Item = i32>; //~ ERROR E0719\n+LL | trait U32Iterator = I32Iterator2<Item = i32>; //~ ERROR E0719\n+   |                                  ^^^^^^^^^^ re-bound here\n+\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/E0719-trait-alias.rs:16:34\n+   |\n+LL | trait I32Iterator = Iterator<Item = i32>;\n+   |                              ---------- `Item` bound here first\n+...\n+LL | trait U32Iterator2 = U32Iterator<Item = u32>; //~ ERROR E0719\n+   |                                  ^^^^^^^^^^ re-bound here\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0719`."}, {"sha": "2177d29110abba7212a7d1ff80f24a6f89eb552a", "filename": "src/test/ui/error-codes/E0719.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6d3ee4170d525612161fa7f4c34315316dd422c5/src%2Ftest%2Fui%2Ferror-codes%2FE0719.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d3ee4170d525612161fa7f4c34315316dd422c5/src%2Ftest%2Fui%2Ferror-codes%2FE0719.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0719.rs?ref=6d3ee4170d525612161fa7f4c34315316dd422c5", "patch": "@@ -8,10 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(trait_alias)]\n-\n-trait I32Iterator = Iterator<Item = i32>;\n-\n-pub fn main() {\n-    let _: &I32Iterator<Item = f32>; //~ ERROR E0719\n+fn main() {\n+    let _: &Iterator<Item = i32, Item = i32>; //~ ERROR E0719\n }"}, {"sha": "78a71b6faabd32a48ba09b747a5f4a3046557f77", "filename": "src/test/ui/error-codes/E0719.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6d3ee4170d525612161fa7f4c34315316dd422c5/src%2Ftest%2Fui%2Ferror-codes%2FE0719.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6d3ee4170d525612161fa7f4c34315316dd422c5/src%2Ftest%2Fui%2Ferror-codes%2FE0719.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0719.stderr?ref=6d3ee4170d525612161fa7f4c34315316dd422c5", "patch": "@@ -0,0 +1,11 @@\n+error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+  --> $DIR/E0719.rs:12:22\n+   |\n+LL |     let _: &Iterator<Item = i32, Item = i32>; //~ ERROR E0719\n+   |                      ^^^^^^^^^^  ---------- `Item` bound here first\n+   |                      |\n+   |                      re-bound here\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0719`."}, {"sha": "3adcd8436d8a1c2c9075aaf5b7bbfe67552660da", "filename": "src/test/ui/traits/trait-alias-object.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/6d3ee4170d525612161fa7f4c34315316dd422c5/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d3ee4170d525612161fa7f4c34315316dd422c5/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias-object.rs?ref=6d3ee4170d525612161fa7f4c34315316dd422c5", "previous_filename": "src/test/ui/traits/trait-alias-objects.rs"}, {"sha": "8f9681e898fe8a11e6e7cad3daac44f023a4c5b1", "filename": "src/test/ui/traits/trait-alias-object.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/6d3ee4170d525612161fa7f4c34315316dd422c5/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias-object.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6d3ee4170d525612161fa7f4c34315316dd422c5/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias-object.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias-object.stderr?ref=6d3ee4170d525612161fa7f4c34315316dd422c5", "previous_filename": "src/test/ui/traits/trait-alias-objects.stderr"}]}