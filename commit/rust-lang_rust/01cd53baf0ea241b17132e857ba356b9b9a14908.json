{"sha": "01cd53baf0ea241b17132e857ba356b9b9a14908", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAxY2Q1M2JhZjBlYTI0MWIxNzEzMmU4NTdiYTM1NmI5YjlhMTQ5MDg=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-12-05T02:49:50Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-12-05T02:49:50Z"}, "message": "Merge remote-tracking branch 'luqmana/incoming'\n\nConflicts:\n\tsrc/librustc/middle/typeck/check.rs", "tree": {"sha": "77b6bbb9478557bd27a3fce89740c51ca6f8e5f7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/77b6bbb9478557bd27a3fce89740c51ca6f8e5f7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/01cd53baf0ea241b17132e857ba356b9b9a14908", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/01cd53baf0ea241b17132e857ba356b9b9a14908", "html_url": "https://github.com/rust-lang/rust/commit/01cd53baf0ea241b17132e857ba356b9b9a14908", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/01cd53baf0ea241b17132e857ba356b9b9a14908/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c0d3b291d55122d319ddc28010675afdaab73dfc", "url": "https://api.github.com/repos/rust-lang/rust/commits/c0d3b291d55122d319ddc28010675afdaab73dfc", "html_url": "https://github.com/rust-lang/rust/commit/c0d3b291d55122d319ddc28010675afdaab73dfc"}, {"sha": "c6b17392323c4eee930451e612e5ba8c81b1f925", "url": "https://api.github.com/repos/rust-lang/rust/commits/c6b17392323c4eee930451e612e5ba8c81b1f925", "html_url": "https://github.com/rust-lang/rust/commit/c6b17392323c4eee930451e612e5ba8c81b1f925"}], "stats": {"total": 477, "additions": 476, "deletions": 1}, "files": [{"sha": "4b3f944d2827933bafb336b699860093bc36c471", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/01cd53baf0ea241b17132e857ba356b9b9a14908/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01cd53baf0ea241b17132e857ba356b9b9a14908/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=01cd53baf0ea241b17132e857ba356b9b9a14908", "patch": "@@ -2380,6 +2380,67 @@ fn declare_intrinsics(llmod: ModuleRef) -> HashMap<~str, ValueRef> {\n     let frameaddress = decl_cdecl_fn(llmod, ~\"llvm.frameaddress\",\n                                      T_fn(T_frameaddress_args,\n                                           T_ptr(T_i8())));\n+    let sqrtf32 = decl_cdecl_fn(llmod, ~\"llvm.sqrt.f32\",\n+                                T_fn(~[T_f32()], T_f32()));\n+    let sqrtf64 = decl_cdecl_fn(llmod, ~\"llvm.sqrt.f64\",\n+                                T_fn(~[T_f64()], T_f64()));\n+    let powif32 = decl_cdecl_fn(llmod, ~\"llvm.powi.f32\",\n+                                T_fn(~[T_f32(), T_i32()], T_f32()));\n+    let powif64 = decl_cdecl_fn(llmod, ~\"llvm.powi.f64\",\n+                                T_fn(~[T_f64(), T_i32()], T_f64()));\n+    let sinf32 = decl_cdecl_fn(llmod, ~\"llvm.sin.f32\",\n+                                T_fn(~[T_f32()], T_f32()));\n+    let sinf64 = decl_cdecl_fn(llmod, ~\"llvm.sin.f64\",\n+                                T_fn(~[T_f64()], T_f64()));\n+    let cosf32 = decl_cdecl_fn(llmod, ~\"llvm.cos.f32\",\n+                                T_fn(~[T_f32()], T_f32()));\n+    let cosf64 = decl_cdecl_fn(llmod, ~\"llvm.cos.f64\",\n+                                T_fn(~[T_f64()], T_f64()));\n+    let powf32 = decl_cdecl_fn(llmod, ~\"llvm.pow.f32\",\n+                                T_fn(~[T_f32(), T_f32()], T_f32()));\n+    let powf64 = decl_cdecl_fn(llmod, ~\"llvm.pow.f64\",\n+                                T_fn(~[T_f64(), T_f64()], T_f64()));\n+    let expf32 = decl_cdecl_fn(llmod, ~\"llvm.exp.f32\",\n+                                T_fn(~[T_f32()], T_f32()));\n+    let expf64 = decl_cdecl_fn(llmod, ~\"llvm.exp.f64\",\n+                                T_fn(~[T_f64()], T_f64()));\n+    let exp2f32 = decl_cdecl_fn(llmod, ~\"llvm.exp2.f32\",\n+                                T_fn(~[T_f32()], T_f32()));\n+    let exp2f64 = decl_cdecl_fn(llmod, ~\"llvm.exp2.f64\",\n+                                T_fn(~[T_f64()], T_f64()));\n+    let logf32 = decl_cdecl_fn(llmod, ~\"llvm.log.f32\",\n+                                T_fn(~[T_f32()], T_f32()));\n+    let logf64 = decl_cdecl_fn(llmod, ~\"llvm.log.f64\",\n+                                T_fn(~[T_f64()], T_f64()));\n+    let log10f32 = decl_cdecl_fn(llmod, ~\"llvm.log10.f32\",\n+                                T_fn(~[T_f32()], T_f32()));\n+    let log10f64 = decl_cdecl_fn(llmod, ~\"llvm.log10.f64\",\n+                                T_fn(~[T_f64()], T_f64()));\n+    let log2f32 = decl_cdecl_fn(llmod, ~\"llvm.log2.f32\",\n+                                T_fn(~[T_f32()], T_f32()));\n+    let log2f64 = decl_cdecl_fn(llmod, ~\"llvm.log2.f64\",\n+                                T_fn(~[T_f64()], T_f64()));\n+    let fmaf32 = decl_cdecl_fn(llmod, ~\"llvm.fma.f32\",\n+                                T_fn(~[T_f32(), T_f32(), T_f32()], T_f32()));\n+    let fmaf64 = decl_cdecl_fn(llmod, ~\"llvm.fma.f64\",\n+                                T_fn(~[T_f64(), T_f64(), T_f64()], T_f64()));\n+    let fabsf32 = decl_cdecl_fn(llmod, ~\"llvm.fabs.f32\",\n+                                T_fn(~[T_f32()], T_f32()));\n+    let fabsf64 = decl_cdecl_fn(llmod, ~\"llvm.fabs.f64\",\n+                                T_fn(~[T_f64()], T_f64()));\n+    let floorf32 = decl_cdecl_fn(llmod, ~\"llvm.floor.f32\",\n+                                T_fn(~[T_f32()], T_f32()));\n+    let floorf64 = decl_cdecl_fn(llmod, ~\"llvm.floor.f64\",\n+                                T_fn(~[T_f64()], T_f64()));\n+    let ceilf32 = decl_cdecl_fn(llmod, ~\"llvm.ceil.f32\",\n+                                T_fn(~[T_f32()], T_f32()));\n+    let ceilf64 = decl_cdecl_fn(llmod, ~\"llvm.ceil.f64\",\n+                                T_fn(~[T_f64()], T_f64()));\n+    let truncf32 = decl_cdecl_fn(llmod, ~\"llvm.trunc.f32\",\n+                                T_fn(~[T_f32()], T_f32()));\n+    let truncf64 = decl_cdecl_fn(llmod, ~\"llvm.trunc.f64\",\n+                                T_fn(~[T_f64()], T_f64()));\n+\n     let intrinsics = HashMap();\n     intrinsics.insert(~\"llvm.gcroot\", gcroot);\n     intrinsics.insert(~\"llvm.gcread\", gcread);\n@@ -2389,6 +2450,37 @@ fn declare_intrinsics(llmod: ModuleRef) -> HashMap<~str, ValueRef> {\n     intrinsics.insert(~\"llvm.memset.p0i8.i64\", memset64);\n     intrinsics.insert(~\"llvm.trap\", trap);\n     intrinsics.insert(~\"llvm.frameaddress\", frameaddress);\n+    intrinsics.insert(~\"llvm.sqrt.f32\", sqrtf32);\n+    intrinsics.insert(~\"llvm.sqrt.f64\", sqrtf64);\n+    intrinsics.insert(~\"llvm.powi.f32\", powif32);\n+    intrinsics.insert(~\"llvm.powi.f64\", powif64);\n+    intrinsics.insert(~\"llvm.sin.f32\", sinf32);\n+    intrinsics.insert(~\"llvm.sin.f64\", sinf64);\n+    intrinsics.insert(~\"llvm.cos.f32\", cosf32);\n+    intrinsics.insert(~\"llvm.cos.f64\", cosf64);\n+    intrinsics.insert(~\"llvm.pow.f32\", powf32);\n+    intrinsics.insert(~\"llvm.pow.f64\", powf64);\n+    intrinsics.insert(~\"llvm.exp.f32\", expf32);\n+    intrinsics.insert(~\"llvm.exp.f64\", expf64);\n+    intrinsics.insert(~\"llvm.exp2.f32\", exp2f32);\n+    intrinsics.insert(~\"llvm.exp2.f64\", exp2f64);\n+    intrinsics.insert(~\"llvm.log.f32\", logf32);\n+    intrinsics.insert(~\"llvm.log.f64\", logf64);\n+    intrinsics.insert(~\"llvm.log10.f32\", log10f32);\n+    intrinsics.insert(~\"llvm.log10.f64\", log10f64);\n+    intrinsics.insert(~\"llvm.log2.f32\", log2f32);\n+    intrinsics.insert(~\"llvm.log2.f64\", log2f64);\n+    intrinsics.insert(~\"llvm.fma.f32\", fmaf32);\n+    intrinsics.insert(~\"llvm.fma.f64\", fmaf64);\n+    intrinsics.insert(~\"llvm.fabs.f32\", fabsf32);\n+    intrinsics.insert(~\"llvm.fabs.f64\", fabsf64);\n+    intrinsics.insert(~\"llvm.floor.f32\", floorf32);\n+    intrinsics.insert(~\"llvm.floor.f64\", floorf64);\n+    intrinsics.insert(~\"llvm.ceil.f32\", ceilf32);\n+    intrinsics.insert(~\"llvm.ceil.f64\", ceilf64);\n+    intrinsics.insert(~\"llvm.trunc.f32\", truncf32);\n+    intrinsics.insert(~\"llvm.trunc.f64\", truncf64);\n+\n     return intrinsics;\n }\n "}, {"sha": "da581711ae6c6e3b5c655303a2313cc5e8c5f515", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 159, "deletions": 1, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/01cd53baf0ea241b17132e857ba356b9b9a14908/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01cd53baf0ea241b17132e857ba356b9b9a14908/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=01cd53baf0ea241b17132e857ba356b9b9a14908", "patch": "@@ -982,7 +982,7 @@ fn trans_intrinsic(ccx: @crate_ctxt, decl: ValueRef, item: @ast::foreign_item,\n               let llcast = PointerCast(bcx, llcast, T_ptr(T_i8()));\n               call_memcpy(bcx, llretptr, llcast, llsize_of(ccx, lltp_ty));\n           }\n-      }\n+        }\n         ~\"addr_of\" => {\n             Store(bcx, get_param(decl, first_real_arg), fcx.llretptr);\n         }\n@@ -1033,6 +1033,164 @@ fn trans_intrinsic(ccx: @crate_ctxt, decl: ValueRef, item: @ast::foreign_item,\n                                              T_ptr(T_nil()));\n             Store(bcx, morestack_addr, fcx.llretptr);\n         }\n+        ~\"sqrtf32\" => {\n+            let x = get_param(decl, first_real_arg);\n+            let sqrtf = ccx.intrinsics.get(~\"llvm.sqrt.f32\");\n+            Store(bcx, Call(bcx, sqrtf, ~[x]), fcx.llretptr);\n+        }\n+        ~\"sqrtf64\" => {\n+            let x = get_param(decl, first_real_arg);\n+            let sqrtf = ccx.intrinsics.get(~\"llvm.sqrt.f64\");\n+            Store(bcx, Call(bcx, sqrtf, ~[x]), fcx.llretptr);\n+        }\n+        ~\"powif32\" => {\n+            let a = get_param(decl, first_real_arg);\n+            let x = get_param(decl, first_real_arg + 1u);\n+            let powif = ccx.intrinsics.get(~\"llvm.powi.f32\");\n+            Store(bcx, Call(bcx, powif, ~[a, x]), fcx.llretptr);\n+        }\n+        ~\"powif64\" => {\n+            let a = get_param(decl, first_real_arg);\n+            let x = get_param(decl, first_real_arg + 1u);\n+            let powif = ccx.intrinsics.get(~\"llvm.powi.f64\");\n+            Store(bcx, Call(bcx, powif, ~[a, x]), fcx.llretptr);\n+        }\n+        ~\"sinf32\" => {\n+            let x = get_param(decl, first_real_arg);\n+            let sinf = ccx.intrinsics.get(~\"llvm.sin.f32\");\n+            Store(bcx, Call(bcx, sinf, ~[x]), fcx.llretptr);\n+        }\n+        ~\"sinf64\" => {\n+            let x = get_param(decl, first_real_arg);\n+            let sinf = ccx.intrinsics.get(~\"llvm.sin.f64\");\n+            Store(bcx, Call(bcx, sinf, ~[x]), fcx.llretptr);\n+        }\n+        ~\"cosf32\" => {\n+            let x = get_param(decl, first_real_arg);\n+            let cosf = ccx.intrinsics.get(~\"llvm.cos.f32\");\n+            Store(bcx, Call(bcx, cosf, ~[x]), fcx.llretptr);\n+        }\n+        ~\"cosf64\" => {\n+            let x = get_param(decl, first_real_arg);\n+            let cosf = ccx.intrinsics.get(~\"llvm.cos.f64\");\n+            Store(bcx, Call(bcx, cosf, ~[x]), fcx.llretptr);\n+        }\n+        ~\"powf32\" => {\n+            let a = get_param(decl, first_real_arg);\n+            let x = get_param(decl, first_real_arg + 1u);\n+            let powf = ccx.intrinsics.get(~\"llvm.pow.f32\");\n+            Store(bcx, Call(bcx, powf, ~[a, x]), fcx.llretptr);\n+        }\n+        ~\"powf64\" => {\n+            let a = get_param(decl, first_real_arg);\n+            let x = get_param(decl, first_real_arg + 1u);\n+            let powf = ccx.intrinsics.get(~\"llvm.pow.f64\");\n+            Store(bcx, Call(bcx, powf, ~[a, x]), fcx.llretptr);\n+        }\n+        ~\"expf32\" => {\n+            let x = get_param(decl, first_real_arg);\n+            let expf = ccx.intrinsics.get(~\"llvm.exp.f32\");\n+            Store(bcx, Call(bcx, expf, ~[x]), fcx.llretptr);\n+        }\n+        ~\"expf64\" => {\n+            let x = get_param(decl, first_real_arg);\n+            let expf = ccx.intrinsics.get(~\"llvm.exp.f64\");\n+            Store(bcx, Call(bcx, expf, ~[x]), fcx.llretptr);\n+        }\n+        ~\"exp2f32\" => {\n+            let x = get_param(decl, first_real_arg);\n+            let exp2f = ccx.intrinsics.get(~\"llvm.exp2.f32\");\n+            Store(bcx, Call(bcx, exp2f, ~[x]), fcx.llretptr);\n+        }\n+        ~\"exp2f64\" => {\n+            let x = get_param(decl, first_real_arg);\n+            let exp2f = ccx.intrinsics.get(~\"llvm.exp2.f64\");\n+            Store(bcx, Call(bcx, exp2f, ~[x]), fcx.llretptr);\n+        }\n+        ~\"logf32\" => {\n+            let x = get_param(decl, first_real_arg);\n+            let logf = ccx.intrinsics.get(~\"llvm.log.f32\");\n+            Store(bcx, Call(bcx, logf, ~[x]), fcx.llretptr);\n+        }\n+        ~\"logf64\" => {\n+            let x = get_param(decl, first_real_arg);\n+            let logf = ccx.intrinsics.get(~\"llvm.log.f64\");\n+            Store(bcx, Call(bcx, logf, ~[x]), fcx.llretptr);\n+        }\n+        ~\"log10f32\" => {\n+            let x = get_param(decl, first_real_arg);\n+            let log10f = ccx.intrinsics.get(~\"llvm.log10.f32\");\n+            Store(bcx, Call(bcx, log10f, ~[x]), fcx.llretptr);\n+        }\n+        ~\"log10f64\" => {\n+            let x = get_param(decl, first_real_arg);\n+            let log10f = ccx.intrinsics.get(~\"llvm.log10.f64\");\n+            Store(bcx, Call(bcx, log10f, ~[x]), fcx.llretptr);\n+        }\n+        ~\"log2f32\" => {\n+            let x = get_param(decl, first_real_arg);\n+            let log2f = ccx.intrinsics.get(~\"llvm.log2.f32\");\n+            Store(bcx, Call(bcx, log2f, ~[x]), fcx.llretptr);\n+        }\n+        ~\"log2f64\" => {\n+            let x = get_param(decl, first_real_arg);\n+            let log2f = ccx.intrinsics.get(~\"llvm.log2.f64\");\n+            Store(bcx, Call(bcx, log2f, ~[x]), fcx.llretptr);\n+        }\n+        ~\"fmaf32\" => {\n+            let a = get_param(decl, first_real_arg);\n+            let b = get_param(decl, first_real_arg + 1u);\n+            let c = get_param(decl, first_real_arg + 2u);\n+            let fmaf = ccx.intrinsics.get(~\"llvm.fma.f32\");\n+            Store(bcx, Call(bcx, fmaf, ~[a, b, c]), fcx.llretptr);\n+        }\n+        ~\"fmaf64\" => {\n+            let a = get_param(decl, first_real_arg);\n+            let b = get_param(decl, first_real_arg + 1u);\n+            let c = get_param(decl, first_real_arg + 2u);\n+            let fmaf = ccx.intrinsics.get(~\"llvm.fma.f64\");\n+            Store(bcx, Call(bcx, fmaf, ~[a, b, c]), fcx.llretptr);\n+        }\n+        ~\"fabsf32\" => {\n+            let x = get_param(decl, first_real_arg);\n+            let fabsf = ccx.intrinsics.get(~\"llvm.fabs.f32\");\n+            Store(bcx, Call(bcx, fabsf, ~[x]), fcx.llretptr);\n+        }\n+        ~\"fabsf64\" => {\n+            let x = get_param(decl, first_real_arg);\n+            let fabsf = ccx.intrinsics.get(~\"llvm.fabs.f64\");\n+            Store(bcx, Call(bcx, fabsf, ~[x]), fcx.llretptr);\n+        }\n+        ~\"floorf32\" => {\n+            let x = get_param(decl, first_real_arg);\n+            let floorf = ccx.intrinsics.get(~\"llvm.floor.f32\");\n+            Store(bcx, Call(bcx, floorf, ~[x]), fcx.llretptr);\n+        }\n+        ~\"floorf64\" => {\n+            let x = get_param(decl, first_real_arg);\n+            let floorf = ccx.intrinsics.get(~\"llvm.floor.f64\");\n+            Store(bcx, Call(bcx, floorf, ~[x]), fcx.llretptr);\n+        }\n+        ~\"ceilf32\" => {\n+            let x = get_param(decl, first_real_arg);\n+            let ceilf = ccx.intrinsics.get(~\"llvm.ceil.f32\");\n+            Store(bcx, Call(bcx, ceilf, ~[x]), fcx.llretptr);\n+        }\n+        ~\"ceilf64\" => {\n+            let x = get_param(decl, first_real_arg);\n+            let ceilf = ccx.intrinsics.get(~\"llvm.ceil.f64\");\n+            Store(bcx, Call(bcx, ceilf, ~[x]), fcx.llretptr);\n+        }\n+        ~\"truncf32\" => {\n+            let x = get_param(decl, first_real_arg);\n+            let truncf = ccx.intrinsics.get(~\"llvm.trunc.f32\");\n+            Store(bcx, Call(bcx, truncf, ~[x]), fcx.llretptr);\n+        }\n+        ~\"truncf64\" => {\n+            let x = get_param(decl, first_real_arg);\n+            let truncf = ccx.intrinsics.get(~\"llvm.trunc.f64\");\n+            Store(bcx, Call(bcx, truncf, ~[x]), fcx.llretptr);\n+        }\n         _ => {\n             // Could we make this an enum rather than a string? does it get\n             // checked earlier?"}, {"sha": "dedf667a4d93d0d3aca4bf0f77c78bd3b48a242b", "filename": "src/librustc/middle/trans/type_use.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/01cd53baf0ea241b17132e857ba356b9b9a14908/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01cd53baf0ea241b17132e857ba356b9b9a14908/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=01cd53baf0ea241b17132e857ba356b9b9a14908", "patch": "@@ -118,6 +118,15 @@ fn type_uses_for(ccx: @crate_ctxt, fn_id: def_id, n_tps: uint)\n                 ~\"visit_tydesc\"  | ~\"forget\" | ~\"addr_of\" |\n                 ~\"frame_address\" | ~\"morestack_addr\" => 0,\n \n+                ~\"sqrtf32\" | ~\"sqrtf64\" | ~\"powif32\" | ~\"powif64\" |\n+                ~\"sinf32\"  | ~\"sinf64\"  | ~\"cosf32\"  | ~\"cosf64\"  |\n+                ~\"powf32\"  | ~\"powf64\"  | ~\"expf32\"  | ~\"expf64\"  |\n+                ~\"exp2f32\" | ~\"exp2f64\" | ~\"logf32\"  | ~\"logf64\"  |\n+                ~\"log10f32\"| ~\"log10f64\"| ~\"log2f32\" | ~\"log2f64\" |\n+                ~\"fmaf32\"  | ~\"fmaf64\"  | ~\"fabsf32\" | ~\"fabsf64\" |\n+                ~\"floorf32\"| ~\"floorf64\"| ~\"ceilf32\" | ~\"ceilf64\" |\n+                ~\"truncf32\"| ~\"truncf64\" => 0,\n+\n                 // would be cool to make these an enum instead of strings!\n                 _ => fail ~\"unknown intrinsic in type_use\"\n             };"}, {"sha": "d7a0dafc779a02a72d646c5e55161b9873920a7a", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/01cd53baf0ea241b17132e857ba356b9b9a14908/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01cd53baf0ea241b17132e857ba356b9b9a14908/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=01cd53baf0ea241b17132e857ba356b9b9a14908", "patch": "@@ -2977,6 +2977,134 @@ fn check_intrinsic_type(ccx: @crate_ctxt, it: @ast::foreign_item) {\n       ~\"morestack_addr\" => {\n         (0u, ~[], ty::mk_nil_ptr(tcx))\n       }\n+     ~\"sqrtf32\" => {\n+        (0u, ~[arg(ast::by_copy, ty::mk_f32(tcx))],\n+         ty::mk_f32(tcx))\n+     }\n+     ~\"sqrtf64\" => {\n+        (0u, ~[arg(ast::by_copy, ty::mk_f64(tcx))],\n+         ty::mk_f64(tcx))\n+     }\n+     ~\"powif32\" => {\n+        (0u, ~[arg(ast::by_copy, ty::mk_f32(tcx)),\n+               arg(ast::by_copy, ty::mk_i32(tcx))],\n+         ty::mk_f32(tcx))\n+     }\n+     ~\"powif64\" => {\n+        (0u, ~[arg(ast::by_copy, ty::mk_f64(tcx)),\n+               arg(ast::by_copy, ty::mk_i32(tcx))],\n+         ty::mk_f64(tcx))\n+     }\n+     ~\"sinf32\" => {\n+        (0u, ~[arg(ast::by_copy, ty::mk_f32(tcx))],\n+         ty::mk_f32(tcx))\n+     }\n+     ~\"sinf64\" => {\n+        (0u, ~[arg(ast::by_copy, ty::mk_f64(tcx))],\n+         ty::mk_f64(tcx))\n+     }\n+     ~\"cosf32\" => {\n+        (0u, ~[arg(ast::by_copy, ty::mk_f32(tcx))],\n+         ty::mk_f32(tcx))\n+     }\n+     ~\"cosf64\" => {\n+        (0u, ~[arg(ast::by_copy, ty::mk_f64(tcx))],\n+         ty::mk_f64(tcx))\n+     }\n+     ~\"powf32\" => {\n+        (0u, ~[arg(ast::by_copy, ty::mk_f32(tcx)),\n+               arg(ast::by_copy, ty::mk_f32(tcx))],\n+         ty::mk_f32(tcx))\n+     }\n+     ~\"powf64\" => {\n+        (0u, ~[arg(ast::by_copy, ty::mk_f64(tcx)),\n+               arg(ast::by_copy, ty::mk_f64(tcx))],\n+         ty::mk_f64(tcx))\n+     }\n+     ~\"expf32\" => {\n+        (0u, ~[arg(ast::by_copy, ty::mk_f32(tcx))],\n+         ty::mk_f32(tcx))\n+     }\n+     ~\"expf64\" => {\n+        (0u, ~[arg(ast::by_copy, ty::mk_f64(tcx))],\n+         ty::mk_f64(tcx))\n+     }\n+     ~\"exp2f32\" => {\n+        (0u, ~[arg(ast::by_copy, ty::mk_f32(tcx))],\n+         ty::mk_f32(tcx))\n+     }\n+     ~\"exp2f64\" => {\n+        (0u, ~[arg(ast::by_copy, ty::mk_f64(tcx))],\n+         ty::mk_f64(tcx))\n+     }\n+     ~\"logf32\" => {\n+        (0u, ~[arg(ast::by_copy, ty::mk_f32(tcx))],\n+         ty::mk_f32(tcx))\n+     }\n+     ~\"logf64\" => {\n+        (0u, ~[arg(ast::by_copy, ty::mk_f64(tcx))],\n+         ty::mk_f64(tcx))\n+     }\n+     ~\"log10f32\" => {\n+        (0u, ~[arg(ast::by_copy, ty::mk_f32(tcx))],\n+         ty::mk_f32(tcx))\n+     }      \n+     ~\"log10f64\" => {\n+        (0u, ~[arg(ast::by_copy, ty::mk_f64(tcx))],\n+         ty::mk_f64(tcx))\n+     }\n+     ~\"log2f32\" => {\n+        (0u, ~[arg(ast::by_copy, ty::mk_f32(tcx))],\n+         ty::mk_f32(tcx))\n+     }\n+     ~\"log2f64\" => {\n+        (0u, ~[arg(ast::by_copy, ty::mk_f64(tcx))],\n+         ty::mk_f64(tcx))\n+     }\n+     ~\"fmaf32\" => {\n+        (0u, ~[arg(ast::by_copy, ty::mk_f32(tcx)),\n+               arg(ast::by_copy, ty::mk_f32(tcx)),\n+               arg(ast::by_copy, ty::mk_f32(tcx))],\n+         ty::mk_f32(tcx))\n+     }\n+     ~\"fmaf64\" => {\n+        (0u, ~[arg(ast::by_copy, ty::mk_f64(tcx)),\n+               arg(ast::by_copy, ty::mk_f64(tcx)),\n+               arg(ast::by_copy, ty::mk_f64(tcx))],\n+         ty::mk_f64(tcx))\n+     }\n+     ~\"fabsf32\" => {\n+        (0u, ~[arg(ast::by_copy, ty::mk_f32(tcx))],\n+         ty::mk_f32(tcx))\n+     }\n+     ~\"fabsf64\" => {\n+        (0u, ~[arg(ast::by_copy, ty::mk_f64(tcx))],\n+         ty::mk_f64(tcx))\n+     }\n+     ~\"floorf32\" => {\n+        (0u, ~[arg(ast::by_copy, ty::mk_f32(tcx))],\n+         ty::mk_f32(tcx))\n+     }\n+     ~\"floorf64\" => {\n+        (0u, ~[arg(ast::by_copy, ty::mk_f64(tcx))],\n+         ty::mk_f64(tcx))\n+     }\n+     ~\"ceilf32\" => {\n+        (0u, ~[arg(ast::by_copy, ty::mk_f32(tcx))],\n+         ty::mk_f32(tcx))\n+     }\n+     ~\"ceilf64\" => {\n+        (0u, ~[arg(ast::by_copy, ty::mk_f64(tcx))],\n+         ty::mk_f64(tcx))\n+     }\n+     ~\"truncf32\" => {\n+        (0u, ~[arg(ast::by_copy, ty::mk_f32(tcx))],\n+         ty::mk_f32(tcx))\n+     }\n+     ~\"truncf64\" => {\n+        (0u, ~[arg(ast::by_copy, ty::mk_f64(tcx))],\n+         ty::mk_f64(tcx))\n+     }\n       ref other => {\n         tcx.sess.span_err(it.span, ~\"unrecognized intrinsic function: `\" +\n                           (*other) + ~\"`\");"}, {"sha": "3512ccf5fcf995dcefb2072b9436d3247c25e40e", "filename": "src/test/run-pass/intrinsics-math.rs", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/01cd53baf0ea241b17132e857ba356b9b9a14908/src%2Ftest%2Frun-pass%2Fintrinsics-math.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01cd53baf0ea241b17132e857ba356b9b9a14908/src%2Ftest%2Frun-pass%2Fintrinsics-math.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fintrinsics-math.rs?ref=01cd53baf0ea241b17132e857ba356b9b9a14908", "patch": "@@ -0,0 +1,88 @@\n+#[abi = \"rust-intrinsic\"]  \n+extern mod rusti {\n+    fn sqrtf32(x: f32) -> f32;\n+    fn sqrtf64(x: f64) -> f64;\n+    fn powif32(a: f32, x: i32) -> f32;\n+    fn powif64(a: f64, x: i32) -> f64;\n+    fn sinf32(x: f32) -> f32;\n+    fn sinf64(x: f64) -> f64;\n+    fn cosf32(x: f32) -> f32;\n+    fn cosf64(x: f64) -> f64;\n+    fn powf32(a: f32, x: f32) -> f32;\n+    fn powf64(a: f64, x: f64) -> f64;\n+    fn expf32(x: f32) -> f32;\n+    fn expf64(x: f64) -> f64;\n+    fn exp2f32(x: f32) -> f32;\n+    fn exp2f64(x: f64) -> f64;\n+    fn logf32(x: f32) -> f32;\n+    fn logf64(x: f64) -> f64;\n+    fn log10f32(x: f32) -> f32;\n+    fn log10f64(x: f64) -> f64;\n+    fn log2f32(x: f32) -> f32;\n+    fn log2f64(x: f64) -> f64;\n+    fn fmaf32(a: f32, b: f32, c: f32) -> f32;\n+    fn fmaf64(a: f64, b: f64, c: f64) -> f64;\n+    fn fabsf32(x: f32) -> f32;\n+    fn fabsf64(x: f64) -> f64;\n+    fn floorf32(x: f32) -> f32;\n+    fn floorf64(x: f64) -> f64;\n+    fn ceilf32(x: f32) -> f32;\n+    fn ceilf64(x: f64) -> f64;\n+    fn truncf32(x: f32) -> f32;\n+    fn truncf64(x: f64) -> f64;\n+}\n+\n+fn main() {\n+\n+    use rusti::*;\n+\n+    assert(sqrtf32(64f32) == 8f32);\n+    assert(sqrtf64(64f64) == 8f64);\n+\n+    assert(powif32(25f32, -2i32) == 0.0016f32);\n+    assert(powif64(23.2f64, 2i32) == 538.24f64);\n+\n+    assert(sinf32(0f32) == 0f32);\n+    assert(sinf64(f64::consts::pi / 2f64) == 1f64);\n+\n+    assert(cosf32(0f32) == 1f32);\n+    assert(cosf64(f64::consts::pi * 2f64) == 1f64);\n+\n+    assert(powf32(25f32, -2f32) == 0.0016f32);\n+    assert(powf64(400f64, 0.5f64) == 20f64);\n+\n+    assert(expf32(1f32) == f32::consts::e);\n+    assert(expf64(1f64) == f64::consts::e);\n+\n+    assert(exp2f32(10f32) == 1024f32);\n+    assert(exp2f64(50f64) == 1125899906842624f64);\n+\n+    assert(logf32(f32::consts::e) == 1f32);\n+    assert(logf64(1f64) == 0f64);\n+\n+    assert(log10f32(10f32) == 1f32);\n+    assert(log10f64(f64::consts::e) == f64::consts::log10_e);\n+\n+    assert(log2f32(8f32) == 3f32);\n+    assert(log2f64(f64::consts::e) == f64::consts::log2_e);\n+  \n+    assert(fmaf32(1.0f32, 2.0f32, 5.0f32) == 7.0f32);\n+    assert(fmaf64(0.0f64, -2.0f64, f64::consts::e) == f64::consts::e);\n+\n+    assert(fabsf32(-1.0f32) == 1.0f32);\n+    assert(fabsf64(34.2f64) == 34.2f64);\n+\n+    assert(floorf32(3.8f32) == 3.0f32);\n+    assert(floorf64(-1.1f64) == -2.0f64);\n+\n+    // Causes linker error\n+    // undefined reference to llvm.ceil.f32/64\n+    //assert(ceilf32(-2.3f32) == -2.0f32);\n+    //assert(ceilf64(3.8f64) == 4.0f64);\n+  \n+    // Causes linker error\n+    // undefined reference to llvm.trunc.f32/64\n+    //assert(truncf32(0.1f32) == 0.0f32);\n+    //assert(truncf64(-0.1f64) == 0.0f64);\n+\n+}"}]}