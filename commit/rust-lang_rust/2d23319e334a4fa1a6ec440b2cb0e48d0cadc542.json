{"sha": "2d23319e334a4fa1a6ec440b2cb0e48d0cadc542", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJkMjMzMTllMzM0YTRmYTFhNmVjNDQwYjJjYjBlNDhkMGNhZGM1NDI=", "commit": {"author": {"name": "Andrew Poelstra", "email": "apoelstra@wpsoftware.net", "date": "2014-06-30T13:43:39Z"}, "committer": {"name": "Andrew Poelstra", "email": "apoelstra@wpsoftware.net", "date": "2014-07-02T19:34:19Z"}, "message": "collections::bitv: Remove SmallBitv/BigBitv dichotomy\n\nThe old `Bitv` structure had two variations: one represented by a vector of\nuints, and another represented by a single uint for bit vectors containing\nfewer than uint::BITS bits.\n\nThe purpose of this is to avoid the indirection of using a Vec, but the\nspeedup is only available to users who\n\n  (a) are storing less than uints::BITS bits\n  (b) know this when they create the vector (since `Bitv`s cannot be resized)\n  (c) don't know this at compile time (else they could use uint directly)\n\nGiving such specific users a (questionable) speed benefit at the cost of\nadding explicit checks to almost every single bit call, frequently writing\nthe same method twice and making iteration much much more difficult, does\nnot seem like a worthwhile tradeoff to me.\n\nAlso, rustc does not use Bitv anywhere, only through BitvSet, which does\nnot have this optimization.\n\nFor reference, here is some speed data from before and after this PR:\n\nBEFORE:\ntest bitv::tests::bench_bitv_big        ... bench:     4 ns/iter (+/- 1)\ntest bitv::tests::bench_bitv_big_iter   ... bench:  4858 ns/iter (+/- 22)\ntest bitv::tests::bench_bitv_big_union  ... bench:   507 ns/iter (+/- 35)\ntest bitv::tests::bench_bitv_set_big    ... bench:     6 ns/iter (+/- 1)\ntest bitv::tests::bench_bitv_set_small  ... bench:     6 ns/iter (+/- 0)\ntest bitv::tests::bench_bitv_small      ... bench:     5 ns/iter (+/- 1)\ntest bitv::tests::bench_bitvset_iter    ... bench: 12930 ns/iter (+/- 662)\ntest bitv::tests::bench_btv_small_iter  ... bench:    39 ns/iter (+/- 1)\ntest bitv::tests::bench_uint_small      ... bench:     4 ns/iter (+/- 1)\n\nAFTER:\ntest bitv::tests::bench_bitv_big        ... bench:     5 ns/iter (+/- 1)\ntest bitv::tests::bench_bitv_big_iter   ... bench:  5004 ns/iter (+/- 102)\ntest bitv::tests::bench_bitv_big_union  ... bench:   356 ns/iter (+/- 26)\ntest bitv::tests::bench_bitv_set_big    ... bench:     6 ns/iter (+/- 0)\ntest bitv::tests::bench_bitv_set_small  ... bench:     6 ns/iter (+/- 1)\ntest bitv::tests::bench_bitv_small      ... bench:     4 ns/iter (+/- 1)\ntest bitv::tests::bench_bitvset_iter    ... bench: 12918 ns/iter (+/- 621)\ntest bitv::tests::bench_btv_small_iter  ... bench:    50 ns/iter (+/- 5)\ntest bitv::tests::bench_uint_small      ... bench:     4 ns/iter (+/- 1)", "tree": {"sha": "81158e012e2ba7cb33668c0eb415803a06146c1a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/81158e012e2ba7cb33668c0eb415803a06146c1a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2d23319e334a4fa1a6ec440b2cb0e48d0cadc542", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2d23319e334a4fa1a6ec440b2cb0e48d0cadc542", "html_url": "https://github.com/rust-lang/rust/commit/2d23319e334a4fa1a6ec440b2cb0e48d0cadc542", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2d23319e334a4fa1a6ec440b2cb0e48d0cadc542/comments", "author": {"login": "apoelstra", "id": 1351933, "node_id": "MDQ6VXNlcjEzNTE5MzM=", "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apoelstra", "html_url": "https://github.com/apoelstra", "followers_url": "https://api.github.com/users/apoelstra/followers", "following_url": "https://api.github.com/users/apoelstra/following{/other_user}", "gists_url": "https://api.github.com/users/apoelstra/gists{/gist_id}", "starred_url": "https://api.github.com/users/apoelstra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions", "organizations_url": "https://api.github.com/users/apoelstra/orgs", "repos_url": "https://api.github.com/users/apoelstra/repos", "events_url": "https://api.github.com/users/apoelstra/events{/privacy}", "received_events_url": "https://api.github.com/users/apoelstra/received_events", "type": "User", "site_admin": false}, "committer": {"login": "apoelstra", "id": 1351933, "node_id": "MDQ6VXNlcjEzNTE5MzM=", "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apoelstra", "html_url": "https://github.com/apoelstra", "followers_url": "https://api.github.com/users/apoelstra/followers", "following_url": "https://api.github.com/users/apoelstra/following{/other_user}", "gists_url": "https://api.github.com/users/apoelstra/gists{/gist_id}", "starred_url": "https://api.github.com/users/apoelstra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions", "organizations_url": "https://api.github.com/users/apoelstra/orgs", "repos_url": "https://api.github.com/users/apoelstra/repos", "events_url": "https://api.github.com/users/apoelstra/events{/privacy}", "received_events_url": "https://api.github.com/users/apoelstra/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a4c0468a21ce48998310947869dcf028ee468b8d", "url": "https://api.github.com/repos/rust-lang/rust/commits/a4c0468a21ce48998310947869dcf028ee468b8d", "html_url": "https://github.com/rust-lang/rust/commit/a4c0468a21ce48998310947869dcf028ee468b8d"}], "stats": {"total": 503, "additions": 106, "deletions": 397}, "files": [{"sha": "20d7c3ef2cf61e2fe3048261bb8e18dd2d3cf1b7", "filename": "src/libcollections/bitv.rs", "status": "modified", "additions": 106, "deletions": 397, "changes": 503, "blob_url": "https://github.com/rust-lang/rust/blob/2d23319e334a4fa1a6ec440b2cb0e48d0cadc542/src%2Flibcollections%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d23319e334a4fa1a6ec440b2cb0e48d0cadc542/src%2Flibcollections%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbitv.rs?ref=2d23319e334a4fa1a6ec440b2cb0e48d0cadc542", "patch": "@@ -16,7 +16,6 @@ use core::cmp;\n use core::default::Default;\n use core::fmt;\n use core::iter::{Map, Zip};\n-use core::option;\n use core::ops;\n use core::slice;\n use core::uint;\n@@ -25,110 +24,14 @@ use std::hash;\n use {Collection, Mutable, Set, MutableSet};\n use vec::Vec;\n \n-#[deriving(Clone)]\n-struct SmallBitv {\n-    /// only the lowest nbits of this value are used. the rest is undefined.\n-    bits: uint\n-}\n-\n-/// a mask that has a 1 for each defined bit in a small_bitv, assuming n bits\n-#[inline]\n-fn small_mask(nbits: uint) -> uint {\n-    (1 << nbits) - 1\n-}\n-\n-impl SmallBitv {\n-    fn new(bits: uint) -> SmallBitv {\n-        SmallBitv {bits: bits}\n-    }\n-\n-    #[inline]\n-    fn bits_op(&mut self,\n-                   right_bits: uint,\n-                   nbits: uint,\n-                   f: |uint, uint| -> uint)\n-                   -> bool {\n-        let mask = small_mask(nbits);\n-        let old_b: uint = self.bits;\n-        let new_b = f(old_b, right_bits);\n-        self.bits = new_b;\n-        mask & old_b != mask & new_b\n-    }\n-\n-    #[inline]\n-    fn union(&mut self, s: &SmallBitv, nbits: uint) -> bool {\n-        self.bits_op(s.bits, nbits, |u1, u2| u1 | u2)\n-    }\n-\n-    #[inline]\n-    fn intersect(&mut self, s: &SmallBitv, nbits: uint) -> bool {\n-        self.bits_op(s.bits, nbits, |u1, u2| u1 & u2)\n-    }\n-\n-    #[inline]\n-    fn become(&mut self, s: &SmallBitv, nbits: uint) -> bool {\n-        self.bits_op(s.bits, nbits, |_u1, u2| u2)\n-    }\n-\n-    #[inline]\n-    fn difference(&mut self, s: &SmallBitv, nbits: uint) -> bool {\n-        self.bits_op(s.bits, nbits, |u1, u2| u1 & !u2)\n-    }\n-\n-    #[inline]\n-    fn get(&self, i: uint) -> bool {\n-        (self.bits & (1 << i)) != 0\n-    }\n-\n-    #[inline]\n-    fn set(&mut self, i: uint, x: bool) {\n-        if x {\n-            self.bits |= 1<<i;\n-        }\n-        else {\n-            self.bits &= !(1<<i);\n-        }\n-    }\n-\n-    #[inline]\n-    fn equals(&self, b: &SmallBitv, nbits: uint) -> bool {\n-        let mask = small_mask(nbits);\n-        mask & self.bits == mask & b.bits\n-    }\n-\n-    #[inline]\n-    fn clear(&mut self) { self.bits = 0; }\n-\n-    #[inline]\n-    fn set_all(&mut self) { self.bits = !0; }\n-\n-    #[inline]\n-    fn all(&self, nbits: uint) -> bool {\n-        small_mask(nbits) & !self.bits == 0\n-    }\n-\n-    #[inline]\n-    fn none(&self, nbits: uint) -> bool {\n-        small_mask(nbits) & self.bits == 0\n-    }\n-\n-    #[inline]\n-    fn negate(&mut self) { self.bits = !self.bits; }\n-}\n-\n-#[deriving(Clone)]\n-struct BigBitv {\n-    storage: Vec<uint>\n-}\n-\n /**\n- * A mask that has a 1 for each defined bit in the n'th element of a `BigBitv`,\n+ * A mask that has a 1 for each defined bit in the n'th element of a `Bitv`,\n  * assuming n bits.\n  */\n #[inline]\n fn big_mask(nbits: uint, elem: uint) -> uint {\n     let rmd = nbits % uint::BITS;\n-    let nelems = nbits/uint::BITS + if rmd == 0 {0} else {1};\n+    let nelems = (nbits + uint::BITS - 1) / uint::BITS;\n \n     if elem < nelems - 1 || rmd == 0 {\n         !0\n@@ -137,99 +40,6 @@ fn big_mask(nbits: uint, elem: uint) -> uint {\n     }\n }\n \n-impl BigBitv {\n-    fn new(storage: Vec<uint>) -> BigBitv {\n-        BigBitv {storage: storage}\n-    }\n-\n-    #[inline]\n-    fn process(&mut self,\n-                   b: &BigBitv,\n-                   nbits: uint,\n-                   op: |uint, uint| -> uint)\n-                   -> bool {\n-        let len = b.storage.len();\n-        assert_eq!(self.storage.len(), len);\n-        let mut changed = false;\n-        for (i, (a, b)) in self.storage.mut_iter()\n-                               .zip(b.storage.iter())\n-                               .enumerate() {\n-            let mask = big_mask(nbits, i);\n-            let w0 = *a & mask;\n-            let w1 = *b & mask;\n-            let w = op(w0, w1) & mask;\n-            if w0 != w {\n-                changed = true;\n-                *a = w;\n-            }\n-        }\n-        changed\n-    }\n-\n-    #[inline]\n-    fn each_storage(&mut self, op: |v: &mut uint| -> bool) -> bool {\n-        self.storage.mut_iter().advance(|elt| op(elt))\n-    }\n-\n-    #[inline]\n-    fn negate(&mut self) {\n-        self.each_storage(|w| { *w = !*w; true });\n-    }\n-\n-    #[inline]\n-    fn union(&mut self, b: &BigBitv, nbits: uint) -> bool {\n-        self.process(b, nbits, |w1, w2| w1 | w2)\n-    }\n-\n-    #[inline]\n-    fn intersect(&mut self, b: &BigBitv, nbits: uint) -> bool {\n-        self.process(b, nbits, |w1, w2| w1 & w2)\n-    }\n-\n-    #[inline]\n-    fn become(&mut self, b: &BigBitv, nbits: uint) -> bool {\n-        self.process(b, nbits, |_, w| w)\n-    }\n-\n-    #[inline]\n-    fn difference(&mut self, b: &BigBitv, nbits: uint) -> bool {\n-        self.process(b, nbits, |w1, w2| w1 & !w2)\n-    }\n-\n-    #[inline]\n-    fn get(&self, i: uint) -> bool {\n-        let w = i / uint::BITS;\n-        let b = i % uint::BITS;\n-        let x = 1 & self.storage.get(w) >> b;\n-        x == 1\n-    }\n-\n-    #[inline]\n-    fn set(&mut self, i: uint, x: bool) {\n-        let w = i / uint::BITS;\n-        let b = i % uint::BITS;\n-        let flag = 1 << b;\n-        *self.storage.get_mut(w) = if x { *self.storage.get(w) | flag }\n-                          else { *self.storage.get(w) & !flag };\n-    }\n-\n-    #[inline]\n-    fn equals(&self, b: &BigBitv, nbits: uint) -> bool {\n-        for (i, elt) in b.storage.iter().enumerate() {\n-            let mask = big_mask(nbits, i);\n-            if mask & *self.storage.get(i) != mask & *elt {\n-                return false;\n-            }\n-        }\n-        true\n-    }\n-}\n-\n-#[deriving(Clone)]\n-enum BitvVariant { Big(BigBitv), Small(SmallBitv) }\n-\n-enum Op {Union, Intersect, Assign, Difference}\n-\n /// The bitvector type\n ///\n /// # Example\n@@ -259,108 +69,72 @@ enum Op {Union, Intersect, Assign, Difference}\n /// ```\n #[deriving(Clone)]\n pub struct Bitv {\n-    /// Internal representation of the bit vector (small or large)\n-    rep: BitvVariant,\n+    /// Internal representation of the bit vector\n+    storage: Vec<uint>,\n     /// The number of valid bits in the internal representation\n     nbits: uint\n }\n \n-fn die() -> ! {\n-    fail!(\"Tried to do operation on bit vectors with different sizes\");\n-}\n-\n-enum WordsVariant<'a> {\n-    NoneIter,\n-    OneIter(option::Item<uint>),\n-    VecIter(slice::Items<'a, uint>)\n-}\n-\n struct Words<'a> {\n-    rep: WordsVariant<'a>,\n+    iter: slice::Items<'a, uint>,\n     offset: uint\n }\n \n impl<'a> Iterator<(uint, uint)> for Words<'a> {\n     /// Returns (offset, word)\n     fn next<'a>(&'a mut self) -> Option<(uint, uint)> {\n-        let ret = match self.rep {\n-            NoneIter => None,\n-            OneIter(ref mut it) => it.next(),\n-            VecIter(ref mut it) => it.next().map(|n| *n)\n-        };\n+        let ret = self.iter.next().map(|&n| (self.offset, n));\n         self.offset += 1;\n-        match ret {\n-            Some(n) => Some((self.offset - 1, n)),\n-            None => None\n-        }\n+        ret\n     }\n }\n \n impl Bitv {\n     #[inline]\n-    fn do_op(&mut self, op: Op, other: &Bitv) -> bool {\n-        if self.nbits != other.nbits {\n-            die();\n-        }\n-        match self.rep {\n-          Small(ref mut s) => match other.rep {\n-            Small(ref s1) => match op {\n-              Union      => s.union(s1,      self.nbits),\n-              Intersect  => s.intersect(s1,  self.nbits),\n-              Assign     => s.become(s1,     self.nbits),\n-              Difference => s.difference(s1, self.nbits)\n-            },\n-            Big(_) => die()\n-          },\n-          Big(ref mut s) => match other.rep {\n-            Small(_) => die(),\n-            Big(ref s1) => match op {\n-              Union      => s.union(s1,      self.nbits),\n-              Intersect  => s.intersect(s1,  self.nbits),\n-              Assign     => s.become(s1,     self.nbits),\n-              Difference => s.difference(s1, self.nbits)\n+    fn process(&mut self, other: &Bitv, nbits: uint,\n+               op: |uint, uint| -> uint) -> bool {\n+        let len = other.storage.len();\n+        assert_eq!(self.storage.len(), len);\n+        let mut changed = false;\n+        for (i, (a, b)) in self.storage.mut_iter()\n+                               .zip(other.storage.iter())\n+                               .enumerate() {\n+            let mask = big_mask(nbits, i);\n+            let w0 = *a & mask;\n+            let w1 = *b & mask;\n+            let w = op(w0, w1) & mask;\n+            if w0 != w {\n+                changed = true;\n+                *a = w;\n             }\n-          }\n         }\n+        changed\n     }\n \n+    #[inline]\n     #[inline]\n     fn words<'a>(&'a self, start: uint) -> Words<'a> {\n         Words {\n-          rep: match self.rep {\n-              Small(_) if start > 0 => NoneIter,\n-              Small(ref s) => OneIter(Some(s.bits).move_iter()),\n-              Big(ref b) => VecIter(b.storage.slice_from(start).iter())\n-          },\n+          iter: self.storage.slice_from(start).iter(),\n           offset: start\n         }\n     }\n-}\n \n-impl Bitv {\n     /// Creates an empty Bitv that holds `nbits` elements, setting each element\n     /// to `init`.\n     pub fn new(nbits: uint, init: bool) -> Bitv {\n-        let rep = if nbits < uint::BITS {\n-            Small(SmallBitv::new(if init {(1<<nbits)-1} else {0}))\n-        } else if nbits == uint::BITS {\n-            Small(SmallBitv::new(if init {!0} else {0}))\n-        } else {\n-            let exact = nbits % uint::BITS == 0;\n-            let nelems = nbits/uint::BITS + if exact {0} else {1};\n-            let s =\n-                if init {\n-                    if exact {\n-                        Vec::from_elem(nelems, !0u)\n-                    } else {\n-                        let mut v = Vec::from_elem(nelems-1, !0u);\n-                        v.push((1<<nbits % uint::BITS)-1);\n-                        v\n-                    }\n-                } else { Vec::from_elem(nelems, 0u)};\n-            Big(BigBitv::new(s))\n-        };\n-        Bitv {rep: rep, nbits: nbits}\n+        Bitv {\n+            storage: {\n+                let nelems = (nbits + uint::BITS - 1) / uint::BITS;\n+                let mut v = Vec::from_elem(nelems, if init { !0u } else { 0u });\n+                // Zero out any remainder bits\n+                if nbits % uint::BITS > 0 {\n+                    *v.get_mut(nelems - 1) &= (1 << nbits % uint::BITS) - 1;\n+                }\n+                v\n+            },\n+            nbits: nbits\n+        }\n     }\n \n     /**\n@@ -370,7 +144,10 @@ impl Bitv {\n      * the same length. Returns `true` if `self` changed.\n     */\n     #[inline]\n-    pub fn union(&mut self, v1: &Bitv) -> bool { self.do_op(Union, v1) }\n+    pub fn union(&mut self, other: &Bitv) -> bool {\n+        let nbits = self.nbits;\n+        self.process(other, nbits, |w1, w2| w1 | w2)\n+    }\n \n     /**\n      * Calculates the intersection of two bitvectors\n@@ -379,8 +156,9 @@ impl Bitv {\n      * must be the same length. Returns `true` if `self` changed.\n     */\n     #[inline]\n-    pub fn intersect(&mut self, v1: &Bitv) -> bool {\n-        self.do_op(Intersect, v1)\n+    pub fn intersect(&mut self, other: &Bitv) -> bool {\n+        let nbits = self.nbits;\n+        self.process(other, nbits, |w1, w2| w1 & w2)\n     }\n \n     /**\n@@ -390,16 +168,19 @@ impl Bitv {\n      * changed\n      */\n     #[inline]\n-    pub fn assign(&mut self, v: &Bitv) -> bool { self.do_op(Assign, v) }\n+    pub fn assign(&mut self, other: &Bitv) -> bool {\n+        let nbits = self.nbits;\n+        self.process(other, nbits, |_, w| w)\n+    }\n \n     /// Retrieve the value at index `i`\n     #[inline]\n     pub fn get(&self, i: uint) -> bool {\n-        assert!((i < self.nbits));\n-        match self.rep {\n-            Big(ref b)   => b.get(i),\n-            Small(ref s) => s.get(i)\n-        }\n+        assert!(i < self.nbits);\n+        let w = i / uint::BITS;\n+        let b = i % uint::BITS;\n+        let x = self.storage.get(w) & (1 << b);\n+        x != 0\n     }\n \n     /**\n@@ -409,42 +190,30 @@ impl Bitv {\n      */\n     #[inline]\n     pub fn set(&mut self, i: uint, x: bool) {\n-      assert!((i < self.nbits));\n-      match self.rep {\n-        Big(ref mut b)   => b.set(i, x),\n-        Small(ref mut s) => s.set(i, x)\n-      }\n+        assert!(i < self.nbits);\n+        let w = i / uint::BITS;\n+        let b = i % uint::BITS;\n+        let flag = 1 << b;\n+        *self.storage.get_mut(w) = if x { *self.storage.get(w) | flag }\n+                          else { *self.storage.get(w) & !flag };\n     }\n \n     /// Set all bits to 0\n     #[inline]\n     pub fn clear(&mut self) {\n-        match self.rep {\n-            Small(ref mut b) => b.clear(),\n-            Big(ref mut s) => {\n-                s.each_storage(|w| { *w = 0u; true });\n-            }\n-        }\n+        for w in self.storage.mut_iter() { *w = 0u; }\n     }\n \n     /// Set all bits to 1\n     #[inline]\n     pub fn set_all(&mut self) {\n-        match self.rep {\n-            Small(ref mut b) => b.set_all(),\n-            Big(ref mut s) => {\n-                s.each_storage(|w| { *w = !0u; true });\n-            }\n-        }\n+        for w in self.storage.mut_iter() { *w = !0u; }\n     }\n \n     /// Flip all bits\n     #[inline]\n     pub fn negate(&mut self) {\n-        match self.rep {\n-            Small(ref mut s) => s.negate(),\n-            Big(ref mut b) => b.negate(),\n-        }\n+        for w in self.storage.mut_iter() { *w = !*w; }\n     }\n \n     /**\n@@ -457,17 +226,21 @@ impl Bitv {\n      * Returns `true` if `v0` was changed.\n      */\n     #[inline]\n-    pub fn difference(&mut self, v: &Bitv) -> bool {\n-        self.do_op(Difference, v)\n+    pub fn difference(&mut self, other: &Bitv) -> bool {\n+        let nbits = self.nbits;\n+        self.process(other, nbits, |w1, w2| w1 & !w2)\n     }\n \n     /// Returns `true` if all bits are 1\n     #[inline]\n     pub fn all(&self) -> bool {\n-      match self.rep {\n-        Small(ref b) => b.all(self.nbits),\n-        _ => self.iter().all(|x| x)\n-      }\n+        for (i, &elem) in self.storage.iter().enumerate() {\n+            let mask = big_mask(self.nbits, i);\n+            if elem & mask != mask {\n+                return false;\n+            }\n+        }\n+        true\n     }\n \n     /// Returns an iterator over the elements of the vector in order.\n@@ -492,10 +265,13 @@ impl Bitv {\n \n     /// Returns `true` if all bits are 0\n     pub fn none(&self) -> bool {\n-      match self.rep {\n-        Small(ref b) => b.none(self.nbits),\n-        _ => self.iter().all(|x| !x)\n-      }\n+        for (i, &elem) in self.storage.iter().enumerate() {\n+            let mask = big_mask(self.nbits, i);\n+            if elem & mask != 0 {\n+                return false;\n+            }\n+        }\n+        true\n     }\n \n     #[inline]\n@@ -621,31 +397,25 @@ impl fmt::Show for Bitv {\n impl<S: hash::Writer> hash::Hash<S> for Bitv {\n     fn hash(&self, state: &mut S) {\n         self.nbits.hash(state);\n-        match self.rep {\n-            Small(ref s) => (s.bits & small_mask(self.nbits)).hash(state),\n-            Big(ref b) => {\n-                for (i, ele) in b.storage.iter().enumerate() {\n-                    (ele & big_mask(self.nbits, i)).hash(state);\n-                }\n-            }\n+        for (i, elem) in self.storage.iter().enumerate() {\n+            (elem & big_mask(self.nbits, i)).hash(state);\n         }\n     }\n }\n \n impl cmp::PartialEq for Bitv {\n     #[inline]\n     fn eq(&self, other: &Bitv) -> bool {\n-        if self.nbits != other.nbits { return false; }\n-        match self.rep {\n-            Small(ref b) => match other.rep {\n-                Small(ref b1) => b.equals(b1, self.nbits),\n-                _ => false\n-            },\n-            Big(ref s) => match other.rep {\n-                Big(ref s1) => s.equals(s1, self.nbits),\n-                Small(_) => return false\n+        if self.nbits != other.nbits {\n+            return false;\n+        }\n+        for (i, (&w1, &w2)) in self.storage.iter().zip(other.storage.iter()).enumerate() {\n+            let mask = big_mask(self.nbits, i);\n+            if w1 & mask != w2 & mask {\n+                return false;\n             }\n         }\n+        true\n     }\n }\n \n@@ -750,10 +520,7 @@ impl BitvSet {\n     /// element less than this amount will not trigger a resizing.\n     pub fn capacity(&self) -> uint {\n         let &BitvSet(ref bitv) = self;\n-        match bitv.rep {\n-            Small(_) => uint::BITS,\n-            Big(ref s) => s.storage.len() * uint::BITS\n-        }\n+        bitv.storage.len() * uint::BITS\n     }\n \n     /// Consumes this set to return the underlying bit vector\n@@ -766,19 +533,10 @@ impl BitvSet {\n     /// Grows the vector to be able to store bits with indices `[0, size - 1]`\n     fn grow(&mut self, size: uint) {\n         let &BitvSet(ref mut bitv) = self;\n-        let small_to_big = match bitv.rep { Small(s) if size >= uint::BITS => Some(s.bits), _ => None };\n-        if small_to_big.is_some() {\n-            bitv.rep = Big(BigBitv { storage: vec![small_to_big.unwrap()]  });\n+        let size = (size + uint::BITS - 1) / uint::BITS;\n+        if bitv.storage.len() < size {\n+            bitv.storage.grow(size, &0);\n         }\n-        match bitv.rep {\n-            Small(_) => {},\n-            Big(ref mut b) => {\n-                let size = (size + uint::BITS - 1) / uint::BITS;\n-                if b.storage.len() < size {\n-                    b.storage.grow(size, &0);\n-                }\n-            }\n-        };\n     }\n \n     #[inline]\n@@ -789,37 +547,24 @@ impl BitvSet {\n         let &BitvSet(ref mut self_bitv) = self;\n         let &BitvSet(ref other_bitv) = other;\n         for (i, w) in other_bitv.words(0) {\n-            match self_bitv.rep {\n-                Small(ref mut s) => { s.bits = f(s.bits, w); }\n-                Big(ref mut b) => {\n-                    let old = *b.storage.get(i);\n-                    let new = f(old, w);\n-                    *b.storage.get_mut(i) = new;\n-                    *b.storage.get_mut(i) = f(*b.storage.get(i), w);\n-                }\n-            }\n+            let old = *self_bitv.storage.get(i);\n+            let new = f(old, w);\n+            *self_bitv.storage.get_mut(i) = new;\n         }\n     }\n \n     #[inline]\n     /// Truncate the underlying vector to the least length required\n     pub fn shrink_to_fit(&mut self) {\n         let &BitvSet(ref mut bitv) = self;\n-        // Two steps: we borrow b as immutable to get the length...\n-        let old_len = match bitv.rep {\n-            Small(_) => 1,\n-            Big(ref b) => b.storage.len()\n-        };\n-        // ...and as mutable to change it.\n-        match bitv.rep {\n-            Small(_) => {},\n-            Big(ref mut b) => {\n-                let n = b.storage.iter().rev().take_while(|&&n| n == 0).count();\n-                let trunc_len = cmp::max(old_len - n, 1);\n-                b.storage.truncate(trunc_len);\n-                bitv.nbits = trunc_len * uint::BITS;\n-            }\n-        }\n+        // Obtain original length\n+        let old_len = bitv.storage.len();\n+        // Obtain coarse trailing zero length\n+        let n = bitv.storage.iter().rev().take_while(|&&n| n == 0).count();\n+        // Truncate\n+        let trunc_len = cmp::max(old_len - n, 1);\n+        bitv.storage.truncate(cmp::max(old_len - n, 1));\n+        bitv.nbits = trunc_len * uint::BITS;\n     }\n \n     /// Union in-place with the specified other bit vector\n@@ -909,10 +654,7 @@ impl Collection for BitvSet {\n     #[inline]\n     fn len(&self) -> uint  {\n         let &BitvSet(ref bitv) = self;\n-        match bitv.rep {\n-            Small(ref s) => s.bits.count_ones(),\n-            Big(ref b) => b.storage.iter().fold(0, |acc, &n| acc + n.count_ones())\n-        }\n+        bitv.storage.iter().fold(0, |acc, &n| acc + n.count_ones())\n     }\n }\n \n@@ -1056,8 +798,7 @@ mod tests {\n     use test::Bencher;\n \n     use {Set, Mutable, MutableSet};\n-    use bitv::{Bitv, SmallBitv, BigBitv, BitvSet, from_bools, from_fn,\n-               from_bytes};\n+    use bitv::{Bitv, BitvSet, from_bools, from_fn, from_bytes};\n     use bitv;\n     use vec::Vec;\n \n@@ -1733,38 +1474,6 @@ mod tests {\n         })\n     }\n \n-    #[bench]\n-    fn bench_small_bitv_small(b: &mut Bencher) {\n-        let mut r = rng();\n-        let mut bitv = SmallBitv::new(uint::BITS);\n-        b.iter(|| {\n-            bitv.set((r.next_u32() as uint) % uint::BITS, true);\n-            &bitv\n-        })\n-    }\n-\n-    #[bench]\n-    fn bench_big_bitv_small(b: &mut Bencher) {\n-        let mut r = rng();\n-        let mut bitv = BigBitv::new(vec!(0));\n-        b.iter(|| {\n-            bitv.set((r.next_u32() as uint) % uint::BITS, true);\n-            &bitv\n-        })\n-    }\n-\n-    #[bench]\n-    fn bench_big_bitv_big(b: &mut Bencher) {\n-        let mut r = rng();\n-        let mut storage = vec!();\n-        storage.grow(BENCH_BITS / uint::BITS, &0u);\n-        let mut bitv = BigBitv::new(storage);\n-        b.iter(|| {\n-            bitv.set((r.next_u32() as uint) % BENCH_BITS, true);\n-            &bitv\n-        })\n-    }\n-\n     #[bench]\n     fn bench_bitv_big(b: &mut Bencher) {\n         let mut r = rng();"}]}