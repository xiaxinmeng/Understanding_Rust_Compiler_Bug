{"sha": "ec3efa8055069e285a4bfcba892f8463ce925d68", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVjM2VmYTgwNTUwNjllMjg1YTRiZmNiYTg5MmY4NDYzY2U5MjVkNjg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-09T02:21:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-09T02:21:37Z"}, "message": "auto merge of #15422 : steveklabnik/rust/guide_compound_data_types, r=brson\n\nI'm not happy about the hand-waving around `cmp`, but I'm not sure how to get around it.", "tree": {"sha": "4bf49c6d2784d538d53700925ac9ed73b3236924", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4bf49c6d2784d538d53700925ac9ed73b3236924"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ec3efa8055069e285a4bfcba892f8463ce925d68", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ec3efa8055069e285a4bfcba892f8463ce925d68", "html_url": "https://github.com/rust-lang/rust/commit/ec3efa8055069e285a4bfcba892f8463ce925d68", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ec3efa8055069e285a4bfcba892f8463ce925d68/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1c711db551b9a5e56ba76e002e287dcfbb2cff3c", "url": "https://api.github.com/repos/rust-lang/rust/commits/1c711db551b9a5e56ba76e002e287dcfbb2cff3c", "html_url": "https://github.com/rust-lang/rust/commit/1c711db551b9a5e56ba76e002e287dcfbb2cff3c"}, {"sha": "11c64f162ff5b3f8bf2fd978ab268395b285b067", "url": "https://api.github.com/repos/rust-lang/rust/commits/11c64f162ff5b3f8bf2fd978ab268395b285b067", "html_url": "https://github.com/rust-lang/rust/commit/11c64f162ff5b3f8bf2fd978ab268395b285b067"}], "stats": {"total": 276, "additions": 273, "deletions": 3}, "files": [{"sha": "7136a7bafb0e5bcfa0dab7c11897cf4024c7dd07", "filename": "src/doc/guide.md", "status": "modified", "additions": 273, "deletions": 3, "changes": 276, "blob_url": "https://github.com/rust-lang/rust/blob/ec3efa8055069e285a4bfcba892f8463ce925d68/src%2Fdoc%2Fguide.md", "raw_url": "https://github.com/rust-lang/rust/raw/ec3efa8055069e285a4bfcba892f8463ce925d68/src%2Fdoc%2Fguide.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide.md?ref=ec3efa8055069e285a4bfcba892f8463ce925d68", "patch": "@@ -991,11 +991,281 @@ generally, you want to export documentation for a full module.\n \n ## Compound Data Types\n \n-Tuples\n+Rust, like many programming languages, has a number of different data types\n+that are built-in. You've already done some simple work with integers and\n+strings, but next, let's talk about some more complicated ways of storing data.\n \n-Structs\n+### Tuples\n \n-Enums\n+The first compound data type we're going to talk about are called **tuple**s.\n+Tuples are an ordered list of a fixed size. Like this:\n+\n+```rust\n+let x = (1i, \"hello\");\n+```\n+\n+The parenthesis and commas form this two-length tuple. Here's the same code, but\n+with the type annotated:\n+\n+```rust\n+let x: (int, &str) = (1, \"hello\");\n+```\n+\n+As you can see, the type of a tuple looks just like the tuple, but with each\n+position having a type name rather than the value. Careful readers will also\n+note that tuples are heterogeneous: we have an `int` and a `&str` in this tuple.\n+You haven't seen `&str` as a type before, and we'll discuss the details of\n+strings later. In systems programming languages, strings are a bit more complex\n+than in other languages. For now, just read `&str` as \"a string slice,\" and\n+we'll learn more soon.\n+\n+You can access the fields in a tuple through a **destructuring let**. Here's\n+an example:\n+\n+```rust\n+let (x, y, z) = (1i, 2i, 3i);\n+\n+println!(\"x is {}\", x);\n+```\n+\n+Remember before when I said the left hand side of a `let` statement was more\n+powerful than just assigning a binding? Here we are. We can put a pattern on\n+the left hand side of the `let`, and if it matches up to the right hand side,\n+we can assign multiple bindings at once. In this case, `let` 'destructures,'\n+or 'breaks up,' the tuple, and assigns the bits to three bindings.\n+\n+This pattern is very powerful, and we'll see it repeated more later.\n+\n+The last thing to say about tuples is that they are only equivalent if\n+the arity, types, and values are all identical.\n+\n+```rust\n+let x = (1i, 2i, 3i);\n+let y = (2i, 3i, 4i);\n+\n+if x == y {\n+    println!(\"yes\");\n+} else {\n+    println!(\"no\");\n+}\n+```\n+\n+This will print `no`, as the values aren't equal.\n+\n+One other use of tuples is to return multiple values from a function:\n+\n+```rust\n+fn next_two(x: int) -> (int, int) { (x + 1i, x + 2i) }\n+\n+fn main() {\n+    let (x, y) = next_two(5i);\n+    println!(\"x, y = {}, {}\", x, y);\n+}\n+```\n+\n+Even though Rust functions can only return one value, a tuple _is_ one value,\n+that happens to be made up of two. You can also see in this example how you\n+can destructure a pattern returned by a function, as well.\n+\n+Tuples are a very simple data structure, and so are not often what you want.\n+Let's move on to their bigger sibling, structs.\n+\n+### Structs\n+\n+A struct is another form of a 'record type,' just like a tuple. There's a\n+difference: structs give each element that they contain a name, called a\n+'field' or a 'member.' Check it out:\n+\n+```rust\n+struct Point {\n+    x: int,\n+    y: int,\n+}\n+\n+fn main() {\n+    let origin = Point { x: 0i, y:  0i };\n+\n+    println!(\"The origin is at ({}, {})\", origin.x, origin.y);\n+}\n+```\n+\n+There's a lot going on here, so let's break it down. We declare a struct with\n+the `struct` keyword, and then with a name. By convention, structs begin with a\n+capital letter and are also camel cased: `PointInSpace`, not `Point_In_Space`.\n+\n+We can create an instance of our struct via `let`, as usual, but we use a `key:\n+value` style syntax to set each field. The order doesn't need to be the same as\n+in the original declaration.\n+\n+Finally, because fields have names, we can access the field through dot\n+notation: `origin.x`.\n+\n+The values in structs are immutable, like other bindings in Rust. However, you\n+can use `mut` to make them mutable:\n+\n+```rust\n+struct Point {\n+    x: int,\n+    y: int,\n+}\n+\n+fn main() {\n+    let mut point = Point { x: 0i, y:  0i };\n+\n+    point.x = 5;\n+\n+    println!(\"The point is at ({}, {})\", point.x, point.y);\n+}\n+```\n+\n+This will print `The point is at (5, 0)`.\n+\n+### Tuple Structs and Newtypes\n+\n+Rust has another data type that's like a hybrid between a tuple and a struct,\n+called a **tuple struct**. Tuple structs do have a name, but their fields\n+don't:\n+\n+\n+```\n+struct Color(int, int, int);\n+struct Point(int, int, int);\n+```\n+\n+These two will not be equal, even if they have the same values:\n+\n+```{rust,ignore}\n+let black  = Color(0, 0, 0);\n+let origin = Point(0, 0, 0);\n+```\n+\n+It is almost always better to use a struct than a tuple struct. We would write\n+`Color` and `Point` like this instead:\n+\n+```rust\n+struct Color {\n+    red: int,\n+    blue: int,\n+    green: int,\n+}\n+\n+struct Point {\n+    x: int,\n+    y: int,\n+    z: int,\n+}\n+```\n+\n+Now, we have actual names, rather than positions. Good names are important,\n+and with a struct, we have actual names.\n+\n+There _is_ one case when a tuple struct is very useful, though, and that's a\n+tuple struct with only one element. We call this a 'newtype,' because it lets\n+you create a new type that's a synonym for another one:\n+\n+```\n+struct Inches(int);\n+struct Centimeters(int);\n+\n+let length = Inches(10);\n+\n+let Inches(integer_length) = length;\n+println!(\"length is {} inches\", integer_length);\n+```\n+\n+As you can see here, you can extract the inner integer type through a\n+destructuring `let`.\n+\n+### Enums\n+\n+Finally, Rust has a \"sum type\", an **enum**. Enums are an incredibly useful\n+feature of Rust, and are used throughout the standard library. Enums look\n+like this:\n+\n+```\n+enum Ordering {\n+    Less,\n+    Equal,\n+    Greater,\n+}\n+```\n+\n+This is an enum that is provided by the Rust standard library. An `Ordering`\n+can only be _one_ of `Less`, `Equal`, or `Greater` at any given time. Here's\n+an example:\n+\n+```rust\n+let x = 5i;\n+let y = 10i;\n+\n+let ordering = x.cmp(&y);\n+\n+if ordering == Less {\n+    println!(\"less\");\n+} else if ordering == Greater {\n+    println!(\"greater\");\n+} else if ordering == Equal {\n+    println!(\"equal\");\n+}\n+```\n+\n+`cmp` is a function that compares two things, and returns an `Ordering`. The\n+call looks a little bit strange: rather than `cmp(x, y)`, we say `x.cmp(&y)`.\n+We haven't covered methods and references yet, so it should look a little bit\n+foreign. Right now, just pretend it says `cmp(x, y)`, and we'll get to those\n+details soon.\n+\n+The `ordering` variable has the type `Ordering`, and so contains one of the\n+three values. We can then do a bunch of `if`/`else` comparisons to check\n+which one it is.\n+\n+However, repeated `if`/`else` comparisons get quite tedious. Rust has a feature\n+that not only makes them nicer to read, but also makes sure that you never\n+miss a case. Before we get to that, though, let's talk about another kind of\n+enum: one with values.\n+\n+This enum has two variants, one of which has a value.:\n+\n+```\n+enum OptionalInt {\n+    Value(int),\n+    Missing\n+}\n+\n+fn main() {\n+    let x = Value(5);\n+    let y = Missing;\n+\n+    match x {\n+        Value(n) => println!(\"x is {:d}\", n),\n+        Missing  => println!(\"x is missing!\"),\n+    }\n+\n+    match y {\n+        Value(n) => println!(\"y is {:d}\", n),\n+        Missing  => println!(\"y is missing!\"),\n+    }\n+}\n+```\n+\n+This enum represents an `int` that we may or may not have. In the `Missing`\n+case, we have no value, but in the `Value` case, we do. This enum is specific\n+to `int`s, though. We can make it usable by any type, but we haven't quite\n+gotten there yet!\n+\n+You can have any number of values in an enum:\n+\n+```\n+enum OptionalColor {\n+    Color(int, int, int),\n+    Missing\n+}\n+```\n+\n+Enums with values are quite useful, but as I mentioned, they're even more\n+useful when they're generic across types. But before we get to generics, let's\n+talk about how to fix this big `if`/`else` statements we've been writing. We'll\n+do that with `match`.\n \n ## Match\n "}]}