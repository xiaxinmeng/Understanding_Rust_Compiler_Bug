{"sha": "430ad769008c0aaa40949a1d98a6f0e18e35ec65", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQzMGFkNzY5MDA4YzBhYWE0MDk0OWExZDk4YTZmMGUxOGUzNWVjNjU=", "commit": {"author": {"name": "Jorge Aparicio", "email": "jorge@japaric.io", "date": "2018-05-16T12:07:58Z"}, "committer": {"name": "Jorge Aparicio", "email": "jorge@japaric.io", "date": "2018-06-03T11:46:19Z"}, "message": "undo payload in core::panic! changes", "tree": {"sha": "deae3f6dbdfd4fd0313086c27beac54df75ce38b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/deae3f6dbdfd4fd0313086c27beac54df75ce38b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/430ad769008c0aaa40949a1d98a6f0e18e35ec65", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/430ad769008c0aaa40949a1d98a6f0e18e35ec65", "html_url": "https://github.com/rust-lang/rust/commit/430ad769008c0aaa40949a1d98a6f0e18e35ec65", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/430ad769008c0aaa40949a1d98a6f0e18e35ec65/comments", "author": {"login": "japaric", "id": 5018213, "node_id": "MDQ6VXNlcjUwMTgyMTM=", "avatar_url": "https://avatars.githubusercontent.com/u/5018213?v=4", "gravatar_id": "", "url": "https://api.github.com/users/japaric", "html_url": "https://github.com/japaric", "followers_url": "https://api.github.com/users/japaric/followers", "following_url": "https://api.github.com/users/japaric/following{/other_user}", "gists_url": "https://api.github.com/users/japaric/gists{/gist_id}", "starred_url": "https://api.github.com/users/japaric/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/japaric/subscriptions", "organizations_url": "https://api.github.com/users/japaric/orgs", "repos_url": "https://api.github.com/users/japaric/repos", "events_url": "https://api.github.com/users/japaric/events{/privacy}", "received_events_url": "https://api.github.com/users/japaric/received_events", "type": "User", "site_admin": false}, "committer": {"login": "japaric", "id": 5018213, "node_id": "MDQ6VXNlcjUwMTgyMTM=", "avatar_url": "https://avatars.githubusercontent.com/u/5018213?v=4", "gravatar_id": "", "url": "https://api.github.com/users/japaric", "html_url": "https://github.com/japaric", "followers_url": "https://api.github.com/users/japaric/followers", "following_url": "https://api.github.com/users/japaric/following{/other_user}", "gists_url": "https://api.github.com/users/japaric/gists{/gist_id}", "starred_url": "https://api.github.com/users/japaric/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/japaric/subscriptions", "organizations_url": "https://api.github.com/users/japaric/orgs", "repos_url": "https://api.github.com/users/japaric/repos", "events_url": "https://api.github.com/users/japaric/events{/privacy}", "received_events_url": "https://api.github.com/users/japaric/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eb1936141611afa8ad9034c4093e1539df36548c", "url": "https://api.github.com/repos/rust-lang/rust/commits/eb1936141611afa8ad9034c4093e1539df36548c", "html_url": "https://github.com/rust-lang/rust/commit/eb1936141611afa8ad9034c4093e1539df36548c"}], "stats": {"total": 163, "additions": 37, "deletions": 126}, "files": [{"sha": "c830c22ee5f50b1c58a46732cbe56036882756c2", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/430ad769008c0aaa40949a1d98a6f0e18e35ec65/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/430ad769008c0aaa40949a1d98a6f0e18e35ec65/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=430ad769008c0aaa40949a1d98a6f0e18e35ec65", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n /// Entry point of thread panic, for details, see std::macros\n-#[cfg(stage0)]\n #[macro_export]\n #[allow_internal_unstable]\n #[stable(feature = \"core\", since = \"1.6.0\")]\n@@ -29,27 +28,6 @@ macro_rules! panic {\n     });\n }\n \n-/// Entry point of thread panic, for details, see std::macros\n-#[cfg(not(stage0))]\n-#[macro_export]\n-#[allow_internal_unstable]\n-#[stable(feature = \"core\", since = \"1.6.0\")]\n-macro_rules! panic {\n-    () => (\n-        panic!(\"explicit panic\")\n-    );\n-    ($msg:expr) => ({\n-        $crate::panicking::panic_payload($msg, &(file!(), line!(), __rust_unstable_column!()))\n-    });\n-    ($msg:expr,) => (\n-        panic!($msg)\n-    );\n-    ($fmt:expr, $($arg:tt)+) => ({\n-        $crate::panicking::panic_fmt(format_args!($fmt, $($arg)*),\n-                                     &(file!(), line!(), __rust_unstable_column!()))\n-    });\n-}\n-\n /// Asserts that two expressions are equal to each other (using [`PartialEq`]).\n ///\n /// On panic, this macro will print the values of the expressions with their"}, {"sha": "0d4f8d1141e739490225c4a688bdc68198a540ea", "filename": "src/libcore/panicking.rs", "status": "modified", "additions": 7, "deletions": 25, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/430ad769008c0aaa40949a1d98a6f0e18e35ec65/src%2Flibcore%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/430ad769008c0aaa40949a1d98a6f0e18e35ec65/src%2Flibcore%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpanicking.rs?ref=430ad769008c0aaa40949a1d98a6f0e18e35ec65", "patch": "@@ -36,35 +36,10 @@\n                       and related macros\",\n             issue = \"0\")]\n \n-#[cfg(not(stage0))]\n-use any::Any;\n use fmt;\n #[cfg(not(stage0))]\n use panic::{Location, PanicInfo};\n \n-// NOTE This function never crosses the FFI boundary; it's a Rust-to-Rust call\n-#[cfg(not(stage0))]\n-#[allow(improper_ctypes)] // PanicInfo contains a trait object which is not FFI safe\n-extern \"Rust\" {\n-    #[lang = \"panic_impl\"]\n-    fn panic_impl(pi: &PanicInfo) -> !;\n-}\n-\n-#[cfg(not(stage0))]\n-#[cold] #[inline(never)]\n-pub fn panic_payload<M>(msg: M, file_line_col: &(&'static str, u32, u32)) -> !\n-where\n-    M: Any + Send,\n-{\n-    let (file, line, col) = *file_line_col;\n-    let mut pi = PanicInfo::internal_constructor(\n-        None,\n-        Location::internal_constructor(file, line, col),\n-    );\n-    pi.set_payload(&msg);\n-    unsafe { panic_impl(&pi) }\n-}\n-\n #[cold] #[inline(never)] // this is the slow path, always\n #[lang = \"panic\"]\n pub fn panic(expr_file_line_col: &(&'static str, &'static str, u32, u32)) -> ! {\n@@ -102,6 +77,13 @@ pub fn panic_fmt(fmt: fmt::Arguments, file_line_col: &(&'static str, u32, u32))\n #[cfg(not(stage0))]\n #[cold] #[inline(never)]\n pub fn panic_fmt(fmt: fmt::Arguments, file_line_col: &(&'static str, u32, u32)) -> ! {\n+    // NOTE This function never crosses the FFI boundary; it's a Rust-to-Rust call\n+    #[allow(improper_ctypes)] // PanicInfo contains a trait object which is not FFI safe\n+    extern \"Rust\" {\n+        #[lang = \"panic_impl\"]\n+        fn panic_impl(pi: &PanicInfo) -> !;\n+    }\n+\n     let (file, line, col) = *file_line_col;\n     let pi = PanicInfo::internal_constructor(\n         Some(&fmt),"}, {"sha": "9d8052143b98e6acacb7df7b204b87fdefeecb36", "filename": "src/libstd/panicking.rs", "status": "modified", "additions": 30, "deletions": 79, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/430ad769008c0aaa40949a1d98a6f0e18e35ec65/src%2Flibstd%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/430ad769008c0aaa40949a1d98a6f0e18e35ec65/src%2Flibstd%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanicking.rs?ref=430ad769008c0aaa40949a1d98a6f0e18e35ec65", "patch": "@@ -186,7 +186,7 @@ fn default_hook(info: &PanicInfo) {\n \n     let location = info.location().unwrap();  // The current implementation always returns Some\n \n-    let msg = match info.payload().downcast_ref::<&str>() {\n+    let msg = match info.payload().downcast_ref::<&'static str>() {\n         Some(s) => *s,\n         None => match info.payload().downcast_ref::<String>() {\n             Some(s) => &s[..],\n@@ -351,44 +351,45 @@ pub fn rust_begin_panic(info: &PanicInfo) -> ! {\n #[inline(never)] #[cold]\n pub fn begin_panic_fmt(msg: &fmt::Arguments,\n                        file_line_col: &(&'static str, u32, u32)) -> ! {\n-    use fmt::Write;\n-\n     // We do two allocations here, unfortunately. But (a) they're\n     // required with the current scheme, and (b) we don't handle\n     // panic + OOM properly anyway (see comment in begin_panic\n     // below).\n \n     rust_panic_with_hook(&mut PanicPayload::new(msg), Some(msg), file_line_col);\n+}\n+\n+// NOTE(stage0) move into `continue_panic_fmt` on next stage0 update\n+struct PanicPayload<'a> {\n+    inner: &'a fmt::Arguments<'a>,\n+    string: Option<String>,\n+}\n \n-    struct PanicPayload<'a> {\n-        inner: &'a fmt::Arguments<'a>,\n-        string: Option<String>,\n+impl<'a> PanicPayload<'a> {\n+    fn new(inner: &'a fmt::Arguments<'a>) -> PanicPayload<'a> {\n+        PanicPayload { inner, string: None }\n     }\n \n-    impl<'a> PanicPayload<'a> {\n-        fn new(inner: &'a fmt::Arguments<'a>) -> PanicPayload<'a> {\n-            PanicPayload { inner, string: None }\n-        }\n+    fn fill(&mut self) -> &mut String {\n+        use fmt::Write;\n \n-        fn fill(&mut self) -> &mut String {\n-            let inner = self.inner;\n-            self.string.get_or_insert_with(|| {\n-                let mut s = String::new();\n-                drop(s.write_fmt(*inner));\n-                s\n-            })\n-        }\n+        let inner = self.inner;\n+        self.string.get_or_insert_with(|| {\n+            let mut s = String::new();\n+            drop(s.write_fmt(*inner));\n+            s\n+        })\n     }\n+}\n \n-    unsafe impl<'a> BoxMeUp for PanicPayload<'a> {\n-        fn box_me_up(&mut self) -> *mut (Any + Send) {\n-            let contents = mem::replace(self.fill(), String::new());\n-            Box::into_raw(Box::new(contents))\n-        }\n+unsafe impl<'a> BoxMeUp for PanicPayload<'a> {\n+    fn box_me_up(&mut self) -> *mut (Any + Send) {\n+        let contents = mem::replace(self.fill(), String::new());\n+        Box::into_raw(Box::new(contents))\n+    }\n \n-        fn get(&mut self) -> &(Any + Send) {\n-            self.fill()\n-        }\n+    fn get(&mut self) -> &(Any + Send) {\n+        self.fill()\n     }\n }\n \n@@ -415,76 +416,26 @@ pub fn begin_panic_fmt(msg: &fmt::Arguments,\n \n #[cfg(not(stage0))]\n fn continue_panic_fmt(info: &PanicInfo) -> ! {\n-    use fmt::Write;\n-\n     // We do two allocations here, unfortunately. But (a) they're\n     // required with the current scheme, and (b) we don't handle\n     // panic + OOM properly anyway (see comment in begin_panic\n     // below).\n \n     let loc = info.location().unwrap(); // The current implementation always returns Some\n+    let msg = info.message().unwrap(); // The current implementation always returns Some\n     let file_line_col = (loc.file(), loc.line(), loc.column());\n     rust_panic_with_hook(\n-        &mut PanicPayload::new(info.payload(), info.message()),\n+        &mut PanicPayload::new(msg),\n         info.message(),\n         &file_line_col);\n-\n-    struct PanicPayload<'a> {\n-        payload: &'a (Any + Send),\n-        msg: Option<&'a fmt::Arguments<'a>>,\n-        string: Option<String>,\n-    }\n-\n-    impl<'a> PanicPayload<'a> {\n-        fn new(payload: &'a (Any + Send), msg: Option<&'a fmt::Arguments<'a>>) -> PanicPayload<'a> {\n-            PanicPayload { payload, msg, string: None }\n-        }\n-\n-        fn fill(&mut self) -> Option<&mut String> {\n-            if let Some(msg) = self.msg.cloned() {\n-                Some(self.string.get_or_insert_with(|| {\n-                    let mut s = String::new();\n-                    drop(s.write_fmt(msg));\n-                    s\n-                }))\n-            } else {\n-                None\n-            }\n-        }\n-    }\n-\n-    unsafe impl<'a> BoxMeUp for PanicPayload<'a> {\n-        fn box_me_up(&mut self) -> *mut (Any + Send) {\n-            if let Some(string) = self.fill() {\n-                let contents = mem::replace(string, String::new());\n-                Box::into_raw(Box::new(contents))\n-            } else if let Some(s) = self.payload.downcast_ref::<&str>() {\n-                Box::into_raw(Box::new(s.to_owned()))\n-            } else if let Some(s) = self.payload.downcast_ref::<String>() {\n-                Box::into_raw(Box::new(s.clone()))\n-            } else {\n-                // We can't go from &(Any+Send) to Box<Any+Send> so the payload is lost here\n-                struct NoPayload;\n-                Box::into_raw(Box::new(NoPayload))\n-            }\n-        }\n-\n-        fn get(&mut self) -> &(Any + Send) {\n-            if let Some(s) = self.fill() {\n-                s\n-            } else {\n-                self.payload\n-            }\n-        }\n-    }\n }\n \n /// This is the entry point of panicking for panic!() and assert!().\n #[unstable(feature = \"libstd_sys_internals\",\n            reason = \"used by the panic! macro\",\n            issue = \"0\")]\n #[inline(never)] #[cold] // avoid code bloat at the call sites as much as possible\n-pub fn begin_panic<M: Any + Send>(msg: M, file_line_col: &(&str, u32, u32)) -> ! {\n+pub fn begin_panic<M: Any + Send>(msg: M, file_line_col: &(&'static str, u32, u32)) -> ! {\n     // Note that this should be the only allocation performed in this code path.\n     // Currently this means that panic!() on OOM will invoke this code path,\n     // but then again we're not really ready for panic on OOM anyway. If"}]}